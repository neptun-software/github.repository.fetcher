{
  "metadata": {
    "timestamp": 1736711817846,
    "page": 111,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mevdschee/php-crud-api",
      "stars": 3635,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.296875,
          "content": "/docker/ export-ignore\n/examples/ export-ignore\n/extras/ export-ignore\n/src/index.php export-ignore\n/tests/ export-ignore\n/.gitattributes export-ignore\n/.gitignore export-ignore\n/.htaccess export-ignore\n/*.php export-ignore\n/*.sh export-ignore\n/docker-compose.yml export-ignore\n/Dockerfile export-ignore\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0283203125,
          "content": "composer.phar\nvendor/\ndata.db"
        },
        {
          "name": ".htaccess",
          "type": "blob",
          "size": 0.1357421875,
          "content": "<IfModule mod_rewrite.c>\n    RewriteEngine on\n    RewriteCond %{REQUEST_FILENAME} !-f\n    RewriteRule ^(.*)$ api.php/$1 [QSA,L]\n</IfModule>"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.0185546875,
          "content": "# Contributing to php-crud-api\n\nPull requests are welcome.\n\n## Use phpfmt\n\nPlease use \"phpfmt\" to ensure consistent formatting.\n\n## Run the tests\n\nBefore you do a PR, you should ensure any new functionality has test cases and that all existing tests are succeeding.\n\n## Run the build \n\nSince this project is a single file application, you must ensure that classes are loaded in the correct order. \nThis is only important for the \"extends\" and \"implements\" relations. The 'build.php' script appends the classes in \nalphabetical order (directories first). The path of the class that is extended or implemented (parent) must be above\nthe extending or implementing (child) class when listing the contents of the 'src' directory in this order. If you\nget this order wrong you will see the build will fail with a \"Class not found\" error message. The solution is to\nrename the child class so that it starts with a later letter in the alphabet than the parent class or that you move\nthe parent class to a subdirectory (directories are scanned first).\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.36328125,
          "content": "FROM php:apache\n\nRUN apt-get update; \\\n    apt-get install -y libpq5 libpq-dev; \\\n    docker-php-ext-install pdo pdo_pgsql pdo_mysql; \\\n    apt-get autoremove --purge -y libpq-dev; \\\n    apt-get clean ; \\\n    rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* /usr/share/doc/*    \n\nRUN a2enmod rewrite\n\nCOPY api.php /var/www/html/api.php\nCOPY .htaccess /var/www/html/.htaccess\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "MIT License\n\nCopyright (c) 2022 Maurits van der Schee\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 77.228515625,
          "content": "# PHP-CRUD-API\n\nSingle file PHP script that adds a REST API to a MySQL/MariaDB, PostgreSQL, SQL Server or SQLite database. \n\nHowto: Upload \"`api.php`\" to your webserver, configure it to connect to your database, have an instant full-featured REST API.\n\nNB: This is the [TreeQL](https://treeql.org) reference implementation in PHP.\n\n## Requirements\n\n  - PHP 7.2 or higher with PDO drivers enabled for one of these database systems:\n    - MySQL 5.7 / MariaDB 10.0 or higher for spatial features in MySQL\n    - PostgreSQL 9.5 or higher with PostGIS 2.2 or higher for spatial features\n    - SQL Server 2017 or higher (2019 also has Linux support)\n    - SQLite 3.16 or higher (spatial features NOT supported)\n\n## Installation\n\nDownload the \"`api.php`\" file from the latest release:\n\nhttps://github.com/mevdschee/php-crud-api/releases/latest or direct from:  \nhttps://raw.githubusercontent.com/mevdschee/php-crud-api/main/api.php\n\nThis is a single file application! Upload \"`api.php`\" somewhere and enjoy!\n\nFor local development you may run PHP's built-in web server:\n\n    php -S localhost:8080\n\nTest the script by opening the following URL:\n\n    http://localhost:8080/api.php/records/posts/1\n\nDon't forget to modify the configuration at the bottom of the file.\n\nAlternatively you can integrate this project into the web framework of your choice, see:\n\n- [Automatic REST API for Laravel](https://tqdev.com/2019-automatic-rest-api-laravel)\n- [Automatic REST API for Symfony 4](https://tqdev.com/2019-automatic-rest-api-symfony)\n- [Automatic REST API for SlimPHP 4](https://tqdev.com/2019-automatic-api-slimphp-4)\n\nIn these integrations [Composer](https://getcomposer.org/) is used to load this project as a dependency.\n\nFor people that don't use composer, the file \"`api.include.php`\" is provided. This file contains everything \nfrom \"`api.php`\" except the configuration from \"`src/index.php`\" and can be used by PHP's \"include\" function.\n\n## Configuration\n\nEdit the following lines in the bottom of the file \"`api.php`\":\n\n    $config = new Config([\n        'username' => 'xxx',\n        'password' => 'xxx',\n        'database' => 'xxx',\n    ]);\n\nThese are all the configuration options and their default value between brackets:\n\n- \"driver\": `mysql`, `pgsql`, `sqlsrv` or `sqlite` (`mysql`)\n- \"address\": Hostname (or filename) of the database server (`localhost`)\n- \"port\": TCP port of the database server (defaults to driver default)\n- \"username\": Username of the user connecting to the database (no default)\n- \"password\": Password of the user connecting to the database (no default)\n- \"database\": Database the connecting is made to (no default)\n- \"command\": Extra SQL to initialize the database connection (none)\n- \"tables\": Comma separated list of tables to publish (defaults to 'all')\n- \"mapping\": Comma separated list of table/column mappings (no mappping)\n- \"geometrySrid\": SRID assumed when converting from WKT to geometry (`4326`)\n- \"middlewares\": List of middlewares to load (`cors`)\n- \"controllers\": List of controllers to load (`records,geojson,openapi,status`)\n- \"customControllers\": List of user custom controllers to load (no default)\n- \"openApiBase\": OpenAPI info (`{\"info\":{\"title\":\"PHP-CRUD-API\",\"version\":\"1.0.0\"}}`)\n- \"cacheType\": `TempFile`, `Redis`, `Memcache`, `Memcached` or `NoCache` (`TempFile`)\n- \"cachePath\": Path/address of the cache (defaults to system's temp directory)\n- \"cacheTime\": Number of seconds the cache is valid (`10`)\n- \"jsonOptions\": Options used for encoding JSON (`JSON_UNESCAPED_UNICODE`)\n- \"debug\": Show errors in the \"X-Exception\" headers (`false`)\n- \"basePath\": URI base path of the API (determined using PATH_INFO by default)\n\nAll configuration options are also available as environment variables. Write the config option with capitals, a \"PHP_CRUD_API_\" prefix and underscores for word breakes, so for instance:\n\n- PHP_CRUD_API_DRIVER=mysql\n- PHP_CRUD_API_ADDRESS=localhost\n- PHP_CRUD_API_PORT=3306\n- PHP_CRUD_API_DATABASE=php-crud-api\n- PHP_CRUD_API_USERNAME=php-crud-api\n- PHP_CRUD_API_PASSWORD=php-crud-api\n- PHP_CRUD_API_DEBUG=1\n\nThe environment variables take precedence over the PHP configuration.\n\n## Limitations\n\nThese limitation and constrains apply:\n\n  - Primary keys should either be auto-increment (from 1 to 2^53) or UUID\n  - Composite primary and composite foreign keys are not supported\n  - Complex writes (transactions) are not supported\n  - Complex queries calling functions (like \"concat\" or \"sum\") are not supported\n  - Database must support and define foreign key constraints\n  - SQLite cannot have bigint typed auto incrementing primary keys\n  - SQLite does not support altering table columns (structure)\n    \n## Features\n\nThe following features are supported:\n\n  - Composer install or single PHP file, easy to deploy.\n  - Very little code, easy to adapt and maintain\n  - Supports POST variables as input (x-www-form-urlencoded)\n  - Supports a JSON object as input\n  - Supports a JSON array as input (batch insert)\n  - Sanitize and validate input using type rules and callbacks\n  - Permission system for databases, tables, columns and records\n  - Multi-tenant single and multi database layouts are supported\n  - Multi-domain CORS support for cross-domain requests\n  - Support for reading joined results from multiple tables\n  - Search support on multiple criteria\n  - Pagination, sorting, top N list and column selection\n  - Relation detection with nested results (belongsTo, hasMany and HABTM)\n  - Atomic increment support via PATCH (for counters)\n  - Binary fields supported with base64 encoding\n  - Spatial/GIS fields and filters supported with WKT and GeoJSON\n  - Mapping table and column names to support legacy systems\n  - Generate API documentation using OpenAPI tools\n  - Authentication via API key, JWT token or username/password\n  - Database connection parameters may depend on authentication\n  - Support for reading database structure in JSON\n  - Support for modifying database structure using REST endpoint\n  - Security enhancing middleware is included\n  - Standard compliant: PSR-4, PSR-7, PSR-12, PSR-15 and PSR-17\n\n## Related projects and ports\n\nRelated projects:\n\n  - [PHP-CRUD-API Quick Start](https://github.com/nik2208/php-crud-api-quick-start): A customizable, ready to go, docker compose file featuring PHP-CRUD-API.\n  - [PHP-CRUD-API filter generator](https://thipages.github.io/jca-filter/#): A JavaScript library creating PHP-CRUD-API filters from expressions.\n  - [JS-CRUD-API](https://github.com/thipages/js-crud-api): A JavaScript client library for the API of PHP-CRUD-API\n  - [PHP-API-AUTH](https://github.com/mevdschee/php-api-auth): Single file PHP script that is an authentication provider for PHP-CRUD-API\n  - [PHP-CRUD-UI](https://github.com/mevdschee/php-crud-ui): Single file PHP script that adds a UI to a PHP-CRUD-API project.\n  - [PHP-CRUD-ADMIN](https://github.com/mevdschee/php-crud-admin): Single file PHP script that adds a database admin interface to a PHP-CRUD-API project.\n  - [PHP-SP-API](https://github.com/mevdschee/php-sp-api): Single file PHP script that adds a REST API to a SQL database.\n  - [dexie-mysql-sync](https://github.com/scriptPilot/dexie-mysql-sync): Synchronization between local IndexedDB and MySQL Database. \n  - [ra-data-treeql](https://github.com/nkappler/ra-data-treeql): NPM package that provides a [Data Provider](https://marmelab.com/react-admin/DataProviderIntroduction.html) for [React Admin](https://marmelab.com/react-admin/).\n  - [scriptPilot/vueuse](https://github.com/scriptPilot/vueuse/): Vue [Composables](https://vuejs.org/guide/reusability/composables.html) in addition to [VueUse.org](https://vueuse.org/) (that support PHP-CRUD-API).\n  - [scriptPilot/add-php-backend](https://github.com/scriptPilot/add-php-backend): Add MySQL, phpMyAdmin and PHP-CRUD-API to your dev environment. \n  - [VUE-CRUD-UI](https://github.com/nlware/vue-crud-ui): Single file Vue.js script that adds a UI to a PHP-CRUD-API project.\n  \nThere are also ports of this script in:\n\n- [Go-CRUD-API](https://github.com/dranih/go-crud-api) (work in progress)\n- [Java JDBC by Ivan Kolchagov](https://github.com/kolchagov/java-crud-api) (v1)\n- [Java Spring Boot + jOOQ](https://github.com/mevdschee/java-crud-api/tree/master/full) (v2: work in progress)\n\nThere are also proof-of-concept ports of this script that only support basic REST CRUD functionality in:\n[PHP](https://github.com/mevdschee/php-crud-api/blob/master/extras/core.php),\n[Java](https://github.com/mevdschee/java-crud-api/blob/master/core/src/main/java/com/tqdev/CrudApiHandler.java),\n[Go](https://github.com/mevdschee/go-crud-api/blob/master/api.go),\n[C# .net core](https://github.com/mevdschee/core-data-api/blob/master/Program.cs),\n[Node.js](https://github.com/mevdschee/js-crud-api/blob/master/app.js) and\n[Python](https://github.com/mevdschee/py-crud-api/blob/master/api.py).\n\n## Compilation\n\nYou can install all dependencies of this project using the following command:\n\n    php install.php\n\nYou can compile all files into a single \"`api.php`\" file using:\n\n    php build.php\n\nNote that you don't use compilation when you integrate this project into another project or framework (use Composer instead).\n\n### Development\n\nYou can access the non-compiled code at the URL:\n\n    http://localhost:8080/src/records/posts/1\n\nThe non-compiled code resides in the \"`src`\" and \"`vendor`\" directories. The \"`vendor`\" directory contains the dependencies.\n\n### Updating dependencies\n\nYou can update all dependencies of this project using the following command:\n\n    php update.php\n\nThis script will install and run [Composer](https://getcomposer.org/) to update the dependencies.\n\nNB: The update script will patch the dependencies in the vendor directory for PHP 7.0 compatibility.\n\n## TreeQL, a pragmatic GraphQL\n\n[TreeQL](https://treeql.org) allows you to create a \"tree\" of JSON objects based on your SQL database structure (relations) and your query.\n\nIt is loosely based on the REST standard and also inspired by json:api.\n\n### CRUD + List\n\nThe example posts table has only a a few fields:\n\n    posts  \n    =======\n    id     \n    title  \n    content\n    created\n\nThe CRUD + List operations below act on this table.\n\n#### Create\n\nIf you want to create a record the request can be written in URL format as: \n\n    POST /records/posts\n\nYou have to send a body containing:\n\n    {\n        \"title\": \"Black is the new red\",\n        \"content\": \"This is the second post.\",\n        \"created\": \"2018-03-06T21:34:01Z\"\n    }\n\nAnd it will return the value of the primary key of the newly created record:\n\n    2\n\n#### Read\n\nTo read a record from this table the request can be written in URL format as:\n\n    GET /records/posts/1\n\nWhere \"1\" is the value of the primary key of the record that you want to read. It will return:\n\n    {\n        \"id\": 1\n        \"title\": \"Hello world!\",\n        \"content\": \"Welcome to the first post.\",\n        \"created\": \"2018-03-05T20:12:56Z\"\n    }\n\nOn read operations you may apply joins.\n\n#### Update\n\nTo update a record in this table the request can be written in URL format as:\n\n    PUT /records/posts/1\n\nWhere \"1\" is the value of the primary key of the record that you want to update. Send as a body:\n\n    {\n        \"title\": \"Adjusted title!\"\n    }\n\nThis adjusts the title of the post. And the return value is the number of rows that are set:\n\n    1\n\n#### Delete\n\nIf you want to delete a record from this table the request can be written in URL format as:\n\n    DELETE /records/posts/1\n\nAnd it will return the number of deleted rows:\n\n    1\n\n#### List\n\nTo list records from this table the request can be written in URL format as:\n\n    GET /records/posts\n\nIt will return:\n\n    {\n        \"records\":[\n            {\n                \"id\": 1,\n                \"title\": \"Hello world!\",\n                \"content\": \"Welcome to the first post.\",\n                \"created\": \"2018-03-05T20:12:56Z\"\n            }\n        ]\n    }\n\nOn list operations you may apply filters and joins.\n\n### Filters\n\nFilters provide search functionality, on list calls, using the \"filter\" parameter. You need to specify the column\nname, a comma, the match type, another comma and the value you want to filter on. These are supported match types:\n\n  - \"cs\": contain string (string contains value)\n  - \"sw\": start with (string starts with value)\n  - \"ew\": end with (string end with value)\n  - \"eq\": equal (string or number matches exactly)\n  - \"lt\": lower than (number is lower than value)\n  - \"le\": lower or equal (number is lower than or equal to value)\n  - \"ge\": greater or equal (number is higher than or equal to value)\n  - \"gt\": greater than (number is higher than value)\n  - \"bt\": between (number is between two comma separated values)\n  - \"in\": in (number or string is in comma separated list of values)\n  - \"is\": is null (field contains \"NULL\" value)\n\nYou can negate all filters by prepending a \"n\" character, so that \"eq\" becomes \"neq\". \nExamples of filter usage are:\n\n    GET /records/categories?filter=name,eq,Internet\n    GET /records/categories?filter=name,sw,Inter\n    GET /records/categories?filter=id,le,1\n    GET /records/categories?filter=id,ngt,1\n    GET /records/categories?filter=id,bt,0,1\n    GET /records/categories?filter=id,in,0,1\n\nOutput:\n\n    {\n        \"records\":[\n            {\n                \"id\": 1\n                \"name\": \"Internet\"\n            }\n        ]\n    }\n\nIn the next section we dive deeper into how you can apply multiple filters on a single list call.\n\n### Multiple filters\n\nFilters can be a by applied by repeating the \"filter\" parameter in the URL. For example the following URL: \n\n    GET /records/categories?filter=id,gt,1&filter=id,lt,3\n\nwill request all categories \"where id > 1 and id < 3\". If you wanted \"where id = 2 or id = 4\" you should write:\n\n    GET /records/categories?filter1=id,eq,2&filter2=id,eq,4\n    \nAs you see we added a number to the \"filter\" parameter to indicate that \"OR\" instead of \"AND\" should be applied.\nNote that you can also repeat \"filter1\" and create an \"AND\" within an \"OR\". Since you can also go one level deeper\nby adding a letter (a-f) you can create almost any reasonably complex condition tree.\n\nNB: You can only filter on the requested table (not on it's included tables) and filters are only applied on list calls.\n\n### Column selection\n\nBy default all columns are selected. With the \"include\" parameter you can select specific columns. \nYou may use a dot to separate the table name from the column name. Multiple columns should be comma separated. \nAn asterisk (\"*\") may be used as a wildcard to indicate \"all columns\". Similar to \"include\" you may use the \"exclude\" parameter to remove certain columns:\n\n```\nGET /records/categories/1?include=name\nGET /records/categories/1?include=categories.name\nGET /records/categories/1?exclude=categories.id\n```\n\nOutput:\n\n```\n    {\n        \"name\": \"Internet\"\n    }\n```\n\nNB: Columns that are used to include related entities are automatically added and cannot be left out of the output.\n\n### Ordering\n\nWith the \"order\" parameter you can sort. By default the sort is in ascending order, but by specifying \"desc\" this can be reversed:\n\n```\nGET /records/categories?order=name,desc\nGET /records/categories?order=id,desc&order=name\n```\n\nOutput:\n\n```\n    {\n        \"records\":[\n            {\n                \"id\": 3\n                \"name\": \"Web development\"\n            },\n            {\n                \"id\": 1\n                \"name\": \"Internet\"\n            }\n        ]\n    }\n```\n\nNB: You may sort on multiple fields by using multiple \"order\" parameters. You can not order on \"joined\" columns.\n\n### Limit size\n\nThe \"size\" parameter limits the number of returned records. This can be used for top N lists together with the \"order\" parameter (use descending order).\n\n```\nGET /records/categories?order=id,desc&size=1\n```\n\nOutput:\n\n```\n    {\n        \"records\":[\n            {\n                \"id\": 3\n                \"name\": \"Web development\"\n            }\n        ]\n    }\n```\n\nNB: If you also want to know to the total number of records you may want to use the \"page\" parameter.\n\n### Pagination\n\nThe \"page\" parameter holds the requested page. The default page size is 20, but can be adjusted (e.g. to 50).\n\n```\nGET /records/categories?order=id&page=1\nGET /records/categories?order=id&page=1,50\n```\n\nOutput:\n\n```\n    {\n        \"records\":[\n            {\n                \"id\": 1\n                \"name\": \"Internet\"\n            },\n            {\n                \"id\": 3\n                \"name\": \"Web development\"\n            }\n        ],\n        \"results\": 2\n    }\n```\n\nThe element \"results\" holds to total number of records in the table, which would be returned if no pagination would be used.\n\nNB: Since pages that are not ordered cannot be paginated, pages will be ordered by primary key.\n\n### Joins\n\nLet's say that you have a posts table that has comments (made by users) and the posts can have tags.\n\n    posts    comments  users     post_tags  tags\n    =======  ========  =======   =========  ======= \n    id       id        id        id         id\n    title    post_id   username  post_id    name\n    content  user_id   phone     tag_id\n    created  message\n\nWhen you want to list posts with their comments users and tags you can ask for two \"tree\" paths:\n\n    posts -> comments  -> users\n    posts -> post_tags -> tags\n\nThese paths have the same root and this request can be written in URL format as:\n\n    GET /records/posts?join=comments,users&join=tags\n\nHere you are allowed to leave out the intermediate table that binds posts to tags. In this example\nyou see all three table relation types (hasMany, belongsTo and hasAndBelongsToMany) in effect:\n\n- \"post\" has many \"comments\"\n- \"comment\" belongs to \"user\"\n- \"post\" has and belongs to many \"tags\"\n\nThis may lead to the following JSON data:\n\n    {\n        \"records\":[\n            {\n                \"id\": 1,\n                \"title\": \"Hello world!\",\n                \"content\": \"Welcome to the first post.\",\n                \"created\": \"2018-03-05T20:12:56Z\",\n                \"comments\": [\n                    {\n                        id: 1,\n                        post_id: 1,\n                        user_id: {\n                            id: 1,\n                            username: \"mevdschee\",\n                            phone: null,\n                        },\n                        message: \"Hi!\"\n                    },\n                    {\n                        id: 2,\n                        post_id: 1,\n                        user_id: {\n                            id: 1,\n                            username: \"mevdschee\",\n                            phone: null,\n                        },\n                        message: \"Hi again!\"\n                    }\n                ],\n                \"tags\": []\n            },\n            {\n                \"id\": 2,\n                \"title\": \"Black is the new red\",\n                \"content\": \"This is the second post.\",\n                \"created\": \"2018-03-06T21:34:01Z\",\n                \"comments\": [],\n                \"tags\": [\n                    {\n                        id: 1,\n                        message: \"Funny\"\n                    },\n                    {\n                        id: 2,\n                        message: \"Informational\"\n                    }\n                ]\n            }\n        ]\n    }\n\nYou see that the \"belongsTo\" relationships are detected and the foreign key value is replaced by the referenced object.\nIn case of \"hasMany\" and \"hasAndBelongsToMany\" the table name is used a new property on the object.\n\n### Batch operations\n\nWhen you want to create, read, update or delete you may specify multiple primary key values in the URL.\nYou also need to send an array instead of an object in the request body for create and update. \n\nTo read a record from this table the request can be written in URL format as:\n\n    GET /records/posts/1,2\n\nThe result may be:\n\n    [\n            {\n                \"id\": 1,\n                \"title\": \"Hello world!\",\n                \"content\": \"Welcome to the first post.\",\n                \"created\": \"2018-03-05T20:12:56Z\"\n            },\n            {\n                \"id\": 2,\n                \"title\": \"Black is the new red\",\n                \"content\": \"This is the second post.\",\n                \"created\": \"2018-03-06T21:34:01Z\"\n            }\n    ]\n\nSimilarly when you want to do a batch update the request in URL format is written as:\n\n    PUT /records/posts/1,2\n\nWhere \"1\" and \"2\" are the values of the primary keys of the records that you want to update. The body should \ncontain the same number of objects as there are primary keys in the URL:\n\n    [   \n        {\n            \"title\": \"Adjusted title for ID 1\"\n        },\n        {\n            \"title\": \"Adjusted title for ID 2\"\n        }        \n    ]\n\nThis adjusts the titles of the posts. And the return values are the number of rows that are set:\n\n    [1,1]\n\nWhich means that there were two update operations and each of them had set one row. Batch operations use database\ntransactions, so they either all succeed or all fail (successful ones get rolled back). If they fail the body will\ncontain the list of error documents. In the following response the first operation succeeded and the second operation\nof the batch failed due to an integrity violation:\n\n    [   \n        {\n            \"code\": 0,\n            \"message\": \"Success\"\n        },\n        {\n            \"code\": 1010,\n            \"message\": \"Data integrity violation\"\n        }\n    ]\n\nThe response status code will always be 424 (failed dependency) in case of any failure of one of the batch operations.\n\nTo insert multiple records into this table the request can be written in URL format as:\n\n    POST /records/posts\n\nThe body should contain an array of records to be inserted:\n\n    [\n            {\n                \"title\": \"Hello world!\",\n                \"content\": \"Welcome to the first post.\",\n                \"created\": \"2018-03-05T20:12:56Z\"\n            },\n            {\n                \"title\": \"Black is the new red\",\n                \"content\": \"This is the second post.\",\n                \"created\": \"2018-03-06T21:34:01Z\"\n            }\n    ]\n\nThe return value is also an array containing the primary keys of the newly inserted records:\n\n    [1,2] \n\nNote that batch operation for DELETE follows the same pattern as PUT, but without a body.\n\n### Spatial support\n\nFor spatial support there is an extra set of filters that can be applied on geometry columns and that starting with an \"s\":\n\n  - \"sco\": spatial contains (geometry contains another)\n  - \"scr\": spatial crosses (geometry crosses another)\n  - \"sdi\": spatial disjoint (geometry is disjoint from another)\n  - \"seq\": spatial equal (geometry is equal to another)\n  - \"sin\": spatial intersects (geometry intersects another)\n  - \"sov\": spatial overlaps (geometry overlaps another)\n  - \"sto\": spatial touches (geometry touches another)\n  - \"swi\": spatial within (geometry is within another)\n  - \"sic\": spatial is closed (geometry is closed and simple)\n  - \"sis\": spatial is simple (geometry is simple)\n  - \"siv\": spatial is valid (geometry is valid)\n\nThese filters are based on OGC standards and so is the WKT specification in which the geometry columns are represented.\nNote that the SRID that is assumed when converting from WKT to geometry is specified by the config variable `geometrySrid` and defaults to 4326 (WGS 84).\n\n#### GeoJSON\n\nThe GeoJSON support is a read-only view on the tables and records in GeoJSON format. These requests are supported:\n\n    method path                  - operation - description\n    ----------------------------------------------------------------------------------------\n    GET    /geojson/{table}      - list      - lists records as a GeoJSON FeatureCollection\n    GET    /geojson/{table}/{id} - read      - reads a record by primary key as a GeoJSON Feature\n\nThe \"`/geojson`\" endpoint uses the \"`/records`\" endpoint internally and inherits all functionality, such as joins and filters.\nIt also supports a \"geometry\" parameter to indicate the name of the geometry column in case the table has more than one.\nFor map views it supports the \"bbox\" parameter in which you can specify upper-left and lower-right coordinates (comma separated).\nThe following Geometry types are supported by the GeoJSON implementation:\n\n  - Point\n  - MultiPoint\n  - LineString\n  - MultiLineString\n  - Polygon\n  - MultiPolygon\n\nThe GeoJSON functionality is enabled by default, but can be disabled using the \"controllers\" configuration.\n\n## Mapping names for legacy systems\n\nTo support creating an API for (a part of) a legacy system (such as Wordpress) you may want to map the table and column \nnames as can not improve them without changing the software, while the names may need some improvement for consistency.\nThe config allows you to rename tables and columns with a comma separated list of mappings that are split with an \nequal sign, like this:\n\n    'mapping' => 'wp_posts=posts,wp_posts.ID=posts.id',\n\nThis specific example will expose the \"`wp_posts`\" table at a \"`posts`\" end-point (instead of \"`wp_posts`\") and the \ncolumn \"`ID`\" within that table as the \"`id`\" property (in lower case instead of upper case).\n\nNB: Since these two mappings overlap the first (less specific) mapping may be omitted.\n\n## Middleware\n\nYou can enable the following middleware using the \"middlewares\" config parameter:\n\n- \"firewall\": Limit access to specific IP addresses\n- \"sslRedirect\": Force connection over HTTPS instead of HTTP\n- \"cors\": Support for CORS requests (enabled by default)\n- \"xsrf\": Block XSRF attacks using the 'Double Submit Cookie' method\n- \"ajaxOnly\": Restrict non-AJAX requests to prevent XSRF attacks\n- \"apiKeyAuth\": Support for \"API Key Authentication\"\n- \"apiKeyDbAuth\": Support for \"API Key Database Authentication\"\n- \"dbAuth\": Support for \"Database Authentication\"\n- \"wpAuth\": Support for \"Wordpress Authentication\"\n- \"jwtAuth\": Support for \"JWT Authentication\"\n- \"basicAuth\": Support for \"Basic Authentication\"\n- \"reconnect\": Reconnect to the database with different parameters\n- \"authorization\": Restrict access to certain tables or columns\n- \"validation\": Return input validation errors for custom rules and default type rules\n- \"ipAddress\": Fill a protected field with the IP address on create\n- \"sanitation\": Apply input sanitation on create and update\n- \"multiTenancy\": Restricts tenants access in a multi-tenant scenario\n- \"pageLimits\": Restricts list operations to prevent database scraping\n- \"joinLimits\": Restricts join parameters to prevent database scraping\n- \"textSearch\": Search in all text fields with a simple parameter\n- \"customization\": Provides handlers for request and response customization\n- \"json\": Support read/write of JSON strings as JSON objects/arrays\n- \"xml\": Translates all input and output from JSON to XML\n\nThe \"middlewares\" config parameter is a comma separated list of enabled middlewares.\nYou can tune the middleware behavior using middleware specific configuration parameters:\n\n- \"firewall.reverseProxy\": Set to \"true\" when a reverse proxy is used (\"\")\n- \"firewall.allowedIpAddresses\": List of IP addresses that are allowed to connect (\"\")\n- \"cors.allowedOrigins\": The origins allowed in the CORS headers (\"*\")\n- \"cors.allowHeaders\": The headers allowed in the CORS request (\"Content-Type, X-XSRF-TOKEN, X-Authorization\")\n- \"cors.allowMethods\": The methods allowed in the CORS request (\"OPTIONS, GET, PUT, POST, DELETE, PATCH\")\n- \"cors.allowCredentials\": To allow credentials in the CORS request (\"true\")\n- \"cors.exposeHeaders\": Whitelist headers that browsers are allowed to access (\"\")\n- \"cors.maxAge\": The time that the CORS grant is valid in seconds (\"1728000\")\n- \"xsrf.excludeMethods\": The methods that do not require XSRF protection (\"OPTIONS,GET\")\n- \"xsrf.cookieName\": The name of the XSRF protection cookie (\"XSRF-TOKEN\")\n- \"xsrf.headerName\": The name of the XSRF protection header (\"X-XSRF-TOKEN\")\n- \"ajaxOnly.excludeMethods\": The methods that do not require AJAX (\"OPTIONS,GET\")\n- \"ajaxOnly.headerName\": The name of the required header (\"X-Requested-With\")\n- \"ajaxOnly.headerValue\": The value of the required header (\"XMLHttpRequest\")\n- \"apiKeyAuth.mode\": Set to \"optional\" if you want to allow anonymous access (\"required\")\n- \"apiKeyAuth.header\": The name of the API key header (\"X-API-Key\")\n- \"apiKeyAuth.keys\": List of API keys that are valid (\"\")\n- \"apiKeyDbAuth.mode\": Set to \"optional\" if you want to allow anonymous access (\"required\")\n- \"apiKeyDbAuth.header\": The name of the API key header (\"X-API-Key\")\n- \"apiKeyDbAuth.usersTable\": The table that is used to store the users in (\"users\")\n- \"apiKeyDbAuth.apiKeyColumn\": The users table column that holds the API key (\"api_key\")\n- \"dbAuth.mode\": Set to \"optional\" if you want to allow anonymous access (\"required\")\n- \"dbAuth.usersTable\": The table that is used to store the users in (\"users\")\n- \"dbAuth.loginTable\": The table or view that is used to retrieve the users info for login (\"users\")\n- \"dbAuth.usernameColumn\": The users table column that holds usernames (\"username\")\n- \"dbAuth.passwordColumn\": The users table column that holds passwords (\"password\")\n- \"dbAuth.returnedColumns\": The columns returned on successful login, empty means 'all' (\"\")\n- \"dbAuth.usernameFormField\": The name of the form field that holds the username (\"username\")\n- \"dbAuth.passwordFormField\": The name of the form field that holds the password (\"password\")\n- \"dbAuth.newPasswordFormField\": The name of the form field that holds the new password (\"newPassword\")\n- \"dbAuth.registerUser\": JSON user data (or \"1\") in case you want the /register endpoint enabled (\"\")\n- \"dbAuth.loginAfterRegistration\": 1 or zero if registered users should be logged in after registration (\"\")\n- \"dbAuth.passwordLength\": Minimum length that the password must have (\"12\")\n- \"dbAuth.sessionName\": The name of the PHP session that is started (\"\")\n- \"wpAuth.mode\": Set to \"optional\" if you want to allow anonymous access (\"required\")\n- \"wpAuth.wpDirectory\": The folder/path where the Wordpress install can be found (\".\")\n- \"wpAuth.usernameFormField\": The name of the form field that holds the username (\"username\")\n- \"wpAuth.passwordFormField\": The name of the form field that holds the password (\"password\")\n- \"jwtAuth.mode\": Set to \"optional\" if you want to allow anonymous access (\"required\")\n- \"jwtAuth.header\": Name of the header containing the JWT token (\"X-Authorization\")\n- \"jwtAuth.leeway\": The acceptable number of seconds of clock skew (\"5\")\n- \"jwtAuth.ttl\": The number of seconds the token is valid (\"30\")\n- \"jwtAuth.secrets\": The shared secret(s) used to sign the JWT token with (\"\")\n- \"jwtAuth.algorithms\": The algorithms that are allowed, empty means 'all' (\"\")\n- \"jwtAuth.audiences\": The audiences that are allowed, empty means 'all' (\"\")\n- \"jwtAuth.issuers\": The issuers that are allowed, empty means 'all' (\"\")\n- \"jwtAuth.sessionName\": The name of the PHP session that is started (\"\")\n- \"basicAuth.mode\": Set to \"optional\" if you want to allow anonymous access (\"required\")\n- \"basicAuth.realm\": Text to prompt when showing login (\"Username and password required\")\n- \"basicAuth.passwordFile\": The file to read for username/password combinations (\".htpasswd\")\n- \"basicAuth.sessionName\": The name of the PHP session that is started (\"\")\n- \"reconnect.driverHandler\": Handler to implement retrieval of the database driver (\"\")\n- \"reconnect.addressHandler\": Handler to implement retrieval of the database address (\"\")\n- \"reconnect.portHandler\": Handler to implement retrieval of the database port (\"\")\n- \"reconnect.databaseHandler\": Handler to implement retrieval of the database name (\"\")\n- \"reconnect.tablesHandler\": Handler to implement retrieval of the table names (\"\")\n- \"reconnect.mappingHandler\": Handler to implement retrieval of the name mapping (\"\")\n- \"reconnect.usernameHandler\": Handler to implement retrieval of the database username (\"\")\n- \"reconnect.passwordHandler\": Handler to implement retrieval of the database password (\"\")\n- \"authorization.tableHandler\": Handler to implement table authorization rules (\"\")\n- \"authorization.columnHandler\": Handler to implement column authorization rules (\"\")\n- \"authorization.pathHandler\": Handler to implement path authorization rules (\"\")\n- \"authorization.recordHandler\": Handler to implement record authorization filter rules (\"\")\n- \"validation.handler\": Handler to implement validation rules for input values (\"\")\n- \"validation.types\": Types to enable type validation for, empty means 'none' (\"all\")\n- \"validation.tables\": Tables to enable type validation for, empty means 'none' (\"all\")\n- \"ipAddress.tables\": Tables to search for columns to override with IP address (\"\")\n- \"ipAddress.columns\": Columns to protect and override with the IP address on create (\"\")\n- \"sanitation.handler\": Handler to implement sanitation rules for input values (\"\")\n- \"sanitation.types\": Types to enable type sanitation for, empty means 'none' (\"all\")\n- \"sanitation.tables\": Tables to enable type sanitation for, empty means 'none' (\"all\")\n- \"multiTenancy.handler\": Handler to implement simple multi-tenancy rules (\"\")\n- \"pageLimits.pages\": The maximum page number that a list operation allows (\"100\")\n- \"pageLimits.records\": The maximum number of records returned by a list operation (\"1000\")\n- \"joinLimits.depth\": The maximum depth (length) that is allowed in a join path (\"3\")\n- \"joinLimits.tables\": The maximum number of tables that you are allowed to join (\"10\")\n- \"joinLimits.records\": The maximum number of records returned for a joined entity (\"1000\")\n- \"textSearch.parameter\": The name of the parameter used for the search term (\"search\")\n- \"customization.beforeHandler\": Handler to implement request customization (\"\")\n- \"customization.afterHandler\": Handler to implement response customization (\"\")\n- \"json.controllers\": Controllers to process JSON strings for (\"records,geojson\")\n- \"json.tables\": Tables to process JSON strings for (\"all\")\n- \"json.columns\": Columns to process JSON strings for (\"all\")\n- \"xml.types\": JSON types that should be added to the XML type attribute (\"null,array\")\n\nIf you don't specify these parameters in the configuration, then the default values (between brackets) are used.\n\nIn the sections below you find more information on the built-in middleware.\n\n### Authentication\n\nCurrently there are five types of authentication supported. They all store the authenticated user in the `$_SESSION` super global.\nThis variable can be used in the authorization handlers to decide wether or not somebody should have read or write access to certain tables, columns or records.\nThe following overview shows the kinds of authentication middleware that you can enable.\n\n| Name       | Middleware   | Authenticated via      | Users are stored in | Session variable        |\n| ---------- | ------------ | ---------------------- | ------------------- | ----------------------- |\n| API key    | apiKeyAuth   | 'X-API-Key' header     | configuration       | `$_SESSION['apiKey']`   |\n| API key DB | apiKeyDbAuth | 'X-API-Key' header     | database table      | `$_SESSION['apiUser']`  |\n| Database   | dbAuth       | '/login' endpoint      | database table      | `$_SESSION['user']`     |\n| Basic      | basicAuth    | 'Authorization' header | '.htpasswd' file    | `$_SESSION['username']` |\n| JWT        | jwtAuth      | 'Authorization' header | identity provider   | `$_SESSION['claims']`   |\n\nBelow you find more information on each of the authentication types.\n\n#### API key authentication\n\nAPI key authentication works by sending an API key in a request header.\nThe header name defaults to \"X-API-Key\" and can be configured using the 'apiKeyAuth.header' configuration parameter.\nValid API keys must be configured using the 'apiKeyAuth.keys' configuration parameter (comma separated list).\n\n    X-API-Key: 02c042aa-c3c2-4d11-9dae-1a6e230ea95e\n\nThe authenticated API key will be stored in the `$_SESSION['apiKey']` variable.\n\nNote that the API key authentication does not require or use session cookies.\n\n#### API key database authentication\n\nAPI key database authentication works by sending an API key in a request header \"X-API-Key\" (the name is configurable).\nValid API keys are read from the database from the column \"api_key\" of the \"users\" table (both names are configurable).\n\n    X-API-Key: 02c042aa-c3c2-4d11-9dae-1a6e230ea95e\n\nThe authenticated user (with all it's properties) will be stored in the `$_SESSION['apiUser']` variable.\n\nNote that the API key database authentication does not require or use session cookies.\n\n#### Database authentication\n\nThe database authentication middleware defines five new routes:\n\n    method path       - parameters                      - description\n    ---------------------------------------------------------------------------------------------------\n    GET    /me        -                                 - returns the user that is currently logged in\n    POST   /register  - username, password              - adds a user with given username and password\n    POST   /login     - username, password              - logs a user in by username and password\n    POST   /password  - username, password, newPassword - updates the password of the logged in user\n    POST   /logout    -                                 - logs out the currently logged in user\n\nA user can be logged in by sending it's username and password to the login endpoint (in JSON format).\nThe authenticated user (with all it's properties) will be stored in the `$_SESSION['user']` variable.\nThe user can be logged out by sending a POST request with an empty body to the logout endpoint.\nThe passwords are stored as hashes in the password column in the users table. You can register a new user\nusing the register endpoint, but this functionality must be turned on using the \"dbAuth.registerUser\"\nconfiguration parameter.\n\nIt is IMPORTANT to restrict access to the users table using the 'authorization' middleware, otherwise all \nusers can freely add, modify or delete any account! The minimal configuration is shown below:\n\n    'middlewares' => 'dbAuth,authorization',\n    'authorization.tableHandler' => function ($operation, $tableName) {\n        return $tableName != 'users';\n    },\n\nNote that this middleware uses session cookies and stores the logged in state on the server.\n\n**Login using views with joined table**\n\nFor login operations, it is possible to use a view as the usersTable. Such view can return a filtered result from the users table, e.g., *where active = true* or it may also return a result multiple tables thru a table join. At a minimum, the view should include the ***username*** and ***password*** and a field named ***id***.\n\nHowever, views with joined tables are not insertable ([see issue 907](https://github.com/mevdschee/php-crud-api/issues/907) ). As a workaround, use the property ***loginTable*** to set a different reference table for login. The **usersTable** will still be set to the normal, insertable users table. \n\n#### Wordpress authentication\n\nThe Wordpress authentication middleware defines three routes:\n\n    method path       - parameters                      - description\n    ---------------------------------------------------------------------------------------------------\n    GET    /me        -                                 - returns the user that is currently logged in\n    POST   /login     - username, password              - logs a user in by username and password\n    POST   /logout    -                                 - logs out the currently logged in user\n\nA user can be logged in by sending it's username and password to the login endpoint (in JSON format).\nThe user can be logged out by sending a POST request with an empty body to the logout endpoint.\nYou need to specify the Wordpress installation directory using the \"wpAuth.wpDirectory\" configuration parameter.\nThe middleware calls \"wp-load.php\" this allows you to use Wordpress functions in the authorization middleware, like:\n\n- wp_get_current_user()\n- is_user_logged_in()\n- is_super_admin()\n- user_can(wp_get_current_user(),'edit_posts');\n\nNote that the `$_SESSION` variable is not used by this middleware.\n\n#### Basic authentication\n\nThe Basic type supports a file (by default '.htpasswd') that holds the users and their (hashed) passwords separated by a colon (':'). \nWhen the passwords are entered in plain text they will be automatically hashed.\nThe authenticated username will be stored in the `$_SESSION['username']` variable.\nYou need to send an \"Authorization\" header containing a base64 url encoded version of your colon separated username and password, after the word \"Basic\".\n\n    Authorization: Basic dXNlcm5hbWUxOnBhc3N3b3JkMQ\n\nThis example sends the string \"username1:password1\".\n\n#### JWT authentication\n\nThe JWT type requires another (SSO/Identity) server to sign a token that contains claims. \nBoth servers share a secret so that they can either sign or verify that the signature is valid.\nClaims are stored in the `$_SESSION['claims']` variable. You need to send an \"X-Authorization\" \nheader containing a base64 url encoded and dot separated token header, body and signature after\nthe word \"Bearer\" ([read more about JWT here](https://jwt.io/)). The standard says you need to\nuse the \"Authorization\" header, but this is problematic in Apache and PHP.\n\n    X-Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6IjE1MzgyMDc2MDUiLCJleHAiOjE1MzgyMDc2MzV9.Z5px_GT15TRKhJCTHhDt5Z6K6LRDSFnLj8U5ok9l7gw\n\nThis example sends the signed claims:\n\n    {\n      \"sub\": \"1234567890\",\n      \"name\": \"John Doe\",\n      \"admin\": true,\n      \"iat\": \"1538207605\",\n      \"exp\": 1538207635\n    }\n\nNB: The JWT implementation only supports the RSA and HMAC based algorithms.\n\n##### Configure and test JWT authentication with Auth0\n\nFirst you need to create an account on [Auth0](https://auth0.com/auth/login).\nOnce logged in, you have to create an application (its type does not matter). Collect the `Domain`\nand `Client ID` and keep them for a later use. Then, create an API: give it a name and fill the\n`identifier` field with your API endpoint's URL.\n\nThen you have to configure the `jwtAuth.secrets` configuration in your `api.php` file.\nDon't fill it with the `secret` you will find in your Auth0 application settings but with **a\npublic certificate**. To find it, go to the settings of your application, then in \"Extra settings\".\nYou will now find a \"Certificates\" tab where you will find your Public Key in the Signing\nCertificate field.\n\nTo test your integration, you can copy the [auth0/vanilla.html](examples/clients/auth0/vanilla.html)\nfile. Be sure to fill these three variables:\n\n - `authUrl` with your Auth0 domain\n - `clientId` with your Client ID\n - `audience` with the API URL you created in Auth0\n\nNote that if you don't fill the audience parameter, it will not work because you won't get a valid JWT.\nAlso note that you should fill `jwtAuth.audiences` (with the value of the `audience`) to ensure the\ntokens are validated to be generated for your application.\n\nYou can also change the `url` variable, used to test the API with authentication.\n\n[More info](https://auth0.com/docs/api-auth/tutorials/verify-access-token)\n\n##### Configure and test JWT authentication with Firebase\n\nFirst you need to create a Firebase project on the [Firebase console](https://console.firebase.google.com/).\nAdd a web application to this project and grab the code snippet for later use.\n\nThen you have to configure the `jwtAuth.secrets` configuration in your `api.php` file. \nThis can be done as follows:\n\na. Log a user in to your Firebase-based app, get an authentication token for that user\nb. Go to [https://jwt.io/](https://jwt.io/) and paste the token in the decoding field\nc. Read the decoded header information from the token, it will give you the correct `kid`\nd. Grab the public key via this [URL](https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com), which corresponds to your `kid` from previous step\ne. Now, just fill `jwtAuth.secrets` with your public key in the `api.php`\n\nAlso configure the `jwtAuth.audiences` (fill in the Firebase project ID).\n\nHere is an example of what it should look like in the configuration:\n\n```\n...,\n'middlewares' => 'cors, jwtAuth, authorization',\n        'jwtAuth.secrets' => \"ce5ced6e40dcd1eff407048867b1ed1e706686a0:-----BEGIN CERTIFICATE-----\\nMIIDHDCCAgSgAwIBAgIIExun9bJSK1wwDQYJKoZIhvcNAQEFBQAwMTEvMC0GA1UE\\nAxMmc2VjdXJldG9rZW4uc3lzdGVtLmdzZXJ2aWNlYWNjb3VudC5jb20wHhcNMTkx\\nMjIyMjEyMTA3WhcNMjAwMTA4MDkzNjA3WjAxMS8wLQYDVQQDEyZzZWN1cmV0b2tl\\nbi5zeXN0ZW0uZ3NlcnZpY2VhY2NvdW50LmNvbTCCASIwDQYJKoZIhvcNAQEBBQAD\\nggEPADCCAQoCggEBAKsvVDUwXeYQtySNvyI1/tZAk0sj7Zx4/1+YLUomwlK6vmEd\\nyl2IXOYOj3VR7FBA24A9//nnrp+mV8YOYEOdaWX7PQo0PIPFPqdA0r7CqBUWHPfQ\\n1WVHVRQY3G0c7upM97UfMes9xOrMqyvecMRk1e5S6eT12Zh2og7yiVs8gP83M1EB\\nGqseUaltaadjyT35w5B0Ny0/7NdLYiv2G6Z0S821SxvSo1/wfmilnBBKYYluP0PA\\n9NPznWFP6uXnX7gKxyJT9//cYVxTO6+b1TT13Yvrpm1a4EuCOhLrZH6ErHQTccAM\\nhAx8mdNtbROsp0dlPKrSfqO82uFz45RXZYmSeP0CAwEAAaM4MDYwDAYDVR0TAQH/\\nBAIwADAOBgNVHQ8BAf8EBAMCB4AwFgYDVR0lAQH/BAwwCgYIKwYBBQUHAwIwDQYJ\\nKoZIhvcNAQEFBQADggEBACNsJ5m00gdTvD6j6ahURsGrNZ0VJ0YREVQ5U2Jtubr8\\nn2fuhMxkB8147ISzfi6wZR+yNwPGjlr8JkAHAC0i+Nam9SqRyfZLqsm+tHdgFT8h\\npa+R/FoGrrLzxJNRiv0Trip8hZjgz3PClz6KxBQzqL+rfGV2MbwTXuBoEvLU1mYA\\no3/UboJT7cNGjZ8nHXeoKMsec1/H55lUdconbTm5iMU1sTDf+3StGYzTwC+H6yc2\\nY3zIq3/cQUCrETkALrqzyCnLjRrLYZu36ITOaKUbtmZhwrP99i2f+H4Ab2i8jeMu\\nk61HD29mROYjl95Mko2BxL+76To7+pmn73U9auT+xfA=\\n-----END CERTIFICATE-----\\n\",\n        'jwtAuth.audiences' => 'your-project-id',\n        'cors.allowedOrigins' => '*',\n        'cors.allowHeaders' => 'X-Authorization'\n```\n\nNotes:\n - The `kid:key` pair is formatted as a string\n - Do not include spaces before or after the ':'\n - Use double quotation marks (\") around the string text\n - The string must contain the linefeeds (\\n)\n - `jwtAuth.audiences` should contain your Firebase projectId\n\nTo test your integration, you can copy the [firebase/vanilla.html](examples/clients/firebase/vanilla.html)\nfile and the [firebase/vanilla-success.html](examples/clients/firebase/vanilla-success.html) file,\nused as a \"success\" page and to display the API result.\n\nReplace, in both files, the Firebase configuration (`firebaseConfig` object).\n\nYou can also change the `url` variable, used to test the API with authentication.\n\n[More info](https://firebase.google.com/docs/auth/admin/verify-id-tokens#verify_id_tokens_using_a_third-party_jwt_library)\n\n### Authorizing operations\n\nThe Authorization model acts on \"operations\". The most important ones are listed here:\n\n    method path                  - operation - description\n    ----------------------------------------------------------------------------------------\n    GET    /records/{table}      - list      - lists records\n    POST   /records/{table}      - create    - creates records\n    GET    /records/{table}/{id} - read      - reads a record by primary key\n    PUT    /records/{table}/{id} - update    - updates columns of a record by primary key\n    DELETE /records/{table}/{id} - delete    - deletes a record by primary key\n    PATCH  /records/{table}/{id} - increment - increments columns of a record by primary key\n\nThe \"`/openapi`\" endpoint will only show what is allowed in your session. It also has a special \n\"document\" operation to allow you to hide tables and columns from the documentation.\n    \nFor endpoints that start with \"`/columns`\" there are the operations \"reflect\" and \"remodel\". \nThese operations can display or change the definition of the database, table or column. \nThis functionality is disabled by default and for good reason (be careful!). \nAdd the \"columns\" controller in the configuration to enable this functionality.\n\n### Authorizing tables, columns and records\n\nBy default all tables, columns and paths are accessible. If you want to restrict access to some tables you may add the 'authorization' middleware \nand define a 'authorization.tableHandler' function that returns 'false' for these tables.\n\n    'authorization.tableHandler' => function ($operation, $tableName) {\n        return $tableName != 'license_keys';\n    },\n\nThe above example will restrict access to the table 'license_keys' for all operations.\n\n    'authorization.columnHandler' => function ($operation, $tableName, $columnName) {\n        return !($tableName == 'users' && $columnName == 'password');\n    },\n\nThe above example will restrict access to the 'password' field of the 'users' table for all operations.\n\n    'authorization.recordHandler' => function ($operation, $tableName) {\n        return ($tableName == 'users') ? 'filter=username,neq,admin' : '';\n    },\n\nThe above example will disallow access to user records where the username is 'admin'. \nThis construct adds a filter to every executed query. \n\n    'authorization.pathHandler' => function ($path) {\n        return $path === 'openapi' ? false : true;\n    },\n\nThe above example will disabled the `/openapi` route.\n\nNB: You need to handle the creation of invalid records with a validation (or sanitation) handler.\n\n### SQL GRANT authorization\n\nYou can alternatively use database permissons (SQL GRANT statements) to define the authorization model. In this case you\nshould not use the \"authorization\" middleware, but you do need to use the \"reconnect\" middleware. The handlers of the\n\"reconnect\" middleware allow you to specify the correct username and password, like this:\n\n    'reconnect.usernameHandler' => function () {\n        return 'mevdschee';\n    },\n    'reconnect.passwordHandler' => function () {\n        return 'secret123';\n    },\n\nThis will make the API connect to the database specifying \"mevdschee\" as the username and \"secret123\" as the password.\nThe OpenAPI specification is less specific on allowed and disallowed operations when you are using database permissions,\nas the permissions are not read in the reflection step.\n\nNB: You may want to retrieve the username and password from the session (the \"$_SESSION\" variable).\n\n### Sanitizing input\n\nBy default all input is accepted and sent to the database. If you want to strip (certain) HTML tags before storing you may add \nthe 'sanitation' middleware and define a 'sanitation.handler' function that returns the adjusted value.\n\n    'sanitation.handler' => function ($operation, $tableName, $column, $value) {\n        return is_string($value) ? strip_tags($value) : $value;\n    },\n\nThe above example will strip all HTML tags from strings in the input.\n\n### Type sanitation\n\nIf you enable the 'sanitation' middleware, then you (automatically) also enable type sanitation. When this is enabled you may:\n\n- send leading and trailing whitespace in a non-character field (it will be ignored).\n- send a float to an integer or bigint field (it will be rounded).\n- send a base64url encoded string (it will be converted to regular base64 encoding).\n- send a time/date/timestamp in any [strtotime accepted format](https://www.php.net/manual/en/datetime.formats.php) (it will be converted).\n\nYou may use the config settings \"`sanitation.types`\" and \"`sanitation.tables`\"' to define for which types and\nin which tables you want to apply type sanitation (defaults to 'all'). Example:\n\n    'sanitation.types' => 'date,timestamp',\n    'sanitation.tables' => 'posts,comments',\n\nHere we enable the type sanitation for date and timestamp fields in the posts and comments tables.\n\n### Validating input\n\nBy default all input is accepted and sent to the database. If you want to validate the input in a custom way, \nyou may add the 'validation' middleware and define a 'validation.handler' function that returns a boolean \nindicating whether or not the value is valid.\n\n    'validation.handler' => function ($operation, $tableName, $column, $value, $context) {\n        return ($column['name'] == 'post_id' && !is_numeric($value)) ? 'must be numeric' : true;\n    },\n\nWhen you edit a comment with id 4 using:\n\n    PUT /records/comments/4\n\nAnd you send as a body:\n\n    {\"post_id\":\"two\"}\n\nThen the server will return a '422' HTTP status code and nice error message:\n\n    {\n        \"code\": 1013,\n        \"message\": \"Input validation failed for 'comments'\",\n        \"details\": {\n            \"post_id\":\"must be numeric\"\n        }\n    }\n\nYou can parse this output to make form fields show up with a red border and their appropriate error message.\n\n### Type validations\n\nIf you enable the 'validation' middleware, then you (automatically) also enable type validation. \nThis includes the following error messages:\n\n| error message       | reason                      | applies to types                            |\n| ------------------- | --------------------------- | ------------------------------------------- |\n| cannot be null      | unexpected null value       | (any non-nullable column)                   |\n| illegal whitespace  | leading/trailing whitespace | integer bigint decimal float double boolean |\n| invalid integer     | illegal characters          | integer bigint                              |\n| string too long     | too many characters         | varchar varbinary                           |\n| invalid decimal     | illegal characters          | decimal                                     |\n| decimal too large   | too many digits before dot  | decimal                                     |\n| decimal too precise | too many digits after dot   | decimal                                     |\n| invalid float       | illegal characters          | float double                                |\n| invalid boolean     | use 1, 0, true or false     | boolean                                     |\n| invalid date        | use yyyy-mm-dd              | date                                        |\n| invalid time        | use hh:mm:ss                | time                                        |\n| invalid timestamp   | use yyyy-mm-dd hh:mm:ss     | timestamp                                   |\n| invalid base64      | illegal characters          | varbinary, blob                             |\n\nYou may use the config settings \"`validation.types`\" and \"`validation.tables`\"' to define for which types and\nin which tables you want to apply type validation (defaults to 'all'). Example:\n\n    'validation.types' => 'date,timestamp',\n    'validation.tables' => 'posts,comments',\n\nHere we enable the type validation for date and timestamp fields in the posts and comments tables.\n\nNB: Types that are enabled will be checked for null values when the column is non-nullable.\n\n### Multi-tenancy support\n\nTwo forms of multi-tenancy are supported:\n\n - Single database, where every table has a tenant column (using the \"multiTenancy\" middleware).\n - Multi database, where every tenant has it's own database (using the \"reconnect\" middleware).\n\nBelow is an explanation of the corresponding middlewares.\n\n#### Multi-tenancy middleware\n\nYou may use the \"multiTenancy\" middleware when you have a single multi-tenant database. \nIf your tenants are identified by the \"customer_id\" column, then you can use the following handler:\n\n    'multiTenancy.handler' => function ($operation, $tableName) {\n        return ['customer_id' => 12];\n    },\n\nThis construct adds a filter requiring \"customer_id\" to be \"12\" to every operation (except for \"create\").\nIt also sets the column \"customer_id\" on \"create\" to \"12\" and removes the column from any other write operation.\n\nNB: You may want to retrieve the customer id from the session (the \"$_SESSION\" variable).\n\n#### Reconnect middleware\n\nYou may use the \"reconnect\" middleware when you have a separate database for each tenant.\nIf the tenant has it's own database named \"customer_12\", then you can use the following handler:\n\n    'reconnect.databaseHandler' => function () {\n        return 'customer_12';\n    },\n\nThis will make the API reconnect to the database specifying \"customer_12\" as the database name. If you don't want\nto use the same credentials, then you should also implement the \"usernameHandler\" and \"passwordHandler\".\n\nNB: You may want to retrieve the database name from the session (the \"$_SESSION\" variable).\n\n### Prevent database scraping\n\nYou may use the \"joinLimits\" and \"pageLimits\" middleware to prevent database scraping.\nThe \"joinLimits\" middleware limits the table depth, number of tables and number of records returned in a join operation. \nIf you want to allow 5 direct direct joins with a maximum of 25 records each, you can specify:\n\n    'joinLimits.depth' => 1,\n    'joinLimits.tables' => 5,\n    'joinLimits.records' => 25,\n\nThe \"pageLimits\" middleware limits the page number and the number records returned from a list operation. \nIf you want to allow no more than 10 pages with a maximum of 25 records each, you can specify:\n\n    'pageLimits.pages' => 10,\n    'pageLimits.records' => 25,\n\nNB: The maximum number of records is also applied when there is no page number specified in the request.\n\n### Search all text fields\n\nYou may use the \"textSearch\" middleware to simplify (wildcard) text searches when listing records. \nIt allows you to specify a \"search\" parameter using:\n\n    GET /records/posts?search=Hello\n\nIt will return all records from \"posts\" that contain \"Hello\" in one of their text (typed) fields:\n\n    {\n        \"records\":[\n            {\n                \"id\": 1,\n                \"title\": \"Hello world!\",\n                \"content\": \"Welcome to the first post.\",\n                \"created\": \"2018-03-05T20:12:56Z\"\n            }\n        ]\n    }\n\nThe example searches the fields \"title\" or \"content\" for the substring \"Hello\".\n\n### Customization handlers\n\nYou may use the \"customization\" middleware to modify request and response and implement any other functionality.\n\n    'customization.beforeHandler' => function ($operation, $tableName, $request, $environment) {\n        $environment->start = microtime(true);\n    },\n    'customization.afterHandler' => function ($operation, $tableName, $response, $environment) {\n        return $response->withHeader('X-Time-Taken', microtime(true) - $environment->start);\n    },\n\nThe above example will add a header \"X-Time-Taken\" with the number of seconds the API call has taken.\n\n### JSON encoding options\n\nYou can change the way the JSON is encoded by setting the configuration parameter \"jsonOptions\".\n\n    'jsonOptions' => JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES,\n\nThe above example will set JSON options to 128+256+64 = 448, as per the list of options below:\n\n    JSON_HEX_TAG (1)\n        All < and > are converted to \\u003C and \\u003E. \n    JSON_HEX_AMP (2)\n        All & are converted to \\u0026. \n    JSON_HEX_APOS (4)\n        All ' are converted to \\u0027. \n    JSON_HEX_QUOT (8)\n        All \" are converted to \\u0022. \n    JSON_FORCE_OBJECT (16)\n        Outputs an object rather than an array when a non-associative array is used. \n        Especially useful when the recipient of the output is expecting an object and \n        the array is empty. \n    JSON_NUMERIC_CHECK (32)\n        Encodes numeric strings as numbers. \n    JSON_UNESCAPED_SLASHES (64)\n        Don't escape /. \n    JSON_PRETTY_PRINT (128)\n        Use whitespace in returned data to format it. \n    JSON_UNESCAPED_UNICODE (256)\n        Encode multibyte Unicode characters literally (default is to escape as \\uXXXX). \n    JSON_PARTIAL_OUTPUT_ON_ERROR (512)\n        Substitute some unencodable values instead of failing. \n    JSON_PRESERVE_ZERO_FRACTION (1024)\n        Ensures that float values are always encoded as a float value. \n    JSON_UNESCAPED_LINE_TERMINATORS (2048)\n        The line terminators are kept unescaped when JSON_UNESCAPED_UNICODE is supplied. \n        It uses the same behaviour as it was before PHP 7.1 without this constant. \n        Available as of PHP 7.1.0. \n\nSource: [PHP's JSON constants documentation](https://www.php.net/manual/en/json.constants.php) \n\n### JSON middleware\n\nYou may use the \"json\" middleware to read/write JSON strings as JSON objects and arrays.\n\nJSON strings are automatically detected when the \"json\" middleware is enabled.\n\nYou may limit the scanning of by specifying specific table and/or field names: \n\n    'json.tables' => 'products',\n    'json.columns' => 'properties',\n\nThis will change the output of:\n\n    GET /records/products/1\n\nWithout \"json\" middleware the output will be:\n\n    {\n        \"id\": 1,\n        \"name\": \"Calculator\",\n        \"price\": \"23.01\",\n        \"properties\": \"{\\\"depth\\\":false,\\\"model\\\":\\\"TRX-120\\\",\\\"width\\\":100,\\\"height\\\":null}\",\n    }\n\nWith \"json\" middleware the output will be:\n\n    {\n        \"id\": 1,\n        \"name\": \"Calculator\",\n        \"price\": \"23.01\",\n        \"properties\": {\n            \"depth\": false,\n            \"model\": \"TRX-120\",\n            \"width\": 100,\n            \"height\": null\n        },\n    }\n\nThis also applies when creating or modifying JSON string fields (also when using batch operations).\n\nNote that JSON string fields cannot be partially updated and that this middleware is disabled by default.\nYou can enable the \"json\" middleware using the \"middlewares\" configuration setting.\n\n### XML middleware\n\nYou may use the \"xml\" middleware to translate input and output from JSON to XML. This request:\n\n    GET /records/posts/1\n\nOutputs (when \"pretty printed\"):\n\n    {\n        \"id\": 1,\n        \"user_id\": 1,\n        \"category_id\": 1,\n        \"content\": \"blog started\"\n    }\n\nWhile (note the \"format\" query parameter):\n\n    GET /records/posts/1?format=xml\n\nOutputs:\n\n    <root>\n        <id>1</id>\n        <user_id>1</user_id>\n        <category_id>1</category_id>\n        <content>blog started</content>\n    </root>\n\nThis functionality is disabled by default and must be enabled using the \"middlewares\" configuration setting.\n\n### File uploads\n\nFile uploads are supported through the [FileReader API](https://caniuse.com/#feat=filereader), check out the [example](https://github.com/mevdschee/php-crud-api/blob/master/examples/clients/upload/vanilla.html).\n\n## OpenAPI specification\n\nOn the \"/openapi\" end-point the OpenAPI 3.0 (formerly called \"Swagger\") specification is served. \nIt is a machine readable instant documentation of your API. To learn more, check out these links:\n\n- [Swagger Editor](https://editor.swagger.io/) can be used to view and debug the generated specification.\n- [OpenAPI specification](https://swagger.io/specification/) is a manual for creating an OpenAPI specification.\n- [Swagger Petstore](https://petstore.swagger.io/) is an example documentation that is generated using OpenAPI.\n\n## Cache\n\nThere are 4 cache engines that can be configured by the \"cacheType\" config parameter:\n\n- TempFile (default)\n- Redis\n- Memcache\n- Memcached\n\nYou can install the dependencies for the last three engines by running:\n\n    sudo apt install php-redis redis\n    sudo apt install php-memcache memcached\n    sudo apt install php-memcached memcached\n\nThe default engine has no dependencies and will use temporary files in the system \"temp\" path.\n\nYou may use the \"cachePath\" config parameter to specify the file system path for the temporary files or\nin case that you use a non-default \"cacheType\" the hostname (optionally with port) of the cache server.\n\n## Types\n\nThese are the supported types with their length, category, JSON type and format:\n\n| type       | length | category  | JSON type | format              |\n| ---------- | ------ | --------- | --------- | ------------------- |\n| varchar    | 255    | character | string    |                     |\n| clob       |        | character | string    |                     |\n| boolean    |        | boolean   | boolean   |                     |\n| integer    |        | integer   | number    |                     |\n| bigint     |        | integer   | number    |                     |\n| float      |        | float     | number    |                     |\n| double     |        | float     | number    |                     |\n| decimal    | 19,4   | decimal   | string    |                     |\n| date       |        | date/time | string    | yyyy-mm-dd          | \n| time       |        | date/time | string    | hh:mm:ss            |\n| timestamp  |        | date/time | string    | yyyy-mm-dd hh:mm:ss |\n| varbinary  | 255    | binary    | string    | base64 encoded      |\n| blob       |        | binary    | string    | base64 encoded      |\n| geometry   |        | other     | string    | well-known text     |\n\nNote that geometry is a non-jdbc type and thus has limited support.\n\n## Data types in JavaScript\n\nJavascript and Javascript object notation (JSON) are not very well suited for reading database records. Decimal, date/time, binary and geometry types must be represented as strings in JSON (binary is base64 encoded, geometries are in WKT format). Below are two more serious issues described.\n\n### 64 bit integers\n\nJavaScript does not support 64 bit integers. All numbers are stored as 64 bit floating point values. The mantissa of a 64 bit floating point number is only 53 bit and that is why all integer numbers bigger than 53 bit may cause problems in JavaScript.\n\n### Inf and NaN floats\n\nThe valid floating point values 'Infinite' (calculated with '1/0') and 'Not a Number' (calculated with '0/0') cannot be expressed in JSON, as they are not supported by the [JSON specification](https://www.json.org). When these values are stored in a database then you cannot read them as this script outputs database records as JSON.\n\n## Errors\n\nThe following errors may be reported:\n\n| Error | HTTP response code        | Message\n| ----- | ------------------------- | --------------\n| 1000  | 404 Not found             | Route not found \n| 1001  | 404 Not found             | Table not found \n| 1002  | 422 Unprocessable entity  | Argument count mismatch \n| 1003  | 404 Not found             | Record not found \n| 1004  | 403 Forbidden             | Origin is forbidden \n| 1005  | 404 Not found             | Column not found \n| 1006  | 409 Conflict              | Table already exists \n| 1007  | 409 Conflict              | Column already exists \n| 1008  | 422 Unprocessable entity  | Cannot read HTTP message \n| 1009  | 409 Conflict              | Duplicate key exception \n| 1010  | 409 Conflict              | Data integrity violation \n| 1011  | 401 Unauthorized          | Authentication required \n| 1012  | 403 Forbidden             | Authentication failed \n| 1013  | 422 Unprocessable entity  | Input validation failed \n| 1014  | 403 Forbidden             | Operation forbidden \n| 1015  | 405 Method not allowed    | Operation not supported \n| 1016  | 403 Forbidden             | Temporary or permanently blocked \n| 1017  | 403 Forbidden             | Bad or missing XSRF token \n| 1018  | 403 Forbidden             | Only AJAX requests allowed \n| 1019  | 403 Forbidden             | Pagination Forbidden \n| 1020  | 409 Conflict              | User already exists\n| 1021  | 422 Unprocessable entity  | Password too short\n| 1022  | 422 Unprocessable entity  | Username is empty\n| 1023  | 404 Not found             | Primary key not found\n| 9999  | 500 Internal server error | Unknown error \n\nThe following JSON structure is used:\n\n    {\n        \"code\":1002,\n        \"message\":\"Argument count mismatch in '1'\"\n    }\n\nNB: Any non-error response will have status: 200 OK\n\n## Status\n\nTo connect to your monitoring there is a 'ping' endpoint:\n\n    GET /status/ping\n\nAnd this should return status 200 and as data:\n\n    {\n        \"db\": 42,\n        \"cache\": 9\n    }\n\nThese can be used to measure the time (in microseconds) to connect and read data from the database and the cache.\n\n## Custom controller\n\nYou can add your own custom REST API endpoints by writing your own custom controller class. \nThe class must provide a constructor that accepts five parameters. With these parameters you can register\nyour own endpoint to the existing router. This endpoint may use the database and/or the reflection class\nof the database.\n\nHere is an example of a custom controller class:\n\n```\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Tqdev\\PhpCrudApi\\Cache\\Cache;\nuse Tqdev\\PhpCrudApi\\Column\\ReflectionService;\nuse Tqdev\\PhpCrudApi\\Controller\\Responder;\nuse Tqdev\\PhpCrudApi\\Database\\GenericDB;\nuse Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n\nclass MyHelloController {\n\n    private $responder;\n\n    public function __construct(Router $router, Responder $responder, GenericDB $db, ReflectionService $reflection, Cache $cache)\n    {\n        $router->register('GET', '/hello', array($this, 'getHello'));\n        $this->responder = $responder;\n    }\n\n    public function getHello(ServerRequestInterface $request): ResponseInterface\n    {\n        return $this->responder->success(['message' => \"Hello World!\"]);\n    }\n}\n```\n\nAnd then you may register your custom controller class in the config object like this:\n\n```\n$config = new Config([\n    ...\n    'customControllers' => 'MyHelloController',\n    ...\n]);\n```\n\nThe `customControllers` config supports a comma separated list of custom controller classes.\n\n## Tests\n\nI am testing mainly on Ubuntu and I have the following test setups:\n\n  - (Docker) Debian 10 with PHP 7.3, MariaDB 10.3, PostgreSQL 11.4 (PostGIS 2.5) and SQLite 3.27\n  - (Docker) Debian 11 with PHP 7.4, MariaDB 10.5, PostgreSQL 13.4 (PostGIS 3.1) and SQLite 3.34\n  - (Docker) Debian 12 with PHP 8.2, MariaDB 10.11, PostgreSQL 15.3 (PostGIS 3.3) and SQLite 3.40\n  - (Docker) RockyLinux 8 with PHP 7.2, MariaDB 10.3 and SQLite 3.26\n  - (Docker) RockyLinux 9 with PHP 8.0, MariaDB 10.5 and SQLite 3.34\n  - (Docker) Ubuntu 18.04 with PHP 7.2, MySQL 5.7, PostgreSQL 10.4 (PostGIS 2.4) and SQLite 3.22\n  - (Docker) Ubuntu 20.04 with PHP 7.4, MySQL 8.0, PostgreSQL 12.15 (PostGIS 3.0) and SQLite 3.31 and SQL Server 2019\n  - (Docker) Ubuntu 22.04 with PHP 8.1, MySQL 8.0, PostgreSQL 14.2 (PostGIS 3.2) and SQLite 3.37 \n  - (Docker) Ubuntu 24.04 with PHP 8.3, MySQL 8.0, PostgreSQL 16.2 (PostGIS 3.4) and SQLite 3.45\n\nThis covers not all environments (yet), so please notify me of failing tests and report your environment. \nI will try to cover most relevant setups in the \"docker\" folder of the project.\n\n### Running\n\nTo run the functional tests locally you may run the following commands:\n\n    php build.php\n    php test.php\n\nThis runs the functional tests from the \"tests\" directory. It uses the database dumps (fixtures) and\ndatabase configuration (config) from the corresponding subdirectories.\n\n## Pretty URL\n\nYou may \"rewrite\" the URL to remove the \"api.php\" from the URL.\n\n### Apache config example\n\nEnable mod_rewrite and add the following to your \".htaccess\" file:\n\n```\nRewriteEngine On\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteRule ^(.*)$ api.php/$1 [L,QSA]\n```\n\nThe \".htaccess\" file needs to go in the same folder as \"api.php\".\n\n### Nginx config example\n\nUse the following config to serve the API under Nginx and PHP-FPM:\n\n```\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    root /var/www/html;\n    index index.php index.html index.htm index.nginx-debian.html;\n    server_name server_domain_or_IP;\n\n    location / {\n        try_files $uri $uri/ /api.php?$args;  \n    }\n\n    location ~ [^/]\\.php(/|$) {\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        try_files $fastcgi_script_name =404;\n        set $path_info $fastcgi_path_info;\n        fastcgi_param PATH_INFO $path_info;\n        fastcgi_index index.php;\n        include fastcgi.conf;\n        fastcgi_pass unix:/run/php/php7.0-fpm.sock;\n    }\n\n    location ~ /\\.ht {\n        deny all;\n    }\n}\n```\n\n### Docker tests\n\nInstall docker using the following commands and then logout and login for the changes to take effect:\n\n    sudo apt install docker.io docker-buildx\n    sudo usermod -aG docker ${USER}\n\nTo run the docker tests run \"build_all.sh\" and \"run_all.sh\" from the docker directory. The output should be:\n\n    ================================================\n    Debian 10 (PHP 7.3)\n    ================================================\n    [1/4] Starting MariaDB 10.3 ..... done\n    [2/4] Starting PostgreSQL 11.4 .. done\n    [3/4] Starting SQLServer 2017 ... skipped\n    [4/4] Cloning PHP-CRUD-API v2 ... skipped\n    ------------------------------------------------\n    mysql: 120 tests ran in 921 ms, 1 skipped, 0 failed\n    pgsql: 120 tests ran in 1058 ms, 1 skipped, 0 failed\n    sqlsrv: skipped, driver not loaded\n    sqlite: 120 tests ran in 752 ms, 13 skipped, 0 failed\n    ================================================\n    Debian 11 (PHP 7.4)\n    ================================================\n    [1/4] Starting MariaDB 10.5 ..... done\n    [2/4] Starting PostgreSQL 13.4 .. done\n    [3/4] Starting SQLServer 2017 ... skipped\n    [4/4] Cloning PHP-CRUD-API v2 ... skipped\n    ------------------------------------------------\n    mysql: 120 tests ran in 914 ms, 1 skipped, 0 failed\n    pgsql: 120 tests ran in 997 ms, 1 skipped, 0 failed\n    sqlsrv: skipped, driver not loaded\n    sqlite: 120 tests ran in 735 ms, 13 skipped, 0 failed\n    ================================================\n    Debian 12 (PHP 8.2)\n    ================================================\n    [1/4] Starting MariaDB 10.11 .... done\n    [2/4] Starting PostgreSQL 15.3 .. done\n    [3/4] Starting SQLServer 2019 ... skipped\n    [4/4] Cloning PHP-CRUD-API v2 ... skipped\n    ------------------------------------------------\n    mysql: 120 tests ran in 1016 ms, 1 skipped, 0 failed\n    pgsql: 120 tests ran in 1041 ms, 1 skipped, 0 failed\n    sqlsrv: skipped, driver not loaded\n    sqlite: 120 tests ran in 733 ms, 13 skipped, 0 failed\n    ================================================\n    RockyLinux 8 (PHP 7.2)\n    ================================================\n    [1/4] Starting MariaDB 10.3 ..... done\n    [2/4] Starting PostgreSQL 11 .... skipped\n    [3/4] Starting SQLServer 2017 ... skipped\n    [4/4] Cloning PHP-CRUD-API v2 ... skipped\n    ------------------------------------------------\n    mysql: 120 tests ran in 935 ms, 1 skipped, 0 failed\n    pgsql: skipped, driver not loaded\n    sqlsrv: skipped, driver not loaded\n    sqlite: 120 tests ran in 746 ms, 13 skipped, 0 failed\n    ================================================\n    RockyLinux 9 (PHP 8.0)\n    ================================================\n    [1/4] Starting MariaDB 10.5 ..... done\n    [2/4] Starting PostgreSQL 12 .... skipped\n    [3/4] Starting SQLServer 2017 ... skipped\n    [4/4] Cloning PHP-CRUD-API v2 ... skipped\n    ------------------------------------------------\n    mysql: 120 tests ran in 928 ms, 1 skipped, 0 failed\n    pgsql: skipped, driver not loaded\n    sqlsrv: skipped, driver not loaded\n    sqlite: 120 tests ran in 728 ms, 13 skipped, 0 failed\n    ================================================\n    Ubuntu 18.04 (PHP 7.2)\n    ================================================\n    [1/4] Starting MySQL 5.7 ........ done\n    [2/4] Starting PostgreSQL 10.4 .. done\n    [3/4] Starting SQLServer 2017 ... skipped\n    [4/4] Cloning PHP-CRUD-API v2 ... skipped\n    ------------------------------------------------\n    mysql: 120 tests ran in 1296 ms, 1 skipped, 0 failed\n    pgsql: 120 tests ran in 1056 ms, 1 skipped, 0 failed\n    sqlsrv: skipped, driver not loaded\n    sqlite: 120 tests ran in 772 ms, 13 skipped, 0 failed\n    ================================================\n    Ubuntu 20.04 (PHP 7.4)\n    ================================================\n    [1/4] Starting MySQL 8.0 ........ done\n    [2/4] Starting PostgreSQL 12.2 .. done\n    [3/4] Starting SQLServer 2019 ... done\n    [4/4] Cloning PHP-CRUD-API v2 ... skipped\n    ------------------------------------------------\n    mysql: 120 tests ran in 1375 ms, 1 skipped, 0 failed\n    pgsql: 120 tests ran in 868 ms, 1 skipped, 0 failed\n    sqlsrv: 120 tests ran in 5713 ms, 1 skipped, 0 failed\n    sqlite: 120 tests ran in 733 ms, 13 skipped, 0 failed\n    ================================================\n    Ubuntu 22.04 (PHP 8.1)\n    ================================================\n    [1/4] Starting MySQL 8.0 ........ done\n    [2/4] Starting PostgreSQL 14.2 .. done\n    [3/4] Starting SQLServer 2019 ... skipped\n    [4/4] Cloning PHP-CRUD-API v2 ... skipped\n    ------------------------------------------------\n    mysql: 120 tests ran in 1372 ms, 1 skipped, 0 failed\n    pgsql: 120 tests ran in 1064 ms, 1 skipped, 0 failed\n    sqlsrv: skipped, driver not loaded\n    sqlite: 120 tests ran in 727 ms, 13 skipped, 0 failed\n    ================================================\n    Ubuntu 24.04 (PHP 8.3)\n    ================================================\n    [1/4] Starting MySQL 8. ........ done\n    [2/4] Starting PostgreSQL 16.2 .. done\n    [3/4] Starting SQLServer 2019 ... skipped\n    [4/4] Cloning PHP-CRUD-API v2 ... skipped\n    ------------------------------------------------\n    mysql: 120 tests ran in 1344 ms, 1 skipped, 0 failed\n    pgsql: 120 tests ran in 856 ms, 1 skipped, 0 failed\n    sqlsrv: skipped, driver not loaded\n    sqlite: 120 tests ran in 722 ms, 13 skipped, 0 failed\n\nThe above test run (including starting up the databases) takes less than 5 minutes on my slow laptop.\n\n    $ ./run.sh\n    1) debian10\n    2) debian11\n    3) debian12\n    4) rockylinux8\n    5) rockylinux9\n    6) ubuntu18\n    7) ubuntu20\n    8) ubuntu22\n    > 6\n    ================================================\n    Ubuntu 18.04 (PHP 7.2)\n    ================================================\n    [1/4] Starting MySQL 5.7 ........ done\n    [2/4] Starting PostgreSQL 10.4 .. done\n    [3/4] Starting SQLServer 2017 ... skipped\n    [4/4] Cloning PHP-CRUD-API v2 ... skipped\n    ------------------------------------------------\n    mysql: 120 tests ran in 1296 ms, 1 skipped, 0 failed\n    pgsql: 120 tests ran in 1056 ms, 1 skipped, 0 failed\n    sqlsrv: skipped, driver not loaded\n    sqlite: 120 tests ran in 772 ms, 13 skipped, 0 failed\n    root@b7ab9472e08f:/php-crud-api# \n\nAs you can see the \"run.sh\" script gives you access to a prompt in the chosen docker environment.\nIn this environment the local files are mounted. This allows for easy debugging on different environments.\nYou may type \"exit\" when you are done.\n\n### Docker image\n\nThere is a `Dockerfile` in the repository that is used to build an image at:\n\n[https://hub.docker.com/r/mevdschee/php-crud-api](https://hub.docker.com/r/mevdschee/php-crud-api)\n\nIt will be automatically build on every release. The \"latest\" tag points to the last release.\n\nThe docker image accepts the environment variable parameters from the configuration.\n\n### Docker compose\n\nThis repository also contains a `docker-compose.yml` file that you can install/build/run using:\n\n    sudo apt install docker-compose\n    docker-compose build\n    docker-compose up\n\nThis will setup a database (MySQL) and a webserver (Apache) and runs the application using the blog example data used in the tests.\n\nTest the script (running in the container) by opening the following URL:\n\n    http://localhost:8080/records/posts/1\n\n### Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=mevdschee/php-crud-api&type=Date)](https://star-history.com/#mevdschee/php-crud-api&Date)\n\nEnjoy!\n"
        },
        {
          "name": "api.include.php",
          "type": "blob",
          "size": 481.734375,
          "content": "<?php\n/**\n * PHP-CRUD-API v2              License: MIT\n * Maurits van der Schee: maurits@vdschee.nl\n * https://github.com/mevdschee/php-crud-api\n *\n * Dependencies:\n * - vendor/psr/*: PHP-FIG\n *   https://github.com/php-fig\n * - vendor/nyholm/*: Tobias Nyholm\n *   https://github.com/Nyholm\n **/\n\n// file: vendor/psr/http-factory/src/RequestFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface RequestFactoryInterface\n    {\n        /**\n         * Create a new request.\n         *\n         * @param string $method The HTTP method associated with the request.\n         * @param UriInterface|string $uri The URI associated with the request. If\n         *     the value is a string, the factory MUST create a UriInterface\n         *     instance based on it.\n         *\n         * @return RequestInterface\n         */\n        public function createRequest(string $method, $uri): RequestInterface;\n    }\n}\n\n// file: vendor/psr/http-factory/src/ResponseFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface ResponseFactoryInterface\n    {\n        /**\n         * Create a new response.\n         *\n         * @param int $code HTTP status code; defaults to 200\n         * @param string $reasonPhrase Reason phrase to associate with status code\n         *     in generated response; if none is provided implementations MAY use\n         *     the defaults as suggested in the HTTP specification.\n         *\n         * @return ResponseInterface\n         */\n        public function createResponse(int $code = 200, string $reasonPhrase = ''): ResponseInterface;\n    }\n}\n\n// file: vendor/psr/http-factory/src/ServerRequestFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface ServerRequestFactoryInterface\n    {\n        /**\n         * Create a new server request.\n         *\n         * Note that server-params are taken precisely as given - no parsing/processing\n         * of the given values is performed, and, in particular, no attempt is made to\n         * determine the HTTP method or URI, which must be provided explicitly.\n         *\n         * @param string $method The HTTP method associated with the request.\n         * @param UriInterface|string $uri The URI associated with the request. If\n         *     the value is a string, the factory MUST create a UriInterface\n         *     instance based on it.\n         * @param array $serverParams Array of SAPI parameters with which to seed\n         *     the generated request instance.\n         *\n         * @return ServerRequestInterface\n         */\n        public function createServerRequest(string $method, $uri, array $serverParams = []): ServerRequestInterface;\n    }\n}\n\n// file: vendor/psr/http-factory/src/StreamFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface StreamFactoryInterface\n    {\n        /**\n         * Create a new stream from a string.\n         *\n         * The stream SHOULD be created with a temporary resource.\n         *\n         * @param string $content String content with which to populate the stream.\n         *\n         * @return StreamInterface\n         */\n        public function createStream(string $content = ''): StreamInterface;\n\n        /**\n         * Create a stream from an existing file.\n         *\n         * The file MUST be opened using the given mode, which may be any mode\n         * supported by the `fopen` function.\n         *\n         * The `$filename` MAY be any string supported by `fopen()`.\n         *\n         * @param string $filename Filename or stream URI to use as basis of stream.\n         * @param string $mode Mode with which to open the underlying filename/stream.\n         *\n         * @return StreamInterface\n         * @throws \\RuntimeException If the file cannot be opened.\n         * @throws \\InvalidArgumentException If the mode is invalid.\n         */\n        public function createStreamFromFile(string $filename, string $mode = 'r'): StreamInterface;\n\n        /**\n         * Create a new stream from an existing resource.\n         *\n         * The stream MUST be readable and may be writable.\n         *\n         * @param resource $resource PHP resource to use as basis of stream.\n         *\n         * @return StreamInterface\n         */\n        public function createStreamFromResource($resource): StreamInterface;\n    }\n}\n\n// file: vendor/psr/http-factory/src/UploadedFileFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface UploadedFileFactoryInterface\n    {\n        /**\n         * Create a new uploaded file.\n         *\n         * If a size is not provided it will be determined by checking the size of\n         * the file.\n         *\n         * @see http://php.net/manual/features.file-upload.post-method.php\n         * @see http://php.net/manual/features.file-upload.errors.php\n         *\n         * @param StreamInterface $stream Underlying stream representing the\n         *     uploaded file content.\n         * @param int|null $size in bytes\n         * @param int $error PHP file upload error\n         * @param string|null $clientFilename Filename as provided by the client, if any.\n         * @param string|null $clientMediaType Media type as provided by the client, if any.\n         *\n         * @return UploadedFileInterface\n         *\n         * @throws \\InvalidArgumentException If the file resource is not readable.\n         */\n        public function createUploadedFile(\n            StreamInterface $stream,\n            ?int $size = null,\n            int $error = \\UPLOAD_ERR_OK,\n            ?string $clientFilename = null,\n            ?string $clientMediaType = null\n        ): UploadedFileInterface;\n    }\n}\n\n// file: vendor/psr/http-factory/src/UriFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface UriFactoryInterface\n    {\n        /**\n         * Create a new URI.\n         *\n         * @param string $uri\n         *\n         * @return UriInterface\n         *\n         * @throws \\InvalidArgumentException If the given URI cannot be parsed.\n         */\n        public function createUri(string $uri = ''): UriInterface;\n    }\n}\n\n// file: vendor/psr/http-message/src/MessageInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * HTTP messages consist of requests from a client to a server and responses\n     * from a server to a client. This interface defines the methods common to\n     * each.\n     *\n     * Messages are considered immutable; all methods that might change state MUST\n     * be implemented such that they retain the internal state of the current\n     * message and return an instance that contains the changed state.\n     *\n     * @link http://www.ietf.org/rfc/rfc7230.txt\n     * @link http://www.ietf.org/rfc/rfc7231.txt\n     */\n    interface MessageInterface\n    {\n        /**\n         * Retrieves the HTTP protocol version as a string.\n         *\n         * The string MUST contain only the HTTP version number (e.g., \"1.1\", \"1.0\").\n         *\n         * @return string HTTP protocol version.\n         */\n        public function getProtocolVersion(): string;\n\n        /**\n         * Return an instance with the specified HTTP protocol version.\n         *\n         * The version string MUST contain only the HTTP version number (e.g.,\n         * \"1.1\", \"1.0\").\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * new protocol version.\n         *\n         * @param string $version HTTP protocol version\n         * @return static\n         */\n        public function withProtocolVersion(string $version): MessageInterface;\n\n        /**\n         * Retrieves all message header values.\n         *\n         * The keys represent the header name as it will be sent over the wire, and\n         * each value is an array of strings associated with the header.\n         *\n         *     // Represent the headers as a string\n         *     foreach ($message->getHeaders() as $name => $values) {\n         *         echo $name . \": \" . implode(\", \", $values);\n         *     }\n         *\n         *     // Emit headers iteratively:\n         *     foreach ($message->getHeaders() as $name => $values) {\n         *         foreach ($values as $value) {\n         *             header(sprintf('%s: %s', $name, $value), false);\n         *         }\n         *     }\n         *\n         * While header names are not case-sensitive, getHeaders() will preserve the\n         * exact case in which headers were originally specified.\n         *\n         * @return string[][] Returns an associative array of the message's headers. Each\n         *     key MUST be a header name, and each value MUST be an array of strings\n         *     for that header.\n         */\n        public function getHeaders(): array;\n\n        /**\n         * Checks if a header exists by the given case-insensitive name.\n         *\n         * @param string $name Case-insensitive header field name.\n         * @return bool Returns true if any header names match the given header\n         *     name using a case-insensitive string comparison. Returns false if\n         *     no matching header name is found in the message.\n         */\n        public function hasHeader(string $name): bool;\n\n        /**\n         * Retrieves a message header value by the given case-insensitive name.\n         *\n         * This method returns an array of all the header values of the given\n         * case-insensitive header name.\n         *\n         * If the header does not appear in the message, this method MUST return an\n         * empty array.\n         *\n         * @param string $name Case-insensitive header field name.\n         * @return string[] An array of string values as provided for the given\n         *    header. If the header does not appear in the message, this method MUST\n         *    return an empty array.\n         */\n        public function getHeader(string $name): array;\n\n        /**\n         * Retrieves a comma-separated string of the values for a single header.\n         *\n         * This method returns all of the header values of the given\n         * case-insensitive header name as a string concatenated together using\n         * a comma.\n         *\n         * NOTE: Not all header values may be appropriately represented using\n         * comma concatenation. For such headers, use getHeader() instead\n         * and supply your own delimiter when concatenating.\n         *\n         * If the header does not appear in the message, this method MUST return\n         * an empty string.\n         *\n         * @param string $name Case-insensitive header field name.\n         * @return string A string of values as provided for the given header\n         *    concatenated together using a comma. If the header does not appear in\n         *    the message, this method MUST return an empty string.\n         */\n        public function getHeaderLine(string $name): string;\n\n        /**\n         * Return an instance with the provided value replacing the specified header.\n         *\n         * While header names are case-insensitive, the casing of the header will\n         * be preserved by this function, and returned from getHeaders().\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * new and/or updated header and value.\n         *\n         * @param string $name Case-insensitive header field name.\n         * @param string|string[] $value Header value(s).\n         * @return static\n         * @throws \\InvalidArgumentException for invalid header names or values.\n         */\n        public function withHeader(string $name, $value): MessageInterface;\n\n        /**\n         * Return an instance with the specified header appended with the given value.\n         *\n         * Existing values for the specified header will be maintained. The new\n         * value(s) will be appended to the existing list. If the header did not\n         * exist previously, it will be added.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * new header and/or value.\n         *\n         * @param string $name Case-insensitive header field name to add.\n         * @param string|string[] $value Header value(s).\n         * @return static\n         * @throws \\InvalidArgumentException for invalid header names or values.\n         */\n        public function withAddedHeader(string $name, $value): MessageInterface;\n\n        /**\n         * Return an instance without the specified header.\n         *\n         * Header resolution MUST be done without case-sensitivity.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that removes\n         * the named header.\n         *\n         * @param string $name Case-insensitive header field name to remove.\n         * @return static\n         */\n        public function withoutHeader(string $name): MessageInterface;\n\n        /**\n         * Gets the body of the message.\n         *\n         * @return StreamInterface Returns the body as a stream.\n         */\n        public function getBody(): StreamInterface;\n\n        /**\n         * Return an instance with the specified message body.\n         *\n         * The body MUST be a StreamInterface object.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return a new instance that has the\n         * new body stream.\n         *\n         * @param StreamInterface $body Body.\n         * @return static\n         * @throws \\InvalidArgumentException When the body is not valid.\n         */\n        public function withBody(StreamInterface $body): MessageInterface;\n    }\n}\n\n// file: vendor/psr/http-message/src/RequestInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Representation of an outgoing, client-side request.\n     *\n     * Per the HTTP specification, this interface includes properties for\n     * each of the following:\n     *\n     * - Protocol version\n     * - HTTP method\n     * - URI\n     * - Headers\n     * - Message body\n     *\n     * During construction, implementations MUST attempt to set the Host header from\n     * a provided URI if no Host header is provided.\n     *\n     * Requests are considered immutable; all methods that might change state MUST\n     * be implemented such that they retain the internal state of the current\n     * message and return an instance that contains the changed state.\n     */\n    interface RequestInterface extends MessageInterface\n    {\n        /**\n         * Retrieves the message's request target.\n         *\n         * Retrieves the message's request-target either as it will appear (for\n         * clients), as it appeared at request (for servers), or as it was\n         * specified for the instance (see withRequestTarget()).\n         *\n         * In most cases, this will be the origin-form of the composed URI,\n         * unless a value was provided to the concrete implementation (see\n         * withRequestTarget() below).\n         *\n         * If no URI is available, and no request-target has been specifically\n         * provided, this method MUST return the string \"/\".\n         *\n         * @return string\n         */\n        public function getRequestTarget(): string;\n\n        /**\n         * Return an instance with the specific request-target.\n         *\n         * If the request needs a non-origin-form request-target — e.g., for\n         * specifying an absolute-form, authority-form, or asterisk-form —\n         * this method may be used to create an instance with the specified\n         * request-target, verbatim.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * changed request target.\n         *\n         * @link http://tools.ietf.org/html/rfc7230#section-5.3 (for the various\n         *     request-target forms allowed in request messages)\n         * @param string $requestTarget\n         * @return static\n         */\n        public function withRequestTarget(string $requestTarget): RequestInterface;\n\n        /**\n         * Retrieves the HTTP method of the request.\n         *\n         * @return string Returns the request method.\n         */\n        public function getMethod(): string;\n\n        /**\n         * Return an instance with the provided HTTP method.\n         *\n         * While HTTP method names are typically all uppercase characters, HTTP\n         * method names are case-sensitive and thus implementations SHOULD NOT\n         * modify the given string.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * changed request method.\n         *\n         * @param string $method Case-sensitive method.\n         * @return static\n         * @throws \\InvalidArgumentException for invalid HTTP methods.\n         */\n        public function withMethod(string $method): RequestInterface;\n\n        /**\n         * Retrieves the URI instance.\n         *\n         * This method MUST return a UriInterface instance.\n         *\n         * @link http://tools.ietf.org/html/rfc3986#section-4.3\n         * @return UriInterface Returns a UriInterface instance\n         *     representing the URI of the request.\n         */\n        public function getUri(): UriInterface;\n\n        /**\n         * Returns an instance with the provided URI.\n         *\n         * This method MUST update the Host header of the returned request by\n         * default if the URI contains a host component. If the URI does not\n         * contain a host component, any pre-existing Host header MUST be carried\n         * over to the returned request.\n         *\n         * You can opt-in to preserving the original state of the Host header by\n         * setting `$preserveHost` to `true`. When `$preserveHost` is set to\n         * `true`, this method interacts with the Host header in the following ways:\n         *\n         * - If the Host header is missing or empty, and the new URI contains\n         *   a host component, this method MUST update the Host header in the returned\n         *   request.\n         * - If the Host header is missing or empty, and the new URI does not contain a\n         *   host component, this method MUST NOT update the Host header in the returned\n         *   request.\n         * - If a Host header is present and non-empty, this method MUST NOT update\n         *   the Host header in the returned request.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * new UriInterface instance.\n         *\n         * @link http://tools.ietf.org/html/rfc3986#section-4.3\n         * @param UriInterface $uri New request URI to use.\n         * @param bool $preserveHost Preserve the original state of the Host header.\n         * @return static\n         */\n        public function withUri(UriInterface $uri, bool $preserveHost = false): RequestInterface;\n    }\n}\n\n// file: vendor/psr/http-message/src/ResponseInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Representation of an outgoing, server-side response.\n     *\n     * Per the HTTP specification, this interface includes properties for\n     * each of the following:\n     *\n     * - Protocol version\n     * - Status code and reason phrase\n     * - Headers\n     * - Message body\n     *\n     * Responses are considered immutable; all methods that might change state MUST\n     * be implemented such that they retain the internal state of the current\n     * message and return an instance that contains the changed state.\n     */\n    interface ResponseInterface extends MessageInterface\n    {\n        /**\n         * Gets the response status code.\n         *\n         * The status code is a 3-digit integer result code of the server's attempt\n         * to understand and satisfy the request.\n         *\n         * @return int Status code.\n         */\n        public function getStatusCode(): int;\n\n        /**\n         * Return an instance with the specified status code and, optionally, reason phrase.\n         *\n         * If no reason phrase is specified, implementations MAY choose to default\n         * to the RFC 7231 or IANA recommended reason phrase for the response's\n         * status code.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated status and reason phrase.\n         *\n         * @link http://tools.ietf.org/html/rfc7231#section-6\n         * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n         * @param int $code The 3-digit integer result code to set.\n         * @param string $reasonPhrase The reason phrase to use with the\n         *     provided status code; if none is provided, implementations MAY\n         *     use the defaults as suggested in the HTTP specification.\n         * @return static\n         * @throws \\InvalidArgumentException For invalid status code arguments.\n         */\n        public function withStatus(int $code, string $reasonPhrase = ''): ResponseInterface;\n\n        /**\n         * Gets the response reason phrase associated with the status code.\n         *\n         * Because a reason phrase is not a required element in a response\n         * status line, the reason phrase value MAY be null. Implementations MAY\n         * choose to return the default RFC 7231 recommended reason phrase (or those\n         * listed in the IANA HTTP Status Code Registry) for the response's\n         * status code.\n         *\n         * @link http://tools.ietf.org/html/rfc7231#section-6\n         * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n         * @return string Reason phrase; must return an empty string if none present.\n         */\n        public function getReasonPhrase(): string;\n    }\n}\n\n// file: vendor/psr/http-message/src/ServerRequestInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Representation of an incoming, server-side HTTP request.\n     *\n     * Per the HTTP specification, this interface includes properties for\n     * each of the following:\n     *\n     * - Protocol version\n     * - HTTP method\n     * - URI\n     * - Headers\n     * - Message body\n     *\n     * Additionally, it encapsulates all data as it has arrived to the\n     * application from the CGI and/or PHP environment, including:\n     *\n     * - The values represented in $_SERVER.\n     * - Any cookies provided (generally via $_COOKIE)\n     * - Query string arguments (generally via $_GET, or as parsed via parse_str())\n     * - Upload files, if any (as represented by $_FILES)\n     * - Deserialized body parameters (generally from $_POST)\n     *\n     * $_SERVER values MUST be treated as immutable, as they represent application\n     * state at the time of request; as such, no methods are provided to allow\n     * modification of those values. The other values provide such methods, as they\n     * can be restored from $_SERVER or the request body, and may need treatment\n     * during the application (e.g., body parameters may be deserialized based on\n     * content type).\n     *\n     * Additionally, this interface recognizes the utility of introspecting a\n     * request to derive and match additional parameters (e.g., via URI path\n     * matching, decrypting cookie values, deserializing non-form-encoded body\n     * content, matching authorization headers to users, etc). These parameters\n     * are stored in an \"attributes\" property.\n     *\n     * Requests are considered immutable; all methods that might change state MUST\n     * be implemented such that they retain the internal state of the current\n     * message and return an instance that contains the changed state.\n     */\n    interface ServerRequestInterface extends RequestInterface\n    {\n        /**\n         * Retrieve server parameters.\n         *\n         * Retrieves data related to the incoming request environment,\n         * typically derived from PHP's $_SERVER superglobal. The data IS NOT\n         * REQUIRED to originate from $_SERVER.\n         *\n         * @return array\n         */\n        public function getServerParams(): array;\n\n        /**\n         * Retrieve cookies.\n         *\n         * Retrieves cookies sent by the client to the server.\n         *\n         * The data MUST be compatible with the structure of the $_COOKIE\n         * superglobal.\n         *\n         * @return array\n         */\n        public function getCookieParams(): array;\n\n        /**\n         * Return an instance with the specified cookies.\n         *\n         * The data IS NOT REQUIRED to come from the $_COOKIE superglobal, but MUST\n         * be compatible with the structure of $_COOKIE. Typically, this data will\n         * be injected at instantiation.\n         *\n         * This method MUST NOT update the related Cookie header of the request\n         * instance, nor related values in the server params.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated cookie values.\n         *\n         * @param array $cookies Array of key/value pairs representing cookies.\n         * @return static\n         */\n        public function withCookieParams(array $cookies): ServerRequestInterface;\n\n        /**\n         * Retrieve query string arguments.\n         *\n         * Retrieves the deserialized query string arguments, if any.\n         *\n         * Note: the query params might not be in sync with the URI or server\n         * params. If you need to ensure you are only getting the original\n         * values, you may need to parse the query string from `getUri()->getQuery()`\n         * or from the `QUERY_STRING` server param.\n         *\n         * @return array\n         */\n        public function getQueryParams(): array;\n\n        /**\n         * Return an instance with the specified query string arguments.\n         *\n         * These values SHOULD remain immutable over the course of the incoming\n         * request. They MAY be injected during instantiation, such as from PHP's\n         * $_GET superglobal, or MAY be derived from some other value such as the\n         * URI. In cases where the arguments are parsed from the URI, the data\n         * MUST be compatible with what PHP's parse_str() would return for\n         * purposes of how duplicate query parameters are handled, and how nested\n         * sets are handled.\n         *\n         * Setting query string arguments MUST NOT change the URI stored by the\n         * request, nor the values in the server params.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated query string arguments.\n         *\n         * @param array $query Array of query string arguments, typically from\n         *     $_GET.\n         * @return static\n         */\n        public function withQueryParams(array $query): ServerRequestInterface;\n\n        /**\n         * Retrieve normalized file upload data.\n         *\n         * This method returns upload metadata in a normalized tree, with each leaf\n         * an instance of Psr\\Http\\Message\\UploadedFileInterface.\n         *\n         * These values MAY be prepared from $_FILES or the message body during\n         * instantiation, or MAY be injected via withUploadedFiles().\n         *\n         * @return array An array tree of UploadedFileInterface instances; an empty\n         *     array MUST be returned if no data is present.\n         */\n        public function getUploadedFiles(): array;\n\n        /**\n         * Create a new instance with the specified uploaded files.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated body parameters.\n         *\n         * @param array $uploadedFiles An array tree of UploadedFileInterface instances.\n         * @return static\n         * @throws \\InvalidArgumentException if an invalid structure is provided.\n         */\n        public function withUploadedFiles(array $uploadedFiles): ServerRequestInterface;\n\n        /**\n         * Retrieve any parameters provided in the request body.\n         *\n         * If the request Content-Type is either application/x-www-form-urlencoded\n         * or multipart/form-data, and the request method is POST, this method MUST\n         * return the contents of $_POST.\n         *\n         * Otherwise, this method may return any results of deserializing\n         * the request body content; as parsing returns structured content, the\n         * potential types MUST be arrays or objects only. A null value indicates\n         * the absence of body content.\n         *\n         * @return null|array|object The deserialized body parameters, if any.\n         *     These will typically be an array or object.\n         */\n        public function getParsedBody();\n\n        /**\n         * Return an instance with the specified body parameters.\n         *\n         * These MAY be injected during instantiation.\n         *\n         * If the request Content-Type is either application/x-www-form-urlencoded\n         * or multipart/form-data, and the request method is POST, use this method\n         * ONLY to inject the contents of $_POST.\n         *\n         * The data IS NOT REQUIRED to come from $_POST, but MUST be the results of\n         * deserializing the request body content. Deserialization/parsing returns\n         * structured data, and, as such, this method ONLY accepts arrays or objects,\n         * or a null value if nothing was available to parse.\n         *\n         * As an example, if content negotiation determines that the request data\n         * is a JSON payload, this method could be used to create a request\n         * instance with the deserialized parameters.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated body parameters.\n         *\n         * @param null|array|object $data The deserialized body data. This will\n         *     typically be in an array or object.\n         * @return static\n         * @throws \\InvalidArgumentException if an unsupported argument type is\n         *     provided.\n         */\n        public function withParsedBody($data): ServerRequestInterface;\n\n        /**\n         * Retrieve attributes derived from the request.\n         *\n         * The request \"attributes\" may be used to allow injection of any\n         * parameters derived from the request: e.g., the results of path\n         * match operations; the results of decrypting cookies; the results of\n         * deserializing non-form-encoded message bodies; etc. Attributes\n         * will be application and request specific, and CAN be mutable.\n         *\n         * @return array Attributes derived from the request.\n         */\n        public function getAttributes(): array;\n\n        /**\n         * Retrieve a single derived request attribute.\n         *\n         * Retrieves a single derived request attribute as described in\n         * getAttributes(). If the attribute has not been previously set, returns\n         * the default value as provided.\n         *\n         * This method obviates the need for a hasAttribute() method, as it allows\n         * specifying a default value to return if the attribute is not found.\n         *\n         * @see getAttributes()\n         * @param string $name The attribute name.\n         * @param mixed $default Default value to return if the attribute does not exist.\n         * @return mixed\n         */\n        public function getAttribute(string $name, $default = null);\n\n        /**\n         * Return an instance with the specified derived request attribute.\n         *\n         * This method allows setting a single derived request attribute as\n         * described in getAttributes().\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated attribute.\n         *\n         * @see getAttributes()\n         * @param string $name The attribute name.\n         * @param mixed $value The value of the attribute.\n         * @return static\n         */\n        public function withAttribute(string $name, $value): ServerRequestInterface;\n\n        /**\n         * Return an instance that removes the specified derived request attribute.\n         *\n         * This method allows removing a single derived request attribute as\n         * described in getAttributes().\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that removes\n         * the attribute.\n         *\n         * @see getAttributes()\n         * @param string $name The attribute name.\n         * @return static\n         */\n        public function withoutAttribute(string $name): ServerRequestInterface;\n    }\n}\n\n// file: vendor/psr/http-message/src/StreamInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Describes a data stream.\n     *\n     * Typically, an instance will wrap a PHP stream; this interface provides\n     * a wrapper around the most common operations, including serialization of\n     * the entire stream to a string.\n     */\n    interface StreamInterface\n    {\n        /**\n         * Reads all data from the stream into a string, from the beginning to end.\n         *\n         * This method MUST attempt to seek to the beginning of the stream before\n         * reading data and read the stream until the end is reached.\n         *\n         * Warning: This could attempt to load a large amount of data into memory.\n         *\n         * This method MUST NOT raise an exception in order to conform with PHP's\n         * string casting operations.\n         *\n         * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring\n         * @return string\n         */\n        public function __toString(): string;\n\n        /**\n         * Closes the stream and any underlying resources.\n         *\n         * @return void\n         */\n        public function close(): void;\n\n        /**\n         * Separates any underlying resources from the stream.\n         *\n         * After the stream has been detached, the stream is in an unusable state.\n         *\n         * @return resource|null Underlying PHP stream, if any\n         */\n        public function detach();\n\n        /**\n         * Get the size of the stream if known.\n         *\n         * @return int|null Returns the size in bytes if known, or null if unknown.\n         */\n        public function getSize(): ?int;\n\n        /**\n         * Returns the current position of the file read/write pointer\n         *\n         * @return int Position of the file pointer\n         * @throws \\RuntimeException on error.\n         */\n        public function tell(): int;\n\n        /**\n         * Returns true if the stream is at the end of the stream.\n         *\n         * @return bool\n         */\n        public function eof(): bool;\n\n        /**\n         * Returns whether or not the stream is seekable.\n         *\n         * @return bool\n         */\n        public function isSeekable(): bool;\n\n        /**\n         * Seek to a position in the stream.\n         *\n         * @link http://www.php.net/manual/en/function.fseek.php\n         * @param int $offset Stream offset\n         * @param int $whence Specifies how the cursor position will be calculated\n         *     based on the seek offset. Valid values are identical to the built-in\n         *     PHP $whence values for `fseek()`.  SEEK_SET: Set position equal to\n         *     offset bytes SEEK_CUR: Set position to current location plus offset\n         *     SEEK_END: Set position to end-of-stream plus offset.\n         * @throws \\RuntimeException on failure.\n         */\n        public function seek(int $offset, int $whence = SEEK_SET): void;\n\n        /**\n         * Seek to the beginning of the stream.\n         *\n         * If the stream is not seekable, this method will raise an exception;\n         * otherwise, it will perform a seek(0).\n         *\n         * @see seek()\n         * @link http://www.php.net/manual/en/function.fseek.php\n         * @throws \\RuntimeException on failure.\n         */\n        public function rewind(): void;\n\n        /**\n         * Returns whether or not the stream is writable.\n         *\n         * @return bool\n         */\n        public function isWritable(): bool;\n\n        /**\n         * Write data to the stream.\n         *\n         * @param string $string The string that is to be written.\n         * @return int Returns the number of bytes written to the stream.\n         * @throws \\RuntimeException on failure.\n         */\n        public function write(string $string): int;\n\n        /**\n         * Returns whether or not the stream is readable.\n         *\n         * @return bool\n         */\n        public function isReadable(): bool;\n\n        /**\n         * Read data from the stream.\n         *\n         * @param int $length Read up to $length bytes from the object and return\n         *     them. Fewer than $length bytes may be returned if underlying stream\n         *     call returns fewer bytes.\n         * @return string Returns the data read from the stream, or an empty string\n         *     if no bytes are available.\n         * @throws \\RuntimeException if an error occurs.\n         */\n        public function read(int $length): string;\n\n        /**\n         * Returns the remaining contents in a string\n         *\n         * @return string\n         * @throws \\RuntimeException if unable to read or an error occurs while\n         *     reading.\n         */\n        public function getContents(): string;\n\n        /**\n         * Get stream metadata as an associative array or retrieve a specific key.\n         *\n         * The keys returned are identical to the keys returned from PHP's\n         * stream_get_meta_data() function.\n         *\n         * @link http://php.net/manual/en/function.stream-get-meta-data.php\n         * @param string|null $key Specific metadata to retrieve.\n         * @return array|mixed|null Returns an associative array if no key is\n         *     provided. Returns a specific key value if a key is provided and the\n         *     value is found, or null if the key is not found.\n         */\n        public function getMetadata(?string $key = null);\n    }\n}\n\n// file: vendor/psr/http-message/src/UploadedFileInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Value object representing a file uploaded through an HTTP request.\n     *\n     * Instances of this interface are considered immutable; all methods that\n     * might change state MUST be implemented such that they retain the internal\n     * state of the current instance and return an instance that contains the\n     * changed state.\n     */\n    interface UploadedFileInterface\n    {\n        /**\n         * Retrieve a stream representing the uploaded file.\n         *\n         * This method MUST return a StreamInterface instance, representing the\n         * uploaded file. The purpose of this method is to allow utilizing native PHP\n         * stream functionality to manipulate the file upload, such as\n         * stream_copy_to_stream() (though the result will need to be decorated in a\n         * native PHP stream wrapper to work with such functions).\n         *\n         * If the moveTo() method has been called previously, this method MUST raise\n         * an exception.\n         *\n         * @return StreamInterface Stream representation of the uploaded file.\n         * @throws \\RuntimeException in cases when no stream is available or can be\n         *     created.\n         */\n        public function getStream(): StreamInterface;\n\n        /**\n         * Move the uploaded file to a new location.\n         *\n         * Use this method as an alternative to move_uploaded_file(). This method is\n         * guaranteed to work in both SAPI and non-SAPI environments.\n         * Implementations must determine which environment they are in, and use the\n         * appropriate method (move_uploaded_file(), rename(), or a stream\n         * operation) to perform the operation.\n         *\n         * $targetPath may be an absolute path, or a relative path. If it is a\n         * relative path, resolution should be the same as used by PHP's rename()\n         * function.\n         *\n         * The original file or stream MUST be removed on completion.\n         *\n         * If this method is called more than once, any subsequent calls MUST raise\n         * an exception.\n         *\n         * When used in an SAPI environment where $_FILES is populated, when writing\n         * files via moveTo(), is_uploaded_file() and move_uploaded_file() SHOULD be\n         * used to ensure permissions and upload status are verified correctly.\n         *\n         * If you wish to move to a stream, use getStream(), as SAPI operations\n         * cannot guarantee writing to stream destinations.\n         *\n         * @see http://php.net/is_uploaded_file\n         * @see http://php.net/move_uploaded_file\n         * @param string $targetPath Path to which to move the uploaded file.\n         * @throws \\InvalidArgumentException if the $targetPath specified is invalid.\n         * @throws \\RuntimeException on any error during the move operation, or on\n         *     the second or subsequent call to the method.\n         */\n        public function moveTo(string $targetPath): void;\n        \n        /**\n         * Retrieve the file size.\n         *\n         * Implementations SHOULD return the value stored in the \"size\" key of\n         * the file in the $_FILES array if available, as PHP calculates this based\n         * on the actual size transmitted.\n         *\n         * @return int|null The file size in bytes or null if unknown.\n         */\n        public function getSize(): ?int;\n        \n        /**\n         * Retrieve the error associated with the uploaded file.\n         *\n         * The return value MUST be one of PHP's UPLOAD_ERR_XXX constants.\n         *\n         * If the file was uploaded successfully, this method MUST return\n         * UPLOAD_ERR_OK.\n         *\n         * Implementations SHOULD return the value stored in the \"error\" key of\n         * the file in the $_FILES array.\n         *\n         * @see http://php.net/manual/en/features.file-upload.errors.php\n         * @return int One of PHP's UPLOAD_ERR_XXX constants.\n         */\n        public function getError(): int;\n        \n        /**\n         * Retrieve the filename sent by the client.\n         *\n         * Do not trust the value returned by this method. A client could send\n         * a malicious filename with the intention to corrupt or hack your\n         * application.\n         *\n         * Implementations SHOULD return the value stored in the \"name\" key of\n         * the file in the $_FILES array.\n         *\n         * @return string|null The filename sent by the client or null if none\n         *     was provided.\n         */\n        public function getClientFilename(): ?string;\n        \n        /**\n         * Retrieve the media type sent by the client.\n         *\n         * Do not trust the value returned by this method. A client could send\n         * a malicious media type with the intention to corrupt or hack your\n         * application.\n         *\n         * Implementations SHOULD return the value stored in the \"type\" key of\n         * the file in the $_FILES array.\n         *\n         * @return string|null The media type sent by the client or null if none\n         *     was provided.\n         */\n        public function getClientMediaType(): ?string;\n    }\n}\n\n// file: vendor/psr/http-message/src/UriInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Value object representing a URI.\n     *\n     * This interface is meant to represent URIs according to RFC 3986 and to\n     * provide methods for most common operations. Additional functionality for\n     * working with URIs can be provided on top of the interface or externally.\n     * Its primary use is for HTTP requests, but may also be used in other\n     * contexts.\n     *\n     * Instances of this interface are considered immutable; all methods that\n     * might change state MUST be implemented such that they retain the internal\n     * state of the current instance and return an instance that contains the\n     * changed state.\n     *\n     * Typically the Host header will be also be present in the request message.\n     * For server-side requests, the scheme will typically be discoverable in the\n     * server parameters.\n     *\n     * @link http://tools.ietf.org/html/rfc3986 (the URI specification)\n     */\n    interface UriInterface\n    {\n        /**\n         * Retrieve the scheme component of the URI.\n         *\n         * If no scheme is present, this method MUST return an empty string.\n         *\n         * The value returned MUST be normalized to lowercase, per RFC 3986\n         * Section 3.1.\n         *\n         * The trailing \":\" character is not part of the scheme and MUST NOT be\n         * added.\n         *\n         * @see https://tools.ietf.org/html/rfc3986#section-3.1\n         * @return string The URI scheme.\n         */\n        public function getScheme(): string;\n\n        /**\n         * Retrieve the authority component of the URI.\n         *\n         * If no authority information is present, this method MUST return an empty\n         * string.\n         *\n         * The authority syntax of the URI is:\n         *\n         * <pre>\n         * [user-info@]host[:port]\n         * </pre>\n         *\n         * If the port component is not set or is the standard port for the current\n         * scheme, it SHOULD NOT be included.\n         *\n         * @see https://tools.ietf.org/html/rfc3986#section-3.2\n         * @return string The URI authority, in \"[user-info@]host[:port]\" format.\n         */\n        public function getAuthority(): string;\n\n        /**\n         * Retrieve the user information component of the URI.\n         *\n         * If no user information is present, this method MUST return an empty\n         * string.\n         *\n         * If a user is present in the URI, this will return that value;\n         * additionally, if the password is also present, it will be appended to the\n         * user value, with a colon (\":\") separating the values.\n         *\n         * The trailing \"@\" character is not part of the user information and MUST\n         * NOT be added.\n         *\n         * @return string The URI user information, in \"username[:password]\" format.\n         */\n        public function getUserInfo(): string;\n\n        /**\n         * Retrieve the host component of the URI.\n         *\n         * If no host is present, this method MUST return an empty string.\n         *\n         * The value returned MUST be normalized to lowercase, per RFC 3986\n         * Section 3.2.2.\n         *\n         * @see http://tools.ietf.org/html/rfc3986#section-3.2.2\n         * @return string The URI host.\n         */\n        public function getHost(): string;\n\n        /**\n         * Retrieve the port component of the URI.\n         *\n         * If a port is present, and it is non-standard for the current scheme,\n         * this method MUST return it as an integer. If the port is the standard port\n         * used with the current scheme, this method SHOULD return null.\n         *\n         * If no port is present, and no scheme is present, this method MUST return\n         * a null value.\n         *\n         * If no port is present, but a scheme is present, this method MAY return\n         * the standard port for that scheme, but SHOULD return null.\n         *\n         * @return null|int The URI port.\n         */\n        public function getPort(): ?int;\n\n        /**\n         * Retrieve the path component of the URI.\n         *\n         * The path can either be empty or absolute (starting with a slash) or\n         * rootless (not starting with a slash). Implementations MUST support all\n         * three syntaxes.\n         *\n         * Normally, the empty path \"\" and absolute path \"/\" are considered equal as\n         * defined in RFC 7230 Section 2.7.3. But this method MUST NOT automatically\n         * do this normalization because in contexts with a trimmed base path, e.g.\n         * the front controller, this difference becomes significant. It's the task\n         * of the user to handle both \"\" and \"/\".\n         *\n         * The value returned MUST be percent-encoded, but MUST NOT double-encode\n         * any characters. To determine what characters to encode, please refer to\n         * RFC 3986, Sections 2 and 3.3.\n         *\n         * As an example, if the value should include a slash (\"/\") not intended as\n         * delimiter between path segments, that value MUST be passed in encoded\n         * form (e.g., \"%2F\") to the instance.\n         *\n         * @see https://tools.ietf.org/html/rfc3986#section-2\n         * @see https://tools.ietf.org/html/rfc3986#section-3.3\n         * @return string The URI path.\n         */\n        public function getPath(): string;\n\n        /**\n         * Retrieve the query string of the URI.\n         *\n         * If no query string is present, this method MUST return an empty string.\n         *\n         * The leading \"?\" character is not part of the query and MUST NOT be\n         * added.\n         *\n         * The value returned MUST be percent-encoded, but MUST NOT double-encode\n         * any characters. To determine what characters to encode, please refer to\n         * RFC 3986, Sections 2 and 3.4.\n         *\n         * As an example, if a value in a key/value pair of the query string should\n         * include an ampersand (\"&\") not intended as a delimiter between values,\n         * that value MUST be passed in encoded form (e.g., \"%26\") to the instance.\n         *\n         * @see https://tools.ietf.org/html/rfc3986#section-2\n         * @see https://tools.ietf.org/html/rfc3986#section-3.4\n         * @return string The URI query string.\n         */\n        public function getQuery(): string;\n\n        /**\n         * Retrieve the fragment component of the URI.\n         *\n         * If no fragment is present, this method MUST return an empty string.\n         *\n         * The leading \"#\" character is not part of the fragment and MUST NOT be\n         * added.\n         *\n         * The value returned MUST be percent-encoded, but MUST NOT double-encode\n         * any characters. To determine what characters to encode, please refer to\n         * RFC 3986, Sections 2 and 3.5.\n         *\n         * @see https://tools.ietf.org/html/rfc3986#section-2\n         * @see https://tools.ietf.org/html/rfc3986#section-3.5\n         * @return string The URI fragment.\n         */\n        public function getFragment(): string;\n\n        /**\n         * Return an instance with the specified scheme.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified scheme.\n         *\n         * Implementations MUST support the schemes \"http\" and \"https\" case\n         * insensitively, and MAY accommodate other schemes if required.\n         *\n         * An empty scheme is equivalent to removing the scheme.\n         *\n         * @param string $scheme The scheme to use with the new instance.\n         * @return static A new instance with the specified scheme.\n         * @throws \\InvalidArgumentException for invalid or unsupported schemes.\n         */\n        public function withScheme(string $scheme): UriInterface;\n\n        /**\n         * Return an instance with the specified user information.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified user information.\n         *\n         * Password is optional, but the user information MUST include the\n         * user; an empty string for the user is equivalent to removing user\n         * information.\n         *\n         * @param string $user The user name to use for authority.\n         * @param null|string $password The password associated with $user.\n         * @return static A new instance with the specified user information.\n         */\n        public function withUserInfo(string $user, ?string $password = null): UriInterface;\n\n        /**\n         * Return an instance with the specified host.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified host.\n         *\n         * An empty host value is equivalent to removing the host.\n         *\n         * @param string $host The hostname to use with the new instance.\n         * @return static A new instance with the specified host.\n         * @throws \\InvalidArgumentException for invalid hostnames.\n         */\n        public function withHost(string $host): UriInterface;\n\n        /**\n         * Return an instance with the specified port.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified port.\n         *\n         * Implementations MUST raise an exception for ports outside the\n         * established TCP and UDP port ranges.\n         *\n         * A null value provided for the port is equivalent to removing the port\n         * information.\n         *\n         * @param null|int $port The port to use with the new instance; a null value\n         *     removes the port information.\n         * @return static A new instance with the specified port.\n         * @throws \\InvalidArgumentException for invalid ports.\n         */\n        public function withPort(?int $port): UriInterface;\n\n        /**\n         * Return an instance with the specified path.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified path.\n         *\n         * The path can either be empty or absolute (starting with a slash) or\n         * rootless (not starting with a slash). Implementations MUST support all\n         * three syntaxes.\n         *\n         * If the path is intended to be domain-relative rather than path relative then\n         * it must begin with a slash (\"/\"). Paths not starting with a slash (\"/\")\n         * are assumed to be relative to some base path known to the application or\n         * consumer.\n         *\n         * Users can provide both encoded and decoded path characters.\n         * Implementations ensure the correct encoding as outlined in getPath().\n         *\n         * @param string $path The path to use with the new instance.\n         * @return static A new instance with the specified path.\n         * @throws \\InvalidArgumentException for invalid paths.\n         */\n        public function withPath(string $path): UriInterface;\n\n        /**\n         * Return an instance with the specified query string.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified query string.\n         *\n         * Users can provide both encoded and decoded query characters.\n         * Implementations ensure the correct encoding as outlined in getQuery().\n         *\n         * An empty query string value is equivalent to removing the query string.\n         *\n         * @param string $query The query string to use with the new instance.\n         * @return static A new instance with the specified query string.\n         * @throws \\InvalidArgumentException for invalid query strings.\n         */\n        public function withQuery(string $query): UriInterface;\n\n        /**\n         * Return an instance with the specified URI fragment.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified URI fragment.\n         *\n         * Users can provide both encoded and decoded fragment characters.\n         * Implementations ensure the correct encoding as outlined in getFragment().\n         *\n         * An empty fragment value is equivalent to removing the fragment.\n         *\n         * @param string $fragment The fragment to use with the new instance.\n         * @return static A new instance with the specified fragment.\n         */\n        public function withFragment(string $fragment): UriInterface;\n\n        /**\n         * Return the string representation as a URI reference.\n         *\n         * Depending on which components of the URI are present, the resulting\n         * string is either a full URI or relative reference according to RFC 3986,\n         * Section 4.1. The method concatenates the various components of the URI,\n         * using the appropriate delimiters:\n         *\n         * - If a scheme is present, it MUST be suffixed by \":\".\n         * - If an authority is present, it MUST be prefixed by \"//\".\n         * - The path can be concatenated without delimiters. But there are two\n         *   cases where the path has to be adjusted to make the URI reference\n         *   valid as PHP does not allow to throw an exception in __toString():\n         *     - If the path is rootless and an authority is present, the path MUST\n         *       be prefixed by \"/\".\n         *     - If the path is starting with more than one \"/\" and no authority is\n         *       present, the starting slashes MUST be reduced to one.\n         * - If a query is present, it MUST be prefixed by \"?\".\n         * - If a fragment is present, it MUST be prefixed by \"#\".\n         *\n         * @see http://tools.ietf.org/html/rfc3986#section-4.1\n         * @return string\n         */\n        public function __toString(): string;\n    }\n}\n\n// file: vendor/psr/http-server-handler/src/RequestHandlerInterface.php\nnamespace Psr\\Http\\Server {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n\n    /**\n     * Handles a server request and produces a response.\n     *\n     * An HTTP request handler process an HTTP request in order to produce an\n     * HTTP response.\n     */\n    interface RequestHandlerInterface\n    {\n        /**\n         * Handles a request and produces a response.\n         *\n         * May call other collaborating code to generate the response.\n         */\n        public function handle(ServerRequestInterface $request): ResponseInterface;\n    }\n}\n\n// file: vendor/psr/http-server-middleware/src/MiddlewareInterface.php\nnamespace Psr\\Http\\Server {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n\n    /**\n     * Participant in processing a server request and response.\n     *\n     * An HTTP middleware component participates in processing an HTTP message:\n     * by acting on the request, generating the response, or forwarding the\n     * request to a subsequent middleware and possibly acting on its response.\n     */\n    interface MiddlewareInterface\n    {\n        /**\n         * Process an incoming server request.\n         *\n         * Processes an incoming server request in order to produce a response.\n         * If unable to produce the response itself, it may delegate to the provided\n         * request handler to do so.\n         */\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface;\n    }\n}\n\n// file: vendor/nyholm/psr7/src/Factory/Psr17Factory.php\nnamespace Nyholm\\Psr7\\Factory {\n\n    use Nyholm\\Psr7\\{Request, Response, ServerRequest, Stream, UploadedFile, Uri};\n    use Psr\\Http\\Message\\{RequestFactoryInterface, RequestInterface, ResponseFactoryInterface, ResponseInterface, ServerRequestFactoryInterface, ServerRequestInterface, StreamFactoryInterface, StreamInterface, UploadedFileFactoryInterface, UploadedFileInterface, UriFactoryInterface, UriInterface};\n\n    /**\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class Psr17Factory implements RequestFactoryInterface, ResponseFactoryInterface, ServerRequestFactoryInterface, StreamFactoryInterface, UploadedFileFactoryInterface, UriFactoryInterface\n    {\n        public function createRequest(string $method, $uri): RequestInterface\n        {\n            return new Request($method, $uri);\n        }\n\n        public function createResponse(int $code = 200, string $reasonPhrase = ''): ResponseInterface\n        {\n            if (2 > \\func_num_args()) {\n                // This will make the Response class to use a custom reasonPhrase\n                $reasonPhrase = null;\n            }\n\n            return new Response($code, [], null, '1.1', $reasonPhrase);\n        }\n\n        public function createStream(string $content = ''): StreamInterface\n        {\n            return Stream::create($content);\n        }\n\n        public function createStreamFromFile(string $filename, string $mode = 'r'): StreamInterface\n        {\n            if ('' === $filename) {\n                throw new \\RuntimeException('Path cannot be empty');\n            }\n\n            if (false === $resource = @\\fopen($filename, $mode)) {\n                if ('' === $mode || false === \\in_array($mode[0], ['r', 'w', 'a', 'x', 'c'], true)) {\n                    throw new \\InvalidArgumentException(\\sprintf('The mode \"%s\" is invalid.', $mode));\n                }\n\n                throw new \\RuntimeException(\\sprintf('The file \"%s\" cannot be opened: %s', $filename, \\error_get_last()['message'] ?? ''));\n            }\n\n            return Stream::create($resource);\n        }\n\n        public function createStreamFromResource($resource): StreamInterface\n        {\n            return Stream::create($resource);\n        }\n\n        public function createUploadedFile(StreamInterface $stream, ?int $size = null, int $error = \\UPLOAD_ERR_OK, ?string $clientFilename = null, ?string $clientMediaType = null): UploadedFileInterface\n        {\n            if (null === $size) {\n                $size = $stream->getSize();\n            }\n\n            return new UploadedFile($stream, $size, $error, $clientFilename, $clientMediaType);\n        }\n\n        public function createUri(string $uri = ''): UriInterface\n        {\n            return new Uri($uri);\n        }\n\n        public function createServerRequest(string $method, $uri, array $serverParams = []): ServerRequestInterface\n        {\n            return new ServerRequest($method, $uri, [], null, '1.1', $serverParams);\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/MessageTrait.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\MessageInterface;\n    use Psr\\Http\\Message\\StreamInterface;\n\n    /**\n     * Trait implementing functionality common to requests and responses.\n     *\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @internal should not be used outside of Nyholm/Psr7 as it does not fall under our BC promise\n     */\n    trait MessageTrait\n    {\n        /** @var array Map of all registered headers, as original name => array of values */\n        private $headers = [];\n\n        /** @var array Map of lowercase header name => original name at registration */\n        private $headerNames = [];\n\n        /** @var string */\n        private $protocol = '1.1';\n\n        /** @var StreamInterface|null */\n        private $stream;\n\n        public function getProtocolVersion(): string\n        {\n            return $this->protocol;\n        }\n\n        /**\n         * @return static\n         */\n        public function withProtocolVersion($version): MessageInterface\n        {\n            if (!\\is_scalar($version)) {\n                throw new \\InvalidArgumentException('Protocol version must be a string');\n            }\n\n            if ($this->protocol === $version) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->protocol = (string) $version;\n\n            return $new;\n        }\n\n        public function getHeaders(): array\n        {\n            return $this->headers;\n        }\n\n        public function hasHeader($header): bool\n        {\n            return isset($this->headerNames[\\strtr($header, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')]);\n        }\n\n        public function getHeader($header): array\n        {\n            if (!\\is_string($header)) {\n                throw new \\InvalidArgumentException('Header name must be an RFC 7230 compatible string');\n            }\n\n            $header = \\strtr($header, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz');\n            if (!isset($this->headerNames[$header])) {\n                return [];\n            }\n\n            $header = $this->headerNames[$header];\n\n            return $this->headers[$header];\n        }\n\n        public function getHeaderLine($header): string\n        {\n            return \\implode(', ', $this->getHeader($header));\n        }\n\n        /**\n         * @return static\n         */\n        public function withHeader($header, $value): MessageInterface\n        {\n            $value = $this->validateAndTrimHeader($header, $value);\n            $normalized = \\strtr($header, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz');\n\n            $new = clone $this;\n            if (isset($new->headerNames[$normalized])) {\n                unset($new->headers[$new->headerNames[$normalized]]);\n            }\n            $new->headerNames[$normalized] = $header;\n            $new->headers[$header] = $value;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withAddedHeader($header, $value): MessageInterface\n        {\n            if (!\\is_string($header) || '' === $header) {\n                throw new \\InvalidArgumentException('Header name must be an RFC 7230 compatible string');\n            }\n\n            $new = clone $this;\n            $new->setHeaders([$header => $value]);\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withoutHeader($header): MessageInterface\n        {\n            if (!\\is_string($header)) {\n                throw new \\InvalidArgumentException('Header name must be an RFC 7230 compatible string');\n            }\n\n            $normalized = \\strtr($header, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz');\n            if (!isset($this->headerNames[$normalized])) {\n                return $this;\n            }\n\n            $header = $this->headerNames[$normalized];\n            $new = clone $this;\n            unset($new->headers[$header], $new->headerNames[$normalized]);\n\n            return $new;\n        }\n\n        public function getBody(): StreamInterface\n        {\n            if (null === $this->stream) {\n                $this->stream = Stream::create('');\n            }\n\n            return $this->stream;\n        }\n\n        /**\n         * @return static\n         */\n        public function withBody(StreamInterface $body): MessageInterface\n        {\n            if ($body === $this->stream) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->stream = $body;\n\n            return $new;\n        }\n\n        private function setHeaders(array $headers): void\n        {\n            foreach ($headers as $header => $value) {\n                if (\\is_int($header)) {\n                    // If a header name was set to a numeric string, PHP will cast the key to an int.\n                    // We must cast it back to a string in order to comply with validation.\n                    $header = (string) $header;\n                }\n                $value = $this->validateAndTrimHeader($header, $value);\n                $normalized = \\strtr($header, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz');\n                if (isset($this->headerNames[$normalized])) {\n                    $header = $this->headerNames[$normalized];\n                    $this->headers[$header] = \\array_merge($this->headers[$header], $value);\n                } else {\n                    $this->headerNames[$normalized] = $header;\n                    $this->headers[$header] = $value;\n                }\n            }\n        }\n\n        /**\n         * Make sure the header complies with RFC 7230.\n         *\n         * Header names must be a non-empty string consisting of token characters.\n         *\n         * Header values must be strings consisting of visible characters with all optional\n         * leading and trailing whitespace stripped. This method will always strip such\n         * optional whitespace. Note that the method does not allow folding whitespace within\n         * the values as this was deprecated for almost all instances by the RFC.\n         *\n         * header-field = field-name \":\" OWS field-value OWS\n         * field-name   = 1*( \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" / \"^\"\n         *              / \"_\" / \"`\" / \"|\" / \"~\" / %x30-39 / ( %x41-5A / %x61-7A ) )\n         * OWS          = *( SP / HTAB )\n         * field-value  = *( ( %x21-7E / %x80-FF ) [ 1*( SP / HTAB ) ( %x21-7E / %x80-FF ) ] )\n         *\n         * @see https://tools.ietf.org/html/rfc7230#section-3.2.4\n         */\n        private function validateAndTrimHeader($header, $values): array\n        {\n            if (!\\is_string($header) || 1 !== \\preg_match(\"@^[!#$%&'*+.^_`|~0-9A-Za-z-]+$@D\", $header)) {\n                throw new \\InvalidArgumentException('Header name must be an RFC 7230 compatible string');\n            }\n\n            if (!\\is_array($values)) {\n                // This is simple, just one value.\n                if ((!\\is_numeric($values) && !\\is_string($values)) || 1 !== \\preg_match(\"@^[ \\t\\x21-\\x7E\\x80-\\xFF]*$@\", (string) $values)) {\n                    throw new \\InvalidArgumentException('Header values must be RFC 7230 compatible strings');\n                }\n\n                return [\\trim((string) $values, \" \\t\")];\n            }\n\n            if (empty($values)) {\n                throw new \\InvalidArgumentException('Header values must be a string or an array of strings, empty array given');\n            }\n\n            // Assert Non empty array\n            $returnValues = [];\n            foreach ($values as $v) {\n                if ((!\\is_numeric($v) && !\\is_string($v)) || 1 !== \\preg_match(\"@^[ \\t\\x21-\\x7E\\x80-\\xFF]*$@D\", (string) $v)) {\n                    throw new \\InvalidArgumentException('Header values must be RFC 7230 compatible strings');\n                }\n\n                $returnValues[] = \\trim((string) $v, \" \\t\");\n            }\n\n            return $returnValues;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/Request.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\{RequestInterface, StreamInterface, UriInterface};\n\n    /**\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class Request implements RequestInterface\n    {\n        use MessageTrait;\n        use RequestTrait;\n\n        /**\n         * @param string $method HTTP method\n         * @param string|UriInterface $uri URI\n         * @param array $headers Request headers\n         * @param string|resource|StreamInterface|null $body Request body\n         * @param string $version Protocol version\n         */\n        public function __construct(string $method, $uri, array $headers = [], $body = null, string $version = '1.1')\n        {\n            if (!($uri instanceof UriInterface)) {\n                $uri = new Uri($uri);\n            }\n\n            $this->method = $method;\n            $this->uri = $uri;\n            $this->setHeaders($headers);\n            $this->protocol = $version;\n\n            if (!$this->hasHeader('Host')) {\n                $this->updateHostFromUri();\n            }\n\n            // If we got no body, defer initialization of the stream until Request::getBody()\n            if ('' !== $body && null !== $body) {\n                $this->stream = Stream::create($body);\n            }\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/RequestTrait.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\RequestInterface;\n    use Psr\\Http\\Message\\UriInterface;\n\n    /**\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @internal should not be used outside of Nyholm/Psr7 as it does not fall under our BC promise\n     */\n    trait RequestTrait\n    {\n        /** @var string */\n        private $method;\n\n        /** @var string|null */\n        private $requestTarget;\n\n        /** @var UriInterface|null */\n        private $uri;\n\n        public function getRequestTarget(): string\n        {\n            if (null !== $this->requestTarget) {\n                return $this->requestTarget;\n            }\n\n            if ('' === $target = $this->uri->getPath()) {\n                $target = '/';\n            }\n            if ('' !== $this->uri->getQuery()) {\n                $target .= '?' . $this->uri->getQuery();\n            }\n\n            return $target;\n        }\n\n        /**\n         * @return static\n         */\n        public function withRequestTarget($requestTarget): RequestInterface\n        {\n            if (!\\is_string($requestTarget)) {\n                throw new \\InvalidArgumentException('Request target must be a string');\n            }\n\n            if (\\preg_match('#\\s#', $requestTarget)) {\n                throw new \\InvalidArgumentException('Invalid request target provided; cannot contain whitespace');\n            }\n\n            $new = clone $this;\n            $new->requestTarget = $requestTarget;\n\n            return $new;\n        }\n\n        public function getMethod(): string\n        {\n            return $this->method;\n        }\n\n        /**\n         * @return static\n         */\n        public function withMethod($method): RequestInterface\n        {\n            if (!\\is_string($method)) {\n                throw new \\InvalidArgumentException('Method must be a string');\n            }\n\n            $new = clone $this;\n            $new->method = $method;\n\n            return $new;\n        }\n\n        public function getUri(): UriInterface\n        {\n            return $this->uri;\n        }\n\n        /**\n         * @return static\n         */\n        public function withUri(UriInterface $uri, $preserveHost = false): RequestInterface\n        {\n            if ($uri === $this->uri) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->uri = $uri;\n\n            if (!$preserveHost || !$this->hasHeader('Host')) {\n                $new->updateHostFromUri();\n            }\n\n            return $new;\n        }\n\n        private function updateHostFromUri(): void\n        {\n            if ('' === $host = $this->uri->getHost()) {\n                return;\n            }\n\n            if (null !== ($port = $this->uri->getPort())) {\n                $host .= ':' . $port;\n            }\n\n            if (isset($this->headerNames['host'])) {\n                $header = $this->headerNames['host'];\n            } else {\n                $this->headerNames['host'] = $header = 'Host';\n            }\n\n            // Ensure Host is the first header.\n            // See: http://tools.ietf.org/html/rfc7230#section-5.4\n            $this->headers = [$header => [$host]] + $this->headers;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/Response.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\{ResponseInterface, StreamInterface};\n\n    /**\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class Response implements ResponseInterface\n    {\n        use MessageTrait;\n\n        /** @var array Map of standard HTTP status code/reason phrases */\n        private const PHRASES = [\n            100 => 'Continue', 101 => 'Switching Protocols', 102 => 'Processing',\n            200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content', 207 => 'Multi-status', 208 => 'Already Reported',\n            300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 306 => 'Switch Proxy', 307 => 'Temporary Redirect',\n            400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Time-out', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Large', 415 => 'Unsupported Media Type', 416 => 'Requested range not satisfiable', 417 => 'Expectation Failed', 418 => 'I\\'m a teapot', 422 => 'Unprocessable Entity', 423 => 'Locked', 424 => 'Failed Dependency', 425 => 'Unordered Collection', 426 => 'Upgrade Required', 428 => 'Precondition Required', 429 => 'Too Many Requests', 431 => 'Request Header Fields Too Large', 451 => 'Unavailable For Legal Reasons',\n            500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Time-out', 505 => 'HTTP Version not supported', 506 => 'Variant Also Negotiates', 507 => 'Insufficient Storage', 508 => 'Loop Detected', 511 => 'Network Authentication Required',\n        ];\n\n        /** @var string */\n        private $reasonPhrase = '';\n\n        /** @var int */\n        private $statusCode;\n\n        /**\n         * @param int $status Status code\n         * @param array $headers Response headers\n         * @param string|resource|StreamInterface|null $body Response body\n         * @param string $version Protocol version\n         * @param string|null $reason Reason phrase (when empty a default will be used based on the status code)\n         */\n        public function __construct(int $status = 200, array $headers = [], $body = null, string $version = '1.1', ?string $reason = null)\n        {\n            // If we got no body, defer initialization of the stream until Response::getBody()\n            if ('' !== $body && null !== $body) {\n                $this->stream = Stream::create($body);\n            }\n\n            $this->statusCode = $status;\n            $this->setHeaders($headers);\n            if (null === $reason && isset(self::PHRASES[$this->statusCode])) {\n                $this->reasonPhrase = self::PHRASES[$status];\n            } else {\n                $this->reasonPhrase = $reason ?? '';\n            }\n\n            $this->protocol = $version;\n        }\n\n        public function getStatusCode(): int\n        {\n            return $this->statusCode;\n        }\n\n        public function getReasonPhrase(): string\n        {\n            return $this->reasonPhrase;\n        }\n\n        /**\n         * @return static\n         */\n        public function withStatus($code, $reasonPhrase = ''): ResponseInterface\n        {\n            if (!\\is_int($code) && !\\is_string($code)) {\n                throw new \\InvalidArgumentException('Status code has to be an integer');\n            }\n\n            $code = (int) $code;\n            if ($code < 100 || $code > 599) {\n                throw new \\InvalidArgumentException(\\sprintf('Status code has to be an integer between 100 and 599. A status code of %d was given', $code));\n            }\n\n            $new = clone $this;\n            $new->statusCode = $code;\n            if ((null === $reasonPhrase || '' === $reasonPhrase) && isset(self::PHRASES[$new->statusCode])) {\n                $reasonPhrase = self::PHRASES[$new->statusCode];\n            }\n            $new->reasonPhrase = $reasonPhrase;\n\n            return $new;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/ServerRequest.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\{ServerRequestInterface, StreamInterface, UploadedFileInterface, UriInterface};\n\n    /**\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class ServerRequest implements ServerRequestInterface\n    {\n        use MessageTrait;\n        use RequestTrait;\n\n        /** @var array */\n        private $attributes = [];\n\n        /** @var array */\n        private $cookieParams = [];\n\n        /** @var array|object|null */\n        private $parsedBody;\n\n        /** @var array */\n        private $queryParams = [];\n\n        /** @var array */\n        private $serverParams;\n\n        /** @var UploadedFileInterface[] */\n        private $uploadedFiles = [];\n\n        /**\n         * @param string $method HTTP method\n         * @param string|UriInterface $uri URI\n         * @param array $headers Request headers\n         * @param string|resource|StreamInterface|null $body Request body\n         * @param string $version Protocol version\n         * @param array $serverParams Typically the $_SERVER superglobal\n         */\n        public function __construct(string $method, $uri, array $headers = [], $body = null, string $version = '1.1', array $serverParams = [])\n        {\n            $this->serverParams = $serverParams;\n\n            if (!($uri instanceof UriInterface)) {\n                $uri = new Uri($uri);\n            }\n\n            $this->method = $method;\n            $this->uri = $uri;\n            $this->setHeaders($headers);\n            $this->protocol = $version;\n            \\parse_str($uri->getQuery(), $this->queryParams);\n\n            if (!$this->hasHeader('Host')) {\n                $this->updateHostFromUri();\n            }\n\n            // If we got no body, defer initialization of the stream until ServerRequest::getBody()\n            if ('' !== $body && null !== $body) {\n                $this->stream = Stream::create($body);\n            }\n        }\n\n        public function getServerParams(): array\n        {\n            return $this->serverParams;\n        }\n\n        public function getUploadedFiles(): array\n        {\n            return $this->uploadedFiles;\n        }\n\n        /**\n         * @return static\n         */\n        public function withUploadedFiles(array $uploadedFiles): ServerRequestInterface\n        {\n            $new = clone $this;\n            $new->uploadedFiles = $uploadedFiles;\n\n            return $new;\n        }\n\n        public function getCookieParams(): array\n        {\n            return $this->cookieParams;\n        }\n\n        /**\n         * @return static\n         */\n        public function withCookieParams(array $cookies): ServerRequestInterface\n        {\n            $new = clone $this;\n            $new->cookieParams = $cookies;\n\n            return $new;\n        }\n\n        public function getQueryParams(): array\n        {\n            return $this->queryParams;\n        }\n\n        /**\n         * @return static\n         */\n        public function withQueryParams(array $query): ServerRequestInterface\n        {\n            $new = clone $this;\n            $new->queryParams = $query;\n\n            return $new;\n        }\n\n        /**\n         * @return array|object|null\n         */\n        public function getParsedBody()\n        {\n            return $this->parsedBody;\n        }\n\n        /**\n         * @return static\n         */\n        public function withParsedBody($data): ServerRequestInterface\n        {\n            if (!\\is_array($data) && !\\is_object($data) && null !== $data) {\n                throw new \\InvalidArgumentException('First parameter to withParsedBody MUST be object, array or null');\n            }\n\n            $new = clone $this;\n            $new->parsedBody = $data;\n\n            return $new;\n        }\n\n        public function getAttributes(): array\n        {\n            return $this->attributes;\n        }\n\n        /**\n         * @return mixed\n         */\n        public function getAttribute($attribute, $default = null)\n        {\n            if (!\\is_string($attribute)) {\n                throw new \\InvalidArgumentException('Attribute name must be a string');\n            }\n\n            if (false === \\array_key_exists($attribute, $this->attributes)) {\n                return $default;\n            }\n\n            return $this->attributes[$attribute];\n        }\n\n        /**\n         * @return static\n         */\n        public function withAttribute($attribute, $value): ServerRequestInterface\n        {\n            if (!\\is_string($attribute)) {\n                throw new \\InvalidArgumentException('Attribute name must be a string');\n            }\n\n            $new = clone $this;\n            $new->attributes[$attribute] = $value;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withoutAttribute($attribute): ServerRequestInterface\n        {\n            if (!\\is_string($attribute)) {\n                throw new \\InvalidArgumentException('Attribute name must be a string');\n            }\n\n            if (false === \\array_key_exists($attribute, $this->attributes)) {\n                return $this;\n            }\n\n            $new = clone $this;\n            unset($new->attributes[$attribute]);\n\n            return $new;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/Stream.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\StreamInterface;\n\n    /**\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class Stream implements StreamInterface\n    {\n        function __toString():string { if ($this->isSeekable()) { $this->seek(0); } return $this->getContents(); }\n\n        /** @var resource|null A resource reference */\n        private $stream;\n\n        /** @var bool */\n        private $seekable;\n\n        /** @var bool */\n        private $readable;\n\n        /** @var bool */\n        private $writable;\n\n        /** @var array|mixed|void|bool|null */\n        private $uri;\n\n        /** @var int|null */\n        private $size;\n\n        /** @var array Hash of readable and writable stream types */\n        private const READ_WRITE_HASH = [\n            'read' => [\n                'r' => true, 'w+' => true, 'r+' => true, 'x+' => true, 'c+' => true,\n                'rb' => true, 'w+b' => true, 'r+b' => true, 'x+b' => true,\n                'c+b' => true, 'rt' => true, 'w+t' => true, 'r+t' => true,\n                'x+t' => true, 'c+t' => true, 'a+' => true,\n            ],\n            'write' => [\n                'w' => true, 'w+' => true, 'rw' => true, 'r+' => true, 'x+' => true,\n                'c+' => true, 'wb' => true, 'w+b' => true, 'r+b' => true,\n                'x+b' => true, 'c+b' => true, 'w+t' => true, 'r+t' => true,\n                'x+t' => true, 'c+t' => true, 'a' => true, 'a+' => true,\n            ],\n        ];\n\n        /**\n         * @param resource $body\n         */\n        public function __construct($body)\n        {\n            if (!\\is_resource($body)) {\n                throw new \\InvalidArgumentException('First argument to Stream::__construct() must be resource');\n            }\n\n            $this->stream = $body;\n            $meta = \\stream_get_meta_data($this->stream);\n            $this->seekable = $meta['seekable'] && 0 === \\fseek($this->stream, 0, \\SEEK_CUR);\n            $this->readable = isset(self::READ_WRITE_HASH['read'][$meta['mode']]);\n            $this->writable = isset(self::READ_WRITE_HASH['write'][$meta['mode']]);\n        }\n\n        /**\n         * Creates a new PSR-7 stream.\n         *\n         * @param string|resource|StreamInterface $body\n         *\n         * @throws \\InvalidArgumentException\n         */\n        public static function create($body = ''): StreamInterface\n        {\n            if ($body instanceof StreamInterface) {\n                return $body;\n            }\n\n            if (\\is_string($body)) {\n                if (200000 <= \\strlen($body)) {\n                    $body = self::openZvalStream($body);\n                } else {\n                    $resource = \\fopen('php://memory', 'r+');\n                    \\fwrite($resource, $body);\n                    \\fseek($resource, 0);\n                    $body = $resource;\n                }\n            }\n\n            if (!\\is_resource($body)) {\n                throw new \\InvalidArgumentException('First argument to Stream::create() must be a string, resource or StreamInterface');\n            }\n\n            return new self($body);\n        }\n\n        /**\n         * Closes the stream when the destructed.\n         */\n        public function __destruct()\n        {\n            $this->close();\n        }\n\n        public function close(): void\n        {\n            if (isset($this->stream)) {\n                if (\\is_resource($this->stream)) {\n                    \\fclose($this->stream);\n                }\n                $this->detach();\n            }\n        }\n\n        public function detach()\n        {\n            if (!isset($this->stream)) {\n                return null;\n            }\n\n            $result = $this->stream;\n            unset($this->stream);\n            $this->size = $this->uri = null;\n            $this->readable = $this->writable = $this->seekable = false;\n\n            return $result;\n        }\n\n        private function getUri()\n        {\n            if (false !== $this->uri) {\n                $this->uri = $this->getMetadata('uri') ?? false;\n            }\n\n            return $this->uri;\n        }\n\n        public function getSize(): ?int\n        {\n            if (null !== $this->size) {\n                return $this->size;\n            }\n\n            if (!isset($this->stream)) {\n                return null;\n            }\n\n            // Clear the stat cache if the stream has a URI\n            if ($uri = $this->getUri()) {\n                \\clearstatcache(true, $uri);\n            }\n\n            $stats = \\fstat($this->stream);\n            if (isset($stats['size'])) {\n                $this->size = $stats['size'];\n\n                return $this->size;\n            }\n\n            return null;\n        }\n\n        public function tell(): int\n        {\n            if (!isset($this->stream)) {\n                throw new \\RuntimeException('Stream is detached');\n            }\n\n            if (false === $result = @\\ftell($this->stream)) {\n                throw new \\RuntimeException('Unable to determine stream position: ' . (\\error_get_last()['message'] ?? ''));\n            }\n\n            return $result;\n        }\n\n        public function eof(): bool\n        {\n            return !isset($this->stream) || \\feof($this->stream);\n        }\n\n        public function isSeekable(): bool\n        {\n            return $this->seekable;\n        }\n\n        public function seek($offset, $whence = \\SEEK_SET): void\n        {\n            if (!isset($this->stream)) {\n                throw new \\RuntimeException('Stream is detached');\n            }\n\n            if (!$this->seekable) {\n                throw new \\RuntimeException('Stream is not seekable');\n            }\n\n            if (-1 === \\fseek($this->stream, $offset, $whence)) {\n                throw new \\RuntimeException('Unable to seek to stream position \"' . $offset . '\" with whence ' . \\var_export($whence, true));\n            }\n        }\n\n        public function rewind(): void\n        {\n            $this->seek(0);\n        }\n\n        public function isWritable(): bool\n        {\n            return $this->writable;\n        }\n\n        public function write($string): int\n        {\n            if (!isset($this->stream)) {\n                throw new \\RuntimeException('Stream is detached');\n            }\n\n            if (!$this->writable) {\n                throw new \\RuntimeException('Cannot write to a non-writable stream');\n            }\n\n            // We can't know the size after writing anything\n            $this->size = null;\n\n            if (false === $result = @\\fwrite($this->stream, $string)) {\n                throw new \\RuntimeException('Unable to write to stream: ' . (\\error_get_last()['message'] ?? ''));\n            }\n\n            return $result;\n        }\n\n        public function isReadable(): bool\n        {\n            return $this->readable;\n        }\n\n        public function read($length): string\n        {\n            if (!isset($this->stream)) {\n                throw new \\RuntimeException('Stream is detached');\n            }\n\n            if (!$this->readable) {\n                throw new \\RuntimeException('Cannot read from non-readable stream');\n            }\n\n            if (false === $result = @\\fread($this->stream, $length)) {\n                throw new \\RuntimeException('Unable to read from stream: ' . (\\error_get_last()['message'] ?? ''));\n            }\n\n            return $result;\n        }\n\n        public function getContents(): string\n        {\n            if (!isset($this->stream)) {\n                throw new \\RuntimeException('Stream is detached');\n            }\n\n            $exception = null;\n\n            \\set_error_handler(static function ($type, $message) use (&$exception) {\n                throw $exception = new \\RuntimeException('Unable to read stream contents: ' . $message);\n            });\n\n            try {\n                return \\stream_get_contents($this->stream);\n            } catch (\\Throwable $e) {\n                throw $e === $exception ? $e : new \\RuntimeException('Unable to read stream contents: ' . $e->getMessage(), 0, $e);\n            } finally {\n                \\restore_error_handler();\n            }\n        }\n\n        /**\n         * @return mixed\n         */\n        public function getMetadata($key = null)\n        {\n            if (null !== $key && !\\is_string($key)) {\n                throw new \\InvalidArgumentException('Metadata key must be a string');\n            }\n\n            if (!isset($this->stream)) {\n                return $key ? null : [];\n            }\n\n            $meta = \\stream_get_meta_data($this->stream);\n\n            if (null === $key) {\n                return $meta;\n            }\n\n            return $meta[$key] ?? null;\n        }\n\n        private static function openZvalStream(string $body)\n        {\n            static $wrapper;\n\n            $wrapper ?? \\stream_wrapper_register('Nyholm-Psr7-Zval', $wrapper = \\get_class(new class() {\n                public $context;\n\n                private $data;\n                private $position = 0;\n\n                public function stream_open(): bool\n                {\n                    $this->data = \\stream_context_get_options($this->context)['Nyholm-Psr7-Zval']['data'];\n                    \\stream_context_set_option($this->context, 'Nyholm-Psr7-Zval', 'data', null);\n\n                    return true;\n                }\n\n                public function stream_read(int $count): string\n                {\n                    $result = \\substr($this->data, $this->position, $count);\n                    $this->position += \\strlen($result);\n\n                    return $result;\n                }\n\n                public function stream_write(string $data): int\n                {\n                    $this->data = \\substr_replace($this->data, $data, $this->position, \\strlen($data));\n                    $this->position += \\strlen($data);\n\n                    return \\strlen($data);\n                }\n\n                public function stream_tell(): int\n                {\n                    return $this->position;\n                }\n\n                public function stream_eof(): bool\n                {\n                    return \\strlen($this->data) <= $this->position;\n                }\n\n                public function stream_stat(): array\n                {\n                    return [\n                        'mode' => 33206, // POSIX_S_IFREG | 0666\n                        'nlink' => 1,\n                        'rdev' => -1,\n                        'size' => \\strlen($this->data),\n                        'blksize' => -1,\n                        'blocks' => -1,\n                    ];\n                }\n\n                public function stream_seek(int $offset, int $whence): bool\n                {\n                    if (\\SEEK_SET === $whence && (0 <= $offset && \\strlen($this->data) >= $offset)) {\n                        $this->position = $offset;\n                    } elseif (\\SEEK_CUR === $whence && 0 <= $offset) {\n                        $this->position += $offset;\n                    } elseif (\\SEEK_END === $whence && (0 > $offset && 0 <= $offset = \\strlen($this->data) + $offset)) {\n                        $this->position = $offset;\n                    } else {\n                        return false;\n                    }\n\n                    return true;\n                }\n\n                public function stream_set_option(): bool\n                {\n                    return true;\n                }\n\n                public function stream_truncate(int $new_size): bool\n                {\n                    if ($new_size) {\n                        $this->data = \\substr($this->data, 0, $new_size);\n                        $this->position = \\min($this->position, $new_size);\n                    } else {\n                        $this->data = '';\n                        $this->position = 0;\n                    }\n\n                    return true;\n                }\n            }));\n\n            $context = \\stream_context_create(['Nyholm-Psr7-Zval' => ['data' => $body]]);\n\n            if (!$stream = @\\fopen('Nyholm-Psr7-Zval://', 'r+', false, $context)) {\n                \\stream_wrapper_register('Nyholm-Psr7-Zval', $wrapper);\n                $stream = \\fopen('Nyholm-Psr7-Zval://', 'r+', false, $context);\n            }\n\n            return $stream;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/StreamTrait.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\StreamInterface;\n    use Symfony\\Component\\Debug\\ErrorHandler as SymfonyLegacyErrorHandler;\n    use Symfony\\Component\\ErrorHandler\\ErrorHandler as SymfonyErrorHandler;\n\n    if (\\PHP_VERSION_ID >= 70400 || (new \\ReflectionMethod(StreamInterface::class, '__toString'))->hasReturnType()) {\n        /**\n         * @internal\n         */\n        trait StreamTrait\n        {\n            public function __toString(): string\n            {\n                if ($this->isSeekable()) {\n                    $this->seek(0);\n                }\n\n                return $this->getContents();\n            }\n        }\n    } else {\n        /**\n         * @internal\n         */\n        trait StreamTrait\n        {\n            /**\n             * @return string\n             */\n            public function __toString()\n            {\n                try {\n                    if ($this->isSeekable()) {\n                        $this->seek(0);\n                    }\n\n                    return $this->getContents();\n                } catch (\\Throwable $e) {\n                    if (\\is_array($errorHandler = \\set_error_handler('var_dump'))) {\n                        $errorHandler = $errorHandler[0] ?? null;\n                    }\n                    \\restore_error_handler();\n\n                    if ($e instanceof \\Error || $errorHandler instanceof SymfonyErrorHandler || $errorHandler instanceof SymfonyLegacyErrorHandler) {\n                        return \\trigger_error((string) $e, \\E_USER_ERROR);\n                    }\n\n                    return '';\n                }\n            }\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/UploadedFile.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\{StreamInterface, UploadedFileInterface};\n\n    /**\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class UploadedFile implements UploadedFileInterface\n    {\n        /** @var array */\n        private const ERRORS = [\n            \\UPLOAD_ERR_OK => 1,\n            \\UPLOAD_ERR_INI_SIZE => 1,\n            \\UPLOAD_ERR_FORM_SIZE => 1,\n            \\UPLOAD_ERR_PARTIAL => 1,\n            \\UPLOAD_ERR_NO_FILE => 1,\n            \\UPLOAD_ERR_NO_TMP_DIR => 1,\n            \\UPLOAD_ERR_CANT_WRITE => 1,\n            \\UPLOAD_ERR_EXTENSION => 1,\n        ];\n\n        /** @var string */\n        private $clientFilename;\n\n        /** @var string */\n        private $clientMediaType;\n\n        /** @var int */\n        private $error;\n\n        /** @var string|null */\n        private $file;\n\n        /** @var bool */\n        private $moved = false;\n\n        /** @var int */\n        private $size;\n\n        /** @var StreamInterface|null */\n        private $stream;\n\n        /**\n         * @param StreamInterface|string|resource $streamOrFile\n         * @param int $size\n         * @param int $errorStatus\n         * @param string|null $clientFilename\n         * @param string|null $clientMediaType\n         */\n        public function __construct($streamOrFile, $size, $errorStatus, $clientFilename = null, $clientMediaType = null)\n        {\n            if (false === \\is_int($errorStatus) || !isset(self::ERRORS[$errorStatus])) {\n                throw new \\InvalidArgumentException('Upload file error status must be an integer value and one of the \"UPLOAD_ERR_*\" constants');\n            }\n\n            if (false === \\is_int($size)) {\n                throw new \\InvalidArgumentException('Upload file size must be an integer');\n            }\n\n            if (null !== $clientFilename && !\\is_string($clientFilename)) {\n                throw new \\InvalidArgumentException('Upload file client filename must be a string or null');\n            }\n\n            if (null !== $clientMediaType && !\\is_string($clientMediaType)) {\n                throw new \\InvalidArgumentException('Upload file client media type must be a string or null');\n            }\n\n            $this->error = $errorStatus;\n            $this->size = $size;\n            $this->clientFilename = $clientFilename;\n            $this->clientMediaType = $clientMediaType;\n\n            if (\\UPLOAD_ERR_OK === $this->error) {\n                // Depending on the value set file or stream variable.\n                if (\\is_string($streamOrFile) && '' !== $streamOrFile) {\n                    $this->file = $streamOrFile;\n                } elseif (\\is_resource($streamOrFile)) {\n                    $this->stream = Stream::create($streamOrFile);\n                } elseif ($streamOrFile instanceof StreamInterface) {\n                    $this->stream = $streamOrFile;\n                } else {\n                    throw new \\InvalidArgumentException('Invalid stream or file provided for UploadedFile');\n                }\n            }\n        }\n\n        /**\n         * @throws \\RuntimeException if is moved or not ok\n         */\n        private function validateActive(): void\n        {\n            if (\\UPLOAD_ERR_OK !== $this->error) {\n                throw new \\RuntimeException('Cannot retrieve stream due to upload error');\n            }\n\n            if ($this->moved) {\n                throw new \\RuntimeException('Cannot retrieve stream after it has already been moved');\n            }\n        }\n\n        public function getStream(): StreamInterface\n        {\n            $this->validateActive();\n\n            if ($this->stream instanceof StreamInterface) {\n                return $this->stream;\n            }\n\n            if (false === $resource = @\\fopen($this->file, 'r')) {\n                throw new \\RuntimeException(\\sprintf('The file \"%s\" cannot be opened: %s', $this->file, \\error_get_last()['message'] ?? ''));\n            }\n\n            return Stream::create($resource);\n        }\n\n        public function moveTo($targetPath): void\n        {\n            $this->validateActive();\n\n            if (!\\is_string($targetPath) || '' === $targetPath) {\n                throw new \\InvalidArgumentException('Invalid path provided for move operation; must be a non-empty string');\n            }\n\n            if (null !== $this->file) {\n                $this->moved = 'cli' === \\PHP_SAPI ? @\\rename($this->file, $targetPath) : @\\move_uploaded_file($this->file, $targetPath);\n\n                if (false === $this->moved) {\n                    throw new \\RuntimeException(\\sprintf('Uploaded file could not be moved to \"%s\": %s', $targetPath, \\error_get_last()['message'] ?? ''));\n                }\n            } else {\n                $stream = $this->getStream();\n                if ($stream->isSeekable()) {\n                    $stream->rewind();\n                }\n\n                if (false === $resource = @\\fopen($targetPath, 'w')) {\n                    throw new \\RuntimeException(\\sprintf('The file \"%s\" cannot be opened: %s', $targetPath, \\error_get_last()['message'] ?? ''));\n                }\n\n                $dest = Stream::create($resource);\n\n                while (!$stream->eof()) {\n                    if (!$dest->write($stream->read(1048576))) {\n                        break;\n                    }\n                }\n\n                $this->moved = true;\n            }\n        }\n\n        public function getSize(): int\n        {\n            return $this->size;\n        }\n\n        public function getError(): int\n        {\n            return $this->error;\n        }\n\n        public function getClientFilename(): ?string\n        {\n            return $this->clientFilename;\n        }\n\n        public function getClientMediaType(): ?string\n        {\n            return $this->clientMediaType;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/Uri.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\UriInterface;\n\n    /**\n     * PSR-7 URI implementation.\n     *\n     * @author Michael Dowling\n     * @author Tobias Schultze\n     * @author Matthew Weier O'Phinney\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class Uri implements UriInterface\n    {\n        private const SCHEMES = ['http' => 80, 'https' => 443];\n\n        private const CHAR_UNRESERVED = 'a-zA-Z0-9_\\-\\.~';\n\n        private const CHAR_SUB_DELIMS = '!\\$&\\'\\(\\)\\*\\+,;=';\n\n        private const CHAR_GEN_DELIMS = ':\\/\\?#\\[\\]@';\n\n        /** @var string Uri scheme. */\n        private $scheme = '';\n\n        /** @var string Uri user info. */\n        private $userInfo = '';\n\n        /** @var string Uri host. */\n        private $host = '';\n\n        /** @var int|null Uri port. */\n        private $port;\n\n        /** @var string Uri path. */\n        private $path = '';\n\n        /** @var string Uri query string. */\n        private $query = '';\n\n        /** @var string Uri fragment. */\n        private $fragment = '';\n\n        public function __construct(string $uri = '')\n        {\n            if ('' !== $uri) {\n                if (false === $parts = \\parse_url($uri)) {\n                    throw new \\InvalidArgumentException(\\sprintf('Unable to parse URI: \"%s\"', $uri));\n                }\n\n                // Apply parse_url parts to a URI.\n                $this->scheme = isset($parts['scheme']) ? \\strtr($parts['scheme'], 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz') : '';\n                $this->userInfo = $parts['user'] ?? '';\n                $this->host = isset($parts['host']) ? \\strtr($parts['host'], 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz') : '';\n                $this->port = isset($parts['port']) ? $this->filterPort($parts['port']) : null;\n                $this->path = isset($parts['path']) ? $this->filterPath($parts['path']) : '';\n                $this->query = isset($parts['query']) ? $this->filterQueryAndFragment($parts['query']) : '';\n                $this->fragment = isset($parts['fragment']) ? $this->filterQueryAndFragment($parts['fragment']) : '';\n                if (isset($parts['pass'])) {\n                    $this->userInfo .= ':' . $parts['pass'];\n                }\n            }\n        }\n\n        public function __toString(): string\n        {\n            return self::createUriString($this->scheme, $this->getAuthority(), $this->path, $this->query, $this->fragment);\n        }\n\n        public function getScheme(): string\n        {\n            return $this->scheme;\n        }\n\n        public function getAuthority(): string\n        {\n            if ('' === $this->host) {\n                return '';\n            }\n\n            $authority = $this->host;\n            if ('' !== $this->userInfo) {\n                $authority = $this->userInfo . '@' . $authority;\n            }\n\n            if (null !== $this->port) {\n                $authority .= ':' . $this->port;\n            }\n\n            return $authority;\n        }\n\n        public function getUserInfo(): string\n        {\n            return $this->userInfo;\n        }\n\n        public function getHost(): string\n        {\n            return $this->host;\n        }\n\n        public function getPort(): ?int\n        {\n            return $this->port;\n        }\n\n        public function getPath(): string\n        {\n            $path = $this->path;\n\n            if ('' !== $path && '/' !== $path[0]) {\n                if ('' !== $this->host) {\n                    // If the path is rootless and an authority is present, the path MUST be prefixed by \"/\"\n                    $path = '/' . $path;\n                }\n            } elseif (isset($path[1]) && '/' === $path[1]) {\n                // If the path is starting with more than one \"/\", the\n                // starting slashes MUST be reduced to one.\n                $path = '/' . \\ltrim($path, '/');\n            }\n\n            return $path;\n        }\n\n        public function getQuery(): string\n        {\n            return $this->query;\n        }\n\n        public function getFragment(): string\n        {\n            return $this->fragment;\n        }\n\n        /**\n         * @return static\n         */\n        public function withScheme($scheme): UriInterface\n        {\n            if (!\\is_string($scheme)) {\n                throw new \\InvalidArgumentException('Scheme must be a string');\n            }\n\n            if ($this->scheme === $scheme = \\strtr($scheme, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->scheme = $scheme;\n            $new->port = $new->filterPort($new->port);\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withUserInfo($user, $password = null): UriInterface\n        {\n            if (!\\is_string($user)) {\n                throw new \\InvalidArgumentException('User must be a string');\n            }\n\n            $info = \\preg_replace_callback('/[' . self::CHAR_GEN_DELIMS . self::CHAR_SUB_DELIMS . ']++/', [__CLASS__, 'rawurlencodeMatchZero'], $user);\n            if (null !== $password && '' !== $password) {\n                if (!\\is_string($password)) {\n                    throw new \\InvalidArgumentException('Password must be a string');\n                }\n\n                $info .= ':' . \\preg_replace_callback('/[' . self::CHAR_GEN_DELIMS . self::CHAR_SUB_DELIMS . ']++/', [__CLASS__, 'rawurlencodeMatchZero'], $password);\n            }\n\n            if ($this->userInfo === $info) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->userInfo = $info;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withHost($host): UriInterface\n        {\n            if (!\\is_string($host)) {\n                throw new \\InvalidArgumentException('Host must be a string');\n            }\n\n            if ($this->host === $host = \\strtr($host, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->host = $host;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withPort($port): UriInterface\n        {\n            if ($this->port === $port = $this->filterPort($port)) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->port = $port;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withPath($path): UriInterface\n        {\n            if ($this->path === $path = $this->filterPath($path)) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->path = $path;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withQuery($query): UriInterface\n        {\n            if ($this->query === $query = $this->filterQueryAndFragment($query)) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->query = $query;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withFragment($fragment): UriInterface\n        {\n            if ($this->fragment === $fragment = $this->filterQueryAndFragment($fragment)) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->fragment = $fragment;\n\n            return $new;\n        }\n\n        /**\n         * Create a URI string from its various parts.\n         */\n        private static function createUriString(string $scheme, string $authority, string $path, string $query, string $fragment): string\n        {\n            $uri = '';\n            if ('' !== $scheme) {\n                $uri .= $scheme . ':';\n            }\n\n            if ('' !== $authority) {\n                $uri .= '//' . $authority;\n            }\n\n            if ('' !== $path) {\n                if ('/' !== $path[0]) {\n                    if ('' !== $authority) {\n                        // If the path is rootless and an authority is present, the path MUST be prefixed by \"/\"\n                        $path = '/' . $path;\n                    }\n                } elseif (isset($path[1]) && '/' === $path[1]) {\n                    if ('' === $authority) {\n                        // If the path is starting with more than one \"/\" and no authority is present, the\n                        // starting slashes MUST be reduced to one.\n                        $path = '/' . \\ltrim($path, '/');\n                    }\n                }\n\n                $uri .= $path;\n            }\n\n            if ('' !== $query) {\n                $uri .= '?' . $query;\n            }\n\n            if ('' !== $fragment) {\n                $uri .= '#' . $fragment;\n            }\n\n            return $uri;\n        }\n\n        /**\n         * Is a given port non-standard for the current scheme?\n         */\n        private static function isNonStandardPort(string $scheme, int $port): bool\n        {\n            return !isset(self::SCHEMES[$scheme]) || $port !== self::SCHEMES[$scheme];\n        }\n\n        private function filterPort($port): ?int\n        {\n            if (null === $port) {\n                return null;\n            }\n\n            $port = (int) $port;\n            if (0 > $port || 0xFFFF < $port) {\n                throw new \\InvalidArgumentException(\\sprintf('Invalid port: %d. Must be between 0 and 65535', $port));\n            }\n\n            return self::isNonStandardPort($this->scheme, $port) ? $port : null;\n        }\n\n        private function filterPath($path): string\n        {\n            if (!\\is_string($path)) {\n                throw new \\InvalidArgumentException('Path must be a string');\n            }\n\n            return \\preg_replace_callback('/(?:[^' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:@\\/]++|%(?![A-Fa-f0-9]{2}))/', [__CLASS__, 'rawurlencodeMatchZero'], $path);\n        }\n\n        private function filterQueryAndFragment($str): string\n        {\n            if (!\\is_string($str)) {\n                throw new \\InvalidArgumentException('Query and fragment must be a string');\n            }\n\n            return \\preg_replace_callback('/(?:[^' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:@\\/\\?]++|%(?![A-Fa-f0-9]{2}))/', [__CLASS__, 'rawurlencodeMatchZero'], $str);\n        }\n\n        private static function rawurlencodeMatchZero(array $match): string\n        {\n            return \\rawurlencode($match[0]);\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7-server/src/ServerRequestCreator.php\nnamespace Nyholm\\Psr7Server {\n\n    use Psr\\Http\\Message\\ServerRequestFactoryInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Message\\StreamFactoryInterface;\n    use Psr\\Http\\Message\\StreamInterface;\n    use Psr\\Http\\Message\\UploadedFileFactoryInterface;\n    use Psr\\Http\\Message\\UploadedFileInterface;\n    use Psr\\Http\\Message\\UriFactoryInterface;\n    use Psr\\Http\\Message\\UriInterface;\n\n    /**\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     */\n    final class ServerRequestCreator implements ServerRequestCreatorInterface\n    {\n        private $serverRequestFactory;\n\n        private $uriFactory;\n\n        private $uploadedFileFactory;\n\n        private $streamFactory;\n\n        public function __construct(\n            ServerRequestFactoryInterface $serverRequestFactory,\n            UriFactoryInterface $uriFactory,\n            UploadedFileFactoryInterface $uploadedFileFactory,\n            StreamFactoryInterface $streamFactory\n        ) {\n            $this->serverRequestFactory = $serverRequestFactory;\n            $this->uriFactory = $uriFactory;\n            $this->uploadedFileFactory = $uploadedFileFactory;\n            $this->streamFactory = $streamFactory;\n        }\n\n        /**\n         * {@inheritdoc}\n         */\n        public function fromGlobals(): ServerRequestInterface\n        {\n            $server = $_SERVER;\n            if (false === isset($server['REQUEST_METHOD'])) {\n                $server['REQUEST_METHOD'] = 'GET';\n            }\n\n            $headers = \\function_exists('getallheaders') ? getallheaders() : static::getHeadersFromServer($_SERVER);\n\n            $post = null;\n            if ('POST' === $this->getMethodFromEnv($server)) {\n                foreach ($headers as $headerName => $headerValue) {\n                    if (true === \\is_int($headerName) || 'content-type' !== \\strtolower($headerName)) {\n                        continue;\n                    }\n                    if (\\in_array(\n                        \\strtolower(\\trim(\\explode(';', $headerValue, 2)[0])),\n                        ['application/x-www-form-urlencoded', 'multipart/form-data']\n                    )) {\n                        $post = $_POST;\n\n                        break;\n                    }\n                }\n            }\n\n            return $this->fromArrays($server, $headers, $_COOKIE, $_GET, $post, $_FILES, \\fopen('php://input', 'r') ?: null);\n        }\n\n        /**\n         * {@inheritdoc}\n         */\n        public function fromArrays(array $server, array $headers = [], array $cookie = [], array $get = [], ?array $post = null, array $files = [], $body = null): ServerRequestInterface\n        {\n            $method = $this->getMethodFromEnv($server);\n            $uri = $this->getUriFromEnvWithHTTP($server);\n            $protocol = isset($server['SERVER_PROTOCOL']) ? \\str_replace('HTTP/', '', $server['SERVER_PROTOCOL']) : '1.1';\n\n            $serverRequest = $this->serverRequestFactory->createServerRequest($method, $uri, $server);\n            foreach ($headers as $name => $value) {\n                // Because PHP automatically casts array keys set with numeric strings to integers, we have to make sure\n                // that numeric headers will not be sent along as integers, as withAddedHeader can only accept strings.\n                if (\\is_int($name)) {\n                    $name = (string) $name;\n                }\n                $serverRequest = $serverRequest->withAddedHeader($name, $value);\n            }\n\n            $serverRequest = $serverRequest\n                ->withProtocolVersion($protocol)\n                ->withCookieParams($cookie)\n                ->withQueryParams($get)\n                ->withParsedBody($post)\n                ->withUploadedFiles($this->normalizeFiles($files));\n\n            if (null === $body) {\n                return $serverRequest;\n            }\n\n            if (\\is_resource($body)) {\n                $body = $this->streamFactory->createStreamFromResource($body);\n            } elseif (\\is_string($body)) {\n                $body = $this->streamFactory->createStream($body);\n            } elseif (!$body instanceof StreamInterface) {\n                throw new \\InvalidArgumentException('The $body parameter to ServerRequestCreator::fromArrays must be string, resource or StreamInterface');\n            }\n\n            return $serverRequest->withBody($body);\n        }\n\n        /**\n         * Implementation from Laminas\\Diactoros\\marshalHeadersFromSapi().\n         */\n        public static function getHeadersFromServer(array $server): array\n        {\n            $headers = [];\n            foreach ($server as $key => $value) {\n                // Apache prefixes environment variables with REDIRECT_\n                // if they are added by rewrite rules\n                if (0 === \\strpos($key, 'REDIRECT_')) {\n                    $key = \\substr($key, 9);\n\n                    // We will not overwrite existing variables with the\n                    // prefixed versions, though\n                    if (\\array_key_exists($key, $server)) {\n                        continue;\n                    }\n                }\n\n                if ($value && 0 === \\strpos($key, 'HTTP_')) {\n                    $name = \\strtr(\\strtolower(\\substr($key, 5)), '_', '-');\n                    $headers[$name] = $value;\n\n                    continue;\n                }\n\n                if ($value && 0 === \\strpos($key, 'CONTENT_')) {\n                    $name = 'content-'.\\strtolower(\\substr($key, 8));\n                    $headers[$name] = $value;\n\n                    continue;\n                }\n            }\n\n            return $headers;\n        }\n\n        private function getMethodFromEnv(array $environment): string\n        {\n            if (false === isset($environment['REQUEST_METHOD'])) {\n                throw new \\InvalidArgumentException('Cannot determine HTTP method');\n            }\n\n            return $environment['REQUEST_METHOD'];\n        }\n\n        private function getUriFromEnvWithHTTP(array $environment): UriInterface\n        {\n            $uri = $this->createUriFromArray($environment);\n            if (empty($uri->getScheme())) {\n                $uri = $uri->withScheme('http');\n            }\n\n            return $uri;\n        }\n\n        /**\n         * Return an UploadedFile instance array.\n         *\n         * @param array $files A array which respect $_FILES structure\n         *\n         * @return UploadedFileInterface[]\n         *\n         * @throws \\InvalidArgumentException for unrecognized values\n         */\n        private function normalizeFiles(array $files): array\n        {\n            $normalized = [];\n\n            foreach ($files as $key => $value) {\n                if ($value instanceof UploadedFileInterface) {\n                    $normalized[$key] = $value;\n                } elseif (\\is_array($value) && isset($value['tmp_name'])) {\n                    $normalized[$key] = $this->createUploadedFileFromSpec($value);\n                } elseif (\\is_array($value)) {\n                    $normalized[$key] = $this->normalizeFiles($value);\n                } else {\n                    throw new \\InvalidArgumentException('Invalid value in files specification');\n                }\n            }\n\n            return $normalized;\n        }\n\n        /**\n         * Create and return an UploadedFile instance from a $_FILES specification.\n         *\n         * If the specification represents an array of values, this method will\n         * delegate to normalizeNestedFileSpec() and return that return value.\n         *\n         * @param array $value $_FILES struct\n         *\n         * @return array|UploadedFileInterface\n         */\n        private function createUploadedFileFromSpec(array $value)\n        {\n            if (\\is_array($value['tmp_name'])) {\n                return $this->normalizeNestedFileSpec($value);\n            }\n\n            if (UPLOAD_ERR_OK !== $value['error']) {\n                $stream = $this->streamFactory->createStream();\n            } else {\n                try {\n                    $stream = $this->streamFactory->createStreamFromFile($value['tmp_name']);\n                } catch (\\RuntimeException $e) {\n                    $stream = $this->streamFactory->createStream();\n                }\n            }\n\n            return $this->uploadedFileFactory->createUploadedFile(\n                $stream,\n                (int) $value['size'],\n                (int) $value['error'],\n                $value['name'],\n                $value['type']\n            );\n        }\n\n        /**\n         * Normalize an array of file specifications.\n         *\n         * Loops through all nested files and returns a normalized array of\n         * UploadedFileInterface instances.\n         *\n         * @return UploadedFileInterface[]\n         */\n        private function normalizeNestedFileSpec(array $files = []): array\n        {\n            $normalizedFiles = [];\n\n            foreach (\\array_keys($files['tmp_name']) as $key) {\n                $spec = [\n                    'tmp_name' => $files['tmp_name'][$key],\n                    'size' => $files['size'][$key],\n                    'error' => $files['error'][$key],\n                    'name' => $files['name'][$key],\n                    'type' => $files['type'][$key],\n                ];\n                $normalizedFiles[$key] = $this->createUploadedFileFromSpec($spec);\n            }\n\n            return $normalizedFiles;\n        }\n\n        /**\n         * Create a new uri from server variable.\n         *\n         * @param array $server typically $_SERVER or similar structure\n         */\n        private function createUriFromArray(array $server): UriInterface\n        {\n            $uri = $this->uriFactory->createUri('');\n\n            if (isset($server['HTTP_X_FORWARDED_PROTO'])) {\n                $uri = $uri->withScheme($server['HTTP_X_FORWARDED_PROTO']);\n            } else {\n                if (isset($server['REQUEST_SCHEME'])) {\n                    $uri = $uri->withScheme($server['REQUEST_SCHEME']);\n                } elseif (isset($server['HTTPS'])) {\n                    $uri = $uri->withScheme('on' === $server['HTTPS'] ? 'https' : 'http');\n                }\n\n                if (isset($server['SERVER_PORT'])) {\n                    $uri = $uri->withPort($server['SERVER_PORT']);\n                }\n            }\n\n            if (isset($server['HTTP_HOST'])) {\n                if (1 === \\preg_match('/^(.+)\\:(\\d+)$/', $server['HTTP_HOST'], $matches)) {\n                    $uri = $uri->withHost($matches[1])->withPort($matches[2]);\n                } else {\n                    $uri = $uri->withHost($server['HTTP_HOST']);\n                }\n            } elseif (isset($server['SERVER_NAME'])) {\n                $uri = $uri->withHost($server['SERVER_NAME']);\n            }\n\n            if (isset($server['REQUEST_URI'])) {\n                $uri = $uri->withPath(\\current(\\explode('?', $server['REQUEST_URI'])));\n            }\n\n            if (isset($server['QUERY_STRING'])) {\n                $uri = $uri->withQuery($server['QUERY_STRING']);\n            }\n\n            return $uri;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7-server/src/ServerRequestCreatorInterface.php\nnamespace Nyholm\\Psr7Server {\n\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Message\\StreamInterface;\n\n    /**\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     */\n    interface ServerRequestCreatorInterface\n    {\n        /**\n         * Create a new server request from the current environment variables.\n         * Defaults to a GET request to minimise the risk of an \\InvalidArgumentException.\n         * Includes the current request headers as supplied by the server through `getallheaders()`.\n         * If `getallheaders()` is unavailable on the current server it will fallback to its own `getHeadersFromServer()` method.\n         * Defaults to php://input for the request body.\n         *\n         * @throws \\InvalidArgumentException if no valid method or URI can be determined\n         */\n        public function fromGlobals(): ServerRequestInterface;\n\n        /**\n         * Create a new server request from a set of arrays.\n         *\n         * @param array                                $server  typically $_SERVER or similar structure\n         * @param array                                $headers typically the output of getallheaders() or similar structure\n         * @param array                                $cookie  typically $_COOKIE or similar structure\n         * @param array                                $get     typically $_GET or similar structure\n         * @param array|null                           $post    typically $_POST or similar structure, represents parsed request body\n         * @param array                                $files   typically $_FILES or similar structure\n         * @param StreamInterface|resource|string|null $body    Typically stdIn\n         *\n         * @throws \\InvalidArgumentException if no valid method or URI can be determined\n         */\n        public function fromArrays(\n            array $server,\n            array $headers = [],\n            array $cookie = [],\n            array $get = [],\n            ?array $post = null,\n            array $files = [],\n            $body = null\n        ): ServerRequestInterface;\n\n        /**\n         * Get parsed headers from ($_SERVER) array.\n         *\n         * @param array $server typically $_SERVER or similar structure\n         */\n        public static function getHeadersFromServer(array $server): array;\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/Base/BaseCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache\\Base {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Cache;\n\n    class BaseCache implements Cache\n    {\n        public function __construct()\n        {\n        }\n\n        public function set(string $key, string $value, int $ttl = 0): bool\n        {\n            return true;\n        }\n\n        public function get(string $key): string\n        {\n            return '';\n        }\n\n        public function clear(): bool\n        {\n            return true;\n        }\n        \n        public function ping(): int\n        {\n            $start = microtime(true);\n            $this->get('__ping__');\n            return intval((microtime(true)-$start)*1000000);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/Cache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    interface Cache\n    {\n        public function set(string $key, string $value, int $ttl = 0): bool;\n        public function get(string $key): string;\n        public function clear(): bool;\n        public function ping(): int;\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/CacheFactory.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    class CacheFactory\n    {\n        public static function create(string $type, string $prefix, string $config): Cache\n        {\n            switch ($type) {\n                case 'TempFile':\n                    $cache = new TempFileCache($prefix, $config);\n                    break;\n                case 'Redis':\n                    $cache = new RedisCache($prefix, $config);\n                    break;\n                case 'Memcache':\n                    $cache = new MemcacheCache($prefix, $config);\n                    break;\n                case 'Memcached':\n                    $cache = new MemcachedCache($prefix, $config);\n                    break;\n                default:\n                    $cache = new NoCache();\n            }\n            return $cache;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/MemcacheCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Base\\BaseCache;\n\n    class MemcacheCache extends BaseCache implements Cache\n    {\n        protected $prefix;\n        protected $memcache;\n\n        public function __construct(string $prefix, string $config)\n        {\n            $this->prefix = $prefix;\n            if ($config == '') {\n                $address = 'localhost';\n                $port = 11211;\n            } elseif (strpos($config, ':') === false) {\n                $address = $config;\n                $port = 11211;\n            } else {\n                list($address, $port) = explode(':', $config);\n            }\n            $this->memcache = $this->create();\n            $this->memcache->addServer($address, $port);\n        }\n\n        protected function create() /*: \\Memcache*/\n        {\n            return new \\Memcache();\n        }\n\n        public function set(string $key, string $value, int $ttl = 0): bool\n        {\n            return $this->memcache->set($this->prefix . $key, $value, 0, $ttl);\n        }\n\n        public function get(string $key): string\n        {\n            return $this->memcache->get($this->prefix . $key) ?: '';\n        }\n\n        public function clear(): bool\n        {\n            return $this->memcache->flush();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/MemcachedCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    class MemcachedCache extends MemcacheCache\n    {\n        protected function create() /*: \\Memcached*/\n        {\n            return new \\Memcached();\n        }\n\n        public function set(string $key, string $value, int $ttl = 0): bool\n        {\n            return $this->memcache->set($this->prefix . $key, $value, $ttl);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/NoCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Base\\BaseCache;\n\n    class NoCache extends BaseCache implements Cache\n    {\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/RedisCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Base\\BaseCache;\n\n    class RedisCache extends BaseCache implements Cache\n    {\n        protected $prefix;\n        protected $redis;\n\n        public function __construct(string $prefix, string $config)\n        {\n            $this->prefix = $prefix;\n            if ($config == '') {\n                $config = '127.0.0.1';\n            }\n            $params = explode(':', $config, 6);\n            if (isset($params[3])) {\n                $params[3] = null;\n            }\n            $this->redis = new \\Redis();\n            call_user_func_array(array($this->redis, 'pconnect'), $params);\n        }\n\n        public function set(string $key, string $value, int $ttl = 0): bool\n        {\n            return $this->redis->set($this->prefix . $key, $value, $ttl);\n        }\n\n        public function get(string $key): string\n        {\n            return $this->redis->get($this->prefix . $key) ?: '';\n        }\n\n        public function clear(): bool\n        {\n            return $this->redis->flushDb();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/TempFileCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Base\\BaseCache;\n\n    class TempFileCache extends BaseCache implements Cache\n    {\n        const SUFFIX = 'cache';\n\n        private $path;\n        private $segments;\n\n        public function __construct(string $prefix, string $config)\n        {\n            $this->segments = [];\n            $s = DIRECTORY_SEPARATOR;\n            $ps = PATH_SEPARATOR;\n            if ($config == '') {\n                $this->path = sys_get_temp_dir() . $s . $prefix . self::SUFFIX;\n            } elseif (strpos($config, $ps) === false) {\n                $this->path = $config;\n            } else {\n                list($path, $segments) = explode($ps, $config);\n                $this->path = $path;\n                $this->segments = explode(',', $segments);\n            }\n            if (file_exists($this->path) && is_dir($this->path)) {\n                $this->clean($this->path, array_filter($this->segments), strlen(md5('')), false);\n            }\n        }\n\n        private function getFileName(string $key): string\n        {\n            $s = DIRECTORY_SEPARATOR;\n            $md5 = md5($key);\n            $filename = rtrim($this->path, $s) . $s;\n            $i = 0;\n            foreach ($this->segments as $segment) {\n                $filename .= substr($md5, $i, $segment) . $s;\n                $i += $segment;\n            }\n            $filename .= substr($md5, $i);\n            return $filename;\n        }\n\n        public function set(string $key, string $value, int $ttl = 0): bool\n        {\n            $filename = $this->getFileName($key);\n            $dirname = dirname($filename);\n            if (!file_exists($dirname)) {\n                if (!mkdir($dirname, 0755, true)) {\n                    return false;\n                }\n            }\n            $string = $ttl . '|' . $value;\n            return $this->filePutContents($filename, $string) !== false;\n        }\n\n        private function filePutContents($filename, $string)\n        {\n            return file_put_contents($filename, $string, LOCK_EX);\n        }\n\n        private function fileGetContents($filename)\n        {\n            $file = fopen($filename, 'rb');\n            if ($file === false) {\n                return false;\n            }\n            $lock = flock($file, LOCK_SH);\n            if (!$lock) {\n                fclose($file);\n                return false;\n            }\n            $string = '';\n            while (!feof($file)) {\n                $string .= fread($file, 8192);\n            }\n            flock($file, LOCK_UN);\n            fclose($file);\n            return $string;\n        }\n\n        private function getString($filename): string\n        {\n            $data = $this->fileGetContents($filename);\n            if ($data === false) {\n                return '';\n            }\n            if (strpos($data, '|') === false) {\n                return '';\n            }\n            list($ttl, $string) = explode('|', $data, 2);\n            if ($ttl > 0 && time() - filemtime($filename) > $ttl) {\n                return '';\n            }\n            return $string;\n        }\n\n        public function get(string $key): string\n        {\n            $filename = $this->getFileName($key);\n            if (!file_exists($filename)) {\n                return '';\n            }\n            $string = $this->getString($filename);\n            if ($string == null) {\n                return '';\n            }\n            return $string;\n        }\n\n        private function clean(string $path, array $segments, int $len, bool $all) /*: void*/\n        {\n            $entries = scandir($path);\n            foreach ($entries as $entry) {\n                if ($entry === '.' || $entry === '..') {\n                    continue;\n                }\n                $filename = $path . DIRECTORY_SEPARATOR . $entry;\n                if (count($segments) == 0) {\n                    if (strlen($entry) != $len) {\n                        continue;\n                    }\n                    if (file_exists($filename) && is_file($filename)) {\n                        if ($all || $this->getString($filename) == null) {\n                            @unlink($filename);\n                        }\n                    }\n                } else {\n                    if (strlen($entry) != $segments[0]) {\n                        continue;\n                    }\n                    if (file_exists($filename) && is_dir($filename)) {\n                        $this->clean($filename, array_slice($segments, 1), $len - $segments[0], $all);\n                        @rmdir($filename);\n                    }\n                }\n            }\n        }\n\n        public function clear(): bool\n        {\n            if (!file_exists($this->path) || !is_dir($this->path)) {\n                return false;\n            }\n            $this->clean($this->path, array_filter($this->segments), strlen(md5('')), true);\n            return true;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Column/Reflection/ReflectedColumn.php\nnamespace Tqdev\\PhpCrudApi\\Column\\Reflection {\n\n    use Tqdev\\PhpCrudApi\\Database\\GenericReflection;\n\n    class ReflectedColumn implements \\JsonSerializable\n    {\n        const DEFAULT_LENGTH = 255;\n        const DEFAULT_PRECISION = 19;\n        const DEFAULT_SCALE = 4;\n\n        private $name;\n        private $realName;\n        private $type;\n        private $length;\n        private $precision;\n        private $scale;\n        private $nullable;\n        private $pk;\n        private $fk;\n\n        public function __construct(string $name, string $realName, string $type, int $length, int $precision, int $scale, bool $nullable, bool $pk, string $fk)\n        {\n            $this->name = $name;\n            $this->realName = $realName;\n            $this->type = $type;\n            $this->length = $length;\n            $this->precision = $precision;\n            $this->scale = $scale;\n            $this->nullable = $nullable;\n            $this->pk = $pk;\n            $this->fk = $fk;\n            $this->sanitize();\n        }\n\n        private static function parseColumnType(string $columnType, int &$length, int &$precision, int &$scale) /*: void*/\n        {\n            if (!$columnType) {\n                return;\n            }\n            $pos = strpos($columnType, '(');\n            if ($pos) {\n                $dataSize = rtrim(substr($columnType, $pos + 1), ')');\n                if ($length) {\n                    $length = (int) $dataSize;\n                } else {\n                    $pos = strpos($dataSize, ',');\n                    if ($pos) {\n                        $precision = (int) substr($dataSize, 0, $pos);\n                        $scale = (int) substr($dataSize, $pos + 1);\n                    } else {\n                        $precision = (int) $dataSize;\n                        $scale = 0;\n                    }\n                }\n            }\n        }\n\n        private static function getDataSize(int $length, int $precision, int $scale): string\n        {\n            $dataSize = '';\n            if ($length) {\n                $dataSize = $length;\n            } elseif ($precision) {\n                if ($scale) {\n                    $dataSize = $precision . ',' . $scale;\n                } else {\n                    $dataSize = $precision;\n                }\n            }\n            return $dataSize;\n        }\n\n        public static function fromReflection(GenericReflection $reflection, array $columnResult): ReflectedColumn\n        {\n            $name = $columnResult['COLUMN_NAME'];\n            $realName = $columnResult['COLUMN_REAL_NAME'];\n            $dataType = $columnResult['DATA_TYPE'];\n            $length = (int) $columnResult['CHARACTER_MAXIMUM_LENGTH'];\n            $precision = (int) $columnResult['NUMERIC_PRECISION'];\n            $scale = (int) $columnResult['NUMERIC_SCALE'];\n            $columnType = $columnResult['COLUMN_TYPE'];\n            self::parseColumnType($columnType, $length, $precision, $scale);\n            $dataSize = self::getDataSize($length, $precision, $scale);\n            $type = $reflection->toJdbcType($dataType, $dataSize);\n            $nullable = in_array(strtoupper($columnResult['IS_NULLABLE']), ['TRUE', 'YES', 'T', 'Y', '1']);\n            $pk = false;\n            $fk = '';\n            return new ReflectedColumn($name, $realName, $type, $length, $precision, $scale, $nullable, $pk, $fk);\n        }\n\n        public static function fromJson( /* object */$json): ReflectedColumn\n        {\n            $name = $json->alias ?? $json->name;\n            $realName = $json->name;\n            $type = $json->type;\n            $length = isset($json->length) ? (int) $json->length : 0;\n            $precision = isset($json->precision) ? (int) $json->precision : 0;\n            $scale = isset($json->scale) ? (int) $json->scale : 0;\n            $nullable = isset($json->nullable) ? (bool) $json->nullable : false;\n            $pk = isset($json->pk) ? (bool) $json->pk : false;\n            $fk = isset($json->fk) ? $json->fk : '';\n            return new ReflectedColumn($name, $realName, $type, $length, $precision, $scale, $nullable, $pk, $fk);\n        }\n\n        private function sanitize()\n        {\n            $this->length = $this->hasLength() ? $this->getLength() : 0;\n            $this->precision = $this->hasPrecision() ? $this->getPrecision() : 0;\n            $this->scale = $this->hasScale() ? $this->getScale() : 0;\n        }\n\n        public function getName(): string\n        {\n            return $this->name;\n        }\n\n        public function getRealName(): string\n        {\n            return $this->realName;\n        }\n\n        public function getNullable(): bool\n        {\n            return $this->nullable;\n        }\n\n        public function getType(): string\n        {\n            return $this->type;\n        }\n\n        public function getLength(): int\n        {\n            return $this->length ?: self::DEFAULT_LENGTH;\n        }\n\n        public function getPrecision(): int\n        {\n            return $this->precision ?: self::DEFAULT_PRECISION;\n        }\n\n        public function getScale(): int\n        {\n            return $this->scale ?: self::DEFAULT_SCALE;\n        }\n\n        public function hasLength(): bool\n        {\n            return in_array($this->type, ['varchar', 'varbinary']);\n        }\n\n        public function hasPrecision(): bool\n        {\n            return $this->type == 'decimal';\n        }\n\n        public function hasScale(): bool\n        {\n            return $this->type == 'decimal';\n        }\n\n        public function isBinary(): bool\n        {\n            return in_array($this->type, ['blob', 'varbinary']);\n        }\n\n        public function isBoolean(): bool\n        {\n            return $this->type == 'boolean';\n        }\n\n        public function isGeometry(): bool\n        {\n            return $this->type == 'geometry';\n        }\n\n        public function isInteger(): bool\n        {\n            return in_array($this->type, ['integer', 'bigint', 'smallint', 'tinyint']);\n        }\n\n        public function isText(): bool\n        {\n            return in_array($this->type, ['varchar', 'clob']);\n        }\n\n        public function setPk($value) /*: void*/\n        {\n            $this->pk = $value;\n        }\n\n        public function getPk(): bool\n        {\n            return $this->pk;\n        }\n\n        public function setFk($value) /*: void*/\n        {\n            $this->fk = $value;\n        }\n\n        public function getFk(): string\n        {\n            return $this->fk;\n        }\n\n        public function serialize()\n        {\n            $json = [\n                'name' => $this->realName,\n                'alias' => $this->name != $this->realName ? $this->name : null,\n                'type' => $this->type,\n                'length' => $this->length,\n                'precision' => $this->precision,\n                'scale' => $this->scale,\n                'nullable' => $this->nullable,\n                'pk' => $this->pk,\n                'fk' => $this->fk,\n            ];\n            return array_filter($json);\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->serialize();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Column/Reflection/ReflectedDatabase.php\nnamespace Tqdev\\PhpCrudApi\\Column\\Reflection {\n\n    use Tqdev\\PhpCrudApi\\Database\\GenericReflection;\n\n    class ReflectedDatabase implements \\JsonSerializable\n    {\n        private $tableTypes;\n        private $tableRealNames;\n\n        public function __construct(array $tableTypes, array $tableRealNames)\n        {\n            $this->tableTypes = $tableTypes;\n            $this->tableRealNames = $tableRealNames;\n        }\n\n        public static function fromReflection(GenericReflection $reflection): ReflectedDatabase\n        {\n            $tableTypes = [];\n            $tableRealNames = [];\n            foreach ($reflection->getTables() as $table) {\n                $tableName = $table['TABLE_NAME'];\n                if (in_array($tableName, $reflection->getIgnoredTables())) {\n                    continue;\n                }\n                $tableTypes[$tableName] = $table['TABLE_TYPE'];\n                $tableRealNames[$tableName] = $table['TABLE_REAL_NAME'];\n            }\n            return new ReflectedDatabase($tableTypes, $tableRealNames);\n        }\n\n        public static function fromJson( /* object */$json): ReflectedDatabase\n        {\n            $tableTypes = (array) $json->types;\n            $tableRealNames = (array) $json->realNames;\n            return new ReflectedDatabase($tableTypes, $tableRealNames);\n        }\n\n        public function hasTable(string $tableName): bool\n        {\n            return isset($this->tableTypes[$tableName]);\n        }\n\n        public function getType(string $tableName): string\n        {\n            return isset($this->tableTypes[$tableName]) ? $this->tableTypes[$tableName] : '';\n        }\n\n        public function getRealName(string $tableName): string\n        {\n            return isset($this->tableRealNames[$tableName]) ? $this->tableRealNames[$tableName] : '';\n        }\n\n        public function getTableNames(): array\n        {\n            return array_keys($this->tableTypes);\n        }\n\n        public function removeTable(string $tableName): bool\n        {\n            if (!isset($this->tableTypes[$tableName])) {\n                return false;\n            }\n            unset($this->tableTypes[$tableName]);\n            unset($this->tableRealNames[$tableName]);\n            return true;\n        }\n\n        public function serialize()\n        {\n            return [\n                'types' => $this->tableTypes,\n                'realNames' => $this->tableRealNames,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->serialize();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Column/Reflection/ReflectedTable.php\nnamespace Tqdev\\PhpCrudApi\\Column\\Reflection {\n\n    use Tqdev\\PhpCrudApi\\Database\\GenericReflection;\n\n    class ReflectedTable implements \\JsonSerializable\n    {\n        private $name;\n        private $realName;\n        private $type;\n        private $columns;\n        private $pk;\n        private $fks;\n\n        public function __construct(string $name, string $realName, string $type, array $columns)\n        {\n            $this->name = $name;\n            $this->realName = $realName;\n            $this->type = $type;\n            // set columns\n            $this->columns = [];\n            foreach ($columns as $column) {\n                $columnName = $column->getName();\n                $this->columns[$columnName] = $column;\n            }\n            // set primary key\n            $this->pk = null;\n            foreach ($columns as $column) {\n                if ($column->getPk() == true) {\n                    $this->pk = $column;\n                }\n            }\n            // set foreign keys\n            $this->fks = [];\n            foreach ($columns as $column) {\n                $columnName = $column->getName();\n                $referencedTableName = $column->getFk();\n                if ($referencedTableName != '') {\n                    $this->fks[$columnName] = $referencedTableName;\n                }\n            }\n        }\n\n        public static function fromReflection(GenericReflection $reflection, string $name, string $realName, string $type): ReflectedTable\n        {\n            // set columns\n            $columns = [];\n            foreach ($reflection->getTableColumns($name, $type) as $tableColumn) {\n                $column = ReflectedColumn::fromReflection($reflection, $tableColumn);\n                $columns[$column->getName()] = $column;\n            }\n            // set primary key\n            $columnName = false;\n            if ($type == 'view') {\n                $columnName = 'id';\n            } else {\n                $columnNames = $reflection->getTablePrimaryKeys($name);\n                if (count($columnNames) == 1) {\n                    $columnName = $columnNames[0];\n                }\n            }\n            if ($columnName && isset($columns[$columnName])) {\n                $pk = $columns[$columnName];\n                $pk->setPk(true);\n            }\n            // set foreign keys\n            if ($type == 'view') {\n                $tables = $reflection->getTables();\n                foreach ($columns as $columnName => $column) {\n                    if (substr($columnName, -3) == '_id') {\n                        foreach ($tables as $table) {\n                            $tableName = $table['TABLE_NAME'];\n                            $suffix = $tableName . '_id';\n                            if (substr($columnName, -1 * strlen($suffix)) == $suffix) {\n                                $column->setFk($tableName);\n                            }\n                        }\n                    }\n                }\n            } else {\n                $fks = $reflection->getTableForeignKeys($name);\n                foreach ($fks as $columnName => $table) {\n                    $columns[$columnName]->setFk($table);\n                }\n            }\n            return new ReflectedTable($name, $realName, $type, array_values($columns));\n        }\n\n        public static function fromJson( /* object */$json): ReflectedTable\n        {\n            $name = $json->alias??$json->name;\n            $realName = $json->name;\n            $type = isset($json->type) ? $json->type : 'table';\n            $columns = [];\n            if (isset($json->columns) && is_array($json->columns)) {\n                foreach ($json->columns as $column) {\n                    $columns[] = ReflectedColumn::fromJson($column);\n                }\n            }\n            return new ReflectedTable($name, $realName, $type, $columns);\n        }\n\n        public function hasColumn(string $columnName): bool\n        {\n            return isset($this->columns[$columnName]);\n        }\n\n        public function hasPk(): bool\n        {\n            return $this->pk != null;\n        }\n\n        public function getPk() /*: ?ReflectedColumn */\n        {\n            return $this->pk;\n        }\n\n        public function getName(): string\n        {\n            return $this->name;\n        }\n\n        public function getRealName(): string\n        {\n            return $this->realName;\n        }\n\n        public function getType(): string\n        {\n            return $this->type;\n        }\n\n        public function getColumnNames(): array\n        {\n            return array_keys($this->columns);\n        }\n\n        public function getColumn($columnName): ReflectedColumn\n        {\n            return $this->columns[$columnName];\n        }\n\n        public function getFksTo(string $tableName): array\n        {\n            $columns = array();\n            foreach ($this->fks as $columnName => $referencedTableName) {\n                if ($tableName == $referencedTableName && !is_null($this->columns[$columnName])) {\n                    $columns[] = $this->columns[$columnName];\n                }\n            }\n            return $columns;\n        }\n\n        public function removeColumn(string $columnName): bool\n        {\n            if (!isset($this->columns[$columnName])) {\n                return false;\n            }\n            unset($this->columns[$columnName]);\n            return true;\n        }\n\n        public function serialize()\n        {\n            $json = [\n                'name' => $this->realName,\n                'alias' => $this->name!=$this->realName?$this->name:null,\n                'type' => $this->type,\n                'columns' => array_values($this->columns),\n            ];\n            return array_filter($json);\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->serialize();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Column/DefinitionService.php\nnamespace Tqdev\\PhpCrudApi\\Column {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n\n    class DefinitionService\n    {\n        private $db;\n        private $reflection;\n\n        public function __construct(GenericDB $db, ReflectionService $reflection)\n        {\n            $this->db = $db;\n            $this->reflection = $reflection;\n        }\n\n        public function updateTable(ReflectedTable $table, /* object */ $changes): bool\n        {\n            $newTable = ReflectedTable::fromJson((object) array_merge((array) $table->jsonSerialize(), (array) $changes));\n            if ($table->getRealName() != $newTable->getRealName()) {\n                if (!$this->db->definition()->renameTable($table->getRealName(), $newTable->getRealName())) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public function updateColumn(ReflectedTable $table, ReflectedColumn $column, /* object */ $changes): bool\n        {\n            // remove constraints on other column\n            $newColumn = ReflectedColumn::fromJson((object) array_merge((array) $column->jsonSerialize(), (array) $changes));\n            if ($newColumn->getPk() != $column->getPk() && $table->hasPk()) {\n                $oldColumn = $table->getPk();\n                if ($oldColumn->getRealName() != $column->getRealName()) {\n                    $oldColumn->setPk(false);\n                    if (!$this->db->definition()->removeColumnPrimaryKey($table->getRealName(), $oldColumn->getRealName(), $oldColumn)) {\n                        return false;\n                    }\n                }\n            }\n\n            // remove constraints\n            $newColumn = ReflectedColumn::fromJson((object) array_merge((array) $column->jsonSerialize(), ['pk' => false, 'fk' => false]));\n            if ($newColumn->getPk() != $column->getPk() && !$newColumn->getPk()) {\n                if (!$this->db->definition()->removeColumnPrimaryKey($table->getRealName(), $column->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            if ($newColumn->getFk() != $column->getFk() && !$newColumn->getFk()) {\n                if (!$this->db->definition()->removeColumnForeignKey($table->getRealName(), $column->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n\n            // name and type\n            $newColumn = ReflectedColumn::fromJson((object) array_merge((array) $column->jsonSerialize(), (array) $changes));\n            $newColumn->setPk(false);\n            $newColumn->setFk('');\n            if ($newColumn->getRealName() != $column->getRealName()) {\n                if (!$this->db->definition()->renameColumn($table->getRealName(), $column->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            if (\n                $newColumn->getType() != $column->getType() ||\n                $newColumn->getLength() != $column->getLength() ||\n                $newColumn->getPrecision() != $column->getPrecision() ||\n                $newColumn->getScale() != $column->getScale()\n            ) {\n                if (!$this->db->definition()->retypeColumn($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            if ($newColumn->getNullable() != $column->getNullable()) {\n                if (!$this->db->definition()->setColumnNullable($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n\n            // add constraints\n            $newColumn = ReflectedColumn::fromJson((object) array_merge((array) $column->jsonSerialize(), (array) $changes));\n            if ($newColumn->getFk()) {\n                if (!$this->db->definition()->addColumnForeignKey($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            if ($newColumn->getPk()) {\n                if (!$this->db->definition()->addColumnPrimaryKey($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public function addTable(/* object */$definition)\n        {\n            $newTable = ReflectedTable::fromJson($definition);\n            if (!$this->db->definition()->addTable($newTable)) {\n                return false;\n            }\n            return true;\n        }\n\n        public function addColumn(ReflectedTable $table, /* object */ $definition)\n        {\n            $newColumn = ReflectedColumn::fromJson($definition);\n            if (!$this->db->definition()->addColumn($table->getRealName(), $newColumn)) {\n                return false;\n            }\n            if ($newColumn->getFk()) {\n                if (!$this->db->definition()->addColumnForeignKey($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            if ($newColumn->getPk()) {\n                if (!$this->db->definition()->addColumnPrimaryKey($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public function removeTable(ReflectedTable $table)\n        {\n            if (!$this->db->definition()->removeTable($table->getRealName())) {\n                return false;\n            }\n            return true;\n        }\n\n        public function removeColumn(ReflectedTable $table, ReflectedColumn $column)\n        {\n            if ($column->getPk()) {\n                $column->setPk(false);\n                if (!$this->db->definition()->removeColumnPrimaryKey($table->getRealName(), $column->getRealName(), $column)) {\n                    return false;\n                }\n            }\n            if ($column->getFk()) {\n                $column->setFk(\"\");\n                if (!$this->db->definition()->removeColumnForeignKey($table->getRealName(), $column->getRealName(), $column)) {\n                    return false;\n                }\n            }\n            if (!$this->db->definition()->removeColumn($table->getRealName(), $column->getRealName())) {\n                return false;\n            }\n            return true;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Column/ReflectionService.php\nnamespace Tqdev\\PhpCrudApi\\Column {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Cache;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedDatabase;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n\n    class ReflectionService\n    {\n        private $db;\n        private $cache;\n        private $ttl;\n        private $database;\n        private $tables;\n\n        public function __construct(GenericDB $db, Cache $cache, int $ttl)\n        {\n            $this->db = $db;\n            $this->cache = $cache;\n            $this->ttl = $ttl;\n            $this->database = null;\n            $this->tables = [];\n        }\n\n        private function database(): ReflectedDatabase\n        {\n            if ($this->database) {\n                return $this->database;\n            }\n            $this->database = $this->loadDatabase(true);\n            return $this->database;\n        }\n\n        private function loadDatabase(bool $useCache): ReflectedDatabase\n        {\n            $key = sprintf('%s-ReflectedDatabase', $this->db->getCacheKey());\n            $data = $useCache ? $this->cache->get($key) : '';\n            if ($data != '') {\n                $database = ReflectedDatabase::fromJson(json_decode(gzuncompress($data)));\n            } else {\n                $database = ReflectedDatabase::fromReflection($this->db->reflection());\n                $data = gzcompress(json_encode($database, JSON_UNESCAPED_UNICODE));\n                $this->cache->set($key, $data, $this->ttl);\n            }\n            return $database;\n        }\n\n        private function loadTable(string $tableName, bool $useCache): ReflectedTable\n        {\n            $key = sprintf('%s-ReflectedTable(%s)', $this->db->getCacheKey(), $tableName);\n            $data = $useCache ? $this->cache->get($key) : '';\n            if ($data != '') {\n                $table = ReflectedTable::fromJson(json_decode(gzuncompress($data)));\n            } else {\n                $tableType = $this->database()->getType($tableName);\n                $tableRealName = $this->database()->getRealName($tableName);\n                $table = ReflectedTable::fromReflection($this->db->reflection(), $tableName, $tableRealName, $tableType);\n                $data = gzcompress(json_encode($table, JSON_UNESCAPED_UNICODE));\n                $this->cache->set($key, $data, $this->ttl);\n            }\n            return $table;\n        }\n\n        public function refreshTables()\n        {\n            $this->database = $this->loadDatabase(false);\n        }\n\n        public function refreshTable(string $tableName)\n        {\n            $this->tables[$tableName] = $this->loadTable($tableName, false);\n        }\n\n        public function hasTable(string $tableName): bool\n        {\n            return $this->database()->hasTable($tableName);\n        }\n\n        public function getType(string $tableName): string\n        {\n            return $this->database()->getType($tableName);\n        }\n\n        public function getTable(string $tableName): ReflectedTable\n        {\n            if (!isset($this->tables[$tableName])) {\n                $this->tables[$tableName] = $this->loadTable($tableName, true);\n            }\n            return $this->tables[$tableName];\n        }\n\n        public function getTableNames(): array\n        {\n            return $this->database()->getTableNames();\n        }\n\n        public function removeTable(string $tableName): bool\n        {\n            unset($this->tables[$tableName]);\n            return $this->database()->removeTable($tableName);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Config/Base/ConfigInterface.php\nnamespace Tqdev\\PhpCrudApi\\Config\\Base {\n\n    interface ConfigInterface\n    {\n        public function getMiddlewares();\n        public function getProperty(string $key, $default = '');\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Config/Config.php\nnamespace Tqdev\\PhpCrudApi\\Config {\n\n    use Tqdev\\PhpCrudApi\\Config\\Base\\ConfigInterface;\n\n    class Config implements ConfigInterface\n    {\n        private $values = [\n            'driver' => null,\n            'address' => null,\n            'port' => null,\n            'username' => '',\n            'password' => '',\n            'database' => '',\n            'command' => '',\n            'tables' => 'all',\n            'mapping' => '',\n            'middlewares' => 'cors',\n            'controllers' => 'records,geojson,openapi,status',\n            'customControllers' => '',\n            'customOpenApiBuilders' => '',\n            'cacheType' => 'TempFile',\n            'cachePath' => '',\n            'cacheTime' => 10,\n            'jsonOptions' => JSON_UNESCAPED_UNICODE,\n            'debug' => false,\n            'basePath' => '',\n            'openApiBase' => '{\"info\":{\"title\":\"PHP-CRUD-API\",\"version\":\"1.0.0\"}}',\n            'geometrySrid' => 4326,\n        ];\n        \n        public function getUID(): string\n        {\n            return md5(json_encode($this->values));\n        }\n        \n        private function getDefaultDriver(array $values): string\n        {\n            if (isset($values['driver'])) {\n                return $values['driver'];\n            }\n            return 'mysql';\n        }\n\n        private function getDefaultPort(string $driver): int\n        {\n            switch ($driver) {\n                case 'mysql':\n                    return 3306;\n                case 'pgsql':\n                    return 5432;\n                case 'sqlsrv':\n                    return 1433;\n                case 'sqlite':\n                    return 0;\n            }\n        }\n\n        private function getDefaultAddress(string $driver): string\n        {\n            switch ($driver) {\n                case 'mysql':\n                    return 'localhost';\n                case 'pgsql':\n                    return 'localhost';\n                case 'sqlsrv':\n                    return 'localhost';\n                case 'sqlite':\n                    return 'data.db';\n            }\n        }\n\n        private function getDriverDefaults(string $driver): array\n        {\n            return [\n                'driver' => $driver,\n                'address' => $this->getDefaultAddress($driver),\n                'port' => $this->getDefaultPort($driver),\n            ];\n        }\n\n        private function getEnvironmentVariableName(string $key): string\n        {\n            $prefix = \"PHP_CRUD_API_\";\n            $suffix = strtoupper(preg_replace('/(?<!^)[A-Z]/', '_$0', str_replace('.', '_', $key)));\n            return $prefix . $suffix;\n        }\n\n        public function getProperty(string $key, $default = '')\n        {\n            if (strpos($key, 'Handler')) {\n                return $this->values[$key] ?? $default;\n            }\n            $variableName = $this->getEnvironmentVariableName($key);\n            return getenv($variableName, true) ?: ($this->values[$key] ?? $default);\n        }\n\n        public function __construct(array $values)\n        {\n            $defaults = array_merge($this->values, $this->getDriverDefaults($this->getDefaultDriver($values)));\n            foreach ($defaults as $key => $default) {\n                $this->values[$key] = $values[$key] ?? $default;\n                $this->values[$key] = $this->getProperty($key);\n            }\n            $this->values['middlewares'] = array_map('trim', explode(',', $this->values['middlewares']));\n            foreach ($values as $key => $value) {\n                if (strpos($key, '.') === false) {\n                    if (!isset($defaults[$key])) {\n                        throw new \\Exception(\"Config has invalid key '$key'\");\n                    }\n                } else {\n                    $middleware = substr($key, 0, strpos($key, '.'));\n                    if (!in_array($middleware, $this->values['middlewares'])) {\n                        throw new \\Exception(\"Config has invalid middleware key '$key'\");\n                    } else {\n                        $this->values[$key] = $value;\n                    }\n                }\n            }\n        }\n\n        public function getDriver(): string\n        {\n            return $this->values['driver'];\n        }\n\n        public function getAddress(): string\n        {\n            return $this->values['address'];\n        }\n\n        public function getPort(): int\n        {\n            return $this->values['port'];\n        }\n\n        public function getUsername(): string\n        {\n            return $this->values['username'];\n        }\n\n        public function getPassword(): string\n        {\n            return $this->values['password'];\n        }\n\n        public function getDatabase(): string\n        {\n            return $this->values['database'];\n        }\n\n        public function getCommand(): string\n        {\n            return $this->values['command'];\n        }\n\n        public function getTables(): array\n        {\n            return array_filter(array_map('trim', explode(',', $this->values['tables'])));\n        }\n\n        public function getMapping(): array\n        {\n            $mapping = array_map(function ($v) {\n                return explode('=', $v);\n            }, array_filter(array_map('trim', explode(',', $this->values['mapping']))));\n            return array_combine(array_column($mapping, 0), array_column($mapping, 1));\n        }\n\n        public function getMiddlewares(): array\n        {\n            return $this->values['middlewares'];\n        }\n\n        public function getControllers(): array\n        {\n            return array_filter(array_map('trim', explode(',', $this->values['controllers'])));\n        }\n\n        public function getCustomControllers(): array\n        {\n            return array_filter(array_map('trim', explode(',', $this->values['customControllers'])));\n        }\n\n        public function getCustomOpenApiBuilders(): array\n        {\n            return array_filter(array_map('trim', explode(',', $this->values['customOpenApiBuilders'])));\n        }\n\n        public function getCacheType(): string\n        {\n            return $this->values['cacheType'];\n        }\n\n        public function getCachePath(): string\n        {\n            return $this->values['cachePath'];\n        }\n\n        public function getCacheTime(): int\n        {\n            return $this->values['cacheTime'];\n        }\n\n        public function getJsonOptions(): int\n        {\n            return $this->values['jsonOptions'];\n        }\n\n        public function getDebug(): bool\n        {\n            return $this->values['debug'];\n        }\n\n        public function getBasePath(): string\n        {\n            return $this->values['basePath'];\n        }\n\n        public function getOpenApiBase(): array\n        {\n            return json_decode($this->values['openApiBase'], true);\n        }\n\n        public function getGeometrySrid(): int\n        {\n            return $this->values['geometrySrid'];\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/CacheController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Cache\\Cache;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n\n    class CacheController\n    {\n        private $cache;\n        private $responder;\n\n        public function __construct(Router $router, Responder $responder, Cache $cache)\n        {\n            $router->register('GET', '/cache/clear', array($this, 'clear'));\n            $this->cache = $cache;\n            $this->responder = $responder;\n        }\n\n        public function clear(ServerRequestInterface $request): ResponseInterface\n        {\n            return $this->responder->success($this->cache->clear());\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/ColumnController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Column\\DefinitionService;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class ColumnController\n    {\n        private $responder;\n        private $reflection;\n        private $definition;\n\n        public function __construct(Router $router, Responder $responder, ReflectionService $reflection, DefinitionService $definition)\n        {\n            $router->register('GET', '/columns', array($this, 'getDatabase'));\n            $router->register('GET', '/columns/*', array($this, 'getTable'));\n            $router->register('GET', '/columns/*/*', array($this, 'getColumn'));\n            $router->register('PUT', '/columns/*', array($this, 'updateTable'));\n            $router->register('PUT', '/columns/*/*', array($this, 'updateColumn'));\n            $router->register('POST', '/columns', array($this, 'addTable'));\n            $router->register('POST', '/columns/*', array($this, 'addColumn'));\n            $router->register('DELETE', '/columns/*', array($this, 'removeTable'));\n            $router->register('DELETE', '/columns/*/*', array($this, 'removeColumn'));\n            $this->responder = $responder;\n            $this->reflection = $reflection;\n            $this->definition = $definition;\n        }\n\n        public function getDatabase(ServerRequestInterface $request): ResponseInterface\n        {\n            $tables = [];\n            foreach ($this->reflection->getTableNames() as $table) {\n                $tables[] = $this->reflection->getTable($table);\n            }\n            $database = ['tables' => $tables];\n            return $this->responder->success($database);\n        }\n\n        public function getTable(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            return $this->responder->success($table);\n        }\n\n        public function getColumn(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            $columnName = RequestUtils::getPathSegment($request, 3);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            if (!$table->hasColumn($columnName)) {\n                return $this->responder->error(ErrorCode::COLUMN_NOT_FOUND, $columnName);\n            }\n            $column = $table->getColumn($columnName);\n            return $this->responder->success($column);\n        }\n\n        public function updateTable(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            $success = $this->definition->updateTable($table, $request->getParsedBody());\n            if ($success) {\n                $this->reflection->refreshTables();\n            }\n            return $this->responder->success($success);\n        }\n\n        public function updateColumn(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            $columnName = RequestUtils::getPathSegment($request, 3);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            if (!$table->hasColumn($columnName)) {\n                return $this->responder->error(ErrorCode::COLUMN_NOT_FOUND, $columnName);\n            }\n            $column = $table->getColumn($columnName);\n            $success = $this->definition->updateColumn($table, $column, $request->getParsedBody());\n            if ($success) {\n                $this->reflection->refreshTable($tableName);\n            }\n            return $this->responder->success($success);\n        }\n\n        public function addTable(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = $request->getParsedBody()->name;\n            if ($this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_ALREADY_EXISTS, $tableName);\n            }\n            $success = $this->definition->addTable($request->getParsedBody());\n            if ($success) {\n                $this->reflection->refreshTables();\n            }\n            return $this->responder->success($success);\n        }\n\n        public function addColumn(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $columnName = $request->getParsedBody()->name;\n            $table = $this->reflection->getTable($tableName);\n            if ($table->hasColumn($columnName)) {\n                return $this->responder->error(ErrorCode::COLUMN_ALREADY_EXISTS, $columnName);\n            }\n            $success = $this->definition->addColumn($table, $request->getParsedBody());\n            if ($success) {\n                $this->reflection->refreshTable($tableName);\n            }\n            return $this->responder->success($success);\n        }\n\n        public function removeTable(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            $success = $this->definition->removeTable($table);\n            if ($success) {\n                $this->reflection->refreshTables();\n            }\n            return $this->responder->success($success);\n        }\n\n        public function removeColumn(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            $columnName = RequestUtils::getPathSegment($request, 3);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            if (!$table->hasColumn($columnName)) {\n                return $this->responder->error(ErrorCode::COLUMN_NOT_FOUND, $columnName);\n            }\n            $column = $table->getColumn($columnName);\n            $success = $this->definition->removeColumn($table, $column);\n            if ($success) {\n                $this->reflection->refreshTable($tableName);\n            }\n            return $this->responder->success($success);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/GeoJsonController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\GeoJson\\GeoJsonService;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class GeoJsonController\n    {\n        private $service;\n        private $responder;\n\n        public function __construct(Router $router, Responder $responder, GeoJsonService $service)\n        {\n            $router->register('GET', '/geojson/*', array($this, '_list'));\n            $router->register('GET', '/geojson/*/*', array($this, 'read'));\n            $this->service = $service;\n            $this->responder = $responder;\n        }\n\n        public function _list(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            $params = RequestUtils::getParams($request);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            return $this->responder->success($this->service->_list($table, $params));\n        }\n\n        public function read(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if ($this->service->getType($table) != 'table') {\n                return $this->responder->error(ErrorCode::OPERATION_NOT_SUPPORTED, __FUNCTION__);\n            }\n            $id = RequestUtils::getPathSegment($request, 3);\n            $params = RequestUtils::getParams($request);\n            if (strpos($id, ',') !== false) {\n                $ids = explode(',', $id);\n                $result = (object) array('type' => 'FeatureCollection', 'features' => array());\n                for ($i = 0; $i < count($ids); $i++) {\n                    array_push($result->features, $this->service->read($table, $ids[$i], $params));\n                }\n                return $this->responder->success($result);\n            } else {\n                $response = $this->service->read($table, $id, $params);\n                if ($response === null) {\n                    return $this->responder->error(ErrorCode::RECORD_NOT_FOUND, $id);\n                }\n                return $this->responder->success($response);\n            }\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/JsonResponder.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Tqdev\\PhpCrudApi\\Record\\Document\\ErrorDocument;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n    use Tqdev\\PhpCrudApi\\ResponseUtils;\n\n    class JsonResponder implements Responder\n    {\n        private $jsonOptions;\n        private $debug;\n\n        public function __construct(int $jsonOptions, bool $debug)\n        {\n            $this->jsonOptions = $jsonOptions;\n            $this->debug = $debug;\n        }\n\n        public function error(int $error, string $argument, $details = null): ResponseInterface\n        {\n            $document = new ErrorDocument(new ErrorCode($error), $argument, $details);\n            return ResponseFactory::fromObject($document->getStatus(), $document, $this->jsonOptions);\n        }\n\n        public function success($result): ResponseInterface\n        {\n            return ResponseFactory::fromObject(ResponseFactory::OK, $result, $this->jsonOptions);\n        }\n\n        public function exception($exception): ResponseInterface\n        {\n            $document = ErrorDocument::fromException($exception, $this->debug);\n            $response = ResponseFactory::fromObject($document->getStatus(), $document, $this->jsonOptions);\n            if ($this->debug) {\n                $response = ResponseUtils::addExceptionHeaders($response, $exception);\n            }\n            return $response;\n        }\n\n        public function multi($results): ResponseInterface\n        {\n            $documents = array();\n            $errors = array();\n            $success = true;\n            foreach ($results as $i => $result) {\n                if ($result instanceof \\Throwable) {\n                    $documents[$i] = null;\n                    $errors[$i] = ErrorDocument::fromException($result, $this->debug);\n                    $success = false;\n                } else {\n                    $documents[$i] = $result;\n                    $errors[$i] = new ErrorDocument(new ErrorCode(0), '', null);\n                }\n            }\n            $status = $success ? ResponseFactory::OK : ResponseFactory::FAILED_DEPENDENCY;\n            $document = $success ? $documents : $errors;\n            $response = ResponseFactory::fromObject($status, $document, $this->jsonOptions);\n            foreach ($results as $i => $result) {\n                if ($result instanceof \\Throwable) {\n                    if ($this->debug) {\n                        $response = ResponseUtils::addExceptionHeaders($response, $result);\n                    }\n                }\n            }\n            return $response;\n        }\n\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/OpenApiController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiService;\n\n    class OpenApiController\n    {\n        private $openApi;\n        private $responder;\n\n        public function __construct(Router $router, Responder $responder, OpenApiService $openApi)\n        {\n            $router->register('GET', '/openapi', array($this, 'openapi'));\n            $this->openApi = $openApi;\n            $this->responder = $responder;\n        }\n\n        public function openapi(ServerRequestInterface $request): ResponseInterface\n        {\n            return $this->responder->success($this->openApi->get($request));\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/RecordController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\Record\\RecordService;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class RecordController\n    {\n        private $service;\n        private $responder;\n\n        public function __construct(Router $router, Responder $responder, RecordService $service)\n        {\n            $router->register('GET', '/records/*', array($this, '_list'));\n            $router->register('POST', '/records/*', array($this, 'create'));\n            $router->register('GET', '/records/*/*', array($this, 'read'));\n            $router->register('PUT', '/records/*/*', array($this, 'update'));\n            $router->register('DELETE', '/records/*/*', array($this, 'delete'));\n            $router->register('PATCH', '/records/*/*', array($this, 'increment'));\n            $this->service = $service;\n            $this->responder = $responder;\n        }\n\n        public function _list(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            $params = RequestUtils::getParams($request);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            return $this->responder->success($this->service->_list($table, $params));\n        }\n\n        public function read(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if (!$this->service->hasPrimaryKey($table)) {\n                return $this->responder->error(ErrorCode::PRIMARY_KEY_NOT_FOUND, $table);\n            }\n            $id = RequestUtils::getPathSegment($request, 3);\n            $params = RequestUtils::getParams($request);\n            if (strpos($id, ',') !== false) {\n                $ids = explode(',', $id);\n                $argumentLists = array();\n                for ($i = 0; $i < count($ids); $i++) {\n                    $argumentLists[] = array($table, $ids[$i], $params);\n                }\n                return $this->responder->multi($this->multiCall([$this->service, 'read'], $argumentLists));\n            } else {\n                $response = $this->service->read($table, $id, $params);\n                if ($response === null) {\n                    return $this->responder->error(ErrorCode::RECORD_NOT_FOUND, $id);\n                }\n                return $this->responder->success($response);\n            }\n        }\n\n        private function multiCall(callable $method, array $argumentLists): array\n        {\n            $result = array();\n            $success = true;\n            $this->service->beginTransaction();\n            foreach ($argumentLists as $arguments) {\n                try {\n                    $result[] = call_user_func_array($method, $arguments);\n                } catch (\\Throwable $e) {\n                    $success = false;\n                    $result[] = $e;\n                }\n            }\n            if ($success) {\n                $this->service->commitTransaction();\n            } else {\n                $this->service->rollBackTransaction();\n            }\n            return $result;\n        }\n\n        public function create(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if (!$this->service->hasPrimaryKey($table)) {\n                return $this->responder->error(ErrorCode::PRIMARY_KEY_NOT_FOUND, $table);\n            }\n            if ($this->service->getType($table) != 'table') {\n                return $this->responder->error(ErrorCode::OPERATION_NOT_SUPPORTED, 'create');\n            }\n            $record = $request->getParsedBody();\n            if ($record === null) {\n                return $this->responder->error(ErrorCode::HTTP_MESSAGE_NOT_READABLE, '');\n            }\n            $params = RequestUtils::getParams($request);\n            if (is_array($record)) {\n                $argumentLists = array();\n                foreach ($record as $r) {\n                    $argumentLists[] = array($table, $r, $params);\n                }\n                return $this->responder->multi($this->multiCall([$this->service, 'create'], $argumentLists));\n            } else {\n                return $this->responder->success($this->service->create($table, $record, $params));\n            }\n        }\n\n        public function update(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if (!$this->service->hasPrimaryKey($table)) {\n                return $this->responder->error(ErrorCode::PRIMARY_KEY_NOT_FOUND, $table);\n            }\n            if ($this->service->getType($table) != 'table') {\n                return $this->responder->error(ErrorCode::OPERATION_NOT_SUPPORTED, 'update');\n            }\n            $id = RequestUtils::getPathSegment($request, 3);\n            $params = RequestUtils::getParams($request);\n            $record = $request->getParsedBody();\n            if ($record === null) {\n                return $this->responder->error(ErrorCode::HTTP_MESSAGE_NOT_READABLE, '');\n            }\n            $ids = explode(',', $id);\n            if (is_array($record)) {\n                if (count($ids) != count($record)) {\n                    return $this->responder->error(ErrorCode::ARGUMENT_COUNT_MISMATCH, $id);\n                }\n                $argumentLists = array();\n                for ($i = 0; $i < count($ids); $i++) {\n                    $argumentLists[] = array($table, $ids[$i], $record[$i], $params);\n                }\n                return $this->responder->multi($this->multiCall([$this->service, 'update'], $argumentLists));\n            } else {\n                if (count($ids) != 1) {\n                    return $this->responder->error(ErrorCode::ARGUMENT_COUNT_MISMATCH, $id);\n                }\n                return $this->responder->success($this->service->update($table, $id, $record, $params));\n            }\n        }\n\n        public function delete(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if (!$this->service->hasPrimaryKey($table)) {\n                return $this->responder->error(ErrorCode::PRIMARY_KEY_NOT_FOUND, $table);\n            }\n            if ($this->service->getType($table) != 'table') {\n                return $this->responder->error(ErrorCode::OPERATION_NOT_SUPPORTED, 'delete');\n            }\n            $id = RequestUtils::getPathSegment($request, 3);\n            $params = RequestUtils::getParams($request);\n            $ids = explode(',', $id);\n            if (count($ids) > 1) {\n                $argumentLists = array();\n                for ($i = 0; $i < count($ids); $i++) {\n                    $argumentLists[] = array($table, $ids[$i], $params);\n                }\n                return $this->responder->multi($this->multiCall([$this->service, 'delete'], $argumentLists));\n            } else {\n                return $this->responder->success($this->service->delete($table, $id, $params));\n            }\n        }\n\n        public function increment(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if (!$this->service->hasPrimaryKey($table)) {\n                return $this->responder->error(ErrorCode::PRIMARY_KEY_NOT_FOUND, $table);\n            }\n            if ($this->service->getType($table) != 'table') {\n                return $this->responder->error(ErrorCode::OPERATION_NOT_SUPPORTED, 'increment');\n            }\n            $id = RequestUtils::getPathSegment($request, 3);\n            $record = $request->getParsedBody();\n            if ($record === null) {\n                return $this->responder->error(ErrorCode::HTTP_MESSAGE_NOT_READABLE, '');\n            }\n            $params = RequestUtils::getParams($request);\n            $ids = explode(',', $id);\n            if (is_array($record)) {\n                if (count($ids) != count($record)) {\n                    return $this->responder->error(ErrorCode::ARGUMENT_COUNT_MISMATCH, $id);\n                }\n                $argumentLists = array();\n                for ($i = 0; $i < count($ids); $i++) {\n                    $argumentLists[] = array($table, $ids[$i], $record[$i], $params);\n                }\n                return $this->responder->multi($this->multiCall([$this->service, 'increment'], $argumentLists));\n            } else {\n                if (count($ids) != 1) {\n                    return $this->responder->error(ErrorCode::ARGUMENT_COUNT_MISMATCH, $id);\n                }\n                return $this->responder->success($this->service->increment($table, $id, $record, $params));\n            }\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/Responder.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n\n    interface Responder\n    {\n        public function error(int $error, string $argument, $details = null): ResponseInterface;\n\n        public function success($result): ResponseInterface;\n\n        public function multi($results): ResponseInterface;\n\n        public function exception($exception): ResponseInterface;\n\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/StatusController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Cache\\Cache;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n\n    class StatusController\n    {\n        private $db;\n        private $cache;\n        private $responder;\n\n        public function __construct(Router $router, Responder $responder, Cache $cache, GenericDB $db)\n        {\n            $router->register('GET', '/status/ping', array($this, 'ping'));\n            $this->db = $db;\n            $this->cache = $cache;\n            $this->responder = $responder;\n        }\n\n        public function ping(ServerRequestInterface $request): ResponseInterface\n        {\n            $result = [\n                'db' => $this->db->ping(),\n                'cache' => $this->cache->ping(),\n            ];\n            return $this->responder->success($result);\n        }\n\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/ColumnConverter.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n\n    class ColumnConverter\n    {\n        private $driver;\n        private $geometrySrid;\n\n        public function __construct(string $driver, int $geometrySrid)\n        {\n            $this->driver = $driver;\n            $this->geometrySrid = $geometrySrid;\n        }\n\n        public function convertColumnValue(ReflectedColumn $column): string\n        {\n            if ($column->isBoolean()) {\n                switch ($this->driver) {\n                    case 'mysql':\n                        return \"IFNULL(IF(?,TRUE,FALSE),NULL)\";\n                    case 'pgsql':\n                        return \"?\";\n                    case 'sqlsrv':\n                        return \"?\";\n                }\n            }\n            if ($column->isBinary()) {\n                switch ($this->driver) {\n                    case 'mysql':\n                        return \"FROM_BASE64(?)\";\n                    case 'pgsql':\n                        return \"decode(?, 'base64')\";\n                    case 'sqlsrv':\n                        return \"CONVERT(XML, ?).value('.','varbinary(max)')\";\n                }\n            }\n            if ($column->isGeometry()) {\n                $srid = $this->geometrySrid;\n                switch ($this->driver) {\n                    case 'mysql':\n                    case 'pgsql':\n                        return \"ST_GeomFromText(?,$srid)\";\n                    case 'sqlsrv':\n                        return \"geometry::STGeomFromText(?,$srid)\";\n                }\n            }\n            return '?';\n        }\n\n        public function convertColumnName(ReflectedColumn $column, $value): string\n        {\n            if ($column->isBinary()) {\n                switch ($this->driver) {\n                    case 'mysql':\n                        return \"TO_BASE64($value) as $value\";\n                    case 'pgsql':\n                        return \"encode($value::bytea, 'base64') as $value\";\n                    case 'sqlsrv':\n                        return \"CASE WHEN $value IS NULL THEN NULL ELSE (SELECT CAST($value as varbinary(max)) FOR XML PATH(''), BINARY BASE64) END as $value\";\n                }\n            }\n            if ($column->isGeometry()) {\n                switch ($this->driver) {\n                    case 'mysql':\n                    case 'pgsql':\n                        return \"ST_AsText($value) as $value\";\n                    case 'sqlsrv':\n                        return \"REPLACE($value.STAsText(),' (','(') as $value\";\n                }\n            }\n            return $value;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/ColumnsBuilder.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n\n    class ColumnsBuilder\n    {\n        private $driver;\n        private $converter;\n\n        public function __construct(string $driver, int $geometrySrid)\n        {\n            $this->driver = $driver;\n            $this->converter = new ColumnConverter($driver, $geometrySrid);\n        }\n\n        public function getOffsetLimit(int $offset, int $limit): string\n        {\n            if ($limit < 0 || $offset < 0) {\n                return '';\n            }\n            switch ($this->driver) {\n                case 'mysql':\n                    return \" LIMIT $offset, $limit\";\n                case 'pgsql':\n                    return \" LIMIT $limit OFFSET $offset\";\n                case 'sqlsrv':\n                    return \" OFFSET $offset ROWS FETCH NEXT $limit ROWS ONLY\";\n                case 'sqlite':\n                    return \" LIMIT $limit OFFSET $offset\";\n            }\n        }\n\n        private function quoteColumnName(ReflectedColumn $column): string\n        {\n            return '\"' . $column->getRealName() . '\"';\n        }\n\n        public function getOrderBy(ReflectedTable $table, array $columnOrdering): string\n        {\n            if (count($columnOrdering) == 0) {\n                return '';\n            }\n            $results = array();\n            foreach ($columnOrdering as $i => list($columnName, $ordering)) {\n                $column = $table->getColumn($columnName);\n                $quotedColumnName = $this->quoteColumnName($column);\n                $results[] = $quotedColumnName . ' ' . $ordering;\n            }\n            return ' ORDER BY ' . implode(',', $results);\n        }\n\n        public function getSelect(ReflectedTable $table, array $columnNames): string\n        {\n            $results = array();\n            foreach ($columnNames as $columnName) {\n                $column = $table->getColumn($columnName);\n                $quotedColumnName = $this->quoteColumnName($column);\n                $quotedColumnName = $this->converter->convertColumnName($column, $quotedColumnName);\n                $results[] = $quotedColumnName;\n            }\n            return implode(',', $results);\n        }\n\n        public function getInsert(ReflectedTable $table, array $columnValues): string\n        {\n            $columns = array();\n            $values = array();\n            foreach ($columnValues as $columnName => $columnValue) {\n                $column = $table->getColumn($columnName);\n                $quotedColumnName = $this->quoteColumnName($column);\n                $columns[] = $quotedColumnName;\n                $columnValue = $this->converter->convertColumnValue($column);\n                $values[] = $columnValue;\n            }\n            $columnsSql = '(' . implode(',', $columns) . ')';\n            $valuesSql = '(' . implode(',', $values) . ')';\n            $outputColumn = $this->quoteColumnName($table->getPk());\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"$columnsSql VALUES $valuesSql\";\n                case 'pgsql':\n                    return \"$columnsSql VALUES $valuesSql RETURNING $outputColumn\";\n                case 'sqlsrv':\n                    return \"$columnsSql OUTPUT INSERTED.$outputColumn VALUES $valuesSql\";\n                case 'sqlite':\n                    return \"$columnsSql VALUES $valuesSql\";\n            }\n        }\n\n        public function getUpdate(ReflectedTable $table, array $columnValues): string\n        {\n            $results = array();\n            foreach ($columnValues as $columnName => $columnValue) {\n                $column = $table->getColumn($columnName);\n                $quotedColumnName = $this->quoteColumnName($column);\n                $columnValue = $this->converter->convertColumnValue($column);\n                $results[] = $quotedColumnName . '=' . $columnValue;\n            }\n            return implode(',', $results);\n        }\n\n        public function getIncrement(ReflectedTable $table, array $columnValues): string\n        {\n            $results = array();\n            foreach ($columnValues as $columnName => $columnValue) {\n                if (!is_numeric($columnValue)) {\n                    continue;\n                }\n                $column = $table->getColumn($columnName);\n                $quotedColumnName = $this->quoteColumnName($column);\n                $columnValue = $this->converter->convertColumnValue($column);\n                $results[] = $quotedColumnName . '=' . $quotedColumnName . '+' . $columnValue;\n            }\n            return implode(',', $results);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/ConditionsBuilder.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\AndCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\Condition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\NoCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\NotCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\OrCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\SpatialCondition;\n\n    class ConditionsBuilder\n    {\n        private $driver;\n        private $geometrySrid;\n\n        public function __construct(string $driver, int $geometrySrid)\n        {\n            $this->driver = $driver;\n            $this->geometrySrid = $geometrySrid;\n        }\n\n        private function getConditionSql(Condition $condition, array &$arguments): string\n        {\n            if ($condition instanceof AndCondition) {\n                return $this->getAndConditionSql($condition, $arguments);\n            }\n            if ($condition instanceof OrCondition) {\n                return $this->getOrConditionSql($condition, $arguments);\n            }\n            if ($condition instanceof NotCondition) {\n                return $this->getNotConditionSql($condition, $arguments);\n            }\n            if ($condition instanceof SpatialCondition) {\n                return $this->getSpatialConditionSql($condition, $arguments);\n            }\n            if ($condition instanceof ColumnCondition) {\n                return $this->getColumnConditionSql($condition, $arguments);\n            }\n            throw new \\Exception('Unknown Condition: ' . get_class($condition));\n        }\n\n        private function getAndConditionSql(AndCondition $and, array &$arguments): string\n        {\n            $parts = [];\n            foreach ($and->getConditions() as $condition) {\n                $parts[] = $this->getConditionSql($condition, $arguments);\n            }\n            return '(' . implode(' AND ', $parts) . ')';\n        }\n\n        private function getOrConditionSql(OrCondition $or, array &$arguments): string\n        {\n            $parts = [];\n            foreach ($or->getConditions() as $condition) {\n                $parts[] = $this->getConditionSql($condition, $arguments);\n            }\n            return '(' . implode(' OR ', $parts) . ')';\n        }\n\n        private function getNotConditionSql(NotCondition $not, array &$arguments): string\n        {\n            $condition = $not->getCondition();\n            return '(NOT ' . $this->getConditionSql($condition, $arguments) . ')';\n        }\n\n        private function quoteColumnName(ReflectedColumn $column): string\n        {\n            return '\"' . $column->getRealName() . '\"';\n        }\n\n        private function escapeLikeValue(string $value): string\n        {\n            return addcslashes($value, '%_');\n        }\n\n        private function getColumnConditionSql(ColumnCondition $condition, array &$arguments): string\n        {\n            $column = $this->quoteColumnName($condition->getColumn());\n            $operator = $condition->getOperator();\n            $value = $condition->getValue();\n            switch ($operator) {\n                case 'cs':\n                    $sql = \"$column LIKE ?\";\n                    $arguments[] = '%' . $this->escapeLikeValue($value) . '%';\n                    break;\n                case 'sw':\n                    $sql = \"$column LIKE ?\";\n                    $arguments[] = $this->escapeLikeValue($value) . '%';\n                    break;\n                case 'ew':\n                    $sql = \"$column LIKE ?\";\n                    $arguments[] = '%' . $this->escapeLikeValue($value);\n                    break;\n                case 'eq':\n                    $sql = \"$column = ?\";\n                    $arguments[] = $value;\n                    break;\n                case 'lt':\n                    $sql = \"$column < ?\";\n                    $arguments[] = $value;\n                    break;\n                case 'le':\n                    $sql = \"$column <= ?\";\n                    $arguments[] = $value;\n                    break;\n                case 'ge':\n                    $sql = \"$column >= ?\";\n                    $arguments[] = $value;\n                    break;\n                case 'gt':\n                    $sql = \"$column > ?\";\n                    $arguments[] = $value;\n                    break;\n                case 'bt':\n                    $parts = explode(',', $value, 2);\n                    $count = count($parts);\n                    if ($count == 2) {\n                        $sql = \"($column >= ? AND $column <= ?)\";\n                        $arguments[] = $parts[0];\n                        $arguments[] = $parts[1];\n                    } else {\n                        $sql = \"FALSE\";\n                    }\n                    break;\n                case 'in':\n                    $parts = explode(',', $value);\n                    $count = count($parts);\n                    if ($count > 0) {\n                        $qmarks = implode(',', str_split(str_repeat('?', $count)));\n                        $sql = \"$column IN ($qmarks)\";\n                        for ($i = 0; $i < $count; $i++) {\n                            $arguments[] = $parts[$i];\n                        }\n                    } else {\n                        $sql = \"FALSE\";\n                    }\n                    break;\n                case 'is':\n                    $sql = \"$column IS NULL\";\n                    break;\n            }\n            return $sql;\n        }\n\n        private function getSpatialFunctionName(string $operator): string\n        {\n            switch ($operator) {\n                case 'co':\n                    return 'ST_Contains';\n                case 'cr':\n                    return 'ST_Crosses';\n                case 'di':\n                    return 'ST_Disjoint';\n                case 'eq':\n                    return 'ST_Equals';\n                case 'in':\n                    return 'ST_Intersects';\n                case 'ov':\n                    return 'ST_Overlaps';\n                case 'to':\n                    return 'ST_Touches';\n                case 'wi':\n                    return 'ST_Within';\n                case 'ic':\n                    return 'ST_IsClosed';\n                case 'is':\n                    return 'ST_IsSimple';\n                case 'iv':\n                    return 'ST_IsValid';\n            }\n        }\n\n        private function hasSpatialArgument(string $operator): bool\n        {\n            return in_array($operator, ['ic', 'is', 'iv']) ? false : true;\n        }\n\n        private function getSpatialFunctionCall(string $functionName, string $column, bool $hasArgument): string\n        {\n            $srid = $this->geometrySrid;\n            switch ($this->driver) {\n                case 'mysql':\n                case 'pgsql':\n                    $argument = $hasArgument ? \"ST_GeomFromText(?,$srid)\" : '';\n                    return \"$functionName($column, $argument)=TRUE\";\n                case 'sqlsrv':\n                    $functionName = str_replace('ST_', 'ST', $functionName);\n                    $argument = $hasArgument ? \"geometry::STGeomFromText(?,$srid)\" : '';\n                    return \"$column.$functionName($argument)=1\";\n                case 'sqlite':\n                    $argument = $hasArgument ? '?' : '0';\n                    return \"$functionName($column, $argument)=1\";\n            }\n        }\n\n        private function getSpatialConditionSql(ColumnCondition $condition, array &$arguments): string\n        {\n            $column = $this->quoteColumnName($condition->getColumn());\n            $operator = $condition->getOperator();\n            $value = $condition->getValue();\n            $functionName = $this->getSpatialFunctionName($operator);\n            $hasArgument = $this->hasSpatialArgument($operator);\n            $sql = $this->getSpatialFunctionCall($functionName, $column, $hasArgument);\n            if ($hasArgument) {\n                $arguments[] = $value;\n            }\n            return $sql;\n        }\n\n        public function getWhereClause(Condition $condition, array &$arguments): string\n        {\n            if ($condition instanceof NoCondition) {\n                return '';\n            }\n            return ' WHERE ' . $this->getConditionSql($condition, $arguments);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/DataConverter.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n\n    class DataConverter\n    {\n        private $driver;\n\n        public function __construct(string $driver)\n        {\n            $this->driver = $driver;\n        }\n\n        private function convertRecordValue($conversion, $value)\n        {\n            $args = explode('|', $conversion);\n            $type = array_shift($args);\n            switch ($type) {\n                case 'boolean':\n                    return $value ? true : false;\n                case 'integer':\n                    return (int) $value;\n                case 'float':\n                    return (float) $value;\n                case 'decimal':\n                    return number_format($value, $args[0], '.', '');\n            }\n            return $value;\n        }\n\n        private function getRecordValueConversion(ReflectedColumn $column): string\n        {\n            if ($column->isBoolean()) {\n                return 'boolean';\n            }\n            if (in_array($column->getType(), ['integer', 'bigint'])) {\n                return 'integer';\n            }\n            if (in_array($column->getType(), ['float', 'double'])) {\n                return 'float';\n            }\n            if (in_array($this->driver, ['sqlite']) && in_array($column->getType(), ['decimal'])) {\n                return 'decimal|' . $column->getScale();\n            }\n            return 'none';\n        }\n\n        public function convertRecords(ReflectedTable $table, array $columnNames, array &$records) /*: void*/\n        {\n            foreach ($columnNames as $columnName) {\n                $column = $table->getColumn($columnName);\n                $conversion = $this->getRecordValueConversion($column);\n                if ($conversion != 'none') {\n                    foreach ($records as $i => $record) {\n                        $value = $records[$i][$columnName];\n                        if ($value === null) {\n                            continue;\n                        }\n                        $records[$i][$columnName] = $this->convertRecordValue($conversion, $value);\n                    }\n                }\n            }\n        }\n\n        private function convertInputValue($conversion, $value)\n        {\n            switch ($conversion) {\n                case 'boolean':\n                    return filter_var($value, FILTER_VALIDATE_BOOLEAN) ? 1 : 0;\n                case 'base64url_to_base64':\n                    return str_pad(strtr($value, '-_', '+/'), ceil(strlen($value) / 4) * 4, '=', STR_PAD_RIGHT);\n            }\n            return $value;\n        }\n\n        private function getInputValueConversion(ReflectedColumn $column): string\n        {\n            if ($column->isBoolean()) {\n                return 'boolean';\n            }\n            if ($column->isBinary()) {\n                return 'base64url_to_base64';\n            }\n            return 'none';\n        }\n\n        public function convertColumnValues(ReflectedTable $table, array &$columnValues) /*: void*/\n        {\n            $columnNames = array_keys($columnValues);\n            foreach ($columnNames as $columnName) {\n                $column = $table->getColumn($columnName);\n                $conversion = $this->getInputValueConversion($column);\n                if ($conversion != 'none') {\n                    $value = $columnValues[$columnName];\n                    if ($value !== null) {\n                        $columnValues[$columnName] = $this->convertInputValue($conversion, $value);\n                    }\n                }\n            }\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/GenericDB.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\Condition;\n\n    class GenericDB\n    {\n        private $driver;\n        private $address;\n        private $port;\n        private $database;\n        private $command;\n        private $tables;\n        private $mapping;\n        private $username;\n        private $password;\n        private $pdo;\n        private $mapper;\n        private $reflection;\n        private $definition;\n        private $conditions;\n        private $columns;\n        private $converter;\n        private $geometrySrid;\n\n        private function getDsn(): string\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"$this->driver:host=$this->address;port=$this->port;dbname=$this->database;charset=utf8mb4\";\n                case 'pgsql':\n                    return \"$this->driver:host=$this->address port=$this->port dbname=$this->database options='--client_encoding=UTF8'\";\n                case 'sqlsrv':\n                    return \"$this->driver:Server=$this->address,$this->port;Database=$this->database\";\n                case 'sqlite':\n                    return \"$this->driver:$this->address\";\n            }\n        }\n\n        private function getCommands(): array\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    $commands = [\n                        'SET SESSION sql_warnings=1;',\n                        'SET NAMES utf8mb4;',\n                        'SET SESSION sql_mode = \"ANSI,TRADITIONAL\";',\n                    ];\n                    break;\n                case 'pgsql':\n                    $commands = [\n                        \"SET NAMES 'UTF8';\",\n                    ];\n                    break;\n                case 'sqlsrv':\n                    $commands = [];\n                    break;\n                case 'sqlite':\n                    $commands = [\n                        'PRAGMA foreign_keys = on;',\n                    ];\n                    break;\n            }\n            if ($this->command != '') {\n                $commands[] = $this->command;\n            }\n            return $commands;\n        }\n\n        private function getOptions(): array\n        {\n            $options = array(\n                \\PDO::ATTR_ERRMODE => \\PDO::ERRMODE_EXCEPTION,\n                \\PDO::ATTR_DEFAULT_FETCH_MODE => \\PDO::FETCH_ASSOC,\n            );\n            switch ($this->driver) {\n                case 'mysql':\n                    return $options + [\n                        \\PDO::MYSQL_ATTR_FOUND_ROWS => true,\n                        \\PDO::ATTR_PERSISTENT => true,\n                    ];\n                case 'pgsql':\n                    return $options + [\n                        \\PDO::ATTR_PERSISTENT => true,\n                    ];\n                case 'sqlsrv':\n                    return $options + [];\n                case 'sqlite':\n                    return $options + [];\n            }\n        }\n\n        private function initPdo(): bool\n        {\n            if ($this->pdo) {\n                $result = $this->pdo->reconstruct($this->getDsn(), $this->username, $this->password, $this->getOptions());\n            } else {\n                $this->pdo = new LazyPdo($this->getDsn(), $this->username, $this->password, $this->getOptions());\n                $result = true;\n            }\n            $commands = $this->getCommands();\n            foreach ($commands as $command) {\n                $this->pdo->addInitCommand($command);\n            }\n            $this->mapper = new RealNameMapper($this->mapping);\n            $this->reflection = new GenericReflection($this->pdo, $this->driver, $this->database, $this->tables, $this->mapper);\n            $this->definition = new GenericDefinition($this->pdo, $this->driver, $this->database, $this->tables, $this->mapper);\n            $this->conditions = new ConditionsBuilder($this->driver, $this->geometrySrid);\n            $this->columns = new ColumnsBuilder($this->driver, $this->geometrySrid);\n            $this->converter = new DataConverter($this->driver);\n            return $result;\n        }\n\n        public function __construct(string $driver, string $address, int $port, string $database, string $command, array $tables, array $mapping, string $username, string $password, int $geometrySrid)\n        {\n            $this->driver = $driver;\n            $this->address = $address;\n            $this->port = $port;\n            $this->database = $database;\n            $this->command = $command;\n            $this->tables = $tables;\n            $this->mapping = $mapping;\n            $this->username = $username;\n            $this->password = $password;\n            $this->geometrySrid = $geometrySrid;\n            $this->initPdo();\n        }\n\n        public function reconstruct(string $driver, string $address, int $port, string $database, string $command, array $tables, array $mapping, string $username, string $password, int $geometrySrid): bool\n        {\n            if ($driver) {\n                $this->driver = $driver;\n            }\n            if ($address) {\n                $this->address = $address;\n            }\n            if ($port) {\n                $this->port = $port;\n            }\n            if ($database) {\n                $this->database = $database;\n            }\n            if ($command) {\n                $this->command = $command;\n            }\n            if ($tables) {\n                $this->tables = $tables;\n            }\n            if ($mapping) {\n                $this->mapping = $mapping;\n            }\n            if ($username) {\n                $this->username = $username;\n            }\n            if ($password) {\n                $this->password = $password;\n            }\n            if ($geometrySrid) {\n                $this->geometrySrid = $geometrySrid;\n            }\n            return $this->initPdo();\n        }\n\n        public function pdo(): LazyPdo\n        {\n            return $this->pdo;\n        }\n\n        public function reflection(): GenericReflection\n        {\n            return $this->reflection;\n        }\n\n        public function definition(): GenericDefinition\n        {\n            return $this->definition;\n        }\n\n        public function beginTransaction() /*: void*/\n        {\n            $this->pdo->beginTransaction();\n        }\n\n        public function commitTransaction() /*: void*/\n        {\n            $this->pdo->commit();\n        }\n\n        public function rollBackTransaction() /*: void*/\n        {\n            $this->pdo->rollBack();\n        }\n\n        private function addMiddlewareConditions(string $tableName, Condition $condition): Condition\n        {\n            $condition1 = VariableStore::get(\"authorization.conditions.$tableName\");\n            if ($condition1) {\n                $condition = $condition->_and($condition1);\n            }\n            $condition2 = VariableStore::get(\"multiTenancy.conditions.$tableName\");\n            if ($condition2) {\n                $condition = $condition->_and($condition2);\n            }\n            return $condition;\n        }\n\n        public function createSingle(ReflectedTable $table, array $columnValues) /*: ?String*/\n        {\n            $this->converter->convertColumnValues($table, $columnValues);\n            $insertColumns = $this->columns->getInsert($table, $columnValues);\n            $tableRealName = $table->getRealName();\n            $pkName = $table->getPk()->getName();\n            $parameters = array_values($columnValues);\n            $sql = 'INSERT INTO \"' . $tableRealName . '\" ' . $insertColumns;\n            $stmt = $this->query($sql, $parameters);\n            // return primary key value if specified in the input\n            if (isset($columnValues[$pkName])) {\n                return $columnValues[$pkName];\n            }\n            // work around missing \"returning\" or \"output\" in mysql\n            switch ($this->driver) {\n                case 'mysql':\n                    $stmt = $this->query('SELECT LAST_INSERT_ID()', []);\n                    break;\n                case 'sqlite':\n                    $stmt = $this->query('SELECT LAST_INSERT_ROWID()', []);\n                    break;\n            }\n            $pkValue = $stmt->fetchColumn(0);\n            if ($table->getPk()->getType() == 'bigint') {\n                return (int) $pkValue;\n            }\n            if (in_array($table->getPk()->getType(), ['integer', 'bigint'])) {\n                return (int) $pkValue;\n            }\n            return $pkValue;\n        }\n\n        public function selectSingle(ReflectedTable $table, array $columnNames, string $id) /*: ?array*/\n        {\n            $selectColumns = $this->columns->getSelect($table, $columnNames);\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = new ColumnCondition($table->getPk(), 'eq', $id);\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array();\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'SELECT ' . $selectColumns . ' FROM \"' . $tableRealName . '\" ' . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            $record = $stmt->fetch() ?: null;\n            if ($record === null) {\n                return null;\n            }\n            $records = array($record);\n            $records = $this->mapRecords($tableRealName, $records);\n            $this->converter->convertRecords($table, $columnNames, $records);\n            return $records[0];\n        }\n\n        public function selectMultiple(ReflectedTable $table, array $columnNames, array $ids): array\n        {\n            if (count($ids) == 0) {\n                return [];\n            }\n            $selectColumns = $this->columns->getSelect($table, $columnNames);\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = new ColumnCondition($table->getPk(), 'in', implode(',', $ids));\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array();\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'SELECT ' . $selectColumns . ' FROM \"' . $tableRealName . '\" ' . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            $records = $stmt->fetchAll();\n            $records = $this->mapRecords($tableRealName, $records);\n            $this->converter->convertRecords($table, $columnNames, $records);\n            return $records;\n        }\n\n        public function selectCount(ReflectedTable $table, Condition $condition): int\n        {\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array();\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'SELECT COUNT(*) FROM \"' . $tableRealName . '\"' . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            return $stmt->fetchColumn(0);\n        }\n\n        private function mapRecords(string $tableRealName, array $records): array\n        {\n            $mappedRecords = [];\n            foreach ($records as $record) {\n                $mappedRecord = [];\n                foreach ($record as $columnRealName => $columnValue) {\n                    $mappedRecord[$this->mapper->getColumnName($tableRealName, $columnRealName)] = $columnValue;\n                }\n                $mappedRecords[] = $mappedRecord;\n            }\n            return $mappedRecords;\n        }\n\n        public function selectAll(ReflectedTable $table, array $columnNames, Condition $condition, array $columnOrdering, int $offset, int $limit): array\n        {\n            if ($limit == 0) {\n                return array();\n            }\n            $selectColumns = $this->columns->getSelect($table, $columnNames);\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array();\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $orderBy = $this->columns->getOrderBy($table, $columnOrdering);\n            $offsetLimit = $this->columns->getOffsetLimit($offset, $limit);\n            $sql = 'SELECT ' . $selectColumns . ' FROM \"' . $tableRealName . '\"' . $whereClause . $orderBy . $offsetLimit;\n            $stmt = $this->query($sql, $parameters);\n            $records = $stmt->fetchAll();\n            $records = $this->mapRecords($tableRealName, $records);\n            $this->converter->convertRecords($table, $columnNames, $records);\n            return $records;\n        }\n\n        public function updateSingle(ReflectedTable $table, array $columnValues, string $id)\n        {\n            if (count($columnValues) == 0) {\n                return 0;\n            }\n            $this->converter->convertColumnValues($table, $columnValues);\n            $updateColumns = $this->columns->getUpdate($table, $columnValues);\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = new ColumnCondition($table->getPk(), 'eq', $id);\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array_values($columnValues);\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'UPDATE \"' . $tableRealName . '\" SET ' . $updateColumns . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            return $stmt->rowCount();\n        }\n\n        public function deleteSingle(ReflectedTable $table, string $id)\n        {\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = new ColumnCondition($table->getPk(), 'eq', $id);\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array();\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'DELETE FROM \"' . $tableRealName . '\" ' . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            return $stmt->rowCount();\n        }\n\n        public function incrementSingle(ReflectedTable $table, array $columnValues, string $id)\n        {\n            if (count($columnValues) == 0) {\n                return 0;\n            }\n            $this->converter->convertColumnValues($table, $columnValues);\n            $updateColumns = $this->columns->getIncrement($table, $columnValues);\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = new ColumnCondition($table->getPk(), 'eq', $id);\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array_values($columnValues);\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'UPDATE \"' . $tableRealName . '\" SET ' . $updateColumns . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            return $stmt->rowCount();\n        }\n\n        private function query(string $sql, array $parameters): \\PDOStatement\n        {\n            $stmt = $this->pdo->prepare($sql);\n            //echo \"- $sql -- \" . json_encode($parameters, JSON_UNESCAPED_UNICODE) . \"\\n\";\n            $stmt->execute($parameters);\n            return $stmt;\n        }\n\n        public function ping(): int\n        {\n            $start = microtime(true);\n            $stmt = $this->pdo->prepare('SELECT 1');\n            $stmt->execute();\n            return intval((microtime(true) - $start) * 1000000);\n        }\n\n        public function getCacheKey(): string\n        {\n            return md5(json_encode([\n                $this->driver,\n                $this->address,\n                $this->port,\n                $this->database,\n                $this->tables,\n                $this->mapping,\n                $this->username,\n            ]));\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/GenericDefinition.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Database\\LazyPdo;\n\n    class GenericDefinition\n    {\n        private $pdo;\n        private $driver;\n        private $database;\n        private $typeConverter;\n        private $reflection;\n\n        public function __construct(LazyPdo $pdo, string $driver, string $database, array $tables, RealNameMapper $mapper)\n        {\n            $this->pdo = $pdo;\n            $this->driver = $driver;\n            $this->database = $database;\n            $this->typeConverter = new TypeConverter($driver);\n            $this->reflection = new GenericReflection($pdo, $driver, $database, $tables, $mapper);\n        }\n\n        private function quote(string $identifier): string\n        {\n            return '\"' . str_replace('\"', '', $identifier) . '\"';\n        }\n\n        public function getColumnType(ReflectedColumn $column, bool $update): string\n        {\n            if ($this->driver == 'pgsql' && !$update && $column->getPk() && $this->canAutoIncrement($column)) {\n                return 'serial';\n            }\n            $type = $this->typeConverter->fromJdbc($column->getType());\n            if ($column->hasPrecision() && $column->hasScale()) {\n                $size = '(' . $column->getPrecision() . ',' . $column->getScale() . ')';\n            } elseif ($column->hasPrecision()) {\n                $size = '(' . $column->getPrecision() . ')';\n            } elseif ($column->hasLength()) {\n                $size = '(' . $column->getLength() . ')';\n            } else {\n                $size = '';\n            }\n            $null = $this->getColumnNullType($column, $update);\n            $auto = $this->getColumnAutoIncrement($column, $update);\n            return $type . $size . $null . $auto;\n        }\n\n        private function getPrimaryKey(string $tableName): string\n        {\n            $pks = $this->reflection->getTablePrimaryKeys($tableName);\n            if (count($pks) == 1) {\n                return $pks[0];\n            }\n            return \"\";\n        }\n\n        private function canAutoIncrement(ReflectedColumn $column): bool\n        {\n            return in_array($column->getType(), ['integer', 'bigint']);\n        }\n\n        private function getColumnAutoIncrement(ReflectedColumn $column, bool $update): string\n        {\n            if (!$this->canAutoIncrement($column)) {\n                return '';\n            }\n            switch ($this->driver) {\n                case 'mysql':\n                    return $column->getPk() ? ' AUTO_INCREMENT' : '';\n                case 'pgsql':\n                case 'sqlsrv':\n                    return $column->getPk() ? ' IDENTITY(1,1)' : '';\n                case 'sqlite':\n                    return $column->getPk() ? ' AUTOINCREMENT' : '';\n            }\n        }\n\n        private function getColumnNullType(ReflectedColumn $column, bool $update): string\n        {\n            if ($this->driver == 'pgsql' && $update) {\n                return '';\n            }\n            return $column->getNullable() ? ' NULL' : ' NOT NULL';\n        }\n\n        private function getTableRenameSQL(string $tableName, string $newTableName): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($newTableName);\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"RENAME TABLE $p1 TO $p2\";\n                case 'pgsql':\n                    return \"ALTER TABLE $p1 RENAME TO $p2\";\n                case 'sqlsrv':\n                    return \"EXEC sp_rename $p1, $p2\";\n                case 'sqlite':\n                    return \"ALTER TABLE $p1 RENAME TO $p2\";\n            }\n        }\n\n        private function getColumnRenameSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($newColumn->getRealName());\n\n            switch ($this->driver) {\n                case 'mysql':\n                    $p4 = $this->getColumnType($newColumn, true);\n                    return \"ALTER TABLE $p1 CHANGE $p2 $p3 $p4\";\n                case 'pgsql':\n                    return \"ALTER TABLE $p1 RENAME COLUMN $p2 TO $p3\";\n                case 'sqlsrv':\n                    $p4 = $this->quote($tableName . '.' . $columnName);\n                    return \"EXEC sp_rename $p4, $p3, 'COLUMN'\";\n                case 'sqlite':\n                    return \"ALTER TABLE $p1 RENAME COLUMN $p2 TO $p3\";\n            }\n        }\n\n        private function getColumnRetypeSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($newColumn->getRealName());\n            $p4 = $this->getColumnType($newColumn, true);\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"ALTER TABLE $p1 CHANGE $p2 $p3 $p4\";\n                case 'pgsql':\n                    return \"ALTER TABLE $p1 ALTER COLUMN $p3 TYPE $p4\";\n                case 'sqlsrv':\n                    return \"ALTER TABLE $p1 ALTER COLUMN $p3 $p4\";\n            }\n        }\n\n        private function getSetColumnNullableSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($newColumn->getRealName());\n            $p4 = $this->getColumnType($newColumn, true);\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"ALTER TABLE $p1 CHANGE $p2 $p3 $p4\";\n                case 'pgsql':\n                    $p5 = $newColumn->getNullable() ? 'DROP NOT NULL' : 'SET NOT NULL';\n                    return \"ALTER TABLE $p1 ALTER COLUMN $p2 $p5\";\n                case 'sqlsrv':\n                    return \"ALTER TABLE $p1 ALTER COLUMN $p2 $p4\";\n            }\n        }\n\n        private function getSetColumnPkConstraintSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($tableName . '_pkey');\n\n            switch ($this->driver) {\n                case 'mysql':\n                    $p4 = $newColumn->getPk() ? \"ADD PRIMARY KEY ($p2)\" : 'DROP PRIMARY KEY';\n                    return \"ALTER TABLE $p1 $p4\";\n                case 'pgsql':\n                case 'sqlsrv':\n                    $p4 = $newColumn->getPk() ? \"ADD CONSTRAINT $p3 PRIMARY KEY ($p2)\" : \"DROP CONSTRAINT $p3\";\n                    return \"ALTER TABLE $p1 $p4\";\n            }\n        }\n\n        private function getSetColumnPkSequenceSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($tableName . '_' . $columnName . '_seq');\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"select 1\";\n                case 'pgsql':\n                    return $newColumn->getPk() ? \"CREATE SEQUENCE $p3 OWNED BY $p1.$p2\" : \"DROP SEQUENCE $p3\";\n                case 'sqlsrv':\n                    return $newColumn->getPk() ? \"CREATE SEQUENCE $p3\" : \"DROP SEQUENCE $p3\";\n            }\n        }\n\n        private function getSetColumnPkSequenceStartSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"select 1\";\n                case 'pgsql':\n                    $p3 = $this->pdo->quote($tableName . '_' . $columnName . '_seq');\n                    return \"SELECT setval($p3, (SELECT max($p2)+1 FROM $p1));\";\n                case 'sqlsrv':\n                    $p3 = $this->quote($tableName . '_' . $columnName . '_seq');\n                    $p4 = $this->pdo->query(\"SELECT max($p2)+1 FROM $p1\")->fetchColumn();\n                    return \"ALTER SEQUENCE $p3 RESTART WITH $p4\";\n            }\n        }\n\n        private function getSetColumnPkDefaultSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n\n            switch ($this->driver) {\n                case 'mysql':\n                    $p3 = $this->quote($newColumn->getRealName());\n                    $p4 = $this->getColumnType($newColumn, true);\n                    return \"ALTER TABLE $p1 CHANGE $p2 $p3 $p4\";\n                case 'pgsql':\n                    if ($newColumn->getPk()) {\n                        $p3 = $this->pdo->quote($tableName . '_' . $columnName . '_seq');\n                        $p4 = \"SET DEFAULT nextval($p3)\";\n                    } else {\n                        $p4 = 'DROP DEFAULT';\n                    }\n                    return \"ALTER TABLE $p1 ALTER COLUMN $p2 $p4\";\n                case 'sqlsrv':\n                    $p3 = $this->quote($tableName . '_' . $columnName . '_seq');\n                    $p4 = $this->quote($tableName . '_' . $columnName . '_def');\n                    if ($newColumn->getPk()) {\n                        return \"ALTER TABLE $p1 ADD CONSTRAINT $p4 DEFAULT NEXT VALUE FOR $p3 FOR $p2\";\n                    } else {\n                        return \"ALTER TABLE $p1 DROP CONSTRAINT $p4\";\n                    }\n            }\n        }\n\n        private function getAddColumnFkConstraintSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($tableName . '_' . $columnName . '_fkey');\n            $p4 = $this->quote($newColumn->getFk());\n            $p5 = $this->quote($this->getPrimaryKey($newColumn->getFk()));\n\n            return \"ALTER TABLE $p1 ADD CONSTRAINT $p3 FOREIGN KEY ($p2) REFERENCES $p4 ($p5)\";\n        }\n\n        private function getRemoveColumnFkConstraintSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($tableName . '_' . $columnName . '_fkey');\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"ALTER TABLE $p1 DROP FOREIGN KEY $p2\";\n                case 'pgsql':\n                case 'sqlsrv':\n                    return \"ALTER TABLE $p1 DROP CONSTRAINT $p2\";\n            }\n        }\n\n        private function getAddTableSQL(ReflectedTable $newTable): string\n        {\n            $tableName = $newTable->getRealName();\n            $p1 = $this->quote($tableName);\n            $fields = [];\n            $constraints = [];\n            foreach ($newTable->getColumnNames() as $columnName) {\n                $pkColumn = $this->getPrimaryKey($tableName);\n                $newColumn = $newTable->getColumn($columnName);\n                $f1 = $this->quote($columnName);\n                $f2 = $this->getColumnType($newColumn, false);\n                $f3 = $this->quote($tableName . '_' . $columnName . '_fkey');\n                $f4 = $this->quote($newColumn->getFk());\n                $f5 = $this->quote($this->getPrimaryKey($newColumn->getFk()));\n                $f6 = $this->quote($tableName . '_' . $pkColumn . '_pkey');\n                if ($this->driver == 'sqlite') {\n                    if ($newColumn->getPk()) {\n                        $f2 = str_replace('NULL', 'NULL PRIMARY KEY', $f2);\n                    }\n                    $fields[] = \"$f1 $f2\";\n                    if ($newColumn->getFk()) {\n                        $constraints[] = \"FOREIGN KEY ($f1) REFERENCES $f4 ($f5)\";\n                    }\n                } else {\n                    $fields[] = \"$f1 $f2\";\n                    if ($newColumn->getPk()) {\n                        $constraints[] = \"CONSTRAINT $f6 PRIMARY KEY ($f1)\";\n                    }\n                    if ($newColumn->getFk()) {\n                        $constraints[] = \"CONSTRAINT $f3 FOREIGN KEY ($f1) REFERENCES $f4 ($f5)\";\n                    }\n                }\n            }\n            $p2 = implode(',', array_merge($fields, $constraints));\n\n            return \"CREATE TABLE $p1 ($p2);\";\n        }\n\n        private function getAddColumnSQL(string $tableName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($newColumn->getRealName());\n            $p3 = $this->getColumnType($newColumn, false);\n\n            switch ($this->driver) {\n                case 'mysql':\n                case 'pgsql':\n                    return \"ALTER TABLE $p1 ADD COLUMN $p2 $p3\";\n                case 'sqlsrv':\n                    return \"ALTER TABLE $p1 ADD $p2 $p3\";\n                case 'sqlite':\n                    return \"ALTER TABLE $p1 ADD COLUMN $p2 $p3\";\n            }\n        }\n\n        private function getRemoveTableSQL(string $tableName): string\n        {\n            $p1 = $this->quote($tableName);\n\n            switch ($this->driver) {\n                case 'mysql':\n                case 'pgsql':\n                    return \"DROP TABLE $p1 CASCADE;\";\n                case 'sqlsrv':\n                    return \"DROP TABLE $p1;\";\n                case 'sqlite':\n                    return \"DROP TABLE $p1;\";\n            }\n        }\n\n        private function getRemoveColumnSQL(string $tableName, string $columnName): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n\n            switch ($this->driver) {\n                case 'mysql':\n                case 'pgsql':\n                    return \"ALTER TABLE $p1 DROP COLUMN $p2 CASCADE;\";\n                case 'sqlsrv':\n                    return \"ALTER TABLE $p1 DROP COLUMN $p2;\";\n                case 'sqlite':\n                    return \"ALTER TABLE $p1 DROP COLUMN $p2;\";\n            }\n        }\n\n        public function renameTable(string $tableName, string $newTableName)\n        {\n            $sql = $this->getTableRenameSQL($tableName, $newTableName);\n            return $this->query($sql, []);\n        }\n\n        public function renameColumn(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getColumnRenameSQL($tableName, $columnName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function retypeColumn(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getColumnRetypeSQL($tableName, $columnName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function setColumnNullable(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getSetColumnNullableSQL($tableName, $columnName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function addColumnPrimaryKey(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getSetColumnPkConstraintSQL($tableName, $columnName, $newColumn);\n            $this->query($sql, []);\n            if ($this->canAutoIncrement($newColumn)) {\n                $sql = $this->getSetColumnPkSequenceSQL($tableName, $columnName, $newColumn);\n                $this->query($sql, []);\n                $sql = $this->getSetColumnPkSequenceStartSQL($tableName, $columnName, $newColumn);\n                $this->query($sql, []);\n                $sql = $this->getSetColumnPkDefaultSQL($tableName, $columnName, $newColumn);\n                $this->query($sql, []);\n            }\n            return true;\n        }\n\n        public function removeColumnPrimaryKey(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            if ($this->canAutoIncrement($newColumn)) {\n                $sql = $this->getSetColumnPkDefaultSQL($tableName, $columnName, $newColumn);\n                $this->query($sql, []);\n                $sql = $this->getSetColumnPkSequenceSQL($tableName, $columnName, $newColumn);\n                $this->query($sql, []);\n            }\n            $sql = $this->getSetColumnPkConstraintSQL($tableName, $columnName, $newColumn);\n            $this->query($sql, []);\n            return true;\n        }\n\n        public function addColumnForeignKey(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getAddColumnFkConstraintSQL($tableName, $columnName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function removeColumnForeignKey(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getRemoveColumnFkConstraintSQL($tableName, $columnName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function addTable(ReflectedTable $newTable)\n        {\n            $sql = $this->getAddTableSQL($newTable);\n            return $this->query($sql, []);\n        }\n\n        public function addColumn(string $tableName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getAddColumnSQL($tableName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function removeTable(string $tableName)\n        {\n            $sql = $this->getRemoveTableSQL($tableName);\n            return $this->query($sql, []);\n        }\n\n        public function removeColumn(string $tableName, string $columnName)\n        {\n            $sql = $this->getRemoveColumnSQL($tableName, $columnName);\n            return $this->query($sql, []);\n        }\n\n        private function query(string $sql, array $arguments): bool\n        {\n            $stmt = $this->pdo->prepare($sql);\n            // echo \"- $sql -- \" . json_encode($arguments) . \"\\n\";\n            return $stmt->execute($arguments);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/GenericReflection.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Database\\LazyPdo;\n\n    class GenericReflection\n    {\n        private $pdo;\n        private $driver;\n        private $database;\n        private $tables;\n        private $mapper;\n        private $typeConverter;\n\n        public function __construct(LazyPdo $pdo, string $driver, string $database, array $tables, RealNameMapper $mapper)\n        {\n            $this->pdo = $pdo;\n            $this->driver = $driver;\n            $this->database = $database;\n            $this->tables = $tables;\n            $this->mapper = $mapper;\n            $this->typeConverter = new TypeConverter($driver);\n        }\n\n        public function getIgnoredTables(): array\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return [];\n                case 'pgsql':\n                    return ['spatial_ref_sys', 'raster_columns', 'raster_overviews', 'geography_columns', 'geometry_columns'];\n                case 'sqlsrv':\n                    return [];\n                case 'sqlite':\n                    return ['sqlite_sequence'];\n            }\n        }\n\n        private function getTablesSQL(): string\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return 'SELECT \"TABLE_NAME\", \"TABLE_TYPE\" FROM \"INFORMATION_SCHEMA\".\"TABLES\" WHERE \"TABLE_TYPE\" IN (\\'BASE TABLE\\' , \\'VIEW\\') AND \"TABLE_SCHEMA\" = ? ORDER BY BINARY \"TABLE_NAME\"';\n                case 'pgsql':\n                    return 'SELECT c.relname as \"TABLE_NAME\", c.relkind as \"TABLE_TYPE\" FROM pg_catalog.pg_class c WHERE c.relkind IN (\\'r\\', \\'v\\') AND c.relnamespace::regnamespace::text !~ \\'^pg_|information_schema\\' AND \\'\\' <> ? ORDER BY \"TABLE_NAME\";';\n                case 'sqlsrv':\n                    return 'SELECT o.name as \"TABLE_NAME\", o.xtype as \"TABLE_TYPE\" FROM sysobjects o WHERE o.xtype IN (\\'U\\', \\'V\\') ORDER BY \"TABLE_NAME\"';\n                case 'sqlite':\n                    return 'SELECT t.name as \"TABLE_NAME\", t.type as \"TABLE_TYPE\" FROM sqlite_master t WHERE t.type IN (\\'table\\', \\'view\\') AND \\'\\' IN (\\'\\', ?) ORDER BY \"TABLE_NAME\"';\n            }\n        }\n\n        private function getTableColumnsSQL(): string\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return 'SELECT \"COLUMN_NAME\", \"IS_NULLABLE\", \"DATA_TYPE\", \"CHARACTER_MAXIMUM_LENGTH\" as \"CHARACTER_MAXIMUM_LENGTH\", \"NUMERIC_PRECISION\", \"NUMERIC_SCALE\", \"COLUMN_TYPE\" FROM \"INFORMATION_SCHEMA\".\"COLUMNS\" WHERE \"TABLE_NAME\" = ? AND \"TABLE_SCHEMA\" = ? ORDER BY \"ORDINAL_POSITION\"';\n                case 'pgsql':\n                    return 'SELECT a.attname AS \"COLUMN_NAME\", case when a.attnotnull then \\'NO\\' else \\'YES\\' end as \"IS_NULLABLE\", pg_catalog.format_type(a.atttypid, -1) as \"DATA_TYPE\", case when a.atttypmod < 0 then NULL else a.atttypmod-4 end as \"CHARACTER_MAXIMUM_LENGTH\", case when a.atttypid != 1700 then NULL else ((a.atttypmod - 4) >> 16) & 65535 end as \"NUMERIC_PRECISION\", case when a.atttypid != 1700 then NULL else (a.atttypmod - 4) & 65535 end as \"NUMERIC_SCALE\", \\'\\' AS \"COLUMN_TYPE\" FROM pg_attribute a JOIN pg_class pgc ON pgc.oid = a.attrelid WHERE pgc.relname = ? AND \\'\\' <> ? AND pgc.relnamespace::regnamespace::text !~ \\'^pg_|information_schema\\' AND a.attnum > 0 AND NOT a.attisdropped ORDER BY a.attnum;';\n                case 'sqlsrv':\n                    return 'SELECT c.name AS \"COLUMN_NAME\", c.is_nullable AS \"IS_NULLABLE\", t.Name AS \"DATA_TYPE\", (c.max_length/2) AS \"CHARACTER_MAXIMUM_LENGTH\", c.precision AS \"NUMERIC_PRECISION\", c.scale AS \"NUMERIC_SCALE\", \\'\\' AS \"COLUMN_TYPE\" FROM sys.columns c INNER JOIN sys.types t ON c.user_type_id = t.user_type_id WHERE c.object_id = OBJECT_ID(?) AND \\'\\' <> ? ORDER BY c.column_id';\n                case 'sqlite':\n                    return 'SELECT \"name\" AS \"COLUMN_NAME\", case when \"notnull\"==1 then \\'no\\' else \\'yes\\' end as \"IS_NULLABLE\", lower(\"type\") AS \"DATA_TYPE\", 2147483647 AS \"CHARACTER_MAXIMUM_LENGTH\", 0 AS \"NUMERIC_PRECISION\", 0 AS \"NUMERIC_SCALE\", \\'\\' AS \"COLUMN_TYPE\" FROM pragma_table_info(?) WHERE \\'\\' IN (\\'\\', ?) ORDER BY \"cid\"';\n            }\n        }\n\n        private function getTablePrimaryKeysSQL(): string\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return 'SELECT \"COLUMN_NAME\" FROM \"INFORMATION_SCHEMA\".\"KEY_COLUMN_USAGE\" WHERE \"CONSTRAINT_NAME\" = \\'PRIMARY\\' AND \"TABLE_NAME\" = ? AND \"TABLE_SCHEMA\" = ?';\n                case 'pgsql':\n                    return 'SELECT a.attname AS \"COLUMN_NAME\" FROM pg_attribute a JOIN pg_constraint c ON (c.conrelid, c.conkey[1]) = (a.attrelid, a.attnum) JOIN pg_class pgc ON pgc.oid = a.attrelid WHERE pgc.relname = ? AND \\'\\' <> ? AND pgc.relnamespace::regnamespace::text !~ \\'^pg_|information_schema\\' AND c.contype = \\'p\\'';\n                case 'sqlsrv':\n                    return 'SELECT c.NAME as \"COLUMN_NAME\" FROM sys.key_constraints kc inner join sys.objects t on t.object_id = kc.parent_object_id INNER JOIN sys.index_columns ic ON kc.parent_object_id = ic.object_id and kc.unique_index_id = ic.index_id INNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id WHERE kc.type = \\'PK\\' and t.object_id = OBJECT_ID(?) and \\'\\' <> ?';\n                case 'sqlite':\n                    return 'SELECT \"name\" as \"COLUMN_NAME\" FROM pragma_table_info(?) WHERE \"pk\"=1 AND \\'\\' IN (\\'\\', ?)';\n            }\n        }\n\n        private function getTableForeignKeysSQL(): string\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return 'SELECT \"COLUMN_NAME\", \"REFERENCED_TABLE_NAME\" FROM \"INFORMATION_SCHEMA\".\"KEY_COLUMN_USAGE\" WHERE \"REFERENCED_TABLE_NAME\" IS NOT NULL AND \"TABLE_NAME\" = ? AND \"TABLE_SCHEMA\" = ?';\n                case 'pgsql':\n                    return 'SELECT a.attname AS \"COLUMN_NAME\", c.confrelid::regclass::text AS \"REFERENCED_TABLE_NAME\" FROM pg_attribute a JOIN pg_constraint c ON (c.conrelid, c.conkey[1]) = (a.attrelid, a.attnum) JOIN pg_class pgc ON pgc.oid = a.attrelid WHERE pgc.relname = ? AND \\'\\' <> ? AND pgc.relnamespace::regnamespace::text !~ \\'^pg_|information_schema\\' AND c.contype  = \\'f\\'';\n                case 'sqlsrv':\n                    return 'SELECT COL_NAME(fc.parent_object_id, fc.parent_column_id) AS \"COLUMN_NAME\", OBJECT_NAME (f.referenced_object_id) AS \"REFERENCED_TABLE_NAME\" FROM sys.foreign_keys AS f INNER JOIN sys.foreign_key_columns AS fc ON f.OBJECT_ID = fc.constraint_object_id WHERE f.parent_object_id = OBJECT_ID(?) and \\'\\' <> ?';\n                case 'sqlite':\n                    return 'SELECT \"from\" AS \"COLUMN_NAME\", \"table\" AS \"REFERENCED_TABLE_NAME\" FROM pragma_foreign_key_list(?) WHERE \\'\\' IN (\\'\\', ?)';\n            }\n        }\n\n        public function getDatabaseName(): string\n        {\n            return $this->database;\n        }\n\n        public function getTables(): array\n        {\n            $sql = $this->getTablesSQL();\n            $results = $this->query($sql, [$this->database]);\n            $tables = $this->tables;\n            $results = array_filter($results, function ($v) use ($tables) {\n                return $tables == ['all'] || in_array($v['TABLE_NAME'], $tables);\n            });\n            foreach ($results as &$result) {\n                $result['TABLE_REAL_NAME'] = $result['TABLE_NAME'];\n                $result['TABLE_NAME'] = $this->mapper->getTableName($result['TABLE_REAL_NAME']);\n            }\n            foreach ($results as &$result) {\n                $map = [];\n                switch ($this->driver) {\n                    case 'mysql':\n                        $map = ['BASE TABLE' => 'table', 'VIEW' => 'view'];\n                        break;\n                    case 'pgsql':\n                        $map = ['r' => 'table', 'v' => 'view'];\n                        break;\n                    case 'sqlsrv':\n                        $map = ['U' => 'table', 'V' => 'view'];\n                        break;\n                    case 'sqlite':\n                        $map = ['table' => 'table', 'view' => 'view'];\n                        break;\n                }\n                $result['TABLE_TYPE'] = $map[trim($result['TABLE_TYPE'])];\n            }\n            return $results;\n        }\n\n        public function getTableColumns(string $tableName, string $type): array\n        {\n            $tableRealName = $this->mapper->getTableRealName($tableName);\n            $sql = $this->getTableColumnsSQL();\n            $results = $this->query($sql, [$tableRealName, $this->database]);\n            foreach ($results as &$result) {\n                $result['COLUMN_REAL_NAME'] = $result['COLUMN_NAME'];\n                $result['COLUMN_NAME'] = $this->mapper->getColumnName($tableRealName, $result['COLUMN_REAL_NAME']);\n            }\n            if ($type == 'view') {\n                foreach ($results as &$result) {\n                    $result['IS_NULLABLE'] = false;\n                }\n            }\n            if ($this->driver == 'mysql') {\n                foreach ($results as &$result) {\n                    // mysql does not properly reflect display width of types\n                    preg_match('|([a-z]+)(\\(([0-9]+)(,([0-9]+))?\\))?|', $result['DATA_TYPE'], $matches);\n                    $result['DATA_TYPE'] = $matches[1];\n                    if (!$result['CHARACTER_MAXIMUM_LENGTH']) {\n                        if (isset($matches[3])) {\n                            $result['NUMERIC_PRECISION'] = $matches[3];\n                        }\n                        if (isset($matches[5])) {\n                            $result['NUMERIC_SCALE'] = $matches[5];\n                        }\n                    }\n                }\n            }\n            if ($this->driver == 'sqlite') {\n                foreach ($results as &$result) {\n                    // sqlite does not reflect types on view columns\n                    preg_match('|([a-z]+)(\\(([0-9]+)(,([0-9]+))?\\))?|', $result['DATA_TYPE'], $matches);\n                    if (isset($matches[1])) {\n                        $result['DATA_TYPE'] = $matches[1];\n                    } else {\n                        $result['DATA_TYPE'] = 'text';\n                    }\n                    if (isset($matches[5])) {\n                        $result['NUMERIC_PRECISION'] = $matches[3];\n                        $result['NUMERIC_SCALE'] = $matches[5];\n                    } else if (isset($matches[3])) {\n                        $result['CHARACTER_MAXIMUM_LENGTH'] = $matches[3];\n                    }\n                }\n            }\n            return $results;\n        }\n\n        public function getTablePrimaryKeys(string $tableName): array\n        {\n            $tableRealName = $this->mapper->getTableRealName($tableName);\n            $sql = $this->getTablePrimaryKeysSQL();\n            $results = $this->query($sql, [$tableRealName, $this->database]);\n            $primaryKeys = [];\n            foreach ($results as $result) {\n                $primaryKeys[] = $this->mapper->getColumnName($tableRealName, $result['COLUMN_NAME']);\n            }\n            return $primaryKeys;\n        }\n\n        public function getTableForeignKeys(string $tableName): array\n        {\n            $tableRealName = $this->mapper->getTableRealName($tableName);\n            $sql = $this->getTableForeignKeysSQL();\n            $results = $this->query($sql, [$tableRealName, $this->database]);\n            $foreignKeys = [];\n            foreach ($results as $result) {\n                $columnName = $this->mapper->getColumnName($tableRealName, $result['COLUMN_NAME']);\n                $otherTableName = $this->mapper->getTableName($result['REFERENCED_TABLE_NAME']);\n                $foreignKeys[$columnName] = $otherTableName;\n            }\n            return $foreignKeys;\n        }\n\n        public function toJdbcType(string $type, string $size): string\n        {\n            return $this->typeConverter->toJdbc($type, $size);\n        }\n\n        private function query(string $sql, array $parameters): array\n        {\n            $stmt = $this->pdo->prepare($sql);\n            //echo \"- $sql -- \" . json_encode($parameters, JSON_UNESCAPED_UNICODE) . \"\\n\";\n            $stmt->execute($parameters);\n            return $stmt->fetchAll();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/LazyPdo.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    class LazyPdo extends \\PDO\n    {\n        private $dsn;\n        private $user;\n        private $password;\n        private $options;\n        private $commands;\n\n        private $pdo = null;\n\n        public function __construct(string $dsn, /*?string*/ $user = null, /*?string*/ $password = null, array $options = array())\n        {\n            $this->dsn = $dsn;\n            $this->user = $user;\n            $this->password = $password;\n            $this->options = $options;\n            $this->commands = array();\n            // explicitly NOT calling super::__construct\n        }\n\n        public function addInitCommand(string $command) /*: void*/\n        {\n            $this->commands[] = $command;\n        }\n\n        private function pdo()\n        {\n            if (!$this->pdo) {\n                $this->pdo = new \\PDO($this->dsn, $this->user, $this->password, $this->options);\n                foreach ($this->commands as $command) {\n                    $this->pdo->query($command);\n                }\n            }\n            return $this->pdo;\n        }\n\n        public function reconstruct(string $dsn, /*?string*/ $user = null, /*?string*/ $password = null, array $options = array()): bool\n        {\n            $this->dsn = $dsn;\n            $this->user = $user;\n            $this->password = $password;\n            $this->options = $options;\n            $this->commands = array();\n            if ($this->pdo) {\n                $this->pdo = null;\n                return true;\n            }\n            return false;\n        }\n\n        public function inTransaction(): bool\n        {\n            // Do not call parent method if there is no pdo object\n            return $this->pdo && parent::inTransaction();\n        }\n\n        public function setAttribute($attribute, $value): bool\n        {\n            if ($this->pdo) {\n                return $this->pdo()->setAttribute($attribute, $value);\n            }\n            $this->options[$attribute] = $value;\n            return true;\n        }\n\n        public function getAttribute($attribute): mixed\n        {\n            return $this->pdo()->getAttribute($attribute);\n        }\n\n        public function beginTransaction(): bool\n        {\n            return $this->pdo()->beginTransaction();\n        }\n\n        public function commit(): bool\n        {\n            return $this->pdo()->commit();\n        }\n\n        public function rollBack(): bool\n        {\n            return $this->pdo()->rollBack();\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function errorCode()\n        {\n            return $this->pdo()->errorCode();\n        }\n\n        public function errorInfo(): array\n        {\n            return $this->pdo()->errorInfo();\n        }\n\n        public function exec($query): int\n        {\n            return $this->pdo()->exec($query);\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function prepare($statement, $options = array())\n        {\n            return $this->pdo()->prepare($statement, $options);\n        }\n\n        public function quote($string, $parameter_type = \\PDO::PARAM_STR): string\n        {\n            return $this->pdo()->quote($string, $parameter_type);\n        }\n\n        public function lastInsertId( /* ?string */$name = null): string\n        {\n            return $this->pdo()->lastInsertId($name);\n        }\n\n        public function query($query, /* ?int */ $fetchMode = null, ...$fetchModeArgs): \\PDOStatement\n        {\n            return call_user_func_array(array($this->pdo(), 'query'), func_get_args());\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/RealNameMapper.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    class RealNameMapper\n    {\n        private $tableMapping;\n        private $reverseTableMapping;\n        private $columnMapping;\n        private $reverseColumnMapping;\n\n        public function __construct(array $mapping)\n        {\n            $this->tableMapping = [];\n            $this->reverseTableMapping = [];\n            $this->columnMapping = [];\n            $this->reverseColumnMapping = [];\n            foreach ($mapping as $name=>$realName) {\n                if (strpos($name,'.') && strpos($realName,'.')) {\n                    list($tableName, $columnName) = explode('.', $name, 2);\n                    list($tableRealName, $columnRealName) = explode('.', $realName, 2);\n                    $this->tableMapping[$tableName] = $tableRealName;\n                    $this->reverseTableMapping[$tableRealName] = $tableName;\n                    if (!isset($this->columnMapping[$tableName])) {\n                        $this->columnMapping[$tableName] = [];\n                    }\n                    $this->columnMapping[$tableName][$columnName] = $columnRealName;\n                    if (!isset($this->reverseColumnMapping[$tableRealName])) {\n                        $this->reverseColumnMapping[$tableRealName] = [];\n                    }\n                    $this->reverseColumnMapping[$tableRealName][$columnRealName] = $columnName;\n                } else {\n                    $this->tableMapping[$name] = $realName;\n                    $this->reverseTableMapping[$realName] = $name;\n                }\n            }\n        }\n\n        public function getColumnRealName(string $tableName,string $columnName): string\n        {\n            return $this->reverseColumnMapping[$tableName][$columnName] ?? $columnName;\n        }\n\n        public function getTableRealName(string $tableName): string\n        {\n            return $this->reverseTableMapping[$tableName] ?? $tableName;\n        }\n\n        public function getColumnName(string $tableRealName,string $columnRealName): string\n        {\n            return $this->columnMapping[$tableRealName][$columnRealName] ?? $columnRealName;\n        }\n\n        public function getTableName(string $tableRealName): string\n        {\n            return $this->tableMapping[$tableRealName] ?? $tableRealName;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/TypeConverter.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    class TypeConverter\n    {\n        private $driver;\n\n        public function __construct(string $driver)\n        {\n            $this->driver = $driver;\n        }\n\n        private $fromJdbc = [\n            'mysql' => [\n                'clob' => 'longtext',\n                'boolean' => 'tinyint(1)',\n                'blob' => 'longblob',\n                'timestamp' => 'datetime',\n            ],\n            'pgsql' => [\n                'clob' => 'text',\n                'blob' => 'bytea',\n                'float' => 'real',\n                'double' => 'double precision',\n                'varbinary' => 'bytea',\n            ],\n            'sqlsrv' => [\n                'boolean' => 'bit',\n                'varchar' => 'nvarchar',\n                'clob' => 'ntext',\n                'blob' => 'image',\n                'time' => 'time(0)',\n                'timestamp' => 'datetime2(0)',\n                'double' => 'float',\n                'float' => 'real',\n            ],\n        ];\n\n        private $toJdbc = [\n            'simplified' => [\n                'char' => 'varchar',\n                'longvarchar' => 'clob',\n                'nchar' => 'varchar',\n                'nvarchar' => 'varchar',\n                'longnvarchar' => 'clob',\n                'binary' => 'varbinary',\n                'longvarbinary' => 'blob',\n                'tinyint' => 'integer',\n                'smallint' => 'integer',\n                'real' => 'float',\n                'numeric' => 'decimal',\n                'nclob' => 'clob',\n                'time_with_timezone' => 'time',\n                'timestamp_with_timezone' => 'timestamp',\n            ],\n            'mysql' => [\n                'tinyint(1)' => 'boolean',\n                'bit(1)' => 'boolean',\n                'tinyblob' => 'blob',\n                'mediumblob' => 'blob',\n                'longblob' => 'blob',\n                'tinytext' => 'clob',\n                'mediumtext' => 'clob',\n                'longtext' => 'clob',\n                'text' => 'clob',\n                'mediumint' => 'integer',\n                'int' => 'integer',\n                'polygon' => 'geometry',\n                'point' => 'geometry',\n                'linestring' => 'geometry',\n                'multipoint' => 'geometry',\n                'multilinestring' => 'geometry',\n                'multipolygon' => 'geometry',\n                'datetime' => 'timestamp',\n                'year' => 'integer',\n                'enum' => 'varchar',\n                'set' => 'varchar',\n                'json' => 'clob',\n            ],\n            'pgsql' => [\n                'bigserial' => 'bigint',\n                'bit varying' => 'bit',\n                'box' => 'geometry',\n                'bytea' => 'blob',\n                'bpchar' => 'char',\n                'character varying' => 'varchar',\n                'character' => 'char',\n                'cidr' => 'varchar',\n                'circle' => 'geometry',\n                'double precision' => 'double',\n                'inet' => 'integer',\n                //'interval [ fields ]'\n                'json' => 'clob',\n                'jsonb' => 'clob',\n                'line' => 'geometry',\n                'lseg' => 'geometry',\n                'macaddr' => 'varchar',\n                'money' => 'decimal',\n                'path' => 'geometry',\n                'point' => 'geometry',\n                'polygon' => 'geometry',\n                'real' => 'float',\n                'serial' => 'integer',\n                'text' => 'clob',\n                'time without time zone' => 'time',\n                'time with time zone' => 'time_with_timezone',\n                'timestamp without time zone' => 'timestamp',\n                'timestamp with time zone' => 'timestamp_with_timezone',\n                //'tsquery'=\n                //'tsvector'\n                //'txid_snapshot'\n                'uuid' => 'char',\n                'xml' => 'clob',\n            ],\n            // source: https://docs.microsoft.com/en-us/sql/connect/jdbc/using-basic-data-types?view=sql-server-2017\n            'sqlsrv' => [\n                'varbinary()' => 'blob',\n                'bit' => 'boolean',\n                'datetime' => 'timestamp',\n                'datetime2' => 'timestamp',\n                'float' => 'double',\n                'image' => 'blob',\n                'int' => 'integer',\n                'money' => 'decimal',\n                'ntext' => 'clob',\n                'smalldatetime' => 'timestamp',\n                'smallmoney' => 'decimal',\n                'text' => 'clob',\n                'timestamp' => 'binary',\n                'udt' => 'varbinary',\n                'uniqueidentifier' => 'char',\n                'xml' => 'clob',\n            ],\n            'sqlite' => [\n                'tinytext' => 'clob',\n                'text' => 'clob',\n                'mediumtext' => 'clob',\n                'longtext' => 'clob',\n                'mediumint' => 'integer',\n                'int' => 'integer',\n                'bigint' => 'bigint',\n                'int2' => 'smallint',\n                'int4' => 'integer',\n                'int8' => 'bigint',\n                'double precision' => 'double',\n                'datetime' => 'timestamp'\n            ],\n        ];\n\n        // source: https://docs.oracle.com/javase/9/docs/api/java/sql/Types.html\n        private $valid = [\n            //'array' => true,\n            'bigint' => true,\n            'binary' => true,\n            'bit' => true,\n            'blob' => true,\n            'boolean' => true,\n            'char' => true,\n            'clob' => true,\n            //'datalink' => true,\n            'date' => true,\n            'decimal' => true,\n            //'distinct' => true,\n            'double' => true,\n            'float' => true,\n            'integer' => true,\n            //'java_object' => true,\n            'longnvarchar' => true,\n            'longvarbinary' => true,\n            'longvarchar' => true,\n            'nchar' => true,\n            'nclob' => true,\n            //'null' => true,\n            'numeric' => true,\n            'nvarchar' => true,\n            //'other' => true,\n            'real' => true,\n            //'ref' => true,\n            //'ref_cursor' => true,\n            //'rowid' => true,\n            'smallint' => true,\n            //'sqlxml' => true,\n            //'struct' => true,\n            'time' => true,\n            'time_with_timezone' => true,\n            'timestamp' => true,\n            'timestamp_with_timezone' => true,\n            'tinyint' => true,\n            'varbinary' => true,\n            'varchar' => true,\n            // extra:\n            'geometry' => true,\n        ];\n\n        public function toJdbc(string $type, string $size): string\n        {\n            $jdbcType = strtolower($type);\n            if (isset($this->toJdbc[$this->driver][\"$jdbcType($size)\"])) {\n                $jdbcType = $this->toJdbc[$this->driver][\"$jdbcType($size)\"];\n            }\n            if (isset($this->toJdbc[$this->driver][$jdbcType])) {\n                $jdbcType = $this->toJdbc[$this->driver][$jdbcType];\n            }\n            if (isset($this->toJdbc['simplified'][$jdbcType])) {\n                $jdbcType = $this->toJdbc['simplified'][$jdbcType];\n            }\n            if (!isset($this->valid[$jdbcType])) {\n                //throw new \\Exception(\"Unsupported type '$jdbcType' for driver '$this->driver'\");\n                $jdbcType = 'clob';\n            }\n            return $jdbcType;\n        }\n\n        public function fromJdbc(string $type): string\n        {\n            $jdbcType = strtolower($type);\n            if (isset($this->fromJdbc[$this->driver][$jdbcType])) {\n                $jdbcType = $this->fromJdbc[$this->driver][$jdbcType];\n            }\n            return $jdbcType;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/GeoJson/Feature.php\nnamespace Tqdev\\PhpCrudApi\\GeoJson {\n\n    class Feature implements \\JsonSerializable\n    {\n        private $id;\n        private $properties;\n        private $geometry;\n\n        public function __construct($id, array $properties, /*?Geometry*/ $geometry)\n        {\n            $this->id = $id;\n            $this->properties = $properties;\n            $this->geometry = $geometry;\n        }\n\n        public function serialize()\n        {\n            return [\n                'type' => 'Feature',\n                'id' => $this->id,\n                'properties' => $this->properties,\n                'geometry' => $this->geometry,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->serialize();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/GeoJson/FeatureCollection.php\nnamespace Tqdev\\PhpCrudApi\\GeoJson {\n\n    class FeatureCollection implements \\JsonSerializable\n    {\n        private $features;\n\n        private $results;\n\n        public function __construct(array $features, int $results)\n        {\n            $this->features = $features;\n            $this->results = $results;\n        }\n\n        public function serialize()\n        {\n            return [\n                'type' => 'FeatureCollection',\n                'features' => $this->features,\n                'results' => $this->results,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return array_filter($this->serialize(), function ($v) {\n                return $v !== -1;\n            });\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/GeoJson/GeoJsonService.php\nnamespace Tqdev\\PhpCrudApi\\GeoJson {\n\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\GeoJson\\FeatureCollection;\n    use Tqdev\\PhpCrudApi\\Record\\RecordService;\n\n    class GeoJsonService\n    {\n        private $reflection;\n        private $records;\n\n        public function __construct(ReflectionService $reflection, RecordService $records)\n        {\n            $this->reflection = $reflection;\n            $this->records = $records;\n        }\n\n        public function hasTable(string $table): bool\n        {\n            return $this->reflection->hasTable($table);\n        }\n\n        public function getType(string $table): string\n        {\n            return $this->reflection->getType($table);\n        }\n\n        private function getGeometryColumnName(string $tableName, array &$params): string\n        {\n            $geometryParam = isset($params['geometry']) ? $params['geometry'][0] : '';\n            $table = $this->reflection->getTable($tableName);\n            $geometryColumnName = '';\n            foreach ($table->getColumnNames() as $columnName) {\n                if ($geometryParam && $geometryParam != $columnName) {\n                    continue;\n                }\n                $column = $table->getColumn($columnName);\n                if ($column->isGeometry()) {\n                    $geometryColumnName = $columnName;\n                    break;\n                }\n            }\n            if ($geometryColumnName) {\n                $params['mandatory'][] = $tableName . \".\" . $geometryColumnName;\n            }\n            return $geometryColumnName;\n        }\n\n        private function setBoudingBoxFilter(string $geometryColumnName, array &$params)\n        {\n            $boundingBox = isset($params['bbox']) ? $params['bbox'][0] : '';\n            if ($boundingBox) {\n                $c = explode(',', $boundingBox);\n                if (!isset($params['filter'])) {\n                    $params['filter'] = array();\n                }\n                $params['filter'][] = \"$geometryColumnName,sin,POLYGON(($c[0] $c[1],$c[2] $c[1],$c[2] $c[3],$c[0] $c[3],$c[0] $c[1]))\";\n            }\n            $tile = isset($params['tile']) ? $params['tile'][0] : '';\n            if ($tile) {\n                $zxy = explode(',', $tile);\n                if (count($zxy) == 3) {\n                    list($z, $x, $y) = $zxy;\n                    $c = array();\n                    $c = array_merge($c, $this->convertTileToLatLonOfUpperLeftCorner($z, $x, $y));\n                    $c = array_merge($c, $this->convertTileToLatLonOfUpperLeftCorner($z, $x + 1, $y + 1));\n                    $params['filter'][] = \"$geometryColumnName,sin,POLYGON(($c[0] $c[1],$c[2] $c[1],$c[2] $c[3],$c[0] $c[3],$c[0] $c[1]))\";\n                }\n            }\n        }\n\n        private function convertTileToLatLonOfUpperLeftCorner($z, $x, $y): array\n        {\n            $n = pow(2, $z);\n            $lon = $x / $n * 360.0 - 180.0;\n            $lat = rad2deg(atan(sinh(pi() * (1 - 2 * $y / $n))));\n            return [$lon, $lat];\n        }\n\n        private function convertRecordToFeature(/*object*/$record, string $primaryKeyColumnName, string $geometryColumnName)\n        {\n            $id = null;\n            if ($primaryKeyColumnName) {\n                $id = $record[$primaryKeyColumnName];\n            }\n            $geometry = null;\n            if (isset($record[$geometryColumnName])) {\n                $geometry = Geometry::fromWkt($record[$geometryColumnName]);\n            }\n            $properties = array_diff_key($record, [$primaryKeyColumnName => true, $geometryColumnName => true]);\n            return new Feature($id, $properties, $geometry);\n        }\n\n        private function getPrimaryKeyColumnName(string $tableName, array &$params): string\n        {\n            $primaryKeyColumn = $this->reflection->getTable($tableName)->getPk();\n            if (!$primaryKeyColumn) {\n                return '';\n            }\n            $primaryKeyColumnName = $primaryKeyColumn->getName();\n            $params['mandatory'][] = $tableName . \".\" . $primaryKeyColumnName;\n            return $primaryKeyColumnName;\n        }\n\n        public function _list(string $tableName, array $params): FeatureCollection\n        {\n            $geometryColumnName = $this->getGeometryColumnName($tableName, $params);\n            $this->setBoudingBoxFilter($geometryColumnName, $params);\n            $primaryKeyColumnName = $this->getPrimaryKeyColumnName($tableName, $params);\n            $records = $this->records->_list($tableName, $params);\n            $features = array();\n            foreach ($records->getRecords() as $record) {\n                $features[] = $this->convertRecordToFeature($record, $primaryKeyColumnName, $geometryColumnName);\n            }\n            return new FeatureCollection($features, $records->getResults());\n        }\n\n        public function read(string $tableName, string $id, array $params): Feature\n        {\n            $geometryColumnName = $this->getGeometryColumnName($tableName, $params);\n            $primaryKeyColumnName = $this->getPrimaryKeyColumnName($tableName, $params);\n            $record = $this->records->read($tableName, $id, $params);\n            return $this->convertRecordToFeature($record, $primaryKeyColumnName, $geometryColumnName);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/GeoJson/Geometry.php\nnamespace Tqdev\\PhpCrudApi\\GeoJson {\n\n    class Geometry implements \\JsonSerializable\n    {\n        private $type;\n        private $coordinates;\n\n        public static $types = [\n            \"Point\",\n            \"MultiPoint\",\n            \"LineString\",\n            \"MultiLineString\",\n            \"Polygon\",\n            \"MultiPolygon\",\n            //\"GeometryCollection\",\n        ];\n\n        public function __construct(string $type, array $coordinates)\n        {\n            $this->type = $type;\n            $this->coordinates = $coordinates;\n        }\n\n        public static function fromWkt(string $wkt): Geometry\n        {\n            $bracket = strpos($wkt, '(');\n            $type = strtoupper(trim(substr($wkt, 0, $bracket)));\n            $supported = false;\n            foreach (Geometry::$types as $typeName) {\n                if (strtoupper($typeName) == $type) {\n                    $type = $typeName;\n                    $supported = true;\n                }\n            }\n            if (!$supported) {\n                throw new \\Exception('Geometry type not supported: ' . $type);\n            }\n            $coordinates = substr($wkt, $bracket);\n            if (substr($type, -5) != 'Point' || ($type == 'MultiPoint' && $coordinates[1] != '(')) {\n                $coordinates = preg_replace('|([0-9\\-\\.]+ )+([0-9\\-\\.]+)|', '[\\1\\2]', $coordinates);\n            }\n            $coordinates = str_replace(['(', ')', ', ', ' '], ['[', ']', ',', ','], $coordinates);\n            $coordinates = json_decode($coordinates);\n            if (!$coordinates) {\n                throw new \\Exception('Could not decode WKT: ' . $wkt);\n            }\n            return new Geometry($type, $coordinates);\n        }\n\n        public function serialize()\n        {\n            return [\n                'type' => $this->type,\n                'coordinates' => $this->coordinates,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->serialize();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/Base/Middleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware\\Base {\n\n    use Psr\\Http\\Server\\MiddlewareInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Config\\Base\\ConfigInterface;\n\n    abstract class Middleware implements MiddlewareInterface\n    {\n        protected $next;\n        protected $responder;\n        private $middleware;\n        private $config;\n\n        public function __construct(Router $router, Responder $responder, ConfigInterface $config, string $middleware)\n        {\n            $router->load($this);\n            $this->responder = $responder;\n            $this->middleware = $middleware;\n            $this->config = $config;\n        }\n\n        protected function getArrayProperty(string $key, string $default): array\n        {\n            return array_filter(array_map('trim', explode(',', $this->getProperty($key, $default))));\n        }\n\n        protected function getMapProperty(string $key, string $default): array\n        {\n            $pairs = $this->getArrayProperty($key, $default);\n            $result = array();\n            foreach ($pairs as $pair) {\n                if (strpos($pair, ':')) {\n                    list($k, $v) = explode(':', $pair, 2);\n                    $result[trim($k)] = trim($v);\n                } else {\n                    $result[] = trim($pair);\n                }\n            }\n            return $result;\n        }\n\n        protected function getProperty(string $key, $default)\n        {\n            return $this->config->getProperty($this->middleware . '.' . $key, $default);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/Communication/VariableStore.php\nnamespace Tqdev\\PhpCrudApi\\Middleware\\Communication {\n\n    class VariableStore\n    {\n        public static $values = array();\n\n        public static function get(string $key)\n        {\n            if (isset(self::$values[$key])) {\n                return self::$values[$key];\n            }\n            return null;\n        }\n\n        public static function set(string $key, /* object */ $value)\n        {\n            self::$values[$key] = $value;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/Router/Router.php\nnamespace Tqdev\\PhpCrudApi\\Middleware\\Router {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n\n    interface Router extends RequestHandlerInterface\n    {\n        public function register(string $method, string $path, array $handler);\n\n        public function load(Middleware $middleware);\n\n        public function route(ServerRequestInterface $request): ResponseInterface;\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/Router/SimpleRouter.php\nnamespace Tqdev\\PhpCrudApi\\Middleware\\Router {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Cache\\Cache;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\Record\\PathTree;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class SimpleRouter implements Router\n    {\n        private $basePath;\n        private $responder;\n        private $cache;\n        private $ttl;\n        private $registration;\n        private $routes;\n        private $routeHandlers;\n        private $middlewares;\n\n        public function __construct(string $basePath, Responder $responder, Cache $cache, int $ttl)\n        {\n            $this->basePath = rtrim($basePath, '/') ?: rtrim($this->detectBasePath(), '/');;\n            $this->responder = $responder;\n            $this->cache = $cache;\n            $this->ttl = $ttl;\n            $this->registration = true;\n            $this->routes = $this->loadPathTree();\n            $this->routeHandlers = [];\n            $this->middlewares = array();\n        }\n\n        private function detectBasePath(): string\n        {\n            if (isset($_SERVER['REQUEST_URI'])) {\n                $fullPath = urldecode(explode('?', $_SERVER['REQUEST_URI'])[0]);\n                if (isset($_SERVER['PATH_INFO'])) {\n                    $path = $_SERVER['PATH_INFO'];\n                    if (substr($fullPath, -1 * strlen($path)) == $path) {\n                        return substr($fullPath, 0, -1 * strlen($path));\n                    }\n                }\n                $path = '/' . basename(__FILE__);\n                if (substr($fullPath, -1 * strlen($path)) == $path) {\n                    return $fullPath;\n                }\n            }\n            return '/';\n        }\n\n        private function loadPathTree(): PathTree\n        {\n            $data = $this->cache->get('PathTree');\n            if ($data != '') {\n                $tree = PathTree::fromJson(json_decode(gzuncompress($data)));\n                $this->registration = false;\n            } else {\n                $tree = new PathTree();\n            }\n            return $tree;\n        }\n\n        public function register(string $method, string $path, array $handler)\n        {\n            $routeNumber = count($this->routeHandlers);\n            $this->routeHandlers[$routeNumber] = $handler;\n            if ($this->registration) {\n                $path = trim($path, '/');\n                $parts = array();\n                if ($path) {\n                    $parts = explode('/', $path);\n                }\n                array_unshift($parts, $method);\n                $this->routes->put($parts, $routeNumber);\n            }\n        }\n\n        public function load(Middleware $middleware) /*: void*/\n        {\n            array_push($this->middlewares, $middleware);\n        }\n\n        public function route(ServerRequestInterface $request): ResponseInterface\n        {\n            if ($this->registration) {\n                $data = gzcompress(json_encode($this->routes, JSON_UNESCAPED_UNICODE));\n                $this->cache->set('PathTree', $data, $this->ttl);\n            }\n\n            return $this->handle($request);\n        }\n\n        private function getRouteNumbers(ServerRequestInterface $request): array\n        {\n            $method = strtoupper($request->getMethod());\n            $path = array();\n            $segment = $method;\n            for ($i = 1; strlen($segment) > 0; $i++) {\n                array_push($path, $segment);\n                $segment = RequestUtils::getPathSegment($request, $i);\n            }\n            return $this->routes->match($path);\n        }\n\n        private function removeBasePath(ServerRequestInterface $request): ServerRequestInterface\n        {\n            $path = $request->getUri()->getPath();\n            if (substr($path, 0, strlen($this->basePath)) == $this->basePath) {\n                $path = substr($path, strlen($this->basePath));\n                $request = $request->withUri($request->getUri()->withPath($path));\n            }\n            return $request;\n        }\n\n        public function getBasePath(): string\n        {\n            return $this->basePath;\n        }\n\n        public function handle(ServerRequestInterface $request): ResponseInterface\n        {\n            $request = $this->removeBasePath($request);\n\n            if (count($this->middlewares)) {\n                $handler = array_shift($this->middlewares);\n                return $handler->process($request, $this);\n            }\n\n            $routeNumbers = $this->getRouteNumbers($request);\n            if (count($routeNumbers) == 0) {\n                return $this->responder->error(ErrorCode::ROUTE_NOT_FOUND, $request->getUri()->getPath());\n            }\n            try {\n                $response = call_user_func($this->routeHandlers[$routeNumbers[0]], $request);\n            } catch (\\Throwable $exception) {\n                $response = $this->responder->exception($exception);\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/AjaxOnlyMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class AjaxOnlyMiddleware extends Middleware\n    {\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $method = $request->getMethod();\n            $excludeMethods = $this->getArrayProperty('excludeMethods', 'OPTIONS,GET');\n            if (!in_array($method, $excludeMethods)) {\n                $headerName = $this->getProperty('headerName', 'X-Requested-With');\n                $headerValue = $this->getProperty('headerValue', 'XMLHttpRequest');\n                if ($headerValue != RequestUtils::getHeader($request, $headerName)) {\n                    return $this->responder->error(ErrorCode::ONLY_AJAX_REQUESTS_ALLOWED, $method);\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/ApiKeyAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class ApiKeyAuthMiddleware extends Middleware\n    {\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $headerName = $this->getProperty('header', 'X-API-Key');\n            $apiKey = RequestUtils::getHeader($request, $headerName);\n            if ($apiKey) {\n                $apiKeys = $this->getArrayProperty('keys', '');\n                if (!in_array($apiKey, $apiKeys)) {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $apiKey);\n                }\n            } else {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                }\n            }\n            $_SESSION['apiKey'] = $apiKey;\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/ApiKeyDbAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\Record\\OrderingInfo;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class ApiKeyDbAuthMiddleware extends Middleware\n    {\n        private $reflection;\n        private $db;\n        private $ordering;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection, GenericDB $db)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n            $this->db = $db;\n            $this->ordering = new OrderingInfo();\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $user = false;\n            $headerName = $this->getProperty('header', 'X-API-Key');\n            $apiKey = RequestUtils::getHeader($request, $headerName);\n            if ($apiKey) {\n                $tableName = $this->getProperty('usersTable', 'users');\n                $table = $this->reflection->getTable($tableName);\n                $apiKeyColumnName = $this->getProperty('apiKeyColumn', 'api_key');\n                $apiKeyColumn = $table->getColumn($apiKeyColumnName);\n                $condition = new ColumnCondition($apiKeyColumn, 'eq', $apiKey);\n                $columnNames = $table->getColumnNames();\n                $columnOrdering = $this->ordering->getDefaultColumnOrdering($table);\n                $users = $this->db->selectAll($table, $columnNames, $condition, $columnOrdering, 0, 1);\n                if (count($users) < 1) {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $apiKey);\n                }\n                $user = $users[0];\n            } else {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                }\n            }\n            $_SESSION['apiUser'] = $user;\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/AuthorizationMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\Record\\FilterInfo;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class AuthorizationMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        private function handleColumns(string $operation, string $tableName) /*: void*/\n        {\n            $columnHandler = $this->getProperty('columnHandler', '');\n            if ($columnHandler) {\n                $table = $this->reflection->getTable($tableName);\n                foreach ($table->getColumnNames() as $columnName) {\n                    $allowed = call_user_func($columnHandler, $operation, $tableName, $columnName);\n                    if (!$allowed) {\n                        $table->removeColumn($columnName);\n                    }\n                }\n            }\n        }\n\n        private function handleTable(string $operation, string $tableName) /*: void*/\n        {\n            if (!$this->reflection->hasTable($tableName)) {\n                return;\n            }\n            $allowed = true;\n            $tableHandler = $this->getProperty('tableHandler', '');\n            if ($tableHandler) {\n                $allowed = call_user_func($tableHandler, $operation, $tableName);\n            }\n            if (!$allowed) {\n                $this->reflection->removeTable($tableName);\n            } else {\n                $this->handleColumns($operation, $tableName);\n            }\n        }\n\n        private function handleRecords(string $operation, string $tableName) /*: void*/\n        {\n            if (!$this->reflection->hasTable($tableName)) {\n                return;\n            }\n            $recordHandler = $this->getProperty('recordHandler', '');\n            if ($recordHandler) {\n                $query = call_user_func($recordHandler, $operation, $tableName);\n                $filters = new FilterInfo();\n                $table = $this->reflection->getTable($tableName);\n                $query = str_replace('][]=', ']=', str_replace('=', '[]=', $query ?: ''));\n                parse_str($query, $params);\n                $condition = $filters->getCombinedConditions($table, $params);\n                VariableStore::set(\"authorization.conditions.$tableName\", $condition);\n            }\n        }\n\n        private function pathHandler(string $path) /*: bool*/\n        {\n            $pathHandler = $this->getProperty('pathHandler', '');\n            return $pathHandler ? call_user_func($pathHandler, $path) : true;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $path = RequestUtils::getPathSegment($request, 1);\n\n            if (!$this->pathHandler($path)) {\n                return $this->responder->error(ErrorCode::ROUTE_NOT_FOUND, $request->getUri()->getPath());\n            }\n\n            $operation = RequestUtils::getOperation($request);\n            $tableNames = RequestUtils::getTableNames($request, $this->reflection);\n            foreach ($tableNames as $tableName) {\n                $this->handleTable($operation, $tableName);\n                if ($path == 'records') {\n                    $this->handleRecords($operation, $tableName);\n                }\n            }\n            if ($path == 'openapi') {\n                VariableStore::set('authorization.tableHandler', $this->getProperty('tableHandler', ''));\n                VariableStore::set('authorization.columnHandler', $this->getProperty('columnHandler', ''));\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/BasicAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class BasicAuthMiddleware extends Middleware\n    {\n        private function hasCorrectPassword(string $username, string $password, array &$passwords): bool\n        {\n            $hash = isset($passwords[$username]) ? $passwords[$username] : false;\n            if ($hash && password_verify($password, $hash)) {\n                if (password_needs_rehash($hash, PASSWORD_DEFAULT)) {\n                    $passwords[$username] = password_hash($password, PASSWORD_DEFAULT);\n                }\n                return true;\n            }\n            return false;\n        }\n\n        private function getValidUsername(string $username, string $password, string $passwordFile): string\n        {\n            $passwords = $this->readPasswords($passwordFile);\n            $valid = $this->hasCorrectPassword($username, $password, $passwords);\n            $this->writePasswords($passwordFile, $passwords);\n            return $valid ? $username : '';\n        }\n\n        private function readPasswords(string $passwordFile): array\n        {\n            $passwords = [];\n            $passwordLines = file($passwordFile);\n            foreach ($passwordLines as $passwordLine) {\n                if (strpos($passwordLine, ':') !== false) {\n                    list($username, $hash) = explode(':', trim($passwordLine), 2);\n                    if (strlen($hash) > 0 && $hash[0] != '$') {\n                        $hash = password_hash($hash, PASSWORD_DEFAULT);\n                    }\n                    $passwords[$username] = $hash;\n                }\n            }\n            return $passwords;\n        }\n\n        private function writePasswords(string $passwordFile, array $passwords): bool\n        {\n            $success = false;\n            $passwordFileContents = '';\n            foreach ($passwords as $username => $hash) {\n                $passwordFileContents .= \"$username:$hash\\n\";\n            }\n            if (file_get_contents($passwordFile) != $passwordFileContents) {\n                $success = file_put_contents($passwordFile, $passwordFileContents) !== false;\n            }\n            return $success;\n        }\n\n        private function getAuthorizationCredentials(ServerRequestInterface $request): string\n        {\n            $serverParams = $request->getServerParams();\n            if (isset($serverParams['PHP_AUTH_USER'])) {\n                return $serverParams['PHP_AUTH_USER'] . ':' . $serverParams['PHP_AUTH_PW'];\n            }\n            $header = RequestUtils::getHeader($request, 'Authorization');\n            $parts = explode(' ', trim($header), 2);\n            if (count($parts) != 2) {\n                return '';\n            }\n            if ($parts[0] != 'Basic') {\n                return '';\n            }\n            return base64_decode(strtr($parts[1], '-_', '+/'));\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            if (session_status() == PHP_SESSION_NONE) {\n                if (!headers_sent()) {\n                    $sessionName = $this->getProperty('sessionName', '');\n                    if ($sessionName) {\n                        session_name($sessionName);\n                    }\n                    if (!ini_get('session.cookie_samesite')) {\n                        ini_set('session.cookie_samesite', 'Lax');\n                    }\n                    if (!ini_get('session.cookie_httponly')) {\n                        ini_set('session.cookie_httponly', 1);\n                    }\n                    if (!ini_get('session.cookie_secure') && isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] != 'off') {\n                        ini_set('session.cookie_secure', 1);\n                    }\n                    session_start();\n                }\n            }\n            $credentials = $this->getAuthorizationCredentials($request);\n            if ($credentials) {\n                list($username, $password) = array('', '');\n                if (strpos($credentials, ':') !== false) {\n                    list($username, $password) = explode(':', $credentials, 2);\n                }\n                $passwordFile = $this->getProperty('passwordFile', '.htpasswd');\n                $validUser = $this->getValidUsername($username, $password, $passwordFile);\n                $_SESSION['username'] = $validUser;\n                if (!$validUser) {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                }\n                if (!headers_sent()) {\n                    session_regenerate_id();\n                }\n            }\n            if (!isset($_SESSION['username']) || !$_SESSION['username']) {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    $response = $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                    $realm = $this->getProperty('realm', 'Username and password required');\n                    $response = $response->withHeader('WWW-Authenticate', \"Basic realm=\\\"$realm\\\"\");\n                    return $response;\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/CorsMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n    use Tqdev\\PhpCrudApi\\ResponseUtils;\n\n    class CorsMiddleware extends Middleware\n    {\n        private $debug;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->debug = $config->getDebug();\n        }\n\n        private function isOriginAllowed(string $origin, string $allowedOrigins): bool\n        {\n            $found = false;\n            foreach (explode(',', $allowedOrigins) as $allowedOrigin) {\n                $hostname = preg_quote(strtolower(trim($allowedOrigin)), '/');\n                $regex = '/^' . str_replace('\\*', '.*', $hostname) . '$/';\n                if (preg_match($regex, $origin)) {\n                    $found = true;\n                    break;\n                }\n            }\n            return $found;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $method = $request->getMethod();\n            $origin = count($request->getHeader('Origin')) ? $request->getHeader('Origin')[0] : '';\n            $allowedOrigins = $this->getProperty('allowedOrigins', '*');\n            if ($origin && !$this->isOriginAllowed($origin, $allowedOrigins)) {\n                $response = $this->responder->error(ErrorCode::ORIGIN_FORBIDDEN, $origin);\n            } elseif ($method == 'OPTIONS') {\n                $response = ResponseFactory::fromStatus(ResponseFactory::OK);\n                $allowHeaders = $this->getProperty('allowHeaders', 'Content-Type, X-XSRF-TOKEN, X-Authorization, X-API-Key');\n                if ($this->debug) {\n                    $allowHeaders = implode(', ', array_filter([$allowHeaders, 'X-Exception-Name, X-Exception-Message, X-Exception-File']));\n                }\n                if ($allowHeaders) {\n                    $response = $response->withHeader('Access-Control-Allow-Headers', $allowHeaders);\n                }\n                $allowMethods = $this->getProperty('allowMethods', 'OPTIONS, GET, PUT, POST, DELETE, PATCH');\n                if ($allowMethods) {\n                    $response = $response->withHeader('Access-Control-Allow-Methods', $allowMethods);\n                }\n                $allowCredentials = $this->getProperty('allowCredentials', 'true');\n                if ($allowCredentials) {\n                    $response = $response->withHeader('Access-Control-Allow-Credentials', $allowCredentials);\n                }\n                $maxAge = $this->getProperty('maxAge', '1728000');\n                if ($maxAge) {\n                    $response = $response->withHeader('Access-Control-Max-Age', $maxAge);\n                }\n                $exposeHeaders = $this->getProperty('exposeHeaders', '');\n                if ($this->debug) {\n                    $exposeHeaders = implode(', ', array_filter([$exposeHeaders, 'X-Exception-Name, X-Exception-Message, X-Exception-File']));\n                }\n                if ($exposeHeaders) {\n                    $response = $response->withHeader('Access-Control-Expose-Headers', $exposeHeaders);\n                }\n            } else {\n                $response = null;\n                try {\n                    $response = $next->handle($request);\n                } catch (\\Throwable $e) {\n                    $response = $this->responder->error(ErrorCode::ERROR_NOT_FOUND, $e->getMessage());\n                    if ($this->debug) {\n                        $response = ResponseUtils::addExceptionHeaders($response, $e);\n                    }\n                }\n            }\n            if ($origin) {\n                $allowCredentials = $this->getProperty('allowCredentials', 'true');\n                if ($allowCredentials) {\n                    $response = $response->withHeader('Access-Control-Allow-Credentials', $allowCredentials);\n                }\n                $response = $response->withHeader('Access-Control-Allow-Origin', $origin);\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/CustomizationMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class CustomizationMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            $beforeHandler = $this->getProperty('beforeHandler', '');\n            $environment = (object) array();\n            if ($beforeHandler !== '') {\n                $result = call_user_func($beforeHandler, $operation, $tableName, $request, $environment);\n                $request = $result ?: $request;\n            }\n            $response = $next->handle($request);\n            $afterHandler = $this->getProperty('afterHandler', '');\n            if ($afterHandler !== '') {\n                $result = call_user_func($afterHandler, $operation, $tableName, $response, $environment);\n                $response = $result ?: $response;\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/DbAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\Record\\OrderingInfo;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class DbAuthMiddleware extends Middleware\n    {\n        private $reflection;\n        private $db;\n        private $ordering;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection, GenericDB $db)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n            $this->db = $db;\n            $this->ordering = new OrderingInfo();\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            if (session_status() == PHP_SESSION_NONE) {\n                if (!headers_sent()) {\n                    $sessionName = $this->getProperty('sessionName', '');\n                    if ($sessionName) {\n                        session_name($sessionName);\n                    }\n                    if (!ini_get('session.cookie_samesite')) {\n                        ini_set('session.cookie_samesite', 'Lax');\n                    }\n                    if (!ini_get('session.cookie_httponly')) {\n                        ini_set('session.cookie_httponly', 1);\n                    }\n                    if (!ini_get('session.cookie_secure') && isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] != 'off') {\n                        ini_set('session.cookie_secure', 1);\n                    }\n                    session_start();\n                }\n            }\n            $path = RequestUtils::getPathSegment($request, 1);\n            $method = $request->getMethod();\n            if ($method == 'POST' && in_array($path, ['login', 'register', 'password'])) {\n                $body = $request->getParsedBody();\n                $usernameFormFieldName = $this->getProperty('usernameFormField', 'username');\n                $passwordFormFieldName = $this->getProperty('passwordFormField', 'password');\n                $newPasswordFormFieldName = $this->getProperty('newPasswordFormField', 'newPassword');\n                $username = isset($body->$usernameFormFieldName) ? $body->$usernameFormFieldName : '';\n                $password = isset($body->$passwordFormFieldName) ? $body->$passwordFormFieldName : '';\n                $newPassword = isset($body->$newPasswordFormFieldName) ? $body->$newPasswordFormFieldName : '';\n                //add separate property for login as this could be a view joining users table to other table \n                //such as roles, details etc. At a minimum, the view output should include the $usernameColumn and $passwordColumn\n                if ($path === 'login') {\n                    $tableName = $this->getProperty('loginTable', $this->getProperty('usersTable', 'users'));\n                } else {\n                    $tableName = $this->getProperty('usersTable', 'users');\n                }\n                $table = $this->reflection->getTable($tableName);\n                $usernameColumnName = $this->getProperty('usernameColumn', 'username');\n                $usernameColumn = $table->getColumn($usernameColumnName);\n                $passwordColumnName = $this->getProperty('passwordColumn', 'password');\n                $passwordLength = $this->getProperty('passwordLength', '12');\n                $pkName = $table->getPk()->getName();\n                $registerUser = $this->getProperty('registerUser', '');\n                $loginAfterRegistration = $this->getProperty('loginAfterRegistration', '');\n                $condition = new ColumnCondition($usernameColumn, 'eq', $username);\n                $returnedColumns = $this->getProperty('returnedColumns', '');\n                if (!$returnedColumns) {\n                    $columnNames = $table->getColumnNames();\n                } else {\n                    $columnNames = array_map('trim', explode(',', $returnedColumns));\n                    $columnNames[] = $passwordColumnName;\n                    $columnNames = array_values(array_unique($columnNames));\n                }\n                $columnOrdering = $this->ordering->getDefaultColumnOrdering($table);\n                if ($path == 'register') {\n                    if (!$registerUser) {\n                        return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                    }\n                    if (strlen(trim($username)) == 0) {\n                        return $this->responder->error(ErrorCode::USERNAME_EMPTY, $username);\n                    }\n                    if (strlen($password) < $passwordLength) {\n                        return $this->responder->error(ErrorCode::PASSWORD_TOO_SHORT, $passwordLength);\n                    }\n                    $users = $this->db->selectAll($table, $columnNames, $condition, $columnOrdering, 0, 1);\n                    if (!empty($users)) {\n                        return $this->responder->error(ErrorCode::USER_ALREADY_EXIST, $username);\n                    }\n                    $data = json_decode($registerUser, true);\n                    $data = is_array($data) ? $data : [];\n                    $data[$usernameColumnName] = $username;\n                    $data[$passwordColumnName] = password_hash($password, PASSWORD_DEFAULT);\n                    $this->db->createSingle($table, $data);\n                    $users = $this->db->selectAll($table, $columnNames, $condition, $columnOrdering, 0, 1);\n                    foreach ($users as $user) {\n                        if ($loginAfterRegistration) {\n                            if (!headers_sent()) {\n                                session_regenerate_id(true);\n                            }\n                            unset($user[$passwordColumnName]);\n                            $_SESSION['user'] = $user;\n                            return $this->responder->success($user);\n                        } else {\n                            unset($user[$passwordColumnName]);\n                            return $this->responder->success($user);\n                        }\n                    }\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                }\n                if ($path == 'login') {\n                    $users = $this->db->selectAll($table, $columnNames, $condition, $columnOrdering, 0, 1);\n                    foreach ($users as $user) {\n                        if (password_verify($password, $user[$passwordColumnName]) == 1) {\n                            if (!headers_sent()) {\n                                session_regenerate_id(true);\n                            }\n                            unset($user[$passwordColumnName]);\n                            $_SESSION['user'] = $user;\n                            return $this->responder->success($user);\n                        }\n                    }\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                }\n                if ($path == 'password') {\n                    if ($username != ($_SESSION['user'][$usernameColumnName] ?? '')) {\n                        return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                    }\n                    if (strlen($newPassword) < $passwordLength) {\n                        return $this->responder->error(ErrorCode::PASSWORD_TOO_SHORT, $passwordLength);\n                    }\n                    $userColumns = $columnNames;\n                    if (!in_array($pkName, $columnNames)) {\n                        array_push($userColumns, $pkName);\n                    }\n                    $users = $this->db->selectAll($table, $userColumns, $condition, $columnOrdering, 0, 1);\n                    foreach ($users as $user) {\n                        if (password_verify($password, $user[$passwordColumnName]) == 1) {\n                            if (!headers_sent()) {\n                                session_regenerate_id(true);\n                            }\n                            $data = [$passwordColumnName => password_hash($newPassword, PASSWORD_DEFAULT)];\n                            $this->db->updateSingle($table, $data, $user[$pkName]);\n                            unset($user[$passwordColumnName]);\n                            if (!in_array($pkName, $columnNames)) {\n                                unset($user[$pkName]);\n                            }\n                            return $this->responder->success($user);\n                        }\n                    }\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                }\n            }\n            if ($method == 'POST' && $path == 'logout') {\n                if (isset($_SESSION['user'])) {\n                    $user = $_SESSION['user'];\n                    unset($_SESSION['user']);\n                    if (session_status() != PHP_SESSION_NONE) {\n                        session_destroy();\n                    }\n                    return $this->responder->success($user);\n                }\n                return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n            }\n            if ($method == 'GET' && $path == 'me') {\n                if (isset($_SESSION['user'])) {\n                    return $this->responder->success($_SESSION['user']);\n                }\n                return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n            }\n            if (!isset($_SESSION['user']) || !$_SESSION['user']) {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/FirewallMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n\n    class FirewallMiddleware extends Middleware\n    {\n        private function ipMatch(string $ip, string $cidr): bool\n        {\n            if (strpos($cidr, '/') !== false) {\n                list($subnet, $mask) = explode('/', trim($cidr));\n                if ((ip2long($ip) & ~((1 << (32 - $mask)) - 1)) == ip2long($subnet)) {\n                    return true;\n                }\n            } else {\n                if (ip2long($ip) == ip2long($cidr)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private function isIpAllowed(string $ipAddress, string $allowedIpAddresses): bool\n        {\n            foreach (explode(',', $allowedIpAddresses) as $allowedIp) {\n                if ($this->ipMatch($ipAddress, $allowedIp)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private function getIpAddress(ServerRequestInterface $request): string\n        {\n            $reverseProxy = $this->getProperty('reverseProxy', '');\n            if ($reverseProxy) {\n                $ipAddress = array_pop($request->getHeader('X-Forwarded-For'));\n            } else {\n                $serverParams = $request->getServerParams();\n                $ipAddress = $serverParams['REMOTE_ADDR'] ?? '127.0.0.1';\n            }\n            return $ipAddress;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $ipAddress = $this->getIpAddress($request);\n            $allowedIpAddresses = $this->getProperty('allowedIpAddresses', '');\n            if (!$this->isIpAllowed($ipAddress, $allowedIpAddresses)) {\n                $response = $this->responder->error(ErrorCode::TEMPORARY_OR_PERMANENTLY_BLOCKED, '');\n            } else {\n                $response = $next->handle($request);\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/IpAddressMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class IpAddressMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        private function callHandler(ServerRequestInterface $request, $record, string $operation, ReflectedTable $table) /*: object */\n        {\n            $context = (array) $record;\n            $columnNames = $this->getProperty('columns', '');\n            if ($columnNames) {\n                foreach (explode(',', $columnNames) as $columnName) {\n                    if ($table->hasColumn($columnName)) {\n                        if ($operation == 'create') {\n                            $context[$columnName] = $this->getIpAddress($request);\n                        } else {\n                            unset($context[$columnName]);\n                        }\n                    }\n                }\n            }\n            return (object) $context;\n        }\n\n        private function getIpAddress(ServerRequestInterface $request): string\n        {\n            $reverseProxy = $this->getProperty('reverseProxy', '');\n            if ($reverseProxy) {\n                $ipAddress = array_pop($request->getHeader('X-Forwarded-For'));\n            } else {\n                $serverParams = $request->getServerParams();\n                $ipAddress = $serverParams['REMOTE_ADDR'] ?? '127.0.0.1';\n            }\n            return $ipAddress;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            if (in_array($operation, ['create', 'update', 'increment'])) {\n                $tableNames = $this->getProperty('tables', '');\n                $tableName = RequestUtils::getPathSegment($request, 2);\n                if (!$tableNames || in_array($tableName, explode(',', $tableNames))) {\n                    if ($this->reflection->hasTable($tableName)) {\n                        $record = $request->getParsedBody();\n                        if ($record !== null) {\n                            $table = $this->reflection->getTable($tableName);\n                            if (is_array($record)) {\n                                foreach ($record as &$r) {\n                                    $r = $this->callHandler($request, $r, $operation, $table);\n                                }\n                            } else {\n                                $record = $this->callHandler($request, $record, $operation, $table);\n                            }\n                            $request = $request->withParsedBody($record);\n                        }\n                    }\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/JoinLimitsMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class JoinLimitsMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            $params = RequestUtils::getParams($request);\n            if (in_array($operation, ['read', 'list']) && isset($params['join'])) {\n                $maxDepth = (int) $this->getProperty('depth', '3');\n                $maxTables = (int) $this->getProperty('tables', '10');\n                $maxRecords = (int) $this->getProperty('records', '1000');\n                $tableCount = 0;\n                $joinPaths = array();\n                for ($i = 0; $i < count($params['join']); $i++) {\n                    $joinPath = array();\n                    $tables = explode(',', $params['join'][$i]);\n                    for ($depth = 0; $depth < min($maxDepth, count($tables)); $depth++) {\n                        array_push($joinPath, $tables[$depth]);\n                        $tableCount += 1;\n                        if ($tableCount == $maxTables) {\n                            break;\n                        }\n                    }\n                    array_push($joinPaths, implode(',', $joinPath));\n                    if ($tableCount == $maxTables) {\n                        break;\n                    }\n                }\n                $params['join'] = $joinPaths;\n                $request = RequestUtils::setParams($request, $params);\n                VariableStore::set(\"joinLimits.maxRecords\", $maxRecords);\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/JsonMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n\n    class JsonMiddleware extends Middleware\n    {\n        private function convertJsonRequestValue($value) /*: object */\n        {\n            if (is_array($value) || is_object($value)) {\n                $value = json_encode($value,JSON_UNESCAPED_UNICODE);\n            }\n            return $value;\n        }\n        \n        private function convertJsonRequest($object, array $columnNames) /*: object */\n        {\n            if (is_array($object)) {\n                foreach ($object as $i => $obj) {\n                    foreach ($obj as $k => $v) {\n                        if (in_array('all', $columnNames) || in_array($k, $columnNames)) {\n                            $object[$i]->$k = $this->convertJsonRequestValue($v);\n                        }\n                    }\n                }\n            } else if (is_object($object)) {\n                foreach ($object as $k => $v) {\n                    if (in_array('all', $columnNames) || in_array($k, $columnNames)) {\n                        $object->$k = $this->convertJsonRequestValue($v);\n                    }\n                }\n            }\n            return $object;\n        }\n\n        private function convertJsonResponseValue(string $value) /*: object */\n        {\n            if (strlen($value) > 0 && in_array($value[0],['[','{'])) {\n                $parsed = json_decode($value);\n                if (json_last_error() == JSON_ERROR_NONE) {\n                    $value = $parsed;\n                }\n            }\n            return $value;\n        }\n\n        private function convertJsonResponse($object, array $columnNames) /*: object */\n        {\n            if (is_array($object)) {\n                foreach ($object as $k => $v) {\n                    $object[$k] = $this->convertJsonResponse($v, $columnNames);\n                }\n            } else if (is_object($object)) {\n                foreach ($object as $k => $v) {\n                    if (in_array('all', $columnNames) || in_array($k, $columnNames)) {\n                        $object->$k = $this->convertJsonResponse($v, $columnNames);\n                    }\n                }\n            } else if (is_string($object)) {\n                $object = $this->convertJsonResponseValue($object);\n            }\n            return $object;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            $controllerPath = RequestUtils::getPathSegment($request, 1);\n            $tableName = RequestUtils::getPathSegment($request, 2);\n\n            $controllerPaths = $this->getArrayProperty('controllers', 'records,geojson');\n    \t\t$tableNames = $this->getArrayProperty('tables', 'all');\n    \t\t$columnNames = $this->getArrayProperty('columns', 'all');\n    \t\tif (\n    \t\t\t(in_array('all', $controllerPaths) || in_array($controllerPath, $controllerPaths)) &&\n    \t\t\t(in_array('all', $tableNames) || in_array($tableName, $tableNames))\n    \t\t) {\n                if (in_array($operation, ['create', 'update'])) {\n                    $records = $request->getParsedBody();\n                    $records = $this->convertJsonRequest($records,$columnNames);\n                    $request = $request->withParsedBody($records);\n                }\n                $response = $next->handle($request);\n                if (in_array($operation, ['read', 'list'])) {\n                    if ($response->getStatusCode() == ResponseFactory::OK) {\n                        $records = json_decode($response->getBody()->getContents());\n                        $records = $this->convertJsonResponse($records, $columnNames);\n                        $response = $this->responder->success($records);\n                    }\n                }\n            } else {\n                $response = $next->handle($request);\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/JwtAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class JwtAuthMiddleware extends Middleware\n    {\n        private function getVerifiedClaims(string $token, int $time, int $leeway, int $ttl, array $secrets, array $requirements): array\n        {\n            $algorithms = array(\n                'HS256' => 'sha256',\n                'HS384' => 'sha384',\n                'HS512' => 'sha512',\n                'RS256' => 'sha256',\n                'RS384' => 'sha384',\n                'RS512' => 'sha512',\n            );\n            $token = explode('.', $token);\n            if (count($token) < 3) {\n                return array();\n            }\n            $header = json_decode(base64_decode(strtr($token[0], '-_', '+/')), true);\n            $kid = 0;\n            if (isset($header['kid'])) {\n                $kid = $header['kid'];\n            }\n            if (!isset($secrets[$kid])) {\n                return array();\n            }\n            $secret = $secrets[$kid];\n            if ($header['typ'] != 'JWT') {\n                return array();\n            }\n            $algorithm = $header['alg'];\n            if (!isset($algorithms[$algorithm])) {\n                return array();\n            }\n            if (!empty($requirements['alg']) && !in_array($algorithm, $requirements['alg'])) {\n                return array();\n            }\n            $hmac = $algorithms[$algorithm];\n            $signature = base64_decode(strtr($token[2], '-_', '+/'));\n            $data = \"$token[0].$token[1]\";\n            switch ($algorithm[0]) {\n                case 'H':\n                    $hash = hash_hmac($hmac, $data, $secret, true);\n                    $equals = hash_equals($hash, $signature);\n                    if (!$equals) {\n                        return array();\n                    }\n                    break;\n                case 'R':\n                    $equals = openssl_verify($data, $signature, $secret, $hmac) == 1;\n                    if (!$equals) {\n                        return array();\n                    }\n                    break;\n            }\n            $claims = json_decode(base64_decode(strtr($token[1], '-_', '+/')), true);\n            if (!$claims) {\n                return array();\n            }\n            foreach ($requirements as $field => $values) {\n                if (!empty($values)) {\n                    if ($field != 'alg') {\n                        if (!isset($claims[$field])) {\n                            return array();\n                        }\n                        if (is_array($claims[$field])) {\n                            if (!array_intersect($claims[$field], $values)) {\n                                return array();\n                            }\n                        } else {\n                            if (!in_array($claims[$field], $values)) {\n                                return array();\n                            }\n                        }\n                    }\n                }\n            }\n            if (isset($claims['nbf']) && $time + $leeway < $claims['nbf']) {\n                return array();\n            }\n            if (isset($claims['iat']) && $time + $leeway < $claims['iat']) {\n                return array();\n            }\n            if (isset($claims['exp']) && $time - $leeway > $claims['exp']) {\n                return array();\n            }\n            if (isset($claims['iat']) && !isset($claims['exp'])) {\n                if ($time - $leeway > $claims['iat'] + $ttl) {\n                    return array();\n                }\n            }\n            return $claims;\n        }\n\n        private function getClaims(string $token): array\n        {\n            $time = (int) $this->getProperty('time', time());\n            $leeway = (int) $this->getProperty('leeway', '5');\n            $ttl = (int) $this->getProperty('ttl', '30');\n            $secrets = $this->getMapProperty('secrets', '');\n            if (!$secrets) {\n                $secrets = [$this->getProperty('secret', '')];\n            }\n            $requirements = array(\n                'alg' => $this->getArrayProperty('algorithms', ''),\n                'aud' => $this->getArrayProperty('audiences', ''),\n                'iss' => $this->getArrayProperty('issuers', ''),\n            );\n            return $this->getVerifiedClaims($token, $time, $leeway, $ttl, $secrets, $requirements);\n        }\n\n        private function getAuthorizationToken(ServerRequestInterface $request): string\n        {\n            $headerName = $this->getProperty('header', 'X-Authorization');\n            $headerValue = RequestUtils::getHeader($request, $headerName);\n            $parts = explode(' ', trim($headerValue), 2);\n            if (count($parts) != 2) {\n                return '';\n            }\n            if ($parts[0] != 'Bearer') {\n                return '';\n            }\n            return $parts[1];\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            if (session_status() == PHP_SESSION_NONE) {\n                if (!headers_sent()) {\n                    $sessionName = $this->getProperty('sessionName', '');\n                    if ($sessionName) {\n                        session_name($sessionName);\n                    }\n                    if (!ini_get('session.cookie_samesite')) {\n                        ini_set('session.cookie_samesite', 'Lax');\n                    }\n                    if (!ini_get('session.cookie_httponly')) {\n                        ini_set('session.cookie_httponly', 1);\n                    }\n                    if (!ini_get('session.cookie_secure') && isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] != 'off') {\n                        ini_set('session.cookie_secure', 1);\n                    }\n                    session_start();\n                }\n            }\n            $token = $this->getAuthorizationToken($request);\n            if ($token) {\n                $claims = $this->getClaims($token);\n                $_SESSION['claims'] = $claims;\n                if (empty($claims)) {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, 'JWT');\n                }\n                if (!headers_sent()) {\n                    session_regenerate_id();\n                }\n            }\n            if (empty($_SESSION['claims'])) {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/MultiTenancyMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\Condition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\NoCondition;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class MultiTenancyMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        private function getCondition(string $tableName, array $pairs): Condition\n        {\n            $condition = new NoCondition();\n            $table = $this->reflection->getTable($tableName);\n            foreach ($pairs as $k => $v) {\n                $condition = $condition->_and(new ColumnCondition($table->getColumn($k), 'eq', $v));\n            }\n            return $condition;\n        }\n\n        private function getPairs($handler, string $operation, string $tableName): array\n        {\n            $result = array();\n            $pairs = call_user_func($handler, $operation, $tableName) ?: [];\n            $table = $this->reflection->getTable($tableName);\n            foreach ($pairs as $k => $v) {\n                if ($table->hasColumn($k)) {\n                    $result[$k] = $v;\n                }\n            }\n            return $result;\n        }\n\n        private function handleRecord(ServerRequestInterface $request, string $operation, array $pairs): ServerRequestInterface\n        {\n            $record = $request->getParsedBody();\n            if ($record === null) {\n                return $request;\n            }\n            $multi = is_array($record);\n            $records = $multi ? $record : [$record];\n            foreach ($records as &$record) {\n                foreach ($pairs as $column => $value) {\n                    if ($operation == 'create') {\n                        $record->$column = $value;\n                    } else {\n                        if (isset($record->$column)) {\n                            unset($record->$column);\n                        }\n                    }\n                }\n            }\n            return $request->withParsedBody($multi ? $records : $records[0]);\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $handler = $this->getProperty('handler', '');\n            if ($handler !== '') {\n                $path = RequestUtils::getPathSegment($request, 1);\n                if ($path == 'records') {\n                    $operation = RequestUtils::getOperation($request);\n                    $tableNames = RequestUtils::getTableNames($request, $this->reflection);\n                    foreach ($tableNames as $i => $tableName) {\n                        if (!$this->reflection->hasTable($tableName)) {\n                            continue;\n                        }\n                        $pairs = $this->getPairs($handler, $operation, $tableName);\n                        if ($i == 0) {\n                            if (in_array($operation, ['create', 'update', 'increment'])) {\n                                $request = $this->handleRecord($request, $operation, $pairs);\n                            }\n                        }\n                        $condition = $this->getCondition($tableName, $pairs);\n                        VariableStore::set(\"multiTenancy.conditions.$tableName\", $condition);\n                    }\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/PageLimitsMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class PageLimitsMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            if ($operation == 'list') {\n                $params = RequestUtils::getParams($request);\n                $maxPage = (int) $this->getProperty('pages', '100');\n                if (isset($params['page']) && $params['page'] && $maxPage > 0) {\n                    if (strpos($params['page'][0], ',') === false) {\n                        $page = $params['page'][0];\n                    } else {\n                        list($page, $size) = explode(',', $params['page'][0], 2);\n                    }\n                    if ($page > $maxPage) {\n                        return $this->responder->error(ErrorCode::PAGINATION_FORBIDDEN, '');\n                    }\n                }\n                $maxSize = (int) $this->getProperty('records', '1000');\n                if (!isset($params['size']) || !$params['size'] && $maxSize > 0) {\n                    $params['size'] = array($maxSize);\n                } else {\n                    $params['size'] = array(min($params['size'][0], $maxSize));\n                }\n                $request = RequestUtils::setParams($request, $params);\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/ReconnectMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n\n    class ReconnectMiddleware extends Middleware\n    {\n        private $config;\n        private $db;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection, GenericDB $db)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->config = $config;\n            $this->db = $db;\n        }\n\n        private function getDriver(): string\n        {\n            $driverHandler = $this->getProperty('driverHandler', '');\n            if ($driverHandler) {\n                return call_user_func($driverHandler);\n            }\n            return $this->config->getDriver();\n        }\n\n        private function getAddress(): string\n        {\n            $addressHandler = $this->getProperty('addressHandler', '');\n            if ($addressHandler) {\n                return call_user_func($addressHandler);\n            }\n            return $this->config->getAddress();\n        }\n\n        private function getPort(): int\n        {\n            $portHandler = $this->getProperty('portHandler', '');\n            if ($portHandler) {\n                return call_user_func($portHandler);\n            }\n            return $this->config->getPort();\n        }\n\n        private function getDatabase(): string\n        {\n            $databaseHandler = $this->getProperty('databaseHandler', '');\n            if ($databaseHandler) {\n                return call_user_func($databaseHandler);\n            }\n            return $this->config->getDatabase();\n        }\n\n        private function getCommand(): string\n        {\n            $commandHandler = $this->getProperty('commandHandler', '');\n            if ($commandHandler) {\n                return call_user_func($commandHandler);\n            }\n            return $this->config->getCommand();\n        }\n\n        private function getTables(): array\n        {\n            $tablesHandler = $this->getProperty('tablesHandler', '');\n            if ($tablesHandler) {\n                return call_user_func($tablesHandler);\n            }\n            return $this->config->getTables();\n        }\n\n        private function getMapping(): array\n        {\n            $mappingHandler = $this->getProperty('mappingHandler', '');\n            if ($mappingHandler) {\n                return call_user_func($mappingHandler);\n            }\n            return $this->config->getMapping();\n        }\n\n        private function getUsername(): string\n        {\n            $usernameHandler = $this->getProperty('usernameHandler', '');\n            if ($usernameHandler) {\n                return call_user_func($usernameHandler);\n            }\n            return $this->config->getUsername();\n        }\n\n        private function getPassword(): string\n        {\n            $passwordHandler = $this->getProperty('passwordHandler', '');\n            if ($passwordHandler) {\n                return call_user_func($passwordHandler);\n            }\n            return $this->config->getPassword();\n        }\n\n        private function getGeometrySrid(): int\n        {\n            $geometrySridHandler = $this->getProperty('geometrySridHandler', '');\n            if ($geometrySridHandler) {\n                return call_user_func($geometrySridHandler);\n            }\n            return $this->config->getGeometrySrid();\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $driver = $this->getDriver();\n            $address = $this->getAddress();\n            $port = $this->getPort();\n            $database = $this->getDatabase();\n            $command = $this->getCommand();\n            $tables = $this->getTables();\n            $mapping = $this->getMapping();\n            $username = $this->getUsername();\n            $password = $this->getPassword();\n            $geometrySrid = $this->getGeometrySrid();\n            $this->db->reconstruct($driver, $address, $port, $database, $command, $tables, $mapping, $username, $password, $geometrySrid);\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/SanitationMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class SanitationMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        private function callHandler($handler, $record, string $operation, ReflectedTable $table) /*: object */\n        {\n            $context = (array) $record;\n            $tableName = $table->getName();\n            foreach ($context as $columnName => &$value) {\n                if ($table->hasColumn($columnName)) {\n                    $column = $table->getColumn($columnName);\n                    $value = call_user_func($handler, $operation, $tableName, $column->serialize(), $value);\n                    $value = $this->sanitizeType($table, $column, $value);\n                }\n            }\n            return (object) $context;\n        }\n\n        private function sanitizeType(ReflectedTable $table, ReflectedColumn $column, $value)\n        {\n            $tables = $this->getArrayProperty('tables', 'all');\n            $types = $this->getArrayProperty('types', 'all');\n            if (\n                (in_array('all', $tables) || in_array($table->getName(), $tables)) &&\n                (in_array('all', $types) || in_array($column->getType(), $types))\n            ) {\n                if (is_null($value)) {\n                    return $value;\n                }\n                if (is_string($value)) {\n                    $newValue = null;\n                    switch ($column->getType()) {\n                        case 'integer':\n                        case 'bigint':\n                            $newValue = filter_var(trim($value), FILTER_VALIDATE_INT, FILTER_NULL_ON_FAILURE);\n                            break;\n                        case 'decimal':\n                            $newValue = filter_var(trim($value), FILTER_VALIDATE_FLOAT, FILTER_NULL_ON_FAILURE);\n                            if (is_float($newValue)) {\n                                $newValue = number_format($newValue, $column->getScale(), '.', '');\n                            }\n                            break;\n                        case 'float':\n                        case 'double':\n                            $newValue = filter_var(trim($value), FILTER_VALIDATE_FLOAT, FILTER_NULL_ON_FAILURE);\n                            break;\n                        case 'boolean':\n                            $newValue = filter_var(trim($value), FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE);\n                            break;\n                        case 'date':\n                            $time = strtotime(trim($value));\n                            if ($time !== false) {\n                                $newValue = date('Y-m-d', $time);\n                            }\n                            break;\n                        case 'time':\n                            $time = strtotime(trim($value));\n                            if ($time !== false) {\n                                $newValue = date('H:i:s', $time);\n                            }\n                            break;\n                        case 'timestamp':\n                            $time = strtotime(trim($value));\n                            if ($time !== false) {\n                                $newValue = date('Y-m-d H:i:s', $time);\n                            }\n                            break;\n                        case 'blob':\n                        case 'varbinary':\n                            // allow base64url format\n                            $newValue = strtr(trim($value), '-_', '+/');\n                            break;\n                        case 'clob':\n                        case 'varchar':\n                            $newValue = $value;\n                            break;\n                        case 'geometry':\n                            $newValue = trim($value);\n                            break;\n                    }\n                    if (!is_null($newValue)) {\n                        $value = $newValue;\n                    }\n                } else {\n                    switch ($column->getType()) {\n                        case 'integer':\n                        case 'bigint':\n                            if (is_float($value)) {\n                                $value = (int) round($value);\n                            }\n                            break;\n                        case 'decimal':\n                            if (is_float($value) || is_int($value)) {\n                                $value = number_format((float) $value, $column->getScale(), '.', '');\n                            }\n                            break;\n                    }\n                }\n                // post process\n            }\n            return $value;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            if (in_array($operation, ['create', 'update', 'increment'])) {\n                $tableName = RequestUtils::getPathSegment($request, 2);\n                if ($this->reflection->hasTable($tableName)) {\n                    $record = $request->getParsedBody();\n                    if ($record !== null) {\n                        $handler = $this->getProperty('handler', '');\n                        if ($handler !== '') {\n                            $table = $this->reflection->getTable($tableName);\n                            if (is_array($record)) {\n                                foreach ($record as &$r) {\n                                    $r = $this->callHandler($handler, $r, $operation, $table);\n                                }\n                            } else {\n                                $record = $this->callHandler($handler, $record, $operation, $table);\n                            }\n                            $request = $request->withParsedBody($record);\n                        }\n                    }\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/SslRedirectMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n\n    class SslRedirectMiddleware extends Middleware\n    {\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $uri = $request->getUri();\n            $scheme = $uri->getScheme();\n            if ($scheme == 'http') {\n                $uri = $request->getUri();\n                $uri = $uri->withScheme('https');\n                $response = ResponseFactory::fromStatus(301);\n                $response = $response->withHeader('Location', $uri->__toString());\n            } else {\n                $response = $next->handle($request);\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/TextSearchMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class TextSearchMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            if ($operation == 'list') {\n                $tableName = RequestUtils::getPathSegment($request, 2);\n                $params = RequestUtils::getParams($request);\n                $parameterName = $this->getProperty('parameter', 'search');\n                if (isset($params[$parameterName])) {\n                    $search = $params[$parameterName][0];\n                    unset($params[$parameterName]);\n                    $table = $this->reflection->getTable($tableName);\n                    $i = 0;\n                    foreach ($table->getColumnNames() as $columnName) {\n                        $column = $table->getColumn($columnName);\n                        while (isset($params[\"filter$i\"])) {\n                            $i++;\n                        }\n                        if ($i >= 10) {\n                            break;\n                        }\n                        if ($column->isText()) {\n                            $params[\"filter$i\"] = \"$columnName,cs,$search\";\n                            $i++;\n                        }\n                    }\n                }\n                $request = RequestUtils::setParams($request, $params);\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/ValidationMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class ValidationMiddleware extends Middleware\n    {\n    \tprivate $reflection;\n\n    \tpublic function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n    \t{\n    \t\tparent::__construct($router, $responder, $config, $middleware);\n    \t\t$this->reflection = $reflection;\n    \t}\n\n    \tprivate function callHandler($handler, $record, string $operation, ReflectedTable $table) /*: ResponseInterface?*/\n    \t{\n    \t\t$context = (array) $record;\n    \t\t$details = array();\n    \t\t$tableName = $table->getName();\n    \t\tforeach ($context as $columnName => $value) {\n    \t\t\tif ($table->hasColumn($columnName)) {\n    \t\t\t\t$column = $table->getColumn($columnName);\n    \t\t\t\t$valid = call_user_func($handler, $operation, $tableName, $column->serialize(), $value, $context);\n    \t\t\t\tif ($valid === true || $valid === '') {\n    \t\t\t\t\t$valid = $this->validateType($table, $column, $value);\n    \t\t\t\t}\n    \t\t\t\tif ($valid !== true && $valid !== '') {\n    \t\t\t\t\t$details[$columnName] = $valid;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tif (count($details) > 0) {\n    \t\t\treturn $this->responder->error(ErrorCode::INPUT_VALIDATION_FAILED, $tableName, $details);\n    \t\t}\n    \t\treturn null;\n    \t}\n\n    \tprivate function validateType(ReflectedTable $table, ReflectedColumn $column, $value)\n    \t{\n    \t\t$tables = $this->getArrayProperty('tables', 'all');\n    \t\t$types = $this->getArrayProperty('types', 'all');\n    \t\tif (\n    \t\t\t(in_array('all', $tables) || in_array($table->getName(), $tables)) &&\n    \t\t\t(in_array('all', $types) || in_array($column->getType(), $types))\n    \t\t) {\n    \t\t\tif (is_null($value)) {\n    \t\t\t\treturn ($column->getNullable() ? true : \"cannot be null\");\n    \t\t\t}\n    \t\t\tif (is_string($value)) {\n    \t\t\t\t// check for whitespace\n    \t\t\t\tswitch ($column->getType()) {\n    \t\t\t\t\tcase 'varchar':\n    \t\t\t\t\tcase 'clob':\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tdefault:\n    \t\t\t\t\t\tif (strlen(trim($value)) != strlen($value)) {\n    \t\t\t\t\t\t\treturn 'illegal whitespace';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\t// try to parse\n    \t\t\t\tswitch ($column->getType()) {\n    \t\t\t\t\tcase 'integer':\n    \t\t\t\t\tcase 'bigint':\n    \t\t\t\t\t\tif (\n    \t\t\t\t\t\t\tfilter_var($value, FILTER_SANITIZE_NUMBER_INT) !== $value ||\n    \t\t\t\t\t\t\tfilter_var($value, FILTER_VALIDATE_INT) === false\n    \t\t\t\t\t\t) {\n    \t\t\t\t\t\t\treturn 'invalid integer';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'decimal':\n    \t\t\t\t\t\tif (strpos($value, '.') !== false) {\n    \t\t\t\t\t\t\tlist($whole, $decimals) = explode('.', ltrim($value, '-'), 2);\n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\tlist($whole, $decimals) = array(ltrim($value, '-'), '');\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif (strlen($whole) > 0 && !ctype_digit($whole)) {\n    \t\t\t\t\t\t\treturn 'invalid decimal';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif (strlen($decimals) > 0 && !ctype_digit($decimals)) {\n    \t\t\t\t\t\t\treturn 'invalid decimal';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif (strlen($whole) > $column->getPrecision() - $column->getScale()) {\n    \t\t\t\t\t\t\treturn 'decimal too large';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif (strlen($decimals) > $column->getScale()) {\n    \t\t\t\t\t\t\treturn 'decimal too precise';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'float':\n    \t\t\t\t\tcase 'double':\n    \t\t\t\t\t\tif (\n    \t\t\t\t\t\t\tfilter_var($value, FILTER_SANITIZE_NUMBER_FLOAT) !== $value ||\n    \t\t\t\t\t\t\tfilter_var($value, FILTER_VALIDATE_FLOAT) === false\n    \t\t\t\t\t\t) {\n    \t\t\t\t\t\t\treturn 'invalid float';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'boolean':\n    \t\t\t\t\t\tif (!in_array(strtolower($value), array('true', 'false'))) {\n    \t\t\t\t\t\t\treturn 'invalid boolean';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'date':\n    \t\t\t\t\t\tif (date_create_from_format('Y-m-d', $value) === false) {\n    \t\t\t\t\t\t\treturn 'invalid date';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'time':\n    \t\t\t\t\t\tif (date_create_from_format('H:i:s', $value) === false) {\n    \t\t\t\t\t\t\treturn 'invalid time';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'timestamp':\n    \t\t\t\t\t\tif (date_create_from_format('Y-m-d H:i:s', $value) === false) {\n    \t\t\t\t\t\t\treturn 'invalid timestamp';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'clob':\n    \t\t\t\t\tcase 'varchar':\n    \t\t\t\t\t\tif ($column->hasLength() && mb_strlen($value, 'UTF-8') > $column->getLength()) {\n    \t\t\t\t\t\t\treturn 'string too long';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'blob':\n    \t\t\t\t\tcase 'varbinary':\n    \t\t\t\t\t\tif (base64_decode($value, true) === false) {\n    \t\t\t\t\t\t\treturn 'invalid base64';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif ($column->hasLength() && strlen(base64_decode($value)) > $column->getLength()) {\n    \t\t\t\t\t\t\treturn 'string too long';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'geometry':\n    \t\t\t\t\t\t// no checks yet\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t} else { // check non-string types\n    \t\t\t\tswitch ($column->getType()) {\n    \t\t\t\t\tcase 'integer':\n    \t\t\t\t\tcase 'bigint':\n    \t\t\t\t\t\tif (!is_int($value)) {\n    \t\t\t\t\t\t\treturn 'invalid integer';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'float':\n    \t\t\t\t\tcase 'double':\n    \t\t\t\t\t\tif (!is_float($value) && !is_int($value)) {\n    \t\t\t\t\t\t\treturn 'invalid float';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'boolean':\n    \t\t\t\t\t\tif (!is_bool($value) && ($value !== 0) && ($value !== 1)) {\n    \t\t\t\t\t\t\treturn 'invalid boolean';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tdefault:\n    \t\t\t\t\t\treturn 'invalid ' . $column->getType();\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t// extra checks\n    \t\t\tswitch ($column->getType()) {\n    \t\t\t\tcase 'integer': // 4 byte signed\n    \t\t\t\t\t$value = filter_var($value, FILTER_VALIDATE_INT);\n    \t\t\t\t\tif ($value > 2147483647 || $value < -2147483648) {\n    \t\t\t\t\t\treturn 'invalid integer';\n    \t\t\t\t\t}\n    \t\t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\treturn (true);\n    \t}\n\n    \tpublic function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n    \t{\n    \t\t$operation = RequestUtils::getOperation($request);\n    \t\tif (in_array($operation, ['create', 'update', 'increment'])) {\n    \t\t\t$tableName = RequestUtils::getPathSegment($request, 2);\n    \t\t\tif ($this->reflection->hasTable($tableName)) {\n    \t\t\t\t$record = $request->getParsedBody();\n    \t\t\t\tif ($record !== null) {\n    \t\t\t\t\t$handler = $this->getProperty('handler', '');\n    \t\t\t\t\tif ($handler !== '') {\n    \t\t\t\t\t\t$table = $this->reflection->getTable($tableName);\n    \t\t\t\t\t\tif (is_array($record)) {\n    \t\t\t\t\t\t\tforeach ($record as $r) {\n    \t\t\t\t\t\t\t\t$response = $this->callHandler($handler, $r, $operation, $table);\n    \t\t\t\t\t\t\t\tif ($response !== null) {\n    \t\t\t\t\t\t\t\t\treturn $response;\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\t$response = $this->callHandler($handler, $record, $operation, $table);\n    \t\t\t\t\t\t\tif ($response !== null) {\n    \t\t\t\t\t\t\t\treturn $response;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn $next->handle($request);\n    \t}\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/WpAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class WpAuthMiddleware extends Middleware\n    {\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            define('WP_USE_THEMES', false); // Don't load theme support functionality\n            $wpDirectory = $this->getProperty('wpDirectory', '.');\n            require_once(\"$wpDirectory/wp-load.php\");\n            $path = RequestUtils::getPathSegment($request, 1);\n            $method = $request->getMethod();\n            if ($method == 'POST' && $path == 'login') {\n                $body = $request->getParsedBody();\n                $usernameFormFieldName = $this->getProperty('usernameFormField', 'username');\n                $passwordFormFieldName = $this->getProperty('passwordFormField', 'password');\n                $username = isset($body->$usernameFormFieldName) ? $body->$usernameFormFieldName : '';\n                $password = isset($body->$passwordFormFieldName) ? $body->$passwordFormFieldName : '';\n                $user = wp_signon([\n                    'user_login'    => $username,\n                    'user_password' => $password,\n                    'remember'      => false,\n                ]);\n                if ($user->ID) {\n                    unset($user->data->user_pass);\n                    return $this->responder->success($user);\n                }\n                return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n            }\n            if ($method == 'POST' && $path == 'logout') {\n                if (is_user_logged_in()) {\n                    wp_logout();\n                    $user = wp_get_current_user();\n                    unset($user->data->user_pass);\n                    return $this->responder->success($user);\n                }\n                return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n            }\n            if ($method == 'GET' && $path == 'me') {\n                if (is_user_logged_in()) {\n                    $user = wp_get_current_user();\n                    unset($user->data->user_pass);\n                    return $this->responder->success($user);\n                }\n                return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n            }\n            if (!is_user_logged_in()) {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/XmlMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n\n    class XmlMiddleware extends Middleware\n    {\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n        }\n\n        private function json2xml($json, $types = 'null,boolean,number,string,object,array')\n        {\n            $a = json_decode($json);\n            $d = new \\DOMDocument();\n            $c = $d->createElement(\"root\");\n            $d->appendChild($c);\n            $t = function ($v) {\n                $type = gettype($v);\n                switch ($type) {\n                    case 'integer':\n                        return 'number';\n                    case 'double':\n                        return 'number';\n                    default:\n                        return strtolower($type);\n                }\n            };\n            $ts = explode(',', $types);\n            $f = function ($f, $c, $a, $s = false) use ($t, $d, $ts) {\n                if (in_array($t($a), $ts)) {\n                    $c->setAttribute('type', $t($a));\n                }\n                if ($t($a) != 'array' && $t($a) != 'object') {\n                    if ($t($a) == 'boolean') {\n                        $c->appendChild($d->createTextNode($a ? 'true' : 'false'));\n                    } else {\n                        $c->appendChild($d->createTextNode($a));\n                    }\n                } else {\n                    foreach ($a as $k => $v) {\n                        $k = preg_replace('/[^a-z0-9\\-\\_\\.]/', '', $k);\n                        if ($k == '__type' && $t($a) == 'object') {\n                            $c->setAttribute('__type', $v);\n                        } else {\n                            if ($t($v) == 'object') {\n                                $ch = $c->appendChild($d->createElementNS(null, $s ? 'item' : $k));\n                                $f($f, $ch, $v);\n                            } else if ($t($v) == 'array') {\n                                $ch = $c->appendChild($d->createElementNS(null, $s ? 'item' : $k));\n                                $f($f, $ch, $v, true);\n                            } else {\n                                $va = $d->createElementNS(null, $s ? 'item' : $k);\n                                if ($t($v) == 'boolean') {\n                                    $va->appendChild($d->createTextNode($v ? 'true' : 'false'));\n                                } else {\n                                    $va->appendChild($d->createTextNode((string) $v));\n                                }\n                                $ch = $c->appendChild($va);\n                                if (in_array($t($v), $ts)) {\n                                    $ch->setAttribute('type', $t($v));\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            $f($f, $c, $a, $t($a) == 'array');\n            return $d->saveXML($d->documentElement);\n        }\n\n        private function xml2json($xml): string\n        {\n            $o = @simplexml_load_string($xml);\n            if ($o === false) {\n                return '';\n            }\n            $a = @dom_import_simplexml($o);\n            if (!$a) {\n                return '';\n            }\n            $t = function ($v) {\n                $t = $v->getAttribute('type');\n                $txt = $v->firstChild->nodeType == XML_TEXT_NODE;\n                return $t ?: ($txt ? 'string' : 'object');\n            };\n            $f = function ($f, $a) use ($t) {\n                $c = null;\n                if ($t($a) == 'null') {\n                    $c = null;\n                } else if ($t($a) == 'boolean') {\n                    $b = substr(strtolower($a->textContent), 0, 1);\n                    $c = in_array($b, array('1', 't'));\n                } else if ($t($a) == 'number') {\n                    $c = $a->textContent + 0;\n                } else if ($t($a) == 'string') {\n                    $c = $a->textContent;\n                } else if ($t($a) == 'object') {\n                    $c = array();\n                    if ($a->getAttribute('__type')) {\n                        $c['__type'] = $a->getAttribute('__type');\n                    }\n                    for ($i = 0; $i < $a->childNodes->length; $i++) {\n                        $v = $a->childNodes[$i];\n                        $c[$v->nodeName] = $f($f, $v);\n                    }\n                    $c = (object) $c;\n                } else if ($t($a) == 'array') {\n                    $c = array();\n                    for ($i = 0; $i < $a->childNodes->length; $i++) {\n                        $v = $a->childNodes[$i];\n                        $c[$i] = $f($f, $v);\n                    }\n                }\n                return $c;\n            };\n            $c = $f($f, $a);\n            return (string) json_encode($c);\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            parse_str($request->getUri()->getQuery(), $params);\n            $isXml = isset($params['format']) && $params['format'] == 'xml';\n            if ($isXml) {\n                $body = $request->getBody()->getContents();\n                if ($body) {\n                    $json = $this->xml2json($body);\n                    $request = $request->withParsedBody(json_decode($json));\n                }\n            }\n            $response = $next->handle($request);\n            if ($isXml) {\n                $body = $response->getBody()->getContents();\n                if ($body) {\n                    $types = implode(',', $this->getArrayProperty('types', 'null,array'));\n                    if ($types == '' || $types == 'all') {\n                        $xml = $this->json2xml($body);\n                    } else {\n                        $xml = $this->json2xml($body, $types);\n                    }\n                    $response = ResponseFactory::fromXml(ResponseFactory::OK, $xml);\n                }\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/XsrfMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n\n    class XsrfMiddleware extends Middleware\n    {\n        private function getToken(ServerRequestInterface $request): string\n        {\n            $cookieName = $this->getProperty('cookieName', 'XSRF-TOKEN');\n            $cookieParams = $request->getCookieParams();\n            if (isset($cookieParams[$cookieName])) {\n                $token = $cookieParams[$cookieName];\n            } else {\n                $secure = $request->getUri()->getScheme() == 'https';\n                $token = bin2hex(random_bytes(8));\n                if (!headers_sent()) {\n                    setcookie($cookieName, $token, 0, '/', '', $secure);\n                }\n            }\n            return $token;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $token = $this->getToken($request);\n            $method = $request->getMethod();\n            $excludeMethods = $this->getArrayProperty('excludeMethods', 'OPTIONS,GET');\n            if (!in_array($method, $excludeMethods)) {\n                $headerName = $this->getProperty('headerName', 'X-XSRF-TOKEN');\n                if ($token != $request->getHeader($headerName)[0]) {\n                    return $this->responder->error(ErrorCode::BAD_OR_MISSING_XSRF_TOKEN, '');\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiBuilder.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiDefinition;\n\n    class OpenApiBuilder\n    {\n        private $openapi;\n        private $records;\n        private $columns;\n        private $status;\n        private $builders;\n\n        public function __construct(ReflectionService $reflection, array $base, array $controllers, array $builders)\n        {\n            $this->openapi = new OpenApiDefinition($base);\n            $this->records = in_array('records', $controllers) ? new OpenApiRecordsBuilder($this->openapi, $reflection) : null;\n            $this->columns = in_array('columns', $controllers) ? new OpenApiColumnsBuilder($this->openapi) : null;\n            $this->status = in_array('status', $controllers) ? new OpenApiStatusBuilder($this->openapi) : null;\n            $this->builders = array();\n            foreach ($builders as $className) {\n                $this->builders[] = new $className($this->openapi, $reflection);\n            }\n        }\n\n        private function getServerUrl(ServerRequestInterface $request): string\n        {\n            $uri = $request->getUri();\n            $path = $uri->getPath();\n            $uri = $uri->withPath(trim(substr($path, 0, strpos($path, '/openapi')), '/'));\n            return $uri->__toString();\n        }\n\n        public function build(ServerRequestInterface $request): OpenApiDefinition\n        {\n            $this->openapi->set(\"openapi\", \"3.0.0\");\n            if (!$this->openapi->has(\"servers\")) {\n                $this->openapi->set(\"servers||url\", $this->getServerUrl($request));\n            }\n            if ($this->records) {\n                $this->records->build();\n            }\n            if ($this->columns) {\n                $this->columns->build();\n            }\n            if ($this->status) {\n                $this->status->build();\n            }\n            foreach ($this->builders as $builder) {\n                $builder->build();\n            }\n            return $this->openapi;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiColumnsBuilder.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiDefinition;\n\n    class OpenApiColumnsBuilder\n    {\n        private $openapi;\n        private $operations = [\n            'database' => [\n                'read' => 'get',\n            ],\n            'table' => [\n                'create' => 'post',\n                'read' => 'get',\n                'update' => 'put', //rename\n                'delete' => 'delete',\n            ],\n            'column' => [\n                'create' => 'post',\n                'read' => 'get',\n                'update' => 'put',\n                'delete' => 'delete',\n            ],\n        ];\n\n        public function __construct(OpenApiDefinition $openapi)\n        {\n            $this->openapi = $openapi;\n        }\n\n        public function build() /*: void*/\n        {\n            $this->setPaths();\n            $this->openapi->set(\"components|responses|bool-success|description\", \"boolean indicating success or failure\");\n            $this->openapi->set(\"components|responses|bool-success|content|application/json|schema|type\", \"boolean\");\n            $this->setComponentSchema();\n            $this->setComponentResponse();\n            $this->setComponentRequestBody();\n            $this->setComponentParameters();\n            foreach (array_keys($this->operations) as $type) {\n                $this->setTag($type);\n            }\n        }\n\n        private function setPaths() /*: void*/\n        {\n            foreach (array_keys($this->operations) as $type) {\n                foreach ($this->operations[$type] as $operation => $method) {\n                    $parameters = [];\n                    switch ($type) {\n                        case 'database':\n                            $path = '/columns';\n                            break;\n                        case 'table':\n                            $path = $operation == 'create' ? '/columns' : '/columns/{table}';\n                            break;\n                        case 'column':\n                            $path = $operation == 'create' ? '/columns/{table}' : '/columns/{table}/{column}';\n                            break;\n                    }\n                    if (strpos($path, '{table}')) {\n                        $parameters[] = 'table';\n                    }\n                    if (strpos($path, '{column}')) {\n                        $parameters[] = 'column';\n                    }\n                    foreach ($parameters as $parameter) {\n                        $this->openapi->set(\"paths|$path|$method|parameters||\\$ref\", \"#/components/parameters/$parameter\");\n                    }\n                    if (in_array($operation, ['create', 'update'])) {\n                        $this->openapi->set(\"paths|$path|$method|requestBody|\\$ref\", \"#/components/requestBodies/$operation-$type\");\n                    }\n                    $this->openapi->set(\"paths|$path|$method|tags|\", \"$type\");\n                    $this->openapi->set(\"paths|$path|$method|operationId\", \"$operation\" . \"_\" . \"$type\");\n                    if (\"$operation-$type\" == 'update-table') {\n                        $this->openapi->set(\"paths|$path|$method|description\", \"rename table\");\n                    } else {\n                        $this->openapi->set(\"paths|$path|$method|description\", \"$operation $type\");\n                    }\n                    switch ($operation) {\n                        case 'read':\n                            $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/$operation-$type\");\n                            break;\n                        case 'create':\n                        case 'update':\n                        case 'delete':\n                            $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/bool-success\");\n                            break;\n                    }\n                }\n            }\n        }\n\n        private function setComponentSchema() /*: void*/\n        {\n            foreach (array_keys($this->operations) as $type) {\n                foreach (array_keys($this->operations[$type]) as $operation) {\n                    if ($operation == 'delete') {\n                        continue;\n                    }\n                    $prefix = \"components|schemas|$operation-$type\";\n                    $this->openapi->set(\"$prefix|type\", \"object\");\n                    switch ($type) {\n                        case 'database':\n                            $this->openapi->set(\"$prefix|properties|tables|type\", 'array');\n                            $this->openapi->set(\"$prefix|properties|tables|items|\\$ref\", \"#/components/schemas/read-table\");\n                            break;\n                        case 'table':\n                            if ($operation == 'update') {\n                                $this->openapi->set(\"$prefix|required\", ['name']);\n                                $this->openapi->set(\"$prefix|properties|name|type\", 'string');\n                            } else {\n                                $this->openapi->set(\"$prefix|properties|name|type\", 'string');\n                                if ($operation == 'read') {\n                                    $this->openapi->set(\"$prefix|properties|type|type\", 'string');\n                                }\n                                $this->openapi->set(\"$prefix|properties|columns|type\", 'array');\n                                $this->openapi->set(\"$prefix|properties|columns|items|\\$ref\", \"#/components/schemas/read-column\");\n                            }\n                            break;\n                        case 'column':\n                            $this->openapi->set(\"$prefix|required\", ['name', 'type']);\n                            $this->openapi->set(\"$prefix|properties|name|type\", 'string');\n                            $this->openapi->set(\"$prefix|properties|type|type\", 'string');\n                            $this->openapi->set(\"$prefix|properties|length|type\", 'integer');\n                            $this->openapi->set(\"$prefix|properties|length|format\", \"int64\");\n                            $this->openapi->set(\"$prefix|properties|precision|type\", 'integer');\n                            $this->openapi->set(\"$prefix|properties|precision|format\", \"int64\");\n                            $this->openapi->set(\"$prefix|properties|scale|type\", 'integer');\n                            $this->openapi->set(\"$prefix|properties|scale|format\", \"int64\");\n                            $this->openapi->set(\"$prefix|properties|nullable|type\", 'boolean');\n                            $this->openapi->set(\"$prefix|properties|pk|type\", 'boolean');\n                            $this->openapi->set(\"$prefix|properties|fk|type\", 'string');\n                            break;\n                    }\n                }\n            }\n        }\n\n        private function setComponentResponse() /*: void*/\n        {\n            foreach (array_keys($this->operations) as $type) {\n                foreach (array_keys($this->operations[$type]) as $operation) {\n                    if ($operation != 'read') {\n                        continue;\n                    }\n                    $this->openapi->set(\"components|responses|$operation-$type|description\", \"single $type record\");\n                    $this->openapi->set(\"components|responses|$operation-$type|content|application/json|schema|\\$ref\", \"#/components/schemas/$operation-$type\");\n                }\n            }\n        }\n\n        private function setComponentRequestBody() /*: void*/\n        {\n            foreach (array_keys($this->operations) as $type) {\n                foreach (array_keys($this->operations[$type]) as $operation) {\n                    if (!in_array($operation, ['create', 'update'])) {\n                        continue;\n                    }\n                    $this->openapi->set(\"components|requestBodies|$operation-$type|description\", \"single $type record\");\n                    $this->openapi->set(\"components|requestBodies|$operation-$type|content|application/json|schema|\\$ref\", \"#/components/schemas/$operation-$type\");\n                }\n            }\n        }\n\n        private function setComponentParameters() /*: void*/\n        {\n            $this->openapi->set(\"components|parameters|table|name\", \"table\");\n            $this->openapi->set(\"components|parameters|table|in\", \"path\");\n            $this->openapi->set(\"components|parameters|table|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|table|description\", \"table name\");\n            $this->openapi->set(\"components|parameters|table|required\", true);\n\n            $this->openapi->set(\"components|parameters|column|name\", \"column\");\n            $this->openapi->set(\"components|parameters|column|in\", \"path\");\n            $this->openapi->set(\"components|parameters|column|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|column|description\", \"column name\");\n            $this->openapi->set(\"components|parameters|column|required\", true);\n        }\n\n        private function setTag(string $type) /*: void*/\n        {\n            $this->openapi->set(\"tags|\", ['name' => $type, 'description' => \"$type operations\"]);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiDefinition.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    class OpenApiDefinition implements \\JsonSerializable\n    {\n        private $root;\n\n        public function __construct(array $base)\n        {\n            $this->root = $base;\n        }\n\n        public function set(string $path, $value) /*: void*/\n        {\n            $parts = explode('|', $path);\n            $current = &$this->root;\n            while (count($parts) > 0) {\n                $part = array_shift($parts);\n                if ($part === '') {\n                    $part = count($current);\n                } \n                if (!isset($current[$part])) {\n                    $current[$part] = [];\n                }\n                $current = &$current[$part];\n            }\n            $current = $value;\n        }\n\n        public function has(string $path): bool\n        {\n            $parts = explode('|', trim($path, '|'));\n            $current = &$this->root;\n            while (count($parts) > 0) {\n                $part = array_shift($parts);\n                if (!isset($current[$part])) {\n                    return false;\n                }\n                $current = &$current[$part];\n            }\n            return true;\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->root;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiRecordsBuilder.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiDefinition;\n\n    class OpenApiRecordsBuilder\n    {\n        private $openapi;\n        private $reflection;\n        private $operations = [\n            'list' => 'get',\n            'create' => 'post',\n            'read' => 'get',\n            'update' => 'put',\n            'delete' => 'delete',\n            'increment' => 'patch',\n        ];\n        private $types = [\n            'integer' => ['type' => 'integer', 'format' => 'int32'],\n            'bigint' => ['type' => 'integer', 'format' => 'int64'],\n            'varchar' => ['type' => 'string'],\n            'clob' => ['type' => 'string', 'format' => 'large-string'], //custom format\n            'varbinary' => ['type' => 'string', 'format' => 'byte'],\n            'blob' => ['type' => 'string', 'format' => 'large-byte'], //custom format\n            'decimal' => ['type' => 'string', 'format' => 'decimal'], //custom format\n            'float' => ['type' => 'number', 'format' => 'float'],\n            'double' => ['type' => 'number', 'format' => 'double'],\n            'date' => ['type' => 'string', 'format' => 'date'],\n            'time' => ['type' => 'string', 'format' => 'time'], //custom format\n            'timestamp' => ['type' => 'string', 'format' => 'date-time'],\n            'geometry' => ['type' => 'string', 'format' => 'geometry'], //custom format\n            'boolean' => ['type' => 'boolean'],\n        ];\n\n        private function normalize(string $value): string\n        {\n            return iconv('UTF-8', 'ASCII//TRANSLIT', $value);\n        }\n\n        public function __construct(OpenApiDefinition $openapi, ReflectionService $reflection)\n        {\n            $this->openapi = $openapi;\n            $this->reflection = $reflection;\n        }\n\n        private function getAllTableReferences(): array\n        {\n            $tableReferences = array();\n            foreach ($this->reflection->getTableNames() as $tableName) {\n                $table = $this->reflection->getTable($tableName);\n                foreach ($table->getColumnNames() as $columnName) {\n                    $column = $table->getColumn($columnName);\n                    $referencedTableName = $column->getFk();\n                    if ($referencedTableName) {\n                        if (!isset($tableReferences[$referencedTableName])) {\n                            $tableReferences[$referencedTableName] = array();\n                        }\n                        $tableReferences[$referencedTableName][] = \"$tableName.$columnName\";\n                    }\n                }\n            }\n            return $tableReferences;\n        }\n\n        public function build() /*: void*/\n        {\n            $tableNames = $this->reflection->getTableNames();\n            foreach ($tableNames as $tableName) {\n                $this->setPath($tableName);\n            }\n            $this->openapi->set(\"components|responses|pk_integer|description\", \"inserted primary key value (integer)\");\n            $this->openapi->set(\"components|responses|pk_integer|content|application/json|schema|type\", \"integer\");\n            $this->openapi->set(\"components|responses|pk_integer|content|application/json|schema|format\", \"int64\");\n            $this->openapi->set(\"components|responses|pk_string|description\", \"inserted primary key value (string)\");\n            $this->openapi->set(\"components|responses|pk_string|content|application/json|schema|type\", \"string\");\n            $this->openapi->set(\"components|responses|pk_string|content|application/json|schema|format\", \"uuid\");\n            $this->openapi->set(\"components|responses|rows_affected|description\", \"number of rows affected (integer)\");\n            $this->openapi->set(\"components|responses|rows_affected|content|application/json|schema|type\", \"integer\");\n            $this->openapi->set(\"components|responses|rows_affected|content|application/json|schema|format\", \"int64\");\n            $tableReferences = $this->getAllTableReferences();\n            foreach ($tableNames as $tableName) {\n                $references = isset($tableReferences[$tableName]) ? $tableReferences[$tableName] : array();\n                $this->setComponentSchema($tableName, $references);\n                $this->setComponentResponse($tableName);\n                $this->setComponentRequestBody($tableName);\n            }\n            $this->setComponentParameters();\n            foreach ($tableNames as $tableName) {\n                $this->setTag($tableName);\n            }\n        }\n\n        private function isOperationOnTableAllowed(string $operation, string $tableName): bool\n        {\n            $tableHandler = VariableStore::get('authorization.tableHandler');\n            if (!$tableHandler) {\n                return true;\n            }\n            return (bool) call_user_func($tableHandler, $operation, $tableName);\n        }\n\n        private function isOperationOnColumnAllowed(string $operation, string $tableName, string $columnName): bool\n        {\n            $columnHandler = VariableStore::get('authorization.columnHandler');\n            if (!$columnHandler) {\n                return true;\n            }\n            return (bool) call_user_func($columnHandler, $operation, $tableName, $columnName);\n        }\n\n        private function setPath(string $tableName) /*: void*/\n        {\n            $normalizedTableName = $this->normalize($tableName);\n            $table = $this->reflection->getTable($tableName);\n            $type = $table->getType();\n            $pk = $table->getPk();\n            $pkName = $pk ? $pk->getName() : '';\n            foreach ($this->operations as $operation => $method) {\n                if (!$pkName && $operation != 'list') {\n                    continue;\n                }\n                if ($type != 'table' && $operation != 'list') {\n                    continue;\n                }\n                if (!$this->isOperationOnTableAllowed($operation, $tableName)) {\n                    continue;\n                }\n                $parameters = [];\n                if (in_array($operation, ['list', 'create'])) {\n                    $path = sprintf('/records/%s', $tableName);\n                    if ($operation == 'list') {\n                        $parameters = ['filter', 'include', 'exclude', 'order', 'size', 'page', 'join'];\n                    }\n                } else {\n                    $path = sprintf('/records/%s/{id}', $tableName);\n                    if ($operation == 'read') {\n                        $parameters = ['pk', 'include', 'exclude', 'join'];\n                    } else {\n                        $parameters = ['pk'];\n                    }\n                }\n                foreach ($parameters as $parameter) {\n                    $this->openapi->set(\"paths|$path|$method|parameters||\\$ref\", \"#/components/parameters/$parameter\");\n                }\n                if (in_array($operation, ['create', 'update', 'increment'])) {\n                    $this->openapi->set(\"paths|$path|$method|requestBody|\\$ref\", \"#/components/requestBodies/$operation-$normalizedTableName\");\n                }\n                $this->openapi->set(\"paths|$path|$method|tags|\", \"$tableName\");\n                $this->openapi->set(\"paths|$path|$method|operationId\", \"$operation\" . \"_\" . \"$normalizedTableName\");\n                $this->openapi->set(\"paths|$path|$method|description\", \"$operation $tableName\");\n                switch ($operation) {\n                    case 'list':\n                        $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/$operation-$normalizedTableName\");\n                        break;\n                    case 'create':\n                        if ($pk->getType() == 'integer') {\n                            $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/pk_integer\");\n                        } else {\n                            $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/pk_string\");\n                        }\n                        break;\n                    case 'read':\n                        $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/$operation-$normalizedTableName\");\n                        break;\n                    case 'update':\n                    case 'delete':\n                    case 'increment':\n                        $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/rows_affected\");\n                        break;\n                }\n            }\n        }\n\n        private function getPattern(ReflectedColumn $column): string\n        {\n            switch ($column->getType()) {\n                case 'integer':\n                    $n = strlen(pow(2, 31));\n                    return '^-?[0-9]{1,' . $n . '}$';\n                case 'bigint':\n                    $n = strlen(pow(2, 63));\n                    return '^-?[0-9]{1,' . $n . '}$';\n                case 'varchar':\n                    $l = $column->getLength();\n                    return '^.{0,' . $l . '}$';\n                case 'clob':\n                    return '^.*$';\n                case 'varbinary':\n                    $l = $column->getLength();\n                    $b = (int) 4 * ceil($l / 3);\n                    return '^[A-Za-z0-9+/]{0,' . $b . '}=*$';\n                case 'blob':\n                    return '^[A-Za-z0-9+/]*=*$';\n                case 'decimal':\n                    $p = $column->getPrecision();\n                    $s = $column->getScale();\n                    return '^-?[0-9]{1,' . ($p - $s) . '}(\\.[0-9]{1,' . $s . '})?$';\n                case 'float':\n                    return '^-?[0-9]+(\\.[0-9]+)?([eE]-?[0-9]+)?$';\n                case 'double':\n                    return '^-?[0-9]+(\\.[0-9]+)?([eE]-?[0-9]+)?$';\n                case 'date':\n                    return '^[0-9]{4}-[0-9]{2}-[0-9]{2}$';\n                case 'time':\n                    return '^[0-9]{2}:[0-9]{2}:[0-9]{2}$';\n                case 'timestamp':\n                    return '^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$';\n                    return '';\n                case 'geometry':\n                    return '^(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON)\\s*\\(.*$';\n                case 'boolean':\n                    return '^(true|false)$';\n            }\n            return '';\n        }\n\n        private function setComponentSchema(string $tableName, array $references) /*: void*/\n        {\n            $normalizedTableName = $this->normalize($tableName);\n            $table = $this->reflection->getTable($tableName);\n            $type = $table->getType();\n            $pk = $table->getPk();\n            $pkName = $pk ? $pk->getName() : '';\n            foreach ($this->operations as $operation => $method) {\n                if (!$pkName && $operation != 'list') {\n                    continue;\n                }\n                if ($type == 'view' && !in_array($operation, array('read', 'list'))) {\n                    continue;\n                }\n                if ($type == 'view' && !$pkName && $operation == 'read') {\n                    continue;\n                }\n                if ($operation == 'delete') {\n                    continue;\n                }\n                if (!$this->isOperationOnTableAllowed($operation, $tableName)) {\n                    continue;\n                }\n                if ($operation == 'list') {\n                    $this->openapi->set(\"components|schemas|$operation-$normalizedTableName|type\", \"object\");\n                    $this->openapi->set(\"components|schemas|$operation-$normalizedTableName|properties|results|type\", \"integer\");\n                    $this->openapi->set(\"components|schemas|$operation-$normalizedTableName|properties|results|format\", \"int64\");\n                    $this->openapi->set(\"components|schemas|$operation-$normalizedTableName|properties|records|type\", \"array\");\n                    $prefix = \"components|schemas|$operation-$normalizedTableName|properties|records|items\";\n                } else {\n                    $prefix = \"components|schemas|$operation-$normalizedTableName\";\n                }\n                $this->openapi->set(\"$prefix|type\", \"object\");\n                foreach ($table->getColumnNames() as $columnName) {\n                    if (!$this->isOperationOnColumnAllowed($operation, $tableName, $columnName)) {\n                        continue;\n                    }\n                    $column = $table->getColumn($columnName);\n                    $properties = $this->types[$column->getType()];\n                    $properties['maxLength'] = $column->hasLength() ? $column->getLength() : 0;\n                    $properties['nullable'] = $column->getNullable();\n                    $properties['pattern'] = $this->getPattern($column);\n                    foreach ($properties as $key => $value) {\n                        if ($value) {\n                            $this->openapi->set(\"$prefix|properties|$columnName|$key\", $value);\n                        }\n                    }\n                    if ($column->getPk()) {\n                        $this->openapi->set(\"$prefix|properties|$columnName|x-primary-key\", true);\n                        $this->openapi->set(\"$prefix|properties|$columnName|x-referenced\", $references);\n                    }\n                    $fk = $column->getFk();\n                    if ($fk) {\n                        $this->openapi->set(\"$prefix|properties|$columnName|x-references\", $fk);\n                    }\n                }\n            }\n        }\n\n        private function setComponentResponse(string $tableName) /*: void*/\n        {\n            $normalizedTableName = $this->normalize($tableName);\n            $table = $this->reflection->getTable($tableName);\n            $type = $table->getType();\n            $pk = $table->getPk();\n            $pkName = $pk ? $pk->getName() : '';\n            foreach (['list', 'read'] as $operation) {\n                if (!$pkName && $operation != 'list') {\n                    continue;\n                }\n                if ($type != 'table' && $operation != 'list') {\n                    continue;\n                }\n                if (!$this->isOperationOnTableAllowed($operation, $tableName)) {\n                    continue;\n                }\n                if ($operation == 'list') {\n                    $this->openapi->set(\"components|responses|$operation-$normalizedTableName|description\", \"list of $tableName records\");\n                } else {\n                    $this->openapi->set(\"components|responses|$operation-$normalizedTableName|description\", \"single $tableName record\");\n                }\n                $this->openapi->set(\"components|responses|$operation-$normalizedTableName|content|application/json|schema|\\$ref\", \"#/components/schemas/$operation-$normalizedTableName\");\n            }\n        }\n\n        private function setComponentRequestBody(string $tableName) /*: void*/\n        {\n            $normalizedTableName = $this->normalize($tableName);\n            $table = $this->reflection->getTable($tableName);\n            $type = $table->getType();\n            $pk = $table->getPk();\n            $pkName = $pk ? $pk->getName() : '';\n            if ($pkName && $type == 'table') {\n                foreach (['create', 'update', 'increment'] as $operation) {\n                    if (!$this->isOperationOnTableAllowed($operation, $tableName)) {\n                        continue;\n                    }\n                    $this->openapi->set(\"components|requestBodies|$operation-$normalizedTableName|description\", \"single $tableName record\");\n                    $this->openapi->set(\"components|requestBodies|$operation-$normalizedTableName|content|application/json|schema|\\$ref\", \"#/components/schemas/$operation-$normalizedTableName\");\n                }\n            }\n        }\n\n        private function setComponentParameters() /*: void*/\n        {\n            $this->openapi->set(\"components|parameters|pk|name\", \"id\");\n            $this->openapi->set(\"components|parameters|pk|in\", \"path\");\n            $this->openapi->set(\"components|parameters|pk|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|pk|description\", \"primary key value\");\n            $this->openapi->set(\"components|parameters|pk|required\", true);\n\n            $this->openapi->set(\"components|parameters|filter|name\", \"filter\");\n            $this->openapi->set(\"components|parameters|filter|in\", \"query\");\n            $this->openapi->set(\"components|parameters|filter|schema|type\", \"array\");\n            $this->openapi->set(\"components|parameters|filter|schema|items|type\", \"string\");\n            $this->openapi->set(\"components|parameters|filter|description\", \"Filters to be applied. Each filter consists of a column, an operator and a value (comma separated). Example: id,eq,1\");\n            $this->openapi->set(\"components|parameters|filter|required\", false);\n\n            $this->openapi->set(\"components|parameters|include|name\", \"include\");\n            $this->openapi->set(\"components|parameters|include|in\", \"query\");\n            $this->openapi->set(\"components|parameters|include|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|include|description\", \"Columns you want to include in the output (comma separated). Example: posts.*,categories.name\");\n            $this->openapi->set(\"components|parameters|include|required\", false);\n\n            $this->openapi->set(\"components|parameters|exclude|name\", \"exclude\");\n            $this->openapi->set(\"components|parameters|exclude|in\", \"query\");\n            $this->openapi->set(\"components|parameters|exclude|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|exclude|description\", \"Columns you want to exclude from the output (comma separated). Example: posts.content\");\n            $this->openapi->set(\"components|parameters|exclude|required\", false);\n\n            $this->openapi->set(\"components|parameters|order|name\", \"order\");\n            $this->openapi->set(\"components|parameters|order|in\", \"query\");\n            $this->openapi->set(\"components|parameters|order|schema|type\", \"array\");\n            $this->openapi->set(\"components|parameters|order|schema|items|type\", \"string\");\n            $this->openapi->set(\"components|parameters|order|description\", \"Column you want to sort on and the sort direction (comma separated). Example: id,desc\");\n            $this->openapi->set(\"components|parameters|order|required\", false);\n\n            $this->openapi->set(\"components|parameters|size|name\", \"size\");\n            $this->openapi->set(\"components|parameters|size|in\", \"query\");\n            $this->openapi->set(\"components|parameters|size|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|size|description\", \"Maximum number of results (for top lists). Example: 10\");\n            $this->openapi->set(\"components|parameters|size|required\", false);\n\n            $this->openapi->set(\"components|parameters|page|name\", \"page\");\n            $this->openapi->set(\"components|parameters|page|in\", \"query\");\n            $this->openapi->set(\"components|parameters|page|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|page|description\", \"Page number and page size (comma separated). Example: 1,10\");\n            $this->openapi->set(\"components|parameters|page|required\", false);\n\n            $this->openapi->set(\"components|parameters|join|name\", \"join\");\n            $this->openapi->set(\"components|parameters|join|in\", \"query\");\n            $this->openapi->set(\"components|parameters|join|schema|type\", \"array\");\n            $this->openapi->set(\"components|parameters|join|schema|items|type\", \"string\");\n            $this->openapi->set(\"components|parameters|join|description\", \"Paths (comma separated) to related entities that you want to include. Example: comments,users\");\n            $this->openapi->set(\"components|parameters|join|required\", false);\n        }\n\n        private function setTag(string $tableName) /*: void*/\n        {\n            $this->openapi->set(\"tags|\", ['name' => $tableName, 'description' => \"$tableName operations\"]);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiService.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiBuilder;\n    use Tqdev\\PhpCrudApi\\RequestFactory;\n\n    class OpenApiService\n    {\n        private $builder;\n\n        public function __construct(ReflectionService $reflection, array $base, array $controllers, array $customBuilders)\n        {\n            $this->builder = new OpenApiBuilder($reflection, $base, $controllers, $customBuilders);\n        }\n\n        public function get(ServerRequestInterface $request): OpenApiDefinition\n        {\n            return $this->builder->build(RequestFactory::fromGlobals());\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiStatusBuilder.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiDefinition;\n\n    class OpenApiStatusBuilder\n    {\n        private $openapi;\n        private $operations = [\n            'status' => [\n                'ping' => 'get',\n            ],\n        ];\n\n        public function __construct(OpenApiDefinition $openapi)\n        {\n            $this->openapi = $openapi;\n        }\n\n        public function build() /*: void*/\n        {\n            $this->setPaths();\n            $this->setComponentSchema();\n            $this->setComponentResponse();\n            foreach (array_keys($this->operations) as $type) {\n                $this->setTag($type);\n            }\n        }\n\n        private function setPaths() /*: void*/\n        {\n            foreach ($this->operations as $type => $operationPair) {\n                foreach ($operationPair as $operation => $method) {\n                    $path = \"/$type/$operation\";\n                    $this->openapi->set(\"paths|$path|$method|tags|\", \"$type\");\n                    $this->openapi->set(\"paths|$path|$method|operationId\", \"$operation\" . \"_\" . \"$type\");\n                    $this->openapi->set(\"paths|$path|$method|description\", \"Request API '$operation' status\");\n                    $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/$operation-$type\");\n\n                }\n            }\n        }\n\n        private function setComponentSchema() /*: void*/\n        {\n            foreach ($this->operations as $type => $operationPair) {\n                foreach ($operationPair as $operation => $method) {\n                    $prefix = \"components|schemas|$operation-$type\";\n                    $this->openapi->set(\"$prefix|type\", \"object\");\n                    switch ($operation) {\n                        case 'ping':\n                            $this->openapi->set(\"$prefix|required\", ['db', 'cache']);\n                            $this->openapi->set(\"$prefix|properties|db|type\", 'integer');\n                            $this->openapi->set(\"$prefix|properties|db|format\", \"int64\");\n                            $this->openapi->set(\"$prefix|properties|cache|type\", 'integer');\n                            $this->openapi->set(\"$prefix|properties|cache|format\", \"int64\");\n                            break;\n                    }\n                }\n            }\n        }\n\n        private function setComponentResponse() /*: void*/\n        {\n            foreach ($this->operations as $type => $operationPair) {\n                foreach ($operationPair as $operation => $method) {\n                    $this->openapi->set(\"components|responses|$operation-$type|description\", \"$operation status record\");\n                    $this->openapi->set(\"components|responses|$operation-$type|content|application/json|schema|\\$ref\", \"#/components/schemas/$operation-$type\");\n                }\n            }\n        }\n\n        private function setTag(string $type) /*: void*/\n        {\n            $this->openapi->set(\"tags|\", [ 'name' => $type, 'description' => \"$type operations\"]);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/AndCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    class AndCondition extends Condition\n    {\n        private $conditions;\n\n        public function __construct(Condition $condition1, Condition $condition2)\n        {\n            $this->conditions = [$condition1, $condition2];\n        }\n\n        public function _and(Condition $condition): Condition\n        {\n            if ($condition instanceof NoCondition) {\n                return $this;\n            }\n            $this->conditions[] = $condition;\n            return $this;\n        }\n\n        public function getConditions(): array\n        {\n            return $this->conditions;\n        }\n\n        public static function fromArray(array $conditions): Condition\n        {\n            $condition = new NoCondition();\n            foreach ($conditions as $c) {\n                $condition = $condition->_and($c);\n            }\n            return $condition;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/ColumnCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n\n    class ColumnCondition extends Condition\n    {\n        private $column;\n        private $operator;\n        private $value;\n\n        public function __construct(ReflectedColumn $column, string $operator, string $value)\n        {\n            $this->column = $column;\n            $this->operator = $operator;\n            $this->value = $value;\n        }\n\n        public function getColumn(): ReflectedColumn\n        {\n            return $this->column;\n        }\n\n        public function getOperator(): string\n        {\n            return $this->operator;\n        }\n\n        public function getValue(): string\n        {\n            return $this->value;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/Condition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n\n    abstract class Condition\n    {\n        public function _and(Condition $condition): Condition\n        {\n            if ($condition instanceof NoCondition) {\n                return $this;\n            }\n            return new AndCondition($this, $condition);\n        }\n\n        public function _or(Condition $condition): Condition\n        {\n            if ($condition instanceof NoCondition) {\n                return $this;\n            }\n            return new OrCondition($this, $condition);\n        }\n\n        public function _not(): Condition\n        {\n            return new NotCondition($this);\n        }\n\n        public static function fromString(ReflectedTable $table, string $value): Condition\n        {\n            $condition = new NoCondition();\n            $parts = explode(',', $value, 3);\n            if (count($parts) < 2) {\n                return $condition;\n            }\n            if (count($parts) < 3) {\n                $parts[2] = '';\n            }\n            $field = $table->getColumn($parts[0]);\n            $command = $parts[1];\n            $negate = false;\n            $spatial = false;\n            if (strlen($command) > 2) {\n                if (substr($command, 0, 1) == 'n') {\n                    $negate = true;\n                    $command = substr($command, 1);\n                } else if (substr($command, 0, 1) == 's') {\n                    $spatial = true;\n                    $command = substr($command, 1);\n                }\n            }\n            if ($spatial) {\n                if (in_array($command, ['co', 'cr', 'di', 'eq', 'in', 'ov', 'to', 'wi', 'ic', 'is', 'iv'])) {\n                    $condition = new SpatialCondition($field, $command, $parts[2]);\n                }\n            } else {\n                if (in_array($command, ['cs', 'sw', 'ew', 'eq', 'lt', 'le', 'ge', 'gt', 'bt', 'in', 'is'])) {\n                    $condition = new ColumnCondition($field, $command, $parts[2]);\n                }\n            }\n            if ($negate) {\n                $condition = $condition->_not();\n            }\n            return $condition;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/NoCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    class NoCondition extends Condition\n    {\n        public function _and(Condition $condition): Condition\n        {\n            return $condition;\n        }\n\n        public function _or(Condition $condition): Condition\n        {\n            return $condition;\n        }\n\n        public function _not(): Condition\n        {\n            return $this;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/NotCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    class NotCondition extends Condition\n    {\n        private $condition;\n\n        public function __construct(Condition $condition)\n        {\n            $this->condition = $condition;\n        }\n\n        public function getCondition(): Condition\n        {\n            return $this->condition;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/OrCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    class OrCondition extends Condition\n    {\n        private $conditions;\n\n        public function __construct(Condition $condition1, Condition $condition2)\n        {\n            $this->conditions = [$condition1, $condition2];\n        }\n\n        public function _or(Condition $condition): Condition\n        {\n            if ($condition instanceof NoCondition) {\n                return $this;\n            }\n            $this->conditions[] = $condition;\n            return $this;\n        }\n\n        public function getConditions(): array\n        {\n            return $this->conditions;\n        }\n\n        public static function fromArray(array $conditions): Condition\n        {\n            $condition = new NoCondition();\n            foreach ($conditions as $c) {\n                $condition = $condition->_or($c);\n            }\n            return $condition;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/SpatialCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    class SpatialCondition extends ColumnCondition\n    {\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Document/ErrorDocument.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Document {\n\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n\n    class ErrorDocument implements \\JsonSerializable\n    {\n        public $errorCode;\n        public $argument;\n        public $details;\n\n        public function __construct(ErrorCode $errorCode, string $argument, $details)\n        {\n            $this->errorCode = $errorCode;\n            $this->argument = $argument;\n            $this->details = $details;\n        }\n\n        public function getStatus(): int\n        {\n            return $this->errorCode->getStatus();\n        }\n\n        public function getCode(): int\n        {\n            return $this->errorCode->getCode();\n        }\n\n        public function getMessage(): string\n        {\n            return $this->errorCode->getMessage($this->argument);\n        }\n\n        public function serialize()\n        {\n            return [\n                'code' => $this->getCode(),\n                'message' => $this->getMessage(),\n                'details' => $this->details,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return array_filter($this->serialize(), function ($v) {return $v !== null;});\n        }\n\n        public static function fromException(\\Throwable $exception, bool $debug)\n        {\n            $document = new ErrorDocument(new ErrorCode(ErrorCode::ERROR_NOT_FOUND), $exception->getMessage(), null);\n            if ($exception instanceof \\PDOException) {\n                if (strpos(strtolower($exception->getMessage()), 'duplicate') !== false) {\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::DUPLICATE_KEY_EXCEPTION), '', null);\n                } elseif (strpos(strtolower($exception->getMessage()), 'unique constraint') !== false) {\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::DUPLICATE_KEY_EXCEPTION), '', null);\n                } elseif (strpos(strtolower($exception->getMessage()), 'default value') !== false) {\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::DATA_INTEGRITY_VIOLATION), '', null);\n                } elseif (strpos(strtolower($exception->getMessage()), 'allow nulls') !== false) {\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::DATA_INTEGRITY_VIOLATION), '', null);\n                } elseif (strpos(strtolower($exception->getMessage()), 'constraint') !== false) {\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::DATA_INTEGRITY_VIOLATION), '', null);\n                } else {\n                    $message = $debug ? $exception->getMessage() : 'PDOException occurred (enable debug mode)';\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::ERROR_NOT_FOUND), $message, null);\n                }\n            }\n            return $document;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Document/ListDocument.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Document {\n\n    class ListDocument implements \\JsonSerializable\n    {\n        private $records;\n\n        private $results;\n\n        public function __construct(array $records, int $results)\n        {\n            $this->records = $records;\n            $this->results = $results;\n        }\n\n        public function getRecords(): array\n        {\n            return $this->records;\n        }\n\n        public function getResults(): int\n        {\n            return $this->results;\n        }\n\n        public function serialize()\n        {\n            return [\n                'records' => $this->records,\n                'results' => $this->results,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return array_filter($this->serialize(), function ($v) {\n                return $v !== -1;\n            });\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/ColumnIncluder.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n\n    class ColumnIncluder\n    {\n        private function isMandatory(string $tableName, string $columnName, array $params): bool\n        {\n            return isset($params['mandatory']) && in_array($tableName . \".\" . $columnName, $params['mandatory']);\n        }\n\n        private function select(\n            string $tableName,\n            bool $primaryTable,\n            array $params,\n            string $paramName,\n            array $columnNames,\n            bool $include\n        ): array {\n            if (!isset($params[$paramName])) {\n                return $columnNames;\n            }\n            $columns = array();\n            foreach (explode(',', $params[$paramName][0]) as $columnName) {\n                $columns[$columnName] = true;\n            }\n            $result = array();\n            foreach ($columnNames as $columnName) {\n                $match = isset($columns['*.*']);\n                if (!$match) {\n                    $match = isset($columns[$tableName . '.*']) || isset($columns[$tableName . '.' . $columnName]);\n                }\n                if ($primaryTable && !$match) {\n                    $match = isset($columns['*']) || isset($columns[$columnName]);\n                }\n                if ($match) {\n                    if ($include || $this->isMandatory($tableName, $columnName, $params)) {\n                        $result[] = $columnName;\n                    }\n                } else {\n                    if (!$include || $this->isMandatory($tableName, $columnName, $params)) {\n                        $result[] = $columnName;\n                    }\n                }\n            }\n            return $result;\n        }\n\n        public function getNames(ReflectedTable $table, bool $primaryTable, array $params): array\n        {\n            $tableName = $table->getName();\n            $results = $table->getColumnNames();\n            $results = $this->select($tableName, $primaryTable, $params, 'include', $results, true);\n            $results = $this->select($tableName, $primaryTable, $params, 'exclude', $results, false);\n            return $results;\n        }\n\n        public function getValues(ReflectedTable $table, bool $primaryTable, /* object */ $record, array $params): array\n        {\n            $results = array();\n            $columnNames = $this->getNames($table, $primaryTable, $params);\n            foreach ($columnNames as $columnName) {\n                if (property_exists($record, $columnName)) {\n                    $results[$columnName] = $record->$columnName;\n                }\n            }\n            return $results;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/ErrorCode.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n\n    class ErrorCode\n    {\n        private $code;\n        private $message;\n        private $status;\n\n        const ERROR_NOT_FOUND = 9999;\n        const ROUTE_NOT_FOUND = 1000;\n        const TABLE_NOT_FOUND = 1001;\n        const ARGUMENT_COUNT_MISMATCH = 1002;\n        const RECORD_NOT_FOUND = 1003;\n        const ORIGIN_FORBIDDEN = 1004;\n        const COLUMN_NOT_FOUND = 1005;\n        const TABLE_ALREADY_EXISTS = 1006;\n        const COLUMN_ALREADY_EXISTS = 1007;\n        const HTTP_MESSAGE_NOT_READABLE = 1008;\n        const DUPLICATE_KEY_EXCEPTION = 1009;\n        const DATA_INTEGRITY_VIOLATION = 1010;\n        const AUTHENTICATION_REQUIRED = 1011;\n        const AUTHENTICATION_FAILED = 1012;\n        const INPUT_VALIDATION_FAILED = 1013;\n        const OPERATION_FORBIDDEN = 1014;\n        const OPERATION_NOT_SUPPORTED = 1015;\n        const TEMPORARY_OR_PERMANENTLY_BLOCKED = 1016;\n        const BAD_OR_MISSING_XSRF_TOKEN = 1017;\n        const ONLY_AJAX_REQUESTS_ALLOWED = 1018;\n        const PAGINATION_FORBIDDEN = 1019;\n        const USER_ALREADY_EXIST = 1020;\n        const PASSWORD_TOO_SHORT = 1021;\n        const USERNAME_EMPTY = 1022;\n        const PRIMARY_KEY_NOT_FOUND = 1023;\n\n        private $values = [\n            0000 => [\"Success\", ResponseFactory::OK],\n            1000 => [\"Route '%s' not found\", ResponseFactory::NOT_FOUND],\n            1001 => [\"Table '%s' not found\", ResponseFactory::NOT_FOUND],\n            1002 => [\"Argument count mismatch in '%s'\", ResponseFactory::UNPROCESSABLE_ENTITY],\n            1003 => [\"Record '%s' not found\", ResponseFactory::NOT_FOUND],\n            1004 => [\"Origin '%s' is forbidden\", ResponseFactory::FORBIDDEN],\n            1005 => [\"Column '%s' not found\", ResponseFactory::NOT_FOUND],\n            1006 => [\"Table '%s' already exists\", ResponseFactory::CONFLICT],\n            1007 => [\"Column '%s' already exists\", ResponseFactory::CONFLICT],\n            1008 => [\"Cannot read HTTP message\", ResponseFactory::UNPROCESSABLE_ENTITY],\n            1009 => [\"Duplicate key exception\", ResponseFactory::CONFLICT],\n            1010 => [\"Data integrity violation\", ResponseFactory::CONFLICT],\n            1011 => [\"Authentication required\", ResponseFactory::UNAUTHORIZED],\n            1012 => [\"Authentication failed for '%s'\", ResponseFactory::FORBIDDEN],\n            1013 => [\"Input validation failed for '%s'\", ResponseFactory::UNPROCESSABLE_ENTITY],\n            1014 => [\"Operation forbidden\", ResponseFactory::FORBIDDEN],\n            1015 => [\"Operation '%s' not supported\", ResponseFactory::METHOD_NOT_ALLOWED],\n            1016 => [\"Temporary or permanently blocked\", ResponseFactory::FORBIDDEN],\n            1017 => [\"Bad or missing XSRF token\", ResponseFactory::FORBIDDEN],\n            1018 => [\"Only AJAX requests allowed for '%s'\", ResponseFactory::FORBIDDEN],\n            1019 => [\"Pagination forbidden\", ResponseFactory::FORBIDDEN],\n            1020 => [\"User '%s' already exists\", ResponseFactory::CONFLICT],\n            1021 => [\"Password too short (<%d characters)\", ResponseFactory::UNPROCESSABLE_ENTITY],\n            1022 => [\"Username is empty or only whitespaces\", ResponseFactory::UNPROCESSABLE_ENTITY],\n            1023 => [\"Primary key for table '%s' not found\", ResponseFactory::NOT_FOUND],\n            9999 => [\"%s\", ResponseFactory::INTERNAL_SERVER_ERROR],\n        ];\n\n        public function __construct(int $code)\n        {\n            if (!isset($this->values[$code])) {\n                $code = 9999;\n            }\n            $this->code = $code;\n            $this->message = $this->values[$code][0];\n            $this->status = $this->values[$code][1];\n        }\n\n        public function getCode(): int\n        {\n            return $this->code;\n        }\n\n        public function getMessage(string $argument): string\n        {\n            return sprintf($this->message, $argument);\n        }\n\n        public function getStatus(): int\n        {\n            return $this->status;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/FilterInfo.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\AndCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\Condition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\NoCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\OrCondition;\n\n    class FilterInfo\n    {\n        private function getConditionsAsPathTree(ReflectedTable $table, array $params): PathTree\n        {\n            $conditions = new PathTree();\n            foreach ($params as $key => $filters) {\n                if (substr($key, 0, 6) == 'filter') {\n                    preg_match_all('/\\d+|\\D+/', substr($key, 6), $matches);\n                    $path = $matches[0];\n                    foreach ($filters as $filter) {\n                        $condition = Condition::fromString($table, $filter);\n                        if (($condition instanceof NoCondition) == false) {\n                            $conditions->put($path, $condition);\n                        }\n                    }\n                }\n            }\n            return $conditions;\n        }\n\n        private function combinePathTreeOfConditions(PathTree $tree): Condition\n        {\n            $andConditions = $tree->getValues();\n            $and = AndCondition::fromArray($andConditions);\n            $orConditions = [];\n            foreach ($tree->getKeys() as $p) {\n                $orConditions[] = $this->combinePathTreeOfConditions($tree->get($p));\n            }\n            $or = OrCondition::fromArray($orConditions);\n            return $and->_and($or);\n        }\n\n        public function getCombinedConditions(ReflectedTable $table, array $params): Condition\n        {\n            return $this->combinePathTreeOfConditions($this->getConditionsAsPathTree($table, $params));\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/HabtmValues.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    class HabtmValues\n    {\n        public $pkValues;\n        public $fkValues;\n\n        public function __construct(array $pkValues, array $fkValues)\n        {\n            $this->pkValues = $pkValues;\n            $this->fkValues = $fkValues;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/OrderingInfo.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n\n    class OrderingInfo\n    {\n        public function getColumnOrdering(ReflectedTable $table, array $params): array\n        {\n            $fields = array();\n            if (isset($params['order'])) {\n                foreach ($params['order'] as $order) {\n                    $parts = explode(',', $order, 3);\n                    $columnName = $parts[0];\n                    if (!$table->hasColumn($columnName)) {\n                        continue;\n                    }\n                    $ascending = 'ASC';\n                    if (count($parts) > 1) {\n                        if (substr(strtoupper($parts[1]), 0, 4) == \"DESC\") {\n                            $ascending = 'DESC';\n                        }\n                    }\n                    $fields[] = [$columnName, $ascending];\n                }\n            }\n            if (count($fields) == 0) {\n                return $this->getDefaultColumnOrdering($table);\n            }\n            return $fields;\n        }\n\n        public function getDefaultColumnOrdering(ReflectedTable $table): array\n        {\n            $fields = array();\n            $pk = $table->getPk();\n            if ($pk) {\n                $fields[] = [$pk->getName(), 'ASC'];\n            } else {\n                foreach ($table->getColumnNames() as $columnName) {\n                    $fields[] = [$columnName, 'ASC'];\n                }\n            }\n            return $fields;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/PaginationInfo.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    class PaginationInfo\n    {\n        public $DEFAULT_PAGE_SIZE = 20;\n\n        public function hasPage(array $params): bool\n        {\n            return isset($params['page']);\n        }\n\n        public function getPageOffset(array $params): int\n        {\n            $offset = 0;\n            $pageSize = $this->getPageSize($params);\n            if (isset($params['page'])) {\n                foreach ($params['page'] as $page) {\n                    $parts = explode(',', $page, 2);\n                    $page = intval($parts[0]) - 1;\n                    $offset = $page * $pageSize;\n                }\n            }\n            return $offset;\n        }\n\n        private function getPageSize(array $params): int\n        {\n            $pageSize = $this->DEFAULT_PAGE_SIZE;\n            if (isset($params['page'])) {\n                foreach ($params['page'] as $page) {\n                    $parts = explode(',', $page, 2);\n                    if (count($parts) > 1) {\n                        $pageSize = intval($parts[1]);\n                    }\n                }\n            }\n            return $pageSize;\n        }\n\n        public function getResultSize(array $params): int\n        {\n            $numberOfRows = -1;\n            if (isset($params['size'])) {\n                foreach ($params['size'] as $size) {\n                    $numberOfRows = intval($size);\n                }\n            }\n            return $numberOfRows;\n        }\n\n        public function getPageLimit(array $params): int\n        {\n            $pageLimit = -1;\n            if ($this->hasPage($params)) {\n                $pageLimit = $this->getPageSize($params);\n            }\n            $resultSize = $this->getResultSize($params);\n            if ($resultSize >= 0) {\n                if ($pageLimit >= 0) {\n                    $pageLimit = min($pageLimit, $resultSize);\n                } else {\n                    $pageLimit = $resultSize;\n                }\n            }\n            return $pageLimit;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/PathTree.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    class PathTree implements \\JsonSerializable\n    {\n        const WILDCARD = '*';\n\n        private $tree;\n\n        public function __construct( /* object */&$tree = null)\n        {\n            if (!$tree) {\n                $tree = $this->newTree();\n            }\n            $this->tree = &$tree;\n        }\n\n        public function newTree()\n        {\n            return (object) ['values' => [], 'branches' => (object) []];\n        }\n\n        public function getKeys(): array\n        {\n            $branches = (array) $this->tree->branches;\n            return array_keys($branches);\n        }\n\n        public function getValues(): array\n        {\n            return $this->tree->values;\n        }\n\n        public function get(string $key): PathTree\n        {\n            if (!isset($this->tree->branches->$key)) {\n                return null;\n            }\n            return new PathTree($this->tree->branches->$key);\n        }\n\n        public function put(array $path, $value)\n        {\n            $tree = &$this->tree;\n            foreach ($path as $key) {\n                if (!isset($tree->branches->$key)) {\n                    $tree->branches->$key = $this->newTree();\n                }\n                $tree = &$tree->branches->$key;\n            }\n            $tree->values[] = $value;\n        }\n\n        public function match(array $path): array\n        {\n            $star = self::WILDCARD;\n            $tree = &$this->tree;\n            foreach ($path as $key) {\n                if (isset($tree->branches->$key)) {\n                    $tree = &$tree->branches->$key;\n                } elseif (isset($tree->branches->$star)) {\n                    $tree = &$tree->branches->$star;\n                } else {\n                    return [];\n                }\n            }\n            return $tree->values;\n        }\n\n        public static function fromJson( /* object */$tree): PathTree\n        {\n            return new PathTree($tree);\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->tree;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/RecordService.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Record\\Document\\ListDocument;\n\n    class RecordService\n    {\n        private $db;\n        private $reflection;\n        private $columns;\n        private $joiner;\n        private $filters;\n        private $ordering;\n        private $pagination;\n\n        public function __construct(GenericDB $db, ReflectionService $reflection)\n        {\n            $this->db = $db;\n            $this->reflection = $reflection;\n            $this->columns = new ColumnIncluder();\n            $this->joiner = new RelationJoiner($reflection, $this->columns);\n            $this->filters = new FilterInfo();\n            $this->ordering = new OrderingInfo();\n            $this->pagination = new PaginationInfo();\n        }\n\n        private function sanitizeRecord(string $tableName, /* object */ $record, string $id)\n        {\n            $keyset = array_keys((array) $record);\n            foreach ($keyset as $key) {\n                if (!$this->reflection->getTable($tableName)->hasColumn($key)) {\n                    unset($record->$key);\n                }\n            }\n            if ($id != '') {\n                $pk = $this->reflection->getTable($tableName)->getPk();\n                foreach ($this->reflection->getTable($tableName)->getColumnNames() as $key) {\n                    $field = $this->reflection->getTable($tableName)->getColumn($key);\n                    if ($field->getName() == $pk->getName()) {\n                        unset($record->$key);\n                    }\n                }\n            }\n        }\n\n        public function hasTable(string $table): bool\n        {\n            return $this->reflection->hasTable($table);\n        }\n\n        public function hasPrimaryKey(string $table): bool\n        {\n            return $this->reflection->getTable($table)->getPk()?true:false;\n        }\n\n        public function getType(string $table): string\n        {\n            return $this->reflection->getType($table);\n        }\n\n        public function beginTransaction() /*: void*/\n        {\n            $this->db->beginTransaction();\n        }\n\n        public function commitTransaction() /*: void*/\n        {\n            $this->db->commitTransaction();\n        }\n\n        public function rollBackTransaction() /*: void*/\n        {\n            $this->db->rollBackTransaction();\n        }\n\n        public function create(string $tableName, /* object */ $record, array $params) /*: ?int*/\n        {\n            $this->sanitizeRecord($tableName, $record, '');\n            $table = $this->reflection->getTable($tableName);\n            $columnValues = $this->columns->getValues($table, true, $record, $params);\n            return $this->db->createSingle($table, $columnValues);\n        }\n\n        public function read(string $tableName, string $id, array $params) /*: ?object*/\n        {\n            $table = $this->reflection->getTable($tableName);\n            $this->joiner->addMandatoryColumns($table, $params);\n            $columnNames = $this->columns->getNames($table, true, $params);\n            $record = $this->db->selectSingle($table, $columnNames, $id);\n            if ($record == null) {\n                return null;\n            }\n            $records = array($record);\n            $this->joiner->addJoins($table, $records, $params, $this->db);\n            return $records[0];\n        }\n\n        public function update(string $tableName, string $id, /* object */ $record, array $params) /*: ?int*/\n        {\n            $this->sanitizeRecord($tableName, $record, $id);\n            $table = $this->reflection->getTable($tableName);\n            $columnValues = $this->columns->getValues($table, true, $record, $params);\n            return $this->db->updateSingle($table, $columnValues, $id);\n        }\n\n        public function delete(string $tableName, string $id, array $params) /*: ?int*/\n        {\n            $table = $this->reflection->getTable($tableName);\n            return $this->db->deleteSingle($table, $id);\n        }\n\n        public function increment(string $tableName, string $id, /* object */ $record, array $params) /*: ?int*/\n        {\n            $this->sanitizeRecord($tableName, $record, $id);\n            $table = $this->reflection->getTable($tableName);\n            $columnValues = $this->columns->getValues($table, true, $record, $params);\n            return $this->db->incrementSingle($table, $columnValues, $id);\n        }\n\n        public function _list(string $tableName, array $params): ListDocument\n        {\n            $table = $this->reflection->getTable($tableName);\n            $this->joiner->addMandatoryColumns($table, $params);\n            $columnNames = $this->columns->getNames($table, true, $params);\n            $condition = $this->filters->getCombinedConditions($table, $params);\n            $columnOrdering = $this->ordering->getColumnOrdering($table, $params);\n            if (!$this->pagination->hasPage($params)) {\n                $offset = 0;\n                $limit = $this->pagination->getPageLimit($params);\n                $count = -1;\n            } else {\n                $offset = $this->pagination->getPageOffset($params);\n                $limit = $this->pagination->getPageLimit($params);\n                $count = $this->db->selectCount($table, $condition);\n            }\n            $records = $this->db->selectAll($table, $columnNames, $condition, $columnOrdering, $offset, $limit);\n            $this->joiner->addJoins($table, $records, $params, $this->db);\n            return new ListDocument($records, $count);\n        }\n\n        public function ping(): int\n        {\n            return $this->db->ping();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/RelationJoiner.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\OrCondition;\n\n    class RelationJoiner\n    {\n        private $reflection;\n        private $ordering;\n        private $columns;\n\n        public function __construct(ReflectionService $reflection, ColumnIncluder $columns)\n        {\n            $this->reflection = $reflection;\n            $this->ordering = new OrderingInfo();\n            $this->columns = $columns;\n        }\n\n        public function addMandatoryColumns(ReflectedTable $table, array &$params) /*: void*/\n        {\n            if (!isset($params['join']) || !isset($params['include'])) {\n                return;\n            }\n            $params['mandatory'] = array();\n            foreach ($params['join'] as $tableNames) {\n                $t1 = $table;\n                foreach (explode(',', $tableNames) as $tableName) {\n                    if (!$this->reflection->hasTable($tableName)) {\n                        continue;\n                    }\n                    $t2 = $this->reflection->getTable($tableName);\n                    $fks1 = $t1->getFksTo($t2->getName());\n                    $t3 = $this->hasAndBelongsToMany($t1, $t2);\n                    if ($t3 != null || count($fks1) > 0) {\n                        $params['mandatory'][] = $t2->getName() . '.' . $t2->getPk()->getName();\n                    }\n                    foreach ($fks1 as $fk) {\n                        $params['mandatory'][] = $t1->getName() . '.' . $fk->getName();\n                    }\n                    $fks2 = $t2->getFksTo($t1->getName());\n                    if ($t3 != null || count($fks2) > 0) {\n                        $params['mandatory'][] = $t1->getName() . '.' . $t1->getPk()->getName();\n                    }\n                    foreach ($fks2 as $fk) {\n                        $params['mandatory'][] = $t2->getName() . '.' . $fk->getName();\n                    }\n                    $t1 = $t2;\n                }\n            }\n        }\n\n        private function getJoinsAsPathTree(array $params): PathTree\n        {\n            $joins = new PathTree();\n            if (isset($params['join'])) {\n                foreach ($params['join'] as $tableNames) {\n                    $path = array();\n                    foreach (explode(',', $tableNames) as $tableName) {\n                        if (!$this->reflection->hasTable($tableName)) {\n                            continue;\n                        }\n                        $t = $this->reflection->getTable($tableName);\n                        if ($t != null) {\n                            $path[] = $t->getName();\n                        }\n                    }\n                    $joins->put($path, true);\n                }\n            }\n            return $joins;\n        }\n\n        public function addJoins(ReflectedTable $table, array &$records, array $params, GenericDB $db) /*: void*/\n        {\n            $joins = $this->getJoinsAsPathTree($params);\n            $this->addJoinsForTables($table, $joins, $records, $params, $db);\n        }\n\n        private function hasAndBelongsToMany(ReflectedTable $t1, ReflectedTable $t2) /*: ?ReflectedTable*/\n        {\n            foreach ($this->reflection->getTableNames() as $tableName) {\n                $t3 = $this->reflection->getTable($tableName);\n                if (count($t3->getFksTo($t1->getName())) > 0 && count($t3->getFksTo($t2->getName())) > 0) {\n                    return $t3;\n                }\n            }\n            return null;\n        }\n\n        private function addJoinsForTables(ReflectedTable $t1, PathTree $joins, array &$records, array $params, GenericDB $db)\n        {\n            foreach ($joins->getKeys() as $t2Name) {\n                $t2 = $this->reflection->getTable($t2Name);\n\n                $belongsTo = count($t1->getFksTo($t2->getName())) > 0;\n                $hasMany = count($t2->getFksTo($t1->getName())) > 0;\n                if (!$belongsTo && !$hasMany) {\n                    $t3 = $this->hasAndBelongsToMany($t1, $t2);\n                } else {\n                    $t3 = null;\n                }\n                $hasAndBelongsToMany = ($t3 != null);\n\n                $newRecords = array();\n                $fkValues = null;\n                $pkValues = null;\n                $habtmValues = null;\n\n                if ($belongsTo) {\n                    $fkValues = $this->getFkEmptyValues($t1, $t2, $records);\n                    $this->addFkRecords($t2, $fkValues, $params, $db, $newRecords);\n                }\n                if ($hasMany) {\n                    $pkValues = $this->getPkEmptyValues($t1, $records);\n                    $this->addPkRecords($t1, $t2, $pkValues, $params, $db, $newRecords);\n                }\n                if ($hasAndBelongsToMany) {\n                    $habtmValues = $this->getHabtmEmptyValues($t1, $t2, $t3, $db, $records);\n                    $this->addFkRecords($t2, $habtmValues->fkValues, $params, $db, $newRecords);\n                }\n\n                $this->addJoinsForTables($t2, $joins->get($t2Name), $newRecords, $params, $db);\n\n                if ($fkValues != null) {\n                    $this->fillFkValues($t2, $newRecords, $fkValues);\n                    $this->setFkValues($t1, $t2, $records, $fkValues);\n                }\n                if ($pkValues != null) {\n                    $this->fillPkValues($t1, $t2, $newRecords, $pkValues);\n                    $this->setPkValues($t1, $t2, $records, $pkValues);\n                }\n                if ($habtmValues != null) {\n                    $this->fillFkValues($t2, $newRecords, $habtmValues->fkValues);\n                    $this->setHabtmValues($t1, $t2, $records, $habtmValues);\n                }\n            }\n        }\n\n        private function getFkEmptyValues(ReflectedTable $t1, ReflectedTable $t2, array $records): array\n        {\n            $fkValues = array();\n            $fks = $t1->getFksTo($t2->getName());\n            foreach ($fks as $fk) {\n                $fkName = $fk->getName();\n                foreach ($records as $record) {\n                    if (isset($record[$fkName])) {\n                        $fkValue = $record[$fkName];\n                        $fkValues[$fkValue] = null;\n                    }\n                }\n            }\n            return $fkValues;\n        }\n\n        private function addFkRecords(ReflectedTable $t2, array $fkValues, array $params, GenericDB $db, array &$records) /*: void*/\n        {\n            $columnNames = $this->columns->getNames($t2, false, $params);\n            $fkIds = array_keys($fkValues);\n\n            foreach ($db->selectMultiple($t2, $columnNames, $fkIds) as $record) {\n                $records[] = $record;\n            }\n        }\n\n        private function fillFkValues(ReflectedTable $t2, array $fkRecords, array &$fkValues) /*: void*/\n        {\n            $pkName = $t2->getPk()->getName();\n            foreach ($fkRecords as $fkRecord) {\n                $pkValue = $fkRecord[$pkName];\n                $fkValues[$pkValue] = $fkRecord;\n            }\n        }\n\n        private function setFkValues(ReflectedTable $t1, ReflectedTable $t2, array &$records, array $fkValues) /*: void*/\n        {\n            $fks = $t1->getFksTo($t2->getName());\n            foreach ($fks as $fk) {\n                $fkName = $fk->getName();\n                foreach ($records as $i => $record) {\n                    if (isset($record[$fkName])) {\n                        $key = $record[$fkName];\n                        $records[$i][$fkName] = $fkValues[$key];\n                    }\n                }\n            }\n        }\n\n        private function getPkEmptyValues(ReflectedTable $t1, array $records): array\n        {\n            $pkValues = array();\n            $pkName = $t1->getPk()->getName();\n            foreach ($records as $record) {\n                $key = $record[$pkName];\n                $pkValues[$key] = array();\n            }\n            return $pkValues;\n        }\n\n        private function addPkRecords(ReflectedTable $t1, ReflectedTable $t2, array $pkValues, array $params, GenericDB $db, array &$records) /*: void*/\n        {\n            $fks = $t2->getFksTo($t1->getName());\n            $columnNames = $this->columns->getNames($t2, false, $params);\n            $pkValueKeys = implode(',', array_keys($pkValues));\n            $conditions = array();\n            foreach ($fks as $fk) {\n                $conditions[] = new ColumnCondition($fk, 'in', $pkValueKeys);\n            }\n            $condition = OrCondition::fromArray($conditions);\n            $columnOrdering = array();\n            $limit = VariableStore::get(\"joinLimits.maxRecords\") ?: -1;\n            if ($limit != -1) {\n                $columnOrdering = $this->ordering->getDefaultColumnOrdering($t2);\n            }\n            foreach ($db->selectAll($t2, $columnNames, $condition, $columnOrdering, 0, $limit) as $record) {\n                $records[] = $record;\n            }\n        }\n\n        private function fillPkValues(ReflectedTable $t1, ReflectedTable $t2, array $pkRecords, array &$pkValues) /*: void*/\n        {\n            $fks = $t2->getFksTo($t1->getName());\n            foreach ($fks as $fk) {\n                $fkName = $fk->getName();\n                foreach ($pkRecords as $pkRecord) {\n                    $key = $pkRecord[$fkName];\n                    if (isset($pkValues[$key])) {\n                        $pkValues[$key][] = $pkRecord;\n                    }\n                }\n            }\n        }\n\n        private function setPkValues(ReflectedTable $t1, ReflectedTable $t2, array &$records, array $pkValues) /*: void*/\n        {\n            $pkName = $t1->getPk()->getName();\n            $t2Name = $t2->getName();\n\n            foreach ($records as $i => $record) {\n                $key = $record[$pkName];\n                $records[$i][$t2Name] = $pkValues[$key];\n            }\n        }\n\n        private function getHabtmEmptyValues(ReflectedTable $t1, ReflectedTable $t2, ReflectedTable $t3, GenericDB $db, array $records): HabtmValues\n        {\n            $pkValues = $this->getPkEmptyValues($t1, $records);\n            $fkValues = array();\n\n            $fk1 = $t3->getFksTo($t1->getName())[0];\n            $fk2 = $t3->getFksTo($t2->getName())[0];\n\n            $fk1Name = $fk1->getName();\n            $fk2Name = $fk2->getName();\n\n            $columnNames = array($fk1Name, $fk2Name);\n\n            $pkIds = implode(',', array_keys($pkValues));\n            $condition = new ColumnCondition($t3->getColumn($fk1Name), 'in', $pkIds);\n            $columnOrdering = array();\n\n            $limit = VariableStore::get(\"joinLimits.maxRecords\") ?: -1;\n            if ($limit != -1) {\n                $columnOrdering = $this->ordering->getDefaultColumnOrdering($t3);\n            }\n            $records = $db->selectAll($t3, $columnNames, $condition, $columnOrdering, 0, $limit);\n            foreach ($records as $record) {\n                $val1 = $record[$fk1Name];\n                $val2 = $record[$fk2Name];\n                $pkValues[$val1][] = $val2;\n                $fkValues[$val2] = null;\n            }\n\n            return new HabtmValues($pkValues, $fkValues);\n        }\n\n        private function setHabtmValues(ReflectedTable $t1, ReflectedTable $t2, array &$records, HabtmValues $habtmValues) /*: void*/\n        {\n            $pkName = $t1->getPk()->getName();\n            $t2Name = $t2->getName();\n            foreach ($records as $i => $record) {\n                $key = $record[$pkName];\n                $val = array();\n                $fks = $habtmValues->pkValues[$key];\n                foreach ($fks as $fk) {\n                    $val[] = $habtmValues->fkValues[$fk];\n                }\n                $records[$i][$t2Name] = $val;\n            }\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Api.php\nnamespace Tqdev\\PhpCrudApi {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Cache\\CacheFactory;\n    use Tqdev\\PhpCrudApi\\Column\\DefinitionService;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\CacheController;\n    use Tqdev\\PhpCrudApi\\Controller\\ColumnController;\n    use Tqdev\\PhpCrudApi\\Controller\\GeoJsonController;\n    use Tqdev\\PhpCrudApi\\Controller\\JsonResponder;\n    use Tqdev\\PhpCrudApi\\Controller\\OpenApiController;\n    use Tqdev\\PhpCrudApi\\Controller\\RecordController;\n    use Tqdev\\PhpCrudApi\\Controller\\StatusController;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\GeoJson\\GeoJsonService;\n    use Tqdev\\PhpCrudApi\\Middleware\\ApiKeyAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\ApiKeyDbAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\AuthorizationMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\BasicAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\CorsMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\CustomizationMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\DbAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\FirewallMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\IpAddressMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\JoinLimitsMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\JsonMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\JwtAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\MultiTenancyMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\PageLimitsMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\ReconnectMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\SimpleRouter;\n    use Tqdev\\PhpCrudApi\\Middleware\\SanitationMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\SslRedirectMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\TextSearchMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\ValidationMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\WpAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\XmlMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\XsrfMiddleware;\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiService;\n    use Tqdev\\PhpCrudApi\\Record\\RecordService;\n\n    class Api implements RequestHandlerInterface\n    {\n        private $router;\n\n        public function __construct(Config $config)\n        {\n            $db = new GenericDB(\n                $config->getDriver(),\n                $config->getAddress(),\n                $config->getPort(),\n                $config->getDatabase(),\n                $config->getCommand(),\n                $config->getTables(),\n                $config->getMapping(),\n                $config->getUsername(),\n                $config->getPassword(),\n                $config->getGeometrySrid()\n            );\n            $prefix = sprintf('phpcrudapi-%s-', substr($config->getUID(), 0, 8));\n            $cache = CacheFactory::create($config->getCacheType(), $prefix, $config->getCachePath());\n            $reflection = new ReflectionService($db, $cache, $config->getCacheTime());\n            $responder = new JsonResponder($config->getJsonOptions(), $config->getDebug());\n            $router = new SimpleRouter($config->getBasePath(), $responder, $cache, $config->getCacheTime());\n            foreach ($config->getMiddlewares() as $middleware) {\n                switch ($middleware) {\n                    case 'sslRedirect':\n                        new SslRedirectMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'cors':\n                        new CorsMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'firewall':\n                        new FirewallMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'apiKeyAuth':\n                        new ApiKeyAuthMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'apiKeyDbAuth':\n                        new ApiKeyDbAuthMiddleware($router, $responder, $config, $middleware, $reflection, $db);\n                        break;\n                    case 'basicAuth':\n                        new BasicAuthMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'jwtAuth':\n                        new JwtAuthMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'dbAuth':\n                        new DbAuthMiddleware($router, $responder, $config, $middleware, $reflection, $db);\n                        break;\n                    case 'wpAuth':\n                        new WpAuthMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'reconnect':\n                        new ReconnectMiddleware($router, $responder, $config, $middleware, $reflection, $db);\n                        break;\n                    case 'validation':\n                        new ValidationMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'ipAddress':\n                        new IpAddressMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'sanitation':\n                        new SanitationMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'multiTenancy':\n                        new MultiTenancyMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'authorization':\n                        new AuthorizationMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'xsrf':\n                        new XsrfMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'pageLimits':\n                        new PageLimitsMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'joinLimits':\n                        new JoinLimitsMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'customization':\n                        new CustomizationMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'textSearch':\n                        new TextSearchMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'xml':\n                        new XmlMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'json':\n                        new JsonMiddleware($router, $responder, $config, $middleware);\n                        break;\n                }\n            }\n            foreach ($config->getControllers() as $controller) {\n                switch ($controller) {\n                    case 'records':\n                        $records = new RecordService($db, $reflection);\n                        new RecordController($router, $responder, $records);\n                        break;\n                    case 'columns':\n                        $definition = new DefinitionService($db, $reflection);\n                        new ColumnController($router, $responder, $reflection, $definition);\n                        break;\n                    case 'cache':\n                        new CacheController($router, $responder, $cache);\n                        break;\n                    case 'openapi':\n                        $openApi = new OpenApiService($reflection, $config->getOpenApiBase(), $config->getControllers(), $config->getCustomOpenApiBuilders());\n                        new OpenApiController($router, $responder, $openApi);\n                        break;\n                    case 'geojson':\n                        $records = new RecordService($db, $reflection);\n                        $geoJson = new GeoJsonService($reflection, $records);\n                        new GeoJsonController($router, $responder, $geoJson);\n                        break;\n                    case 'status':\n                        new StatusController($router, $responder, $cache, $db);\n                        break;\n                }\n            }\n            foreach ($config->getCustomControllers() as $className) {\n                if (class_exists($className)) {\n                    new $className($router, $responder, $db, $reflection, $cache);\n                }\n            }\n            $this->router = $router;\n        }\n\n        private function parseBody(string $body) /*: ?object*/\n        {\n            $first = substr(ltrim($body), 0, 1);\n            if ($first == '[' || $first == '{') {\n                $object = json_decode($body);\n                $causeCode = json_last_error();\n                if ($causeCode !== JSON_ERROR_NONE) {\n                    $object = null;\n                }\n            } else {\n                parse_str($body, $input);\n                foreach ($input as $key => $value) {\n                    if (substr($key, -9) == '__is_null') {\n                        $input[substr($key, 0, -9)] = null;\n                        unset($input[$key]);\n                    }\n                }\n                $object = (object) $input;\n            }\n            return $object;\n        }\n\n        private function addParsedBody(ServerRequestInterface $request): ServerRequestInterface\n        {\n            $parsedBody = $request->getParsedBody();\n            if ($parsedBody) {\n                $request = $this->applyParsedBodyHack($request);\n            } else {\n                $body = $request->getBody();\n                if ($body->isReadable()) {\n                    if ($body->isSeekable()) {\n                        $body->rewind();\n                    }\n                    $contents = $body->getContents();\n                    if ($body->isSeekable()) {\n                        $body->rewind();\n                    }\n                    if ($contents) {\n                        $parsedBody = $this->parseBody($contents);\n                        $request = $request->withParsedBody($parsedBody);\n                    }\n                }\n            }\n            return $request;\n        }\n\n        private function applyParsedBodyHack(ServerRequestInterface $request): ServerRequestInterface\n        {\n            $parsedBody = $request->getParsedBody();\n            if (is_array($parsedBody)) { // is it really?\n                $contents = json_encode($parsedBody);\n                $parsedBody = $this->parseBody($contents);\n                $request = $request->withParsedBody($parsedBody);\n            }\n            return $request;\n        }\n\n        public function handle(ServerRequestInterface $request): ResponseInterface\n        {\n            return $this->router->route($this->addParsedBody($request));\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/RequestFactory.php\nnamespace Tqdev\\PhpCrudApi {\n\n    use Nyholm\\Psr7\\Factory\\Psr17Factory;\n    use Nyholm\\Psr7Server\\ServerRequestCreator;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n\n    class RequestFactory\n    {\n        public static function fromGlobals(): ServerRequestInterface\n        {\n            $psr17Factory = new Psr17Factory();\n            $creator = new ServerRequestCreator($psr17Factory, $psr17Factory, $psr17Factory, $psr17Factory);\n            $serverRequest = $creator->fromGlobals();\n            $stream = $psr17Factory->createStreamFromFile('php://input');\n            $serverRequest = $serverRequest->withBody($stream);\n            return $serverRequest;\n        }\n\n        public static function fromString(string $request): ServerRequestInterface\n        {\n            $parts = explode(\"\\n\\n\", trim($request), 2);\n            $lines = explode(\"\\n\", $parts[0]);\n            $first = explode(' ', trim(array_shift($lines)), 2);\n            $method = $first[0];\n            $body = isset($parts[1]) ? $parts[1] : '';\n            $url = isset($first[1]) ? $first[1] : '';\n\n            $psr17Factory = new Psr17Factory();\n            $serverRequest = $psr17Factory->createServerRequest($method, $url);\n            foreach ($lines as $line) {\n                list($key, $value) = explode(':', $line, 2);\n                $serverRequest = $serverRequest->withAddedHeader($key, $value);\n            }\n            if ($body) {\n                $stream = $psr17Factory->createStream($body);\n                $stream->rewind();\n                $serverRequest = $serverRequest->withBody($stream);\n            }\n            return $serverRequest;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/RequestUtils.php\nnamespace Tqdev\\PhpCrudApi {\n\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n\n    class RequestUtils\n    {\n        public static function setParams(ServerRequestInterface $request, array $params): ServerRequestInterface\n        {\n            $query = preg_replace('|%5B[0-9]+%5D=|', '=', http_build_query($params));\n            return $request->withUri($request->getUri()->withQuery($query));\n        }\n\n        public static function getHeader(ServerRequestInterface $request, string $header): string\n        {\n            $headers = $request->getHeader($header);\n            return isset($headers[0]) ? $headers[0] : '';\n        }\n\n        public static function getParams(ServerRequestInterface $request): array\n        {\n            $params = array();\n            $query = $request->getUri()->getQuery();\n            //$query = str_replace('][]=', ']=', str_replace('=', '[]=', $query));\n            $query = str_replace('%5D%5B%5D=', '%5D=', str_replace('=', '%5B%5D=', $query));\n            parse_str($query, $params);\n            return $params;\n        }\n\n        public static function getPathSegment(ServerRequestInterface $request, int $part): string\n        {\n            $path = $request->getUri()->getPath();\n            $pathSegments = explode('/', rtrim($path, '/'));\n            if ($part < 0 || $part >= count($pathSegments)) {\n                return '';\n            }\n            return urldecode($pathSegments[$part]);\n        }\n\n        public static function getOperation(ServerRequestInterface $request): string\n        {\n            $method = $request->getMethod();\n            $path = RequestUtils::getPathSegment($request, 1);\n            $hasPk = RequestUtils::getPathSegment($request, 3) != '';\n            switch ($path) {\n                case 'openapi':\n                    return 'document';\n                case 'columns':\n                    return $method == 'get' ? 'reflect' : 'remodel';\n                case 'geojson':\n                case 'records':\n                    switch ($method) {\n                        case 'POST':\n                            return 'create';\n                        case 'GET':\n                            return $hasPk ? 'read' : 'list';\n                        case 'PUT':\n                            return 'update';\n                        case 'DELETE':\n                            return 'delete';\n                        case 'PATCH':\n                            return 'increment';\n                    }\n            }\n            return 'unknown';\n        }\n\n        private static function getJoinTables(string $tableName, array $parameters): array\n        {\n            $uniqueTableNames = array();\n            $uniqueTableNames[$tableName] = true;\n            if (isset($parameters['join'])) {\n                foreach ($parameters['join'] as $parameter) {\n                    $tableNames = explode(',', trim($parameter));\n                    foreach ($tableNames as $tableName) {\n                        $uniqueTableNames[$tableName] = true;\n                    }\n                }\n            }\n            return array_keys($uniqueTableNames);\n        }\n\n        public static function getTableNames(ServerRequestInterface $request, ReflectionService $reflection): array\n        {\n            $path = RequestUtils::getPathSegment($request, 1);\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            $allTableNames = $reflection->getTableNames();\n            switch ($path) {\n                case 'openapi':\n                    return $allTableNames;\n                case 'columns':\n                    return $tableName ? [$tableName] : $allTableNames;\n                case 'records':\n                    return self::getJoinTables($tableName, RequestUtils::getParams($request));\n            }\n            return $allTableNames;\n        }\n\n        public static function toString(ServerRequestInterface $request): string\n        {\n            $method = $request->getMethod();\n            $uri = $request->getUri()->__toString();\n            $headers = $request->getHeaders();\n            $request->getBody()->rewind();\n            $body = $request->getBody()->getContents();\n\n            $str = \"$method $uri\\n\";\n            foreach ($headers as $key => $values) {\n                foreach ($values as $value) {\n                    $str .= \"$key: $value\\n\";\n                }\n            }\n            if ($body !== '') {\n                $str .= \"\\n\";\n                $str .= \"$body\\n\";\n            }\n            return $str;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/ResponseFactory.php\nnamespace Tqdev\\PhpCrudApi {\n\n    use Nyholm\\Psr7\\Factory\\Psr17Factory;\n    use Psr\\Http\\Message\\ResponseInterface;\n\n    class ResponseFactory\n    {\n        const OK = 200;\n        const MOVED_PERMANENTLY = 301;\n        const FOUND = 302;\n        const UNAUTHORIZED = 401;\n        const FORBIDDEN = 403;\n        const NOT_FOUND = 404;\n        const METHOD_NOT_ALLOWED = 405;\n        const CONFLICT = 409;\n        const UNPROCESSABLE_ENTITY = 422;\n        const FAILED_DEPENDENCY = 424;\n        const INTERNAL_SERVER_ERROR = 500;\n\n        public static function fromXml(int $status, string $xml): ResponseInterface\n        {\n            return self::from($status, 'text/xml', $xml);\n        }\n\n        public static function fromCsv(int $status, string $csv): ResponseInterface\n        {\n            return self::from($status, 'text/csv', $csv);\n        }\n\n        public static function fromHtml(int $status, string $html): ResponseInterface\n        {\n            return self::from($status, 'text/html', $html);\n        }\n\n        public static function fromObject(int $status, $body, int $jsonOptions): ResponseInterface\n        {\n            $content = json_encode($body, $jsonOptions);\n            return self::from($status, 'application/json', $content);\n        }\n\n        public static function from(int $status, string $contentType, string $content): ResponseInterface\n        {\n            $psr17Factory = new Psr17Factory();\n            $response = $psr17Factory->createResponse($status);\n            $stream = $psr17Factory->createStream($content);\n            $stream->rewind();\n            $response = $response->withBody($stream);\n            $response = $response->withHeader('Content-Type', $contentType . '; charset=utf-8');\n            $response = $response->withHeader('Content-Length', strlen($content));\n            return $response;\n        }\n\n        public static function fromStatus(int $status): ResponseInterface\n        {\n            $psr17Factory = new Psr17Factory();\n            return $psr17Factory->createResponse($status);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/ResponseUtils.php\nnamespace Tqdev\\PhpCrudApi {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n\n    class ResponseUtils\n    {\n        public static function output(ResponseInterface $response)\n        {\n            $status = $response->getStatusCode();\n            $headers = $response->getHeaders();\n            $body = $response->getBody()->getContents();\n\n            http_response_code($status);\n            foreach ($headers as $key => $values) {\n                foreach ($values as $value) {\n                    header(\"$key: $value\");\n                }\n            }\n            echo $body;\n        }\n\n        public static function addExceptionHeaders(ResponseInterface $response, \\Throwable $e): ResponseInterface\n        {\n            $response = $response->withHeader('X-Exception-Name', get_class($e));\n            $response = $response->withHeader('X-Exception-Message', preg_replace('|\\n|', ' ', trim($e->getMessage())));\n            $response = $response->withHeader('X-Exception-File', $e->getFile() . ':' . $e->getLine());\n            return $response;\n        }\n\n        public static function toString(ResponseInterface $response): string\n        {\n            $status = $response->getStatusCode();\n            $headers = $response->getHeaders();\n            $response->getBody()->rewind();\n            $body = $response->getBody()->getContents();\n\n            $str = \"$status\\n\";\n            foreach ($headers as $key => $values) {\n                foreach ($values as $value) {\n                    $str .= \"$key: $value\\n\";\n                }\n            }\n            if ($body !== '') {\n                $str .= \"\\n\";\n                $str .= \"$body\\n\";\n            }\n            return $str;\n        }\n    }\n}\n"
        },
        {
          "name": "api.php",
          "type": "blob",
          "size": 482.5400390625,
          "content": "<?php\n/**\n * PHP-CRUD-API v2              License: MIT\n * Maurits van der Schee: maurits@vdschee.nl\n * https://github.com/mevdschee/php-crud-api\n *\n * Dependencies:\n * - vendor/psr/*: PHP-FIG\n *   https://github.com/php-fig\n * - vendor/nyholm/*: Tobias Nyholm\n *   https://github.com/Nyholm\n **/\n\n// file: vendor/psr/http-factory/src/RequestFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface RequestFactoryInterface\n    {\n        /**\n         * Create a new request.\n         *\n         * @param string $method The HTTP method associated with the request.\n         * @param UriInterface|string $uri The URI associated with the request. If\n         *     the value is a string, the factory MUST create a UriInterface\n         *     instance based on it.\n         *\n         * @return RequestInterface\n         */\n        public function createRequest(string $method, $uri): RequestInterface;\n    }\n}\n\n// file: vendor/psr/http-factory/src/ResponseFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface ResponseFactoryInterface\n    {\n        /**\n         * Create a new response.\n         *\n         * @param int $code HTTP status code; defaults to 200\n         * @param string $reasonPhrase Reason phrase to associate with status code\n         *     in generated response; if none is provided implementations MAY use\n         *     the defaults as suggested in the HTTP specification.\n         *\n         * @return ResponseInterface\n         */\n        public function createResponse(int $code = 200, string $reasonPhrase = ''): ResponseInterface;\n    }\n}\n\n// file: vendor/psr/http-factory/src/ServerRequestFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface ServerRequestFactoryInterface\n    {\n        /**\n         * Create a new server request.\n         *\n         * Note that server-params are taken precisely as given - no parsing/processing\n         * of the given values is performed, and, in particular, no attempt is made to\n         * determine the HTTP method or URI, which must be provided explicitly.\n         *\n         * @param string $method The HTTP method associated with the request.\n         * @param UriInterface|string $uri The URI associated with the request. If\n         *     the value is a string, the factory MUST create a UriInterface\n         *     instance based on it.\n         * @param array $serverParams Array of SAPI parameters with which to seed\n         *     the generated request instance.\n         *\n         * @return ServerRequestInterface\n         */\n        public function createServerRequest(string $method, $uri, array $serverParams = []): ServerRequestInterface;\n    }\n}\n\n// file: vendor/psr/http-factory/src/StreamFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface StreamFactoryInterface\n    {\n        /**\n         * Create a new stream from a string.\n         *\n         * The stream SHOULD be created with a temporary resource.\n         *\n         * @param string $content String content with which to populate the stream.\n         *\n         * @return StreamInterface\n         */\n        public function createStream(string $content = ''): StreamInterface;\n\n        /**\n         * Create a stream from an existing file.\n         *\n         * The file MUST be opened using the given mode, which may be any mode\n         * supported by the `fopen` function.\n         *\n         * The `$filename` MAY be any string supported by `fopen()`.\n         *\n         * @param string $filename Filename or stream URI to use as basis of stream.\n         * @param string $mode Mode with which to open the underlying filename/stream.\n         *\n         * @return StreamInterface\n         * @throws \\RuntimeException If the file cannot be opened.\n         * @throws \\InvalidArgumentException If the mode is invalid.\n         */\n        public function createStreamFromFile(string $filename, string $mode = 'r'): StreamInterface;\n\n        /**\n         * Create a new stream from an existing resource.\n         *\n         * The stream MUST be readable and may be writable.\n         *\n         * @param resource $resource PHP resource to use as basis of stream.\n         *\n         * @return StreamInterface\n         */\n        public function createStreamFromResource($resource): StreamInterface;\n    }\n}\n\n// file: vendor/psr/http-factory/src/UploadedFileFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface UploadedFileFactoryInterface\n    {\n        /**\n         * Create a new uploaded file.\n         *\n         * If a size is not provided it will be determined by checking the size of\n         * the file.\n         *\n         * @see http://php.net/manual/features.file-upload.post-method.php\n         * @see http://php.net/manual/features.file-upload.errors.php\n         *\n         * @param StreamInterface $stream Underlying stream representing the\n         *     uploaded file content.\n         * @param int|null $size in bytes\n         * @param int $error PHP file upload error\n         * @param string|null $clientFilename Filename as provided by the client, if any.\n         * @param string|null $clientMediaType Media type as provided by the client, if any.\n         *\n         * @return UploadedFileInterface\n         *\n         * @throws \\InvalidArgumentException If the file resource is not readable.\n         */\n        public function createUploadedFile(\n            StreamInterface $stream,\n            ?int $size = null,\n            int $error = \\UPLOAD_ERR_OK,\n            ?string $clientFilename = null,\n            ?string $clientMediaType = null\n        ): UploadedFileInterface;\n    }\n}\n\n// file: vendor/psr/http-factory/src/UriFactoryInterface.php\nnamespace Psr\\Http\\Message {\n\n    interface UriFactoryInterface\n    {\n        /**\n         * Create a new URI.\n         *\n         * @param string $uri\n         *\n         * @return UriInterface\n         *\n         * @throws \\InvalidArgumentException If the given URI cannot be parsed.\n         */\n        public function createUri(string $uri = ''): UriInterface;\n    }\n}\n\n// file: vendor/psr/http-message/src/MessageInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * HTTP messages consist of requests from a client to a server and responses\n     * from a server to a client. This interface defines the methods common to\n     * each.\n     *\n     * Messages are considered immutable; all methods that might change state MUST\n     * be implemented such that they retain the internal state of the current\n     * message and return an instance that contains the changed state.\n     *\n     * @link http://www.ietf.org/rfc/rfc7230.txt\n     * @link http://www.ietf.org/rfc/rfc7231.txt\n     */\n    interface MessageInterface\n    {\n        /**\n         * Retrieves the HTTP protocol version as a string.\n         *\n         * The string MUST contain only the HTTP version number (e.g., \"1.1\", \"1.0\").\n         *\n         * @return string HTTP protocol version.\n         */\n        public function getProtocolVersion(): string;\n\n        /**\n         * Return an instance with the specified HTTP protocol version.\n         *\n         * The version string MUST contain only the HTTP version number (e.g.,\n         * \"1.1\", \"1.0\").\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * new protocol version.\n         *\n         * @param string $version HTTP protocol version\n         * @return static\n         */\n        public function withProtocolVersion(string $version): MessageInterface;\n\n        /**\n         * Retrieves all message header values.\n         *\n         * The keys represent the header name as it will be sent over the wire, and\n         * each value is an array of strings associated with the header.\n         *\n         *     // Represent the headers as a string\n         *     foreach ($message->getHeaders() as $name => $values) {\n         *         echo $name . \": \" . implode(\", \", $values);\n         *     }\n         *\n         *     // Emit headers iteratively:\n         *     foreach ($message->getHeaders() as $name => $values) {\n         *         foreach ($values as $value) {\n         *             header(sprintf('%s: %s', $name, $value), false);\n         *         }\n         *     }\n         *\n         * While header names are not case-sensitive, getHeaders() will preserve the\n         * exact case in which headers were originally specified.\n         *\n         * @return string[][] Returns an associative array of the message's headers. Each\n         *     key MUST be a header name, and each value MUST be an array of strings\n         *     for that header.\n         */\n        public function getHeaders(): array;\n\n        /**\n         * Checks if a header exists by the given case-insensitive name.\n         *\n         * @param string $name Case-insensitive header field name.\n         * @return bool Returns true if any header names match the given header\n         *     name using a case-insensitive string comparison. Returns false if\n         *     no matching header name is found in the message.\n         */\n        public function hasHeader(string $name): bool;\n\n        /**\n         * Retrieves a message header value by the given case-insensitive name.\n         *\n         * This method returns an array of all the header values of the given\n         * case-insensitive header name.\n         *\n         * If the header does not appear in the message, this method MUST return an\n         * empty array.\n         *\n         * @param string $name Case-insensitive header field name.\n         * @return string[] An array of string values as provided for the given\n         *    header. If the header does not appear in the message, this method MUST\n         *    return an empty array.\n         */\n        public function getHeader(string $name): array;\n\n        /**\n         * Retrieves a comma-separated string of the values for a single header.\n         *\n         * This method returns all of the header values of the given\n         * case-insensitive header name as a string concatenated together using\n         * a comma.\n         *\n         * NOTE: Not all header values may be appropriately represented using\n         * comma concatenation. For such headers, use getHeader() instead\n         * and supply your own delimiter when concatenating.\n         *\n         * If the header does not appear in the message, this method MUST return\n         * an empty string.\n         *\n         * @param string $name Case-insensitive header field name.\n         * @return string A string of values as provided for the given header\n         *    concatenated together using a comma. If the header does not appear in\n         *    the message, this method MUST return an empty string.\n         */\n        public function getHeaderLine(string $name): string;\n\n        /**\n         * Return an instance with the provided value replacing the specified header.\n         *\n         * While header names are case-insensitive, the casing of the header will\n         * be preserved by this function, and returned from getHeaders().\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * new and/or updated header and value.\n         *\n         * @param string $name Case-insensitive header field name.\n         * @param string|string[] $value Header value(s).\n         * @return static\n         * @throws \\InvalidArgumentException for invalid header names or values.\n         */\n        public function withHeader(string $name, $value): MessageInterface;\n\n        /**\n         * Return an instance with the specified header appended with the given value.\n         *\n         * Existing values for the specified header will be maintained. The new\n         * value(s) will be appended to the existing list. If the header did not\n         * exist previously, it will be added.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * new header and/or value.\n         *\n         * @param string $name Case-insensitive header field name to add.\n         * @param string|string[] $value Header value(s).\n         * @return static\n         * @throws \\InvalidArgumentException for invalid header names or values.\n         */\n        public function withAddedHeader(string $name, $value): MessageInterface;\n\n        /**\n         * Return an instance without the specified header.\n         *\n         * Header resolution MUST be done without case-sensitivity.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that removes\n         * the named header.\n         *\n         * @param string $name Case-insensitive header field name to remove.\n         * @return static\n         */\n        public function withoutHeader(string $name): MessageInterface;\n\n        /**\n         * Gets the body of the message.\n         *\n         * @return StreamInterface Returns the body as a stream.\n         */\n        public function getBody(): StreamInterface;\n\n        /**\n         * Return an instance with the specified message body.\n         *\n         * The body MUST be a StreamInterface object.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return a new instance that has the\n         * new body stream.\n         *\n         * @param StreamInterface $body Body.\n         * @return static\n         * @throws \\InvalidArgumentException When the body is not valid.\n         */\n        public function withBody(StreamInterface $body): MessageInterface;\n    }\n}\n\n// file: vendor/psr/http-message/src/RequestInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Representation of an outgoing, client-side request.\n     *\n     * Per the HTTP specification, this interface includes properties for\n     * each of the following:\n     *\n     * - Protocol version\n     * - HTTP method\n     * - URI\n     * - Headers\n     * - Message body\n     *\n     * During construction, implementations MUST attempt to set the Host header from\n     * a provided URI if no Host header is provided.\n     *\n     * Requests are considered immutable; all methods that might change state MUST\n     * be implemented such that they retain the internal state of the current\n     * message and return an instance that contains the changed state.\n     */\n    interface RequestInterface extends MessageInterface\n    {\n        /**\n         * Retrieves the message's request target.\n         *\n         * Retrieves the message's request-target either as it will appear (for\n         * clients), as it appeared at request (for servers), or as it was\n         * specified for the instance (see withRequestTarget()).\n         *\n         * In most cases, this will be the origin-form of the composed URI,\n         * unless a value was provided to the concrete implementation (see\n         * withRequestTarget() below).\n         *\n         * If no URI is available, and no request-target has been specifically\n         * provided, this method MUST return the string \"/\".\n         *\n         * @return string\n         */\n        public function getRequestTarget(): string;\n\n        /**\n         * Return an instance with the specific request-target.\n         *\n         * If the request needs a non-origin-form request-target — e.g., for\n         * specifying an absolute-form, authority-form, or asterisk-form —\n         * this method may be used to create an instance with the specified\n         * request-target, verbatim.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * changed request target.\n         *\n         * @link http://tools.ietf.org/html/rfc7230#section-5.3 (for the various\n         *     request-target forms allowed in request messages)\n         * @param string $requestTarget\n         * @return static\n         */\n        public function withRequestTarget(string $requestTarget): RequestInterface;\n\n        /**\n         * Retrieves the HTTP method of the request.\n         *\n         * @return string Returns the request method.\n         */\n        public function getMethod(): string;\n\n        /**\n         * Return an instance with the provided HTTP method.\n         *\n         * While HTTP method names are typically all uppercase characters, HTTP\n         * method names are case-sensitive and thus implementations SHOULD NOT\n         * modify the given string.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * changed request method.\n         *\n         * @param string $method Case-sensitive method.\n         * @return static\n         * @throws \\InvalidArgumentException for invalid HTTP methods.\n         */\n        public function withMethod(string $method): RequestInterface;\n\n        /**\n         * Retrieves the URI instance.\n         *\n         * This method MUST return a UriInterface instance.\n         *\n         * @link http://tools.ietf.org/html/rfc3986#section-4.3\n         * @return UriInterface Returns a UriInterface instance\n         *     representing the URI of the request.\n         */\n        public function getUri(): UriInterface;\n\n        /**\n         * Returns an instance with the provided URI.\n         *\n         * This method MUST update the Host header of the returned request by\n         * default if the URI contains a host component. If the URI does not\n         * contain a host component, any pre-existing Host header MUST be carried\n         * over to the returned request.\n         *\n         * You can opt-in to preserving the original state of the Host header by\n         * setting `$preserveHost` to `true`. When `$preserveHost` is set to\n         * `true`, this method interacts with the Host header in the following ways:\n         *\n         * - If the Host header is missing or empty, and the new URI contains\n         *   a host component, this method MUST update the Host header in the returned\n         *   request.\n         * - If the Host header is missing or empty, and the new URI does not contain a\n         *   host component, this method MUST NOT update the Host header in the returned\n         *   request.\n         * - If a Host header is present and non-empty, this method MUST NOT update\n         *   the Host header in the returned request.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * new UriInterface instance.\n         *\n         * @link http://tools.ietf.org/html/rfc3986#section-4.3\n         * @param UriInterface $uri New request URI to use.\n         * @param bool $preserveHost Preserve the original state of the Host header.\n         * @return static\n         */\n        public function withUri(UriInterface $uri, bool $preserveHost = false): RequestInterface;\n    }\n}\n\n// file: vendor/psr/http-message/src/ResponseInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Representation of an outgoing, server-side response.\n     *\n     * Per the HTTP specification, this interface includes properties for\n     * each of the following:\n     *\n     * - Protocol version\n     * - Status code and reason phrase\n     * - Headers\n     * - Message body\n     *\n     * Responses are considered immutable; all methods that might change state MUST\n     * be implemented such that they retain the internal state of the current\n     * message and return an instance that contains the changed state.\n     */\n    interface ResponseInterface extends MessageInterface\n    {\n        /**\n         * Gets the response status code.\n         *\n         * The status code is a 3-digit integer result code of the server's attempt\n         * to understand and satisfy the request.\n         *\n         * @return int Status code.\n         */\n        public function getStatusCode(): int;\n\n        /**\n         * Return an instance with the specified status code and, optionally, reason phrase.\n         *\n         * If no reason phrase is specified, implementations MAY choose to default\n         * to the RFC 7231 or IANA recommended reason phrase for the response's\n         * status code.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated status and reason phrase.\n         *\n         * @link http://tools.ietf.org/html/rfc7231#section-6\n         * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n         * @param int $code The 3-digit integer result code to set.\n         * @param string $reasonPhrase The reason phrase to use with the\n         *     provided status code; if none is provided, implementations MAY\n         *     use the defaults as suggested in the HTTP specification.\n         * @return static\n         * @throws \\InvalidArgumentException For invalid status code arguments.\n         */\n        public function withStatus(int $code, string $reasonPhrase = ''): ResponseInterface;\n\n        /**\n         * Gets the response reason phrase associated with the status code.\n         *\n         * Because a reason phrase is not a required element in a response\n         * status line, the reason phrase value MAY be null. Implementations MAY\n         * choose to return the default RFC 7231 recommended reason phrase (or those\n         * listed in the IANA HTTP Status Code Registry) for the response's\n         * status code.\n         *\n         * @link http://tools.ietf.org/html/rfc7231#section-6\n         * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n         * @return string Reason phrase; must return an empty string if none present.\n         */\n        public function getReasonPhrase(): string;\n    }\n}\n\n// file: vendor/psr/http-message/src/ServerRequestInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Representation of an incoming, server-side HTTP request.\n     *\n     * Per the HTTP specification, this interface includes properties for\n     * each of the following:\n     *\n     * - Protocol version\n     * - HTTP method\n     * - URI\n     * - Headers\n     * - Message body\n     *\n     * Additionally, it encapsulates all data as it has arrived to the\n     * application from the CGI and/or PHP environment, including:\n     *\n     * - The values represented in $_SERVER.\n     * - Any cookies provided (generally via $_COOKIE)\n     * - Query string arguments (generally via $_GET, or as parsed via parse_str())\n     * - Upload files, if any (as represented by $_FILES)\n     * - Deserialized body parameters (generally from $_POST)\n     *\n     * $_SERVER values MUST be treated as immutable, as they represent application\n     * state at the time of request; as such, no methods are provided to allow\n     * modification of those values. The other values provide such methods, as they\n     * can be restored from $_SERVER or the request body, and may need treatment\n     * during the application (e.g., body parameters may be deserialized based on\n     * content type).\n     *\n     * Additionally, this interface recognizes the utility of introspecting a\n     * request to derive and match additional parameters (e.g., via URI path\n     * matching, decrypting cookie values, deserializing non-form-encoded body\n     * content, matching authorization headers to users, etc). These parameters\n     * are stored in an \"attributes\" property.\n     *\n     * Requests are considered immutable; all methods that might change state MUST\n     * be implemented such that they retain the internal state of the current\n     * message and return an instance that contains the changed state.\n     */\n    interface ServerRequestInterface extends RequestInterface\n    {\n        /**\n         * Retrieve server parameters.\n         *\n         * Retrieves data related to the incoming request environment,\n         * typically derived from PHP's $_SERVER superglobal. The data IS NOT\n         * REQUIRED to originate from $_SERVER.\n         *\n         * @return array\n         */\n        public function getServerParams(): array;\n\n        /**\n         * Retrieve cookies.\n         *\n         * Retrieves cookies sent by the client to the server.\n         *\n         * The data MUST be compatible with the structure of the $_COOKIE\n         * superglobal.\n         *\n         * @return array\n         */\n        public function getCookieParams(): array;\n\n        /**\n         * Return an instance with the specified cookies.\n         *\n         * The data IS NOT REQUIRED to come from the $_COOKIE superglobal, but MUST\n         * be compatible with the structure of $_COOKIE. Typically, this data will\n         * be injected at instantiation.\n         *\n         * This method MUST NOT update the related Cookie header of the request\n         * instance, nor related values in the server params.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated cookie values.\n         *\n         * @param array $cookies Array of key/value pairs representing cookies.\n         * @return static\n         */\n        public function withCookieParams(array $cookies): ServerRequestInterface;\n\n        /**\n         * Retrieve query string arguments.\n         *\n         * Retrieves the deserialized query string arguments, if any.\n         *\n         * Note: the query params might not be in sync with the URI or server\n         * params. If you need to ensure you are only getting the original\n         * values, you may need to parse the query string from `getUri()->getQuery()`\n         * or from the `QUERY_STRING` server param.\n         *\n         * @return array\n         */\n        public function getQueryParams(): array;\n\n        /**\n         * Return an instance with the specified query string arguments.\n         *\n         * These values SHOULD remain immutable over the course of the incoming\n         * request. They MAY be injected during instantiation, such as from PHP's\n         * $_GET superglobal, or MAY be derived from some other value such as the\n         * URI. In cases where the arguments are parsed from the URI, the data\n         * MUST be compatible with what PHP's parse_str() would return for\n         * purposes of how duplicate query parameters are handled, and how nested\n         * sets are handled.\n         *\n         * Setting query string arguments MUST NOT change the URI stored by the\n         * request, nor the values in the server params.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated query string arguments.\n         *\n         * @param array $query Array of query string arguments, typically from\n         *     $_GET.\n         * @return static\n         */\n        public function withQueryParams(array $query): ServerRequestInterface;\n\n        /**\n         * Retrieve normalized file upload data.\n         *\n         * This method returns upload metadata in a normalized tree, with each leaf\n         * an instance of Psr\\Http\\Message\\UploadedFileInterface.\n         *\n         * These values MAY be prepared from $_FILES or the message body during\n         * instantiation, or MAY be injected via withUploadedFiles().\n         *\n         * @return array An array tree of UploadedFileInterface instances; an empty\n         *     array MUST be returned if no data is present.\n         */\n        public function getUploadedFiles(): array;\n\n        /**\n         * Create a new instance with the specified uploaded files.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated body parameters.\n         *\n         * @param array $uploadedFiles An array tree of UploadedFileInterface instances.\n         * @return static\n         * @throws \\InvalidArgumentException if an invalid structure is provided.\n         */\n        public function withUploadedFiles(array $uploadedFiles): ServerRequestInterface;\n\n        /**\n         * Retrieve any parameters provided in the request body.\n         *\n         * If the request Content-Type is either application/x-www-form-urlencoded\n         * or multipart/form-data, and the request method is POST, this method MUST\n         * return the contents of $_POST.\n         *\n         * Otherwise, this method may return any results of deserializing\n         * the request body content; as parsing returns structured content, the\n         * potential types MUST be arrays or objects only. A null value indicates\n         * the absence of body content.\n         *\n         * @return null|array|object The deserialized body parameters, if any.\n         *     These will typically be an array or object.\n         */\n        public function getParsedBody();\n\n        /**\n         * Return an instance with the specified body parameters.\n         *\n         * These MAY be injected during instantiation.\n         *\n         * If the request Content-Type is either application/x-www-form-urlencoded\n         * or multipart/form-data, and the request method is POST, use this method\n         * ONLY to inject the contents of $_POST.\n         *\n         * The data IS NOT REQUIRED to come from $_POST, but MUST be the results of\n         * deserializing the request body content. Deserialization/parsing returns\n         * structured data, and, as such, this method ONLY accepts arrays or objects,\n         * or a null value if nothing was available to parse.\n         *\n         * As an example, if content negotiation determines that the request data\n         * is a JSON payload, this method could be used to create a request\n         * instance with the deserialized parameters.\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated body parameters.\n         *\n         * @param null|array|object $data The deserialized body data. This will\n         *     typically be in an array or object.\n         * @return static\n         * @throws \\InvalidArgumentException if an unsupported argument type is\n         *     provided.\n         */\n        public function withParsedBody($data): ServerRequestInterface;\n\n        /**\n         * Retrieve attributes derived from the request.\n         *\n         * The request \"attributes\" may be used to allow injection of any\n         * parameters derived from the request: e.g., the results of path\n         * match operations; the results of decrypting cookies; the results of\n         * deserializing non-form-encoded message bodies; etc. Attributes\n         * will be application and request specific, and CAN be mutable.\n         *\n         * @return array Attributes derived from the request.\n         */\n        public function getAttributes(): array;\n\n        /**\n         * Retrieve a single derived request attribute.\n         *\n         * Retrieves a single derived request attribute as described in\n         * getAttributes(). If the attribute has not been previously set, returns\n         * the default value as provided.\n         *\n         * This method obviates the need for a hasAttribute() method, as it allows\n         * specifying a default value to return if the attribute is not found.\n         *\n         * @see getAttributes()\n         * @param string $name The attribute name.\n         * @param mixed $default Default value to return if the attribute does not exist.\n         * @return mixed\n         */\n        public function getAttribute(string $name, $default = null);\n\n        /**\n         * Return an instance with the specified derived request attribute.\n         *\n         * This method allows setting a single derived request attribute as\n         * described in getAttributes().\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that has the\n         * updated attribute.\n         *\n         * @see getAttributes()\n         * @param string $name The attribute name.\n         * @param mixed $value The value of the attribute.\n         * @return static\n         */\n        public function withAttribute(string $name, $value): ServerRequestInterface;\n\n        /**\n         * Return an instance that removes the specified derived request attribute.\n         *\n         * This method allows removing a single derived request attribute as\n         * described in getAttributes().\n         *\n         * This method MUST be implemented in such a way as to retain the\n         * immutability of the message, and MUST return an instance that removes\n         * the attribute.\n         *\n         * @see getAttributes()\n         * @param string $name The attribute name.\n         * @return static\n         */\n        public function withoutAttribute(string $name): ServerRequestInterface;\n    }\n}\n\n// file: vendor/psr/http-message/src/StreamInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Describes a data stream.\n     *\n     * Typically, an instance will wrap a PHP stream; this interface provides\n     * a wrapper around the most common operations, including serialization of\n     * the entire stream to a string.\n     */\n    interface StreamInterface\n    {\n        /**\n         * Reads all data from the stream into a string, from the beginning to end.\n         *\n         * This method MUST attempt to seek to the beginning of the stream before\n         * reading data and read the stream until the end is reached.\n         *\n         * Warning: This could attempt to load a large amount of data into memory.\n         *\n         * This method MUST NOT raise an exception in order to conform with PHP's\n         * string casting operations.\n         *\n         * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring\n         * @return string\n         */\n        public function __toString(): string;\n\n        /**\n         * Closes the stream and any underlying resources.\n         *\n         * @return void\n         */\n        public function close(): void;\n\n        /**\n         * Separates any underlying resources from the stream.\n         *\n         * After the stream has been detached, the stream is in an unusable state.\n         *\n         * @return resource|null Underlying PHP stream, if any\n         */\n        public function detach();\n\n        /**\n         * Get the size of the stream if known.\n         *\n         * @return int|null Returns the size in bytes if known, or null if unknown.\n         */\n        public function getSize(): ?int;\n\n        /**\n         * Returns the current position of the file read/write pointer\n         *\n         * @return int Position of the file pointer\n         * @throws \\RuntimeException on error.\n         */\n        public function tell(): int;\n\n        /**\n         * Returns true if the stream is at the end of the stream.\n         *\n         * @return bool\n         */\n        public function eof(): bool;\n\n        /**\n         * Returns whether or not the stream is seekable.\n         *\n         * @return bool\n         */\n        public function isSeekable(): bool;\n\n        /**\n         * Seek to a position in the stream.\n         *\n         * @link http://www.php.net/manual/en/function.fseek.php\n         * @param int $offset Stream offset\n         * @param int $whence Specifies how the cursor position will be calculated\n         *     based on the seek offset. Valid values are identical to the built-in\n         *     PHP $whence values for `fseek()`.  SEEK_SET: Set position equal to\n         *     offset bytes SEEK_CUR: Set position to current location plus offset\n         *     SEEK_END: Set position to end-of-stream plus offset.\n         * @throws \\RuntimeException on failure.\n         */\n        public function seek(int $offset, int $whence = SEEK_SET): void;\n\n        /**\n         * Seek to the beginning of the stream.\n         *\n         * If the stream is not seekable, this method will raise an exception;\n         * otherwise, it will perform a seek(0).\n         *\n         * @see seek()\n         * @link http://www.php.net/manual/en/function.fseek.php\n         * @throws \\RuntimeException on failure.\n         */\n        public function rewind(): void;\n\n        /**\n         * Returns whether or not the stream is writable.\n         *\n         * @return bool\n         */\n        public function isWritable(): bool;\n\n        /**\n         * Write data to the stream.\n         *\n         * @param string $string The string that is to be written.\n         * @return int Returns the number of bytes written to the stream.\n         * @throws \\RuntimeException on failure.\n         */\n        public function write(string $string): int;\n\n        /**\n         * Returns whether or not the stream is readable.\n         *\n         * @return bool\n         */\n        public function isReadable(): bool;\n\n        /**\n         * Read data from the stream.\n         *\n         * @param int $length Read up to $length bytes from the object and return\n         *     them. Fewer than $length bytes may be returned if underlying stream\n         *     call returns fewer bytes.\n         * @return string Returns the data read from the stream, or an empty string\n         *     if no bytes are available.\n         * @throws \\RuntimeException if an error occurs.\n         */\n        public function read(int $length): string;\n\n        /**\n         * Returns the remaining contents in a string\n         *\n         * @return string\n         * @throws \\RuntimeException if unable to read or an error occurs while\n         *     reading.\n         */\n        public function getContents(): string;\n\n        /**\n         * Get stream metadata as an associative array or retrieve a specific key.\n         *\n         * The keys returned are identical to the keys returned from PHP's\n         * stream_get_meta_data() function.\n         *\n         * @link http://php.net/manual/en/function.stream-get-meta-data.php\n         * @param string|null $key Specific metadata to retrieve.\n         * @return array|mixed|null Returns an associative array if no key is\n         *     provided. Returns a specific key value if a key is provided and the\n         *     value is found, or null if the key is not found.\n         */\n        public function getMetadata(?string $key = null);\n    }\n}\n\n// file: vendor/psr/http-message/src/UploadedFileInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Value object representing a file uploaded through an HTTP request.\n     *\n     * Instances of this interface are considered immutable; all methods that\n     * might change state MUST be implemented such that they retain the internal\n     * state of the current instance and return an instance that contains the\n     * changed state.\n     */\n    interface UploadedFileInterface\n    {\n        /**\n         * Retrieve a stream representing the uploaded file.\n         *\n         * This method MUST return a StreamInterface instance, representing the\n         * uploaded file. The purpose of this method is to allow utilizing native PHP\n         * stream functionality to manipulate the file upload, such as\n         * stream_copy_to_stream() (though the result will need to be decorated in a\n         * native PHP stream wrapper to work with such functions).\n         *\n         * If the moveTo() method has been called previously, this method MUST raise\n         * an exception.\n         *\n         * @return StreamInterface Stream representation of the uploaded file.\n         * @throws \\RuntimeException in cases when no stream is available or can be\n         *     created.\n         */\n        public function getStream(): StreamInterface;\n\n        /**\n         * Move the uploaded file to a new location.\n         *\n         * Use this method as an alternative to move_uploaded_file(). This method is\n         * guaranteed to work in both SAPI and non-SAPI environments.\n         * Implementations must determine which environment they are in, and use the\n         * appropriate method (move_uploaded_file(), rename(), or a stream\n         * operation) to perform the operation.\n         *\n         * $targetPath may be an absolute path, or a relative path. If it is a\n         * relative path, resolution should be the same as used by PHP's rename()\n         * function.\n         *\n         * The original file or stream MUST be removed on completion.\n         *\n         * If this method is called more than once, any subsequent calls MUST raise\n         * an exception.\n         *\n         * When used in an SAPI environment where $_FILES is populated, when writing\n         * files via moveTo(), is_uploaded_file() and move_uploaded_file() SHOULD be\n         * used to ensure permissions and upload status are verified correctly.\n         *\n         * If you wish to move to a stream, use getStream(), as SAPI operations\n         * cannot guarantee writing to stream destinations.\n         *\n         * @see http://php.net/is_uploaded_file\n         * @see http://php.net/move_uploaded_file\n         * @param string $targetPath Path to which to move the uploaded file.\n         * @throws \\InvalidArgumentException if the $targetPath specified is invalid.\n         * @throws \\RuntimeException on any error during the move operation, or on\n         *     the second or subsequent call to the method.\n         */\n        public function moveTo(string $targetPath): void;\n        \n        /**\n         * Retrieve the file size.\n         *\n         * Implementations SHOULD return the value stored in the \"size\" key of\n         * the file in the $_FILES array if available, as PHP calculates this based\n         * on the actual size transmitted.\n         *\n         * @return int|null The file size in bytes or null if unknown.\n         */\n        public function getSize(): ?int;\n        \n        /**\n         * Retrieve the error associated with the uploaded file.\n         *\n         * The return value MUST be one of PHP's UPLOAD_ERR_XXX constants.\n         *\n         * If the file was uploaded successfully, this method MUST return\n         * UPLOAD_ERR_OK.\n         *\n         * Implementations SHOULD return the value stored in the \"error\" key of\n         * the file in the $_FILES array.\n         *\n         * @see http://php.net/manual/en/features.file-upload.errors.php\n         * @return int One of PHP's UPLOAD_ERR_XXX constants.\n         */\n        public function getError(): int;\n        \n        /**\n         * Retrieve the filename sent by the client.\n         *\n         * Do not trust the value returned by this method. A client could send\n         * a malicious filename with the intention to corrupt or hack your\n         * application.\n         *\n         * Implementations SHOULD return the value stored in the \"name\" key of\n         * the file in the $_FILES array.\n         *\n         * @return string|null The filename sent by the client or null if none\n         *     was provided.\n         */\n        public function getClientFilename(): ?string;\n        \n        /**\n         * Retrieve the media type sent by the client.\n         *\n         * Do not trust the value returned by this method. A client could send\n         * a malicious media type with the intention to corrupt or hack your\n         * application.\n         *\n         * Implementations SHOULD return the value stored in the \"type\" key of\n         * the file in the $_FILES array.\n         *\n         * @return string|null The media type sent by the client or null if none\n         *     was provided.\n         */\n        public function getClientMediaType(): ?string;\n    }\n}\n\n// file: vendor/psr/http-message/src/UriInterface.php\nnamespace Psr\\Http\\Message {\n\n    /**\n     * Value object representing a URI.\n     *\n     * This interface is meant to represent URIs according to RFC 3986 and to\n     * provide methods for most common operations. Additional functionality for\n     * working with URIs can be provided on top of the interface or externally.\n     * Its primary use is for HTTP requests, but may also be used in other\n     * contexts.\n     *\n     * Instances of this interface are considered immutable; all methods that\n     * might change state MUST be implemented such that they retain the internal\n     * state of the current instance and return an instance that contains the\n     * changed state.\n     *\n     * Typically the Host header will be also be present in the request message.\n     * For server-side requests, the scheme will typically be discoverable in the\n     * server parameters.\n     *\n     * @link http://tools.ietf.org/html/rfc3986 (the URI specification)\n     */\n    interface UriInterface\n    {\n        /**\n         * Retrieve the scheme component of the URI.\n         *\n         * If no scheme is present, this method MUST return an empty string.\n         *\n         * The value returned MUST be normalized to lowercase, per RFC 3986\n         * Section 3.1.\n         *\n         * The trailing \":\" character is not part of the scheme and MUST NOT be\n         * added.\n         *\n         * @see https://tools.ietf.org/html/rfc3986#section-3.1\n         * @return string The URI scheme.\n         */\n        public function getScheme(): string;\n\n        /**\n         * Retrieve the authority component of the URI.\n         *\n         * If no authority information is present, this method MUST return an empty\n         * string.\n         *\n         * The authority syntax of the URI is:\n         *\n         * <pre>\n         * [user-info@]host[:port]\n         * </pre>\n         *\n         * If the port component is not set or is the standard port for the current\n         * scheme, it SHOULD NOT be included.\n         *\n         * @see https://tools.ietf.org/html/rfc3986#section-3.2\n         * @return string The URI authority, in \"[user-info@]host[:port]\" format.\n         */\n        public function getAuthority(): string;\n\n        /**\n         * Retrieve the user information component of the URI.\n         *\n         * If no user information is present, this method MUST return an empty\n         * string.\n         *\n         * If a user is present in the URI, this will return that value;\n         * additionally, if the password is also present, it will be appended to the\n         * user value, with a colon (\":\") separating the values.\n         *\n         * The trailing \"@\" character is not part of the user information and MUST\n         * NOT be added.\n         *\n         * @return string The URI user information, in \"username[:password]\" format.\n         */\n        public function getUserInfo(): string;\n\n        /**\n         * Retrieve the host component of the URI.\n         *\n         * If no host is present, this method MUST return an empty string.\n         *\n         * The value returned MUST be normalized to lowercase, per RFC 3986\n         * Section 3.2.2.\n         *\n         * @see http://tools.ietf.org/html/rfc3986#section-3.2.2\n         * @return string The URI host.\n         */\n        public function getHost(): string;\n\n        /**\n         * Retrieve the port component of the URI.\n         *\n         * If a port is present, and it is non-standard for the current scheme,\n         * this method MUST return it as an integer. If the port is the standard port\n         * used with the current scheme, this method SHOULD return null.\n         *\n         * If no port is present, and no scheme is present, this method MUST return\n         * a null value.\n         *\n         * If no port is present, but a scheme is present, this method MAY return\n         * the standard port for that scheme, but SHOULD return null.\n         *\n         * @return null|int The URI port.\n         */\n        public function getPort(): ?int;\n\n        /**\n         * Retrieve the path component of the URI.\n         *\n         * The path can either be empty or absolute (starting with a slash) or\n         * rootless (not starting with a slash). Implementations MUST support all\n         * three syntaxes.\n         *\n         * Normally, the empty path \"\" and absolute path \"/\" are considered equal as\n         * defined in RFC 7230 Section 2.7.3. But this method MUST NOT automatically\n         * do this normalization because in contexts with a trimmed base path, e.g.\n         * the front controller, this difference becomes significant. It's the task\n         * of the user to handle both \"\" and \"/\".\n         *\n         * The value returned MUST be percent-encoded, but MUST NOT double-encode\n         * any characters. To determine what characters to encode, please refer to\n         * RFC 3986, Sections 2 and 3.3.\n         *\n         * As an example, if the value should include a slash (\"/\") not intended as\n         * delimiter between path segments, that value MUST be passed in encoded\n         * form (e.g., \"%2F\") to the instance.\n         *\n         * @see https://tools.ietf.org/html/rfc3986#section-2\n         * @see https://tools.ietf.org/html/rfc3986#section-3.3\n         * @return string The URI path.\n         */\n        public function getPath(): string;\n\n        /**\n         * Retrieve the query string of the URI.\n         *\n         * If no query string is present, this method MUST return an empty string.\n         *\n         * The leading \"?\" character is not part of the query and MUST NOT be\n         * added.\n         *\n         * The value returned MUST be percent-encoded, but MUST NOT double-encode\n         * any characters. To determine what characters to encode, please refer to\n         * RFC 3986, Sections 2 and 3.4.\n         *\n         * As an example, if a value in a key/value pair of the query string should\n         * include an ampersand (\"&\") not intended as a delimiter between values,\n         * that value MUST be passed in encoded form (e.g., \"%26\") to the instance.\n         *\n         * @see https://tools.ietf.org/html/rfc3986#section-2\n         * @see https://tools.ietf.org/html/rfc3986#section-3.4\n         * @return string The URI query string.\n         */\n        public function getQuery(): string;\n\n        /**\n         * Retrieve the fragment component of the URI.\n         *\n         * If no fragment is present, this method MUST return an empty string.\n         *\n         * The leading \"#\" character is not part of the fragment and MUST NOT be\n         * added.\n         *\n         * The value returned MUST be percent-encoded, but MUST NOT double-encode\n         * any characters. To determine what characters to encode, please refer to\n         * RFC 3986, Sections 2 and 3.5.\n         *\n         * @see https://tools.ietf.org/html/rfc3986#section-2\n         * @see https://tools.ietf.org/html/rfc3986#section-3.5\n         * @return string The URI fragment.\n         */\n        public function getFragment(): string;\n\n        /**\n         * Return an instance with the specified scheme.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified scheme.\n         *\n         * Implementations MUST support the schemes \"http\" and \"https\" case\n         * insensitively, and MAY accommodate other schemes if required.\n         *\n         * An empty scheme is equivalent to removing the scheme.\n         *\n         * @param string $scheme The scheme to use with the new instance.\n         * @return static A new instance with the specified scheme.\n         * @throws \\InvalidArgumentException for invalid or unsupported schemes.\n         */\n        public function withScheme(string $scheme): UriInterface;\n\n        /**\n         * Return an instance with the specified user information.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified user information.\n         *\n         * Password is optional, but the user information MUST include the\n         * user; an empty string for the user is equivalent to removing user\n         * information.\n         *\n         * @param string $user The user name to use for authority.\n         * @param null|string $password The password associated with $user.\n         * @return static A new instance with the specified user information.\n         */\n        public function withUserInfo(string $user, ?string $password = null): UriInterface;\n\n        /**\n         * Return an instance with the specified host.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified host.\n         *\n         * An empty host value is equivalent to removing the host.\n         *\n         * @param string $host The hostname to use with the new instance.\n         * @return static A new instance with the specified host.\n         * @throws \\InvalidArgumentException for invalid hostnames.\n         */\n        public function withHost(string $host): UriInterface;\n\n        /**\n         * Return an instance with the specified port.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified port.\n         *\n         * Implementations MUST raise an exception for ports outside the\n         * established TCP and UDP port ranges.\n         *\n         * A null value provided for the port is equivalent to removing the port\n         * information.\n         *\n         * @param null|int $port The port to use with the new instance; a null value\n         *     removes the port information.\n         * @return static A new instance with the specified port.\n         * @throws \\InvalidArgumentException for invalid ports.\n         */\n        public function withPort(?int $port): UriInterface;\n\n        /**\n         * Return an instance with the specified path.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified path.\n         *\n         * The path can either be empty or absolute (starting with a slash) or\n         * rootless (not starting with a slash). Implementations MUST support all\n         * three syntaxes.\n         *\n         * If the path is intended to be domain-relative rather than path relative then\n         * it must begin with a slash (\"/\"). Paths not starting with a slash (\"/\")\n         * are assumed to be relative to some base path known to the application or\n         * consumer.\n         *\n         * Users can provide both encoded and decoded path characters.\n         * Implementations ensure the correct encoding as outlined in getPath().\n         *\n         * @param string $path The path to use with the new instance.\n         * @return static A new instance with the specified path.\n         * @throws \\InvalidArgumentException for invalid paths.\n         */\n        public function withPath(string $path): UriInterface;\n\n        /**\n         * Return an instance with the specified query string.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified query string.\n         *\n         * Users can provide both encoded and decoded query characters.\n         * Implementations ensure the correct encoding as outlined in getQuery().\n         *\n         * An empty query string value is equivalent to removing the query string.\n         *\n         * @param string $query The query string to use with the new instance.\n         * @return static A new instance with the specified query string.\n         * @throws \\InvalidArgumentException for invalid query strings.\n         */\n        public function withQuery(string $query): UriInterface;\n\n        /**\n         * Return an instance with the specified URI fragment.\n         *\n         * This method MUST retain the state of the current instance, and return\n         * an instance that contains the specified URI fragment.\n         *\n         * Users can provide both encoded and decoded fragment characters.\n         * Implementations ensure the correct encoding as outlined in getFragment().\n         *\n         * An empty fragment value is equivalent to removing the fragment.\n         *\n         * @param string $fragment The fragment to use with the new instance.\n         * @return static A new instance with the specified fragment.\n         */\n        public function withFragment(string $fragment): UriInterface;\n\n        /**\n         * Return the string representation as a URI reference.\n         *\n         * Depending on which components of the URI are present, the resulting\n         * string is either a full URI or relative reference according to RFC 3986,\n         * Section 4.1. The method concatenates the various components of the URI,\n         * using the appropriate delimiters:\n         *\n         * - If a scheme is present, it MUST be suffixed by \":\".\n         * - If an authority is present, it MUST be prefixed by \"//\".\n         * - The path can be concatenated without delimiters. But there are two\n         *   cases where the path has to be adjusted to make the URI reference\n         *   valid as PHP does not allow to throw an exception in __toString():\n         *     - If the path is rootless and an authority is present, the path MUST\n         *       be prefixed by \"/\".\n         *     - If the path is starting with more than one \"/\" and no authority is\n         *       present, the starting slashes MUST be reduced to one.\n         * - If a query is present, it MUST be prefixed by \"?\".\n         * - If a fragment is present, it MUST be prefixed by \"#\".\n         *\n         * @see http://tools.ietf.org/html/rfc3986#section-4.1\n         * @return string\n         */\n        public function __toString(): string;\n    }\n}\n\n// file: vendor/psr/http-server-handler/src/RequestHandlerInterface.php\nnamespace Psr\\Http\\Server {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n\n    /**\n     * Handles a server request and produces a response.\n     *\n     * An HTTP request handler process an HTTP request in order to produce an\n     * HTTP response.\n     */\n    interface RequestHandlerInterface\n    {\n        /**\n         * Handles a request and produces a response.\n         *\n         * May call other collaborating code to generate the response.\n         */\n        public function handle(ServerRequestInterface $request): ResponseInterface;\n    }\n}\n\n// file: vendor/psr/http-server-middleware/src/MiddlewareInterface.php\nnamespace Psr\\Http\\Server {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n\n    /**\n     * Participant in processing a server request and response.\n     *\n     * An HTTP middleware component participates in processing an HTTP message:\n     * by acting on the request, generating the response, or forwarding the\n     * request to a subsequent middleware and possibly acting on its response.\n     */\n    interface MiddlewareInterface\n    {\n        /**\n         * Process an incoming server request.\n         *\n         * Processes an incoming server request in order to produce a response.\n         * If unable to produce the response itself, it may delegate to the provided\n         * request handler to do so.\n         */\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface;\n    }\n}\n\n// file: vendor/nyholm/psr7/src/Factory/Psr17Factory.php\nnamespace Nyholm\\Psr7\\Factory {\n\n    use Nyholm\\Psr7\\{Request, Response, ServerRequest, Stream, UploadedFile, Uri};\n    use Psr\\Http\\Message\\{RequestFactoryInterface, RequestInterface, ResponseFactoryInterface, ResponseInterface, ServerRequestFactoryInterface, ServerRequestInterface, StreamFactoryInterface, StreamInterface, UploadedFileFactoryInterface, UploadedFileInterface, UriFactoryInterface, UriInterface};\n\n    /**\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class Psr17Factory implements RequestFactoryInterface, ResponseFactoryInterface, ServerRequestFactoryInterface, StreamFactoryInterface, UploadedFileFactoryInterface, UriFactoryInterface\n    {\n        public function createRequest(string $method, $uri): RequestInterface\n        {\n            return new Request($method, $uri);\n        }\n\n        public function createResponse(int $code = 200, string $reasonPhrase = ''): ResponseInterface\n        {\n            if (2 > \\func_num_args()) {\n                // This will make the Response class to use a custom reasonPhrase\n                $reasonPhrase = null;\n            }\n\n            return new Response($code, [], null, '1.1', $reasonPhrase);\n        }\n\n        public function createStream(string $content = ''): StreamInterface\n        {\n            return Stream::create($content);\n        }\n\n        public function createStreamFromFile(string $filename, string $mode = 'r'): StreamInterface\n        {\n            if ('' === $filename) {\n                throw new \\RuntimeException('Path cannot be empty');\n            }\n\n            if (false === $resource = @\\fopen($filename, $mode)) {\n                if ('' === $mode || false === \\in_array($mode[0], ['r', 'w', 'a', 'x', 'c'], true)) {\n                    throw new \\InvalidArgumentException(\\sprintf('The mode \"%s\" is invalid.', $mode));\n                }\n\n                throw new \\RuntimeException(\\sprintf('The file \"%s\" cannot be opened: %s', $filename, \\error_get_last()['message'] ?? ''));\n            }\n\n            return Stream::create($resource);\n        }\n\n        public function createStreamFromResource($resource): StreamInterface\n        {\n            return Stream::create($resource);\n        }\n\n        public function createUploadedFile(StreamInterface $stream, ?int $size = null, int $error = \\UPLOAD_ERR_OK, ?string $clientFilename = null, ?string $clientMediaType = null): UploadedFileInterface\n        {\n            if (null === $size) {\n                $size = $stream->getSize();\n            }\n\n            return new UploadedFile($stream, $size, $error, $clientFilename, $clientMediaType);\n        }\n\n        public function createUri(string $uri = ''): UriInterface\n        {\n            return new Uri($uri);\n        }\n\n        public function createServerRequest(string $method, $uri, array $serverParams = []): ServerRequestInterface\n        {\n            return new ServerRequest($method, $uri, [], null, '1.1', $serverParams);\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/MessageTrait.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\MessageInterface;\n    use Psr\\Http\\Message\\StreamInterface;\n\n    /**\n     * Trait implementing functionality common to requests and responses.\n     *\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @internal should not be used outside of Nyholm/Psr7 as it does not fall under our BC promise\n     */\n    trait MessageTrait\n    {\n        /** @var array Map of all registered headers, as original name => array of values */\n        private $headers = [];\n\n        /** @var array Map of lowercase header name => original name at registration */\n        private $headerNames = [];\n\n        /** @var string */\n        private $protocol = '1.1';\n\n        /** @var StreamInterface|null */\n        private $stream;\n\n        public function getProtocolVersion(): string\n        {\n            return $this->protocol;\n        }\n\n        /**\n         * @return static\n         */\n        public function withProtocolVersion($version): MessageInterface\n        {\n            if (!\\is_scalar($version)) {\n                throw new \\InvalidArgumentException('Protocol version must be a string');\n            }\n\n            if ($this->protocol === $version) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->protocol = (string) $version;\n\n            return $new;\n        }\n\n        public function getHeaders(): array\n        {\n            return $this->headers;\n        }\n\n        public function hasHeader($header): bool\n        {\n            return isset($this->headerNames[\\strtr($header, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')]);\n        }\n\n        public function getHeader($header): array\n        {\n            if (!\\is_string($header)) {\n                throw new \\InvalidArgumentException('Header name must be an RFC 7230 compatible string');\n            }\n\n            $header = \\strtr($header, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz');\n            if (!isset($this->headerNames[$header])) {\n                return [];\n            }\n\n            $header = $this->headerNames[$header];\n\n            return $this->headers[$header];\n        }\n\n        public function getHeaderLine($header): string\n        {\n            return \\implode(', ', $this->getHeader($header));\n        }\n\n        /**\n         * @return static\n         */\n        public function withHeader($header, $value): MessageInterface\n        {\n            $value = $this->validateAndTrimHeader($header, $value);\n            $normalized = \\strtr($header, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz');\n\n            $new = clone $this;\n            if (isset($new->headerNames[$normalized])) {\n                unset($new->headers[$new->headerNames[$normalized]]);\n            }\n            $new->headerNames[$normalized] = $header;\n            $new->headers[$header] = $value;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withAddedHeader($header, $value): MessageInterface\n        {\n            if (!\\is_string($header) || '' === $header) {\n                throw new \\InvalidArgumentException('Header name must be an RFC 7230 compatible string');\n            }\n\n            $new = clone $this;\n            $new->setHeaders([$header => $value]);\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withoutHeader($header): MessageInterface\n        {\n            if (!\\is_string($header)) {\n                throw new \\InvalidArgumentException('Header name must be an RFC 7230 compatible string');\n            }\n\n            $normalized = \\strtr($header, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz');\n            if (!isset($this->headerNames[$normalized])) {\n                return $this;\n            }\n\n            $header = $this->headerNames[$normalized];\n            $new = clone $this;\n            unset($new->headers[$header], $new->headerNames[$normalized]);\n\n            return $new;\n        }\n\n        public function getBody(): StreamInterface\n        {\n            if (null === $this->stream) {\n                $this->stream = Stream::create('');\n            }\n\n            return $this->stream;\n        }\n\n        /**\n         * @return static\n         */\n        public function withBody(StreamInterface $body): MessageInterface\n        {\n            if ($body === $this->stream) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->stream = $body;\n\n            return $new;\n        }\n\n        private function setHeaders(array $headers): void\n        {\n            foreach ($headers as $header => $value) {\n                if (\\is_int($header)) {\n                    // If a header name was set to a numeric string, PHP will cast the key to an int.\n                    // We must cast it back to a string in order to comply with validation.\n                    $header = (string) $header;\n                }\n                $value = $this->validateAndTrimHeader($header, $value);\n                $normalized = \\strtr($header, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz');\n                if (isset($this->headerNames[$normalized])) {\n                    $header = $this->headerNames[$normalized];\n                    $this->headers[$header] = \\array_merge($this->headers[$header], $value);\n                } else {\n                    $this->headerNames[$normalized] = $header;\n                    $this->headers[$header] = $value;\n                }\n            }\n        }\n\n        /**\n         * Make sure the header complies with RFC 7230.\n         *\n         * Header names must be a non-empty string consisting of token characters.\n         *\n         * Header values must be strings consisting of visible characters with all optional\n         * leading and trailing whitespace stripped. This method will always strip such\n         * optional whitespace. Note that the method does not allow folding whitespace within\n         * the values as this was deprecated for almost all instances by the RFC.\n         *\n         * header-field = field-name \":\" OWS field-value OWS\n         * field-name   = 1*( \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" / \"^\"\n         *              / \"_\" / \"`\" / \"|\" / \"~\" / %x30-39 / ( %x41-5A / %x61-7A ) )\n         * OWS          = *( SP / HTAB )\n         * field-value  = *( ( %x21-7E / %x80-FF ) [ 1*( SP / HTAB ) ( %x21-7E / %x80-FF ) ] )\n         *\n         * @see https://tools.ietf.org/html/rfc7230#section-3.2.4\n         */\n        private function validateAndTrimHeader($header, $values): array\n        {\n            if (!\\is_string($header) || 1 !== \\preg_match(\"@^[!#$%&'*+.^_`|~0-9A-Za-z-]+$@D\", $header)) {\n                throw new \\InvalidArgumentException('Header name must be an RFC 7230 compatible string');\n            }\n\n            if (!\\is_array($values)) {\n                // This is simple, just one value.\n                if ((!\\is_numeric($values) && !\\is_string($values)) || 1 !== \\preg_match(\"@^[ \\t\\x21-\\x7E\\x80-\\xFF]*$@\", (string) $values)) {\n                    throw new \\InvalidArgumentException('Header values must be RFC 7230 compatible strings');\n                }\n\n                return [\\trim((string) $values, \" \\t\")];\n            }\n\n            if (empty($values)) {\n                throw new \\InvalidArgumentException('Header values must be a string or an array of strings, empty array given');\n            }\n\n            // Assert Non empty array\n            $returnValues = [];\n            foreach ($values as $v) {\n                if ((!\\is_numeric($v) && !\\is_string($v)) || 1 !== \\preg_match(\"@^[ \\t\\x21-\\x7E\\x80-\\xFF]*$@D\", (string) $v)) {\n                    throw new \\InvalidArgumentException('Header values must be RFC 7230 compatible strings');\n                }\n\n                $returnValues[] = \\trim((string) $v, \" \\t\");\n            }\n\n            return $returnValues;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/Request.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\{RequestInterface, StreamInterface, UriInterface};\n\n    /**\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class Request implements RequestInterface\n    {\n        use MessageTrait;\n        use RequestTrait;\n\n        /**\n         * @param string $method HTTP method\n         * @param string|UriInterface $uri URI\n         * @param array $headers Request headers\n         * @param string|resource|StreamInterface|null $body Request body\n         * @param string $version Protocol version\n         */\n        public function __construct(string $method, $uri, array $headers = [], $body = null, string $version = '1.1')\n        {\n            if (!($uri instanceof UriInterface)) {\n                $uri = new Uri($uri);\n            }\n\n            $this->method = $method;\n            $this->uri = $uri;\n            $this->setHeaders($headers);\n            $this->protocol = $version;\n\n            if (!$this->hasHeader('Host')) {\n                $this->updateHostFromUri();\n            }\n\n            // If we got no body, defer initialization of the stream until Request::getBody()\n            if ('' !== $body && null !== $body) {\n                $this->stream = Stream::create($body);\n            }\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/RequestTrait.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\RequestInterface;\n    use Psr\\Http\\Message\\UriInterface;\n\n    /**\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @internal should not be used outside of Nyholm/Psr7 as it does not fall under our BC promise\n     */\n    trait RequestTrait\n    {\n        /** @var string */\n        private $method;\n\n        /** @var string|null */\n        private $requestTarget;\n\n        /** @var UriInterface|null */\n        private $uri;\n\n        public function getRequestTarget(): string\n        {\n            if (null !== $this->requestTarget) {\n                return $this->requestTarget;\n            }\n\n            if ('' === $target = $this->uri->getPath()) {\n                $target = '/';\n            }\n            if ('' !== $this->uri->getQuery()) {\n                $target .= '?' . $this->uri->getQuery();\n            }\n\n            return $target;\n        }\n\n        /**\n         * @return static\n         */\n        public function withRequestTarget($requestTarget): RequestInterface\n        {\n            if (!\\is_string($requestTarget)) {\n                throw new \\InvalidArgumentException('Request target must be a string');\n            }\n\n            if (\\preg_match('#\\s#', $requestTarget)) {\n                throw new \\InvalidArgumentException('Invalid request target provided; cannot contain whitespace');\n            }\n\n            $new = clone $this;\n            $new->requestTarget = $requestTarget;\n\n            return $new;\n        }\n\n        public function getMethod(): string\n        {\n            return $this->method;\n        }\n\n        /**\n         * @return static\n         */\n        public function withMethod($method): RequestInterface\n        {\n            if (!\\is_string($method)) {\n                throw new \\InvalidArgumentException('Method must be a string');\n            }\n\n            $new = clone $this;\n            $new->method = $method;\n\n            return $new;\n        }\n\n        public function getUri(): UriInterface\n        {\n            return $this->uri;\n        }\n\n        /**\n         * @return static\n         */\n        public function withUri(UriInterface $uri, $preserveHost = false): RequestInterface\n        {\n            if ($uri === $this->uri) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->uri = $uri;\n\n            if (!$preserveHost || !$this->hasHeader('Host')) {\n                $new->updateHostFromUri();\n            }\n\n            return $new;\n        }\n\n        private function updateHostFromUri(): void\n        {\n            if ('' === $host = $this->uri->getHost()) {\n                return;\n            }\n\n            if (null !== ($port = $this->uri->getPort())) {\n                $host .= ':' . $port;\n            }\n\n            if (isset($this->headerNames['host'])) {\n                $header = $this->headerNames['host'];\n            } else {\n                $this->headerNames['host'] = $header = 'Host';\n            }\n\n            // Ensure Host is the first header.\n            // See: http://tools.ietf.org/html/rfc7230#section-5.4\n            $this->headers = [$header => [$host]] + $this->headers;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/Response.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\{ResponseInterface, StreamInterface};\n\n    /**\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class Response implements ResponseInterface\n    {\n        use MessageTrait;\n\n        /** @var array Map of standard HTTP status code/reason phrases */\n        private const PHRASES = [\n            100 => 'Continue', 101 => 'Switching Protocols', 102 => 'Processing',\n            200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content', 207 => 'Multi-status', 208 => 'Already Reported',\n            300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 306 => 'Switch Proxy', 307 => 'Temporary Redirect',\n            400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Time-out', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Large', 415 => 'Unsupported Media Type', 416 => 'Requested range not satisfiable', 417 => 'Expectation Failed', 418 => 'I\\'m a teapot', 422 => 'Unprocessable Entity', 423 => 'Locked', 424 => 'Failed Dependency', 425 => 'Unordered Collection', 426 => 'Upgrade Required', 428 => 'Precondition Required', 429 => 'Too Many Requests', 431 => 'Request Header Fields Too Large', 451 => 'Unavailable For Legal Reasons',\n            500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Time-out', 505 => 'HTTP Version not supported', 506 => 'Variant Also Negotiates', 507 => 'Insufficient Storage', 508 => 'Loop Detected', 511 => 'Network Authentication Required',\n        ];\n\n        /** @var string */\n        private $reasonPhrase = '';\n\n        /** @var int */\n        private $statusCode;\n\n        /**\n         * @param int $status Status code\n         * @param array $headers Response headers\n         * @param string|resource|StreamInterface|null $body Response body\n         * @param string $version Protocol version\n         * @param string|null $reason Reason phrase (when empty a default will be used based on the status code)\n         */\n        public function __construct(int $status = 200, array $headers = [], $body = null, string $version = '1.1', ?string $reason = null)\n        {\n            // If we got no body, defer initialization of the stream until Response::getBody()\n            if ('' !== $body && null !== $body) {\n                $this->stream = Stream::create($body);\n            }\n\n            $this->statusCode = $status;\n            $this->setHeaders($headers);\n            if (null === $reason && isset(self::PHRASES[$this->statusCode])) {\n                $this->reasonPhrase = self::PHRASES[$status];\n            } else {\n                $this->reasonPhrase = $reason ?? '';\n            }\n\n            $this->protocol = $version;\n        }\n\n        public function getStatusCode(): int\n        {\n            return $this->statusCode;\n        }\n\n        public function getReasonPhrase(): string\n        {\n            return $this->reasonPhrase;\n        }\n\n        /**\n         * @return static\n         */\n        public function withStatus($code, $reasonPhrase = ''): ResponseInterface\n        {\n            if (!\\is_int($code) && !\\is_string($code)) {\n                throw new \\InvalidArgumentException('Status code has to be an integer');\n            }\n\n            $code = (int) $code;\n            if ($code < 100 || $code > 599) {\n                throw new \\InvalidArgumentException(\\sprintf('Status code has to be an integer between 100 and 599. A status code of %d was given', $code));\n            }\n\n            $new = clone $this;\n            $new->statusCode = $code;\n            if ((null === $reasonPhrase || '' === $reasonPhrase) && isset(self::PHRASES[$new->statusCode])) {\n                $reasonPhrase = self::PHRASES[$new->statusCode];\n            }\n            $new->reasonPhrase = $reasonPhrase;\n\n            return $new;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/ServerRequest.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\{ServerRequestInterface, StreamInterface, UploadedFileInterface, UriInterface};\n\n    /**\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class ServerRequest implements ServerRequestInterface\n    {\n        use MessageTrait;\n        use RequestTrait;\n\n        /** @var array */\n        private $attributes = [];\n\n        /** @var array */\n        private $cookieParams = [];\n\n        /** @var array|object|null */\n        private $parsedBody;\n\n        /** @var array */\n        private $queryParams = [];\n\n        /** @var array */\n        private $serverParams;\n\n        /** @var UploadedFileInterface[] */\n        private $uploadedFiles = [];\n\n        /**\n         * @param string $method HTTP method\n         * @param string|UriInterface $uri URI\n         * @param array $headers Request headers\n         * @param string|resource|StreamInterface|null $body Request body\n         * @param string $version Protocol version\n         * @param array $serverParams Typically the $_SERVER superglobal\n         */\n        public function __construct(string $method, $uri, array $headers = [], $body = null, string $version = '1.1', array $serverParams = [])\n        {\n            $this->serverParams = $serverParams;\n\n            if (!($uri instanceof UriInterface)) {\n                $uri = new Uri($uri);\n            }\n\n            $this->method = $method;\n            $this->uri = $uri;\n            $this->setHeaders($headers);\n            $this->protocol = $version;\n            \\parse_str($uri->getQuery(), $this->queryParams);\n\n            if (!$this->hasHeader('Host')) {\n                $this->updateHostFromUri();\n            }\n\n            // If we got no body, defer initialization of the stream until ServerRequest::getBody()\n            if ('' !== $body && null !== $body) {\n                $this->stream = Stream::create($body);\n            }\n        }\n\n        public function getServerParams(): array\n        {\n            return $this->serverParams;\n        }\n\n        public function getUploadedFiles(): array\n        {\n            return $this->uploadedFiles;\n        }\n\n        /**\n         * @return static\n         */\n        public function withUploadedFiles(array $uploadedFiles): ServerRequestInterface\n        {\n            $new = clone $this;\n            $new->uploadedFiles = $uploadedFiles;\n\n            return $new;\n        }\n\n        public function getCookieParams(): array\n        {\n            return $this->cookieParams;\n        }\n\n        /**\n         * @return static\n         */\n        public function withCookieParams(array $cookies): ServerRequestInterface\n        {\n            $new = clone $this;\n            $new->cookieParams = $cookies;\n\n            return $new;\n        }\n\n        public function getQueryParams(): array\n        {\n            return $this->queryParams;\n        }\n\n        /**\n         * @return static\n         */\n        public function withQueryParams(array $query): ServerRequestInterface\n        {\n            $new = clone $this;\n            $new->queryParams = $query;\n\n            return $new;\n        }\n\n        /**\n         * @return array|object|null\n         */\n        public function getParsedBody()\n        {\n            return $this->parsedBody;\n        }\n\n        /**\n         * @return static\n         */\n        public function withParsedBody($data): ServerRequestInterface\n        {\n            if (!\\is_array($data) && !\\is_object($data) && null !== $data) {\n                throw new \\InvalidArgumentException('First parameter to withParsedBody MUST be object, array or null');\n            }\n\n            $new = clone $this;\n            $new->parsedBody = $data;\n\n            return $new;\n        }\n\n        public function getAttributes(): array\n        {\n            return $this->attributes;\n        }\n\n        /**\n         * @return mixed\n         */\n        public function getAttribute($attribute, $default = null)\n        {\n            if (!\\is_string($attribute)) {\n                throw new \\InvalidArgumentException('Attribute name must be a string');\n            }\n\n            if (false === \\array_key_exists($attribute, $this->attributes)) {\n                return $default;\n            }\n\n            return $this->attributes[$attribute];\n        }\n\n        /**\n         * @return static\n         */\n        public function withAttribute($attribute, $value): ServerRequestInterface\n        {\n            if (!\\is_string($attribute)) {\n                throw new \\InvalidArgumentException('Attribute name must be a string');\n            }\n\n            $new = clone $this;\n            $new->attributes[$attribute] = $value;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withoutAttribute($attribute): ServerRequestInterface\n        {\n            if (!\\is_string($attribute)) {\n                throw new \\InvalidArgumentException('Attribute name must be a string');\n            }\n\n            if (false === \\array_key_exists($attribute, $this->attributes)) {\n                return $this;\n            }\n\n            $new = clone $this;\n            unset($new->attributes[$attribute]);\n\n            return $new;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/Stream.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\StreamInterface;\n\n    /**\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class Stream implements StreamInterface\n    {\n        function __toString():string { if ($this->isSeekable()) { $this->seek(0); } return $this->getContents(); }\n\n        /** @var resource|null A resource reference */\n        private $stream;\n\n        /** @var bool */\n        private $seekable;\n\n        /** @var bool */\n        private $readable;\n\n        /** @var bool */\n        private $writable;\n\n        /** @var array|mixed|void|bool|null */\n        private $uri;\n\n        /** @var int|null */\n        private $size;\n\n        /** @var array Hash of readable and writable stream types */\n        private const READ_WRITE_HASH = [\n            'read' => [\n                'r' => true, 'w+' => true, 'r+' => true, 'x+' => true, 'c+' => true,\n                'rb' => true, 'w+b' => true, 'r+b' => true, 'x+b' => true,\n                'c+b' => true, 'rt' => true, 'w+t' => true, 'r+t' => true,\n                'x+t' => true, 'c+t' => true, 'a+' => true,\n            ],\n            'write' => [\n                'w' => true, 'w+' => true, 'rw' => true, 'r+' => true, 'x+' => true,\n                'c+' => true, 'wb' => true, 'w+b' => true, 'r+b' => true,\n                'x+b' => true, 'c+b' => true, 'w+t' => true, 'r+t' => true,\n                'x+t' => true, 'c+t' => true, 'a' => true, 'a+' => true,\n            ],\n        ];\n\n        /**\n         * @param resource $body\n         */\n        public function __construct($body)\n        {\n            if (!\\is_resource($body)) {\n                throw new \\InvalidArgumentException('First argument to Stream::__construct() must be resource');\n            }\n\n            $this->stream = $body;\n            $meta = \\stream_get_meta_data($this->stream);\n            $this->seekable = $meta['seekable'] && 0 === \\fseek($this->stream, 0, \\SEEK_CUR);\n            $this->readable = isset(self::READ_WRITE_HASH['read'][$meta['mode']]);\n            $this->writable = isset(self::READ_WRITE_HASH['write'][$meta['mode']]);\n        }\n\n        /**\n         * Creates a new PSR-7 stream.\n         *\n         * @param string|resource|StreamInterface $body\n         *\n         * @throws \\InvalidArgumentException\n         */\n        public static function create($body = ''): StreamInterface\n        {\n            if ($body instanceof StreamInterface) {\n                return $body;\n            }\n\n            if (\\is_string($body)) {\n                if (200000 <= \\strlen($body)) {\n                    $body = self::openZvalStream($body);\n                } else {\n                    $resource = \\fopen('php://memory', 'r+');\n                    \\fwrite($resource, $body);\n                    \\fseek($resource, 0);\n                    $body = $resource;\n                }\n            }\n\n            if (!\\is_resource($body)) {\n                throw new \\InvalidArgumentException('First argument to Stream::create() must be a string, resource or StreamInterface');\n            }\n\n            return new self($body);\n        }\n\n        /**\n         * Closes the stream when the destructed.\n         */\n        public function __destruct()\n        {\n            $this->close();\n        }\n\n        public function close(): void\n        {\n            if (isset($this->stream)) {\n                if (\\is_resource($this->stream)) {\n                    \\fclose($this->stream);\n                }\n                $this->detach();\n            }\n        }\n\n        public function detach()\n        {\n            if (!isset($this->stream)) {\n                return null;\n            }\n\n            $result = $this->stream;\n            unset($this->stream);\n            $this->size = $this->uri = null;\n            $this->readable = $this->writable = $this->seekable = false;\n\n            return $result;\n        }\n\n        private function getUri()\n        {\n            if (false !== $this->uri) {\n                $this->uri = $this->getMetadata('uri') ?? false;\n            }\n\n            return $this->uri;\n        }\n\n        public function getSize(): ?int\n        {\n            if (null !== $this->size) {\n                return $this->size;\n            }\n\n            if (!isset($this->stream)) {\n                return null;\n            }\n\n            // Clear the stat cache if the stream has a URI\n            if ($uri = $this->getUri()) {\n                \\clearstatcache(true, $uri);\n            }\n\n            $stats = \\fstat($this->stream);\n            if (isset($stats['size'])) {\n                $this->size = $stats['size'];\n\n                return $this->size;\n            }\n\n            return null;\n        }\n\n        public function tell(): int\n        {\n            if (!isset($this->stream)) {\n                throw new \\RuntimeException('Stream is detached');\n            }\n\n            if (false === $result = @\\ftell($this->stream)) {\n                throw new \\RuntimeException('Unable to determine stream position: ' . (\\error_get_last()['message'] ?? ''));\n            }\n\n            return $result;\n        }\n\n        public function eof(): bool\n        {\n            return !isset($this->stream) || \\feof($this->stream);\n        }\n\n        public function isSeekable(): bool\n        {\n            return $this->seekable;\n        }\n\n        public function seek($offset, $whence = \\SEEK_SET): void\n        {\n            if (!isset($this->stream)) {\n                throw new \\RuntimeException('Stream is detached');\n            }\n\n            if (!$this->seekable) {\n                throw new \\RuntimeException('Stream is not seekable');\n            }\n\n            if (-1 === \\fseek($this->stream, $offset, $whence)) {\n                throw new \\RuntimeException('Unable to seek to stream position \"' . $offset . '\" with whence ' . \\var_export($whence, true));\n            }\n        }\n\n        public function rewind(): void\n        {\n            $this->seek(0);\n        }\n\n        public function isWritable(): bool\n        {\n            return $this->writable;\n        }\n\n        public function write($string): int\n        {\n            if (!isset($this->stream)) {\n                throw new \\RuntimeException('Stream is detached');\n            }\n\n            if (!$this->writable) {\n                throw new \\RuntimeException('Cannot write to a non-writable stream');\n            }\n\n            // We can't know the size after writing anything\n            $this->size = null;\n\n            if (false === $result = @\\fwrite($this->stream, $string)) {\n                throw new \\RuntimeException('Unable to write to stream: ' . (\\error_get_last()['message'] ?? ''));\n            }\n\n            return $result;\n        }\n\n        public function isReadable(): bool\n        {\n            return $this->readable;\n        }\n\n        public function read($length): string\n        {\n            if (!isset($this->stream)) {\n                throw new \\RuntimeException('Stream is detached');\n            }\n\n            if (!$this->readable) {\n                throw new \\RuntimeException('Cannot read from non-readable stream');\n            }\n\n            if (false === $result = @\\fread($this->stream, $length)) {\n                throw new \\RuntimeException('Unable to read from stream: ' . (\\error_get_last()['message'] ?? ''));\n            }\n\n            return $result;\n        }\n\n        public function getContents(): string\n        {\n            if (!isset($this->stream)) {\n                throw new \\RuntimeException('Stream is detached');\n            }\n\n            $exception = null;\n\n            \\set_error_handler(static function ($type, $message) use (&$exception) {\n                throw $exception = new \\RuntimeException('Unable to read stream contents: ' . $message);\n            });\n\n            try {\n                return \\stream_get_contents($this->stream);\n            } catch (\\Throwable $e) {\n                throw $e === $exception ? $e : new \\RuntimeException('Unable to read stream contents: ' . $e->getMessage(), 0, $e);\n            } finally {\n                \\restore_error_handler();\n            }\n        }\n\n        /**\n         * @return mixed\n         */\n        public function getMetadata($key = null)\n        {\n            if (null !== $key && !\\is_string($key)) {\n                throw new \\InvalidArgumentException('Metadata key must be a string');\n            }\n\n            if (!isset($this->stream)) {\n                return $key ? null : [];\n            }\n\n            $meta = \\stream_get_meta_data($this->stream);\n\n            if (null === $key) {\n                return $meta;\n            }\n\n            return $meta[$key] ?? null;\n        }\n\n        private static function openZvalStream(string $body)\n        {\n            static $wrapper;\n\n            $wrapper ?? \\stream_wrapper_register('Nyholm-Psr7-Zval', $wrapper = \\get_class(new class() {\n                public $context;\n\n                private $data;\n                private $position = 0;\n\n                public function stream_open(): bool\n                {\n                    $this->data = \\stream_context_get_options($this->context)['Nyholm-Psr7-Zval']['data'];\n                    \\stream_context_set_option($this->context, 'Nyholm-Psr7-Zval', 'data', null);\n\n                    return true;\n                }\n\n                public function stream_read(int $count): string\n                {\n                    $result = \\substr($this->data, $this->position, $count);\n                    $this->position += \\strlen($result);\n\n                    return $result;\n                }\n\n                public function stream_write(string $data): int\n                {\n                    $this->data = \\substr_replace($this->data, $data, $this->position, \\strlen($data));\n                    $this->position += \\strlen($data);\n\n                    return \\strlen($data);\n                }\n\n                public function stream_tell(): int\n                {\n                    return $this->position;\n                }\n\n                public function stream_eof(): bool\n                {\n                    return \\strlen($this->data) <= $this->position;\n                }\n\n                public function stream_stat(): array\n                {\n                    return [\n                        'mode' => 33206, // POSIX_S_IFREG | 0666\n                        'nlink' => 1,\n                        'rdev' => -1,\n                        'size' => \\strlen($this->data),\n                        'blksize' => -1,\n                        'blocks' => -1,\n                    ];\n                }\n\n                public function stream_seek(int $offset, int $whence): bool\n                {\n                    if (\\SEEK_SET === $whence && (0 <= $offset && \\strlen($this->data) >= $offset)) {\n                        $this->position = $offset;\n                    } elseif (\\SEEK_CUR === $whence && 0 <= $offset) {\n                        $this->position += $offset;\n                    } elseif (\\SEEK_END === $whence && (0 > $offset && 0 <= $offset = \\strlen($this->data) + $offset)) {\n                        $this->position = $offset;\n                    } else {\n                        return false;\n                    }\n\n                    return true;\n                }\n\n                public function stream_set_option(): bool\n                {\n                    return true;\n                }\n\n                public function stream_truncate(int $new_size): bool\n                {\n                    if ($new_size) {\n                        $this->data = \\substr($this->data, 0, $new_size);\n                        $this->position = \\min($this->position, $new_size);\n                    } else {\n                        $this->data = '';\n                        $this->position = 0;\n                    }\n\n                    return true;\n                }\n            }));\n\n            $context = \\stream_context_create(['Nyholm-Psr7-Zval' => ['data' => $body]]);\n\n            if (!$stream = @\\fopen('Nyholm-Psr7-Zval://', 'r+', false, $context)) {\n                \\stream_wrapper_register('Nyholm-Psr7-Zval', $wrapper);\n                $stream = \\fopen('Nyholm-Psr7-Zval://', 'r+', false, $context);\n            }\n\n            return $stream;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/StreamTrait.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\StreamInterface;\n    use Symfony\\Component\\Debug\\ErrorHandler as SymfonyLegacyErrorHandler;\n    use Symfony\\Component\\ErrorHandler\\ErrorHandler as SymfonyErrorHandler;\n\n    if (\\PHP_VERSION_ID >= 70400 || (new \\ReflectionMethod(StreamInterface::class, '__toString'))->hasReturnType()) {\n        /**\n         * @internal\n         */\n        trait StreamTrait\n        {\n            public function __toString(): string\n            {\n                if ($this->isSeekable()) {\n                    $this->seek(0);\n                }\n\n                return $this->getContents();\n            }\n        }\n    } else {\n        /**\n         * @internal\n         */\n        trait StreamTrait\n        {\n            /**\n             * @return string\n             */\n            public function __toString()\n            {\n                try {\n                    if ($this->isSeekable()) {\n                        $this->seek(0);\n                    }\n\n                    return $this->getContents();\n                } catch (\\Throwable $e) {\n                    if (\\is_array($errorHandler = \\set_error_handler('var_dump'))) {\n                        $errorHandler = $errorHandler[0] ?? null;\n                    }\n                    \\restore_error_handler();\n\n                    if ($e instanceof \\Error || $errorHandler instanceof SymfonyErrorHandler || $errorHandler instanceof SymfonyLegacyErrorHandler) {\n                        return \\trigger_error((string) $e, \\E_USER_ERROR);\n                    }\n\n                    return '';\n                }\n            }\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/UploadedFile.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\{StreamInterface, UploadedFileInterface};\n\n    /**\n     * @author Michael Dowling and contributors to guzzlehttp/psr7\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class UploadedFile implements UploadedFileInterface\n    {\n        /** @var array */\n        private const ERRORS = [\n            \\UPLOAD_ERR_OK => 1,\n            \\UPLOAD_ERR_INI_SIZE => 1,\n            \\UPLOAD_ERR_FORM_SIZE => 1,\n            \\UPLOAD_ERR_PARTIAL => 1,\n            \\UPLOAD_ERR_NO_FILE => 1,\n            \\UPLOAD_ERR_NO_TMP_DIR => 1,\n            \\UPLOAD_ERR_CANT_WRITE => 1,\n            \\UPLOAD_ERR_EXTENSION => 1,\n        ];\n\n        /** @var string */\n        private $clientFilename;\n\n        /** @var string */\n        private $clientMediaType;\n\n        /** @var int */\n        private $error;\n\n        /** @var string|null */\n        private $file;\n\n        /** @var bool */\n        private $moved = false;\n\n        /** @var int */\n        private $size;\n\n        /** @var StreamInterface|null */\n        private $stream;\n\n        /**\n         * @param StreamInterface|string|resource $streamOrFile\n         * @param int $size\n         * @param int $errorStatus\n         * @param string|null $clientFilename\n         * @param string|null $clientMediaType\n         */\n        public function __construct($streamOrFile, $size, $errorStatus, $clientFilename = null, $clientMediaType = null)\n        {\n            if (false === \\is_int($errorStatus) || !isset(self::ERRORS[$errorStatus])) {\n                throw new \\InvalidArgumentException('Upload file error status must be an integer value and one of the \"UPLOAD_ERR_*\" constants');\n            }\n\n            if (false === \\is_int($size)) {\n                throw new \\InvalidArgumentException('Upload file size must be an integer');\n            }\n\n            if (null !== $clientFilename && !\\is_string($clientFilename)) {\n                throw new \\InvalidArgumentException('Upload file client filename must be a string or null');\n            }\n\n            if (null !== $clientMediaType && !\\is_string($clientMediaType)) {\n                throw new \\InvalidArgumentException('Upload file client media type must be a string or null');\n            }\n\n            $this->error = $errorStatus;\n            $this->size = $size;\n            $this->clientFilename = $clientFilename;\n            $this->clientMediaType = $clientMediaType;\n\n            if (\\UPLOAD_ERR_OK === $this->error) {\n                // Depending on the value set file or stream variable.\n                if (\\is_string($streamOrFile) && '' !== $streamOrFile) {\n                    $this->file = $streamOrFile;\n                } elseif (\\is_resource($streamOrFile)) {\n                    $this->stream = Stream::create($streamOrFile);\n                } elseif ($streamOrFile instanceof StreamInterface) {\n                    $this->stream = $streamOrFile;\n                } else {\n                    throw new \\InvalidArgumentException('Invalid stream or file provided for UploadedFile');\n                }\n            }\n        }\n\n        /**\n         * @throws \\RuntimeException if is moved or not ok\n         */\n        private function validateActive(): void\n        {\n            if (\\UPLOAD_ERR_OK !== $this->error) {\n                throw new \\RuntimeException('Cannot retrieve stream due to upload error');\n            }\n\n            if ($this->moved) {\n                throw new \\RuntimeException('Cannot retrieve stream after it has already been moved');\n            }\n        }\n\n        public function getStream(): StreamInterface\n        {\n            $this->validateActive();\n\n            if ($this->stream instanceof StreamInterface) {\n                return $this->stream;\n            }\n\n            if (false === $resource = @\\fopen($this->file, 'r')) {\n                throw new \\RuntimeException(\\sprintf('The file \"%s\" cannot be opened: %s', $this->file, \\error_get_last()['message'] ?? ''));\n            }\n\n            return Stream::create($resource);\n        }\n\n        public function moveTo($targetPath): void\n        {\n            $this->validateActive();\n\n            if (!\\is_string($targetPath) || '' === $targetPath) {\n                throw new \\InvalidArgumentException('Invalid path provided for move operation; must be a non-empty string');\n            }\n\n            if (null !== $this->file) {\n                $this->moved = 'cli' === \\PHP_SAPI ? @\\rename($this->file, $targetPath) : @\\move_uploaded_file($this->file, $targetPath);\n\n                if (false === $this->moved) {\n                    throw new \\RuntimeException(\\sprintf('Uploaded file could not be moved to \"%s\": %s', $targetPath, \\error_get_last()['message'] ?? ''));\n                }\n            } else {\n                $stream = $this->getStream();\n                if ($stream->isSeekable()) {\n                    $stream->rewind();\n                }\n\n                if (false === $resource = @\\fopen($targetPath, 'w')) {\n                    throw new \\RuntimeException(\\sprintf('The file \"%s\" cannot be opened: %s', $targetPath, \\error_get_last()['message'] ?? ''));\n                }\n\n                $dest = Stream::create($resource);\n\n                while (!$stream->eof()) {\n                    if (!$dest->write($stream->read(1048576))) {\n                        break;\n                    }\n                }\n\n                $this->moved = true;\n            }\n        }\n\n        public function getSize(): int\n        {\n            return $this->size;\n        }\n\n        public function getError(): int\n        {\n            return $this->error;\n        }\n\n        public function getClientFilename(): ?string\n        {\n            return $this->clientFilename;\n        }\n\n        public function getClientMediaType(): ?string\n        {\n            return $this->clientMediaType;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7/src/Uri.php\nnamespace Nyholm\\Psr7 {\n\n    use Psr\\Http\\Message\\UriInterface;\n\n    /**\n     * PSR-7 URI implementation.\n     *\n     * @author Michael Dowling\n     * @author Tobias Schultze\n     * @author Matthew Weier O'Phinney\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     *\n     * @final This class should never be extended. See https://github.com/Nyholm/psr7/blob/master/doc/final.md\n     */\n    class Uri implements UriInterface\n    {\n        private const SCHEMES = ['http' => 80, 'https' => 443];\n\n        private const CHAR_UNRESERVED = 'a-zA-Z0-9_\\-\\.~';\n\n        private const CHAR_SUB_DELIMS = '!\\$&\\'\\(\\)\\*\\+,;=';\n\n        private const CHAR_GEN_DELIMS = ':\\/\\?#\\[\\]@';\n\n        /** @var string Uri scheme. */\n        private $scheme = '';\n\n        /** @var string Uri user info. */\n        private $userInfo = '';\n\n        /** @var string Uri host. */\n        private $host = '';\n\n        /** @var int|null Uri port. */\n        private $port;\n\n        /** @var string Uri path. */\n        private $path = '';\n\n        /** @var string Uri query string. */\n        private $query = '';\n\n        /** @var string Uri fragment. */\n        private $fragment = '';\n\n        public function __construct(string $uri = '')\n        {\n            if ('' !== $uri) {\n                if (false === $parts = \\parse_url($uri)) {\n                    throw new \\InvalidArgumentException(\\sprintf('Unable to parse URI: \"%s\"', $uri));\n                }\n\n                // Apply parse_url parts to a URI.\n                $this->scheme = isset($parts['scheme']) ? \\strtr($parts['scheme'], 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz') : '';\n                $this->userInfo = $parts['user'] ?? '';\n                $this->host = isset($parts['host']) ? \\strtr($parts['host'], 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz') : '';\n                $this->port = isset($parts['port']) ? $this->filterPort($parts['port']) : null;\n                $this->path = isset($parts['path']) ? $this->filterPath($parts['path']) : '';\n                $this->query = isset($parts['query']) ? $this->filterQueryAndFragment($parts['query']) : '';\n                $this->fragment = isset($parts['fragment']) ? $this->filterQueryAndFragment($parts['fragment']) : '';\n                if (isset($parts['pass'])) {\n                    $this->userInfo .= ':' . $parts['pass'];\n                }\n            }\n        }\n\n        public function __toString(): string\n        {\n            return self::createUriString($this->scheme, $this->getAuthority(), $this->path, $this->query, $this->fragment);\n        }\n\n        public function getScheme(): string\n        {\n            return $this->scheme;\n        }\n\n        public function getAuthority(): string\n        {\n            if ('' === $this->host) {\n                return '';\n            }\n\n            $authority = $this->host;\n            if ('' !== $this->userInfo) {\n                $authority = $this->userInfo . '@' . $authority;\n            }\n\n            if (null !== $this->port) {\n                $authority .= ':' . $this->port;\n            }\n\n            return $authority;\n        }\n\n        public function getUserInfo(): string\n        {\n            return $this->userInfo;\n        }\n\n        public function getHost(): string\n        {\n            return $this->host;\n        }\n\n        public function getPort(): ?int\n        {\n            return $this->port;\n        }\n\n        public function getPath(): string\n        {\n            $path = $this->path;\n\n            if ('' !== $path && '/' !== $path[0]) {\n                if ('' !== $this->host) {\n                    // If the path is rootless and an authority is present, the path MUST be prefixed by \"/\"\n                    $path = '/' . $path;\n                }\n            } elseif (isset($path[1]) && '/' === $path[1]) {\n                // If the path is starting with more than one \"/\", the\n                // starting slashes MUST be reduced to one.\n                $path = '/' . \\ltrim($path, '/');\n            }\n\n            return $path;\n        }\n\n        public function getQuery(): string\n        {\n            return $this->query;\n        }\n\n        public function getFragment(): string\n        {\n            return $this->fragment;\n        }\n\n        /**\n         * @return static\n         */\n        public function withScheme($scheme): UriInterface\n        {\n            if (!\\is_string($scheme)) {\n                throw new \\InvalidArgumentException('Scheme must be a string');\n            }\n\n            if ($this->scheme === $scheme = \\strtr($scheme, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->scheme = $scheme;\n            $new->port = $new->filterPort($new->port);\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withUserInfo($user, $password = null): UriInterface\n        {\n            if (!\\is_string($user)) {\n                throw new \\InvalidArgumentException('User must be a string');\n            }\n\n            $info = \\preg_replace_callback('/[' . self::CHAR_GEN_DELIMS . self::CHAR_SUB_DELIMS . ']++/', [__CLASS__, 'rawurlencodeMatchZero'], $user);\n            if (null !== $password && '' !== $password) {\n                if (!\\is_string($password)) {\n                    throw new \\InvalidArgumentException('Password must be a string');\n                }\n\n                $info .= ':' . \\preg_replace_callback('/[' . self::CHAR_GEN_DELIMS . self::CHAR_SUB_DELIMS . ']++/', [__CLASS__, 'rawurlencodeMatchZero'], $password);\n            }\n\n            if ($this->userInfo === $info) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->userInfo = $info;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withHost($host): UriInterface\n        {\n            if (!\\is_string($host)) {\n                throw new \\InvalidArgumentException('Host must be a string');\n            }\n\n            if ($this->host === $host = \\strtr($host, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->host = $host;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withPort($port): UriInterface\n        {\n            if ($this->port === $port = $this->filterPort($port)) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->port = $port;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withPath($path): UriInterface\n        {\n            if ($this->path === $path = $this->filterPath($path)) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->path = $path;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withQuery($query): UriInterface\n        {\n            if ($this->query === $query = $this->filterQueryAndFragment($query)) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->query = $query;\n\n            return $new;\n        }\n\n        /**\n         * @return static\n         */\n        public function withFragment($fragment): UriInterface\n        {\n            if ($this->fragment === $fragment = $this->filterQueryAndFragment($fragment)) {\n                return $this;\n            }\n\n            $new = clone $this;\n            $new->fragment = $fragment;\n\n            return $new;\n        }\n\n        /**\n         * Create a URI string from its various parts.\n         */\n        private static function createUriString(string $scheme, string $authority, string $path, string $query, string $fragment): string\n        {\n            $uri = '';\n            if ('' !== $scheme) {\n                $uri .= $scheme . ':';\n            }\n\n            if ('' !== $authority) {\n                $uri .= '//' . $authority;\n            }\n\n            if ('' !== $path) {\n                if ('/' !== $path[0]) {\n                    if ('' !== $authority) {\n                        // If the path is rootless and an authority is present, the path MUST be prefixed by \"/\"\n                        $path = '/' . $path;\n                    }\n                } elseif (isset($path[1]) && '/' === $path[1]) {\n                    if ('' === $authority) {\n                        // If the path is starting with more than one \"/\" and no authority is present, the\n                        // starting slashes MUST be reduced to one.\n                        $path = '/' . \\ltrim($path, '/');\n                    }\n                }\n\n                $uri .= $path;\n            }\n\n            if ('' !== $query) {\n                $uri .= '?' . $query;\n            }\n\n            if ('' !== $fragment) {\n                $uri .= '#' . $fragment;\n            }\n\n            return $uri;\n        }\n\n        /**\n         * Is a given port non-standard for the current scheme?\n         */\n        private static function isNonStandardPort(string $scheme, int $port): bool\n        {\n            return !isset(self::SCHEMES[$scheme]) || $port !== self::SCHEMES[$scheme];\n        }\n\n        private function filterPort($port): ?int\n        {\n            if (null === $port) {\n                return null;\n            }\n\n            $port = (int) $port;\n            if (0 > $port || 0xFFFF < $port) {\n                throw new \\InvalidArgumentException(\\sprintf('Invalid port: %d. Must be between 0 and 65535', $port));\n            }\n\n            return self::isNonStandardPort($this->scheme, $port) ? $port : null;\n        }\n\n        private function filterPath($path): string\n        {\n            if (!\\is_string($path)) {\n                throw new \\InvalidArgumentException('Path must be a string');\n            }\n\n            return \\preg_replace_callback('/(?:[^' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:@\\/]++|%(?![A-Fa-f0-9]{2}))/', [__CLASS__, 'rawurlencodeMatchZero'], $path);\n        }\n\n        private function filterQueryAndFragment($str): string\n        {\n            if (!\\is_string($str)) {\n                throw new \\InvalidArgumentException('Query and fragment must be a string');\n            }\n\n            return \\preg_replace_callback('/(?:[^' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:@\\/\\?]++|%(?![A-Fa-f0-9]{2}))/', [__CLASS__, 'rawurlencodeMatchZero'], $str);\n        }\n\n        private static function rawurlencodeMatchZero(array $match): string\n        {\n            return \\rawurlencode($match[0]);\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7-server/src/ServerRequestCreator.php\nnamespace Nyholm\\Psr7Server {\n\n    use Psr\\Http\\Message\\ServerRequestFactoryInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Message\\StreamFactoryInterface;\n    use Psr\\Http\\Message\\StreamInterface;\n    use Psr\\Http\\Message\\UploadedFileFactoryInterface;\n    use Psr\\Http\\Message\\UploadedFileInterface;\n    use Psr\\Http\\Message\\UriFactoryInterface;\n    use Psr\\Http\\Message\\UriInterface;\n\n    /**\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     */\n    final class ServerRequestCreator implements ServerRequestCreatorInterface\n    {\n        private $serverRequestFactory;\n\n        private $uriFactory;\n\n        private $uploadedFileFactory;\n\n        private $streamFactory;\n\n        public function __construct(\n            ServerRequestFactoryInterface $serverRequestFactory,\n            UriFactoryInterface $uriFactory,\n            UploadedFileFactoryInterface $uploadedFileFactory,\n            StreamFactoryInterface $streamFactory\n        ) {\n            $this->serverRequestFactory = $serverRequestFactory;\n            $this->uriFactory = $uriFactory;\n            $this->uploadedFileFactory = $uploadedFileFactory;\n            $this->streamFactory = $streamFactory;\n        }\n\n        /**\n         * {@inheritdoc}\n         */\n        public function fromGlobals(): ServerRequestInterface\n        {\n            $server = $_SERVER;\n            if (false === isset($server['REQUEST_METHOD'])) {\n                $server['REQUEST_METHOD'] = 'GET';\n            }\n\n            $headers = \\function_exists('getallheaders') ? getallheaders() : static::getHeadersFromServer($_SERVER);\n\n            $post = null;\n            if ('POST' === $this->getMethodFromEnv($server)) {\n                foreach ($headers as $headerName => $headerValue) {\n                    if (true === \\is_int($headerName) || 'content-type' !== \\strtolower($headerName)) {\n                        continue;\n                    }\n                    if (\\in_array(\n                        \\strtolower(\\trim(\\explode(';', $headerValue, 2)[0])),\n                        ['application/x-www-form-urlencoded', 'multipart/form-data']\n                    )) {\n                        $post = $_POST;\n\n                        break;\n                    }\n                }\n            }\n\n            return $this->fromArrays($server, $headers, $_COOKIE, $_GET, $post, $_FILES, \\fopen('php://input', 'r') ?: null);\n        }\n\n        /**\n         * {@inheritdoc}\n         */\n        public function fromArrays(array $server, array $headers = [], array $cookie = [], array $get = [], ?array $post = null, array $files = [], $body = null): ServerRequestInterface\n        {\n            $method = $this->getMethodFromEnv($server);\n            $uri = $this->getUriFromEnvWithHTTP($server);\n            $protocol = isset($server['SERVER_PROTOCOL']) ? \\str_replace('HTTP/', '', $server['SERVER_PROTOCOL']) : '1.1';\n\n            $serverRequest = $this->serverRequestFactory->createServerRequest($method, $uri, $server);\n            foreach ($headers as $name => $value) {\n                // Because PHP automatically casts array keys set with numeric strings to integers, we have to make sure\n                // that numeric headers will not be sent along as integers, as withAddedHeader can only accept strings.\n                if (\\is_int($name)) {\n                    $name = (string) $name;\n                }\n                $serverRequest = $serverRequest->withAddedHeader($name, $value);\n            }\n\n            $serverRequest = $serverRequest\n                ->withProtocolVersion($protocol)\n                ->withCookieParams($cookie)\n                ->withQueryParams($get)\n                ->withParsedBody($post)\n                ->withUploadedFiles($this->normalizeFiles($files));\n\n            if (null === $body) {\n                return $serverRequest;\n            }\n\n            if (\\is_resource($body)) {\n                $body = $this->streamFactory->createStreamFromResource($body);\n            } elseif (\\is_string($body)) {\n                $body = $this->streamFactory->createStream($body);\n            } elseif (!$body instanceof StreamInterface) {\n                throw new \\InvalidArgumentException('The $body parameter to ServerRequestCreator::fromArrays must be string, resource or StreamInterface');\n            }\n\n            return $serverRequest->withBody($body);\n        }\n\n        /**\n         * Implementation from Laminas\\Diactoros\\marshalHeadersFromSapi().\n         */\n        public static function getHeadersFromServer(array $server): array\n        {\n            $headers = [];\n            foreach ($server as $key => $value) {\n                // Apache prefixes environment variables with REDIRECT_\n                // if they are added by rewrite rules\n                if (0 === \\strpos($key, 'REDIRECT_')) {\n                    $key = \\substr($key, 9);\n\n                    // We will not overwrite existing variables with the\n                    // prefixed versions, though\n                    if (\\array_key_exists($key, $server)) {\n                        continue;\n                    }\n                }\n\n                if ($value && 0 === \\strpos($key, 'HTTP_')) {\n                    $name = \\strtr(\\strtolower(\\substr($key, 5)), '_', '-');\n                    $headers[$name] = $value;\n\n                    continue;\n                }\n\n                if ($value && 0 === \\strpos($key, 'CONTENT_')) {\n                    $name = 'content-'.\\strtolower(\\substr($key, 8));\n                    $headers[$name] = $value;\n\n                    continue;\n                }\n            }\n\n            return $headers;\n        }\n\n        private function getMethodFromEnv(array $environment): string\n        {\n            if (false === isset($environment['REQUEST_METHOD'])) {\n                throw new \\InvalidArgumentException('Cannot determine HTTP method');\n            }\n\n            return $environment['REQUEST_METHOD'];\n        }\n\n        private function getUriFromEnvWithHTTP(array $environment): UriInterface\n        {\n            $uri = $this->createUriFromArray($environment);\n            if (empty($uri->getScheme())) {\n                $uri = $uri->withScheme('http');\n            }\n\n            return $uri;\n        }\n\n        /**\n         * Return an UploadedFile instance array.\n         *\n         * @param array $files A array which respect $_FILES structure\n         *\n         * @return UploadedFileInterface[]\n         *\n         * @throws \\InvalidArgumentException for unrecognized values\n         */\n        private function normalizeFiles(array $files): array\n        {\n            $normalized = [];\n\n            foreach ($files as $key => $value) {\n                if ($value instanceof UploadedFileInterface) {\n                    $normalized[$key] = $value;\n                } elseif (\\is_array($value) && isset($value['tmp_name'])) {\n                    $normalized[$key] = $this->createUploadedFileFromSpec($value);\n                } elseif (\\is_array($value)) {\n                    $normalized[$key] = $this->normalizeFiles($value);\n                } else {\n                    throw new \\InvalidArgumentException('Invalid value in files specification');\n                }\n            }\n\n            return $normalized;\n        }\n\n        /**\n         * Create and return an UploadedFile instance from a $_FILES specification.\n         *\n         * If the specification represents an array of values, this method will\n         * delegate to normalizeNestedFileSpec() and return that return value.\n         *\n         * @param array $value $_FILES struct\n         *\n         * @return array|UploadedFileInterface\n         */\n        private function createUploadedFileFromSpec(array $value)\n        {\n            if (\\is_array($value['tmp_name'])) {\n                return $this->normalizeNestedFileSpec($value);\n            }\n\n            if (UPLOAD_ERR_OK !== $value['error']) {\n                $stream = $this->streamFactory->createStream();\n            } else {\n                try {\n                    $stream = $this->streamFactory->createStreamFromFile($value['tmp_name']);\n                } catch (\\RuntimeException $e) {\n                    $stream = $this->streamFactory->createStream();\n                }\n            }\n\n            return $this->uploadedFileFactory->createUploadedFile(\n                $stream,\n                (int) $value['size'],\n                (int) $value['error'],\n                $value['name'],\n                $value['type']\n            );\n        }\n\n        /**\n         * Normalize an array of file specifications.\n         *\n         * Loops through all nested files and returns a normalized array of\n         * UploadedFileInterface instances.\n         *\n         * @return UploadedFileInterface[]\n         */\n        private function normalizeNestedFileSpec(array $files = []): array\n        {\n            $normalizedFiles = [];\n\n            foreach (\\array_keys($files['tmp_name']) as $key) {\n                $spec = [\n                    'tmp_name' => $files['tmp_name'][$key],\n                    'size' => $files['size'][$key],\n                    'error' => $files['error'][$key],\n                    'name' => $files['name'][$key],\n                    'type' => $files['type'][$key],\n                ];\n                $normalizedFiles[$key] = $this->createUploadedFileFromSpec($spec);\n            }\n\n            return $normalizedFiles;\n        }\n\n        /**\n         * Create a new uri from server variable.\n         *\n         * @param array $server typically $_SERVER or similar structure\n         */\n        private function createUriFromArray(array $server): UriInterface\n        {\n            $uri = $this->uriFactory->createUri('');\n\n            if (isset($server['HTTP_X_FORWARDED_PROTO'])) {\n                $uri = $uri->withScheme($server['HTTP_X_FORWARDED_PROTO']);\n            } else {\n                if (isset($server['REQUEST_SCHEME'])) {\n                    $uri = $uri->withScheme($server['REQUEST_SCHEME']);\n                } elseif (isset($server['HTTPS'])) {\n                    $uri = $uri->withScheme('on' === $server['HTTPS'] ? 'https' : 'http');\n                }\n\n                if (isset($server['SERVER_PORT'])) {\n                    $uri = $uri->withPort($server['SERVER_PORT']);\n                }\n            }\n\n            if (isset($server['HTTP_HOST'])) {\n                if (1 === \\preg_match('/^(.+)\\:(\\d+)$/', $server['HTTP_HOST'], $matches)) {\n                    $uri = $uri->withHost($matches[1])->withPort($matches[2]);\n                } else {\n                    $uri = $uri->withHost($server['HTTP_HOST']);\n                }\n            } elseif (isset($server['SERVER_NAME'])) {\n                $uri = $uri->withHost($server['SERVER_NAME']);\n            }\n\n            if (isset($server['REQUEST_URI'])) {\n                $uri = $uri->withPath(\\current(\\explode('?', $server['REQUEST_URI'])));\n            }\n\n            if (isset($server['QUERY_STRING'])) {\n                $uri = $uri->withQuery($server['QUERY_STRING']);\n            }\n\n            return $uri;\n        }\n    }\n}\n\n// file: vendor/nyholm/psr7-server/src/ServerRequestCreatorInterface.php\nnamespace Nyholm\\Psr7Server {\n\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Message\\StreamInterface;\n\n    /**\n     * @author Tobias Nyholm <tobias.nyholm@gmail.com>\n     * @author Martijn van der Ven <martijn@vanderven.se>\n     */\n    interface ServerRequestCreatorInterface\n    {\n        /**\n         * Create a new server request from the current environment variables.\n         * Defaults to a GET request to minimise the risk of an \\InvalidArgumentException.\n         * Includes the current request headers as supplied by the server through `getallheaders()`.\n         * If `getallheaders()` is unavailable on the current server it will fallback to its own `getHeadersFromServer()` method.\n         * Defaults to php://input for the request body.\n         *\n         * @throws \\InvalidArgumentException if no valid method or URI can be determined\n         */\n        public function fromGlobals(): ServerRequestInterface;\n\n        /**\n         * Create a new server request from a set of arrays.\n         *\n         * @param array                                $server  typically $_SERVER or similar structure\n         * @param array                                $headers typically the output of getallheaders() or similar structure\n         * @param array                                $cookie  typically $_COOKIE or similar structure\n         * @param array                                $get     typically $_GET or similar structure\n         * @param array|null                           $post    typically $_POST or similar structure, represents parsed request body\n         * @param array                                $files   typically $_FILES or similar structure\n         * @param StreamInterface|resource|string|null $body    Typically stdIn\n         *\n         * @throws \\InvalidArgumentException if no valid method or URI can be determined\n         */\n        public function fromArrays(\n            array $server,\n            array $headers = [],\n            array $cookie = [],\n            array $get = [],\n            ?array $post = null,\n            array $files = [],\n            $body = null\n        ): ServerRequestInterface;\n\n        /**\n         * Get parsed headers from ($_SERVER) array.\n         *\n         * @param array $server typically $_SERVER or similar structure\n         */\n        public static function getHeadersFromServer(array $server): array;\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/Base/BaseCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache\\Base {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Cache;\n\n    class BaseCache implements Cache\n    {\n        public function __construct()\n        {\n        }\n\n        public function set(string $key, string $value, int $ttl = 0): bool\n        {\n            return true;\n        }\n\n        public function get(string $key): string\n        {\n            return '';\n        }\n\n        public function clear(): bool\n        {\n            return true;\n        }\n        \n        public function ping(): int\n        {\n            $start = microtime(true);\n            $this->get('__ping__');\n            return intval((microtime(true)-$start)*1000000);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/Cache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    interface Cache\n    {\n        public function set(string $key, string $value, int $ttl = 0): bool;\n        public function get(string $key): string;\n        public function clear(): bool;\n        public function ping(): int;\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/CacheFactory.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    class CacheFactory\n    {\n        public static function create(string $type, string $prefix, string $config): Cache\n        {\n            switch ($type) {\n                case 'TempFile':\n                    $cache = new TempFileCache($prefix, $config);\n                    break;\n                case 'Redis':\n                    $cache = new RedisCache($prefix, $config);\n                    break;\n                case 'Memcache':\n                    $cache = new MemcacheCache($prefix, $config);\n                    break;\n                case 'Memcached':\n                    $cache = new MemcachedCache($prefix, $config);\n                    break;\n                default:\n                    $cache = new NoCache();\n            }\n            return $cache;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/MemcacheCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Base\\BaseCache;\n\n    class MemcacheCache extends BaseCache implements Cache\n    {\n        protected $prefix;\n        protected $memcache;\n\n        public function __construct(string $prefix, string $config)\n        {\n            $this->prefix = $prefix;\n            if ($config == '') {\n                $address = 'localhost';\n                $port = 11211;\n            } elseif (strpos($config, ':') === false) {\n                $address = $config;\n                $port = 11211;\n            } else {\n                list($address, $port) = explode(':', $config);\n            }\n            $this->memcache = $this->create();\n            $this->memcache->addServer($address, $port);\n        }\n\n        protected function create() /*: \\Memcache*/\n        {\n            return new \\Memcache();\n        }\n\n        public function set(string $key, string $value, int $ttl = 0): bool\n        {\n            return $this->memcache->set($this->prefix . $key, $value, 0, $ttl);\n        }\n\n        public function get(string $key): string\n        {\n            return $this->memcache->get($this->prefix . $key) ?: '';\n        }\n\n        public function clear(): bool\n        {\n            return $this->memcache->flush();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/MemcachedCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    class MemcachedCache extends MemcacheCache\n    {\n        protected function create() /*: \\Memcached*/\n        {\n            return new \\Memcached();\n        }\n\n        public function set(string $key, string $value, int $ttl = 0): bool\n        {\n            return $this->memcache->set($this->prefix . $key, $value, $ttl);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/NoCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Base\\BaseCache;\n\n    class NoCache extends BaseCache implements Cache\n    {\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/RedisCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Base\\BaseCache;\n\n    class RedisCache extends BaseCache implements Cache\n    {\n        protected $prefix;\n        protected $redis;\n\n        public function __construct(string $prefix, string $config)\n        {\n            $this->prefix = $prefix;\n            if ($config == '') {\n                $config = '127.0.0.1';\n            }\n            $params = explode(':', $config, 6);\n            if (isset($params[3])) {\n                $params[3] = null;\n            }\n            $this->redis = new \\Redis();\n            call_user_func_array(array($this->redis, 'pconnect'), $params);\n        }\n\n        public function set(string $key, string $value, int $ttl = 0): bool\n        {\n            return $this->redis->set($this->prefix . $key, $value, $ttl);\n        }\n\n        public function get(string $key): string\n        {\n            return $this->redis->get($this->prefix . $key) ?: '';\n        }\n\n        public function clear(): bool\n        {\n            return $this->redis->flushDb();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Cache/TempFileCache.php\nnamespace Tqdev\\PhpCrudApi\\Cache {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Base\\BaseCache;\n\n    class TempFileCache extends BaseCache implements Cache\n    {\n        const SUFFIX = 'cache';\n\n        private $path;\n        private $segments;\n\n        public function __construct(string $prefix, string $config)\n        {\n            $this->segments = [];\n            $s = DIRECTORY_SEPARATOR;\n            $ps = PATH_SEPARATOR;\n            if ($config == '') {\n                $this->path = sys_get_temp_dir() . $s . $prefix . self::SUFFIX;\n            } elseif (strpos($config, $ps) === false) {\n                $this->path = $config;\n            } else {\n                list($path, $segments) = explode($ps, $config);\n                $this->path = $path;\n                $this->segments = explode(',', $segments);\n            }\n            if (file_exists($this->path) && is_dir($this->path)) {\n                $this->clean($this->path, array_filter($this->segments), strlen(md5('')), false);\n            }\n        }\n\n        private function getFileName(string $key): string\n        {\n            $s = DIRECTORY_SEPARATOR;\n            $md5 = md5($key);\n            $filename = rtrim($this->path, $s) . $s;\n            $i = 0;\n            foreach ($this->segments as $segment) {\n                $filename .= substr($md5, $i, $segment) . $s;\n                $i += $segment;\n            }\n            $filename .= substr($md5, $i);\n            return $filename;\n        }\n\n        public function set(string $key, string $value, int $ttl = 0): bool\n        {\n            $filename = $this->getFileName($key);\n            $dirname = dirname($filename);\n            if (!file_exists($dirname)) {\n                if (!mkdir($dirname, 0755, true)) {\n                    return false;\n                }\n            }\n            $string = $ttl . '|' . $value;\n            return $this->filePutContents($filename, $string) !== false;\n        }\n\n        private function filePutContents($filename, $string)\n        {\n            return file_put_contents($filename, $string, LOCK_EX);\n        }\n\n        private function fileGetContents($filename)\n        {\n            $file = fopen($filename, 'rb');\n            if ($file === false) {\n                return false;\n            }\n            $lock = flock($file, LOCK_SH);\n            if (!$lock) {\n                fclose($file);\n                return false;\n            }\n            $string = '';\n            while (!feof($file)) {\n                $string .= fread($file, 8192);\n            }\n            flock($file, LOCK_UN);\n            fclose($file);\n            return $string;\n        }\n\n        private function getString($filename): string\n        {\n            $data = $this->fileGetContents($filename);\n            if ($data === false) {\n                return '';\n            }\n            if (strpos($data, '|') === false) {\n                return '';\n            }\n            list($ttl, $string) = explode('|', $data, 2);\n            if ($ttl > 0 && time() - filemtime($filename) > $ttl) {\n                return '';\n            }\n            return $string;\n        }\n\n        public function get(string $key): string\n        {\n            $filename = $this->getFileName($key);\n            if (!file_exists($filename)) {\n                return '';\n            }\n            $string = $this->getString($filename);\n            if ($string == null) {\n                return '';\n            }\n            return $string;\n        }\n\n        private function clean(string $path, array $segments, int $len, bool $all) /*: void*/\n        {\n            $entries = scandir($path);\n            foreach ($entries as $entry) {\n                if ($entry === '.' || $entry === '..') {\n                    continue;\n                }\n                $filename = $path . DIRECTORY_SEPARATOR . $entry;\n                if (count($segments) == 0) {\n                    if (strlen($entry) != $len) {\n                        continue;\n                    }\n                    if (file_exists($filename) && is_file($filename)) {\n                        if ($all || $this->getString($filename) == null) {\n                            @unlink($filename);\n                        }\n                    }\n                } else {\n                    if (strlen($entry) != $segments[0]) {\n                        continue;\n                    }\n                    if (file_exists($filename) && is_dir($filename)) {\n                        $this->clean($filename, array_slice($segments, 1), $len - $segments[0], $all);\n                        @rmdir($filename);\n                    }\n                }\n            }\n        }\n\n        public function clear(): bool\n        {\n            if (!file_exists($this->path) || !is_dir($this->path)) {\n                return false;\n            }\n            $this->clean($this->path, array_filter($this->segments), strlen(md5('')), true);\n            return true;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Column/Reflection/ReflectedColumn.php\nnamespace Tqdev\\PhpCrudApi\\Column\\Reflection {\n\n    use Tqdev\\PhpCrudApi\\Database\\GenericReflection;\n\n    class ReflectedColumn implements \\JsonSerializable\n    {\n        const DEFAULT_LENGTH = 255;\n        const DEFAULT_PRECISION = 19;\n        const DEFAULT_SCALE = 4;\n\n        private $name;\n        private $realName;\n        private $type;\n        private $length;\n        private $precision;\n        private $scale;\n        private $nullable;\n        private $pk;\n        private $fk;\n\n        public function __construct(string $name, string $realName, string $type, int $length, int $precision, int $scale, bool $nullable, bool $pk, string $fk)\n        {\n            $this->name = $name;\n            $this->realName = $realName;\n            $this->type = $type;\n            $this->length = $length;\n            $this->precision = $precision;\n            $this->scale = $scale;\n            $this->nullable = $nullable;\n            $this->pk = $pk;\n            $this->fk = $fk;\n            $this->sanitize();\n        }\n\n        private static function parseColumnType(string $columnType, int &$length, int &$precision, int &$scale) /*: void*/\n        {\n            if (!$columnType) {\n                return;\n            }\n            $pos = strpos($columnType, '(');\n            if ($pos) {\n                $dataSize = rtrim(substr($columnType, $pos + 1), ')');\n                if ($length) {\n                    $length = (int) $dataSize;\n                } else {\n                    $pos = strpos($dataSize, ',');\n                    if ($pos) {\n                        $precision = (int) substr($dataSize, 0, $pos);\n                        $scale = (int) substr($dataSize, $pos + 1);\n                    } else {\n                        $precision = (int) $dataSize;\n                        $scale = 0;\n                    }\n                }\n            }\n        }\n\n        private static function getDataSize(int $length, int $precision, int $scale): string\n        {\n            $dataSize = '';\n            if ($length) {\n                $dataSize = $length;\n            } elseif ($precision) {\n                if ($scale) {\n                    $dataSize = $precision . ',' . $scale;\n                } else {\n                    $dataSize = $precision;\n                }\n            }\n            return $dataSize;\n        }\n\n        public static function fromReflection(GenericReflection $reflection, array $columnResult): ReflectedColumn\n        {\n            $name = $columnResult['COLUMN_NAME'];\n            $realName = $columnResult['COLUMN_REAL_NAME'];\n            $dataType = $columnResult['DATA_TYPE'];\n            $length = (int) $columnResult['CHARACTER_MAXIMUM_LENGTH'];\n            $precision = (int) $columnResult['NUMERIC_PRECISION'];\n            $scale = (int) $columnResult['NUMERIC_SCALE'];\n            $columnType = $columnResult['COLUMN_TYPE'];\n            self::parseColumnType($columnType, $length, $precision, $scale);\n            $dataSize = self::getDataSize($length, $precision, $scale);\n            $type = $reflection->toJdbcType($dataType, $dataSize);\n            $nullable = in_array(strtoupper($columnResult['IS_NULLABLE']), ['TRUE', 'YES', 'T', 'Y', '1']);\n            $pk = false;\n            $fk = '';\n            return new ReflectedColumn($name, $realName, $type, $length, $precision, $scale, $nullable, $pk, $fk);\n        }\n\n        public static function fromJson( /* object */$json): ReflectedColumn\n        {\n            $name = $json->alias ?? $json->name;\n            $realName = $json->name;\n            $type = $json->type;\n            $length = isset($json->length) ? (int) $json->length : 0;\n            $precision = isset($json->precision) ? (int) $json->precision : 0;\n            $scale = isset($json->scale) ? (int) $json->scale : 0;\n            $nullable = isset($json->nullable) ? (bool) $json->nullable : false;\n            $pk = isset($json->pk) ? (bool) $json->pk : false;\n            $fk = isset($json->fk) ? $json->fk : '';\n            return new ReflectedColumn($name, $realName, $type, $length, $precision, $scale, $nullable, $pk, $fk);\n        }\n\n        private function sanitize()\n        {\n            $this->length = $this->hasLength() ? $this->getLength() : 0;\n            $this->precision = $this->hasPrecision() ? $this->getPrecision() : 0;\n            $this->scale = $this->hasScale() ? $this->getScale() : 0;\n        }\n\n        public function getName(): string\n        {\n            return $this->name;\n        }\n\n        public function getRealName(): string\n        {\n            return $this->realName;\n        }\n\n        public function getNullable(): bool\n        {\n            return $this->nullable;\n        }\n\n        public function getType(): string\n        {\n            return $this->type;\n        }\n\n        public function getLength(): int\n        {\n            return $this->length ?: self::DEFAULT_LENGTH;\n        }\n\n        public function getPrecision(): int\n        {\n            return $this->precision ?: self::DEFAULT_PRECISION;\n        }\n\n        public function getScale(): int\n        {\n            return $this->scale ?: self::DEFAULT_SCALE;\n        }\n\n        public function hasLength(): bool\n        {\n            return in_array($this->type, ['varchar', 'varbinary']);\n        }\n\n        public function hasPrecision(): bool\n        {\n            return $this->type == 'decimal';\n        }\n\n        public function hasScale(): bool\n        {\n            return $this->type == 'decimal';\n        }\n\n        public function isBinary(): bool\n        {\n            return in_array($this->type, ['blob', 'varbinary']);\n        }\n\n        public function isBoolean(): bool\n        {\n            return $this->type == 'boolean';\n        }\n\n        public function isGeometry(): bool\n        {\n            return $this->type == 'geometry';\n        }\n\n        public function isInteger(): bool\n        {\n            return in_array($this->type, ['integer', 'bigint', 'smallint', 'tinyint']);\n        }\n\n        public function isText(): bool\n        {\n            return in_array($this->type, ['varchar', 'clob']);\n        }\n\n        public function setPk($value) /*: void*/\n        {\n            $this->pk = $value;\n        }\n\n        public function getPk(): bool\n        {\n            return $this->pk;\n        }\n\n        public function setFk($value) /*: void*/\n        {\n            $this->fk = $value;\n        }\n\n        public function getFk(): string\n        {\n            return $this->fk;\n        }\n\n        public function serialize()\n        {\n            $json = [\n                'name' => $this->realName,\n                'alias' => $this->name != $this->realName ? $this->name : null,\n                'type' => $this->type,\n                'length' => $this->length,\n                'precision' => $this->precision,\n                'scale' => $this->scale,\n                'nullable' => $this->nullable,\n                'pk' => $this->pk,\n                'fk' => $this->fk,\n            ];\n            return array_filter($json);\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->serialize();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Column/Reflection/ReflectedDatabase.php\nnamespace Tqdev\\PhpCrudApi\\Column\\Reflection {\n\n    use Tqdev\\PhpCrudApi\\Database\\GenericReflection;\n\n    class ReflectedDatabase implements \\JsonSerializable\n    {\n        private $tableTypes;\n        private $tableRealNames;\n\n        public function __construct(array $tableTypes, array $tableRealNames)\n        {\n            $this->tableTypes = $tableTypes;\n            $this->tableRealNames = $tableRealNames;\n        }\n\n        public static function fromReflection(GenericReflection $reflection): ReflectedDatabase\n        {\n            $tableTypes = [];\n            $tableRealNames = [];\n            foreach ($reflection->getTables() as $table) {\n                $tableName = $table['TABLE_NAME'];\n                if (in_array($tableName, $reflection->getIgnoredTables())) {\n                    continue;\n                }\n                $tableTypes[$tableName] = $table['TABLE_TYPE'];\n                $tableRealNames[$tableName] = $table['TABLE_REAL_NAME'];\n            }\n            return new ReflectedDatabase($tableTypes, $tableRealNames);\n        }\n\n        public static function fromJson( /* object */$json): ReflectedDatabase\n        {\n            $tableTypes = (array) $json->types;\n            $tableRealNames = (array) $json->realNames;\n            return new ReflectedDatabase($tableTypes, $tableRealNames);\n        }\n\n        public function hasTable(string $tableName): bool\n        {\n            return isset($this->tableTypes[$tableName]);\n        }\n\n        public function getType(string $tableName): string\n        {\n            return isset($this->tableTypes[$tableName]) ? $this->tableTypes[$tableName] : '';\n        }\n\n        public function getRealName(string $tableName): string\n        {\n            return isset($this->tableRealNames[$tableName]) ? $this->tableRealNames[$tableName] : '';\n        }\n\n        public function getTableNames(): array\n        {\n            return array_keys($this->tableTypes);\n        }\n\n        public function removeTable(string $tableName): bool\n        {\n            if (!isset($this->tableTypes[$tableName])) {\n                return false;\n            }\n            unset($this->tableTypes[$tableName]);\n            unset($this->tableRealNames[$tableName]);\n            return true;\n        }\n\n        public function serialize()\n        {\n            return [\n                'types' => $this->tableTypes,\n                'realNames' => $this->tableRealNames,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->serialize();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Column/Reflection/ReflectedTable.php\nnamespace Tqdev\\PhpCrudApi\\Column\\Reflection {\n\n    use Tqdev\\PhpCrudApi\\Database\\GenericReflection;\n\n    class ReflectedTable implements \\JsonSerializable\n    {\n        private $name;\n        private $realName;\n        private $type;\n        private $columns;\n        private $pk;\n        private $fks;\n\n        public function __construct(string $name, string $realName, string $type, array $columns)\n        {\n            $this->name = $name;\n            $this->realName = $realName;\n            $this->type = $type;\n            // set columns\n            $this->columns = [];\n            foreach ($columns as $column) {\n                $columnName = $column->getName();\n                $this->columns[$columnName] = $column;\n            }\n            // set primary key\n            $this->pk = null;\n            foreach ($columns as $column) {\n                if ($column->getPk() == true) {\n                    $this->pk = $column;\n                }\n            }\n            // set foreign keys\n            $this->fks = [];\n            foreach ($columns as $column) {\n                $columnName = $column->getName();\n                $referencedTableName = $column->getFk();\n                if ($referencedTableName != '') {\n                    $this->fks[$columnName] = $referencedTableName;\n                }\n            }\n        }\n\n        public static function fromReflection(GenericReflection $reflection, string $name, string $realName, string $type): ReflectedTable\n        {\n            // set columns\n            $columns = [];\n            foreach ($reflection->getTableColumns($name, $type) as $tableColumn) {\n                $column = ReflectedColumn::fromReflection($reflection, $tableColumn);\n                $columns[$column->getName()] = $column;\n            }\n            // set primary key\n            $columnName = false;\n            if ($type == 'view') {\n                $columnName = 'id';\n            } else {\n                $columnNames = $reflection->getTablePrimaryKeys($name);\n                if (count($columnNames) == 1) {\n                    $columnName = $columnNames[0];\n                }\n            }\n            if ($columnName && isset($columns[$columnName])) {\n                $pk = $columns[$columnName];\n                $pk->setPk(true);\n            }\n            // set foreign keys\n            if ($type == 'view') {\n                $tables = $reflection->getTables();\n                foreach ($columns as $columnName => $column) {\n                    if (substr($columnName, -3) == '_id') {\n                        foreach ($tables as $table) {\n                            $tableName = $table['TABLE_NAME'];\n                            $suffix = $tableName . '_id';\n                            if (substr($columnName, -1 * strlen($suffix)) == $suffix) {\n                                $column->setFk($tableName);\n                            }\n                        }\n                    }\n                }\n            } else {\n                $fks = $reflection->getTableForeignKeys($name);\n                foreach ($fks as $columnName => $table) {\n                    $columns[$columnName]->setFk($table);\n                }\n            }\n            return new ReflectedTable($name, $realName, $type, array_values($columns));\n        }\n\n        public static function fromJson( /* object */$json): ReflectedTable\n        {\n            $name = $json->alias??$json->name;\n            $realName = $json->name;\n            $type = isset($json->type) ? $json->type : 'table';\n            $columns = [];\n            if (isset($json->columns) && is_array($json->columns)) {\n                foreach ($json->columns as $column) {\n                    $columns[] = ReflectedColumn::fromJson($column);\n                }\n            }\n            return new ReflectedTable($name, $realName, $type, $columns);\n        }\n\n        public function hasColumn(string $columnName): bool\n        {\n            return isset($this->columns[$columnName]);\n        }\n\n        public function hasPk(): bool\n        {\n            return $this->pk != null;\n        }\n\n        public function getPk() /*: ?ReflectedColumn */\n        {\n            return $this->pk;\n        }\n\n        public function getName(): string\n        {\n            return $this->name;\n        }\n\n        public function getRealName(): string\n        {\n            return $this->realName;\n        }\n\n        public function getType(): string\n        {\n            return $this->type;\n        }\n\n        public function getColumnNames(): array\n        {\n            return array_keys($this->columns);\n        }\n\n        public function getColumn($columnName): ReflectedColumn\n        {\n            return $this->columns[$columnName];\n        }\n\n        public function getFksTo(string $tableName): array\n        {\n            $columns = array();\n            foreach ($this->fks as $columnName => $referencedTableName) {\n                if ($tableName == $referencedTableName && !is_null($this->columns[$columnName])) {\n                    $columns[] = $this->columns[$columnName];\n                }\n            }\n            return $columns;\n        }\n\n        public function removeColumn(string $columnName): bool\n        {\n            if (!isset($this->columns[$columnName])) {\n                return false;\n            }\n            unset($this->columns[$columnName]);\n            return true;\n        }\n\n        public function serialize()\n        {\n            $json = [\n                'name' => $this->realName,\n                'alias' => $this->name!=$this->realName?$this->name:null,\n                'type' => $this->type,\n                'columns' => array_values($this->columns),\n            ];\n            return array_filter($json);\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->serialize();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Column/DefinitionService.php\nnamespace Tqdev\\PhpCrudApi\\Column {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n\n    class DefinitionService\n    {\n        private $db;\n        private $reflection;\n\n        public function __construct(GenericDB $db, ReflectionService $reflection)\n        {\n            $this->db = $db;\n            $this->reflection = $reflection;\n        }\n\n        public function updateTable(ReflectedTable $table, /* object */ $changes): bool\n        {\n            $newTable = ReflectedTable::fromJson((object) array_merge((array) $table->jsonSerialize(), (array) $changes));\n            if ($table->getRealName() != $newTable->getRealName()) {\n                if (!$this->db->definition()->renameTable($table->getRealName(), $newTable->getRealName())) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public function updateColumn(ReflectedTable $table, ReflectedColumn $column, /* object */ $changes): bool\n        {\n            // remove constraints on other column\n            $newColumn = ReflectedColumn::fromJson((object) array_merge((array) $column->jsonSerialize(), (array) $changes));\n            if ($newColumn->getPk() != $column->getPk() && $table->hasPk()) {\n                $oldColumn = $table->getPk();\n                if ($oldColumn->getRealName() != $column->getRealName()) {\n                    $oldColumn->setPk(false);\n                    if (!$this->db->definition()->removeColumnPrimaryKey($table->getRealName(), $oldColumn->getRealName(), $oldColumn)) {\n                        return false;\n                    }\n                }\n            }\n\n            // remove constraints\n            $newColumn = ReflectedColumn::fromJson((object) array_merge((array) $column->jsonSerialize(), ['pk' => false, 'fk' => false]));\n            if ($newColumn->getPk() != $column->getPk() && !$newColumn->getPk()) {\n                if (!$this->db->definition()->removeColumnPrimaryKey($table->getRealName(), $column->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            if ($newColumn->getFk() != $column->getFk() && !$newColumn->getFk()) {\n                if (!$this->db->definition()->removeColumnForeignKey($table->getRealName(), $column->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n\n            // name and type\n            $newColumn = ReflectedColumn::fromJson((object) array_merge((array) $column->jsonSerialize(), (array) $changes));\n            $newColumn->setPk(false);\n            $newColumn->setFk('');\n            if ($newColumn->getRealName() != $column->getRealName()) {\n                if (!$this->db->definition()->renameColumn($table->getRealName(), $column->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            if (\n                $newColumn->getType() != $column->getType() ||\n                $newColumn->getLength() != $column->getLength() ||\n                $newColumn->getPrecision() != $column->getPrecision() ||\n                $newColumn->getScale() != $column->getScale()\n            ) {\n                if (!$this->db->definition()->retypeColumn($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            if ($newColumn->getNullable() != $column->getNullable()) {\n                if (!$this->db->definition()->setColumnNullable($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n\n            // add constraints\n            $newColumn = ReflectedColumn::fromJson((object) array_merge((array) $column->jsonSerialize(), (array) $changes));\n            if ($newColumn->getFk()) {\n                if (!$this->db->definition()->addColumnForeignKey($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            if ($newColumn->getPk()) {\n                if (!$this->db->definition()->addColumnPrimaryKey($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public function addTable(/* object */$definition)\n        {\n            $newTable = ReflectedTable::fromJson($definition);\n            if (!$this->db->definition()->addTable($newTable)) {\n                return false;\n            }\n            return true;\n        }\n\n        public function addColumn(ReflectedTable $table, /* object */ $definition)\n        {\n            $newColumn = ReflectedColumn::fromJson($definition);\n            if (!$this->db->definition()->addColumn($table->getRealName(), $newColumn)) {\n                return false;\n            }\n            if ($newColumn->getFk()) {\n                if (!$this->db->definition()->addColumnForeignKey($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            if ($newColumn->getPk()) {\n                if (!$this->db->definition()->addColumnPrimaryKey($table->getRealName(), $newColumn->getRealName(), $newColumn)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public function removeTable(ReflectedTable $table)\n        {\n            if (!$this->db->definition()->removeTable($table->getRealName())) {\n                return false;\n            }\n            return true;\n        }\n\n        public function removeColumn(ReflectedTable $table, ReflectedColumn $column)\n        {\n            if ($column->getPk()) {\n                $column->setPk(false);\n                if (!$this->db->definition()->removeColumnPrimaryKey($table->getRealName(), $column->getRealName(), $column)) {\n                    return false;\n                }\n            }\n            if ($column->getFk()) {\n                $column->setFk(\"\");\n                if (!$this->db->definition()->removeColumnForeignKey($table->getRealName(), $column->getRealName(), $column)) {\n                    return false;\n                }\n            }\n            if (!$this->db->definition()->removeColumn($table->getRealName(), $column->getRealName())) {\n                return false;\n            }\n            return true;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Column/ReflectionService.php\nnamespace Tqdev\\PhpCrudApi\\Column {\n\n    use Tqdev\\PhpCrudApi\\Cache\\Cache;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedDatabase;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n\n    class ReflectionService\n    {\n        private $db;\n        private $cache;\n        private $ttl;\n        private $database;\n        private $tables;\n\n        public function __construct(GenericDB $db, Cache $cache, int $ttl)\n        {\n            $this->db = $db;\n            $this->cache = $cache;\n            $this->ttl = $ttl;\n            $this->database = null;\n            $this->tables = [];\n        }\n\n        private function database(): ReflectedDatabase\n        {\n            if ($this->database) {\n                return $this->database;\n            }\n            $this->database = $this->loadDatabase(true);\n            return $this->database;\n        }\n\n        private function loadDatabase(bool $useCache): ReflectedDatabase\n        {\n            $key = sprintf('%s-ReflectedDatabase', $this->db->getCacheKey());\n            $data = $useCache ? $this->cache->get($key) : '';\n            if ($data != '') {\n                $database = ReflectedDatabase::fromJson(json_decode(gzuncompress($data)));\n            } else {\n                $database = ReflectedDatabase::fromReflection($this->db->reflection());\n                $data = gzcompress(json_encode($database, JSON_UNESCAPED_UNICODE));\n                $this->cache->set($key, $data, $this->ttl);\n            }\n            return $database;\n        }\n\n        private function loadTable(string $tableName, bool $useCache): ReflectedTable\n        {\n            $key = sprintf('%s-ReflectedTable(%s)', $this->db->getCacheKey(), $tableName);\n            $data = $useCache ? $this->cache->get($key) : '';\n            if ($data != '') {\n                $table = ReflectedTable::fromJson(json_decode(gzuncompress($data)));\n            } else {\n                $tableType = $this->database()->getType($tableName);\n                $tableRealName = $this->database()->getRealName($tableName);\n                $table = ReflectedTable::fromReflection($this->db->reflection(), $tableName, $tableRealName, $tableType);\n                $data = gzcompress(json_encode($table, JSON_UNESCAPED_UNICODE));\n                $this->cache->set($key, $data, $this->ttl);\n            }\n            return $table;\n        }\n\n        public function refreshTables()\n        {\n            $this->database = $this->loadDatabase(false);\n        }\n\n        public function refreshTable(string $tableName)\n        {\n            $this->tables[$tableName] = $this->loadTable($tableName, false);\n        }\n\n        public function hasTable(string $tableName): bool\n        {\n            return $this->database()->hasTable($tableName);\n        }\n\n        public function getType(string $tableName): string\n        {\n            return $this->database()->getType($tableName);\n        }\n\n        public function getTable(string $tableName): ReflectedTable\n        {\n            if (!isset($this->tables[$tableName])) {\n                $this->tables[$tableName] = $this->loadTable($tableName, true);\n            }\n            return $this->tables[$tableName];\n        }\n\n        public function getTableNames(): array\n        {\n            return $this->database()->getTableNames();\n        }\n\n        public function removeTable(string $tableName): bool\n        {\n            unset($this->tables[$tableName]);\n            return $this->database()->removeTable($tableName);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Config/Base/ConfigInterface.php\nnamespace Tqdev\\PhpCrudApi\\Config\\Base {\n\n    interface ConfigInterface\n    {\n        public function getMiddlewares();\n        public function getProperty(string $key, $default = '');\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Config/Config.php\nnamespace Tqdev\\PhpCrudApi\\Config {\n\n    use Tqdev\\PhpCrudApi\\Config\\Base\\ConfigInterface;\n\n    class Config implements ConfigInterface\n    {\n        private $values = [\n            'driver' => null,\n            'address' => null,\n            'port' => null,\n            'username' => '',\n            'password' => '',\n            'database' => '',\n            'command' => '',\n            'tables' => 'all',\n            'mapping' => '',\n            'middlewares' => 'cors',\n            'controllers' => 'records,geojson,openapi,status',\n            'customControllers' => '',\n            'customOpenApiBuilders' => '',\n            'cacheType' => 'TempFile',\n            'cachePath' => '',\n            'cacheTime' => 10,\n            'jsonOptions' => JSON_UNESCAPED_UNICODE,\n            'debug' => false,\n            'basePath' => '',\n            'openApiBase' => '{\"info\":{\"title\":\"PHP-CRUD-API\",\"version\":\"1.0.0\"}}',\n            'geometrySrid' => 4326,\n        ];\n        \n        public function getUID(): string\n        {\n            return md5(json_encode($this->values));\n        }\n        \n        private function getDefaultDriver(array $values): string\n        {\n            if (isset($values['driver'])) {\n                return $values['driver'];\n            }\n            return 'mysql';\n        }\n\n        private function getDefaultPort(string $driver): int\n        {\n            switch ($driver) {\n                case 'mysql':\n                    return 3306;\n                case 'pgsql':\n                    return 5432;\n                case 'sqlsrv':\n                    return 1433;\n                case 'sqlite':\n                    return 0;\n            }\n        }\n\n        private function getDefaultAddress(string $driver): string\n        {\n            switch ($driver) {\n                case 'mysql':\n                    return 'localhost';\n                case 'pgsql':\n                    return 'localhost';\n                case 'sqlsrv':\n                    return 'localhost';\n                case 'sqlite':\n                    return 'data.db';\n            }\n        }\n\n        private function getDriverDefaults(string $driver): array\n        {\n            return [\n                'driver' => $driver,\n                'address' => $this->getDefaultAddress($driver),\n                'port' => $this->getDefaultPort($driver),\n            ];\n        }\n\n        private function getEnvironmentVariableName(string $key): string\n        {\n            $prefix = \"PHP_CRUD_API_\";\n            $suffix = strtoupper(preg_replace('/(?<!^)[A-Z]/', '_$0', str_replace('.', '_', $key)));\n            return $prefix . $suffix;\n        }\n\n        public function getProperty(string $key, $default = '')\n        {\n            if (strpos($key, 'Handler')) {\n                return $this->values[$key] ?? $default;\n            }\n            $variableName = $this->getEnvironmentVariableName($key);\n            return getenv($variableName, true) ?: ($this->values[$key] ?? $default);\n        }\n\n        public function __construct(array $values)\n        {\n            $defaults = array_merge($this->values, $this->getDriverDefaults($this->getDefaultDriver($values)));\n            foreach ($defaults as $key => $default) {\n                $this->values[$key] = $values[$key] ?? $default;\n                $this->values[$key] = $this->getProperty($key);\n            }\n            $this->values['middlewares'] = array_map('trim', explode(',', $this->values['middlewares']));\n            foreach ($values as $key => $value) {\n                if (strpos($key, '.') === false) {\n                    if (!isset($defaults[$key])) {\n                        throw new \\Exception(\"Config has invalid key '$key'\");\n                    }\n                } else {\n                    $middleware = substr($key, 0, strpos($key, '.'));\n                    if (!in_array($middleware, $this->values['middlewares'])) {\n                        throw new \\Exception(\"Config has invalid middleware key '$key'\");\n                    } else {\n                        $this->values[$key] = $value;\n                    }\n                }\n            }\n        }\n\n        public function getDriver(): string\n        {\n            return $this->values['driver'];\n        }\n\n        public function getAddress(): string\n        {\n            return $this->values['address'];\n        }\n\n        public function getPort(): int\n        {\n            return $this->values['port'];\n        }\n\n        public function getUsername(): string\n        {\n            return $this->values['username'];\n        }\n\n        public function getPassword(): string\n        {\n            return $this->values['password'];\n        }\n\n        public function getDatabase(): string\n        {\n            return $this->values['database'];\n        }\n\n        public function getCommand(): string\n        {\n            return $this->values['command'];\n        }\n\n        public function getTables(): array\n        {\n            return array_filter(array_map('trim', explode(',', $this->values['tables'])));\n        }\n\n        public function getMapping(): array\n        {\n            $mapping = array_map(function ($v) {\n                return explode('=', $v);\n            }, array_filter(array_map('trim', explode(',', $this->values['mapping']))));\n            return array_combine(array_column($mapping, 0), array_column($mapping, 1));\n        }\n\n        public function getMiddlewares(): array\n        {\n            return $this->values['middlewares'];\n        }\n\n        public function getControllers(): array\n        {\n            return array_filter(array_map('trim', explode(',', $this->values['controllers'])));\n        }\n\n        public function getCustomControllers(): array\n        {\n            return array_filter(array_map('trim', explode(',', $this->values['customControllers'])));\n        }\n\n        public function getCustomOpenApiBuilders(): array\n        {\n            return array_filter(array_map('trim', explode(',', $this->values['customOpenApiBuilders'])));\n        }\n\n        public function getCacheType(): string\n        {\n            return $this->values['cacheType'];\n        }\n\n        public function getCachePath(): string\n        {\n            return $this->values['cachePath'];\n        }\n\n        public function getCacheTime(): int\n        {\n            return $this->values['cacheTime'];\n        }\n\n        public function getJsonOptions(): int\n        {\n            return $this->values['jsonOptions'];\n        }\n\n        public function getDebug(): bool\n        {\n            return $this->values['debug'];\n        }\n\n        public function getBasePath(): string\n        {\n            return $this->values['basePath'];\n        }\n\n        public function getOpenApiBase(): array\n        {\n            return json_decode($this->values['openApiBase'], true);\n        }\n\n        public function getGeometrySrid(): int\n        {\n            return $this->values['geometrySrid'];\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/CacheController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Cache\\Cache;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n\n    class CacheController\n    {\n        private $cache;\n        private $responder;\n\n        public function __construct(Router $router, Responder $responder, Cache $cache)\n        {\n            $router->register('GET', '/cache/clear', array($this, 'clear'));\n            $this->cache = $cache;\n            $this->responder = $responder;\n        }\n\n        public function clear(ServerRequestInterface $request): ResponseInterface\n        {\n            return $this->responder->success($this->cache->clear());\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/ColumnController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Column\\DefinitionService;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class ColumnController\n    {\n        private $responder;\n        private $reflection;\n        private $definition;\n\n        public function __construct(Router $router, Responder $responder, ReflectionService $reflection, DefinitionService $definition)\n        {\n            $router->register('GET', '/columns', array($this, 'getDatabase'));\n            $router->register('GET', '/columns/*', array($this, 'getTable'));\n            $router->register('GET', '/columns/*/*', array($this, 'getColumn'));\n            $router->register('PUT', '/columns/*', array($this, 'updateTable'));\n            $router->register('PUT', '/columns/*/*', array($this, 'updateColumn'));\n            $router->register('POST', '/columns', array($this, 'addTable'));\n            $router->register('POST', '/columns/*', array($this, 'addColumn'));\n            $router->register('DELETE', '/columns/*', array($this, 'removeTable'));\n            $router->register('DELETE', '/columns/*/*', array($this, 'removeColumn'));\n            $this->responder = $responder;\n            $this->reflection = $reflection;\n            $this->definition = $definition;\n        }\n\n        public function getDatabase(ServerRequestInterface $request): ResponseInterface\n        {\n            $tables = [];\n            foreach ($this->reflection->getTableNames() as $table) {\n                $tables[] = $this->reflection->getTable($table);\n            }\n            $database = ['tables' => $tables];\n            return $this->responder->success($database);\n        }\n\n        public function getTable(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            return $this->responder->success($table);\n        }\n\n        public function getColumn(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            $columnName = RequestUtils::getPathSegment($request, 3);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            if (!$table->hasColumn($columnName)) {\n                return $this->responder->error(ErrorCode::COLUMN_NOT_FOUND, $columnName);\n            }\n            $column = $table->getColumn($columnName);\n            return $this->responder->success($column);\n        }\n\n        public function updateTable(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            $success = $this->definition->updateTable($table, $request->getParsedBody());\n            if ($success) {\n                $this->reflection->refreshTables();\n            }\n            return $this->responder->success($success);\n        }\n\n        public function updateColumn(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            $columnName = RequestUtils::getPathSegment($request, 3);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            if (!$table->hasColumn($columnName)) {\n                return $this->responder->error(ErrorCode::COLUMN_NOT_FOUND, $columnName);\n            }\n            $column = $table->getColumn($columnName);\n            $success = $this->definition->updateColumn($table, $column, $request->getParsedBody());\n            if ($success) {\n                $this->reflection->refreshTable($tableName);\n            }\n            return $this->responder->success($success);\n        }\n\n        public function addTable(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = $request->getParsedBody()->name;\n            if ($this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_ALREADY_EXISTS, $tableName);\n            }\n            $success = $this->definition->addTable($request->getParsedBody());\n            if ($success) {\n                $this->reflection->refreshTables();\n            }\n            return $this->responder->success($success);\n        }\n\n        public function addColumn(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $columnName = $request->getParsedBody()->name;\n            $table = $this->reflection->getTable($tableName);\n            if ($table->hasColumn($columnName)) {\n                return $this->responder->error(ErrorCode::COLUMN_ALREADY_EXISTS, $columnName);\n            }\n            $success = $this->definition->addColumn($table, $request->getParsedBody());\n            if ($success) {\n                $this->reflection->refreshTable($tableName);\n            }\n            return $this->responder->success($success);\n        }\n\n        public function removeTable(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            $success = $this->definition->removeTable($table);\n            if ($success) {\n                $this->reflection->refreshTables();\n            }\n            return $this->responder->success($success);\n        }\n\n        public function removeColumn(ServerRequestInterface $request): ResponseInterface\n        {\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            $columnName = RequestUtils::getPathSegment($request, 3);\n            if (!$this->reflection->hasTable($tableName)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $tableName);\n            }\n            $table = $this->reflection->getTable($tableName);\n            if (!$table->hasColumn($columnName)) {\n                return $this->responder->error(ErrorCode::COLUMN_NOT_FOUND, $columnName);\n            }\n            $column = $table->getColumn($columnName);\n            $success = $this->definition->removeColumn($table, $column);\n            if ($success) {\n                $this->reflection->refreshTable($tableName);\n            }\n            return $this->responder->success($success);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/GeoJsonController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\GeoJson\\GeoJsonService;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class GeoJsonController\n    {\n        private $service;\n        private $responder;\n\n        public function __construct(Router $router, Responder $responder, GeoJsonService $service)\n        {\n            $router->register('GET', '/geojson/*', array($this, '_list'));\n            $router->register('GET', '/geojson/*/*', array($this, 'read'));\n            $this->service = $service;\n            $this->responder = $responder;\n        }\n\n        public function _list(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            $params = RequestUtils::getParams($request);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            return $this->responder->success($this->service->_list($table, $params));\n        }\n\n        public function read(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if ($this->service->getType($table) != 'table') {\n                return $this->responder->error(ErrorCode::OPERATION_NOT_SUPPORTED, __FUNCTION__);\n            }\n            $id = RequestUtils::getPathSegment($request, 3);\n            $params = RequestUtils::getParams($request);\n            if (strpos($id, ',') !== false) {\n                $ids = explode(',', $id);\n                $result = (object) array('type' => 'FeatureCollection', 'features' => array());\n                for ($i = 0; $i < count($ids); $i++) {\n                    array_push($result->features, $this->service->read($table, $ids[$i], $params));\n                }\n                return $this->responder->success($result);\n            } else {\n                $response = $this->service->read($table, $id, $params);\n                if ($response === null) {\n                    return $this->responder->error(ErrorCode::RECORD_NOT_FOUND, $id);\n                }\n                return $this->responder->success($response);\n            }\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/JsonResponder.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Tqdev\\PhpCrudApi\\Record\\Document\\ErrorDocument;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n    use Tqdev\\PhpCrudApi\\ResponseUtils;\n\n    class JsonResponder implements Responder\n    {\n        private $jsonOptions;\n        private $debug;\n\n        public function __construct(int $jsonOptions, bool $debug)\n        {\n            $this->jsonOptions = $jsonOptions;\n            $this->debug = $debug;\n        }\n\n        public function error(int $error, string $argument, $details = null): ResponseInterface\n        {\n            $document = new ErrorDocument(new ErrorCode($error), $argument, $details);\n            return ResponseFactory::fromObject($document->getStatus(), $document, $this->jsonOptions);\n        }\n\n        public function success($result): ResponseInterface\n        {\n            return ResponseFactory::fromObject(ResponseFactory::OK, $result, $this->jsonOptions);\n        }\n\n        public function exception($exception): ResponseInterface\n        {\n            $document = ErrorDocument::fromException($exception, $this->debug);\n            $response = ResponseFactory::fromObject($document->getStatus(), $document, $this->jsonOptions);\n            if ($this->debug) {\n                $response = ResponseUtils::addExceptionHeaders($response, $exception);\n            }\n            return $response;\n        }\n\n        public function multi($results): ResponseInterface\n        {\n            $documents = array();\n            $errors = array();\n            $success = true;\n            foreach ($results as $i => $result) {\n                if ($result instanceof \\Throwable) {\n                    $documents[$i] = null;\n                    $errors[$i] = ErrorDocument::fromException($result, $this->debug);\n                    $success = false;\n                } else {\n                    $documents[$i] = $result;\n                    $errors[$i] = new ErrorDocument(new ErrorCode(0), '', null);\n                }\n            }\n            $status = $success ? ResponseFactory::OK : ResponseFactory::FAILED_DEPENDENCY;\n            $document = $success ? $documents : $errors;\n            $response = ResponseFactory::fromObject($status, $document, $this->jsonOptions);\n            foreach ($results as $i => $result) {\n                if ($result instanceof \\Throwable) {\n                    if ($this->debug) {\n                        $response = ResponseUtils::addExceptionHeaders($response, $result);\n                    }\n                }\n            }\n            return $response;\n        }\n\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/OpenApiController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiService;\n\n    class OpenApiController\n    {\n        private $openApi;\n        private $responder;\n\n        public function __construct(Router $router, Responder $responder, OpenApiService $openApi)\n        {\n            $router->register('GET', '/openapi', array($this, 'openapi'));\n            $this->openApi = $openApi;\n            $this->responder = $responder;\n        }\n\n        public function openapi(ServerRequestInterface $request): ResponseInterface\n        {\n            return $this->responder->success($this->openApi->get($request));\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/RecordController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\Record\\RecordService;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class RecordController\n    {\n        private $service;\n        private $responder;\n\n        public function __construct(Router $router, Responder $responder, RecordService $service)\n        {\n            $router->register('GET', '/records/*', array($this, '_list'));\n            $router->register('POST', '/records/*', array($this, 'create'));\n            $router->register('GET', '/records/*/*', array($this, 'read'));\n            $router->register('PUT', '/records/*/*', array($this, 'update'));\n            $router->register('DELETE', '/records/*/*', array($this, 'delete'));\n            $router->register('PATCH', '/records/*/*', array($this, 'increment'));\n            $this->service = $service;\n            $this->responder = $responder;\n        }\n\n        public function _list(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            $params = RequestUtils::getParams($request);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            return $this->responder->success($this->service->_list($table, $params));\n        }\n\n        public function read(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if (!$this->service->hasPrimaryKey($table)) {\n                return $this->responder->error(ErrorCode::PRIMARY_KEY_NOT_FOUND, $table);\n            }\n            $id = RequestUtils::getPathSegment($request, 3);\n            $params = RequestUtils::getParams($request);\n            if (strpos($id, ',') !== false) {\n                $ids = explode(',', $id);\n                $argumentLists = array();\n                for ($i = 0; $i < count($ids); $i++) {\n                    $argumentLists[] = array($table, $ids[$i], $params);\n                }\n                return $this->responder->multi($this->multiCall([$this->service, 'read'], $argumentLists));\n            } else {\n                $response = $this->service->read($table, $id, $params);\n                if ($response === null) {\n                    return $this->responder->error(ErrorCode::RECORD_NOT_FOUND, $id);\n                }\n                return $this->responder->success($response);\n            }\n        }\n\n        private function multiCall(callable $method, array $argumentLists): array\n        {\n            $result = array();\n            $success = true;\n            $this->service->beginTransaction();\n            foreach ($argumentLists as $arguments) {\n                try {\n                    $result[] = call_user_func_array($method, $arguments);\n                } catch (\\Throwable $e) {\n                    $success = false;\n                    $result[] = $e;\n                }\n            }\n            if ($success) {\n                $this->service->commitTransaction();\n            } else {\n                $this->service->rollBackTransaction();\n            }\n            return $result;\n        }\n\n        public function create(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if (!$this->service->hasPrimaryKey($table)) {\n                return $this->responder->error(ErrorCode::PRIMARY_KEY_NOT_FOUND, $table);\n            }\n            if ($this->service->getType($table) != 'table') {\n                return $this->responder->error(ErrorCode::OPERATION_NOT_SUPPORTED, 'create');\n            }\n            $record = $request->getParsedBody();\n            if ($record === null) {\n                return $this->responder->error(ErrorCode::HTTP_MESSAGE_NOT_READABLE, '');\n            }\n            $params = RequestUtils::getParams($request);\n            if (is_array($record)) {\n                $argumentLists = array();\n                foreach ($record as $r) {\n                    $argumentLists[] = array($table, $r, $params);\n                }\n                return $this->responder->multi($this->multiCall([$this->service, 'create'], $argumentLists));\n            } else {\n                return $this->responder->success($this->service->create($table, $record, $params));\n            }\n        }\n\n        public function update(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if (!$this->service->hasPrimaryKey($table)) {\n                return $this->responder->error(ErrorCode::PRIMARY_KEY_NOT_FOUND, $table);\n            }\n            if ($this->service->getType($table) != 'table') {\n                return $this->responder->error(ErrorCode::OPERATION_NOT_SUPPORTED, 'update');\n            }\n            $id = RequestUtils::getPathSegment($request, 3);\n            $params = RequestUtils::getParams($request);\n            $record = $request->getParsedBody();\n            if ($record === null) {\n                return $this->responder->error(ErrorCode::HTTP_MESSAGE_NOT_READABLE, '');\n            }\n            $ids = explode(',', $id);\n            if (is_array($record)) {\n                if (count($ids) != count($record)) {\n                    return $this->responder->error(ErrorCode::ARGUMENT_COUNT_MISMATCH, $id);\n                }\n                $argumentLists = array();\n                for ($i = 0; $i < count($ids); $i++) {\n                    $argumentLists[] = array($table, $ids[$i], $record[$i], $params);\n                }\n                return $this->responder->multi($this->multiCall([$this->service, 'update'], $argumentLists));\n            } else {\n                if (count($ids) != 1) {\n                    return $this->responder->error(ErrorCode::ARGUMENT_COUNT_MISMATCH, $id);\n                }\n                return $this->responder->success($this->service->update($table, $id, $record, $params));\n            }\n        }\n\n        public function delete(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if (!$this->service->hasPrimaryKey($table)) {\n                return $this->responder->error(ErrorCode::PRIMARY_KEY_NOT_FOUND, $table);\n            }\n            if ($this->service->getType($table) != 'table') {\n                return $this->responder->error(ErrorCode::OPERATION_NOT_SUPPORTED, 'delete');\n            }\n            $id = RequestUtils::getPathSegment($request, 3);\n            $params = RequestUtils::getParams($request);\n            $ids = explode(',', $id);\n            if (count($ids) > 1) {\n                $argumentLists = array();\n                for ($i = 0; $i < count($ids); $i++) {\n                    $argumentLists[] = array($table, $ids[$i], $params);\n                }\n                return $this->responder->multi($this->multiCall([$this->service, 'delete'], $argumentLists));\n            } else {\n                return $this->responder->success($this->service->delete($table, $id, $params));\n            }\n        }\n\n        public function increment(ServerRequestInterface $request): ResponseInterface\n        {\n            $table = RequestUtils::getPathSegment($request, 2);\n            if (!$this->service->hasTable($table)) {\n                return $this->responder->error(ErrorCode::TABLE_NOT_FOUND, $table);\n            }\n            if (!$this->service->hasPrimaryKey($table)) {\n                return $this->responder->error(ErrorCode::PRIMARY_KEY_NOT_FOUND, $table);\n            }\n            if ($this->service->getType($table) != 'table') {\n                return $this->responder->error(ErrorCode::OPERATION_NOT_SUPPORTED, 'increment');\n            }\n            $id = RequestUtils::getPathSegment($request, 3);\n            $record = $request->getParsedBody();\n            if ($record === null) {\n                return $this->responder->error(ErrorCode::HTTP_MESSAGE_NOT_READABLE, '');\n            }\n            $params = RequestUtils::getParams($request);\n            $ids = explode(',', $id);\n            if (is_array($record)) {\n                if (count($ids) != count($record)) {\n                    return $this->responder->error(ErrorCode::ARGUMENT_COUNT_MISMATCH, $id);\n                }\n                $argumentLists = array();\n                for ($i = 0; $i < count($ids); $i++) {\n                    $argumentLists[] = array($table, $ids[$i], $record[$i], $params);\n                }\n                return $this->responder->multi($this->multiCall([$this->service, 'increment'], $argumentLists));\n            } else {\n                if (count($ids) != 1) {\n                    return $this->responder->error(ErrorCode::ARGUMENT_COUNT_MISMATCH, $id);\n                }\n                return $this->responder->success($this->service->increment($table, $id, $record, $params));\n            }\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/Responder.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n\n    interface Responder\n    {\n        public function error(int $error, string $argument, $details = null): ResponseInterface;\n\n        public function success($result): ResponseInterface;\n\n        public function multi($results): ResponseInterface;\n\n        public function exception($exception): ResponseInterface;\n\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Controller/StatusController.php\nnamespace Tqdev\\PhpCrudApi\\Controller {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Cache\\Cache;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n\n    class StatusController\n    {\n        private $db;\n        private $cache;\n        private $responder;\n\n        public function __construct(Router $router, Responder $responder, Cache $cache, GenericDB $db)\n        {\n            $router->register('GET', '/status/ping', array($this, 'ping'));\n            $this->db = $db;\n            $this->cache = $cache;\n            $this->responder = $responder;\n        }\n\n        public function ping(ServerRequestInterface $request): ResponseInterface\n        {\n            $result = [\n                'db' => $this->db->ping(),\n                'cache' => $this->cache->ping(),\n            ];\n            return $this->responder->success($result);\n        }\n\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/ColumnConverter.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n\n    class ColumnConverter\n    {\n        private $driver;\n        private $geometrySrid;\n\n        public function __construct(string $driver, int $geometrySrid)\n        {\n            $this->driver = $driver;\n            $this->geometrySrid = $geometrySrid;\n        }\n\n        public function convertColumnValue(ReflectedColumn $column): string\n        {\n            if ($column->isBoolean()) {\n                switch ($this->driver) {\n                    case 'mysql':\n                        return \"IFNULL(IF(?,TRUE,FALSE),NULL)\";\n                    case 'pgsql':\n                        return \"?\";\n                    case 'sqlsrv':\n                        return \"?\";\n                }\n            }\n            if ($column->isBinary()) {\n                switch ($this->driver) {\n                    case 'mysql':\n                        return \"FROM_BASE64(?)\";\n                    case 'pgsql':\n                        return \"decode(?, 'base64')\";\n                    case 'sqlsrv':\n                        return \"CONVERT(XML, ?).value('.','varbinary(max)')\";\n                }\n            }\n            if ($column->isGeometry()) {\n                $srid = $this->geometrySrid;\n                switch ($this->driver) {\n                    case 'mysql':\n                    case 'pgsql':\n                        return \"ST_GeomFromText(?,$srid)\";\n                    case 'sqlsrv':\n                        return \"geometry::STGeomFromText(?,$srid)\";\n                }\n            }\n            return '?';\n        }\n\n        public function convertColumnName(ReflectedColumn $column, $value): string\n        {\n            if ($column->isBinary()) {\n                switch ($this->driver) {\n                    case 'mysql':\n                        return \"TO_BASE64($value) as $value\";\n                    case 'pgsql':\n                        return \"encode($value::bytea, 'base64') as $value\";\n                    case 'sqlsrv':\n                        return \"CASE WHEN $value IS NULL THEN NULL ELSE (SELECT CAST($value as varbinary(max)) FOR XML PATH(''), BINARY BASE64) END as $value\";\n                }\n            }\n            if ($column->isGeometry()) {\n                switch ($this->driver) {\n                    case 'mysql':\n                    case 'pgsql':\n                        return \"ST_AsText($value) as $value\";\n                    case 'sqlsrv':\n                        return \"REPLACE($value.STAsText(),' (','(') as $value\";\n                }\n            }\n            return $value;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/ColumnsBuilder.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n\n    class ColumnsBuilder\n    {\n        private $driver;\n        private $converter;\n\n        public function __construct(string $driver, int $geometrySrid)\n        {\n            $this->driver = $driver;\n            $this->converter = new ColumnConverter($driver, $geometrySrid);\n        }\n\n        public function getOffsetLimit(int $offset, int $limit): string\n        {\n            if ($limit < 0 || $offset < 0) {\n                return '';\n            }\n            switch ($this->driver) {\n                case 'mysql':\n                    return \" LIMIT $offset, $limit\";\n                case 'pgsql':\n                    return \" LIMIT $limit OFFSET $offset\";\n                case 'sqlsrv':\n                    return \" OFFSET $offset ROWS FETCH NEXT $limit ROWS ONLY\";\n                case 'sqlite':\n                    return \" LIMIT $limit OFFSET $offset\";\n            }\n        }\n\n        private function quoteColumnName(ReflectedColumn $column): string\n        {\n            return '\"' . $column->getRealName() . '\"';\n        }\n\n        public function getOrderBy(ReflectedTable $table, array $columnOrdering): string\n        {\n            if (count($columnOrdering) == 0) {\n                return '';\n            }\n            $results = array();\n            foreach ($columnOrdering as $i => list($columnName, $ordering)) {\n                $column = $table->getColumn($columnName);\n                $quotedColumnName = $this->quoteColumnName($column);\n                $results[] = $quotedColumnName . ' ' . $ordering;\n            }\n            return ' ORDER BY ' . implode(',', $results);\n        }\n\n        public function getSelect(ReflectedTable $table, array $columnNames): string\n        {\n            $results = array();\n            foreach ($columnNames as $columnName) {\n                $column = $table->getColumn($columnName);\n                $quotedColumnName = $this->quoteColumnName($column);\n                $quotedColumnName = $this->converter->convertColumnName($column, $quotedColumnName);\n                $results[] = $quotedColumnName;\n            }\n            return implode(',', $results);\n        }\n\n        public function getInsert(ReflectedTable $table, array $columnValues): string\n        {\n            $columns = array();\n            $values = array();\n            foreach ($columnValues as $columnName => $columnValue) {\n                $column = $table->getColumn($columnName);\n                $quotedColumnName = $this->quoteColumnName($column);\n                $columns[] = $quotedColumnName;\n                $columnValue = $this->converter->convertColumnValue($column);\n                $values[] = $columnValue;\n            }\n            $columnsSql = '(' . implode(',', $columns) . ')';\n            $valuesSql = '(' . implode(',', $values) . ')';\n            $outputColumn = $this->quoteColumnName($table->getPk());\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"$columnsSql VALUES $valuesSql\";\n                case 'pgsql':\n                    return \"$columnsSql VALUES $valuesSql RETURNING $outputColumn\";\n                case 'sqlsrv':\n                    return \"$columnsSql OUTPUT INSERTED.$outputColumn VALUES $valuesSql\";\n                case 'sqlite':\n                    return \"$columnsSql VALUES $valuesSql\";\n            }\n        }\n\n        public function getUpdate(ReflectedTable $table, array $columnValues): string\n        {\n            $results = array();\n            foreach ($columnValues as $columnName => $columnValue) {\n                $column = $table->getColumn($columnName);\n                $quotedColumnName = $this->quoteColumnName($column);\n                $columnValue = $this->converter->convertColumnValue($column);\n                $results[] = $quotedColumnName . '=' . $columnValue;\n            }\n            return implode(',', $results);\n        }\n\n        public function getIncrement(ReflectedTable $table, array $columnValues): string\n        {\n            $results = array();\n            foreach ($columnValues as $columnName => $columnValue) {\n                if (!is_numeric($columnValue)) {\n                    continue;\n                }\n                $column = $table->getColumn($columnName);\n                $quotedColumnName = $this->quoteColumnName($column);\n                $columnValue = $this->converter->convertColumnValue($column);\n                $results[] = $quotedColumnName . '=' . $quotedColumnName . '+' . $columnValue;\n            }\n            return implode(',', $results);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/ConditionsBuilder.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\AndCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\Condition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\NoCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\NotCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\OrCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\SpatialCondition;\n\n    class ConditionsBuilder\n    {\n        private $driver;\n        private $geometrySrid;\n\n        public function __construct(string $driver, int $geometrySrid)\n        {\n            $this->driver = $driver;\n            $this->geometrySrid = $geometrySrid;\n        }\n\n        private function getConditionSql(Condition $condition, array &$arguments): string\n        {\n            if ($condition instanceof AndCondition) {\n                return $this->getAndConditionSql($condition, $arguments);\n            }\n            if ($condition instanceof OrCondition) {\n                return $this->getOrConditionSql($condition, $arguments);\n            }\n            if ($condition instanceof NotCondition) {\n                return $this->getNotConditionSql($condition, $arguments);\n            }\n            if ($condition instanceof SpatialCondition) {\n                return $this->getSpatialConditionSql($condition, $arguments);\n            }\n            if ($condition instanceof ColumnCondition) {\n                return $this->getColumnConditionSql($condition, $arguments);\n            }\n            throw new \\Exception('Unknown Condition: ' . get_class($condition));\n        }\n\n        private function getAndConditionSql(AndCondition $and, array &$arguments): string\n        {\n            $parts = [];\n            foreach ($and->getConditions() as $condition) {\n                $parts[] = $this->getConditionSql($condition, $arguments);\n            }\n            return '(' . implode(' AND ', $parts) . ')';\n        }\n\n        private function getOrConditionSql(OrCondition $or, array &$arguments): string\n        {\n            $parts = [];\n            foreach ($or->getConditions() as $condition) {\n                $parts[] = $this->getConditionSql($condition, $arguments);\n            }\n            return '(' . implode(' OR ', $parts) . ')';\n        }\n\n        private function getNotConditionSql(NotCondition $not, array &$arguments): string\n        {\n            $condition = $not->getCondition();\n            return '(NOT ' . $this->getConditionSql($condition, $arguments) . ')';\n        }\n\n        private function quoteColumnName(ReflectedColumn $column): string\n        {\n            return '\"' . $column->getRealName() . '\"';\n        }\n\n        private function escapeLikeValue(string $value): string\n        {\n            return addcslashes($value, '%_');\n        }\n\n        private function getColumnConditionSql(ColumnCondition $condition, array &$arguments): string\n        {\n            $column = $this->quoteColumnName($condition->getColumn());\n            $operator = $condition->getOperator();\n            $value = $condition->getValue();\n            switch ($operator) {\n                case 'cs':\n                    $sql = \"$column LIKE ?\";\n                    $arguments[] = '%' . $this->escapeLikeValue($value) . '%';\n                    break;\n                case 'sw':\n                    $sql = \"$column LIKE ?\";\n                    $arguments[] = $this->escapeLikeValue($value) . '%';\n                    break;\n                case 'ew':\n                    $sql = \"$column LIKE ?\";\n                    $arguments[] = '%' . $this->escapeLikeValue($value);\n                    break;\n                case 'eq':\n                    $sql = \"$column = ?\";\n                    $arguments[] = $value;\n                    break;\n                case 'lt':\n                    $sql = \"$column < ?\";\n                    $arguments[] = $value;\n                    break;\n                case 'le':\n                    $sql = \"$column <= ?\";\n                    $arguments[] = $value;\n                    break;\n                case 'ge':\n                    $sql = \"$column >= ?\";\n                    $arguments[] = $value;\n                    break;\n                case 'gt':\n                    $sql = \"$column > ?\";\n                    $arguments[] = $value;\n                    break;\n                case 'bt':\n                    $parts = explode(',', $value, 2);\n                    $count = count($parts);\n                    if ($count == 2) {\n                        $sql = \"($column >= ? AND $column <= ?)\";\n                        $arguments[] = $parts[0];\n                        $arguments[] = $parts[1];\n                    } else {\n                        $sql = \"FALSE\";\n                    }\n                    break;\n                case 'in':\n                    $parts = explode(',', $value);\n                    $count = count($parts);\n                    if ($count > 0) {\n                        $qmarks = implode(',', str_split(str_repeat('?', $count)));\n                        $sql = \"$column IN ($qmarks)\";\n                        for ($i = 0; $i < $count; $i++) {\n                            $arguments[] = $parts[$i];\n                        }\n                    } else {\n                        $sql = \"FALSE\";\n                    }\n                    break;\n                case 'is':\n                    $sql = \"$column IS NULL\";\n                    break;\n            }\n            return $sql;\n        }\n\n        private function getSpatialFunctionName(string $operator): string\n        {\n            switch ($operator) {\n                case 'co':\n                    return 'ST_Contains';\n                case 'cr':\n                    return 'ST_Crosses';\n                case 'di':\n                    return 'ST_Disjoint';\n                case 'eq':\n                    return 'ST_Equals';\n                case 'in':\n                    return 'ST_Intersects';\n                case 'ov':\n                    return 'ST_Overlaps';\n                case 'to':\n                    return 'ST_Touches';\n                case 'wi':\n                    return 'ST_Within';\n                case 'ic':\n                    return 'ST_IsClosed';\n                case 'is':\n                    return 'ST_IsSimple';\n                case 'iv':\n                    return 'ST_IsValid';\n            }\n        }\n\n        private function hasSpatialArgument(string $operator): bool\n        {\n            return in_array($operator, ['ic', 'is', 'iv']) ? false : true;\n        }\n\n        private function getSpatialFunctionCall(string $functionName, string $column, bool $hasArgument): string\n        {\n            $srid = $this->geometrySrid;\n            switch ($this->driver) {\n                case 'mysql':\n                case 'pgsql':\n                    $argument = $hasArgument ? \"ST_GeomFromText(?,$srid)\" : '';\n                    return \"$functionName($column, $argument)=TRUE\";\n                case 'sqlsrv':\n                    $functionName = str_replace('ST_', 'ST', $functionName);\n                    $argument = $hasArgument ? \"geometry::STGeomFromText(?,$srid)\" : '';\n                    return \"$column.$functionName($argument)=1\";\n                case 'sqlite':\n                    $argument = $hasArgument ? '?' : '0';\n                    return \"$functionName($column, $argument)=1\";\n            }\n        }\n\n        private function getSpatialConditionSql(ColumnCondition $condition, array &$arguments): string\n        {\n            $column = $this->quoteColumnName($condition->getColumn());\n            $operator = $condition->getOperator();\n            $value = $condition->getValue();\n            $functionName = $this->getSpatialFunctionName($operator);\n            $hasArgument = $this->hasSpatialArgument($operator);\n            $sql = $this->getSpatialFunctionCall($functionName, $column, $hasArgument);\n            if ($hasArgument) {\n                $arguments[] = $value;\n            }\n            return $sql;\n        }\n\n        public function getWhereClause(Condition $condition, array &$arguments): string\n        {\n            if ($condition instanceof NoCondition) {\n                return '';\n            }\n            return ' WHERE ' . $this->getConditionSql($condition, $arguments);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/DataConverter.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n\n    class DataConverter\n    {\n        private $driver;\n\n        public function __construct(string $driver)\n        {\n            $this->driver = $driver;\n        }\n\n        private function convertRecordValue($conversion, $value)\n        {\n            $args = explode('|', $conversion);\n            $type = array_shift($args);\n            switch ($type) {\n                case 'boolean':\n                    return $value ? true : false;\n                case 'integer':\n                    return (int) $value;\n                case 'float':\n                    return (float) $value;\n                case 'decimal':\n                    return number_format($value, $args[0], '.', '');\n            }\n            return $value;\n        }\n\n        private function getRecordValueConversion(ReflectedColumn $column): string\n        {\n            if ($column->isBoolean()) {\n                return 'boolean';\n            }\n            if (in_array($column->getType(), ['integer', 'bigint'])) {\n                return 'integer';\n            }\n            if (in_array($column->getType(), ['float', 'double'])) {\n                return 'float';\n            }\n            if (in_array($this->driver, ['sqlite']) && in_array($column->getType(), ['decimal'])) {\n                return 'decimal|' . $column->getScale();\n            }\n            return 'none';\n        }\n\n        public function convertRecords(ReflectedTable $table, array $columnNames, array &$records) /*: void*/\n        {\n            foreach ($columnNames as $columnName) {\n                $column = $table->getColumn($columnName);\n                $conversion = $this->getRecordValueConversion($column);\n                if ($conversion != 'none') {\n                    foreach ($records as $i => $record) {\n                        $value = $records[$i][$columnName];\n                        if ($value === null) {\n                            continue;\n                        }\n                        $records[$i][$columnName] = $this->convertRecordValue($conversion, $value);\n                    }\n                }\n            }\n        }\n\n        private function convertInputValue($conversion, $value)\n        {\n            switch ($conversion) {\n                case 'boolean':\n                    return filter_var($value, FILTER_VALIDATE_BOOLEAN) ? 1 : 0;\n                case 'base64url_to_base64':\n                    return str_pad(strtr($value, '-_', '+/'), ceil(strlen($value) / 4) * 4, '=', STR_PAD_RIGHT);\n            }\n            return $value;\n        }\n\n        private function getInputValueConversion(ReflectedColumn $column): string\n        {\n            if ($column->isBoolean()) {\n                return 'boolean';\n            }\n            if ($column->isBinary()) {\n                return 'base64url_to_base64';\n            }\n            return 'none';\n        }\n\n        public function convertColumnValues(ReflectedTable $table, array &$columnValues) /*: void*/\n        {\n            $columnNames = array_keys($columnValues);\n            foreach ($columnNames as $columnName) {\n                $column = $table->getColumn($columnName);\n                $conversion = $this->getInputValueConversion($column);\n                if ($conversion != 'none') {\n                    $value = $columnValues[$columnName];\n                    if ($value !== null) {\n                        $columnValues[$columnName] = $this->convertInputValue($conversion, $value);\n                    }\n                }\n            }\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/GenericDB.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\Condition;\n\n    class GenericDB\n    {\n        private $driver;\n        private $address;\n        private $port;\n        private $database;\n        private $command;\n        private $tables;\n        private $mapping;\n        private $username;\n        private $password;\n        private $pdo;\n        private $mapper;\n        private $reflection;\n        private $definition;\n        private $conditions;\n        private $columns;\n        private $converter;\n        private $geometrySrid;\n\n        private function getDsn(): string\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"$this->driver:host=$this->address;port=$this->port;dbname=$this->database;charset=utf8mb4\";\n                case 'pgsql':\n                    return \"$this->driver:host=$this->address port=$this->port dbname=$this->database options='--client_encoding=UTF8'\";\n                case 'sqlsrv':\n                    return \"$this->driver:Server=$this->address,$this->port;Database=$this->database\";\n                case 'sqlite':\n                    return \"$this->driver:$this->address\";\n            }\n        }\n\n        private function getCommands(): array\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    $commands = [\n                        'SET SESSION sql_warnings=1;',\n                        'SET NAMES utf8mb4;',\n                        'SET SESSION sql_mode = \"ANSI,TRADITIONAL\";',\n                    ];\n                    break;\n                case 'pgsql':\n                    $commands = [\n                        \"SET NAMES 'UTF8';\",\n                    ];\n                    break;\n                case 'sqlsrv':\n                    $commands = [];\n                    break;\n                case 'sqlite':\n                    $commands = [\n                        'PRAGMA foreign_keys = on;',\n                    ];\n                    break;\n            }\n            if ($this->command != '') {\n                $commands[] = $this->command;\n            }\n            return $commands;\n        }\n\n        private function getOptions(): array\n        {\n            $options = array(\n                \\PDO::ATTR_ERRMODE => \\PDO::ERRMODE_EXCEPTION,\n                \\PDO::ATTR_DEFAULT_FETCH_MODE => \\PDO::FETCH_ASSOC,\n            );\n            switch ($this->driver) {\n                case 'mysql':\n                    return $options + [\n                        \\PDO::MYSQL_ATTR_FOUND_ROWS => true,\n                        \\PDO::ATTR_PERSISTENT => true,\n                    ];\n                case 'pgsql':\n                    return $options + [\n                        \\PDO::ATTR_PERSISTENT => true,\n                    ];\n                case 'sqlsrv':\n                    return $options + [];\n                case 'sqlite':\n                    return $options + [];\n            }\n        }\n\n        private function initPdo(): bool\n        {\n            if ($this->pdo) {\n                $result = $this->pdo->reconstruct($this->getDsn(), $this->username, $this->password, $this->getOptions());\n            } else {\n                $this->pdo = new LazyPdo($this->getDsn(), $this->username, $this->password, $this->getOptions());\n                $result = true;\n            }\n            $commands = $this->getCommands();\n            foreach ($commands as $command) {\n                $this->pdo->addInitCommand($command);\n            }\n            $this->mapper = new RealNameMapper($this->mapping);\n            $this->reflection = new GenericReflection($this->pdo, $this->driver, $this->database, $this->tables, $this->mapper);\n            $this->definition = new GenericDefinition($this->pdo, $this->driver, $this->database, $this->tables, $this->mapper);\n            $this->conditions = new ConditionsBuilder($this->driver, $this->geometrySrid);\n            $this->columns = new ColumnsBuilder($this->driver, $this->geometrySrid);\n            $this->converter = new DataConverter($this->driver);\n            return $result;\n        }\n\n        public function __construct(string $driver, string $address, int $port, string $database, string $command, array $tables, array $mapping, string $username, string $password, int $geometrySrid)\n        {\n            $this->driver = $driver;\n            $this->address = $address;\n            $this->port = $port;\n            $this->database = $database;\n            $this->command = $command;\n            $this->tables = $tables;\n            $this->mapping = $mapping;\n            $this->username = $username;\n            $this->password = $password;\n            $this->geometrySrid = $geometrySrid;\n            $this->initPdo();\n        }\n\n        public function reconstruct(string $driver, string $address, int $port, string $database, string $command, array $tables, array $mapping, string $username, string $password, int $geometrySrid): bool\n        {\n            if ($driver) {\n                $this->driver = $driver;\n            }\n            if ($address) {\n                $this->address = $address;\n            }\n            if ($port) {\n                $this->port = $port;\n            }\n            if ($database) {\n                $this->database = $database;\n            }\n            if ($command) {\n                $this->command = $command;\n            }\n            if ($tables) {\n                $this->tables = $tables;\n            }\n            if ($mapping) {\n                $this->mapping = $mapping;\n            }\n            if ($username) {\n                $this->username = $username;\n            }\n            if ($password) {\n                $this->password = $password;\n            }\n            if ($geometrySrid) {\n                $this->geometrySrid = $geometrySrid;\n            }\n            return $this->initPdo();\n        }\n\n        public function pdo(): LazyPdo\n        {\n            return $this->pdo;\n        }\n\n        public function reflection(): GenericReflection\n        {\n            return $this->reflection;\n        }\n\n        public function definition(): GenericDefinition\n        {\n            return $this->definition;\n        }\n\n        public function beginTransaction() /*: void*/\n        {\n            $this->pdo->beginTransaction();\n        }\n\n        public function commitTransaction() /*: void*/\n        {\n            $this->pdo->commit();\n        }\n\n        public function rollBackTransaction() /*: void*/\n        {\n            $this->pdo->rollBack();\n        }\n\n        private function addMiddlewareConditions(string $tableName, Condition $condition): Condition\n        {\n            $condition1 = VariableStore::get(\"authorization.conditions.$tableName\");\n            if ($condition1) {\n                $condition = $condition->_and($condition1);\n            }\n            $condition2 = VariableStore::get(\"multiTenancy.conditions.$tableName\");\n            if ($condition2) {\n                $condition = $condition->_and($condition2);\n            }\n            return $condition;\n        }\n\n        public function createSingle(ReflectedTable $table, array $columnValues) /*: ?String*/\n        {\n            $this->converter->convertColumnValues($table, $columnValues);\n            $insertColumns = $this->columns->getInsert($table, $columnValues);\n            $tableRealName = $table->getRealName();\n            $pkName = $table->getPk()->getName();\n            $parameters = array_values($columnValues);\n            $sql = 'INSERT INTO \"' . $tableRealName . '\" ' . $insertColumns;\n            $stmt = $this->query($sql, $parameters);\n            // return primary key value if specified in the input\n            if (isset($columnValues[$pkName])) {\n                return $columnValues[$pkName];\n            }\n            // work around missing \"returning\" or \"output\" in mysql\n            switch ($this->driver) {\n                case 'mysql':\n                    $stmt = $this->query('SELECT LAST_INSERT_ID()', []);\n                    break;\n                case 'sqlite':\n                    $stmt = $this->query('SELECT LAST_INSERT_ROWID()', []);\n                    break;\n            }\n            $pkValue = $stmt->fetchColumn(0);\n            if ($table->getPk()->getType() == 'bigint') {\n                return (int) $pkValue;\n            }\n            if (in_array($table->getPk()->getType(), ['integer', 'bigint'])) {\n                return (int) $pkValue;\n            }\n            return $pkValue;\n        }\n\n        public function selectSingle(ReflectedTable $table, array $columnNames, string $id) /*: ?array*/\n        {\n            $selectColumns = $this->columns->getSelect($table, $columnNames);\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = new ColumnCondition($table->getPk(), 'eq', $id);\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array();\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'SELECT ' . $selectColumns . ' FROM \"' . $tableRealName . '\" ' . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            $record = $stmt->fetch() ?: null;\n            if ($record === null) {\n                return null;\n            }\n            $records = array($record);\n            $records = $this->mapRecords($tableRealName, $records);\n            $this->converter->convertRecords($table, $columnNames, $records);\n            return $records[0];\n        }\n\n        public function selectMultiple(ReflectedTable $table, array $columnNames, array $ids): array\n        {\n            if (count($ids) == 0) {\n                return [];\n            }\n            $selectColumns = $this->columns->getSelect($table, $columnNames);\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = new ColumnCondition($table->getPk(), 'in', implode(',', $ids));\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array();\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'SELECT ' . $selectColumns . ' FROM \"' . $tableRealName . '\" ' . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            $records = $stmt->fetchAll();\n            $records = $this->mapRecords($tableRealName, $records);\n            $this->converter->convertRecords($table, $columnNames, $records);\n            return $records;\n        }\n\n        public function selectCount(ReflectedTable $table, Condition $condition): int\n        {\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array();\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'SELECT COUNT(*) FROM \"' . $tableRealName . '\"' . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            return $stmt->fetchColumn(0);\n        }\n\n        private function mapRecords(string $tableRealName, array $records): array\n        {\n            $mappedRecords = [];\n            foreach ($records as $record) {\n                $mappedRecord = [];\n                foreach ($record as $columnRealName => $columnValue) {\n                    $mappedRecord[$this->mapper->getColumnName($tableRealName, $columnRealName)] = $columnValue;\n                }\n                $mappedRecords[] = $mappedRecord;\n            }\n            return $mappedRecords;\n        }\n\n        public function selectAll(ReflectedTable $table, array $columnNames, Condition $condition, array $columnOrdering, int $offset, int $limit): array\n        {\n            if ($limit == 0) {\n                return array();\n            }\n            $selectColumns = $this->columns->getSelect($table, $columnNames);\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array();\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $orderBy = $this->columns->getOrderBy($table, $columnOrdering);\n            $offsetLimit = $this->columns->getOffsetLimit($offset, $limit);\n            $sql = 'SELECT ' . $selectColumns . ' FROM \"' . $tableRealName . '\"' . $whereClause . $orderBy . $offsetLimit;\n            $stmt = $this->query($sql, $parameters);\n            $records = $stmt->fetchAll();\n            $records = $this->mapRecords($tableRealName, $records);\n            $this->converter->convertRecords($table, $columnNames, $records);\n            return $records;\n        }\n\n        public function updateSingle(ReflectedTable $table, array $columnValues, string $id)\n        {\n            if (count($columnValues) == 0) {\n                return 0;\n            }\n            $this->converter->convertColumnValues($table, $columnValues);\n            $updateColumns = $this->columns->getUpdate($table, $columnValues);\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = new ColumnCondition($table->getPk(), 'eq', $id);\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array_values($columnValues);\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'UPDATE \"' . $tableRealName . '\" SET ' . $updateColumns . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            return $stmt->rowCount();\n        }\n\n        public function deleteSingle(ReflectedTable $table, string $id)\n        {\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = new ColumnCondition($table->getPk(), 'eq', $id);\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array();\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'DELETE FROM \"' . $tableRealName . '\" ' . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            return $stmt->rowCount();\n        }\n\n        public function incrementSingle(ReflectedTable $table, array $columnValues, string $id)\n        {\n            if (count($columnValues) == 0) {\n                return 0;\n            }\n            $this->converter->convertColumnValues($table, $columnValues);\n            $updateColumns = $this->columns->getIncrement($table, $columnValues);\n            $tableName = $table->getName();\n            $tableRealName = $table->getRealName();\n            $condition = new ColumnCondition($table->getPk(), 'eq', $id);\n            $condition = $this->addMiddlewareConditions($tableName, $condition);\n            $parameters = array_values($columnValues);\n            $whereClause = $this->conditions->getWhereClause($condition, $parameters);\n            $sql = 'UPDATE \"' . $tableRealName . '\" SET ' . $updateColumns . $whereClause;\n            $stmt = $this->query($sql, $parameters);\n            return $stmt->rowCount();\n        }\n\n        private function query(string $sql, array $parameters): \\PDOStatement\n        {\n            $stmt = $this->pdo->prepare($sql);\n            //echo \"- $sql -- \" . json_encode($parameters, JSON_UNESCAPED_UNICODE) . \"\\n\";\n            $stmt->execute($parameters);\n            return $stmt;\n        }\n\n        public function ping(): int\n        {\n            $start = microtime(true);\n            $stmt = $this->pdo->prepare('SELECT 1');\n            $stmt->execute();\n            return intval((microtime(true) - $start) * 1000000);\n        }\n\n        public function getCacheKey(): string\n        {\n            return md5(json_encode([\n                $this->driver,\n                $this->address,\n                $this->port,\n                $this->database,\n                $this->tables,\n                $this->mapping,\n                $this->username,\n            ]));\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/GenericDefinition.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Database\\LazyPdo;\n\n    class GenericDefinition\n    {\n        private $pdo;\n        private $driver;\n        private $database;\n        private $typeConverter;\n        private $reflection;\n\n        public function __construct(LazyPdo $pdo, string $driver, string $database, array $tables, RealNameMapper $mapper)\n        {\n            $this->pdo = $pdo;\n            $this->driver = $driver;\n            $this->database = $database;\n            $this->typeConverter = new TypeConverter($driver);\n            $this->reflection = new GenericReflection($pdo, $driver, $database, $tables, $mapper);\n        }\n\n        private function quote(string $identifier): string\n        {\n            return '\"' . str_replace('\"', '', $identifier) . '\"';\n        }\n\n        public function getColumnType(ReflectedColumn $column, bool $update): string\n        {\n            if ($this->driver == 'pgsql' && !$update && $column->getPk() && $this->canAutoIncrement($column)) {\n                return 'serial';\n            }\n            $type = $this->typeConverter->fromJdbc($column->getType());\n            if ($column->hasPrecision() && $column->hasScale()) {\n                $size = '(' . $column->getPrecision() . ',' . $column->getScale() . ')';\n            } elseif ($column->hasPrecision()) {\n                $size = '(' . $column->getPrecision() . ')';\n            } elseif ($column->hasLength()) {\n                $size = '(' . $column->getLength() . ')';\n            } else {\n                $size = '';\n            }\n            $null = $this->getColumnNullType($column, $update);\n            $auto = $this->getColumnAutoIncrement($column, $update);\n            return $type . $size . $null . $auto;\n        }\n\n        private function getPrimaryKey(string $tableName): string\n        {\n            $pks = $this->reflection->getTablePrimaryKeys($tableName);\n            if (count($pks) == 1) {\n                return $pks[0];\n            }\n            return \"\";\n        }\n\n        private function canAutoIncrement(ReflectedColumn $column): bool\n        {\n            return in_array($column->getType(), ['integer', 'bigint']);\n        }\n\n        private function getColumnAutoIncrement(ReflectedColumn $column, bool $update): string\n        {\n            if (!$this->canAutoIncrement($column)) {\n                return '';\n            }\n            switch ($this->driver) {\n                case 'mysql':\n                    return $column->getPk() ? ' AUTO_INCREMENT' : '';\n                case 'pgsql':\n                case 'sqlsrv':\n                    return $column->getPk() ? ' IDENTITY(1,1)' : '';\n                case 'sqlite':\n                    return $column->getPk() ? ' AUTOINCREMENT' : '';\n            }\n        }\n\n        private function getColumnNullType(ReflectedColumn $column, bool $update): string\n        {\n            if ($this->driver == 'pgsql' && $update) {\n                return '';\n            }\n            return $column->getNullable() ? ' NULL' : ' NOT NULL';\n        }\n\n        private function getTableRenameSQL(string $tableName, string $newTableName): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($newTableName);\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"RENAME TABLE $p1 TO $p2\";\n                case 'pgsql':\n                    return \"ALTER TABLE $p1 RENAME TO $p2\";\n                case 'sqlsrv':\n                    return \"EXEC sp_rename $p1, $p2\";\n                case 'sqlite':\n                    return \"ALTER TABLE $p1 RENAME TO $p2\";\n            }\n        }\n\n        private function getColumnRenameSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($newColumn->getRealName());\n\n            switch ($this->driver) {\n                case 'mysql':\n                    $p4 = $this->getColumnType($newColumn, true);\n                    return \"ALTER TABLE $p1 CHANGE $p2 $p3 $p4\";\n                case 'pgsql':\n                    return \"ALTER TABLE $p1 RENAME COLUMN $p2 TO $p3\";\n                case 'sqlsrv':\n                    $p4 = $this->quote($tableName . '.' . $columnName);\n                    return \"EXEC sp_rename $p4, $p3, 'COLUMN'\";\n                case 'sqlite':\n                    return \"ALTER TABLE $p1 RENAME COLUMN $p2 TO $p3\";\n            }\n        }\n\n        private function getColumnRetypeSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($newColumn->getRealName());\n            $p4 = $this->getColumnType($newColumn, true);\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"ALTER TABLE $p1 CHANGE $p2 $p3 $p4\";\n                case 'pgsql':\n                    return \"ALTER TABLE $p1 ALTER COLUMN $p3 TYPE $p4\";\n                case 'sqlsrv':\n                    return \"ALTER TABLE $p1 ALTER COLUMN $p3 $p4\";\n            }\n        }\n\n        private function getSetColumnNullableSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($newColumn->getRealName());\n            $p4 = $this->getColumnType($newColumn, true);\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"ALTER TABLE $p1 CHANGE $p2 $p3 $p4\";\n                case 'pgsql':\n                    $p5 = $newColumn->getNullable() ? 'DROP NOT NULL' : 'SET NOT NULL';\n                    return \"ALTER TABLE $p1 ALTER COLUMN $p2 $p5\";\n                case 'sqlsrv':\n                    return \"ALTER TABLE $p1 ALTER COLUMN $p2 $p4\";\n            }\n        }\n\n        private function getSetColumnPkConstraintSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($tableName . '_pkey');\n\n            switch ($this->driver) {\n                case 'mysql':\n                    $p4 = $newColumn->getPk() ? \"ADD PRIMARY KEY ($p2)\" : 'DROP PRIMARY KEY';\n                    return \"ALTER TABLE $p1 $p4\";\n                case 'pgsql':\n                case 'sqlsrv':\n                    $p4 = $newColumn->getPk() ? \"ADD CONSTRAINT $p3 PRIMARY KEY ($p2)\" : \"DROP CONSTRAINT $p3\";\n                    return \"ALTER TABLE $p1 $p4\";\n            }\n        }\n\n        private function getSetColumnPkSequenceSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($tableName . '_' . $columnName . '_seq');\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"select 1\";\n                case 'pgsql':\n                    return $newColumn->getPk() ? \"CREATE SEQUENCE $p3 OWNED BY $p1.$p2\" : \"DROP SEQUENCE $p3\";\n                case 'sqlsrv':\n                    return $newColumn->getPk() ? \"CREATE SEQUENCE $p3\" : \"DROP SEQUENCE $p3\";\n            }\n        }\n\n        private function getSetColumnPkSequenceStartSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"select 1\";\n                case 'pgsql':\n                    $p3 = $this->pdo->quote($tableName . '_' . $columnName . '_seq');\n                    return \"SELECT setval($p3, (SELECT max($p2)+1 FROM $p1));\";\n                case 'sqlsrv':\n                    $p3 = $this->quote($tableName . '_' . $columnName . '_seq');\n                    $p4 = $this->pdo->query(\"SELECT max($p2)+1 FROM $p1\")->fetchColumn();\n                    return \"ALTER SEQUENCE $p3 RESTART WITH $p4\";\n            }\n        }\n\n        private function getSetColumnPkDefaultSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n\n            switch ($this->driver) {\n                case 'mysql':\n                    $p3 = $this->quote($newColumn->getRealName());\n                    $p4 = $this->getColumnType($newColumn, true);\n                    return \"ALTER TABLE $p1 CHANGE $p2 $p3 $p4\";\n                case 'pgsql':\n                    if ($newColumn->getPk()) {\n                        $p3 = $this->pdo->quote($tableName . '_' . $columnName . '_seq');\n                        $p4 = \"SET DEFAULT nextval($p3)\";\n                    } else {\n                        $p4 = 'DROP DEFAULT';\n                    }\n                    return \"ALTER TABLE $p1 ALTER COLUMN $p2 $p4\";\n                case 'sqlsrv':\n                    $p3 = $this->quote($tableName . '_' . $columnName . '_seq');\n                    $p4 = $this->quote($tableName . '_' . $columnName . '_def');\n                    if ($newColumn->getPk()) {\n                        return \"ALTER TABLE $p1 ADD CONSTRAINT $p4 DEFAULT NEXT VALUE FOR $p3 FOR $p2\";\n                    } else {\n                        return \"ALTER TABLE $p1 DROP CONSTRAINT $p4\";\n                    }\n            }\n        }\n\n        private function getAddColumnFkConstraintSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n            $p3 = $this->quote($tableName . '_' . $columnName . '_fkey');\n            $p4 = $this->quote($newColumn->getFk());\n            $p5 = $this->quote($this->getPrimaryKey($newColumn->getFk()));\n\n            return \"ALTER TABLE $p1 ADD CONSTRAINT $p3 FOREIGN KEY ($p2) REFERENCES $p4 ($p5)\";\n        }\n\n        private function getRemoveColumnFkConstraintSQL(string $tableName, string $columnName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($tableName . '_' . $columnName . '_fkey');\n\n            switch ($this->driver) {\n                case 'mysql':\n                    return \"ALTER TABLE $p1 DROP FOREIGN KEY $p2\";\n                case 'pgsql':\n                case 'sqlsrv':\n                    return \"ALTER TABLE $p1 DROP CONSTRAINT $p2\";\n            }\n        }\n\n        private function getAddTableSQL(ReflectedTable $newTable): string\n        {\n            $tableName = $newTable->getRealName();\n            $p1 = $this->quote($tableName);\n            $fields = [];\n            $constraints = [];\n            foreach ($newTable->getColumnNames() as $columnName) {\n                $pkColumn = $this->getPrimaryKey($tableName);\n                $newColumn = $newTable->getColumn($columnName);\n                $f1 = $this->quote($columnName);\n                $f2 = $this->getColumnType($newColumn, false);\n                $f3 = $this->quote($tableName . '_' . $columnName . '_fkey');\n                $f4 = $this->quote($newColumn->getFk());\n                $f5 = $this->quote($this->getPrimaryKey($newColumn->getFk()));\n                $f6 = $this->quote($tableName . '_' . $pkColumn . '_pkey');\n                if ($this->driver == 'sqlite') {\n                    if ($newColumn->getPk()) {\n                        $f2 = str_replace('NULL', 'NULL PRIMARY KEY', $f2);\n                    }\n                    $fields[] = \"$f1 $f2\";\n                    if ($newColumn->getFk()) {\n                        $constraints[] = \"FOREIGN KEY ($f1) REFERENCES $f4 ($f5)\";\n                    }\n                } else {\n                    $fields[] = \"$f1 $f2\";\n                    if ($newColumn->getPk()) {\n                        $constraints[] = \"CONSTRAINT $f6 PRIMARY KEY ($f1)\";\n                    }\n                    if ($newColumn->getFk()) {\n                        $constraints[] = \"CONSTRAINT $f3 FOREIGN KEY ($f1) REFERENCES $f4 ($f5)\";\n                    }\n                }\n            }\n            $p2 = implode(',', array_merge($fields, $constraints));\n\n            return \"CREATE TABLE $p1 ($p2);\";\n        }\n\n        private function getAddColumnSQL(string $tableName, ReflectedColumn $newColumn): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($newColumn->getRealName());\n            $p3 = $this->getColumnType($newColumn, false);\n\n            switch ($this->driver) {\n                case 'mysql':\n                case 'pgsql':\n                    return \"ALTER TABLE $p1 ADD COLUMN $p2 $p3\";\n                case 'sqlsrv':\n                    return \"ALTER TABLE $p1 ADD $p2 $p3\";\n                case 'sqlite':\n                    return \"ALTER TABLE $p1 ADD COLUMN $p2 $p3\";\n            }\n        }\n\n        private function getRemoveTableSQL(string $tableName): string\n        {\n            $p1 = $this->quote($tableName);\n\n            switch ($this->driver) {\n                case 'mysql':\n                case 'pgsql':\n                    return \"DROP TABLE $p1 CASCADE;\";\n                case 'sqlsrv':\n                    return \"DROP TABLE $p1;\";\n                case 'sqlite':\n                    return \"DROP TABLE $p1;\";\n            }\n        }\n\n        private function getRemoveColumnSQL(string $tableName, string $columnName): string\n        {\n            $p1 = $this->quote($tableName);\n            $p2 = $this->quote($columnName);\n\n            switch ($this->driver) {\n                case 'mysql':\n                case 'pgsql':\n                    return \"ALTER TABLE $p1 DROP COLUMN $p2 CASCADE;\";\n                case 'sqlsrv':\n                    return \"ALTER TABLE $p1 DROP COLUMN $p2;\";\n                case 'sqlite':\n                    return \"ALTER TABLE $p1 DROP COLUMN $p2;\";\n            }\n        }\n\n        public function renameTable(string $tableName, string $newTableName)\n        {\n            $sql = $this->getTableRenameSQL($tableName, $newTableName);\n            return $this->query($sql, []);\n        }\n\n        public function renameColumn(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getColumnRenameSQL($tableName, $columnName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function retypeColumn(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getColumnRetypeSQL($tableName, $columnName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function setColumnNullable(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getSetColumnNullableSQL($tableName, $columnName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function addColumnPrimaryKey(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getSetColumnPkConstraintSQL($tableName, $columnName, $newColumn);\n            $this->query($sql, []);\n            if ($this->canAutoIncrement($newColumn)) {\n                $sql = $this->getSetColumnPkSequenceSQL($tableName, $columnName, $newColumn);\n                $this->query($sql, []);\n                $sql = $this->getSetColumnPkSequenceStartSQL($tableName, $columnName, $newColumn);\n                $this->query($sql, []);\n                $sql = $this->getSetColumnPkDefaultSQL($tableName, $columnName, $newColumn);\n                $this->query($sql, []);\n            }\n            return true;\n        }\n\n        public function removeColumnPrimaryKey(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            if ($this->canAutoIncrement($newColumn)) {\n                $sql = $this->getSetColumnPkDefaultSQL($tableName, $columnName, $newColumn);\n                $this->query($sql, []);\n                $sql = $this->getSetColumnPkSequenceSQL($tableName, $columnName, $newColumn);\n                $this->query($sql, []);\n            }\n            $sql = $this->getSetColumnPkConstraintSQL($tableName, $columnName, $newColumn);\n            $this->query($sql, []);\n            return true;\n        }\n\n        public function addColumnForeignKey(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getAddColumnFkConstraintSQL($tableName, $columnName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function removeColumnForeignKey(string $tableName, string $columnName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getRemoveColumnFkConstraintSQL($tableName, $columnName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function addTable(ReflectedTable $newTable)\n        {\n            $sql = $this->getAddTableSQL($newTable);\n            return $this->query($sql, []);\n        }\n\n        public function addColumn(string $tableName, ReflectedColumn $newColumn)\n        {\n            $sql = $this->getAddColumnSQL($tableName, $newColumn);\n            return $this->query($sql, []);\n        }\n\n        public function removeTable(string $tableName)\n        {\n            $sql = $this->getRemoveTableSQL($tableName);\n            return $this->query($sql, []);\n        }\n\n        public function removeColumn(string $tableName, string $columnName)\n        {\n            $sql = $this->getRemoveColumnSQL($tableName, $columnName);\n            return $this->query($sql, []);\n        }\n\n        private function query(string $sql, array $arguments): bool\n        {\n            $stmt = $this->pdo->prepare($sql);\n            // echo \"- $sql -- \" . json_encode($arguments) . \"\\n\";\n            return $stmt->execute($arguments);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/GenericReflection.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    use Tqdev\\PhpCrudApi\\Database\\LazyPdo;\n\n    class GenericReflection\n    {\n        private $pdo;\n        private $driver;\n        private $database;\n        private $tables;\n        private $mapper;\n        private $typeConverter;\n\n        public function __construct(LazyPdo $pdo, string $driver, string $database, array $tables, RealNameMapper $mapper)\n        {\n            $this->pdo = $pdo;\n            $this->driver = $driver;\n            $this->database = $database;\n            $this->tables = $tables;\n            $this->mapper = $mapper;\n            $this->typeConverter = new TypeConverter($driver);\n        }\n\n        public function getIgnoredTables(): array\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return [];\n                case 'pgsql':\n                    return ['spatial_ref_sys', 'raster_columns', 'raster_overviews', 'geography_columns', 'geometry_columns'];\n                case 'sqlsrv':\n                    return [];\n                case 'sqlite':\n                    return ['sqlite_sequence'];\n            }\n        }\n\n        private function getTablesSQL(): string\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return 'SELECT \"TABLE_NAME\", \"TABLE_TYPE\" FROM \"INFORMATION_SCHEMA\".\"TABLES\" WHERE \"TABLE_TYPE\" IN (\\'BASE TABLE\\' , \\'VIEW\\') AND \"TABLE_SCHEMA\" = ? ORDER BY BINARY \"TABLE_NAME\"';\n                case 'pgsql':\n                    return 'SELECT c.relname as \"TABLE_NAME\", c.relkind as \"TABLE_TYPE\" FROM pg_catalog.pg_class c WHERE c.relkind IN (\\'r\\', \\'v\\') AND c.relnamespace::regnamespace::text !~ \\'^pg_|information_schema\\' AND \\'\\' <> ? ORDER BY \"TABLE_NAME\";';\n                case 'sqlsrv':\n                    return 'SELECT o.name as \"TABLE_NAME\", o.xtype as \"TABLE_TYPE\" FROM sysobjects o WHERE o.xtype IN (\\'U\\', \\'V\\') ORDER BY \"TABLE_NAME\"';\n                case 'sqlite':\n                    return 'SELECT t.name as \"TABLE_NAME\", t.type as \"TABLE_TYPE\" FROM sqlite_master t WHERE t.type IN (\\'table\\', \\'view\\') AND \\'\\' IN (\\'\\', ?) ORDER BY \"TABLE_NAME\"';\n            }\n        }\n\n        private function getTableColumnsSQL(): string\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return 'SELECT \"COLUMN_NAME\", \"IS_NULLABLE\", \"DATA_TYPE\", \"CHARACTER_MAXIMUM_LENGTH\" as \"CHARACTER_MAXIMUM_LENGTH\", \"NUMERIC_PRECISION\", \"NUMERIC_SCALE\", \"COLUMN_TYPE\" FROM \"INFORMATION_SCHEMA\".\"COLUMNS\" WHERE \"TABLE_NAME\" = ? AND \"TABLE_SCHEMA\" = ? ORDER BY \"ORDINAL_POSITION\"';\n                case 'pgsql':\n                    return 'SELECT a.attname AS \"COLUMN_NAME\", case when a.attnotnull then \\'NO\\' else \\'YES\\' end as \"IS_NULLABLE\", pg_catalog.format_type(a.atttypid, -1) as \"DATA_TYPE\", case when a.atttypmod < 0 then NULL else a.atttypmod-4 end as \"CHARACTER_MAXIMUM_LENGTH\", case when a.atttypid != 1700 then NULL else ((a.atttypmod - 4) >> 16) & 65535 end as \"NUMERIC_PRECISION\", case when a.atttypid != 1700 then NULL else (a.atttypmod - 4) & 65535 end as \"NUMERIC_SCALE\", \\'\\' AS \"COLUMN_TYPE\" FROM pg_attribute a JOIN pg_class pgc ON pgc.oid = a.attrelid WHERE pgc.relname = ? AND \\'\\' <> ? AND pgc.relnamespace::regnamespace::text !~ \\'^pg_|information_schema\\' AND a.attnum > 0 AND NOT a.attisdropped ORDER BY a.attnum;';\n                case 'sqlsrv':\n                    return 'SELECT c.name AS \"COLUMN_NAME\", c.is_nullable AS \"IS_NULLABLE\", t.Name AS \"DATA_TYPE\", (c.max_length/2) AS \"CHARACTER_MAXIMUM_LENGTH\", c.precision AS \"NUMERIC_PRECISION\", c.scale AS \"NUMERIC_SCALE\", \\'\\' AS \"COLUMN_TYPE\" FROM sys.columns c INNER JOIN sys.types t ON c.user_type_id = t.user_type_id WHERE c.object_id = OBJECT_ID(?) AND \\'\\' <> ? ORDER BY c.column_id';\n                case 'sqlite':\n                    return 'SELECT \"name\" AS \"COLUMN_NAME\", case when \"notnull\"==1 then \\'no\\' else \\'yes\\' end as \"IS_NULLABLE\", lower(\"type\") AS \"DATA_TYPE\", 2147483647 AS \"CHARACTER_MAXIMUM_LENGTH\", 0 AS \"NUMERIC_PRECISION\", 0 AS \"NUMERIC_SCALE\", \\'\\' AS \"COLUMN_TYPE\" FROM pragma_table_info(?) WHERE \\'\\' IN (\\'\\', ?) ORDER BY \"cid\"';\n            }\n        }\n\n        private function getTablePrimaryKeysSQL(): string\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return 'SELECT \"COLUMN_NAME\" FROM \"INFORMATION_SCHEMA\".\"KEY_COLUMN_USAGE\" WHERE \"CONSTRAINT_NAME\" = \\'PRIMARY\\' AND \"TABLE_NAME\" = ? AND \"TABLE_SCHEMA\" = ?';\n                case 'pgsql':\n                    return 'SELECT a.attname AS \"COLUMN_NAME\" FROM pg_attribute a JOIN pg_constraint c ON (c.conrelid, c.conkey[1]) = (a.attrelid, a.attnum) JOIN pg_class pgc ON pgc.oid = a.attrelid WHERE pgc.relname = ? AND \\'\\' <> ? AND pgc.relnamespace::regnamespace::text !~ \\'^pg_|information_schema\\' AND c.contype = \\'p\\'';\n                case 'sqlsrv':\n                    return 'SELECT c.NAME as \"COLUMN_NAME\" FROM sys.key_constraints kc inner join sys.objects t on t.object_id = kc.parent_object_id INNER JOIN sys.index_columns ic ON kc.parent_object_id = ic.object_id and kc.unique_index_id = ic.index_id INNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id WHERE kc.type = \\'PK\\' and t.object_id = OBJECT_ID(?) and \\'\\' <> ?';\n                case 'sqlite':\n                    return 'SELECT \"name\" as \"COLUMN_NAME\" FROM pragma_table_info(?) WHERE \"pk\"=1 AND \\'\\' IN (\\'\\', ?)';\n            }\n        }\n\n        private function getTableForeignKeysSQL(): string\n        {\n            switch ($this->driver) {\n                case 'mysql':\n                    return 'SELECT \"COLUMN_NAME\", \"REFERENCED_TABLE_NAME\" FROM \"INFORMATION_SCHEMA\".\"KEY_COLUMN_USAGE\" WHERE \"REFERENCED_TABLE_NAME\" IS NOT NULL AND \"TABLE_NAME\" = ? AND \"TABLE_SCHEMA\" = ?';\n                case 'pgsql':\n                    return 'SELECT a.attname AS \"COLUMN_NAME\", c.confrelid::regclass::text AS \"REFERENCED_TABLE_NAME\" FROM pg_attribute a JOIN pg_constraint c ON (c.conrelid, c.conkey[1]) = (a.attrelid, a.attnum) JOIN pg_class pgc ON pgc.oid = a.attrelid WHERE pgc.relname = ? AND \\'\\' <> ? AND pgc.relnamespace::regnamespace::text !~ \\'^pg_|information_schema\\' AND c.contype  = \\'f\\'';\n                case 'sqlsrv':\n                    return 'SELECT COL_NAME(fc.parent_object_id, fc.parent_column_id) AS \"COLUMN_NAME\", OBJECT_NAME (f.referenced_object_id) AS \"REFERENCED_TABLE_NAME\" FROM sys.foreign_keys AS f INNER JOIN sys.foreign_key_columns AS fc ON f.OBJECT_ID = fc.constraint_object_id WHERE f.parent_object_id = OBJECT_ID(?) and \\'\\' <> ?';\n                case 'sqlite':\n                    return 'SELECT \"from\" AS \"COLUMN_NAME\", \"table\" AS \"REFERENCED_TABLE_NAME\" FROM pragma_foreign_key_list(?) WHERE \\'\\' IN (\\'\\', ?)';\n            }\n        }\n\n        public function getDatabaseName(): string\n        {\n            return $this->database;\n        }\n\n        public function getTables(): array\n        {\n            $sql = $this->getTablesSQL();\n            $results = $this->query($sql, [$this->database]);\n            $tables = $this->tables;\n            $results = array_filter($results, function ($v) use ($tables) {\n                return $tables == ['all'] || in_array($v['TABLE_NAME'], $tables);\n            });\n            foreach ($results as &$result) {\n                $result['TABLE_REAL_NAME'] = $result['TABLE_NAME'];\n                $result['TABLE_NAME'] = $this->mapper->getTableName($result['TABLE_REAL_NAME']);\n            }\n            foreach ($results as &$result) {\n                $map = [];\n                switch ($this->driver) {\n                    case 'mysql':\n                        $map = ['BASE TABLE' => 'table', 'VIEW' => 'view'];\n                        break;\n                    case 'pgsql':\n                        $map = ['r' => 'table', 'v' => 'view'];\n                        break;\n                    case 'sqlsrv':\n                        $map = ['U' => 'table', 'V' => 'view'];\n                        break;\n                    case 'sqlite':\n                        $map = ['table' => 'table', 'view' => 'view'];\n                        break;\n                }\n                $result['TABLE_TYPE'] = $map[trim($result['TABLE_TYPE'])];\n            }\n            return $results;\n        }\n\n        public function getTableColumns(string $tableName, string $type): array\n        {\n            $tableRealName = $this->mapper->getTableRealName($tableName);\n            $sql = $this->getTableColumnsSQL();\n            $results = $this->query($sql, [$tableRealName, $this->database]);\n            foreach ($results as &$result) {\n                $result['COLUMN_REAL_NAME'] = $result['COLUMN_NAME'];\n                $result['COLUMN_NAME'] = $this->mapper->getColumnName($tableRealName, $result['COLUMN_REAL_NAME']);\n            }\n            if ($type == 'view') {\n                foreach ($results as &$result) {\n                    $result['IS_NULLABLE'] = false;\n                }\n            }\n            if ($this->driver == 'mysql') {\n                foreach ($results as &$result) {\n                    // mysql does not properly reflect display width of types\n                    preg_match('|([a-z]+)(\\(([0-9]+)(,([0-9]+))?\\))?|', $result['DATA_TYPE'], $matches);\n                    $result['DATA_TYPE'] = $matches[1];\n                    if (!$result['CHARACTER_MAXIMUM_LENGTH']) {\n                        if (isset($matches[3])) {\n                            $result['NUMERIC_PRECISION'] = $matches[3];\n                        }\n                        if (isset($matches[5])) {\n                            $result['NUMERIC_SCALE'] = $matches[5];\n                        }\n                    }\n                }\n            }\n            if ($this->driver == 'sqlite') {\n                foreach ($results as &$result) {\n                    // sqlite does not reflect types on view columns\n                    preg_match('|([a-z]+)(\\(([0-9]+)(,([0-9]+))?\\))?|', $result['DATA_TYPE'], $matches);\n                    if (isset($matches[1])) {\n                        $result['DATA_TYPE'] = $matches[1];\n                    } else {\n                        $result['DATA_TYPE'] = 'text';\n                    }\n                    if (isset($matches[5])) {\n                        $result['NUMERIC_PRECISION'] = $matches[3];\n                        $result['NUMERIC_SCALE'] = $matches[5];\n                    } else if (isset($matches[3])) {\n                        $result['CHARACTER_MAXIMUM_LENGTH'] = $matches[3];\n                    }\n                }\n            }\n            return $results;\n        }\n\n        public function getTablePrimaryKeys(string $tableName): array\n        {\n            $tableRealName = $this->mapper->getTableRealName($tableName);\n            $sql = $this->getTablePrimaryKeysSQL();\n            $results = $this->query($sql, [$tableRealName, $this->database]);\n            $primaryKeys = [];\n            foreach ($results as $result) {\n                $primaryKeys[] = $this->mapper->getColumnName($tableRealName, $result['COLUMN_NAME']);\n            }\n            return $primaryKeys;\n        }\n\n        public function getTableForeignKeys(string $tableName): array\n        {\n            $tableRealName = $this->mapper->getTableRealName($tableName);\n            $sql = $this->getTableForeignKeysSQL();\n            $results = $this->query($sql, [$tableRealName, $this->database]);\n            $foreignKeys = [];\n            foreach ($results as $result) {\n                $columnName = $this->mapper->getColumnName($tableRealName, $result['COLUMN_NAME']);\n                $otherTableName = $this->mapper->getTableName($result['REFERENCED_TABLE_NAME']);\n                $foreignKeys[$columnName] = $otherTableName;\n            }\n            return $foreignKeys;\n        }\n\n        public function toJdbcType(string $type, string $size): string\n        {\n            return $this->typeConverter->toJdbc($type, $size);\n        }\n\n        private function query(string $sql, array $parameters): array\n        {\n            $stmt = $this->pdo->prepare($sql);\n            //echo \"- $sql -- \" . json_encode($parameters, JSON_UNESCAPED_UNICODE) . \"\\n\";\n            $stmt->execute($parameters);\n            return $stmt->fetchAll();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/LazyPdo.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    class LazyPdo extends \\PDO\n    {\n        private $dsn;\n        private $user;\n        private $password;\n        private $options;\n        private $commands;\n\n        private $pdo = null;\n\n        public function __construct(string $dsn, /*?string*/ $user = null, /*?string*/ $password = null, array $options = array())\n        {\n            $this->dsn = $dsn;\n            $this->user = $user;\n            $this->password = $password;\n            $this->options = $options;\n            $this->commands = array();\n            // explicitly NOT calling super::__construct\n        }\n\n        public function addInitCommand(string $command) /*: void*/\n        {\n            $this->commands[] = $command;\n        }\n\n        private function pdo()\n        {\n            if (!$this->pdo) {\n                $this->pdo = new \\PDO($this->dsn, $this->user, $this->password, $this->options);\n                foreach ($this->commands as $command) {\n                    $this->pdo->query($command);\n                }\n            }\n            return $this->pdo;\n        }\n\n        public function reconstruct(string $dsn, /*?string*/ $user = null, /*?string*/ $password = null, array $options = array()): bool\n        {\n            $this->dsn = $dsn;\n            $this->user = $user;\n            $this->password = $password;\n            $this->options = $options;\n            $this->commands = array();\n            if ($this->pdo) {\n                $this->pdo = null;\n                return true;\n            }\n            return false;\n        }\n\n        public function inTransaction(): bool\n        {\n            // Do not call parent method if there is no pdo object\n            return $this->pdo && parent::inTransaction();\n        }\n\n        public function setAttribute($attribute, $value): bool\n        {\n            if ($this->pdo) {\n                return $this->pdo()->setAttribute($attribute, $value);\n            }\n            $this->options[$attribute] = $value;\n            return true;\n        }\n\n        public function getAttribute($attribute): mixed\n        {\n            return $this->pdo()->getAttribute($attribute);\n        }\n\n        public function beginTransaction(): bool\n        {\n            return $this->pdo()->beginTransaction();\n        }\n\n        public function commit(): bool\n        {\n            return $this->pdo()->commit();\n        }\n\n        public function rollBack(): bool\n        {\n            return $this->pdo()->rollBack();\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function errorCode()\n        {\n            return $this->pdo()->errorCode();\n        }\n\n        public function errorInfo(): array\n        {\n            return $this->pdo()->errorInfo();\n        }\n\n        public function exec($query): int\n        {\n            return $this->pdo()->exec($query);\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function prepare($statement, $options = array())\n        {\n            return $this->pdo()->prepare($statement, $options);\n        }\n\n        public function quote($string, $parameter_type = \\PDO::PARAM_STR): string\n        {\n            return $this->pdo()->quote($string, $parameter_type);\n        }\n\n        public function lastInsertId( /* ?string */$name = null): string\n        {\n            return $this->pdo()->lastInsertId($name);\n        }\n\n        public function query($query, /* ?int */ $fetchMode = null, ...$fetchModeArgs): \\PDOStatement\n        {\n            return call_user_func_array(array($this->pdo(), 'query'), func_get_args());\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/RealNameMapper.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    class RealNameMapper\n    {\n        private $tableMapping;\n        private $reverseTableMapping;\n        private $columnMapping;\n        private $reverseColumnMapping;\n\n        public function __construct(array $mapping)\n        {\n            $this->tableMapping = [];\n            $this->reverseTableMapping = [];\n            $this->columnMapping = [];\n            $this->reverseColumnMapping = [];\n            foreach ($mapping as $name=>$realName) {\n                if (strpos($name,'.') && strpos($realName,'.')) {\n                    list($tableName, $columnName) = explode('.', $name, 2);\n                    list($tableRealName, $columnRealName) = explode('.', $realName, 2);\n                    $this->tableMapping[$tableName] = $tableRealName;\n                    $this->reverseTableMapping[$tableRealName] = $tableName;\n                    if (!isset($this->columnMapping[$tableName])) {\n                        $this->columnMapping[$tableName] = [];\n                    }\n                    $this->columnMapping[$tableName][$columnName] = $columnRealName;\n                    if (!isset($this->reverseColumnMapping[$tableRealName])) {\n                        $this->reverseColumnMapping[$tableRealName] = [];\n                    }\n                    $this->reverseColumnMapping[$tableRealName][$columnRealName] = $columnName;\n                } else {\n                    $this->tableMapping[$name] = $realName;\n                    $this->reverseTableMapping[$realName] = $name;\n                }\n            }\n        }\n\n        public function getColumnRealName(string $tableName,string $columnName): string\n        {\n            return $this->reverseColumnMapping[$tableName][$columnName] ?? $columnName;\n        }\n\n        public function getTableRealName(string $tableName): string\n        {\n            return $this->reverseTableMapping[$tableName] ?? $tableName;\n        }\n\n        public function getColumnName(string $tableRealName,string $columnRealName): string\n        {\n            return $this->columnMapping[$tableRealName][$columnRealName] ?? $columnRealName;\n        }\n\n        public function getTableName(string $tableRealName): string\n        {\n            return $this->tableMapping[$tableRealName] ?? $tableRealName;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Database/TypeConverter.php\nnamespace Tqdev\\PhpCrudApi\\Database {\n\n    class TypeConverter\n    {\n        private $driver;\n\n        public function __construct(string $driver)\n        {\n            $this->driver = $driver;\n        }\n\n        private $fromJdbc = [\n            'mysql' => [\n                'clob' => 'longtext',\n                'boolean' => 'tinyint(1)',\n                'blob' => 'longblob',\n                'timestamp' => 'datetime',\n            ],\n            'pgsql' => [\n                'clob' => 'text',\n                'blob' => 'bytea',\n                'float' => 'real',\n                'double' => 'double precision',\n                'varbinary' => 'bytea',\n            ],\n            'sqlsrv' => [\n                'boolean' => 'bit',\n                'varchar' => 'nvarchar',\n                'clob' => 'ntext',\n                'blob' => 'image',\n                'time' => 'time(0)',\n                'timestamp' => 'datetime2(0)',\n                'double' => 'float',\n                'float' => 'real',\n            ],\n        ];\n\n        private $toJdbc = [\n            'simplified' => [\n                'char' => 'varchar',\n                'longvarchar' => 'clob',\n                'nchar' => 'varchar',\n                'nvarchar' => 'varchar',\n                'longnvarchar' => 'clob',\n                'binary' => 'varbinary',\n                'longvarbinary' => 'blob',\n                'tinyint' => 'integer',\n                'smallint' => 'integer',\n                'real' => 'float',\n                'numeric' => 'decimal',\n                'nclob' => 'clob',\n                'time_with_timezone' => 'time',\n                'timestamp_with_timezone' => 'timestamp',\n            ],\n            'mysql' => [\n                'tinyint(1)' => 'boolean',\n                'bit(1)' => 'boolean',\n                'tinyblob' => 'blob',\n                'mediumblob' => 'blob',\n                'longblob' => 'blob',\n                'tinytext' => 'clob',\n                'mediumtext' => 'clob',\n                'longtext' => 'clob',\n                'text' => 'clob',\n                'mediumint' => 'integer',\n                'int' => 'integer',\n                'polygon' => 'geometry',\n                'point' => 'geometry',\n                'linestring' => 'geometry',\n                'multipoint' => 'geometry',\n                'multilinestring' => 'geometry',\n                'multipolygon' => 'geometry',\n                'datetime' => 'timestamp',\n                'year' => 'integer',\n                'enum' => 'varchar',\n                'set' => 'varchar',\n                'json' => 'clob',\n            ],\n            'pgsql' => [\n                'bigserial' => 'bigint',\n                'bit varying' => 'bit',\n                'box' => 'geometry',\n                'bytea' => 'blob',\n                'bpchar' => 'char',\n                'character varying' => 'varchar',\n                'character' => 'char',\n                'cidr' => 'varchar',\n                'circle' => 'geometry',\n                'double precision' => 'double',\n                'inet' => 'integer',\n                //'interval [ fields ]'\n                'json' => 'clob',\n                'jsonb' => 'clob',\n                'line' => 'geometry',\n                'lseg' => 'geometry',\n                'macaddr' => 'varchar',\n                'money' => 'decimal',\n                'path' => 'geometry',\n                'point' => 'geometry',\n                'polygon' => 'geometry',\n                'real' => 'float',\n                'serial' => 'integer',\n                'text' => 'clob',\n                'time without time zone' => 'time',\n                'time with time zone' => 'time_with_timezone',\n                'timestamp without time zone' => 'timestamp',\n                'timestamp with time zone' => 'timestamp_with_timezone',\n                //'tsquery'=\n                //'tsvector'\n                //'txid_snapshot'\n                'uuid' => 'char',\n                'xml' => 'clob',\n            ],\n            // source: https://docs.microsoft.com/en-us/sql/connect/jdbc/using-basic-data-types?view=sql-server-2017\n            'sqlsrv' => [\n                'varbinary()' => 'blob',\n                'bit' => 'boolean',\n                'datetime' => 'timestamp',\n                'datetime2' => 'timestamp',\n                'float' => 'double',\n                'image' => 'blob',\n                'int' => 'integer',\n                'money' => 'decimal',\n                'ntext' => 'clob',\n                'smalldatetime' => 'timestamp',\n                'smallmoney' => 'decimal',\n                'text' => 'clob',\n                'timestamp' => 'binary',\n                'udt' => 'varbinary',\n                'uniqueidentifier' => 'char',\n                'xml' => 'clob',\n            ],\n            'sqlite' => [\n                'tinytext' => 'clob',\n                'text' => 'clob',\n                'mediumtext' => 'clob',\n                'longtext' => 'clob',\n                'mediumint' => 'integer',\n                'int' => 'integer',\n                'bigint' => 'bigint',\n                'int2' => 'smallint',\n                'int4' => 'integer',\n                'int8' => 'bigint',\n                'double precision' => 'double',\n                'datetime' => 'timestamp'\n            ],\n        ];\n\n        // source: https://docs.oracle.com/javase/9/docs/api/java/sql/Types.html\n        private $valid = [\n            //'array' => true,\n            'bigint' => true,\n            'binary' => true,\n            'bit' => true,\n            'blob' => true,\n            'boolean' => true,\n            'char' => true,\n            'clob' => true,\n            //'datalink' => true,\n            'date' => true,\n            'decimal' => true,\n            //'distinct' => true,\n            'double' => true,\n            'float' => true,\n            'integer' => true,\n            //'java_object' => true,\n            'longnvarchar' => true,\n            'longvarbinary' => true,\n            'longvarchar' => true,\n            'nchar' => true,\n            'nclob' => true,\n            //'null' => true,\n            'numeric' => true,\n            'nvarchar' => true,\n            //'other' => true,\n            'real' => true,\n            //'ref' => true,\n            //'ref_cursor' => true,\n            //'rowid' => true,\n            'smallint' => true,\n            //'sqlxml' => true,\n            //'struct' => true,\n            'time' => true,\n            'time_with_timezone' => true,\n            'timestamp' => true,\n            'timestamp_with_timezone' => true,\n            'tinyint' => true,\n            'varbinary' => true,\n            'varchar' => true,\n            // extra:\n            'geometry' => true,\n        ];\n\n        public function toJdbc(string $type, string $size): string\n        {\n            $jdbcType = strtolower($type);\n            if (isset($this->toJdbc[$this->driver][\"$jdbcType($size)\"])) {\n                $jdbcType = $this->toJdbc[$this->driver][\"$jdbcType($size)\"];\n            }\n            if (isset($this->toJdbc[$this->driver][$jdbcType])) {\n                $jdbcType = $this->toJdbc[$this->driver][$jdbcType];\n            }\n            if (isset($this->toJdbc['simplified'][$jdbcType])) {\n                $jdbcType = $this->toJdbc['simplified'][$jdbcType];\n            }\n            if (!isset($this->valid[$jdbcType])) {\n                //throw new \\Exception(\"Unsupported type '$jdbcType' for driver '$this->driver'\");\n                $jdbcType = 'clob';\n            }\n            return $jdbcType;\n        }\n\n        public function fromJdbc(string $type): string\n        {\n            $jdbcType = strtolower($type);\n            if (isset($this->fromJdbc[$this->driver][$jdbcType])) {\n                $jdbcType = $this->fromJdbc[$this->driver][$jdbcType];\n            }\n            return $jdbcType;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/GeoJson/Feature.php\nnamespace Tqdev\\PhpCrudApi\\GeoJson {\n\n    class Feature implements \\JsonSerializable\n    {\n        private $id;\n        private $properties;\n        private $geometry;\n\n        public function __construct($id, array $properties, /*?Geometry*/ $geometry)\n        {\n            $this->id = $id;\n            $this->properties = $properties;\n            $this->geometry = $geometry;\n        }\n\n        public function serialize()\n        {\n            return [\n                'type' => 'Feature',\n                'id' => $this->id,\n                'properties' => $this->properties,\n                'geometry' => $this->geometry,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->serialize();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/GeoJson/FeatureCollection.php\nnamespace Tqdev\\PhpCrudApi\\GeoJson {\n\n    class FeatureCollection implements \\JsonSerializable\n    {\n        private $features;\n\n        private $results;\n\n        public function __construct(array $features, int $results)\n        {\n            $this->features = $features;\n            $this->results = $results;\n        }\n\n        public function serialize()\n        {\n            return [\n                'type' => 'FeatureCollection',\n                'features' => $this->features,\n                'results' => $this->results,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return array_filter($this->serialize(), function ($v) {\n                return $v !== -1;\n            });\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/GeoJson/GeoJsonService.php\nnamespace Tqdev\\PhpCrudApi\\GeoJson {\n\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\GeoJson\\FeatureCollection;\n    use Tqdev\\PhpCrudApi\\Record\\RecordService;\n\n    class GeoJsonService\n    {\n        private $reflection;\n        private $records;\n\n        public function __construct(ReflectionService $reflection, RecordService $records)\n        {\n            $this->reflection = $reflection;\n            $this->records = $records;\n        }\n\n        public function hasTable(string $table): bool\n        {\n            return $this->reflection->hasTable($table);\n        }\n\n        public function getType(string $table): string\n        {\n            return $this->reflection->getType($table);\n        }\n\n        private function getGeometryColumnName(string $tableName, array &$params): string\n        {\n            $geometryParam = isset($params['geometry']) ? $params['geometry'][0] : '';\n            $table = $this->reflection->getTable($tableName);\n            $geometryColumnName = '';\n            foreach ($table->getColumnNames() as $columnName) {\n                if ($geometryParam && $geometryParam != $columnName) {\n                    continue;\n                }\n                $column = $table->getColumn($columnName);\n                if ($column->isGeometry()) {\n                    $geometryColumnName = $columnName;\n                    break;\n                }\n            }\n            if ($geometryColumnName) {\n                $params['mandatory'][] = $tableName . \".\" . $geometryColumnName;\n            }\n            return $geometryColumnName;\n        }\n\n        private function setBoudingBoxFilter(string $geometryColumnName, array &$params)\n        {\n            $boundingBox = isset($params['bbox']) ? $params['bbox'][0] : '';\n            if ($boundingBox) {\n                $c = explode(',', $boundingBox);\n                if (!isset($params['filter'])) {\n                    $params['filter'] = array();\n                }\n                $params['filter'][] = \"$geometryColumnName,sin,POLYGON(($c[0] $c[1],$c[2] $c[1],$c[2] $c[3],$c[0] $c[3],$c[0] $c[1]))\";\n            }\n            $tile = isset($params['tile']) ? $params['tile'][0] : '';\n            if ($tile) {\n                $zxy = explode(',', $tile);\n                if (count($zxy) == 3) {\n                    list($z, $x, $y) = $zxy;\n                    $c = array();\n                    $c = array_merge($c, $this->convertTileToLatLonOfUpperLeftCorner($z, $x, $y));\n                    $c = array_merge($c, $this->convertTileToLatLonOfUpperLeftCorner($z, $x + 1, $y + 1));\n                    $params['filter'][] = \"$geometryColumnName,sin,POLYGON(($c[0] $c[1],$c[2] $c[1],$c[2] $c[3],$c[0] $c[3],$c[0] $c[1]))\";\n                }\n            }\n        }\n\n        private function convertTileToLatLonOfUpperLeftCorner($z, $x, $y): array\n        {\n            $n = pow(2, $z);\n            $lon = $x / $n * 360.0 - 180.0;\n            $lat = rad2deg(atan(sinh(pi() * (1 - 2 * $y / $n))));\n            return [$lon, $lat];\n        }\n\n        private function convertRecordToFeature(/*object*/$record, string $primaryKeyColumnName, string $geometryColumnName)\n        {\n            $id = null;\n            if ($primaryKeyColumnName) {\n                $id = $record[$primaryKeyColumnName];\n            }\n            $geometry = null;\n            if (isset($record[$geometryColumnName])) {\n                $geometry = Geometry::fromWkt($record[$geometryColumnName]);\n            }\n            $properties = array_diff_key($record, [$primaryKeyColumnName => true, $geometryColumnName => true]);\n            return new Feature($id, $properties, $geometry);\n        }\n\n        private function getPrimaryKeyColumnName(string $tableName, array &$params): string\n        {\n            $primaryKeyColumn = $this->reflection->getTable($tableName)->getPk();\n            if (!$primaryKeyColumn) {\n                return '';\n            }\n            $primaryKeyColumnName = $primaryKeyColumn->getName();\n            $params['mandatory'][] = $tableName . \".\" . $primaryKeyColumnName;\n            return $primaryKeyColumnName;\n        }\n\n        public function _list(string $tableName, array $params): FeatureCollection\n        {\n            $geometryColumnName = $this->getGeometryColumnName($tableName, $params);\n            $this->setBoudingBoxFilter($geometryColumnName, $params);\n            $primaryKeyColumnName = $this->getPrimaryKeyColumnName($tableName, $params);\n            $records = $this->records->_list($tableName, $params);\n            $features = array();\n            foreach ($records->getRecords() as $record) {\n                $features[] = $this->convertRecordToFeature($record, $primaryKeyColumnName, $geometryColumnName);\n            }\n            return new FeatureCollection($features, $records->getResults());\n        }\n\n        public function read(string $tableName, string $id, array $params): Feature\n        {\n            $geometryColumnName = $this->getGeometryColumnName($tableName, $params);\n            $primaryKeyColumnName = $this->getPrimaryKeyColumnName($tableName, $params);\n            $record = $this->records->read($tableName, $id, $params);\n            return $this->convertRecordToFeature($record, $primaryKeyColumnName, $geometryColumnName);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/GeoJson/Geometry.php\nnamespace Tqdev\\PhpCrudApi\\GeoJson {\n\n    class Geometry implements \\JsonSerializable\n    {\n        private $type;\n        private $coordinates;\n\n        public static $types = [\n            \"Point\",\n            \"MultiPoint\",\n            \"LineString\",\n            \"MultiLineString\",\n            \"Polygon\",\n            \"MultiPolygon\",\n            //\"GeometryCollection\",\n        ];\n\n        public function __construct(string $type, array $coordinates)\n        {\n            $this->type = $type;\n            $this->coordinates = $coordinates;\n        }\n\n        public static function fromWkt(string $wkt): Geometry\n        {\n            $bracket = strpos($wkt, '(');\n            $type = strtoupper(trim(substr($wkt, 0, $bracket)));\n            $supported = false;\n            foreach (Geometry::$types as $typeName) {\n                if (strtoupper($typeName) == $type) {\n                    $type = $typeName;\n                    $supported = true;\n                }\n            }\n            if (!$supported) {\n                throw new \\Exception('Geometry type not supported: ' . $type);\n            }\n            $coordinates = substr($wkt, $bracket);\n            if (substr($type, -5) != 'Point' || ($type == 'MultiPoint' && $coordinates[1] != '(')) {\n                $coordinates = preg_replace('|([0-9\\-\\.]+ )+([0-9\\-\\.]+)|', '[\\1\\2]', $coordinates);\n            }\n            $coordinates = str_replace(['(', ')', ', ', ' '], ['[', ']', ',', ','], $coordinates);\n            $coordinates = json_decode($coordinates);\n            if (!$coordinates) {\n                throw new \\Exception('Could not decode WKT: ' . $wkt);\n            }\n            return new Geometry($type, $coordinates);\n        }\n\n        public function serialize()\n        {\n            return [\n                'type' => $this->type,\n                'coordinates' => $this->coordinates,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->serialize();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/Base/Middleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware\\Base {\n\n    use Psr\\Http\\Server\\MiddlewareInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Config\\Base\\ConfigInterface;\n\n    abstract class Middleware implements MiddlewareInterface\n    {\n        protected $next;\n        protected $responder;\n        private $middleware;\n        private $config;\n\n        public function __construct(Router $router, Responder $responder, ConfigInterface $config, string $middleware)\n        {\n            $router->load($this);\n            $this->responder = $responder;\n            $this->middleware = $middleware;\n            $this->config = $config;\n        }\n\n        protected function getArrayProperty(string $key, string $default): array\n        {\n            return array_filter(array_map('trim', explode(',', $this->getProperty($key, $default))));\n        }\n\n        protected function getMapProperty(string $key, string $default): array\n        {\n            $pairs = $this->getArrayProperty($key, $default);\n            $result = array();\n            foreach ($pairs as $pair) {\n                if (strpos($pair, ':')) {\n                    list($k, $v) = explode(':', $pair, 2);\n                    $result[trim($k)] = trim($v);\n                } else {\n                    $result[] = trim($pair);\n                }\n            }\n            return $result;\n        }\n\n        protected function getProperty(string $key, $default)\n        {\n            return $this->config->getProperty($this->middleware . '.' . $key, $default);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/Communication/VariableStore.php\nnamespace Tqdev\\PhpCrudApi\\Middleware\\Communication {\n\n    class VariableStore\n    {\n        public static $values = array();\n\n        public static function get(string $key)\n        {\n            if (isset(self::$values[$key])) {\n                return self::$values[$key];\n            }\n            return null;\n        }\n\n        public static function set(string $key, /* object */ $value)\n        {\n            self::$values[$key] = $value;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/Router/Router.php\nnamespace Tqdev\\PhpCrudApi\\Middleware\\Router {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n\n    interface Router extends RequestHandlerInterface\n    {\n        public function register(string $method, string $path, array $handler);\n\n        public function load(Middleware $middleware);\n\n        public function route(ServerRequestInterface $request): ResponseInterface;\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/Router/SimpleRouter.php\nnamespace Tqdev\\PhpCrudApi\\Middleware\\Router {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Cache\\Cache;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\Record\\PathTree;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class SimpleRouter implements Router\n    {\n        private $basePath;\n        private $responder;\n        private $cache;\n        private $ttl;\n        private $registration;\n        private $routes;\n        private $routeHandlers;\n        private $middlewares;\n\n        public function __construct(string $basePath, Responder $responder, Cache $cache, int $ttl)\n        {\n            $this->basePath = rtrim($basePath, '/') ?: rtrim($this->detectBasePath(), '/');;\n            $this->responder = $responder;\n            $this->cache = $cache;\n            $this->ttl = $ttl;\n            $this->registration = true;\n            $this->routes = $this->loadPathTree();\n            $this->routeHandlers = [];\n            $this->middlewares = array();\n        }\n\n        private function detectBasePath(): string\n        {\n            if (isset($_SERVER['REQUEST_URI'])) {\n                $fullPath = urldecode(explode('?', $_SERVER['REQUEST_URI'])[0]);\n                if (isset($_SERVER['PATH_INFO'])) {\n                    $path = $_SERVER['PATH_INFO'];\n                    if (substr($fullPath, -1 * strlen($path)) == $path) {\n                        return substr($fullPath, 0, -1 * strlen($path));\n                    }\n                }\n                $path = '/' . basename(__FILE__);\n                if (substr($fullPath, -1 * strlen($path)) == $path) {\n                    return $fullPath;\n                }\n            }\n            return '/';\n        }\n\n        private function loadPathTree(): PathTree\n        {\n            $data = $this->cache->get('PathTree');\n            if ($data != '') {\n                $tree = PathTree::fromJson(json_decode(gzuncompress($data)));\n                $this->registration = false;\n            } else {\n                $tree = new PathTree();\n            }\n            return $tree;\n        }\n\n        public function register(string $method, string $path, array $handler)\n        {\n            $routeNumber = count($this->routeHandlers);\n            $this->routeHandlers[$routeNumber] = $handler;\n            if ($this->registration) {\n                $path = trim($path, '/');\n                $parts = array();\n                if ($path) {\n                    $parts = explode('/', $path);\n                }\n                array_unshift($parts, $method);\n                $this->routes->put($parts, $routeNumber);\n            }\n        }\n\n        public function load(Middleware $middleware) /*: void*/\n        {\n            array_push($this->middlewares, $middleware);\n        }\n\n        public function route(ServerRequestInterface $request): ResponseInterface\n        {\n            if ($this->registration) {\n                $data = gzcompress(json_encode($this->routes, JSON_UNESCAPED_UNICODE));\n                $this->cache->set('PathTree', $data, $this->ttl);\n            }\n\n            return $this->handle($request);\n        }\n\n        private function getRouteNumbers(ServerRequestInterface $request): array\n        {\n            $method = strtoupper($request->getMethod());\n            $path = array();\n            $segment = $method;\n            for ($i = 1; strlen($segment) > 0; $i++) {\n                array_push($path, $segment);\n                $segment = RequestUtils::getPathSegment($request, $i);\n            }\n            return $this->routes->match($path);\n        }\n\n        private function removeBasePath(ServerRequestInterface $request): ServerRequestInterface\n        {\n            $path = $request->getUri()->getPath();\n            if (substr($path, 0, strlen($this->basePath)) == $this->basePath) {\n                $path = substr($path, strlen($this->basePath));\n                $request = $request->withUri($request->getUri()->withPath($path));\n            }\n            return $request;\n        }\n\n        public function getBasePath(): string\n        {\n            return $this->basePath;\n        }\n\n        public function handle(ServerRequestInterface $request): ResponseInterface\n        {\n            $request = $this->removeBasePath($request);\n\n            if (count($this->middlewares)) {\n                $handler = array_shift($this->middlewares);\n                return $handler->process($request, $this);\n            }\n\n            $routeNumbers = $this->getRouteNumbers($request);\n            if (count($routeNumbers) == 0) {\n                return $this->responder->error(ErrorCode::ROUTE_NOT_FOUND, $request->getUri()->getPath());\n            }\n            try {\n                $response = call_user_func($this->routeHandlers[$routeNumbers[0]], $request);\n            } catch (\\Throwable $exception) {\n                $response = $this->responder->exception($exception);\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/AjaxOnlyMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class AjaxOnlyMiddleware extends Middleware\n    {\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $method = $request->getMethod();\n            $excludeMethods = $this->getArrayProperty('excludeMethods', 'OPTIONS,GET');\n            if (!in_array($method, $excludeMethods)) {\n                $headerName = $this->getProperty('headerName', 'X-Requested-With');\n                $headerValue = $this->getProperty('headerValue', 'XMLHttpRequest');\n                if ($headerValue != RequestUtils::getHeader($request, $headerName)) {\n                    return $this->responder->error(ErrorCode::ONLY_AJAX_REQUESTS_ALLOWED, $method);\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/ApiKeyAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class ApiKeyAuthMiddleware extends Middleware\n    {\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $headerName = $this->getProperty('header', 'X-API-Key');\n            $apiKey = RequestUtils::getHeader($request, $headerName);\n            if ($apiKey) {\n                $apiKeys = $this->getArrayProperty('keys', '');\n                if (!in_array($apiKey, $apiKeys)) {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $apiKey);\n                }\n            } else {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                }\n            }\n            $_SESSION['apiKey'] = $apiKey;\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/ApiKeyDbAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\Record\\OrderingInfo;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class ApiKeyDbAuthMiddleware extends Middleware\n    {\n        private $reflection;\n        private $db;\n        private $ordering;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection, GenericDB $db)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n            $this->db = $db;\n            $this->ordering = new OrderingInfo();\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $user = false;\n            $headerName = $this->getProperty('header', 'X-API-Key');\n            $apiKey = RequestUtils::getHeader($request, $headerName);\n            if ($apiKey) {\n                $tableName = $this->getProperty('usersTable', 'users');\n                $table = $this->reflection->getTable($tableName);\n                $apiKeyColumnName = $this->getProperty('apiKeyColumn', 'api_key');\n                $apiKeyColumn = $table->getColumn($apiKeyColumnName);\n                $condition = new ColumnCondition($apiKeyColumn, 'eq', $apiKey);\n                $columnNames = $table->getColumnNames();\n                $columnOrdering = $this->ordering->getDefaultColumnOrdering($table);\n                $users = $this->db->selectAll($table, $columnNames, $condition, $columnOrdering, 0, 1);\n                if (count($users) < 1) {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $apiKey);\n                }\n                $user = $users[0];\n            } else {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                }\n            }\n            $_SESSION['apiUser'] = $user;\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/AuthorizationMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\Record\\FilterInfo;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class AuthorizationMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        private function handleColumns(string $operation, string $tableName) /*: void*/\n        {\n            $columnHandler = $this->getProperty('columnHandler', '');\n            if ($columnHandler) {\n                $table = $this->reflection->getTable($tableName);\n                foreach ($table->getColumnNames() as $columnName) {\n                    $allowed = call_user_func($columnHandler, $operation, $tableName, $columnName);\n                    if (!$allowed) {\n                        $table->removeColumn($columnName);\n                    }\n                }\n            }\n        }\n\n        private function handleTable(string $operation, string $tableName) /*: void*/\n        {\n            if (!$this->reflection->hasTable($tableName)) {\n                return;\n            }\n            $allowed = true;\n            $tableHandler = $this->getProperty('tableHandler', '');\n            if ($tableHandler) {\n                $allowed = call_user_func($tableHandler, $operation, $tableName);\n            }\n            if (!$allowed) {\n                $this->reflection->removeTable($tableName);\n            } else {\n                $this->handleColumns($operation, $tableName);\n            }\n        }\n\n        private function handleRecords(string $operation, string $tableName) /*: void*/\n        {\n            if (!$this->reflection->hasTable($tableName)) {\n                return;\n            }\n            $recordHandler = $this->getProperty('recordHandler', '');\n            if ($recordHandler) {\n                $query = call_user_func($recordHandler, $operation, $tableName);\n                $filters = new FilterInfo();\n                $table = $this->reflection->getTable($tableName);\n                $query = str_replace('][]=', ']=', str_replace('=', '[]=', $query ?: ''));\n                parse_str($query, $params);\n                $condition = $filters->getCombinedConditions($table, $params);\n                VariableStore::set(\"authorization.conditions.$tableName\", $condition);\n            }\n        }\n\n        private function pathHandler(string $path) /*: bool*/\n        {\n            $pathHandler = $this->getProperty('pathHandler', '');\n            return $pathHandler ? call_user_func($pathHandler, $path) : true;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $path = RequestUtils::getPathSegment($request, 1);\n\n            if (!$this->pathHandler($path)) {\n                return $this->responder->error(ErrorCode::ROUTE_NOT_FOUND, $request->getUri()->getPath());\n            }\n\n            $operation = RequestUtils::getOperation($request);\n            $tableNames = RequestUtils::getTableNames($request, $this->reflection);\n            foreach ($tableNames as $tableName) {\n                $this->handleTable($operation, $tableName);\n                if ($path == 'records') {\n                    $this->handleRecords($operation, $tableName);\n                }\n            }\n            if ($path == 'openapi') {\n                VariableStore::set('authorization.tableHandler', $this->getProperty('tableHandler', ''));\n                VariableStore::set('authorization.columnHandler', $this->getProperty('columnHandler', ''));\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/BasicAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class BasicAuthMiddleware extends Middleware\n    {\n        private function hasCorrectPassword(string $username, string $password, array &$passwords): bool\n        {\n            $hash = isset($passwords[$username]) ? $passwords[$username] : false;\n            if ($hash && password_verify($password, $hash)) {\n                if (password_needs_rehash($hash, PASSWORD_DEFAULT)) {\n                    $passwords[$username] = password_hash($password, PASSWORD_DEFAULT);\n                }\n                return true;\n            }\n            return false;\n        }\n\n        private function getValidUsername(string $username, string $password, string $passwordFile): string\n        {\n            $passwords = $this->readPasswords($passwordFile);\n            $valid = $this->hasCorrectPassword($username, $password, $passwords);\n            $this->writePasswords($passwordFile, $passwords);\n            return $valid ? $username : '';\n        }\n\n        private function readPasswords(string $passwordFile): array\n        {\n            $passwords = [];\n            $passwordLines = file($passwordFile);\n            foreach ($passwordLines as $passwordLine) {\n                if (strpos($passwordLine, ':') !== false) {\n                    list($username, $hash) = explode(':', trim($passwordLine), 2);\n                    if (strlen($hash) > 0 && $hash[0] != '$') {\n                        $hash = password_hash($hash, PASSWORD_DEFAULT);\n                    }\n                    $passwords[$username] = $hash;\n                }\n            }\n            return $passwords;\n        }\n\n        private function writePasswords(string $passwordFile, array $passwords): bool\n        {\n            $success = false;\n            $passwordFileContents = '';\n            foreach ($passwords as $username => $hash) {\n                $passwordFileContents .= \"$username:$hash\\n\";\n            }\n            if (file_get_contents($passwordFile) != $passwordFileContents) {\n                $success = file_put_contents($passwordFile, $passwordFileContents) !== false;\n            }\n            return $success;\n        }\n\n        private function getAuthorizationCredentials(ServerRequestInterface $request): string\n        {\n            $serverParams = $request->getServerParams();\n            if (isset($serverParams['PHP_AUTH_USER'])) {\n                return $serverParams['PHP_AUTH_USER'] . ':' . $serverParams['PHP_AUTH_PW'];\n            }\n            $header = RequestUtils::getHeader($request, 'Authorization');\n            $parts = explode(' ', trim($header), 2);\n            if (count($parts) != 2) {\n                return '';\n            }\n            if ($parts[0] != 'Basic') {\n                return '';\n            }\n            return base64_decode(strtr($parts[1], '-_', '+/'));\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            if (session_status() == PHP_SESSION_NONE) {\n                if (!headers_sent()) {\n                    $sessionName = $this->getProperty('sessionName', '');\n                    if ($sessionName) {\n                        session_name($sessionName);\n                    }\n                    if (!ini_get('session.cookie_samesite')) {\n                        ini_set('session.cookie_samesite', 'Lax');\n                    }\n                    if (!ini_get('session.cookie_httponly')) {\n                        ini_set('session.cookie_httponly', 1);\n                    }\n                    if (!ini_get('session.cookie_secure') && isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] != 'off') {\n                        ini_set('session.cookie_secure', 1);\n                    }\n                    session_start();\n                }\n            }\n            $credentials = $this->getAuthorizationCredentials($request);\n            if ($credentials) {\n                list($username, $password) = array('', '');\n                if (strpos($credentials, ':') !== false) {\n                    list($username, $password) = explode(':', $credentials, 2);\n                }\n                $passwordFile = $this->getProperty('passwordFile', '.htpasswd');\n                $validUser = $this->getValidUsername($username, $password, $passwordFile);\n                $_SESSION['username'] = $validUser;\n                if (!$validUser) {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                }\n                if (!headers_sent()) {\n                    session_regenerate_id();\n                }\n            }\n            if (!isset($_SESSION['username']) || !$_SESSION['username']) {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    $response = $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                    $realm = $this->getProperty('realm', 'Username and password required');\n                    $response = $response->withHeader('WWW-Authenticate', \"Basic realm=\\\"$realm\\\"\");\n                    return $response;\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/CorsMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n    use Tqdev\\PhpCrudApi\\ResponseUtils;\n\n    class CorsMiddleware extends Middleware\n    {\n        private $debug;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->debug = $config->getDebug();\n        }\n\n        private function isOriginAllowed(string $origin, string $allowedOrigins): bool\n        {\n            $found = false;\n            foreach (explode(',', $allowedOrigins) as $allowedOrigin) {\n                $hostname = preg_quote(strtolower(trim($allowedOrigin)), '/');\n                $regex = '/^' . str_replace('\\*', '.*', $hostname) . '$/';\n                if (preg_match($regex, $origin)) {\n                    $found = true;\n                    break;\n                }\n            }\n            return $found;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $method = $request->getMethod();\n            $origin = count($request->getHeader('Origin')) ? $request->getHeader('Origin')[0] : '';\n            $allowedOrigins = $this->getProperty('allowedOrigins', '*');\n            if ($origin && !$this->isOriginAllowed($origin, $allowedOrigins)) {\n                $response = $this->responder->error(ErrorCode::ORIGIN_FORBIDDEN, $origin);\n            } elseif ($method == 'OPTIONS') {\n                $response = ResponseFactory::fromStatus(ResponseFactory::OK);\n                $allowHeaders = $this->getProperty('allowHeaders', 'Content-Type, X-XSRF-TOKEN, X-Authorization, X-API-Key');\n                if ($this->debug) {\n                    $allowHeaders = implode(', ', array_filter([$allowHeaders, 'X-Exception-Name, X-Exception-Message, X-Exception-File']));\n                }\n                if ($allowHeaders) {\n                    $response = $response->withHeader('Access-Control-Allow-Headers', $allowHeaders);\n                }\n                $allowMethods = $this->getProperty('allowMethods', 'OPTIONS, GET, PUT, POST, DELETE, PATCH');\n                if ($allowMethods) {\n                    $response = $response->withHeader('Access-Control-Allow-Methods', $allowMethods);\n                }\n                $allowCredentials = $this->getProperty('allowCredentials', 'true');\n                if ($allowCredentials) {\n                    $response = $response->withHeader('Access-Control-Allow-Credentials', $allowCredentials);\n                }\n                $maxAge = $this->getProperty('maxAge', '1728000');\n                if ($maxAge) {\n                    $response = $response->withHeader('Access-Control-Max-Age', $maxAge);\n                }\n                $exposeHeaders = $this->getProperty('exposeHeaders', '');\n                if ($this->debug) {\n                    $exposeHeaders = implode(', ', array_filter([$exposeHeaders, 'X-Exception-Name, X-Exception-Message, X-Exception-File']));\n                }\n                if ($exposeHeaders) {\n                    $response = $response->withHeader('Access-Control-Expose-Headers', $exposeHeaders);\n                }\n            } else {\n                $response = null;\n                try {\n                    $response = $next->handle($request);\n                } catch (\\Throwable $e) {\n                    $response = $this->responder->error(ErrorCode::ERROR_NOT_FOUND, $e->getMessage());\n                    if ($this->debug) {\n                        $response = ResponseUtils::addExceptionHeaders($response, $e);\n                    }\n                }\n            }\n            if ($origin) {\n                $allowCredentials = $this->getProperty('allowCredentials', 'true');\n                if ($allowCredentials) {\n                    $response = $response->withHeader('Access-Control-Allow-Credentials', $allowCredentials);\n                }\n                $response = $response->withHeader('Access-Control-Allow-Origin', $origin);\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/CustomizationMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class CustomizationMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            $beforeHandler = $this->getProperty('beforeHandler', '');\n            $environment = (object) array();\n            if ($beforeHandler !== '') {\n                $result = call_user_func($beforeHandler, $operation, $tableName, $request, $environment);\n                $request = $result ?: $request;\n            }\n            $response = $next->handle($request);\n            $afterHandler = $this->getProperty('afterHandler', '');\n            if ($afterHandler !== '') {\n                $result = call_user_func($afterHandler, $operation, $tableName, $response, $environment);\n                $response = $result ?: $response;\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/DbAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\Record\\OrderingInfo;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class DbAuthMiddleware extends Middleware\n    {\n        private $reflection;\n        private $db;\n        private $ordering;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection, GenericDB $db)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n            $this->db = $db;\n            $this->ordering = new OrderingInfo();\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            if (session_status() == PHP_SESSION_NONE) {\n                if (!headers_sent()) {\n                    $sessionName = $this->getProperty('sessionName', '');\n                    if ($sessionName) {\n                        session_name($sessionName);\n                    }\n                    if (!ini_get('session.cookie_samesite')) {\n                        ini_set('session.cookie_samesite', 'Lax');\n                    }\n                    if (!ini_get('session.cookie_httponly')) {\n                        ini_set('session.cookie_httponly', 1);\n                    }\n                    if (!ini_get('session.cookie_secure') && isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] != 'off') {\n                        ini_set('session.cookie_secure', 1);\n                    }\n                    session_start();\n                }\n            }\n            $path = RequestUtils::getPathSegment($request, 1);\n            $method = $request->getMethod();\n            if ($method == 'POST' && in_array($path, ['login', 'register', 'password'])) {\n                $body = $request->getParsedBody();\n                $usernameFormFieldName = $this->getProperty('usernameFormField', 'username');\n                $passwordFormFieldName = $this->getProperty('passwordFormField', 'password');\n                $newPasswordFormFieldName = $this->getProperty('newPasswordFormField', 'newPassword');\n                $username = isset($body->$usernameFormFieldName) ? $body->$usernameFormFieldName : '';\n                $password = isset($body->$passwordFormFieldName) ? $body->$passwordFormFieldName : '';\n                $newPassword = isset($body->$newPasswordFormFieldName) ? $body->$newPasswordFormFieldName : '';\n                //add separate property for login as this could be a view joining users table to other table \n                //such as roles, details etc. At a minimum, the view output should include the $usernameColumn and $passwordColumn\n                if ($path === 'login') {\n                    $tableName = $this->getProperty('loginTable', $this->getProperty('usersTable', 'users'));\n                } else {\n                    $tableName = $this->getProperty('usersTable', 'users');\n                }\n                $table = $this->reflection->getTable($tableName);\n                $usernameColumnName = $this->getProperty('usernameColumn', 'username');\n                $usernameColumn = $table->getColumn($usernameColumnName);\n                $passwordColumnName = $this->getProperty('passwordColumn', 'password');\n                $passwordLength = $this->getProperty('passwordLength', '12');\n                $pkName = $table->getPk()->getName();\n                $registerUser = $this->getProperty('registerUser', '');\n                $loginAfterRegistration = $this->getProperty('loginAfterRegistration', '');\n                $condition = new ColumnCondition($usernameColumn, 'eq', $username);\n                $returnedColumns = $this->getProperty('returnedColumns', '');\n                if (!$returnedColumns) {\n                    $columnNames = $table->getColumnNames();\n                } else {\n                    $columnNames = array_map('trim', explode(',', $returnedColumns));\n                    $columnNames[] = $passwordColumnName;\n                    $columnNames = array_values(array_unique($columnNames));\n                }\n                $columnOrdering = $this->ordering->getDefaultColumnOrdering($table);\n                if ($path == 'register') {\n                    if (!$registerUser) {\n                        return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                    }\n                    if (strlen(trim($username)) == 0) {\n                        return $this->responder->error(ErrorCode::USERNAME_EMPTY, $username);\n                    }\n                    if (strlen($password) < $passwordLength) {\n                        return $this->responder->error(ErrorCode::PASSWORD_TOO_SHORT, $passwordLength);\n                    }\n                    $users = $this->db->selectAll($table, $columnNames, $condition, $columnOrdering, 0, 1);\n                    if (!empty($users)) {\n                        return $this->responder->error(ErrorCode::USER_ALREADY_EXIST, $username);\n                    }\n                    $data = json_decode($registerUser, true);\n                    $data = is_array($data) ? $data : [];\n                    $data[$usernameColumnName] = $username;\n                    $data[$passwordColumnName] = password_hash($password, PASSWORD_DEFAULT);\n                    $this->db->createSingle($table, $data);\n                    $users = $this->db->selectAll($table, $columnNames, $condition, $columnOrdering, 0, 1);\n                    foreach ($users as $user) {\n                        if ($loginAfterRegistration) {\n                            if (!headers_sent()) {\n                                session_regenerate_id(true);\n                            }\n                            unset($user[$passwordColumnName]);\n                            $_SESSION['user'] = $user;\n                            return $this->responder->success($user);\n                        } else {\n                            unset($user[$passwordColumnName]);\n                            return $this->responder->success($user);\n                        }\n                    }\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                }\n                if ($path == 'login') {\n                    $users = $this->db->selectAll($table, $columnNames, $condition, $columnOrdering, 0, 1);\n                    foreach ($users as $user) {\n                        if (password_verify($password, $user[$passwordColumnName]) == 1) {\n                            if (!headers_sent()) {\n                                session_regenerate_id(true);\n                            }\n                            unset($user[$passwordColumnName]);\n                            $_SESSION['user'] = $user;\n                            return $this->responder->success($user);\n                        }\n                    }\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                }\n                if ($path == 'password') {\n                    if ($username != ($_SESSION['user'][$usernameColumnName] ?? '')) {\n                        return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                    }\n                    if (strlen($newPassword) < $passwordLength) {\n                        return $this->responder->error(ErrorCode::PASSWORD_TOO_SHORT, $passwordLength);\n                    }\n                    $userColumns = $columnNames;\n                    if (!in_array($pkName, $columnNames)) {\n                        array_push($userColumns, $pkName);\n                    }\n                    $users = $this->db->selectAll($table, $userColumns, $condition, $columnOrdering, 0, 1);\n                    foreach ($users as $user) {\n                        if (password_verify($password, $user[$passwordColumnName]) == 1) {\n                            if (!headers_sent()) {\n                                session_regenerate_id(true);\n                            }\n                            $data = [$passwordColumnName => password_hash($newPassword, PASSWORD_DEFAULT)];\n                            $this->db->updateSingle($table, $data, $user[$pkName]);\n                            unset($user[$passwordColumnName]);\n                            if (!in_array($pkName, $columnNames)) {\n                                unset($user[$pkName]);\n                            }\n                            return $this->responder->success($user);\n                        }\n                    }\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n                }\n            }\n            if ($method == 'POST' && $path == 'logout') {\n                if (isset($_SESSION['user'])) {\n                    $user = $_SESSION['user'];\n                    unset($_SESSION['user']);\n                    if (session_status() != PHP_SESSION_NONE) {\n                        session_destroy();\n                    }\n                    return $this->responder->success($user);\n                }\n                return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n            }\n            if ($method == 'GET' && $path == 'me') {\n                if (isset($_SESSION['user'])) {\n                    return $this->responder->success($_SESSION['user']);\n                }\n                return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n            }\n            if (!isset($_SESSION['user']) || !$_SESSION['user']) {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/FirewallMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n\n    class FirewallMiddleware extends Middleware\n    {\n        private function ipMatch(string $ip, string $cidr): bool\n        {\n            if (strpos($cidr, '/') !== false) {\n                list($subnet, $mask) = explode('/', trim($cidr));\n                if ((ip2long($ip) & ~((1 << (32 - $mask)) - 1)) == ip2long($subnet)) {\n                    return true;\n                }\n            } else {\n                if (ip2long($ip) == ip2long($cidr)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private function isIpAllowed(string $ipAddress, string $allowedIpAddresses): bool\n        {\n            foreach (explode(',', $allowedIpAddresses) as $allowedIp) {\n                if ($this->ipMatch($ipAddress, $allowedIp)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private function getIpAddress(ServerRequestInterface $request): string\n        {\n            $reverseProxy = $this->getProperty('reverseProxy', '');\n            if ($reverseProxy) {\n                $ipAddress = array_pop($request->getHeader('X-Forwarded-For'));\n            } else {\n                $serverParams = $request->getServerParams();\n                $ipAddress = $serverParams['REMOTE_ADDR'] ?? '127.0.0.1';\n            }\n            return $ipAddress;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $ipAddress = $this->getIpAddress($request);\n            $allowedIpAddresses = $this->getProperty('allowedIpAddresses', '');\n            if (!$this->isIpAllowed($ipAddress, $allowedIpAddresses)) {\n                $response = $this->responder->error(ErrorCode::TEMPORARY_OR_PERMANENTLY_BLOCKED, '');\n            } else {\n                $response = $next->handle($request);\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/IpAddressMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class IpAddressMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        private function callHandler(ServerRequestInterface $request, $record, string $operation, ReflectedTable $table) /*: object */\n        {\n            $context = (array) $record;\n            $columnNames = $this->getProperty('columns', '');\n            if ($columnNames) {\n                foreach (explode(',', $columnNames) as $columnName) {\n                    if ($table->hasColumn($columnName)) {\n                        if ($operation == 'create') {\n                            $context[$columnName] = $this->getIpAddress($request);\n                        } else {\n                            unset($context[$columnName]);\n                        }\n                    }\n                }\n            }\n            return (object) $context;\n        }\n\n        private function getIpAddress(ServerRequestInterface $request): string\n        {\n            $reverseProxy = $this->getProperty('reverseProxy', '');\n            if ($reverseProxy) {\n                $ipAddress = array_pop($request->getHeader('X-Forwarded-For'));\n            } else {\n                $serverParams = $request->getServerParams();\n                $ipAddress = $serverParams['REMOTE_ADDR'] ?? '127.0.0.1';\n            }\n            return $ipAddress;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            if (in_array($operation, ['create', 'update', 'increment'])) {\n                $tableNames = $this->getProperty('tables', '');\n                $tableName = RequestUtils::getPathSegment($request, 2);\n                if (!$tableNames || in_array($tableName, explode(',', $tableNames))) {\n                    if ($this->reflection->hasTable($tableName)) {\n                        $record = $request->getParsedBody();\n                        if ($record !== null) {\n                            $table = $this->reflection->getTable($tableName);\n                            if (is_array($record)) {\n                                foreach ($record as &$r) {\n                                    $r = $this->callHandler($request, $r, $operation, $table);\n                                }\n                            } else {\n                                $record = $this->callHandler($request, $record, $operation, $table);\n                            }\n                            $request = $request->withParsedBody($record);\n                        }\n                    }\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/JoinLimitsMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class JoinLimitsMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            $params = RequestUtils::getParams($request);\n            if (in_array($operation, ['read', 'list']) && isset($params['join'])) {\n                $maxDepth = (int) $this->getProperty('depth', '3');\n                $maxTables = (int) $this->getProperty('tables', '10');\n                $maxRecords = (int) $this->getProperty('records', '1000');\n                $tableCount = 0;\n                $joinPaths = array();\n                for ($i = 0; $i < count($params['join']); $i++) {\n                    $joinPath = array();\n                    $tables = explode(',', $params['join'][$i]);\n                    for ($depth = 0; $depth < min($maxDepth, count($tables)); $depth++) {\n                        array_push($joinPath, $tables[$depth]);\n                        $tableCount += 1;\n                        if ($tableCount == $maxTables) {\n                            break;\n                        }\n                    }\n                    array_push($joinPaths, implode(',', $joinPath));\n                    if ($tableCount == $maxTables) {\n                        break;\n                    }\n                }\n                $params['join'] = $joinPaths;\n                $request = RequestUtils::setParams($request, $params);\n                VariableStore::set(\"joinLimits.maxRecords\", $maxRecords);\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/JsonMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n\n    class JsonMiddleware extends Middleware\n    {\n        private function convertJsonRequestValue($value) /*: object */\n        {\n            if (is_array($value) || is_object($value)) {\n                $value = json_encode($value,JSON_UNESCAPED_UNICODE);\n            }\n            return $value;\n        }\n        \n        private function convertJsonRequest($object, array $columnNames) /*: object */\n        {\n            if (is_array($object)) {\n                foreach ($object as $i => $obj) {\n                    foreach ($obj as $k => $v) {\n                        if (in_array('all', $columnNames) || in_array($k, $columnNames)) {\n                            $object[$i]->$k = $this->convertJsonRequestValue($v);\n                        }\n                    }\n                }\n            } else if (is_object($object)) {\n                foreach ($object as $k => $v) {\n                    if (in_array('all', $columnNames) || in_array($k, $columnNames)) {\n                        $object->$k = $this->convertJsonRequestValue($v);\n                    }\n                }\n            }\n            return $object;\n        }\n\n        private function convertJsonResponseValue(string $value) /*: object */\n        {\n            if (strlen($value) > 0 && in_array($value[0],['[','{'])) {\n                $parsed = json_decode($value);\n                if (json_last_error() == JSON_ERROR_NONE) {\n                    $value = $parsed;\n                }\n            }\n            return $value;\n        }\n\n        private function convertJsonResponse($object, array $columnNames) /*: object */\n        {\n            if (is_array($object)) {\n                foreach ($object as $k => $v) {\n                    $object[$k] = $this->convertJsonResponse($v, $columnNames);\n                }\n            } else if (is_object($object)) {\n                foreach ($object as $k => $v) {\n                    if (in_array('all', $columnNames) || in_array($k, $columnNames)) {\n                        $object->$k = $this->convertJsonResponse($v, $columnNames);\n                    }\n                }\n            } else if (is_string($object)) {\n                $object = $this->convertJsonResponseValue($object);\n            }\n            return $object;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            $controllerPath = RequestUtils::getPathSegment($request, 1);\n            $tableName = RequestUtils::getPathSegment($request, 2);\n\n            $controllerPaths = $this->getArrayProperty('controllers', 'records,geojson');\n    \t\t$tableNames = $this->getArrayProperty('tables', 'all');\n    \t\t$columnNames = $this->getArrayProperty('columns', 'all');\n    \t\tif (\n    \t\t\t(in_array('all', $controllerPaths) || in_array($controllerPath, $controllerPaths)) &&\n    \t\t\t(in_array('all', $tableNames) || in_array($tableName, $tableNames))\n    \t\t) {\n                if (in_array($operation, ['create', 'update'])) {\n                    $records = $request->getParsedBody();\n                    $records = $this->convertJsonRequest($records,$columnNames);\n                    $request = $request->withParsedBody($records);\n                }\n                $response = $next->handle($request);\n                if (in_array($operation, ['read', 'list'])) {\n                    if ($response->getStatusCode() == ResponseFactory::OK) {\n                        $records = json_decode($response->getBody()->getContents());\n                        $records = $this->convertJsonResponse($records, $columnNames);\n                        $response = $this->responder->success($records);\n                    }\n                }\n            } else {\n                $response = $next->handle($request);\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/JwtAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class JwtAuthMiddleware extends Middleware\n    {\n        private function getVerifiedClaims(string $token, int $time, int $leeway, int $ttl, array $secrets, array $requirements): array\n        {\n            $algorithms = array(\n                'HS256' => 'sha256',\n                'HS384' => 'sha384',\n                'HS512' => 'sha512',\n                'RS256' => 'sha256',\n                'RS384' => 'sha384',\n                'RS512' => 'sha512',\n            );\n            $token = explode('.', $token);\n            if (count($token) < 3) {\n                return array();\n            }\n            $header = json_decode(base64_decode(strtr($token[0], '-_', '+/')), true);\n            $kid = 0;\n            if (isset($header['kid'])) {\n                $kid = $header['kid'];\n            }\n            if (!isset($secrets[$kid])) {\n                return array();\n            }\n            $secret = $secrets[$kid];\n            if ($header['typ'] != 'JWT') {\n                return array();\n            }\n            $algorithm = $header['alg'];\n            if (!isset($algorithms[$algorithm])) {\n                return array();\n            }\n            if (!empty($requirements['alg']) && !in_array($algorithm, $requirements['alg'])) {\n                return array();\n            }\n            $hmac = $algorithms[$algorithm];\n            $signature = base64_decode(strtr($token[2], '-_', '+/'));\n            $data = \"$token[0].$token[1]\";\n            switch ($algorithm[0]) {\n                case 'H':\n                    $hash = hash_hmac($hmac, $data, $secret, true);\n                    $equals = hash_equals($hash, $signature);\n                    if (!$equals) {\n                        return array();\n                    }\n                    break;\n                case 'R':\n                    $equals = openssl_verify($data, $signature, $secret, $hmac) == 1;\n                    if (!$equals) {\n                        return array();\n                    }\n                    break;\n            }\n            $claims = json_decode(base64_decode(strtr($token[1], '-_', '+/')), true);\n            if (!$claims) {\n                return array();\n            }\n            foreach ($requirements as $field => $values) {\n                if (!empty($values)) {\n                    if ($field != 'alg') {\n                        if (!isset($claims[$field])) {\n                            return array();\n                        }\n                        if (is_array($claims[$field])) {\n                            if (!array_intersect($claims[$field], $values)) {\n                                return array();\n                            }\n                        } else {\n                            if (!in_array($claims[$field], $values)) {\n                                return array();\n                            }\n                        }\n                    }\n                }\n            }\n            if (isset($claims['nbf']) && $time + $leeway < $claims['nbf']) {\n                return array();\n            }\n            if (isset($claims['iat']) && $time + $leeway < $claims['iat']) {\n                return array();\n            }\n            if (isset($claims['exp']) && $time - $leeway > $claims['exp']) {\n                return array();\n            }\n            if (isset($claims['iat']) && !isset($claims['exp'])) {\n                if ($time - $leeway > $claims['iat'] + $ttl) {\n                    return array();\n                }\n            }\n            return $claims;\n        }\n\n        private function getClaims(string $token): array\n        {\n            $time = (int) $this->getProperty('time', time());\n            $leeway = (int) $this->getProperty('leeway', '5');\n            $ttl = (int) $this->getProperty('ttl', '30');\n            $secrets = $this->getMapProperty('secrets', '');\n            if (!$secrets) {\n                $secrets = [$this->getProperty('secret', '')];\n            }\n            $requirements = array(\n                'alg' => $this->getArrayProperty('algorithms', ''),\n                'aud' => $this->getArrayProperty('audiences', ''),\n                'iss' => $this->getArrayProperty('issuers', ''),\n            );\n            return $this->getVerifiedClaims($token, $time, $leeway, $ttl, $secrets, $requirements);\n        }\n\n        private function getAuthorizationToken(ServerRequestInterface $request): string\n        {\n            $headerName = $this->getProperty('header', 'X-Authorization');\n            $headerValue = RequestUtils::getHeader($request, $headerName);\n            $parts = explode(' ', trim($headerValue), 2);\n            if (count($parts) != 2) {\n                return '';\n            }\n            if ($parts[0] != 'Bearer') {\n                return '';\n            }\n            return $parts[1];\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            if (session_status() == PHP_SESSION_NONE) {\n                if (!headers_sent()) {\n                    $sessionName = $this->getProperty('sessionName', '');\n                    if ($sessionName) {\n                        session_name($sessionName);\n                    }\n                    if (!ini_get('session.cookie_samesite')) {\n                        ini_set('session.cookie_samesite', 'Lax');\n                    }\n                    if (!ini_get('session.cookie_httponly')) {\n                        ini_set('session.cookie_httponly', 1);\n                    }\n                    if (!ini_get('session.cookie_secure') && isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] != 'off') {\n                        ini_set('session.cookie_secure', 1);\n                    }\n                    session_start();\n                }\n            }\n            $token = $this->getAuthorizationToken($request);\n            if ($token) {\n                $claims = $this->getClaims($token);\n                $_SESSION['claims'] = $claims;\n                if (empty($claims)) {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, 'JWT');\n                }\n                if (!headers_sent()) {\n                    session_regenerate_id();\n                }\n            }\n            if (empty($_SESSION['claims'])) {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/MultiTenancyMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\Condition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\NoCondition;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class MultiTenancyMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        private function getCondition(string $tableName, array $pairs): Condition\n        {\n            $condition = new NoCondition();\n            $table = $this->reflection->getTable($tableName);\n            foreach ($pairs as $k => $v) {\n                $condition = $condition->_and(new ColumnCondition($table->getColumn($k), 'eq', $v));\n            }\n            return $condition;\n        }\n\n        private function getPairs($handler, string $operation, string $tableName): array\n        {\n            $result = array();\n            $pairs = call_user_func($handler, $operation, $tableName) ?: [];\n            $table = $this->reflection->getTable($tableName);\n            foreach ($pairs as $k => $v) {\n                if ($table->hasColumn($k)) {\n                    $result[$k] = $v;\n                }\n            }\n            return $result;\n        }\n\n        private function handleRecord(ServerRequestInterface $request, string $operation, array $pairs): ServerRequestInterface\n        {\n            $record = $request->getParsedBody();\n            if ($record === null) {\n                return $request;\n            }\n            $multi = is_array($record);\n            $records = $multi ? $record : [$record];\n            foreach ($records as &$record) {\n                foreach ($pairs as $column => $value) {\n                    if ($operation == 'create') {\n                        $record->$column = $value;\n                    } else {\n                        if (isset($record->$column)) {\n                            unset($record->$column);\n                        }\n                    }\n                }\n            }\n            return $request->withParsedBody($multi ? $records : $records[0]);\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $handler = $this->getProperty('handler', '');\n            if ($handler !== '') {\n                $path = RequestUtils::getPathSegment($request, 1);\n                if ($path == 'records') {\n                    $operation = RequestUtils::getOperation($request);\n                    $tableNames = RequestUtils::getTableNames($request, $this->reflection);\n                    foreach ($tableNames as $i => $tableName) {\n                        if (!$this->reflection->hasTable($tableName)) {\n                            continue;\n                        }\n                        $pairs = $this->getPairs($handler, $operation, $tableName);\n                        if ($i == 0) {\n                            if (in_array($operation, ['create', 'update', 'increment'])) {\n                                $request = $this->handleRecord($request, $operation, $pairs);\n                            }\n                        }\n                        $condition = $this->getCondition($tableName, $pairs);\n                        VariableStore::set(\"multiTenancy.conditions.$tableName\", $condition);\n                    }\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/PageLimitsMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class PageLimitsMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            if ($operation == 'list') {\n                $params = RequestUtils::getParams($request);\n                $maxPage = (int) $this->getProperty('pages', '100');\n                if (isset($params['page']) && $params['page'] && $maxPage > 0) {\n                    if (strpos($params['page'][0], ',') === false) {\n                        $page = $params['page'][0];\n                    } else {\n                        list($page, $size) = explode(',', $params['page'][0], 2);\n                    }\n                    if ($page > $maxPage) {\n                        return $this->responder->error(ErrorCode::PAGINATION_FORBIDDEN, '');\n                    }\n                }\n                $maxSize = (int) $this->getProperty('records', '1000');\n                if (!isset($params['size']) || !$params['size'] && $maxSize > 0) {\n                    $params['size'] = array($maxSize);\n                } else {\n                    $params['size'] = array(min($params['size'][0], $maxSize));\n                }\n                $request = RequestUtils::setParams($request, $params);\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/ReconnectMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n\n    class ReconnectMiddleware extends Middleware\n    {\n        private $config;\n        private $db;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection, GenericDB $db)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->config = $config;\n            $this->db = $db;\n        }\n\n        private function getDriver(): string\n        {\n            $driverHandler = $this->getProperty('driverHandler', '');\n            if ($driverHandler) {\n                return call_user_func($driverHandler);\n            }\n            return $this->config->getDriver();\n        }\n\n        private function getAddress(): string\n        {\n            $addressHandler = $this->getProperty('addressHandler', '');\n            if ($addressHandler) {\n                return call_user_func($addressHandler);\n            }\n            return $this->config->getAddress();\n        }\n\n        private function getPort(): int\n        {\n            $portHandler = $this->getProperty('portHandler', '');\n            if ($portHandler) {\n                return call_user_func($portHandler);\n            }\n            return $this->config->getPort();\n        }\n\n        private function getDatabase(): string\n        {\n            $databaseHandler = $this->getProperty('databaseHandler', '');\n            if ($databaseHandler) {\n                return call_user_func($databaseHandler);\n            }\n            return $this->config->getDatabase();\n        }\n\n        private function getCommand(): string\n        {\n            $commandHandler = $this->getProperty('commandHandler', '');\n            if ($commandHandler) {\n                return call_user_func($commandHandler);\n            }\n            return $this->config->getCommand();\n        }\n\n        private function getTables(): array\n        {\n            $tablesHandler = $this->getProperty('tablesHandler', '');\n            if ($tablesHandler) {\n                return call_user_func($tablesHandler);\n            }\n            return $this->config->getTables();\n        }\n\n        private function getMapping(): array\n        {\n            $mappingHandler = $this->getProperty('mappingHandler', '');\n            if ($mappingHandler) {\n                return call_user_func($mappingHandler);\n            }\n            return $this->config->getMapping();\n        }\n\n        private function getUsername(): string\n        {\n            $usernameHandler = $this->getProperty('usernameHandler', '');\n            if ($usernameHandler) {\n                return call_user_func($usernameHandler);\n            }\n            return $this->config->getUsername();\n        }\n\n        private function getPassword(): string\n        {\n            $passwordHandler = $this->getProperty('passwordHandler', '');\n            if ($passwordHandler) {\n                return call_user_func($passwordHandler);\n            }\n            return $this->config->getPassword();\n        }\n\n        private function getGeometrySrid(): int\n        {\n            $geometrySridHandler = $this->getProperty('geometrySridHandler', '');\n            if ($geometrySridHandler) {\n                return call_user_func($geometrySridHandler);\n            }\n            return $this->config->getGeometrySrid();\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $driver = $this->getDriver();\n            $address = $this->getAddress();\n            $port = $this->getPort();\n            $database = $this->getDatabase();\n            $command = $this->getCommand();\n            $tables = $this->getTables();\n            $mapping = $this->getMapping();\n            $username = $this->getUsername();\n            $password = $this->getPassword();\n            $geometrySrid = $this->getGeometrySrid();\n            $this->db->reconstruct($driver, $address, $port, $database, $command, $tables, $mapping, $username, $password, $geometrySrid);\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/SanitationMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class SanitationMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        private function callHandler($handler, $record, string $operation, ReflectedTable $table) /*: object */\n        {\n            $context = (array) $record;\n            $tableName = $table->getName();\n            foreach ($context as $columnName => &$value) {\n                if ($table->hasColumn($columnName)) {\n                    $column = $table->getColumn($columnName);\n                    $value = call_user_func($handler, $operation, $tableName, $column->serialize(), $value);\n                    $value = $this->sanitizeType($table, $column, $value);\n                }\n            }\n            return (object) $context;\n        }\n\n        private function sanitizeType(ReflectedTable $table, ReflectedColumn $column, $value)\n        {\n            $tables = $this->getArrayProperty('tables', 'all');\n            $types = $this->getArrayProperty('types', 'all');\n            if (\n                (in_array('all', $tables) || in_array($table->getName(), $tables)) &&\n                (in_array('all', $types) || in_array($column->getType(), $types))\n            ) {\n                if (is_null($value)) {\n                    return $value;\n                }\n                if (is_string($value)) {\n                    $newValue = null;\n                    switch ($column->getType()) {\n                        case 'integer':\n                        case 'bigint':\n                            $newValue = filter_var(trim($value), FILTER_VALIDATE_INT, FILTER_NULL_ON_FAILURE);\n                            break;\n                        case 'decimal':\n                            $newValue = filter_var(trim($value), FILTER_VALIDATE_FLOAT, FILTER_NULL_ON_FAILURE);\n                            if (is_float($newValue)) {\n                                $newValue = number_format($newValue, $column->getScale(), '.', '');\n                            }\n                            break;\n                        case 'float':\n                        case 'double':\n                            $newValue = filter_var(trim($value), FILTER_VALIDATE_FLOAT, FILTER_NULL_ON_FAILURE);\n                            break;\n                        case 'boolean':\n                            $newValue = filter_var(trim($value), FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE);\n                            break;\n                        case 'date':\n                            $time = strtotime(trim($value));\n                            if ($time !== false) {\n                                $newValue = date('Y-m-d', $time);\n                            }\n                            break;\n                        case 'time':\n                            $time = strtotime(trim($value));\n                            if ($time !== false) {\n                                $newValue = date('H:i:s', $time);\n                            }\n                            break;\n                        case 'timestamp':\n                            $time = strtotime(trim($value));\n                            if ($time !== false) {\n                                $newValue = date('Y-m-d H:i:s', $time);\n                            }\n                            break;\n                        case 'blob':\n                        case 'varbinary':\n                            // allow base64url format\n                            $newValue = strtr(trim($value), '-_', '+/');\n                            break;\n                        case 'clob':\n                        case 'varchar':\n                            $newValue = $value;\n                            break;\n                        case 'geometry':\n                            $newValue = trim($value);\n                            break;\n                    }\n                    if (!is_null($newValue)) {\n                        $value = $newValue;\n                    }\n                } else {\n                    switch ($column->getType()) {\n                        case 'integer':\n                        case 'bigint':\n                            if (is_float($value)) {\n                                $value = (int) round($value);\n                            }\n                            break;\n                        case 'decimal':\n                            if (is_float($value) || is_int($value)) {\n                                $value = number_format((float) $value, $column->getScale(), '.', '');\n                            }\n                            break;\n                    }\n                }\n                // post process\n            }\n            return $value;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            if (in_array($operation, ['create', 'update', 'increment'])) {\n                $tableName = RequestUtils::getPathSegment($request, 2);\n                if ($this->reflection->hasTable($tableName)) {\n                    $record = $request->getParsedBody();\n                    if ($record !== null) {\n                        $handler = $this->getProperty('handler', '');\n                        if ($handler !== '') {\n                            $table = $this->reflection->getTable($tableName);\n                            if (is_array($record)) {\n                                foreach ($record as &$r) {\n                                    $r = $this->callHandler($handler, $r, $operation, $table);\n                                }\n                            } else {\n                                $record = $this->callHandler($handler, $record, $operation, $table);\n                            }\n                            $request = $request->withParsedBody($record);\n                        }\n                    }\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/SslRedirectMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n\n    class SslRedirectMiddleware extends Middleware\n    {\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $uri = $request->getUri();\n            $scheme = $uri->getScheme();\n            if ($scheme == 'http') {\n                $uri = $request->getUri();\n                $uri = $uri->withScheme('https');\n                $response = ResponseFactory::fromStatus(301);\n                $response = $response->withHeader('Location', $uri->__toString());\n            } else {\n                $response = $next->handle($request);\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/TextSearchMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class TextSearchMiddleware extends Middleware\n    {\n        private $reflection;\n\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n            $this->reflection = $reflection;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $operation = RequestUtils::getOperation($request);\n            if ($operation == 'list') {\n                $tableName = RequestUtils::getPathSegment($request, 2);\n                $params = RequestUtils::getParams($request);\n                $parameterName = $this->getProperty('parameter', 'search');\n                if (isset($params[$parameterName])) {\n                    $search = $params[$parameterName][0];\n                    unset($params[$parameterName]);\n                    $table = $this->reflection->getTable($tableName);\n                    $i = 0;\n                    foreach ($table->getColumnNames() as $columnName) {\n                        $column = $table->getColumn($columnName);\n                        while (isset($params[\"filter$i\"])) {\n                            $i++;\n                        }\n                        if ($i >= 10) {\n                            break;\n                        }\n                        if ($column->isText()) {\n                            $params[\"filter$i\"] = \"$columnName,cs,$search\";\n                            $i++;\n                        }\n                    }\n                }\n                $request = RequestUtils::setParams($request, $params);\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/ValidationMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class ValidationMiddleware extends Middleware\n    {\n    \tprivate $reflection;\n\n    \tpublic function __construct(Router $router, Responder $responder, Config $config, string $middleware, ReflectionService $reflection)\n    \t{\n    \t\tparent::__construct($router, $responder, $config, $middleware);\n    \t\t$this->reflection = $reflection;\n    \t}\n\n    \tprivate function callHandler($handler, $record, string $operation, ReflectedTable $table) /*: ResponseInterface?*/\n    \t{\n    \t\t$context = (array) $record;\n    \t\t$details = array();\n    \t\t$tableName = $table->getName();\n    \t\tforeach ($context as $columnName => $value) {\n    \t\t\tif ($table->hasColumn($columnName)) {\n    \t\t\t\t$column = $table->getColumn($columnName);\n    \t\t\t\t$valid = call_user_func($handler, $operation, $tableName, $column->serialize(), $value, $context);\n    \t\t\t\tif ($valid === true || $valid === '') {\n    \t\t\t\t\t$valid = $this->validateType($table, $column, $value);\n    \t\t\t\t}\n    \t\t\t\tif ($valid !== true && $valid !== '') {\n    \t\t\t\t\t$details[$columnName] = $valid;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tif (count($details) > 0) {\n    \t\t\treturn $this->responder->error(ErrorCode::INPUT_VALIDATION_FAILED, $tableName, $details);\n    \t\t}\n    \t\treturn null;\n    \t}\n\n    \tprivate function validateType(ReflectedTable $table, ReflectedColumn $column, $value)\n    \t{\n    \t\t$tables = $this->getArrayProperty('tables', 'all');\n    \t\t$types = $this->getArrayProperty('types', 'all');\n    \t\tif (\n    \t\t\t(in_array('all', $tables) || in_array($table->getName(), $tables)) &&\n    \t\t\t(in_array('all', $types) || in_array($column->getType(), $types))\n    \t\t) {\n    \t\t\tif (is_null($value)) {\n    \t\t\t\treturn ($column->getNullable() ? true : \"cannot be null\");\n    \t\t\t}\n    \t\t\tif (is_string($value)) {\n    \t\t\t\t// check for whitespace\n    \t\t\t\tswitch ($column->getType()) {\n    \t\t\t\t\tcase 'varchar':\n    \t\t\t\t\tcase 'clob':\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tdefault:\n    \t\t\t\t\t\tif (strlen(trim($value)) != strlen($value)) {\n    \t\t\t\t\t\t\treturn 'illegal whitespace';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\t// try to parse\n    \t\t\t\tswitch ($column->getType()) {\n    \t\t\t\t\tcase 'integer':\n    \t\t\t\t\tcase 'bigint':\n    \t\t\t\t\t\tif (\n    \t\t\t\t\t\t\tfilter_var($value, FILTER_SANITIZE_NUMBER_INT) !== $value ||\n    \t\t\t\t\t\t\tfilter_var($value, FILTER_VALIDATE_INT) === false\n    \t\t\t\t\t\t) {\n    \t\t\t\t\t\t\treturn 'invalid integer';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'decimal':\n    \t\t\t\t\t\tif (strpos($value, '.') !== false) {\n    \t\t\t\t\t\t\tlist($whole, $decimals) = explode('.', ltrim($value, '-'), 2);\n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\tlist($whole, $decimals) = array(ltrim($value, '-'), '');\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif (strlen($whole) > 0 && !ctype_digit($whole)) {\n    \t\t\t\t\t\t\treturn 'invalid decimal';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif (strlen($decimals) > 0 && !ctype_digit($decimals)) {\n    \t\t\t\t\t\t\treturn 'invalid decimal';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif (strlen($whole) > $column->getPrecision() - $column->getScale()) {\n    \t\t\t\t\t\t\treturn 'decimal too large';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif (strlen($decimals) > $column->getScale()) {\n    \t\t\t\t\t\t\treturn 'decimal too precise';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'float':\n    \t\t\t\t\tcase 'double':\n    \t\t\t\t\t\tif (\n    \t\t\t\t\t\t\tfilter_var($value, FILTER_SANITIZE_NUMBER_FLOAT) !== $value ||\n    \t\t\t\t\t\t\tfilter_var($value, FILTER_VALIDATE_FLOAT) === false\n    \t\t\t\t\t\t) {\n    \t\t\t\t\t\t\treturn 'invalid float';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'boolean':\n    \t\t\t\t\t\tif (!in_array(strtolower($value), array('true', 'false'))) {\n    \t\t\t\t\t\t\treturn 'invalid boolean';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'date':\n    \t\t\t\t\t\tif (date_create_from_format('Y-m-d', $value) === false) {\n    \t\t\t\t\t\t\treturn 'invalid date';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'time':\n    \t\t\t\t\t\tif (date_create_from_format('H:i:s', $value) === false) {\n    \t\t\t\t\t\t\treturn 'invalid time';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'timestamp':\n    \t\t\t\t\t\tif (date_create_from_format('Y-m-d H:i:s', $value) === false) {\n    \t\t\t\t\t\t\treturn 'invalid timestamp';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'clob':\n    \t\t\t\t\tcase 'varchar':\n    \t\t\t\t\t\tif ($column->hasLength() && mb_strlen($value, 'UTF-8') > $column->getLength()) {\n    \t\t\t\t\t\t\treturn 'string too long';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'blob':\n    \t\t\t\t\tcase 'varbinary':\n    \t\t\t\t\t\tif (base64_decode($value, true) === false) {\n    \t\t\t\t\t\t\treturn 'invalid base64';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif ($column->hasLength() && strlen(base64_decode($value)) > $column->getLength()) {\n    \t\t\t\t\t\t\treturn 'string too long';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'geometry':\n    \t\t\t\t\t\t// no checks yet\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t} else { // check non-string types\n    \t\t\t\tswitch ($column->getType()) {\n    \t\t\t\t\tcase 'integer':\n    \t\t\t\t\tcase 'bigint':\n    \t\t\t\t\t\tif (!is_int($value)) {\n    \t\t\t\t\t\t\treturn 'invalid integer';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'float':\n    \t\t\t\t\tcase 'double':\n    \t\t\t\t\t\tif (!is_float($value) && !is_int($value)) {\n    \t\t\t\t\t\t\treturn 'invalid float';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tcase 'boolean':\n    \t\t\t\t\t\tif (!is_bool($value) && ($value !== 0) && ($value !== 1)) {\n    \t\t\t\t\t\t\treturn 'invalid boolean';\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\tdefault:\n    \t\t\t\t\t\treturn 'invalid ' . $column->getType();\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t// extra checks\n    \t\t\tswitch ($column->getType()) {\n    \t\t\t\tcase 'integer': // 4 byte signed\n    \t\t\t\t\t$value = filter_var($value, FILTER_VALIDATE_INT);\n    \t\t\t\t\tif ($value > 2147483647 || $value < -2147483648) {\n    \t\t\t\t\t\treturn 'invalid integer';\n    \t\t\t\t\t}\n    \t\t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\treturn (true);\n    \t}\n\n    \tpublic function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n    \t{\n    \t\t$operation = RequestUtils::getOperation($request);\n    \t\tif (in_array($operation, ['create', 'update', 'increment'])) {\n    \t\t\t$tableName = RequestUtils::getPathSegment($request, 2);\n    \t\t\tif ($this->reflection->hasTable($tableName)) {\n    \t\t\t\t$record = $request->getParsedBody();\n    \t\t\t\tif ($record !== null) {\n    \t\t\t\t\t$handler = $this->getProperty('handler', '');\n    \t\t\t\t\tif ($handler !== '') {\n    \t\t\t\t\t\t$table = $this->reflection->getTable($tableName);\n    \t\t\t\t\t\tif (is_array($record)) {\n    \t\t\t\t\t\t\tforeach ($record as $r) {\n    \t\t\t\t\t\t\t\t$response = $this->callHandler($handler, $r, $operation, $table);\n    \t\t\t\t\t\t\t\tif ($response !== null) {\n    \t\t\t\t\t\t\t\t\treturn $response;\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\t$response = $this->callHandler($handler, $record, $operation, $table);\n    \t\t\t\t\t\t\tif ($response !== null) {\n    \t\t\t\t\t\t\t\treturn $response;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn $next->handle($request);\n    \t}\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/WpAuthMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n    use Tqdev\\PhpCrudApi\\RequestUtils;\n\n    class WpAuthMiddleware extends Middleware\n    {\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            define('WP_USE_THEMES', false); // Don't load theme support functionality\n            $wpDirectory = $this->getProperty('wpDirectory', '.');\n            require_once(\"$wpDirectory/wp-load.php\");\n            $path = RequestUtils::getPathSegment($request, 1);\n            $method = $request->getMethod();\n            if ($method == 'POST' && $path == 'login') {\n                $body = $request->getParsedBody();\n                $usernameFormFieldName = $this->getProperty('usernameFormField', 'username');\n                $passwordFormFieldName = $this->getProperty('passwordFormField', 'password');\n                $username = isset($body->$usernameFormFieldName) ? $body->$usernameFormFieldName : '';\n                $password = isset($body->$passwordFormFieldName) ? $body->$passwordFormFieldName : '';\n                $user = wp_signon([\n                    'user_login'    => $username,\n                    'user_password' => $password,\n                    'remember'      => false,\n                ]);\n                if ($user->ID) {\n                    unset($user->data->user_pass);\n                    return $this->responder->success($user);\n                }\n                return $this->responder->error(ErrorCode::AUTHENTICATION_FAILED, $username);\n            }\n            if ($method == 'POST' && $path == 'logout') {\n                if (is_user_logged_in()) {\n                    wp_logout();\n                    $user = wp_get_current_user();\n                    unset($user->data->user_pass);\n                    return $this->responder->success($user);\n                }\n                return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n            }\n            if ($method == 'GET' && $path == 'me') {\n                if (is_user_logged_in()) {\n                    $user = wp_get_current_user();\n                    unset($user->data->user_pass);\n                    return $this->responder->success($user);\n                }\n                return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n            }\n            if (!is_user_logged_in()) {\n                $authenticationMode = $this->getProperty('mode', 'required');\n                if ($authenticationMode == 'required') {\n                    return $this->responder->error(ErrorCode::AUTHENTICATION_REQUIRED, '');\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/XmlMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\Router;\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n\n    class XmlMiddleware extends Middleware\n    {\n        public function __construct(Router $router, Responder $responder, Config $config, string $middleware)\n        {\n            parent::__construct($router, $responder, $config, $middleware);\n        }\n\n        private function json2xml($json, $types = 'null,boolean,number,string,object,array')\n        {\n            $a = json_decode($json);\n            $d = new \\DOMDocument();\n            $c = $d->createElement(\"root\");\n            $d->appendChild($c);\n            $t = function ($v) {\n                $type = gettype($v);\n                switch ($type) {\n                    case 'integer':\n                        return 'number';\n                    case 'double':\n                        return 'number';\n                    default:\n                        return strtolower($type);\n                }\n            };\n            $ts = explode(',', $types);\n            $f = function ($f, $c, $a, $s = false) use ($t, $d, $ts) {\n                if (in_array($t($a), $ts)) {\n                    $c->setAttribute('type', $t($a));\n                }\n                if ($t($a) != 'array' && $t($a) != 'object') {\n                    if ($t($a) == 'boolean') {\n                        $c->appendChild($d->createTextNode($a ? 'true' : 'false'));\n                    } else {\n                        $c->appendChild($d->createTextNode($a));\n                    }\n                } else {\n                    foreach ($a as $k => $v) {\n                        $k = preg_replace('/[^a-z0-9\\-\\_\\.]/', '', $k);\n                        if ($k == '__type' && $t($a) == 'object') {\n                            $c->setAttribute('__type', $v);\n                        } else {\n                            if ($t($v) == 'object') {\n                                $ch = $c->appendChild($d->createElementNS(null, $s ? 'item' : $k));\n                                $f($f, $ch, $v);\n                            } else if ($t($v) == 'array') {\n                                $ch = $c->appendChild($d->createElementNS(null, $s ? 'item' : $k));\n                                $f($f, $ch, $v, true);\n                            } else {\n                                $va = $d->createElementNS(null, $s ? 'item' : $k);\n                                if ($t($v) == 'boolean') {\n                                    $va->appendChild($d->createTextNode($v ? 'true' : 'false'));\n                                } else {\n                                    $va->appendChild($d->createTextNode((string) $v));\n                                }\n                                $ch = $c->appendChild($va);\n                                if (in_array($t($v), $ts)) {\n                                    $ch->setAttribute('type', $t($v));\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            $f($f, $c, $a, $t($a) == 'array');\n            return $d->saveXML($d->documentElement);\n        }\n\n        private function xml2json($xml): string\n        {\n            $o = @simplexml_load_string($xml);\n            if ($o === false) {\n                return '';\n            }\n            $a = @dom_import_simplexml($o);\n            if (!$a) {\n                return '';\n            }\n            $t = function ($v) {\n                $t = $v->getAttribute('type');\n                $txt = $v->firstChild->nodeType == XML_TEXT_NODE;\n                return $t ?: ($txt ? 'string' : 'object');\n            };\n            $f = function ($f, $a) use ($t) {\n                $c = null;\n                if ($t($a) == 'null') {\n                    $c = null;\n                } else if ($t($a) == 'boolean') {\n                    $b = substr(strtolower($a->textContent), 0, 1);\n                    $c = in_array($b, array('1', 't'));\n                } else if ($t($a) == 'number') {\n                    $c = $a->textContent + 0;\n                } else if ($t($a) == 'string') {\n                    $c = $a->textContent;\n                } else if ($t($a) == 'object') {\n                    $c = array();\n                    if ($a->getAttribute('__type')) {\n                        $c['__type'] = $a->getAttribute('__type');\n                    }\n                    for ($i = 0; $i < $a->childNodes->length; $i++) {\n                        $v = $a->childNodes[$i];\n                        $c[$v->nodeName] = $f($f, $v);\n                    }\n                    $c = (object) $c;\n                } else if ($t($a) == 'array') {\n                    $c = array();\n                    for ($i = 0; $i < $a->childNodes->length; $i++) {\n                        $v = $a->childNodes[$i];\n                        $c[$i] = $f($f, $v);\n                    }\n                }\n                return $c;\n            };\n            $c = $f($f, $a);\n            return (string) json_encode($c);\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            parse_str($request->getUri()->getQuery(), $params);\n            $isXml = isset($params['format']) && $params['format'] == 'xml';\n            if ($isXml) {\n                $body = $request->getBody()->getContents();\n                if ($body) {\n                    $json = $this->xml2json($body);\n                    $request = $request->withParsedBody(json_decode($json));\n                }\n            }\n            $response = $next->handle($request);\n            if ($isXml) {\n                $body = $response->getBody()->getContents();\n                if ($body) {\n                    $types = implode(',', $this->getArrayProperty('types', 'null,array'));\n                    if ($types == '' || $types == 'all') {\n                        $xml = $this->json2xml($body);\n                    } else {\n                        $xml = $this->json2xml($body, $types);\n                    }\n                    $response = ResponseFactory::fromXml(ResponseFactory::OK, $xml);\n                }\n            }\n            return $response;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Middleware/XsrfMiddleware.php\nnamespace Tqdev\\PhpCrudApi\\Middleware {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Controller\\Responder;\n    use Tqdev\\PhpCrudApi\\Middleware\\Base\\Middleware;\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n\n    class XsrfMiddleware extends Middleware\n    {\n        private function getToken(ServerRequestInterface $request): string\n        {\n            $cookieName = $this->getProperty('cookieName', 'XSRF-TOKEN');\n            $cookieParams = $request->getCookieParams();\n            if (isset($cookieParams[$cookieName])) {\n                $token = $cookieParams[$cookieName];\n            } else {\n                $secure = $request->getUri()->getScheme() == 'https';\n                $token = bin2hex(random_bytes(8));\n                if (!headers_sent()) {\n                    setcookie($cookieName, $token, 0, '/', '', $secure);\n                }\n            }\n            return $token;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $next): ResponseInterface\n        {\n            $token = $this->getToken($request);\n            $method = $request->getMethod();\n            $excludeMethods = $this->getArrayProperty('excludeMethods', 'OPTIONS,GET');\n            if (!in_array($method, $excludeMethods)) {\n                $headerName = $this->getProperty('headerName', 'X-XSRF-TOKEN');\n                if ($token != $request->getHeader($headerName)[0]) {\n                    return $this->responder->error(ErrorCode::BAD_OR_MISSING_XSRF_TOKEN, '');\n                }\n            }\n            return $next->handle($request);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiBuilder.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiDefinition;\n\n    class OpenApiBuilder\n    {\n        private $openapi;\n        private $records;\n        private $columns;\n        private $status;\n        private $builders;\n\n        public function __construct(ReflectionService $reflection, array $base, array $controllers, array $builders)\n        {\n            $this->openapi = new OpenApiDefinition($base);\n            $this->records = in_array('records', $controllers) ? new OpenApiRecordsBuilder($this->openapi, $reflection) : null;\n            $this->columns = in_array('columns', $controllers) ? new OpenApiColumnsBuilder($this->openapi) : null;\n            $this->status = in_array('status', $controllers) ? new OpenApiStatusBuilder($this->openapi) : null;\n            $this->builders = array();\n            foreach ($builders as $className) {\n                $this->builders[] = new $className($this->openapi, $reflection);\n            }\n        }\n\n        private function getServerUrl(ServerRequestInterface $request): string\n        {\n            $uri = $request->getUri();\n            $path = $uri->getPath();\n            $uri = $uri->withPath(trim(substr($path, 0, strpos($path, '/openapi')), '/'));\n            return $uri->__toString();\n        }\n\n        public function build(ServerRequestInterface $request): OpenApiDefinition\n        {\n            $this->openapi->set(\"openapi\", \"3.0.0\");\n            if (!$this->openapi->has(\"servers\")) {\n                $this->openapi->set(\"servers||url\", $this->getServerUrl($request));\n            }\n            if ($this->records) {\n                $this->records->build();\n            }\n            if ($this->columns) {\n                $this->columns->build();\n            }\n            if ($this->status) {\n                $this->status->build();\n            }\n            foreach ($this->builders as $builder) {\n                $builder->build();\n            }\n            return $this->openapi;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiColumnsBuilder.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiDefinition;\n\n    class OpenApiColumnsBuilder\n    {\n        private $openapi;\n        private $operations = [\n            'database' => [\n                'read' => 'get',\n            ],\n            'table' => [\n                'create' => 'post',\n                'read' => 'get',\n                'update' => 'put', //rename\n                'delete' => 'delete',\n            ],\n            'column' => [\n                'create' => 'post',\n                'read' => 'get',\n                'update' => 'put',\n                'delete' => 'delete',\n            ],\n        ];\n\n        public function __construct(OpenApiDefinition $openapi)\n        {\n            $this->openapi = $openapi;\n        }\n\n        public function build() /*: void*/\n        {\n            $this->setPaths();\n            $this->openapi->set(\"components|responses|bool-success|description\", \"boolean indicating success or failure\");\n            $this->openapi->set(\"components|responses|bool-success|content|application/json|schema|type\", \"boolean\");\n            $this->setComponentSchema();\n            $this->setComponentResponse();\n            $this->setComponentRequestBody();\n            $this->setComponentParameters();\n            foreach (array_keys($this->operations) as $type) {\n                $this->setTag($type);\n            }\n        }\n\n        private function setPaths() /*: void*/\n        {\n            foreach (array_keys($this->operations) as $type) {\n                foreach ($this->operations[$type] as $operation => $method) {\n                    $parameters = [];\n                    switch ($type) {\n                        case 'database':\n                            $path = '/columns';\n                            break;\n                        case 'table':\n                            $path = $operation == 'create' ? '/columns' : '/columns/{table}';\n                            break;\n                        case 'column':\n                            $path = $operation == 'create' ? '/columns/{table}' : '/columns/{table}/{column}';\n                            break;\n                    }\n                    if (strpos($path, '{table}')) {\n                        $parameters[] = 'table';\n                    }\n                    if (strpos($path, '{column}')) {\n                        $parameters[] = 'column';\n                    }\n                    foreach ($parameters as $parameter) {\n                        $this->openapi->set(\"paths|$path|$method|parameters||\\$ref\", \"#/components/parameters/$parameter\");\n                    }\n                    if (in_array($operation, ['create', 'update'])) {\n                        $this->openapi->set(\"paths|$path|$method|requestBody|\\$ref\", \"#/components/requestBodies/$operation-$type\");\n                    }\n                    $this->openapi->set(\"paths|$path|$method|tags|\", \"$type\");\n                    $this->openapi->set(\"paths|$path|$method|operationId\", \"$operation\" . \"_\" . \"$type\");\n                    if (\"$operation-$type\" == 'update-table') {\n                        $this->openapi->set(\"paths|$path|$method|description\", \"rename table\");\n                    } else {\n                        $this->openapi->set(\"paths|$path|$method|description\", \"$operation $type\");\n                    }\n                    switch ($operation) {\n                        case 'read':\n                            $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/$operation-$type\");\n                            break;\n                        case 'create':\n                        case 'update':\n                        case 'delete':\n                            $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/bool-success\");\n                            break;\n                    }\n                }\n            }\n        }\n\n        private function setComponentSchema() /*: void*/\n        {\n            foreach (array_keys($this->operations) as $type) {\n                foreach (array_keys($this->operations[$type]) as $operation) {\n                    if ($operation == 'delete') {\n                        continue;\n                    }\n                    $prefix = \"components|schemas|$operation-$type\";\n                    $this->openapi->set(\"$prefix|type\", \"object\");\n                    switch ($type) {\n                        case 'database':\n                            $this->openapi->set(\"$prefix|properties|tables|type\", 'array');\n                            $this->openapi->set(\"$prefix|properties|tables|items|\\$ref\", \"#/components/schemas/read-table\");\n                            break;\n                        case 'table':\n                            if ($operation == 'update') {\n                                $this->openapi->set(\"$prefix|required\", ['name']);\n                                $this->openapi->set(\"$prefix|properties|name|type\", 'string');\n                            } else {\n                                $this->openapi->set(\"$prefix|properties|name|type\", 'string');\n                                if ($operation == 'read') {\n                                    $this->openapi->set(\"$prefix|properties|type|type\", 'string');\n                                }\n                                $this->openapi->set(\"$prefix|properties|columns|type\", 'array');\n                                $this->openapi->set(\"$prefix|properties|columns|items|\\$ref\", \"#/components/schemas/read-column\");\n                            }\n                            break;\n                        case 'column':\n                            $this->openapi->set(\"$prefix|required\", ['name', 'type']);\n                            $this->openapi->set(\"$prefix|properties|name|type\", 'string');\n                            $this->openapi->set(\"$prefix|properties|type|type\", 'string');\n                            $this->openapi->set(\"$prefix|properties|length|type\", 'integer');\n                            $this->openapi->set(\"$prefix|properties|length|format\", \"int64\");\n                            $this->openapi->set(\"$prefix|properties|precision|type\", 'integer');\n                            $this->openapi->set(\"$prefix|properties|precision|format\", \"int64\");\n                            $this->openapi->set(\"$prefix|properties|scale|type\", 'integer');\n                            $this->openapi->set(\"$prefix|properties|scale|format\", \"int64\");\n                            $this->openapi->set(\"$prefix|properties|nullable|type\", 'boolean');\n                            $this->openapi->set(\"$prefix|properties|pk|type\", 'boolean');\n                            $this->openapi->set(\"$prefix|properties|fk|type\", 'string');\n                            break;\n                    }\n                }\n            }\n        }\n\n        private function setComponentResponse() /*: void*/\n        {\n            foreach (array_keys($this->operations) as $type) {\n                foreach (array_keys($this->operations[$type]) as $operation) {\n                    if ($operation != 'read') {\n                        continue;\n                    }\n                    $this->openapi->set(\"components|responses|$operation-$type|description\", \"single $type record\");\n                    $this->openapi->set(\"components|responses|$operation-$type|content|application/json|schema|\\$ref\", \"#/components/schemas/$operation-$type\");\n                }\n            }\n        }\n\n        private function setComponentRequestBody() /*: void*/\n        {\n            foreach (array_keys($this->operations) as $type) {\n                foreach (array_keys($this->operations[$type]) as $operation) {\n                    if (!in_array($operation, ['create', 'update'])) {\n                        continue;\n                    }\n                    $this->openapi->set(\"components|requestBodies|$operation-$type|description\", \"single $type record\");\n                    $this->openapi->set(\"components|requestBodies|$operation-$type|content|application/json|schema|\\$ref\", \"#/components/schemas/$operation-$type\");\n                }\n            }\n        }\n\n        private function setComponentParameters() /*: void*/\n        {\n            $this->openapi->set(\"components|parameters|table|name\", \"table\");\n            $this->openapi->set(\"components|parameters|table|in\", \"path\");\n            $this->openapi->set(\"components|parameters|table|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|table|description\", \"table name\");\n            $this->openapi->set(\"components|parameters|table|required\", true);\n\n            $this->openapi->set(\"components|parameters|column|name\", \"column\");\n            $this->openapi->set(\"components|parameters|column|in\", \"path\");\n            $this->openapi->set(\"components|parameters|column|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|column|description\", \"column name\");\n            $this->openapi->set(\"components|parameters|column|required\", true);\n        }\n\n        private function setTag(string $type) /*: void*/\n        {\n            $this->openapi->set(\"tags|\", ['name' => $type, 'description' => \"$type operations\"]);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiDefinition.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    class OpenApiDefinition implements \\JsonSerializable\n    {\n        private $root;\n\n        public function __construct(array $base)\n        {\n            $this->root = $base;\n        }\n\n        public function set(string $path, $value) /*: void*/\n        {\n            $parts = explode('|', $path);\n            $current = &$this->root;\n            while (count($parts) > 0) {\n                $part = array_shift($parts);\n                if ($part === '') {\n                    $part = count($current);\n                } \n                if (!isset($current[$part])) {\n                    $current[$part] = [];\n                }\n                $current = &$current[$part];\n            }\n            $current = $value;\n        }\n\n        public function has(string $path): bool\n        {\n            $parts = explode('|', trim($path, '|'));\n            $current = &$this->root;\n            while (count($parts) > 0) {\n                $part = array_shift($parts);\n                if (!isset($current[$part])) {\n                    return false;\n                }\n                $current = &$current[$part];\n            }\n            return true;\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->root;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiRecordsBuilder.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiDefinition;\n\n    class OpenApiRecordsBuilder\n    {\n        private $openapi;\n        private $reflection;\n        private $operations = [\n            'list' => 'get',\n            'create' => 'post',\n            'read' => 'get',\n            'update' => 'put',\n            'delete' => 'delete',\n            'increment' => 'patch',\n        ];\n        private $types = [\n            'integer' => ['type' => 'integer', 'format' => 'int32'],\n            'bigint' => ['type' => 'integer', 'format' => 'int64'],\n            'varchar' => ['type' => 'string'],\n            'clob' => ['type' => 'string', 'format' => 'large-string'], //custom format\n            'varbinary' => ['type' => 'string', 'format' => 'byte'],\n            'blob' => ['type' => 'string', 'format' => 'large-byte'], //custom format\n            'decimal' => ['type' => 'string', 'format' => 'decimal'], //custom format\n            'float' => ['type' => 'number', 'format' => 'float'],\n            'double' => ['type' => 'number', 'format' => 'double'],\n            'date' => ['type' => 'string', 'format' => 'date'],\n            'time' => ['type' => 'string', 'format' => 'time'], //custom format\n            'timestamp' => ['type' => 'string', 'format' => 'date-time'],\n            'geometry' => ['type' => 'string', 'format' => 'geometry'], //custom format\n            'boolean' => ['type' => 'boolean'],\n        ];\n\n        private function normalize(string $value): string\n        {\n            return iconv('UTF-8', 'ASCII//TRANSLIT', $value);\n        }\n\n        public function __construct(OpenApiDefinition $openapi, ReflectionService $reflection)\n        {\n            $this->openapi = $openapi;\n            $this->reflection = $reflection;\n        }\n\n        private function getAllTableReferences(): array\n        {\n            $tableReferences = array();\n            foreach ($this->reflection->getTableNames() as $tableName) {\n                $table = $this->reflection->getTable($tableName);\n                foreach ($table->getColumnNames() as $columnName) {\n                    $column = $table->getColumn($columnName);\n                    $referencedTableName = $column->getFk();\n                    if ($referencedTableName) {\n                        if (!isset($tableReferences[$referencedTableName])) {\n                            $tableReferences[$referencedTableName] = array();\n                        }\n                        $tableReferences[$referencedTableName][] = \"$tableName.$columnName\";\n                    }\n                }\n            }\n            return $tableReferences;\n        }\n\n        public function build() /*: void*/\n        {\n            $tableNames = $this->reflection->getTableNames();\n            foreach ($tableNames as $tableName) {\n                $this->setPath($tableName);\n            }\n            $this->openapi->set(\"components|responses|pk_integer|description\", \"inserted primary key value (integer)\");\n            $this->openapi->set(\"components|responses|pk_integer|content|application/json|schema|type\", \"integer\");\n            $this->openapi->set(\"components|responses|pk_integer|content|application/json|schema|format\", \"int64\");\n            $this->openapi->set(\"components|responses|pk_string|description\", \"inserted primary key value (string)\");\n            $this->openapi->set(\"components|responses|pk_string|content|application/json|schema|type\", \"string\");\n            $this->openapi->set(\"components|responses|pk_string|content|application/json|schema|format\", \"uuid\");\n            $this->openapi->set(\"components|responses|rows_affected|description\", \"number of rows affected (integer)\");\n            $this->openapi->set(\"components|responses|rows_affected|content|application/json|schema|type\", \"integer\");\n            $this->openapi->set(\"components|responses|rows_affected|content|application/json|schema|format\", \"int64\");\n            $tableReferences = $this->getAllTableReferences();\n            foreach ($tableNames as $tableName) {\n                $references = isset($tableReferences[$tableName]) ? $tableReferences[$tableName] : array();\n                $this->setComponentSchema($tableName, $references);\n                $this->setComponentResponse($tableName);\n                $this->setComponentRequestBody($tableName);\n            }\n            $this->setComponentParameters();\n            foreach ($tableNames as $tableName) {\n                $this->setTag($tableName);\n            }\n        }\n\n        private function isOperationOnTableAllowed(string $operation, string $tableName): bool\n        {\n            $tableHandler = VariableStore::get('authorization.tableHandler');\n            if (!$tableHandler) {\n                return true;\n            }\n            return (bool) call_user_func($tableHandler, $operation, $tableName);\n        }\n\n        private function isOperationOnColumnAllowed(string $operation, string $tableName, string $columnName): bool\n        {\n            $columnHandler = VariableStore::get('authorization.columnHandler');\n            if (!$columnHandler) {\n                return true;\n            }\n            return (bool) call_user_func($columnHandler, $operation, $tableName, $columnName);\n        }\n\n        private function setPath(string $tableName) /*: void*/\n        {\n            $normalizedTableName = $this->normalize($tableName);\n            $table = $this->reflection->getTable($tableName);\n            $type = $table->getType();\n            $pk = $table->getPk();\n            $pkName = $pk ? $pk->getName() : '';\n            foreach ($this->operations as $operation => $method) {\n                if (!$pkName && $operation != 'list') {\n                    continue;\n                }\n                if ($type != 'table' && $operation != 'list') {\n                    continue;\n                }\n                if (!$this->isOperationOnTableAllowed($operation, $tableName)) {\n                    continue;\n                }\n                $parameters = [];\n                if (in_array($operation, ['list', 'create'])) {\n                    $path = sprintf('/records/%s', $tableName);\n                    if ($operation == 'list') {\n                        $parameters = ['filter', 'include', 'exclude', 'order', 'size', 'page', 'join'];\n                    }\n                } else {\n                    $path = sprintf('/records/%s/{id}', $tableName);\n                    if ($operation == 'read') {\n                        $parameters = ['pk', 'include', 'exclude', 'join'];\n                    } else {\n                        $parameters = ['pk'];\n                    }\n                }\n                foreach ($parameters as $parameter) {\n                    $this->openapi->set(\"paths|$path|$method|parameters||\\$ref\", \"#/components/parameters/$parameter\");\n                }\n                if (in_array($operation, ['create', 'update', 'increment'])) {\n                    $this->openapi->set(\"paths|$path|$method|requestBody|\\$ref\", \"#/components/requestBodies/$operation-$normalizedTableName\");\n                }\n                $this->openapi->set(\"paths|$path|$method|tags|\", \"$tableName\");\n                $this->openapi->set(\"paths|$path|$method|operationId\", \"$operation\" . \"_\" . \"$normalizedTableName\");\n                $this->openapi->set(\"paths|$path|$method|description\", \"$operation $tableName\");\n                switch ($operation) {\n                    case 'list':\n                        $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/$operation-$normalizedTableName\");\n                        break;\n                    case 'create':\n                        if ($pk->getType() == 'integer') {\n                            $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/pk_integer\");\n                        } else {\n                            $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/pk_string\");\n                        }\n                        break;\n                    case 'read':\n                        $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/$operation-$normalizedTableName\");\n                        break;\n                    case 'update':\n                    case 'delete':\n                    case 'increment':\n                        $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/rows_affected\");\n                        break;\n                }\n            }\n        }\n\n        private function getPattern(ReflectedColumn $column): string\n        {\n            switch ($column->getType()) {\n                case 'integer':\n                    $n = strlen(pow(2, 31));\n                    return '^-?[0-9]{1,' . $n . '}$';\n                case 'bigint':\n                    $n = strlen(pow(2, 63));\n                    return '^-?[0-9]{1,' . $n . '}$';\n                case 'varchar':\n                    $l = $column->getLength();\n                    return '^.{0,' . $l . '}$';\n                case 'clob':\n                    return '^.*$';\n                case 'varbinary':\n                    $l = $column->getLength();\n                    $b = (int) 4 * ceil($l / 3);\n                    return '^[A-Za-z0-9+/]{0,' . $b . '}=*$';\n                case 'blob':\n                    return '^[A-Za-z0-9+/]*=*$';\n                case 'decimal':\n                    $p = $column->getPrecision();\n                    $s = $column->getScale();\n                    return '^-?[0-9]{1,' . ($p - $s) . '}(\\.[0-9]{1,' . $s . '})?$';\n                case 'float':\n                    return '^-?[0-9]+(\\.[0-9]+)?([eE]-?[0-9]+)?$';\n                case 'double':\n                    return '^-?[0-9]+(\\.[0-9]+)?([eE]-?[0-9]+)?$';\n                case 'date':\n                    return '^[0-9]{4}-[0-9]{2}-[0-9]{2}$';\n                case 'time':\n                    return '^[0-9]{2}:[0-9]{2}:[0-9]{2}$';\n                case 'timestamp':\n                    return '^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$';\n                    return '';\n                case 'geometry':\n                    return '^(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON)\\s*\\(.*$';\n                case 'boolean':\n                    return '^(true|false)$';\n            }\n            return '';\n        }\n\n        private function setComponentSchema(string $tableName, array $references) /*: void*/\n        {\n            $normalizedTableName = $this->normalize($tableName);\n            $table = $this->reflection->getTable($tableName);\n            $type = $table->getType();\n            $pk = $table->getPk();\n            $pkName = $pk ? $pk->getName() : '';\n            foreach ($this->operations as $operation => $method) {\n                if (!$pkName && $operation != 'list') {\n                    continue;\n                }\n                if ($type == 'view' && !in_array($operation, array('read', 'list'))) {\n                    continue;\n                }\n                if ($type == 'view' && !$pkName && $operation == 'read') {\n                    continue;\n                }\n                if ($operation == 'delete') {\n                    continue;\n                }\n                if (!$this->isOperationOnTableAllowed($operation, $tableName)) {\n                    continue;\n                }\n                if ($operation == 'list') {\n                    $this->openapi->set(\"components|schemas|$operation-$normalizedTableName|type\", \"object\");\n                    $this->openapi->set(\"components|schemas|$operation-$normalizedTableName|properties|results|type\", \"integer\");\n                    $this->openapi->set(\"components|schemas|$operation-$normalizedTableName|properties|results|format\", \"int64\");\n                    $this->openapi->set(\"components|schemas|$operation-$normalizedTableName|properties|records|type\", \"array\");\n                    $prefix = \"components|schemas|$operation-$normalizedTableName|properties|records|items\";\n                } else {\n                    $prefix = \"components|schemas|$operation-$normalizedTableName\";\n                }\n                $this->openapi->set(\"$prefix|type\", \"object\");\n                foreach ($table->getColumnNames() as $columnName) {\n                    if (!$this->isOperationOnColumnAllowed($operation, $tableName, $columnName)) {\n                        continue;\n                    }\n                    $column = $table->getColumn($columnName);\n                    $properties = $this->types[$column->getType()];\n                    $properties['maxLength'] = $column->hasLength() ? $column->getLength() : 0;\n                    $properties['nullable'] = $column->getNullable();\n                    $properties['pattern'] = $this->getPattern($column);\n                    foreach ($properties as $key => $value) {\n                        if ($value) {\n                            $this->openapi->set(\"$prefix|properties|$columnName|$key\", $value);\n                        }\n                    }\n                    if ($column->getPk()) {\n                        $this->openapi->set(\"$prefix|properties|$columnName|x-primary-key\", true);\n                        $this->openapi->set(\"$prefix|properties|$columnName|x-referenced\", $references);\n                    }\n                    $fk = $column->getFk();\n                    if ($fk) {\n                        $this->openapi->set(\"$prefix|properties|$columnName|x-references\", $fk);\n                    }\n                }\n            }\n        }\n\n        private function setComponentResponse(string $tableName) /*: void*/\n        {\n            $normalizedTableName = $this->normalize($tableName);\n            $table = $this->reflection->getTable($tableName);\n            $type = $table->getType();\n            $pk = $table->getPk();\n            $pkName = $pk ? $pk->getName() : '';\n            foreach (['list', 'read'] as $operation) {\n                if (!$pkName && $operation != 'list') {\n                    continue;\n                }\n                if ($type != 'table' && $operation != 'list') {\n                    continue;\n                }\n                if (!$this->isOperationOnTableAllowed($operation, $tableName)) {\n                    continue;\n                }\n                if ($operation == 'list') {\n                    $this->openapi->set(\"components|responses|$operation-$normalizedTableName|description\", \"list of $tableName records\");\n                } else {\n                    $this->openapi->set(\"components|responses|$operation-$normalizedTableName|description\", \"single $tableName record\");\n                }\n                $this->openapi->set(\"components|responses|$operation-$normalizedTableName|content|application/json|schema|\\$ref\", \"#/components/schemas/$operation-$normalizedTableName\");\n            }\n        }\n\n        private function setComponentRequestBody(string $tableName) /*: void*/\n        {\n            $normalizedTableName = $this->normalize($tableName);\n            $table = $this->reflection->getTable($tableName);\n            $type = $table->getType();\n            $pk = $table->getPk();\n            $pkName = $pk ? $pk->getName() : '';\n            if ($pkName && $type == 'table') {\n                foreach (['create', 'update', 'increment'] as $operation) {\n                    if (!$this->isOperationOnTableAllowed($operation, $tableName)) {\n                        continue;\n                    }\n                    $this->openapi->set(\"components|requestBodies|$operation-$normalizedTableName|description\", \"single $tableName record\");\n                    $this->openapi->set(\"components|requestBodies|$operation-$normalizedTableName|content|application/json|schema|\\$ref\", \"#/components/schemas/$operation-$normalizedTableName\");\n                }\n            }\n        }\n\n        private function setComponentParameters() /*: void*/\n        {\n            $this->openapi->set(\"components|parameters|pk|name\", \"id\");\n            $this->openapi->set(\"components|parameters|pk|in\", \"path\");\n            $this->openapi->set(\"components|parameters|pk|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|pk|description\", \"primary key value\");\n            $this->openapi->set(\"components|parameters|pk|required\", true);\n\n            $this->openapi->set(\"components|parameters|filter|name\", \"filter\");\n            $this->openapi->set(\"components|parameters|filter|in\", \"query\");\n            $this->openapi->set(\"components|parameters|filter|schema|type\", \"array\");\n            $this->openapi->set(\"components|parameters|filter|schema|items|type\", \"string\");\n            $this->openapi->set(\"components|parameters|filter|description\", \"Filters to be applied. Each filter consists of a column, an operator and a value (comma separated). Example: id,eq,1\");\n            $this->openapi->set(\"components|parameters|filter|required\", false);\n\n            $this->openapi->set(\"components|parameters|include|name\", \"include\");\n            $this->openapi->set(\"components|parameters|include|in\", \"query\");\n            $this->openapi->set(\"components|parameters|include|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|include|description\", \"Columns you want to include in the output (comma separated). Example: posts.*,categories.name\");\n            $this->openapi->set(\"components|parameters|include|required\", false);\n\n            $this->openapi->set(\"components|parameters|exclude|name\", \"exclude\");\n            $this->openapi->set(\"components|parameters|exclude|in\", \"query\");\n            $this->openapi->set(\"components|parameters|exclude|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|exclude|description\", \"Columns you want to exclude from the output (comma separated). Example: posts.content\");\n            $this->openapi->set(\"components|parameters|exclude|required\", false);\n\n            $this->openapi->set(\"components|parameters|order|name\", \"order\");\n            $this->openapi->set(\"components|parameters|order|in\", \"query\");\n            $this->openapi->set(\"components|parameters|order|schema|type\", \"array\");\n            $this->openapi->set(\"components|parameters|order|schema|items|type\", \"string\");\n            $this->openapi->set(\"components|parameters|order|description\", \"Column you want to sort on and the sort direction (comma separated). Example: id,desc\");\n            $this->openapi->set(\"components|parameters|order|required\", false);\n\n            $this->openapi->set(\"components|parameters|size|name\", \"size\");\n            $this->openapi->set(\"components|parameters|size|in\", \"query\");\n            $this->openapi->set(\"components|parameters|size|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|size|description\", \"Maximum number of results (for top lists). Example: 10\");\n            $this->openapi->set(\"components|parameters|size|required\", false);\n\n            $this->openapi->set(\"components|parameters|page|name\", \"page\");\n            $this->openapi->set(\"components|parameters|page|in\", \"query\");\n            $this->openapi->set(\"components|parameters|page|schema|type\", \"string\");\n            $this->openapi->set(\"components|parameters|page|description\", \"Page number and page size (comma separated). Example: 1,10\");\n            $this->openapi->set(\"components|parameters|page|required\", false);\n\n            $this->openapi->set(\"components|parameters|join|name\", \"join\");\n            $this->openapi->set(\"components|parameters|join|in\", \"query\");\n            $this->openapi->set(\"components|parameters|join|schema|type\", \"array\");\n            $this->openapi->set(\"components|parameters|join|schema|items|type\", \"string\");\n            $this->openapi->set(\"components|parameters|join|description\", \"Paths (comma separated) to related entities that you want to include. Example: comments,users\");\n            $this->openapi->set(\"components|parameters|join|required\", false);\n        }\n\n        private function setTag(string $tableName) /*: void*/\n        {\n            $this->openapi->set(\"tags|\", ['name' => $tableName, 'description' => \"$tableName operations\"]);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiService.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiBuilder;\n    use Tqdev\\PhpCrudApi\\RequestFactory;\n\n    class OpenApiService\n    {\n        private $builder;\n\n        public function __construct(ReflectionService $reflection, array $base, array $controllers, array $customBuilders)\n        {\n            $this->builder = new OpenApiBuilder($reflection, $base, $controllers, $customBuilders);\n        }\n\n        public function get(ServerRequestInterface $request): OpenApiDefinition\n        {\n            return $this->builder->build(RequestFactory::fromGlobals());\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/OpenApi/OpenApiStatusBuilder.php\nnamespace Tqdev\\PhpCrudApi\\OpenApi {\n\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiDefinition;\n\n    class OpenApiStatusBuilder\n    {\n        private $openapi;\n        private $operations = [\n            'status' => [\n                'ping' => 'get',\n            ],\n        ];\n\n        public function __construct(OpenApiDefinition $openapi)\n        {\n            $this->openapi = $openapi;\n        }\n\n        public function build() /*: void*/\n        {\n            $this->setPaths();\n            $this->setComponentSchema();\n            $this->setComponentResponse();\n            foreach (array_keys($this->operations) as $type) {\n                $this->setTag($type);\n            }\n        }\n\n        private function setPaths() /*: void*/\n        {\n            foreach ($this->operations as $type => $operationPair) {\n                foreach ($operationPair as $operation => $method) {\n                    $path = \"/$type/$operation\";\n                    $this->openapi->set(\"paths|$path|$method|tags|\", \"$type\");\n                    $this->openapi->set(\"paths|$path|$method|operationId\", \"$operation\" . \"_\" . \"$type\");\n                    $this->openapi->set(\"paths|$path|$method|description\", \"Request API '$operation' status\");\n                    $this->openapi->set(\"paths|$path|$method|responses|200|\\$ref\", \"#/components/responses/$operation-$type\");\n\n                }\n            }\n        }\n\n        private function setComponentSchema() /*: void*/\n        {\n            foreach ($this->operations as $type => $operationPair) {\n                foreach ($operationPair as $operation => $method) {\n                    $prefix = \"components|schemas|$operation-$type\";\n                    $this->openapi->set(\"$prefix|type\", \"object\");\n                    switch ($operation) {\n                        case 'ping':\n                            $this->openapi->set(\"$prefix|required\", ['db', 'cache']);\n                            $this->openapi->set(\"$prefix|properties|db|type\", 'integer');\n                            $this->openapi->set(\"$prefix|properties|db|format\", \"int64\");\n                            $this->openapi->set(\"$prefix|properties|cache|type\", 'integer');\n                            $this->openapi->set(\"$prefix|properties|cache|format\", \"int64\");\n                            break;\n                    }\n                }\n            }\n        }\n\n        private function setComponentResponse() /*: void*/\n        {\n            foreach ($this->operations as $type => $operationPair) {\n                foreach ($operationPair as $operation => $method) {\n                    $this->openapi->set(\"components|responses|$operation-$type|description\", \"$operation status record\");\n                    $this->openapi->set(\"components|responses|$operation-$type|content|application/json|schema|\\$ref\", \"#/components/schemas/$operation-$type\");\n                }\n            }\n        }\n\n        private function setTag(string $type) /*: void*/\n        {\n            $this->openapi->set(\"tags|\", [ 'name' => $type, 'description' => \"$type operations\"]);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/AndCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    class AndCondition extends Condition\n    {\n        private $conditions;\n\n        public function __construct(Condition $condition1, Condition $condition2)\n        {\n            $this->conditions = [$condition1, $condition2];\n        }\n\n        public function _and(Condition $condition): Condition\n        {\n            if ($condition instanceof NoCondition) {\n                return $this;\n            }\n            $this->conditions[] = $condition;\n            return $this;\n        }\n\n        public function getConditions(): array\n        {\n            return $this->conditions;\n        }\n\n        public static function fromArray(array $conditions): Condition\n        {\n            $condition = new NoCondition();\n            foreach ($conditions as $c) {\n                $condition = $condition->_and($c);\n            }\n            return $condition;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/ColumnCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedColumn;\n\n    class ColumnCondition extends Condition\n    {\n        private $column;\n        private $operator;\n        private $value;\n\n        public function __construct(ReflectedColumn $column, string $operator, string $value)\n        {\n            $this->column = $column;\n            $this->operator = $operator;\n            $this->value = $value;\n        }\n\n        public function getColumn(): ReflectedColumn\n        {\n            return $this->column;\n        }\n\n        public function getOperator(): string\n        {\n            return $this->operator;\n        }\n\n        public function getValue(): string\n        {\n            return $this->value;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/Condition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n\n    abstract class Condition\n    {\n        public function _and(Condition $condition): Condition\n        {\n            if ($condition instanceof NoCondition) {\n                return $this;\n            }\n            return new AndCondition($this, $condition);\n        }\n\n        public function _or(Condition $condition): Condition\n        {\n            if ($condition instanceof NoCondition) {\n                return $this;\n            }\n            return new OrCondition($this, $condition);\n        }\n\n        public function _not(): Condition\n        {\n            return new NotCondition($this);\n        }\n\n        public static function fromString(ReflectedTable $table, string $value): Condition\n        {\n            $condition = new NoCondition();\n            $parts = explode(',', $value, 3);\n            if (count($parts) < 2) {\n                return $condition;\n            }\n            if (count($parts) < 3) {\n                $parts[2] = '';\n            }\n            $field = $table->getColumn($parts[0]);\n            $command = $parts[1];\n            $negate = false;\n            $spatial = false;\n            if (strlen($command) > 2) {\n                if (substr($command, 0, 1) == 'n') {\n                    $negate = true;\n                    $command = substr($command, 1);\n                } else if (substr($command, 0, 1) == 's') {\n                    $spatial = true;\n                    $command = substr($command, 1);\n                }\n            }\n            if ($spatial) {\n                if (in_array($command, ['co', 'cr', 'di', 'eq', 'in', 'ov', 'to', 'wi', 'ic', 'is', 'iv'])) {\n                    $condition = new SpatialCondition($field, $command, $parts[2]);\n                }\n            } else {\n                if (in_array($command, ['cs', 'sw', 'ew', 'eq', 'lt', 'le', 'ge', 'gt', 'bt', 'in', 'is'])) {\n                    $condition = new ColumnCondition($field, $command, $parts[2]);\n                }\n            }\n            if ($negate) {\n                $condition = $condition->_not();\n            }\n            return $condition;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/NoCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    class NoCondition extends Condition\n    {\n        public function _and(Condition $condition): Condition\n        {\n            return $condition;\n        }\n\n        public function _or(Condition $condition): Condition\n        {\n            return $condition;\n        }\n\n        public function _not(): Condition\n        {\n            return $this;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/NotCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    class NotCondition extends Condition\n    {\n        private $condition;\n\n        public function __construct(Condition $condition)\n        {\n            $this->condition = $condition;\n        }\n\n        public function getCondition(): Condition\n        {\n            return $this->condition;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/OrCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    class OrCondition extends Condition\n    {\n        private $conditions;\n\n        public function __construct(Condition $condition1, Condition $condition2)\n        {\n            $this->conditions = [$condition1, $condition2];\n        }\n\n        public function _or(Condition $condition): Condition\n        {\n            if ($condition instanceof NoCondition) {\n                return $this;\n            }\n            $this->conditions[] = $condition;\n            return $this;\n        }\n\n        public function getConditions(): array\n        {\n            return $this->conditions;\n        }\n\n        public static function fromArray(array $conditions): Condition\n        {\n            $condition = new NoCondition();\n            foreach ($conditions as $c) {\n                $condition = $condition->_or($c);\n            }\n            return $condition;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Condition/SpatialCondition.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Condition {\n\n    class SpatialCondition extends ColumnCondition\n    {\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Document/ErrorDocument.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Document {\n\n    use Tqdev\\PhpCrudApi\\Record\\ErrorCode;\n\n    class ErrorDocument implements \\JsonSerializable\n    {\n        public $errorCode;\n        public $argument;\n        public $details;\n\n        public function __construct(ErrorCode $errorCode, string $argument, $details)\n        {\n            $this->errorCode = $errorCode;\n            $this->argument = $argument;\n            $this->details = $details;\n        }\n\n        public function getStatus(): int\n        {\n            return $this->errorCode->getStatus();\n        }\n\n        public function getCode(): int\n        {\n            return $this->errorCode->getCode();\n        }\n\n        public function getMessage(): string\n        {\n            return $this->errorCode->getMessage($this->argument);\n        }\n\n        public function serialize()\n        {\n            return [\n                'code' => $this->getCode(),\n                'message' => $this->getMessage(),\n                'details' => $this->details,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return array_filter($this->serialize(), function ($v) {return $v !== null;});\n        }\n\n        public static function fromException(\\Throwable $exception, bool $debug)\n        {\n            $document = new ErrorDocument(new ErrorCode(ErrorCode::ERROR_NOT_FOUND), $exception->getMessage(), null);\n            if ($exception instanceof \\PDOException) {\n                if (strpos(strtolower($exception->getMessage()), 'duplicate') !== false) {\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::DUPLICATE_KEY_EXCEPTION), '', null);\n                } elseif (strpos(strtolower($exception->getMessage()), 'unique constraint') !== false) {\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::DUPLICATE_KEY_EXCEPTION), '', null);\n                } elseif (strpos(strtolower($exception->getMessage()), 'default value') !== false) {\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::DATA_INTEGRITY_VIOLATION), '', null);\n                } elseif (strpos(strtolower($exception->getMessage()), 'allow nulls') !== false) {\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::DATA_INTEGRITY_VIOLATION), '', null);\n                } elseif (strpos(strtolower($exception->getMessage()), 'constraint') !== false) {\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::DATA_INTEGRITY_VIOLATION), '', null);\n                } else {\n                    $message = $debug ? $exception->getMessage() : 'PDOException occurred (enable debug mode)';\n                    $document = new ErrorDocument(new ErrorCode(ErrorCode::ERROR_NOT_FOUND), $message, null);\n                }\n            }\n            return $document;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/Document/ListDocument.php\nnamespace Tqdev\\PhpCrudApi\\Record\\Document {\n\n    class ListDocument implements \\JsonSerializable\n    {\n        private $records;\n\n        private $results;\n\n        public function __construct(array $records, int $results)\n        {\n            $this->records = $records;\n            $this->results = $results;\n        }\n\n        public function getRecords(): array\n        {\n            return $this->records;\n        }\n\n        public function getResults(): int\n        {\n            return $this->results;\n        }\n\n        public function serialize()\n        {\n            return [\n                'records' => $this->records,\n                'results' => $this->results,\n            ];\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return array_filter($this->serialize(), function ($v) {\n                return $v !== -1;\n            });\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/ColumnIncluder.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n\n    class ColumnIncluder\n    {\n        private function isMandatory(string $tableName, string $columnName, array $params): bool\n        {\n            return isset($params['mandatory']) && in_array($tableName . \".\" . $columnName, $params['mandatory']);\n        }\n\n        private function select(\n            string $tableName,\n            bool $primaryTable,\n            array $params,\n            string $paramName,\n            array $columnNames,\n            bool $include\n        ): array {\n            if (!isset($params[$paramName])) {\n                return $columnNames;\n            }\n            $columns = array();\n            foreach (explode(',', $params[$paramName][0]) as $columnName) {\n                $columns[$columnName] = true;\n            }\n            $result = array();\n            foreach ($columnNames as $columnName) {\n                $match = isset($columns['*.*']);\n                if (!$match) {\n                    $match = isset($columns[$tableName . '.*']) || isset($columns[$tableName . '.' . $columnName]);\n                }\n                if ($primaryTable && !$match) {\n                    $match = isset($columns['*']) || isset($columns[$columnName]);\n                }\n                if ($match) {\n                    if ($include || $this->isMandatory($tableName, $columnName, $params)) {\n                        $result[] = $columnName;\n                    }\n                } else {\n                    if (!$include || $this->isMandatory($tableName, $columnName, $params)) {\n                        $result[] = $columnName;\n                    }\n                }\n            }\n            return $result;\n        }\n\n        public function getNames(ReflectedTable $table, bool $primaryTable, array $params): array\n        {\n            $tableName = $table->getName();\n            $results = $table->getColumnNames();\n            $results = $this->select($tableName, $primaryTable, $params, 'include', $results, true);\n            $results = $this->select($tableName, $primaryTable, $params, 'exclude', $results, false);\n            return $results;\n        }\n\n        public function getValues(ReflectedTable $table, bool $primaryTable, /* object */ $record, array $params): array\n        {\n            $results = array();\n            $columnNames = $this->getNames($table, $primaryTable, $params);\n            foreach ($columnNames as $columnName) {\n                if (property_exists($record, $columnName)) {\n                    $results[$columnName] = $record->$columnName;\n                }\n            }\n            return $results;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/ErrorCode.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\ResponseFactory;\n\n    class ErrorCode\n    {\n        private $code;\n        private $message;\n        private $status;\n\n        const ERROR_NOT_FOUND = 9999;\n        const ROUTE_NOT_FOUND = 1000;\n        const TABLE_NOT_FOUND = 1001;\n        const ARGUMENT_COUNT_MISMATCH = 1002;\n        const RECORD_NOT_FOUND = 1003;\n        const ORIGIN_FORBIDDEN = 1004;\n        const COLUMN_NOT_FOUND = 1005;\n        const TABLE_ALREADY_EXISTS = 1006;\n        const COLUMN_ALREADY_EXISTS = 1007;\n        const HTTP_MESSAGE_NOT_READABLE = 1008;\n        const DUPLICATE_KEY_EXCEPTION = 1009;\n        const DATA_INTEGRITY_VIOLATION = 1010;\n        const AUTHENTICATION_REQUIRED = 1011;\n        const AUTHENTICATION_FAILED = 1012;\n        const INPUT_VALIDATION_FAILED = 1013;\n        const OPERATION_FORBIDDEN = 1014;\n        const OPERATION_NOT_SUPPORTED = 1015;\n        const TEMPORARY_OR_PERMANENTLY_BLOCKED = 1016;\n        const BAD_OR_MISSING_XSRF_TOKEN = 1017;\n        const ONLY_AJAX_REQUESTS_ALLOWED = 1018;\n        const PAGINATION_FORBIDDEN = 1019;\n        const USER_ALREADY_EXIST = 1020;\n        const PASSWORD_TOO_SHORT = 1021;\n        const USERNAME_EMPTY = 1022;\n        const PRIMARY_KEY_NOT_FOUND = 1023;\n\n        private $values = [\n            0000 => [\"Success\", ResponseFactory::OK],\n            1000 => [\"Route '%s' not found\", ResponseFactory::NOT_FOUND],\n            1001 => [\"Table '%s' not found\", ResponseFactory::NOT_FOUND],\n            1002 => [\"Argument count mismatch in '%s'\", ResponseFactory::UNPROCESSABLE_ENTITY],\n            1003 => [\"Record '%s' not found\", ResponseFactory::NOT_FOUND],\n            1004 => [\"Origin '%s' is forbidden\", ResponseFactory::FORBIDDEN],\n            1005 => [\"Column '%s' not found\", ResponseFactory::NOT_FOUND],\n            1006 => [\"Table '%s' already exists\", ResponseFactory::CONFLICT],\n            1007 => [\"Column '%s' already exists\", ResponseFactory::CONFLICT],\n            1008 => [\"Cannot read HTTP message\", ResponseFactory::UNPROCESSABLE_ENTITY],\n            1009 => [\"Duplicate key exception\", ResponseFactory::CONFLICT],\n            1010 => [\"Data integrity violation\", ResponseFactory::CONFLICT],\n            1011 => [\"Authentication required\", ResponseFactory::UNAUTHORIZED],\n            1012 => [\"Authentication failed for '%s'\", ResponseFactory::FORBIDDEN],\n            1013 => [\"Input validation failed for '%s'\", ResponseFactory::UNPROCESSABLE_ENTITY],\n            1014 => [\"Operation forbidden\", ResponseFactory::FORBIDDEN],\n            1015 => [\"Operation '%s' not supported\", ResponseFactory::METHOD_NOT_ALLOWED],\n            1016 => [\"Temporary or permanently blocked\", ResponseFactory::FORBIDDEN],\n            1017 => [\"Bad or missing XSRF token\", ResponseFactory::FORBIDDEN],\n            1018 => [\"Only AJAX requests allowed for '%s'\", ResponseFactory::FORBIDDEN],\n            1019 => [\"Pagination forbidden\", ResponseFactory::FORBIDDEN],\n            1020 => [\"User '%s' already exists\", ResponseFactory::CONFLICT],\n            1021 => [\"Password too short (<%d characters)\", ResponseFactory::UNPROCESSABLE_ENTITY],\n            1022 => [\"Username is empty or only whitespaces\", ResponseFactory::UNPROCESSABLE_ENTITY],\n            1023 => [\"Primary key for table '%s' not found\", ResponseFactory::NOT_FOUND],\n            9999 => [\"%s\", ResponseFactory::INTERNAL_SERVER_ERROR],\n        ];\n\n        public function __construct(int $code)\n        {\n            if (!isset($this->values[$code])) {\n                $code = 9999;\n            }\n            $this->code = $code;\n            $this->message = $this->values[$code][0];\n            $this->status = $this->values[$code][1];\n        }\n\n        public function getCode(): int\n        {\n            return $this->code;\n        }\n\n        public function getMessage(string $argument): string\n        {\n            return sprintf($this->message, $argument);\n        }\n\n        public function getStatus(): int\n        {\n            return $this->status;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/FilterInfo.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\AndCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\Condition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\NoCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\OrCondition;\n\n    class FilterInfo\n    {\n        private function getConditionsAsPathTree(ReflectedTable $table, array $params): PathTree\n        {\n            $conditions = new PathTree();\n            foreach ($params as $key => $filters) {\n                if (substr($key, 0, 6) == 'filter') {\n                    preg_match_all('/\\d+|\\D+/', substr($key, 6), $matches);\n                    $path = $matches[0];\n                    foreach ($filters as $filter) {\n                        $condition = Condition::fromString($table, $filter);\n                        if (($condition instanceof NoCondition) == false) {\n                            $conditions->put($path, $condition);\n                        }\n                    }\n                }\n            }\n            return $conditions;\n        }\n\n        private function combinePathTreeOfConditions(PathTree $tree): Condition\n        {\n            $andConditions = $tree->getValues();\n            $and = AndCondition::fromArray($andConditions);\n            $orConditions = [];\n            foreach ($tree->getKeys() as $p) {\n                $orConditions[] = $this->combinePathTreeOfConditions($tree->get($p));\n            }\n            $or = OrCondition::fromArray($orConditions);\n            return $and->_and($or);\n        }\n\n        public function getCombinedConditions(ReflectedTable $table, array $params): Condition\n        {\n            return $this->combinePathTreeOfConditions($this->getConditionsAsPathTree($table, $params));\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/HabtmValues.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    class HabtmValues\n    {\n        public $pkValues;\n        public $fkValues;\n\n        public function __construct(array $pkValues, array $fkValues)\n        {\n            $this->pkValues = $pkValues;\n            $this->fkValues = $fkValues;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/OrderingInfo.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n\n    class OrderingInfo\n    {\n        public function getColumnOrdering(ReflectedTable $table, array $params): array\n        {\n            $fields = array();\n            if (isset($params['order'])) {\n                foreach ($params['order'] as $order) {\n                    $parts = explode(',', $order, 3);\n                    $columnName = $parts[0];\n                    if (!$table->hasColumn($columnName)) {\n                        continue;\n                    }\n                    $ascending = 'ASC';\n                    if (count($parts) > 1) {\n                        if (substr(strtoupper($parts[1]), 0, 4) == \"DESC\") {\n                            $ascending = 'DESC';\n                        }\n                    }\n                    $fields[] = [$columnName, $ascending];\n                }\n            }\n            if (count($fields) == 0) {\n                return $this->getDefaultColumnOrdering($table);\n            }\n            return $fields;\n        }\n\n        public function getDefaultColumnOrdering(ReflectedTable $table): array\n        {\n            $fields = array();\n            $pk = $table->getPk();\n            if ($pk) {\n                $fields[] = [$pk->getName(), 'ASC'];\n            } else {\n                foreach ($table->getColumnNames() as $columnName) {\n                    $fields[] = [$columnName, 'ASC'];\n                }\n            }\n            return $fields;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/PaginationInfo.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    class PaginationInfo\n    {\n        public $DEFAULT_PAGE_SIZE = 20;\n\n        public function hasPage(array $params): bool\n        {\n            return isset($params['page']);\n        }\n\n        public function getPageOffset(array $params): int\n        {\n            $offset = 0;\n            $pageSize = $this->getPageSize($params);\n            if (isset($params['page'])) {\n                foreach ($params['page'] as $page) {\n                    $parts = explode(',', $page, 2);\n                    $page = intval($parts[0]) - 1;\n                    $offset = $page * $pageSize;\n                }\n            }\n            return $offset;\n        }\n\n        private function getPageSize(array $params): int\n        {\n            $pageSize = $this->DEFAULT_PAGE_SIZE;\n            if (isset($params['page'])) {\n                foreach ($params['page'] as $page) {\n                    $parts = explode(',', $page, 2);\n                    if (count($parts) > 1) {\n                        $pageSize = intval($parts[1]);\n                    }\n                }\n            }\n            return $pageSize;\n        }\n\n        public function getResultSize(array $params): int\n        {\n            $numberOfRows = -1;\n            if (isset($params['size'])) {\n                foreach ($params['size'] as $size) {\n                    $numberOfRows = intval($size);\n                }\n            }\n            return $numberOfRows;\n        }\n\n        public function getPageLimit(array $params): int\n        {\n            $pageLimit = -1;\n            if ($this->hasPage($params)) {\n                $pageLimit = $this->getPageSize($params);\n            }\n            $resultSize = $this->getResultSize($params);\n            if ($resultSize >= 0) {\n                if ($pageLimit >= 0) {\n                    $pageLimit = min($pageLimit, $resultSize);\n                } else {\n                    $pageLimit = $resultSize;\n                }\n            }\n            return $pageLimit;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/PathTree.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    class PathTree implements \\JsonSerializable\n    {\n        const WILDCARD = '*';\n\n        private $tree;\n\n        public function __construct( /* object */&$tree = null)\n        {\n            if (!$tree) {\n                $tree = $this->newTree();\n            }\n            $this->tree = &$tree;\n        }\n\n        public function newTree()\n        {\n            return (object) ['values' => [], 'branches' => (object) []];\n        }\n\n        public function getKeys(): array\n        {\n            $branches = (array) $this->tree->branches;\n            return array_keys($branches);\n        }\n\n        public function getValues(): array\n        {\n            return $this->tree->values;\n        }\n\n        public function get(string $key): PathTree\n        {\n            if (!isset($this->tree->branches->$key)) {\n                return null;\n            }\n            return new PathTree($this->tree->branches->$key);\n        }\n\n        public function put(array $path, $value)\n        {\n            $tree = &$this->tree;\n            foreach ($path as $key) {\n                if (!isset($tree->branches->$key)) {\n                    $tree->branches->$key = $this->newTree();\n                }\n                $tree = &$tree->branches->$key;\n            }\n            $tree->values[] = $value;\n        }\n\n        public function match(array $path): array\n        {\n            $star = self::WILDCARD;\n            $tree = &$this->tree;\n            foreach ($path as $key) {\n                if (isset($tree->branches->$key)) {\n                    $tree = &$tree->branches->$key;\n                } elseif (isset($tree->branches->$star)) {\n                    $tree = &$tree->branches->$star;\n                } else {\n                    return [];\n                }\n            }\n            return $tree->values;\n        }\n\n        public static function fromJson( /* object */$tree): PathTree\n        {\n            return new PathTree($tree);\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function jsonSerialize()\n        {\n            return $this->tree;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/RecordService.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Record\\Document\\ListDocument;\n\n    class RecordService\n    {\n        private $db;\n        private $reflection;\n        private $columns;\n        private $joiner;\n        private $filters;\n        private $ordering;\n        private $pagination;\n\n        public function __construct(GenericDB $db, ReflectionService $reflection)\n        {\n            $this->db = $db;\n            $this->reflection = $reflection;\n            $this->columns = new ColumnIncluder();\n            $this->joiner = new RelationJoiner($reflection, $this->columns);\n            $this->filters = new FilterInfo();\n            $this->ordering = new OrderingInfo();\n            $this->pagination = new PaginationInfo();\n        }\n\n        private function sanitizeRecord(string $tableName, /* object */ $record, string $id)\n        {\n            $keyset = array_keys((array) $record);\n            foreach ($keyset as $key) {\n                if (!$this->reflection->getTable($tableName)->hasColumn($key)) {\n                    unset($record->$key);\n                }\n            }\n            if ($id != '') {\n                $pk = $this->reflection->getTable($tableName)->getPk();\n                foreach ($this->reflection->getTable($tableName)->getColumnNames() as $key) {\n                    $field = $this->reflection->getTable($tableName)->getColumn($key);\n                    if ($field->getName() == $pk->getName()) {\n                        unset($record->$key);\n                    }\n                }\n            }\n        }\n\n        public function hasTable(string $table): bool\n        {\n            return $this->reflection->hasTable($table);\n        }\n\n        public function hasPrimaryKey(string $table): bool\n        {\n            return $this->reflection->getTable($table)->getPk()?true:false;\n        }\n\n        public function getType(string $table): string\n        {\n            return $this->reflection->getType($table);\n        }\n\n        public function beginTransaction() /*: void*/\n        {\n            $this->db->beginTransaction();\n        }\n\n        public function commitTransaction() /*: void*/\n        {\n            $this->db->commitTransaction();\n        }\n\n        public function rollBackTransaction() /*: void*/\n        {\n            $this->db->rollBackTransaction();\n        }\n\n        public function create(string $tableName, /* object */ $record, array $params) /*: ?int*/\n        {\n            $this->sanitizeRecord($tableName, $record, '');\n            $table = $this->reflection->getTable($tableName);\n            $columnValues = $this->columns->getValues($table, true, $record, $params);\n            return $this->db->createSingle($table, $columnValues);\n        }\n\n        public function read(string $tableName, string $id, array $params) /*: ?object*/\n        {\n            $table = $this->reflection->getTable($tableName);\n            $this->joiner->addMandatoryColumns($table, $params);\n            $columnNames = $this->columns->getNames($table, true, $params);\n            $record = $this->db->selectSingle($table, $columnNames, $id);\n            if ($record == null) {\n                return null;\n            }\n            $records = array($record);\n            $this->joiner->addJoins($table, $records, $params, $this->db);\n            return $records[0];\n        }\n\n        public function update(string $tableName, string $id, /* object */ $record, array $params) /*: ?int*/\n        {\n            $this->sanitizeRecord($tableName, $record, $id);\n            $table = $this->reflection->getTable($tableName);\n            $columnValues = $this->columns->getValues($table, true, $record, $params);\n            return $this->db->updateSingle($table, $columnValues, $id);\n        }\n\n        public function delete(string $tableName, string $id, array $params) /*: ?int*/\n        {\n            $table = $this->reflection->getTable($tableName);\n            return $this->db->deleteSingle($table, $id);\n        }\n\n        public function increment(string $tableName, string $id, /* object */ $record, array $params) /*: ?int*/\n        {\n            $this->sanitizeRecord($tableName, $record, $id);\n            $table = $this->reflection->getTable($tableName);\n            $columnValues = $this->columns->getValues($table, true, $record, $params);\n            return $this->db->incrementSingle($table, $columnValues, $id);\n        }\n\n        public function _list(string $tableName, array $params): ListDocument\n        {\n            $table = $this->reflection->getTable($tableName);\n            $this->joiner->addMandatoryColumns($table, $params);\n            $columnNames = $this->columns->getNames($table, true, $params);\n            $condition = $this->filters->getCombinedConditions($table, $params);\n            $columnOrdering = $this->ordering->getColumnOrdering($table, $params);\n            if (!$this->pagination->hasPage($params)) {\n                $offset = 0;\n                $limit = $this->pagination->getPageLimit($params);\n                $count = -1;\n            } else {\n                $offset = $this->pagination->getPageOffset($params);\n                $limit = $this->pagination->getPageLimit($params);\n                $count = $this->db->selectCount($table, $condition);\n            }\n            $records = $this->db->selectAll($table, $columnNames, $condition, $columnOrdering, $offset, $limit);\n            $this->joiner->addJoins($table, $records, $params, $this->db);\n            return new ListDocument($records, $count);\n        }\n\n        public function ping(): int\n        {\n            return $this->db->ping();\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Record/RelationJoiner.php\nnamespace Tqdev\\PhpCrudApi\\Record {\n\n    use Tqdev\\PhpCrudApi\\Column\\Reflection\\ReflectedTable;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\Middleware\\Communication\\VariableStore;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\ColumnCondition;\n    use Tqdev\\PhpCrudApi\\Record\\Condition\\OrCondition;\n\n    class RelationJoiner\n    {\n        private $reflection;\n        private $ordering;\n        private $columns;\n\n        public function __construct(ReflectionService $reflection, ColumnIncluder $columns)\n        {\n            $this->reflection = $reflection;\n            $this->ordering = new OrderingInfo();\n            $this->columns = $columns;\n        }\n\n        public function addMandatoryColumns(ReflectedTable $table, array &$params) /*: void*/\n        {\n            if (!isset($params['join']) || !isset($params['include'])) {\n                return;\n            }\n            $params['mandatory'] = array();\n            foreach ($params['join'] as $tableNames) {\n                $t1 = $table;\n                foreach (explode(',', $tableNames) as $tableName) {\n                    if (!$this->reflection->hasTable($tableName)) {\n                        continue;\n                    }\n                    $t2 = $this->reflection->getTable($tableName);\n                    $fks1 = $t1->getFksTo($t2->getName());\n                    $t3 = $this->hasAndBelongsToMany($t1, $t2);\n                    if ($t3 != null || count($fks1) > 0) {\n                        $params['mandatory'][] = $t2->getName() . '.' . $t2->getPk()->getName();\n                    }\n                    foreach ($fks1 as $fk) {\n                        $params['mandatory'][] = $t1->getName() . '.' . $fk->getName();\n                    }\n                    $fks2 = $t2->getFksTo($t1->getName());\n                    if ($t3 != null || count($fks2) > 0) {\n                        $params['mandatory'][] = $t1->getName() . '.' . $t1->getPk()->getName();\n                    }\n                    foreach ($fks2 as $fk) {\n                        $params['mandatory'][] = $t2->getName() . '.' . $fk->getName();\n                    }\n                    $t1 = $t2;\n                }\n            }\n        }\n\n        private function getJoinsAsPathTree(array $params): PathTree\n        {\n            $joins = new PathTree();\n            if (isset($params['join'])) {\n                foreach ($params['join'] as $tableNames) {\n                    $path = array();\n                    foreach (explode(',', $tableNames) as $tableName) {\n                        if (!$this->reflection->hasTable($tableName)) {\n                            continue;\n                        }\n                        $t = $this->reflection->getTable($tableName);\n                        if ($t != null) {\n                            $path[] = $t->getName();\n                        }\n                    }\n                    $joins->put($path, true);\n                }\n            }\n            return $joins;\n        }\n\n        public function addJoins(ReflectedTable $table, array &$records, array $params, GenericDB $db) /*: void*/\n        {\n            $joins = $this->getJoinsAsPathTree($params);\n            $this->addJoinsForTables($table, $joins, $records, $params, $db);\n        }\n\n        private function hasAndBelongsToMany(ReflectedTable $t1, ReflectedTable $t2) /*: ?ReflectedTable*/\n        {\n            foreach ($this->reflection->getTableNames() as $tableName) {\n                $t3 = $this->reflection->getTable($tableName);\n                if (count($t3->getFksTo($t1->getName())) > 0 && count($t3->getFksTo($t2->getName())) > 0) {\n                    return $t3;\n                }\n            }\n            return null;\n        }\n\n        private function addJoinsForTables(ReflectedTable $t1, PathTree $joins, array &$records, array $params, GenericDB $db)\n        {\n            foreach ($joins->getKeys() as $t2Name) {\n                $t2 = $this->reflection->getTable($t2Name);\n\n                $belongsTo = count($t1->getFksTo($t2->getName())) > 0;\n                $hasMany = count($t2->getFksTo($t1->getName())) > 0;\n                if (!$belongsTo && !$hasMany) {\n                    $t3 = $this->hasAndBelongsToMany($t1, $t2);\n                } else {\n                    $t3 = null;\n                }\n                $hasAndBelongsToMany = ($t3 != null);\n\n                $newRecords = array();\n                $fkValues = null;\n                $pkValues = null;\n                $habtmValues = null;\n\n                if ($belongsTo) {\n                    $fkValues = $this->getFkEmptyValues($t1, $t2, $records);\n                    $this->addFkRecords($t2, $fkValues, $params, $db, $newRecords);\n                }\n                if ($hasMany) {\n                    $pkValues = $this->getPkEmptyValues($t1, $records);\n                    $this->addPkRecords($t1, $t2, $pkValues, $params, $db, $newRecords);\n                }\n                if ($hasAndBelongsToMany) {\n                    $habtmValues = $this->getHabtmEmptyValues($t1, $t2, $t3, $db, $records);\n                    $this->addFkRecords($t2, $habtmValues->fkValues, $params, $db, $newRecords);\n                }\n\n                $this->addJoinsForTables($t2, $joins->get($t2Name), $newRecords, $params, $db);\n\n                if ($fkValues != null) {\n                    $this->fillFkValues($t2, $newRecords, $fkValues);\n                    $this->setFkValues($t1, $t2, $records, $fkValues);\n                }\n                if ($pkValues != null) {\n                    $this->fillPkValues($t1, $t2, $newRecords, $pkValues);\n                    $this->setPkValues($t1, $t2, $records, $pkValues);\n                }\n                if ($habtmValues != null) {\n                    $this->fillFkValues($t2, $newRecords, $habtmValues->fkValues);\n                    $this->setHabtmValues($t1, $t2, $records, $habtmValues);\n                }\n            }\n        }\n\n        private function getFkEmptyValues(ReflectedTable $t1, ReflectedTable $t2, array $records): array\n        {\n            $fkValues = array();\n            $fks = $t1->getFksTo($t2->getName());\n            foreach ($fks as $fk) {\n                $fkName = $fk->getName();\n                foreach ($records as $record) {\n                    if (isset($record[$fkName])) {\n                        $fkValue = $record[$fkName];\n                        $fkValues[$fkValue] = null;\n                    }\n                }\n            }\n            return $fkValues;\n        }\n\n        private function addFkRecords(ReflectedTable $t2, array $fkValues, array $params, GenericDB $db, array &$records) /*: void*/\n        {\n            $columnNames = $this->columns->getNames($t2, false, $params);\n            $fkIds = array_keys($fkValues);\n\n            foreach ($db->selectMultiple($t2, $columnNames, $fkIds) as $record) {\n                $records[] = $record;\n            }\n        }\n\n        private function fillFkValues(ReflectedTable $t2, array $fkRecords, array &$fkValues) /*: void*/\n        {\n            $pkName = $t2->getPk()->getName();\n            foreach ($fkRecords as $fkRecord) {\n                $pkValue = $fkRecord[$pkName];\n                $fkValues[$pkValue] = $fkRecord;\n            }\n        }\n\n        private function setFkValues(ReflectedTable $t1, ReflectedTable $t2, array &$records, array $fkValues) /*: void*/\n        {\n            $fks = $t1->getFksTo($t2->getName());\n            foreach ($fks as $fk) {\n                $fkName = $fk->getName();\n                foreach ($records as $i => $record) {\n                    if (isset($record[$fkName])) {\n                        $key = $record[$fkName];\n                        $records[$i][$fkName] = $fkValues[$key];\n                    }\n                }\n            }\n        }\n\n        private function getPkEmptyValues(ReflectedTable $t1, array $records): array\n        {\n            $pkValues = array();\n            $pkName = $t1->getPk()->getName();\n            foreach ($records as $record) {\n                $key = $record[$pkName];\n                $pkValues[$key] = array();\n            }\n            return $pkValues;\n        }\n\n        private function addPkRecords(ReflectedTable $t1, ReflectedTable $t2, array $pkValues, array $params, GenericDB $db, array &$records) /*: void*/\n        {\n            $fks = $t2->getFksTo($t1->getName());\n            $columnNames = $this->columns->getNames($t2, false, $params);\n            $pkValueKeys = implode(',', array_keys($pkValues));\n            $conditions = array();\n            foreach ($fks as $fk) {\n                $conditions[] = new ColumnCondition($fk, 'in', $pkValueKeys);\n            }\n            $condition = OrCondition::fromArray($conditions);\n            $columnOrdering = array();\n            $limit = VariableStore::get(\"joinLimits.maxRecords\") ?: -1;\n            if ($limit != -1) {\n                $columnOrdering = $this->ordering->getDefaultColumnOrdering($t2);\n            }\n            foreach ($db->selectAll($t2, $columnNames, $condition, $columnOrdering, 0, $limit) as $record) {\n                $records[] = $record;\n            }\n        }\n\n        private function fillPkValues(ReflectedTable $t1, ReflectedTable $t2, array $pkRecords, array &$pkValues) /*: void*/\n        {\n            $fks = $t2->getFksTo($t1->getName());\n            foreach ($fks as $fk) {\n                $fkName = $fk->getName();\n                foreach ($pkRecords as $pkRecord) {\n                    $key = $pkRecord[$fkName];\n                    if (isset($pkValues[$key])) {\n                        $pkValues[$key][] = $pkRecord;\n                    }\n                }\n            }\n        }\n\n        private function setPkValues(ReflectedTable $t1, ReflectedTable $t2, array &$records, array $pkValues) /*: void*/\n        {\n            $pkName = $t1->getPk()->getName();\n            $t2Name = $t2->getName();\n\n            foreach ($records as $i => $record) {\n                $key = $record[$pkName];\n                $records[$i][$t2Name] = $pkValues[$key];\n            }\n        }\n\n        private function getHabtmEmptyValues(ReflectedTable $t1, ReflectedTable $t2, ReflectedTable $t3, GenericDB $db, array $records): HabtmValues\n        {\n            $pkValues = $this->getPkEmptyValues($t1, $records);\n            $fkValues = array();\n\n            $fk1 = $t3->getFksTo($t1->getName())[0];\n            $fk2 = $t3->getFksTo($t2->getName())[0];\n\n            $fk1Name = $fk1->getName();\n            $fk2Name = $fk2->getName();\n\n            $columnNames = array($fk1Name, $fk2Name);\n\n            $pkIds = implode(',', array_keys($pkValues));\n            $condition = new ColumnCondition($t3->getColumn($fk1Name), 'in', $pkIds);\n            $columnOrdering = array();\n\n            $limit = VariableStore::get(\"joinLimits.maxRecords\") ?: -1;\n            if ($limit != -1) {\n                $columnOrdering = $this->ordering->getDefaultColumnOrdering($t3);\n            }\n            $records = $db->selectAll($t3, $columnNames, $condition, $columnOrdering, 0, $limit);\n            foreach ($records as $record) {\n                $val1 = $record[$fk1Name];\n                $val2 = $record[$fk2Name];\n                $pkValues[$val1][] = $val2;\n                $fkValues[$val2] = null;\n            }\n\n            return new HabtmValues($pkValues, $fkValues);\n        }\n\n        private function setHabtmValues(ReflectedTable $t1, ReflectedTable $t2, array &$records, HabtmValues $habtmValues) /*: void*/\n        {\n            $pkName = $t1->getPk()->getName();\n            $t2Name = $t2->getName();\n            foreach ($records as $i => $record) {\n                $key = $record[$pkName];\n                $val = array();\n                $fks = $habtmValues->pkValues[$key];\n                foreach ($fks as $fk) {\n                    $val[] = $habtmValues->fkValues[$fk];\n                }\n                $records[$i][$t2Name] = $val;\n            }\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/Api.php\nnamespace Tqdev\\PhpCrudApi {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Psr\\Http\\Server\\RequestHandlerInterface;\n    use Tqdev\\PhpCrudApi\\Cache\\CacheFactory;\n    use Tqdev\\PhpCrudApi\\Column\\DefinitionService;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\Controller\\CacheController;\n    use Tqdev\\PhpCrudApi\\Controller\\ColumnController;\n    use Tqdev\\PhpCrudApi\\Controller\\GeoJsonController;\n    use Tqdev\\PhpCrudApi\\Controller\\JsonResponder;\n    use Tqdev\\PhpCrudApi\\Controller\\OpenApiController;\n    use Tqdev\\PhpCrudApi\\Controller\\RecordController;\n    use Tqdev\\PhpCrudApi\\Controller\\StatusController;\n    use Tqdev\\PhpCrudApi\\Database\\GenericDB;\n    use Tqdev\\PhpCrudApi\\GeoJson\\GeoJsonService;\n    use Tqdev\\PhpCrudApi\\Middleware\\ApiKeyAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\ApiKeyDbAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\AuthorizationMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\BasicAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\CorsMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\CustomizationMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\DbAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\FirewallMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\IpAddressMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\JoinLimitsMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\JsonMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\JwtAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\MultiTenancyMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\PageLimitsMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\ReconnectMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\Router\\SimpleRouter;\n    use Tqdev\\PhpCrudApi\\Middleware\\SanitationMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\SslRedirectMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\TextSearchMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\ValidationMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\WpAuthMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\XmlMiddleware;\n    use Tqdev\\PhpCrudApi\\Middleware\\XsrfMiddleware;\n    use Tqdev\\PhpCrudApi\\OpenApi\\OpenApiService;\n    use Tqdev\\PhpCrudApi\\Record\\RecordService;\n\n    class Api implements RequestHandlerInterface\n    {\n        private $router;\n\n        public function __construct(Config $config)\n        {\n            $db = new GenericDB(\n                $config->getDriver(),\n                $config->getAddress(),\n                $config->getPort(),\n                $config->getDatabase(),\n                $config->getCommand(),\n                $config->getTables(),\n                $config->getMapping(),\n                $config->getUsername(),\n                $config->getPassword(),\n                $config->getGeometrySrid()\n            );\n            $prefix = sprintf('phpcrudapi-%s-', substr($config->getUID(), 0, 8));\n            $cache = CacheFactory::create($config->getCacheType(), $prefix, $config->getCachePath());\n            $reflection = new ReflectionService($db, $cache, $config->getCacheTime());\n            $responder = new JsonResponder($config->getJsonOptions(), $config->getDebug());\n            $router = new SimpleRouter($config->getBasePath(), $responder, $cache, $config->getCacheTime());\n            foreach ($config->getMiddlewares() as $middleware) {\n                switch ($middleware) {\n                    case 'sslRedirect':\n                        new SslRedirectMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'cors':\n                        new CorsMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'firewall':\n                        new FirewallMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'apiKeyAuth':\n                        new ApiKeyAuthMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'apiKeyDbAuth':\n                        new ApiKeyDbAuthMiddleware($router, $responder, $config, $middleware, $reflection, $db);\n                        break;\n                    case 'basicAuth':\n                        new BasicAuthMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'jwtAuth':\n                        new JwtAuthMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'dbAuth':\n                        new DbAuthMiddleware($router, $responder, $config, $middleware, $reflection, $db);\n                        break;\n                    case 'wpAuth':\n                        new WpAuthMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'reconnect':\n                        new ReconnectMiddleware($router, $responder, $config, $middleware, $reflection, $db);\n                        break;\n                    case 'validation':\n                        new ValidationMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'ipAddress':\n                        new IpAddressMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'sanitation':\n                        new SanitationMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'multiTenancy':\n                        new MultiTenancyMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'authorization':\n                        new AuthorizationMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'xsrf':\n                        new XsrfMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'pageLimits':\n                        new PageLimitsMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'joinLimits':\n                        new JoinLimitsMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'customization':\n                        new CustomizationMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'textSearch':\n                        new TextSearchMiddleware($router, $responder, $config, $middleware, $reflection);\n                        break;\n                    case 'xml':\n                        new XmlMiddleware($router, $responder, $config, $middleware);\n                        break;\n                    case 'json':\n                        new JsonMiddleware($router, $responder, $config, $middleware);\n                        break;\n                }\n            }\n            foreach ($config->getControllers() as $controller) {\n                switch ($controller) {\n                    case 'records':\n                        $records = new RecordService($db, $reflection);\n                        new RecordController($router, $responder, $records);\n                        break;\n                    case 'columns':\n                        $definition = new DefinitionService($db, $reflection);\n                        new ColumnController($router, $responder, $reflection, $definition);\n                        break;\n                    case 'cache':\n                        new CacheController($router, $responder, $cache);\n                        break;\n                    case 'openapi':\n                        $openApi = new OpenApiService($reflection, $config->getOpenApiBase(), $config->getControllers(), $config->getCustomOpenApiBuilders());\n                        new OpenApiController($router, $responder, $openApi);\n                        break;\n                    case 'geojson':\n                        $records = new RecordService($db, $reflection);\n                        $geoJson = new GeoJsonService($reflection, $records);\n                        new GeoJsonController($router, $responder, $geoJson);\n                        break;\n                    case 'status':\n                        new StatusController($router, $responder, $cache, $db);\n                        break;\n                }\n            }\n            foreach ($config->getCustomControllers() as $className) {\n                if (class_exists($className)) {\n                    new $className($router, $responder, $db, $reflection, $cache);\n                }\n            }\n            $this->router = $router;\n        }\n\n        private function parseBody(string $body) /*: ?object*/\n        {\n            $first = substr(ltrim($body), 0, 1);\n            if ($first == '[' || $first == '{') {\n                $object = json_decode($body);\n                $causeCode = json_last_error();\n                if ($causeCode !== JSON_ERROR_NONE) {\n                    $object = null;\n                }\n            } else {\n                parse_str($body, $input);\n                foreach ($input as $key => $value) {\n                    if (substr($key, -9) == '__is_null') {\n                        $input[substr($key, 0, -9)] = null;\n                        unset($input[$key]);\n                    }\n                }\n                $object = (object) $input;\n            }\n            return $object;\n        }\n\n        private function addParsedBody(ServerRequestInterface $request): ServerRequestInterface\n        {\n            $parsedBody = $request->getParsedBody();\n            if ($parsedBody) {\n                $request = $this->applyParsedBodyHack($request);\n            } else {\n                $body = $request->getBody();\n                if ($body->isReadable()) {\n                    if ($body->isSeekable()) {\n                        $body->rewind();\n                    }\n                    $contents = $body->getContents();\n                    if ($body->isSeekable()) {\n                        $body->rewind();\n                    }\n                    if ($contents) {\n                        $parsedBody = $this->parseBody($contents);\n                        $request = $request->withParsedBody($parsedBody);\n                    }\n                }\n            }\n            return $request;\n        }\n\n        private function applyParsedBodyHack(ServerRequestInterface $request): ServerRequestInterface\n        {\n            $parsedBody = $request->getParsedBody();\n            if (is_array($parsedBody)) { // is it really?\n                $contents = json_encode($parsedBody);\n                $parsedBody = $this->parseBody($contents);\n                $request = $request->withParsedBody($parsedBody);\n            }\n            return $request;\n        }\n\n        public function handle(ServerRequestInterface $request): ResponseInterface\n        {\n            return $this->router->route($this->addParsedBody($request));\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/RequestFactory.php\nnamespace Tqdev\\PhpCrudApi {\n\n    use Nyholm\\Psr7\\Factory\\Psr17Factory;\n    use Nyholm\\Psr7Server\\ServerRequestCreator;\n    use Psr\\Http\\Message\\ServerRequestInterface;\n\n    class RequestFactory\n    {\n        public static function fromGlobals(): ServerRequestInterface\n        {\n            $psr17Factory = new Psr17Factory();\n            $creator = new ServerRequestCreator($psr17Factory, $psr17Factory, $psr17Factory, $psr17Factory);\n            $serverRequest = $creator->fromGlobals();\n            $stream = $psr17Factory->createStreamFromFile('php://input');\n            $serverRequest = $serverRequest->withBody($stream);\n            return $serverRequest;\n        }\n\n        public static function fromString(string $request): ServerRequestInterface\n        {\n            $parts = explode(\"\\n\\n\", trim($request), 2);\n            $lines = explode(\"\\n\", $parts[0]);\n            $first = explode(' ', trim(array_shift($lines)), 2);\n            $method = $first[0];\n            $body = isset($parts[1]) ? $parts[1] : '';\n            $url = isset($first[1]) ? $first[1] : '';\n\n            $psr17Factory = new Psr17Factory();\n            $serverRequest = $psr17Factory->createServerRequest($method, $url);\n            foreach ($lines as $line) {\n                list($key, $value) = explode(':', $line, 2);\n                $serverRequest = $serverRequest->withAddedHeader($key, $value);\n            }\n            if ($body) {\n                $stream = $psr17Factory->createStream($body);\n                $stream->rewind();\n                $serverRequest = $serverRequest->withBody($stream);\n            }\n            return $serverRequest;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/RequestUtils.php\nnamespace Tqdev\\PhpCrudApi {\n\n    use Psr\\Http\\Message\\ServerRequestInterface;\n    use Tqdev\\PhpCrudApi\\Column\\ReflectionService;\n\n    class RequestUtils\n    {\n        public static function setParams(ServerRequestInterface $request, array $params): ServerRequestInterface\n        {\n            $query = preg_replace('|%5B[0-9]+%5D=|', '=', http_build_query($params));\n            return $request->withUri($request->getUri()->withQuery($query));\n        }\n\n        public static function getHeader(ServerRequestInterface $request, string $header): string\n        {\n            $headers = $request->getHeader($header);\n            return isset($headers[0]) ? $headers[0] : '';\n        }\n\n        public static function getParams(ServerRequestInterface $request): array\n        {\n            $params = array();\n            $query = $request->getUri()->getQuery();\n            //$query = str_replace('][]=', ']=', str_replace('=', '[]=', $query));\n            $query = str_replace('%5D%5B%5D=', '%5D=', str_replace('=', '%5B%5D=', $query));\n            parse_str($query, $params);\n            return $params;\n        }\n\n        public static function getPathSegment(ServerRequestInterface $request, int $part): string\n        {\n            $path = $request->getUri()->getPath();\n            $pathSegments = explode('/', rtrim($path, '/'));\n            if ($part < 0 || $part >= count($pathSegments)) {\n                return '';\n            }\n            return urldecode($pathSegments[$part]);\n        }\n\n        public static function getOperation(ServerRequestInterface $request): string\n        {\n            $method = $request->getMethod();\n            $path = RequestUtils::getPathSegment($request, 1);\n            $hasPk = RequestUtils::getPathSegment($request, 3) != '';\n            switch ($path) {\n                case 'openapi':\n                    return 'document';\n                case 'columns':\n                    return $method == 'get' ? 'reflect' : 'remodel';\n                case 'geojson':\n                case 'records':\n                    switch ($method) {\n                        case 'POST':\n                            return 'create';\n                        case 'GET':\n                            return $hasPk ? 'read' : 'list';\n                        case 'PUT':\n                            return 'update';\n                        case 'DELETE':\n                            return 'delete';\n                        case 'PATCH':\n                            return 'increment';\n                    }\n            }\n            return 'unknown';\n        }\n\n        private static function getJoinTables(string $tableName, array $parameters): array\n        {\n            $uniqueTableNames = array();\n            $uniqueTableNames[$tableName] = true;\n            if (isset($parameters['join'])) {\n                foreach ($parameters['join'] as $parameter) {\n                    $tableNames = explode(',', trim($parameter));\n                    foreach ($tableNames as $tableName) {\n                        $uniqueTableNames[$tableName] = true;\n                    }\n                }\n            }\n            return array_keys($uniqueTableNames);\n        }\n\n        public static function getTableNames(ServerRequestInterface $request, ReflectionService $reflection): array\n        {\n            $path = RequestUtils::getPathSegment($request, 1);\n            $tableName = RequestUtils::getPathSegment($request, 2);\n            $allTableNames = $reflection->getTableNames();\n            switch ($path) {\n                case 'openapi':\n                    return $allTableNames;\n                case 'columns':\n                    return $tableName ? [$tableName] : $allTableNames;\n                case 'records':\n                    return self::getJoinTables($tableName, RequestUtils::getParams($request));\n            }\n            return $allTableNames;\n        }\n\n        public static function toString(ServerRequestInterface $request): string\n        {\n            $method = $request->getMethod();\n            $uri = $request->getUri()->__toString();\n            $headers = $request->getHeaders();\n            $request->getBody()->rewind();\n            $body = $request->getBody()->getContents();\n\n            $str = \"$method $uri\\n\";\n            foreach ($headers as $key => $values) {\n                foreach ($values as $value) {\n                    $str .= \"$key: $value\\n\";\n                }\n            }\n            if ($body !== '') {\n                $str .= \"\\n\";\n                $str .= \"$body\\n\";\n            }\n            return $str;\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/ResponseFactory.php\nnamespace Tqdev\\PhpCrudApi {\n\n    use Nyholm\\Psr7\\Factory\\Psr17Factory;\n    use Psr\\Http\\Message\\ResponseInterface;\n\n    class ResponseFactory\n    {\n        const OK = 200;\n        const MOVED_PERMANENTLY = 301;\n        const FOUND = 302;\n        const UNAUTHORIZED = 401;\n        const FORBIDDEN = 403;\n        const NOT_FOUND = 404;\n        const METHOD_NOT_ALLOWED = 405;\n        const CONFLICT = 409;\n        const UNPROCESSABLE_ENTITY = 422;\n        const FAILED_DEPENDENCY = 424;\n        const INTERNAL_SERVER_ERROR = 500;\n\n        public static function fromXml(int $status, string $xml): ResponseInterface\n        {\n            return self::from($status, 'text/xml', $xml);\n        }\n\n        public static function fromCsv(int $status, string $csv): ResponseInterface\n        {\n            return self::from($status, 'text/csv', $csv);\n        }\n\n        public static function fromHtml(int $status, string $html): ResponseInterface\n        {\n            return self::from($status, 'text/html', $html);\n        }\n\n        public static function fromObject(int $status, $body, int $jsonOptions): ResponseInterface\n        {\n            $content = json_encode($body, $jsonOptions);\n            return self::from($status, 'application/json', $content);\n        }\n\n        public static function from(int $status, string $contentType, string $content): ResponseInterface\n        {\n            $psr17Factory = new Psr17Factory();\n            $response = $psr17Factory->createResponse($status);\n            $stream = $psr17Factory->createStream($content);\n            $stream->rewind();\n            $response = $response->withBody($stream);\n            $response = $response->withHeader('Content-Type', $contentType . '; charset=utf-8');\n            $response = $response->withHeader('Content-Length', strlen($content));\n            return $response;\n        }\n\n        public static function fromStatus(int $status): ResponseInterface\n        {\n            $psr17Factory = new Psr17Factory();\n            return $psr17Factory->createResponse($status);\n        }\n    }\n}\n\n// file: src/Tqdev/PhpCrudApi/ResponseUtils.php\nnamespace Tqdev\\PhpCrudApi {\n\n    use Psr\\Http\\Message\\ResponseInterface;\n\n    class ResponseUtils\n    {\n        public static function output(ResponseInterface $response)\n        {\n            $status = $response->getStatusCode();\n            $headers = $response->getHeaders();\n            $body = $response->getBody()->getContents();\n\n            http_response_code($status);\n            foreach ($headers as $key => $values) {\n                foreach ($values as $value) {\n                    header(\"$key: $value\");\n                }\n            }\n            echo $body;\n        }\n\n        public static function addExceptionHeaders(ResponseInterface $response, \\Throwable $e): ResponseInterface\n        {\n            $response = $response->withHeader('X-Exception-Name', get_class($e));\n            $response = $response->withHeader('X-Exception-Message', preg_replace('|\\n|', ' ', trim($e->getMessage())));\n            $response = $response->withHeader('X-Exception-File', $e->getFile() . ':' . $e->getLine());\n            return $response;\n        }\n\n        public static function toString(ResponseInterface $response): string\n        {\n            $status = $response->getStatusCode();\n            $headers = $response->getHeaders();\n            $response->getBody()->rewind();\n            $body = $response->getBody()->getContents();\n\n            $str = \"$status\\n\";\n            foreach ($headers as $key => $values) {\n                foreach ($values as $value) {\n                    $str .= \"$key: $value\\n\";\n                }\n            }\n            if ($body !== '') {\n                $str .= \"\\n\";\n                $str .= \"$body\\n\";\n            }\n            return $str;\n        }\n    }\n}\n\n// file: src/index.php\nnamespace Tqdev\\PhpCrudApi {\n\n    use Tqdev\\PhpCrudApi\\Api;\n    use Tqdev\\PhpCrudApi\\Config\\Config;\n    use Tqdev\\PhpCrudApi\\RequestFactory;\n    use Tqdev\\PhpCrudApi\\ResponseUtils;\n\n    $config = new Config([\n        // 'driver' => 'mysql',\n        // 'address' => 'localhost',\n        // 'port' => '3306',\n        'username' => 'php-crud-api',\n        'password' => 'php-crud-api',\n        'database' => 'php-crud-api',\n        // 'debug' => false\n    ]);\n    $request = RequestFactory::fromGlobals();\n    $api = new Api($config);\n    $response = $api->handle($request);\n    ResponseUtils::output($response);\n\n    //file_put_contents('request.log',RequestUtils::toString($request).\"===\\n\",FILE_APPEND);\n    //file_put_contents('request.log',ResponseUtils::toString($response).\"===\\n\",FILE_APPEND);\n}\n"
        },
        {
          "name": "build.php",
          "type": "blob",
          "size": 3.5771484375,
          "content": "<?php\n\n// combine src and vendor directories into a single file\n\nfunction removeIgnored(string $dir, array &$entries, array $ignore)\n{\n    foreach ($entries as $i => $entry) {\n        if (isset($ignore[$dir . '/' . $entry])) {\n            unset($entries[$i]);\n        }\n    }\n}\n\nfunction runDir(string $base, string $dir, array &$lines, array $ignore): int\n{\n    $count = 0;\n    $entries = scandir($dir);\n    removeIgnored($dir, $entries, $ignore);\n    sort($entries);\n    foreach ($entries as $entry) {\n        if ($entry === '.' || $entry === '..') {\n            continue;\n        }\n        $filename = \"$base/$dir/$entry\";\n        if (is_dir($filename)) {\n            $count += runDir($base, \"$dir/$entry\", $lines, $ignore);\n        }\n    }\n    foreach ($entries as $entry) {\n        $filename = \"$base/$dir/$entry\";\n        if (is_file($filename)) {\n            if (substr($entry, -4) != '.php') {\n                continue;\n            }\n            $data = file_get_contents($filename);\n            $data = preg_replace('/\\s*<\\?php\\s+/s', '', $data, 1);\n            $data = preg_replace('/^.*?(vendor\\/autoload|declare\\s*\\(\\s*strict_types\\s*=\\s*1).*?$/m', '', $data);\n            array_push($lines, \"// file: $dir/$entry\");\n            if (!preg_match('/^\\s*(namespace[^;]*);/', $data)) {\n                $data = \"namespace;\\n\" . $data;\n            }\n            foreach (explode(\"\\n\", trim($data)) as $line) {\n                if ($line) {\n                    $line = '    ' . $line;\n                }\n                $line = preg_replace('/^\\s*(namespace[^;]*);/', '\\1 {', $line);\n                array_push($lines, $line);\n            }\n            array_push($lines, '}');\n            array_push($lines, '');\n            $count++;\n        }\n    }\n    return $count;\n}\n\nfunction addHeader(array &$lines)\n{\n    $head = <<<EOF\n<?php\n/**\n * PHP-CRUD-API v2              License: MIT\n * Maurits van der Schee: maurits@vdschee.nl\n * https://github.com/mevdschee/php-crud-api\n *\n * Dependencies:\n * - vendor/psr/*: PHP-FIG\n *   https://github.com/php-fig\n * - vendor/nyholm/*: Tobias Nyholm\n *   https://github.com/Nyholm\n **/\n\nEOF;\n    foreach (explode(\"\\n\", $head) as $line) {\n        array_push($lines, $line);\n    }\n}\n\nfunction run(string $base, array $dirs, string $filename, array $ignore, array $replaces)\n{\n    $lines = [];\n    $start = microtime(true);\n    addHeader($lines);\n    $ignore = array_flip($ignore);\n    $count = 0;\n    foreach ($dirs as $dir) {\n        $count += runDir($base, $dir, $lines, $ignore);\n    }\n    $data = implode(\"\\n\", $lines);\n    $data = preg_replace('/\\n({)?\\s*\\n\\s*\\n/', \"\\n$1\\n\", $data);\n    foreach ($replaces as $search => $replace) {\n        $data = str_replace($search, $replace, $data);\n    }\n    file_put_contents('tmp_' . $filename, $data);\n    ob_start();\n    include 'tmp_' . $filename;\n    ob_end_clean();\n    rename('tmp_' . $filename, $filename);\n    $data = substr($data, 0, strrpos($data, \"\\n// file: src/index.php\"));\n    file_put_contents(str_replace('.php', '.include.php', $filename), $data);\n    $end = microtime(true);\n    $time = ($end - $start) * 1000;\n    echo sprintf(\"%d files combined in %d ms into '%s'\\n\", $count, $time, $filename);\n}\n\n$ignore = [\n    'vendor/nyholm/psr7/src/Factory/HttplugFactory.php',\n    'vendor/nyholm/psr7/.php-cs-fixer.dist.php',\n];\n\n$replaces = [\n    'use StreamTrait;' => 'function __toString():string { if ($this->isSeekable()) { $this->seek(0); } return $this->getContents(); }'\n];\n\n$directories = ['vendor/nyholm', 'src'];\n\nif (!extension_loaded('psr')) {\n    array_unshift($directories, 'vendor/psr');\n}\n\nrun(__DIR__, $directories, 'api.php', $ignore, $replaces);\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.1708984375,
          "content": "{\n  \"name\": \"mevdschee/php-crud-api\",\n  \"type\": \"library\",\n  \"description\": \"Single file PHP script that adds a REST API to a SQL database.\",\n  \"keywords\": [\n    \"api-server\",\n    \"restful\",\n    \"mysql\",\n    \"geospatial\",\n    \"php\",\n    \"sql-server\",\n    \"postgresql\",\n    \"php-api\",\n    \"postgis\",\n    \"crud\",\n    \"rest-api\",\n    \"openapi\",\n    \"swagger\",\n    \"automatic-api\",\n    \"database\",\n    \"multi-database\",\n    \"sql-database\",\n    \"ubuntu-linux\"\n  ],\n  \"homepage\": \"https://github.com/mevdschee/php-crud-api\",\n  \"license\": \"MIT\",\n  \"authors\": [\n    {\n      \"name\": \"Maurits van der Schee\",\n      \"email\": \"maurits@vdschee.nl\",\n      \"homepage\": \"https://github.com/mevdschee\"\n    }\n  ],\n  \"require\": {\n    \"php\": \">=7.0.0\",\n    \"ext-zlib\": \"*\",\n    \"ext-json\": \"*\",\n    \"ext-pdo\": \"*\",\n    \"ext-mbstring\": \"*\",\n    \"psr/http-message\": \"*\",\n    \"psr/http-factory\": \"*\",\n    \"psr/http-server-handler\": \"*\",\n    \"psr/http-server-middleware\": \"*\",\n    \"nyholm/psr7\": \"*\",\n    \"nyholm/psr7-server\": \"*\"\n  },\n  \"suggest\": {\n    \"ext-memcache\": \"*\",\n    \"ext-memcached\": \"*\",\n    \"ext-redis\": \"*\"\n  },\n  \"autoload\": {\n    \"psr-4\": {\n      \"Tqdev\\\\PhpCrudApi\\\\\": \"src/Tqdev/PhpCrudApi\"\n    }\n  }\n}\n"
        },
        {
          "name": "composer.lock",
          "type": "blob",
          "size": 12.9658203125,
          "content": "{\n    \"_readme\": [\n        \"This file locks the dependencies of your project to a known state\",\n        \"Read more about it at https://getcomposer.org/doc/01-basic-usage.md#installing-dependencies\",\n        \"This file is @generated automatically\"\n    ],\n    \"content-hash\": \"5f2fee2526a8086e2f5c7e9207bc7504\",\n    \"packages\": [\n        {\n            \"name\": \"nyholm/psr7\",\n            \"version\": \"1.8.2\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/Nyholm/psr7.git\",\n                \"reference\": \"a71f2b11690f4b24d099d6b16690a90ae14fc6f3\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/Nyholm/psr7/zipball/a71f2b11690f4b24d099d6b16690a90ae14fc6f3\",\n                \"reference\": \"a71f2b11690f4b24d099d6b16690a90ae14fc6f3\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=7.2\",\n                \"psr/http-factory\": \"^1.0\",\n                \"psr/http-message\": \"^1.1 || ^2.0\"\n            },\n            \"provide\": {\n                \"php-http/message-factory-implementation\": \"1.0\",\n                \"psr/http-factory-implementation\": \"1.0\",\n                \"psr/http-message-implementation\": \"1.0\"\n            },\n            \"require-dev\": {\n                \"http-interop/http-factory-tests\": \"^0.9\",\n                \"php-http/message-factory\": \"^1.0\",\n                \"php-http/psr7-integration-tests\": \"^1.0\",\n                \"phpunit/phpunit\": \"^7.5 || ^8.5 || ^9.4\",\n                \"symfony/error-handler\": \"^4.4\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.8-dev\"\n                }\n            },\n            \"autoload\": {\n                \"psr-4\": {\n                    \"Nyholm\\\\Psr7\\\\\": \"src/\"\n                }\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Tobias Nyholm\",\n                    \"email\": \"tobias.nyholm@gmail.com\"\n                },\n                {\n                    \"name\": \"Martijn van der Ven\",\n                    \"email\": \"martijn@vanderven.se\"\n                }\n            ],\n            \"description\": \"A fast PHP7 implementation of PSR-7\",\n            \"homepage\": \"https://tnyholm.se\",\n            \"keywords\": [\n                \"psr-17\",\n                \"psr-7\"\n            ],\n            \"support\": {\n                \"issues\": \"https://github.com/Nyholm/psr7/issues\",\n                \"source\": \"https://github.com/Nyholm/psr7/tree/1.8.2\"\n            },\n            \"funding\": [\n                {\n                    \"url\": \"https://github.com/Zegnat\",\n                    \"type\": \"github\"\n                },\n                {\n                    \"url\": \"https://github.com/nyholm\",\n                    \"type\": \"github\"\n                }\n            ],\n            \"time\": \"2024-09-09T07:06:30+00:00\"\n        },\n        {\n            \"name\": \"nyholm/psr7-server\",\n            \"version\": \"1.1.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/Nyholm/psr7-server.git\",\n                \"reference\": \"4335801d851f554ca43fa6e7d2602141538854dc\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/Nyholm/psr7-server/zipball/4335801d851f554ca43fa6e7d2602141538854dc\",\n                \"reference\": \"4335801d851f554ca43fa6e7d2602141538854dc\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \"^7.1 || ^8.0\",\n                \"psr/http-factory\": \"^1.0\",\n                \"psr/http-message\": \"^1.0 || ^2.0\"\n            },\n            \"require-dev\": {\n                \"nyholm/nsa\": \"^1.1\",\n                \"nyholm/psr7\": \"^1.3\",\n                \"phpunit/phpunit\": \"^7.0 || ^8.5 || ^9.3\"\n            },\n            \"type\": \"library\",\n            \"autoload\": {\n                \"psr-4\": {\n                    \"Nyholm\\\\Psr7Server\\\\\": \"src/\"\n                }\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Tobias Nyholm\",\n                    \"email\": \"tobias.nyholm@gmail.com\"\n                },\n                {\n                    \"name\": \"Martijn van der Ven\",\n                    \"email\": \"martijn@vanderven.se\"\n                }\n            ],\n            \"description\": \"Helper classes to handle PSR-7 server requests\",\n            \"homepage\": \"http://tnyholm.se\",\n            \"keywords\": [\n                \"psr-17\",\n                \"psr-7\"\n            ],\n            \"support\": {\n                \"issues\": \"https://github.com/Nyholm/psr7-server/issues\",\n                \"source\": \"https://github.com/Nyholm/psr7-server/tree/1.1.0\"\n            },\n            \"funding\": [\n                {\n                    \"url\": \"https://github.com/Zegnat\",\n                    \"type\": \"github\"\n                },\n                {\n                    \"url\": \"https://github.com/nyholm\",\n                    \"type\": \"github\"\n                }\n            ],\n            \"time\": \"2023-11-08T09:30:43+00:00\"\n        },\n        {\n            \"name\": \"psr/http-factory\",\n            \"version\": \"1.1.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/php-fig/http-factory.git\",\n                \"reference\": \"2b4765fddfe3b508ac62f829e852b1501d3f6e8a\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/php-fig/http-factory/zipball/2b4765fddfe3b508ac62f829e852b1501d3f6e8a\",\n                \"reference\": \"2b4765fddfe3b508ac62f829e852b1501d3f6e8a\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=7.1\",\n                \"psr/http-message\": \"^1.0 || ^2.0\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.0.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"psr-4\": {\n                    \"Psr\\\\Http\\\\Message\\\\\": \"src/\"\n                }\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"PHP-FIG\",\n                    \"homepage\": \"https://www.php-fig.org/\"\n                }\n            ],\n            \"description\": \"PSR-17: Common interfaces for PSR-7 HTTP message factories\",\n            \"keywords\": [\n                \"factory\",\n                \"http\",\n                \"message\",\n                \"psr\",\n                \"psr-17\",\n                \"psr-7\",\n                \"request\",\n                \"response\"\n            ],\n            \"support\": {\n                \"source\": \"https://github.com/php-fig/http-factory\"\n            },\n            \"time\": \"2024-04-15T12:06:14+00:00\"\n        },\n        {\n            \"name\": \"psr/http-message\",\n            \"version\": \"2.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/php-fig/http-message.git\",\n                \"reference\": \"402d35bcb92c70c026d1a6a9883f06b2ead23d71\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/php-fig/http-message/zipball/402d35bcb92c70c026d1a6a9883f06b2ead23d71\",\n                \"reference\": \"402d35bcb92c70c026d1a6a9883f06b2ead23d71\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \"^7.2 || ^8.0\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"2.0.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"psr-4\": {\n                    \"Psr\\\\Http\\\\Message\\\\\": \"src/\"\n                }\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"PHP-FIG\",\n                    \"homepage\": \"https://www.php-fig.org/\"\n                }\n            ],\n            \"description\": \"Common interface for HTTP messages\",\n            \"homepage\": \"https://github.com/php-fig/http-message\",\n            \"keywords\": [\n                \"http\",\n                \"http-message\",\n                \"psr\",\n                \"psr-7\",\n                \"request\",\n                \"response\"\n            ],\n            \"support\": {\n                \"source\": \"https://github.com/php-fig/http-message/tree/2.0\"\n            },\n            \"time\": \"2023-04-04T09:54:51+00:00\"\n        },\n        {\n            \"name\": \"psr/http-server-handler\",\n            \"version\": \"1.0.2\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/php-fig/http-server-handler.git\",\n                \"reference\": \"84c4fb66179be4caaf8e97bd239203245302e7d4\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/php-fig/http-server-handler/zipball/84c4fb66179be4caaf8e97bd239203245302e7d4\",\n                \"reference\": \"84c4fb66179be4caaf8e97bd239203245302e7d4\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=7.0\",\n                \"psr/http-message\": \"^1.0 || ^2.0\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.0.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"psr-4\": {\n                    \"Psr\\\\Http\\\\Server\\\\\": \"src/\"\n                }\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"PHP-FIG\",\n                    \"homepage\": \"https://www.php-fig.org/\"\n                }\n            ],\n            \"description\": \"Common interface for HTTP server-side request handler\",\n            \"keywords\": [\n                \"handler\",\n                \"http\",\n                \"http-interop\",\n                \"psr\",\n                \"psr-15\",\n                \"psr-7\",\n                \"request\",\n                \"response\",\n                \"server\"\n            ],\n            \"support\": {\n                \"source\": \"https://github.com/php-fig/http-server-handler/tree/1.0.2\"\n            },\n            \"time\": \"2023-04-10T20:06:20+00:00\"\n        },\n        {\n            \"name\": \"psr/http-server-middleware\",\n            \"version\": \"1.0.2\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/php-fig/http-server-middleware.git\",\n                \"reference\": \"c1481f747daaa6a0782775cd6a8c26a1bf4a3829\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/php-fig/http-server-middleware/zipball/c1481f747daaa6a0782775cd6a8c26a1bf4a3829\",\n                \"reference\": \"c1481f747daaa6a0782775cd6a8c26a1bf4a3829\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=7.0\",\n                \"psr/http-message\": \"^1.0 || ^2.0\",\n                \"psr/http-server-handler\": \"^1.0\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.0.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"psr-4\": {\n                    \"Psr\\\\Http\\\\Server\\\\\": \"src/\"\n                }\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"PHP-FIG\",\n                    \"homepage\": \"https://www.php-fig.org/\"\n                }\n            ],\n            \"description\": \"Common interface for HTTP server-side middleware\",\n            \"keywords\": [\n                \"http\",\n                \"http-interop\",\n                \"middleware\",\n                \"psr\",\n                \"psr-15\",\n                \"psr-7\",\n                \"request\",\n                \"response\"\n            ],\n            \"support\": {\n                \"issues\": \"https://github.com/php-fig/http-server-middleware/issues\",\n                \"source\": \"https://github.com/php-fig/http-server-middleware/tree/1.0.2\"\n            },\n            \"time\": \"2023-04-11T06:14:47+00:00\"\n        }\n    ],\n    \"packages-dev\": [],\n    \"aliases\": [],\n    \"minimum-stability\": \"stable\",\n    \"stability-flags\": [],\n    \"prefer-stable\": false,\n    \"prefer-lowest\": false,\n    \"platform\": {\n        \"php\": \">=7.0.0\",\n        \"ext-zlib\": \"*\",\n        \"ext-json\": \"*\",\n        \"ext-pdo\": \"*\",\n        \"ext-mbstring\": \"*\"\n    },\n    \"platform-dev\": [],\n    \"plugin-api-version\": \"2.6.0\"\n}\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 1.16796875,
          "content": "version: '3'\nservices:\n    database:\n        image: mysql:8.0\n        container_name: database\n        restart: always\n        environment:\n            - MYSQL_ROOT_PASSWORD=php-crud-api\n            - MYSQL_DATABASE=php-crud-api\n            - MYSQL_USER=php-crud-api\n            - MYSQL_PASSWORD=php-crud-api\n            #ports:\n            #- \"33066:3306\"\n        volumes:\n            - ./tests/fixtures/blog_mysql.sql:/docker-entrypoint-initdb.d/blog_mysql.sql\n    webserver:\n        container_name: webserver\n        build:\n            context: ./\n        environment:\n            #- PHP_CRUD_API_DRIVER=mysql\n            - PHP_CRUD_API_ADDRESS=database\n            #- PHP_CRUD_API_PORT=3306\n            #- PHP_CRUD_API_DATABASE=php-crud-api\n            #- PHP_CRUD_API_USERNAME=php-crud-api\n            #- PHP_CRUD_API_PASSWORD=php-crud-api\n            #- PHP_CRUD_API_DEBUG=1\n            - PHP_CRUD_API_MAPPING=abc_posts.abc_id=posts.id,abc_posts.abc_user_id=posts.user_id,abc_posts.abc_category_id=posts.category_id,abc_posts.abc_content=posts.content\n        ports:\n            - \"8080:80\"\n        depends_on:\n            - database\n            #volumes:\n            #- .:/php-crud-api:ro\n"
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "extras",
          "type": "tree",
          "content": null
        },
        {
          "name": "install.php",
          "type": "blob",
          "size": 0.271484375,
          "content": "<?php\n\n// download composer and install dependencies\n\nif (!file_exists('composer.phar')) {\n    $composer = file_get_contents('https://getcomposer.org/composer.phar');\n    file_put_contents('composer.phar', $composer);\n}\nexec('php composer.phar install --ignore-platform-reqs');\n"
        },
        {
          "name": "publish-docker.sh",
          "type": "blob",
          "size": 0.712890625,
          "content": "#!/bin/bash\n\n# Get new tags from remote\ngit fetch --tags\n# Get latest tag name\nlatestTag=$(git describe --tags `git rev-list --tags --max-count=1`)\n# Checkout latest tag\ngit checkout $latestTag || exit\n# Make docker tag\ndockerTag=$(echo $latestTag | sed s/v/release-/)\n# Build release\ndocker build . -t mevdschee/php-crud-api:$dockerTag\n# Build latest\ndocker build . -t mevdschee/php-crud-api:latest\n\n# Revert\ngit switch -\n\n# Confirm to publish\necho; echo; echo\nread -p \"Publish $latestTag to mevdschee/php-crud-api:$dockerTag? \" -n 1 -r\necho\nif [[ $REPLY =~ ^[Yy]$ ]]\nthen\n\n# Login to DockerHub\ndocker login\n# Push release\ndocker push mevdschee/php-crud-api:$dockerTag\n# Push latest\ndocker push mevdschee/php-crud-api:latest\n\nfi\n"
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 0.7099609375,
          "content": "#!/bin/bash\n\n# Get new tags from remote\ngit fetch --tags\n# Get latest tag name\nlatestTag=$(git describe --tags `git rev-list --tags --max-count=1`)\n# Parse v1.2.3 into array\nlatestTag=${latestTag//./ }\nlatestTag=${latestTag/v/}\nversion=($latestTag)\n# Calculate new version\ncase $1 in \n  major)\n    version[0]=$((version[0]+1))\n    version[1]=0\n    version[2]=0\n    ;;\n  minor) \n    version[1]=$((version[1]+1))\n    version[2]=0\n    ;;\n  *) # build\n    version[2]=$((version[2]+1))\n    ;; \nesac\n# Constuct new tag\nnewTag=v${version[0]}.${version[1]}.${version[2]}\n# Build all files\nphp update.php\nphp build.php\ngit commit -am \"update dependencies\" && git push\n# Build all files\ngh release create $newTag api.php api.include.php\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.php",
          "type": "blob",
          "size": 6.857421875,
          "content": "<?php\n\nuse Tqdev\\PhpCrudApi\\Api;\nuse Tqdev\\PhpCrudApi\\Config\\Config;\nuse Tqdev\\PhpCrudApi\\Database\\GenericDB;\nuse Tqdev\\PhpCrudApi\\RequestFactory;\nuse Tqdev\\PhpCrudApi\\ResponseUtils;\n\nerror_reporting(-1);\nrequire 'api.include.php';\n\nfunction runDir(Config $config, string $dir, array $matches, string $category): array\n{\n    $success = 0;\n    $skipped = 0;\n    $failed = 0;\n    $entries = scandir($dir);\n    foreach ($entries as $entry) {\n        if ($entry === '.' || $entry === '..') {\n            continue;\n        }\n        if (isset($matches[0])) {\n            if (!preg_match('/' . $matches[0] . '/', $entry)) {\n                continue;\n            }\n        }\n        $file = \"$dir/$entry\";\n        if (is_file($file)) {\n            if (substr($entry, -4) != '.log') {\n                continue;\n            }\n            $statistics = runTest($config, $file, $category);\n            $success += $statistics['success'];\n            $skipped += $statistics['skipped'];\n            $failed += $statistics['failed'];\n        } elseif (is_dir($file)) {\n            $statistics = runDir($config, $file, array_slice($matches, 1), \"$category/$entry\");\n            $success += $statistics['success'];\n            $skipped += $statistics['skipped'];\n            $failed += $statistics['failed'];\n        }\n    }\n    return compact('success', 'skipped', 'failed');\n}\n\nfunction runTest(Config $config, string $file, string $category): array\n{\n    $success = 1;\n    $skipped = 0;\n    $failed = 0;\n    $title = ucwords(str_replace('_', ' ', $category)) . '/';\n    $title .= ucwords(str_replace('_', ' ', substr(basename($file), 0, -4)));\n    $line1 = \"=====[$title]=====\";\n    $len = strlen($line1);\n    $line2 = str_repeat(\"=\", $len);\n    $parts = preg_split('/^[=]+([\\r\\n]+|$)/m', file_get_contents($file));\n    $headers = explode(\"\\n\", $parts[0]);\n    $driver = $config->getDriver();\n    foreach ($headers as $header) {\n        if (!strpos($header, ':')) {\n            continue;\n        }\n        list($key, $value) = explode(':', strtolower($header));\n        if ($key == \"skip-for-$driver\") {\n            $skipped = 1;\n            $success = 0;\n        }\n        if ($key == \"skip-always\") {\n            $skipped = 1;\n            $success = 0;\n        }\n    }\n    if (!$skipped) {\n        $dirty = false;\n        for ($i = 1; $i < count($parts); $i += 2) {\n            $recording = false;\n            if (empty($parts[$i + 1])) {\n                if (substr($parts[$i], -1) != \"\\n\") {\n                    $parts[$i] .= \"\\n\";\n                }\n                $parts[$i + 1] = '';\n                $recording = true;\n                $dirty = true;\n            }\n            $in = $parts[$i];\n            $exp = $parts[$i + 1];\n            $api = new Api($config);\n            $out = ResponseUtils::toString($api->handle(RequestFactory::fromString($in)));\n            if ($recording) {\n                $parts[$i + 1] = $out;\n            } else if ($out != $exp) {\n                echo \"$line1\\n$exp\\n$line2\\n$out\\n$line2\\n\";\n                $failed = 1;\n                $success = 0;\n            }\n        }\n        if ($dirty) {\n            file_put_contents($file, implode(\"===\\n\", $parts));\n        }\n    }\n    return compact('success', 'skipped', 'failed');\n}\n\nfunction getDatabase(Config $config)\n{\n    if (!is_callable($config->getProperty('reconnect.databaseHandler'))) {\n        return $config->getDatabase();\n    }\n    return $config->getProperty('reconnect.databaseHandler')();\n}\n\nfunction getCommand(Config $config)\n{\n    if (!is_callable($config->getProperty('reconnect.commandHandler'))) {\n        return $config->getCommand();\n    }\n    return $config->getProperty('reconnect.commandHandler')();\n}\n\nfunction getTables(Config $config)\n{\n    if (!is_callable($config->getProperty('reconnect.tablesHandler'))) {\n        return $config->getTables();\n    }\n    return $config->getProperty('reconnect.tablesHandler')();\n}\n\nfunction getMapping(Config $config)\n{\n    if (!is_callable($config->getProperty('reconnect.mappingHandler'))) {\n        return $config->getMapping();\n    }\n    return $config->getProperty('reconnect.mappingHandler')();\n}\n\nfunction getUsername(Config $config)\n{\n    if (!is_callable($config->getProperty('reconnect.usernameHandler'))) {\n        return $config->getUsername();\n    }\n    return $config->getProperty('reconnect.usernameHandler')();\n}\n\nfunction getPassword(Config $config)\n{\n    if (!is_callable($config->getProperty('reconnect.passwordHandler'))) {\n        return $config->getPassword();\n    }\n    return $config->getProperty('reconnect.passwordHandler')();\n}\n\nfunction loadFixture(string $dir, Config $config)\n{\n    $driver = $config->getDriver();\n    $filename = \"$dir/fixtures/blog_$driver.sql\";\n    $file = file_get_contents($filename);\n    $db = new GenericDB(\n        $config->getDriver(),\n        $config->getAddress(),\n        $config->getPort(),\n        getDatabase($config),\n        getCommand($config),\n        getTables($config),\n        getMapping($config),\n        getUsername($config),\n        getPassword($config),\n        $config->getGeometrySrid()\n    );\n    $pdo = $db->pdo();\n    $file = preg_replace('/--.*$/m', '', $file);\n    if ($driver == 'sqlsrv') {\n        $statements = preg_split('/\\n\\s*GO\\s*\\n/s', $file);\n    } else {\n        $statements = preg_split('/(?<=;)\\n/s', $file);\n    }\n    foreach ($statements as $i => $statement) {\n        $statement = trim($statement);\n        if ($statement) {\n            try {\n                $pdo->exec($statement);\n            } catch (\\PDOException $e) {\n                $error = print_r($pdo->errorInfo(), true);\n                $statement = var_export($statement, true);\n                echo \"Loading '$filename' failed on statemement #$i:\\n$statement\\nwith error:\\n$error\\n\";\n                exit(1);\n            }\n        }\n    }\n}\n\nfunction run(array $drivers, string $dir, array $matches)\n{\n    foreach ($drivers as $driver) {\n        if (isset($matches[0])) {\n            if (!preg_match('/' . $matches[0] . '/', $driver)) {\n                continue;\n            }\n        }\n        if (!extension_loaded(\"pdo_$driver\")) {\n            echo sprintf(\"%s: skipped, driver not loaded\\n\", $driver);\n            continue;\n        }\n        $settings = [];\n        include \"$dir/config/base.php\";\n        include sprintf(\"$dir/config/%s.php\", $driver);\n        $config = new Config($settings);\n        loadFixture($dir, $config);\n        $start = microtime(true);\n        $statistics = runDir($config, \"$dir/functional\", array_slice($matches, 1), '');\n        $end = microtime(true);\n        $time = ($end - $start) * 1000;\n        $success = $statistics['success'];\n        $skipped = $statistics['skipped'];\n        $failed = $statistics['failed'];\n        $total = $success + $skipped + $failed;\n        echo sprintf(\"%s: %d tests ran in %d ms, %d skipped, %d failed\\n\", $driver, $total, $time, $skipped, $failed);\n    }\n}\n\nrun(['mysql', 'pgsql', 'sqlsrv', 'sqlite'], __DIR__ . '/tests', array_slice($argv, 1));\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "update.php",
          "type": "blob",
          "size": 0.26953125,
          "content": "<?php\n\n// download composer and update dependencies\n\nif (!file_exists('composer.phar')) {\n    $composer = file_get_contents('https://getcomposer.org/composer.phar');\n    file_put_contents('composer.phar', $composer);\n}\nexec('php composer.phar update --ignore-platform-reqs');\n"
        }
      ]
    }
  ]
}