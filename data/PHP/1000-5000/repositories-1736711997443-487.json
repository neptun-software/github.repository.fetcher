{
  "metadata": {
    "timestamp": 1736711997443,
    "page": 487,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ssl/ezXSS",
      "stars": 1954,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0830078125,
          "content": ".github/\n.gitignore\n.git/\nDockerfile\ndocker-compose.yml\nreadme.md\nnginx-rewrite.conf\n"
        },
        {
          "name": ".env.example",
          "type": "blob",
          "size": 0.51171875,
          "content": "# Database settings for ezXSS\ndbHost=\"ezxssdb\"\ndbUser=ezxss\ndbPassword=changeme\ndbName=database\ndbPort=3306\n\n# ezXSS app settings\ndebug=false\nhttpmode=false\nsignupEnabled=false\n\n# Docker settings\ndockerHttpPort=80\ndockerHttpsPort=443\nuseMailAlerts=true\nautoInstallCertificate=true\ndomain=example.ezxss.com\n\n# ezProxy settings\nprHost=0.0.0.0\nprWebPort=30055\nprProxyPort=13000\nprCertFile=/home/ezxss/domains/example.com/ssl.cert\nprKeyFile=/home/ezxss/domains/example.com/ssl.key\nprUseLogin=false\nprUser=ezxss\nprPassword=ezxss\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.05859375,
          "content": ".env\nezxssdb/\n.idea/\n.vscode/\n/assets/img/report-*\n.DS_Store"
        },
        {
          "name": ".htaccess",
          "type": "blob",
          "size": 0.15234375,
          "content": "Options -Indexes\nRewriteEngine On\nRewriteCond %{REQUEST_URI} !assets\nRewriteCond %{REQUEST_URI} !.well-known/acme-challenge/\nRewriteRule ^(.*)$ init.php [L]"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.23828125,
          "content": "FROM php:8-apache\n\n# PHP and Apache configuration\nRUN mv /usr/local/etc/php/php.ini-production /usr/local/etc/php/php.ini\nRUN echo \"RemoteIPHeader X-Forwarded-For\" >> /etc/apache2/conf-enabled/remoteip.conf\nRUN echo \"RemoteIPInternalProxy 172.16.0.0/12\" >> /etc/apache2/conf-enabled/remoteip.conf\nRUN a2enmod rewrite headers remoteip\nRUN docker-php-ext-install pdo_mysql\n\n# Install necessary packages\nRUN apt-get update && \\\n    apt-get install -y certbot python3-certbot-apache msmtp && \\\n    rm -rf /var/lib/apt/lists/*\n\n# Configure Apache and SSL\nRUN a2enmod ssl\nCOPY ./docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh\nRUN chmod +x /usr/local/bin/docker-entrypoint.sh\n\n# Copy the application files\nCOPY . /var/www/html\n\n# Mail alerts service configuring\nARG USE_MAIL_ALERTS\nRUN if [ \"$USE_MAIL_ALERTS\" = \"true\" ]; then \\\n        cp ./msmtprc /etc/msmtprc; \\\n        chmod 640 /etc/msmtprc; \\\n        touch /var/log/msmtp.log; \\\n        chown root:www-data /etc/msmtprc; \\\n        chown root:www-data /var/log/msmtp.log; \\\n        echo \"sendmail_path = /usr/bin/msmtp -t\" >> /usr/local/etc/php/conf.d/php-sendmail.ini; \\\n    fi\n\nRUN chmod 777 /var/www/html/assets/img\n\n# Set the entrypoint script to initialize everything\nENTRYPOINT [\"docker-entrypoint.sh\"]\n"
        },
        {
          "name": "app",
          "type": "tree",
          "content": null
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.6884765625,
          "content": "version: '3.7'\n\nservices:\n  ezxssdb:\n    image: mysql:latest\n    restart: always\n    environment:\n      - MYSQL_RANDOM_ROOT_PASSWORD=yes\n      - MYSQL_DATABASE=${dbName}\n      - MYSQL_USER=${dbUser}\n      - MYSQL_PASSWORD=${dbPassword}\n    volumes:\n      - \"./ezxssdb:/var/lib/mysql\"\n  ezxss:\n    build:\n      context: .\n      dockerfile: ./Dockerfile\n      args:\n        - USE_MAIL_ALERTS=${useMailAlerts}\n    ports:\n      - \"${dockerHttpPort:-80}:80\"\n      - \"${dockerHttpsPort:-443}:443\"\n    volumes:\n      - .:/var/www/html\n    restart: always\n    depends_on:\n      - ezxssdb\n    environment:\n      - INSTALL_CERTIFICATE=${autoInstallCertificate}\n      - DOMAIN=${domain}\n      - HTTPMODE=${httpmode}\n"
        },
        {
          "name": "docker-entrypoint.sh",
          "type": "blob",
          "size": 2.8232421875,
          "content": "#!/bin/bash\n\necho \"Starting ezXSS with Apache in the background...\"\n# Start Apache in the background to allow for certificate validation\napache2ctl start || { echo \"Failed to start Apache\"; exit 1; }\n\n# Short delay to ensure Apache starts properly\nsleep 5\n\necho \"Checking and obtaining SSL certificate if necessary...\"\n# Function to check and obtain a certificate if needed\nobtain_certificate() {\n    if [ \"$INSTALL_CERTIFICATE\" = \"true\" ]; then\n        if [ ! -e \"/etc/letsencrypt/live/$DOMAIN/fullchain.pem\" ]; then\n            echo \"Setting ServerName $DOMAIN in Apache configuration...\"\n            if ! grep -q \"ServerName $DOMAIN\" /etc/apache2/apache2.conf; then\n                echo \"ServerName $DOMAIN\" >> /etc/apache2/apache2.conf\n            fi\n            \n            echo \"Attempting to obtain SSL certificate for $DOMAIN...\"\n            certbot certonly --non-interactive --agree-tos --email webmaster@$DOMAIN --webroot --webroot-path=/var/www/html -d $DOMAIN\n            \n            if [ $? -eq 0 ] && [ -e \"/etc/letsencrypt/live/$DOMAIN/fullchain.pem\" ]; then\n                echo \"SSL certificate obtained successfully. Updating Apache SSL configuration...\"\n                sed -i \"s|SSLCertificateFile .*|SSLCertificateFile /etc/letsencrypt/live/$DOMAIN/fullchain.pem|g\" /etc/apache2/sites-available/default-ssl.conf\n                sed -i \"s|SSLCertificateKeyFile .*|SSLCertificateKeyFile /etc/letsencrypt/live/$DOMAIN/privkey.pem|g\" /etc/apache2/sites-available/default-ssl.conf\n                \n                if [ ! -e \"/etc/apache2/sites-enabled/default-ssl.conf\" ]; then\n                    echo \"Enabling SSL site configuration...\"\n                    a2ensite default-ssl.conf && apache2ctl graceful || { echo \"Failed to enable SSL site or reload Apache\"; exit 1; }\n                else\n                    echo \"SSL site already enabled. Reloading Apache to apply changes...\"\n                    apache2ctl graceful || { echo \"Failed to reload Apache\"; exit 1; }\n                fi\n            else\n                echo \"Certbot failed to obtain the certificate. Exiting...\"\n                exit 1\n            fi\n        else\n            echo \"SSL certificate already exists. Skipping certificate acquisition...\"\n        fi\n    else\n        echo \"SSL certificate installation not requested. Skipping...\"\n        if [ \"$HTTPMODE\" = \"false\" ]; then\n            if [ ! -e \"/etc/apache2/sites-enabled/default-ssl.conf\" ]; then\n                echo \"Enabling SSL site configuration...\"\n                a2ensite default-ssl.conf && apache2ctl graceful || { echo \"Failed to enable SSL site or reload Apache\"; exit 1; }\n            fi\n        fi\n    fi\n}\n\n# Obtain the certificate\nobtain_certificate\n\necho \"Switching Apache to run in the foreground...\"\n# Switch Apache to run in the foreground to keep the container running\napache2ctl stop\nexec apache2ctl -D FOREGROUND\n"
        },
        {
          "name": "ezProxy.py",
          "type": "blob",
          "size": 8.5029296875,
          "content": "#!/usr/bin/env python3\nimport os\nimport asyncio\nimport ssl\nimport websockets\nfrom urllib.parse import urlsplit\nimport json\nimport base64\nfrom dotenv import load_dotenv\n\n\"\"\"\nThe ezXSS persistent proxy is a reverse proxy that can only be used in combination with a ezXSS installation.\nAfter starting the proxy, users can insert the domain and port used into a persistent session in the ezXSS management panel.\nThis feature enables easy and secure testing of persistent XSS vulnerabilities on a target website.\nFor additional information and support, please visit the ezXSS wiki on GitHub at https://github.com/ssl/ezXSS/wiki\n\"\"\"\n\nprint(\"\"\"\n                   .::      .::  .:: ::    .:: ::  \n                    .::   .::  .::    .::.::    .::\n   .::    .:::: .::  .:: .::    .::       .::      \n .:   .::      .::     .::        .::       .::    \n.::::: .::   .::     .:: .::         .::       .::     ezProxy v1.0\n.:          .::     .::   .::  .::    .::.::    .::    github.com/ssl/ezXSS\n  .::::   .::::::::.::      .::  .:: ::    .:: ::\n\"\"\")\n\n\n# Settings\nload_dotenv()\nhost = os.getenv(\"prHost\")\nwebsockets_port = os.getenv(\"prWebPort\")\nproxy_port = os.getenv(\"prProxyPort\")\nuse_login = True if os.getenv(\"prUseLogin\") == '1' or os.getenv(\"prUseLogin\") == 'true' else False\nusername = os.getenv(\"prUser\")\npassword = os.getenv(\"prPassword\")\ncert_file = os.getenv(\"prCertFile\")\ncert_key = os.getenv(\"prKeyFile\")\n\n# SSL context\ntry:\n    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    ssl_context.load_cert_chain(cert_file, keyfile=cert_key)\n\n    from cryptography import x509\n    from cryptography.hazmat.backends import default_backend\n    with open(cert_file, \"rb\") as cert_file_stream:\n        cert_data = cert_file_stream.read()\n        certificate = x509.load_pem_x509_certificate(cert_data, default_backend())\n        hostname = None\n        for attribute in certificate.subject:\n            if attribute.oid == x509.NameOID.COMMON_NAME:\n                hostname = attribute.value\n                break\n    if hostname == None:\n        raise Exception('Could not find hostname from certificate')\nexcept Exception as e:\n    print(f\"Error while loading SSL cert: {e}\")\n    exit()\n\n\nconnected_clients, passed_origins, client_queues = {}, {}, {}\n\n# Websockets receiving message\nasync def echo(websocket, path):\n    client_id = None\n    try:\n        async for message in websocket:\n            data = json.loads(message)\n\n            if client_id is None:\n                client_id = data['clientid'].lower()\n                connected_clients[client_id] = websocket\n\n                print(f\"\\n[!] Client connected with client ID: {client_id}\")\n                print(f\"[!] Origin: {data['origin']}\")\n\n                if data['pass'] == True:\n                    print(f\"[>] Accessible on http://{client_id}.ezxss and http://{data['origin']}\")\n                    passed_origins[data['origin']] = client_id\n                else:\n                    print(f'[>] Accessible on http://{client_id}.ezxss')\n            else:\n                data = json.loads(message)\n                client_id = data['clientid'].lower()\n\n                if \"body\" in data:\n                    if client_id not in client_queues:\n                        client_queues[client_id] = {}\n\n                    request_uri = data[\"request_uri\"]\n                    if request_uri not in client_queues[client_id]:\n                        client_queues[client_id][request_uri] = asyncio.Queue()\n\n                    await client_queues[client_id][request_uri].put(message)\n    finally:\n        if client_id is not None:\n            connected_clients.pop(client_id, None)\n            client_queues.pop(client_id, None)\n\n\n# Proxy server receives new request\nasync def handle_connection(reader, writer):\n    try:\n        writer.get_extra_info('socket')\n        request = ''.join((line + '\\n') for line in (await reader.read(32768)).decode(\"ISO-8859-1\").splitlines())\n        if '\\n\\n' in request:\n            request_head, request_body = request.split('\\n\\n', 1)\n        else:\n            request_head, request_body = request, ''\n        request_head = request_head.splitlines()\n        request_headline = request_head[0]\n        request_method, request_uri, request_proto = (request_headline.split(' ') + [''] * 3)[:3]\n\n        parsed_uri = urlsplit(request_uri)\n        domain = parsed_uri.netloc\n        status_code, content_type = 200, \"text/html; encoding=utf8\"\n        \n        do_proxy = False\n        response_body = 'You can not browse the internet while on the ezXSS proxy.'.encode('utf-8')\n\n        # Check for the Authorization header\n        if use_login:\n            auth_encoded = base64.b64encode(f'{username}:{password}'.encode('utf-8')).decode('utf-8')\n            auth_header = [header for header in request_head if header.lower().startswith('authorization')]\n            if not auth_header or f'Basic {auth_encoded}' != auth_header[0].split(' ', 1)[1]:\n                response_head = 'HTTP/1.1 401 Unauthorized\\r\\nWWW-Authenticate: Basic realm=\"Proxy\"\\r\\n\\r\\n'\n                writer.write(response_head.encode('utf-8'))\n                writer.write(response_body)\n                await writer.drain()\n\n        if domain.endswith('.ezxss'):\n            client_id = domain[:-6]\n            do_proxy = True\n        \n        if not domain.endswith('.ezxss'):\n            if domain in passed_origins:\n                client_id = passed_origins[domain]\n                do_proxy = True\n        \n        if do_proxy:\n            full_uri = parsed_uri.path + ('?' + parsed_uri.query if parsed_uri.query else '')\n            if client_id in connected_clients:\n                message = json.dumps({\"method\": request_method, \"request_uri\": full_uri, \"postData\": request_body})\n                await connected_clients[client_id].send(message)\n\n                client_response = None\n                try:\n                    if client_id not in client_queues:\n                        client_queues[client_id] = {}\n\n                    if full_uri not in client_queues[client_id]:\n                        client_queues[client_id][full_uri] = asyncio.Queue()\n\n                    msg = await asyncio.wait_for(client_queues[client_id][full_uri].get(), timeout=10)\n                    data = json.loads(msg)\n                    if 'body' in data and data.get('request_uri') == full_uri:\n                        status_code = data.get('statusCode', 200)\n                        client_response = base64.b64decode(data['body'])\n                        content_type = data.get('content_type', 'text/html')\n                except asyncio.TimeoutError:\n                    print(f'Timed out waiting for a response from client with unique ID \"{client_id}\"')\n\n                if client_response is not None:\n                    response_body = client_response\n                else:\n                    response_body = f'No response received from client with client ID \"{client_id}\"'.encode('utf-8')\n            else:\n                response_body = f'No connected client found with client ID \"{client_id}\"'.encode('utf-8')\n        \n        response_head = f'HTTP/1.1 {status_code} OK\\r\\nContent-Type: {content_type}\\r\\nContent-Length: {len(response_body)}\\r\\n\\r\\n'\n        writer.write(response_head.encode('utf-8'))\n        writer.write(response_body)\n        await writer.drain()\n    except Exception as e:\n        #pass\n        print(f\"Error while processing request: {e}\")\n    finally:\n        writer.close()\n\n\n# Async server\nclass AsyncServer:\n    def __init__(self, server):\n        self.server = server\n\n    async def __aenter__(self):\n        return self.server\n\n    async def __aexit__(self, exc_type, exc, tb):\n        self.server.close()\n\n\n# Run proxy server\nasync def run_proxy_server():\n    try:\n        server = await asyncio.start_server(handle_connection, host, proxy_port)\n    except:\n        print('Error in starting proxy server')\n        exit()\n    print(f'[#] Proxy running on {hostname}:{proxy_port}')\n\n    async with AsyncServer(server) as server:\n        await asyncio.gather(server.wait_closed())\n\n\n# Run websockets server\nasync def run_websockets_server():\n    await websockets.serve(echo, host, websockets_port, ssl=ssl_context)\n    print(f'[#] Websockets running on {hostname}:{websockets_port}')\n\n\n# Gather both servers\nasync def main():\n    websockets_server = asyncio.ensure_future(run_websockets_server())\n    proxy_server = asyncio.ensure_future(run_proxy_server())\n    print('')\n    await asyncio.gather(websockets_server, proxy_server)\n\n\n# Start loop\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n    try:\n        loop.run_until_complete(main())\n    finally:\n        loop.close()\n\n"
        },
        {
          "name": "index.html",
          "type": "blob",
          "size": 0.1435546875,
          "content": "<h1>Error</h1>\n<p>Your mod_rewrite is not setup correctly. Visit the <a href=\"https://github.com/ssl/ezXSS/wiki\">wiki</a> for more information.</p>"
        },
        {
          "name": "init.php",
          "type": "blob",
          "size": 0.8447265625,
          "content": "<?php\ntry {\n    // Check PHP version\n    if (PHP_VERSION_ID < 70100) {\n        throw new Exception('PHP 7.1 or up is required to use ezXSS');\n    }\n\n    // Load all required files\n    require __DIR__ . '/system/Autoload.php';\n\n    // Display all errors if in debug mode\n    if (debug) {\n        ini_set('display_errors', 1);\n        ini_set('display_startup_errors', 1);\n        error_reporting(E_ALL);\n    } else {\n        ini_set('display_errors', 0);\n    }\n\n    // Start routing\n    $router = new Router();\n    echo $router->proccess(path);\n} catch (Exception $message) {\n    // Any unexpected uncatched exception will show an error page\n    if (!class_exists('View')) {\n        require_once __DIR__ . '/system/View.php';\n    }\n    $view = new View();\n    $view->setContentType('text/html');\n    echo $view->renderErrorPage($message->getMessage());\n    exit();\n}"
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2018 Elyesa (ezXSS)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "msmtprc",
          "type": "blob",
          "size": 0.31640625,
          "content": "## This file is used by docker for easy external SMTP email configuration\n## We suggest a free email service like Mailjet if you decide to use this\naccount default\nhost smtp.example.com\nport 587\ntls on\ntls_starttls on\nauth on\nuser usernamegoeshere\npassword passwordgoeshere\nfrom ezXSS@example.com\nlogfile /var/log/msmtp.log\n"
        },
        {
          "name": "nginx-rewrite.conf",
          "type": "blob",
          "size": 2.7490234375,
          "content": "server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    root /var/www/html;\n    index index.php index.html index.htm index.nginx-debian.html;\n\n    client_max_body_size 150m;\n\n    server_name 'domain.tld';\n\n    autoindex off;\n\n    # Redirect all HTTP requests to HTTPS with a 301 Moved Permanently response.\n    return 301 https://$host$request_uri;\n\n    # Misc Hardening\n    server_tokens off;\n\n    location ~ /\\.(?!well-known).* {\n      deny all;\n      access_log off;\n      log_not_found off;\n      return 404;\n    }\n\n    if ($request_method !~ ^(GET|HEAD|POST)$ ) {\n        return 444;\n    }\n\n}\n\nserver {\n    listen 443 ssl http2;\n    listen [::]:443 ssl http2;\n\n    root /var/www/html;\n    index index.php index.html index.htm index.nginx-debian.html;\n\n    client_max_body_size 150m;\n\n    autoindex off;\n\n    server_name 'domain.tld';\n\nlocation /\n    {\n        if ($request_uri !~ \"assets\")\n        {\n                set $rule_0 1$rule_0;\n        }\n\n        if ($rule_0 = \"1\")\n        {\n                rewrite ^/(.*)$ /init.php;\n        }\n    }\n\n   location ^~ /.well-known/security.txt {\n        allow all;\n        default_type \"text/plain\";\n    }\n\n   location ^~ /humans.txt {\n         allow all;\n         default_type \"text/plain\";\n   }\n\n    location ~ \\.php$ {\n        include snippets/fastcgi-php.conf;\n        fastcgi_pass unix:/run/php/php7.2-fpm.sock;\n    }\n\n    # Certs sent to the client in SERVER HELLO are concatenated in ssl_certificate\n    ssl_certificate /etc/letsencrypt/live/domain.tld/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/domain.tld/privkey.pem;\n    ssl_session_timeout 1d;\n    ssl_session_cache shared:SSL:50m;\n    ssl_session_tickets off;\n\n    # \"Modern\"-ish configuration.\n    ssl_protocols TLSv1.3 TLSv1.2 TLSv1.1;\n    ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';\n    ssl_prefer_server_ciphers on;\n\n    # HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months)\n    add_header Strict-Transport-Security max-age=15768000;\n\n    # OCSP Stapling ---\n    # fetch OCSP records from URL in ssl_certificate and cache them\n    ssl_stapling on;\n    ssl_stapling_verify on;\n\n    ## Verify chain of trust of OCSP response using Root CA and Intermediate certs\n    ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;\n    resolver 1.0.0.1;\n\n    # Misc Hardening\n    server_tokens off;\n\n    location ~ /\\.(?!well-known).* {\n      deny all;\n      access_log off;\n      log_not_found off;\n      return 404;\n    }\n\n    if ($request_method !~ ^(GET|HEAD|POST)$ ) {\n        return 444;\n    }\n}\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 4.28515625,
          "content": "<p align=\"center\">\n  <img src=\"https://i.imgur.com/oPtfbDG.png\"><br>\n  ezXSS is an easy way for penetration testers and bug \n  bounty hunters to test (blind) Cross Site Scripting.<br><br>\n  <img src=\"https://img.shields.io/github/release/ssl/ezXSS?style=flat\">\n  <img src=\"https://img.shields.io/github/issues/ssl/ezXSS?style=flat\">\n  <img src=\"https://img.shields.io/github/forks/ssl/ezXSS?style=flat\">\n  <img src=\"https://img.shields.io/github/stars/ssl/ezXSS?style=flat\">\n  <img src=\"https://img.shields.io/github/license/ssl/ezXSS?style=flat\">\n</p>\n<hr>\nezXSS is a tool that is designed to help find and exploit cross-site scripting (XSS) vulnerabilities. One of the key features of ezXSS is its ability to identify and exploit blind XSS vulnerabilities, which can be difficult to find using traditional methods.\n<br><br>\nOnce an ezXSS payload is placed, the user must wait until it is triggered, at which point ezXSS will store and alert the user all the information of the vulnerable page. These reports can then be used to further identify and track important data. Payloads can even be updated to make the XSS persistent, allowing to track the infected user over all visited pages and open a reverse proxy.\n\n## Features\n* Easy to use dashboard with settings, statistics, payloads, view/share/search reports\n* :new: Persistent XSS sessions with reverse proxy aslong as the browser is active\n* Manage unlimited users with permissions to personal payloads & their reports\n* Instant alerts via mail, Telegram, Slack, Discord or custom callback URL\n* Custom extra javascript payloads\n* Custom payload links to distinguish insert points\n* Extract additional pages, block, whitelist and other filters\n* Secure your login with Two-factor (2FA)\n* The following information can be collected on a vulnerable page:\n    * The URL of the page\n    * IP Address\n    * Any page referer (or share referer)\n    * The User-Agent\n    * All Non-HTTP-Only Cookies\n    * All Locale Storage\n    * All Session Storage\n    * Full HTML DOM source of the page\n    * Page origin\n    * Time of execution\n    * Payload URL\n    * Screenshot of the page\n    * Extract additional defined pages\n* Triggers in all browsers, starting from Chrome 3+, IE 6+, Firefox 4+, Opera 10.5+, Safari 4+\n* much much more, and, its just ez :-)\n\n## Required\n* Server or shared web hosting with PHP 7.0 or up\n* Domain name (consider a short one or check out [shortboost](https://github.com/ssl/shortboost))\n* SSL Certificate to test on https websites (consider Cloudflare or Let's Encrypt for a free SSL)\n\n## Installation\nezXSS is ez to install with Apache, NGINX or Docker\n\nvisit the [wiki](https://github.com/ssl/ezXSS/wiki) for installation instructions.\n\n\n## Explore ezXSS hassle free\nInterested in using ezXSS but don't want to install it yet? Worry not! You can access and start using ezXSS with a free account on [ez.pe](https://ez.pe). Simply sign up and get started without any installation hassle.\n\nAdditionally, if you'd like to explore and test the tool before committing, there is a demo environment with admin account available at [demo.ezxss.com/manage](https://demo.ezxss.com/manage).\n\nPlease note that some features might be disabled or limited in both the free account on ez.pe and the demo environment. These limitations are in place to maintain the integrity and security of the platforms. However, you can still get a good grasp of the tool's capabilities and decide after to install it yourself.\n\n## Sponsors\nMaintenance of this project is made possible by all the contributors and sponsors. \nI've personally worked for over 8 years on this project, taking hundreds of hours from my time. Please kindly consider becoming a sponsor, so I can continue maintaining and improving ezXSS as well as creating and releasing new projects. Current sponsors:\n\n<p align=\"center\">\n<!-- sponsors --><a href=\"https://github.com/geeknik\"><img src=\"https:&#x2F;&#x2F;github.com&#x2F;geeknik.png\" width=\"60px\" alt=\"geeknik\" /></a>&nbsp;&nbsp;<a href=\"https://github.com/GlitchSecure\"><img src=\"https:&#x2F;&#x2F;github.com&#x2F;GlitchSecure.png\" width=\"60px\" alt=\"GlitchSecure\" /></a>&nbsp;&nbsp;<a href=\"https://github.com/vaadata\"><img src=\"https:&#x2F;&#x2F;github.com&#x2F;vaadata.png\" width=\"60px\" alt=\"vaadata\" /></a>&nbsp;&nbsp;<!-- sponsors -->\n<br><br><a href=\"https://github.com/sponsors/ssl\">Become a sponsor</a>\n</p>\n"
        },
        {
          "name": "system",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}