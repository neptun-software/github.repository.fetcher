{
  "metadata": {
    "timestamp": 1736712032074,
    "page": 542,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "3masterplus/book",
      "stars": 1836,
      "defaultBranch": "master",
      "files": [
        {
          "name": "C程序设计语言(K&amp;R)_第2版中文版.pdf",
          "type": "blob",
          "size": 970.3994140625,
          "content": null
        },
        {
          "name": "HTTP权威指南（中文版）.pdf",
          "type": "blob",
          "size": 87167.2255859375,
          "content": ""
        },
        {
          "name": "Head First 设计模式(中文版).pdf",
          "type": "blob",
          "size": 45141.0791015625,
          "content": ""
        },
        {
          "name": "Java数据结构和算法.（第二版）.pdf",
          "type": "blob",
          "size": 25774.3271484375,
          "content": ""
        },
        {
          "name": "Linux高性能服务器编程.pdf",
          "type": "blob",
          "size": 35159.88671875,
          "content": ""
        },
        {
          "name": "Mysql.zip",
          "type": "blob",
          "size": 18449.0078125,
          "content": ""
        },
        {
          "name": "Nginx 安全配置指南技术手册.pdf",
          "type": "blob",
          "size": 673.1396484375,
          "content": null
        },
        {
          "name": "PHP-Debug-Manual-public(链家鸟哥参与).pdf",
          "type": "blob",
          "size": 1940.5244140625,
          "content": null
        },
        {
          "name": "PHP5权威编程.pdf",
          "type": "blob",
          "size": 25956.091796875,
          "content": ""
        },
        {
          "name": "PHP7 Swoole开发超高性能后台程序--韩天峰@PHPCon2016-web.pdf",
          "type": "blob",
          "size": 2355.3388671875,
          "content": null
        },
        {
          "name": "PHP与MySQL高性能应用开发.杜江.pdf",
          "type": "blob",
          "size": 61925.1552734375,
          "content": ""
        },
        {
          "name": "PHP入门到高级成长线路图（一）.docx",
          "type": "blob",
          "size": 199.087890625,
          "content": null
        },
        {
          "name": "PHP在金融股票项目中的应用--超群@PHPCon2016.pdf",
          "type": "blob",
          "size": 1222.1748046875,
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.1201171875,
          "content": "# book\nBook PDF\n\n#注:\n  作者整理了一下有助于提升自己的书籍的pdf版,希望有兴趣的朋友可以down~ \n"
        },
        {
          "name": "Redis 高可用架构最佳实践.ppt",
          "type": "blob",
          "size": 1782.5,
          "content": null
        },
        {
          "name": "Redis源代码分析.pdf",
          "type": "blob",
          "size": 641.0537109375,
          "content": null
        },
        {
          "name": "Redis设计与实现.pdf",
          "type": "blob",
          "size": 67052.37890625,
          "content": ""
        },
        {
          "name": "UNIX网络编程_卷2_进程间通信.pdf",
          "type": "blob",
          "size": 43183.96875,
          "content": ""
        },
        {
          "name": "[设计模式之禅].秦小波.源代码.zip",
          "type": "blob",
          "size": 903.369140625,
          "content": null
        },
        {
          "name": "application",
          "type": "tree",
          "content": null
        },
        {
          "name": "git.png",
          "type": "blob",
          "size": 177.1572265625,
          "content": null
        },
        {
          "name": "hplus.zip",
          "type": "blob",
          "size": 8830.4306640625,
          "content": ""
        },
        {
          "name": "linux C编程实战.pdf",
          "type": "blob",
          "size": 82484.4169921875,
          "content": ""
        },
        {
          "name": "linux常见操作.zip",
          "type": "blob",
          "size": 993.0263671875,
          "content": null
        },
        {
          "name": "markdown笔记",
          "type": "tree",
          "content": null
        },
        {
          "name": "php核心知识纲要.html",
          "type": "blob",
          "size": 59.4990234375,
          "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>PHP核心知识纲要</title>\n<script src=\"jquery-1.7.1.js\"></script>\n<script>\n\t$(function(){\n\t\t$(\"ul\").hide();\n\t\t$(\"body>ul\").show();\n\n\t\t$(\"li\").each(function(){\n\t\t\tif($(this)[0].childNodes.length > 1 && $(\"ul\",this).size() > 0)\n\t\t\t{\n\t\t\t\t$($(this)[0].childNodes[0]).wrap(\"<a href='#'></a>\");\n\n\t\t\t}\n\t\t});\n\t\t$(\"li > a\").click(function(){\n\t\t\t$(this).next().toggle();\n\t\t\t$(this).css({\"text-decoration\":\"underline\"});\n\t\t\treturn false;\n\t\t});\n\t\t$(\"ul:first\").dblclick(function(){\n\t\t\t$(\"ul\").show();\n\t\t});\n\t\t\n\t\t//$(\"li>ul\").toggle();\n\t\t//$(\"li>ul:first\").toggle();\n\n\t});\n</script>\n</head>\n\n<body>\n<ul>\n  <li>php介绍 \n    <ul>\n      <li>缩写：Personal Home Page  ==&gt;&gt;PHP：HypeText  Preprocessor </li>\n      <li>历史\n        <ul>\n          <li>1995PHP/FI，Rasmus Lorderf，Personal Home Page </li>\n          <li>1997PHP/FI2.0，1998PHP3，2000PHP4，2005PHP5 </li>\n        </ul>\n      </li>\n      <li>应用范围：\n        <ul>\n          <li>web服务器端脚本 </li>\n          <li>命令行脚本</li>\n          <li>应用程序图形界面 </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>php运行环境\n    <ul>\n      <li>BS软件模式\n        <ul>\n          <li>浏览器软件若干 </li>\n          <li>web服务器软件若干 </li>\n          <li>后台程序语言若干 </li>\n          <li>web运行流程：\n            <ul>\n              <li>浏览器输入地址，回车（发送请求） </li>\n              <li>根据规则找到对应web服务器。规则如下：\n                <ul>\n                  <li>首先在本机hosts文件中找对应IP </li>\n                  <li>如果hosts中没有找到，则到互联网上找对应IP </li>\n                  <li>如果还是没有找到，则终止请求，返回“找不到服务器”提示 </li>\n                </ul>\n              </li>\n              <li>web服务器取得对应文件 </li>\n              <li>如有需要，对该文件进行一定的处理（比如php代码执行） </li>\n              <li>将文件（或执行结果文件）返回给浏览器（返回应答） </li>\n              <li>浏览器接收到文件 </li>\n              <li>浏览器处理文件（显示/执行） </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>PHP的命令行运行模式：\n        <ul>\n          <li>运行php文件：php.exe -f &quot;php文件路径&quot;</li>\n          <li>运行php代码：php.exe -r &quot;php脚本代码&quot;</li>\n        </ul>\n      </li>\n      <li>web服务器运行模式\n        <ul>\n          <li>安装apache软件\n            <ul>\n              <li>测试apache </li>\n            </ul>\n          </li>\n          <li>将php配置为apache模块：loadModule php5_module &quot;php5apache2_2.dll路径&quot;</li>\n          <li>告知apache何时调用php模块\n            <ul>\n              <li>方式1：FilesMatch〉setHandler &quot;application/x-httpd-php&quot;</li>\n              <li>方式2：addType application/x-httpd-php .php .php3</li>\n              <li>测试php运行: </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>配置php\n        <ul>\n          <li>使用phpinfo()测试。</li>\n          <li>确定php的配置文件\n            <ul>\n              <li>PHPIniDir 设定php.in文件位置 </li>\n            </ul>\n          </li>\n          <li>修改php配置\n            <ul>\n              <li>设置时区：timezone=PRC </li>\n              <li>设置扩展库目录：extension_dir </li>\n              <li>打开扩展库：mysql, mysqli </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>安装mysql数据库\n    <ul>\n      <li>安装过程： </li>\n      <li>相关配置过程：\n        <ul>\n          <li>设置环境变量以方便登录 </li>\n          <li>对php.ini，可以打开对应扩展mysql </li>\n        </ul>\n      </li>\n      <li>操作mysql数据库的基本流程\n        <ul>\n          <li>客户端连接mysql服务器 </li>\n          <li>客户端发送命令（操作语句） </li>\n          <li>服务器执行语句 </li>\n          <li>服务器返回执行结果 </li>\n          <li>客户端展示执行结果 </li>\n          <li>断开连接（退出登录） </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>虚拟主机基本配置\n    <ul>\n      <li>端口监听设置 </li>\n      <li>主机配置的关键项\n        <ul>\n          <li>主机名： </li>\n          <li>主机目录： </li>\n        </ul>\n      </li>\n      <li>目录的访问设置\n        <ul>\n          <li>Options</li>\n          <li>Order</li>\n          <li>Allow和Deny</li>\n          <li>AllowOverride</li>\n          <li>.htaccess文件 </li>\n        </ul>\n      </li>\n      <li>其他相关设置\n        <ul>\n          <li>默认页设置DirectoryIndex </li>\n          <li>主机别名设置ServerAlias </li>\n          <li>目录别名设置Alias </li>\n        </ul>\n      </li>\n      <li>多域名虚拟主机配置：\n        <ul>\n          <li>打开主配置文件中的httpd-vhosts.conf开关 </li>\n          <li>编辑多域名配置文件httpd-vhosts.conf</li>\n          <li>设定要进行多域名配置的IP及端口：NameVirtualHost *:80</li>\n          <li>一个一个主机进行配置：\n            <ul>\n              <li>设定主机域名：ServerName</li>\n              <li>设定主机目录：DocumentRoot</li>\n              <li>设定目录访问：Directory权限设定 </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>PHP运行基本环境配置与设定\n    <ul>\n      <li>确定配置文件所在位置：用phpinfo.php查看 </li>\n      <li>修改php的时区设定 </li>\n      <li>设定php的标记形式：\n        <ul>\n          <li>典型（标准）标记形式 </li>\n          <li>脚本形式&lt;script language=&quot;php&quot;&gt;</li>\n          <li>短标记形式：short_open_tag </li>\n          <li>结束标记有时可以省略</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>php基本语法形式：\n    <ul>\n      <li>区分大小写\n        <ul>\n          <li>是指变量名区分大小写</li>\n          <li>但函数名不区分</li>\n          <li>而系统中使用的关键字也不区分大小写，比如if， else， for</li>\n        </ul>\n      </li>\n      <li>一条语句使用一个分号结束\n        <ul>\n          <li>最后一个分号可省略 </li>\n          <li>php结束标记省略则不能省略最后一个分号 </li>\n        </ul>\n      </li>\n      <li>php注释形式\n        <ul>\n          <li>单行注释\n            <ul>\n              <li>//常规风格（推荐） </li>\n              <li>#配置文件风格 </li>\n            </ul>\n          </li>\n          <li>多行注释\n            <ul>\n              <li>多行注释技巧1：/*.... //*/ </li>\n              <li>多行注释技巧2：if语句 </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>变量：\n    <ul>\n      <li>含义：包含名称和值一个标识符\n        <ul>\n          <li>名称和值的关系可以称为“引用” （指向）</li>\n          <li>使用一个变量名其实是指使用该变量所“引用”（指向）的值</li>\n        </ul>\n      </li>\n      <li>形式：变量必须以$开头，后面紧跟变量名 </li>\n      <li>基本操作：\n        <ul>\n          <li>定义变量（赋值）： </li>\n          <li>取值： </li>\n          <li>判断变量是否存在isset() </li>\n          <li>修改变量值（赋值）： </li>\n          <li>删除unset()：就是断开变量名跟数据之间的“引用关系” </li>\n        </ul>\n      </li>\n      <li>变量命名基本规则\n        <ul>\n          <li>以字母或下划线开头</li>\n          <li>后跟任意数量（含０个）的字母，数字和下划线 </li>\n        </ul>\n      </li>\n      <li>命名推荐规则（行业规则）：\n        <ul>\n          <li>骆驼命名法： </li>\n          <li>帕斯卡命名法： </li>\n          <li>下划线间隔法： </li>\n        </ul>\n      </li>\n      <li>变量间传值方式：\n        <ul>\n          <li>赋值传值（值传递）：在php中，变量之间默认都是“值传递”，即将一个变量的“内容”复制一份再赋值给另一个变量。</li>\n          <li>引用传值（引用传递）：可以使用“&amp;”运算符来强制引用传值，语法形式为：$v1 = &amp;$v2;\n            <ul>\n              <li>例：$v1 = 10; $v2 = &amp;$v1;</li>\n              <li>$v2 = 20;</li>\n              <li>则：echo $v1;//结果是20，这就是引用。</li>\n            </ul>\n          </li>\n          <li>注意事项：对象和资源在某些语句中有时会被“误认为”是引用传值，其实不是的。例如：\n            <ul>\n              <li>$obj1 = new c1(); $obj1.age = 10; $obj2 = $obj1; </li>\n              <li>$obj2.age = 20;</li>\n              <li>echo $obj1.age;//结果是20，也改变了：这就好像是引用传值一样。但其实不是，因为变量中存储的并不是对象本身，而是对象的一个“标识符”，该标识符才指向（引用）对象本身。即“new”的时候，创建了一个对象的同时，也生成了一个标识符，该标识符指向了该对象，同时将该标识符赋值给了变量$obj1。赋值的时候，是“复制”了该标识符，然后再赋值给了另一个变量。</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>可变变量： </li>\n      <li>预定义变量（超全局变量/数组）：\n        <ul>\n          <li>综述：\n            <ul>\n              <li>主要有：$_GET, $_POST, $_REQUEST, $_SERVER, $GLOBALS</li>\n              <li>均是数组</li>\n              <li>系统定义与维护</li>\n              <li>具有超全局作用域</li>\n              <li>不同情形下可能具有不同的值</li>\n            </ul>\n          </li>\n          <li>$_GET：get请求（发送数据）的4种形式\n            <ul>\n              <li>&lt;form   method=”get” &gt;</li>\n              <li>&lt;a   href=”abc.php?a=5&amp;b=xyz”&gt;内容&lt;/a&gt; </li>\n              <li>location.href=”abc.php?a=5&amp;b=xyz” ;</li>\n              <li>location.assign(“abc.php?a=5&amp;b=xyz”);</li>\n            </ul>\n          </li>\n          <li>$_POST\n            <ul>\n              <li>基本形式：&lt;form   method=”post” &gt;</li>\n            </ul>\n          </li>\n          <ul>\n            <li>注意特殊的表单项的写法：多选通常要使用数组形式命名 </li>\n            <li>另外，post方式时在action中还可以带参数，且作为get方式 </li>\n              </ul>\n          <li>$_REQUEST\n                <ul>\n                  <li>实际是$_GET和$_POST的合集 </li>\n                  <li>如果两者有重名项，默认是$_POST项覆盖$_GET项 </li>\n                  <li>可以在php.ini配置文件中设定先后顺序，后者覆盖前者：request_order=GP </li>\n                  <li>$_GET, $_POST, $_REQUEST三种数据是相互独立的。 </li>\n                </ul>\n          </li>\n          <li>$_SERVER：保存了服务器或客户端的有关信息。\n            <ul>\n              <li>常用的有：REMOTE_ADDR, DOCUMENT_ROOT,  PHP_SELF </li>\n              <li>输出所有项（可能每台服务器有所差异） </li>\n            </ul>\n          </li>\n          <li>$GLOBALS：保存了用户定义的所有全局变量的数据 </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>常量：\n    <ul>\n      <li>含义： </li>\n      <li>定义形式：\n        <ul>\n          <li>使用define()函数定义\n            <ul>\n              <li>推荐常用名使用全大写形式</li>\n            </ul>\n          </li>\n          <li>使用const语法定义\n            <ul>\n              <li>但const语法只能在“最顶层”的代码域中使用</li>\n              <li>也即，const语法不能在函数中或条件语句中或其他表示一个“范围”的语句中使用</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>使用（取值）：\n        <ul>\n          <li>直接使用名字 </li>\n          <li>或使用constant()函数</li>\n        </ul>\n      </li>\n      <li>常量和变量的区别\n        <ul>\n          <li>定义形式不同： </li>\n          <li>使用形式不同：常量无需$符号 </li>\n          <li>可变程度不同：常量的值不可以改变，常量也不可以销毁 </li>\n          <li>作用范围不同：常量具有超全局作用域 （函数内外都可以直接使用）</li>\n          <li>可用类型不同：常量只能存储标量类型 </li>\n        </ul>\n      </li>\n      <li>判断常量是否存在：defined() </li>\n      <li>使用一个未定义的常量（特殊情况）： </li>\n      <li>预定义常量：\n        <ul>\n          <li>比如M_PI, PHP_OS, PHP_VERSION，PHP_INT_MAX </li>\n          <li>参考手册〉保留字列表〉预定义常量 </li>\n        </ul>\n      </li>\n      <li>魔术常量\n        <ul>\n          <li>比如：__DIR__，__FILE__，__LINE__ </li>\n          <li>魔术常量其实类似变量，其值随着不同代码而变化，不区分大小写</li>\n          <li>参考手册〉语言参考〉常量〉魔术常量 </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>数据类型：\n    <ul>\n      <li>类型总体划分：\n        <ul>\n          <li>标量类型： int， float， string， bool</li>\n          <li>复合类型： array， object</li>\n          <li>特殊类型： null， resouce</li>\n        </ul>\n      </li>\n      <li>整数类型：int， integer\n        <ul>\n          <li>整数的3种进制写法：\n            <ul>\n              <li>十进制写法：123</li>\n              <li>八进制写法： 0123</li>\n              <li>十六进制写法： 0x123</li>\n            </ul>\n          </li>\n          <li>进制转换问题\n            <ul>\n              <li>十进制转二进制decbin()，除2取余倒着写 </li>\n              <li>十进制转八进制decoct()，除8取余倒着写 </li>\n              <li>十进制转十六进制dechex()，除16取余倒着写 </li>\n              <li>二进制转十进制bindec()，每位数值乘以2的权值然后相加 </li>\n              <li>八进制转十进制octdec() ，每位数值乘以8的权值然后相加 </li>\n              <li>十六进制转十进制hexdec() ，每位数值乘以16的权值然后相加 </li>\n              <li>注意：十进制转为其他进制结果是字符串，其他进制转为十进制要求给定数据是字符串形式</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>浮点数类型：float，double\n        ，real\n        <ul>\n          <li>浮点数的2种写法：\n            <ul>\n              <li>小数写法：</li>\n              <li>科学计数法：</li>\n            </ul>\n          </li>\n          <li>关于浮点数的细节知识\n            <ul>\n              <li>浮点数不应进行大小比较</li>\n              <li>小数转二进制的做法：乘2并顺序取整数部分 </li>\n              <li>当整数运算的结果超出整数的范围后，会自动转换为浮点数。</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>字符串类型：string\n        <ul>\n          <li>单引号字符串： </li>\n          <li>双引号字符串： </li>\n          <li>定界符字符串heredoc： </li>\n          <li>定界符字符串nowdoc： </li>\n          <li>字符串中的变量：双引号和heredoc形式中可以识别 </li>\n        </ul>\n      </li>\n      <li>布尔类型：bool， boolean\n        <ul>\n          <li>被当作false的数据 ：null, &quot;&quot;, 0, 0.0, &quot;0&quot;, array(), 未定义</li>\n          <li>其他的都会当作true</li>\n        </ul>\n      </li>\n      <li>数组类型： array\n        <ul>\n          <li>定义： </li>\n          <li>赋值： </li>\n          <li>取值： </li>\n          <li>下标，键，key </li>\n          <li>值，value </li>\n          <li>元素顺序问题 </li>\n        </ul>\n      </li>\n      <li>对象类型： object\n        <ul>\n          <li>定义类： </li>\n          <li>创建对象： </li>\n          <li>对象属性操作：</li>\n          <li>对象方法操作： </li>\n        </ul>\n      </li>\n      <li>资源类型：resource\n        <ul>\n          <li>含义：基本上都是指对外部数据的引用。<br />\n          不是PHP语言通过某种语法形式“创造”的数据，而是外部本来就有该数据（比如数据库，文件，图片），PHP只是通过某种语法（或方式）来对其进行某些操作。 </li>\n        </ul>\n      </li>\n      <li>空类型：null </li>\n      <li>类型转换问题：\n        <ul>\n          <li>自动转换：\n            根据数据所使用的具体环境而可能会发生自动转换，\n            常见的自动转换情形如：\n            <ul>\n              <li>if(数据){}：转为bool类型 </li>\n              <li>算术运算符：转为数字类型 </li>\n              <li>连接运算符：转为字符串类型 </li>\n              <li>比较运算符：转为布尔类型或数字类型 </li>\n            </ul>\n          </li>\n          <li>强制转换：\n            <ul>\n              <li>语法：(目标类型)数据 </li>\n              <li>常见：(int), (float), (string),  (bool) </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>类型相关的系统函数：\n        <ul>\n          <li>var_dump()</li>\n          <li>getType(), setType();</li>\n          <li>isset(), empty(), unset();</li>\n          <li>is_XX类型() 系列函数：</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>运算符\n    <ul>\n      <li>算术运算符：\n        <ul>\n          <li>一般 </li>\n          <li>注意取余运算%，先取整，再取余 </li>\n          <li>自增自减运算符\n            <ul>\n              <li>常规：对数字进行自加1或自减1。 </li>\n              <li>字符串： 只能自增，且自增的效果就是“下一个字符” </li>\n              <li>布尔值递增递减无效 </li>\n              <li>null递减无效，递增结果为1 </li>\n            </ul>\n          </li>\n          <li>前自增和后自增的区别（自减类似）：\n            <ul>\n              <li>前++：先完成变量的递增运算，再取得该变量的值参与别的运算。 </li>\n              <li>后++：先将原来变量的值临时存储，再将变量值递增，最后再将临时存储的值参与别的运算。 </li>\n              <li>推论1：如果独立语句中进行自加运算，前自加后自加没有区别 。</li>\n              <li>推论2：如果前自加后自加是放在别的语句中，则会有所区别。 </li>\n              <li>推论3： 前加加比后加加效率略高（在循环中建议使用前加加）。</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>比较运算符：\n        <ul>\n          <li>一般比较： </li>\n          <li>==和===比较 </li>\n          <li>不要对浮点数直接进行大小比较 </li>\n          <li>常见不同类型的比较\n            <ul>\n              <li>有布尔值，转为布尔值比较 </li>\n              <li>有数字转为数字比较 </li>\n              <li>两边都是纯数字字符串，转为数字比较 </li>\n              <li>否则就按字符串比较 </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>逻辑运算符：\n        <ul>\n          <li>短路现象\n            <ul>\n              <li>逻辑与短路： </li>\n              <li>逻辑或短路： </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>字符串运算符： </li>\n      <li>赋值运算符：\n        <ul>\n          <li>标准赋值 </li>\n          <li>自赋值 </li>\n        </ul>\n      </li>\n      <li>条件（三目）运算符： </li>\n      <li>位运算符：\n        <ul>\n          <li>位运算符基本规则：\n            <ul>\n              <li>&amp; ： 两个都是1，结果才是1（有一个是0，结果就是0）</li>\n              <li>| ： 两个都是0，结果才是0（有一个是1，结果就是1）</li>\n              <li>~ ： 取二进制数字的相反值，即：~1的结果是0，~0的结果是1。</li>\n            </ul>\n          </li>\n          <li>按位与运算（&amp;)： </li>\n          <li>按位或运算（|）： </li>\n          <li>按位非运算（~）： </li>\n          <li>按位左移运算（&lt;&lt;）： </li>\n          <li>按位右移运算（&gt;&gt;）： </li>\n          <li>按位异或运算（^）： </li>\n          <li>补充介绍：原码，反码，补码\n            <ul>\n              <li>原码：一个数字的原始二进制形式，人可理解 </li>\n              <li>反码：正数的反码是其本身（即不变），负数的反码：符号位不变，各位取反</li>\n              <li>补码：正数的补码是其本身（即不变），负数的补码：符号位不变，各位取反后加1（即反码加1）</li>\n              <li>补码还原：正数无需还原，负数：符号位不变，各位取反加1</li>\n              <li>计算机cpu中的运算，只有加法运算，没有减法运算 </li>\n              <li>用补码来表示一个数，就可以将减法转换为加法：15-13相当于15+(-13) </li>\n              <li>举例计算：5+3， 5-3 </li>\n            </ul>\n          </li>\n          <li> 应用：管理一组对象（事物）的开关状态\n            <ul>\n              <li>有些事物（数据）只有2个状态（值），此时可以称为“开关状态”，比如灯的亮灭状态，商品是否推荐状态</li>\n              <li>用二进制原理可以方便轻松管理多个该类事物的状态：</li>\n              <li>每个事物的状态用一个变量值来表示：$S1=1，$S2=2，$S3=4，$S4=8，$S5=16，...</li>\n              <li>则所有灯的总状态变量：$state = &quot;11111&quot;(2进制)就表示他们都是“开”的。$state = &quot;10110&quot;(2进制)就表示第一第四盏灯是关的，其余是开的。</li>\n              <li>判断某盏灯的状态（亮或灭）：如果($state &amp; $Sn)&gt;0，则表示亮，否则表示灭（其中$Sn代表某盏灯，即$S1,$S2,$S3,$S4,$S5之一，下同）。</li>\n              <li>对于任意的初始状态，想要打开某盏灯：$state = $state | $Sn。</li>\n              <li>对于任意的初始状态，想要关闭某盏灯：$state = $state &amp; ~$Sn。</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>数组运算符：+  ==    !=   &lt;&gt;    ===     !== \n        <ul>\n          <li>联合（+）：将右边的数组项合并到左边数组的后面，得到一个新数组。如有重复键，则结果以左边的为准</li>\n          <li>相等（==）： 如果两个数组具有相同的键名和键值（可以顺序不同，或类型不同），则返回true</li>\n          <li>不相等（!=, &lt;&gt;） ：如果两个数组不是相等（==），则返回true</li>\n          <li>全等（===）：如果两个数组具有相同的键名和键值且顺序和类型都一样，则返回true</li>\n          <li>不全等（!==) ： 如果两个数组不是全等（===），则返回true</li>\n        </ul>\n      </li>\n      <li>错误控制运算符@：用于一个表达式的前面，以抑制该表达式可能产生的报错信息。</li>\n      <li>运算符的优先级问题\n        <ul>\n          <li>要意识到运算符有优先级问题</li>\n          <li>括号最优先，赋值最落后（通常）</li>\n          <li>先乘除后加减</li>\n          <li>大致：算术运算符〉比较运算符〉逻辑运算符（除了“非”运算）</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>流程控制：\n    <ul>\n      <li>流程图基本符号：开始结束，语句（块），判断，输入输出，走向 </li>\n      <li>分支结构\n        <ul>\n          <li>if</li>\n          <li>if else</li>\n          <li>if else if（推荐）</li>\n          <li>if elseif</li>\n          <li>if else if else</li>\n          <li>switch\n                  <ul>\n                    <li>break的作用 </li>\n                    <li>不使用break的技巧</li>\n                  </ul>\n          </li>\n        </ul>\n      </li>\n      <li>循环结构：\n        <ul>\n          <li>while</li>\n          <li>do while</li>\n          <li>for</li>\n          <li>foreach（用于数组遍历循环） </li>\n          <li>循环的中断\n            <ul>\n              <li>break</li>\n              <li>continue</li>\n              <li>中断层级 </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>部分流程控制的替换语法：\n        <ul>\n          <li>if ( ... ) :    。。。。  endif; </li>\n          <li>if ( ... ) :   。。。else: 。。。 endif; </li>\n          <li>if ( ... ): 。。。elseif( ... ) : 。。。 elseif( ... ): 。。。 else: 。。。 endif; </li>\n          <li>switch( ... ) : case ... case ... endSwitch;</li>\n          <li>while(...): 。。。endwhile;</li>\n          <li>for(...; ...; ...): :。。。 endfor;</li>\n        </ul>\n      </li>\n      <li>\n        goto语句： \n\t\t<ul>\n          <li>基本形式： goto Flag; ... Flag: .....</li>\n          <li>注意事项： \n            <ul>\n              <li>不能跳入循环中</li>\n              <li>不能跳入函数中</li>\n              <li>不能跳出函数外</li>\n              <li>不能跳出文件外</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>控制脚本执行进度\n        <ul>\n          <li>die() / exit();</li>\n          <li>sleep()</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>文件加载\n    <ul>\n      <li>综述和基本语法：include, require, include_once,  require_once：</li>\n      <li>文件路径问题\n        <ul>\n          <li>相对路径： ./    ../</li>\n          <li>绝对路径： c:/abc/def/ 或：http://www.abc.com</li>\n          <li>无路径设定（只给出文件名，不推荐）\n            <ul>\n              <li>先在include_path设定的目录中找</li>\n              <li>没找到，则在网页文件所在目录下找(当前工作目录）</li>\n              <li>没找到，则在当前include命令所在文件的目录下找</li>\n            </ul>\n          </li>\n          <li>include_path设置，set_include_path(), get_include_path()</li>\n        </ul>\n      </li>\n      <li>文件载入和执行过程：\n        <ul>\n          <li>从include语句处退出php脚本模式（进入html代码模式）</li>\n          <li>载入include语句所设定的文件中的代码，并执行之（如同在当前文件中一样）</li>\n          <li>退出html模式重新进入php脚本模式，继续之后的代码</li>\n        </ul>\n      </li>\n      <li>include_once 和include的区别</li>\n      <li>require 和 include的区别：引用失败（出错）时，include警告并继续，require终止。</li>\n      <li>require 和 require_once的区别</li>\n      <li>在被载入文件中 return 关键字的作用\n        <ul>\n          <li>默认情况下include载入成功返回1，载入失败返回false</li>\n          <li>但被包含的文件中可以使用return语句返回数据值并终止该文件的后续部分的执行</li>\n          <li>return返回的数据如同函数返回值一样可以进一步处理（比如赋值给其他变量）</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>错误处理：\n    <ul>\n      <li>错误的分类：\n        <ul>\n            <li>语法错误：程序没法运行，直接提示语法错误</li>\n          <li>运行时错误：只有程序运行到某行，或在某些特定的情形下运行才会发生的错误。</li>\n          <li>逻辑错误：程序从头到尾运行都没有发生（并提示）错误，但程序运行计算的结果是错误的。</li>\n        </ul>\n      </li>\n      <li>错误分级与代号： 不同的错误会导致不同程度的程序运行反应，这就是错误的分级。\n        错误代号其实只是一个系统内部常量。也就是说，这些错误代号是一个系统预先定义好的数据，然后系统根据发生的不同错误情形，而分配不同的值供程序员使用来判断错误类型。\n        <ul>\n            <li>系统错误：E_ERROR, E_WARNING, E_NOTICE</li>\n          <li>用户错误：E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE</li>\n          <li>所有错误： E_ALL | E_STRICT</li>\n          <li>PHP手册〉函数参考〉影响PHP行为的扩展〉错误处理〉预定义常量</li>\n        </ul>\n      </li>\n      <li>错误的触发：\n        <ul>\n            <li>程序运行时触发。</li>\n          <li>程序中通过触发函数来人为触发3种用户错误\n            <ul>\n                  <li>trigger_error(&quot;错误提示文字&quot;, 错误类型T）</li>\n              <li>错误类型T：E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE之一</li>\n            </ul>\n          </li>\n          <li>其中，系统关键错误(E_ERROR)或用户关键错误(E_USER_ERROR)一旦发生，则程序停止执行。</li>\n        </ul>\n      </li>\n      <li>显示错误报告：\n        <ul>\n            <li>display_errors = On || Off ，或 ini_set(&quot;display_errors&quot;, 0或1);</li>\n          <li>error_reporting = E_ALL，或ini_set('error_reporting', E_ALL);</li>\n        </ul>\n      </li>\n      <li>记录错误日志：\n        <ul>\n            <li>log_errors = On||Off， 或ini_set('log_errors', 1或0);</li>\n          <li>error_log = &quot;错误日志文件名&quot;， 或ini_set('error_log', &quot;错误日志文件名&quot;);</li>\n          <li>error_log = &quot;syslog&quot;则会将错误信息记录到系统日志去。</li>\n        </ul>\n      </li>\n      <li>自定义错误处理器：\n        <ul>\n            <li>设定错误由我们自定义函数来处理：set_error_handler(&quot;函数名&quot;);</li>\n          <li>定义该函数，带4个参数：function errorHandler($errNo, $errMsg, $errFile, $errLine){...}</li>\n          <li>这样，发生错误之后，就会调用该函数来处理该错误</li>\n          <li>但如果发生系统关键错误（E_ERROR），则不会去调用自定义错误处理函数，而是会直接停止运行，并按php.ini的设定显示或记录错误信息。</li>\n          <li>除了系统关键错误，其他错误发生后则不会再去显示或记录错误了，而是按照自定义错误处理函数中的代码执行。</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>函数\n    <ul>\n      <li>基本使用\n        <ul>\n          <li>函数定义形式</li>\n          <li>函数调用形式</li>\n          <li>函数调用流程分析\n            <ul>\n              <li>开始调用：实际参数传数据给形式参数</li>\n              <li>程序执行流程进入到函数中（一个独立的运行空间），跟全局执行空间是隔离的</li>\n              <li>按常规的程序逻辑执行函数中的代码</li>\n              <li>如果碰到return语句，则终止函数的执行，跳回函数开始调用的位置；</li>\n              <li>如果执行到函数的最后位置，也同样跳回函数开始调用的位置</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>函数参数\n        <ul>\n          <li>形式参数，形参，parameter</li>\n          <li>实际参数，实参，arguement</li>\n          <li>参数的默认值\n            <ul>\n                <li>形式：形式参数上给其赋值（就是默认值）</li>\n              <li>要求：\n                <ul>\n                      <li>默认值不能是对象或资源类型；</li>\n                  <li>默认值只能是常量表达式，或常量，不能是变量</li>\n                  <li>默认值参数必须放在非默认值参数的右边</li>\n                  <li>调用函数的时候，对应有默认值的参数可以给值，也可以不给值\n                    <ul>\n                            <li>如果给值，则该对应形式参数使用给定的值</li>\n                      <li>如果不给值，则该对应形式参数使用默认</li>\n                    </ul>\n                  </li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n          <li>参数传值问题\n            <ul>\n              <li>默认情况下，参数传值采用的是“值传递”的方式进行传值。</li>\n              <li>可以在形式参数的前面使用“＆”符号，来达到“引用传递”的传值方式。</li>\n              <li>注意1：如果是引用传值，则实参只能是一个“变量”——也即变量跟变量之间才有引用传值方式问题。</li>\n              <li>注意2：引用传值的形参变量，在函数内部改变该形参变量的值，则对应实参变量的值也就改变。</li>\n            </ul>\n          </li>\n          <li>参数的数量问题\n            <ul>\n              <li>常规：实际参数数量跟形式参数一致；</li>\n              <li>实际参数数量多于形式参数，不报错（很多其他语言是报错的）；</li>\n              <li>实际参数数量少于形式参数，则分为：\n                <ul>\n                  <li>实际参数数量少于形式参数的非默认参数数量，则报错</li>\n                  <li>实际参数数量不少于形式参数的非默认参数数量，则不报错，不够部分，使用默认参数值</li>\n                </ul>\n              </li>\n              <li>不定参数数量的情形：\n                <ul>\n                  <li>类似：var_dump()可以传递不定个数的参数，如何做实现？</li>\n                  <li>定义的时候不定义形式参数</li>\n                  <li>在函数内部，使用func_get_args()获取所有传递过来的实际参数值，结果是一个数组</li>\n                  <li>在函数内部，使用func_get_arg(n)获得第n个参数（n从0开始）</li>\n                  <li>在函数内部，使用func_num_args()获得所有实际参数的个数</li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>函数的返回值\n        <ul>\n          <li>在函数中，使用return语句后面跟一个数据（直接数据或变量数据或常量数据），就可以返回该数据（值）。</li>\n          <li>通常情况下，函数返回的数据都是以“值传递”的形式返回。</li>\n          <li>我们还可以使用强制引用返回(&amp;)的形式来定义一个函数的返回值的返回方式，做法：\n            <ul>\n              <li>定义函数使用&amp;符号：function <strong>&amp;</strong>f1(){....}</li>\n              <li>调用函数使用&amp;符号：$v1 = <strong>&amp;</strong>f1();</li>\n              <li>要求：return语句返回的值必须是变量值（即变量）。</li>\n              <li>举例：函数中的一个静态变量的值，使用引用返回，则外部也可以修改其值。</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>函数的其他形式\n        <ul>\n            <li>可变函数：一个变量名后面带括号，则会被识别为可变函数：找到与该变量的值同名的函数并执行之。</li>\n          <li>匿名函数：没有名字的一个函数，可将其赋值给一个变量，然后该变量后面加括号就可以调用该函数\n            <ul>\n              <li>$f1 = function($p1, $p2) { ........ }</li>\n              <li>call_user_func_array($f1, array(1, 2));</li>\n            </ul>\n          </li>\n          <li>或纯粹是一个没有名字的函数，且直接当作其他函数的参数（即改函数的参数是一个函数）。</li>\n          <ul>\n            <li>call_user_func_array( <strong>function($p1, $p2) { ........ }</strong> , array(1, 2) )</li>\n            <li>这种当作其他函数参数的函数，通常称为“callable”（可调函数），或“callback”（回调函数）。</li>\n          </ul>\n        </ul>\n      </li>\n      <li>变量作用域\n        <ul>\n          <li>局部作用域（局部变量）\n            <ul>\n              <li>静态局部变量：静态变量只能赋值为一个直接的标量值，不能是计算值，或另一个变量值。</li>\n            </ul>\n          </li>\n          <li>全局作用域（全局变量）</li>\n          <li>超全局作用域（超全局变量）</li>\n          <li>局部访问全局变量\n            <ul>\n              <li>使用$GLOBALS超全局数组</li>\n              <li>global关键字：本质是设定一个局部变量来引用某个全局变量，删掉该局部变量，全局变量仍然存在</li>\n              <li>$GLOBALS数组中的元素跟全局变量是一一对应关系。删掉（unset）一个，另一个也就没有了</li>\n              <li>使用$GLOBALS数组的一个新元素，则可以“创造”全局变量，如：$GLOBALS['vvv'] = 1; #假设之前没有$vvv这个全局变量，则这一行之后就有了。</li>\n            </ul>\n          </li>\n          <li>全局访问局部\n            <ul>\n              <li>通过引用传递的方式向形参传递一个引用实参变量</li>\n              <li>使用函数的引用返回形式</li>\n              <li>函数中使用global关键字来首次引用一个全局变量，则函数结束后在全局范围就可以使用该变量了</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>有关函数的系统函数\n        <ul>\n          <li>function_exists()</li>\n          <li>func_get_arg()</li>\n          <li>func_get_args()</li>\n          <li>func_num_args()</li>\n        </ul>\n      </li>\n      <li>函数相关编程思想\n        <ul>\n          <li>递归思想</li>\n          <li>递推思想（迭代思想）</li>\n        </ul>\n      </li>\n      <li>常用内部函数：\n        <ul>\n          <li>字符串函数：\n            <ul>\n              <li>输出与格式化：echo , print, printf, print_r, var_dump.</li>\n              <li>字符串去除与填充：trim, ltrim, rtrim, str_pad</li>\n              <li>字符串连接与分割：implode, join， explode, str_split</li>\n              <li>字符串截取：substr, strchr, strrchr, </li>\n              <li>字符串替换：str_replace, substr_replace</li>\n              <li>字符串长度与位置： strlen, strpos, strrpos, </li>\n              <li>字符转换：strtolower, strtoupper, lcfirst, ucfirst, ucwords</li>\n              <li>特殊字符处理：nl2br, addslashes, htmlspecialchars, htmlspecialchars_decode,</li>\n            </ul>\n          </li>\n          <li>时间函数：\n            <ul>\n              <li>time, microtime, mktime, date, idate, strtotime, date_add, date_diff, date_default_timezone_set, date_default_timezone_get</li>\n            </ul>\n          </li>\n          <li>数学函数：\n            <ul>\n              <li>max, min, round, ceil, floor, abs, sqrt, pow, round, rand</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>数组\n    <ul>\n      <li>数组基础\n        <ul>\n          <li>定义（多种形式）</li>\n          <li>取值</li>\n          <li>赋值（多种形式）</li>\n        </ul>\n      </li>\n      <li>数组分类\n        <ul>\n          <li>从键值关系来分\n            <ul>\n              <li>关联数组</li>\n              <li>索引数组</li>\n            </ul>\n          </li>\n          <li>从数组层次来分\n            <ul>\n              <li>一维数组</li>\n              <li>多维数组</li>\n              <li>混合数组</li>\n              <li>“维”的本质</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>数组遍历\n        <ul>\n          <li>foreach基本语法</li>\n          <li>数组指针操作与遍历原理</li>\n          <li>foreach遍历流程图</li>\n          <li>for+next遍历数组</li>\n          <li>while+each()+list()遍历数组</li>\n          <li>foreach遍历的细节探讨：\n            <ul>\n              <li>foreach也是正常的循环语法结构，可以有break和continue等操作。</li>\n              <li>遍历过程中值变量默认的传值方式是值传递。</li>\n              <li>遍历过程中值变量可以人为设定为引用传递：foreach($arr as $key =&gt; &amp;$value){ ... }</li>\n              <li>foreach默认是原数组上进行遍历。但如果在遍历过程中对数组进行了某种修改或某种指针性操作，则会复制数组后在复制的数组上继续遍历循环。</li>\n              <li>foreach中如果值变量是引用传递，则无论如何都是在原数组上进行。</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>数组函数\n        <ul>\n          <li>指针操作函数： current, key, next, prev, reset, end, each</li>\n          <li>单元操作函数： array_pop，array_push, array_shift, array_unshift, array_slice, array_splice</li>\n          <li>排序函数： sort， asort， ksort， usort, rsort, arsort , krsort , shuffle, </li>\n          <li>查找函数： in_array, array_key_exists, array_search</li>\n          <li>其他函数： count, array_reverse, array_merge, array_sum, array_keys, array_values,array_map, array_walk, range</li>\n        </ul>\n      </li>\n      <li>数组排序算法\n        <ul>\n          <li>冒泡排序</li>\n          <li>选择排序</li>\n          <li>插入排序</li>\n          <li>快速排序</li>\n        </ul>\n      </li>\n      <li>数组查找算法\n        <ul>\n          <li>顺序查找</li>\n          <li>二分查找</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>面向对象编程\n    <ul>\n      <li>面向对象编程思想介绍：\n        <ul>\n            <li>传统的面向过程的编程思想：\n              <ul>\n                  <li>将要实现的功能描述为一个从开始到结束的连续的“步骤（过程）”。</li>\n                <li>依次逐步完成这些步骤。如果步骤较大，又可以将该步骤再次细分为子步骤，以此类推。</li>\n                <li>程序从头开始执行一直到结尾并得到所需结果。</li>\n                <li>例子：完成来传智“报名学习”这件事，可以分为以下几步：\n                  <ul>\n                        <li>学生： 提出要报名，并提供姓名和照片</li>\n                    <li>咨询老师： 接收照片并登记学生姓名</li>\n                    <li>学生：缴费（付款到学校账号）并获得缴费凭证</li>\n                    <li>咨询老师：验证凭证并分配班级</li>\n                    <li>结果：报名完成，学生可以在规定的时间到规定的班级（教室）上课，数据库中就有了该学生的信息。</li>\n                  </ul>\n                </li>\n              </ul>\n            </li>\n          <li>现代的面向对象的编程思想：\n            <ul>\n                  <li>将要实现的功能描述为一个“对象/物体”完成的任务——现实中也是如此：功能的实现都是依赖于一个实体的“行动/操作/动作”。</li>\n              <li>完成该最终功能的过程中需要实现其他中间功能（过程），则再去调用其它对象（或也可能是自己本身）来实现该中间功能。</li>\n              <li>整个系统的完成（功能的实现）看作是一个一个对象在发挥其各自的“能力”并在内部进行协调有序的调用过程。</li>\n              <li>例子：完成来传智“报名学习”这件事，可以这样来处理：\n                <ul>\n                        <li>学生对象：有姓名有照片，有所属班级，能“提出报名”，能“缴费”</li>\n                  <li>咨询老师对象：能接收照片并登记姓名，能分配班级。</li>\n                  <li>班级对象：有班号，有开班日期，有教室。</li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>面向对象基本概念：\n        <ul>\n            <li>类与对象：\n              <ul>\n                  <li>类是描述一类事物的一个总称，是具有相同特征特性的该类事物的一个通用名字（称呼）；</li>\n                <li>比如人就是一个类（人类），狗也是一个类（狗类），它们又属于一个更大的类（哺乳类），桌子，手机，书都是一个类；</li>\n                <li>对象是一个明确的具体的“物体”，是某个类中的一个“实物”（相对来说，类就是一种抽象的泛称）。对象离不开类，或者说，对象一定隶属于某个类——有类才有对象，先有类再有对象。</li>\n                <li>比如“黄晓明”就是“人”这个类的一个具体对象，“阿黄”是“狗”这个类的一个具体对象。</li>\n                <li>一个类决定了一个对象所具有的所有特征特性信息，比如我是人类，则我有：姓名，性别，年龄，我还能吃饭，走路，说话。</li>\n                <li>一个对象的所有特征特性信息，都是由其所属的类决定的，但每个对象又很有可能有自己不同的特征特性信息，比如有个对象的名字叫吴六奇，性别男，会写程序，另一个对象可能叫章子怡，性别女，会演戏。</li>\n                <li>语法上，一个类内部可以具有自己的“变量”和“函数”，但此时在技术术语上就对应地称为“属性”和“方法”。一个类也可以有自己的常量。这些属性，方法和常量就都称为“类”的“成员”。</li>\n              </ul>\n            </li>\n          <li>类的定义：</li>\n          <li>类中属性property：</li>\n          <li>类中方法method：</li>\n          <li>对象的创建：就是由一个类“创建”出一个具体的“物体”——专业说法就是对象。创建对象的语法可以有：\n            <ul>\n              <li>new 类名();</li>\n              <li>new 变量名(); //该变量的内容是一个表示类名的字符串。</li>\n              <li>new 对象名（）;//创建该对象所属类的一个新对象</li>\n              <li>new self; //用于在类的方法内部创建一个该类对象。</li>\n              <li>类名::getNew();//定义类的一个静态方法用于获取该类的一个对象</li>\n            </ul>\n          </li>\n          <li>对象的使用：要么使用其属性，要么使用其方法。使用属性，就可以当作一个变量看待。使用方法，就可以当作一个函数看待。</li>\n          <li>对象的传值：</li>\n        </ul>\n      </li>\n      <li>类中成员member：\n        <ul>\n            <li>一个类中能且只能包含如下3种成员（代码）：变量（称为属性），函数（称为方法），常量（称为类常量）。</li>\n            <li>一般属性：\n              <ul>\n                <li>属性就是定义在类中的变量，需要使用public或var来修饰（定义），也可以使用protected或private来修饰（见后续知识）。</li>\n                <li>定义的时候可以不赋值，也可以赋（初）值，但只能是一个“直接值”（常量值）或常量，不能是变量值或计算值或函数调用返回值等。</li>\n                <li>属性的使用形式：对象名-&gt;属性名；</li>\n                <li>属性是可读可写的（可取值赋值）。</li>\n              </ul>\n            </li>\n          <li>一般方法：\n            <ul>\n                  <li>方法就是定义在类中的函数，但函数前可以使用public，protected, private修饰（见后续知识），也可以省略。</li>\n                  <li>但该方法的调用（使用）不能独立进行，而是需要通过对象来调用。</li>\n              <li>方法中$this关键字具有特定含义：表示调用该方法的对象。</li>\n                  <li>获取$this的所属类：get_class($this)</li>\n            </ul>\n          </li>\n          <li>静态属性：\n            <ul>\n              <li>一个仅仅隶属于（依附于）类的属性，其是通过类名直接来取用的。</li>\n              <li>定义形式：[访问修饰符] static $静态属性名 [ = 初值]；//访问修饰符省略则默认为public，初值也应该是直接值或常量</li>\n              <li>使用形式：类名::$静态属性名；//可取值可赋值；</li>\n            </ul>\n          </li>\n          <li>静态方法：\n            <ul>\n                  <li>一个仅仅隶属于（依附于）类的方法，其是通过类名直接调用的（不过新版php已经可以使用该类的对象名来调用了）</li>\n                  <li>定义形式：[访问修饰符] static function $静态方法名(...){ ...... }</li>\n                  <li>使用形式：类名::静态方法名(...)；其中类名也可以用该类的对象名，一个内容为该类名的字符串变量名，self等来代替。</li>\n                  <li>self关键字：用在方法中，表示该方法所在的类。</li>\n                  <li>static关键字：代替self关键字的位置，除了具有self作用外，还具有更灵活的作用，那就是所谓“后期静态绑定”。</li>\n                  <li>注意1：$this在静态方法中不能使用。</li>\n                  <li>注意2：静态方法中不应调用非静态方法。</li>\n            </ul>\n          </li>\n          <li>类常量：\n            <ul>\n              <li>一个仅仅隶属于（依附于）类的常量，其是通过类名直接来取用的（不过新版php已经可以使用该类的对象名来调用了）</li>\n              <li>定义形式：const 常量名 = 初值；//必须赋初值</li>\n              <li>使用形式：类名::常量名；其中类名也可以用该类的对象名，一个内容为该类名的字符串变量名，self等来代替。</li>\n            </ul>\n          </li>\n          <li>构造方法（函数）：\n            <ul>\n              <li>构造方法是一个类在进行实例化（new一个对象出来）的时候，会首先自动调用的方法。</li>\n              <li>构造方法适用于创建对象时（使用对象前）对该对象做一些初始化工作。</li>\n              <li>定义形式：[访问修饰符] function __construct(...){ ...... }；//访问修饰符通常总是需要public（或省略）。</li>\n              <li>调用形式：实际上，没有直接的调用形式，而是在new一个对象的时候就调用了：new C1(&quot;小花&quot;,18,&quot;女&quot;);</li>\n              <li>如果一个类中定义了构造方法，则实例化该类时就会调用该方法，且实例化时的参数需要跟构造方法的参数匹配。</li>\n              <li>如果一个类中没有定义构造方法，则会自动调用其父类的构造方法（如果有），则实例化时的参数需跟父类的构造方法的参数匹配。</li>\n              <li>也可以在当前类的构造方法中调用父类的构造方法：parent::__construct();</li>\n            </ul>\n          </li>\n          <li>析构方法（函数）：\n            <ul>\n              <li>析构方法是在一个对象被销毁的时候会自动调用（执行）的方法；对象销毁的几种情况：\n                <ul>\n                  <li>脚本程序运行结束，自动销毁；</li>\n                  <li>明确地unset()一个对象变量，则被销毁；</li>\n                  <li>改变对象变量的值，被销毁；</li>\n                </ul>\n              </li>\n              <li>析构方法适用于销毁对象时对对象中使用的一些资源进行清理（销毁）——不过实际上现代PHP已经内具了垃圾回收机制，一般无需清理。。</li>\n              <li>定义形式：function __destruct(){ ...... }；//注意：只能是public的，且不能有参数</li>\n              <li>调用形式：无需在代码中手工调用，而是在代码运行结束时自动被调用（执行）。</li>\n              <li>如果一个类中定义了析构方法，则销毁对象时就会调用该方法。</li>\n              <li>如果一个类中没有定义析构方法，则销毁对象时就会调用其父类的析构方法（如果有）</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>类的继承：\n        <ul>\n            <li>基本含义：类是用来描述现实世界中同一种事物的共有特性的抽象模型。但现实世界中，不同种类的事物之间有往往有一些上下级或大小范围的关系。比如，动物是一个“类”，具有某些特性。但脊椎动物也是一个类，也具有一些特性，且同时具有动物类的所有特性。哺乳动物还是一个类，具有一些特性，并同时具有脊椎动物的所有特性。如此等等，则面向对象编程中，我们定义的类也同样可以具有类似的关系特征，这就是类的继承。</li>\n            <li>基本语法：extends</li>\n            <li>基本概念：\n              <ul>\n                <li>继承：一个类从另一个已有的类获得其特性，称为继承。</li>\n                <li>派生：从一个已有的类产生一个新的类，称为派生。</li>\n                <li>父类/子类：已有类为父类，新建类为子类。</li>\n                <li>单继承：一个类只能从一个上级类继承其特性信息。PHP和大多数面向对象的语言都是单继承模式。C++是多继承。</li>\n                <li>扩展：在子类中再来定义自己的一些新的特有的特性信息（属性，方法和常量）。没有扩展，继承也就没有意义了。</li>\n              </ul>\n            </li>\n          <li>访问控制修饰符：\n            <ul>\n                  <li>public公共的：在所有位置都可访问（使用）。</li>\n              <li>protected受保护的：只能再该类内部和该类的子类或父类中访问（使用）。</li>\n              <li>private私有的：只能在该类内部访问（使用）。</li>\n            </ul>\n          </li>\n          <li>parent关键字：在类的内部用来表示（代表）该类的父类。可以用来访问父类的属性或方法或常量。</li>\n          <li>构造和析构方法中的调用上级同样方法的问题：\n            <ul>\n              <li>子类中没有定义构造方法时，会自动调用父类的构造方法。因此实例化子类时，需按照父类的构造方法的形式进行。</li>\n              <li>子类定义了自己的构造方法，则不会自动调用父类的构造方法，但可以手动调用：parent::__construct();</li>\n              <li>子类中没有定义析构方法时，会自动调用父类的析构方法。</li>\n              <li>子类定义了自己的析构方法，则不会自动调用父类的析构方法，但可以手动调用：parent::__destruct()</li>\n            </ul>\n          </li>\n          <li>重写override\n            <ul>\n                  <li>什么是重写？重写又叫“覆盖”，就是将从父类继承下来的属性或方法重新定义。只有保护的或公有的属性或方法能够被覆盖。</li>\n              <li>为什么要重写？因为父类的某个属性可能对于子类来说不够具体或详细，子类想要同样特性或功能的更准确或详细信息。</li>\n              <li>重写的基本要求：访问控制权限，方法的参数形式。</li>\n              <li>私有属性和私有方法的重写问题：私有属性和方法都不能覆盖，但其实子类可以定义跟父类私有的同名属性或方法。只是当作一个自身的新的属性或方法来看待而已。不过方法的参数必须一致。</li>\n              <li>构造方法的重写问题：构造方法不但可以像其他普通方法一样重写，而且，比普通方法更宽松：重写的时候参数可以不一致。</li>\n            </ul>\n          </li>\n          <li>最终类final class：</li>\n          <li>最终方法final method：</li>\n        </ul>\n      </li>\n      <li>设计模式：\n        <ul>\n            <li>工厂模式：一种专门用于“生产”其他各种类的对象的一个类</li>\n          <li>单例模式：一种只能从中实例化出来一个对象的类</li>\n        </ul>\n      </li>\n      <li>类的“扩大化”技术：\n        <ul>\n            <li>抽象类，抽象方法：\n              <ul>\n                <li>一个类可以使用关键字abstract声明为抽象类；抽象类是不能实例化的类，只用作其他类的父类。</li>\n                <li>一个方法可以使用关键字abstract声明为抽象方法；抽象方法只需要声明方法头，不需要大括号部分的方法体。</li>\n                <li>一个类中有抽象方法，则该类必须声明为抽象类。</li>\n                <li>子类继承自一个抽象类，则子类必须实现父类中的所有抽象方法，除非子类也继续作为抽象类。</li>\n                <li>子类实现抽象父类的方法时，访问控制修饰符的范围不能降低，且方法的参数也须一致。</li>\n              </ul>\n            </li>\n          <li>重载技术overloading：\n            <ul>\n                  <li>属性重载：__set(), __get(), __isset(), __unset()</li>\n              <li>方法重载：__call(), __callstatic();</li>\n            </ul>\n          </li>\n          <li>接口interface：\n            <ul>\n                  <li>什么是接口？</li>\n              <li>为什么需要接口？</li>\n              <li>接口的定义形式：</li>\n              <li>接口的实现：使用接口被称为接口的“实现”（implements)，其实就是类似“继承”</li>\n              <li>接口的多实现：</li>\n              <li>接口常量：</li>\n              <li>接口继承：</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>有关类或对象的其他相关技术：\n        <ul>\n            <li>类的自动加载：__autoload(), spl_autoload_register();</li>\n          <li>对象的复制（克隆）：</li>\n          <li>对象的遍历：</li>\n          <li>PHP内置标准类：</li>\n          <li>对象的类型转换：\n            将得到一个标准类stdClass的对象\n            <ul>\n              <li>对象转换为对象：没有变化；</li>\n              <li>数组转换为对象：数组的键名当作属性名，值为对应值；</li>\n              <li>null转换为对象：空对象；</li>\n              <li>其他标量数据转换为对象：属性名为固定的“scalar”，值为该变量的值</li>\n            </ul>\n          </li>\n          <li>类型约束：可以对函数（方法）的参数设定必须使用的类型。只能对对象，接口，数组进行约束。</li>\n          <li>与类有关的魔术常量：__CLASS__, __METHOD__</li>\n          <li>与类有关的其他魔术方法：\n            <ul>\n                  <li>已学过的魔术方法：__construct, __destruct, __set(), __get(), __isset(), __unset(), __call(), __callstatic()</li>\n              <li>__sleep()和__wakeup(): 序列化操作的时候，会先调用__sleep()方法，反序列化操作的时候会先调用__wakeup()方法。</li>\n              <li>__tostring():将对象当作字符串来使用的时候，会自动调用该方法，以此来作为对象转换为字符串的结果数据。</li>\n              <li>__invoke():将对象当作函数来使用的时候，会自动调用该方法。</li>\n            </ul>\n          </li>\n          <li>与类有关的系统函数：class_exists(), interface_exists(), get_class(),get_parent_class(), get_class_methods(), get_class_vars(),  get_declared_classes()</li>\n          <li>与对象有关的系统函数：is_object()，get_object_vars()</li>\n          <li>与类有关的运算符：new，instanceof</li>\n          <li>面向对象编程思想的3个特征：封装，继承，多态。</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li></li>\n</ul>\n</body>\n</html>\n"
        },
        {
          "name": "redis3.0.2-分布式集群安装详细步骤.pdf",
          "type": "blob",
          "size": 319.5986328125,
          "content": null
        },
        {
          "name": "redis主从同步介绍.pptx",
          "type": "blob",
          "size": 756.1416015625,
          "content": null
        },
        {
          "name": "redis快速入门详解.ppt",
          "type": "blob",
          "size": 1183.5,
          "content": null
        },
        {
          "name": "xunzai.com_设计模式.pdf",
          "type": "blob",
          "size": 2173.0263671875,
          "content": null
        },
        {
          "name": "《PHP精粹 编写高效PHP代码》.(Lorna Mitchell).[PDF].&ckook.pdf",
          "type": "blob",
          "size": 29126.61328125,
          "content": ""
        },
        {
          "name": "《PHP设计模式》.((美)Aaron Saray).[PDF].&ckook(jb51.net).pdf",
          "type": "blob",
          "size": 27683.1708984375,
          "content": ""
        },
        {
          "name": "《图解TCP IP(第5版)》.((日)竹下隆史).[PDF].&ckook.pdf",
          "type": "blob",
          "size": 32947.958984375,
          "content": ""
        },
        {
          "name": "【1】深入理解计算机系统(中文版).pdf",
          "type": "blob",
          "size": 20380.7705078125,
          "content": ""
        },
        {
          "name": "【2】现代操作系统（第三版）中文版.pdf",
          "type": "blob",
          "size": 86532.478515625,
          "content": ""
        },
        {
          "name": "【3】数据结构与算法分析：C语言描述_原书第2版_高清版.pdf",
          "type": "blob",
          "size": 39839.1845703125,
          "content": ""
        },
        {
          "name": "【4】UNIX环境高级编程（第三版）.pdf",
          "type": "blob",
          "size": 5392.5673828125,
          "content": ""
        },
        {
          "name": "【51】TCP IP详解 卷1：协议.pdf",
          "type": "blob",
          "size": 4243.16015625,
          "content": null
        },
        {
          "name": "【52】TCP IP详解 卷2：实现.pdf",
          "type": "blob",
          "size": 19752.6279296875,
          "content": ""
        },
        {
          "name": "【53】TCP IP详解 卷3：TCP事务协议，HTTP，NNTP和UNIX域协议.pdf",
          "type": "blob",
          "size": 4271.375,
          "content": null
        },
        {
          "name": "大话数据结构.pdf",
          "type": "blob",
          "size": 52414.4033203125,
          "content": ""
        },
        {
          "name": "大话设计模式(带目录完整版).pdf",
          "type": "blob",
          "size": 71223.564453125,
          "content": ""
        },
        {
          "name": "大话重构.pdf",
          "type": "blob",
          "size": 91912.0244140625,
          "content": ""
        },
        {
          "name": "循序渐进Linux(第2版)服务器搭建系统.pdf",
          "type": "blob",
          "size": 49211.4765625,
          "content": ""
        },
        {
          "name": "携程技术2017年度合辑.pdf",
          "type": "blob",
          "size": 12684.5380859375,
          "content": ""
        },
        {
          "name": "数据库规范.txt",
          "type": "blob",
          "size": 16.322265625,
          "content": "一、 表设计\n\n1.库名、表名、字段名必须使用小写字母，“_”分割。【FAQ】\n2.库名、表名、字段名必须不超过12个字符。【FAQ】\n3.库名、表名、字段名见名知意,建议使用名词而不是动词。【FAQ】\n4.建议使用InnoDB存储引擎。【FAQ】\n5.存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE。【FAQ】\n6.建议使用UNSIGNED存储非负数值。【FAQ】\n7.建议使用INT UNSIGNED存储IPV4。【FAQ】\n8.整形定义中不添加长度，比如使用INT，而不是INT(4)。【FAQ】\n9.使用短数据类型，比如取值范围为0-80时，使用TINYINT UNSIGNED。\n10.不建议使用ENUM类型，使用TINYINT来代替。【FAQ】\n11.尽可能不使用TEXT、BLOB类型。【FAQ】\n12.VARCHAR(N)，N表示的是字符数不是字节数，比如VARCHAR(255)，可以最大可存储255个汉字，需要根据实际的宽度来选择N。\n13.VARCHAR(N)，N尽可能小，因为MySQL一个表中所有的VARCHAR字段最大长度是65535个字节，进行排序和创建临时表一类的内存操作时，会使用N的长度申请内存。【FAQ】\n14.表字符集选择UTF8。【FAQ】\n15.使用VARBINARY存储变长字符串。\n16.存储年使用YEAR类型。\n17.存储日期使用DATE类型。\n18.存储时间（精确到秒）建议使用TIMESTAMP类型，因为TIMESTAMP使用4字节，DATETIME使用8个字节。【FAQ】\n19.建议字段定义为NOT NULL。【FAQ】\n20.将过大字段拆分到其他表中。\n21.禁止在数据库中使用VARBINARY、BLOB存储图片、文件等。\n22.表结构变更需要通知DBA审核。\n二、 索引【FAQ】\n\n1.非唯一索引必须按照“idx_字段名称_字段名称[_字段名]”进行命名。\n2.唯一索引必须按照“uniq_字段名称_字段名称[_字段名]”进行命名。\n3.索引名称必须使用小写。\n4.索引中的字段数建议不超过5个。\n5.单张表的索引数量控制在5个以内。【FAQ】\n6.唯一键由3个以下字段组成，并且字段都是整形时，使用唯一键作为主键。\n7.没有唯一键或者唯一键不符合5中的条件时，使用自增（或者通过发号器获取）id作为主键。\n8.唯一键不和主键重复。\n9.索引字段的顺序需要考虑字段值去重之后的个数，个数多的放在前面。\n10.ORDER BY，GROUP BY，DISTINCT的字段需要添加在索引的后面。\n11.使用EXPLAIN判断SQL语句是否合理使用索引，尽量避免extra列出现：Using File Sort，Using Temporary。【FAQ】\n12.UPDATE、DELETE语句需要根据WHERE条件添加索引。\n13.不建议使用%前缀模糊查询，例如LIKE “%weibo”。\n14.对长度过长的VARCHAR字段建立索引时，添加crc32或者MD5 Hash字段，对Hash字段建立索引。【FAQ】\n15.合理创建联合索引（避免冗余），(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)。\n16.合理利用覆盖索引。【FAQ】\n17.SQL变更需要确认索引是否需要变更并通知DBA。\n三、 SQL语句\n\n1.使用prepared statement，可以提供性能并且避免SQL注入。\n2.SQL语句中IN包含的值不应过多。\n3.UPDATE、DELETE语句不使用LIMIT。\n4.WHERE条件中必须使用合适的类型，避免MySQL进行隐式类型转化。【FAQ】\n5.SELECT语句只获取需要的字段。\n6.SELECT、INSERT语句必须显式的指明字段名称，不使用SELECT *，不使用INSERT INTO table()。【FAQ】\n7.使用SELECT column_name1, column_name2 FROM table WHERE [condition]而不是SELECT column_name1 FROM table WHERE [condition]和SELECT column_name2 FROM table WHERE [condition]。\n8.WHERE条件中的非等值条件（IN、BETWEEN、<、<=、>、>=）会导致后面的条件使用不了索引。\n9.避免在SQL语句进行数学运算或者函数运算，容易将业务逻辑和DB耦合在一起。\n10.INSERT语句使用batch提交（INSERT INTO table VALUES(),(),()……），values的个数不应过多。\n11.避免使用存储过程、触发器、函数等，容易将业务逻辑和DB耦合在一起，并且MySQL的存储过程、触发器、函数中存在一定的bug。\n12.避免使用JOIN。\n13.使用合理的SQL语句减少与数据库的交互次数。【FAQ】\n14.不使用ORDER BY RAND()，使用其他方法替换。【FAQ】\n15.建议使用合理的分页方式以提高分页的效率。【FAQ】\n16.统计表中记录数时使用COUNT(*)，而不是COUNT(primary_key)和COUNT(1)。\n17.禁止在从库上执行后台管理和统计类型功能的QUERY。【FAQ】\n四、 散表\n\n1.每张表数据量建议控制在5000w以下。\n2.可以结合使用hash、range、lookup table进行散表。\n3.散表如果使用md5（或者类似的hash算法）进行散表，表名后缀使用16进制，比如user_ff。\n4.推荐使用CRC32求余（或者类似的算术算法）进行散表，表名后缀使用数字，数字必须从0开始并等宽，比如散100张表，后缀从00-99。\n5.使用时间散表，表名后缀必须使用特定格式，比如按日散表user_20110209、按月散表user_201102。\n五、 其他\n\n1.批量导入、导出数据需要DBA进行审查，并在执行过程中观察服务。\n2.批量更新数据，如update,delete 操作，需要DBA进行审查，并在执行过程中观察服务。\n3.产品出现非数据库平台运维导致的问题和故障时，如前端被抓站，请及时通知DBA，便于维护服务稳定。\n4.业务部门程序出现bug等影响数据库服务的问题,请及时通知DBA，便于维护服务稳定。\n5.业务部门推广活动，请提前通知DBA进行服务和访问评估。\n6.如果出现业务部门人为误操作导致数据丢失，需要恢复数据，请在第一时间通知DBA，并提供准确时间，误操作语句等重要线索。\n \n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nFAQ\n\n1-1.库名、表名、字段名必须使用小写字母，“_”分割。\n\n\na) MySQL有配置参数lower_case_table_names，不可动态更改，linux系统默认为0，即库表名以实际情况存储，大小写敏感。如果是1，以小写存储，大小写不敏感。如果是2，以实际情况存储，但以小写比较。\n\nb) 如果大小写混合用，可能存在abc,Abc,ABC等多个表共存，容易导致混乱。\n\nc) 字段名显示区分大小写，但实际使用不区分，即不可以建立两个名字一样但大小写不一样的字段。\n\nd) 为了统一规范， 库名、表名、字段名使用小写字母。\n\nback\n\n1-2.库名、表名、字段名必须不超过12个字符。\n\n库名、表名、字段名支持最多64个字符，但为了统一规范、易于辨识以及减少传输量，必须不超过12字符。\n\nback\n\n1-3.库名、表名、字段名见名知意,建议使用名词而不是动词。\n\na) 用户评论可用表名usercomment或者comment。\n\nb) 库表是一种客观存在的事物，一种对象，所以建议使用名词。\n\nback\n\n1-4.建议使用InnoDB存储引擎。\n\na) 5.5以后的默认引擘，支持事务，行级锁，更好的恢复性，高并发下性能更好，对多核，大内存，ssd等硬件支持更好。\n\nb) 具体比较可见附件的官方白皮书。\n\nback\n\n1-5.存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE。\n\na) mysql中的数值类型（不包括整型）：\n    IEEE754浮点数： float  （单精度） ， double  或 real  （双精度）\n    定点数： decimal 或 numeric\n    单精度浮点数的有效数字二进制是24位，按十进制来说，是8位；双精度浮点数的有效数字二进制是53位，按十进制来说，是16 位\n    一个实数的有效数字超过8位，用单精度浮点数来表示的话，就会产生误差！同样，如果一个实数的有效数字超过16位，用双精度浮点数来表示，也会产生误差\nb) IEEE754标准的计算机浮点数，在内部是用二进制表示的，但在将一个十进制数转换为二进制浮点数时，也会造成误差，原因是不是所有的数都能转换成有限长度的二进制数。\n    即一个二进制可以准确转换成十进制，但一个带小数的十进制不一定能够准确地用二进制来表示。\n\n实例：\ndrop table if exists t;\n\ncreate table t(value float(10,2));\n\ninsert into t values(131072.67),(131072.68);\n\nselect  value  from t;\n\n+-----------+\n\n| value     |\n\n+-----------+\n\n| 131072.67 |\n\n| 131072.69 |\n\n+-----------+\n\nback\n\n1-6.建议使用UNSIGNED存储非负数值。\n\n同样的字节数，存储的数值范围更大。如tinyint 有符号为 -128-127，无符号为0-255\n\nback\n\n1-7. 如何使用INT UNSIGNED存储ip？\n\n使用INT UNSIGNED而不是char(15)来存储ipv4地址，通过MySQL函数inet_ntoa和inet_aton来进行转化。Ipv6地址目前没有转化函数，需要使用DECIMAL或者两个bigINT来存储。例如：\n\nSELECT INET_ATON('209.207.224.40');\n\n3520061480\n\nSELECT INET_NTOA(3520061480);\n\n209.207.224.40\n\nback\n\n1-8. INT[M]，M值代表什么含义？\n\n注意数值类型括号后面的数字只是表示宽度而跟存储范围没有关系，比如INT(3)默认显示3位，空格补齐，超出时正常显示，python、java客户端等不具备这个功能。\n\nback\n\n1-10.不建议使用ENUM、SET类型，使用TINYINT来代替。\n\na) ENUM，有三个问题：添加新的值要做DDL，默认值问题(将一个非法值插入ENUM(也就是说，允许的值列之外的字符串)，将插入空字符串以作为特殊错误值)，索引值问题（插入数字实际是插入索引对应的值）\n\n实例：\n\ndrop table if exists t;\n\ncreate table t(sex enum('0','1'));\n\ninsert into t values(1);\n\ninsert into t values('3');\n\nselect * from t;\n\n+------+\n\n| sex  |\n\n+------+\n\n| 0    |\n\n|      |\n\n+------+\n\n2 rows in set (0.00 sec)\n\nback\n\n1-11.尽可能不使用TEXT、BLOB类型。\n\na) 索引排序问题，只能使用max_sort_length的长度或者手工指定ORDER BY SUBSTRING(column, length)的长度来排序\n\nb) Memory引擘不支持text,blog类型，会在磁盘上生成临时表\n\nc) 可能浪费更多的空间\n\nd) 可能无法使用adaptive hash index\n\ne) 导致使用where没有索引的语句变慢\n\nback\n\n1-13. VARCHAR中会产生额外存储吗？\n\nVARCHAR(M)，如果M<256时会使用一个字节来存储长度，如果M>=256则使用两个字节来存储长度。\n\nback\n\n1-14.表字符集选择UTF8。\n\na) 使用utf8字符集，如果是汉字，占3个字节，但ASCII码字符还是1个字节。\nb) 统一，不会有转换产生乱码风险\nc) 其他地区的用户（美国、印度、台湾）无需安装简体中文支持，就能正常看您的文字，并且不会出现乱码\nd) ISO-8859-1编码(latin1)使用了单字节内的所有空间，在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃。即把其他任何编码的字节流当作ISO-8859-1编码看待都没有问题，保存的是原封不动的字节流。\n\nback\n\n1-15.使用VARBINARY存储变长字符串。\n\n二进制字节流，不存在编码问题\n\nback\n\n1-18. 为什么建议使用TIMESTAMP来存储时间而不是DATETIME？\n\nDATETIME和TIMESTAMP都是精确到秒，优先选择TIMESTAMP，因为TIMESTAMP只有4个字节，而DATETIME8个字节。同时TIMESTAMP具有自动赋值以及自动更新的特性。\n\n如何使用TIMESTAMP的自动赋值属性？\n\na)  将当前时间作为ts的默认值：ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP。\n\nb)  当行更新时，更新ts的值：ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP。\n\nc)  可以将1和2结合起来：ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP。\n\nback\n\n1-19.建议字段定义为NOT NULL。\n\na）如果null字段被索引，需要额外的1字节\n\nb）使索引，索引统计，值的比较变得更复杂\n\nc）可用0，''代替\n\nd）如果是索引字段，一定要定义为not null\n\nback\n\n1-21.禁止在数据库中使用VARBINARY、BLOB存储图片、文件等。\n\n采用分布式文件系统更高效\n\nback\n\n2. 为什么MySQL的性能依赖于索引？\n\nMySQL的查询速度依赖良好的索引设计，因此索引对于高性能至关重要。合理的索引会加快查询速度（包括UPDATE和DELETE的速度，MySQL会将包含该行的page加载到内存中，然后进行UPDATE或者DELETE操作），不合理的索引会降低速度。\n\nMySQL索引查找类似于新华字典的拼音和部首查找，当拼音和部首索引不存在时，只能通过一页一页的翻页来查找。当MySQL查询不能使用索引时，MySQL会进行全表扫描，会消耗大量的IO。\n\nback\n\n2-5. 为什么一张表中不能存在过多的索引？\n\nInnoDB的secondary index使用b+tree来存储，因此在UPDATE、DELETE、INSERT的时候需要对b+tree进行调整，过多的索引会减慢更新的速度。\n\n back\n\n2-11. EXPLAIN语句\n\nEXPLAIN 语句（在MySQL客户端中执行）可以获得MySQL如何执行SELECT语句的信息。通过对SELECT语句执行EXPLAIN，可以知晓MySQL执 行该SELECT语句时是否使用了索引、全表扫描、临时表、排序等信息。尽量避免MySQL进行全表扫描、使用临时表、排序等。详见官方文档。\n\n back\n\n2-13.不建议使用%前缀模糊查询，例如LIKE “%weibo”。\n\n会导致全表扫描\n\n2-14. 如何对长度大于50的VARCHAR字段建立索引？\n\n下面的表增加一列url_crc32，然后对url_crc32建立索引，减少索引字段的长度，提高效率。\n\n•CREATE TABLE url(\n        ……\n\n        url VARCHAR(255) NOT NULL DEFAULT 0,\n        url_crc32 INT UNSIGNED NOT NULL DEFAULT 0,\n\n        ……\n\n        index idx_url(url_crc32)\n\n    )\n\nback\n\n2-16. 什么是覆盖索引？\n\nInnoDB 存储引擎中，secondary index（非主键索引）中没有直接存储行地址，存储主键值。如果用户需要查询secondary index中所不包含的数据列时，需要先通过secondary index查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次。\n\n覆盖索引的概念就是查询可以通过在一个索引中完成，覆盖索引效率会比较高，主键查询是天然的覆盖索引。\n\n合理的创建索引以及合理的使用查询语句，当使用到覆盖索引时可以获得性能提升。\n\n比如SELECT email,uid FROM user_email WHERE uid=xx，如果uid不是主键，适当时候可以将索引添加为index(uid,email)，以获得性能提升。\n\n back\n\n3-3.UPDATE、DELETE语句不使用LIMIT。\n\na) 可能导致主从数据不一致\n\nb) 会记录到错误日志，导致日志占用大量空间\n\n3-4. 为什么需要避免MySQL进行隐式类型转化？\n\n因为MySQL进行隐式类型转化之后，可能会将索引字段类型转化成=号右边值的类型，导致使用不到索引，原因和避免在索引字段中使用函数是类似的。\n\n back\n\n3-6. 为什么不建议使用SELECT *?\n\n增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前段也需要更新。\n\nback\n\n3-13. 如何减少与数据库的交互次数？\n\n使用下面的语句来减少和db的交互次数：\n\nINSERT ... ON DUPLICATE KEY UPDATE\n\nREPLACE\n\nINSERT IGNORE\n\nINSERT INTO values(),()如何结合使用多个纬度进行散表散库？\n\n例如微博message，先按照crc32(message_id)%16将message散到16个库中，然后针对每个库中的表，一天生成一张新表。\n\nback\n\n3-14. 为什么不能使用ORDER BY rand()？\n\n因为ORDER BY rand()会将数据从磁盘中读取，进行排序，会消耗大量的IO和CPU，可以在程序中获取一个rand值，然后通过在从数据库中获取对应的值。\n\nback\n\n3-15. MySQL中如何进行分页？\n\n假如有类似下面分页语句：\n\nSELECT * FROM table ORDER BY TIME DESC LIMIT 10000,10;\n\n这种分页方式会导致大量的io，因为MySQL使用的是提前读取策略。\n\n推荐分页方式：\n\nSELECT * FROM table WHERE TIME<last_TIME ORDER BY TIME DESC LIMIT 10.\n\nSELECT * FROM table inner JOIN(SELECT id FROM table ORDER BY TIME LIMIT 10000,10) as t USING(id)\n\nback\n\n 3-17.为什么避免使用复杂的SQL？\n\n拒绝使用复杂的SQL，将大的SQL拆分成多条简单SQL分步执行。原因：简单的SQL容易使用到MySQL的query cache；减少锁表时间特别是MyISAM；可以使用多核cpu。\n\nback\n\n \n\n2. InnoDB存储引擎为什么避免使用COUNT(*)?\n\nInnoDB表避免使用COUNT(*)操作，计数统计实时要求较强可以使用memcache或者redis，非实时统计可以使用单独统计表，定时更新。\n"
        },
        {
          "name": "数据结构基础(C语言版)（第2版）.pdf",
          "type": "blob",
          "size": 36251.4072265625,
          "content": ""
        },
        {
          "name": "正则表达式应用.txt",
          "type": "blob",
          "size": 3.291015625,
          "content": "正则表达式应用——实例应用\n1.验证用户名和密码：（\"^[a-zA-Z]\\w{5,15}$\"）正确格式：\"(?!^\\\\d+$)(?!^[a-zA-Z]+$)(?!^[_#@]+$).{8,}\"组成,并且第一个字必须为字母6~16位；\n2.验证电话号码：（\"^(\\d{3,4}-)\\d{7,8}$\"）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx；\n3.验证手机号码：\"^1[3|4|5|7|8][0-9]\\\\d{8}$\"；\n4.验证身份证号（15位或18位数字）：\"\\d{14}[[0-9],0-9xX]\"；\n5.验证Email地址：(\"^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\")；\n6.只能输入由数字和26个英文字母组成的字符串：(\"^[A-Za-z0-9]+$\")；\n7.整数或者小数：^[0-9]+([.][0-9]+){0,1}$\n8.只能输入数字：\"^[0-9]*$\"。\n9.只能输入n位的数字：\"^\\d{n}$\"。\n10.只能输入至少n位的数字：\"^\\d{n,}$\"。\n11.只能输入m~n位的数字：\"^\\d{m,n}$\"。\n12.只能输入零和非零开头的数字：\"^(0|[1-9][0-9]*)$\"。\n13.只能输入有两位小数的正实数：\"^[0-9]+(\\.[0-9]{2})?$\"。\n14.只能输入有1~3位小数的正实数：\"^[0-9]+(\\.[0-9]{1,3})?$\"。\n15.只能输入非零的正整数：\"^\\+?[1-9][0-9]*$\"。\n16.只能输入非零的负整数：\"^\\-[1-9][0-9]*$\"。\n17.只能输入长度为3的字符：\"^.{3}$\"。\n18.只能输入由26个英文字母组成的字符串：\"^[A-Za-z]+$\"。\n19.只能输入由26个大写英文字母组成的字符串：\"^[A-Z]+$\"。\n20.只能输入由26个小写英文字母组成的字符串：\"^[a-z]+$\"。\n21.验证是否含有^%&',;=?$\\\"等字符：\"[%&',;=?$\\\\^]+\"。\n22.只能输入汉字：\"^[\\u4e00-\\u9fa5]{0,}$\"。\n23.验证URL：\"^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\"。\n24.验证一年的12个月：\"^(0?[1-9]|1[0-2])$\"正确格式为：\"01\"～\"09\"和\"10\"～\"12\"。\n25.验证一个月的31天：\"^((0?[1-9])|((1|2)[0-9])|30|31)$\"正确格式为；\"01\"～\"09\"、\"10\"～\"29\"和“30”~“31”。\n26.获取日期正则表达式：\\\\d{4}[年|\\-|\\.]\\d{\\1-\\12}[月|\\-|\\.]\\d{\\1-\\31}日?\n评注：可用来匹配大多数年月日信息。\n27.匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]\n评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）\n28.匹配空白行的正则表达式：\\n\\s*\\r\n评注：可以用来删除空白行\n29.匹配HTML标记的正则表达式：<(\\S*?)[^>]*>.*?</>|<.*? />\n评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力\n30.匹配首尾空白字符的正则表达式：^\\s*|\\s*$\n评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式\n31.匹配网址URL的正则表达式：[a-zA-z]+://[^\\s]*\n评注：网上流传的版本功能很有限，上面这个基本可以满足需求\n32.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n评注：表单验证时很实用\n33.匹配腾讯QQ号：[1-9][0-9]{4,}\n评注：腾讯QQ号从10 000 开始\n34.匹配中国邮政编码：[1-9]\\\\d{5}(?!\\d)\n评注：中国邮政编码为6位数字\n35.匹配ip地址：([1-9]{1,3}\\.){3}[1-9]。\n评注：提取ip地址时有用\n36.匹配MAC地址：([A-Fa-f0-9]{2}\\:){5}[A-Fa-f0-9]\nFunction IsRegu(Regu,s)\n'正则表达式校验\nIf Regu=\"\" Then\nExit Function\nEnd if\nDim Re,Sre\nSet Re = New RegExp\nRe.Pattern = Regu\nSre = Re.Test(s)\nIf Sre = True Then\nIsRegu = True\nElse\nIsRegu = False\nEnd If\nEnd Function\ntmp=\" \"\nif (IsRegu(\"\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\",tmp )) =false then\nmsgbox \"E-mail地址不合法 ！\"\nFieldCheck#N=false\n不同的语言（如PHP和JAVA）、相同语言的不同类库（如来自Sun的Java Regular Expression类库跟Apache Jakarta的正则表达式类库）间，用法会有所差别，在使用的时候，要注意这些差别。\n验证URL\nfunctionIsValidUrl(str){\nvarregu=\"^(https?://)\"\n+\"?(([0-9a-z_!~*'().&=+$%-]+:)?[0-9a-z_!~*'().&=+$%-]+@)?\"\n+\"(([0-9]{1,3}\\.){3}[0-9]{1,3}\"\n+\"|\"\n+\"([0-9a-z_!~*'()-]+\\.)*\"\n+\"([0-9a-z][0-9a-z-]{0,61})?[0-9a-z]\\.\"\n+\"[a-z]{2,6})\"\n+\"(:[0-9]{1,4})?\"\n+\"((/?)|\"\n+\"(/[0-9a-z_!~*'().;?:@&=+$,%#-]+)+/?)$\";\nvarre=newRegExp(regu);\nif(!re.test(str)){\nreturn false;\n}\nreturn true;\n}"
        },
        {
          "name": "深入PHP：面向对象、模式与实践(第三版)中文_有书签.pdf",
          "type": "blob",
          "size": 44523.0458984375,
          "content": ""
        },
        {
          "name": "深入了解redis.pdf",
          "type": "blob",
          "size": 4118.5908203125,
          "content": null
        },
        {
          "name": "深入理解Nginx模块开发与架构解析.pdf",
          "type": "blob",
          "size": 49199.7822265625,
          "content": ""
        },
        {
          "name": "深入理解PHP.pdf",
          "type": "blob",
          "size": 2759.318359375,
          "content": null
        },
        {
          "name": "程序员的数学思维修炼（趣味解读）.pdf",
          "type": "blob",
          "size": 32425.2060546875,
          "content": ""
        },
        {
          "name": "设计模式之禅(完整高清版).pdf",
          "type": "blob",
          "size": 1020.263671875,
          "content": null
        },
        {
          "name": "设计模式之禅第2版28jb51.net29.pdf",
          "type": "blob",
          "size": 15805.7294921875,
          "content": ""
        },
        {
          "name": "设计模式之禅（第2版）.pdf",
          "type": "blob",
          "size": 15805.7294921875,
          "content": ""
        },
        {
          "name": "高性能的MySQL.pdf",
          "type": "blob",
          "size": 74733.8720703125,
          "content": ""
        }
      ]
    }
  ]
}