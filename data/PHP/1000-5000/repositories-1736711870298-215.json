{
  "metadata": {
    "timestamp": 1736711870298,
    "page": 215,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/browser-kit",
      "stars": 2974,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "AbstractBrowser.php",
          "type": "blob",
          "size": 22.2255859375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\BrowserKit;\n\nuse Symfony\\Component\\BrowserKit\\Exception\\BadMethodCallException;\nuse Symfony\\Component\\BrowserKit\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\BrowserKit\\Exception\\LogicException;\nuse Symfony\\Component\\BrowserKit\\Exception\\RuntimeException;\nuse Symfony\\Component\\DomCrawler\\Crawler;\nuse Symfony\\Component\\DomCrawler\\Form;\nuse Symfony\\Component\\DomCrawler\\Link;\nuse Symfony\\Component\\Process\\PhpProcess;\n\n/**\n * Simulates a browser.\n *\n * To make the actual request, you need to implement the doRequest() method.\n *\n * If you want to be able to run requests in their own process (insulated flag),\n * you need to also implement the getScript() method.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @template TRequest of object\n * @template TResponse of object\n */\nabstract class AbstractBrowser\n{\n    protected History $history;\n    protected CookieJar $cookieJar;\n    protected array $server = [];\n    protected Request $internalRequest;\n    /** @psalm-var TRequest */\n    protected object $request;\n    protected Response $internalResponse;\n    /** @psalm-var TResponse */\n    protected object $response;\n    protected Crawler $crawler;\n    protected bool $useHtml5Parser = true;\n    protected bool $insulated = false;\n    protected ?string $redirect;\n    protected bool $followRedirects = true;\n    protected bool $followMetaRefresh = false;\n\n    private int $maxRedirects = -1;\n    private int $redirectCount = 0;\n    private array $redirects = [];\n    private bool $isMainRequest = true;\n\n    /**\n     * @param array $server The server parameters (equivalent of $_SERVER)\n     */\n    public function __construct(array $server = [], ?History $history = null, ?CookieJar $cookieJar = null)\n    {\n        $this->setServerParameters($server);\n        $this->history = $history ?? new History();\n        $this->cookieJar = $cookieJar ?? new CookieJar();\n    }\n\n    /**\n     * Sets whether to automatically follow redirects or not.\n     */\n    public function followRedirects(bool $followRedirects = true): void\n    {\n        $this->followRedirects = $followRedirects;\n    }\n\n    /**\n     * Sets whether to automatically follow meta refresh redirects or not.\n     */\n    public function followMetaRefresh(bool $followMetaRefresh = true): void\n    {\n        $this->followMetaRefresh = $followMetaRefresh;\n    }\n\n    /**\n     * Returns whether client automatically follows redirects or not.\n     */\n    public function isFollowingRedirects(): bool\n    {\n        return $this->followRedirects;\n    }\n\n    /**\n     * Sets the maximum number of redirects that crawler can follow.\n     */\n    public function setMaxRedirects(int $maxRedirects): void\n    {\n        $this->maxRedirects = $maxRedirects < 0 ? -1 : $maxRedirects;\n        $this->followRedirects = -1 !== $this->maxRedirects;\n    }\n\n    /**\n     * Returns the maximum number of redirects that crawler can follow.\n     */\n    public function getMaxRedirects(): int\n    {\n        return $this->maxRedirects;\n    }\n\n    /**\n     * Sets the insulated flag.\n     *\n     * @throws LogicException When Symfony Process Component is not installed\n     */\n    public function insulate(bool $insulated = true): void\n    {\n        if ($insulated && !class_exists(\\Symfony\\Component\\Process\\Process::class)) {\n            throw new LogicException('Unable to isolate requests as the Symfony Process Component is not installed. Try running \"composer require symfony/process\".');\n        }\n\n        $this->insulated = $insulated;\n    }\n\n    /**\n     * Sets server parameters.\n     */\n    public function setServerParameters(array $server): void\n    {\n        $this->server = array_merge([\n            'HTTP_USER_AGENT' => 'Symfony BrowserKit',\n        ], $server);\n    }\n\n    /**\n     * Sets single server parameter.\n     */\n    public function setServerParameter(string $key, string $value): void\n    {\n        $this->server[$key] = $value;\n    }\n\n    /**\n     * Gets single server parameter for specified key.\n     */\n    public function getServerParameter(string $key, mixed $default = ''): mixed\n    {\n        return $this->server[$key] ?? $default;\n    }\n\n    public function xmlHttpRequest(string $method, string $uri, array $parameters = [], array $files = [], array $server = [], ?string $content = null, bool $changeHistory = true): Crawler\n    {\n        $this->setServerParameter('HTTP_X_REQUESTED_WITH', 'XMLHttpRequest');\n\n        try {\n            return $this->request($method, $uri, $parameters, $files, $server, $content, $changeHistory);\n        } finally {\n            unset($this->server['HTTP_X_REQUESTED_WITH']);\n        }\n    }\n\n    /**\n     * Converts the request parameters into a JSON string and uses it as request content.\n     */\n    public function jsonRequest(string $method, string $uri, array $parameters = [], array $server = [], bool $changeHistory = true): Crawler\n    {\n        $content = json_encode($parameters);\n\n        $this->setServerParameter('CONTENT_TYPE', 'application/json');\n        $this->setServerParameter('HTTP_ACCEPT', 'application/json');\n\n        try {\n            return $this->request($method, $uri, [], [], $server, $content, $changeHistory);\n        } finally {\n            unset($this->server['CONTENT_TYPE']);\n            unset($this->server['HTTP_ACCEPT']);\n        }\n    }\n\n    /**\n     * Returns the History instance.\n     */\n    public function getHistory(): History\n    {\n        return $this->history;\n    }\n\n    /**\n     * Returns the CookieJar instance.\n     */\n    public function getCookieJar(): CookieJar\n    {\n        return $this->cookieJar;\n    }\n\n    /**\n     * Returns the current Crawler instance.\n     */\n    public function getCrawler(): Crawler\n    {\n        return $this->crawler ?? throw new BadMethodCallException(\\sprintf('The \"request()\" method must be called before \"%s()\".', __METHOD__));\n    }\n\n    /**\n     * Sets whether parsing should be done using \"masterminds/html5\".\n     *\n     * @return $this\n     */\n    public function useHtml5Parser(bool $useHtml5Parser): static\n    {\n        $this->useHtml5Parser = $useHtml5Parser;\n\n        return $this;\n    }\n\n    /**\n     * Returns the current BrowserKit Response instance.\n     */\n    public function getInternalResponse(): Response\n    {\n        return $this->internalResponse ?? throw new BadMethodCallException(\\sprintf('The \"request()\" method must be called before \"%s()\".', __METHOD__));\n    }\n\n    /**\n     * Returns the current origin response instance.\n     *\n     * The origin response is the response instance that is returned\n     * by the code that handles requests.\n     *\n     * @psalm-return TResponse\n     *\n     * @see doRequest()\n     */\n    public function getResponse(): object\n    {\n        return $this->response ?? throw new BadMethodCallException(\\sprintf('The \"request()\" method must be called before \"%s()\".', __METHOD__));\n    }\n\n    /**\n     * Returns the current BrowserKit Request instance.\n     */\n    public function getInternalRequest(): Request\n    {\n        return $this->internalRequest ?? throw new BadMethodCallException(\\sprintf('The \"request()\" method must be called before \"%s()\".', __METHOD__));\n    }\n\n    /**\n     * Returns the current origin Request instance.\n     *\n     * The origin request is the request instance that is sent\n     * to the code that handles requests.\n     *\n     * @psalm-return TRequest\n     *\n     * @see doRequest()\n     */\n    public function getRequest(): object\n    {\n        return $this->request ?? throw new BadMethodCallException(\\sprintf('The \"request()\" method must be called before \"%s()\".', __METHOD__));\n    }\n\n    /**\n     * Clicks on a given link.\n     *\n     * @param array $serverParameters An array of server parameters\n     */\n    public function click(Link $link, array $serverParameters = []): Crawler\n    {\n        if ($link instanceof Form) {\n            return $this->submit($link, [], $serverParameters);\n        }\n\n        return $this->request($link->getMethod(), $link->getUri(), [], [], $serverParameters);\n    }\n\n    /**\n     * Clicks the first link (or clickable image) that contains the given text.\n     *\n     * @param string $linkText         The text of the link or the alt attribute of the clickable image\n     * @param array  $serverParameters An array of server parameters\n     */\n    public function clickLink(string $linkText, array $serverParameters = []): Crawler\n    {\n        $crawler = $this->crawler ?? throw new BadMethodCallException(\\sprintf('The \"request()\" method must be called before \"%s()\".', __METHOD__));\n\n        return $this->click($crawler->selectLink($linkText)->link(), $serverParameters);\n    }\n\n    /**\n     * Submits a form.\n     *\n     * @param array $values           An array of form field values\n     * @param array $serverParameters An array of server parameters\n     */\n    public function submit(Form $form, array $values = [], array $serverParameters = []): Crawler\n    {\n        $form->setValues($values);\n\n        return $this->request($form->getMethod(), $form->getUri(), $form->getPhpValues(), $form->getPhpFiles(), $serverParameters);\n    }\n\n    /**\n     * Finds the first form that contains a button with the given content and\n     * uses it to submit the given form field values.\n     *\n     * @param string $button           The text content, id, value or name of the form <button> or <input type=\"submit\">\n     * @param array  $fieldValues      Use this syntax: ['my_form[name]' => '...', 'my_form[email]' => '...']\n     * @param string $method           The HTTP method used to submit the form\n     * @param array  $serverParameters These values override the ones stored in $_SERVER (HTTP headers must include an HTTP_ prefix as PHP does)\n     */\n    public function submitForm(string $button, array $fieldValues = [], string $method = 'POST', array $serverParameters = []): Crawler\n    {\n        $crawler = $this->crawler ?? throw new BadMethodCallException(\\sprintf('The \"request()\" method must be called before \"%s()\".', __METHOD__));\n        $buttonNode = $crawler->selectButton($button);\n\n        if (0 === $buttonNode->count()) {\n            throw new InvalidArgumentException(\\sprintf('There is no button with \"%s\" as its content, id, value or name.', $button));\n        }\n\n        $form = $buttonNode->form($fieldValues, $method);\n\n        return $this->submit($form, [], $serverParameters);\n    }\n\n    /**\n     * Calls a URI.\n     *\n     * @param string $method        The request method\n     * @param string $uri           The URI to fetch\n     * @param array  $parameters    The Request parameters\n     * @param array  $files         The files\n     * @param array  $server        The server parameters (HTTP headers are referenced with an HTTP_ prefix as PHP does)\n     * @param string $content       The raw body data\n     * @param bool   $changeHistory Whether to update the history or not (only used internally for back(), forward(), and reload())\n     */\n    public function request(string $method, string $uri, array $parameters = [], array $files = [], array $server = [], ?string $content = null, bool $changeHistory = true): Crawler\n    {\n        if ($this->isMainRequest) {\n            $this->redirectCount = 0;\n        } else {\n            ++$this->redirectCount;\n        }\n\n        $originalUri = $uri;\n\n        $uri = $this->getAbsoluteUri($uri);\n\n        $server = array_merge($this->server, $server);\n\n        if (!empty($server['HTTP_HOST']) && !parse_url($originalUri, \\PHP_URL_HOST)) {\n            $uri = preg_replace('{^(https?\\://)'.preg_quote($this->extractHost($uri)).'}', '${1}'.$server['HTTP_HOST'], $uri);\n        }\n\n        if (isset($server['HTTPS']) && !parse_url($originalUri, \\PHP_URL_SCHEME)) {\n            $uri = preg_replace('{^'.parse_url($uri, \\PHP_URL_SCHEME).'}', $server['HTTPS'] ? 'https' : 'http', $uri);\n        }\n\n        if (!isset($server['HTTP_REFERER']) && !$this->history->isEmpty()) {\n            $server['HTTP_REFERER'] = $this->history->current()->getUri();\n        }\n\n        if (empty($server['HTTP_HOST'])) {\n            $server['HTTP_HOST'] = $this->extractHost($uri);\n        }\n\n        $server['HTTPS'] = 'https' === parse_url($uri, \\PHP_URL_SCHEME);\n\n        $this->internalRequest = new Request($uri, $method, $parameters, $files, $this->cookieJar->allValues($uri), $server, $content);\n\n        $this->request = $this->filterRequest($this->internalRequest);\n\n        if (true === $changeHistory) {\n            $this->history->add($this->internalRequest);\n        }\n\n        if ($this->insulated) {\n            $this->response = $this->doRequestInProcess($this->request);\n        } else {\n            $this->response = $this->doRequest($this->request);\n        }\n\n        $this->internalResponse = $this->filterResponse($this->response);\n\n        $this->cookieJar->updateFromResponse($this->internalResponse, $uri);\n\n        $status = $this->internalResponse->getStatusCode();\n\n        if ($status >= 300 && $status < 400) {\n            $this->redirect = $this->internalResponse->getHeader('Location');\n        } else {\n            $this->redirect = null;\n        }\n\n        if ($this->followRedirects && $this->redirect) {\n            $this->redirects[serialize($this->history->current())] = true;\n\n            return $this->crawler = $this->followRedirect();\n        }\n\n        $this->crawler = $this->createCrawlerFromContent($this->internalRequest->getUri(), $this->internalResponse->getContent(), $this->internalResponse->getHeader('Content-Type') ?? '');\n\n        // Check for meta refresh redirect\n        if ($this->followMetaRefresh && null !== $redirect = $this->getMetaRefreshUrl()) {\n            $this->redirect = $redirect;\n            $this->redirects[serialize($this->history->current())] = true;\n            $this->crawler = $this->followRedirect();\n        }\n\n        return $this->crawler;\n    }\n\n    /**\n     * Makes a request in another process.\n     *\n     * @psalm-param TRequest $request\n     *\n     * @return object\n     *\n     * @psalm-return TResponse\n     *\n     * @throws \\RuntimeException When processing returns exit code\n     */\n    protected function doRequestInProcess(object $request)\n    {\n        $deprecationsFile = tempnam(sys_get_temp_dir(), 'deprec');\n        putenv('SYMFONY_DEPRECATIONS_SERIALIZE='.$deprecationsFile);\n        $_ENV['SYMFONY_DEPRECATIONS_SERIALIZE'] = $deprecationsFile;\n        $process = new PhpProcess($this->getScript($request), null, null);\n        $process->run();\n\n        if (file_exists($deprecationsFile)) {\n            $deprecations = file_get_contents($deprecationsFile);\n            unlink($deprecationsFile);\n            foreach ($deprecations ? unserialize($deprecations) : [] as $deprecation) {\n                if ($deprecation[0]) {\n                    // unsilenced on purpose\n                    trigger_error($deprecation[1], \\E_USER_DEPRECATED);\n                } else {\n                    @trigger_error($deprecation[1], \\E_USER_DEPRECATED);\n                }\n            }\n        }\n\n        if (!$process->isSuccessful() || !preg_match('/^O\\:\\d+\\:/', $process->getOutput())) {\n            throw new RuntimeException(\\sprintf('OUTPUT: %s ERROR OUTPUT: %s.', $process->getOutput(), $process->getErrorOutput()));\n        }\n\n        return unserialize($process->getOutput());\n    }\n\n    /**\n     * Makes a request.\n     *\n     * @psalm-param TRequest $request\n     *\n     * @return object\n     *\n     * @psalm-return TResponse\n     */\n    abstract protected function doRequest(object $request);\n\n    /**\n     * Returns the script to execute when the request must be insulated.\n     *\n     * @psalm-param TRequest $request\n     *\n     * @param object $request An origin request instance\n     *\n     * @return string\n     *\n     * @throws LogicException When this abstract class is not implemented\n     */\n    protected function getScript(object $request)\n    {\n        throw new LogicException('To insulate requests, you need to override the getScript() method.');\n    }\n\n    /**\n     * Filters the BrowserKit request to the origin one.\n     *\n     * @return object\n     *\n     * @psalm-return TRequest\n     */\n    protected function filterRequest(Request $request)\n    {\n        return $request;\n    }\n\n    /**\n     * Filters the origin response to the BrowserKit one.\n     *\n     * @psalm-param TResponse $response\n     *\n     * @return Response\n     */\n    protected function filterResponse(object $response)\n    {\n        return $response;\n    }\n\n    /**\n     * Creates a crawler.\n     *\n     * This method returns null if the DomCrawler component is not available.\n     */\n    protected function createCrawlerFromContent(string $uri, string $content, string $type): ?Crawler\n    {\n        if (!class_exists(Crawler::class)) {\n            return null;\n        }\n\n        $crawler = new Crawler(null, $uri, null, $this->useHtml5Parser);\n        $crawler->addContent($content, $type);\n\n        return $crawler;\n    }\n\n    /**\n     * Goes back in the browser history.\n     */\n    public function back(): Crawler\n    {\n        do {\n            $request = $this->history->back();\n        } while (\\array_key_exists(serialize($request), $this->redirects));\n\n        return $this->requestFromRequest($request, false);\n    }\n\n    /**\n     * Goes forward in the browser history.\n     */\n    public function forward(): Crawler\n    {\n        do {\n            $request = $this->history->forward();\n        } while (\\array_key_exists(serialize($request), $this->redirects));\n\n        return $this->requestFromRequest($request, false);\n    }\n\n    /**\n     * Reloads the current browser.\n     */\n    public function reload(): Crawler\n    {\n        return $this->requestFromRequest($this->history->current(), false);\n    }\n\n    /**\n     * Follow redirects?\n     *\n     * @throws LogicException If request was not a redirect\n     */\n    public function followRedirect(): Crawler\n    {\n        if (!isset($this->redirect)) {\n            throw new LogicException('The request was not redirected.');\n        }\n\n        if (-1 !== $this->maxRedirects) {\n            if ($this->redirectCount > $this->maxRedirects) {\n                $this->redirectCount = 0;\n                throw new LogicException(\\sprintf('The maximum number (%d) of redirections was reached.', $this->maxRedirects));\n            }\n        }\n\n        $request = $this->internalRequest;\n\n        if (\\in_array($this->internalResponse->getStatusCode(), [301, 302, 303])) {\n            $method = 'GET';\n            $files = [];\n            $content = null;\n        } else {\n            $method = $request->getMethod();\n            $files = $request->getFiles();\n            $content = $request->getContent();\n        }\n\n        if ('GET' === strtoupper($method)) {\n            // Don't forward parameters for GET request as it should reach the redirection URI\n            $parameters = [];\n        } else {\n            $parameters = $request->getParameters();\n        }\n\n        $server = $request->getServer();\n        $server = $this->updateServerFromUri($server, $this->redirect);\n\n        $this->isMainRequest = false;\n\n        $response = $this->request($method, $this->redirect, $parameters, $files, $server, $content);\n\n        $this->isMainRequest = true;\n\n        return $response;\n    }\n\n    /**\n     * @see https://dev.w3.org/html5/spec-preview/the-meta-element.html#attr-meta-http-equiv-refresh\n     */\n    private function getMetaRefreshUrl(): ?string\n    {\n        $metaRefresh = $this->getCrawler()->filter('head meta[http-equiv=\"refresh\"]');\n        foreach ($metaRefresh->extract(['content']) as $content) {\n            if (preg_match('/^\\s*0\\s*;\\s*URL\\s*=\\s*(?|\\'([^\\']++)|\"([^\"]++)|([^\\'\"].*))/i', $content, $m)) {\n                return str_replace(\"\\t\\r\\n\", '', rtrim($m[1]));\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Restarts the client.\n     *\n     * It flushes history and all cookies.\n     */\n    public function restart(): void\n    {\n        $this->cookieJar->clear();\n        $this->history->clear();\n    }\n\n    /**\n     * Takes a URI and converts it to absolute if it is not already absolute.\n     */\n    protected function getAbsoluteUri(string $uri): string\n    {\n        // already absolute?\n        if (str_starts_with($uri, 'http://') || str_starts_with($uri, 'https://')) {\n            return $uri;\n        }\n\n        if (!$this->history->isEmpty()) {\n            $currentUri = $this->history->current()->getUri();\n        } else {\n            $currentUri = \\sprintf('http%s://%s/',\n                isset($this->server['HTTPS']) ? 's' : '',\n                $this->server['HTTP_HOST'] ?? 'localhost'\n            );\n        }\n\n        // protocol relative URL\n        if ('' !== trim($uri, '/') && str_starts_with($uri, '//')) {\n            return parse_url($currentUri, \\PHP_URL_SCHEME).':'.$uri;\n        }\n\n        // anchor or query string parameters?\n        if (!$uri || '#' === $uri[0] || '?' === $uri[0]) {\n            return preg_replace('/[#?].*?$/', '', $currentUri).$uri;\n        }\n\n        if ('/' !== $uri[0]) {\n            $path = parse_url($currentUri, \\PHP_URL_PATH);\n\n            if (!str_ends_with($path, '/')) {\n                $path = substr($path, 0, strrpos($path, '/') + 1);\n            }\n\n            $uri = $path.$uri;\n        }\n\n        return preg_replace('#^(.*?//[^/]+)\\/.*$#', '$1', $currentUri).$uri;\n    }\n\n    /**\n     * Makes a request from a Request object directly.\n     *\n     * @param bool $changeHistory Whether to update the history or not (only used internally for back(), forward(), and reload())\n     */\n    protected function requestFromRequest(Request $request, bool $changeHistory = true): Crawler\n    {\n        return $this->request($request->getMethod(), $request->getUri(), $request->getParameters(), $request->getFiles(), $request->getServer(), $request->getContent(), $changeHistory);\n    }\n\n    private function updateServerFromUri(array $server, string $uri): array\n    {\n        $server['HTTP_HOST'] = $this->extractHost($uri);\n        $scheme = parse_url($uri, \\PHP_URL_SCHEME);\n        $server['HTTPS'] = null === $scheme ? $server['HTTPS'] : 'https' === $scheme;\n        unset($server['HTTP_IF_NONE_MATCH'], $server['HTTP_IF_MODIFIED_SINCE']);\n\n        return $server;\n    }\n\n    private function extractHost(string $uri): ?string\n    {\n        $host = parse_url($uri, \\PHP_URL_HOST);\n\n        if ($port = parse_url($uri, \\PHP_URL_PORT)) {\n            return $host.':'.$port;\n        }\n\n        return $host;\n    }\n}\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.8583984375,
          "content": "CHANGELOG\n=========\n\n6.4\n---\n\n * Add argument `$serverParameters` to `AbstractBrowser::click()` and `AbstractBrowser::clickLink()`\n\n6.3\n---\n\n * Add `AbstractBrowser::useHtml5Parser()`\n\n6.1\n---\n\n * Add `toArray` method to `Response`\n\n5.3\n---\n\n * Added `jsonRequest` method to `AbstractBrowser`\n * Allowed sending a body with GET requests when a content-type is defined\n\n5.2.0\n-----\n\n * [BC BREAK] Request parameters are now casted to string in `Request::__construct()`.\n\n4.3.0\n-----\n\n * Added PHPUnit constraints: `BrowserCookieValueSame` and `BrowserHasCookie`\n * Added `HttpBrowser`, an implementation of a browser with the HttpClient component\n * Renamed `Client` to `AbstractBrowser`\n * Marked `Response` final.\n * Deprecated `Response::buildHeader()`\n * Deprecated `Response::getStatus()`, use `Response::getStatusCode()` instead\n\n4.2.0\n-----\n\n * The method `Client::submit()` will have a new `$serverParameters` argument\n   in version 5.0, not defining it is deprecated\n * Added ability to read the \"samesite\" attribute of cookies using `Cookie::getSameSite()`\n\n3.4.0\n-----\n\n * [BC BREAK] Client will skip redirects during history navigation\n   (back and forward calls) according to W3C Browsers recommendation\n\n3.3.0\n-----\n\n * [BC BREAK] The request method is dropped from POST to GET when the response\n   status code is 301.\n\n3.2.0\n-----\n\n * Client HTTP user agent has been changed to 'Symfony BrowserKit'\n\n2.3.0\n-----\n\n * [BC BREAK] `Client::followRedirect()` won't redirect responses with\n   a non-3xx Status Code and `Location` header anymore, as per\n   http://tools.ietf.org/html/rfc2616#section-14.30\n\n * added `Client::getInternalRequest()` and `Client::getInternalResponse()` to\n   have access to the BrowserKit internal request and response objects\n\n2.1.0\n-----\n\n * [BC BREAK] The CookieJar internals have changed to allow cookies with the\n   same name on different sub-domains/sub-paths\n"
        },
        {
          "name": "Cookie.php",
          "type": "blob",
          "size": 8.24609375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\BrowserKit;\n\nuse Symfony\\Component\\BrowserKit\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\BrowserKit\\Exception\\UnexpectedValueException;\n\n/**\n * Cookie represents an HTTP cookie.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Cookie\n{\n    /**\n     * Handles dates as defined by RFC 2616 section 3.3.1, and also some other\n     * non-standard, but common formats.\n     */\n    private const DATE_FORMATS = [\n        'D, d M Y H:i:s T',\n        'D, d-M-y H:i:s T',\n        'D, d-M-Y H:i:s T',\n        'D, d-m-y H:i:s T',\n        'D, d-m-Y H:i:s T',\n        'D M j G:i:s Y',\n        'D M d H:i:s Y T',\n    ];\n\n    protected string $value;\n    protected ?string $expires = null;\n    protected string $path;\n    protected string $rawValue;\n\n    /**\n     * Sets a cookie.\n     *\n     * @param string      $name         The cookie name\n     * @param string|null $value        The value of the cookie\n     * @param string|null $expires      The time the cookie expires\n     * @param string|null $path         The path on the server in which the cookie will be available on\n     * @param string      $domain       The domain that the cookie is available\n     * @param bool        $secure       Indicates that the cookie should only be transmitted over a secure HTTPS connection from the client\n     * @param bool        $httponly     The cookie httponly flag\n     * @param bool        $encodedValue Whether the value is encoded or not\n     * @param string|null $samesite     The cookie samesite attribute\n     */\n    public function __construct(\n        private string $name,\n        ?string $value,\n        ?string $expires = null,\n        ?string $path = null,\n        private string $domain = '',\n        private bool $secure = false,\n        private bool $httponly = true,\n        bool $encodedValue = false,\n        private ?string $samesite = null,\n    ) {\n        if ($encodedValue) {\n            $this->rawValue = $value ?? '';\n            $this->value = urldecode($this->rawValue);\n        } else {\n            $this->value = $value ?? '';\n            $this->rawValue = rawurlencode($this->value);\n        }\n        $this->path = $path ?: '/';\n\n        if (null !== $expires) {\n            $timestampAsDateTime = \\DateTimeImmutable::createFromFormat('U', $expires);\n            if (false === $timestampAsDateTime) {\n                throw new UnexpectedValueException(\\sprintf('The cookie expiration time \"%s\" is not valid.', $expires));\n            }\n\n            $this->expires = $timestampAsDateTime->format('U');\n        }\n    }\n\n    /**\n     * Returns the HTTP representation of the Cookie.\n     */\n    public function __toString(): string\n    {\n        $cookie = \\sprintf('%s=%s', $this->name, $this->rawValue);\n\n        if (null !== $this->expires) {\n            $dateTime = \\DateTimeImmutable::createFromFormat('U', $this->expires, new \\DateTimeZone('GMT'));\n            $cookie .= '; expires='.str_replace('+0000', '', $dateTime->format(self::DATE_FORMATS[0]));\n        }\n\n        if ('' !== $this->domain) {\n            $cookie .= '; domain='.$this->domain;\n        }\n\n        if ($this->path) {\n            $cookie .= '; path='.$this->path;\n        }\n\n        if ($this->secure) {\n            $cookie .= '; secure';\n        }\n\n        if ($this->httponly) {\n            $cookie .= '; httponly';\n        }\n\n        if (null !== $this->samesite) {\n            $cookie .= '; samesite='.$this->samesite;\n        }\n\n        return $cookie;\n    }\n\n    /**\n     * Creates a Cookie instance from a Set-Cookie header value.\n     *\n     * @throws InvalidArgumentException\n     */\n    public static function fromString(string $cookie, ?string $url = null): static\n    {\n        $parts = explode(';', $cookie);\n\n        if (!str_contains($parts[0], '=')) {\n            throw new InvalidArgumentException(\\sprintf('The cookie string \"%s\" is not valid.', $parts[0]));\n        }\n\n        [$name, $value] = explode('=', array_shift($parts), 2);\n\n        $values = [\n            'name' => trim($name),\n            'value' => trim($value),\n            'expires' => null,\n            'path' => '/',\n            'domain' => '',\n            'secure' => false,\n            'httponly' => false,\n            'passedRawValue' => true,\n            'samesite' => null,\n        ];\n\n        if (null !== $url) {\n            if (false === ($urlParts = parse_url($url)) || !isset($urlParts['host'])) {\n                throw new InvalidArgumentException(\\sprintf('The URL \"%s\" is not valid.', $url));\n            }\n\n            $values['domain'] = $urlParts['host'];\n            $values['path'] = isset($urlParts['path']) ? substr($urlParts['path'], 0, strrpos($urlParts['path'], '/')) : '';\n        }\n\n        foreach ($parts as $part) {\n            $part = trim($part);\n\n            if ('secure' === strtolower($part)) {\n                // Ignore the secure flag if the original URI is not given or is not HTTPS\n                if (null === $url || !isset($urlParts['scheme']) || 'https' !== $urlParts['scheme']) {\n                    continue;\n                }\n\n                $values['secure'] = true;\n\n                continue;\n            }\n\n            if ('httponly' === strtolower($part)) {\n                $values['httponly'] = true;\n\n                continue;\n            }\n\n            if (2 === \\count($elements = explode('=', $part, 2))) {\n                if ('expires' === strtolower($elements[0])) {\n                    $elements[1] = self::parseDate($elements[1]);\n                }\n\n                $values[strtolower($elements[0])] = $elements[1];\n            }\n        }\n\n        return new static(\n            $values['name'],\n            $values['value'],\n            $values['expires'],\n            $values['path'],\n            $values['domain'],\n            $values['secure'],\n            $values['httponly'],\n            $values['passedRawValue'],\n            $values['samesite']\n        );\n    }\n\n    private static function parseDate(string $dateValue): ?string\n    {\n        // trim single quotes around date if present\n        if (($length = \\strlen($dateValue)) > 1 && \"'\" === $dateValue[0] && \"'\" === $dateValue[$length - 1]) {\n            $dateValue = substr($dateValue, 1, -1);\n        }\n\n        foreach (self::DATE_FORMATS as $dateFormat) {\n            if (false !== $date = \\DateTimeImmutable::createFromFormat($dateFormat, $dateValue, new \\DateTimeZone('GMT'))) {\n                return $date->format('U');\n            }\n        }\n\n        // attempt a fallback for unusual formatting\n        if (false !== $date = date_create_immutable($dateValue, new \\DateTimeZone('GMT'))) {\n            return $date->format('U');\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets the name of the cookie.\n     */\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    /**\n     * Gets the value of the cookie.\n     */\n    public function getValue(): string\n    {\n        return $this->value;\n    }\n\n    /**\n     * Gets the raw value of the cookie.\n     */\n    public function getRawValue(): string\n    {\n        return $this->rawValue;\n    }\n\n    /**\n     * Gets the expires time of the cookie.\n     */\n    public function getExpiresTime(): ?string\n    {\n        return $this->expires;\n    }\n\n    /**\n     * Gets the path of the cookie.\n     */\n    public function getPath(): string\n    {\n        return $this->path;\n    }\n\n    /**\n     * Gets the domain of the cookie.\n     */\n    public function getDomain(): string\n    {\n        return $this->domain;\n    }\n\n    /**\n     * Returns the secure flag of the cookie.\n     */\n    public function isSecure(): bool\n    {\n        return $this->secure;\n    }\n\n    /**\n     * Returns the httponly flag of the cookie.\n     */\n    public function isHttpOnly(): bool\n    {\n        return $this->httponly;\n    }\n\n    /**\n     * Returns true if the cookie has expired.\n     */\n    public function isExpired(): bool\n    {\n        return null !== $this->expires && 0 != $this->expires && $this->expires <= time();\n    }\n\n    /**\n     * Gets the samesite attribute of the cookie.\n     */\n    public function getSameSite(): ?string\n    {\n        return $this->samesite;\n    }\n}\n"
        },
        {
          "name": "CookieJar.php",
          "type": "blob",
          "size": 6.1474609375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\BrowserKit;\n\nuse Symfony\\Component\\BrowserKit\\Exception\\InvalidArgumentException;\n\n/**\n * CookieJar.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass CookieJar\n{\n    protected array $cookieJar = [];\n\n    public function set(Cookie $cookie): void\n    {\n        $this->cookieJar[$cookie->getDomain()][$cookie->getPath()][$cookie->getName()] = $cookie;\n    }\n\n    /**\n     * Gets a cookie by name.\n     *\n     * You should never use an empty domain, but if you do so,\n     * this method returns the first cookie for the given name/path\n     * (this behavior ensures a BC behavior with previous versions of\n     * Symfony).\n     */\n    public function get(string $name, string $path = '/', ?string $domain = null): ?Cookie\n    {\n        $this->flushExpiredCookies();\n\n        foreach ($this->cookieJar as $cookieDomain => $pathCookies) {\n            if ($cookieDomain && $domain) {\n                $cookieDomain = '.'.ltrim($cookieDomain, '.');\n                if (!str_ends_with('.'.$domain, $cookieDomain)) {\n                    continue;\n                }\n            }\n\n            foreach ($pathCookies as $cookiePath => $namedCookies) {\n                if (!str_starts_with($path, $cookiePath)) {\n                    continue;\n                }\n                if (isset($namedCookies[$name])) {\n                    return $namedCookies[$name];\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Removes a cookie by name.\n     *\n     * You should never use an empty domain, but if you do so,\n     * all cookies for the given name/path expire (this behavior\n     * ensures a BC behavior with previous versions of Symfony).\n     */\n    public function expire(string $name, ?string $path = '/', ?string $domain = null): void\n    {\n        $path ??= '/';\n\n        if (!$domain) {\n            // an empty domain means any domain\n            // this should never happen but it allows for a better BC\n            $domains = array_keys($this->cookieJar);\n        } else {\n            $domains = [$domain];\n        }\n\n        foreach ($domains as $domain) {\n            unset($this->cookieJar[$domain][$path][$name]);\n\n            if (empty($this->cookieJar[$domain][$path])) {\n                unset($this->cookieJar[$domain][$path]);\n\n                if (empty($this->cookieJar[$domain])) {\n                    unset($this->cookieJar[$domain]);\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes all the cookies from the jar.\n     */\n    public function clear(): void\n    {\n        $this->cookieJar = [];\n    }\n\n    /**\n     * Updates the cookie jar from a response Set-Cookie headers.\n     *\n     * @param string[] $setCookies Set-Cookie headers from an HTTP response\n     */\n    public function updateFromSetCookie(array $setCookies, ?string $uri = null): void\n    {\n        $cookies = [];\n\n        foreach ($setCookies as $cookie) {\n            foreach (explode(',', $cookie) as $i => $part) {\n                if (0 === $i || preg_match('/^(?P<token>\\s*[0-9A-Za-z!#\\$%\\&\\'\\*\\+\\-\\.^_`\\|~]+)=/', $part)) {\n                    $cookies[] = ltrim($part);\n                } else {\n                    $cookies[\\count($cookies) - 1] .= ','.$part;\n                }\n            }\n        }\n\n        foreach ($cookies as $cookie) {\n            try {\n                $this->set(Cookie::fromString($cookie, $uri));\n            } catch (InvalidArgumentException) {\n                // invalid cookies are just ignored\n            }\n        }\n    }\n\n    /**\n     * Updates the cookie jar from a Response object.\n     */\n    public function updateFromResponse(Response $response, ?string $uri = null): void\n    {\n        $this->updateFromSetCookie($response->getHeader('Set-Cookie', false), $uri);\n    }\n\n    /**\n     * Returns not yet expired cookies.\n     *\n     * @return Cookie[]\n     */\n    public function all(): array\n    {\n        $this->flushExpiredCookies();\n\n        $flattenedCookies = [];\n        foreach ($this->cookieJar as $path) {\n            foreach ($path as $cookies) {\n                foreach ($cookies as $cookie) {\n                    $flattenedCookies[] = $cookie;\n                }\n            }\n        }\n\n        return $flattenedCookies;\n    }\n\n    /**\n     * Returns not yet expired cookie values for the given URI.\n     */\n    public function allValues(string $uri, bool $returnsRawValue = false): array\n    {\n        $this->flushExpiredCookies();\n\n        $parts = array_replace(['path' => '/'], parse_url($uri));\n        $cookies = [];\n        foreach ($this->cookieJar as $domain => $pathCookies) {\n            if ($domain) {\n                $domain = '.'.ltrim($domain, '.');\n                if (!str_ends_with('.'.$parts['host'], $domain)) {\n                    continue;\n                }\n            }\n\n            foreach ($pathCookies as $path => $namedCookies) {\n                if (!str_starts_with($parts['path'], $path)) {\n                    continue;\n                }\n\n                foreach ($namedCookies as $cookie) {\n                    if ($cookie->isSecure() && 'https' !== $parts['scheme']) {\n                        continue;\n                    }\n\n                    $cookies[$cookie->getName()] = $returnsRawValue ? $cookie->getRawValue() : $cookie->getValue();\n                }\n            }\n        }\n\n        return $cookies;\n    }\n\n    /**\n     * Returns not yet expired raw cookie values for the given URI.\n     */\n    public function allRawValues(string $uri): array\n    {\n        return $this->allValues($uri, true);\n    }\n\n    /**\n     * Removes all expired cookies.\n     */\n    public function flushExpiredCookies(): void\n    {\n        foreach ($this->cookieJar as $domain => $pathCookies) {\n            foreach ($pathCookies as $path => $namedCookies) {\n                foreach ($namedCookies as $name => $cookie) {\n                    if ($cookie->isExpired()) {\n                        unset($this->cookieJar[$domain][$path][$name]);\n                    }\n                }\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "History.php",
          "type": "blob",
          "size": 2.1083984375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\BrowserKit;\n\nuse Symfony\\Component\\BrowserKit\\Exception\\LogicException;\n\n/**\n * History.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass History\n{\n    protected array $stack = [];\n    protected int $position = -1;\n\n    /**\n     * Clears the history.\n     */\n    public function clear(): void\n    {\n        $this->stack = [];\n        $this->position = -1;\n    }\n\n    /**\n     * Adds a Request to the history.\n     */\n    public function add(Request $request): void\n    {\n        $this->stack = \\array_slice($this->stack, 0, $this->position + 1);\n        $this->stack[] = clone $request;\n        $this->position = \\count($this->stack) - 1;\n    }\n\n    /**\n     * Returns true if the history is empty.\n     */\n    public function isEmpty(): bool\n    {\n        return 0 === \\count($this->stack);\n    }\n\n    /**\n     * Goes back in the history.\n     *\n     * @throws LogicException if the stack is already on the first page\n     */\n    public function back(): Request\n    {\n        if ($this->position < 1) {\n            throw new LogicException('You are already on the first page.');\n        }\n\n        return clone $this->stack[--$this->position];\n    }\n\n    /**\n     * Goes forward in the history.\n     *\n     * @throws LogicException if the stack is already on the last page\n     */\n    public function forward(): Request\n    {\n        if ($this->position > \\count($this->stack) - 2) {\n            throw new LogicException('You are already on the last page.');\n        }\n\n        return clone $this->stack[++$this->position];\n    }\n\n    /**\n     * Returns the current element in the history.\n     *\n     * @throws LogicException if the stack is empty\n     */\n    public function current(): Request\n    {\n        if (-1 === $this->position) {\n            throw new LogicException('The page history is empty.');\n        }\n\n        return clone $this->stack[$this->position];\n    }\n}\n"
        },
        {
          "name": "HttpBrowser.php",
          "type": "blob",
          "size": 5.220703125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\BrowserKit;\n\nuse Symfony\\Component\\BrowserKit\\Exception\\LogicException;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\n/**\n * An implementation of a browser using the HttpClient component\n * to make real HTTP requests.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @template-extends AbstractBrowser<Request, Response>\n */\nclass HttpBrowser extends AbstractBrowser\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null, ?History $history = null, ?CookieJar $cookieJar = null)\n    {\n        if (!$client && !class_exists(HttpClient::class)) {\n            throw new LogicException(\\sprintf('You cannot use \"%s\" as the HttpClient component is not installed. Try running \"composer require symfony/http-client\".', __CLASS__));\n        }\n\n        $this->client = $client ?? HttpClient::create();\n\n        parent::__construct([], $history, $cookieJar);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function doRequest(object $request): Response\n    {\n        $headers = $this->getHeaders($request);\n        [$body, $extraHeaders] = $this->getBodyAndExtraHeaders($request, $headers);\n\n        $response = $this->client->request($request->getMethod(), $request->getUri(), [\n            'headers' => array_merge($headers, $extraHeaders),\n            'body' => $body,\n            'max_redirects' => 0,\n        ]);\n\n        return new Response($response->getContent(false), $response->getStatusCode(), $response->getHeaders(false));\n    }\n\n    /**\n     * @return array [$body, $headers]\n     */\n    private function getBodyAndExtraHeaders(Request $request, array $headers): array\n    {\n        if (\\in_array($request->getMethod(), ['GET', 'HEAD']) && !isset($headers['content-type'])) {\n            return ['', []];\n        }\n\n        if (!class_exists(AbstractPart::class)) {\n            throw new LogicException('You cannot pass non-empty bodies as the Mime component is not installed. Try running \"composer require symfony/mime\".');\n        }\n\n        if (null !== $content = $request->getContent()) {\n            if (isset($headers['content-type'])) {\n                return [$content, []];\n            }\n\n            $part = new TextPart($content, 'utf-8', 'plain', '8bit');\n\n            return [$part->bodyToString(), $part->getPreparedHeaders()->toArray()];\n        }\n\n        $fields = $request->getParameters();\n\n        if ($uploadedFiles = $this->getUploadedFiles($request->getFiles())) {\n            $part = new FormDataPart(array_replace_recursive($fields, $uploadedFiles));\n\n            return [$part->bodyToIterable(), $part->getPreparedHeaders()->toArray()];\n        }\n\n        if (!$fields) {\n            return ['', []];\n        }\n\n        array_walk_recursive($fields, $caster = static function (&$v) use (&$caster) {\n            if (\\is_object($v)) {\n                if ($vars = get_object_vars($v)) {\n                    array_walk_recursive($vars, $caster);\n                    $v = $vars;\n                } elseif ($v instanceof \\Stringable) {\n                    $v = (string) $v;\n                }\n            }\n        });\n\n        return [http_build_query($fields, '', '&'), ['Content-Type' => 'application/x-www-form-urlencoded']];\n    }\n\n    protected function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->getServer() as $key => $value) {\n            $key = strtolower(str_replace('_', '-', $key));\n            $contentHeaders = ['content-length' => true, 'content-md5' => true, 'content-type' => true];\n            if (str_starts_with($key, 'http-')) {\n                $headers[substr($key, 5)] = $value;\n            } elseif (isset($contentHeaders[$key])) {\n                // CONTENT_* are not prefixed with HTTP_\n                $headers[$key] = $value;\n            }\n        }\n        $cookies = [];\n        foreach ($this->getCookieJar()->allRawValues($request->getUri()) as $name => $value) {\n            $cookies[] = $name.'='.$value;\n        }\n        if ($cookies) {\n            $headers['cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n\n    /**\n     * Recursively go through the list. If the file has a tmp_name, convert it to a DataPart.\n     * Keep the original hierarchy.\n     */\n    private function getUploadedFiles(array $files): array\n    {\n        $uploadedFiles = [];\n        foreach ($files as $name => $file) {\n            if (!\\is_array($file)) {\n                return $uploadedFiles;\n            }\n            if (!isset($file['tmp_name'])) {\n                $uploadedFiles[$name] = $this->getUploadedFiles($file);\n            }\n            if (isset($file['tmp_name'])) {\n                $uploadedFiles[$name] = DataPart::fromPath($file['tmp_name'], $file['name']);\n            }\n        }\n\n        return $uploadedFiles;\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.6826171875,
          "content": "BrowserKit Component\n====================\n\nThe BrowserKit component simulates the behavior of a web browser, allowing you\nto make requests, click on links and submit forms programmatically.\n\nThe component comes with a concrete implementation that uses the HttpClient\ncomponent to make real HTTP requests.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/browser_kit/introduction.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Request.php",
          "type": "blob",
          "size": 2.1640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\BrowserKit;\n\n/**\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Request\n{\n    /**\n     * @param string      $uri        The request URI\n     * @param string      $method     The HTTP method request\n     * @param array       $parameters The request parameters\n     * @param array       $files      An array of uploaded files\n     * @param array       $cookies    An array of cookies\n     * @param array       $server     An array of server parameters\n     * @param string|null $content    The raw body data\n     */\n    public function __construct(\n        protected string $uri,\n        protected string $method,\n        protected array $parameters = [],\n        protected array $files = [],\n        protected array $cookies = [],\n        protected array $server = [],\n        protected ?string $content = null,\n    ) {\n        array_walk_recursive($parameters, static function (&$value) {\n            $value = (string) $value;\n        });\n\n        $this->parameters = $parameters;\n    }\n\n    /**\n     * Gets the request URI.\n     */\n    public function getUri(): string\n    {\n        return $this->uri;\n    }\n\n    /**\n     * Gets the request HTTP method.\n     */\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    /**\n     * Gets the request parameters.\n     */\n    public function getParameters(): array\n    {\n        return $this->parameters;\n    }\n\n    /**\n     * Gets the request server files.\n     */\n    public function getFiles(): array\n    {\n        return $this->files;\n    }\n\n    /**\n     * Gets the request cookies.\n     */\n    public function getCookies(): array\n    {\n        return $this->cookies;\n    }\n\n    /**\n     * Gets the request server parameters.\n     */\n    public function getServer(): array\n    {\n        return $this->server;\n    }\n\n    /**\n     * Gets the request raw body data.\n     */\n    public function getContent(): ?string\n    {\n        return $this->content;\n    }\n}\n"
        },
        {
          "name": "Response.php",
          "type": "blob",
          "size": 3.0234375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\BrowserKit;\n\nuse Symfony\\Component\\BrowserKit\\Exception\\JsonException;\n\n/**\n * @author Fabien Potencier <fabien@symfony.com>\n */\nfinal class Response\n{\n    private array $jsonData;\n\n    /**\n     * The headers array is a set of key/value pairs. If a header is present multiple times\n     * then the value is an array of all the values.\n     *\n     * @param string $content The content of the response\n     * @param int    $status  The response status code (302 \"Found\" by default)\n     * @param array  $headers An array of headers\n     */\n    public function __construct(\n        private string $content = '',\n        private int $status = 200,\n        private array $headers = [],\n    ) {\n    }\n\n    /**\n     * Converts the response object to string containing all headers and the response content.\n     */\n    public function __toString(): string\n    {\n        $headers = '';\n        foreach ($this->headers as $name => $value) {\n            if (\\is_string($value)) {\n                $headers .= \\sprintf(\"%s: %s\\n\", $name, $value);\n            } else {\n                foreach ($value as $headerValue) {\n                    $headers .= \\sprintf(\"%s: %s\\n\", $name, $headerValue);\n                }\n            }\n        }\n\n        return $headers.\"\\n\".$this->content;\n    }\n\n    public function getContent(): string\n    {\n        return $this->content;\n    }\n\n    public function getStatusCode(): int\n    {\n        return $this->status;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n\n    /**\n     * @return string|array|null The first header value if $first is true, an array of values otherwise\n     */\n    public function getHeader(string $header, bool $first = true): string|array|null\n    {\n        $normalizedHeader = str_replace('-', '_', strtolower($header));\n        foreach ($this->headers as $key => $value) {\n            if (str_replace('-', '_', strtolower($key)) === $normalizedHeader) {\n                if ($first) {\n                    return \\is_array($value) ? (\\count($value) ? $value[0] : '') : $value;\n                }\n\n                return \\is_array($value) ? $value : [$value];\n            }\n        }\n\n        return $first ? null : [];\n    }\n\n    public function toArray(): array\n    {\n        if (isset($this->jsonData)) {\n            return $this->jsonData;\n        }\n\n        try {\n            $content = json_decode($this->content, true, flags: \\JSON_BIGINT_AS_STRING | \\JSON_THROW_ON_ERROR);\n        } catch (\\JsonException $e) {\n            throw new JsonException($e->getMessage(), $e->getCode(), $e);\n        }\n\n        if (!\\is_array($content)) {\n            throw new JsonException(\\sprintf('JSON content was expected to decode to an array, \"%s\" returned.', get_debug_type($content)));\n        }\n\n        return $this->jsonData = $content;\n    }\n}\n"
        },
        {
          "name": "Test",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.9775390625,
          "content": "{\n    \"name\": \"symfony/browser-kit\",\n    \"type\": \"library\",\n    \"description\": \"Simulates the behavior of a web browser, allowing you to make requests, click on links and submit forms programmatically\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/dom-crawler\": \"^6.4|^7.0\"\n    },\n    \"require-dev\": {\n        \"symfony/css-selector\": \"^6.4|^7.0\",\n        \"symfony/http-client\": \"^6.4|^7.0\",\n        \"symfony/mime\": \"^6.4|^7.0\",\n        \"symfony/process\": \"^6.4|^7.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\BrowserKit\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.84765625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony BrowserKit Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Resources</directory>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}