{
  "metadata": {
    "timestamp": 1736711884376,
    "page": 244,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/expression-language",
      "stars": 2811,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.798828125,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Add support for null-coalescing unknown variables\n * Add support for comments using `/*` & `*/`\n * Allow passing any iterable as `$providers` list to `ExpressionLanguage` constructor\n * Add support for `<<`, `>>`, and `~` bitwise operators\n * Add support for logical `xor` operator\n\n7.1\n---\n\n * Add support for PHP `min` and `max` functions\n * Add `Parser::IGNORE_UNKNOWN_VARIABLES` and `Parser::IGNORE_UNKNOWN_FUNCTIONS` flags to control whether\n   parsing and linting should check for unknown variables and functions.\n * Deprecate passing `null` as the allowed variable names to `ExpressionLanguage::lint()` and `Parser::lint()`,\n   pass the `IGNORE_UNKNOWN_VARIABLES` flag instead to ignore unknown variables during linting\n\n7.0\n---\n\n * The `in` and `not in` operators now use strict comparison\n\n6.3\n---\n\n * Add `enum` expression function\n * Deprecate loose comparisons when using the \"in\" operator; normalize the array parameter\n   so it only has the expected types or implement loose matching in your own expression function\n\n6.2\n---\n\n * Add support for null-coalescing syntax\n\n6.1\n---\n\n * Add support for null-safe syntax when parsing object's methods and properties\n * Add new operators: `contains`, `starts with` and `ends with`\n * Support lexing numbers with the numeric literal separator `_`\n * Support lexing decimals with no leading zero\n\n5.1.0\n-----\n\n * added `lint` method to `ExpressionLanguage` class\n * added `lint` method to `Parser` class\n\n4.0.0\n-----\n\n * the first argument of the `ExpressionLanguage` constructor must be an instance\n   of `CacheItemPoolInterface`\n * removed the `ArrayParserCache` and `ParserCacheAdapter` classes\n * removed the `ParserCacheInterface`\n\n2.6.0\n-----\n\n * Added ExpressionFunction and ExpressionFunctionProviderInterface\n\n2.4.0\n-----\n\n * added the component\n"
        },
        {
          "name": "Compiler.php",
          "type": "blob",
          "size": 2.9453125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * Compiles a node to PHP code.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Compiler implements ResetInterface\n{\n    private string $source = '';\n\n    public function __construct(\n        private array $functions,\n    ) {\n    }\n\n    public function getFunction(string $name): array\n    {\n        return $this->functions[$name];\n    }\n\n    /**\n     * Gets the current PHP code after compilation.\n     */\n    public function getSource(): string\n    {\n        return $this->source;\n    }\n\n    /**\n     * @return $this\n     */\n    public function reset(): static\n    {\n        $this->source = '';\n\n        return $this;\n    }\n\n    /**\n     * Compiles a node.\n     *\n     * @return $this\n     */\n    public function compile(Node\\Node $node): static\n    {\n        $node->compile($this);\n\n        return $this;\n    }\n\n    public function subcompile(Node\\Node $node): string\n    {\n        $current = $this->source;\n        $this->source = '';\n\n        $node->compile($this);\n\n        $source = $this->source;\n        $this->source = $current;\n\n        return $source;\n    }\n\n    /**\n     * Adds a raw string to the compiled code.\n     *\n     * @return $this\n     */\n    public function raw(string $string): static\n    {\n        $this->source .= $string;\n\n        return $this;\n    }\n\n    /**\n     * Adds a quoted string to the compiled code.\n     *\n     * @return $this\n     */\n    public function string(string $value): static\n    {\n        $this->source .= \\sprintf('\"%s\"', addcslashes($value, \"\\0\\t\\\"\\$\\\\\"));\n\n        return $this;\n    }\n\n    /**\n     * Returns a PHP representation of a given value.\n     *\n     * @return $this\n     */\n    public function repr(mixed $value): static\n    {\n        if (\\is_int($value) || \\is_float($value)) {\n            if (false !== $locale = setlocale(\\LC_NUMERIC, 0)) {\n                setlocale(\\LC_NUMERIC, 'C');\n            }\n\n            $this->raw($value);\n\n            if (false !== $locale) {\n                setlocale(\\LC_NUMERIC, $locale);\n            }\n        } elseif (null === $value) {\n            $this->raw('null');\n        } elseif (\\is_bool($value)) {\n            $this->raw($value ? 'true' : 'false');\n        } elseif (\\is_array($value)) {\n            $this->raw('[');\n            $first = true;\n            foreach ($value as $key => $value) {\n                if (!$first) {\n                    $this->raw(', ');\n                }\n                $first = false;\n                $this->repr($key);\n                $this->raw(' => ');\n                $this->repr($value);\n            }\n            $this->raw(']');\n        } else {\n            $this->string($value);\n        }\n\n        return $this;\n    }\n}\n"
        },
        {
          "name": "Expression.php",
          "type": "blob",
          "size": 0.599609375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\n/**\n * Represents an expression.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Expression\n{\n    public function __construct(\n        protected string $expression,\n    ) {\n    }\n\n    /**\n     * Gets the expression.\n     */\n    public function __toString(): string\n    {\n        return $this->expression;\n    }\n}\n"
        },
        {
          "name": "ExpressionFunction.php",
          "type": "blob",
          "size": 3.0576171875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\n/**\n * Represents a function that can be used in an expression.\n *\n * A function is defined by two PHP callables. The callables are used\n * by the language to compile and/or evaluate the function.\n *\n * The \"compiler\" function is used at compilation time and must return a\n * PHP representation of the function call (it receives the function\n * arguments as arguments).\n *\n * The \"evaluator\" function is used for expression evaluation and must return\n * the value of the function call based on the values defined for the\n * expression (it receives the values as a first argument and the function\n * arguments as remaining arguments).\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass ExpressionFunction\n{\n    private \\Closure $compiler;\n    private \\Closure $evaluator;\n\n    /**\n     * @param string   $name      The function name\n     * @param callable $compiler  A callable able to compile the function\n     * @param callable $evaluator A callable able to evaluate the function\n     */\n    public function __construct(\n        private string $name,\n        callable $compiler,\n        callable $evaluator,\n    ) {\n        $this->compiler = $compiler(...);\n        $this->evaluator = $evaluator(...);\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    public function getCompiler(): \\Closure\n    {\n        return $this->compiler;\n    }\n\n    public function getEvaluator(): \\Closure\n    {\n        return $this->evaluator;\n    }\n\n    /**\n     * Creates an ExpressionFunction from a PHP function name.\n     *\n     * @param string|null $expressionFunctionName The expression function name (default: same than the PHP function name)\n     *\n     * @throws \\InvalidArgumentException if given PHP function name does not exist\n     * @throws \\InvalidArgumentException if given PHP function name is in namespace\n     *                                   and expression function name is not defined\n     */\n    public static function fromPhp(string $phpFunctionName, ?string $expressionFunctionName = null): self\n    {\n        $phpFunctionName = ltrim($phpFunctionName, '\\\\');\n        if (!\\function_exists($phpFunctionName)) {\n            throw new \\InvalidArgumentException(\\sprintf('PHP function \"%s\" does not exist.', $phpFunctionName));\n        }\n\n        $parts = explode('\\\\', $phpFunctionName);\n        if (!$expressionFunctionName && \\count($parts) > 1) {\n            throw new \\InvalidArgumentException(\\sprintf('An expression function name must be defined when PHP function \"%s\" is namespaced.', $phpFunctionName));\n        }\n\n        $compiler = fn (...$args) => \\sprintf('\\%s(%s)', $phpFunctionName, implode(', ', $args));\n\n        $evaluator = fn ($p, ...$args) => $phpFunctionName(...$args);\n\n        return new self($expressionFunctionName ?: end($parts), $compiler, $evaluator);\n    }\n}\n"
        },
        {
          "name": "ExpressionFunctionProviderInterface.php",
          "type": "blob",
          "size": 0.4775390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\n/**\n * @author Fabien Potencier <fabien@symfony.com>\n */\ninterface ExpressionFunctionProviderInterface\n{\n    /**\n     * @return ExpressionFunction[]\n     */\n    public function getFunctions(): array;\n}\n"
        },
        {
          "name": "ExpressionLanguage.php",
          "type": "blob",
          "size": 5.9296875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\nuse Psr\\Cache\\CacheItemPoolInterface;\nuse Symfony\\Component\\Cache\\Adapter\\ArrayAdapter;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(ParsedExpression::class);\n\n/**\n * Allows to compile and evaluate expressions written in your own DSL.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass ExpressionLanguage\n{\n    private CacheItemPoolInterface $cache;\n    private Lexer $lexer;\n    private Parser $parser;\n    private Compiler $compiler;\n\n    protected array $functions = [];\n\n    /**\n     * @param iterable<ExpressionFunctionProviderInterface> $providers\n     */\n    public function __construct(?CacheItemPoolInterface $cache = null, iterable $providers = [])\n    {\n        $this->cache = $cache ?? new ArrayAdapter();\n        $this->registerFunctions();\n        foreach ($providers as $provider) {\n            $this->registerProvider($provider);\n        }\n    }\n\n    /**\n     * Compiles an expression source code.\n     */\n    public function compile(Expression|string $expression, array $names = []): string\n    {\n        return $this->getCompiler()->compile($this->parse($expression, $names)->getNodes())->getSource();\n    }\n\n    /**\n     * Evaluate an expression.\n     */\n    public function evaluate(Expression|string $expression, array $values = []): mixed\n    {\n        return $this->parse($expression, array_keys($values))->getNodes()->evaluate($this->functions, $values);\n    }\n\n    /**\n     * Parses an expression.\n     *\n     * @param int-mask-of<Parser::IGNORE_*> $flags\n     */\n    public function parse(Expression|string $expression, array $names, int $flags = 0): ParsedExpression\n    {\n        if ($expression instanceof ParsedExpression) {\n            return $expression;\n        }\n\n        asort($names);\n        $cacheKeyItems = [];\n\n        foreach ($names as $nameKey => $name) {\n            $cacheKeyItems[] = \\is_int($nameKey) ? $name : $nameKey.':'.$name;\n        }\n\n        $cacheItem = $this->cache->getItem(rawurlencode($expression.'//'.implode('|', $cacheKeyItems)));\n\n        if (null === $parsedExpression = $cacheItem->get()) {\n            $nodes = $this->getParser()->parse($this->getLexer()->tokenize((string) $expression), $names, $flags);\n            $parsedExpression = new ParsedExpression((string) $expression, $nodes);\n\n            $cacheItem->set($parsedExpression);\n            $this->cache->save($cacheItem);\n        }\n\n        return $parsedExpression;\n    }\n\n    /**\n     * Validates the syntax of an expression.\n     *\n     * @param array|null                    $names The list of acceptable variable names in the expression\n     * @param int-mask-of<Parser::IGNORE_*> $flags\n     *\n     * @throws SyntaxError When the passed expression is invalid\n     */\n    public function lint(Expression|string $expression, ?array $names, int $flags = 0): void\n    {\n        if (null === $names) {\n            trigger_deprecation('symfony/expression-language', '7.1', 'Passing \"null\" as the second argument of \"%s()\" is deprecated, pass \"%s\\Parser::IGNORE_UNKNOWN_VARIABLES\" instead as a third argument.', __METHOD__, __NAMESPACE__);\n\n            $flags |= Parser::IGNORE_UNKNOWN_VARIABLES;\n            $names = [];\n        }\n\n        if ($expression instanceof ParsedExpression) {\n            return;\n        }\n\n        $this->getParser()->lint($this->getLexer()->tokenize((string) $expression), $names, $flags);\n    }\n\n    /**\n     * Registers a function.\n     *\n     * @param callable $compiler  A callable able to compile the function\n     * @param callable $evaluator A callable able to evaluate the function\n     *\n     * @throws \\LogicException when registering a function after calling evaluate(), compile() or parse()\n     *\n     * @see ExpressionFunction\n     */\n    public function register(string $name, callable $compiler, callable $evaluator): void\n    {\n        if (isset($this->parser)) {\n            throw new \\LogicException('Registering functions after calling evaluate(), compile() or parse() is not supported.');\n        }\n\n        $this->functions[$name] = ['compiler' => $compiler, 'evaluator' => $evaluator];\n    }\n\n    public function addFunction(ExpressionFunction $function): void\n    {\n        $this->register($function->getName(), $function->getCompiler(), $function->getEvaluator());\n    }\n\n    public function registerProvider(ExpressionFunctionProviderInterface $provider): void\n    {\n        foreach ($provider->getFunctions() as $function) {\n            $this->addFunction($function);\n        }\n    }\n\n    /**\n     * @return void\n     */\n    protected function registerFunctions()\n    {\n        $basicPhpFunctions = ['constant', 'min', 'max'];\n        foreach ($basicPhpFunctions as $function) {\n            $this->addFunction(ExpressionFunction::fromPhp($function));\n        }\n\n        $this->addFunction(new ExpressionFunction('enum',\n            static fn ($str): string => \\sprintf(\"(\\constant(\\$v = (%s))) instanceof \\UnitEnum ? \\constant(\\$v) : throw new \\TypeError(\\sprintf('The string \\\"%%s\\\" is not the name of a valid enum case.', \\$v))\", $str),\n            static function ($arguments, $str): \\UnitEnum {\n                $value = \\constant($str);\n\n                if (!$value instanceof \\UnitEnum) {\n                    throw new \\TypeError(\\sprintf('The string \"%s\" is not the name of a valid enum case.', $str));\n                }\n\n                return $value;\n            }\n        ));\n    }\n\n    private function getLexer(): Lexer\n    {\n        return $this->lexer ??= new Lexer();\n    }\n\n    private function getParser(): Parser\n    {\n        return $this->parser ??= new Parser($this->functions);\n    }\n\n    private function getCompiler(): Compiler\n    {\n        $this->compiler ??= new Compiler($this->functions);\n\n        return $this->compiler->reset();\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Lexer.php",
          "type": "blob",
          "size": 4.697265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\n/**\n * Lexes an expression.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Lexer\n{\n    /**\n     * Tokenizes an expression.\n     *\n     * @throws SyntaxError\n     */\n    public function tokenize(string $expression): TokenStream\n    {\n        $expression = str_replace([\"\\r\", \"\\n\", \"\\t\", \"\\v\", \"\\f\"], ' ', $expression);\n        $cursor = 0;\n        $tokens = [];\n        $brackets = [];\n        $end = \\strlen($expression);\n\n        while ($cursor < $end) {\n            if (' ' == $expression[$cursor]) {\n                ++$cursor;\n\n                continue;\n            }\n\n            if (preg_match('/\n                (?(DEFINE)(?P<LNUM>[0-9]+(_[0-9]+)*))\n                (?:\\.(?&LNUM)|(?&LNUM)(?:\\.(?!\\.)(?&LNUM)?)?)(?:[eE][+-]?(?&LNUM))?/Ax',\n                $expression, $match, 0, $cursor)\n            ) {\n                // numbers\n                $tokens[] = new Token(Token::NUMBER_TYPE, 0 + str_replace('_', '', $match[0]), $cursor + 1);\n                $cursor += \\strlen($match[0]);\n            } elseif (str_contains('([{', $expression[$cursor])) {\n                // opening bracket\n                $brackets[] = [$expression[$cursor], $cursor];\n\n                $tokens[] = new Token(Token::PUNCTUATION_TYPE, $expression[$cursor], $cursor + 1);\n                ++$cursor;\n            } elseif (str_contains(')]}', $expression[$cursor])) {\n                // closing bracket\n                if (!$brackets) {\n                    throw new SyntaxError(\\sprintf('Unexpected \"%s\".', $expression[$cursor]), $cursor, $expression);\n                }\n\n                [$expect, $cur] = array_pop($brackets);\n                if ($expression[$cursor] != strtr($expect, '([{', ')]}')) {\n                    throw new SyntaxError(\\sprintf('Unclosed \"%s\".', $expect), $cur, $expression);\n                }\n\n                $tokens[] = new Token(Token::PUNCTUATION_TYPE, $expression[$cursor], $cursor + 1);\n                ++$cursor;\n            } elseif (preg_match('/\"([^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*)\"|\\'([^\\'\\\\\\\\]*(?:\\\\\\\\.[^\\'\\\\\\\\]*)*)\\'/As', $expression, $match, 0, $cursor)) {\n                // strings\n                $tokens[] = new Token(Token::STRING_TYPE, stripcslashes(substr($match[0], 1, -1)), $cursor + 1);\n                $cursor += \\strlen($match[0]);\n            } elseif (preg_match('{/\\*.*?\\*/}A', $expression, $match, 0, $cursor)) {\n                // comments\n                $cursor += \\strlen($match[0]);\n            } elseif (preg_match('/(?<=^|[\\s(])starts with(?=[\\s(])|(?<=^|[\\s(])ends with(?=[\\s(])|(?<=^|[\\s(])contains(?=[\\s(])|(?<=^|[\\s(])matches(?=[\\s(])|(?<=^|[\\s(])not in(?=[\\s(])|(?<=^|[\\s(])not(?=[\\s(])|(?<=^|[\\s(])xor(?=[\\s(])|(?<=^|[\\s(])and(?=[\\s(])|\\=\\=\\=|\\!\\=\\=|(?<=^|[\\s(])or(?=[\\s(])|\\|\\||&&|\\=\\=|\\!\\=|\\>\\=|\\<\\=|(?<=^|[\\s(])in(?=[\\s(])|\\.\\.|\\*\\*|\\<\\<|\\>\\>|\\!|\\||\\^|&|\\<|\\>|\\+|\\-|~|\\*|\\/|%/A', $expression, $match, 0, $cursor)) {\n                // operators\n                $tokens[] = new Token(Token::OPERATOR_TYPE, $match[0], $cursor + 1);\n                $cursor += \\strlen($match[0]);\n            } elseif ('?' === $expression[$cursor] && '.' === ($expression[$cursor + 1] ?? '')) {\n                // null-safe\n                $tokens[] = new Token(Token::PUNCTUATION_TYPE, '?.', ++$cursor);\n                ++$cursor;\n            } elseif ('?' === $expression[$cursor] && '?' === ($expression[$cursor + 1] ?? '')) {\n                // null-coalescing\n                $tokens[] = new Token(Token::PUNCTUATION_TYPE, '??', ++$cursor);\n                ++$cursor;\n            } elseif (str_contains('.,?:', $expression[$cursor])) {\n                // punctuation\n                $tokens[] = new Token(Token::PUNCTUATION_TYPE, $expression[$cursor], $cursor + 1);\n                ++$cursor;\n            } elseif (preg_match('/[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*/A', $expression, $match, 0, $cursor)) {\n                // names\n                $tokens[] = new Token(Token::NAME_TYPE, $match[0], $cursor + 1);\n                $cursor += \\strlen($match[0]);\n            } else {\n                // unlexable\n                throw new SyntaxError(\\sprintf('Unexpected character \"%s\".', $expression[$cursor]), $cursor, $expression);\n            }\n        }\n\n        $tokens[] = new Token(Token::EOF_TYPE, null, $cursor + 1);\n\n        if ($brackets) {\n            [$expect, $cur] = array_pop($brackets);\n            throw new SyntaxError(\\sprintf('Unclosed \"%s\".', $expect), $cur, $expression);\n        }\n\n        return new TokenStream($tokens, $expression);\n    }\n}\n"
        },
        {
          "name": "Node",
          "type": "tree",
          "content": null
        },
        {
          "name": "ParsedExpression.php",
          "type": "blob",
          "size": 0.6982421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\nuse Symfony\\Component\\ExpressionLanguage\\Node\\Node;\n\n/**\n * Represents an already parsed expression.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass ParsedExpression extends Expression\n{\n    public function __construct(\n        string $expression,\n        private Node $nodes,\n    ) {\n        parent::__construct($expression);\n    }\n\n    public function getNodes(): Node\n    {\n        return $this->nodes;\n    }\n}\n"
        },
        {
          "name": "Parser.php",
          "type": "blob",
          "size": 18.142578125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\n/**\n * Parses a token stream.\n *\n * This parser implements a \"Precedence climbing\" algorithm.\n *\n * @see http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm\n * @see http://en.wikipedia.org/wiki/Operator-precedence_parser\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Parser\n{\n    public const OPERATOR_LEFT = 1;\n    public const OPERATOR_RIGHT = 2;\n\n    public const IGNORE_UNKNOWN_VARIABLES = 1;\n    public const IGNORE_UNKNOWN_FUNCTIONS = 2;\n\n    private TokenStream $stream;\n    private array $unaryOperators;\n    private array $binaryOperators;\n    private array $names;\n    private int $flags = 0;\n\n    public function __construct(\n        private array $functions,\n    ) {\n        $this->unaryOperators = [\n            'not' => ['precedence' => 50],\n            '!' => ['precedence' => 50],\n            '-' => ['precedence' => 500],\n            '+' => ['precedence' => 500],\n            '~' => ['precedence' => 500],\n        ];\n        $this->binaryOperators = [\n            'or' => ['precedence' => 10, 'associativity' => self::OPERATOR_LEFT],\n            '||' => ['precedence' => 10, 'associativity' => self::OPERATOR_LEFT],\n            'xor' => ['precedence' => 12, 'associativity' => self::OPERATOR_LEFT],\n            'and' => ['precedence' => 15, 'associativity' => self::OPERATOR_LEFT],\n            '&&' => ['precedence' => 15, 'associativity' => self::OPERATOR_LEFT],\n            '|' => ['precedence' => 16, 'associativity' => self::OPERATOR_LEFT],\n            '^' => ['precedence' => 17, 'associativity' => self::OPERATOR_LEFT],\n            '&' => ['precedence' => 18, 'associativity' => self::OPERATOR_LEFT],\n            '==' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            '===' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            '!=' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            '!==' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            '<' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            '>' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            '>=' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            '<=' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            'not in' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            'in' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            'contains' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            'starts with' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            'ends with' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            'matches' => ['precedence' => 20, 'associativity' => self::OPERATOR_LEFT],\n            '..' => ['precedence' => 25, 'associativity' => self::OPERATOR_LEFT],\n            '<<' => ['precedence' => 25, 'associativity' => self::OPERATOR_LEFT],\n            '>>' => ['precedence' => 25, 'associativity' => self::OPERATOR_LEFT],\n            '+' => ['precedence' => 30, 'associativity' => self::OPERATOR_LEFT],\n            '-' => ['precedence' => 30, 'associativity' => self::OPERATOR_LEFT],\n            '~' => ['precedence' => 40, 'associativity' => self::OPERATOR_LEFT],\n            '*' => ['precedence' => 60, 'associativity' => self::OPERATOR_LEFT],\n            '/' => ['precedence' => 60, 'associativity' => self::OPERATOR_LEFT],\n            '%' => ['precedence' => 60, 'associativity' => self::OPERATOR_LEFT],\n            '**' => ['precedence' => 200, 'associativity' => self::OPERATOR_RIGHT],\n        ];\n    }\n\n    /**\n     * Converts a token stream to a node tree.\n     *\n     * The valid names is an array where the values\n     * are the names that the user can use in an expression.\n     *\n     * If the variable name in the compiled PHP code must be\n     * different, define it as the key.\n     *\n     * For instance, ['this' => 'container'] means that the\n     * variable 'container' can be used in the expression\n     * but the compiled code will use 'this'.\n     *\n     * @param int-mask-of<Parser::IGNORE_*> $flags\n     *\n     * @throws SyntaxError\n     */\n    public function parse(TokenStream $stream, array $names = [], int $flags = 0): Node\\Node\n    {\n        return $this->doParse($stream, $names, $flags);\n    }\n\n    /**\n     * Validates the syntax of an expression.\n     *\n     * The syntax of the passed expression will be checked, but not parsed.\n     * If you want to skip checking dynamic variable names, pass `Parser::IGNORE_UNKNOWN_VARIABLES` instead of the array.\n     *\n     * @param int-mask-of<Parser::IGNORE_*> $flags\n     *\n     * @throws SyntaxError When the passed expression is invalid\n     */\n    public function lint(TokenStream $stream, ?array $names = [], int $flags = 0): void\n    {\n        if (null === $names) {\n            trigger_deprecation('symfony/expression-language', '7.1', 'Passing \"null\" as the second argument of \"%s()\" is deprecated, pass \"%s::IGNORE_UNKNOWN_VARIABLES\" instead as a third argument.', __METHOD__, __CLASS__);\n\n            $flags |= self::IGNORE_UNKNOWN_VARIABLES;\n            $names = [];\n        }\n\n        $this->doParse($stream, $names, $flags);\n    }\n\n    /**\n     * @param int-mask-of<Parser::IGNORE_*> $flags\n     *\n     * @throws SyntaxError\n     */\n    private function doParse(TokenStream $stream, array $names, int $flags): Node\\Node\n    {\n        $this->flags = $flags;\n        $this->stream = $stream;\n        $this->names = $names;\n\n        $node = $this->parseExpression();\n        if (!$stream->isEOF()) {\n            throw new SyntaxError(\\sprintf('Unexpected token \"%s\" of value \"%s\".', $stream->current->type, $stream->current->value), $stream->current->cursor, $stream->getExpression());\n        }\n\n        unset($this->stream, $this->names);\n\n        return $node;\n    }\n\n    public function parseExpression(int $precedence = 0): Node\\Node\n    {\n        $expr = $this->getPrimary();\n        $token = $this->stream->current;\n        while ($token->test(Token::OPERATOR_TYPE) && isset($this->binaryOperators[$token->value]) && $this->binaryOperators[$token->value]['precedence'] >= $precedence) {\n            $op = $this->binaryOperators[$token->value];\n            $this->stream->next();\n\n            $expr1 = $this->parseExpression(self::OPERATOR_LEFT === $op['associativity'] ? $op['precedence'] + 1 : $op['precedence']);\n            $expr = new Node\\BinaryNode($token->value, $expr, $expr1);\n\n            $token = $this->stream->current;\n        }\n\n        if (0 === $precedence) {\n            return $this->parseConditionalExpression($expr);\n        }\n\n        return $expr;\n    }\n\n    protected function getPrimary(): Node\\Node\n    {\n        $token = $this->stream->current;\n\n        if ($token->test(Token::OPERATOR_TYPE) && isset($this->unaryOperators[$token->value])) {\n            $operator = $this->unaryOperators[$token->value];\n            $this->stream->next();\n            $expr = $this->parseExpression($operator['precedence']);\n\n            return $this->parsePostfixExpression(new Node\\UnaryNode($token->value, $expr));\n        }\n\n        if ($token->test(Token::PUNCTUATION_TYPE, '(')) {\n            $this->stream->next();\n            $expr = $this->parseExpression();\n            $this->stream->expect(Token::PUNCTUATION_TYPE, ')', 'An opened parenthesis is not properly closed');\n\n            return $this->parsePostfixExpression($expr);\n        }\n\n        return $this->parsePrimaryExpression();\n    }\n\n    protected function parseConditionalExpression(Node\\Node $expr): Node\\Node\n    {\n        while ($this->stream->current->test(Token::PUNCTUATION_TYPE, '??')) {\n            $this->stream->next();\n            $expr2 = $this->parseExpression();\n\n            $expr = new Node\\NullCoalesceNode($expr, $expr2);\n        }\n\n        while ($this->stream->current->test(Token::PUNCTUATION_TYPE, '?')) {\n            $this->stream->next();\n            if (!$this->stream->current->test(Token::PUNCTUATION_TYPE, ':')) {\n                $expr2 = $this->parseExpression();\n                if ($this->stream->current->test(Token::PUNCTUATION_TYPE, ':')) {\n                    $this->stream->next();\n                    $expr3 = $this->parseExpression();\n                } else {\n                    $expr3 = new Node\\ConstantNode(null);\n                }\n            } else {\n                $this->stream->next();\n                $expr2 = $expr;\n                $expr3 = $this->parseExpression();\n            }\n\n            $expr = new Node\\ConditionalNode($expr, $expr2, $expr3);\n        }\n\n        return $expr;\n    }\n\n    public function parsePrimaryExpression(): Node\\Node\n    {\n        $token = $this->stream->current;\n        switch ($token->type) {\n            case Token::NAME_TYPE:\n                $this->stream->next();\n                switch ($token->value) {\n                    case 'true':\n                    case 'TRUE':\n                        return new Node\\ConstantNode(true);\n\n                    case 'false':\n                    case 'FALSE':\n                        return new Node\\ConstantNode(false);\n\n                    case 'null':\n                    case 'NULL':\n                        return new Node\\ConstantNode(null);\n\n                    default:\n                        if ('(' === $this->stream->current->value) {\n                            if (!($this->flags & self::IGNORE_UNKNOWN_FUNCTIONS) && false === isset($this->functions[$token->value])) {\n                                throw new SyntaxError(\\sprintf('The function \"%s\" does not exist.', $token->value), $token->cursor, $this->stream->getExpression(), $token->value, array_keys($this->functions));\n                            }\n\n                            $node = new Node\\FunctionNode($token->value, $this->parseArguments());\n                        } else {\n                            if (!($this->flags & self::IGNORE_UNKNOWN_VARIABLES)) {\n                                if (!\\in_array($token->value, $this->names, true)) {\n                                    if ($this->stream->current->test(Token::PUNCTUATION_TYPE, '??')) {\n                                        return new Node\\NullCoalescedNameNode($token->value);\n                                    }\n\n                                    throw new SyntaxError(\\sprintf('Variable \"%s\" is not valid.', $token->value), $token->cursor, $this->stream->getExpression(), $token->value, $this->names);\n                                }\n\n                                // is the name used in the compiled code different\n                                // from the name used in the expression?\n                                if (\\is_int($name = array_search($token->value, $this->names))) {\n                                    $name = $token->value;\n                                }\n                            } else {\n                                $name = $token->value;\n                            }\n\n                            $node = new Node\\NameNode($name);\n                        }\n                }\n                break;\n\n            case Token::NUMBER_TYPE:\n            case Token::STRING_TYPE:\n                $this->stream->next();\n\n                return new Node\\ConstantNode($token->value);\n\n            default:\n                if ($token->test(Token::PUNCTUATION_TYPE, '[')) {\n                    $node = $this->parseArrayExpression();\n                } elseif ($token->test(Token::PUNCTUATION_TYPE, '{')) {\n                    $node = $this->parseHashExpression();\n                } else {\n                    throw new SyntaxError(\\sprintf('Unexpected token \"%s\" of value \"%s\".', $token->type, $token->value), $token->cursor, $this->stream->getExpression());\n                }\n        }\n\n        return $this->parsePostfixExpression($node);\n    }\n\n    public function parseArrayExpression(): Node\\ArrayNode\n    {\n        $this->stream->expect(Token::PUNCTUATION_TYPE, '[', 'An array element was expected');\n\n        $node = new Node\\ArrayNode();\n        $first = true;\n        while (!$this->stream->current->test(Token::PUNCTUATION_TYPE, ']')) {\n            if (!$first) {\n                $this->stream->expect(Token::PUNCTUATION_TYPE, ',', 'An array element must be followed by a comma');\n\n                // trailing ,?\n                if ($this->stream->current->test(Token::PUNCTUATION_TYPE, ']')) {\n                    break;\n                }\n            }\n            $first = false;\n\n            $node->addElement($this->parseExpression());\n        }\n        $this->stream->expect(Token::PUNCTUATION_TYPE, ']', 'An opened array is not properly closed');\n\n        return $node;\n    }\n\n    public function parseHashExpression(): Node\\ArrayNode\n    {\n        $this->stream->expect(Token::PUNCTUATION_TYPE, '{', 'A hash element was expected');\n\n        $node = new Node\\ArrayNode();\n        $first = true;\n        while (!$this->stream->current->test(Token::PUNCTUATION_TYPE, '}')) {\n            if (!$first) {\n                $this->stream->expect(Token::PUNCTUATION_TYPE, ',', 'A hash value must be followed by a comma');\n\n                // trailing ,?\n                if ($this->stream->current->test(Token::PUNCTUATION_TYPE, '}')) {\n                    break;\n                }\n            }\n            $first = false;\n\n            // a hash key can be:\n            //\n            //  * a number -- 12\n            //  * a string -- 'a'\n            //  * a name, which is equivalent to a string -- a\n            //  * an expression, which must be enclosed in parentheses -- (1 + 2)\n            if ($this->stream->current->test(Token::STRING_TYPE) || $this->stream->current->test(Token::NAME_TYPE) || $this->stream->current->test(Token::NUMBER_TYPE)) {\n                $key = new Node\\ConstantNode($this->stream->current->value);\n                $this->stream->next();\n            } elseif ($this->stream->current->test(Token::PUNCTUATION_TYPE, '(')) {\n                $key = $this->parseExpression();\n            } else {\n                $current = $this->stream->current;\n\n                throw new SyntaxError(\\sprintf('A hash key must be a quoted string, a number, a name, or an expression enclosed in parentheses (unexpected token \"%s\" of value \"%s\".', $current->type, $current->value), $current->cursor, $this->stream->getExpression());\n            }\n\n            $this->stream->expect(Token::PUNCTUATION_TYPE, ':', 'A hash key must be followed by a colon (:)');\n            $value = $this->parseExpression();\n\n            $node->addElement($value, $key);\n        }\n        $this->stream->expect(Token::PUNCTUATION_TYPE, '}', 'An opened hash is not properly closed');\n\n        return $node;\n    }\n\n    public function parsePostfixExpression(Node\\Node $node): Node\\GetAttrNode|Node\\Node\n    {\n        $token = $this->stream->current;\n        while (Token::PUNCTUATION_TYPE == $token->type) {\n            if ('.' === $token->value || '?.' === $token->value) {\n                $isNullSafe = '?.' === $token->value;\n                $this->stream->next();\n                $token = $this->stream->current;\n                $this->stream->next();\n\n                if (\n                    Token::NAME_TYPE !== $token->type\n                    // Operators like \"not\" and \"matches\" are valid method or property names,\n                    //\n                    // In other words, besides NAME_TYPE, OPERATOR_TYPE could also be parsed as a property or method.\n                    // This is because operators are processed by the lexer prior to names. So \"not\" in \"foo.not()\" or \"matches\" in \"foo.matches\" will be recognized as an operator first.\n                    // But in fact, \"not\" and \"matches\" in such expressions shall be parsed as method or property names.\n                    //\n                    // And this ONLY works if the operator consists of valid characters for a property or method name.\n                    //\n                    // Other types, such as STRING_TYPE and NUMBER_TYPE, can't be parsed as property nor method names.\n                    //\n                    // As a result, if $token is NOT an operator OR $token->value is NOT a valid property or method name, an exception shall be thrown.\n                    && (Token::OPERATOR_TYPE !== $token->type || !preg_match('/[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*/A', $token->value))\n                ) {\n                    throw new SyntaxError('Expected name.', $token->cursor, $this->stream->getExpression());\n                }\n\n                $arg = new Node\\ConstantNode($token->value, true, $isNullSafe);\n\n                $arguments = new Node\\ArgumentsNode();\n                if ($this->stream->current->test(Token::PUNCTUATION_TYPE, '(')) {\n                    $type = Node\\GetAttrNode::METHOD_CALL;\n                    foreach ($this->parseArguments()->nodes as $n) {\n                        $arguments->addElement($n);\n                    }\n                } else {\n                    $type = Node\\GetAttrNode::PROPERTY_CALL;\n                }\n\n                $node = new Node\\GetAttrNode($node, $arg, $arguments, $type);\n            } elseif ('[' === $token->value) {\n                $this->stream->next();\n                $arg = $this->parseExpression();\n                $this->stream->expect(Token::PUNCTUATION_TYPE, ']');\n\n                $node = new Node\\GetAttrNode($node, $arg, new Node\\ArgumentsNode(), Node\\GetAttrNode::ARRAY_CALL);\n            } else {\n                break;\n            }\n\n            $token = $this->stream->current;\n        }\n\n        return $node;\n    }\n\n    /**\n     * Parses arguments.\n     */\n    public function parseArguments(): Node\\Node\n    {\n        $args = [];\n        $this->stream->expect(Token::PUNCTUATION_TYPE, '(', 'A list of arguments must begin with an opening parenthesis');\n        while (!$this->stream->current->test(Token::PUNCTUATION_TYPE, ')')) {\n            if ($args) {\n                $this->stream->expect(Token::PUNCTUATION_TYPE, ',', 'Arguments must be separated by a comma');\n            }\n\n            $args[] = $this->parseExpression();\n        }\n        $this->stream->expect(Token::PUNCTUATION_TYPE, ')', 'A list of arguments must be closed by a parenthesis');\n\n        return new Node\\Node($args);\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.630859375,
          "content": "ExpressionLanguage Component\n============================\n\nThe ExpressionLanguage component provides an engine that can compile and\nevaluate expressions. An expression is a one-liner that returns a value\n(mostly, but not limited to, Booleans).\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/expression_language/introduction.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "SerializedParsedExpression.php",
          "type": "blob",
          "size": 0.87109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\nuse Symfony\\Component\\ExpressionLanguage\\Node\\Node;\n\n/**\n * Represents an already serialized parsed expression.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass SerializedParsedExpression extends ParsedExpression\n{\n    /**\n     * @param string $expression An expression\n     * @param string $nodes      The serialized nodes for the expression\n     */\n    public function __construct(\n        string $expression,\n        private string $nodes,\n    ) {\n        $this->expression = $expression;\n    }\n\n    public function getNodes(): Node\n    {\n        return unserialize($this->nodes);\n    }\n}\n"
        },
        {
          "name": "SyntaxError.php",
          "type": "blob",
          "size": 1.2275390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\nclass SyntaxError extends \\LogicException\n{\n    public function __construct(string $message, int $cursor = 0, string $expression = '', ?string $subject = null, ?array $proposals = null)\n    {\n        $message = \\sprintf('%s around position %d', rtrim($message, '.'), $cursor);\n        if ($expression) {\n            $message = \\sprintf('%s for expression `%s`', $message, $expression);\n        }\n        $message .= '.';\n\n        if (null !== $subject && null !== $proposals) {\n            $minScore = \\INF;\n            foreach ($proposals as $proposal) {\n                $distance = levenshtein($subject, $proposal);\n                if ($distance < $minScore) {\n                    $guess = $proposal;\n                    $minScore = $distance;\n                }\n            }\n\n            if (isset($guess) && $minScore < 3) {\n                $message .= \\sprintf(' Did you mean \"%s\"?', $guess);\n            }\n        }\n\n        parent::__construct($message);\n    }\n}\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "Token.php",
          "type": "blob",
          "size": 1.3447265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\n/**\n * Represents a token.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Token\n{\n    public const EOF_TYPE = 'end of expression';\n    public const NAME_TYPE = 'name';\n    public const NUMBER_TYPE = 'number';\n    public const STRING_TYPE = 'string';\n    public const OPERATOR_TYPE = 'operator';\n    public const PUNCTUATION_TYPE = 'punctuation';\n\n    /**\n     * @param self::*_TYPE $type\n     * @param int|null     $cursor The cursor position in the source\n     */\n    public function __construct(\n        public string $type,\n        public string|int|float|null $value,\n        public ?int $cursor,\n    ) {\n    }\n\n    /**\n     * Returns a string representation of the token.\n     */\n    public function __toString(): string\n    {\n        return \\sprintf('%3d %-11s %s', $this->cursor, strtoupper($this->type), $this->value);\n    }\n\n    /**\n     * Tests the current token for a type and/or a value.\n     */\n    public function test(string $type, ?string $value = null): bool\n    {\n        return $this->type === $type && (null === $value || $this->value == $value);\n    }\n}\n"
        },
        {
          "name": "TokenStream.php",
          "type": "blob",
          "size": 1.9736328125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ExpressionLanguage;\n\n/**\n * Represents a token stream.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass TokenStream\n{\n    public Token $current;\n\n    private int $position = 0;\n\n    public function __construct(\n        private array $tokens,\n        private string $expression = '',\n    ) {\n        $this->current = $tokens[0];\n    }\n\n    /**\n     * Returns a string representation of the token stream.\n     */\n    public function __toString(): string\n    {\n        return implode(\"\\n\", $this->tokens);\n    }\n\n    /**\n     * Sets the pointer to the next token and returns the old one.\n     */\n    public function next(): void\n    {\n        ++$this->position;\n\n        if (!isset($this->tokens[$this->position])) {\n            throw new SyntaxError('Unexpected end of expression.', $this->current->cursor, $this->expression);\n        }\n\n        $this->current = $this->tokens[$this->position];\n    }\n\n    /**\n     * @param string|null $message The syntax error message\n     */\n    public function expect(string $type, ?string $value = null, ?string $message = null): void\n    {\n        $token = $this->current;\n        if (!$token->test($type, $value)) {\n            throw new SyntaxError(\\sprintf('%sUnexpected token \"%s\" of value \"%s\" (\"%s\" expected%s).', $message ? $message.'. ' : '', $token->type, $token->value, $type, $value ? \\sprintf(' with value \"%s\"', $value) : ''), $token->cursor, $this->expression);\n        }\n        $this->next();\n    }\n\n    /**\n     * Checks if end of stream was reached.\n     */\n    public function isEOF(): bool\n    {\n        return Token::EOF_TYPE === $this->current->type;\n    }\n\n    /**\n     * @internal\n     */\n    public function getExpression(): string\n    {\n        return $this->expression;\n    }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.837890625,
          "content": "{\n    \"name\": \"symfony/expression-language\",\n    \"type\": \"library\",\n    \"description\": \"Provides an engine that can compile and evaluate expressions\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/cache\": \"^6.4|^7.0\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3\",\n        \"symfony/service-contracts\": \"^2.5|^3\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\ExpressionLanguage\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.8095703125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony ExpressionLanguage Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}