{
  "metadata": {
    "timestamp": 1736712160326,
    "page": 803,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "staudenmeir/laravel-adjacency-list",
      "stars": 1395,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".docker",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.408203125,
          "content": "/.docker                export-ignore\n/.github                export-ignore\n/tests                  export-ignore\n/types                  export-ignore\n.gitattributes          export-ignore\n.gitignore              export-ignore\ndocker-compose.ci.yml   export-ignore\ndocker-compose.yml      export-ignore\nphpstan.neon.dist       export-ignore\nphpstan.types.neon.dist export-ignore\nphpunit.xml.dist        export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0634765625,
          "content": "/.idea\n/.phpunit.cache\n/vendor\n.php-cs-fixer.cache\ncomposer.lock\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "MIT License\n\nCopyright (c) 2019 Jonas Staudenmeir\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.5302734375,
          "content": "# Laravel Adjacency List\n\n[![CI](https://github.com/staudenmeir/laravel-adjacency-list/actions/workflows/ci.yml/badge.svg)](https://github.com/staudenmeir/laravel-adjacency-list/actions/workflows/ci.yml?query=branch%3Amain)\n[![Code Coverage](https://codecov.io/gh/staudenmeir/laravel-adjacency-list/graph/badge.svg?token=VhZ3oBh1YE)](https://codecov.io/gh/staudenmeir/laravel-adjacency-list)\n[![PHPStan](https://img.shields.io/badge/PHPStan-level%209-brightgreen.svg?style=flat)](https://github.com/staudenmeir/laravel-adjacency-list/actions/workflows/static-analysis.yml?query=branch%3Amain)\n[![Latest Stable Version](https://poser.pugx.org/staudenmeir/laravel-adjacency-list/v/stable)](https://packagist.org/packages/staudenmeir/laravel-adjacency-list)\n[![Total Downloads](https://poser.pugx.org/staudenmeir/laravel-adjacency-list/downloads)](https://packagist.org/packages/staudenmeir/laravel-adjacency-list/stats)\n[![License](https://poser.pugx.org/staudenmeir/laravel-adjacency-list/license)](https://github.com/staudenmeir/laravel-adjacency-list/blob/main/LICENSE)\n\nThis Laravel Eloquent extension provides recursive relationships for [trees](#trees-one-parent-per-node-one-to-many) and\n[graphs](#graphs-multiple-parents-per-node-many-to-many) using common table expressions (CTE).\n\n## Compatibility\n\n- MySQL 8.0+\n- MariaDB 10.2+\n- PostgreSQL 9.4+\n- SQLite 3.8.3+\n- SQL Server 2008+\n- SingleStore 8.1+ (only [trees](#trees-one-parent-per-node-one-to-many))\n- Firebird\n\n## Installation\n\n    composer require staudenmeir/laravel-adjacency-list:\"^1.0\"\n\nUse this command if you are in PowerShell on Windows (e.g. in VS Code):\n\n    composer require staudenmeir/laravel-adjacency-list:\"^^^^1.0\"\n\n## Versions\n\n| Laravel | Package |\n|:--------|:--------|\n| 11.x    | 1.21    |\n| 10.x    | 1.13    |\n| 9.x     | 1.12    |\n| 8.x     | 1.9     |\n| 7.x     | 1.5     |\n| 6.x     | 1.3     |\n| 5.8     | 1.1     |\n| 5.5â€“5.7 | 1.0     |\n\n## Usage\n\nThe package offers recursive relationships for traversing two types of data structures:\n\n- [Trees: One Parent per Node (One-to-Many)](#trees-one-parent-per-node-one-to-many)\n- [Graphs: Multiple Parents per Node (Many-to-Many)](#graphs-multiple-parents-per-node-many-to-many)\n\n### Trees: One Parent per Node (One-to-Many)\n\nUse the package to traverse a tree structure with one parent per node. Use cases might be recursive categories, a page\nhierarchy or nested comments.\n\nSupports Laravel 5.5+.\n\n- [Getting Started](#getting-started)\n- [Included Relationships](#included-relationships)\n- [Trees](#trees)\n- [Filters](#filters)\n- [Order](#order)\n- [Depth](#depth)\n- [Path](#path)\n- [Custom Paths](#custom-paths)\n- [Nested Results](#nested-results)\n- [Initial & Recursive Query Constraints](#initial--recursive-query-constraints)\n- [Additional Methods](#additional-methods)\n- [Custom Relationships](#custom-relationships)\n- [Deep Relationship Concatenation](#deep-relationship-concatenation)\n- [Known Issues](#known-issues)\n\n#### Getting Started\n\nConsider the following table schema for hierarchical data in trees:\n\n```php\nSchema::create('users', function (Blueprint $table) {\n    $table->id();\n    $table->unsignedBigInteger('parent_id')->nullable();\n});\n```\n\nUse the `HasRecursiveRelationships` trait in your model to work with recursive relationships:\n\n```php\nclass User extends Model\n{\n    use \\Staudenmeir\\LaravelAdjacencyList\\Eloquent\\HasRecursiveRelationships;\n}\n```\n\nBy default, the trait expects a parent key named `parent_id`. You can customize it by overriding `getParentKeyName()`:\n\n```php\nclass User extends Model\n{ \n    public function getParentKeyName()\n    {\n        return 'parent_id';\n    }\n}\n```\n\nBy default, the trait uses the model's primary key as the local key. You can customize it by\noverriding `getLocalKeyName()`:\n\n```php\nclass User extends Model\n{\n    public function getLocalKeyName()\n    {\n        return 'id';\n    }\n}\n```\n\n#### Included Relationships\n\nThe trait provides various relationships:\n\n- `ancestors()`: The model's recursive parents.\n- `ancestorsAndSelf()`: The model's recursive parents and itself.\n- `bloodline()`: The model's ancestors, descendants and itself.\n- `children()`: The model's direct children.\n- `childrenAndSelf()`: The model's direct children and itself.\n- `descendants()`: The model's recursive children.\n- `descendantsAndSelf()`: The model's recursive children and itself.\n- `parent()`: The model's direct parent.\n- `parentAndSelf()`: The model's direct parent and itself.\n- `rootAncestor()`: The model's topmost parent.\n- `rootAncestorOrSelf()`: The model's topmost parent or itself.\n- `siblings()`: The parent's other children.\n- `siblingsAndSelf()`: All the parent's children.\n\n```php\n$ancestors = User::find($id)->ancestors;\n\n$users = User::with('descendants')->get();\n\n$users = User::whereHas('siblings', function ($query) {\n    $query->where('name', 'John');\n})->get();\n\n$total = User::find($id)->descendants()->count();\n\nUser::find($id)->descendants()->update(['active' => false]);\n\nUser::find($id)->siblings()->delete();\n```\n\n#### Trees\n\nThe trait provides the `tree()` query scope to get all models, beginning at the root(s):\n\n```php\n$tree = User::tree()->get();\n```\n\n`treeOf()` allows you to query trees with custom constraints for the root model(s). Consider a table with multiple\nseparate lists:\n\n```php\n$constraint = function ($query) {\n    $query->whereNull('parent_id')->where('list_id', 1);\n};\n\n$tree = User::treeOf($constraint)->get();\n```\n\nYou can also pass a maximum depth:\n\n```php\n$tree = User::tree(3)->get();\n\n$tree = User::treeOf($constraint, 3)->get();\n```\n\nYou can also chaperone tree relationships to load `ancestors` and `parent` relationships already present in the tree to\n(potentially) reduce N+1 queries:\n\n```php\n$users = User::tree(3)->get();\n\n$users->loadTreeRelationships();\n```\n\nOr with `toTree()`:\n\n```php\n$users = User::tree(1)->get();\n\n$tree = $users->loadTreeRelationships()->toTree();\n```\n\n#### Filters\n\nThe trait provides query scopes to filter models by their position in the tree:\n\n- `hasChildren()`: Models with children.\n- `hasParent()`: Models with a parent.\n- `isLeaf()`/`doesntHaveChildren()`: Models without children.\n- `isRoot()`: Models without a parent.\n\n```php\n$noLeaves = User::hasChildren()->get();\n\n$noRoots = User::hasParent()->get();\n\n$leaves = User::isLeaf()->get();\n$leaves = User::doesntHaveChildren()->get();\n\n$roots = User::isRoot()->get();\n```\n\n#### Order\n\nThe trait provides query scopes to order models breadth-first or depth-first:\n\n- `breadthFirst()`: Get siblings before children.\n- `depthFirst()`: Get children before siblings.\n\n```php\n$tree = User::tree()->breadthFirst()->get();\n\n$descendants = User::find($id)->descendants()->depthFirst()->get();\n```\n\n#### Depth\n\nThe results of ancestor, bloodline, descendant and tree queries include an additional `depth` column.\n\nIt contains the model's depth *relative* to the query's parent. The depth is positive for descendants and negative for\nancestors:\n\n```php\n$descendantsAndSelf = User::find($id)->descendantsAndSelf()->depthFirst()->get();\n\necho $descendantsAndSelf[0]->depth; // 0\necho $descendantsAndSelf[1]->depth; // 1\necho $descendantsAndSelf[2]->depth; // 2\n```\n\nChange the column name by overriding `getDepthName()` if your table already contains a `depth` column:\n\n```php\nclass User extends Model\n{\n    public function getDepthName()\n    {\n        return 'depth';\n    }\n}\n```\n\n##### Depth Constraints\n\nYou can use the `whereDepth()` query scope to filter models by their relative depth:\n\n```php\n$descendants = User::find($id)->descendants()->whereDepth(2)->get();\n\n$descendants = User::find($id)->descendants()->whereDepth('<', 3)->get();\n```\n\nQueries with `whereDepth()` constraints that limit the maximum depth still build the entire (sub)tree internally.\nUse `withMaxDepth()` to set a maximum depth that improves query performance by only building the requested section of\nthe tree:\n\n```php\n$descendants = User::withMaxDepth(3, function () use ($id) {\n    return User::find($id)->descendants;\n});\n```\n\nThis also works with negative depths (where it's technically a minimum):\n\n```php\n$ancestors = User::withMaxDepth(-3, function () use ($id) {\n    return User::find($id)->ancestors;\n});\n```\n\n#### Path\n\nThe results of ancestor, bloodline, descendant and tree queries include an additional `path` column.\n\nIt contains the dot-separated path of local keys from the query's parent to the model:\n\n```php\n$descendantsAndSelf = User::find(1)->descendantsAndSelf()->depthFirst()->get();\n\necho $descendantsAndSelf[0]->path; // 1\necho $descendantsAndSelf[1]->path; // 1.2\necho $descendantsAndSelf[2]->path; // 1.2.3\n```\n\nChange the column name by overriding `getPathName()` if your table already contains a `path` column:\n\n```php\nclass User extends Model\n{\n    public function getPathName()\n    {\n        return 'path';\n    }\n```\n\nYou can also customize the path separator by overriding `getPathSeparator()`:\n\n```php\nclass User extends Model\n{\n    public function getPathSeparator()\n    {\n        return '.';\n    }\n}\n```\n\n#### Custom Paths\n\nYou can add custom path columns to the query results:\n\n```php\nclass User extends Model\n{\n    public function getCustomPaths()\n    {\n        return [\n            [\n                'name' => 'slug_path',\n                'column' => 'slug',\n                'separator' => '/',\n            ],\n        ];\n    }\n}\n\n$descendantsAndSelf = User::find(1)->descendantsAndSelf;\n\necho $descendantsAndSelf[0]->slug_path; // user-1\necho $descendantsAndSelf[1]->slug_path; // user-1/user-2\necho $descendantsAndSelf[2]->slug_path; // user-1/user-2/user-3\n```\n\nYou can also reverse custom paths:\n\n```php\nclass User extends Model\n{\n    public function getCustomPaths()\n    {\n        return [\n            [\n                'name' => 'reverse_slug_path',\n                'column' => 'slug',\n                'separator' => '/',\n                'reverse' => true,\n            ],\n        ];\n    }\n}\n```\n\n#### Nested Results\n\nUse the `toTree()` method on a result collection to generate a nested tree:\n\n```php\n$users = User::tree()->get();\n\n$tree = $users->toTree();\n```\n\nThis recursively sets `children` relationships:\n\n```json\n[\n  {\n    \"id\": 1,\n    \"children\": [\n      {\n        \"id\": 2,\n        \"children\": [\n          {\n            \"id\": 3,\n            \"children\": []\n          }\n        ]\n      },\n      {\n        \"id\": 4,\n        \"children\": [\n          {\n            \"id\": 5,\n            \"children\": []\n          }\n        ]\n      }\n    ]\n  }\n]\n```\n\n#### Initial & Recursive Query Constraints\n\nYou can add custom constraints to the CTE's initial and recursive query. Consider a query where you want to traverse a\ntree while skipping inactive users and their descendants:\n\n ```php\n$tree = User::withQueryConstraint(function (Builder $query) {\n    $query->where('users.active', true);\n}, function () {\n    return User::tree()->get();\n});\n ```\n\n You can also add a custom constraint to only the initial or recursive query using `withInitialQueryConstraint()`/\n `withRecursiveQueryConstraint()`.\n\n#### Additional Methods\n\nThe trait also provides methods to check relationships between models:\n\n- `isChildOf(Model $model)`: Checks if the current model is a child of the given model.\n- `isParentOf(Model $model)`: Checks if the current model is a parent of the given model.\n- `getDepthRelatedTo(Model $model)`: Returns the depth of the current model related to the given model.\n\n```php\n$rootUser = User::create(['parent_id' => null]); \n$firstLevelUser = User::create(['parent_id' => $rootUser->id]); \n$secondLevelUser = User::create(['parent_id' => $firstLevelUser->id]);  \n\n$isChildOf = $secondLevelUser->isChildOf($firstLevelUser); // Output: true\n$isParentOf = $rootUser->isParentOf($firstLevelUser); // Output: true\n$depthRelatedTo = $secondLevelUser->getDepthRelatedTo($rootUser); // Output: 2\n```\n\n#### Custom Relationships\n\nYou can also define custom relationships to retrieve related models recursively.\n\n- [HasManyOfDescendants](#hasmanyofdescendants)\n- [BelongsToManyOfDescendants](#belongstomanyofdescendants)\n- [MorphToManyOfDescendants](#morphtomanyofdescendants)\n- [MorphedByManyOfDescendants](#morphedbymanyofdescendants)\n- [Intermediate Scopes](#intermediate-scopes)\n- [Usage outside of Laravel](#usage-outside-of-laravel)\n\n##### HasManyOfDescendants\n\nConsider a `HasMany` relationship between `User` and `Post`:\n\n ```php\n class User extends Model\n {\n     public function posts()\n     {\n         return $this->hasMany(Post::class);\n     }\n }\n ```\n\nDefine a `HasManyOfDescendants` relationship to get all posts of a user and its descendants:\n\n```php\nclass User extends Model\n{\n    public function recursivePosts()\n    {\n        return $this->hasManyOfDescendantsAndSelf(Post::class);\n    }\n}\n\n$recursivePosts = User::find($id)->recursivePosts;\n\n$users = User::withCount('recursivePosts')->get();\n```\n\nUse `hasManyOfDescendants()` to only get the descendants' posts:\n\n```php\nclass User extends Model\n{\n    public function descendantPosts()\n    {\n        return $this->hasManyOfDescendants(Post::class);\n    }\n}\n```\n\n##### BelongsToManyOfDescendants\n\nConsider a `BelongsToMany` relationship between `User` and `Role`:\n\n ```php\n class User extends Model\n {\n     public function roles()\n     {\n         return $this->belongsToMany(Role::class);\n     }\n }\n ```\n\nDefine a `BelongsToManyOfDescendants` relationship to get all roles of a user and its descendants:\n\n```php\nclass User extends Model\n{\n    public function recursiveRoles()\n    {\n        return $this->belongsToManyOfDescendantsAndSelf(Role::class);\n    }\n}\n\n$recursiveRoles = User::find($id)->recursiveRoles;\n\n$users = User::withCount('recursiveRoles')->get();\n```\n\nUse `belongsToManyOfDescendants()` to only get the descendants' roles:\n\n```php\nclass User extends Model\n{\n    public function descendantRoles()\n    {\n        return $this->belongsToManyOfDescendants(Role::class);\n    }\n}\n```\n\n##### MorphToManyOfDescendants\n\nConsider a `MorphToMany` relationship between `User` and `Tag`:\n\n ```php\n class User extends Model\n {\n     public function tags()\n     {\n         return $this->morphToMany(Tag::class, 'taggable');\n     }\n }\n ```\n\nDefine a `MorphToManyOfDescendants` relationship to get all tags of a user and its descendants:\n\n```php\nclass User extends Model\n{\n    public function recursiveTags()\n    {\n        return $this->morphToManyOfDescendantsAndSelf(Tag::class, 'taggable');\n    }\n}\n\n$recursiveTags = User::find($id)->recursiveTags;\n\n$users = User::withCount('recursiveTags')->get();\n```\n\nUse `morphToManyOfDescendants()` to only get the descendants' tags:\n\n```php\nclass User extends Model\n{\n    public function descendantTags()\n    {\n        return $this->morphToManyOfDescendants(Tag::class, 'taggable');\n    }\n}\n```\n\n##### MorphedByManyOfDescendants\n\nConsider a `MorphedByMany` relationship between `Category` and `Post`:\n\n ```php\n class Category extends Model\n {\n     public function posts()\n     {\n         return $this->morphedByMany(Post::class, 'categorizable');\n     }\n }\n ```\n\nDefine a `MorphedByManyOfDescendants` relationship to get all posts of a category and its descendants:\n\n```php\nclass Category extends Model\n{\n    public function recursivePosts()\n    {\n        return $this->morphedByManyOfDescendantsAndSelf(Post::class, 'categorizable');\n    }\n}\n\n$recursivePosts = Category::find($id)->recursivePosts;\n\n$categories = Category::withCount('recursivePosts')->get();\n```\n\nUse `morphedByManyOfDescendants()` to only get the descendants' posts:\n\n```php\nclass Category extends Model\n{\n    public function descendantPosts()\n    {\n        return $this->morphedByManyOfDescendants(Post::class, 'categorizable');\n    }\n}\n```\n\n##### Intermediate Scopes\n\nYou can adjust the descendants query (e.g. child users) by adding or removing intermediate scopes:\n\n```php\nUser::find($id)->recursivePosts()->withTrashedDescendants()->get();\n\nUser::find($id)->recursivePosts()->withIntermediateScope('active', new ActiveScope())->get();\n\nUser::find($id)->recursivePosts()->withIntermediateScope(\n    'depth',\n    function ($query) {\n        $query->whereDepth('<=', 10);\n    }\n)->get();\n\nUser::find($id)->recursivePosts()->withoutIntermediateScope('active')->get();\n```\n\n##### Usage outside of Laravel\n\nIf you are using the package outside of Laravel or have disabled package discovery for `staudenmeir/laravel-cte`, you\nneed to add support for common table expressions to the related model:\n\n```php\nclass Post extends Model\n{\n    use \\Staudenmeir\\LaravelCte\\Eloquent\\QueriesExpressions;\n}\n```\n\n#### Deep Relationship Concatenation\n\nYou can include recursive relationships into deep relationships by concatenating them with other relationships\nusing [staudenmeir/eloquent-has-many-deep](https://github.com/staudenmeir/eloquent-has-many-deep). This\nworks with `Ancestors`, `Bloodline` and `Descendants` relationships (Laravel 9+).\n\nConsider a `HasMany` relationship between `User` and `Post` and building a deep relationship to get all posts of a\nuser's descendants:\n\n`User` â†’ descendants â†’ `User` â†’ has many â†’ `Post`\n\n[Install](https://github.com/staudenmeir/eloquent-has-many-deep/#installation) the additional package, add the\n`HasRelationships` trait to the recursive model\nand [define](https://github.com/staudenmeir/eloquent-has-many-deep/#concatenating-existing-relationships) a\ndeep relationship:\n\n```php\nclass User extends Model\n{\n    use \\Staudenmeir\\EloquentHasManyDeep\\HasRelationships;\n    use \\Staudenmeir\\LaravelAdjacencyList\\Eloquent\\HasRecursiveRelationships;\n\n    public function descendantPosts(): \\Staudenmeir\\EloquentHasManyDeep\\HasManyDeep\n    {\n        return $this->hasManyDeepFromRelations(\n            $this->descendants(),\n            (new static)->posts()\n        );\n    }\n    \n    public function posts()\n    {\n        return $this->hasMany(Post::class);\n    }\n}\n\n$descendantPosts = User::find($id)->descendantPosts;\n```\n\nAt the moment, recursive relationships can only be at the beginning of deep relationships:\n\n- Supported: `User` â†’ descendants â†’ `User` â†’ has many â†’ `Post`\n- Not supported: `Post` â†’ belongs to â†’ `User` â†’ descendants â†’ `User`\n\n#### Known Issues\n\nMariaDB [doesn't yet support](https://jira.mariadb.org/browse/MDEV-19077) correlated CTEs in subqueries. This affects\nqueries like `User::whereHas('descendants')` or `User::withCount('descendants')`.\n\n### Graphs: Multiple Parents per Node (Many-to-Many)\n\nYou can also use the package to traverse graphs with multiple parents per node that are defined in a pivot table. Use\ncases might be a bill of materials (BOM) or a family tree.\n\nSupports Laravel 9+.\n\n- [Getting Started](#graphs-getting-started)\n- [Included Relationships](#graphs-included-relationships)\n- [Pivot Columns](#graphs-pivot-columns)\n- [Cycle Detection](#graphs-cycle-detection)\n- [Subgraphs](#graphs-subgraphs)\n- [Order](#graphs-order)\n- [Depth](#graphs-depth)\n- [Path](#graphs-path)\n- [Custom Paths](#graphs-custom-paths)\n- [Nested Results](#graphs-nested-results)\n- [Initial & Recursive Query Constraints](#graphs-initial--recursive-query-constraints)\n- [Deep Relationship Concatenation](#graphs-deep-relationship-concatenation)\n- [Known Issues](#graphs-known-issues)\n\n#### <a name=\"graphs-getting-started\">Getting Started</a>\n\nConsider the following table schema for storing directed graphs as nodes and edges:\n\n```php\nSchema::create('nodes', function (Blueprint $table) {\n    $table->id();\n});\n\nSchema::create('edges', function (Blueprint $table) {\n    $table->unsignedBigInteger('source_id');\n    $table->unsignedBigInteger('target_id');\n    $table->string('label');\n    $table->unsignedBigInteger('weight');\n});\n```\n\nUse the `HasGraphRelationships` trait in your model to work with graph relationships and specify the name of the pivot\ntable:\n\n```php\nclass Node extends Model\n{\n    use \\Staudenmeir\\LaravelAdjacencyList\\Eloquent\\HasGraphRelationships;\n\n    public function getPivotTableName(): string\n    {\n        return 'edges';\n    }\n}\n```\n\nBy default, the trait expects a parent key named `parent_id` and child key named `child_id` in the pivot table. You can\ncustomize them by overriding `getParentKeyName()` and `getChildKeyName()`:\n\n```php\nclass Node extends Model\n{\n    public function getParentKeyName(): string\n    {\n        return 'source_id';\n    }\n  \n    public function getChildKeyName(): string\n    {\n        return 'target_id';\n    }\n}\n```\n\nBy default, the trait uses the model's primary key as the local key. You can customize it by\noverriding `getLocalKeyName()`:\n\n```php\nclass Node extends Model\n{\n    public function getLocalKeyName(): string\n    {\n        return 'id';\n    }\n}\n```\n\n#### <a name=\"graphs-included-relationships\">Included Relationships</a>\n\nThe trait provides various relationships:\n\n- `ancestors()`: The node's recursive parents.\n- `ancestorsAndSelf()`: The node's recursive parents and itself.\n- `children()`: The node's direct children.\n- `childrenAndSelf()`: The node's direct children and itself.\n- `descendants()`: The node's recursive children.\n- `descendantsAndSelf()`: The node's recursive children and itself.\n- `parents()`: The node's direct parents.\n- `parentsAndSelf()`: The node's direct parents and itself.\n\n```php\n$ancestors = Node::find($id)->ancestors;\n\n$nodes = Node::with('descendants')->get();\n\n$nodes = Node::has('children')->get();\n\n$total = Node::find($id)->descendants()->count();\n\nNode::find($id)->descendants()->update(['active' => false]);\n\nNode::find($id)->parents()->delete();\n```\n\n#### <a name=\"graphs-pivot-columns\">Pivot Columns</a>\n\nSimilar to `BelongsToMany` relationships, you can retrieve additional columns from the pivot table besides the parent\nand child key:\n\n```php\nclass Node extends Model\n{\n    public function getPivotColumns(): array\n    {\n        return ['label', 'weight'];\n    }\n}\n\n$nodes = Node::find($id)->descendants;\n\nforeach ($nodes as $node) {\n    dump(\n        $node->pivot->label,\n        $node->pivot->weight\n    );\n}\n```\n\n#### <a name=\"graphs-cycle-detection\">Cycle Detection\n\nIf your graph contains cycles, you need to enable cycle detection to prevent infinite loops:\n\n```php\nclass Node extends Model\n{\n    public function enableCycleDetection(): bool\n    {\n        return true;\n    }\n}\n```\n\nYou can also retrieve the start of a cycle, i.e. the first duplicate node. With this option, the query results include\nan `is_cycle` column that indicates whether the node is part of a cycle:\n\n```php\nclass Node extends Model\n{\n    public function enableCycleDetection(): bool\n    {\n        return true;\n    }\n\n    public function includeCycleStart(): bool\n    {\n        return true;\n    }\n}\n\n$nodes = Node::find($id)->descendants;\n\nforeach ($nodes as $node) {\n    dump($node->is_cycle);\n}\n```\n\n#### <a name=\"graphs-subgraphs\">Subgraphs</a>\n\nThe trait provides the `subgraph()` query scope to get the subgraph of a custom constraint:\n\n```php\n$constraint = function ($query) {\n    $query->whereIn('id', $ids);\n};\n\n$subgraph = Node::subgraph($constraint)->get();\n```\n\nYou can pass a maximum depth as the second argument:\n\n```php\n$subgraph = Node::subgraph($constraint, 3)->get();\n```\n\n#### <a name=\"graphs-order\">Order</a>\n\nThe trait provides query scopes to order nodes breadth-first or depth-first:\n\n- `breadthFirst()`: Get siblings before children.\n- `depthFirst()`: Get children before siblings.\n\n```php\n$descendants = Node::find($id)->descendants()->breadthFirst()->get();\n\n$descendants = Node::find($id)->descendants()->depthFirst()->get();\n```\n\n#### <a name=\"graphs-depth\">Depth</a>\n\nThe results of ancestor, descendant and subgraph queries include an additional `depth` column.\n\nIt contains the node's depth *relative* to the query's parent. The depth is positive for descendants and negative for\nancestors:\n\n```php\n$descendantsAndSelf = Node::find($id)->descendantsAndSelf()->depthFirst()->get();\n\necho $descendantsAndSelf[0]->depth; // 0\necho $descendantsAndSelf[1]->depth; // 1\necho $descendantsAndSelf[2]->depth; // 2\n```\n\nChange the column name by overriding `getDepthName()` if your table already contains a `depth` column:\n\n```php\nclass Node extends Model\n{\n    public function getDepthName(): string\n    {\n        return 'depth';\n    }\n}\n```\n\n##### Depth Constraints\n\nYou can use the `whereDepth()` query scope to filter nodes by their relative depth:\n\n```php\n$descendants = Node::find($id)->descendants()->whereDepth(2)->get();\n\n$descendants = Node::find($id)->descendants()->whereDepth('<', 3)->get();\n```\n\nQueries with `whereDepth()` constraints that limit the maximum depth still build the entire (sub)graph internally.\nUse `withMaxDepth()` to set a maximum depth that improves query performance by only building the requested section of\nthe graph:\n\n```php\n$descendants = Node::withMaxDepth(3, function () use ($id) {\n    return Node::find($id)->descendants;\n});\n```\n\nThis also works with negative depths (where it's technically a minimum):\n\n```php\n$ancestors = Node::withMaxDepth(-3, function () use ($id) {\n    return Node::find($id)->ancestors;\n});\n```\n\n#### <a name=\"graphs-path\">Path</a>\n\nThe results of ancestor, descendant and subgraph queries include an additional `path` column.\n\nIt contains the dot-separated path of local keys from the query's parent to the node:\n\n```php\n$descendantsAndSelf = Node::find(1)->descendantsAndSelf()->depthFirst()->get();\n\necho $descendantsAndSelf[0]->path; // 1\necho $descendantsAndSelf[1]->path; // 1.2\necho $descendantsAndSelf[2]->path; // 1.2.3\n```\n\nChange the column name by overriding `getPathName()` if your table already contains a `path` column:\n\n```php\nclass Node extends Model\n{\n    public function getPathName(): string\n    {\n        return 'path';\n    }\n}\n```\n\nYou can also customize the path separator by overriding `getPathSeparator()`:\n\n```php\nclass Node extends Model\n{\n    public function getPathSeparator(): string\n    {\n        return '.';\n    }\n}\n```\n\n#### <a name=\"graphs-custom-paths\">Custom Paths</a>\n\nYou can add custom path columns to the query results:\n\n```php\nclass Node extends Model\n{\n    public function getCustomPaths(): array\n    {\n        return [\n            [\n                'name' => 'slug_path',\n                'column' => 'slug',\n                'separator' => '/',\n            ],\n        ];\n    }\n}\n\n$descendantsAndSelf = Node::find(1)->descendantsAndSelf;\n\necho $descendantsAndSelf[0]->slug_path; // node-1\necho $descendantsAndSelf[1]->slug_path; // node-1/node-2\necho $descendantsAndSelf[2]->slug_path; // node-1/node-2/node-3\n```\n\nYou can also reverse custom paths:\n\n```php\nclass Node extends Model\n{\n    public function getCustomPaths(): array\n    {\n        return [\n            [\n                'name' => 'reverse_slug_path',\n                'column' => 'slug',\n                'separator' => '/',\n                'reverse' => true,\n            ],\n        ];\n    }\n}\n```\n\n#### <a name=\"graphs-nested-results\">Nested Results</a>\n\nUse the `toTree()` method on a result collection to generate a nested tree:\n\n```php\n$nodes = Node::find($id)->descendants;\n\n$tree = $nodes->toTree();\n```\n\nThis recursively sets `children` relationships:\n\n```json\n[\n  {\n    \"id\": 1,\n    \"children\": [\n      {\n        \"id\": 2,\n        \"children\": [\n          {\n            \"id\": 3,\n            \"children\": []\n          }\n        ]\n      },\n      {\n        \"id\": 4,\n        \"children\": [\n          {\n            \"id\": 5,\n            \"children\": []\n          }\n        ]\n      }\n    ]\n  }\n]\n```\n\n#### <a name=\"graphs-initial--recursive-query-constraints\">Initial & Recursive Query Constraints</a>\n\nYou can add custom constraints to the CTE's initial and recursive query. Consider a query where you want to traverse a\nnode's descendants while skipping inactive nodes and their descendants:\n\n ```php\n$descendants = Node::withQueryConstraint(function (Builder $query) {\n    $query->where('nodes.active', true);\n}, function () {\n    return Node::find($id)->descendants;\n});\n ```\n\nYou can also add a custom constraint to only the initial or recursive query using `withInitialQueryConstraint()`/\n`withRecursiveQueryConstraint()`.\n\n#### <a name=\"graphs-deep-relationship-concatenation\">Deep Relationship Concatenation</a>\n\nYou can include recursive relationships into deep relationships by concatenating them with other relationships\nusing [staudenmeir/eloquent-has-many-deep](https://github.com/staudenmeir/eloquent-has-many-deep) (Laravel 9+).\n\nConsider a `HasMany` relationship between `Node` and `Post` and building a deep relationship to get all posts of a\nnode's descendants:\n\n`Node` â†’ descendants â†’ `Node` â†’ has many â†’ `Post`\n\n[Install](https://github.com/staudenmeir/eloquent-has-many-deep/#installation) the additional package, add the\n`HasRelationships` trait to the recursive model\nand [define](https://github.com/staudenmeir/eloquent-has-many-deep/#concatenating-existing-relationships) a\ndeep relationship:\n\n```php\nclass Node extends Model\n{\n    use \\Staudenmeir\\EloquentHasManyDeep\\HasRelationships;\n    use \\Staudenmeir\\LaravelAdjacencyList\\Eloquent\\HasGraphRelationships;\n\n    public function descendantPosts(): \\Staudenmeir\\EloquentHasManyDeep\\HasManyDeep\n    {\n        return $this->hasManyDeepFromRelations(\n            $this->descendants(),\n            (new static)->posts()\n        );\n    }\n    \n    public function posts()\n    {\n        return $this->hasMany(Post::class);\n    }\n}\n\n$descendantPosts = Node::find($id)->descendantPosts;\n```\n\nAt the moment, recursive relationships can only be at the beginning of deep relationships:\n\n- Supported: `Node` â†’ descendants â†’ `Node` â†’ has many â†’ `Post`\n- Not supported: `Post` â†’ belongs to â†’ `Node` â†’ descendants â†’ `Node`\n\n#### <a name=\"graphs-known-issues\">Known Issues</a>\n\nMariaDB [doesn't yet support](https://jira.mariadb.org/browse/MDEV-19077) correlated CTEs in subqueries. This affects\nqueries like `Node::whereHas('descendants')` or `Node::withCount('descendants')`.\n\n### Package Conflicts\n\n- `staudenmeir/eloquent-param-limit-fix`: Replace both packages\n  with [staudenmeir/eloquent-param-limit-fix-x-laravel-adjacency-list](https://github.com/staudenmeir/eloquent-param-limit-fix-x-laravel-adjacency-list)\n  to use them on the same model.\n\n## Contributing\n\nPlease see [CONTRIBUTING](.github/CONTRIBUTING.md) and [CODE OF CONDUCT](.github/CODE_OF_CONDUCT.md) for details.\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.5048828125,
          "content": "{\n    \"name\": \"staudenmeir/laravel-adjacency-list\",\n    \"description\": \"Recursive Laravel Eloquent relationships with CTEs\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Jonas Staudenmeir\",\n            \"email\": \"mail@jonas-staudenmeir.de\"\n        }\n    ],\n    \"require\": {\n        \"php\": \"^8.2\",\n        \"illuminate/database\": \"^11.0\",\n        \"staudenmeir/eloquent-has-many-deep-contracts\": \"^1.2\",\n        \"staudenmeir/laravel-cte\": \"^1.11\"\n    },\n    \"require-dev\": {\n        \"barryvdh/laravel-ide-helper\": \"^3.0\",\n        \"harrygulliford/laravel-firebird\": \"^3.3\",\n        \"larastan/larastan\": \"^3.0\",\n        \"laravel/framework\": \"^11.0\",\n        \"mockery/mockery\": \"^1.5.1\",\n        \"orchestra/testbench-core\": \"^9.5\",\n        \"phpunit/phpunit\": \"^11.0\",\n        \"singlestoredb/singlestoredb-laravel\": \"^1.5.4\",\n        \"staudenmeir/eloquent-has-many-deep\": \"^1.20\"\n    },\n    \"suggest\": {\n        \"barryvdh/laravel-ide-helper\": \"Provide type hints for attributes and relations.\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"Staudenmeir\\\\LaravelAdjacencyList\\\\\": \"src/\"\n        }\n    },\n    \"autoload-dev\": {\n        \"psr-4\": {\n            \"Staudenmeir\\\\LaravelAdjacencyList\\\\Tests\\\\\": \"tests/\"\n        }\n    },\n    \"config\": {\n        \"sort-packages\": true\n    },\n    \"extra\": {\n        \"laravel\": {\n            \"providers\": [\n                \"Staudenmeir\\\\LaravelAdjacencyList\\\\IdeHelperServiceProvider\"\n            ]\n        }\n    },\n    \"minimum-stability\": \"dev\",\n    \"prefer-stable\" : true\n}\n"
        },
        {
          "name": "docker-compose.ci.yml",
          "type": "blob",
          "size": 0.9326171875,
          "content": "services:\n  php8.2:\n    image: ghcr.io/staudenmeir/php:8.2\n    working_dir: /var/www/html\n    networks:\n      - test\n    volumes:\n      - .:/var/www/html:delegated\n      - ~/.cache/composer/files:/root/.composer/cache/files\n  php8.3:\n    image: ghcr.io/staudenmeir/php:8.3\n    working_dir: /var/www/html\n    networks:\n      - test\n    volumes:\n      - .:/var/www/html:delegated\n      - ~/.cache/composer/files:/root/.composer/cache/files\n  php8.3-xdebug:\n    image: ghcr.io/staudenmeir/php:8.3\n    working_dir: /var/www/html\n    networks:\n      - test\n    volumes:\n      - .:/var/www/html:delegated\n      - .docker/xdebug.ci.ini:/usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini\n      - ~/.cache/composer/files:/root/.composer/cache/files\n  php8.4:\n    image: ghcr.io/staudenmeir/php:8.4\n    working_dir: /var/www/html\n    networks:\n      - test\n    volumes:\n      - .:/var/www/html:delegated\n      - ~/.cache/composer/files:/root/.composer/cache/files\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 2.4169921875,
          "content": "services:\n  php8.2:\n    image: ghcr.io/staudenmeir/php:8.2\n    working_dir: /var/www/html\n    networks:\n      - test\n    volumes:\n      - .:/var/www/html:delegated\n      - .docker/xdebug.ini:/usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini\n  php8.3:\n    image: ghcr.io/staudenmeir/php:8.3\n    working_dir: /var/www/html\n    networks:\n      - test\n    volumes:\n      - .:/var/www/html:delegated\n      - .docker/xdebug.ini:/usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini\n  php8.4:\n    image: ghcr.io/staudenmeir/php:8.4\n    working_dir: /var/www/html\n    networks:\n      - test\n    volumes:\n      - .:/var/www/html:delegated\n      #- .docker/xdebug.ini:/usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini\n  mysql:\n    image: 'mysql:latest'\n    environment:\n      MYSQL_ROOT_PASSWORD: password\n      MYSQL_DATABASE: test\n    healthcheck:\n      test: mysqladmin ping --silent\n      interval: 5s\n      timeout: 3s\n      retries: 10\n    networks:\n      - test\n  mariadb:\n    image: 'mariadb:latest'\n    environment:\n      MYSQL_ROOT_PASSWORD: password\n      MYSQL_DATABASE: test\n    networks:\n      - test\n  pgsql:\n    image: 'postgres:latest'\n    environment:\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: test\n    networks:\n      - test\n  sqlsrv:\n    image: 'mcr.microsoft.com/mssql/server:2022-latest'\n    environment:\n      ACCEPT_EULA: Y\n      SA_PASSWORD: Password!\n    healthcheck:\n      test: /opt/mssql-tools18/bin/sqlcmd -C -S localhost -U sa -P \"$${SA_PASSWORD}\" -Q \"SELECT 1\" -b -o /dev/null\n      interval: 5s\n      timeout: 3s\n      retries: 10\n    networks:\n      - test\n  singlestore:\n    image: 'ghcr.io/singlestore-labs/singlestoredb-dev:latest'\n    environment:\n      # this license key is only authorized for use in SingleStore laravel-cte tests and is heavily restricted\n      # if you want a free SingleStore license for your own use please visit https://www.singlestore.com/cloud-trial/\n      SINGLESTORE_LICENSE: BDMwMzMyOTEyNjMwYzQ1ODE5MDdjNThiYjU1MGM5YTAyAAAAAAAAAAAEAAAAAAAAAAwwNQIZAKqnuBG9UX3K2enIHyshQGHZIjQiCZpqlwIYE8t4J8VewDLm2m4+4i8KorAIZsJd8j6EAA==\n      ROOT_PASSWORD: password\n    networks:\n      - test\n    volumes:\n      - .docker/singlestore/init.sql:/init.sql\n  firebird:\n    image: jacobalberty/firebird:latest\n    environment:\n      FIREBIRD_DATABASE: 'test.fdb'\n      ISC_PASSWORD: 'password'\n      EnableLegacyClientAuth: 'true'\n    networks:\n      - test\n\nnetworks:\n  test:\n    driver: bridge\n"
        },
        {
          "name": "phpstan.neon.dist",
          "type": "blob",
          "size": 0.6552734375,
          "content": "parameters:\n    level: 9\n    paths:\n        - src\n    ignoreErrors:\n        - '#Unsafe usage of new static\\(\\).#'\n        - '#Access to an undefined property Illuminate\\\\Database\\\\Eloquent\\\\Model::\\$laravel_through_key#'\n        - '#Call to an undefined method TRelatedModel of Illuminate\\\\Database\\\\Eloquent\\\\Model#'\n        - '#Call to an undefined method TDeclaringModel of Illuminate\\\\Database\\\\Eloquent\\\\Model#'\n        - '#Call to an undefined method TModel of Illuminate\\\\Database\\\\Eloquent\\\\Model#'\n        - '#Call to an undefined method Illuminate\\\\Database\\\\Eloquent\\\\Model::#'\n        - '#Call to an undefined method Illuminate\\\\Database\\\\Eloquent\\\\Builder#'\n"
        },
        {
          "name": "phpstan.types.neon.dist",
          "type": "blob",
          "size": 0.107421875,
          "content": "includes:\n    - ./vendor/larastan/larastan/extension.neon\nparameters:\n    level: 9\n    paths:\n        - types\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.6337890625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" backupGlobals=\"false\" colors=\"true\" failOnWarning=\"true\" processIsolation=\"false\" stopOnError=\"false\" stopOnFailure=\"false\" xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/10.1/phpunit.xsd\" cacheDirectory=\".phpunit.cache\" backupStaticProperties=\"false\">\n  <testsuites>\n    <testsuite name=\"LaravelAdjacencyList Test Suite\">\n      <directory suffix=\"Test.php\">./tests</directory>\n    </testsuite>\n  </testsuites>\n  <coverage/>\n  <source>\n    <include>\n      <directory suffix=\".php\">./src</directory>\n    </include>\n  </source>\n</phpunit>\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}