{
  "metadata": {
    "timestamp": 1736711990693,
    "page": 470,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "j4mie/idiorm",
      "stars": 2007,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.123046875,
          "content": ".gitignore export-ignore\n.gitattributes export-ignore\n/test export-ignore\n.travis.yml export-ignore\nphpunit.xml export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.072265625,
          "content": "*.swp\n*.sqlite\ndocs/_build\n/phpunit.phar\n/vendor\n/composer.lock\n.DS_Store\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.6611328125,
          "content": "---\n### Feature complete\n\nIdiorm is now considered to be feature complete as of version 1.5.0. Whilst it will continue to be maintained with bug fixes there will be no further new features added.\n\n**Please do not submit feature requests or pull requests adding new features as they will be closed without ceremony.**\n\n---\n\nWhen making a pull request please include the following aspects:\n\n- Update the changelog in the README.markdown file to include details of the pull request\n- If the documentation in the README or Sphinx docs needs to be amended please do so in the pull request\n- Include unit tests for any changes - if it is a bug include at least one regression test\n\n\n"
        },
        {
          "name": "README.markdown",
          "type": "blob",
          "size": 19.29296875,
          "content": "Idiorm\n======\n\n[![idiorm master branch](https://github.com/j4mie/idiorm/actions/workflows/idiorm-workflow.yml/badge.svg?branch=master)](https://github.com/j4mie/idiorm/actions?query=branch%3Amaster) [![Latest Stable Version](https://poser.pugx.org/j4mie/idiorm/v/stable.png)](https://packagist.org/packages/j4mie/idiorm) [![Total Downloads](https://poser.pugx.org/j4mie/idiorm/downloads.png)](https://packagist.org/packages/j4mie/idiorm) [![Code Climate](https://codeclimate.com/github/j4mie/idiorm/badges/gpa.svg)](https://codeclimate.com/github/j4mie/idiorm)\n\n[https://j4mie.github.io/idiormandparis/](https://j4mie.github.io/idiormandparis/)\n\n---\n\n### In maintenance only mode\n\nIdiorm and Paris are now considered to be feature complete as of version 1.5.0. Whilst they will continue to be maintained with bug fixes there will be no further new features added from this point on. This means that if a pull request makes breaking changes to the API or requires anything other than a patch version bump of the library then it will not be merged.\n\n**Please do not submit feature requests or API breaking changes as they will be closed without ceremony.**\n\n### Should I use Idiorm/Paris?\n\n#### If you're starting a new project\n\nIt is not recommended that you use either Idiorm or Paris in new projects.\n\nI recommend that you use the [Eloquent database library](https://github.com/illuminate/database) from [Laravel](https://laravel.com) as Taylor based it on Idiorm when he wrote it.\nThis means that many of the same ideas are present there, but it is more actively maintained and has a more modern code style.\n\n#### If you have existing projects based on Idiorm or Paris\n\nYou can continue to use both projects as they will continue to receive security patches and bug fixes.\nIt is important to note that future versions of PHP may not be supported if changes they require would break backwards compatibility.\n\nAt this point you can either use another database library such as Eloquent from Laravel (see If you're starting a new project above) or you could decide to fork Idiorm and/or Paris to patch them with your own modifications.\n\n### But, why?\n\nFor further information on the state of this project please see https://github.com/j4mie/idiorm/issues/360\n\n---\n\nA lightweight nearly-zero-configuration object-relational mapper and fluent query builder for PHP5 and above.\n\nTested on PHP 5.2.0+ - may work on earlier versions with PDO and the correct database drivers.\n\nReleased under a [BSD license](https://en.wikipedia.org/wiki/BSD_licenses).\n\n**See Also: [Paris](https://github.com/j4mie/paris), an Active Record implementation built on top of Idiorm.**\n\nFeatures\n--------\n\n* Makes simple queries and simple CRUD operations completely painless.\n* Gets out of the way when more complex SQL is required.\n* Built on top of [PDO](https://php.net/pdo).\n* Uses [prepared statements](https://uk.php.net/manual/en/pdo.prepared-statements.php) throughout to protect against [SQL injection](https://en.wikipedia.org/wiki/SQL_injection) attacks.\n* Requires no model classes, no XML configuration and no code generation: works out of the box, given only a connection string.\n* Consists of one main class called `ORM`. Additional classes are prefixed with `Idiorm`. Minimal global namespace pollution.\n* Database agnostic. Currently supports SQLite, MySQL, Firebird and PostgreSQL. May support others, please give it a try!\n* Supports collections of models with method chaining to filter or apply actions to multiple results at once.\n* Multiple connections supported\n* PSR-1 compliant methods (any method can be called in camelCase instead of underscores eg. `find_many()` becomes `findMany()`) - you'll need PHP 5.3+\n\nDocumentation\n-------------\n\nThe documentation is hosted on Read the Docs: [idiorm.rtfd.org](https://idiorm.rtfd.org)\n\n### Building the Docs ###\n\nYou will need to install [Sphinx](https://sphinx-doc.org/) and then in the docs folder run:\n\n    make html\n\nThe documentation will now be in docs/_build/html/index.html\n\nLet's See Some Code\n-------------------\n\n```php\n$user = ORM::for_table('user')\n    ->where_equal('username', 'j4mie')\n    ->find_one();\n\n$user->first_name = 'Jamie';\n$user->save();\n\n$tweets = ORM::for_table('tweet')\n    ->select('tweet.*')\n    ->join('user', array(\n        'user.id', '=', 'tweet.user_id'\n    ))\n    ->where_equal('user.username', 'j4mie')\n    ->find_many();\n\nforeach ($tweets as $tweet) {\n    echo $tweet->text;\n}\n```\n\nTests\n-----\n\nTests are written with PHPUnit and be run through composer\n\n    composer test\n\nTo make testing on PHP 5.2 (Idiorm maintains support back to this version of PHP) there\nis a Docker setup in `./test/docker_for_php52` - check the readme in there for more.\n\nChangelog\n---------\n\n#### 1.5.8 - released 2022-07-18\n\n* Update to support PHP 8.1 [[edlerd](https://github.com/edlerd) and [aaronpk](https://github.com/aaronpk)] - [issue #370](https://github.com/j4mie/idiorm/pull/370) and [issue #372](https://github.com/j4mie/idiorm/pull/372)\n* GitHub actions used to perform unit testing/CI [[Treffynnon](https://github.com/treffynnon) and [yan12125](https://github.com/yan12125)]\n\n#### 1.5.7 - released 2020-04-29\n\n* Fix argument order in call to join() [[CatalinFrancu](https://github.com/CatalinFrancu)] - [issue #357](https://github.com/j4mie/idiorm/pull/357)\n\n#### 1.5.6 - released 2018-05-31\n\n* Assign `null` to `self::$_db` on `reset_db()` to ensure PDO closes the connections [[bleakgadfly](https://github.com/bleakgadfly)] - [issue #338](https://github.com/j4mie/idiorm/issues/338)\n\n#### 1.5.5 - released 2018-01-05\n\n* Add a docker setup for testing with PHP 5.2 (uses PHPUnit 3.6.12, which is the last version released compatible with PHP 5.2) [[Treffynnon](https://github.com/treffynnon)]\n\n#### 1.5.4 - released 2018-01-04\n\n* Reset Idiorm state when a cached result is returned [[fayland](https://github.com/fayland) (and [Treffynnon](https://github.com/treffynnon))] - [issue #319](https://github.com/j4mie/idiorm/issues/319)\n* Fix travis builds for PHP 5.2+ (adding 7.0 and 7.1) and document support for newer PHP versions [[Treffynnon](https://github.com/treffynnon)]\n* Correct PHPDoc comments for `selectMany()` [[kawausokun](https://github.com/kawausokun)] - [issue #325](github.com/j4mie/idiorm/issues/325)\n* Add pdo_sqlite to the composer require-dev dependencies [[qyanu](https://github.com/qyanu)] - [issue #328](github.com/j4mie/idiorm/issues/328)\n\n#### 1.5.3 - released 2017-03-21\n\n* Document the `raw_execute()` method and add a note for `get_db()` in the querying documentation - [[Treffynnon](https://github.com/treffynnon)]\n\n#### 1.5.2 - released 2016-12-14\n\n* Fix autoincremented compound keys inserts [[lrlopez](https://github.com/lrlopez)] - [issue #233](https://github.com/j4mie/idiorm/issues/233) and [pull #235](https://github.com/j4mie/idiorm/pull/235)\n* Add @method tags for magic methods [[stellis](https://github.com/stellis)] - [issue #237](https://github.com/j4mie/idiorm/issues/237)\n* Ensure `is_dirty()` returns correctly when fed null or an empty string [[tentwofour](https://github.com/tentwofour)] - [issue #268](https://github.com/j4mie/idiorm/issues/268)\n* Adding Code Climate badge to the readme file [[e3betht](https://github.com/e3betht)] - [issue #260](https://github.com/j4mie/idiorm/issues/260)\n* Typo in navigation [[leongersen](https://github.com/leongersen)] - [issue #257](https://github.com/j4mie/idiorm/issues/257)\n* Support named placeholders logging and test [[m92o](https://github.com/m92o)] - [issue #223](https://github.com/j4mie/idiorm/issues/223)\n* `having_id_is()` reference undefined variable `$value` [[Treffynnon](https://github.com/treffynnon)] - [issue #224](https://github.com/j4mie/idiorm/issues/224)\n* Documentation fix - ORM query output for `where_any_is()` [[uovidiu](https://github.com/uovidiu)] - [issue #306](https://github.com/j4mie/idiorm/issues/306)\n* Code style fix preventing nested loops from using the same variable names [[mkkeck](https://github.com/mkkeck)] - [issue #301](https://github.com/j4mie/idiorm/issues/301)\n* Document shortcomings of the built in query logger [[Treffynnon](https://github.com/treffynnon)] - [issue #307](https://github.com/j4mie/idiorm/issues/307)\n* Add phpunit to dev dependencies, add `composer test` script shortcut and fix PDO mock in test bootstrap [[Treffynnon](https://github.com/treffynnon)]\n* New test for multiple raw where clauses [[Treffynnon](https://github.com/treffynnon)] - [issue #236](https://github.com/j4mie/idiorm/issues/236)\n* Remove PHP 5.2 from travis-ci containers to test against (**note** Idiorm still supports PHP 5.2 despite this) [[Treffynnon](https://github.com/treffynnon)]\n\n#### 1.5.1 - released 2014-06-23\n\n* Binding of named parameters was broken [[cainmi](https://github.com/cainmi)] - [issue #221](https://github.com/j4mie/idiorm/pull/221)\n\n#### 1.5.0 - released 2014-06-22\n\n* Multiple OR'ed conditions support [[lrlopez](https://github.com/lrlopez)] - [issue #201](https://github.com/j4mie/idiorm/issues/201)\n* `where_id_in()` for selecting multiple records by primary key [[lrlopez](https://github.com/lrlopez)] - [issue #202](https://github.com/j4mie/idiorm/issues/202)\n* Add compound primary key support [[lrlopez](https://github.com/lrlopez)] - [issue #171](https://github.com/j4mie/idiorm/issues/171)\n* Add a RAW JOIN source to the query [[moiseevigor](https://github.com/moiseevigor)] - [issue #163](https://github.com/j4mie/idiorm/issues/163)\n* offsetExists() should return true for null values, resolves [#181](https://github.com/j4mie/idiorm/issues/181) [[cainmi](https://github.com/cainmi)] - [issue #214](https://github.com/j4mie/idiorm/pull/214)\n* Custom cache callback functions [[peter-mw](https://github.com/peter-mw)] - [issue #216](https://github.com/j4mie/idiorm/pull/216)\n* Restrict null primary keys on update/delete, resolves [#203](https://github.com/j4mie/idiorm/issues/203) [[cainmi](https://github.com/cainmi)] - [issue #205](https://github.com/j4mie/idiorm/issues/205) \n* Ensure parameters treated by type correctly [[charsleysa](https://github.com/charsleysa)] & [[SneakyBobito](https://github.com/SneakyBobito)] - [issue #206](https://github.com/j4mie/idiorm/issues/206) & [issue #208](https://github.com/j4mie/idiorm/issues/208)\n* Reduce the type casting on aggregate functions to allow characters [[herroffizier](https://github.com/herroffizier)] - [issue #150](https://github.com/j4mie/idiorm/issues/150)\n* Prevent invalid method calls from triggering infinite recursion [[michaelward82](https://github.com/michaelward82)] - [issue #152](https://github.com/j4mie/idiorm/issues/152)\n* Add time to query logging - adds query time parameter to external logger callback function [[AgelxNash](https://github.com/AgelxNash)] - [issue #180](https://github.com/j4mie/idiorm/issues/180)\n* Changed database array access to ensure it's always properly setup [[falmp](https://github.com/falmp)] - [issue #159](https://github.com/j4mie/idiorm/issues/159)\n* Allow unsetting the db (`ORM::set_db(null)`) to make the test work again [[borrel](https://github.com/borrel)] - [issue #160](https://github.com/j4mie/idiorm/issues/160)\n* Correct [issue #176](https://github.com/j4mie/idiorm/issues/176): Ensure database setup before building select [[kendru](https://github.com/kendru)] - [issue #197](https://github.com/j4mie/idiorm/issues/197)\n* Add HHVM to travis-ci build matrix [[ptarjan](https://github.com/ptarjan)] - [issue #168](https://github.com/j4mie/idiorm/issues/168)\n* Improve where statement precendence documentation [[thomasahle](https://github.com/thomasahle)] - [issue #190](https://github.com/j4mie/idiorm/issues/190)\n* Improve testing checks [[charsleysa](https://github.com/charsleysa)] - [issue #173](https://github.com/j4mie/idiorm/issues/173)\n\n#### 1.4.1 - released 2013-12-12\n\n**Patch update to remove a broken pull request** - may have consequences for users of 1.4.0 that exploited the \"`find_many()` now returns an associative array with the databases primary ID as the array keys\" change that was merged in 1.4.0.\n\n* Back out pull request/issue [#133](https://github.com/j4mie/idiorm/pull/133) as it breaks backwards compatibility in previously unexpected ways (see [#162](https://github.com/j4mie/idiorm/pull/162), [#156](https://github.com/j4mie/idiorm/issues/156) and [#133](https://github.com/j4mie/idiorm/pull/133#issuecomment-29063108)) - sorry for merging this change into Idiorm - closes [issue 156](https://github.com/j4mie/idiorm/issues/156)\n\n#### 1.4.0 - released 2013-09-05\n\n* `find_many()` now returns an associative array with the databases primary ID as the array keys [[Surt](https://github.com/Surt)] - [issue #133](https://github.com/j4mie/idiorm/issues/133)\n* Calls to `set()` and `set_expr()` return `$this` allowing them to be chained [[Surt](https://github.com/Surt)]\n* Add PSR-1 compliant camelCase method calls to Idiorm (PHP 5.3+ required) [[crhayes](https://github.com/crhayes)] - [issue #108](https://github.com/j4mie/idiorm/issues/108)\n* Add static method `get_config()` to access current configuration [[javierd](https://github.com/mikejestes)] - [issue #141](https://github.com/j4mie/idiorm/issues/141)\n* Add logging callback functionality [[lalop](https://github.com/lalop)] - [issue #130](https://github.com/j4mie/idiorm/issues/130)\n* Add support for MS SQL ``TOP`` limit style (automatically used for PDO drivers: sqlsrv, dblib and mssql) [[numkem](https://github.com/numkem)] - [issue #116](https://github.com/j4mie/idiorm/issues/116)\n* Uses table aliases in `WHERE` clauses [[vicvicvic](https://github.com/vicvicvic)] - [issue #140](https://github.com/j4mie/idiorm/issues/140)\n* Ignore result columns when calling an aggregate function [[tassoevan](https://github.com/tassoevan)] - [issue #120](https://github.com/j4mie/idiorm/issues/120)\n* Improve documentation [[bruston](https://github.com/bruston)] - [issue #111](https://github.com/j4mie/idiorm/issues/111)\n* Improve PHPDoc on `get_db()` [[mailopl](https://github.com/mailopl)] - [issue #106](https://github.com/j4mie/idiorm/issues/106)\n* Improve documentation [[sjparsons](https://github.com/sjparsons)] - [issue #103](https://github.com/j4mie/idiorm/issues/103)\n* Make tests/bootstrap.php HHVM compatible [[JoelMarcey](https://github.com/JoelMarcey)] - [issue #143](https://github.com/j4mie/idiorm/issues/143)\n* Fix docblock [[ulrikjohansson](https://github.com/ulrikjohansson)] - [issue #147](https://github.com/j4mie/idiorm/issues/147)\n* Fix incorrect variable name in querying documentation [[fridde](https://github.com/fridde)] - [issue #146](https://github.com/j4mie/idiorm/issues/146)\n\n#### 1.3.0 - released 2013-01-31\n\n* Documentation moved to [idiorm.rtfd.org](http://idiorm.rtfd.org) and now built using [Sphinx](http://sphinx-doc.org/)\n* Add support for multiple database connections - closes [issue #15](https://github.com/j4mie/idiorm/issues/15) [[tag](https://github.com/tag)]\n* Add in raw_execute - closes [issue #40](https://github.com/j4mie/idiorm/issues/40) [[tag](https://github.com/tag)]\n* Add `get_last_statement()` - closes [issue #84](https://github.com/j4mie/idiorm/issues/84) [[tag](https://github.com/tag)]\n* Add HAVING clause functionality - closes [issue #50](https://github.com/j4mie/idiorm/issues/50)\n* Add `is_new` method - closes [issue #85](https://github.com/j4mie/idiorm/issues/85)\n* Add `ArrayAccess` support to the model instances allowing property access via `$model['field']` as well as `$model->field` - [issue #51](https://github.com/j4mie/idiorm/issues/51)\n* Add a result set object for collections of models that can support method chains to filter or apply actions to multiple results at once - issue [#51](https://github.com/j4mie/idiorm/issues/51) and [#22](https://github.com/j4mie/idiorm/issues/22)\n* Add support for [Firebird](http://www.firebirdsql.org) with `ROWS` and `TO` result set limiting and identifier quoting [[mapner](https://github.com/mapner)] - [issue #98](https://github.com/j4mie/idiorm/issues/98)\n* Fix last insert ID for PostgreSQL using RETURNING - closes issues [#62](https://github.com/j4mie/idiorm/issues/62) and [#89](https://github.com/j4mie/idiorm/issues/89) [[laacz](https://github.com/laacz)]\n* Reset Idiorm after performing a query to allow for calling `count()` and then `find_many()` [[fayland](https://github.com/fayland)] - [issue #97](https://github.com/j4mie/idiorm/issues/97)\n* Change Composer to use a classmap so that autoloading is better supported [[javierd](https://github.com/javiervd)] - [issue #96](https://github.com/j4mie/idiorm/issues/96)\n* Add query logging to `delete_many` [[tag](https://github.com/tag)]\n* Fix when using `set_expr` alone it doesn't trigger query creation - closes [issue #90](https://github.com/j4mie/idiorm/issues/90)\n* Escape quote symbols in \"_quote_identifier_part\" - close [issue #74](https://github.com/j4mie/idiorm/issues/74)\n* Fix issue with aggregate functions always returning `int` when is `float` sometimes required - closes [issue #92](https://github.com/j4mie/idiorm/issues/92)\n* Move testing into PHPUnit to unify method testing and query generation testing\n\n#### 1.2.3 - released 2012-11-28\n\n* Fix [issue #78](https://github.com/j4mie/idiorm/issues/78) - remove use of PHP 5.3 static call\n\n#### 1.2.2 - released 2012-11-15\n\n* Fix bug where input parameters were sent as part-indexed, part associative\n\n#### 1.2.1 - released 2012-11-15\n\n* Fix minor bug caused by IdiormStringException not extending Exception\n\n#### 1.2.0 - released 2012-11-14\n\n* Setup composer for installation via packagist (j4mie/idiorm)\n* Add `order_by_expr` method [[sandermarechal](http://github.com/sandermarechal)]\n* Add support for raw queries without parameters argument [[sandermarechal](http://github.com/sandermarechal)]\n* Add support to set multiple properties at once by passing an associative array to `set` method [[sandermarechal](http://github.com/sandermarechal)]\n* Allow an associative array to be passed to `configure` method [[jordanlev](http://github.com/jordanlev)]\n* Patch to allow empty Paris models to be saved ([[j4mie/paris](http://github.com/j4mie/paris)]) - [issue #58](https://github.com/j4mie/idiorm/issues/58)\n* Add `select_many` and `select_many_expr` - closing issues [#49](https://github.com/j4mie/idiorm/issues/49) and [#69](https://github.com/j4mie/idiorm/issues/69)\n* Add support for `MIN`, `AVG`, `MAX` and `SUM` - closes [issue #16](https://github.com/j4mie/idiorm/issues/16)\n* Add `group_by_expr` - closes [issue #24](https://github.com/j4mie/idiorm/issues/24)\n* Add `set_expr` to allow database expressions to be set as ORM properties - closes issues [#59](https://github.com/j4mie/idiorm/issues/59) and [#43](https://github.com/j4mie/idiorm/issues/43) [[brianherbert](https://github.com/brianherbert)]\n* Prevent ambiguous column names when joining tables - [issue #66](https://github.com/j4mie/idiorm/issues/66) [[hellogerard](https://github.com/hellogerard)]\n* Add `delete_many` method [[CBeerta](https://github.com/CBeerta)]\n* Allow unsetting of ORM parameters [[CBeerta](https://github.com/CBeerta)]\n* Add `find_array` to get the records as associative arrays [[Surt](https://github.com/Surt)] - closes [issue #17](https://github.com/j4mie/idiorm/issues/17)\n* Fix bug in `_log_query` with `?` and `%` supplied in raw where statements etc. - closes [issue #57](https://github.com/j4mie/idiorm/issues/57) [[ridgerunner](https://github.com/ridgerunner)]\n\n#### 1.1.1 - released 2011-01-30\n\n* Fix bug in quoting column wildcard. j4mie/paris#12\n* Small documentation improvements\n\n#### 1.1.0 - released 2011-01-24\n\n* Add `is_dirty` method\n* Add basic query caching\n* Add `distinct` method\n* Add `group_by` method\n\n#### 1.0.0 - released 2010-12-01\n\n* Initial release\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.33203125,
          "content": "{\n    \"name\": \"j4mie/idiorm\",\n    \"type\": \"library\",\n    \"description\": \"A lightweight nearly-zero-configuration object-relational mapper and fluent query builder for PHP5\",\n    \"keywords\": [\"idiorm\", \"orm\", \"query builder\"],\n    \"homepage\": \"https://j4mie.github.io/idiormandparis\",\n    \"support\": {\n        \"issues\": \"https://github.com/j4mie/idiorm/issues\",\n        \"source\": \"https://github.com/j4mie/idiorm\"\n    },\n    \"authors\": [\n        {\n            \"name\": \"Jamie Matthews\",\n            \"email\": \"jamie.matthews@gmail.com\",\n            \"homepage\": \"http://j4mie.org\",\n            \"role\": \"Developer\"\n        },\n        {\n            \"name\": \"Simon Holywell\",\n            \"email\": \"treffynnon@php.net\",\n            \"homepage\": \"https://www.simonholywell.com\",\n            \"role\": \"Maintainer\"\n        },\n        {\n            \"name\": \"Durham Hale\",\n            \"email\": \"me@durhamhale.com\",\n            \"homepage\": \"http://durhamhale.com\",\n            \"role\": \"Maintainer\"\n        }\n    ],\n    \"scripts\": {\n        \"test\": \"phpunit -c ./phpunit.xml\"\n    },\n    \"require-dev\": {\n        \"phpunit/phpunit\": \"^4.8\",\n        \"ext-pdo_sqlite\": \"*\"\n    },\n    \"license\": [\n        \"BSD-2-Clause\",\n        \"BSD-3-Clause\",\n        \"BSD-4-Clause\"\n    ],\n    \"require\": {\n        \"php\": \">=5.2.0\"\n    },\n    \"autoload\": {\n        \"classmap\": [\"idiorm.php\"]\n    }\n}\n"
        },
        {
          "name": "demo.php",
          "type": "blob",
          "size": 2.353515625,
          "content": "<?php\n\n    // ------------------- //\n    // --- Idiorm Demo --- //\n    // ------------------- //\n\n    // Note: This is just about the simplest database-driven webapp it's possible to create\n    // and is designed only for the purpose of demonstrating how Idiorm works.\n\n    // In case it's not obvious: this is not the correct way to build web applications!\n\n    // Require the idiorm file\n    require_once(\"idiorm.php\");\n\n    // Connect to the demo database file\n    ORM::configure('sqlite:./demo.sqlite');\n\n    // This grabs the raw database connection from the ORM\n    // class and creates the table if it doesn't already exist.\n    // Wouldn't normally be needed if the table is already there.\n    $db = ORM::get_db();\n    $db->exec(\"\n        CREATE TABLE IF NOT EXISTS contact (\n            id INTEGER PRIMARY KEY, \n            name TEXT, \n            email TEXT \n        );\"\n    );\n\n    // Handle POST submission\n    if (!empty($_POST)) {\n        \n        // Create a new contact object\n        $contact = ORM::for_table('contact')->create();\n\n        // SHOULD BE MORE ERROR CHECKING HERE!\n\n        // Set the properties of the object\n        $contact->name = $_POST['name'];\n        $contact->email = $_POST['email'];\n\n        // Save the object to the database\n        $contact->save();\n        \n        // Redirect to self.\n        header('Location: ' . basename(__FILE__));\n        exit;\n    }\n\n    // Get a list of all contacts from the database\n    $count = ORM::for_table('contact')->count();\n    $contact_list = ORM::for_table('contact')->find_many();\n?>\n\n<html>\n    <head>\n        <title>Idiorm Demo</title>\n    </head>\n\n    <body>\n    \n        <h1>Idiorm Demo</h1>\n\n        <h2>Contact List (<?php echo $count; ?> contacts)</h2>\n        <ul>\n            <?php foreach ($contact_list as $contact): ?>\n                <li>\n                    <strong><?php echo $contact->name ?></strong>\n                    <a href=\"mailto:<?php echo $contact->email; ?>\"><?php echo $contact->email; ?></a>\n                </li>\n            <?php endforeach; ?>\n        </ul>\n\n        <form method=\"post\" action=\"\">\n            <h2>Add Contact</h2>\n            <p><label for=\"name\">Name:</label> <input type=\"text\" name=\"name\" /></p>\n            <p><label for=\"email\">Email:</label> <input type=\"email\" name=\"email\" /></p>\n            <input type=\"submit\" value=\"Create\" />\n        </form>\n    </body>\n</html>\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "idiorm.php",
          "type": "blob",
          "size": 95.453125,
          "content": "<?php\n\n    /**\n     *\n     * Idiorm\n     *\n     * http://github.com/j4mie/idiorm/\n     *\n     * A single-class super-simple database abstraction layer for PHP.\n     * Provides (nearly) zero-configuration object-relational mapping\n     * and a fluent interface for building basic, commonly-used queries.\n     *\n     * BSD Licensed.\n     *\n     * Copyright (c) 2010, Jamie Matthews\n     * All rights reserved.\n     *\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are met:\n     *\n     * * Redistributions of source code must retain the above copyright notice, this\n     *   list of conditions and the following disclaimer.\n     *\n     * * Redistributions in binary form must reproduce the above copyright notice,\n     *   this list of conditions and the following disclaimer in the documentation\n     *   and/or other materials provided with the distribution.\n     *\n     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     *\n     *\n     * The methods documented below are magic methods that conform to PSR-1.\n     * This documentation exposes these methods to doc generators and IDEs.\n     * @see http://www.php-fig.org/psr/psr-1/\n     *\n     * @method static array|string getConfig($key = null, $connection_name = self::DEFAULT_CONNECTION)\n     * @method static null resetConfig()\n     * @method static \\ORM forTable($table_name, $connection_name = self::DEFAULT_CONNECTION)\n     * @method static null setDb($db, $connection_name = self::DEFAULT_CONNECTION)\n     * @method static null resetDb()\n     * @method static null setupLimitClauseStyle($connection_name)\n     * @method static \\PDO getDb($connection_name = self::DEFAULT_CONNECTION)\n     * @method static bool rawExecute($query, $parameters = array())\n     * @method static \\PDOStatement getLastStatement()\n     * @method static string getLastQuery($connection_name = null)\n     * @method static array getQueryLog($connection_name = self::DEFAULT_CONNECTION)\n     * @method array getConnectionNames()\n     * @method $this useIdColumn($id_column)\n     * @method \\ORM|bool findOne($id=null)\n     * @method array|\\IdiormResultSet findMany()\n     * @method \\IdiormResultSet findResultSet()\n     * @method array findArray()\n     * @method $this forceAllDirty()\n     * @method $this rawQuery($query, $parameters = array())\n     * @method $this tableAlias($alias)\n     * @method int countNullIdColumns()\n     * @method $this selectExpr($expr, $alias=null)\n     * @method \\ORM selectMany($values)\n     * @method \\ORM selectManyExpr($values)\n     * @method $this rawJoin($table, $constraint, $table_alias, $parameters = array())\n     * @method $this innerJoin($table, $constraint, $table_alias=null)\n     * @method $this leftOuterJoin($table, $constraint, $table_alias=null)\n     * @method $this rightOuterJoin($table, $constraint, $table_alias=null)\n     * @method $this fullOuterJoin($table, $constraint, $table_alias=null)\n     * @method $this whereEqual($column_name, $value=null)\n     * @method $this whereNotEqual($column_name, $value=null)\n     * @method $this whereIdIs($id)\n     * @method $this whereAnyIs($values, $operator='=')\n     * @method array|string whereIdIn($ids)\n     * @method $this whereLike($column_name, $value=null)\n     * @method $this whereNotLike($column_name, $value=null)\n     * @method $this whereGt($column_name, $value=null)\n     * @method $this whereLt($column_name, $value=null)\n     * @method $this whereGte($column_name, $value=null)\n     * @method $this whereLte($column_name, $value=null)\n     * @method $this whereIn($column_name, $values)\n     * @method $this whereNotIn($column_name, $values)\n     * @method $this whereNull($column_name)\n     * @method $this whereNotNull($column_name)\n     * @method $this whereRaw($clause, $parameters=array())\n     * @method $this orderByDesc($column_name)\n     * @method $this orderByAsc($column_name)\n     * @method $this orderByExpr($clause)\n     * @method $this groupBy($column_name)\n     * @method $this groupByExpr($expr)\n     * @method $this havingEqual($column_name, $value=null)\n     * @method $this havingNotEqual($column_name, $value=null)\n     * @method $this havingIdIs($id)\n     * @method $this havingLike($column_name, $value=null)\n     * @method $this havingNotLike($column_name, $value=null)\n     * @method $this havingGt($column_name, $value=null)\n     * @method $this havingLt($column_name, $value=null)\n     * @method $this havingGte($column_name, $value=null)\n     * @method $this havingLte($column_name, $value=null)\n     * @method $this havingIn($column_name, $values=null)\n     * @method $this havingNotIn($column_name, $values=null)\n     * @method $this havingNull($column_name)\n     * @method $this havingNotNull($column_name)\n     * @method $this havingRaw($clause, $parameters=array())\n     * @method static this clearCache($table_name = null, $connection_name = self::DEFAULT_CONNECTION)\n     * @method array asArray()\n     * @method bool setExpr($key, $value = null)\n     * @method bool isDirty($key)\n     * @method bool isNew()\n     */\n\n    class ORM implements ArrayAccess {\n\n        // ----------------------- //\n        // --- CLASS CONSTANTS --- //\n        // ----------------------- //\n\n        // WHERE and HAVING condition array keys\n        const CONDITION_FRAGMENT = 0;\n        const CONDITION_VALUES = 1;\n\n        const DEFAULT_CONNECTION = 'default';\n\n        // Limit clause style\n        const LIMIT_STYLE_TOP_N = \"top\";\n        const LIMIT_STYLE_LIMIT = \"limit\";\n\n        // ------------------------ //\n        // --- CLASS PROPERTIES --- //\n        // ------------------------ //\n\n        // Class configuration\n        protected static $_default_config = array(\n            'connection_string' => 'sqlite::memory:',\n            'id_column' => 'id',\n            'id_column_overrides' => array(),\n            'error_mode' => PDO::ERRMODE_EXCEPTION,\n            'username' => null,\n            'password' => null,\n            'driver_options' => null,\n            'identifier_quote_character' => null, // if this is null, will be autodetected\n            'limit_clause_style' => null, // if this is null, will be autodetected\n            'logging' => false,\n            'logger' => null,\n            'caching' => false,\n            'caching_auto_clear' => false,\n            'return_result_sets' => false,\n        );\n\n        // Map of configuration settings\n        protected static $_config = array();\n\n        // Map of database connections, instances of the PDO class\n        protected static $_db = array();\n\n        // Last query run, only populated if logging is enabled\n        protected static $_last_query;\n\n        // Log of all queries run, mapped by connection key, only populated if logging is enabled\n        protected static $_query_log = array();\n\n        // Query cache, only used if query caching is enabled\n        protected static $_query_cache = array();\n\n        // Reference to previously used PDOStatement object to enable low-level access, if needed\n        protected static $_last_statement = null;\n\n        // --------------------------- //\n        // --- INSTANCE PROPERTIES --- //\n        // --------------------------- //\n\n        // Key name of the connections in self::$_db used by this instance\n        protected $_connection_name;\n\n        // The name of the table the current ORM instance is associated with\n        protected $_table_name;\n\n        // Alias for the table to be used in SELECT queries\n        protected $_table_alias = null;\n\n        // Values to be bound to the query\n        protected $_values = array();\n\n        // Columns to select in the result\n        protected $_result_columns = array('*');\n\n        // Are we using the default result column or have these been manually changed?\n        protected $_using_default_result_columns = true;\n\n        // Join sources\n        protected $_join_sources = array();\n\n        // Should the query include a DISTINCT keyword?\n        protected $_distinct = false;\n\n        // Is this a raw query?\n        protected $_is_raw_query = false;\n\n        // The raw query\n        protected $_raw_query = '';\n\n        // The raw query parameters\n        protected $_raw_parameters = array();\n\n        // Array of WHERE clauses\n        protected $_where_conditions = array();\n\n        // LIMIT\n        protected $_limit = null;\n\n        // OFFSET\n        protected $_offset = null;\n\n        // ORDER BY\n        protected $_order_by = array();\n\n        // GROUP BY\n        protected $_group_by = array();\n\n        // HAVING\n        protected $_having_conditions = array();\n\n        // The data for a hydrated instance of the class\n        protected $_data = array();\n\n        // Fields that have been modified during the\n        // lifetime of the object\n        protected $_dirty_fields = array();\n\n        // Fields that are to be inserted in the DB raw\n        protected $_expr_fields = array();\n\n        // Is this a new object (has create() been called)?\n        protected $_is_new = false;\n\n        // Name of the column to use as the primary key for\n        // this instance only. Overrides the config settings.\n        protected $_instance_id_column = null;\n\n        // ---------------------- //\n        // --- STATIC METHODS --- //\n        // ---------------------- //\n\n        /**\n         * Pass configuration settings to the class in the form of\n         * key/value pairs. As a shortcut, if the second argument\n         * is omitted and the key is a string, the setting is\n         * assumed to be the DSN string used by PDO to connect\n         * to the database (often, this will be the only configuration\n         * required to use Idiorm). If you have more than one setting\n         * you wish to configure, another shortcut is to pass an array\n         * of settings (and omit the second argument).\n         * @param string|array $key\n         * @param mixed $value\n         * @param string $connection_name Which connection to use\n         */\n        public static function configure($key, $value = null, $connection_name = self::DEFAULT_CONNECTION) {\n            self::_setup_db_config($connection_name); //ensures at least default config is set\n\n            if (is_array($key)) {\n                // Shortcut: If only one array argument is passed,\n                // assume it's an array of configuration settings\n                foreach ($key as $conf_key => $conf_value) {\n                    self::configure($conf_key, $conf_value, $connection_name);\n                }\n            } else {\n                if (is_null($value)) {\n                    // Shortcut: If only one string argument is passed, \n                    // assume it's a connection string\n                    $value = $key;\n                    $key = 'connection_string';\n                }\n                self::$_config[$connection_name][$key] = $value;\n            }\n        }\n\n        /**\n         * Retrieve configuration options by key, or as whole array.\n         * @param string $key\n         * @param string $connection_name Which connection to use\n         */\n        public static function get_config($key = null, $connection_name = self::DEFAULT_CONNECTION) {\n            if ($key) {\n                return self::$_config[$connection_name][$key];\n            } else {\n                return self::$_config[$connection_name];\n            }\n        }\n\n        /**\n         * Delete all configs in _config array.\n         */\n        public static function reset_config() {\n            self::$_config = array();\n        }\n        \n        /**\n         * Despite its slightly odd name, this is actually the factory\n         * method used to acquire instances of the class. It is named\n         * this way for the sake of a readable interface, ie\n         * ORM::for_table('table_name')->find_one()-> etc. As such,\n         * this will normally be the first method called in a chain.\n         * @param string $table_name\n         * @param string $connection_name Which connection to use\n         * @return ORM\n         */\n        public static function for_table($table_name, $connection_name = self::DEFAULT_CONNECTION) {\n            self::_setup_db($connection_name);\n            return new self($table_name, array(), $connection_name);\n        }\n\n        /**\n         * Set up the database connection used by the class\n         * @param string $connection_name Which connection to use\n         */\n        protected static function _setup_db($connection_name = self::DEFAULT_CONNECTION) {\n            if (!array_key_exists($connection_name, self::$_db) ||\n                !is_object(self::$_db[$connection_name])) {\n                self::_setup_db_config($connection_name);\n\n                $db = new PDO(\n                    self::$_config[$connection_name]['connection_string'],\n                    self::$_config[$connection_name]['username'],\n                    self::$_config[$connection_name]['password'],\n                    self::$_config[$connection_name]['driver_options']\n                );\n\n                $db->setAttribute(PDO::ATTR_ERRMODE, self::$_config[$connection_name]['error_mode']);\n                self::set_db($db, $connection_name);\n            }\n        }\n\n       /**\n        * Ensures configuration (multiple connections) is at least set to default.\n        * @param string $connection_name Which connection to use\n        */\n        protected static function _setup_db_config($connection_name) {\n            if (!array_key_exists($connection_name, self::$_config)) {\n                self::$_config[$connection_name] = self::$_default_config;\n            }\n        }\n\n        /**\n         * Set the PDO object used by Idiorm to communicate with the database.\n         * This is public in case the ORM should use a ready-instantiated\n         * PDO object as its database connection. Accepts an optional string key\n         * to identify the connection if multiple connections are used.\n         * @param PDO $db\n         * @param string $connection_name Which connection to use\n         */\n        public static function set_db($db, $connection_name = self::DEFAULT_CONNECTION) {\n            self::_setup_db_config($connection_name);\n            self::$_db[$connection_name] = $db;\n            if(!is_null(self::$_db[$connection_name])) {\n                self::_setup_identifier_quote_character($connection_name);\n                self::_setup_limit_clause_style($connection_name);\n            }\n        }\n\n        /**\n         * Close and delete all registered PDO objects in _db array.\n         */\n        public static function reset_db() {\n            self::$_db = null;\n\n            self::$_db = array();\n        }\n\n        /**\n         * Detect and initialise the character used to quote identifiers\n         * (table names, column names etc). If this has been specified\n         * manually using ORM::configure('identifier_quote_character', 'some-char'),\n         * this will do nothing.\n         * @param string $connection_name Which connection to use\n         */\n        protected static function _setup_identifier_quote_character($connection_name) {\n            if (is_null(self::$_config[$connection_name]['identifier_quote_character'])) {\n                self::$_config[$connection_name]['identifier_quote_character'] =\n                    self::_detect_identifier_quote_character($connection_name);\n            }\n        }\n\n        /**\n         * Detect and initialise the limit clause style (\"SELECT TOP 5\" /\n         * \"... LIMIT 5\"). If this has been specified manually using \n         * ORM::configure('limit_clause_style', 'top'), this will do nothing.\n         * @param string $connection_name Which connection to use\n         */\n        public static function _setup_limit_clause_style($connection_name) {\n            if (is_null(self::$_config[$connection_name]['limit_clause_style'])) {\n                self::$_config[$connection_name]['limit_clause_style'] =\n                    self::_detect_limit_clause_style($connection_name);\n            }\n        }\n\n        /**\n         * Return the correct character used to quote identifiers (table\n         * names, column names etc) by looking at the driver being used by PDO.\n         * @param string $connection_name Which connection to use\n         * @return string\n         */\n        protected static function _detect_identifier_quote_character($connection_name) {\n            switch(self::get_db($connection_name)->getAttribute(PDO::ATTR_DRIVER_NAME)) {\n                case 'pgsql':\n                case 'sqlsrv':\n                case 'dblib':\n                case 'mssql':\n                case 'sybase':\n                case 'firebird':\n                    return '\"';\n                case 'mysql':\n                case 'sqlite':\n                case 'sqlite2':\n                default:\n                    return '`';\n            }\n        }\n\n        /**\n         * Returns a constant after determining the appropriate limit clause\n         * style\n         * @param string $connection_name Which connection to use\n         * @return string Limit clause style keyword/constant\n         */\n        protected static function _detect_limit_clause_style($connection_name) {\n            switch(self::get_db($connection_name)->getAttribute(PDO::ATTR_DRIVER_NAME)) {\n                case 'sqlsrv':\n                case 'dblib':\n                case 'mssql':\n                    return ORM::LIMIT_STYLE_TOP_N;\n                default:\n                    return ORM::LIMIT_STYLE_LIMIT;\n            }\n        }\n\n        /**\n         * Returns the PDO instance used by the the ORM to communicate with\n         * the database. This can be called if any low-level DB access is\n         * required outside the class. If multiple connections are used,\n         * accepts an optional key name for the connection.\n         * @param string $connection_name Which connection to use\n         * @return PDO\n         */\n        public static function get_db($connection_name = self::DEFAULT_CONNECTION) {\n            self::_setup_db($connection_name); // required in case this is called before Idiorm is instantiated\n            return self::$_db[$connection_name];\n        }\n\n        /**\n         * Executes a raw query as a wrapper for PDOStatement::execute.\n         * Useful for queries that can't be accomplished through Idiorm,\n         * particularly those using engine-specific features.\n         * @example raw_execute('SELECT `name`, AVG(`order`) FROM `customer` GROUP BY `name` HAVING AVG(`order`) > 10')\n         * @example raw_execute('INSERT OR REPLACE INTO `widget` (`id`, `name`) SELECT `id`, `name` FROM `other_table`')\n         * @param string $query The raw SQL query\n         * @param array  $parameters Optional bound parameters\n         * @param string $connection_name Which connection to use\n         * @return bool Success\n         */\n        public static function raw_execute($query, $parameters = array(), $connection_name = self::DEFAULT_CONNECTION) {\n            self::_setup_db($connection_name);\n            return self::_execute($query, $parameters, $connection_name);\n        }\n\n        /**\n         * Returns the PDOStatement instance last used by any connection wrapped by the ORM.\n         * Useful for access to PDOStatement::rowCount() or error information\n         * @return PDOStatement\n         */\n        public static function get_last_statement() {\n            return self::$_last_statement;\n        }\n\n       /**\n        * Internal helper method for executing statments. Logs queries, and\n        * stores statement object in ::_last_statment, accessible publicly\n        * through ::get_last_statement()\n        * @param string $query\n        * @param array $parameters An array of parameters to be bound in to the query\n        * @param string $connection_name Which connection to use\n        * @return bool Response of PDOStatement::execute()\n        */\n        protected static function _execute($query, $parameters = array(), $connection_name = self::DEFAULT_CONNECTION) {\n            $statement = self::get_db($connection_name)->prepare($query);\n            self::$_last_statement = $statement;\n            $time = microtime(true);\n\n            foreach ($parameters as $key => &$param) {\n                if (is_null($param)) {\n                    $type = PDO::PARAM_NULL;\n                } else if (is_bool($param)) {\n                    $type = PDO::PARAM_BOOL;\n                } else if (is_int($param)) {\n                    $type = PDO::PARAM_INT;\n                } else {\n                    $type = PDO::PARAM_STR;\n                }\n\n                $statement->bindParam(is_int($key) ? ++$key : $key, $param, $type);\n            }\n\n            $q = $statement->execute();\n            self::_log_query($query, $parameters, $connection_name, (microtime(true)-$time));\n\n            return $q;\n        }\n\n        /**\n         * Add a query to the internal query log. Only works if the\n         * 'logging' config option is set to true.\n         *\n         * This works by manually binding the parameters to the query - the\n         * query isn't executed like this (PDO normally passes the query and\n         * parameters to the database which takes care of the binding) but\n         * doing it this way makes the logged queries more readable.\n         * @param string $query\n         * @param array $parameters An array of parameters to be bound in to the query\n         * @param string $connection_name Which connection to use\n\t\t * @param float $query_time Query time\n         * @return bool\n         */\n        protected static function _log_query($query, $parameters, $connection_name, $query_time) {\n            // If logging is not enabled, do nothing\n            if (!self::$_config[$connection_name]['logging']) {\n                return false;\n            }\n\n            if (!isset(self::$_query_log[$connection_name])) {\n                self::$_query_log[$connection_name] = array();\n            }\n\n            if (empty($parameters)) {\n                $bound_query = $query;\n            } else {\n                // Escape the parameters\n                $parameters = array_map(array(self::get_db($connection_name), 'quote'), $parameters);\n\n                if (array_values($parameters) === $parameters) {\n                    // ? placeholders\n                    // Avoid %format collision for vsprintf\n                    $query = str_replace(\"%\", \"%%\", $query);\n\n                    // Replace placeholders in the query for vsprintf\n                    if(false !== strpos($query, \"'\") || false !== strpos($query, '\"')) {\n                        $query = IdiormString::str_replace_outside_quotes(\"?\", \"%s\", $query);\n                    } else {\n                        $query = str_replace(\"?\", \"%s\", $query);\n                    }\n\n                    // Replace the question marks in the query with the parameters\n                    $bound_query = vsprintf($query, $parameters);\n                } else {\n                    // named placeholders\n                    foreach ($parameters as $key => $val) {\n                        $query = str_replace($key, $val, $query);\n                    }\n                    $bound_query = $query;\n                }\n            }\n\n            self::$_last_query = $bound_query;\n            self::$_query_log[$connection_name][] = $bound_query;\n            \n            \n            if(is_callable(self::$_config[$connection_name]['logger'])){\n                $logger = self::$_config[$connection_name]['logger'];\n                $logger($bound_query, $query_time);\n            }\n            \n            return true;\n        }\n\n        /**\n         * Get the last query executed. Only works if the\n         * 'logging' config option is set to true. Otherwise\n         * this will return null. Returns last query from all connections if\n         * no connection_name is specified\n         * @param null|string $connection_name Which connection to use\n         * @return string\n         */\n        public static function get_last_query($connection_name = null) {\n            if ($connection_name === null) {\n                return self::$_last_query;\n            }\n            if (!isset(self::$_query_log[$connection_name])) {\n                return '';\n            }\n\n            return end(self::$_query_log[$connection_name]);\n        }\n\n        /**\n         * Get an array containing all the queries run on a\n         * specified connection up to now.\n         * Only works if the 'logging' config option is\n         * set to true. Otherwise, returned array will be empty.\n         * @param string $connection_name Which connection to use\n         */\n        public static function get_query_log($connection_name = self::DEFAULT_CONNECTION) {\n            if (isset(self::$_query_log[$connection_name])) {\n                return self::$_query_log[$connection_name];\n            }\n            return array();\n        }\n\n        /**\n         * Get a list of the available connection names\n         * @return array\n         */\n        public static function get_connection_names() {\n            return array_keys(self::$_db);\n        }\n\n        // ------------------------ //\n        // --- INSTANCE METHODS --- //\n        // ------------------------ //\n\n        /**\n         * \"Private\" constructor; shouldn't be called directly.\n         * Use the ORM::for_table factory method instead.\n         */\n        protected function __construct($table_name, $data = array(), $connection_name = self::DEFAULT_CONNECTION) {\n            $this->_table_name = $table_name;\n            $this->_data = $data;\n\n            $this->_connection_name = $connection_name;\n            self::_setup_db_config($connection_name);\n        }\n\n        /**\n         * Create a new, empty instance of the class. Used\n         * to add a new row to your database. May optionally\n         * be passed an associative array of data to populate\n         * the instance. If so, all fields will be flagged as\n         * dirty so all will be saved to the database when\n         * save() is called.\n         */\n        public function create($data=null) {\n            $this->_is_new = true;\n            if (!is_null($data)) {\n                return $this->hydrate($data)->force_all_dirty();\n            }\n            return $this;\n        }\n\n        /**\n         * Specify the ID column to use for this instance or array of instances only.\n         * This overrides the id_column and id_column_overrides settings.\n         *\n         * This is mostly useful for libraries built on top of Idiorm, and will\n         * not normally be used in manually built queries. If you don't know why\n         * you would want to use this, you should probably just ignore it.\n         */\n        public function use_id_column($id_column) {\n            $this->_instance_id_column = $id_column;\n            return $this;\n        }\n\n        /**\n         * Create an ORM instance from the given row (an associative\n         * array of data fetched from the database)\n         */\n        protected function _create_instance_from_row($row) {\n            $instance = self::for_table($this->_table_name, $this->_connection_name);\n            $instance->use_id_column($this->_instance_id_column);\n            $instance->hydrate($row);\n            return $instance;\n        }\n\n        /**\n         * Tell the ORM that you are expecting a single result\n         * back from your query, and execute it. Will return\n         * a single instance of the ORM class, or false if no\n         * rows were returned.\n         * As a shortcut, you may supply an ID as a parameter\n         * to this method. This will perform a primary key\n         * lookup on the table.\n         */\n        public function find_one($id=null) {\n            if (!is_null($id)) {\n                $this->where_id_is($id);\n            }\n            $this->limit(1);\n            $rows = $this->_run();\n\n            if (empty($rows)) {\n                return false;\n            }\n\n            return $this->_create_instance_from_row($rows[0]);\n        }\n\n        /**\n         * Tell the ORM that you are expecting multiple results\n         * from your query, and execute it. Will return an array\n         * of instances of the ORM class, or an empty array if\n         * no rows were returned.\n         * @return array|\\IdiormResultSet\n         */\n        public function find_many() {\n            if(self::$_config[$this->_connection_name]['return_result_sets']) {\n                return $this->find_result_set();\n            }\n            return $this->_find_many();\n        }\n\n        /**\n         * Tell the ORM that you are expecting multiple results\n         * from your query, and execute it. Will return an array\n         * of instances of the ORM class, or an empty array if\n         * no rows were returned.\n         * @return array\n         */\n        protected function _find_many() {\n            $rows = $this->_run();\n            return array_map(array($this, '_create_instance_from_row'), $rows);\n        }\n\n        /**\n         * Tell the ORM that you are expecting multiple results\n         * from your query, and execute it. Will return a result set object\n         * containing instances of the ORM class.\n         * @return \\IdiormResultSet\n         */\n        public function find_result_set() {\n            return new IdiormResultSet($this->_find_many());\n        }\n\n        /**\n         * Tell the ORM that you are expecting multiple results\n         * from your query, and execute it. Will return an array,\n         * or an empty array if no rows were returned.\n         * @return array\n         */\n        public function find_array() {\n            return $this->_run(); \n        }\n\n        /**\n         * Tell the ORM that you wish to execute a COUNT query.\n         * Will return an integer representing the number of\n         * rows returned.\n         */\n        public function count($column = '*') {\n            return $this->_call_aggregate_db_function(__FUNCTION__, $column);\n        }\n\n        /**\n         * Tell the ORM that you wish to execute a MAX query.\n         * Will return the max value of the choosen column.\n         */\n        public function max($column)  {\n            return $this->_call_aggregate_db_function(__FUNCTION__, $column);\n        }\n\n        /**\n         * Tell the ORM that you wish to execute a MIN query.\n         * Will return the min value of the choosen column.\n         */\n        public function min($column)  {\n            return $this->_call_aggregate_db_function(__FUNCTION__, $column);\n        }\n\n        /**\n         * Tell the ORM that you wish to execute a AVG query.\n         * Will return the average value of the choosen column.\n         */\n        public function avg($column)  {\n            return $this->_call_aggregate_db_function(__FUNCTION__, $column);\n        }\n\n        /**\n         * Tell the ORM that you wish to execute a SUM query.\n         * Will return the sum of the choosen column.\n         */\n        public function sum($column)  {\n            return $this->_call_aggregate_db_function(__FUNCTION__, $column);\n        }\n\n        /**\n         * Execute an aggregate query on the current connection.\n         * @param string $sql_function The aggregate function to call eg. MIN, COUNT, etc\n         * @param string $column The column to execute the aggregate query against\n         * @return int\n         */\n        protected function _call_aggregate_db_function($sql_function, $column) {\n            $alias = strtolower($sql_function);\n            $sql_function = strtoupper($sql_function);\n            if('*' != $column) {\n                $column = $this->_quote_identifier($column);\n            }\n            $result_columns = $this->_result_columns;\n            $this->_result_columns = array();\n            $this->select_expr(\"$sql_function($column)\", $alias);\n            $result = $this->find_one();\n            $this->_result_columns = $result_columns;\n\n            $return_value = 0;\n            if($result !== false && isset($result->$alias)) {\n                if (!is_numeric($result->$alias)) {\n                    $return_value = $result->$alias;\n                }\n                elseif((int) $result->$alias == (float) $result->$alias) {\n                    $return_value = (int) $result->$alias;\n                } else {\n                    $return_value = (float) $result->$alias;\n                }\n            }\n            return $return_value;\n        }\n\n         /**\n         * This method can be called to hydrate (populate) this\n         * instance of the class from an associative array of data.\n         * This will usually be called only from inside the class,\n         * but it's public in case you need to call it directly.\n         */\n        public function hydrate($data=array()) {\n            $this->_data = $data;\n            return $this;\n        }\n\n        /**\n         * Force the ORM to flag all the fields in the $data array\n         * as \"dirty\" and therefore update them when save() is called.\n         */\n        public function force_all_dirty() {\n            $this->_dirty_fields = $this->_data;\n            return $this;\n        }\n\n        /**\n         * Perform a raw query. The query can contain placeholders in\n         * either named or question mark style. If placeholders are\n         * used, the parameters should be an array of values which will\n         * be bound to the placeholders in the query. If this method\n         * is called, all other query building methods will be ignored.\n         */\n        public function raw_query($query, $parameters = array()) {\n            $this->_is_raw_query = true;\n            $this->_raw_query = $query;\n            $this->_raw_parameters = $parameters;\n            return $this;\n        }\n\n        /**\n         * Add an alias for the main table to be used in SELECT queries\n         */\n        public function table_alias($alias) {\n            $this->_table_alias = $alias;\n            return $this;\n        }\n\n        /**\n         * Internal method to add an unquoted expression to the set\n         * of columns returned by the SELECT query. The second optional\n         * argument is the alias to return the expression as.\n         */\n        protected function _add_result_column($expr, $alias=null) {\n            if (!is_null($alias)) {\n                $expr .= \" AS \" . $this->_quote_identifier($alias);\n            }\n\n            if ($this->_using_default_result_columns) {\n                $this->_result_columns = array($expr);\n                $this->_using_default_result_columns = false;\n            } else {\n                $this->_result_columns[] = $expr;\n            }\n            return $this;\n        }\n\n        /**\n         * Counts the number of columns that belong to the primary\n         * key and their value is null.\n         */\n        public function count_null_id_columns() {\n            if (is_array($this->_get_id_column_name())) {\n                return count(array_filter($this->id(), 'is_null'));\n            } else {\n                return is_null($this->id()) ? 1 : 0;\n            }\n        }\n\n        /**\n         * Add a column to the list of columns returned by the SELECT\n         * query. This defaults to '*'. The second optional argument is\n         * the alias to return the column as.\n         */\n        public function select($column, $alias=null) {\n            $column = $this->_quote_identifier($column);\n            return $this->_add_result_column($column, $alias);\n        }\n\n        /**\n         * Add an unquoted expression to the list of columns returned\n         * by the SELECT query. The second optional argument is\n         * the alias to return the column as.\n         */\n        public function select_expr($expr, $alias=null) {\n            return $this->_add_result_column($expr, $alias);\n        }\n\n        /**\n         * Add columns to the list of columns returned by the SELECT\n         * query. This defaults to '*'. Many columns can be supplied\n         * as either an array or as a list of parameters to the method.\n         * \n         * Note that the alias must not be numeric - if you want a\n         * numeric alias then prepend it with some alpha chars. eg. a1\n         * \n         * @example select_many(array('alias' => 'column', 'column2', 'alias2' => 'column3'), 'column4', 'column5');\n         * @example select_many('column', 'column2', 'column3');\n         * @example select_many(array('column', 'column2', 'column3'), 'column4', 'column5');\n         * \n         * @return \\ORM\n         */\n        public function select_many() {\n            $columns = func_get_args();\n            if(!empty($columns)) {\n                $columns = $this->_normalise_select_many_columns($columns);\n                foreach($columns as $alias => $column) {\n                    if(is_numeric($alias)) {\n                        $alias = null;\n                    }\n                    $this->select($column, $alias);\n                }\n            }\n            return $this;\n        }\n\n        /**\n         * Add an unquoted expression to the list of columns returned\n         * by the SELECT query. Many columns can be supplied as either \n         * an array or as a list of parameters to the method.\n         * \n         * Note that the alias must not be numeric - if you want a\n         * numeric alias then prepend it with some alpha chars. eg. a1\n         * \n         * @example select_many_expr(array('alias' => 'column', 'column2', 'alias2' => 'column3'), 'column4', 'column5')\n         * @example select_many_expr('column', 'column2', 'column3')\n         * @example select_many_expr(array('column', 'column2', 'column3'), 'column4', 'column5')\n         * \n         * @return \\ORM\n         */\n        public function select_many_expr() {\n            $columns = func_get_args();\n            if(!empty($columns)) {\n                $columns = $this->_normalise_select_many_columns($columns);\n                foreach($columns as $alias => $column) {\n                    if(is_numeric($alias)) {\n                        $alias = null;\n                    }\n                    $this->select_expr($column, $alias);\n                }\n            }\n            return $this;\n        }\n\n        /**\n         * Take a column specification for the select many methods and convert it\n         * into a normalised array of columns and aliases.\n         * \n         * It is designed to turn the following styles into a normalised array:\n         * \n         * array(array('alias' => 'column', 'column2', 'alias2' => 'column3'), 'column4', 'column5'))\n         * \n         * @param array $columns\n         * @return array\n         */\n        protected function _normalise_select_many_columns($columns) {\n            $return = array();\n            foreach($columns as $column) {\n                if(is_array($column)) {\n                    foreach($column as $key => $value) {\n                        if(!is_numeric($key)) {\n                            $return[$key] = $value;\n                        } else {\n                            $return[] = $value;\n                        }\n                    }\n                } else {\n                    $return[] = $column;\n                }\n            }\n            return $return;\n        }\n\n        /**\n         * Add a DISTINCT keyword before the list of columns in the SELECT query\n         */\n        public function distinct() {\n            $this->_distinct = true;\n            return $this;\n        }\n\n        /**\n         * Internal method to add a JOIN source to the query.\n         *\n         * The join_operator should be one of INNER, LEFT OUTER, CROSS etc - this\n         * will be prepended to JOIN.\n         *\n         * The table should be the name of the table to join to.\n         *\n         * The constraint may be either a string or an array with three elements. If it\n         * is a string, it will be compiled into the query as-is, with no escaping. The\n         * recommended way to supply the constraint is as an array with three elements:\n         *\n         * first_column, operator, second_column\n         *\n         * Example: array('user.id', '=', 'profile.user_id')\n         *\n         * will compile to\n         *\n         * ON `user`.`id` = `profile`.`user_id`\n         *\n         * The final (optional) argument specifies an alias for the joined table.\n         */\n        protected function _add_join_source($join_operator, $table, $constraint, $table_alias=null) {\n\n            $join_operator = trim(\"{$join_operator} JOIN\");\n\n            $table = $this->_quote_identifier($table);\n\n            // Add table alias if present\n            if (!is_null($table_alias)) {\n                $table_alias = $this->_quote_identifier($table_alias);\n                $table .= \" {$table_alias}\";\n            }\n\n            // Build the constraint\n            if (is_array($constraint)) {\n                list($first_column, $operator, $second_column) = $constraint;\n                $first_column = $this->_quote_identifier($first_column);\n                $second_column = $this->_quote_identifier($second_column);\n                $constraint = \"{$first_column} {$operator} {$second_column}\";\n            }\n\n            $this->_join_sources[] = \"{$join_operator} {$table} ON {$constraint}\";\n            return $this;\n        }\n\n        /**\n         * Add a RAW JOIN source to the query\n         */\n        public function raw_join($table, $constraint, $table_alias, $parameters = array()) {\n            // Add table alias if present\n            if (!is_null($table_alias)) {\n                $table_alias = $this->_quote_identifier($table_alias);\n                $table .= \" {$table_alias}\";\n            }\n\n            $this->_values = array_merge($this->_values, $parameters);\n\n            // Build the constraint\n            if (is_array($constraint)) {\n                list($first_column, $operator, $second_column) = $constraint;\n                $first_column = $this->_quote_identifier($first_column);\n                $second_column = $this->_quote_identifier($second_column);\n                $constraint = \"{$first_column} {$operator} {$second_column}\";\n            }\n\n            $this->_join_sources[] = \"{$table} ON {$constraint}\";\n            return $this;\n        }\n\n        /**\n         * Add a simple JOIN source to the query\n         */\n        public function join($table, $constraint, $table_alias=null) {\n            return $this->_add_join_source(\"\", $table, $constraint, $table_alias);\n        }\n\n        /**\n         * Add an INNER JOIN souce to the query\n         */\n        public function inner_join($table, $constraint, $table_alias=null) {\n            return $this->_add_join_source(\"INNER\", $table, $constraint, $table_alias);\n        }\n\n        /**\n         * Add a LEFT OUTER JOIN souce to the query\n         */\n        public function left_outer_join($table, $constraint, $table_alias=null) {\n            return $this->_add_join_source(\"LEFT OUTER\", $table, $constraint, $table_alias);\n        }\n\n        /**\n         * Add an RIGHT OUTER JOIN souce to the query\n         */\n        public function right_outer_join($table, $constraint, $table_alias=null) {\n            return $this->_add_join_source(\"RIGHT OUTER\", $table, $constraint, $table_alias);\n        }\n\n        /**\n         * Add an FULL OUTER JOIN souce to the query\n         */\n        public function full_outer_join($table, $constraint, $table_alias=null) {\n            return $this->_add_join_source(\"FULL OUTER\", $table, $constraint, $table_alias);\n        }\n\n        /**\n         * Internal method to add a HAVING condition to the query\n         */\n        protected function _add_having($fragment, $values=array()) {\n            return $this->_add_condition('having', $fragment, $values);\n        }\n\n        /**\n         * Internal method to add a HAVING condition to the query\n         */\n        protected function _add_simple_having($column_name, $separator, $value) {\n            return $this->_add_simple_condition('having', $column_name, $separator, $value);\n        }\n\n        /**\n         * Internal method to add a HAVING clause with multiple values (like IN and NOT IN)\n         */\n        public function _add_having_placeholder($column_name, $separator, $values) {\n            if (!is_array($column_name)) {\n                $data = array($column_name => $values);\n            } else {\n                $data = $column_name;\n            }\n            $result = $this;\n            foreach ($data as $key => $val) {\n                $column = $result->_quote_identifier($key);\n                $placeholders = $result->_create_placeholders($val);\n                $result = $result->_add_having(\"{$column} {$separator} ({$placeholders})\", $val);    \n            }\n            return $result;\n        }\n\n        /**\n         * Internal method to add a HAVING clause with no parameters(like IS NULL and IS NOT NULL)\n         */\n        public function _add_having_no_value($column_name, $operator) {\n            $conditions = (is_array($column_name)) ? $column_name : array($column_name);\n            $result = $this;\n            foreach($conditions as $column) {\n                $column = $this->_quote_identifier($column);\n                $result = $result->_add_having(\"{$column} {$operator}\");\n            }\n            return $result;\n        }\n\n        /**\n         * Internal method to add a WHERE condition to the query\n         */\n        protected function _add_where($fragment, $values=array()) {\n            return $this->_add_condition('where', $fragment, $values);\n        }\n\n        /**\n         * Internal method to add a WHERE condition to the query\n         */\n        protected function _add_simple_where($column_name, $separator, $value) {\n            return $this->_add_simple_condition('where', $column_name, $separator, $value);\n        }\n\n        /**\n         * Add a WHERE clause with multiple values (like IN and NOT IN)\n         */\n        public function _add_where_placeholder($column_name, $separator, $values) {\n            if (!is_array($column_name)) {\n                $data = array($column_name => $values);\n            } else {\n                $data = $column_name;\n            }\n            $result = $this;\n            foreach ($data as $key => $val) {\n                $column = $result->_quote_identifier($key);\n                $placeholders = $result->_create_placeholders($val);\n                $result = $result->_add_where(\"{$column} {$separator} ({$placeholders})\", $val);    \n            }\n            return $result;\n        }\n\n        /**\n         * Add a WHERE clause with no parameters(like IS NULL and IS NOT NULL)\n         */\n        public function _add_where_no_value($column_name, $operator) {\n            $conditions = (is_array($column_name)) ? $column_name : array($column_name);\n            $result = $this;\n            foreach($conditions as $column) {\n                $column = $this->_quote_identifier($column);\n                $result = $result->_add_where(\"{$column} {$operator}\");\n            }\n            return $result;\n        }\n\n        /**\n         * Internal method to add a HAVING or WHERE condition to the query\n         */\n        protected function _add_condition($type, $fragment, $values=array()) {\n            $conditions_class_property_name = \"_{$type}_conditions\";\n            if (!is_array($values)) {\n                $values = array($values);\n            }\n            array_push($this->$conditions_class_property_name, array(\n                self::CONDITION_FRAGMENT => $fragment,\n                self::CONDITION_VALUES => $values,\n            ));\n            return $this;\n        }\n\n       /**\n         * Helper method to compile a simple COLUMN SEPARATOR VALUE\n         * style HAVING or WHERE condition into a string and value ready to\n         * be passed to the _add_condition method. Avoids duplication\n         * of the call to _quote_identifier\n         *\n         * If column_name is an associative array, it will add a condition for each column\n         */\n        protected function _add_simple_condition($type, $column_name, $separator, $value) {\n            $multiple = is_array($column_name) ? $column_name : array($column_name => $value);\n            $result = $this;\n\n            foreach($multiple as $key => $val) {\n                // Add the table name in case of ambiguous columns\n                if (count($result->_join_sources) > 0 && strpos($key, '.') === false) {\n                    $table = $result->_table_name;\n                    if (!is_null($result->_table_alias)) {\n                        $table = $result->_table_alias;\n                    }\n\n                    $key = \"{$table}.{$key}\";\n                }\n                $key = $result->_quote_identifier($key);\n                $result = $result->_add_condition($type, \"{$key} {$separator} ?\", $val);\n            }\n            return $result;\n        } \n\n        /**\n         * Return a string containing the given number of question marks,\n         * separated by commas. Eg \"?, ?, ?\"\n         */\n        protected function _create_placeholders($fields) {\n            if(!empty($fields)) {\n                $db_fields = array();\n                foreach($fields as $key => $value) {\n                    // Process expression fields directly into the query\n                    if(array_key_exists($key, $this->_expr_fields)) {\n                        $db_fields[] = $value;\n                    } else {\n                        $db_fields[] = '?';\n                    }\n                }\n                return implode(', ', $db_fields);\n            }\n        }\n        \n        /**\n         * Helper method that filters a column/value array returning only those\n         * columns that belong to a compound primary key.\n         *\n         * If the key contains a column that does not exist in the given array,\n         * a null value will be returned for it.\n         */\n        protected function _get_compound_id_column_values($value) {\n            $filtered = array();\n            foreach($this->_get_id_column_name() as $key) {\n                $filtered[$key] = isset($value[$key]) ? $value[$key] : null;\n            }\n            return $filtered;\n        }\n\n       /**\n         * Helper method that filters an array containing compound column/value\n         * arrays.\n         */\n        protected function _get_compound_id_column_values_array($values) {\n            $filtered = array();\n            foreach($values as $value) {\n                $filtered[] = $this->_get_compound_id_column_values($value);\n            }\n            return $filtered;\n        }\n\n        /**\n         * Add a WHERE column = value clause to your query. Each time\n         * this is called in the chain, an additional WHERE will be\n         * added, and these will be ANDed together when the final query\n         * is built.\n         *\n         * If you use an array in $column_name, a new clause will be\n         * added for each element. In this case, $value is ignored.\n         */\n        public function where($column_name, $value=null) {\n            return $this->where_equal($column_name, $value);\n        }\n\n        /**\n         * More explicitly named version of for the where() method.\n         * Can be used if preferred.\n         */\n        public function where_equal($column_name, $value=null) {\n            return $this->_add_simple_where($column_name, '=', $value);\n        }\n\n        /**\n         * Add a WHERE column != value clause to your query.\n         */\n        public function where_not_equal($column_name, $value=null) {\n            return $this->_add_simple_where($column_name, '!=', $value);\n        }\n\n        /**\n         * Special method to query the table by its primary key\n         *\n         * If primary key is compound, only the columns that\n         * belong to they key will be used for the query\n         */\n        public function where_id_is($id) {\n            return (is_array($this->_get_id_column_name())) ?\n                $this->where($this->_get_compound_id_column_values($id), null) :\n                $this->where($this->_get_id_column_name(), $id);\n        }\n\n        /**\n         * Allows adding a WHERE clause that matches any of the conditions\n         * specified in the array. Each element in the associative array will\n         * be a different condition, where the key will be the column name.\n         *\n         * By default, an equal operator will be used against all columns, but\n         * it can be overriden for any or every column using the second parameter.\n         *\n         * Each condition will be ORed together when added to the final query.\n         */        \n        public function where_any_is($values, $operator='=') {\n            $data = array();\n            $query = array(\"((\");\n            $first = true;\n            foreach ($values as $value) {\n                if ($first) {\n                    $first = false;\n                } else {\n                    $query[] = \") OR (\";\n                }\n                $firstsub = true;\n                foreach($value as $key => $item) {\n                    $op = is_string($operator) ? $operator : (isset($operator[$key]) ? $operator[$key] : '=');\n                    if ($firstsub) {\n                        $firstsub = false;\n                    } else {\n                        $query[] = \"AND\";\n                    }\n                    $query[] = $this->_quote_identifier($key);\n                    $data[] = $item;\n                    $query[] = $op . \" ?\";\n                }\n            }\n            $query[] = \"))\";\n            return $this->where_raw(join(' ', $query), $data);\n        }\n\n        /**\n         * Similar to where_id_is() but allowing multiple primary keys.\n         *\n         * If primary key is compound, only the columns that\n         * belong to they key will be used for the query\n         */\n        public function where_id_in($ids) {\n            return (is_array($this->_get_id_column_name())) ?\n                $this->where_any_is($this->_get_compound_id_column_values_array($ids)) :\n                $this->where_in($this->_get_id_column_name(), $ids);\n        }\n\n        /**\n         * Add a WHERE ... LIKE clause to your query.\n         */\n        public function where_like($column_name, $value=null) {\n            return $this->_add_simple_where($column_name, 'LIKE', $value);\n        }\n\n        /**\n         * Add where WHERE ... NOT LIKE clause to your query.\n         */\n        public function where_not_like($column_name, $value=null) {\n            return $this->_add_simple_where($column_name, 'NOT LIKE', $value);\n        }\n\n        /**\n         * Add a WHERE ... > clause to your query\n         */\n        public function where_gt($column_name, $value=null) {\n            return $this->_add_simple_where($column_name, '>', $value);\n        }\n\n        /**\n         * Add a WHERE ... < clause to your query\n         */\n        public function where_lt($column_name, $value=null) {\n            return $this->_add_simple_where($column_name, '<', $value);\n        }\n\n        /**\n         * Add a WHERE ... >= clause to your query\n         */\n        public function where_gte($column_name, $value=null) {\n            return $this->_add_simple_where($column_name, '>=', $value);\n        }\n\n        /**\n         * Add a WHERE ... <= clause to your query\n         */\n        public function where_lte($column_name, $value=null) {\n            return $this->_add_simple_where($column_name, '<=', $value);\n        }\n\n        /**\n         * Add a WHERE ... IN clause to your query\n         */\n        public function where_in($column_name, $values) {\n            return $this->_add_where_placeholder($column_name, 'IN', $values);\n        }\n\n        /**\n         * Add a WHERE ... NOT IN clause to your query\n         */\n        public function where_not_in($column_name, $values) {\n            return $this->_add_where_placeholder($column_name, 'NOT IN', $values);\n        }\n\n        /**\n         * Add a WHERE column IS NULL clause to your query\n         */\n        public function where_null($column_name) {\n            return $this->_add_where_no_value($column_name, \"IS NULL\");\n        }\n\n        /**\n         * Add a WHERE column IS NOT NULL clause to your query\n         */\n        public function where_not_null($column_name) {\n            return $this->_add_where_no_value($column_name, \"IS NOT NULL\");\n        }\n\n        /**\n         * Add a raw WHERE clause to the query. The clause should\n         * contain question mark placeholders, which will be bound\n         * to the parameters supplied in the second argument.\n         */\n        public function where_raw($clause, $parameters=array()) {\n            return $this->_add_where($clause, $parameters);\n        }\n\n        /**\n         * Add a LIMIT to the query\n         */\n        public function limit($limit) {\n            $this->_limit = $limit;\n            return $this;\n        }\n\n        /**\n         * Add an OFFSET to the query\n         */\n        public function offset($offset) {\n            $this->_offset = $offset;\n            return $this;\n        }\n\n        /**\n         * Add an ORDER BY clause to the query\n         */\n        protected function _add_order_by($column_name, $ordering) {\n            $column_name = $this->_quote_identifier($column_name);\n            $this->_order_by[] = \"{$column_name} {$ordering}\";\n            return $this;\n        }\n\n        /**\n         * Add an ORDER BY column DESC clause\n         */\n        public function order_by_desc($column_name) {\n            return $this->_add_order_by($column_name, 'DESC');\n        }\n\n        /**\n         * Add an ORDER BY column ASC clause\n         */\n        public function order_by_asc($column_name) {\n            return $this->_add_order_by($column_name, 'ASC');\n        }\n\n        /**\n         * Add an unquoted expression as an ORDER BY clause\n         */\n        public function order_by_expr($clause) {\n            $this->_order_by[] = $clause;\n            return $this;\n        }\n\n        /**\n         * Add a column to the list of columns to GROUP BY\n         */\n        public function group_by($column_name) {\n            $column_name = $this->_quote_identifier($column_name);\n            $this->_group_by[] = $column_name;\n            return $this;\n        }\n\n        /**\n         * Add an unquoted expression to the list of columns to GROUP BY \n         */\n        public function group_by_expr($expr) {\n            $this->_group_by[] = $expr;\n            return $this;\n        }\n\n        /**\n         * Add a HAVING column = value clause to your query. Each time\n         * this is called in the chain, an additional HAVING will be\n         * added, and these will be ANDed together when the final query\n         * is built.\n         *\n         * If you use an array in $column_name, a new clause will be\n         * added for each element. In this case, $value is ignored.\n         */\n        public function having($column_name, $value=null) {\n            return $this->having_equal($column_name, $value);\n        }\n\n        /**\n         * More explicitly named version of for the having() method.\n         * Can be used if preferred.\n         */\n        public function having_equal($column_name, $value=null) {\n            return $this->_add_simple_having($column_name, '=', $value);\n        }\n\n        /**\n         * Add a HAVING column != value clause to your query.\n         */\n        public function having_not_equal($column_name, $value=null) {\n            return $this->_add_simple_having($column_name, '!=', $value);\n        }\n\n        /**\n         * Special method to query the table by its primary key.\n         *\n         * If primary key is compound, only the columns that\n         * belong to they key will be used for the query\n         */\n        public function having_id_is($id) {\n            return (is_array($this->_get_id_column_name())) ?\n                $this->having($this->_get_compound_id_column_values($id), null) :\n                $this->having($this->_get_id_column_name(), $id);\n        }\n\n        /**\n         * Add a HAVING ... LIKE clause to your query.\n         */\n        public function having_like($column_name, $value=null) {\n            return $this->_add_simple_having($column_name, 'LIKE', $value);\n        }\n\n        /**\n         * Add where HAVING ... NOT LIKE clause to your query.\n         */\n        public function having_not_like($column_name, $value=null) {\n            return $this->_add_simple_having($column_name, 'NOT LIKE', $value);\n        }\n\n        /**\n         * Add a HAVING ... > clause to your query\n         */\n        public function having_gt($column_name, $value=null) {\n            return $this->_add_simple_having($column_name, '>', $value);\n        }\n\n        /**\n         * Add a HAVING ... < clause to your query\n         */\n        public function having_lt($column_name, $value=null) {\n            return $this->_add_simple_having($column_name, '<', $value);\n        }\n\n        /**\n         * Add a HAVING ... >= clause to your query\n         */\n        public function having_gte($column_name, $value=null) {\n            return $this->_add_simple_having($column_name, '>=', $value);\n        }\n\n        /**\n         * Add a HAVING ... <= clause to your query\n         */\n        public function having_lte($column_name, $value=null) {\n            return $this->_add_simple_having($column_name, '<=', $value);\n        }\n\n        /**\n         * Add a HAVING ... IN clause to your query\n         */\n        public function having_in($column_name, $values=null) {\n            return $this->_add_having_placeholder($column_name, 'IN', $values);\n        }\n\n        /**\n         * Add a HAVING ... NOT IN clause to your query\n         */\n        public function having_not_in($column_name, $values=null) {\n            return $this->_add_having_placeholder($column_name, 'NOT IN', $values);\n        }\n\n        /**\n         * Add a HAVING column IS NULL clause to your query\n         */\n        public function having_null($column_name) {\n            return $this->_add_having_no_value($column_name, 'IS NULL');\n        }\n\n        /**\n         * Add a HAVING column IS NOT NULL clause to your query\n         */\n        public function having_not_null($column_name) {\n            return $this->_add_having_no_value($column_name, 'IS NOT NULL');\n        }\n\n        /**\n         * Add a raw HAVING clause to the query. The clause should\n         * contain question mark placeholders, which will be bound\n         * to the parameters supplied in the second argument.\n         */\n        public function having_raw($clause, $parameters=array()) {\n            return $this->_add_having($clause, $parameters);\n        }\n\n        /**\n         * Build a SELECT statement based on the clauses that have\n         * been passed to this instance by chaining method calls.\n         */\n        protected function _build_select() {\n            // If the query is raw, just set the $this->_values to be\n            // the raw query parameters and return the raw query\n            if ($this->_is_raw_query) {\n                $this->_values = $this->_raw_parameters;\n                return $this->_raw_query;\n            }\n\n            // Build and return the full SELECT statement by concatenating\n            // the results of calling each separate builder method.\n            return $this->_join_if_not_empty(\" \", array(\n                $this->_build_select_start(),\n                $this->_build_join(),\n                $this->_build_where(),\n                $this->_build_group_by(),\n                $this->_build_having(),\n                $this->_build_order_by(),\n                $this->_build_limit(),\n                $this->_build_offset(),\n            ));\n        }\n\n        /**\n         * Build the start of the SELECT statement\n         */\n        protected function _build_select_start() {\n            $fragment = 'SELECT ';\n            $result_columns = join(', ', $this->_result_columns);\n\n            if (!is_null($this->_limit) &&\n                self::$_config[$this->_connection_name]['limit_clause_style'] === ORM::LIMIT_STYLE_TOP_N) {\n                $fragment .= \"TOP {$this->_limit} \";\n            }\n\n            if ($this->_distinct) {\n                $result_columns = 'DISTINCT ' . $result_columns;\n            }\n\n            $fragment .= \"{$result_columns} FROM \" . $this->_quote_identifier($this->_table_name);\n\n            if (!is_null($this->_table_alias)) {\n                $fragment .= \" \" . $this->_quote_identifier($this->_table_alias);\n            }\n            return $fragment;\n        }\n\n        /**\n         * Build the JOIN sources\n         */\n        protected function _build_join() {\n            if (count($this->_join_sources) === 0) {\n                return '';\n            }\n\n            return join(\" \", $this->_join_sources);\n        }\n\n        /**\n         * Build the WHERE clause(s)\n         */\n        protected function _build_where() {\n            return $this->_build_conditions('where');\n        }\n\n        /**\n         * Build the HAVING clause(s)\n         */\n        protected function _build_having() {\n            return $this->_build_conditions('having');\n        }\n\n        /**\n         * Build GROUP BY\n         */\n        protected function _build_group_by() {\n            if (count($this->_group_by) === 0) {\n                return '';\n            }\n            return \"GROUP BY \" . join(\", \", $this->_group_by);\n        }\n\n        /**\n         * Build a WHERE or HAVING clause\n         * @param string $type\n         * @return string\n         */\n        protected function _build_conditions($type) {\n            $conditions_class_property_name = \"_{$type}_conditions\";\n            // If there are no clauses, return empty string\n            if (count($this->$conditions_class_property_name) === 0) {\n                return '';\n            }\n\n            $conditions = array();\n            foreach ($this->$conditions_class_property_name as $condition) {\n                $conditions[] = $condition[self::CONDITION_FRAGMENT];\n                $this->_values = array_merge($this->_values, $condition[self::CONDITION_VALUES]);\n            }\n\n            return strtoupper($type) . \" \" . join(\" AND \", $conditions);\n        }\n\n        /**\n         * Build ORDER BY\n         */\n        protected function _build_order_by() {\n            if (count($this->_order_by) === 0) {\n                return '';\n            }\n            return \"ORDER BY \" . join(\", \", $this->_order_by);\n        }\n\n        /**\n         * Build LIMIT\n         */\n        protected function _build_limit() {\n            $fragment = '';\n            if (!is_null($this->_limit) &&\n                self::$_config[$this->_connection_name]['limit_clause_style'] == ORM::LIMIT_STYLE_LIMIT) {\n                if (self::get_db($this->_connection_name)->getAttribute(PDO::ATTR_DRIVER_NAME) == 'firebird') {\n                    $fragment = 'ROWS';\n                } else {\n                    $fragment = 'LIMIT';\n                }\n                $fragment .= \" {$this->_limit}\";\n            }\n            return $fragment;\n        }\n\n        /**\n         * Build OFFSET\n         */\n        protected function _build_offset() {\n            if (!is_null($this->_offset)) {\n                $clause = 'OFFSET';\n                if (self::get_db($this->_connection_name)->getAttribute(PDO::ATTR_DRIVER_NAME) == 'firebird') {\n                    $clause = 'TO';\n                }\n                return \"$clause \" . $this->_offset;\n            }\n            return '';\n        }\n\n        /**\n         * Wrapper around PHP's join function which\n         * only adds the pieces if they are not empty.\n         */\n        protected function _join_if_not_empty($glue, $pieces) {\n            $filtered_pieces = array();\n            foreach ($pieces as $piece) {\n                if (is_string($piece)) {\n                    $piece = trim($piece);\n                }\n                if (!empty($piece)) {\n                    $filtered_pieces[] = $piece;\n                }\n            }\n            return join($glue, $filtered_pieces);\n        }\n\n        /**\n         * Quote a string that is used as an identifier\n         * (table names, column names etc). This method can\n         * also deal with dot-separated identifiers eg table.column\n         */\n        protected function _quote_one_identifier($identifier) {\n            $parts = explode('.', $identifier);\n            $parts = array_map(array($this, '_quote_identifier_part'), $parts);\n            return join('.', $parts);\n        }\n\n        /**\n         * Quote a string that is used as an identifier\n         * (table names, column names etc) or an array containing\n         * multiple identifiers. This method can also deal with\n         * dot-separated identifiers eg table.column\n         */\n        protected function _quote_identifier($identifier) {\n            if (is_array($identifier)) {\n                $result = array_map(array($this, '_quote_one_identifier'), $identifier);\n                return join(', ', $result);\n            } else {\n                return $this->_quote_one_identifier($identifier);\n            }\n        }\n\n        /**\n         * This method performs the actual quoting of a single\n         * part of an identifier, using the identifier quote\n         * character specified in the config (or autodetected).\n         */\n        protected function _quote_identifier_part($part) {\n            if ($part === '*') {\n                return $part;\n            }\n\n            $quote_character = self::$_config[$this->_connection_name]['identifier_quote_character'];\n            // double up any identifier quotes to escape them\n            return $quote_character .\n                   str_replace($quote_character,\n                               $quote_character . $quote_character,\n                               $part\n                   ) . $quote_character;\n        }\n\n        /**\n         * Create a cache key for the given query and parameters.\n         */\n        protected static function _create_cache_key($query, $parameters, $table_name = null, $connection_name = self::DEFAULT_CONNECTION) {\n            if(isset(self::$_config[$connection_name]['create_cache_key']) and is_callable(self::$_config[$connection_name]['create_cache_key'])){\n                return call_user_func_array(self::$_config[$connection_name]['create_cache_key'], array($query, $parameters, $table_name, $connection_name));\n            }\n            $parameter_string = join(',', $parameters);\n            $key = $query . ':' . $parameter_string;\n            return sha1($key);\n        }\n\n        /**\n         * Check the query cache for the given cache key. If a value\n         * is cached for the key, return the value. Otherwise, return false.\n         */\n        protected static function _check_query_cache($cache_key, $table_name = null, $connection_name = self::DEFAULT_CONNECTION) {\n            if(isset(self::$_config[$connection_name]['check_query_cache']) and is_callable(self::$_config[$connection_name]['check_query_cache'])){\n                return call_user_func_array(self::$_config[$connection_name]['check_query_cache'], array($cache_key, $table_name, $connection_name));\n            } elseif (isset(self::$_query_cache[$connection_name][$cache_key])) {\n                return self::$_query_cache[$connection_name][$cache_key];\n            }\n            return false;\n        }\n\n        /**\n         * Clear the query cache\n         */\n        public static function clear_cache($table_name = null, $connection_name = self::DEFAULT_CONNECTION) {\n            self::$_query_cache = array();\n            if(isset(self::$_config[$connection_name]['clear_cache']) and is_callable(self::$_config[$connection_name]['clear_cache'])){\n                return call_user_func_array(self::$_config[$connection_name]['clear_cache'], array($table_name, $connection_name));\n            }\n        }\n\n        /**\n         * Add the given value to the query cache.\n         */\n        protected static function _cache_query_result($cache_key, $value, $table_name = null, $connection_name = self::DEFAULT_CONNECTION) {\n            if(isset(self::$_config[$connection_name]['cache_query_result']) and is_callable(self::$_config[$connection_name]['cache_query_result'])){\n                return call_user_func_array(self::$_config[$connection_name]['cache_query_result'], array($cache_key, $value, $table_name, $connection_name));\n            } elseif (!isset(self::$_query_cache[$connection_name])) {\n                self::$_query_cache[$connection_name] = array();\n            }\n            self::$_query_cache[$connection_name][$cache_key] = $value;\n        }\n\n        /**\n         * Execute the SELECT query that has been built up by chaining methods\n         * on this class. Return an array of rows as associative arrays.\n         */\n        protected function _run() {\n            $query = $this->_build_select();\n            $caching_enabled = self::$_config[$this->_connection_name]['caching'];\n\n            if ($caching_enabled) {\n                $cache_key = self::_create_cache_key($query, $this->_values, $this->_table_name, $this->_connection_name);\n                $cached_result = self::_check_query_cache($cache_key, $this->_table_name, $this->_connection_name);\n\n                if ($cached_result !== false) {\n                    $this->_reset_idiorm_state();\n                    return $cached_result;\n                }\n            }\n\n            self::_execute($query, $this->_values, $this->_connection_name);\n            $statement = self::get_last_statement();\n\n            $rows = array();\n            while ($row = $statement->fetch(PDO::FETCH_ASSOC)) {\n                $rows[] = $row;\n            }\n\n            if ($caching_enabled) {\n                self::_cache_query_result($cache_key, $rows, $this->_table_name, $this->_connection_name);\n            }\n\n            $this->_reset_idiorm_state();\n            return $rows;\n        }\n\n        /**\n         * Reset the Idiorm instance state\n         */\n        private function _reset_idiorm_state() {\n            $this->_values = array();\n            $this->_result_columns = array('*');\n            $this->_using_default_result_columns = true;\n        }\n\n        /**\n         * Return the raw data wrapped by this ORM\n         * instance as an associative array. Column\n         * names may optionally be supplied as arguments,\n         * if so, only those keys will be returned.\n         */\n        public function as_array() {\n            if (func_num_args() === 0) {\n                return $this->_data;\n            }\n            $args = func_get_args();\n            return array_intersect_key($this->_data, array_flip($args));\n        }\n\n        /**\n         * Return the value of a property of this object (database row)\n         * or null if not present.\n         *\n         * If a column-names array is passed, it will return a associative array\n         * with the value of each column or null if it is not present.\n         */\n        public function get($key) {\n            if (is_array($key)) {\n                $result = array();\n                foreach($key as $column) {\n                    $result[$column] = isset($this->_data[$column]) ? $this->_data[$column] : null;\n                }\n                return $result;\n            } else {\n                return isset($this->_data[$key]) ? $this->_data[$key] : null;\n            }\n        }\n\n        /**\n         * Return the name of the column in the database table which contains\n         * the primary key ID of the row.\n         */\n        protected function _get_id_column_name() {\n            if (!is_null($this->_instance_id_column)) {\n                return $this->_instance_id_column;\n            }\n            if (isset(self::$_config[$this->_connection_name]['id_column_overrides'][$this->_table_name])) {\n                return self::$_config[$this->_connection_name]['id_column_overrides'][$this->_table_name];\n            }\n            return self::$_config[$this->_connection_name]['id_column'];\n        }\n\n        /**\n         * Get the primary key ID of this object.\n         */\n        public function id($disallow_null = false) {\n            $id = $this->get($this->_get_id_column_name());\n\n            if ($disallow_null) {\n                if (is_array($id)) {\n                    foreach ($id as $id_part) {\n                        if ($id_part === null) {\n                            throw new Exception('Primary key ID contains null value(s)');\n                        }\n                    }\n                } else if ($id === null) {\n                    throw new Exception('Primary key ID missing from row or is null');\n                }\n            }\n\n            return $id;\n        }\n\n        /**\n         * Set a property to a particular value on this object.\n         * To set multiple properties at once, pass an associative array\n         * as the first parameter and leave out the second parameter.\n         * Flags the properties as 'dirty' so they will be saved to the\n         * database when save() is called.\n         */\n        public function set($key, $value = null) {\n            return $this->_set_orm_property($key, $value);\n        }\n\n        /**\n         * Set a property to a particular value on this object.\n         * To set multiple properties at once, pass an associative array\n         * as the first parameter and leave out the second parameter.\n         * Flags the properties as 'dirty' so they will be saved to the\n         * database when save() is called. \n         * @param string|array $key\n         * @param string|null $value\n         */\n        public function set_expr($key, $value = null) {\n            return $this->_set_orm_property($key, $value, true);\n        }\n\n        /**\n         * Set a property on the ORM object.\n         * @param string|array $key\n         * @param string|null $value\n         * @param bool $raw Whether this value should be treated as raw or not\n         */\n        protected function _set_orm_property($key, $value = null, $expr = false) {\n            if (!is_array($key)) {\n                $key = array($key => $value);\n            }\n            foreach ($key as $field => $value) {\n                $this->_data[$field] = $value;\n                $this->_dirty_fields[$field] = $value;\n                if (false === $expr and isset($this->_expr_fields[$field])) {\n                    unset($this->_expr_fields[$field]);\n                } else if (true === $expr) {\n                    $this->_expr_fields[$field] = true;\n                }\n            }\n            return $this;\n        }\n\n        /**\n         * Check whether the given field has been changed since this\n         * object was saved.\n         */\n        public function is_dirty($key) {\n            return array_key_exists($key, $this->_dirty_fields);\n        }\n\n        /**\n         * Check whether the model was the result of a call to create() or not\n         * @return bool\n         */\n        public function is_new() {\n            return $this->_is_new;\n        }\n\n        /**\n         * Save any fields which have been modified on this object\n         * to the database.\n         */\n        public function save() {\n            $query = array();\n\n            // remove any expression fields as they are already baked into the query\n            $values = array_values(array_diff_key($this->_dirty_fields, $this->_expr_fields));\n\n            if (!$this->_is_new) { // UPDATE\n                // If there are no dirty values, do nothing\n                if (empty($values) && empty($this->_expr_fields)) {\n                    return true;\n                }\n                $query = $this->_build_update();\n                $id = $this->id(true);\n                if (is_array($id)) {\n                    $values = array_merge($values, array_values($id));\n                } else {\n                    $values[] = $id;\n                }\n            } else { // INSERT\n                $query = $this->_build_insert();\n            }\n\n            $success = self::_execute($query, $values, $this->_connection_name);\n            $caching_auto_clear_enabled = self::$_config[$this->_connection_name]['caching_auto_clear'];\n            if($caching_auto_clear_enabled){\n                self::clear_cache($this->_table_name, $this->_connection_name);\n            }\n            // If we've just inserted a new record, set the ID of this object\n            if ($this->_is_new) {\n                $this->_is_new = false;\n                if ($this->count_null_id_columns() != 0) {\n                    $db = self::get_db($this->_connection_name);\n                    if($db->getAttribute(PDO::ATTR_DRIVER_NAME) == 'pgsql') {\n                        // it may return several columns if a compound primary\n                        // key is used\n                        $row = self::get_last_statement()->fetch(PDO::FETCH_ASSOC);\n                        foreach($row as $key => $value) {\n                            $this->_data[$key] = $value;\n                        }\n                    } else {\n                        $column = $this->_get_id_column_name();\n                        // if the primary key is compound, assign the last inserted id\n                        // to the first column\n                        if (is_array($column)) {\n                            $column = reset($column);\n                        }\n                        $this->_data[$column] = $db->lastInsertId();\n                    }\n                }\n            }\n\n            $this->_dirty_fields = $this->_expr_fields = array();\n            return $success;\n        }\n\n        /**\n         * Add a WHERE clause for every column that belongs to the primary key\n         */\n        public function _add_id_column_conditions(&$query) {\n            $query[] = \"WHERE\";\n            $keys = is_array($this->_get_id_column_name()) ? $this->_get_id_column_name() : array( $this->_get_id_column_name() );\n            $first = true;\n            foreach($keys as $key) {\n                if ($first) {\n                    $first = false;\n                }\n                else {\n                    $query[] = \"AND\";\n                }\n                $query[] = $this->_quote_identifier($key);\n                $query[] = \"= ?\";\n            }\n        }\n\n        /**\n         * Build an UPDATE query\n         */\n        protected function _build_update() {\n            $query = array();\n            $query[] = \"UPDATE {$this->_quote_identifier($this->_table_name)} SET\";\n\n            $field_list = array();\n            foreach ($this->_dirty_fields as $key => $value) {\n                if(!array_key_exists($key, $this->_expr_fields)) {\n                    $value = '?';\n                }\n                $field_list[] = \"{$this->_quote_identifier($key)} = $value\";\n            }\n            $query[] = join(\", \", $field_list);\n            $this->_add_id_column_conditions($query);\n            return join(\" \", $query);\n        }\n\n        /**\n         * Build an INSERT query\n         */\n        protected function _build_insert() {\n            $query[] = \"INSERT INTO\";\n            $query[] = $this->_quote_identifier($this->_table_name);\n            $field_list = array_map(array($this, '_quote_identifier'), array_keys($this->_dirty_fields));\n            $query[] = \"(\" . join(\", \", $field_list) . \")\";\n            $query[] = \"VALUES\";\n\n            $placeholders = $this->_create_placeholders($this->_dirty_fields);\n            $query[] = \"({$placeholders})\";\n\n            if (self::get_db($this->_connection_name)->getAttribute(PDO::ATTR_DRIVER_NAME) == 'pgsql') {\n                $query[] = 'RETURNING ' . $this->_quote_identifier($this->_get_id_column_name());\n            }\n\n            return join(\" \", $query);\n        }\n\n        /**\n         * Delete this record from the database\n         */\n        public function delete() {\n            $query = array(\n                \"DELETE FROM\",\n                $this->_quote_identifier($this->_table_name)\n            );\n            $this->_add_id_column_conditions($query);\n            return self::_execute(join(\" \", $query), is_array($this->id(true)) ? array_values($this->id(true)) : array($this->id(true)), $this->_connection_name);\n        }\n\n        /**\n         * Delete many records from the database\n         */\n        public function delete_many() {\n            // Build and return the full DELETE statement by concatenating\n            // the results of calling each separate builder method.\n            $query = $this->_join_if_not_empty(\" \", array(\n                \"DELETE FROM\",\n                $this->_quote_identifier($this->_table_name),\n                $this->_build_where(),\n            ));\n\n            return self::_execute($query, $this->_values, $this->_connection_name);\n        }\n\n        // --------------------- //\n        // ---  ArrayAccess  --- //\n        // --------------------- //\n\n        #[\\ReturnTypeWillChange]\n        public function offsetExists($key) {\n            return array_key_exists($key, $this->_data);\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function offsetGet($key) {\n            return $this->get($key);\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function offsetSet($key, $value) {\n            if(is_null($key)) {\n                throw new InvalidArgumentException('You must specify a key/array index.');\n            }\n            $this->set($key, $value);\n        }\n\n        #[\\ReturnTypeWillChange]\n        public function offsetUnset($key) {\n            unset($this->_data[$key]);\n            unset($this->_dirty_fields[$key]);\n        }\n\n        // --------------------- //\n        // --- MAGIC METHODS --- //\n        // --------------------- //\n        public function __get($key) {\n            return $this->offsetGet($key);\n        }\n\n        public function __set($key, $value) {\n            $this->offsetSet($key, $value);\n        }\n\n        public function __unset($key) {\n            $this->offsetUnset($key);\n        }\n\n\n        public function __isset($key) {\n            return $this->offsetExists($key);\n        }\n\n        /**\n         * Magic method to capture calls to undefined class methods.\n         * In this case we are attempting to convert camel case formatted \n         * methods into underscore formatted methods.\n         *\n         * This allows us to call ORM methods using camel case and remain \n         * backwards compatible.\n         * \n         * @param  string   $name\n         * @param  array    $arguments\n         * @return ORM\n         */\n        public function __call($name, $arguments)\n        {\n            $method = strtolower(preg_replace('/([a-z])([A-Z])/', '$1_$2', $name));\n\n            if (method_exists($this, $method)) {\n                return call_user_func_array(array($this, $method), $arguments);\n            } else {\n                throw new IdiormMethodMissingException(\"Method $name() does not exist in class \" . get_class($this));\n            }\n        }\n\n        /**\n         * Magic method to capture calls to undefined static class methods. \n         * In this case we are attempting to convert camel case formatted \n         * methods into underscore formatted methods.\n         *\n         * This allows us to call ORM methods using camel case and remain \n         * backwards compatible.\n         * \n         * @param  string   $name\n         * @param  array    $arguments\n         * @return ORM\n         */\n        public static function __callStatic($name, $arguments)\n        {\n            $method = strtolower(preg_replace('/([a-z])([A-Z])/', '$1_$2', $name));\n\n            return call_user_func_array(array('ORM', $method), $arguments);\n        }\n    }\n\n    /**\n     * A class to handle str_replace operations that involve quoted strings\n     * @example IdiormString::str_replace_outside_quotes('?', '%s', 'columnA = \"Hello?\" AND columnB = ?');\n     * @example IdiormString::value('columnA = \"Hello?\" AND columnB = ?')->replace_outside_quotes('?', '%s');\n     * @author Jeff Roberson <ridgerunner@fluxbb.org>\n     * @author Simon Holywell <treffynnon@php.net>\n     * @link http://stackoverflow.com/a/13370709/461813 StackOverflow answer\n     */\n    class IdiormString {\n        protected $subject;\n        protected $search;\n        protected $replace;\n\n        /**\n         * Get an easy to use instance of the class\n         * @param string $subject\n         * @return \\self\n         */\n        public static function value($subject) {\n            return new self($subject);\n        }\n\n        /**\n         * Shortcut method: Replace all occurrences of the search string with the replacement\n         * string where they appear outside quotes.\n         * @param string $search\n         * @param string $replace\n         * @param string $subject\n         * @return string\n         */\n        public static function str_replace_outside_quotes($search, $replace, $subject) {\n            return self::value($subject)->replace_outside_quotes($search, $replace);\n        }\n\n        /**\n         * Set the base string object\n         * @param string $subject\n         */\n        public function __construct($subject) {\n            $this->subject = (string) $subject;\n        }\n\n        /**\n         * Replace all occurrences of the search string with the replacement\n         * string where they appear outside quotes\n         * @param string $search\n         * @param string $replace\n         * @return string\n         */\n        public function replace_outside_quotes($search, $replace) {\n            $this->search = $search;\n            $this->replace = $replace;\n            return $this->_str_replace_outside_quotes();\n        }\n\n        /**\n         * Validate an input string and perform a replace on all ocurrences\n         * of $this->search with $this->replace\n         * @author Jeff Roberson <ridgerunner@fluxbb.org>\n         * @link http://stackoverflow.com/a/13370709/461813 StackOverflow answer\n         * @return string\n         */\n        protected function _str_replace_outside_quotes(){\n            $re_valid = '/\n                # Validate string having embedded quoted substrings.\n                ^                           # Anchor to start of string.\n                (?:                         # Zero or more string chunks.\n                  \"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*\"  # Either a double quoted chunk,\n                | \\'[^\\'\\\\\\\\]*(?:\\\\\\\\.[^\\'\\\\\\\\]*)*\\'  # or a single quoted chunk,\n                | [^\\'\"\\\\\\\\]+               # or an unquoted chunk (no escapes).\n                )*                          # Zero or more string chunks.\n                \\z                          # Anchor to end of string.\n                /sx';\n            if (!preg_match($re_valid, $this->subject)) {\n                throw new IdiormStringException(\"Subject string is not valid in the replace_outside_quotes context.\");\n            }\n            $re_parse = '/\n                # Match one chunk of a valid string having embedded quoted substrings.\n                  (                         # Either $1: Quoted chunk.\n                    \"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*\"  # Either a double quoted chunk,\n                  | \\'[^\\'\\\\\\\\]*(?:\\\\\\\\.[^\\'\\\\\\\\]*)*\\'  # or a single quoted chunk.\n                  )                         # End $1: Quoted chunk.\n                | ([^\\'\"\\\\\\\\]+)             # or $2: an unquoted chunk (no escapes).\n                /sx';\n            return preg_replace_callback($re_parse, array($this, '_str_replace_outside_quotes_cb'), $this->subject);\n        }\n\n        /**\n         * Process each matching chunk from preg_replace_callback replacing\n         * each occurrence of $this->search with $this->replace\n         * @author Jeff Roberson <ridgerunner@fluxbb.org>\n         * @link http://stackoverflow.com/a/13370709/461813 StackOverflow answer\n         * @param array $matches\n         * @return string\n         */\n        protected function _str_replace_outside_quotes_cb($matches) {\n            // Return quoted string chunks (in group $1) unaltered.\n            if ($matches[1]) return $matches[1];\n            // Process only unquoted chunks (in group $2).\n            return preg_replace('/'. preg_quote($this->search, '/') .'/',\n                $this->replace, $matches[2]);\n        }\n    }\n\n    /**\n     * A result set class for working with collections of model instances\n     * @author Simon Holywell <treffynnon@php.net>\n     * @method null setResults(array $results)\n     * @method array getResults()\n     */\n    class IdiormResultSet implements Countable, IteratorAggregate, ArrayAccess, Serializable {\n        /**\n         * The current result set as an array\n         * @var array\n         */\n        protected $_results = array();\n\n        /**\n         * Optionally set the contents of the result set by passing in array\n         * @param array $results\n         */\n        public function __construct(array $results = array()) {\n            $this->set_results($results);\n        }\n\n        /**\n         * Set the contents of the result set by passing in array\n         * @param array $results\n         */\n        public function set_results(array $results) {\n            $this->_results = $results;\n        }\n\n        /**\n         * Get the current result set as an array\n         * @return array\n         */\n        public function get_results() {\n            return $this->_results;\n        }\n\n        /**\n         * Get the current result set as an array\n         * @return array\n         */\n        public function as_array() {\n            return $this->get_results();\n        }\n        \n        /**\n         * Get the number of records in the result set\n         * @return int\n         */\n        #[\\ReturnTypeWillChange]\n        public function count() {\n            return count($this->_results);\n        }\n\n        /**\n         * Get an iterator for this object. In this case it supports foreaching\n         * over the result set.\n         * @return \\ArrayIterator\n         */\n        #[\\ReturnTypeWillChange]\n        public function getIterator() {\n            return new ArrayIterator($this->_results);\n        }\n\n        /**\n         * ArrayAccess\n         * @param int|string $offset\n         * @return bool\n         */\n        #[\\ReturnTypeWillChange]\n        public function offsetExists($offset) {\n            return isset($this->_results[$offset]);\n        }\n\n        /**\n         * ArrayAccess\n         * @param int|string $offset\n         * @return mixed\n         */\n        #[\\ReturnTypeWillChange]\n        public function offsetGet($offset) {\n            return $this->_results[$offset];\n        }\n        \n        /**\n         * ArrayAccess\n         * @param int|string $offset\n         * @param mixed $value\n         */\n        #[\\ReturnTypeWillChange]\n        public function offsetSet($offset, $value) {\n            $this->_results[$offset] = $value;\n        }\n\n        /**\n         * ArrayAccess\n         * @param int|string $offset\n         */\n        #[\\ReturnTypeWillChange]\n        public function offsetUnset($offset) {\n            unset($this->_results[$offset]);\n        }\n\n        public function __serialize() {\n            return $this->serialize();\n        }\n\n        public function __unserialize($data) {\n            $this->unserialize($data);\n        }\n\n        /**\n         * Serializable\n         * @return string\n         */\n        public function serialize() {\n            return serialize($this->_results);\n        }\n\n        /**\n         * Serializable\n         * @param string $serialized\n         * @return array\n         */\n        public function unserialize($serialized) {\n            return unserialize($serialized);\n        }\n\n        /**\n         * Call a method on all models in a result set. This allows for method\n         * chaining such as setting a property on all models in a result set or\n         * any other batch operation across models.\n         * @example ORM::for_table('Widget')->find_many()->set('field', 'value')->save();\n         * @param string $method\n         * @param array $params\n         * @return \\IdiormResultSet\n         */\n        public function __call($method, $params = array()) {\n            foreach($this->_results as $model) {\n                if (method_exists($model, $method)) {\n                    call_user_func_array(array($model, $method), $params);\n                } else {\n                    throw new IdiormMethodMissingException(\"Method $method() does not exist in class \" . get_class($this));\n                }\n            }\n            return $this;\n        }\n    }\n\n    /**\n     * A placeholder for exceptions eminating from the IdiormString class\n     */\n    class IdiormStringException extends Exception {}\n\n    class IdiormMethodMissingException extends Exception {}\n"
        },
        {
          "name": "phpunit.xml",
          "type": "blob",
          "size": 0.4248046875,
          "content": "<phpunit backupGlobals=\"true\"\n         backupStaticAttributes=\"false\"\n         bootstrap=\"test/bootstrap.php\"\n         cacheTokens=\"false\"\n         colors=\"true\">\n    <testsuites>\n        <testsuite name=\"Idiorm Test Suite\">\n            <directory suffix=\"Test.php\">test</directory>\n            <directory suffix=\"Test53.php\" phpVersion=\"5.3.0\" phpVersionOperator=\">=\">test</directory>\n        </testsuite>\n    </testsuites>\n</phpunit>"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}