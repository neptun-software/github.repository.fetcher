{
  "metadata": {
    "timestamp": 1736711850446,
    "page": 176,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/options-resolver",
      "stars": 3217,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 3.2763671875,
          "content": "CHANGELOG\n=========\n\n6.4\n---\n\n* Improve message with full path on invalid type in nested option\n\n6.3\n---\n\n * Add `OptionsResolver::setIgnoreUndefined()` and `OptionConfigurator::ignoreUndefined()` to ignore not defined options while resolving\n\n6.0\n---\n\n * Remove `OptionsResolverIntrospector::getDeprecationMessage()`\n\n5.3\n---\n\n * Add prototype definition for nested options\n\n5.1.0\n-----\n\n * added fluent configuration of options using `OptionResolver::define()`\n * added `setInfo()` and `getInfo()` methods\n * updated the signature of method `OptionsResolver::setDeprecated()` to `OptionsResolver::setDeprecation(string $option, string $package, string $version, $message)`\n * deprecated `OptionsResolverIntrospector::getDeprecationMessage()`, use `OptionsResolverIntrospector::getDeprecation()` instead\n\n5.0.0\n-----\n\n * added argument `$triggerDeprecation` to `OptionsResolver::offsetGet()`\n\n4.3.0\n-----\n\n * added `OptionsResolver::addNormalizer` method\n\n4.2.0\n-----\n\n * added support for nested options definition\n * added `setDeprecated` and `isDeprecated` methods\n\n3.4.0\n-----\n\n * added `OptionsResolverIntrospector` to inspect options definitions inside an `OptionsResolver` instance\n * added array of types support in allowed types (e.g int[])\n\n2.6.0\n-----\n\n * deprecated OptionsResolverInterface\n * [BC BREAK] removed \"array\" type hint from OptionsResolverInterface methods\n   setRequired(), setAllowedValues(), addAllowedValues(), setAllowedTypes() and\n   addAllowedTypes()\n * added OptionsResolver::setDefault()\n * added OptionsResolver::hasDefault()\n * added OptionsResolver::setNormalizer()\n * added OptionsResolver::isRequired()\n * added OptionsResolver::getRequiredOptions()\n * added OptionsResolver::isMissing()\n * added OptionsResolver::getMissingOptions()\n * added OptionsResolver::setDefined()\n * added OptionsResolver::isDefined()\n * added OptionsResolver::getDefinedOptions()\n * added OptionsResolver::remove()\n * added OptionsResolver::clear()\n * deprecated OptionsResolver::replaceDefaults()\n * deprecated OptionsResolver::setOptional() in favor of setDefined()\n * deprecated OptionsResolver::isKnown() in favor of isDefined()\n * [BC BREAK] OptionsResolver::isRequired() returns true now if a required\n   option has a default value set\n * [BC BREAK] merged Options into OptionsResolver and turned Options into an\n   interface\n * deprecated Options::overload() (now in OptionsResolver)\n * deprecated Options::set() (now in OptionsResolver)\n * deprecated Options::get() (now in OptionsResolver)\n * deprecated Options::has() (now in OptionsResolver)\n * deprecated Options::replace() (now in OptionsResolver)\n * [BC BREAK] Options::get() (now in OptionsResolver) can only be used within\n   lazy option/normalizer closures now\n * [BC BREAK] removed Traversable interface from Options since using within\n   lazy option/normalizer closures resulted in exceptions\n * [BC BREAK] removed Options::all() since using within lazy option/normalizer\n   closures resulted in exceptions\n * [BC BREAK] OptionDefinitionException now extends LogicException instead of\n   RuntimeException\n * [BC BREAK] normalizers are not executed anymore for unset options\n * normalizers are executed after validating the options now\n * [BC BREAK] an UndefinedOptionsException is now thrown instead of an\n   InvalidOptionsException when non-existing options are passed\n"
        },
        {
          "name": "Debug",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "OptionConfigurator.php",
          "type": "blob",
          "size": 3.4931640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\OptionsResolver;\n\nuse Symfony\\Component\\OptionsResolver\\Exception\\AccessException;\n\nfinal class OptionConfigurator\n{\n    public function __construct(\n        private string $name,\n        private OptionsResolver $resolver,\n    ) {\n        $this->resolver->setDefined($name);\n    }\n\n    /**\n     * Adds allowed types for this option.\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function allowedTypes(string ...$types): static\n    {\n        $this->resolver->setAllowedTypes($this->name, $types);\n\n        return $this;\n    }\n\n    /**\n     * Sets allowed values for this option.\n     *\n     * @param mixed ...$values One or more acceptable values/closures\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function allowedValues(mixed ...$values): static\n    {\n        $this->resolver->setAllowedValues($this->name, $values);\n\n        return $this;\n    }\n\n    /**\n     * Sets the default value for this option.\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function default(mixed $value): static\n    {\n        $this->resolver->setDefault($this->name, $value);\n\n        return $this;\n    }\n\n    /**\n     * Defines an option configurator with the given name.\n     */\n    public function define(string $option): self\n    {\n        return $this->resolver->define($option);\n    }\n\n    /**\n     * Marks this option as deprecated.\n     *\n     * @param string          $package The name of the composer package that is triggering the deprecation\n     * @param string          $version The version of the package that introduced the deprecation\n     * @param string|\\Closure $message The deprecation message to use\n     *\n     * @return $this\n     */\n    public function deprecated(string $package, string $version, string|\\Closure $message = 'The option \"%name%\" is deprecated.'): static\n    {\n        $this->resolver->setDeprecated($this->name, $package, $version, $message);\n\n        return $this;\n    }\n\n    /**\n     * Sets the normalizer for this option.\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function normalize(\\Closure $normalizer): static\n    {\n        $this->resolver->setNormalizer($this->name, $normalizer);\n\n        return $this;\n    }\n\n    /**\n     * Marks this option as required.\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function required(): static\n    {\n        $this->resolver->setRequired($this->name);\n\n        return $this;\n    }\n\n    /**\n     * Sets an info message for an option.\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function info(string $info): static\n    {\n        $this->resolver->setInfo($this->name, $info);\n\n        return $this;\n    }\n\n    /**\n     * Sets whether ignore undefined options.\n     *\n     * @return $this\n     */\n    public function ignoreUndefined(bool $ignore = true): static\n    {\n        $this->resolver->setIgnoreUndefined($ignore);\n\n        return $this;\n    }\n}\n"
        },
        {
          "name": "Options.php",
          "type": "blob",
          "size": 0.4716796875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\OptionsResolver;\n\n/**\n * Contains resolved option values.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n * @author Tobias Schultze <http://tobion.de>\n */\ninterface Options extends \\ArrayAccess, \\Countable\n{\n}\n"
        },
        {
          "name": "OptionsResolver.php",
          "type": "blob",
          "size": 44.65625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\OptionsResolver;\n\nuse Symfony\\Component\\OptionsResolver\\Exception\\AccessException;\nuse Symfony\\Component\\OptionsResolver\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\OptionsResolver\\Exception\\InvalidOptionsException;\nuse Symfony\\Component\\OptionsResolver\\Exception\\MissingOptionsException;\nuse Symfony\\Component\\OptionsResolver\\Exception\\NoSuchOptionException;\nuse Symfony\\Component\\OptionsResolver\\Exception\\OptionDefinitionException;\nuse Symfony\\Component\\OptionsResolver\\Exception\\UndefinedOptionsException;\n\n/**\n * Validates options and merges them with default values.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n * @author Tobias Schultze <http://tobion.de>\n */\nclass OptionsResolver implements Options\n{\n    private const VALIDATION_FUNCTIONS = [\n        'bool' => 'is_bool',\n        'boolean' => 'is_bool',\n        'int' => 'is_int',\n        'integer' => 'is_int',\n        'long' => 'is_int',\n        'float' => 'is_float',\n        'double' => 'is_float',\n        'real' => 'is_float',\n        'numeric' => 'is_numeric',\n        'string' => 'is_string',\n        'scalar' => 'is_scalar',\n        'array' => 'is_array',\n        'iterable' => 'is_iterable',\n        'countable' => 'is_countable',\n        'callable' => 'is_callable',\n        'object' => 'is_object',\n        'resource' => 'is_resource',\n    ];\n\n    /**\n     * The names of all defined options.\n     */\n    private array $defined = [];\n\n    /**\n     * The default option values.\n     */\n    private array $defaults = [];\n\n    /**\n     * A list of closure for nested options.\n     *\n     * @var \\Closure[][]\n     */\n    private array $nested = [];\n\n    /**\n     * The names of required options.\n     */\n    private array $required = [];\n\n    /**\n     * The resolved option values.\n     */\n    private array $resolved = [];\n\n    /**\n     * A list of normalizer closures.\n     *\n     * @var \\Closure[][]\n     */\n    private array $normalizers = [];\n\n    /**\n     * A list of accepted values for each option.\n     */\n    private array $allowedValues = [];\n\n    /**\n     * A list of accepted types for each option.\n     */\n    private array $allowedTypes = [];\n\n    /**\n     * A list of info messages for each option.\n     */\n    private array $info = [];\n\n    /**\n     * A list of closures for evaluating lazy options.\n     */\n    private array $lazy = [];\n\n    /**\n     * A list of lazy options whose closure is currently being called.\n     *\n     * This list helps detecting circular dependencies between lazy options.\n     */\n    private array $calling = [];\n\n    /**\n     * A list of deprecated options.\n     */\n    private array $deprecated = [];\n\n    /**\n     * The list of options provided by the user.\n     */\n    private array $given = [];\n\n    /**\n     * Whether the instance is locked for reading.\n     *\n     * Once locked, the options cannot be changed anymore. This is\n     * necessary in order to avoid inconsistencies during the resolving\n     * process. If any option is changed after being read, all evaluated\n     * lazy options that depend on this option would become invalid.\n     */\n    private bool $locked = false;\n\n    private array $parentsOptions = [];\n\n    /**\n     * Whether the whole options definition is marked as array prototype.\n     */\n    private ?bool $prototype = null;\n\n    /**\n     * The prototype array's index that is being read.\n     */\n    private int|string|null $prototypeIndex = null;\n\n    /**\n     * Whether to ignore undefined options.\n     */\n    private bool $ignoreUndefined = false;\n\n    /**\n     * Sets the default value of a given option.\n     *\n     * If the default value should be set based on other options, you can pass\n     * a closure with the following signature:\n     *\n     *     function (Options $options) {\n     *         // ...\n     *     }\n     *\n     * The closure will be evaluated when {@link resolve()} is called. The\n     * closure has access to the resolved values of other options through the\n     * passed {@link Options} instance:\n     *\n     *     function (Options $options) {\n     *         if (isset($options['port'])) {\n     *             // ...\n     *         }\n     *     }\n     *\n     * If you want to access the previously set default value, add a second\n     * argument to the closure's signature:\n     *\n     *     $options->setDefault('name', 'Default Name');\n     *\n     *     $options->setDefault('name', function (Options $options, $previousValue) {\n     *         // 'Default Name' === $previousValue\n     *     });\n     *\n     * This is mostly useful if the configuration of the {@link Options} object\n     * is spread across different locations of your code, such as base and\n     * sub-classes.\n     *\n     * If you want to define nested options, you can pass a closure with the\n     * following signature:\n     *\n     *     $options->setDefault('database', function (OptionsResolver $resolver) {\n     *         $resolver->setDefined(['dbname', 'host', 'port', 'user', 'pass']);\n     *     }\n     *\n     * To get access to the parent options, add a second argument to the closure's\n     * signature:\n     *\n     *     function (OptionsResolver $resolver, Options $parent) {\n     *         // 'default' === $parent['connection']\n     *     }\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function setDefault(string $option, mixed $value): static\n    {\n        // Setting is not possible once resolving starts, because then lazy\n        // options could manipulate the state of the object, leading to\n        // inconsistent results.\n        if ($this->locked) {\n            throw new AccessException('Default values cannot be set from a lazy option or normalizer.');\n        }\n\n        // If an option is a closure that should be evaluated lazily, store it\n        // in the \"lazy\" property.\n        if ($value instanceof \\Closure) {\n            $reflClosure = new \\ReflectionFunction($value);\n            $params = $reflClosure->getParameters();\n\n            if (isset($params[0]) && Options::class === $this->getParameterClassName($params[0])) {\n                // Initialize the option if no previous value exists\n                if (!isset($this->defaults[$option])) {\n                    $this->defaults[$option] = null;\n                }\n\n                // Ignore previous lazy options if the closure has no second parameter\n                if (!isset($this->lazy[$option]) || !isset($params[1])) {\n                    $this->lazy[$option] = [];\n                }\n\n                // Store closure for later evaluation\n                $this->lazy[$option][] = $value;\n                $this->defined[$option] = true;\n\n                // Make sure the option is processed and is not nested anymore\n                unset($this->resolved[$option], $this->nested[$option]);\n\n                return $this;\n            }\n\n            if (isset($params[0]) && ($type = $params[0]->getType()) instanceof \\ReflectionNamedType && self::class === $type->getName() && (!isset($params[1]) || (($type = $params[1]->getType()) instanceof \\ReflectionNamedType && Options::class === $type->getName()))) {\n                // Store closure for later evaluation\n                $this->nested[$option][] = $value;\n                $this->defaults[$option] = [];\n                $this->defined[$option] = true;\n\n                // Make sure the option is processed and is not lazy anymore\n                unset($this->resolved[$option], $this->lazy[$option]);\n\n                return $this;\n            }\n        }\n\n        // This option is not lazy nor nested anymore\n        unset($this->lazy[$option], $this->nested[$option]);\n\n        // Yet undefined options can be marked as resolved, because we only need\n        // to resolve options with lazy closures, normalizers or validation\n        // rules, none of which can exist for undefined options\n        // If the option was resolved before, update the resolved value\n        if (!isset($this->defined[$option]) || \\array_key_exists($option, $this->resolved)) {\n            $this->resolved[$option] = $value;\n        }\n\n        $this->defaults[$option] = $value;\n        $this->defined[$option] = true;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function setDefaults(array $defaults): static\n    {\n        foreach ($defaults as $option => $value) {\n            $this->setDefault($option, $value);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns whether a default value is set for an option.\n     *\n     * Returns true if {@link setDefault()} was called for this option.\n     * An option is also considered set if it was set to null.\n     */\n    public function hasDefault(string $option): bool\n    {\n        return \\array_key_exists($option, $this->defaults);\n    }\n\n    /**\n     * Marks one or more options as required.\n     *\n     * @param string|string[] $optionNames One or more option names\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function setRequired(string|array $optionNames): static\n    {\n        if ($this->locked) {\n            throw new AccessException('Options cannot be made required from a lazy option or normalizer.');\n        }\n\n        foreach ((array) $optionNames as $option) {\n            $this->defined[$option] = true;\n            $this->required[$option] = true;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns whether an option is required.\n     *\n     * An option is required if it was passed to {@link setRequired()}.\n     */\n    public function isRequired(string $option): bool\n    {\n        return isset($this->required[$option]);\n    }\n\n    /**\n     * Returns the names of all required options.\n     *\n     * @return string[]\n     *\n     * @see isRequired()\n     */\n    public function getRequiredOptions(): array\n    {\n        return array_keys($this->required);\n    }\n\n    /**\n     * Returns whether an option is missing a default value.\n     *\n     * An option is missing if it was passed to {@link setRequired()}, but not\n     * to {@link setDefault()}. This option must be passed explicitly to\n     * {@link resolve()}, otherwise an exception will be thrown.\n     */\n    public function isMissing(string $option): bool\n    {\n        return isset($this->required[$option]) && !\\array_key_exists($option, $this->defaults);\n    }\n\n    /**\n     * Returns the names of all options missing a default value.\n     *\n     * @return string[]\n     */\n    public function getMissingOptions(): array\n    {\n        return array_keys(array_diff_key($this->required, $this->defaults));\n    }\n\n    /**\n     * Defines a valid option name.\n     *\n     * Defines an option name without setting a default value. The option will\n     * be accepted when passed to {@link resolve()}. When not passed, the\n     * option will not be included in the resolved options.\n     *\n     * @param string|string[] $optionNames One or more option names\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function setDefined(string|array $optionNames): static\n    {\n        if ($this->locked) {\n            throw new AccessException('Options cannot be defined from a lazy option or normalizer.');\n        }\n\n        foreach ((array) $optionNames as $option) {\n            $this->defined[$option] = true;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns whether an option is defined.\n     *\n     * Returns true for any option passed to {@link setDefault()},\n     * {@link setRequired()} or {@link setDefined()}.\n     */\n    public function isDefined(string $option): bool\n    {\n        return isset($this->defined[$option]);\n    }\n\n    /**\n     * Returns the names of all defined options.\n     *\n     * @return string[]\n     *\n     * @see isDefined()\n     */\n    public function getDefinedOptions(): array\n    {\n        return array_keys($this->defined);\n    }\n\n    public function isNested(string $option): bool\n    {\n        return isset($this->nested[$option]);\n    }\n\n    /**\n     * Deprecates an option, allowed types or values.\n     *\n     * Instead of passing the message, you may also pass a closure with the\n     * following signature:\n     *\n     *     function (Options $options, $value): string {\n     *         // ...\n     *     }\n     *\n     * The closure receives the value as argument and should return a string.\n     * Return an empty string to ignore the option deprecation.\n     *\n     * The closure is invoked when {@link resolve()} is called. The parameter\n     * passed to the closure is the value of the option after validating it\n     * and before normalizing it.\n     *\n     * @param string          $package The name of the composer package that is triggering the deprecation\n     * @param string          $version The version of the package that introduced the deprecation\n     * @param string|\\Closure $message The deprecation message to use\n     *\n     * @return $this\n     */\n    public function setDeprecated(string $option, string $package, string $version, string|\\Closure $message = 'The option \"%name%\" is deprecated.'): static\n    {\n        if ($this->locked) {\n            throw new AccessException('Options cannot be deprecated from a lazy option or normalizer.');\n        }\n\n        if (!isset($this->defined[$option])) {\n            throw new UndefinedOptionsException(\\sprintf('The option \"%s\" does not exist, defined options are: \"%s\".', $this->formatOptions([$option]), implode('\", \"', array_keys($this->defined))));\n        }\n\n        if (!\\is_string($message) && !$message instanceof \\Closure) {\n            throw new InvalidArgumentException(\\sprintf('Invalid type for deprecation message argument, expected string or \\Closure, but got \"%s\".', get_debug_type($message)));\n        }\n\n        // ignore if empty string\n        if ('' === $message) {\n            return $this;\n        }\n\n        $this->deprecated[$option] = [\n            'package' => $package,\n            'version' => $version,\n            'message' => $message,\n        ];\n\n        // Make sure the option is processed\n        unset($this->resolved[$option]);\n\n        return $this;\n    }\n\n    public function isDeprecated(string $option): bool\n    {\n        return isset($this->deprecated[$option]);\n    }\n\n    /**\n     * Sets the normalizer for an option.\n     *\n     * The normalizer should be a closure with the following signature:\n     *\n     *     function (Options $options, $value) {\n     *         // ...\n     *     }\n     *\n     * The closure is invoked when {@link resolve()} is called. The closure\n     * has access to the resolved values of other options through the passed\n     * {@link Options} instance.\n     *\n     * The second parameter passed to the closure is the value of\n     * the option.\n     *\n     * The resolved option value is set to the return value of the closure.\n     *\n     * @return $this\n     *\n     * @throws UndefinedOptionsException If the option is undefined\n     * @throws AccessException           If called from a lazy option or normalizer\n     */\n    public function setNormalizer(string $option, \\Closure $normalizer): static\n    {\n        if ($this->locked) {\n            throw new AccessException('Normalizers cannot be set from a lazy option or normalizer.');\n        }\n\n        if (!isset($this->defined[$option])) {\n            throw new UndefinedOptionsException(\\sprintf('The option \"%s\" does not exist. Defined options are: \"%s\".', $this->formatOptions([$option]), implode('\", \"', array_keys($this->defined))));\n        }\n\n        $this->normalizers[$option] = [$normalizer];\n\n        // Make sure the option is processed\n        unset($this->resolved[$option]);\n\n        return $this;\n    }\n\n    /**\n     * Adds a normalizer for an option.\n     *\n     * The normalizer should be a closure with the following signature:\n     *\n     *     function (Options $options, $value): mixed {\n     *         // ...\n     *     }\n     *\n     * The closure is invoked when {@link resolve()} is called. The closure\n     * has access to the resolved values of other options through the passed\n     * {@link Options} instance.\n     *\n     * The second parameter passed to the closure is the value of\n     * the option.\n     *\n     * The resolved option value is set to the return value of the closure.\n     *\n     * @return $this\n     *\n     * @throws UndefinedOptionsException If the option is undefined\n     * @throws AccessException           If called from a lazy option or normalizer\n     */\n    public function addNormalizer(string $option, \\Closure $normalizer, bool $forcePrepend = false): static\n    {\n        if ($this->locked) {\n            throw new AccessException('Normalizers cannot be set from a lazy option or normalizer.');\n        }\n\n        if (!isset($this->defined[$option])) {\n            throw new UndefinedOptionsException(\\sprintf('The option \"%s\" does not exist. Defined options are: \"%s\".', $this->formatOptions([$option]), implode('\", \"', array_keys($this->defined))));\n        }\n\n        if ($forcePrepend) {\n            $this->normalizers[$option] ??= [];\n            array_unshift($this->normalizers[$option], $normalizer);\n        } else {\n            $this->normalizers[$option][] = $normalizer;\n        }\n\n        // Make sure the option is processed\n        unset($this->resolved[$option]);\n\n        return $this;\n    }\n\n    /**\n     * Sets allowed values for an option.\n     *\n     * Instead of passing values, you may also pass a closures with the\n     * following signature:\n     *\n     *     function ($value) {\n     *         // return true or false\n     *     }\n     *\n     * The closure receives the value as argument and should return true to\n     * accept the value and false to reject the value.\n     *\n     * @param mixed $allowedValues One or more acceptable values/closures\n     *\n     * @return $this\n     *\n     * @throws UndefinedOptionsException If the option is undefined\n     * @throws AccessException           If called from a lazy option or normalizer\n     */\n    public function setAllowedValues(string $option, mixed $allowedValues): static\n    {\n        if ($this->locked) {\n            throw new AccessException('Allowed values cannot be set from a lazy option or normalizer.');\n        }\n\n        if (!isset($this->defined[$option])) {\n            throw new UndefinedOptionsException(\\sprintf('The option \"%s\" does not exist. Defined options are: \"%s\".', $this->formatOptions([$option]), implode('\", \"', array_keys($this->defined))));\n        }\n\n        $this->allowedValues[$option] = \\is_array($allowedValues) ? $allowedValues : [$allowedValues];\n\n        // Make sure the option is processed\n        unset($this->resolved[$option]);\n\n        return $this;\n    }\n\n    /**\n     * Adds allowed values for an option.\n     *\n     * The values are merged with the allowed values defined previously.\n     *\n     * Instead of passing values, you may also pass a closures with the\n     * following signature:\n     *\n     *     function ($value) {\n     *         // return true or false\n     *     }\n     *\n     * The closure receives the value as argument and should return true to\n     * accept the value and false to reject the value.\n     *\n     * @param mixed $allowedValues One or more acceptable values/closures\n     *\n     * @return $this\n     *\n     * @throws UndefinedOptionsException If the option is undefined\n     * @throws AccessException           If called from a lazy option or normalizer\n     */\n    public function addAllowedValues(string $option, mixed $allowedValues): static\n    {\n        if ($this->locked) {\n            throw new AccessException('Allowed values cannot be added from a lazy option or normalizer.');\n        }\n\n        if (!isset($this->defined[$option])) {\n            throw new UndefinedOptionsException(\\sprintf('The option \"%s\" does not exist. Defined options are: \"%s\".', $this->formatOptions([$option]), implode('\", \"', array_keys($this->defined))));\n        }\n\n        if (!\\is_array($allowedValues)) {\n            $allowedValues = [$allowedValues];\n        }\n\n        if (!isset($this->allowedValues[$option])) {\n            $this->allowedValues[$option] = $allowedValues;\n        } else {\n            $this->allowedValues[$option] = array_merge($this->allowedValues[$option], $allowedValues);\n        }\n\n        // Make sure the option is processed\n        unset($this->resolved[$option]);\n\n        return $this;\n    }\n\n    /**\n     * Sets allowed types for an option.\n     *\n     * Any type for which a corresponding is_<type>() function exists is\n     * acceptable. Additionally, fully-qualified class or interface names may\n     * be passed.\n     *\n     * @param string|string[] $allowedTypes One or more accepted types\n     *\n     * @return $this\n     *\n     * @throws UndefinedOptionsException If the option is undefined\n     * @throws AccessException           If called from a lazy option or normalizer\n     */\n    public function setAllowedTypes(string $option, string|array $allowedTypes): static\n    {\n        if ($this->locked) {\n            throw new AccessException('Allowed types cannot be set from a lazy option or normalizer.');\n        }\n\n        if (!isset($this->defined[$option])) {\n            throw new UndefinedOptionsException(\\sprintf('The option \"%s\" does not exist. Defined options are: \"%s\".', $this->formatOptions([$option]), implode('\", \"', array_keys($this->defined))));\n        }\n\n        $this->allowedTypes[$option] = (array) $allowedTypes;\n\n        // Make sure the option is processed\n        unset($this->resolved[$option]);\n\n        return $this;\n    }\n\n    /**\n     * Adds allowed types for an option.\n     *\n     * The types are merged with the allowed types defined previously.\n     *\n     * Any type for which a corresponding is_<type>() function exists is\n     * acceptable. Additionally, fully-qualified class or interface names may\n     * be passed.\n     *\n     * @param string|string[] $allowedTypes One or more accepted types\n     *\n     * @return $this\n     *\n     * @throws UndefinedOptionsException If the option is undefined\n     * @throws AccessException           If called from a lazy option or normalizer\n     */\n    public function addAllowedTypes(string $option, string|array $allowedTypes): static\n    {\n        if ($this->locked) {\n            throw new AccessException('Allowed types cannot be added from a lazy option or normalizer.');\n        }\n\n        if (!isset($this->defined[$option])) {\n            throw new UndefinedOptionsException(\\sprintf('The option \"%s\" does not exist. Defined options are: \"%s\".', $this->formatOptions([$option]), implode('\", \"', array_keys($this->defined))));\n        }\n\n        if (!isset($this->allowedTypes[$option])) {\n            $this->allowedTypes[$option] = (array) $allowedTypes;\n        } else {\n            $this->allowedTypes[$option] = array_merge($this->allowedTypes[$option], (array) $allowedTypes);\n        }\n\n        // Make sure the option is processed\n        unset($this->resolved[$option]);\n\n        return $this;\n    }\n\n    /**\n     * Defines an option configurator with the given name.\n     */\n    public function define(string $option): OptionConfigurator\n    {\n        if (isset($this->defined[$option])) {\n            throw new OptionDefinitionException(\\sprintf('The option \"%s\" is already defined.', $option));\n        }\n\n        return new OptionConfigurator($option, $this);\n    }\n\n    /**\n     * Sets an info message for an option.\n     *\n     * @return $this\n     *\n     * @throws UndefinedOptionsException If the option is undefined\n     * @throws AccessException           If called from a lazy option or normalizer\n     */\n    public function setInfo(string $option, string $info): static\n    {\n        if ($this->locked) {\n            throw new AccessException('The Info message cannot be set from a lazy option or normalizer.');\n        }\n\n        if (!isset($this->defined[$option])) {\n            throw new UndefinedOptionsException(\\sprintf('The option \"%s\" does not exist. Defined options are: \"%s\".', $this->formatOptions([$option]), implode('\", \"', array_keys($this->defined))));\n        }\n\n        $this->info[$option] = $info;\n\n        return $this;\n    }\n\n    /**\n     * Gets the info message for an option.\n     */\n    public function getInfo(string $option): ?string\n    {\n        if (!isset($this->defined[$option])) {\n            throw new UndefinedOptionsException(\\sprintf('The option \"%s\" does not exist. Defined options are: \"%s\".', $this->formatOptions([$option]), implode('\", \"', array_keys($this->defined))));\n        }\n\n        return $this->info[$option] ?? null;\n    }\n\n    /**\n     * Marks the whole options definition as array prototype.\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option, a normalizer or a root definition\n     */\n    public function setPrototype(bool $prototype): static\n    {\n        if ($this->locked) {\n            throw new AccessException('The prototype property cannot be set from a lazy option or normalizer.');\n        }\n\n        if (null === $this->prototype && $prototype) {\n            throw new AccessException('The prototype property cannot be set from a root definition.');\n        }\n\n        $this->prototype = $prototype;\n\n        return $this;\n    }\n\n    public function isPrototype(): bool\n    {\n        return $this->prototype ?? false;\n    }\n\n    /**\n     * Removes the option with the given name.\n     *\n     * Undefined options are ignored.\n     *\n     * @param string|string[] $optionNames One or more option names\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function remove(string|array $optionNames): static\n    {\n        if ($this->locked) {\n            throw new AccessException('Options cannot be removed from a lazy option or normalizer.');\n        }\n\n        foreach ((array) $optionNames as $option) {\n            unset($this->defined[$option], $this->defaults[$option], $this->required[$option], $this->resolved[$option]);\n            unset($this->lazy[$option], $this->normalizers[$option], $this->allowedTypes[$option], $this->allowedValues[$option], $this->info[$option]);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Removes all options.\n     *\n     * @return $this\n     *\n     * @throws AccessException If called from a lazy option or normalizer\n     */\n    public function clear(): static\n    {\n        if ($this->locked) {\n            throw new AccessException('Options cannot be cleared from a lazy option or normalizer.');\n        }\n\n        $this->defined = [];\n        $this->defaults = [];\n        $this->nested = [];\n        $this->required = [];\n        $this->resolved = [];\n        $this->lazy = [];\n        $this->normalizers = [];\n        $this->allowedTypes = [];\n        $this->allowedValues = [];\n        $this->deprecated = [];\n        $this->info = [];\n\n        return $this;\n    }\n\n    /**\n     * Merges options with the default values stored in the container and\n     * validates them.\n     *\n     * Exceptions are thrown if:\n     *\n     *  - Undefined options are passed;\n     *  - Required options are missing;\n     *  - Options have invalid types;\n     *  - Options have invalid values.\n     *\n     * @throws UndefinedOptionsException If an option name is undefined\n     * @throws InvalidOptionsException   If an option doesn't fulfill the\n     *                                   specified validation rules\n     * @throws MissingOptionsException   If a required option is missing\n     * @throws OptionDefinitionException If there is a cyclic dependency between\n     *                                   lazy options and/or normalizers\n     * @throws NoSuchOptionException     If a lazy option reads an unavailable option\n     * @throws AccessException           If called from a lazy option or normalizer\n     */\n    public function resolve(array $options = []): array\n    {\n        if ($this->locked) {\n            throw new AccessException('Options cannot be resolved from a lazy option or normalizer.');\n        }\n\n        // Allow this method to be called multiple times\n        $clone = clone $this;\n\n        // Make sure that no unknown options are passed\n        $diff = $this->ignoreUndefined ? [] : array_diff_key($options, $clone->defined);\n\n        if (\\count($diff) > 0) {\n            ksort($clone->defined);\n            ksort($diff);\n\n            throw new UndefinedOptionsException(\\sprintf((\\count($diff) > 1 ? 'The options \"%s\" do not exist.' : 'The option \"%s\" does not exist.').' Defined options are: \"%s\".', $this->formatOptions(array_keys($diff)), implode('\", \"', array_keys($clone->defined))));\n        }\n\n        // Override options set by the user\n        foreach ($options as $option => $value) {\n            if ($this->ignoreUndefined && !isset($clone->defined[$option])) {\n                continue;\n            }\n\n            $clone->given[$option] = true;\n            $clone->defaults[$option] = $value;\n            unset($clone->resolved[$option], $clone->lazy[$option]);\n        }\n\n        // Check whether any required option is missing\n        $diff = array_diff_key($clone->required, $clone->defaults);\n\n        if (\\count($diff) > 0) {\n            ksort($diff);\n\n            throw new MissingOptionsException(\\sprintf(\\count($diff) > 1 ? 'The required options \"%s\" are missing.' : 'The required option \"%s\" is missing.', $this->formatOptions(array_keys($diff))));\n        }\n\n        // Lock the container\n        $clone->locked = true;\n\n        // Now process the individual options. Use offsetGet(), which resolves\n        // the option itself and any options that the option depends on\n        foreach ($clone->defaults as $option => $_) {\n            $clone->offsetGet($option);\n        }\n\n        return $clone->resolved;\n    }\n\n    /**\n     * Returns the resolved value of an option.\n     *\n     * @param bool $triggerDeprecation Whether to trigger the deprecation or not (true by default)\n     *\n     * @throws AccessException           If accessing this method outside of\n     *                                   {@link resolve()}\n     * @throws NoSuchOptionException     If the option is not set\n     * @throws InvalidOptionsException   If the option doesn't fulfill the\n     *                                   specified validation rules\n     * @throws OptionDefinitionException If there is a cyclic dependency between\n     *                                   lazy options and/or normalizers\n     */\n    public function offsetGet(mixed $option, bool $triggerDeprecation = true): mixed\n    {\n        if (!$this->locked) {\n            throw new AccessException('Array access is only supported within closures of lazy options and normalizers.');\n        }\n\n        // Shortcut for resolved options\n        if (isset($this->resolved[$option]) || \\array_key_exists($option, $this->resolved)) {\n            if ($triggerDeprecation && isset($this->deprecated[$option]) && (isset($this->given[$option]) || $this->calling) && \\is_string($this->deprecated[$option]['message'])) {\n                trigger_deprecation($this->deprecated[$option]['package'], $this->deprecated[$option]['version'], strtr($this->deprecated[$option]['message'], ['%name%' => $option]));\n            }\n\n            return $this->resolved[$option];\n        }\n\n        // Check whether the option is set at all\n        if (!isset($this->defaults[$option]) && !\\array_key_exists($option, $this->defaults)) {\n            if (!isset($this->defined[$option])) {\n                throw new NoSuchOptionException(\\sprintf('The option \"%s\" does not exist. Defined options are: \"%s\".', $this->formatOptions([$option]), implode('\", \"', array_keys($this->defined))));\n            }\n\n            throw new NoSuchOptionException(\\sprintf('The optional option \"%s\" has no value set. You should make sure it is set with \"isset\" before reading it.', $this->formatOptions([$option])));\n        }\n\n        $value = $this->defaults[$option];\n\n        // Resolve the option if it is a nested definition\n        if (isset($this->nested[$option])) {\n            // If the closure is already being called, we have a cyclic dependency\n            if (isset($this->calling[$option])) {\n                throw new OptionDefinitionException(\\sprintf('The options \"%s\" have a cyclic dependency.', $this->formatOptions(array_keys($this->calling))));\n            }\n\n            if (!\\is_array($value)) {\n                throw new InvalidOptionsException(\\sprintf('The nested option \"%s\" with value %s is expected to be of type array, but is of type \"%s\".', $this->formatOptions([$option]), $this->formatValue($value), get_debug_type($value)));\n            }\n\n            // The following section must be protected from cyclic calls.\n            $this->calling[$option] = true;\n            try {\n                $resolver = new self();\n                $resolver->prototype = false;\n                $resolver->parentsOptions = $this->parentsOptions;\n                $resolver->parentsOptions[] = $option;\n                foreach ($this->nested[$option] as $closure) {\n                    $closure($resolver, $this);\n                }\n\n                if ($resolver->prototype) {\n                    $values = [];\n                    foreach ($value as $index => $prototypeValue) {\n                        if (!\\is_array($prototypeValue)) {\n                            throw new InvalidOptionsException(\\sprintf('The value of the option \"%s\" is expected to be of type array of array, but is of type array of \"%s\".', $this->formatOptions([$option]), get_debug_type($prototypeValue)));\n                        }\n\n                        $resolver->prototypeIndex = $index;\n                        $values[$index] = $resolver->resolve($prototypeValue);\n                    }\n                    $value = $values;\n                } else {\n                    $value = $resolver->resolve($value);\n                }\n            } finally {\n                $resolver->prototypeIndex = null;\n                unset($this->calling[$option]);\n            }\n        }\n\n        // Resolve the option if the default value is lazily evaluated\n        if (isset($this->lazy[$option])) {\n            // If the closure is already being called, we have a cyclic\n            // dependency\n            if (isset($this->calling[$option])) {\n                throw new OptionDefinitionException(\\sprintf('The options \"%s\" have a cyclic dependency.', $this->formatOptions(array_keys($this->calling))));\n            }\n\n            // The following section must be protected from cyclic\n            // calls. Set $calling for the current $option to detect a cyclic\n            // dependency\n            // BEGIN\n            $this->calling[$option] = true;\n            try {\n                foreach ($this->lazy[$option] as $closure) {\n                    $value = $closure($this, $value);\n                }\n            } finally {\n                unset($this->calling[$option]);\n            }\n            // END\n        }\n\n        // Validate the type of the resolved option\n        if (isset($this->allowedTypes[$option])) {\n            $valid = true;\n            $invalidTypes = [];\n\n            foreach ($this->allowedTypes[$option] as $type) {\n                if ($valid = $this->verifyTypes($type, $value, $invalidTypes)) {\n                    break;\n                }\n            }\n\n            if (!$valid) {\n                $fmtActualValue = $this->formatValue($value);\n                $fmtAllowedTypes = implode('\" or \"', $this->allowedTypes[$option]);\n                $fmtProvidedTypes = implode('|', array_keys($invalidTypes));\n                $allowedContainsArrayType = \\count(array_filter($this->allowedTypes[$option], static fn ($item) => str_ends_with($item, '[]'))) > 0;\n\n                if (\\is_array($value) && $allowedContainsArrayType) {\n                    throw new InvalidOptionsException(\\sprintf('The option \"%s\" with value %s is expected to be of type \"%s\", but one of the elements is of type \"%s\".', $this->formatOptions([$option]), $fmtActualValue, $fmtAllowedTypes, $fmtProvidedTypes));\n                }\n\n                throw new InvalidOptionsException(\\sprintf('The option \"%s\" with value %s is expected to be of type \"%s\", but is of type \"%s\".', $this->formatOptions([$option]), $fmtActualValue, $fmtAllowedTypes, $fmtProvidedTypes));\n            }\n        }\n\n        // Validate the value of the resolved option\n        if (isset($this->allowedValues[$option])) {\n            $success = false;\n            $printableAllowedValues = [];\n\n            foreach ($this->allowedValues[$option] as $allowedValue) {\n                if ($allowedValue instanceof \\Closure) {\n                    if ($allowedValue($value)) {\n                        $success = true;\n                        break;\n                    }\n\n                    // Don't include closures in the exception message\n                    continue;\n                }\n\n                if ($value === $allowedValue) {\n                    $success = true;\n                    break;\n                }\n\n                $printableAllowedValues[] = $allowedValue;\n            }\n\n            if (!$success) {\n                $message = \\sprintf(\n                    'The option \"%s\" with value %s is invalid.',\n                    $this->formatOptions([$option]),\n                    $this->formatValue($value)\n                );\n\n                if (\\count($printableAllowedValues) > 0) {\n                    $message .= \\sprintf(\n                        ' Accepted values are: %s.',\n                        $this->formatValues($printableAllowedValues)\n                    );\n                }\n\n                if (isset($this->info[$option])) {\n                    $message .= \\sprintf(' Info: %s.', $this->info[$option]);\n                }\n\n                throw new InvalidOptionsException($message);\n            }\n        }\n\n        // Check whether the option is deprecated\n        // and it is provided by the user or is being called from a lazy evaluation\n        if ($triggerDeprecation && isset($this->deprecated[$option]) && (isset($this->given[$option]) || ($this->calling && \\is_string($this->deprecated[$option]['message'])))) {\n            $deprecation = $this->deprecated[$option];\n            $message = $this->deprecated[$option]['message'];\n\n            if ($message instanceof \\Closure) {\n                // If the closure is already being called, we have a cyclic dependency\n                if (isset($this->calling[$option])) {\n                    throw new OptionDefinitionException(\\sprintf('The options \"%s\" have a cyclic dependency.', $this->formatOptions(array_keys($this->calling))));\n                }\n\n                $this->calling[$option] = true;\n                try {\n                    if (!\\is_string($message = $message($this, $value))) {\n                        throw new InvalidOptionsException(\\sprintf('Invalid type for deprecation message, expected string but got \"%s\", return an empty string to ignore.', get_debug_type($message)));\n                    }\n                } finally {\n                    unset($this->calling[$option]);\n                }\n            }\n\n            if ('' !== $message) {\n                trigger_deprecation($deprecation['package'], $deprecation['version'], strtr($message, ['%name%' => $option]));\n            }\n        }\n\n        // Normalize the validated option\n        if (isset($this->normalizers[$option])) {\n            // If the closure is already being called, we have a cyclic\n            // dependency\n            if (isset($this->calling[$option])) {\n                throw new OptionDefinitionException(\\sprintf('The options \"%s\" have a cyclic dependency.', $this->formatOptions(array_keys($this->calling))));\n            }\n\n            // The following section must be protected from cyclic\n            // calls. Set $calling for the current $option to detect a cyclic\n            // dependency\n            // BEGIN\n            $this->calling[$option] = true;\n            try {\n                foreach ($this->normalizers[$option] as $normalizer) {\n                    $value = $normalizer($this, $value);\n                }\n            } finally {\n                unset($this->calling[$option]);\n            }\n            // END\n        }\n\n        // Mark as resolved\n        $this->resolved[$option] = $value;\n\n        return $value;\n    }\n\n    private function verifyTypes(string $type, mixed $value, array &$invalidTypes, int $level = 0): bool\n    {\n        if (\\is_array($value) && str_ends_with($type, '[]')) {\n            $type = substr($type, 0, -2);\n            $valid = true;\n\n            foreach ($value as $val) {\n                if (!$this->verifyTypes($type, $val, $invalidTypes, $level + 1)) {\n                    $valid = false;\n                }\n            }\n\n            return $valid;\n        }\n\n        if (('null' === $type && null === $value) || (isset(self::VALIDATION_FUNCTIONS[$type]) ? self::VALIDATION_FUNCTIONS[$type]($value) : $value instanceof $type)) {\n            return true;\n        }\n\n        if (!$invalidTypes || $level > 0) {\n            $invalidTypes[get_debug_type($value)] = true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns whether a resolved option with the given name exists.\n     *\n     * @throws AccessException If accessing this method outside of {@link resolve()}\n     *\n     * @see \\ArrayAccess::offsetExists()\n     */\n    public function offsetExists(mixed $option): bool\n    {\n        if (!$this->locked) {\n            throw new AccessException('Array access is only supported within closures of lazy options and normalizers.');\n        }\n\n        return \\array_key_exists($option, $this->defaults);\n    }\n\n    /**\n     * Not supported.\n     *\n     * @throws AccessException\n     */\n    public function offsetSet(mixed $option, mixed $value): void\n    {\n        throw new AccessException('Setting options via array access is not supported. Use setDefault() instead.');\n    }\n\n    /**\n     * Not supported.\n     *\n     * @throws AccessException\n     */\n    public function offsetUnset(mixed $option): void\n    {\n        throw new AccessException('Removing options via array access is not supported. Use remove() instead.');\n    }\n\n    /**\n     * Returns the number of set options.\n     *\n     * This may be only a subset of the defined options.\n     *\n     * @throws AccessException If accessing this method outside of {@link resolve()}\n     *\n     * @see \\Countable::count()\n     */\n    public function count(): int\n    {\n        if (!$this->locked) {\n            throw new AccessException('Counting is only supported within closures of lazy options and normalizers.');\n        }\n\n        return \\count($this->defaults);\n    }\n\n    /**\n     * Sets whether ignore undefined options.\n     *\n     * @return $this\n     */\n    public function setIgnoreUndefined(bool $ignore = true): static\n    {\n        $this->ignoreUndefined = $ignore;\n\n        return $this;\n    }\n\n    /**\n     * Returns a string representation of the value.\n     *\n     * This method returns the equivalent PHP tokens for most scalar types\n     * (i.e. \"false\" for false, \"1\" for 1 etc.). Strings are always wrapped\n     * in double quotes (\").\n     */\n    private function formatValue(mixed $value): string\n    {\n        if (\\is_object($value)) {\n            return $value::class;\n        }\n\n        if (\\is_array($value)) {\n            return 'array';\n        }\n\n        if (\\is_string($value)) {\n            return '\"'.$value.'\"';\n        }\n\n        if (\\is_resource($value)) {\n            return 'resource';\n        }\n\n        if (null === $value) {\n            return 'null';\n        }\n\n        if (false === $value) {\n            return 'false';\n        }\n\n        if (true === $value) {\n            return 'true';\n        }\n\n        return (string) $value;\n    }\n\n    /**\n     * Returns a string representation of a list of values.\n     *\n     * Each of the values is converted to a string using\n     * {@link formatValue()}. The values are then concatenated with commas.\n     *\n     * @see formatValue()\n     */\n    private function formatValues(array $values): string\n    {\n        foreach ($values as $key => $value) {\n            $values[$key] = $this->formatValue($value);\n        }\n\n        return implode(', ', $values);\n    }\n\n    private function formatOptions(array $options): string\n    {\n        if ($this->parentsOptions) {\n            $prefix = array_shift($this->parentsOptions);\n            if ($this->parentsOptions) {\n                $prefix .= \\sprintf('[%s]', implode('][', $this->parentsOptions));\n            }\n\n            if ($this->prototype && null !== $this->prototypeIndex) {\n                $prefix .= \\sprintf('[%s]', $this->prototypeIndex);\n            }\n\n            $options = array_map(static fn (string $option): string => \\sprintf('%s[%s]', $prefix, $option), $options);\n        }\n\n        return implode('\", \"', $options);\n    }\n\n    private function getParameterClassName(\\ReflectionParameter $parameter): ?string\n    {\n        if (!($type = $parameter->getType()) instanceof \\ReflectionNamedType || $type->isBuiltin()) {\n            return null;\n        }\n\n        return $type->getName();\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.611328125,
          "content": "OptionsResolver Component\n=========================\n\nThe OptionsResolver component is `array_replace` on steroids. It allows you to\ncreate an options system with required options, defaults, validation (type,\nvalue), normalization and more.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/options_resolver.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.7900390625,
          "content": "{\n    \"name\": \"symfony/options-resolver\",\n    \"type\": \"library\",\n    \"description\": \"Provides an improved replacement for the array_replace PHP function\",\n    \"keywords\": [\"options\", \"config\", \"configuration\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\OptionsResolver\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.8525390625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony OptionsResolver Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Resources</directory>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}