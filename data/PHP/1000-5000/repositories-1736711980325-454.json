{
  "metadata": {
    "timestamp": 1736711980325,
    "page": 454,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/var-exporter",
      "stars": 2061,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "composer.lock\nphpunit.xml\nvendor/\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.5400390625,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Allow reinitializing lazy objects with a new initializer\n\n6.4\n---\n\n * Deprecate per-property lazy-initializers\n\n6.2\n---\n\n * Add support for lazy ghost objects and virtual proxies\n * Add `Hydrator::hydrate()`\n * Preserve PHP references also when using `Hydrator::hydrate()` or `Instantiator::instantiate()`\n * Add support for hydrating from native (array) casts\n\n5.1.0\n-----\n\n * added argument `array &$foundClasses` to `VarExporter::export()` to ease with preloading exported values\n\n4.2.0\n-----\n\n * added the component\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Hydrator.php",
          "type": "blob",
          "size": 2.939453125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarExporter;\n\nuse Symfony\\Component\\VarExporter\\Internal\\Hydrator as InternalHydrator;\n\n/**\n * Utility class to hydrate the properties of an object.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class Hydrator\n{\n    /**\n     * Sets the properties of an object, including private and protected ones.\n     *\n     * For example:\n     *\n     *     // Sets the public or protected $object->propertyName property\n     *     Hydrator::hydrate($object, ['propertyName' => $propertyValue]);\n     *\n     *     // Sets a private property defined on its parent Bar class:\n     *     Hydrator::hydrate($object, [\"\\0Bar\\0privateBarProperty\" => $propertyValue]);\n     *\n     *     // Alternative way to set the private $object->privateBarProperty property\n     *     Hydrator::hydrate($object, [], [\n     *         Bar::class => ['privateBarProperty' => $propertyValue],\n     *     ]);\n     *\n     * Instances of ArrayObject, ArrayIterator and SplObjectStorage can be hydrated\n     * by using the special \"\\0\" property name to define their internal value:\n     *\n     *     // Hydrates an SplObjectStorage where $info1 is attached to $obj1, etc.\n     *     Hydrator::hydrate($object, [\"\\0\" => [$obj1, $info1, $obj2, $info2...]]);\n     *\n     *     // Hydrates an ArrayObject populated with $inputArray\n     *     Hydrator::hydrate($object, [\"\\0\" => [$inputArray]]);\n     *\n     * @template T of object\n     *\n     * @param T                                         $instance         The object to hydrate\n     * @param array<string, mixed>                      $properties       The properties to set on the instance\n     * @param array<class-string, array<string, mixed>> $scopedProperties The properties to set on the instance,\n     *                                                                    keyed by their declaring class\n     *\n     * @return T\n     */\n    public static function hydrate(object $instance, array $properties = [], array $scopedProperties = []): object\n    {\n        if ($properties) {\n            $class = $instance::class;\n            $propertyScopes = InternalHydrator::$propertyScopes[$class] ??= InternalHydrator::getPropertyScopes($class);\n\n            foreach ($properties as $name => &$value) {\n                [$scope, $name, $readonlyScope] = $propertyScopes[$name] ?? [$class, $name, $class];\n                $scopedProperties[$readonlyScope ?? $scope][$name] = &$value;\n            }\n            unset($value);\n        }\n\n        foreach ($scopedProperties as $scope => $properties) {\n            if ($properties) {\n                (InternalHydrator::$simpleHydrators[$scope] ??= InternalHydrator::getSimpleHydrator($scope))($properties, $instance);\n            }\n        }\n\n        return $instance;\n    }\n}\n"
        },
        {
          "name": "Instantiator.php",
          "type": "blob",
          "size": 2.3359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarExporter;\n\nuse Symfony\\Component\\VarExporter\\Exception\\ExceptionInterface;\nuse Symfony\\Component\\VarExporter\\Exception\\NotInstantiableTypeException;\nuse Symfony\\Component\\VarExporter\\Internal\\Registry;\n\n/**\n * A utility class to create objects without calling their constructor.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class Instantiator\n{\n    /**\n     * Creates an object and sets its properties without calling its constructor nor any other methods.\n     *\n     * @see Hydrator::hydrate() for examples\n     *\n     * @template T of object\n     *\n     * @param class-string<T>                           $class            The class of the instance to create\n     * @param array<string, mixed>                      $properties       The properties to set on the instance\n     * @param array<class-string, array<string, mixed>> $scopedProperties The properties to set on the instance,\n     *                                                                    keyed by their declaring class\n     *\n     * @return T\n     *\n     * @throws ExceptionInterface When the instance cannot be created\n     */\n    public static function instantiate(string $class, array $properties = [], array $scopedProperties = []): object\n    {\n        $reflector = Registry::$reflectors[$class] ??= Registry::getClassReflector($class);\n\n        if (Registry::$cloneable[$class]) {\n            $instance = clone Registry::$prototypes[$class];\n        } elseif (Registry::$instantiableWithoutConstructor[$class]) {\n            $instance = $reflector->newInstanceWithoutConstructor();\n        } elseif (null === Registry::$prototypes[$class]) {\n            throw new NotInstantiableTypeException($class);\n        } elseif ($reflector->implementsInterface('Serializable') && !method_exists($class, '__unserialize')) {\n            $instance = unserialize('C:'.\\strlen($class).':\"'.$class.'\":0:{}');\n        } else {\n            $instance = unserialize('O:'.\\strlen($class).':\"'.$class.'\":0:{}');\n        }\n\n        return $properties || $scopedProperties ? Hydrator::hydrate($instance, $properties, $scopedProperties) : $instance;\n    }\n}\n"
        },
        {
          "name": "Internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2018-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "LazyGhostTrait.php",
          "type": "blob",
          "size": 12.87890625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarExporter;\n\nuse Symfony\\Component\\Serializer\\Attribute\\Ignore;\nuse Symfony\\Component\\VarExporter\\Internal\\Hydrator;\nuse Symfony\\Component\\VarExporter\\Internal\\LazyObjectRegistry as Registry;\nuse Symfony\\Component\\VarExporter\\Internal\\LazyObjectState;\nuse Symfony\\Component\\VarExporter\\Internal\\LazyObjectTrait;\n\ntrait LazyGhostTrait\n{\n    use LazyObjectTrait;\n\n    /**\n     * Creates a lazy-loading ghost instance.\n     *\n     * Skipped properties should be indexed by their array-cast identifier, see\n     * https://php.net/manual/language.types.array#language.types.array.casting\n     *\n     * @param \\Closure(static):void    $initializer       The closure should initialize the object it receives as argument\n     * @param array<string, true>|null $skippedProperties An array indexed by the properties to skip, a.k.a. the ones\n     *                                                    that the initializer doesn't initialize, if any\n     * @param static|null              $instance\n     */\n    public static function createLazyGhost(\\Closure $initializer, ?array $skippedProperties = null, ?object $instance = null): static\n    {\n        if (self::class !== $class = $instance ? $instance::class : static::class) {\n            $skippedProperties[\"\\0\".self::class.\"\\0lazyObjectState\"] = true;\n        }\n\n        if (!isset(Registry::$defaultProperties[$class])) {\n            Registry::$classReflectors[$class] ??= new \\ReflectionClass($class);\n            $instance ??= Registry::$classReflectors[$class]->newInstanceWithoutConstructor();\n            Registry::$defaultProperties[$class] ??= (array) $instance;\n            Registry::$classResetters[$class] ??= Registry::getClassResetters($class);\n\n            if (self::class === $class && \\defined($class.'::LAZY_OBJECT_PROPERTY_SCOPES')) {\n                Hydrator::$propertyScopes[$class] ??= $class::LAZY_OBJECT_PROPERTY_SCOPES;\n            }\n        } else {\n            $instance ??= Registry::$classReflectors[$class]->newInstanceWithoutConstructor();\n        }\n\n        if (isset($instance->lazyObjectState)) {\n            $instance->lazyObjectState->initializer = $initializer;\n            $instance->lazyObjectState->skippedProperties = $skippedProperties ??= [];\n\n            if (LazyObjectState::STATUS_UNINITIALIZED_FULL !== $instance->lazyObjectState->status) {\n                $instance->lazyObjectState->reset($instance);\n            }\n\n            return $instance;\n        }\n\n        $instance->lazyObjectState = new LazyObjectState($initializer, $skippedProperties ??= []);\n\n        foreach (Registry::$classResetters[$class] as $reset) {\n            $reset($instance, $skippedProperties);\n        }\n\n        return $instance;\n    }\n\n    /**\n     * Returns whether the object is initialized.\n     *\n     * @param bool $partial Whether partially initialized objects should be considered as initialized\n     */\n    #[Ignore]\n    public function isLazyObjectInitialized(bool $partial = false): bool\n    {\n        if (!$state = $this->lazyObjectState ?? null) {\n            return true;\n        }\n\n        return LazyObjectState::STATUS_INITIALIZED_FULL === $state->status;\n    }\n\n    /**\n     * Forces initialization of a lazy object and returns it.\n     */\n    public function initializeLazyObject(): static\n    {\n        if (!$state = $this->lazyObjectState ?? null) {\n            return $this;\n        }\n\n        if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {\n            $state->initialize($this, '', null);\n        }\n\n        return $this;\n    }\n\n    /**\n     * @return bool Returns false when the object cannot be reset, ie when it's not a lazy object\n     */\n    public function resetLazyObject(): bool\n    {\n        if (!$state = $this->lazyObjectState ?? null) {\n            return false;\n        }\n\n        if (LazyObjectState::STATUS_UNINITIALIZED_FULL !== $state->status) {\n            $state->reset($this);\n        }\n\n        return true;\n    }\n\n    public function &__get($name): mixed\n    {\n        $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);\n        $scope = null;\n\n        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {\n            $scope = Registry::getScope($propertyScopes, $class, $name);\n            $state = $this->lazyObjectState ?? null;\n\n            if ($state && (null === $scope || isset($propertyScopes[\"\\0$scope\\0$name\"]))) {\n                if (LazyObjectState::STATUS_INITIALIZED_FULL === $state->status) {\n                    // Work around php/php-src#12695\n                    $property = null === $scope ? $name : \"\\0$scope\\0$name\";\n                    $property = $propertyScopes[$property][3]\n                        ?? Hydrator::$propertyScopes[$this::class][$property][3] = new \\ReflectionProperty($scope ?? $class, $name);\n                } else {\n                    $property = null;\n                }\n\n                if ($property?->isInitialized($this) ?? LazyObjectState::STATUS_UNINITIALIZED_PARTIAL !== $state->initialize($this, $name, $readonlyScope ?? $scope)) {\n                    goto get_in_scope;\n                }\n            }\n        }\n\n        if ($parent = (Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['get']) {\n            if (2 === $parent) {\n                return parent::__get($name);\n            }\n            $value = parent::__get($name);\n\n            return $value;\n        }\n\n        if (null === $class) {\n            $frame = debug_backtrace(\\DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];\n            trigger_error(\\sprintf('Undefined property: %s::$%s in %s on line %s', $this::class, $name, $frame['file'], $frame['line']), \\E_USER_NOTICE);\n        }\n\n        get_in_scope:\n\n        try {\n            if (null === $scope) {\n                if (null === $readonlyScope) {\n                    return $this->$name;\n                }\n                $value = $this->$name;\n\n                return $value;\n            }\n            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);\n\n            return $accessor['get']($this, $name, null !== $readonlyScope);\n        } catch (\\Error $e) {\n            if (\\Error::class !== $e::class || !str_starts_with($e->getMessage(), 'Cannot access uninitialized non-nullable property')) {\n                throw $e;\n            }\n\n            try {\n                if (null === $scope) {\n                    $this->$name = [];\n\n                    return $this->$name;\n                }\n\n                $accessor['set']($this, $name, []);\n\n                return $accessor['get']($this, $name, null !== $readonlyScope);\n            } catch (\\Error) {\n                if (preg_match('/^Cannot access uninitialized non-nullable property ([^ ]++) by reference$/', $e->getMessage(), $matches)) {\n                    throw new \\Error('Typed property '.$matches[1].' must not be accessed before initialization', $e->getCode(), $e->getPrevious());\n                }\n\n                throw $e;\n            }\n        }\n    }\n\n    public function __set($name, $value): void\n    {\n        $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);\n        $scope = null;\n\n        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {\n            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);\n            $state = $this->lazyObjectState ?? null;\n\n            if ($state && ($readonlyScope === $scope || isset($propertyScopes[\"\\0$scope\\0$name\"]))\n                && LazyObjectState::STATUS_INITIALIZED_FULL !== $state->status\n            ) {\n                if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {\n                    $state->initialize($this, $name, $readonlyScope ?? $scope);\n                }\n                goto set_in_scope;\n            }\n        }\n\n        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['set']) {\n            parent::__set($name, $value);\n\n            return;\n        }\n\n        set_in_scope:\n\n        if (null === $scope) {\n            $this->$name = $value;\n        } else {\n            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);\n            $accessor['set']($this, $name, $value);\n        }\n    }\n\n    public function __isset($name): bool\n    {\n        $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);\n        $scope = null;\n\n        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {\n            $scope = Registry::getScope($propertyScopes, $class, $name);\n            $state = $this->lazyObjectState ?? null;\n\n            if ($state && (null === $scope || isset($propertyScopes[\"\\0$scope\\0$name\"]))\n                && LazyObjectState::STATUS_INITIALIZED_FULL !== $state->status\n                && LazyObjectState::STATUS_UNINITIALIZED_PARTIAL !== $state->initialize($this, $name, $readonlyScope ?? $scope)\n            ) {\n                goto isset_in_scope;\n            }\n        }\n\n        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['isset']) {\n            return parent::__isset($name);\n        }\n\n        isset_in_scope:\n\n        if (null === $scope) {\n            return isset($this->$name);\n        }\n        $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);\n\n        return $accessor['isset']($this, $name);\n    }\n\n    public function __unset($name): void\n    {\n        $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);\n        $scope = null;\n\n        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {\n            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);\n            $state = $this->lazyObjectState ?? null;\n\n            if ($state && ($readonlyScope === $scope || isset($propertyScopes[\"\\0$scope\\0$name\"]))\n                && LazyObjectState::STATUS_INITIALIZED_FULL !== $state->status\n            ) {\n                if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {\n                    $state->initialize($this, $name, $readonlyScope ?? $scope);\n                }\n                goto unset_in_scope;\n            }\n        }\n\n        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['unset']) {\n            parent::__unset($name);\n\n            return;\n        }\n\n        unset_in_scope:\n\n        if (null === $scope) {\n            unset($this->$name);\n        } else {\n            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);\n            $accessor['unset']($this, $name);\n        }\n    }\n\n    public function __clone(): void\n    {\n        if ($state = $this->lazyObjectState ?? null) {\n            $this->lazyObjectState = clone $state;\n        }\n\n        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['clone']) {\n            parent::__clone();\n        }\n    }\n\n    public function __serialize(): array\n    {\n        $class = self::class;\n\n        if ((Registry::$parentMethods[$class] ??= Registry::getParentMethods($class))['serialize']) {\n            $properties = parent::__serialize();\n        } else {\n            $this->initializeLazyObject();\n            $properties = (array) $this;\n        }\n        unset($properties[\"\\0$class\\0lazyObjectState\"]);\n\n        if (Registry::$parentMethods[$class]['serialize'] || !Registry::$parentMethods[$class]['sleep']) {\n            return $properties;\n        }\n\n        $scope = get_parent_class($class);\n        $data = [];\n\n        foreach (parent::__sleep() as $name) {\n            $value = $properties[$k = $name] ?? $properties[$k = \"\\0*\\0$name\"] ?? $properties[$k = \"\\0$class\\0$name\"] ?? $properties[$k = \"\\0$scope\\0$name\"] ?? $k = null;\n\n            if (null === $k) {\n                trigger_error(\\sprintf('serialize(): \"%s\" returned as member variable from __sleep() but does not exist', $name), \\E_USER_NOTICE);\n            } else {\n                $data[$k] = $value;\n            }\n        }\n\n        return $data;\n    }\n\n    public function __destruct()\n    {\n        $state = $this->lazyObjectState ?? null;\n\n        if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state?->status) {\n            return;\n        }\n\n        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['destruct']) {\n            parent::__destruct();\n        }\n    }\n\n    #[Ignore]\n    private function setLazyObjectAsInitialized(bool $initialized): void\n    {\n        if ($state = $this->lazyObjectState ?? null) {\n            $state->status = $initialized ? LazyObjectState::STATUS_INITIALIZED_FULL : LazyObjectState::STATUS_UNINITIALIZED_FULL;\n        }\n    }\n}\n"
        },
        {
          "name": "LazyObjectInterface.php",
          "type": "blob",
          "size": 0.833984375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarExporter;\n\ninterface LazyObjectInterface\n{\n    /**\n     * Returns whether the object is initialized.\n     *\n     * @param bool $partial Whether partially initialized objects should be considered as initialized\n     */\n    public function isLazyObjectInitialized(bool $partial = false): bool;\n\n    /**\n     * Forces initialization of a lazy object and returns it.\n     */\n    public function initializeLazyObject(): object;\n\n    /**\n     * @return bool Returns false when the object cannot be reset, ie when it's not a lazy object\n     */\n    public function resetLazyObject(): bool;\n}\n"
        },
        {
          "name": "LazyProxyTrait.php",
          "type": "blob",
          "size": 12.6611328125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarExporter;\n\nuse Symfony\\Component\\Serializer\\Attribute\\Ignore;\nuse Symfony\\Component\\VarExporter\\Hydrator as PublicHydrator;\nuse Symfony\\Component\\VarExporter\\Internal\\Hydrator;\nuse Symfony\\Component\\VarExporter\\Internal\\LazyObjectRegistry as Registry;\nuse Symfony\\Component\\VarExporter\\Internal\\LazyObjectState;\nuse Symfony\\Component\\VarExporter\\Internal\\LazyObjectTrait;\n\ntrait LazyProxyTrait\n{\n    use LazyObjectTrait;\n\n    /**\n     * Creates a lazy-loading virtual proxy.\n     *\n     * @param \\Closure():object $initializer Returns the proxied object\n     * @param static|null       $instance\n     */\n    public static function createLazyProxy(\\Closure $initializer, ?object $instance = null): static\n    {\n        if (self::class !== $class = $instance ? $instance::class : static::class) {\n            $skippedProperties = [\"\\0\".self::class.\"\\0lazyObjectState\" => true];\n        }\n\n        if (!isset(Registry::$defaultProperties[$class])) {\n            Registry::$classReflectors[$class] ??= new \\ReflectionClass($class);\n            $instance ??= Registry::$classReflectors[$class]->newInstanceWithoutConstructor();\n            Registry::$defaultProperties[$class] ??= (array) $instance;\n            Registry::$classResetters[$class] ??= Registry::getClassResetters($class);\n\n            if (self::class === $class && \\defined($class.'::LAZY_OBJECT_PROPERTY_SCOPES')) {\n                Hydrator::$propertyScopes[$class] ??= $class::LAZY_OBJECT_PROPERTY_SCOPES;\n            }\n        } else {\n            $instance ??= Registry::$classReflectors[$class]->newInstanceWithoutConstructor();\n        }\n\n        if (isset($instance->lazyObjectState)) {\n            $instance->lazyObjectState->initializer = $initializer;\n            unset($instance->lazyObjectState->realInstance);\n\n            return $instance;\n        }\n\n        $instance->lazyObjectState = new LazyObjectState($initializer);\n\n        foreach (Registry::$classResetters[$class] as $reset) {\n            $reset($instance, $skippedProperties ??= []);\n        }\n\n        return $instance;\n    }\n\n    /**\n     * Returns whether the object is initialized.\n     *\n     * @param bool $partial Whether partially initialized objects should be considered as initialized\n     */\n    #[Ignore]\n    public function isLazyObjectInitialized(bool $partial = false): bool\n    {\n        return !isset($this->lazyObjectState) || isset($this->lazyObjectState->realInstance) || Registry::$noInitializerState === $this->lazyObjectState->initializer;\n    }\n\n    /**\n     * Forces initialization of a lazy object and returns it.\n     */\n    public function initializeLazyObject(): parent\n    {\n        if ($state = $this->lazyObjectState ?? null) {\n            return $state->realInstance ??= ($state->initializer)();\n        }\n\n        return $this;\n    }\n\n    /**\n     * @return bool Returns false when the object cannot be reset, ie when it's not a lazy object\n     */\n    public function resetLazyObject(): bool\n    {\n        if (!isset($this->lazyObjectState) || Registry::$noInitializerState === $this->lazyObjectState->initializer) {\n            return false;\n        }\n\n        unset($this->lazyObjectState->realInstance);\n\n        return true;\n    }\n\n    public function &__get($name): mixed\n    {\n        $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);\n        $scope = null;\n        $instance = $this;\n\n        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {\n            $scope = Registry::getScope($propertyScopes, $class, $name);\n\n            if (null === $scope || isset($propertyScopes[\"\\0$scope\\0$name\"])) {\n                if ($state = $this->lazyObjectState ?? null) {\n                    $instance = $state->realInstance ??= ($state->initializer)();\n                }\n                $parent = 2;\n                goto get_in_scope;\n            }\n        }\n        $parent = (Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['get'];\n\n        if ($state = $this->lazyObjectState ?? null) {\n            $instance = $state->realInstance ??= ($state->initializer)();\n        } else {\n            if (2 === $parent) {\n                return parent::__get($name);\n            }\n            $value = parent::__get($name);\n\n            return $value;\n        }\n\n        if (!$parent && null === $class && !\\array_key_exists($name, (array) $instance)) {\n            $frame = debug_backtrace(\\DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];\n            trigger_error(\\sprintf('Undefined property: %s::$%s in %s on line %s', $instance::class, $name, $frame['file'], $frame['line']), \\E_USER_NOTICE);\n        }\n\n        get_in_scope:\n\n        try {\n            if (null === $scope) {\n                if (null === $readonlyScope && 1 !== $parent) {\n                    return $instance->$name;\n                }\n                $value = $instance->$name;\n\n                return $value;\n            }\n            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);\n\n            return $accessor['get']($instance, $name, null !== $readonlyScope || 1 === $parent);\n        } catch (\\Error $e) {\n            if (\\Error::class !== $e::class || !str_starts_with($e->getMessage(), 'Cannot access uninitialized non-nullable property')) {\n                throw $e;\n            }\n\n            try {\n                if (null === $scope) {\n                    $instance->$name = [];\n\n                    return $instance->$name;\n                }\n\n                $accessor['set']($instance, $name, []);\n\n                return $accessor['get']($instance, $name, null !== $readonlyScope || 1 === $parent);\n            } catch (\\Error) {\n                throw $e;\n            }\n        }\n    }\n\n    public function __set($name, $value): void\n    {\n        $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);\n        $scope = null;\n        $instance = $this;\n\n        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {\n            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);\n\n            if ($readonlyScope === $scope || isset($propertyScopes[\"\\0$scope\\0$name\"])) {\n                if ($state = $this->lazyObjectState ?? null) {\n                    $instance = $state->realInstance ??= ($state->initializer)();\n                }\n                goto set_in_scope;\n            }\n        }\n\n        if ($state = $this->lazyObjectState ?? null) {\n            $instance = $state->realInstance ??= ($state->initializer)();\n        } elseif ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['set']) {\n            parent::__set($name, $value);\n\n            return;\n        }\n\n        set_in_scope:\n\n        if (null === $scope) {\n            $instance->$name = $value;\n        } else {\n            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);\n            $accessor['set']($instance, $name, $value);\n        }\n    }\n\n    public function __isset($name): bool\n    {\n        $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);\n        $scope = null;\n        $instance = $this;\n\n        if ([$class] = $propertyScopes[$name] ?? null) {\n            $scope = Registry::getScope($propertyScopes, $class, $name);\n\n            if (null === $scope || isset($propertyScopes[\"\\0$scope\\0$name\"])) {\n                if ($state = $this->lazyObjectState ?? null) {\n                    $instance = $state->realInstance ??= ($state->initializer)();\n                }\n                goto isset_in_scope;\n            }\n        }\n\n        if ($state = $this->lazyObjectState ?? null) {\n            $instance = $state->realInstance ??= ($state->initializer)();\n        } elseif ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['isset']) {\n            return parent::__isset($name);\n        }\n\n        isset_in_scope:\n\n        if (null === $scope) {\n            return isset($instance->$name);\n        }\n        $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);\n\n        return $accessor['isset']($instance, $name);\n    }\n\n    public function __unset($name): void\n    {\n        $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);\n        $scope = null;\n        $instance = $this;\n\n        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {\n            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);\n\n            if ($readonlyScope === $scope || isset($propertyScopes[\"\\0$scope\\0$name\"])) {\n                if ($state = $this->lazyObjectState ?? null) {\n                    $instance = $state->realInstance ??= ($state->initializer)();\n                }\n                goto unset_in_scope;\n            }\n        }\n\n        if ($state = $this->lazyObjectState ?? null) {\n            $instance = $state->realInstance ??= ($state->initializer)();\n        } elseif ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['unset']) {\n            parent::__unset($name);\n\n            return;\n        }\n\n        unset_in_scope:\n\n        if (null === $scope) {\n            unset($instance->$name);\n        } else {\n            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);\n            $accessor['unset']($instance, $name);\n        }\n    }\n\n    public function __clone(): void\n    {\n        if (!isset($this->lazyObjectState)) {\n            if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['clone']) {\n                parent::__clone();\n            }\n\n            return;\n        }\n\n        $this->lazyObjectState = clone $this->lazyObjectState;\n\n        if (isset($this->lazyObjectState->realInstance)) {\n            $this->lazyObjectState->realInstance = clone $this->lazyObjectState->realInstance;\n        }\n    }\n\n    public function __serialize(): array\n    {\n        $class = self::class;\n        $state = $this->lazyObjectState ?? null;\n\n        if (!$state && (Registry::$parentMethods[$class] ??= Registry::getParentMethods($class))['serialize']) {\n            $properties = parent::__serialize();\n        } else {\n            $properties = (array) $this;\n\n            if ($state) {\n                unset($properties[\"\\0$class\\0lazyObjectState\"]);\n                $properties[\"\\0$class\\0lazyObjectReal\"] = $state->realInstance ??= ($state->initializer)();\n            }\n        }\n\n        if ($state || Registry::$parentMethods[$class]['serialize'] || !Registry::$parentMethods[$class]['sleep']) {\n            return $properties;\n        }\n\n        $scope = get_parent_class($class);\n        $data = [];\n\n        foreach (parent::__sleep() as $name) {\n            $value = $properties[$k = $name] ?? $properties[$k = \"\\0*\\0$name\"] ?? $properties[$k = \"\\0$class\\0$name\"] ?? $properties[$k = \"\\0$scope\\0$name\"] ?? $k = null;\n\n            if (null === $k) {\n                trigger_error(\\sprintf('serialize(): \"%s\" returned as member variable from __sleep() but does not exist', $name), \\E_USER_NOTICE);\n            } else {\n                $data[$k] = $value;\n            }\n        }\n\n        return $data;\n    }\n\n    public function __unserialize(array $data): void\n    {\n        $class = self::class;\n\n        if ($instance = $data[\"\\0$class\\0lazyObjectReal\"] ?? null) {\n            unset($data[\"\\0$class\\0lazyObjectReal\"]);\n\n            foreach (Registry::$classResetters[$class] ??= Registry::getClassResetters($class) as $reset) {\n                $reset($this, $data);\n            }\n\n            if ($data) {\n                PublicHydrator::hydrate($this, $data);\n            }\n            $this->lazyObjectState = new LazyObjectState(Registry::$noInitializerState ??= static fn () => throw new \\LogicException('Lazy proxy has no initializer.'));\n            $this->lazyObjectState->realInstance = $instance;\n        } elseif ((Registry::$parentMethods[$class] ??= Registry::getParentMethods($class))['unserialize']) {\n            parent::__unserialize($data);\n        } else {\n            PublicHydrator::hydrate($this, $data);\n\n            if (Registry::$parentMethods[$class]['wakeup']) {\n                parent::__wakeup();\n            }\n        }\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->lazyObjectState)) {\n            return;\n        }\n\n        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['destruct']) {\n            parent::__destruct();\n        }\n    }\n}\n"
        },
        {
          "name": "ProxyHelper.php",
          "type": "blob",
          "size": 18.0126953125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarExporter;\n\nuse Symfony\\Component\\VarExporter\\Exception\\LogicException;\nuse Symfony\\Component\\VarExporter\\Internal\\Hydrator;\nuse Symfony\\Component\\VarExporter\\Internal\\LazyObjectRegistry;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class ProxyHelper\n{\n    /**\n     * Helps generate lazy-loading ghost objects.\n     *\n     * @throws LogicException When the class is incompatible with ghost objects\n     */\n    public static function generateLazyGhost(\\ReflectionClass $class): string\n    {\n        if (\\PHP_VERSION_ID < 80300 && $class->isReadOnly()) {\n            throw new LogicException(\\sprintf('Cannot generate lazy ghost with PHP < 8.3: class \"%s\" is readonly.', $class->name));\n        }\n        if ($class->isFinal()) {\n            throw new LogicException(\\sprintf('Cannot generate lazy ghost: class \"%s\" is final.', $class->name));\n        }\n        if ($class->isInterface() || $class->isAbstract()) {\n            throw new LogicException(\\sprintf('Cannot generate lazy ghost: \"%s\" is not a concrete class.', $class->name));\n        }\n        if (\\stdClass::class !== $class->name && $class->isInternal()) {\n            throw new LogicException(\\sprintf('Cannot generate lazy ghost: class \"%s\" is internal.', $class->name));\n        }\n        if ($class->hasMethod('__get') && 'mixed' !== (self::exportType($class->getMethod('__get')) ?? 'mixed')) {\n            throw new LogicException(\\sprintf('Cannot generate lazy ghost: return type of method \"%s::__get()\" should be \"mixed\".', $class->name));\n        }\n\n        static $traitMethods;\n        $traitMethods ??= (new \\ReflectionClass(LazyGhostTrait::class))->getMethods();\n\n        foreach ($traitMethods as $method) {\n            if ($class->hasMethod($method->name) && $class->getMethod($method->name)->isFinal()) {\n                throw new LogicException(\\sprintf('Cannot generate lazy ghost: method \"%s::%s()\" is final.', $class->name, $method->name));\n            }\n        }\n\n        $parent = $class;\n        while ($parent = $parent->getParentClass()) {\n            if (\\stdClass::class !== $parent->name && $parent->isInternal()) {\n                throw new LogicException(\\sprintf('Cannot generate lazy ghost: class \"%s\" extends \"%s\" which is internal.', $class->name, $parent->name));\n            }\n        }\n        $propertyScopes = self::exportPropertyScopes($class->name);\n\n        return <<<EOPHP\n             extends \\\\{$class->name} implements \\Symfony\\Component\\VarExporter\\LazyObjectInterface\n            {\n                use \\Symfony\\Component\\VarExporter\\LazyGhostTrait;\n\n                private const LAZY_OBJECT_PROPERTY_SCOPES = {$propertyScopes};\n            }\n\n            // Help opcache.preload discover always-needed symbols\n            class_exists(\\Symfony\\Component\\VarExporter\\Internal\\Hydrator::class);\n            class_exists(\\Symfony\\Component\\VarExporter\\Internal\\LazyObjectRegistry::class);\n            class_exists(\\Symfony\\Component\\VarExporter\\Internal\\LazyObjectState::class);\n\n            EOPHP;\n    }\n\n    /**\n     * Helps generate lazy-loading virtual proxies.\n     *\n     * @param \\ReflectionClass[] $interfaces\n     *\n     * @throws LogicException When the class is incompatible with virtual proxies\n     */\n    public static function generateLazyProxy(?\\ReflectionClass $class, array $interfaces = []): string\n    {\n        if (!class_exists($class?->name ?? \\stdClass::class, false)) {\n            throw new LogicException(\\sprintf('Cannot generate lazy proxy: \"%s\" is not a class.', $class->name));\n        }\n        if ($class?->isFinal()) {\n            throw new LogicException(\\sprintf('Cannot generate lazy proxy: class \"%s\" is final.', $class->name));\n        }\n        if (\\PHP_VERSION_ID < 80300 && $class?->isReadOnly()) {\n            throw new LogicException(\\sprintf('Cannot generate lazy proxy with PHP < 8.3: class \"%s\" is readonly.', $class->name));\n        }\n\n        $methodReflectors = [$class?->getMethods(\\ReflectionMethod::IS_PUBLIC | \\ReflectionMethod::IS_PROTECTED) ?? []];\n        foreach ($interfaces as $interface) {\n            if (!$interface->isInterface()) {\n                throw new LogicException(\\sprintf('Cannot generate lazy proxy: \"%s\" is not an interface.', $interface->name));\n            }\n            $methodReflectors[] = $interface->getMethods();\n        }\n        $methodReflectors = array_merge(...$methodReflectors);\n\n        $extendsInternalClass = false;\n        if ($parent = $class) {\n            do {\n                $extendsInternalClass = \\stdClass::class !== $parent->name && $parent->isInternal();\n            } while (!$extendsInternalClass && $parent = $parent->getParentClass());\n        }\n        $methodsHaveToBeProxied = $extendsInternalClass;\n        $methods = [];\n\n        foreach ($methodReflectors as $method) {\n            if ('__get' !== strtolower($method->name) || 'mixed' === ($type = self::exportType($method) ?? 'mixed')) {\n                continue;\n            }\n            $methodsHaveToBeProxied = true;\n            $trait = new \\ReflectionMethod(LazyProxyTrait::class, '__get');\n            $body = \\array_slice(file($trait->getFileName()), $trait->getStartLine() - 1, $trait->getEndLine() - $trait->getStartLine());\n            $body[0] = str_replace('): mixed', '): '.$type, $body[0]);\n            $methods['__get'] = strtr(implode('', $body).'    }', [\n                'Hydrator' => '\\\\'.Hydrator::class,\n                'Registry' => '\\\\'.LazyObjectRegistry::class,\n            ]);\n            break;\n        }\n\n        foreach ($methodReflectors as $method) {\n            if (($method->isStatic() && !$method->isAbstract()) || isset($methods[$lcName = strtolower($method->name)])) {\n                continue;\n            }\n            if ($method->isFinal()) {\n                if ($extendsInternalClass || $methodsHaveToBeProxied || method_exists(LazyProxyTrait::class, $method->name)) {\n                    throw new LogicException(\\sprintf('Cannot generate lazy proxy: method \"%s::%s()\" is final.', $class->name, $method->name));\n                }\n                continue;\n            }\n            if (method_exists(LazyProxyTrait::class, $method->name) || ($method->isProtected() && !$method->isAbstract())) {\n                continue;\n            }\n\n            $signature = self::exportSignature($method, true, $args);\n            $parentCall = $method->isAbstract() ? \"throw new \\BadMethodCallException('Cannot forward abstract method \\\"{$method->class}::{$method->name}()\\\".')\" : \"parent::{$method->name}({$args})\";\n\n            if ($method->isStatic()) {\n                $body = \"        $parentCall;\";\n            } elseif (str_ends_with($signature, '): never') || str_ends_with($signature, '): void')) {\n                $body = <<<EOPHP\n                        if (isset(\\$this->lazyObjectState)) {\n                            (\\$this->lazyObjectState->realInstance ??= (\\$this->lazyObjectState->initializer)())->{$method->name}({$args});\n                        } else {\n                            {$parentCall};\n                        }\n                EOPHP;\n            } else {\n                if (!$methodsHaveToBeProxied && !$method->isAbstract()) {\n                    // Skip proxying methods that might return $this\n                    foreach (preg_split('/[()|&]++/', self::exportType($method) ?? 'static') as $type) {\n                        if (\\in_array($type = ltrim($type, '?'), ['static', 'object'], true)) {\n                            continue 2;\n                        }\n                        foreach ([$class, ...$interfaces] as $r) {\n                            if ($r && is_a($r->name, $type, true)) {\n                                continue 3;\n                            }\n                        }\n                    }\n                }\n\n                $body = <<<EOPHP\n                        if (isset(\\$this->lazyObjectState)) {\n                            return (\\$this->lazyObjectState->realInstance ??= (\\$this->lazyObjectState->initializer)())->{$method->name}({$args});\n                        }\n\n                        return {$parentCall};\n                EOPHP;\n            }\n            $methods[$lcName] = \"    {$signature}\\n    {\\n{$body}\\n    }\";\n        }\n\n        $types = $interfaces = array_unique(array_column($interfaces, 'name'));\n        $interfaces[] = LazyObjectInterface::class;\n        $interfaces = implode(', \\\\', $interfaces);\n        $parent = $class ? ' extends \\\\'.$class->name : '';\n        array_unshift($types, $class ? 'parent' : '');\n        $type = ltrim(implode('&\\\\', $types), '&');\n\n        if (!$class) {\n            $trait = new \\ReflectionMethod(LazyProxyTrait::class, 'initializeLazyObject');\n            $body = \\array_slice(file($trait->getFileName()), $trait->getStartLine() - 1, $trait->getEndLine() - $trait->getStartLine());\n            $body[0] = str_replace('): parent', '): '.$type, $body[0]);\n            $methods = ['initializeLazyObject' => implode('', $body).'    }'] + $methods;\n        }\n        $body = $methods ? \"\\n\".implode(\"\\n\\n\", $methods).\"\\n\" : '';\n        $propertyScopes = $class ? self::exportPropertyScopes($class->name) : '[]';\n\n        if (\n            $class?->hasMethod('__unserialize')\n            && !$class->getMethod('__unserialize')->getParameters()[0]->getType()\n        ) {\n            // fix contravariance type problem when $class declares a `__unserialize()` method without typehint.\n            $lazyProxyTraitStatement = <<<EOPHP\n            use \\Symfony\\Component\\VarExporter\\LazyProxyTrait {\n                    __unserialize as private __doUnserialize;\n                }\n            EOPHP;\n\n            $body .= <<<EOPHP\n\n                    public function __unserialize(\\$data): void\n                    {\n                        \\$this->__doUnserialize(\\$data);\n                    }\n\n                EOPHP;\n        } else {\n            $lazyProxyTraitStatement = <<<EOPHP\n            use \\Symfony\\Component\\VarExporter\\LazyProxyTrait;\n            EOPHP;\n        }\n\n        return <<<EOPHP\n            {$parent} implements \\\\{$interfaces}\n            {\n                {$lazyProxyTraitStatement}\n\n                private const LAZY_OBJECT_PROPERTY_SCOPES = {$propertyScopes};\n            {$body}}\n\n            // Help opcache.preload discover always-needed symbols\n            class_exists(\\Symfony\\Component\\VarExporter\\Internal\\Hydrator::class);\n            class_exists(\\Symfony\\Component\\VarExporter\\Internal\\LazyObjectRegistry::class);\n            class_exists(\\Symfony\\Component\\VarExporter\\Internal\\LazyObjectState::class);\n\n            EOPHP;\n    }\n\n    public static function exportSignature(\\ReflectionFunctionAbstract $function, bool $withParameterTypes = true, ?string &$args = null): string\n    {\n        $byRefIndex = 0;\n        $args = '';\n        $param = null;\n        $parameters = [];\n        $namespace = $function instanceof \\ReflectionMethod ? $function->class : $function->getNamespaceName().'\\\\';\n        $namespace = substr($namespace, 0, strrpos($namespace, '\\\\') ?: 0);\n        foreach ($function->getParameters() as $param) {\n            $parameters[] = ($param->getAttributes(\\SensitiveParameter::class) ? '#[\\SensitiveParameter] ' : '')\n                .($withParameterTypes && $param->hasType() ? self::exportType($param).' ' : '')\n                .($param->isPassedByReference() ? '&' : '')\n                .($param->isVariadic() ? '...' : '').'$'.$param->name\n                .($param->isOptional() && !$param->isVariadic() ? ' = '.self::exportDefault($param, $namespace) : '');\n            if ($param->isPassedByReference()) {\n                $byRefIndex = 1 + $param->getPosition();\n            }\n            $args .= ($param->isVariadic() ? '...$' : '$').$param->name.', ';\n        }\n\n        if (!$param || !$byRefIndex) {\n            $args = '...\\func_get_args()';\n        } elseif ($param->isVariadic()) {\n            $args = substr($args, 0, -2);\n        } else {\n            $args = explode(', ', $args, 1 + $byRefIndex);\n            $args[$byRefIndex] = \\sprintf('...\\array_slice(\\func_get_args(), %d)', $byRefIndex);\n            $args = implode(', ', $args);\n        }\n\n        $signature = 'function '.($function->returnsReference() ? '&' : '')\n            .($function->isClosure() ? '' : $function->name).'('.implode(', ', $parameters).')';\n\n        if ($function instanceof \\ReflectionMethod) {\n            $signature = ($function->isPublic() ? 'public ' : ($function->isProtected() ? 'protected ' : 'private '))\n                .($function->isStatic() ? 'static ' : '').$signature;\n        }\n        if ($function->hasReturnType()) {\n            $signature .= ': '.self::exportType($function);\n        }\n\n        static $getPrototype;\n        $getPrototype ??= (new \\ReflectionMethod(\\ReflectionMethod::class, 'getPrototype'))->invoke(...);\n\n        while ($function) {\n            if ($function->hasTentativeReturnType()) {\n                return '#[\\ReturnTypeWillChange] '.$signature;\n            }\n\n            try {\n                $function = $function instanceof \\ReflectionMethod && $function->isAbstract() ? false : $getPrototype($function);\n            } catch (\\ReflectionException) {\n                break;\n            }\n        }\n\n        return $signature;\n    }\n\n    public static function exportType(\\ReflectionFunctionAbstract|\\ReflectionProperty|\\ReflectionParameter $owner, bool $noBuiltin = false, ?\\ReflectionType $type = null): ?string\n    {\n        if (!$type ??= $owner instanceof \\ReflectionFunctionAbstract ? $owner->getReturnType() : $owner->getType()) {\n            return null;\n        }\n        $class = null;\n        $types = [];\n        if ($type instanceof \\ReflectionUnionType) {\n            $reflectionTypes = $type->getTypes();\n            $glue = '|';\n        } elseif ($type instanceof \\ReflectionIntersectionType) {\n            $reflectionTypes = $type->getTypes();\n            $glue = '&';\n        } else {\n            $reflectionTypes = [$type];\n            $glue = null;\n        }\n\n        foreach ($reflectionTypes as $type) {\n            if ($type instanceof \\ReflectionIntersectionType) {\n                if ('' !== $name = '('.self::exportType($owner, $noBuiltin, $type).')') {\n                    $types[] = $name;\n                }\n                continue;\n            }\n            $name = $type->getName();\n\n            if ($noBuiltin && $type->isBuiltin()) {\n                continue;\n            }\n            if (\\in_array($name, ['parent', 'self'], true) && $class ??= $owner->getDeclaringClass()) {\n                $name = 'parent' === $name ? ($class->getParentClass() ?: null)?->name ?? 'parent' : $class->name;\n            }\n\n            $types[] = ($noBuiltin || $type->isBuiltin() || 'static' === $name ? '' : '\\\\').$name;\n        }\n\n        if (!$types) {\n            return '';\n        }\n        if (null === $glue) {\n            return (!$noBuiltin && $type->allowsNull() && !\\in_array($name, ['mixed', 'null'], true) ? '?' : '').$types[0];\n        }\n        sort($types);\n\n        return implode($glue, $types);\n    }\n\n    private static function exportPropertyScopes(string $parent): string\n    {\n        $propertyScopes = Hydrator::$propertyScopes[$parent] ??= Hydrator::getPropertyScopes($parent);\n        uksort($propertyScopes, 'strnatcmp');\n        foreach ($propertyScopes as $k => $v) {\n            unset($propertyScopes[$k][3]);\n        }\n        $propertyScopes = VarExporter::export($propertyScopes);\n        $propertyScopes = str_replace(VarExporter::export($parent), 'parent::class', $propertyScopes);\n        $propertyScopes = preg_replace(\"/(?|(,)\\n( )       |\\n        |,\\n    (\\]))/\", '$1$2', $propertyScopes);\n\n        return str_replace(\"\\n\", \"\\n    \", $propertyScopes);\n    }\n\n    private static function exportDefault(\\ReflectionParameter $param, $namespace): string\n    {\n        $default = rtrim(substr(explode('$'.$param->name.' = ', (string) $param, 2)[1] ?? '', 0, -2));\n\n        if (\\in_array($default, ['<default>', 'NULL'], true)) {\n            return 'null';\n        }\n        if (str_ends_with($default, \"...'\") && preg_match(\"/^'(?:[^'\\\\\\\\]*+(?:\\\\\\\\.)*+)*+'$/\", $default)) {\n            return VarExporter::export($param->getDefaultValue());\n        }\n\n        $regexp = \"/(\\\"(?:[^\\\"\\\\\\\\]*+(?:\\\\\\\\.)*+)*+\\\"|'(?:[^'\\\\\\\\]*+(?:\\\\\\\\.)*+)*+')/\";\n        $parts = preg_split($regexp, $default, -1, \\PREG_SPLIT_DELIM_CAPTURE | \\PREG_SPLIT_NO_EMPTY);\n\n        $regexp = '/([\\[\\( ]|^)([a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*+(?:\\\\\\\\[a-zA-Z0-9_\\x7f-\\xff]++)*+)(\\(?)(?!: )/';\n        $callback = (false !== strpbrk($default, \"\\\\:('\") && $class = $param->getDeclaringClass())\n            ? fn ($m) => $m[1].match ($m[2]) {\n                'new', 'false', 'true', 'null' => $m[2],\n                'NULL' => 'null',\n                'self' => '\\\\'.$class->name,\n                'namespace\\\\parent',\n                'parent' => ($parent = $class->getParentClass()) ? '\\\\'.$parent->name : 'parent',\n                default => self::exportSymbol($m[2], '(' !== $m[3], $namespace),\n            }.$m[3]\n            : fn ($m) => $m[1].match ($m[2]) {\n                'new', 'false', 'true', 'null', 'self', 'parent' => $m[2],\n                'NULL' => 'null',\n                default => self::exportSymbol($m[2], '(' !== $m[3], $namespace),\n            }.$m[3];\n\n        return implode('', array_map(fn ($part) => match ($part[0]) {\n            '\"' => $part, // for internal classes only\n            \"'\" => false !== strpbrk($part, \"\\\\\\0\\r\\n\") ? '\"'.substr(str_replace(['$', \"\\0\", \"\\r\", \"\\n\"], ['\\$', '\\0', '\\r', '\\n'], $part), 1, -1).'\"' : $part,\n            default => preg_replace_callback($regexp, $callback, $part),\n        }, $parts));\n    }\n\n    private static function exportSymbol(string $symbol, bool $mightBeRootConst, string $namespace): string\n    {\n        if (!$mightBeRootConst\n            || false === ($ns = strrpos($symbol, '\\\\'))\n            || substr($symbol, 0, $ns) !== $namespace\n            || \\defined($symbol)\n            || !\\defined(substr($symbol, $ns + 1))\n        ) {\n            return '\\\\'.$symbol;\n        }\n\n        return '\\\\'.substr($symbol, $ns + 1);\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.2939453125,
          "content": "VarExporter Component\n=====================\n\nThe VarExporter component provides various tools to deal with the internal state\nof objects:\n\n- `VarExporter::export()` allows exporting any serializable PHP data structure to\n  plain PHP code. While doing so, it preserves all the semantics associated with\n  the serialization mechanism of PHP (`__wakeup`, `__sleep`, `Serializable`,\n  `__serialize`, `__unserialize`);\n- `Instantiator::instantiate()` creates an object and sets its properties without\n  calling its constructor nor any other methods;\n- `Hydrator::hydrate()` can set the properties of an existing object;\n- `Lazy*Trait` can make a class behave as a lazy-loading ghost or virtual proxy.\n\nVarExporter::export()\n---------------------\n\nThe reason to use `VarExporter::export()` *vs* `serialize()` or\n[igbinary](https://github.com/igbinary/igbinary) is performance: thanks to\nOPcache, the resulting code is significantly faster and more memory efficient\nthan using `unserialize()` or `igbinary_unserialize()`.\n\nUnlike `var_export()`, this works on any serializable PHP value.\n\nIt also provides a few improvements over `var_export()`/`serialize()`:\n\n * the output is PSR-2 compatible;\n * the output can be re-indented without messing up with `\\r` or `\\n` in the data;\n * missing classes throw a `ClassNotFoundException` instead of being unserialized\n   to `PHP_Incomplete_Class` objects;\n * references involving `SplObjectStorage`, `ArrayObject` or `ArrayIterator`\n   instances are preserved;\n * `Reflection*`, `IteratorIterator` and `RecursiveIteratorIterator` classes\n   throw an exception when being serialized (their unserialized version is broken\n   anyway, see https://bugs.php.net/76737).\n\nInstantiator and Hydrator\n-------------------------\n\n`Instantiator::instantiate($class)` creates an object of the given class without\ncalling its constructor nor any other methods.\n\n`Hydrator::hydrate()` sets the properties of an existing object, including\nprivate and protected ones. For example:\n\n```php\n// Sets the public or protected $object->propertyName property\nHydrator::hydrate($object, ['propertyName' => $propertyValue]);\n\n// Sets a private property defined on its parent Bar class:\nHydrator::hydrate($object, [\"\\0Bar\\0privateBarProperty\" => $propertyValue]);\n\n// Alternative way to set the private $object->privateBarProperty property\nHydrator::hydrate($object, [], [\n    Bar::class => ['privateBarProperty' => $propertyValue],\n]);\n```\n\n`Lazy*Trait`\n------------\n\nThe component provides two lazy-loading patterns: ghost objects and virtual\nproxies (see https://martinfowler.com/eaaCatalog/lazyLoad.html for reference).\n\nGhost objects work only with concrete and non-internal classes. In the generic\ncase, they are not compatible with using factories in their initializer.\n\nVirtual proxies work with concrete, abstract or internal classes. They provide an\nAPI that looks like the actual objects and forward calls to them. They can cause\nidentity problems because proxies might not be seen as equivalents to the actual\nobjects they proxy.\n\nBecause of this identity problem, ghost objects should be preferred when\npossible. Exceptions thrown by the `ProxyHelper` class can help decide when it\ncan be used or not.\n\nGhost objects and virtual proxies both provide implementations for the\n`LazyObjectInterface` which allows resetting them to their initial state or to\nforcibly initialize them when needed. Note that resetting a ghost object skips\nits read-only properties. You should use a virtual proxy to reset read-only\nproperties.\n\n### `LazyGhostTrait`\n\nBy using `LazyGhostTrait` either directly in your classes or by using\n`ProxyHelper::generateLazyGhost()`, you can make their instances lazy-loadable.\nThis works by creating these instances empty and by computing their state only\nwhen accessing a property.\n\n```php\nclass FooLazyGhost extends Foo\n{\n    use LazyGhostTrait;\n}\n\n$foo = FooLazyGhost::createLazyGhost(initializer: function (Foo $instance): void {\n    // [...] Use whatever heavy logic you need here\n    // to compute the $dependencies of the $instance\n    $instance->__construct(...$dependencies);\n    // [...] Call setters, etc. if needed\n});\n\n// $foo is now a lazy-loading ghost object. The initializer will\n// be called only when and if a *property* is accessed.\n```\n\n### `LazyProxyTrait`\n\nAlternatively, `LazyProxyTrait` can be used to create virtual proxies:\n\n```php\n$proxyCode = ProxyHelper::generateLazyProxy(new ReflectionClass(Foo::class));\n// $proxyCode contains the reference to LazyProxyTrait\n// and should be dumped into a file in production envs\neval('class FooLazyProxy'.$proxyCode);\n\n$foo = FooLazyProxy::createLazyProxy(initializer: function (): Foo {\n    // [...] Use whatever heavy logic you need here\n    // to compute the $dependencies of the $instance\n    $instance = new Foo(...$dependencies);\n    // [...] Call setters, etc. if needed\n\n    return $instance;\n});\n// $foo is now a lazy-loading virtual proxy object. The initializer will\n// be called only when and if a *method* is called.\n```\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/var_exporter.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "VarExporter.php",
          "type": "blob",
          "size": 3.5546875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarExporter;\n\nuse Symfony\\Component\\VarExporter\\Exception\\ExceptionInterface;\nuse Symfony\\Component\\VarExporter\\Internal\\Exporter;\nuse Symfony\\Component\\VarExporter\\Internal\\Hydrator;\nuse Symfony\\Component\\VarExporter\\Internal\\Registry;\nuse Symfony\\Component\\VarExporter\\Internal\\Values;\n\n/**\n * Exports serializable PHP values to PHP code.\n *\n * VarExporter allows serializing PHP data structures to plain PHP code (like var_export())\n * while preserving all the semantics associated with serialize() (unlike var_export()).\n *\n * By leveraging OPcache, the generated PHP code is faster than doing the same with unserialize().\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class VarExporter\n{\n    /**\n     * Exports a serializable PHP value to PHP code.\n     *\n     * @param bool                              &$isStaticValue Set to true after execution if the provided value is static, false otherwise\n     * @param array<class-string, class-string> &$foundClasses  Classes found in the value are added to this list as both keys and values\n     *\n     * @throws ExceptionInterface When the provided value cannot be serialized\n     */\n    public static function export(mixed $value, ?bool &$isStaticValue = null, array &$foundClasses = []): string\n    {\n        $isStaticValue = true;\n\n        if (!\\is_object($value) && !(\\is_array($value) && $value) && !\\is_resource($value) || $value instanceof \\UnitEnum) {\n            return Exporter::export($value);\n        }\n\n        $objectsPool = new \\SplObjectStorage();\n        $refsPool = [];\n        $objectsCount = 0;\n\n        try {\n            $value = Exporter::prepare([$value], $objectsPool, $refsPool, $objectsCount, $isStaticValue)[0];\n        } finally {\n            $references = [];\n            foreach ($refsPool as $i => $v) {\n                if ($v[0]->count) {\n                    $references[1 + $i] = $v[2];\n                }\n                $v[0] = $v[1];\n            }\n        }\n\n        if ($isStaticValue) {\n            return Exporter::export($value);\n        }\n\n        $classes = [];\n        $values = [];\n        $states = [];\n        foreach ($objectsPool as $i => $v) {\n            [, $class, $values[], $wakeup] = $objectsPool[$v];\n            $foundClasses[$class] = $classes[] = $class;\n\n            if (0 < $wakeup) {\n                $states[$wakeup] = $i;\n            } elseif (0 > $wakeup) {\n                $states[-$wakeup] = [$i, array_pop($values)];\n                $values[] = [];\n            }\n        }\n        ksort($states);\n\n        $wakeups = [null];\n        foreach ($states as $v) {\n            if (\\is_array($v)) {\n                $wakeups[-$v[0]] = $v[1];\n            } else {\n                $wakeups[] = $v;\n            }\n        }\n\n        if (null === $wakeups[0]) {\n            unset($wakeups[0]);\n        }\n\n        $properties = [];\n        foreach ($values as $i => $vars) {\n            foreach ($vars as $class => $values) {\n                foreach ($values as $name => $v) {\n                    $properties[$class][$name][$i] = $v;\n                }\n            }\n        }\n\n        if ($classes || $references) {\n            $value = new Hydrator(new Registry($classes), $references ? new Values($references) : null, $properties, $value, $wakeups);\n        } else {\n            $isStaticValue = true;\n        }\n\n        return Exporter::export($value);\n    }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.94140625,
          "content": "{\n    \"name\": \"symfony/var-exporter\",\n    \"type\": \"library\",\n    \"description\": \"Allows exporting any serializable PHP data structure to plain PHP code\",\n    \"keywords\": [\"export\", \"serialize\", \"instantiate\", \"hydrate\", \"construct\", \"clone\", \"lazy-loading\", \"proxy\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Nicolas Grekas\",\n            \"email\": \"p@tchwork.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\"\n    },\n    \"require-dev\": {\n        \"symfony/property-access\": \"^6.4|^7.0\",\n        \"symfony/serializer\": \"^6.4|^7.0\",\n        \"symfony/var-dumper\": \"^6.4|^7.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\VarExporter\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.8486328125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony VarExporter Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Resources</directory>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}