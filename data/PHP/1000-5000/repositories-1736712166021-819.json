{
  "metadata": {
    "timestamp": 1736712166021,
    "page": 819,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ccampbell/chromephp",
      "stars": 1376,
      "defaultBranch": "master",
      "files": [
        {
          "name": "ChromePhp.php",
          "type": "blob",
          "size": 10.2646484375,
          "content": "<?php\n/**\n * Copyright 2010-2013 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Server Side Chrome PHP debugger class\n *\n * @package ChromePhp\n * @author Craig Campbell <iamcraigcampbell@gmail.com>\n */\nclass ChromePhp\n{\n    /**\n     * @var string\n     */\n    const VERSION = '4.1.0';\n\n    /**\n     * @var string\n     */\n    const HEADER_NAME = 'X-ChromeLogger-Data';\n\n    /**\n     * @var string\n     */\n    const BACKTRACE_LEVEL = 'backtrace_level';\n\n    /**\n     * @var string\n     */\n    const LOG = 'log';\n\n    /**\n     * @var string\n     */\n    const WARN = 'warn';\n\n    /**\n     * @var string\n     */\n    const ERROR = 'error';\n\n    /**\n     * @var string\n     */\n    const GROUP = 'group';\n\n    /**\n     * @var string\n     */\n    const INFO = 'info';\n\n    /**\n     * @var string\n     */\n    const GROUP_END = 'groupEnd';\n\n    /**\n     * @var string\n     */\n    const GROUP_COLLAPSED = 'groupCollapsed';\n\n    /**\n     * @var string\n     */\n    const TABLE = 'table';\n\n    /**\n     * @var string\n     */\n    protected $_php_version;\n\n    /**\n     * @var int\n     */\n    protected $_timestamp;\n\n    /**\n     * @var array\n     */\n    protected $_json = array(\n        'version' => self::VERSION,\n        'columns' => array('log', 'backtrace', 'type'),\n        'rows' => array()\n    );\n\n    /**\n     * @var array\n     */\n    protected $_backtraces = array();\n\n    /**\n     * @var bool\n     */\n    protected $_error_triggered = false;\n\n    /**\n     * @var array\n     */\n    protected $_settings = array(\n        self::BACKTRACE_LEVEL => 1\n    );\n\n    /**\n     * @var ChromePhp\n     */\n    protected static $_instance;\n\n    /**\n     * Prevent recursion when working with objects referring to each other\n     *\n     * @var array\n     */\n    protected $_processed = array();\n\n    /**\n     * constructor\n     */\n    private function __construct()\n    {\n        $this->_php_version = phpversion();\n        $this->_timestamp = $this->_php_version >= 5.1 ? $_SERVER['REQUEST_TIME'] : time();\n        $this->_json['request_uri'] = $_SERVER['REQUEST_URI'];\n    }\n\n    /**\n     * gets instance of this class\n     *\n     * @return ChromePhp\n     */\n    public static function getInstance()\n    {\n        if (self::$_instance === null) {\n            self::$_instance = new self();\n        }\n        return self::$_instance;\n    }\n\n    /**\n     * logs a variable to the console\n     *\n     * @param mixed $data,... unlimited OPTIONAL number of additional logs [...]\n     * @return void\n     */\n    public static function log()\n    {\n        $args = func_get_args();\n        return self::_log('', $args);\n    }\n\n    /**\n     * logs a warning to the console\n     *\n     * @param mixed $data,... unlimited OPTIONAL number of additional logs [...]\n     * @return void\n     */\n    public static function warn()\n    {\n        $args = func_get_args();\n        return self::_log(self::WARN, $args);\n    }\n\n    /**\n     * logs an error to the console\n     *\n     * @param mixed $data,... unlimited OPTIONAL number of additional logs [...]\n     * @return void\n     */\n    public static function error()\n    {\n        $args = func_get_args();\n        return self::_log(self::ERROR, $args);\n    }\n\n    /**\n     * sends a group log\n     *\n     * @param string value\n     */\n    public static function group()\n    {\n        $args = func_get_args();\n        return self::_log(self::GROUP, $args);\n    }\n\n    /**\n     * sends an info log\n     *\n     * @param mixed $data,... unlimited OPTIONAL number of additional logs [...]\n     * @return void\n     */\n    public static function info()\n    {\n        $args = func_get_args();\n        return self::_log(self::INFO, $args);\n    }\n\n    /**\n     * sends a collapsed group log\n     *\n     * @param string value\n     */\n    public static function groupCollapsed()\n    {\n        $args = func_get_args();\n        return self::_log(self::GROUP_COLLAPSED, $args);\n    }\n\n    /**\n     * ends a group log\n     *\n     * @param string value\n     */\n    public static function groupEnd()\n    {\n        $args = func_get_args();\n        return self::_log(self::GROUP_END, $args);\n    }\n\n    /**\n     * sends a table log\n     *\n     * @param string value\n     */\n    public static function table()\n    {\n        $args = func_get_args();\n        return self::_log(self::TABLE, $args);\n    }\n\n    /**\n     * internal logging call\n     *\n     * @param string $type\n     * @return void\n     */\n    protected static function _log($type, array $args)\n    {\n        // nothing passed in, don't do anything\n        if (count($args) == 0 && $type != self::GROUP_END) {\n            return;\n        }\n\n        $logger = self::getInstance();\n\n        $logger->_processed = array();\n\n        $logs = array();\n        foreach ($args as $arg) {\n            $logs[] = $logger->_convert($arg);\n        }\n\n        $backtrace = debug_backtrace(false);\n        $level = $logger->getSetting(self::BACKTRACE_LEVEL);\n\n        $backtrace_message = 'unknown';\n        if (isset($backtrace[$level]['file']) && isset($backtrace[$level]['line'])) {\n            $backtrace_message = $backtrace[$level]['file'] . ' : ' . $backtrace[$level]['line'];\n        }\n\n        $logger->_addRow($logs, $backtrace_message, $type);\n    }\n\n    /**\n     * converts an object to a better format for logging\n     *\n     * @param Object\n     * @return array\n     */\n    protected function _convert($object)\n    {\n        // if this isn't an object then just return it\n        if (!is_object($object)) {\n            return $object;\n        }\n\n        //Mark this object as processed so we don't convert it twice and it\n        //Also avoid recursion when objects refer to each other\n        $this->_processed[] = $object;\n\n        $object_as_array = array();\n\n        // first add the class name\n        $object_as_array['___class_name'] = get_class($object);\n\n        // loop through object vars\n        $object_vars = get_object_vars($object);\n        foreach ($object_vars as $key => $value) {\n\n            // same instance as parent object\n            if ($value === $object || in_array($value, $this->_processed, true)) {\n                $value = 'recursion - parent object [' . get_class($value) . ']';\n            }\n            $object_as_array[$key] = $this->_convert($value);\n        }\n\n        $reflection = new ReflectionClass($object);\n\n        // loop through the properties and add those\n        foreach ($reflection->getProperties() as $property) {\n\n            // if one of these properties was already added above then ignore it\n            if (array_key_exists($property->getName(), $object_vars)) {\n                continue;\n            }\n            $type = $this->_getPropertyKey($property);\n\n            if ($this->_php_version >= 5.3) {\n                $property->setAccessible(true);\n            }\n\n            try {\n                $value = $property->getValue($object);\n            } catch (ReflectionException $e) {\n                $value = 'only PHP 5.3 can access private/protected properties';\n            }\n\n            // same instance as parent object\n            if ($value === $object || in_array($value, $this->_processed, true)) {\n                $value = 'recursion - parent object [' . get_class($value) . ']';\n            }\n\n            $object_as_array[$type] = $this->_convert($value);\n        }\n        return $object_as_array;\n    }\n\n    /**\n     * takes a reflection property and returns a nicely formatted key of the property name\n     *\n     * @param ReflectionProperty\n     * @return string\n     */\n    protected function _getPropertyKey(ReflectionProperty $property)\n    {\n        $static = $property->isStatic() ? ' static' : '';\n        if ($property->isPublic()) {\n            return 'public' . $static . ' ' . $property->getName();\n        }\n\n        if ($property->isProtected()) {\n            return 'protected' . $static . ' ' . $property->getName();\n        }\n\n        if ($property->isPrivate()) {\n            return 'private' . $static . ' ' . $property->getName();\n        }\n    }\n\n    /**\n     * adds a value to the data array\n     *\n     * @var mixed\n     * @return void\n     */\n    protected function _addRow(array $logs, $backtrace, $type)\n    {\n        // if this is logged on the same line for example in a loop, set it to null to save space\n        if (in_array($backtrace, $this->_backtraces)) {\n            $backtrace = null;\n        }\n\n        // for group, groupEnd, and groupCollapsed\n        // take out the backtrace since it is not useful\n        if ($type == self::GROUP || $type == self::GROUP_END || $type == self::GROUP_COLLAPSED) {\n            $backtrace = null;\n        }\n\n        if ($backtrace !== null) {\n            $this->_backtraces[] = $backtrace;\n        }\n\n        $row = array($logs, $backtrace, $type);\n\n        $this->_json['rows'][] = $row;\n        $this->_writeHeader($this->_json);\n    }\n\n    protected function _writeHeader($data)\n    {\n        header(self::HEADER_NAME . ': ' . $this->_encode($data));\n    }\n\n    /**\n     * encodes the data to be sent along with the request\n     *\n     * @param array $data\n     * @return string\n     */\n    protected function _encode($data)\n    {\n        return base64_encode(utf8_encode(json_encode($data)));\n    }\n\n    /**\n     * adds a setting\n     *\n     * @param string key\n     * @param mixed value\n     * @return void\n     */\n    public function addSetting($key, $value)\n    {\n        $this->_settings[$key] = $value;\n    }\n\n    /**\n     * add ability to set multiple settings in one call\n     *\n     * @param array $settings\n     * @return void\n     */\n    public function addSettings(array $settings)\n    {\n        foreach ($settings as $key => $value) {\n            $this->addSetting($key, $value);\n        }\n    }\n\n    /**\n     * gets a setting\n     *\n     * @param string key\n     * @return mixed\n     */\n    public function getSetting($key)\n    {\n        if (!isset($this->_settings[$key])) {\n            return null;\n        }\n        return $this->_settings[$key];\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.6865234375,
          "content": "## Overview\nChromePhp is a PHP library for the Chrome Logger Google Chrome extension.\n\nThis library allows you to log variables to the Chrome console.\n\n## Requirements\n- PHP 5 or later\n\n## Installation\n1. Install the Chrome extension from: https://chrome.google.com/extensions/detail/noaneddfkdjfnfdakjjmocngnfkfehhd\n2. Click the extension icon in the browser to enable it for the current tab's domain\n3. Put ChromePhp.php somewhere in your PHP include path\n4. Log some data\n\n    ```php\n    include 'ChromePhp.php';\n    ChromePhp::log('Hello console!');\n    ChromePhp::log($_SERVER);\n    ChromePhp::warn('something went wrong!');\n    ```\n\nMore information can be found here:\nhttp://www.chromelogger.com\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.609375,
          "content": "{\n    \"name\": \"ccampbell/chromephp\",\n    \"type\": \"library\",\n    \"description\": \"Log variables to the Chrome console (via Chrome Logger Google Chrome extension).\",\n    \"keywords\": [\"log\",\"logging\"],\n    \"homepage\": \"http://github.com/ccampbell/chromephp\",\n    \"license\": \"Apache-2.0\",\n    \"authors\": [\n        {\n            \"name\": \"Craig Campbell\",\n            \"email\": \"iamcraigcampbell@gmail.com\",\n            \"homepage\": \"http://craig.is\",\n            \"role\": \"Developer\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=5.0.0\"\n    },\n    \"autoload\": {\n        \"psr-0\": {\n            \"ChromePhp\": \"\"\n        }\n    }\n}\n"
        }
      ]
    }
  ]
}