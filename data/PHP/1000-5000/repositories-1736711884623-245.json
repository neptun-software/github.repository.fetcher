{
  "metadata": {
    "timestamp": 1736711884623,
    "page": 245,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/stopwatch",
      "stars": 2805,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.7138671875,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Add method `getLastPeriod()` to `StopwatchEvent`\n * Add `getRootSectionEvents()` method and `ROOT` constant to `Stopwatch`\n\n5.2\n---\n\n * Add `name` argument to the `StopWatchEvent` constructor, accessible via a new `StopwatchEvent::getName()`\n\n5.0.0\n-----\n\n * Removed support for passing `null` as 1st (`$id`) argument of `Section::get()` method, pass a valid child section identifier instead.\n\n4.4.0\n-----\n\n * Deprecated passing `null` as 1st (`$id`) argument of `Section::get()` method, pass a valid child section identifier instead.\n\n3.4.0\n-----\n\n * added the `Stopwatch::reset()` method\n * allowed to measure sub-millisecond times by introducing an argument to the\n   constructor of `Stopwatch`\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.9052734375,
          "content": "Stopwatch Component\n===================\n\nThe Stopwatch component provides a way to profile code.\n\nGetting Started\n---------------\n\n```bash\ncomposer require symfony/stopwatch\n```\n\n```php\nuse Symfony\\Component\\Stopwatch\\Stopwatch;\n\n$stopwatch = new Stopwatch();\n\n// optionally group events into sections (e.g. phases of the execution)\n$stopwatch->openSection();\n\n// starts event named 'eventName'\n$stopwatch->start('eventName');\n\n// ... run your code here\n\n// optionally, start a new \"lap\" time\n$stopwatch->lap('foo');\n\n// ... run your code here\n\n$event = $stopwatch->stop('eventName');\n\n$stopwatch->stopSection('phase_1');\n```\n\nResources\n---------\n\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Section.php",
          "type": "blob",
          "size": 3.580078125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Stopwatch;\n\n/**\n * Stopwatch section.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Section\n{\n    /**\n     * @var StopwatchEvent[]\n     */\n    private array $events = [];\n\n    private ?string $id = null;\n\n    /**\n     * @var Section[]\n     */\n    private array $children = [];\n\n    /**\n     * @param float|null $origin        Set the origin of the events in this section, use null to set their origin to their start time\n     * @param bool       $morePrecision If true, time is stored as float to keep the original microsecond precision\n     */\n    public function __construct(\n        private ?float $origin = null,\n        private bool $morePrecision = false,\n    ) {\n    }\n\n    /**\n     * Returns the child section.\n     */\n    public function get(string $id): ?self\n    {\n        foreach ($this->children as $child) {\n            if ($id === $child->getId()) {\n                return $child;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Creates or re-opens a child section.\n     *\n     * @param string|null $id Null to create a new section, the identifier to re-open an existing one\n     */\n    public function open(?string $id): self\n    {\n        if (null === $id || null === $session = $this->get($id)) {\n            $session = $this->children[] = new self(microtime(true) * 1000, $this->morePrecision);\n        }\n\n        return $session;\n    }\n\n    public function getId(): ?string\n    {\n        return $this->id;\n    }\n\n    /**\n     * Sets the session identifier.\n     *\n     * @return $this\n     */\n    public function setId(string $id): static\n    {\n        $this->id = $id;\n\n        return $this;\n    }\n\n    /**\n     * Starts an event.\n     */\n    public function startEvent(string $name, ?string $category): StopwatchEvent\n    {\n        if (!isset($this->events[$name])) {\n            $this->events[$name] = new StopwatchEvent($this->origin ?: microtime(true) * 1000, $category, $this->morePrecision, $name);\n        }\n\n        return $this->events[$name]->start();\n    }\n\n    /**\n     * Checks if the event was started.\n     */\n    public function isEventStarted(string $name): bool\n    {\n        return isset($this->events[$name]) && $this->events[$name]->isStarted();\n    }\n\n    /**\n     * Stops an event.\n     *\n     * @throws \\LogicException When the event has not been started\n     */\n    public function stopEvent(string $name): StopwatchEvent\n    {\n        if (!isset($this->events[$name])) {\n            throw new \\LogicException(\\sprintf('Event \"%s\" is not started.', $name));\n        }\n\n        return $this->events[$name]->stop();\n    }\n\n    /**\n     * Stops then restarts an event.\n     *\n     * @throws \\LogicException When the event has not been started\n     */\n    public function lap(string $name): StopwatchEvent\n    {\n        return $this->stopEvent($name)->start();\n    }\n\n    /**\n     * Returns a specific event by name.\n     *\n     * @throws \\LogicException When the event is not known\n     */\n    public function getEvent(string $name): StopwatchEvent\n    {\n        if (!isset($this->events[$name])) {\n            throw new \\LogicException(\\sprintf('Event \"%s\" is not known.', $name));\n        }\n\n        return $this->events[$name];\n    }\n\n    /**\n     * Returns the events from this section.\n     *\n     * @return StopwatchEvent[]\n     */\n    public function getEvents(): array\n    {\n        return $this->events;\n    }\n}\n"
        },
        {
          "name": "Stopwatch.php",
          "type": "blob",
          "size": 3.994140625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Stopwatch;\n\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(Section::class);\n\n/**\n * Stopwatch provides a way to profile code.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Stopwatch implements ResetInterface\n{\n    public const ROOT = '__root__';\n\n    /**\n     * @var Section[]\n     */\n    private array $sections;\n\n    /**\n     * @var Section[]\n     */\n    private array $activeSections;\n\n    /**\n     * @param bool $morePrecision If true, time is stored as float to keep the original microsecond precision\n     */\n    public function __construct(\n        private bool $morePrecision = false,\n    ) {\n        $this->reset();\n    }\n\n    /**\n     * @return Section[]\n     */\n    public function getSections(): array\n    {\n        return $this->sections;\n    }\n\n    /**\n     * Creates a new section or re-opens an existing section.\n     *\n     * @param string|null $id The id of the session to re-open, null to create a new one\n     *\n     * @throws \\LogicException When the section to re-open is not reachable\n     */\n    public function openSection(?string $id = null): void\n    {\n        $current = end($this->activeSections);\n\n        if (null !== $id && null === $current->get($id)) {\n            throw new \\LogicException(\\sprintf('The section \"%s\" has been started at an other level and cannot be opened.', $id));\n        }\n\n        $this->start('__section__.child', 'section');\n        $this->activeSections[] = $current->open($id);\n        $this->start('__section__');\n    }\n\n    /**\n     * Stops the last started section.\n     *\n     * The id parameter is used to retrieve the events from this section.\n     *\n     * @see getSectionEvents()\n     *\n     * @throws \\LogicException When there's no started section to be stopped\n     */\n    public function stopSection(string $id): void\n    {\n        $this->stop('__section__');\n\n        if (1 == \\count($this->activeSections)) {\n            throw new \\LogicException('There is no started section to stop.');\n        }\n\n        $this->sections[$id] = array_pop($this->activeSections)->setId($id);\n        $this->stop('__section__.child');\n    }\n\n    /**\n     * Starts an event.\n     */\n    public function start(string $name, ?string $category = null): StopwatchEvent\n    {\n        return end($this->activeSections)->startEvent($name, $category);\n    }\n\n    /**\n     * Checks if the event was started.\n     */\n    public function isStarted(string $name): bool\n    {\n        return end($this->activeSections)->isEventStarted($name);\n    }\n\n    /**\n     * Stops an event.\n     */\n    public function stop(string $name): StopwatchEvent\n    {\n        return end($this->activeSections)->stopEvent($name);\n    }\n\n    /**\n     * Stops then restarts an event.\n     */\n    public function lap(string $name): StopwatchEvent\n    {\n        return end($this->activeSections)->stopEvent($name)->start();\n    }\n\n    /**\n     * Returns a specific event by name.\n     */\n    public function getEvent(string $name): StopwatchEvent\n    {\n        return end($this->activeSections)->getEvent($name);\n    }\n\n    /**\n     * Gets all events for a given section.\n     *\n     * @return StopwatchEvent[]\n     */\n    public function getSectionEvents(string $id): array\n    {\n        return isset($this->sections[$id]) ? $this->sections[$id]->getEvents() : [];\n    }\n\n    /**\n     * Gets all events for the root section.\n     *\n     * @return StopwatchEvent[]\n     */\n    public function getRootSectionEvents(): array\n    {\n        return $this->sections[self::ROOT]->getEvents() ?? [];\n    }\n\n    /**\n     * Resets the stopwatch to its original state.\n     */\n    public function reset(): void\n    {\n        $this->sections = $this->activeSections = [self::ROOT => new Section(null, $this->morePrecision)];\n    }\n}\n"
        },
        {
          "name": "StopwatchEvent.php",
          "type": "blob",
          "size": 5.490234375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Stopwatch;\n\n/**\n * Represents an Event managed by Stopwatch.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass StopwatchEvent\n{\n    /**\n     * @var StopwatchPeriod[]\n     */\n    private array $periods = [];\n\n    private float $origin;\n    private string $category;\n\n    /**\n     * @var float[]\n     */\n    private array $started = [];\n\n    private string $name;\n\n    /**\n     * @param float       $origin        The origin time in milliseconds\n     * @param string|null $category      The event category or null to use the default\n     * @param bool        $morePrecision If true, time is stored as float to keep the original microsecond precision\n     * @param string|null $name          The event name or null to define the name as default\n     *\n     * @throws \\InvalidArgumentException When the raw time is not valid\n     */\n    public function __construct(\n        float $origin,\n        ?string $category = null,\n        private bool $morePrecision = false,\n        ?string $name = null,\n    ) {\n        $this->origin = $this->formatTime($origin);\n        $this->category = \\is_string($category) ? $category : 'default';\n        $this->name = $name ?? 'default';\n    }\n\n    /**\n     * Gets the category.\n     */\n    public function getCategory(): string\n    {\n        return $this->category;\n    }\n\n    /**\n     * Gets the origin in milliseconds.\n     */\n    public function getOrigin(): float\n    {\n        return $this->origin;\n    }\n\n    /**\n     * Starts a new event period.\n     *\n     * @return $this\n     */\n    public function start(): static\n    {\n        $this->started[] = $this->getNow();\n\n        return $this;\n    }\n\n    /**\n     * Stops the last started event period.\n     *\n     * @return $this\n     *\n     * @throws \\LogicException When stop() is called without a matching call to start()\n     */\n    public function stop(): static\n    {\n        if (!\\count($this->started)) {\n            throw new \\LogicException('stop() called but start() has not been called before.');\n        }\n\n        $this->periods[] = new StopwatchPeriod(array_pop($this->started), $this->getNow(), $this->morePrecision);\n\n        return $this;\n    }\n\n    /**\n     * Checks if the event was started.\n     */\n    public function isStarted(): bool\n    {\n        return (bool) $this->started;\n    }\n\n    /**\n     * Stops the current period and then starts a new one.\n     *\n     * @return $this\n     */\n    public function lap(): static\n    {\n        return $this->stop()->start();\n    }\n\n    /**\n     * Stops all non already stopped periods.\n     */\n    public function ensureStopped(): void\n    {\n        while (\\count($this->started)) {\n            $this->stop();\n        }\n    }\n\n    /**\n     * Gets all event periods.\n     *\n     * @return StopwatchPeriod[]\n     */\n    public function getPeriods(): array\n    {\n        return $this->periods;\n    }\n\n    /**\n     * Gets the last event period.\n     */\n    public function getLastPeriod(): ?StopwatchPeriod\n    {\n        if ([] === $this->periods) {\n            return null;\n        }\n\n        return $this->periods[array_key_last($this->periods)];\n    }\n\n    /**\n     * Gets the relative time of the start of the first period in milliseconds.\n     */\n    public function getStartTime(): int|float\n    {\n        if (isset($this->periods[0])) {\n            return $this->periods[0]->getStartTime();\n        }\n\n        if ($this->started) {\n            return $this->started[0];\n        }\n\n        return 0;\n    }\n\n    /**\n     * Gets the relative time of the end of the last period in milliseconds.\n     */\n    public function getEndTime(): int|float\n    {\n        $count = \\count($this->periods);\n\n        return $count ? $this->periods[$count - 1]->getEndTime() : 0;\n    }\n\n    /**\n     * Gets the duration of the events in milliseconds (including all periods).\n     */\n    public function getDuration(): int|float\n    {\n        $periods = $this->periods;\n        $left = \\count($this->started);\n\n        for ($i = $left - 1; $i >= 0; --$i) {\n            $periods[] = new StopwatchPeriod($this->started[$i], $this->getNow(), $this->morePrecision);\n        }\n\n        $total = 0;\n        foreach ($periods as $period) {\n            $total += $period->getDuration();\n        }\n\n        return $total;\n    }\n\n    /**\n     * Gets the max memory usage of all periods in bytes.\n     */\n    public function getMemory(): int\n    {\n        $memory = 0;\n        foreach ($this->periods as $period) {\n            if ($period->getMemory() > $memory) {\n                $memory = $period->getMemory();\n            }\n        }\n\n        return $memory;\n    }\n\n    /**\n     * Return the current time relative to origin in milliseconds.\n     */\n    protected function getNow(): float\n    {\n        return $this->formatTime(microtime(true) * 1000 - $this->origin);\n    }\n\n    /**\n     * Formats a time.\n     *\n     * @throws \\InvalidArgumentException When the raw time is not valid\n     */\n    private function formatTime(float $time): float\n    {\n        return round($time, 1);\n    }\n\n    /**\n     * Gets the event name.\n     */\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    public function __toString(): string\n    {\n        return \\sprintf('%s/%s: %.2F MiB - %d ms', $this->getCategory(), $this->getName(), $this->getMemory() / 1024 / 1024, $this->getDuration());\n    }\n}\n"
        },
        {
          "name": "StopwatchPeriod.php",
          "type": "blob",
          "size": 1.87890625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Stopwatch;\n\n/**\n * Represents a Period for an Event.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass StopwatchPeriod\n{\n    private int|float $start;\n    private int|float $end;\n    private int $memory;\n\n    /**\n     * @param int|float $start         The relative time of the start of the period (in milliseconds)\n     * @param int|float $end           The relative time of the end of the period (in milliseconds)\n     * @param bool      $morePrecision If true, time is stored as float to keep the original microsecond precision\n     */\n    public function __construct(int|float $start, int|float $end, bool $morePrecision = false)\n    {\n        $this->start = $morePrecision ? (float) $start : (int) $start;\n        $this->end = $morePrecision ? (float) $end : (int) $end;\n        $this->memory = memory_get_usage(true);\n    }\n\n    /**\n     * Gets the relative time of the start of the period in milliseconds.\n     */\n    public function getStartTime(): int|float\n    {\n        return $this->start;\n    }\n\n    /**\n     * Gets the relative time of the end of the period in milliseconds.\n     */\n    public function getEndTime(): int|float\n    {\n        return $this->end;\n    }\n\n    /**\n     * Gets the time spent in this period in milliseconds.\n     */\n    public function getDuration(): int|float\n    {\n        return $this->end - $this->start;\n    }\n\n    /**\n     * Gets the memory usage in bytes.\n     */\n    public function getMemory(): int\n    {\n        return $this->memory;\n    }\n\n    public function __toString(): string\n    {\n        return \\sprintf('%.2F MiB - %d ms', $this->getMemory() / 1024 / 1024, $this->getDuration());\n    }\n}\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.7021484375,
          "content": "{\n    \"name\": \"symfony/stopwatch\",\n    \"type\": \"library\",\n    \"description\": \"Provides a way to profile code\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/service-contracts\": \"^2.5|^3\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Stopwatch\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.80078125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Stopwatch Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}