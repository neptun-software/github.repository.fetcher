{
  "metadata": {
    "timestamp": 1736712102124,
    "page": 678,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "thephpleague/flysystem-aws-s3-v3",
      "stars": 1574,
      "defaultBranch": "3.x",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1630859375,
          "content": "* text=auto\n\n.github export-ignore\n.gitattributes export-ignore\n.gitignore export-ignore\n**/*Test.php export-ignore\n**/*Stub.php export-ignore\nREADME.md export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "AwsS3V3Adapter.php",
          "type": "blob",
          "size": 16.96484375,
          "content": "<?php\n\ndeclare(strict_types=1);\n\nnamespace League\\Flysystem\\AwsS3V3;\n\nuse Aws\\Api\\DateTimeResult;\nuse Aws\\S3\\S3ClientInterface;\nuse DateTimeInterface;\nuse Generator;\nuse League\\Flysystem\\ChecksumAlgoIsNotSupported;\nuse League\\Flysystem\\ChecksumProvider;\nuse League\\Flysystem\\Config;\nuse League\\Flysystem\\DirectoryAttributes;\nuse League\\Flysystem\\FileAttributes;\nuse League\\Flysystem\\FilesystemAdapter;\nuse League\\Flysystem\\FilesystemOperationFailed;\nuse League\\Flysystem\\PathPrefixer;\nuse League\\Flysystem\\StorageAttributes;\nuse League\\Flysystem\\UnableToCheckDirectoryExistence;\nuse League\\Flysystem\\UnableToCheckFileExistence;\nuse League\\Flysystem\\UnableToCopyFile;\nuse League\\Flysystem\\UnableToDeleteDirectory;\nuse League\\Flysystem\\UnableToDeleteFile;\nuse League\\Flysystem\\UnableToGeneratePublicUrl;\nuse League\\Flysystem\\UnableToGenerateTemporaryUrl;\nuse League\\Flysystem\\UnableToMoveFile;\nuse League\\Flysystem\\UnableToProvideChecksum;\nuse League\\Flysystem\\UnableToReadFile;\nuse League\\Flysystem\\UnableToRetrieveMetadata;\nuse League\\Flysystem\\UnableToSetVisibility;\nuse League\\Flysystem\\UnableToWriteFile;\nuse League\\Flysystem\\UrlGeneration\\PublicUrlGenerator;\nuse League\\Flysystem\\UrlGeneration\\TemporaryUrlGenerator;\nuse League\\Flysystem\\Visibility;\nuse League\\MimeTypeDetection\\FinfoMimeTypeDetector;\nuse League\\MimeTypeDetection\\MimeTypeDetector;\nuse Psr\\Http\\Message\\StreamInterface;\nuse Throwable;\nuse function trim;\n\nclass AwsS3V3Adapter implements FilesystemAdapter, PublicUrlGenerator, ChecksumProvider, TemporaryUrlGenerator\n{\n    /**\n     * @var string[]\n     */\n    public const AVAILABLE_OPTIONS = [\n        'ACL',\n        'CacheControl',\n        'ContentDisposition',\n        'ContentEncoding',\n        'ContentLength',\n        'ContentType',\n        'Expires',\n        'GrantFullControl',\n        'GrantRead',\n        'GrantReadACP',\n        'GrantWriteACP',\n        'Metadata',\n        'MetadataDirective',\n        'RequestPayer',\n        'SSECustomerAlgorithm',\n        'SSECustomerKey',\n        'SSECustomerKeyMD5',\n        'SSEKMSKeyId',\n        'ServerSideEncryption',\n        'StorageClass',\n        'Tagging',\n        'WebsiteRedirectLocation',\n        'ChecksumAlgorithm',\n        'CopySourceSSECustomerAlgorithm',\n        'CopySourceSSECustomerKey',\n        'CopySourceSSECustomerKeyMD5',\n    ];\n    /**\n     * @var string[]\n     */\n    public const MUP_AVAILABLE_OPTIONS = [\n        'add_content_md5',\n        'before_upload',\n        'concurrency',\n        'mup_threshold',\n        'params',\n        'part_size',\n    ];\n\n    /**\n     * @var string[]\n     */\n    private const EXTRA_METADATA_FIELDS = [\n        'Metadata',\n        'StorageClass',\n        'ETag',\n        'VersionId',\n    ];\n\n    private PathPrefixer $prefixer;\n    private VisibilityConverter $visibility;\n    private MimeTypeDetector $mimeTypeDetector;\n\n    public function __construct(\n        private S3ClientInterface $client,\n        private string $bucket,\n        string $prefix = '',\n        ?VisibilityConverter $visibility = null,\n        ?MimeTypeDetector $mimeTypeDetector = null,\n        private array $options = [],\n        private bool $streamReads = true,\n        private array $forwardedOptions = self::AVAILABLE_OPTIONS,\n        private array $metadataFields = self::EXTRA_METADATA_FIELDS,\n        private array $multipartUploadOptions = self::MUP_AVAILABLE_OPTIONS,\n    ) {\n        $this->prefixer = new PathPrefixer($prefix);\n        $this->visibility = $visibility ?? new PortableVisibilityConverter();\n        $this->mimeTypeDetector = $mimeTypeDetector ?? new FinfoMimeTypeDetector();\n    }\n\n    public function fileExists(string $path): bool\n    {\n        try {\n            return $this->client->doesObjectExistV2($this->bucket, $this->prefixer->prefixPath($path), false, $this->options);\n        } catch (Throwable $exception) {\n            throw UnableToCheckFileExistence::forLocation($path, $exception);\n        }\n    }\n\n    public function directoryExists(string $path): bool\n    {\n        try {\n            $prefix = $this->prefixer->prefixDirectoryPath($path);\n            $options = ['Bucket' => $this->bucket, 'Prefix' => $prefix, 'MaxKeys' => 1, 'Delimiter' => '/'];\n            $command = $this->client->getCommand('ListObjectsV2', $options);\n            $result = $this->client->execute($command);\n\n            return $result->hasKey('Contents') || $result->hasKey('CommonPrefixes');\n        } catch (Throwable $exception) {\n            throw UnableToCheckDirectoryExistence::forLocation($path, $exception);\n        }\n    }\n\n    public function write(string $path, string $contents, Config $config): void\n    {\n        $this->upload($path, $contents, $config);\n    }\n\n    /**\n     * @param string          $path\n     * @param string|resource $body\n     * @param Config          $config\n     */\n    private function upload(string $path, $body, Config $config): void\n    {\n        $key = $this->prefixer->prefixPath($path);\n        $options = $this->createOptionsFromConfig($config);\n        $acl = $options['params']['ACL'] ?? $this->determineAcl($config);\n        $shouldDetermineMimetype = ! array_key_exists('ContentType', $options['params']);\n\n        if ($shouldDetermineMimetype && $mimeType = $this->mimeTypeDetector->detectMimeType($key, $body)) {\n            $options['params']['ContentType'] = $mimeType;\n        }\n\n        try {\n            $this->client->upload($this->bucket, $key, $body, $acl, $options);\n        } catch (Throwable $exception) {\n            throw UnableToWriteFile::atLocation($path, $exception->getMessage(), $exception);\n        }\n    }\n\n    private function determineAcl(Config $config): string\n    {\n        $visibility = (string) $config->get(Config::OPTION_VISIBILITY, Visibility::PRIVATE);\n\n        return $this->visibility->visibilityToAcl($visibility);\n    }\n\n    private function createOptionsFromConfig(Config $config): array\n    {\n        $config = $config->withDefaults($this->options);\n        $options = ['params' => []];\n\n        if ($mimetype = $config->get('mimetype')) {\n            $options['params']['ContentType'] = $mimetype;\n        }\n\n        foreach ($this->forwardedOptions as $option) {\n            $value = $config->get($option, '__NOT_SET__');\n\n            if ($value !== '__NOT_SET__') {\n                $options['params'][$option] = $value;\n            }\n        }\n\n        foreach ($this->multipartUploadOptions as $option) {\n            $value = $config->get($option, '__NOT_SET__');\n\n            if ($value !== '__NOT_SET__') {\n                $options[$option] = $value;\n            }\n        }\n\n        return $options;\n    }\n\n    public function writeStream(string $path, $contents, Config $config): void\n    {\n        $this->upload($path, $contents, $config);\n    }\n\n    public function read(string $path): string\n    {\n        $body = $this->readObject($path, false);\n\n        return (string) $body->getContents();\n    }\n\n    public function readStream(string $path)\n    {\n        /** @var resource $resource */\n        $resource = $this->readObject($path, true)->detach();\n\n        return $resource;\n    }\n\n    public function delete(string $path): void\n    {\n        $arguments = ['Bucket' => $this->bucket, 'Key' => $this->prefixer->prefixPath($path)];\n        $command = $this->client->getCommand('DeleteObject', $arguments);\n\n        try {\n            $this->client->execute($command);\n        } catch (Throwable $exception) {\n            throw UnableToDeleteFile::atLocation($path, '', $exception);\n        }\n    }\n\n    public function deleteDirectory(string $path): void\n    {\n        $prefix = $this->prefixer->prefixPath($path);\n        $prefix = ltrim(rtrim($prefix, '/') . '/', '/');\n\n        try {\n            $this->client->deleteMatchingObjects($this->bucket, $prefix);\n        } catch (Throwable $exception) {\n            throw UnableToDeleteDirectory::atLocation($path, '', $exception);\n        }\n    }\n\n    public function createDirectory(string $path, Config $config): void\n    {\n        $defaultVisibility = $config->get(Config::OPTION_DIRECTORY_VISIBILITY, $this->visibility->defaultForDirectories());\n        $config = $config->withDefaults([Config::OPTION_VISIBILITY => $defaultVisibility]);\n        $this->upload(rtrim($path, '/') . '/', '', $config);\n    }\n\n    public function setVisibility(string $path, string $visibility): void\n    {\n        $arguments = [\n            'Bucket' => $this->bucket,\n            'Key' => $this->prefixer->prefixPath($path),\n            'ACL' => $this->visibility->visibilityToAcl($visibility),\n        ];\n        $command = $this->client->getCommand('PutObjectAcl', $arguments);\n\n        try {\n            $this->client->execute($command);\n        } catch (Throwable $exception) {\n            throw UnableToSetVisibility::atLocation($path, '', $exception);\n        }\n    }\n\n    public function visibility(string $path): FileAttributes\n    {\n        $arguments = ['Bucket' => $this->bucket, 'Key' => $this->prefixer->prefixPath($path)];\n        $command = $this->client->getCommand('GetObjectAcl', $arguments);\n\n        try {\n            $result = $this->client->execute($command);\n        } catch (Throwable $exception) {\n            throw UnableToRetrieveMetadata::visibility($path, '', $exception);\n        }\n\n        $visibility = $this->visibility->aclToVisibility((array) $result->get('Grants'));\n\n        return new FileAttributes($path, null, $visibility);\n    }\n\n    private function fetchFileMetadata(string $path, string $type): FileAttributes\n    {\n        $arguments = ['Bucket' => $this->bucket, 'Key' => $this->prefixer->prefixPath($path)];\n        $command = $this->client->getCommand('HeadObject', $arguments);\n\n        try {\n            $result = $this->client->execute($command);\n        } catch (Throwable $exception) {\n            throw UnableToRetrieveMetadata::create($path, $type, '', $exception);\n        }\n\n        $attributes = $this->mapS3ObjectMetadata($result->toArray(), $path);\n\n        if ( ! $attributes instanceof FileAttributes) {\n            throw UnableToRetrieveMetadata::create($path, $type, '');\n        }\n\n        return $attributes;\n    }\n\n    private function mapS3ObjectMetadata(array $metadata, string $path): StorageAttributes\n    {\n        if (substr($path, -1) === '/') {\n            return new DirectoryAttributes(rtrim($path, '/'));\n        }\n\n        $mimetype = $metadata['ContentType'] ?? null;\n        $fileSize = $metadata['ContentLength'] ?? $metadata['Size'] ?? null;\n        $fileSize = $fileSize === null ? null : (int) $fileSize;\n        $dateTime = $metadata['LastModified'] ?? null;\n        $lastModified = $dateTime instanceof DateTimeResult ? $dateTime->getTimeStamp() : null;\n\n        return new FileAttributes(\n            $path,\n            $fileSize,\n            null,\n            $lastModified,\n            $mimetype,\n            $this->extractExtraMetadata($metadata)\n        );\n    }\n\n    private function extractExtraMetadata(array $metadata): array\n    {\n        $extracted = [];\n\n        foreach ($this->metadataFields as $field) {\n            if (isset($metadata[$field]) && $metadata[$field] !== '') {\n                $extracted[$field] = $metadata[$field];\n            }\n        }\n\n        return $extracted;\n    }\n\n    public function mimeType(string $path): FileAttributes\n    {\n        $attributes = $this->fetchFileMetadata($path, FileAttributes::ATTRIBUTE_MIME_TYPE);\n\n        if ($attributes->mimeType() === null) {\n            throw UnableToRetrieveMetadata::mimeType($path);\n        }\n\n        return $attributes;\n    }\n\n    public function lastModified(string $path): FileAttributes\n    {\n        $attributes = $this->fetchFileMetadata($path, FileAttributes::ATTRIBUTE_LAST_MODIFIED);\n\n        if ($attributes->lastModified() === null) {\n            throw UnableToRetrieveMetadata::lastModified($path);\n        }\n\n        return $attributes;\n    }\n\n    public function fileSize(string $path): FileAttributes\n    {\n        $attributes = $this->fetchFileMetadata($path, FileAttributes::ATTRIBUTE_FILE_SIZE);\n\n        if ($attributes->fileSize() === null) {\n            throw UnableToRetrieveMetadata::fileSize($path);\n        }\n\n        return $attributes;\n    }\n\n    public function listContents(string $path, bool $deep): iterable\n    {\n        $prefix = trim($this->prefixer->prefixPath($path), '/');\n        $prefix = empty($prefix) ? '' : $prefix . '/';\n        $options = ['Bucket' => $this->bucket, 'Prefix' => $prefix];\n\n        if ($deep === false) {\n            $options['Delimiter'] = '/';\n        }\n\n        $listing = $this->retrievePaginatedListing($options);\n\n        foreach ($listing as $item) {\n            $key = $item['Key'] ?? $item['Prefix'];\n\n            if ($key === $prefix) {\n                continue;\n            }\n\n            yield $this->mapS3ObjectMetadata($item, $this->prefixer->stripPrefix($key));\n        }\n    }\n\n    private function retrievePaginatedListing(array $options): Generator\n    {\n        $resultPaginator = $this->client->getPaginator('ListObjectsV2', $options + $this->options);\n\n        foreach ($resultPaginator as $result) {\n            yield from ($result->get('CommonPrefixes') ?? []);\n            yield from ($result->get('Contents') ?? []);\n        }\n    }\n\n    public function move(string $source, string $destination, Config $config): void\n    {\n        if ($source === $destination) {\n            return;\n        }\n\n        try {\n            $this->copy($source, $destination, $config);\n            $this->delete($source);\n        } catch (FilesystemOperationFailed $exception) {\n            throw UnableToMoveFile::fromLocationTo($source, $destination, $exception);\n        }\n    }\n\n    public function copy(string $source, string $destination, Config $config): void\n    {\n        if ($source === $destination) {\n            return;\n        }\n\n        try {\n            $visibility = $config->get(Config::OPTION_VISIBILITY);\n\n            if ($visibility === null && $config->get(Config::OPTION_RETAIN_VISIBILITY, true)) {\n                $visibility = $this->visibility($source)->visibility();\n            }\n        } catch (Throwable $exception) {\n            throw UnableToCopyFile::fromLocationTo(\n                $source,\n                $destination,\n                $exception\n            );\n        }\n\n        $options = $this->createOptionsFromConfig($config);\n        $options['MetadataDirective'] = $config->get('MetadataDirective', 'COPY');\n\n        try {\n            $this->client->copy(\n                $this->bucket,\n                $this->prefixer->prefixPath($source),\n                $this->bucket,\n                $this->prefixer->prefixPath($destination),\n                $this->visibility->visibilityToAcl($visibility ?: 'private'),\n                $options,\n            );\n        } catch (Throwable $exception) {\n            throw UnableToCopyFile::fromLocationTo($source, $destination, $exception);\n        }\n    }\n\n    private function readObject(string $path, bool $wantsStream): StreamInterface\n    {\n        $options = ['Bucket' => $this->bucket, 'Key' => $this->prefixer->prefixPath($path)];\n\n        if ($wantsStream && $this->streamReads && ! isset($this->options['@http']['stream'])) {\n            $options['@http']['stream'] = true;\n        }\n\n        $command = $this->client->getCommand('GetObject', $options + $this->options);\n\n        try {\n            return $this->client->execute($command)->get('Body');\n        } catch (Throwable $exception) {\n            throw UnableToReadFile::fromLocation($path, '', $exception);\n        }\n    }\n\n    public function publicUrl(string $path, Config $config): string\n    {\n        $location = $this->prefixer->prefixPath($path);\n\n        try {\n            return $this->client->getObjectUrl($this->bucket, $location);\n        } catch (Throwable $exception) {\n            throw UnableToGeneratePublicUrl::dueToError($path, $exception);\n        }\n    }\n\n    public function checksum(string $path, Config $config): string\n    {\n        $algo = $config->get('checksum_algo', 'etag');\n\n        if ($algo !== 'etag') {\n            throw new ChecksumAlgoIsNotSupported();\n        }\n\n        try {\n            $metadata = $this->fetchFileMetadata($path, 'checksum')->extraMetadata();\n        } catch (UnableToRetrieveMetadata $exception) {\n            throw new UnableToProvideChecksum($exception->reason(), $path, $exception);\n        }\n\n        if ( ! isset($metadata['ETag'])) {\n            throw new UnableToProvideChecksum('ETag header not available.', $path);\n        }\n\n        return trim($metadata['ETag'], '\"');\n    }\n\n    public function temporaryUrl(string $path, DateTimeInterface $expiresAt, Config $config): string\n    {\n        try {\n            $options = $config->get('get_object_options', []);\n            $command = $this->client->getCommand('GetObject', [\n                    'Bucket' => $this->bucket,\n                    'Key' => $this->prefixer->prefixPath($path),\n                ] + $options);\n\n            $presignedRequestOptions = $config->get('presigned_request_options', []);\n            $request = $this->client->createPresignedRequest($command, $expiresAt, $presignedRequestOptions);\n\n            return (string) $request->getUri();\n        } catch (Throwable $exception) {\n            throw UnableToGenerateTemporaryUrl::dueToError($path, $exception);\n        }\n    }\n}\n"
        },
        {
          "name": "AwsS3V3AdapterTest.php",
          "type": "blob",
          "size": 14.923828125,
          "content": "<?php\n\ndeclare(strict_types=1);\n\nnamespace League\\Flysystem\\AwsS3V3;\n\nuse Aws\\Result;\nuse Aws\\S3\\S3Client;\nuse Aws\\S3\\S3ClientInterface;\nuse Exception;\nuse Generator;\nuse League\\Flysystem\\AdapterTestUtilities\\FilesystemAdapterTestCase;\nuse League\\Flysystem\\ChecksumAlgoIsNotSupported;\nuse League\\Flysystem\\Config;\nuse League\\Flysystem\\FileAttributes;\nuse League\\Flysystem\\FilesystemAdapter;\nuse League\\Flysystem\\PathPrefixer;\nuse League\\Flysystem\\StorageAttributes;\nuse League\\Flysystem\\UnableToCheckFileExistence;\nuse League\\Flysystem\\UnableToDeleteFile;\nuse League\\Flysystem\\UnableToMoveFile;\nuse League\\Flysystem\\UnableToRetrieveMetadata;\nuse League\\Flysystem\\UnableToWriteFile;\nuse League\\Flysystem\\Visibility;\nuse RuntimeException;\n\nuse function getenv;\nuse function iterator_to_array;\n\n/**\n * @group aws\n */\nclass AwsS3V3AdapterTest extends FilesystemAdapterTestCase\n{\n    /**\n     * @var bool\n     */\n    private $shouldCleanUp = false;\n\n    /**\n     * @var string\n     */\n    private static $adapterPrefix = 'test-prefix';\n\n    /**\n     * @var S3ClientInterface|null\n     */\n    private static $s3Client;\n\n    /**\n     * @var S3ClientStub\n     */\n    private static $stubS3Client;\n\n    public static function setUpBeforeClass(): void\n    {\n        static::$adapterPrefix = getenv('FLYSYSTEM_AWS_S3_PREFIX') ?: 'ci/' . bin2hex(random_bytes(10));\n    }\n\n    protected function tearDown(): void\n    {\n        if ( ! $this->shouldCleanUp) {\n            return;\n        }\n\n        $adapter = $this->adapter();\n        $adapter->deleteDirectory('/');\n        /** @var StorageAttributes[] $listing */\n        $listing = $adapter->listContents('', false);\n\n        foreach ($listing as $item) {\n            if ($item->isFile()) {\n                $adapter->delete($item->path());\n            } else {\n                $adapter->deleteDirectory($item->path());\n            }\n        }\n\n        self::$adapter = null;\n    }\n\n    protected function setUp(): void\n    {\n        if (PHP_VERSION_ID < 80100) {\n            $this->markTestSkipped('AWS does not support this anymore.');\n        }\n\n        parent::setUp();\n    }\n\n    private static function s3Client(): S3ClientInterface\n    {\n        if (static::$s3Client instanceof S3ClientInterface) {\n            return static::$s3Client;\n        }\n\n        $key = getenv('FLYSYSTEM_AWS_S3_KEY');\n        $secret = getenv('FLYSYSTEM_AWS_S3_SECRET');\n        $bucket = getenv('FLYSYSTEM_AWS_S3_BUCKET');\n        $region = getenv('FLYSYSTEM_AWS_S3_REGION') ?: 'eu-central-1';\n\n        if ( ! $key || ! $secret || ! $bucket) {\n            self::markTestSkipped('No AWS credentials present for testing.');\n        }\n\n        $options = ['version' => 'latest', 'credentials' => compact('key', 'secret'), 'region' => $region];\n\n        return static::$s3Client = new S3Client($options);\n    }\n\n    /**\n     * @test\n     */\n    public function writing_with_a_specific_mime_type(): void\n    {\n        $adapter = $this->adapter();\n        $adapter->write('some/path.txt', 'contents', new Config(['ContentType' => 'text/plain+special']));\n        $mimeType = $adapter->mimeType('some/path.txt')->mimeType();\n        $this->assertEquals('text/plain+special', $mimeType);\n    }\n\n    /**\n     * @test\n     */\n    public function writing_a_file_with_explicit_mime_type(): void\n    {\n        $adapter = $this->adapter();\n        $adapter->write('some/path.txt', 'contents', new Config(['mimetype' => 'text/plain+special']));\n        $mimeType = $adapter->mimeType('some/path.txt')->mimeType();\n        $this->assertEquals('text/plain+special', $mimeType);\n    }\n\n    /**\n     * @test\n     *\n     * @see https://github.com/thephpleague/flysystem-aws-s3-v3/issues/291\n     */\n    public function issue_291(): void\n    {\n        $adapter = $this->adapter();\n        $adapter->createDirectory('directory', new Config());\n        $listing = iterator_to_array($adapter->listContents('directory', true));\n\n        self::assertCount(0, $listing);\n    }\n\n    /**\n     * @test\n     */\n    public function listing_contents_recursive(): void\n    {\n        $adapter = $this->adapter();\n        $adapter->write('something/0/here.txt', 'contents', new Config());\n        $adapter->write('something/1/also/here.txt', 'contents', new Config());\n\n        $contents = iterator_to_array($adapter->listContents('', true));\n\n        $this->assertCount(2, $contents);\n        $this->assertContainsOnlyInstancesOf(FileAttributes::class, $contents);\n        /** @var FileAttributes $file */\n        $file = $contents[0];\n        $this->assertEquals('something/0/here.txt', $file->path());\n        /** @var FileAttributes $file */\n        $file = $contents[1];\n        $this->assertEquals('something/1/also/here.txt', $file->path());\n    }\n\n    /**\n     * @test\n     */\n    public function failing_to_delete_while_moving(): void\n    {\n        $adapter = $this->adapter();\n        $adapter->write('source.txt', 'contents to be copied', new Config());\n        static::$stubS3Client->failOnNextCopy();\n\n        $this->expectException(UnableToMoveFile::class);\n\n        $adapter->move('source.txt', 'destination.txt', new Config());\n    }\n\n    /**\n     * @test\n     *\n     * @see https://github.com/thephpleague/flysystem-aws-s3-v3/issues/287\n     */\n    public function issue_287(): void\n    {\n        $adapter = $this->adapter();\n        $adapter->write('KmFVvKqo/QLMExy2U/620ff60c8a154.pdf', 'pdf content', new Config());\n\n        self::assertTrue($adapter->directoryExists('KmFVvKqo'));\n    }\n\n    /**\n     * @test\n     */\n    public function failing_to_write_a_file(): void\n    {\n        $adapter = $this->adapter();\n        static::$stubS3Client->throwDuringUpload(new RuntimeException('Oh no'));\n\n        $this->expectException(UnableToWriteFile::class);\n\n        $adapter->write('path.txt', 'contents', new Config());\n    }\n\n    /**\n     * @test\n     */\n    public function failing_to_delete_a_file(): void\n    {\n        $adapter = $this->adapter();\n        static::$stubS3Client->throwExceptionWhenExecutingCommand('DeleteObject');\n\n        $this->expectException(UnableToDeleteFile::class);\n\n        $adapter->delete('path.txt');\n    }\n\n    /**\n     * @test\n     */\n    public function fetching_unknown_mime_type_of_a_file(): void\n    {\n        $this->adapter();\n        $result = new Result([\n            'Key' => static::$adapterPrefix . '/unknown-mime-type.md5',\n        ]);\n        static::$stubS3Client->stageResultForCommand('HeadObject', $result);\n\n        parent::fetching_unknown_mime_type_of_a_file();\n    }\n\n    /**\n     * @test\n     *\n     * @dataProvider dpFailingMetadataGetters\n     */\n    public function failing_to_retrieve_metadata(Exception $exception, string $getterName): void\n    {\n        $adapter = $this->adapter();\n        $result = new Result([\n             'Key' => static::$adapterPrefix . '/filename.txt',\n        ]);\n        static::$stubS3Client->stageResultForCommand('HeadObject', $result);\n\n        $this->expectExceptionObject($exception);\n\n        $adapter->{$getterName}('filename.txt');\n    }\n\n    public static function dpFailingMetadataGetters(): iterable\n    {\n        yield \"mimeType\" => [UnableToRetrieveMetadata::mimeType('filename.txt'), 'mimeType'];\n        yield \"lastModified\" => [UnableToRetrieveMetadata::lastModified('filename.txt'), 'lastModified'];\n        yield \"fileSize\" => [UnableToRetrieveMetadata::fileSize('filename.txt'), 'fileSize'];\n    }\n\n    /**\n     * @test\n     */\n    public function failing_to_check_for_file_existence(): void\n    {\n        $adapter = $this->adapter();\n\n        static::$stubS3Client->throw500ExceptionWhenExecutingCommand('HeadObject');\n\n        $this->expectException(UnableToCheckFileExistence::class);\n\n        $adapter->fileExists('something-that-does-exist.txt');\n    }\n\n    /**\n     * @test\n     *\n     * @dataProvider casesWhereHttpStreamingInfluencesSeekability\n     */\n    public function streaming_reads_are_not_seekable_and_non_streaming_are(bool $streaming, bool $seekable): void\n    {\n        if (getenv('COMPOSER_OPTS') === '--prefer-lowest') {\n            $this->markTestSkipped('The SDK does not support streaming in low versions.');\n        }\n\n        $adapter = $this->useAdapter($this->createFilesystemAdapter($streaming));\n        $this->givenWeHaveAnExistingFile('path.txt');\n\n        $resource = $adapter->readStream('path.txt');\n        $metadata = stream_get_meta_data($resource);\n        fclose($resource);\n\n        $this->assertEquals($seekable, $metadata['seekable']);\n    }\n\n    public static function casesWhereHttpStreamingInfluencesSeekability(): Generator\n    {\n        yield \"not streaming reads have seekable stream\" => [false, true];\n        yield \"streaming reads have non-seekable stream\" => [true, false];\n    }\n\n    /**\n     * @test\n     *\n     * @dataProvider casesWhereHttpStreamingInfluencesSeekability\n     */\n    public function configuring_http_streaming_via_options(bool $streaming): void\n    {\n        $adapter = $this->useAdapter($this->createFilesystemAdapter($streaming, ['@http' => ['stream' => false]]));\n        $this->givenWeHaveAnExistingFile('path.txt');\n\n        $resource = $adapter->readStream('path.txt');\n        $metadata = stream_get_meta_data($resource);\n        fclose($resource);\n\n        $this->assertTrue($metadata['seekable']);\n    }\n\n    /**\n     * @test\n     *\n     * @dataProvider casesWhereHttpStreamingInfluencesSeekability\n     */\n    public function use_globally_configured_options(bool $streaming): void\n    {\n        $adapter = $this->useAdapter($this->createFilesystemAdapter($streaming, ['ContentType' => 'text/plain+special']));\n        $this->givenWeHaveAnExistingFile('path.txt');\n\n        $mimeType = $adapter->mimeType('path.txt')->mimeType();\n        $this->assertSame('text/plain+special', $mimeType);\n    }\n\n    /**\n     * @test\n     */\n    public function moving_with_updated_metadata(): void\n    {\n        $adapter = $this->adapter();\n        $adapter->write('source.txt', 'contents to be moved', new Config(['ContentType' => 'text/plain']));\n        $mimeTypeSource = $adapter->mimeType('source.txt')->mimeType();\n        $this->assertSame('text/plain', $mimeTypeSource);\n\n        $adapter->move('source.txt', 'destination.txt', new Config(\n            ['ContentType' => 'text/plain+special', 'MetadataDirective' => 'REPLACE']\n        ));\n        $mimeTypeDestination = $adapter->mimeType('destination.txt')->mimeType();\n        $this->assertSame('text/plain+special', $mimeTypeDestination);\n    }\n\n    /**\n     * @test\n     */\n    public function moving_without_updated_metadata(): void\n    {\n        $adapter = $this->adapter();\n        $adapter->write('source.txt', 'contents to be moved', new Config(['ContentType' => 'text/plain']));\n        $mimeTypeSource = $adapter->mimeType('source.txt')->mimeType();\n        $this->assertSame('text/plain', $mimeTypeSource);\n\n        $adapter->move('source.txt', 'destination.txt', new Config(\n            ['ContentType' => 'text/plain+special']\n        ));\n        $mimeTypeDestination = $adapter->mimeType('destination.txt')->mimeType();\n        $this->assertSame('text/plain', $mimeTypeDestination);\n    }\n\n    /**\n     * @test\n     */\n    public function copying_with_updated_metadata(): void\n    {\n        $adapter = $this->adapter();\n        $adapter->write('source.txt', 'contents to be moved', new Config(['ContentType' => 'text/plain']));\n        $mimeTypeSource = $adapter->mimeType('source.txt')->mimeType();\n        $this->assertSame('text/plain', $mimeTypeSource);\n\n        $adapter->copy('source.txt', 'destination.txt', new Config(\n            ['ContentType' => 'text/plain+special', 'MetadataDirective' => 'REPLACE']\n        ));\n        $mimeTypeDestination = $adapter->mimeType('destination.txt')->mimeType();\n        $this->assertSame('text/plain+special', $mimeTypeDestination);\n    }\n\n    /**\n     * @test\n     */\n    public function setting_acl_via_options(): void\n    {\n        $adapter = $this->adapter();\n        $prefixer = new PathPrefixer(static::$adapterPrefix);\n        $prefixedPath = $prefixer->prefixPath('path.txt');\n\n        $adapter->write('path.txt', 'contents', new Config(['ACL' => 'bucket-owner-full-control']));\n        $arguments = ['Bucket' => getenv('FLYSYSTEM_AWS_S3_BUCKET'), 'Key' => $prefixedPath];\n        $command = static::$s3Client->getCommand('GetObjectAcl', $arguments);\n        $response = static::$s3Client->execute($command)->toArray();\n        $permission = $response['Grants'][0]['Permission'];\n\n        self::assertEquals('FULL_CONTROL', $permission);\n    }\n\n    /**\n     * @test\n     */\n    public function moving_a_file_with_visibility(): void\n    {\n        $this->runScenario(function () {\n            $adapter = $this->adapter();\n            $adapter->write(\n                'source.txt',\n                'contents to be copied',\n                new Config([Config::OPTION_VISIBILITY => Visibility::PUBLIC])\n            );\n            $adapter->move('source.txt', 'destination.txt', new Config([Config::OPTION_VISIBILITY => Visibility::PRIVATE]));\n            $this->assertFalse(\n                $adapter->fileExists('source.txt'),\n                'After moving a file should no longer exist in the original location.'\n            );\n            $this->assertTrue(\n                $adapter->fileExists('destination.txt'),\n                'After moving, a file should be present at the new location.'\n            );\n            $this->assertEquals(Visibility::PRIVATE, $adapter->visibility('destination.txt')->visibility());\n            $this->assertEquals('contents to be copied', $adapter->read('destination.txt'));\n        });\n    }\n\n    /**\n     * @test\n     */\n    public function specifying_a_custom_checksum_algo_is_not_supported(): void\n    {\n        /** @var AwsS3V3Adapter $adapter */\n        $adapter = $this->adapter();\n\n        $this->expectException(ChecksumAlgoIsNotSupported::class);\n\n        $adapter->checksum('something', new Config(['checksum_algo' => 'md5']));\n    }\n\n    /**\n     * @test\n     */\n    public function copying_a_file_with_visibility(): void\n    {\n        $this->runScenario(function () {\n            $adapter = $this->adapter();\n            $adapter->write(\n                'source.txt',\n                'contents to be copied',\n                new Config([Config::OPTION_VISIBILITY => Visibility::PUBLIC])\n            );\n\n            $adapter->copy('source.txt', 'destination.txt', new Config([Config::OPTION_VISIBILITY => Visibility::PRIVATE]));\n\n            $this->assertTrue($adapter->fileExists('source.txt'));\n            $this->assertTrue($adapter->fileExists('destination.txt'));\n            $this->assertEquals(Visibility::PRIVATE, $adapter->visibility('destination.txt')->visibility());\n            $this->assertEquals('contents to be copied', $adapter->read('destination.txt'));\n        });\n    }\n\n    protected static function createFilesystemAdapter(bool $streaming = true, array $options = []): FilesystemAdapter\n    {\n        static::$stubS3Client = new S3ClientStub(static::s3Client());\n        /** @var string $bucket */\n        $bucket = getenv('FLYSYSTEM_AWS_S3_BUCKET');\n        $prefix = static::$adapterPrefix;\n\n        return new AwsS3V3Adapter(static::$stubS3Client, $bucket, $prefix, null, null, $options, $streaming);\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0380859375,
          "content": "Copyright (c) 2013-2024 Frank de Jonge\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "PortableVisibilityConverter.php",
          "type": "blob",
          "size": 1.240234375,
          "content": "<?php\n\ndeclare(strict_types=1);\n\nnamespace League\\Flysystem\\AwsS3V3;\n\nuse League\\Flysystem\\Visibility;\n\nclass PortableVisibilityConverter implements VisibilityConverter\n{\n    private const PUBLIC_GRANTEE_URI = 'http://acs.amazonaws.com/groups/global/AllUsers';\n    private const PUBLIC_GRANTS_PERMISSION = 'READ';\n    private const PUBLIC_ACL = 'public-read';\n    private const PRIVATE_ACL = 'private';\n\n    public function __construct(private string $defaultForDirectories = Visibility::PUBLIC)\n    {\n    }\n\n    public function visibilityToAcl(string $visibility): string\n    {\n        if ($visibility === Visibility::PUBLIC) {\n            return self::PUBLIC_ACL;\n        }\n\n        return self::PRIVATE_ACL;\n    }\n\n    public function aclToVisibility(array $grants): string\n    {\n        foreach ($grants as $grant) {\n            $granteeUri = $grant['Grantee']['URI'] ?? null;\n            $permission = $grant['Permission'] ?? null;\n\n            if ($granteeUri === self::PUBLIC_GRANTEE_URI && $permission === self::PUBLIC_GRANTS_PERMISSION) {\n                return Visibility::PUBLIC;\n            }\n        }\n\n        return Visibility::PRIVATE;\n    }\n\n    public function defaultForDirectories(): string\n    {\n        return $this->defaultForDirectories;\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.28515625,
          "content": "## Sub-split of Flysystem for AWS S3.\n\n> ⚠️ this is a sub-split, for pull requests and issues, visit: https://github.com/thephpleague/flysystem\n\n```bash\ncomposer require league/flysystem-aws-s3-v3\n```\n\nView the [documentation](https://flysystem.thephpleague.com/docs/adapter/aws-s3-v3/).\n"
        },
        {
          "name": "S3ClientStub.php",
          "type": "blob",
          "size": 4.533203125,
          "content": "<?php\n\ndeclare(strict_types=1);\n\nnamespace League\\Flysystem\\AwsS3V3;\n\nuse Aws\\Command;\nuse Aws\\CommandInterface;\nuse Aws\\ResultInterface;\nuse Aws\\S3\\Exception\\S3Exception;\nuse Aws\\S3\\S3ClientInterface;\nuse Aws\\S3\\S3ClientTrait;\nuse GuzzleHttp\\Psr7\\Response;\n\nuse Throwable;\n\nuse function GuzzleHttp\\Promise\\promise_for;\n\n/**\n * @codeCoverageIgnore\n */\nclass S3ClientStub implements S3ClientInterface\n{\n    use S3ClientTrait;\n\n    /**\n     * @var S3ClientInterface\n     */\n    private $actualClient;\n\n    /**\n     * @var S3Exception[]\n     */\n    private $stagedExceptions = [];\n\n    /**\n     * @var ResultInterface[]\n     */\n    private $stagedResult = [];\n\n    /**\n     * @var Throwable|null\n     */\n    private $exceptionForUpload = null;\n\n    public function __construct(S3ClientInterface $client)\n    {\n        return $this->actualClient = $client;\n    }\n\n    public function throwDuringUpload(Throwable $throwable): void\n    {\n        $this->exceptionForUpload = $throwable;\n    }\n\n    public function upload($bucket, $key, $body, $acl = 'private', array $options = [])\n    {\n        if ($this->exceptionForUpload instanceof Throwable) {\n            $throwable = $this->exceptionForUpload;\n            $this->exceptionForUpload = null;\n            throw $throwable;\n        }\n\n        return $this->actualClient->upload($bucket, $key, $body, $acl, $options);\n    }\n\n    public function failOnNextCopy(): void\n    {\n        $this->throwExceptionWhenExecutingCommand('CopyObject');\n    }\n\n    public function throwExceptionWhenExecutingCommand(string $commandName, ?S3Exception $exception = null): void\n    {\n        $this->stagedExceptions[$commandName] = $exception ?? new S3Exception($commandName, new Command($commandName));\n    }\n\n    public function throw500ExceptionWhenExecutingCommand(string $commandName): void\n    {\n        $response = new Response(500);\n        $exception = new S3Exception($commandName, new Command($commandName), compact('response'));\n\n        $this->throwExceptionWhenExecutingCommand($commandName, $exception);\n    }\n\n    public function stageResultForCommand(string $commandName, ResultInterface $result): void\n    {\n        $this->stagedResult[$commandName] = $result;\n    }\n\n    public function execute(CommandInterface $command)\n    {\n        return $this->executeAsync($command)->wait();\n    }\n\n    public function getCommand($name, array $args = [])\n    {\n        return $this->actualClient->getCommand($name, $args);\n    }\n\n    public function getHandlerList()\n    {\n        return $this->actualClient->getHandlerList();\n    }\n\n    public function getIterator($name, array $args = [])\n    {\n        return $this->actualClient->getIterator($name, $args);\n    }\n\n    public function __call($name, array $arguments)\n    {\n        return $this->actualClient->__call($name, $arguments);\n    }\n\n    public function executeAsync(CommandInterface $command)\n    {\n        $name = $command->getName();\n\n        if (array_key_exists($name, $this->stagedExceptions)) {\n            $exception = $this->stagedExceptions[$name];\n            unset($this->stagedExceptions[$name]);\n            throw $exception;\n        }\n\n        if (array_key_exists($name, $this->stagedResult)) {\n            $result = $this->stagedResult[$name];\n            unset($this->stagedResult[$name]);\n\n            return promise_for($result);\n        }\n\n        return $this->actualClient->executeAsync($command);\n    }\n\n    public function getCredentials()\n    {\n        return $this->actualClient->getCredentials();\n    }\n\n    public function getRegion()\n    {\n        return $this->actualClient->getRegion();\n    }\n\n    public function getEndpoint()\n    {\n        return $this->actualClient->getEndpoint();\n    }\n\n    public function getApi()\n    {\n        return $this->actualClient->getApi();\n    }\n\n    public function getConfig($option = null)\n    {\n        return $this->actualClient->getConfig($option);\n    }\n\n    public function getPaginator($name, array $args = [])\n    {\n        return $this->actualClient->getPaginator($name, $args);\n    }\n\n    public function waitUntil($name, array $args = [])\n    {\n        $this->actualClient->waitUntil($name, $args);\n    }\n\n    public function getWaiter($name, array $args = [])\n    {\n        return $this->actualClient->getWaiter($name, $args);\n    }\n\n    public function createPresignedRequest(CommandInterface $command, $expires, array $options = [])\n    {\n        return $this->actualClient->createPresignedRequest($command, $expires, $options);\n    }\n\n    public function getObjectUrl($bucket, $key)\n    {\n        return $this->actualClient->getObjectUrl($bucket, $key);\n    }\n}\n"
        },
        {
          "name": "VisibilityConverter.php",
          "type": "blob",
          "size": 0.275390625,
          "content": "<?php\n\ndeclare(strict_types=1);\n\nnamespace League\\Flysystem\\AwsS3V3;\n\ninterface VisibilityConverter\n{\n    public function visibilityToAcl(string $visibility): string;\n    public function aclToVisibility(array $grants): string;\n    public function defaultForDirectories(): string;\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.724609375,
          "content": "{\n    \"name\": \"league/flysystem-aws-s3-v3\",\n    \"description\": \"AWS S3 filesystem adapter for Flysystem.\",\n    \"keywords\": [\"aws\", \"s3\", \"flysystem\", \"filesystem\", \"storage\", \"file\", \"files\"],\n    \"type\": \"library\",\n    \"autoload\": {\n        \"psr-4\": {\n            \"League\\\\Flysystem\\\\AwsS3V3\\\\\": \"\"\n        }\n    },\n    \"require\": {\n        \"php\": \"^8.0.2\",\n        \"league/flysystem\": \"^3.10.0\",\n        \"league/mime-type-detection\": \"^1.0.0\",\n        \"aws/aws-sdk-php\": \"^3.295.10\"\n    },\n    \"conflict\": {\n        \"guzzlehttp/ringphp\": \"<1.1.1\",\n        \"guzzlehttp/guzzle\": \"<7.0\"\n    },\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Frank de Jonge\",\n            \"email\": \"info@frankdejonge.nl\"\n        }\n    ]\n}\n"
        }
      ]
    }
  ]
}