{
  "metadata": {
    "timestamp": 1736711772720,
    "page": 28,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/filesystem",
      "stars": 4612,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.6337890625,
          "content": "CHANGELOG\n=========\n\n7.1\n---\n\n * Add the `Filesystem::readFile()` method\n\n7.0\n---\n\n * Add argument `$lock` to `Filesystem::appendToFile()`\n\n5.4\n---\n\n * Add `Path` class\n * Add `$lock` argument to `Filesystem::appendToFile()`\n\n5.0.0\n-----\n\n * `Filesystem::dumpFile()` and `appendToFile()` don't accept arrays anymore\n\n4.4.0\n-----\n\n * support for passing a `null` value to `Filesystem::isAbsolutePath()` is deprecated and will be removed in 5.0\n * `tempnam()` now accepts a third argument `$suffix`.\n\n4.3.0\n-----\n\n * support for passing arrays to `Filesystem::dumpFile()` is deprecated and will be removed in 5.0\n * support for passing arrays to `Filesystem::appendToFile()` is deprecated and will be removed in 5.0\n\n4.0.0\n-----\n\n * removed `LockHandler`\n * Support for passing relative paths to `Filesystem::makePathRelative()` has been removed.\n\n3.4.0\n-----\n\n * support for passing relative paths to `Filesystem::makePathRelative()` is deprecated and will be removed in 4.0\n\n3.3.0\n-----\n\n * added `appendToFile()` to append contents to existing files\n\n3.2.0\n-----\n\n * added `readlink()` as a platform independent method to read links\n\n3.0.0\n-----\n\n * removed `$mode` argument from `Filesystem::dumpFile()`\n\n2.8.0\n-----\n\n * added tempnam() a stream aware version of PHP's native tempnam()\n\n2.6.0\n-----\n\n * added LockHandler\n\n2.3.12\n------\n\n * deprecated dumpFile() file mode argument.\n\n2.3.0\n-----\n\n * added the dumpFile() method to atomically write files\n\n2.2.0\n-----\n\n * added a delete option for the mirror() method\n\n2.1.0\n-----\n\n * 24eb396 : BC Break : mkdir() function now throws exception in case of failure instead of returning Boolean value\n * created the component\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Filesystem.php",
          "type": "blob",
          "size": 29.3828125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Filesystem;\n\nuse Symfony\\Component\\Filesystem\\Exception\\FileNotFoundException;\nuse Symfony\\Component\\Filesystem\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Filesystem\\Exception\\IOException;\n\n/**\n * Provides basic utility to manipulate the file system.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Filesystem\n{\n    private static ?string $lastError = null;\n\n    /**\n     * Copies a file.\n     *\n     * If the target file is older than the origin file, it's always overwritten.\n     * If the target file is newer, it is overwritten only when the\n     * $overwriteNewerFiles option is set to true.\n     *\n     * @throws FileNotFoundException When originFile doesn't exist\n     * @throws IOException           When copy fails\n     */\n    public function copy(string $originFile, string $targetFile, bool $overwriteNewerFiles = false): void\n    {\n        $originIsLocal = stream_is_local($originFile) || 0 === stripos($originFile, 'file://');\n        if ($originIsLocal && !is_file($originFile)) {\n            throw new FileNotFoundException(\\sprintf('Failed to copy \"%s\" because file does not exist.', $originFile), 0, null, $originFile);\n        }\n\n        $this->mkdir(\\dirname($targetFile));\n\n        $doCopy = true;\n        if (!$overwriteNewerFiles && !parse_url($originFile, \\PHP_URL_HOST) && is_file($targetFile)) {\n            $doCopy = filemtime($originFile) > filemtime($targetFile);\n        }\n\n        if ($doCopy) {\n            // https://bugs.php.net/64634\n            if (!$source = self::box('fopen', $originFile, 'r')) {\n                throw new IOException(\\sprintf('Failed to copy \"%s\" to \"%s\" because source file could not be opened for reading: ', $originFile, $targetFile).self::$lastError, 0, null, $originFile);\n            }\n\n            // Stream context created to allow files overwrite when using FTP stream wrapper - disabled by default\n            if (!$target = self::box('fopen', $targetFile, 'w', false, stream_context_create(['ftp' => ['overwrite' => true]]))) {\n                throw new IOException(\\sprintf('Failed to copy \"%s\" to \"%s\" because target file could not be opened for writing: ', $originFile, $targetFile).self::$lastError, 0, null, $originFile);\n            }\n\n            $bytesCopied = stream_copy_to_stream($source, $target);\n            fclose($source);\n            fclose($target);\n            unset($source, $target);\n\n            if (!is_file($targetFile)) {\n                throw new IOException(\\sprintf('Failed to copy \"%s\" to \"%s\".', $originFile, $targetFile), 0, null, $originFile);\n            }\n\n            if ($originIsLocal) {\n                // Like `cp`, preserve executable permission bits\n                self::box('chmod', $targetFile, fileperms($targetFile) | (fileperms($originFile) & 0111));\n\n                // Like `cp`, preserve the file modification time\n                self::box('touch', $targetFile, filemtime($originFile));\n\n                if ($bytesCopied !== $bytesOrigin = filesize($originFile)) {\n                    throw new IOException(\\sprintf('Failed to copy the whole content of \"%s\" to \"%s\" (%g of %g bytes copied).', $originFile, $targetFile, $bytesCopied, $bytesOrigin), 0, null, $originFile);\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates a directory recursively.\n     *\n     * @throws IOException On any directory creation failure\n     */\n    public function mkdir(string|iterable $dirs, int $mode = 0777): void\n    {\n        foreach ($this->toIterable($dirs) as $dir) {\n            if (is_dir($dir)) {\n                continue;\n            }\n\n            if (!self::box('mkdir', $dir, $mode, true) && !is_dir($dir)) {\n                throw new IOException(\\sprintf('Failed to create \"%s\": ', $dir).self::$lastError, 0, null, $dir);\n            }\n        }\n    }\n\n    /**\n     * Checks the existence of files or directories.\n     */\n    public function exists(string|iterable $files): bool\n    {\n        $maxPathLength = \\PHP_MAXPATHLEN - 2;\n\n        foreach ($this->toIterable($files) as $file) {\n            if (\\strlen($file) > $maxPathLength) {\n                throw new IOException(\\sprintf('Could not check if file exist because path length exceeds %d characters.', $maxPathLength), 0, null, $file);\n            }\n\n            if (!file_exists($file)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Sets access and modification time of file.\n     *\n     * @param int|null $time  The touch time as a Unix timestamp, if not supplied the current system time is used\n     * @param int|null $atime The access time as a Unix timestamp, if not supplied the current system time is used\n     *\n     * @throws IOException When touch fails\n     */\n    public function touch(string|iterable $files, ?int $time = null, ?int $atime = null): void\n    {\n        foreach ($this->toIterable($files) as $file) {\n            if (!($time ? self::box('touch', $file, $time, $atime) : self::box('touch', $file))) {\n                throw new IOException(\\sprintf('Failed to touch \"%s\": ', $file).self::$lastError, 0, null, $file);\n            }\n        }\n    }\n\n    /**\n     * Removes files or directories.\n     *\n     * @throws IOException When removal fails\n     */\n    public function remove(string|iterable $files): void\n    {\n        if ($files instanceof \\Traversable) {\n            $files = iterator_to_array($files, false);\n        } elseif (!\\is_array($files)) {\n            $files = [$files];\n        }\n\n        self::doRemove($files, false);\n    }\n\n    private static function doRemove(array $files, bool $isRecursive): void\n    {\n        $files = array_reverse($files);\n        foreach ($files as $file) {\n            if (is_link($file)) {\n                // See https://bugs.php.net/52176\n                if (!(self::box('unlink', $file) || '\\\\' !== \\DIRECTORY_SEPARATOR || self::box('rmdir', $file)) && file_exists($file)) {\n                    throw new IOException(\\sprintf('Failed to remove symlink \"%s\": ', $file).self::$lastError);\n                }\n            } elseif (is_dir($file)) {\n                if (!$isRecursive) {\n                    $tmpName = \\dirname(realpath($file)).'/.!'.strrev(strtr(base64_encode(random_bytes(2)), '/=', '-!'));\n\n                    if (file_exists($tmpName)) {\n                        try {\n                            self::doRemove([$tmpName], true);\n                        } catch (IOException) {\n                        }\n                    }\n\n                    if (!file_exists($tmpName) && self::box('rename', $file, $tmpName)) {\n                        $origFile = $file;\n                        $file = $tmpName;\n                    } else {\n                        $origFile = null;\n                    }\n                }\n\n                $filesystemIterator = new \\FilesystemIterator($file, \\FilesystemIterator::CURRENT_AS_PATHNAME | \\FilesystemIterator::SKIP_DOTS);\n                self::doRemove(iterator_to_array($filesystemIterator, true), true);\n\n                if (!self::box('rmdir', $file) && file_exists($file) && !$isRecursive) {\n                    $lastError = self::$lastError;\n\n                    if (null !== $origFile && self::box('rename', $file, $origFile)) {\n                        $file = $origFile;\n                    }\n\n                    throw new IOException(\\sprintf('Failed to remove directory \"%s\": ', $file).$lastError);\n                }\n            } elseif (!self::box('unlink', $file) && ((self::$lastError && str_contains(self::$lastError, 'Permission denied')) || file_exists($file))) {\n                throw new IOException(\\sprintf('Failed to remove file \"%s\": ', $file).self::$lastError);\n            }\n        }\n    }\n\n    /**\n     * Change mode for an array of files or directories.\n     *\n     * @param int  $mode      The new mode (octal)\n     * @param int  $umask     The mode mask (octal)\n     * @param bool $recursive Whether change the mod recursively or not\n     *\n     * @throws IOException When the change fails\n     */\n    public function chmod(string|iterable $files, int $mode, int $umask = 0000, bool $recursive = false): void\n    {\n        foreach ($this->toIterable($files) as $file) {\n            if (!self::box('chmod', $file, $mode & ~$umask)) {\n                throw new IOException(\\sprintf('Failed to chmod file \"%s\": ', $file).self::$lastError, 0, null, $file);\n            }\n            if ($recursive && is_dir($file) && !is_link($file)) {\n                $this->chmod(new \\FilesystemIterator($file), $mode, $umask, true);\n            }\n        }\n    }\n\n    /**\n     * Change the owner of an array of files or directories.\n     *\n     * This method always throws on Windows, as the underlying PHP function is not supported.\n     *\n     * @see https://www.php.net/chown\n     *\n     * @param string|int $user      A user name or number\n     * @param bool       $recursive Whether change the owner recursively or not\n     *\n     * @throws IOException When the change fails\n     */\n    public function chown(string|iterable $files, string|int $user, bool $recursive = false): void\n    {\n        foreach ($this->toIterable($files) as $file) {\n            if ($recursive && is_dir($file) && !is_link($file)) {\n                $this->chown(new \\FilesystemIterator($file), $user, true);\n            }\n            if (is_link($file) && \\function_exists('lchown')) {\n                if (!self::box('lchown', $file, $user)) {\n                    throw new IOException(\\sprintf('Failed to chown file \"%s\": ', $file).self::$lastError, 0, null, $file);\n                }\n            } else {\n                if (!self::box('chown', $file, $user)) {\n                    throw new IOException(\\sprintf('Failed to chown file \"%s\": ', $file).self::$lastError, 0, null, $file);\n                }\n            }\n        }\n    }\n\n    /**\n     * Change the group of an array of files or directories.\n     *\n     * This method always throws on Windows, as the underlying PHP function is not supported.\n     *\n     * @see https://www.php.net/chgrp\n     *\n     * @param string|int $group     A group name or number\n     * @param bool       $recursive Whether change the group recursively or not\n     *\n     * @throws IOException When the change fails\n     */\n    public function chgrp(string|iterable $files, string|int $group, bool $recursive = false): void\n    {\n        foreach ($this->toIterable($files) as $file) {\n            if ($recursive && is_dir($file) && !is_link($file)) {\n                $this->chgrp(new \\FilesystemIterator($file), $group, true);\n            }\n            if (is_link($file) && \\function_exists('lchgrp')) {\n                if (!self::box('lchgrp', $file, $group)) {\n                    throw new IOException(\\sprintf('Failed to chgrp file \"%s\": ', $file).self::$lastError, 0, null, $file);\n                }\n            } else {\n                if (!self::box('chgrp', $file, $group)) {\n                    throw new IOException(\\sprintf('Failed to chgrp file \"%s\": ', $file).self::$lastError, 0, null, $file);\n                }\n            }\n        }\n    }\n\n    /**\n     * Renames a file or a directory.\n     *\n     * @throws IOException When target file or directory already exists\n     * @throws IOException When origin cannot be renamed\n     */\n    public function rename(string $origin, string $target, bool $overwrite = false): void\n    {\n        // we check that target does not exist\n        if (!$overwrite && $this->isReadable($target)) {\n            throw new IOException(\\sprintf('Cannot rename because the target \"%s\" already exists.', $target), 0, null, $target);\n        }\n\n        if (!self::box('rename', $origin, $target)) {\n            if (is_dir($origin)) {\n                // See https://bugs.php.net/54097 & https://php.net/rename#113943\n                $this->mirror($origin, $target, null, ['override' => $overwrite, 'delete' => $overwrite]);\n                $this->remove($origin);\n\n                return;\n            }\n            throw new IOException(\\sprintf('Cannot rename \"%s\" to \"%s\": ', $origin, $target).self::$lastError, 0, null, $target);\n        }\n    }\n\n    /**\n     * Tells whether a file exists and is readable.\n     *\n     * @throws IOException When windows path is longer than 258 characters\n     */\n    private function isReadable(string $filename): bool\n    {\n        $maxPathLength = \\PHP_MAXPATHLEN - 2;\n\n        if (\\strlen($filename) > $maxPathLength) {\n            throw new IOException(\\sprintf('Could not check if file is readable because path length exceeds %d characters.', $maxPathLength), 0, null, $filename);\n        }\n\n        return is_readable($filename);\n    }\n\n    /**\n     * Creates a symbolic link or copy a directory.\n     *\n     * @throws IOException When symlink fails\n     */\n    public function symlink(string $originDir, string $targetDir, bool $copyOnWindows = false): void\n    {\n        self::assertFunctionExists('symlink');\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $originDir = strtr($originDir, '/', '\\\\');\n            $targetDir = strtr($targetDir, '/', '\\\\');\n\n            if ($copyOnWindows) {\n                $this->mirror($originDir, $targetDir);\n\n                return;\n            }\n        }\n\n        $this->mkdir(\\dirname($targetDir));\n\n        if (is_link($targetDir)) {\n            if (readlink($targetDir) === $originDir) {\n                return;\n            }\n            $this->remove($targetDir);\n        }\n\n        if (!self::box('symlink', $originDir, $targetDir)) {\n            $this->linkException($originDir, $targetDir, 'symbolic');\n        }\n    }\n\n    /**\n     * Creates a hard link, or several hard links to a file.\n     *\n     * @param string|string[] $targetFiles The target file(s)\n     *\n     * @throws FileNotFoundException When original file is missing or not a file\n     * @throws IOException           When link fails, including if link already exists\n     */\n    public function hardlink(string $originFile, string|iterable $targetFiles): void\n    {\n        self::assertFunctionExists('link');\n\n        if (!$this->exists($originFile)) {\n            throw new FileNotFoundException(null, 0, null, $originFile);\n        }\n\n        if (!is_file($originFile)) {\n            throw new FileNotFoundException(\\sprintf('Origin file \"%s\" is not a file.', $originFile));\n        }\n\n        foreach ($this->toIterable($targetFiles) as $targetFile) {\n            if (is_file($targetFile)) {\n                if (fileinode($originFile) === fileinode($targetFile)) {\n                    continue;\n                }\n                $this->remove($targetFile);\n            }\n\n            if (!self::box('link', $originFile, $targetFile)) {\n                $this->linkException($originFile, $targetFile, 'hard');\n            }\n        }\n    }\n\n    /**\n     * @param string $linkType Name of the link type, typically 'symbolic' or 'hard'\n     */\n    private function linkException(string $origin, string $target, string $linkType): never\n    {\n        if (self::$lastError) {\n            if ('\\\\' === \\DIRECTORY_SEPARATOR && str_contains(self::$lastError, 'error code(1314)')) {\n                throw new IOException(\\sprintf('Unable to create \"%s\" link due to error code 1314: \\'A required privilege is not held by the client\\'. Do you have the required Administrator-rights?', $linkType), 0, null, $target);\n            }\n        }\n        throw new IOException(\\sprintf('Failed to create \"%s\" link from \"%s\" to \"%s\": ', $linkType, $origin, $target).self::$lastError, 0, null, $target);\n    }\n\n    /**\n     * Resolves links in paths.\n     *\n     * With $canonicalize = false (default)\n     *      - if $path does not exist or is not a link, returns null\n     *      - if $path is a link, returns the next direct target of the link without considering the existence of the target\n     *\n     * With $canonicalize = true\n     *      - if $path does not exist, returns null\n     *      - if $path exists, returns its absolute fully resolved final version\n     */\n    public function readlink(string $path, bool $canonicalize = false): ?string\n    {\n        if (!$canonicalize && !is_link($path)) {\n            return null;\n        }\n\n        if ($canonicalize) {\n            if (!$this->exists($path)) {\n                return null;\n            }\n\n            return realpath($path);\n        }\n\n        return readlink($path);\n    }\n\n    /**\n     * Given an existing path, convert it to a path relative to a given starting path.\n     */\n    public function makePathRelative(string $endPath, string $startPath): string\n    {\n        if (!$this->isAbsolutePath($startPath)) {\n            throw new InvalidArgumentException(\\sprintf('The start path \"%s\" is not absolute.', $startPath));\n        }\n\n        if (!$this->isAbsolutePath($endPath)) {\n            throw new InvalidArgumentException(\\sprintf('The end path \"%s\" is not absolute.', $endPath));\n        }\n\n        // Normalize separators on Windows\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $endPath = str_replace('\\\\', '/', $endPath);\n            $startPath = str_replace('\\\\', '/', $startPath);\n        }\n\n        $splitDriveLetter = fn ($path) => (\\strlen($path) > 2 && ':' === $path[1] && '/' === $path[2] && ctype_alpha($path[0]))\n            ? [substr($path, 2), strtoupper($path[0])]\n            : [$path, null];\n\n        $splitPath = function ($path) {\n            $result = [];\n\n            foreach (explode('/', trim($path, '/')) as $segment) {\n                if ('..' === $segment) {\n                    array_pop($result);\n                } elseif ('.' !== $segment && '' !== $segment) {\n                    $result[] = $segment;\n                }\n            }\n\n            return $result;\n        };\n\n        [$endPath, $endDriveLetter] = $splitDriveLetter($endPath);\n        [$startPath, $startDriveLetter] = $splitDriveLetter($startPath);\n\n        $startPathArr = $splitPath($startPath);\n        $endPathArr = $splitPath($endPath);\n\n        if ($endDriveLetter && $startDriveLetter && $endDriveLetter != $startDriveLetter) {\n            // End path is on another drive, so no relative path exists\n            return $endDriveLetter.':/'.($endPathArr ? implode('/', $endPathArr).'/' : '');\n        }\n\n        // Find for which directory the common path stops\n        $index = 0;\n        while (isset($startPathArr[$index]) && isset($endPathArr[$index]) && $startPathArr[$index] === $endPathArr[$index]) {\n            ++$index;\n        }\n\n        // Determine how deep the start path is relative to the common path (ie, \"web/bundles\" = 2 levels)\n        if (1 === \\count($startPathArr) && '' === $startPathArr[0]) {\n            $depth = 0;\n        } else {\n            $depth = \\count($startPathArr) - $index;\n        }\n\n        // Repeated \"../\" for each level need to reach the common path\n        $traverser = str_repeat('../', $depth);\n\n        $endPathRemainder = implode('/', \\array_slice($endPathArr, $index));\n\n        // Construct $endPath from traversing to the common path, then to the remaining $endPath\n        $relativePath = $traverser.('' !== $endPathRemainder ? $endPathRemainder.'/' : '');\n\n        return '' === $relativePath ? './' : $relativePath;\n    }\n\n    /**\n     * Mirrors a directory to another.\n     *\n     * Copies files and directories from the origin directory into the target directory. By default:\n     *\n     *  - existing files in the target directory will be overwritten, except if they are newer (see the `override` option)\n     *  - files in the target directory that do not exist in the source directory will not be deleted (see the `delete` option)\n     *\n     * @param \\Traversable|null $iterator Iterator that filters which files and directories to copy, if null a recursive iterator is created\n     * @param array             $options  An array of boolean options\n     *                                    Valid options are:\n     *                                    - $options['override'] If true, target files newer than origin files are overwritten (see copy(), defaults to false)\n     *                                    - $options['copy_on_windows'] Whether to copy files instead of links on Windows (see symlink(), defaults to false)\n     *                                    - $options['delete'] Whether to delete files that are not in the source directory (defaults to false)\n     *\n     * @throws IOException When file type is unknown\n     */\n    public function mirror(string $originDir, string $targetDir, ?\\Traversable $iterator = null, array $options = []): void\n    {\n        $targetDir = rtrim($targetDir, '/\\\\');\n        $originDir = rtrim($originDir, '/\\\\');\n        $originDirLen = \\strlen($originDir);\n\n        if (!$this->exists($originDir)) {\n            throw new IOException(\\sprintf('The origin directory specified \"%s\" was not found.', $originDir), 0, null, $originDir);\n        }\n\n        // Iterate in destination folder to remove obsolete entries\n        if ($this->exists($targetDir) && isset($options['delete']) && $options['delete']) {\n            $deleteIterator = $iterator;\n            if (null === $deleteIterator) {\n                $flags = \\FilesystemIterator::SKIP_DOTS;\n                $deleteIterator = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($targetDir, $flags), \\RecursiveIteratorIterator::CHILD_FIRST);\n            }\n            $targetDirLen = \\strlen($targetDir);\n            foreach ($deleteIterator as $file) {\n                $origin = $originDir.substr($file->getPathname(), $targetDirLen);\n                if (!$this->exists($origin)) {\n                    $this->remove($file);\n                }\n            }\n        }\n\n        $copyOnWindows = $options['copy_on_windows'] ?? false;\n\n        if (null === $iterator) {\n            $flags = $copyOnWindows ? \\FilesystemIterator::SKIP_DOTS | \\FilesystemIterator::FOLLOW_SYMLINKS : \\FilesystemIterator::SKIP_DOTS;\n            $iterator = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($originDir, $flags), \\RecursiveIteratorIterator::SELF_FIRST);\n        }\n\n        $this->mkdir($targetDir);\n        $filesCreatedWhileMirroring = [];\n\n        foreach ($iterator as $file) {\n            if ($file->getPathname() === $targetDir || $file->getRealPath() === $targetDir || isset($filesCreatedWhileMirroring[$file->getRealPath()])) {\n                continue;\n            }\n\n            $target = $targetDir.substr($file->getPathname(), $originDirLen);\n            $filesCreatedWhileMirroring[$target] = true;\n\n            if (!$copyOnWindows && is_link($file)) {\n                $this->symlink($file->getLinkTarget(), $target);\n            } elseif (is_dir($file)) {\n                $this->mkdir($target);\n            } elseif (is_file($file)) {\n                $this->copy($file, $target, $options['override'] ?? false);\n            } else {\n                throw new IOException(\\sprintf('Unable to guess \"%s\" file type.', $file), 0, null, $file);\n            }\n        }\n    }\n\n    /**\n     * Returns whether the file path is an absolute path.\n     */\n    public function isAbsolutePath(string $file): bool\n    {\n        return '' !== $file && (strspn($file, '/\\\\', 0, 1)\n            || (\\strlen($file) > 3 && ctype_alpha($file[0])\n                && ':' === $file[1]\n                && strspn($file, '/\\\\', 2, 1)\n            )\n            || null !== parse_url($file, \\PHP_URL_SCHEME)\n        );\n    }\n\n    /**\n     * Creates a temporary file with support for custom stream wrappers.\n     *\n     * @param string $prefix The prefix of the generated temporary filename\n     *                       Note: Windows uses only the first three characters of prefix\n     * @param string $suffix The suffix of the generated temporary filename\n     *\n     * @return string The new temporary filename (with path), or throw an exception on failure\n     */\n    public function tempnam(string $dir, string $prefix, string $suffix = ''): string\n    {\n        [$scheme, $hierarchy] = $this->getSchemeAndHierarchy($dir);\n\n        // If no scheme or scheme is \"file\" or \"gs\" (Google Cloud) create temp file in local filesystem\n        if ((null === $scheme || 'file' === $scheme || 'gs' === $scheme) && '' === $suffix) {\n            // If tempnam failed or no scheme return the filename otherwise prepend the scheme\n            if ($tmpFile = self::box('tempnam', $hierarchy, $prefix)) {\n                if (null !== $scheme && 'gs' !== $scheme) {\n                    return $scheme.'://'.$tmpFile;\n                }\n\n                return $tmpFile;\n            }\n\n            throw new IOException('A temporary file could not be created: '.self::$lastError);\n        }\n\n        // Loop until we create a valid temp file or have reached 10 attempts\n        for ($i = 0; $i < 10; ++$i) {\n            // Create a unique filename\n            $tmpFile = $dir.'/'.$prefix.bin2hex(random_bytes(4)).$suffix;\n\n            // Use fopen instead of file_exists as some streams do not support stat\n            // Use mode 'x+' to atomically check existence and create to avoid a TOCTOU vulnerability\n            if (!$handle = self::box('fopen', $tmpFile, 'x+')) {\n                continue;\n            }\n\n            // Close the file if it was successfully opened\n            self::box('fclose', $handle);\n\n            return $tmpFile;\n        }\n\n        throw new IOException('A temporary file could not be created: '.self::$lastError);\n    }\n\n    /**\n     * Atomically dumps content into a file.\n     *\n     * @param string|resource $content The data to write into the file\n     *\n     * @throws IOException if the file cannot be written to\n     */\n    public function dumpFile(string $filename, $content): void\n    {\n        if (\\is_array($content)) {\n            throw new \\TypeError(\\sprintf('Argument 2 passed to \"%s()\" must be string or resource, array given.', __METHOD__));\n        }\n\n        $dir = \\dirname($filename);\n\n        if (is_link($filename) && $linkTarget = $this->readlink($filename)) {\n            $this->dumpFile(Path::makeAbsolute($linkTarget, $dir), $content);\n\n            return;\n        }\n\n        if (!is_dir($dir)) {\n            $this->mkdir($dir);\n        }\n\n        // Will create a temp file with 0600 access rights\n        // when the filesystem supports chmod.\n        $tmpFile = $this->tempnam($dir, basename($filename));\n\n        try {\n            if (false === self::box('file_put_contents', $tmpFile, $content)) {\n                throw new IOException(\\sprintf('Failed to write file \"%s\": ', $filename).self::$lastError, 0, null, $filename);\n            }\n\n            self::box('chmod', $tmpFile, self::box('fileperms', $filename) ?: 0666 & ~umask());\n\n            $this->rename($tmpFile, $filename, true);\n        } finally {\n            if (file_exists($tmpFile)) {\n                if ('\\\\' === \\DIRECTORY_SEPARATOR && !is_writable($tmpFile)) {\n                    self::box('chmod', $tmpFile, self::box('fileperms', $tmpFile) | 0200);\n                }\n\n                self::box('unlink', $tmpFile);\n            }\n        }\n    }\n\n    /**\n     * Appends content to an existing file.\n     *\n     * @param string|resource $content The content to append\n     * @param bool            $lock    Whether the file should be locked when writing to it\n     *\n     * @throws IOException If the file is not writable\n     */\n    public function appendToFile(string $filename, $content, bool $lock = false): void\n    {\n        if (\\is_array($content)) {\n            throw new \\TypeError(\\sprintf('Argument 2 passed to \"%s()\" must be string or resource, array given.', __METHOD__));\n        }\n\n        $dir = \\dirname($filename);\n\n        if (!is_dir($dir)) {\n            $this->mkdir($dir);\n        }\n\n        if (false === self::box('file_put_contents', $filename, $content, \\FILE_APPEND | ($lock ? \\LOCK_EX : 0))) {\n            throw new IOException(\\sprintf('Failed to write file \"%s\": ', $filename).self::$lastError, 0, null, $filename);\n        }\n    }\n\n    /**\n     * Returns the content of a file as a string.\n     *\n     * @throws IOException If the file cannot be read\n     */\n    public function readFile(string $filename): string\n    {\n        if (is_dir($filename)) {\n            throw new IOException(\\sprintf('Failed to read file \"%s\": File is a directory.', $filename));\n        }\n\n        $content = self::box('file_get_contents', $filename);\n        if (false === $content) {\n            throw new IOException(\\sprintf('Failed to read file \"%s\": ', $filename).self::$lastError, 0, null, $filename);\n        }\n\n        return $content;\n    }\n\n    private function toIterable(string|iterable $files): iterable\n    {\n        return is_iterable($files) ? $files : [$files];\n    }\n\n    /**\n     * Gets a 2-tuple of scheme (may be null) and hierarchical part of a filename (e.g. file:///tmp -> [file, tmp]).\n     */\n    private function getSchemeAndHierarchy(string $filename): array\n    {\n        $components = explode('://', $filename, 2);\n\n        return 2 === \\count($components) ? [$components[0], $components[1]] : [null, $components[0]];\n    }\n\n    private static function assertFunctionExists(string $func): void\n    {\n        if (!\\function_exists($func)) {\n            throw new IOException(\\sprintf('Unable to perform filesystem operation because the \"%s()\" function has been disabled.', $func));\n        }\n    }\n\n    private static function box(string $func, mixed ...$args): mixed\n    {\n        self::assertFunctionExists($func);\n\n        self::$lastError = null;\n        set_error_handler(self::handleError(...));\n        try {\n            return $func(...$args);\n        } finally {\n            restore_error_handler();\n        }\n    }\n\n    /**\n     * @internal\n     */\n    public static function handleError(int $type, string $msg): void\n    {\n        self::$lastError = $msg;\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Path.php",
          "type": "blob",
          "size": 25.4072265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Filesystem;\n\nuse Symfony\\Component\\Filesystem\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Filesystem\\Exception\\RuntimeException;\n\n/**\n * Contains utility methods for handling path strings.\n *\n * The methods in this class are able to deal with both UNIX and Windows paths\n * with both forward and backward slashes. All methods return normalized parts\n * containing only forward slashes and no excess \".\" and \"..\" segments.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n * @author Thomas Schulz <mail@king2500.net>\n * @author Th√©o Fidry <theo.fidry@gmail.com>\n */\nfinal class Path\n{\n    /**\n     * The number of buffer entries that triggers a cleanup operation.\n     */\n    private const CLEANUP_THRESHOLD = 1250;\n\n    /**\n     * The buffer size after the cleanup operation.\n     */\n    private const CLEANUP_SIZE = 1000;\n\n    /**\n     * Buffers input/output of {@link canonicalize()}.\n     *\n     * @var array<string, string>\n     */\n    private static array $buffer = [];\n\n    private static int $bufferSize = 0;\n\n    /**\n     * Canonicalizes the given path.\n     *\n     * During normalization, all slashes are replaced by forward slashes (\"/\").\n     * Furthermore, all \".\" and \"..\" segments are removed as far as possible.\n     * \"..\" segments at the beginning of relative paths are not removed.\n     *\n     * ```php\n     * echo Path::canonicalize(\"\\symfony\\puli\\..\\css\\style.css\");\n     * // => /symfony/css/style.css\n     *\n     * echo Path::canonicalize(\"../css/./style.css\");\n     * // => ../css/style.css\n     * ```\n     *\n     * This method is able to deal with both UNIX and Windows paths.\n     */\n    public static function canonicalize(string $path): string\n    {\n        if ('' === $path) {\n            return '';\n        }\n\n        // This method is called by many other methods in this class. Buffer\n        // the canonicalized paths to make up for the severe performance\n        // decrease.\n        if (isset(self::$buffer[$path])) {\n            return self::$buffer[$path];\n        }\n\n        // Replace \"~\" with user's home directory.\n        if ('~' === $path[0]) {\n            $path = self::getHomeDirectory().substr($path, 1);\n        }\n\n        $path = self::normalize($path);\n\n        [$root, $pathWithoutRoot] = self::split($path);\n\n        $canonicalParts = self::findCanonicalParts($root, $pathWithoutRoot);\n\n        // Add the root directory again\n        self::$buffer[$path] = $canonicalPath = $root.implode('/', $canonicalParts);\n        ++self::$bufferSize;\n\n        // Clean up regularly to prevent memory leaks\n        if (self::$bufferSize > self::CLEANUP_THRESHOLD) {\n            self::$buffer = \\array_slice(self::$buffer, -self::CLEANUP_SIZE, null, true);\n            self::$bufferSize = self::CLEANUP_SIZE;\n        }\n\n        return $canonicalPath;\n    }\n\n    /**\n     * Normalizes the given path.\n     *\n     * During normalization, all slashes are replaced by forward slashes (\"/\").\n     * Contrary to {@link canonicalize()}, this method does not remove invalid\n     * or dot path segments. Consequently, it is much more efficient and should\n     * be used whenever the given path is known to be a valid, absolute system\n     * path.\n     *\n     * This method is able to deal with both UNIX and Windows paths.\n     */\n    public static function normalize(string $path): string\n    {\n        return str_replace('\\\\', '/', $path);\n    }\n\n    /**\n     * Returns the directory part of the path.\n     *\n     * This method is similar to PHP's dirname(), but handles various cases\n     * where dirname() returns a weird result:\n     *\n     *  - dirname() does not accept backslashes on UNIX\n     *  - dirname(\"C:/symfony\") returns \"C:\", not \"C:/\"\n     *  - dirname(\"C:/\") returns \".\", not \"C:/\"\n     *  - dirname(\"C:\") returns \".\", not \"C:/\"\n     *  - dirname(\"symfony\") returns \".\", not \"\"\n     *  - dirname() does not canonicalize the result\n     *\n     * This method fixes these shortcomings and behaves like dirname()\n     * otherwise.\n     *\n     * The result is a canonical path.\n     *\n     * @return string The canonical directory part. Returns the root directory\n     *                if the root directory is passed. Returns an empty string\n     *                if a relative path is passed that contains no slashes.\n     *                Returns an empty string if an empty string is passed.\n     */\n    public static function getDirectory(string $path): string\n    {\n        if ('' === $path) {\n            return '';\n        }\n\n        $path = self::canonicalize($path);\n\n        // Maintain scheme\n        if (false !== $schemeSeparatorPosition = strpos($path, '://')) {\n            $scheme = substr($path, 0, $schemeSeparatorPosition + 3);\n            $path = substr($path, $schemeSeparatorPosition + 3);\n        } else {\n            $scheme = '';\n        }\n\n        if (false === $dirSeparatorPosition = strrpos($path, '/')) {\n            return '';\n        }\n\n        // Directory equals root directory \"/\"\n        if (0 === $dirSeparatorPosition) {\n            return $scheme.'/';\n        }\n\n        // Directory equals Windows root \"C:/\"\n        if (2 === $dirSeparatorPosition && ctype_alpha($path[0]) && ':' === $path[1]) {\n            return $scheme.substr($path, 0, 3);\n        }\n\n        return $scheme.substr($path, 0, $dirSeparatorPosition);\n    }\n\n    /**\n     * Returns canonical path of the user's home directory.\n     *\n     * Supported operating systems:\n     *\n     *  - UNIX\n     *  - Windows8 and upper\n     *\n     * If your operating system or environment isn't supported, an exception is thrown.\n     *\n     * The result is a canonical path.\n     *\n     * @throws RuntimeException If your operating system or environment isn't supported\n     */\n    public static function getHomeDirectory(): string\n    {\n        // For UNIX support\n        if (getenv('HOME')) {\n            return self::canonicalize(getenv('HOME'));\n        }\n\n        // For >= Windows8 support\n        if (getenv('HOMEDRIVE') && getenv('HOMEPATH')) {\n            return self::canonicalize(getenv('HOMEDRIVE').getenv('HOMEPATH'));\n        }\n\n        throw new RuntimeException(\"Cannot find the home directory path: Your environment or operating system isn't supported.\");\n    }\n\n    /**\n     * Returns the root directory of a path.\n     *\n     * The result is a canonical path.\n     *\n     * @return string The canonical root directory. Returns an empty string if\n     *                the given path is relative or empty.\n     */\n    public static function getRoot(string $path): string\n    {\n        if ('' === $path) {\n            return '';\n        }\n\n        // Maintain scheme\n        if (false !== $schemeSeparatorPosition = strpos($path, '://')) {\n            $scheme = substr($path, 0, $schemeSeparatorPosition + 3);\n            $path = substr($path, $schemeSeparatorPosition + 3);\n        } else {\n            $scheme = '';\n        }\n\n        $firstCharacter = $path[0];\n\n        // UNIX root \"/\" or \"\\\" (Windows style)\n        if ('/' === $firstCharacter || '\\\\' === $firstCharacter) {\n            return $scheme.'/';\n        }\n\n        $length = \\strlen($path);\n\n        // Windows root\n        if ($length > 1 && ':' === $path[1] && ctype_alpha($firstCharacter)) {\n            // Special case: \"C:\"\n            if (2 === $length) {\n                return $scheme.$path.'/';\n            }\n\n            // Normal case: \"C:/ or \"C:\\\"\n            if ('/' === $path[2] || '\\\\' === $path[2]) {\n                return $scheme.$firstCharacter.$path[1].'/';\n            }\n        }\n\n        return '';\n    }\n\n    /**\n     * Returns the file name without the extension from a file path.\n     *\n     * @param string|null $extension if specified, only that extension is cut\n     *                               off (may contain leading dot)\n     */\n    public static function getFilenameWithoutExtension(string $path, ?string $extension = null): string\n    {\n        if ('' === $path) {\n            return '';\n        }\n\n        if (null !== $extension) {\n            // remove extension and trailing dot\n            return rtrim(basename($path, $extension), '.');\n        }\n\n        return pathinfo($path, \\PATHINFO_FILENAME);\n    }\n\n    /**\n     * Returns the extension from a file path (without leading dot).\n     *\n     * @param bool $forceLowerCase forces the extension to be lower-case\n     */\n    public static function getExtension(string $path, bool $forceLowerCase = false): string\n    {\n        if ('' === $path) {\n            return '';\n        }\n\n        $extension = pathinfo($path, \\PATHINFO_EXTENSION);\n\n        if ($forceLowerCase) {\n            $extension = self::toLower($extension);\n        }\n\n        return $extension;\n    }\n\n    /**\n     * Returns whether the path has an (or the specified) extension.\n     *\n     * @param string               $path       the path string\n     * @param string|string[]|null $extensions if null or not provided, checks if\n     *                                         an extension exists, otherwise\n     *                                         checks for the specified extension\n     *                                         or array of extensions (with or\n     *                                         without leading dot)\n     * @param bool                 $ignoreCase whether to ignore case-sensitivity\n     */\n    public static function hasExtension(string $path, $extensions = null, bool $ignoreCase = false): bool\n    {\n        if ('' === $path) {\n            return false;\n        }\n\n        $actualExtension = self::getExtension($path, $ignoreCase);\n\n        // Only check if path has any extension\n        if ([] === $extensions || null === $extensions) {\n            return '' !== $actualExtension;\n        }\n\n        if (\\is_string($extensions)) {\n            $extensions = [$extensions];\n        }\n\n        foreach ($extensions as $key => $extension) {\n            if ($ignoreCase) {\n                $extension = self::toLower($extension);\n            }\n\n            // remove leading '.' in extensions array\n            $extensions[$key] = ltrim($extension, '.');\n        }\n\n        return \\in_array($actualExtension, $extensions, true);\n    }\n\n    /**\n     * Changes the extension of a path string.\n     *\n     * @param string $path      The path string with filename.ext to change.\n     * @param string $extension new extension (with or without leading dot)\n     *\n     * @return string the path string with new file extension\n     */\n    public static function changeExtension(string $path, string $extension): string\n    {\n        if ('' === $path) {\n            return '';\n        }\n\n        $actualExtension = self::getExtension($path);\n        $extension = ltrim($extension, '.');\n\n        // No extension for paths\n        if (str_ends_with($path, '/')) {\n            return $path;\n        }\n\n        // No actual extension in path\n        if (!$actualExtension) {\n            return $path.(str_ends_with($path, '.') ? '' : '.').$extension;\n        }\n\n        return substr($path, 0, -\\strlen($actualExtension)).$extension;\n    }\n\n    public static function isAbsolute(string $path): bool\n    {\n        if ('' === $path) {\n            return false;\n        }\n\n        // Strip scheme\n        if (false !== ($schemeSeparatorPosition = strpos($path, '://')) && 1 !== $schemeSeparatorPosition) {\n            $path = substr($path, $schemeSeparatorPosition + 3);\n        }\n\n        $firstCharacter = $path[0];\n\n        // UNIX root \"/\" or \"\\\" (Windows style)\n        if ('/' === $firstCharacter || '\\\\' === $firstCharacter) {\n            return true;\n        }\n\n        // Windows root\n        if (\\strlen($path) > 1 && ctype_alpha($firstCharacter) && ':' === $path[1]) {\n            // Special case: \"C:\"\n            if (2 === \\strlen($path)) {\n                return true;\n            }\n\n            // Normal case: \"C:/ or \"C:\\\"\n            if ('/' === $path[2] || '\\\\' === $path[2]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static function isRelative(string $path): bool\n    {\n        return !self::isAbsolute($path);\n    }\n\n    /**\n     * Turns a relative path into an absolute path in canonical form.\n     *\n     * Usually, the relative path is appended to the given base path. Dot\n     * segments (\".\" and \"..\") are removed/collapsed and all slashes turned\n     * into forward slashes.\n     *\n     * ```php\n     * echo Path::makeAbsolute(\"../style.css\", \"/symfony/puli/css\");\n     * // => /symfony/puli/style.css\n     * ```\n     *\n     * If an absolute path is passed, that path is returned unless its root\n     * directory is different than the one of the base path. In that case, an\n     * exception is thrown.\n     *\n     * ```php\n     * Path::makeAbsolute(\"/style.css\", \"/symfony/puli/css\");\n     * // => /style.css\n     *\n     * Path::makeAbsolute(\"C:/style.css\", \"C:/symfony/puli/css\");\n     * // => C:/style.css\n     *\n     * Path::makeAbsolute(\"C:/style.css\", \"/symfony/puli/css\");\n     * // InvalidArgumentException\n     * ```\n     *\n     * If the base path is not an absolute path, an exception is thrown.\n     *\n     * The result is a canonical path.\n     *\n     * @param string $basePath an absolute base path\n     *\n     * @throws InvalidArgumentException if the base path is not absolute or if\n     *                                  the given path is an absolute path with\n     *                                  a different root than the base path\n     */\n    public static function makeAbsolute(string $path, string $basePath): string\n    {\n        if ('' === $basePath) {\n            throw new InvalidArgumentException(\\sprintf('The base path must be a non-empty string. Got: \"%s\".', $basePath));\n        }\n\n        if (!self::isAbsolute($basePath)) {\n            throw new InvalidArgumentException(\\sprintf('The base path \"%s\" is not an absolute path.', $basePath));\n        }\n\n        if (self::isAbsolute($path)) {\n            return self::canonicalize($path);\n        }\n\n        if (false !== $schemeSeparatorPosition = strpos($basePath, '://')) {\n            $scheme = substr($basePath, 0, $schemeSeparatorPosition + 3);\n            $basePath = substr($basePath, $schemeSeparatorPosition + 3);\n        } else {\n            $scheme = '';\n        }\n\n        return $scheme.self::canonicalize(rtrim($basePath, '/\\\\').'/'.$path);\n    }\n\n    /**\n     * Turns a path into a relative path.\n     *\n     * The relative path is created relative to the given base path:\n     *\n     * ```php\n     * echo Path::makeRelative(\"/symfony/style.css\", \"/symfony/puli\");\n     * // => ../style.css\n     * ```\n     *\n     * If a relative path is passed and the base path is absolute, the relative\n     * path is returned unchanged:\n     *\n     * ```php\n     * Path::makeRelative(\"style.css\", \"/symfony/puli/css\");\n     * // => style.css\n     * ```\n     *\n     * If both paths are relative, the relative path is created with the\n     * assumption that both paths are relative to the same directory:\n     *\n     * ```php\n     * Path::makeRelative(\"style.css\", \"symfony/puli/css\");\n     * // => ../../../style.css\n     * ```\n     *\n     * If both paths are absolute, their root directory must be the same,\n     * otherwise an exception is thrown:\n     *\n     * ```php\n     * Path::makeRelative(\"C:/symfony/style.css\", \"/symfony/puli\");\n     * // InvalidArgumentException\n     * ```\n     *\n     * If the passed path is absolute, but the base path is not, an exception\n     * is thrown as well:\n     *\n     * ```php\n     * Path::makeRelative(\"/symfony/style.css\", \"symfony/puli\");\n     * // InvalidArgumentException\n     * ```\n     *\n     * If the base path is not an absolute path, an exception is thrown.\n     *\n     * The result is a canonical path.\n     *\n     * @throws InvalidArgumentException if the base path is not absolute or if\n     *                                  the given path has a different root\n     *                                  than the base path\n     */\n    public static function makeRelative(string $path, string $basePath): string\n    {\n        $path = self::canonicalize($path);\n        $basePath = self::canonicalize($basePath);\n\n        [$root, $relativePath] = self::split($path);\n        [$baseRoot, $relativeBasePath] = self::split($basePath);\n\n        // If the base path is given as absolute path and the path is already\n        // relative, consider it to be relative to the given absolute path\n        // already\n        if ('' === $root && '' !== $baseRoot) {\n            // If base path is already in its root\n            if ('' === $relativeBasePath) {\n                $relativePath = ltrim($relativePath, './\\\\');\n            }\n\n            return $relativePath;\n        }\n\n        // If the passed path is absolute, but the base path is not, we\n        // cannot generate a relative path\n        if ('' !== $root && '' === $baseRoot) {\n            throw new InvalidArgumentException(\\sprintf('The absolute path \"%s\" cannot be made relative to the relative path \"%s\". You should provide an absolute base path instead.', $path, $basePath));\n        }\n\n        // Fail if the roots of the two paths are different\n        if ($baseRoot && $root !== $baseRoot) {\n            throw new InvalidArgumentException(\\sprintf('The path \"%s\" cannot be made relative to \"%s\", because they have different roots (\"%s\" and \"%s\").', $path, $basePath, $root, $baseRoot));\n        }\n\n        if ('' === $relativeBasePath) {\n            return $relativePath;\n        }\n\n        // Build a \"../../\" prefix with as many \"../\" parts as necessary\n        $parts = explode('/', $relativePath);\n        $baseParts = explode('/', $relativeBasePath);\n        $dotDotPrefix = '';\n\n        // Once we found a non-matching part in the prefix, we need to add\n        // \"../\" parts for all remaining parts\n        $match = true;\n\n        foreach ($baseParts as $index => $basePart) {\n            if ($match && isset($parts[$index]) && $basePart === $parts[$index]) {\n                unset($parts[$index]);\n\n                continue;\n            }\n\n            $match = false;\n            $dotDotPrefix .= '../';\n        }\n\n        return rtrim($dotDotPrefix.implode('/', $parts), '/');\n    }\n\n    /**\n     * Returns whether the given path is on the local filesystem.\n     */\n    public static function isLocal(string $path): bool\n    {\n        return '' !== $path && !str_contains($path, '://');\n    }\n\n    /**\n     * Returns the longest common base path in canonical form of a set of paths or\n     * `null` if the paths are on different Windows partitions.\n     *\n     * Dot segments (\".\" and \"..\") are removed/collapsed and all slashes turned\n     * into forward slashes.\n     *\n     * ```php\n     * $basePath = Path::getLongestCommonBasePath(\n     *     '/symfony/css/style.css',\n     *     '/symfony/css/..'\n     * );\n     * // => /symfony\n     * ```\n     *\n     * The root is returned if no common base path can be found:\n     *\n     * ```php\n     * $basePath = Path::getLongestCommonBasePath(\n     *     '/symfony/css/style.css',\n     *     '/puli/css/..'\n     * );\n     * // => /\n     * ```\n     *\n     * If the paths are located on different Windows partitions, `null` is\n     * returned.\n     *\n     * ```php\n     * $basePath = Path::getLongestCommonBasePath(\n     *     'C:/symfony/css/style.css',\n     *     'D:/symfony/css/..'\n     * );\n     * // => null\n     * ```\n     */\n    public static function getLongestCommonBasePath(string ...$paths): ?string\n    {\n        [$bpRoot, $basePath] = self::split(self::canonicalize(reset($paths)));\n\n        for (next($paths); null !== key($paths) && '' !== $basePath; next($paths)) {\n            [$root, $path] = self::split(self::canonicalize(current($paths)));\n\n            // If we deal with different roots (e.g. C:/ vs. D:/), it's time\n            // to quit\n            if ($root !== $bpRoot) {\n                return null;\n            }\n\n            // Make the base path shorter until it fits into path\n            while (true) {\n                if ('.' === $basePath) {\n                    // No more base paths\n                    $basePath = '';\n\n                    // next path\n                    continue 2;\n                }\n\n                // Prevent false positives for common prefixes\n                // see isBasePath()\n                if (str_starts_with($path.'/', $basePath.'/')) {\n                    // next path\n                    continue 2;\n                }\n\n                $basePath = \\dirname($basePath);\n            }\n        }\n\n        return $bpRoot.$basePath;\n    }\n\n    /**\n     * Joins two or more path strings into a canonical path.\n     */\n    public static function join(string ...$paths): string\n    {\n        $finalPath = null;\n        $wasScheme = false;\n\n        foreach ($paths as $path) {\n            if ('' === $path) {\n                continue;\n            }\n\n            if (null === $finalPath) {\n                // For first part we keep slashes, like '/top', 'C:\\' or 'phar://'\n                $finalPath = $path;\n                $wasScheme = str_contains($path, '://');\n                continue;\n            }\n\n            // Only add slash if previous part didn't end with '/' or '\\'\n            if (!\\in_array(substr($finalPath, -1), ['/', '\\\\'], true)) {\n                $finalPath .= '/';\n            }\n\n            // If first part included a scheme like 'phar://' we allow \\current part to start with '/', otherwise trim\n            $finalPath .= $wasScheme ? $path : ltrim($path, '/');\n            $wasScheme = false;\n        }\n\n        if (null === $finalPath) {\n            return '';\n        }\n\n        return self::canonicalize($finalPath);\n    }\n\n    /**\n     * Returns whether a path is a base path of another path.\n     *\n     * Dot segments (\".\" and \"..\") are removed/collapsed and all slashes turned\n     * into forward slashes.\n     *\n     * ```php\n     * Path::isBasePath('/symfony', '/symfony/css');\n     * // => true\n     *\n     * Path::isBasePath('/symfony', '/symfony');\n     * // => true\n     *\n     * Path::isBasePath('/symfony', '/symfony/..');\n     * // => false\n     *\n     * Path::isBasePath('/symfony', '/puli');\n     * // => false\n     * ```\n     */\n    public static function isBasePath(string $basePath, string $ofPath): bool\n    {\n        $basePath = self::canonicalize($basePath);\n        $ofPath = self::canonicalize($ofPath);\n\n        // Append slashes to prevent false positives when two paths have\n        // a common prefix, for example /base/foo and /base/foobar.\n        // Don't append a slash for the root \"/\", because then that root\n        // won't be discovered as common prefix (\"//\" is not a prefix of\n        // \"/foobar/\").\n        return str_starts_with($ofPath.'/', rtrim($basePath, '/').'/');\n    }\n\n    /**\n     * @return string[]\n     */\n    private static function findCanonicalParts(string $root, string $pathWithoutRoot): array\n    {\n        $parts = explode('/', $pathWithoutRoot);\n\n        $canonicalParts = [];\n\n        // Collapse \".\" and \"..\", if possible\n        foreach ($parts as $part) {\n            if ('.' === $part || '' === $part) {\n                continue;\n            }\n\n            // Collapse \"..\" with the previous part, if one exists\n            // Don't collapse \"..\" if the previous part is also \"..\"\n            if ('..' === $part && \\count($canonicalParts) > 0 && '..' !== $canonicalParts[\\count($canonicalParts) - 1]) {\n                array_pop($canonicalParts);\n\n                continue;\n            }\n\n            // Only add \"..\" prefixes for relative paths\n            if ('..' !== $part || '' === $root) {\n                $canonicalParts[] = $part;\n            }\n        }\n\n        return $canonicalParts;\n    }\n\n    /**\n     * Splits a canonical path into its root directory and the remainder.\n     *\n     * If the path has no root directory, an empty root directory will be\n     * returned.\n     *\n     * If the root directory is a Windows style partition, the resulting root\n     * will always contain a trailing slash.\n     *\n     * list ($root, $path) = Path::split(\"C:/symfony\")\n     * // => [\"C:/\", \"symfony\"]\n     *\n     * list ($root, $path) = Path::split(\"C:\")\n     * // => [\"C:/\", \"\"]\n     *\n     * @return array{string, string} an array with the root directory and the remaining relative path\n     */\n    private static function split(string $path): array\n    {\n        if ('' === $path) {\n            return ['', ''];\n        }\n\n        // Remember scheme as part of the root, if any\n        if (false !== $schemeSeparatorPosition = strpos($path, '://')) {\n            $root = substr($path, 0, $schemeSeparatorPosition + 3);\n            $path = substr($path, $schemeSeparatorPosition + 3);\n        } else {\n            $root = '';\n        }\n\n        $length = \\strlen($path);\n\n        // Remove and remember root directory\n        if (str_starts_with($path, '/')) {\n            $root .= '/';\n            $path = $length > 1 ? substr($path, 1) : '';\n        } elseif ($length > 1 && ctype_alpha($path[0]) && ':' === $path[1]) {\n            if (2 === $length) {\n                // Windows special case: \"C:\"\n                $root .= $path.'/';\n                $path = '';\n            } elseif ('/' === $path[2]) {\n                // Windows normal case: \"C:/\"..\n                $root .= substr($path, 0, 3);\n                $path = $length > 3 ? substr($path, 3) : '';\n            }\n        }\n\n        return [$root, $path];\n    }\n\n    private static function toLower(string $string): string\n    {\n        if (false !== $encoding = mb_detect_encoding($string, null, true)) {\n            return mb_strtolower($string, $encoding);\n        }\n\n        return strtolower($string);\n    }\n\n    private function __construct()\n    {\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.4814453125,
          "content": "Filesystem Component\n====================\n\nThe Filesystem component provides basic utilities for the filesystem.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/filesystem.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.8203125,
          "content": "{\n    \"name\": \"symfony/filesystem\",\n    \"type\": \"library\",\n    \"description\": \"Provides basic utilities for the filesystem\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/polyfill-ctype\": \"~1.8\",\n        \"symfony/polyfill-mbstring\": \"~1.8\"\n    },\n    \"require-dev\": {\n        \"symfony/process\": \"^6.4|^7.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Filesystem\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.8017578125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Filesystem Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}