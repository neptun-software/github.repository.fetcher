{
  "metadata": {
    "timestamp": 1736712134014,
    "page": 748,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jacklul/pihole-updatelists",
      "stars": 1463,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.046875,
          "content": "build*.conf\nmanifest-*.json\nDockerfile_*\n.idea/\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.4111328125,
          "content": "FROM pihole/pihole:latest\n\nCOPY install.sh docker.sh pihole-updatelists.* /tmp/pihole-updatelists/\n\nRUN apt-get update && \\\n    apt-get install -Vy wget php-cli php-sqlite3 php-intl php-curl && \\\n    apt-get clean && \\\n    rm -fr /var/cache/apt/* /var/lib/apt/lists/*.lz4 && \\\n    chmod +x /tmp/pihole-updatelists/install.sh && \\\n    bash /tmp/pihole-updatelists/install.sh docker && \\\n    rm -fr /tmp/pihole-updatelists\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0673828125,
          "content": "MIT License\n\nCopyright (c) 2021 Jack'lul <https://jacklul.github.io>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.8525390625,
          "content": "# Update Pi-hole's lists from remote sources\n\nWhen using remote lists like [this](https://v.firebog.net/hosts/lists.php?type=tick) or [this](https://raw.githubusercontent.com/anudeepND/whitelist/master/domains/whitelist.txt) it's a hassle to manually check for changes and update - this script will do that for you!\n\nUser-created entries will not be touched and those removed from the remote list will be disabled instead.\n\n__If you're not using remote lists like the ones mentioned above then this script will be useless to you - Pi-hole already updates the lists weekly automatically.__\n\n## Requirements\n\n- **Pi-hole V5** installed (fresh install preferred)\n- **php-cli >=7.0** and **a few extensions** (`sudo apt-get install php-cli php-sqlite3 php-intl php-curl`)\n- **systemd** is optional but recommended\n\n## Install\n\n_Docker users - [look below](#install-with-docker)._\n\nThis command will install this script to `/usr/local/sbin`:\n\n```bash\nwget -O - https://raw.githubusercontent.com/jacklul/pihole-updatelists/master/install.sh | sudo bash\n```\n\n_Alternatively you can clone this repo and `sudo bash install.sh`._\n\nIf **systemd** is available this script will also add service and timer unit files to the system, otherwise a crontab entry in `/etc/cron.d/pihole-updatelists` will be created.\n\nIf for some reasons the install script does not copy service and timer files while your distro has systemd scheduler available you can force the installation by passing `systemd` as a parameter to the install script - modifying the install command above with `sudo bash -s systemd` instead.\n\nNote that in most cases you will be able to execute this script globally as `pihole-updatelists` command but some will require you to add `/usr/local/sbin` to `$PATH` or execute it via `/usr/local/sbin/pihole-updatelists`.\n\n__This script does nothing by default (except running `pihole updateGravity`), you have to [configure it](#configuration).__\n\n**You can quickly update the script with `sudo pihole-updatelists --update` which checks for script difference and re-runs the install script when needed.**\n\n### Disable default gravity update schedule\n\n_If you don't plan on updating adlists or want to keep Pi-hole's gravity update schedule you should skip this section and set `UPDATE_GRAVITY=false` in the configuration file._\n\nYou should disable entry with `pihole updateGravity` command in `/etc/cron.d/pihole` as this script already runs it:\n\n```bash\nsudo nano /etc/cron.d/pihole\n```\nPut a `#` before this line (numbers might be different):\n```\n#49 4   * * 7   root    PATH=\"$PATH:/usr/local/bin/\" pihole updateGravity >/var/log/pihole_updateGravity.log || cat /var/log/pihole_updateGravity.log\n```\nAlternatively, the following `sed` command will disable the same entry:\n```bash\nsudo sed -e '/pihole updateGravity/ s/^#*/#/' -i /etc/cron.d/pihole\n```\n\n**You might have to do this after each Pi-hole update.**\n\nYou can override `pihole-FTL.service` to disable the cron entry automatically after each update:\n\n```bash\nsudo systemctl edit pihole-FTL.service\n```\n```\n[Service]\nExecStartPre=-/bin/sh -c \"[ -w /etc/cron.d/pihole ] && /bin/sed -e '/pihole updateGravity/ s/^#*/#/' -i /etc/cron.d/pihole\"\n```\n\n### Migrating lists and domains\n\nIf you already imported any of the remote lists manually you should migrate their entries to allow the script to disable them in case they are removed from the remote list.\n\nIf you used [pihole5-list-tool](https://github.com/jessedp/pihole5-list-tool) to import adlists and whitelist you can use these commands to do this quickly:\n```bash\nsudo sqlite3 /etc/pihole/gravity.db \"UPDATE adlist SET comment = 'Managed by pihole-updatelists' WHERE comment LIKE '%Firebog |%' OR comment LIKE '%[ph5lt]'\"\nsudo sqlite3 /etc/pihole/gravity.db \"UPDATE domainlist SET comment = 'Managed by pihole-updatelists' WHERE comment LIKE '%AndeepND |%' OR comment LIKE '%[ph5lt]'\"\n```\n_(code up to date as of pihole5-list-tool 0.6.0)_\n\nAlternatively, some manual work is required - pick one:\n\n- Manually modify comment field of all imported domains/adlists to match the one this script uses (see `COMMENT` variable in **Configuration** section) **(recommended but might be a lot of work)**\n- Manually delete all imported domains/adlists from the web interface (might be a lot of work)\n- Wipe all adlists and domains (not recommended but fast - use this if you want to start fresh)\n  - backup your lists and custom entries (write them down somewhere, do not use the Teleporter)\n  - run the following commands:\n\t```bash\n\tsudo sqlite3 /etc/pihole/gravity.db \"DELETE FROM adlist\"\n\tsudo sqlite3 /etc/pihole/gravity.db \"DELETE FROM adlist_by_group\"\n\tsudo sqlite3 /etc/pihole/gravity.db \"DELETE FROM domainlist\"\n\tsudo sqlite3 /etc/pihole/gravity.db \"DELETE FROM domainlist_by_group\"\n\t```\n  - keep reading and configure the script then run `sudo pihole-updatelists` to finish up\n  - (only when `UPDATE_GRAVITY=false`) run `pihole updateGravity`\n\n## Install with Docker\n\nFollow the [official instructions](https://hub.docker.com/r/pihole/pihole/) but use `jacklul/pihole:latest` image instead, pass [configuration variables](#configuration) as environment variables in `docker-compose.yml`.\n\nIf you need to pull a specific version of Pi-hole image you have no other choice but to use [custom Dockerfile](#using-official-image).\n\n### Using custom image\n\nUse [`jacklul/pihole:latest`](https://hub.docker.com/r/jacklul/pihole) image instead of `pihole/pihole:latest`. [Version-specific tags](https://hub.docker.com/r/jacklul/pihole/tags) are also available but keep in mind they will contain version of the script that was available at the time of that particular version.\n\n### Using official image\n\nIf you don't want to use my image you can write custom `Dockerfile`:\n\n```\nFROM pihole/pihole:latest\n\nRUN apt-get update && apt-get install -Vy wget php-cli php-sqlite3 php-intl php-curl\n\nRUN wget -O - https://raw.githubusercontent.com/jacklul/pihole-updatelists/master/install.sh | bash -s docker\n```\n\nThen build your image locally and use that image in your `docker-composer.yml` or launch command line.\nYou will have to update your local image manually each time update is released.\n\n### Container Configuration\n\nYour `docker-compose.yml` file should look similar to this:\n\n```yml\nversion: \"3\"\n\nservices:\n  pihole:\n    container_name: pihole\n    image: jacklul/pihole:latest\n    ports:\n      - \"53:53/tcp\"\n      - \"53:53/udp\"\n      - \"67:67/udp\"\n      - \"80:80/tcp\"\n    environment:\n      TZ: 'America/Chicago'\n      ADLISTS_URL: 'https://v.firebog.net/hosts/lists.php?type=tick'\n      WHITELIST_URL: 'https://raw.githubusercontent.com/anudeepND/whitelist/master/domains/whitelist.txt'\n      #REGEX_WHITELIST_URL: ''\n      #BLACKLIST_URL: ''\n      REGEX_BLACKLIST_URL: 'https://raw.githubusercontent.com/mmotti/pihole-regex/master/regex.list'\n    volumes:\n      - './etc-pihole/:/etc/pihole/'\n      - './etc-dnsmasq.d/:/etc/dnsmasq.d/'\n      # If you need advanced configuration create a mount to access the config file:\n      #- './etc-pihole-updatelists/:/etc/pihole-updatelists/'\n    cap_add:\n      - NET_ADMIN\n    restart: unless-stopped\n```\n_(for more up to date `docker-compose.yml` see [pi-hole/docker-pi-hole](https://github.com/pi-hole/docker-pi-hole/#quick-start))_\n\nIf you already have existing `gravity.db` you should also check out [Migrating lists and domains](#migrating-lists-and-domains) section, keep in mind that you will have to adjust paths in the commands mentioned there.\n\nDocker start script uses these extra environment variables:\n- `PHUL_DNSCHECK_DOMAIN` - the domain to `nslookup` to check whenever DNS resolution is available (`pi.hole` by default)\n- `PHUL_DNSCHECK_TIMELIMIT` - maximum time to wait for the DNS resolution to become available (`300` seconds by default)\n\n## Configuration\n\nDefault configuration file is `/etc/pihole-updatelists.conf`.\n\n```bash\nsudo nano /etc/pihole-updatelists.conf\n```\n\n### Available variables\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| ADLISTS_URL | \" \" | Remote list URL containing list of adlists to import <br>**URLs to single adlists are supported but it might be better if you add them manually** |\n| WHITELIST_URL | \" \" | Remote list URL containing exact domains to whitelist |\n| REGEX_WHITELIST_URL | \" \" | Remote list URL containing regex rules for whitelisting |\n| BLACKLIST_URL | \" \" | Remote list URL containing exact domains to blacklist <br>**This is specifically for handcrafted lists only, do not use regular blocklists here!** |\n| REGEX_BLACKLIST_URL | \" \" | Remote list URL containing regex rules for blacklisting |\n| COMMENT | \"Managed by pihole-updatelists\" | Comment string used to know which entries were created by the script <br>**You can still add your own comments to individual entries as long you keep this string intact** |\n| GROUP_ID | 0 | Assign additional group to all inserted entries, to assign only the specified group (do not add to the default) make the number negative <br>`0` is the default group, you can view ID of the group in Pi-hole's web interface by hovering mouse cursor over group name field on the 'Group management' page <br>**Multiple groups are not supported** |\n| PERSISTENT_GROUP | true | Makes sure entries have the specified group assigned on each script run <br>This does not prevent you from assigning more groups through the web interface but can remove entries from the default group if GROUP_ID is a negative number <br>**When disabled but an entry has no groups assigned and is about to be enabled then it will be re-added to the groups it's supposed to be in** <br>**WARNING: This option might be buggy when running multiple different configurations with same lists** |\n| REQUIRE_COMMENT | true | Prevent touching entries not created by this script by comparing comment field <br>When `false` any user-created entry will be disabled, only those created by the script will be active |\n| MIGRATION_MODE | 1 | Decides how to migrate disabled entries from another config sections <br>1 - replace comment field <br>2 - append to comment field <br>0 - disables migration, entry will be ignored\n| GROUP_EXCLUSIVE | false | Causes defined group in `GROUP_ID` to contain one defined list exclusively - only entries from the last list inserted will be enabled <br>**This option is experimental**\n| UPDATE_GRAVITY | true | Update gravity after lists are updated? (runs `pihole updateGravity`) <br>When `false` invokes lists reload instead <br>Set to `null` to do nothing |\n| VERBOSE | false | Show more information while the script is running |\n| DEBUG | false | Show debug messages for troubleshooting purposes <br>**If you're having issues - this might help tracking it down** |\n| DOWNLOAD_TIMEOUT | 60 | Maximum time in seconds one list download can take before giving up <br>You should increase this when downloads fail because of timeout |\n| IGNORE_DOWNLOAD_FAILURE | false | Ignore download failures when using multiple lists <br> **This will cause entries from the lists that failed to download to be disabled** |\n| GRAVITY_DB | \"/etc/pihole/gravity.db\" | Path to `gravity.db` in case you need to change it |\n| LOCK_FILE | \"/var/lock/pihole-updatelists.lock\" | Process lockfile to prevent multiple instances of the script from running <br>**You shouldn't change it - unless `/var/lock` is unavailable** |\n| LOG_FILE | \" \" | Log console output to file <br>In most cases you don't have to set this as you can view full log in the system journal <br>Put `-` before path to overwrite file instead of appending to it |\n| PIHOLE_CMD | \"/usr/local/bin/pihole\" | Path to `pihole` script, <br>Change this only if it isn't in the default location |\n| GIT_BRANCH | \"master\" | Branch to pull remote checksum and update from |\n\nString values should be put between `\" \"`, otherwise weird things might happen.\n\nYou can also give paths to the local files instead of URLs, for example setting `WHITELIST_URL` to `/home/pi/whitelist.txt` will fetch this file from filesystem.\n\n### Environment variables\n\nIt is also possible to load configuration variables from the environment by using `--env` parameter - this will overwrite values in default section of the config file.\n\n**Some variables will have to be prefixed with `PHUL_` for compatibility:**\n```\nCONFIG_FILE, GRAVITY_DB, LOCK_FILE, PIHOLE_CMD, LOG_FILE, VERBOSE, DEBUG, GIT_BRANCH\n```\n\n### Multiple configurations\n\nYou can specify alternative config file by passing the path to the script through `config` parameter: `pihole-updatelists --config=/home/pi/pihole-updatelists2.conf` - this combined with different `COMMENT` string can allow multiple script configurations for the same Pi-hole instance.\n\n**A more advanced way is to use sections in the configuration file:**\n\n_**Warning: this method can sometimes be buggy or have weird behaviors!**_\n\n```\n(bottom of the file)\n\n[GroupA_adlists]\nWHITELIST_URL=\"https://raw.githubusercontent.com/you/adlists/master/my_whitelist1.txt\"\nGROUP_ID=-1\nCOMMENT=\"pihole-updatelists - whitelist1\"\n\n[GroupB_adlists]\nWHITELIST_URL=\"https://raw.githubusercontent.com/you/adlists/master/my_whitelist2.txt\"\nGROUP_ID=-2\nCOMMENT=\"pihole-updatelists - whitelist2\"\n```\n\nConfigurations where one of the lists contains entries from the other are not officially supported but may work:\n\n```\n; When one of the lists contains entries from the other\n; it's best to have it defined after the other one\n\n; Group with ID=1 will use 'tick' list of adlists\n[GroupA_adlists]\nADLISTS_URL=\"https://v.firebog.net/hosts/lists.php?type=tick\"\nGROUP_ID=-1\nCOMMENT=\"pihole-updatelists - firebog (tick)\"\n\n; Group with ID=2 will use 'nocross' list of adlists\n[GroupB_adlists]\nADLISTS_URL=\"https://v.firebog.net/hosts/lists.php?type=nocross\"\nGROUP_ID=-2\nCOMMENT=\"pihole-updatelists - firebog (nocross)\"\n```\n\n**You will want to have a different `COMMENT` value in each section, they have to be unique and one must not match the other!**\n\nMain configuration (the one without section header) is processed first, then the sections in the order of their appearance.\n\n**IMPORTANT:** You can only use selected variables in sections:\n```\nADLISTS_URL, WHITELIST_URL, REGEX_WHITELIST_URL, BLACKLIST_URL, REGEX_BLACKLIST_URL, COMMENT, GROUP_ID, PERSISTENT_GROUP, GROUP_EXCLUSIVE, IGNORE_DOWNLOAD_FAILURE\n```\n\n### Multiple list URLs\n\nYou can pass multiple URLs to the list variables by separating them with whitespace (space or new line):\n\n```bash\nADLISTS_URL=\"https://v.firebog.net/hosts/lists.php?type=tick  https://raw.githubusercontent.com/you/adlists/master/my_adlists.txt\"\n```\n\nIf one of the lists fails to download nothing will be affected for that list type.\n\n### Recommended lists\n\n| List | URL/Variable value | Description |\n|----------|-------------|-------------|\n| Adlist<br>(ADLISTS_URL) | https://v.firebog.net/hosts/lists.php?type=tick | https://firebog.net - safe lists only |\n| Whitelist<br>(WHITELIST_URL) | https://raw.githubusercontent.com/anudeepND/whitelist/master/domains/whitelist.txt | https://github.com/anudeepND/whitelist - commonly whitelisted |\n| Regex blacklist<br>(REGEX_BLACKLIST_URL) | https://raw.githubusercontent.com/mmotti/pihole-regex/master/regex.list | https://github.com/mmotti/pihole-regex - basic regex rules |\n\nPlease note that [mmotti/pihole-regex](https://github.com/mmotti/pihole-regex) list can sometimes block domains that should not be blocked - any false positives should be [reported to the repository](https://github.com/mmotti/pihole-regex/issues) to be included in the [whitelist](https://github.com/mmotti/pihole-regex/blob/master/whitelist.list) (in that case you might consider adding that list to the `WHITELIST_URL` too).\n\n## Extra information\n\n### Runtime options\n\nThese can be used when executing `pihole-updatelists`.\n\n| Option | Description |\n|----------|-------------|\n| `--help, -h` | Show help message, which is simply this list |\n| `--no-gravity, -n` | Force gravity update to be skipped |\n| `--no-reload, -b` | Force lists reload to be skipped<br>Only if gravity update is disabled either by configuration (`UPDATE_GRAVITY=false`) or `--no-gravity` parameter |\n| `--verbose, -v` | Turn on verbose mode |\n| `--debug, -d`  | Turn on debug mode |\n| `--config=<file>` | Load alternative configuration file |\n| `--env, -e` | Load configuration from environment variables |\n| `--git-branch=<branch>` | Select git branch to pull remote checksum and update from <br>Can only be used with `--update` and `--version` |\n| `--update` | Update the script using selected git branch |\n| `--rollback` | Rollback script version to previous |\n| `--force` | Force update without checking for newest version |\n| `--yes, -y` | Automatically reply YES to all questions |\n| `--version `| Show script checksum (and also if update is available) |\n\n### Changing the schedule\n\nBy default, the script runs at random time (between 03:00 and 04:00) on Saturday, to change it you'll have to override [timer unit](https://www.freedesktop.org/software/systemd/man/systemd.timer.html) file:\n\n```bash\nsudo systemctl edit pihole-updatelists.timer\n```\n```\n[Timer]\nRandomizedDelaySec=5m\nOnCalendar=\nOnCalendar=Sat *-*-* 00:00:00\n```\n\nIf systemd is not available you just modify the crontab entry in `/etc/cron.d/pihole-updatelists`:\n\n```bash\n14 6 * * 6   root   /usr/local/sbin/pihole-updatelists\n```\n\n### Running custom commands before/after scheduled run\n\nOverride [service unit](https://www.freedesktop.org/software/systemd/man/systemd.service.html) file:\n\n```bash\nsudo systemctl edit pihole-updatelists.service\n```\n```\n[Service]\nType=oneshot\nExecStartPre=echo \"before\"\nExecStartPost=echo \"after\"\n```\n\nIf systemd is not available you just modify the crontab entry in `/etc/cron.d/pihole-updatelists`:\n\n```bash\n30 3 * * 6   root   /home/pi/before.sh && /usr/local/sbin/pihole-updatelists && /home/pi/after.sh\n```\n\n_You can use `;` instead of `&&` if you don't want the execution to stop on previous command failure._\n\n### Changing comment value after running the script\n\n```bash\nsudo sqlite3 /etc/pihole/gravity.db \"UPDATE adlist SET comment = 'NEWCOMMENT' WHERE comment LIKE '%Managed by pihole-updatelists%'\"\nsudo sqlite3 /etc/pihole/gravity.db \"UPDATE domainlist SET comment = 'NEWCOMMENT' WHERE comment LIKE '%Managed by pihole-updatelists%'\"\n```\n\nReplace `NEWCOMMENT` with your new desired comment value. This assumes `Managed by pihole-updatelists` is the old comment value, replace it with your old custom value when needed.\n\n### Custom comments for entries\n\nIf you wish to add custom comments to entries you can use the following file syntax:\n\n```\nexample-domain.com # your comment\n```\n\nWhich will cause `example-domain.com` to have `comment` set to `your comment | Managed by pihole-updatelists`.\n\nYou can also add your comments directly through the Pi-hole's web interface by either appending or prepending the comment field for entries.\n\n### Uninstalling\n\n```bash\nwget -O - https://raw.githubusercontent.com/jacklul/pihole-updatelists/master/install.sh | sudo bash -s uninstall\n```\n\nor remove files manually:\n\n```bash\nsudo rm -vf /usr/local/sbin/pihole-updatelists /etc/bash_completion.d/pihole-updatelists /etc/systemd/system/pihole-updatelists.service /etc/systemd/system/pihole-updatelists.timer /etc/cron.d/pihole-updatelists\n```\n\n## License\n\n[MIT License](/LICENSE).\n"
        },
        {
          "name": "docker.sh",
          "type": "blob",
          "size": 2.5361328125,
          "content": "#!/bin/bash\n# This is the startup file for Docker installation that runs before actual _postFTL service is started\n\nif [ ! -d \"/etc/s6-overlay/s6-rc.d/_postFTL\" ]; then\n\techo \"Missing /etc/s6-overlay/s6-rc.d/_postFTL - not a Docker installation?\"\n\texit\nfi\n\n# Respect PH_VERBOSE environment variable\nif [ \"${PH_VERBOSE:-0}\" -gt 0 ]; then\n\tset -x\n\tSCRIPT_ARGS=\"--verbose --debug\"\nfi\n\n# Recreate the config file if it is missing\nif [ ! -f \"/etc/pihole-updatelists/pihole-updatelists.conf\" ]; then\n\tcp /etc/pihole-updatelists.conf /etc/pihole-updatelists/pihole-updatelists.conf\n\techo \"Created /etc/pihole-updatelists/pihole-updatelists.conf\"\nfi\n\n# Fix permissions (when config directory is mounted as a volume)\nchown root:root /etc/pihole-updatelists/*\nchmod 644 /etc/pihole-updatelists/*\n\n# Disable default gravity update schedule\nif [ \"$(grep 'pihole updateGravity' < /etc/cron.d/pihole | cut -c1-1)\" != \"#\" ]; then\n\tsed -e '/pihole updateGravity/ s/^#*/#/' -i /etc/cron.d/pihole\n\techo \"Disabled default gravity update schedule in /etc/cron.d/pihole\"\nfi\n\n# Create new schedule with random time\necho \"#30 3 * * 6   root   /usr/bin/php /usr/local/sbin/pihole-updatelists --config=/etc/pihole-updatelists/pihole-updatelists.conf\" > /etc/cron.d/pihole-updatelists\nsed \"s/#30 /$((1 + RANDOM % 58)) /\" -i /etc/cron.d/pihole-updatelists\n\nif [ -n \"$SKIPGRAVITYONBOOT\" ]; then\n\techo \"Lists update skipped - SKIPGRAVITYONBOOT=true\"\nelse\n\tif [ ! -f \"/etc/pihole/gravity.db\" ]; then\n\t\techo \"Gravity database not found - running 'pihole -g' command...\"\n\t\tpihole -g\n\telse\n\t\tif [ -z \"$PHUL_SKIPDNSCHECK\" ]; then\n\t\t\t[ -n \"$PHUL_DNSCHECK_DOMAIN\" ] && _DNSCHECK_DOMAIN=\"$PHUL_DNSCHECK_DOMAIN\" || _DNSCHECK_DOMAIN=\"pi-hole.net\"\n\t\t\t[ -n \"$PHUL_DNSCHECK_TIMELIMIT\" ] && _DNSCHECK_TIMELIMIT=\"$PHUL_DNSCHECK_TIMELIMIT\" || _DNSCHECK_TIMELIMIT=300\n\n\t\t\t_DNSCHECK_COUNTER=0\n\t\t\twhile [ -z \"$_DNSCHECK_IP\" ] && [ \"$_DNSCHECK_COUNTER\" -lt \"$_DNSCHECK_TIMELIMIT\" ]; do\n\t\t\t\t_DNSCHECK_IP=\"$(nslookup \"$_DNSCHECK_DOMAIN\" | awk '/^Address: / { print $2 }')\"\n\n\t\t\t\tif [ -z \"$_DNSCHECK_IP\" ]; then\n\t\t\t\t\t[ \"$_DNSCHECK_COUNTER\" = 0 ] && echo \"Waiting for DNS resolution to be available...\"\n\n\t\t\t\t\tsleep 1\n\t\t\t\tfi\n\n\t\t\t\t((_DNSCHECK_COUNTER++))\n\t\t\tdone\n\n\t\t\t[ -z \"$_DNSCHECK_IP\" ] && echo \"Timed out while waiting for DNS resolution to be available\"\n\t\tfi\n\tfi\n\n\tif [ -z \"$PHUL_LOG_FILE\" ]; then\n\t\texport PHUL_LOG_FILE=\"-/var/log/pihole-updatelists-boot.log\"\n\tfi\n\n\t# shellcheck disable=SC2086\n\t/usr/bin/php /usr/local/sbin/pihole-updatelists --config=/etc/pihole-updatelists/pihole-updatelists.conf --env --no-gravity --no-reload $SCRIPT_ARGS\nfi\n"
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 7.17578125,
          "content": "#!/usr/bin/env bash\nset -e\n\n# Try re-running with sudo\n[ \"$UID\" -eq 0 ] || exec sudo bash \"$0\" \"$@\"\n\n# Required to do when unit files are changed or removed\nfunction reloadSystemd() {\n\techo \"Reloading systemd manager configuration...\" \n\tsystemctl daemon-reload\n}\n\nSPATH=$(dirname \"$0\") # Path to the script\nREMOTE_URL=https://raw.githubusercontent.com/jacklul/pihole-updatelists # Remote URL that serves raw files from the repository\nGIT_BRANCH=master # Git branch to use, user can specify custom branch as first argument\nSYSTEMD=$(pidof systemd >/dev/null && echo \"1\" || echo \"0\") # Is systemd available?\nSYSTEMD_INSTALLED=$([ -f \"/etc/systemd/system/pihole-updatelists.timer\" ] && echo \"1\" || echo \"0\") # Is systemd timer installed already?\nDOCKER=$([ \"$(grep \"docker\" < /proc/1/cgroup)\" == \"\" ] && echo \"0\" || echo \"1\") # Is this a Docker installation?\n\nif [ \"$1\" == \"uninstall\" ]; then\t# Simply remove the files and reload systemd (if available)\n\trm -v /usr/local/sbin/pihole-updatelists\n\trm -v /etc/bash_completion.d/pihole-updatelists\n\trm -vf /etc/cron.d/pihole-updatelists\n\trm -vf /etc/systemd/system/pihole-updatelists.service\n\trm -vf /etc/systemd/system/pihole-updatelists.timer\n\t\n\tif [ -f \"/var/tmp/pihole-updatelists.old\" ]; then\n\t\trm -v /var/tmp/pihole-updatelists.old\n\tfi\n\n\tif [ \"$SYSTEMD\" == 1 ]; then\n\t\treloadSystemd\n\tfi\n\n\texit 0\nelif [ \"$1\" == \"docker\" ]; then\t# Force Docker install\n\tDOCKER=1\nelif [ \"$1\" == \"systemd\" ]; then # Force systemd unit files installation\n\tSYSTEMD=1\nelif [ \"$1\" == \"crontab\" ]; then # Force crontab installation\n\tSYSTEMD=0\nelif [ \"$1\" != \"\" ]; then\t# Install using different branch\n\tGIT_BRANCH=$1\n\n\tif ! wget -q --spider \"$REMOTE_URL/$GIT_BRANCH/install.sh\" ; then\n\t\techo \"Invalid branch: ${GIT_BRANCH}\"\n\t\texit 1\n\tfi\nfi\n\n# Do not install systemd unit files inside Docker container\nif [ \"$DOCKER\" == 1 ]; then\n\tSYSTEMD=0\nfi\n\n# We require some stuff before continuing\ncommand -v php >/dev/null 2>&1 || { echo \"This script requires PHP-CLI to run, install it with 'sudo apt install php-cli'.\"; exit 1; }\n[[ $(php -v | head -n 1 | cut -d \" \" -f 2 | cut -f1 -d\".\") -lt 7 ]] && { echo \"Detected PHP version lower than 7.0, make sure php-cli package is up to date!\"; exit 1; }\n\n# Use local files when possible, otherwise install from remote repository\nif \\\n\t[ \"$GIT_BRANCH\" == \"master\" ] && \\\n\t[ -f \"$SPATH/pihole-updatelists.php\" ] && \\\n\t[ -f \"$SPATH/pihole-updatelists.conf\" ] && \\\n\t[ -f \"$SPATH/pihole-updatelists.service\" ] && \\\n\t[ -f \"$SPATH/pihole-updatelists.timer\" ] && \\\n\t[ -f \"$SPATH/pihole-updatelists.bash\" ] \\\n; then\n\tif [ ! -d \"/usr/local/sbin\" ]; then\n\t\tmkdir -vp /usr/local/sbin && chmod -v 0755 /usr/local/sbin\n\tfi\n\n\tif [ -f \"/usr/local/sbin/pihole-updatelists\" ]; then\n\t\tif ! cmp -s \"$SPATH/pihole-updatelists.php\" \"/usr/local/sbin/pihole-updatelists\"; then\n\t\t\techo \"Backing up previous version...\"\n\t\t\tcp -v /usr/local/sbin/pihole-updatelists /var/tmp/pihole-updatelists.old && \\\n\t\t\tchmod -v -x /var/tmp/pihole-updatelists.old\n\t\tfi\n\tfi\n\n\tcp -v \"$SPATH/pihole-updatelists.php\" /usr/local/sbin/pihole-updatelists && \\\n\tchmod -v +x /usr/local/sbin/pihole-updatelists\n\t\n\tif [ ! -f \"/etc/pihole-updatelists.conf\" ]; then\n\t\tcp -v \"$SPATH/pihole-updatelists.conf\" /etc/pihole-updatelists.conf\n\tfi\n\n\tif [ \"$SYSTEMD\" == 1 ]; then\n\t\tcp -v \"$SPATH/pihole-updatelists.service\" /etc/systemd/system\n\t\tcp -v \"$SPATH/pihole-updatelists.timer\" /etc/systemd/system\n\tfi\n\t\n\tif [ ! -d \"/etc/bash_completion.d\" ]; then\n\t\tmkdir -vp /etc/bash_completion.d\n\tfi\n\n\tcp -v \"$SPATH/pihole-updatelists.bash\" /etc/bash_completion.d/pihole-updatelists\n\n\t# Convert line endings when dos2unix command is available\n\tcommand -v dos2unix >/dev/null 2>&1 && dos2unix /usr/local/sbin/pihole-updatelists /etc/bash_completion.d/pihole-updatelists\nelif [ \"$REMOTE_URL\" != \"\" ] && [ \"$GIT_BRANCH\" != \"\" ]; then\n\tif [ ! -d \"/usr/local/sbin\" ]; then\n\t\tmkdir -vp /usr/local/sbin && chmod -v 0755 /usr/local/sbin\n\tfi\n\t\n\tif [ -f \"/usr/local/sbin/pihole-updatelists\" ]; then\n\t\twget -nv -O /tmp/pihole-updatelists.php \"$REMOTE_URL/$GIT_BRANCH/pihole-updatelists.php\"\n\n\t\tif ! cmp -s \"/tmp/pihole-updatelists.php\" \"/usr/local/sbin/pihole-updatelists\"; then\n\t\t\techo \"Backing up previous version...\"\n\t\t\tcp -v /usr/local/sbin/pihole-updatelists /var/tmp/pihole-updatelists.old && \\\n\t\t\tchmod -v -x /var/tmp/pihole-updatelists.old\n\t\tfi\n\n\t\tmv -v /tmp/pihole-updatelists.php /usr/local/sbin/pihole-updatelists && \\\n\t\tchmod -v +x /usr/local/sbin/pihole-updatelists\n\telse\n\t\twget -nv -O /usr/local/sbin/pihole-updatelists \"$REMOTE_URL/$GIT_BRANCH/pihole-updatelists.php\" && \\\n\t\tchmod -v +x /usr/local/sbin/pihole-updatelists\n\tfi\n\n\tif [ ! -f \"/etc/pihole-updatelists.conf\" ]; then\n\t\twget -nv -O /etc/pihole-updatelists.conf \"$REMOTE_URL/$GIT_BRANCH/pihole-updatelists.conf\"\n\tfi\n\n\tif [ \"$SYSTEMD\" == 1 ]; then\n\t\twget -nv -O /etc/systemd/system/pihole-updatelists.service \"$REMOTE_URL/$GIT_BRANCH/pihole-updatelists.service\"\n\t\twget -nv -O /etc/systemd/system/pihole-updatelists.timer \"$REMOTE_URL/$GIT_BRANCH/pihole-updatelists.timer\"\n\tfi\n\n\tif [ ! -d \"/etc/bash_completion.d\" ]; then\n\t\tmkdir -vp /etc/bash_completion.d\n\tfi\n\n\twget -nv -O /etc/bash_completion.d/pihole-updatelists \"$REMOTE_URL/$GIT_BRANCH/pihole-updatelists.bash\"\nelse\n\techo \"Missing required files for installation!\"\n\texit 1\nfi\n\nif [ -f \"/usr/local/sbin/pihole-updatelists.old\" ]; then\n\trm -v /usr/local/sbin/pihole-updatelists.old\nfi\n\n# Install schedule related files\nif [ \"$SYSTEMD\" == 1 ]; then\n\tif [ -f \"/etc/cron.d/pihole-updatelists\" ]; then\n\t\t# Comment out the existing cron job\n\t\tsed \"s/^#*/#/\" -i /etc/cron.d/pihole-updatelists\n\tfi\n\n\tif [ \"$SYSTEMD_INSTALLED\" == 0 ]; then\n\t\techo \"Enabling and starting pihole-updatelists.timer...\"\n\t\tsystemctl enable pihole-updatelists.timer && systemctl start pihole-updatelists.timer\n\telse\n\t\treloadSystemd\n\tfi\nelse\n\tif [ ! -f \"/etc/cron.d/pihole-updatelists\" ]; then\n\t\techo \"# Pi-hole's Lists Updater by Jack'lul\n# https://github.com/jacklul/pihole-updatelists\n\n#30 3 * * 6   root   /usr/local/sbin/pihole-updatelists\n\" > /etc/cron.d/pihole-updatelists\n\t\tsed \"s/#30 /$((1 + RANDOM % 58)) /\" -i /etc/cron.d/pihole-updatelists\n\n\t\techo \"Created crontab (/etc/cron.d/pihole-updatelists)\"\n\tfi\nfi\n\n# Docker-related tasks\nif [ \"$DOCKER\" == 1 ]; then\n\t[ ! -d \"/etc/s6-overlay/s6-rc.d/_postFTL\" ] && { echo \"Missing /etc/s6-overlay/s6-rc.d/_postFTL directory!\"; exit 1; }\n\t[ ! -f \"/usr/local/bin/_postFTL.sh\" ] && { echo \"Missing /usr/local/bin/_postFTL.sh file!\"; exit 1; }\n\t\n\tmkdir -v /etc/pihole-updatelists\n\t\n\tif [ -f \"$SPATH/docker.sh\" ]; then\n\t\tcp -v \"$SPATH/docker.sh\" /usr/local/bin/_updatelists.sh\n\telif [ \"$REMOTE_URL\" != \"\" ]; then\n\t\twget -nv -O /usr/local/bin/_updatelists.sh \"$REMOTE_URL/$GIT_BRANCH/docker.sh\"\n\telse\n\t\techo \"Missing required file (docker.sh) for installation!\"\n\tfi\n\n\tchmod -v +x /usr/local/bin/_updatelists.sh\n\n\techo \"#!/command/execlineb\" > /etc/s6-overlay/s6-rc.d/_postFTL/up\n\techo \"background { bash -ec \\\"/usr/local/bin/_updatelists.sh && /usr/local/bin/_postFTL.sh\\\" }\" >> /etc/s6-overlay/s6-rc.d/_postFTL/up\n\techo \"Modified /etc/s6-overlay/s6-rc.d/_postFTL/up to launch pihole-updatelists first!\"\n\n\techo \"alias pihole-updatelists='/usr/local/sbin/pihole-updatelists --config=/etc/pihole-updatelists/pihole-updatelists.conf --env'\" >> /root/.bashrc\n\techo \"Created alias for pihole-updatelists command in /root/.bashrc\"\nfi\n"
        },
        {
          "name": "pihole-updatelists.bash",
          "type": "blob",
          "size": 1.2060546875,
          "content": "#!/usr/bin/env bash\n# https://unix.stackexchange.com/a/55622\n\n_pihole_updatelists()\n{\n    local cur prev opts\n\t\n    COMPREPLY=()\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n    opts=\"--help --no-gravity --no-reload --verbose --debug --config= --env --git-branch= --update --rollback --version\"\n\n    case \"${prev}\" in\n            \"--version\")\n                opts=\"--git-branch=\"\n            ;;\n            \"--update\")\n                opts=\"--force --git-branch= --yes\"\n            ;;\n            \"--rollback\")\n                opts=\"--yes\"\n            ;;\n    esac\n\n    if [[ ${prev} == \"--\"* && ${cur} == \"=\" ]] ; then\n        compopt -o filenames\n        COMPREPLY=(*)\n\n        return 0\n    fi\n\n    if [[ ${prev} == '=' ]] ; then\n        cur=${cur//\\\\ / }\n        [[ ${cur} == \"~/\"* ]] && cur=${cur/\\~/$HOME}\n        compopt -o filenames\n        local files=(\"${cur}\"*)\n        [[ -e ${files[0]} ]] && COMPREPLY=( \"${files[@]// /\\ }\" )\n\n        return 0\n    fi\n\n    COMPREPLY=( $(compgen -W \"${opts}\" -- \"${cur}\") )\n\n    if [[ ${#COMPREPLY[@]} == 1 && ${COMPREPLY[0]} != \"--\"*\"=\" ]] ; then\n        compopt +o nospace\n    fi\n\t\n    return 0\n}\n\ncomplete -o nospace -F _pihole_updatelists pihole-updatelists\n"
        },
        {
          "name": "pihole-updatelists.conf",
          "type": "blob",
          "size": 0.6533203125,
          "content": "; Pi-hole's Lists Updater by Jack'lul\n; https://github.com/jacklul/pihole-updatelists\n; For a full list of available variables please see the readme.\n\n; Remote list URL containing list of adlists to import\n; URLs to single adlists are not supported here!\nADLISTS_URL=\"\"\n\n; Remote list URL containing exact domains to whitelist\nWHITELIST_URL=\"\"\n\n; Remote list URL containing regex rules for whitelisting\nREGEX_WHITELIST_URL=\"\"\n\n; Remote list URL containing exact domains to blacklist\n; This is specifically for handcrafted lists only, do not use regular blocklists here!\nBLACKLIST_URL=\"\"\n\n; Remote list URL containing regex rules for blacklisting\nREGEX_BLACKLIST_URL=\"\"\n"
        },
        {
          "name": "pihole-updatelists.php",
          "type": "blob",
          "size": 96.625,
          "content": "#!/usr/bin/env php\n<?php declare (strict_types = 1);\n/**\n * Update Pi-hole lists from remote sources\n *\n * @author  Jack'lul <jacklul.github.io>\n * @license MIT\n * @link    https://github.com/jacklul/pihole-updatelists\n */\n\n// A hash in case we're gonna force an update - f362448aaf23adbf8a900b3616a6719c\ndefine('GITHUB_LINK', 'https://github.com/jacklul/pihole-updatelists'); // Link to Github page\ndefine('GITHUB_LINK_RAW', 'https://raw.githubusercontent.com/jacklul/pihole-updatelists'); // URL serving raw files from the repository\n\n/**\n * Print (and optionally log) string\n *\n * @param string $str\n * @param string $severity\n * @param bool   $logOnly\n *\n * @throws RuntimeException\n */\nfunction printAndLog($str, $severity = 'INFO', $logOnly = false)\n{\n    global $config, $lock;\n\n    if (!in_array(strtoupper($severity), ['DEBUG', 'INFO', 'NOTICE', 'WARNING', 'ERROR'])) {\n        throw new RuntimeException('Invalid log severity: ' . $severity);\n    }\n\n    if (!empty($config['LOG_FILE'])) {\n        $flags = FILE_APPEND;\n\n        if (strpos($config['LOG_FILE'], '-') === 0) {\n            $flags              = 0;\n            $config['LOG_FILE'] = substr($config['LOG_FILE'], 1);\n        }\n\n        // Do not overwrite log files until we have a lock (this could mess up log file if another instance is already running)\n        if ($flags !== null || $lock !== null) {\n            if (!file_exists($config['LOG_FILE']) && !@touch($config['LOG_FILE'])) {\n                throw new RuntimeException('Unable to create log file: ' . $config['LOG_FILE']);\n            }\n\n            $lines = preg_split('/\\r\\n|\\r|\\n/', ucfirst(trim($str)));\n            foreach ($lines as &$line) {\n                $line = '[' . date('Y-m-d H:i:s e') . '] [' . strtoupper($severity) . ']' . \"\\t\" . $line;\n            }\n            unset($line);\n\n            file_put_contents(\n                $config['LOG_FILE'],\n                implode(PHP_EOL, $lines) . PHP_EOL,\n                $flags | LOCK_EX\n            );\n        }\n    }\n\n    if ($logOnly) {\n        return;\n    }\n\n    print $str;\n}\n\n/**\n * Check for required stuff\n *\n * Setting environment variable IGNORE_OS_CHECK allows to run this script on Windows\n */\nfunction checkDependencies()\n{\n    // Do not run on PHP lower than 7.0\n    if ((float) PHP_VERSION < 7.0) {\n        printAndLog('Minimum PHP 7.0 is required to run this script!' . PHP_EOL, 'ERROR');\n        exit(1);\n    }\n\n    // Windows is obviously not supported (invironment variable IGNORE_OS_CHECK overrides this)\n    if (stripos(PHP_OS, 'WIN') === 0 && empty(getenv('IGNORE_OS_CHECK'))) {\n        printAndLog('Windows is not supported!' . PHP_EOL, 'ERROR');\n        exit(1);\n    }\n\n    // Check for required PHP extensions\n    $extensions = [\n        'pdo',\n        'pdo_sqlite',\n    ];\n\n    foreach ($extensions as $extension) {\n        if (!extension_loaded($extension)) {\n            printAndLog('Missing required PHP extension: ' . $extension . PHP_EOL, 'ERROR');\n            print 'You can install it using `apt-get install php-' . str_replace('_', '-', $extension) . '`' . PHP_EOL;\n            exit(1);\n        }\n    }\n}\n\n/**\n * Check for optional stuff\n */\nfunction checkOptionalDependencies()\n{\n    // Check for recommended PHP extensions\n    $missingExtensions = [];\n    $extensions        = [\n        'intl',\n        'curl',\n    ];\n\n    foreach ($extensions as $extension) {\n        if (!extension_loaded($extension)) {\n            printAndLog('Missing recommended PHP extension: php-' . $extension . PHP_EOL, 'WARNING');\n            incrementStat('warnings');\n            $missingExtensions[] = 'php-' . str_replace('_', '-', $extension);\n        }\n    }\n\n    if (count($missingExtensions) > 0) {\n        print 'You can install missing extensions using `apt-get install ' . implode(' ', $missingExtensions) . '`' . PHP_EOL . PHP_EOL;\n    }\n}\n\n/**\n * Returns array of defined options\n *\n * @return array\n */\nfunction getDefinedOptions()\n{\n    return [\n        'help'       => [\n            'long'        => 'help',\n            'short'       => 'h',\n            'function'    => 'printHelp',\n            'description' => 'This help message',\n        ],\n        'no-gravity' => [\n            'long'        => 'no-gravity',\n            'short'       => 'n',\n            'description' => 'Force no gravity update',\n        ],\n        'no-reload'  => [\n            'long'        => 'no-reload',\n            'short'       => 'b',\n            'description' => 'Force no lists reload',\n        ],\n        'verbose'    => [\n            'long'        => 'verbose',\n            'short'       => 'v',\n            'description' => 'Turn on verbose mode',\n        ],\n        'debug'      => [\n            'long'        => 'debug',\n            'short'       => 'd',\n            'description' => 'Turn on debug mode',\n        ],\n        'yes'        => [\n            'long'        => 'yes',\n            'short'       => 'y',\n            'description' => 'Automatically reply YES to all questions',\n        ],\n        'force'      => [\n            'long'        => 'force',\n            'short'       => 'f',\n            'description' => 'Force update without checking for newest version',\n            'requires'    => ['update'],\n        ],\n        'update'     => [\n            'long'        => 'update',\n            'function'    => 'updateScript',\n            'description' => 'Update the script using selected git branch',\n            'conflicts'   => ['rollback'],\n        ],\n        'rollback'   => [\n            'long'        => 'rollback',\n            'function'    => 'rollbackScript',\n            'description' => 'Rollback script version to previous',\n            'conflicts'   => ['update'],\n        ],\n        'version'    => [\n            'long'        => 'version',\n            'function'    => 'printVersion',\n            'description' => 'Show script version checksum (and if update is available)',\n            'conflicts'   => ['update', 'rollback'],\n        ],\n        'debug-print' => [\n            'long'        => 'debug-print',\n            'function'    => 'showDebugPrint',\n            'description' => 'Shows debug print only',\n            'hidden'      => true,\n        ],\n        'config'     => [\n            'long'                  => 'config::',\n            'description'           => 'Load alternative configuration file',\n            'parameter-description' => 'file',\n        ],\n        'git-branch' => [\n            'long'                  => 'git-branch::',\n            'description'           => 'Select git branch to pull remote checksum and update from',\n            'parameter-description' => 'branch',\n            'requires'              => ['version', 'update'],\n        ],\n        'env'        => [\n            'long'        => 'env',\n            'short'       => 'e',\n            'description' => 'Load configuration from environment variables',\n        ],\n    ];\n}\n\n/**\n * Re-run the script with sudo when not running as root\n *\n * This check is ignored if script is not installed\n */\nfunction requireRoot()\n{\n    global $isRoot;\n\n    if (!isset($isRoot) || $isRoot === null) {\n        $isRoot = null;\n\n        if (function_exists('posix_getuid')) {\n            $isRoot = posix_getuid() === 0;\n        } else {\n            $isRoot = shell_exec('whoami') === 'root';\n        }\n    }\n    \n    if (!$isRoot && strpos(basename($_SERVER['argv'][0]), '.php') === false) {\n        print 'root privileges required' . PHP_EOL;\n        exit(1);\n    }\n}\n\n/**\n * Parse command-line options\n */\nfunction parseOptions()\n{\n    $definedOptions = getDefinedOptions();\n    $shortOpts      = [];\n    $longOpts       = [];\n\n    foreach ($definedOptions as $i => $data) {\n        if (isset($data['long'])) {\n            if (in_array($data['long'], $longOpts)) {\n                throw new RuntimeException('Unable to define long option because it is already defined: ' . $data['long']);\n            }\n\n            $longOpts[] = $data['long'];\n        }\n\n        if (isset($data['short'])) {\n            if (in_array($data['short'], $longOpts)) {\n                throw new RuntimeException('Unable to define short option because it is already defined: ' . $data['short']);\n            }\n\n            $shortOpts[] = $data['short'];\n        }\n    }\n\n    $options = getopt(implode('', $shortOpts), $longOpts);\n\n    // --help will take priority always\n    if ((isset($options['help']) || isset($options['h'])) && isset($definedOptions['help']['function'])) {\n        $runFunction = $definedOptions['help']['function'];\n        $runFunction($options, loadConfig($options));\n        exit;\n    }\n\n    // If short is used set the long one\n    foreach ($options as $option => $data) {\n        foreach ($definedOptions as $definedOptionsIndex => $definedOptionsData) {\n            $definedOptionsData['short'] = isset($definedOptionsData['short']) ? str_replace(':', '', $definedOptionsData['short']) : '';\n            $definedOptionsData['long']  = isset($definedOptionsData['long']) ? str_replace(':', '', $definedOptionsData['long']) : '';\n\n            if (\n                $definedOptionsData['short'] === $option ||\n                $definedOptionsData['long'] === $option\n            ) {\n                // Replaces short option with long in $options\n                if (\n                    !empty($definedOptionsData['short']) &&\n                    !empty($definedOptionsData['long']) &&\n                    $definedOptionsData['short'] === $option\n                ) {\n                    $options[$definedOptionsData['long']] = $data;\n                    unset($options[$option]);\n                }\n\n                // Set function to run if it is defined for this option\n                if (!isset($runFunction) && isset($definedOptionsData['function']) && function_exists($definedOptionsData['function'])) {\n                    $runFunction = $definedOptionsData['function'];\n                }\n            }\n        }\n    }\n\n    foreach ($options as $option => $data) {\n        if (isset($definedOptions[$option]['conflicts'])) {\n            foreach ($definedOptions[$option]['conflicts'] as $conflictingOption) {\n                if (isset($options[$conflictingOption])) {\n                    print 'Options \"--' . $option . '\" and \"--' . $conflictingOption . '\" cannot be used together' . PHP_EOL;\n                    exit(1);\n                }\n            }\n        } elseif (isset($definedOptions[$option]['requires'])) {\n            $requirementsMet = 0;\n\n            $anotherOptionsList = '';\n            foreach ($definedOptions[$option]['requires'] as $requiredOption) {\n                if (isset($options[$requiredOption])) {\n                    $requirementsMet++;\n                }\n\n                if (!empty($anotherOptionsList)) {\n                    $anotherOptionsList .= ', ';\n                }\n\n                $anotherOptionsList .= '\"--' . $requiredOption . '\"';\n            }\n\n            if ($requirementsMet === 0) {\n                print 'Option \"--' . $option . '\" can only be used with specific option(s) (' . $anotherOptionsList . ')' . PHP_EOL;\n                exit(1);\n            }\n        }\n    }\n\n    global $argv;\n    unset($argv[0]); // Remove path to self\n\n    // Split \"-asdf\" into \"-a -s -d -f\" to prevent a bug (issues/66#issuecomment-787836262)\n    foreach ($argv as $key => $option) {\n        if (substr($option, 0, 1) === '-' && substr($option, 0, 2) !== '--') {\n            foreach (str_split(substr($option, 1)) as $character) {\n                $argv[] = '-' . $character;\n            }\n\n            unset($argv[$key]);\n        }\n    }\n\n    // Remove recognized options from argv[]\n    foreach ($options as $option => $data) {\n        $result = array_filter($argv, function ($el) use ($option) {\n            return strpos($el, $option) !== false;\n        });\n\n        if (!empty($result)) {\n            unset($argv[key($result)]);\n        }\n\n        if (isset($definedOptions[$option]['short'])) {\n            $shortOption = $definedOptions[$option]['short'];\n\n            $result = array_filter($argv, function ($el) use ($shortOption) {\n                return strpos($el, $shortOption) !== false;\n            });\n\n            if (!empty($result) && !preg_match('/^--' . $shortOption . '/', $argv[key($result)])) {\n                $argv[key($result)] = str_replace('-' . $shortOption, '', $argv[key($result)]);\n\n                if ($argv[key($result)] === '-' || $argv[key($result)] === '') {\n                    unset($argv[key($result)]);\n                }\n\n                if (empty($argv[key($result)])) {\n                    unset($argv[key($result)]);\n                }\n            }\n        }\n    }\n\n    // When unknown option is used\n    if (count($argv) > 0) {\n        print 'Unknown option(s): ' . implode(' ', $argv) . PHP_EOL;\n        exit(1);\n    }\n\n    // Run the function\n    if (isset($runFunction)) {\n        $runFunction($options, loadConfig($options));\n        exit;\n    }\n\n    requireRoot(); // Require root privileges\n\n    return $options;\n}\n\n/**\n * Register object oriented wrapper for cURL/file_get_contents\n *\n * @return void\n */\nfunction registerHttpClient()\n{\n    if (!class_exists('HttpClient')) {\n        if (function_exists('curl_init')) {\n            class HttpClient\n            {\n                /**\n                 * @var CurlHandle\n                 */\n                private $curl;\n\n                /**\n                 * @param array $config\n                 */\n                public function __construct(array $config = null)\n                {\n                    $this->init();\n                    $this->setopt(CURLOPT_RETURNTRANSFER, true);\n                    $this->setopt(CURLOPT_FOLLOWLOCATION, true);\n\n                    if (is_array($config)) {\n                        isset($config['timeout']) && $this->setopt(CURLOPT_TIMEOUT, $config['timeout']);\n                        isset($config['user_agent']) && $this->setopt(CURLOPT_USERAGENT, $config['user_agent']);\n                    }\n                }\n\n                /**\n                 * @param string $function\n                 * @param array  $parameters\n                 *\n                 * @return mixed\n                 */\n                public function __call($function, array $parameters)\n                {\n                    $function = strtolower($function);\n\n                    if ($function === 'init' || $function === 'multi_init') {\n                        is_resource($this->curl) && curl_close($this->curl);\n\n                        return $this->curl = call_user_func_array('curl_' . $function, $parameters);\n                    } else {\n                        array_unshift($parameters, $this->curl);\n                        return call_user_func_array('curl_' . $function, $parameters);\n                    }\n                }\n\n                /**\n                 * @param string $url\n                 *\n                 * @return string|false\n                 */\n                public function get($url)\n                {\n                    $this->setopt(CURLOPT_URL, $url);\n\n                    return $this->exec();\n                }\n\n                /**\n                 * @return int|null\n                 */\n                public function getStatusCode()\n                {\n                    return (int) $this->getinfo(CURLINFO_HTTP_CODE);\n                }\n\n                /**\n                 * @param string $url\n                 *\n                 * @return string|false\n                 */\n                public function getWithHeaders($url)\n                {\n                    $this->setopt(CURLOPT_HEADER, true);\n                    $return = $this->get($url);\n                    $this->setopt(CURLOPT_HEADER, false);\n\n                    return $return;\n                }\n\n                /**\n                 * @return int\n                 */\n                public function getHeaderSize()\n                {\n                    return $this->getinfo(CURLINFO_HEADER_SIZE);\n                }\n            }\n        } else {\n            class HttpClient\n            {\n                /**\n                 * @var array\n                 */\n                private $streamContextArray;\n\n                /**\n                 * @param string\n                 */\n                private $headers;\n\n                /**\n                 * @param string $url\n                 */\n                public function __construct(array $config = null)\n                {\n                    if (is_array($config)) {\n                        $this->streamContextArray = [\n                            'http' => [\n                                'timeout'         => $config['timeout'],\n                                'user_agent'      => $config['user_agent'],\n                                'follow_location' => true,\n                            ],\n                        ];\n                    }\n                }\n\n                /**\n                 * @param string $function\n                 * @param array  $parameters\n                 *\n                 * @return mixed\n                 */\n                public function __call($function, array $parameters)\n                {\n                    return null;\n                }\n\n                /**\n                 * @param string $url\n                 * @param string $withHeaders\n                 *\n                 * @return string|false\n                 */\n                public function get($url, $withHeaders = false)\n                {\n                    $streamContext = $this->streamContextArray;\n                    if ($withHeaders === true) {\n                        $streamContext['http']['ignore_errors'] = false;\n\n                        global $http_response_header;\n                    }\n\n                    $this->headers = null;\n                    $return        = file_get_contents($url, false, stream_context_create($streamContext));\n\n                    if ($withHeaders === true) {\n                        $headersAsString = '';\n                        foreach ($http_response_header as $header) {\n                            $headersAsString .= $header . \"\\r\\n\";\n                        }\n\n                        $this->headers = $headersAsString . \"\\r\\n\\r\\n\";\n\n                        return $this->headers . $return;\n                    }\n\n                    if ($return === false || $return == '') {\n                        return false;\n                    }\n\n                    return $return;\n                }\n\n                /**\n                 * @return int|null\n                 */\n                public function getStatusCode()\n                {\n                    if ($this->headers !== null) {\n                        preg_match_all('/HTTP.*(\\d{3})/', $this->headers, $matches);\n\n                        if (isset($matches[1]) && count($matches[1]) > 0) {\n                            return (int) $matches[1][count($matches[1]) - 1];\n                        }\n                    }\n\n                    return null;\n                }\n\n                /**\n                 * @param string $url\n                 *\n                 * @return string|false\n                 */\n                public function getWithHeaders($url)\n                {\n                    return $this->get($url, true);\n                }\n\n                /**\n                 * @return int\n                 */\n                public function getHeaderSize()\n                {\n                    return $this->headers !== null ? strlen($this->headers) : 0;\n                }\n            }\n        }\n    }\n}\n\n/**\n * Create HTTP client instance\n *\n * @param array|null $config\n *\n * @return HttpClient|void\n */\nfunction createHttpClient(array $config = null)\n{\n    registerHttpClient();\n\n    $defaultConfig = [\n        'timeout'    => 60,\n        'user_agent' => (function_exists('curl_version') ? 'curl/' . curl_version()['version'] . ' ' : '') . 'PHP/' . PHP_VERSION,\n    ];\n    $config = array_merge($defaultConfig, $config ?? []);\n\n    return new HttpClient($config);\n}\n\n/**\n * Wrapper function for doing requests to files\n *\n * @param string $url\n *\n * @return string|false\n */\nfunction fetchFileContents($url)\n{\n    if (file_exists($url) || !filter_var($url, FILTER_VALIDATE_URL)) {\n        return file_get_contents($url);\n    }\n\n    global $httpClient;\n\n    $result = $httpClient->get($url);\n\n    if (is_int($httpStatusCode = $httpClient->getStatusCode()) && $httpStatusCode > 0 && substr((string) $httpStatusCode, 0, 1) !== '2') {\n        global $customError;\n\n        $customError = 'HTTP request failed with status code ' . $httpStatusCode;\n\n        return false;\n    }\n\n    return $result;\n}\n\n/**\n * Fetch remote script file\n *\n * @param string $branch\n * @param bool   $debug\n *\n * @return string|false\n */\nfunction fetchRemoteScript($branch = 'master', $debug = false)\n{\n    global $remoteScript, $customError;\n\n    if (isset($remoteScript[$branch])) {\n        return $remoteScript[$branch];\n    }\n\n    $httpClient  = createHttpClient(['timeout' => 15]);\n    $response    = $httpClient->getWithHeaders(GITHUB_LINK_RAW . '/' . $branch . '/pihole-updatelists.php');\n    $header_size = $httpClient->getHeaderSize();\n\n    if ($response === false) {\n        $customError = 'HTTP request failed';\n\n        return false;\n    }\n\n    $headers = [];\n    foreach (explode(\"\\r\\n\", substr($response, 0, $header_size)) as $i => $line) {\n        if ($i === 0) {\n            preg_match('/(\\d{3})/', $line, $matches);\n            $headers['http_code'] = (int) $matches[1];\n        } elseif (!empty($line)) {\n            list($key, $value) = explode(': ', $line);\n\n            $headers[$key] = $value;\n        }\n    }\n\n    $remoteScript[$branch] = substr($response, $header_size);\n\n    $isSuccessful = false;\n    if ($headers['http_code'] === 200) {\n        $isSuccessful = true;\n    }\n\n    if ($isSuccessful) {\n        $firstLine = strtok($remoteScript[$branch], \"\\n\");\n\n        if (strpos($firstLine, '#!/usr/bin/env php') === false) {\n            $customError = 'Returned remote script data doesn\\'t seem to be valid';\n\n            if ($debug === true) {\n                print $customError . PHP_EOL;\n                print 'First line: ' . $firstLine . PHP_EOL;\n\n                exit(1);\n            }\n\n            return false;\n        }\n\n        return $remoteScript[$branch];\n    }\n\n    $customError = 'Failed to fetch remote file';\n\n    return false;\n}\n\n/**\n * Check if script is up to date\n *\n * @param string $branch\n * @param bool   $debug\n *\n * @return string\n */\nfunction isUpToDate($branch = 'master', $debug = false)\n{\n    $md5Self      = md5_file(__FILE__);\n    $remoteScript = fetchRemoteScript($branch, $debug);\n\n    if ($remoteScript === false) {\n        return null;\n    }\n\n    if ($md5Self !== md5($remoteScript)) {\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Returns currently selected branch\n *\n * @param array $options\n * @param array $config\n */\nfunction getBranch(array $options = [], array $config = [])\n{\n    $branch = 'master';\n\n    if (!empty($options['git-branch'])) {\n        $branch = $options['git-branch'];\n    } elseif (!empty($config['GIT_BRANCH'])) {\n        $branch = $config['GIT_BRANCH'];\n    }\n\n    return $branch;\n}\n\n/**\n * Print help\n *\n * @param array $options\n * @param array $config\n */\nfunction printHelp(array $options = [], array $config = [])\n{\n    $definedOptions = getDefinedOptions();\n    $help           = [];\n    $maxLen         = 0;\n\n    foreach ($definedOptions as $option) {\n        if (isset($option['hidden']) && $option['hidden'] === true) {\n            continue;\n        }\n\n        $line = ' ';\n\n        if (!isset($option['description'])) {\n            continue;\n        }\n\n        if (isset($option['short'])) {\n            $line .= '-' . $option['short'];\n        }\n\n        if (isset($option['long'])) {\n            if (!empty(trim($line))) {\n                $line .= ', ';\n            }\n\n            $line .= '--' . str_replace(':', '', $option['long']);\n\n            if (isset($option['parameter-description'])) {\n                $line .= '=<' . $option['parameter-description'] . '>';\n            }\n        }\n\n        if (strlen($line) > $maxLen) {\n            $maxLen = strlen($line);\n        }\n\n        $help[$line] = $option['description'];\n    }\n\n    printHeader();\n    print 'Usage: ' . basename(__FILE__) . ' [OPTIONS...] ' . PHP_EOL . PHP_EOL;\n    print 'Options:' . PHP_EOL;\n\n    foreach ($help as $option => $description) {\n        $whitespace = str_repeat(' ', $maxLen - strlen($option) + 2);\n        print $option . $whitespace . $description . PHP_EOL;\n    }\n\n    print PHP_EOL;\n}\n\n/**\n * CLI interactive question\n *\n * @param string $question\n * @param string $validAnswers\n *\n * @return bool\n */\nfunction expectUserInput($question, array $validAnswers = [])\n{\n    print $question . ' : ';\n    $stdin    = fopen('php://stdin', 'r');\n    $response = fgetc($stdin);\n\n    if (in_array(strtolower($response), $validAnswers)) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * This will update the script to newest version\n *\n * @param array $options\n * @param array $config\n */\nfunction updateScript(array $options = [], array $config = [])\n{\n    if (strpos(basename($_SERVER['argv'][0]), '.php') !== false) {\n        print 'It seems like this script haven\\'t been installed - unable to update!' . PHP_EOL;\n        exit(1);\n    }\n\n    requireRoot(); // Only root should be able to run this command\n\n    if (!isset($options['force'])) {\n        $status = printVersion($options, $config, true);\n    } else {\n        $status = false;\n    }\n\n    $branch = getBranch($options, $config);\n\n    if ($status === false) {\n        print 'See changes in commit history - https://github.com/jacklul/pihole-updatelists/commits/' . $branch . PHP_EOL . PHP_EOL;\n\n        if (isset($options['yes']) || isset($options['force']) || expectUserInput('Update now? [Y/N]', ['y', 'yes'])) {\n            $script_md5 = md5_file(__FILE__);\n            \n            print 'Downloading and running install script from \"' . GITHUB_LINK_RAW . '/' . $branch . '/install.sh\"...' . PHP_EOL . PHP_EOL;\n            passthru('wget -nv -O - ' . GITHUB_LINK_RAW . '/' . $branch . '/install.sh | sudo bash /dev/stdin ' . $branch, $return);\n\n            clearstatcache();\n\n            if (file_exists('/var/tmp/pihole-updatelists.old') && $script_md5 != md5_file(__FILE__)) {\n                print PHP_EOL . 'Use \"' . basename(__FILE__) . ' --rollback\" to return to the previous script version!' . PHP_EOL;\n            }\n\n            exit($return);\n        } else {\n            print 'Aborted by user.' . PHP_EOL;\n        }\n    }\n}\n\n/**\n * This will rollback the script to previous version\n *\n * @param array $options\n * @param array $config\n */\nfunction rollbackScript(array $options = [], array $config = [])\n{\n    if (strpos(basename($_SERVER['argv'][0]), '.php') !== false) {\n        print 'It seems like this script haven\\'t been installed - unable to rollback!' . PHP_EOL;\n        exit(1);\n    }\n\n    if (!file_exists('/var/tmp/pihole-updatelists.old')) {\n        print 'Backup file does not exist, unable to rollback!' . PHP_EOL;\n        exit(1);\n    }\n\n    if (md5_file('/usr/local/sbin/pihole-updatelists') === md5_file('/var/tmp/pihole-updatelists.old')) {\n        print 'Current script checksum matches checksum of the backup, unable to rollback!' . PHP_EOL;\n        exit(1);\n    }\n\n    requireRoot(); // Only root should be able to run this command\n\n    if (isset($options['yes']) || expectUserInput('Are you sure you want to rollback? [Y/N]', ['y', 'yes'])) {\n        if (rename('/var/tmp/pihole-updatelists.old', '/usr/local/sbin/pihole-updatelists') && chmod('/usr/local/sbin/pihole-updatelists', 0755)) {\n            print 'Successfully rolled back the script!' . PHP_EOL;\n            exit;\n        }\n\n        print 'Failed to rollback!' . PHP_EOL;\n        exit(1);\n    } else {\n        print 'Aborted by user.' . PHP_EOL;\n    }\n}\n\n/**\n * Check local and remote version and print it\n *\n * @param array $options\n * @param array $config\n *\n * @param bool  $return\n */\nfunction printVersion(array $options = [], array $config = [], $return = false)\n{\n    global $remoteScript;\n\n    $config['DEBUG'] === true && printDebugHeader($options, $config);\n    $branch = getBranch($options, $config);\n\n    print 'Git branch: ' . $branch . PHP_EOL;\n    print 'Local checksum: ' . md5_file(__FILE__) . PHP_EOL;\n\n    $updateCheck = isUpToDate($branch);\n    if ($updateCheck === null) {\n        print 'Failed to check remote script: ' . parseLastError() . PHP_EOL;\n        exit(1);\n    }\n\n    print 'Remote checksum: ' . md5($remoteScript[$branch]) . PHP_EOL;\n\n    if ($updateCheck === true) {\n        print 'The script is up to date!' . PHP_EOL;\n\n        if ($return === true) {\n            return true;\n        }\n\n        exit;\n    }\n\n    print 'Update is available!' . PHP_EOL;\n\n    if ($return === true) {\n        return false;\n    }\n}\n\n/**\n * Prints only the debug output and exits\n *\n * @param array $options\n * @param array $config\n *\n * @return void\n */\nfunction showDebugPrint(array $options = [], array $config = [])\n{\n    printDebugHeader($options, $config);\n    print 'Update check:' . PHP_EOL;\n    printVersion($options, $config);\n    exit;\n}\n\n/**\n * Validate important configuration variables\n *\n * @param array  $config\n * @param string $section\n *\n * @return array\n */\nfunction validateConfig(array $config, $section = null)\n{\n    $configSection = $section ? ' (in configuration section \"' . $section . '\")' : '';\n\n    if (isset($config['COMMENT'])) {\n        if ($config['COMMENT'] === '') {\n            printAndLog('Variable COMMENT must be a string at least 1 characters long!' . $configSection . PHP_EOL, 'ERROR');\n            exit(1);\n        }\n\n        $config['COMMENT'] = trim($config['COMMENT']);\n    }\n\n    if (isset($config['GROUP_ID']) && !is_int($config['GROUP_ID'])) {\n        printAndLog('Variable GROUP_ID must be a number!' . $configSection . PHP_EOL, 'ERROR');\n        exit(1);\n    }\n\n    return $config;\n}\n\n/**\n * Load config file, if exists\n *\n * @param array $options\n *\n * @return array\n */\nfunction loadConfig(array $options = [])\n{\n    // Default configuration\n    $config = [\n        'CONFIG_FILE'             => '/etc/pihole-updatelists.conf',\n        'GRAVITY_DB'              => '/etc/pihole/gravity.db',\n        'LOCK_FILE'               => '/var/lock/pihole-updatelists.lock',\n        'PIHOLE_CMD'              => '/usr/local/bin/pihole',\n        'LOG_FILE'                => '',\n        'ADLISTS_URL'             => '',\n        'WHITELIST_URL'           => '',\n        'REGEX_WHITELIST_URL'     => '',\n        'BLACKLIST_URL'           => '',\n        'REGEX_BLACKLIST_URL'     => '',\n        'COMMENT'                 => 'Managed by pihole-updatelists',\n        'GROUP_ID'                => 0,\n        'PERSISTENT_GROUP'        => true,\n        'REQUIRE_COMMENT'         => true,\n        'MIGRATION_MODE'          => 1,\n        'GROUP_EXCLUSIVE'         => false,\n        'UPDATE_GRAVITY'          => true,\n        'VERBOSE'                 => false,\n        'DEBUG'                   => false,\n        'DOWNLOAD_TIMEOUT'        => 60,\n        'IGNORE_DOWNLOAD_FAILURE' => false,\n        'GIT_BRANCH'              => 'master',\n    ];\n\n    if (isset($options['config'])) {\n        if (!file_exists($options['config']) && !isset($options['env'])) {\n            printAndLog('Invalid file: ' . $options['config'] . PHP_EOL, 'ERROR');\n            exit(1);\n        }\n\n        $config['CONFIG_FILE'] = $options['config'];\n    }\n\n    if (file_exists($config['CONFIG_FILE'])) {\n        $configFile = file_get_contents($config['CONFIG_FILE']);\n\n        // Convert any hash-commented lines to semicolons\n        $configFile = preg_replace('/^\\s{0,}(#)(.*)$/m', ';$2', $configFile);\n\n        $loadedConfig = @parse_ini_string($configFile, true, INI_SCANNER_TYPED);\n        if ($loadedConfig === false) {\n            printAndLog('Failed to load configuration file: ' . parseLastError() . PHP_EOL, 'ERROR');\n            exit(1);\n        }\n\n        unset($loadedConfig['CONFIG_FILE']);\n\n        $config = array_merge($config, $loadedConfig);\n\n        foreach ($config as $var => $val) {\n            if (is_array($val)) {\n                $sectionName = strtoupper($var);\n\n                if (!isset($config['CONFIG_SECTIONS']) || !is_array($config['CONFIG_SECTIONS'])) {\n                    $config['CONFIG_SECTIONS'] = [];\n                }\n\n                $config['CONFIG_SECTIONS'][$sectionName] = validateConfig(processConfigSection($val), $sectionName);\n\n                unset($config[$var]);\n            }\n        }\n    }\n\n    if (isset($options['env'])) {\n        $config = loadConfigFromEnvironment($config);\n    }\n\n    $config = validateConfig($config);\n\n    if (isset($options['no-gravity']) && $config['UPDATE_GRAVITY'] === true) {\n        $config['UPDATE_GRAVITY'] = false;\n    }\n\n    if (isset($options['no-reload']) && $config['UPDATE_GRAVITY'] === false) {\n        $config['UPDATE_GRAVITY'] = null;\n    }\n\n    if (isset($options['verbose'])) {\n        $config['VERBOSE'] = true;\n    }\n\n    if (isset($options['debug'])) {\n        $config['DEBUG'] = true;\n    }\n\n    return $config;\n}\n\n/**\n * Load supported environment config variables\n *\n * @param array $config\n * \n * @return array\n */\nfunction loadConfigFromEnvironment(array $config)\n{\n    $renamedVariables = [ // These variables with be prefixed with \"PHUL_\"\n        'CONFIG_FILE',\n        'GRAVITY_DB',\n        'LOCK_FILE',\n        'PIHOLE_CMD',\n        'LOG_FILE',\n        'VERBOSE',\n        'DEBUG',\n        'GIT_BRANCH',\n    ];\n\n    foreach ($config as $var => $val) {\n        if (in_array($var, $renamedVariables)) {\n            $env = getenv('PHUL_' . $var);\n        } else {\n            $env = getenv($var);\n        }\n\n        if (!empty($env))\n        {\n            switch (gettype($val)) {\n                case \"int\":\n                case \"integer\":\n                    $env = (int)$env;\n                    break;\n                case \"float\":\n                    $env = (float)$env;\n                    break;\n                case \"string\":\n                    $env = (string)$env;\n                    break;\n                case \"bool\":\n                case \"boolean\":\n                    $env = (bool)$env;\n                    break;\n            }\n\n            $config[$var] = $env;\n        }\n    }\n\n    return $config;\n}\n\n/**\n * Remove variables that are useless from section\n *\n * @param array $section\n *\n * @return array\n */\nfunction processConfigSection(array $section)\n{\n    $filteredKeys = [\n        'ADLISTS_URL',\n        'WHITELIST_URL',\n        'REGEX_WHITELIST_URL',\n        'BLACKLIST_URL',\n        'REGEX_BLACKLIST_URL',\n        'COMMENT',\n        'GROUP_ID',\n        'PERSISTENT_GROUP',\n        'GROUP_EXCLUSIVE',\n        'IGNORE_DOWNLOAD_FAILURE',\n    ];\n\n    foreach ($section as $var => &$val) {\n        if (!in_array($var, $filteredKeys)) {\n            unset($section[$var]);\n        }\n    }\n\n    return $section;\n}\n\n/**\n * Process sections in config, if any\n *\n * @param array $config\n *\n * @return array\n */\nfunction processConfigSections(array $config)\n{\n    $defaultConfig         = processConfigSection($config);\n    $defaultConfigFiltered = $defaultConfig;\n\n    foreach ($defaultConfigFiltered as $var => $val) {\n        if (substr($var, -4) === '_URL') {\n            unset($defaultConfigFiltered[$var]);\n        }\n    }\n\n    $sections = [];\n    if (isset($config['CONFIG_SECTIONS'])) {\n        $sections = $config['CONFIG_SECTIONS'];\n\n        // Import unset values from main config\n        foreach ($sections as &$section) {\n            $section = array_merge($defaultConfigFiltered, $section);\n        }\n    }\n\n    unset($config['CONFIG_SECTIONS']);\n    $sections = ['DEFAULT' => $defaultConfig] + $sections;\n\n    return $sections;\n}\n\n/**\n * Acquire process lock\n *\n * @param string $lockfile\n * @param bool   $debug\n *\n * @return resource\n */\nfunction acquireLock($lockfile, $debug = false)\n{\n    if (empty($lockfile)) {\n        printAndLog('Lock file not defined!' . PHP_EOL, 'ERROR');\n        exit(1);\n    }\n\n    if ($lock = @fopen($lockfile, 'wb+')) {\n        if (!flock($lock, LOCK_EX | LOCK_NB)) {\n            printAndLog('Another process is already running!' . PHP_EOL, 'ERROR');\n            exit(6);\n        }\n\n        $debug === true && printAndLog('Acquired process lock through file: ' . $lockfile . PHP_EOL, 'DEBUG');\n\n        return $lock;\n    }\n\n    printAndLog('Unable to access path or lock file: ' . $lockfile . PHP_EOL, 'ERROR');\n    exit(1);\n}\n\n/**\n * Shutdown related tasks\n *\n * @return void\n */\nfunction shutdownCleanup()\n{\n    global $config, $lock;\n\n    if ($config['DEBUG'] === true) {\n        printAndLog('Releasing lock and removing lockfile: ' . $config['LOCK_FILE'] . PHP_EOL, 'DEBUG');\n    }\n\n    flock($lock, LOCK_UN) && fclose($lock) && unlink($config['LOCK_FILE']);\n}\n\n/**\n * Just print the header\n *\n * @return void\n */\nfunction printHeader()\n{\n    $header[] = 'Pi-hole\\'s Lists Updater by Jack\\'lul';\n    $header[] = GITHUB_LINK;\n    $offset   = ' ';\n\n    $maxLen = 0;\n    foreach ($header as $string) {\n        $strlen                      = strlen($string);\n        $strlen > $maxLen && $maxLen = $strlen;\n    }\n\n    foreach ($header as &$string) {\n        $strlen = strlen($string);\n\n        if ($strlen < $maxLen) {\n            $diff = $maxLen - $strlen;\n            $addL = ceil($diff / 2);\n            $addR = $diff - $addL;\n\n            $string = str_repeat(' ', (int) $addL) . $string . str_repeat(' ', (int) $addR);\n        }\n\n        $string = $offset . $string;\n    }\n    unset($string);\n\n    printAndLog(trim($header[0]) . ' started' . PHP_EOL, 'INFO', true);\n    print PHP_EOL . implode(PHP_EOL, $header) . PHP_EOL . PHP_EOL;\n}\n\n/**\n * Print debug information\n *\n * @param array $options\n * @param array $config\n */\nfunction printDebugHeader(array $options, array $config)\n{\n    printAndLog('Checksum: ' . md5_file(__FILE__) . PHP_EOL, 'DEBUG');\n    printAndLog('Git branch: ' . getBranch($options, $config) . PHP_EOL, 'DEBUG');\n    printAndLog('OS: ' . php_uname() . PHP_EOL, 'DEBUG');\n    printAndLog('PHP: ' . PHP_VERSION . (ZEND_THREAD_SAFE ? '' : ' NTS') . PHP_EOL, 'DEBUG');\n    printAndLog('SQLite: ' . (new PDO('sqlite::memory:'))->query('select sqlite_version()')->fetch()[0] . PHP_EOL, 'DEBUG');\n    printAndLog('cURL: ' . (function_exists('curl_version') ? curl_version()['version'] : 'Unavailable') . PHP_EOL, 'DEBUG');\n\n    if (file_exists('/etc/pihole/versions')) {\n        $versions = file_get_contents('/etc/pihole/versions');\n        $versions = parse_ini_string($versions);\n\n        $piholeVersions = [\n            $versions['CORE_VERSION'],\n            $versions['WEB_VERSION'],\n            $versions['FTL_VERSION'],\n        ];\n\n        $piholeBranches = [\n            $versions['CORE_BRANCH'],\n            $versions['WEB_BRANCH'],\n            $versions['FTL_BRANCH'],\n        ];\n    }\n\n    if (empty($versions) && file_exists('/etc/pihole/localversions')) {\n        $piholeVersions = file_get_contents('/etc/pihole/localversions');\n        $piholeVersions = explode(' ', $piholeVersions);\n    }\n\n    if (empty($versions) && file_exists('/etc/pihole/localbranches')) {\n        $piholeBranches = file_get_contents('/etc/pihole/localbranches');\n        $piholeBranches = explode(' ', $piholeBranches);\n    }\n\n    if (\n        isset($piholeVersions, $piholeBranches) &&\n        $piholeVersions !== false && $piholeBranches !== false &&\n        count($piholeVersions) === 3 && count($piholeBranches) === 3\n    ) {\n        printAndLog('Pi-hole Core: ' . $piholeVersions[0] . ' (' . $piholeBranches[0] . ')' . PHP_EOL, 'DEBUG');\n        printAndLog('Pi-hole Web: ' . $piholeVersions[1] . ' (' . $piholeBranches[1] . ')' . PHP_EOL, 'DEBUG');\n        printAndLog('Pi-hole FTL: ' . $piholeVersions[2] . ' (' . $piholeBranches[2] . ')' . PHP_EOL, 'DEBUG');\n    } else {\n        printAndLog('Pi-hole: Unavailable' . PHP_EOL, 'WARNING');\n        incrementStat('warnings');\n    }\n\n    ob_start();\n    var_dump($config);\n    printAndLog('Configuration: ' . preg_replace('/=>\\s+/', ' => ', ob_get_clean()), 'DEBUG');\n\n    ob_start();\n    var_dump($options);\n    printAndLog('Options: ' . preg_replace('/=>\\s+/', ' => ', ob_get_clean()), 'DEBUG');\n\n    print PHP_EOL;\n}\n\n/**\n * Register PDO logging class\n *\n * @return void\n */\nfunction registerPDOLogger()\n{\n    if (!class_exists('LoggedPDOStatement')) {\n        class LoggedPDOStatement extends PDOStatement\n        {\n            private $queryParameters = [];\n            private $parsedQuery     = '';\n\n            public function bindValue($parameter, $value, $data_type = PDO::PARAM_STR): bool\n            {\n                $this->queryParameters[$parameter] = [\n                    'value' => $value,\n                    'type'  => $data_type,\n                ];\n\n                return parent::bindValue($parameter, $value, $data_type);\n            }\n\n            public function bindParam($parameter, &$variable, $data_type = PDO::PARAM_STR, $length = null, $driver_options = null): bool\n            {\n                $this->queryParameters[$parameter] = [\n                    'value' => $variable,\n                    'type'  => $data_type,\n                ];\n\n                return parent::bindParam($parameter, $variable, $data_type);\n            }\n\n            public function execute($input_parameters = null): bool\n            {\n                printAndLog('SQL Query: ' . $this->parseQuery() . PHP_EOL, 'DEBUG');\n\n                return parent::execute($input_parameters);\n            }\n\n            private function parseQuery(): string\n            {\n                if (!empty($this->parsedQuery)) {\n                    return $this->parsedQuery;\n                }\n\n                $query = $this->queryString;\n                foreach ($this->queryParameters as $parameter => $data) {\n                    switch ($data['type']) {\n                        case PDO::PARAM_STR:\n                            $value = '\"' . $data['value'] . '\"';\n                            break;\n                        case PDO::PARAM_INT:\n                            $value = (string) $data['value'];\n                            break;\n                        case PDO::PARAM_BOOL:\n                            $value = $data['value'] ? 'true' : 'false';\n                            break;\n                        default:\n                            $value = null;\n                    }\n\n                    $query = str_replace($parameter, $value, $query);\n                }\n\n                return $this->parsedQuery = $query;\n            }\n        }\n    }\n}\n\n/**\n * Open the database\n *\n * @param string $db_file\n * @param bool   $verbose\n * @param bool   $debug\n *\n * @return PDO\n */\nfunction openDatabase($db_file, $verbose = true, $debug = false)\n{\n    $dbh = new PDO('sqlite:' . $db_file);\n    $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n    $dbh->exec('PRAGMA foreign_keys = ON;'); // Require foreign key constraints\n\n    if ($debug) {\n        registerPDOLogger();\n        $dbh->setAttribute(PDO::ATTR_STATEMENT_CLASS, ['LoggedPDOStatement']);\n    }\n\n    if ($verbose) {\n        clearstatcache();\n        printAndLog('Opened gravity database: ' . $db_file . ' (' . formatBytes(filesize($db_file)) . ')' . PHP_EOL);\n    }\n\n    return $dbh;\n}\n\n/**\n * Convert text files from one-entry-per-line to array\n *\n * @param string $text\n *\n * @return array\n *\n * @noinspection OnlyWritesOnParameterInspection\n */\nfunction textToArray($text)\n{\n    global $comments;\n\n    $array    = preg_split('/\\r\\n|\\r|\\n/', $text);\n    $comments = [];\n\n    foreach ($array as $var => &$val) {\n        // Ignore empty lines and those with only a comment\n        if (empty($val) || strpos(trim($val), '#') === 0 || strpos(trim($val), '=') === 0) {\n            unset($array[$var]);\n            continue;\n        }\n\n        $comment = '';\n\n        // Extract value from lines ending with comment\n        if (preg_match('/^(.*)\\s+#\\s*(\\S.*)$/U', $val, $matches)) {\n            list(, $val, $comment) = $matches;\n        }\n\n        $val                                = trim($val);\n        !empty($comment) && $comments[$val] = trim($comment);\n    }\n    unset($val);\n\n    return array_values($array);\n}\n\n/**\n * Checks if a given entry is a single adlist by checking if the first entry in the given $content is a domain\n * instead of an URL\n * \n * @param string $content\n *\n * @return boolean\n */\nfunction isSingleAdlist($content) {\n    $list = textToArray($content);\n\n    if (!empty($list)) {\n        $row_content = explode(' ', $list[0]);\n        \n        return filter_var($row_content[sizeof($row_content) - 1], FILTER_VALIDATE_DOMAIN, FILTER_FLAG_HOSTNAME);\n    }\n\n    return false;\n}\n\n/**\n * Parse last error from error_get_last()\n *\n * @param string $default\n *\n * @return string\n */\nfunction parseLastError($default = 'Unknown error')\n{\n    global $httpClient, $customError;\n\n    if (!empty($customError)) {\n        $returnCustom = $customError;\n        $customError  = '';\n\n        return $returnCustom;\n    }\n\n    $lastError = error_get_last();\n\n    if (is_object($httpClient)) {\n        $lastHttpError = $httpClient->error();\n\n        if (empty($lastError) && !empty($lastHttpError)) {\n            $lastError['message'] = $lastHttpError;\n        }\n    }\n\n    return preg_replace('/file_get_contents(.*): /U', '', trim($lastError['message'] ?? $default)) . (isset($lastError['line']) ? ' (' . $lastError['line'] . ')' : '');\n}\n\n/**\n * @param int $bytes\n * @param int $precision\n *\n * @return string\n */\nfunction formatBytes($bytes, $precision = 2)\n{\n    $units = ['B', 'KB', 'MB', 'GB', 'TB'];\n\n    $bytes = max($bytes, 0);\n    $pow   = floor(($bytes ? log($bytes) : 0) / log(1024));\n    $pow   = min($pow, count($units) - 1);\n    $bytes /= (1 << (10 * $pow));\n\n    return round($bytes, $precision) . ' ' . $units[$pow];\n}\n\n/**\n * Increment values on $stat array\n *\n * @param string $name\n * @param string $deduplication\n *\n * @return void\n */\nfunction incrementStat($name, $deduplication = null)\n{\n    global $stat;\n\n    if (!isset($stat[$name])) {\n        $stat[$name] = 0;\n    }\n\n    if ($deduplication !== null) {\n        if (!isset($stat['list'][$name]) || !is_array($stat['list'][$name])) {\n            if (!isset($stat['list']) || !is_array($stat['list'])) {\n                $stat['list'] = [];\n            }\n\n            $stat['list'][$name] = [];\n        }\n\n        if (in_array($deduplication, $stat['list'][$name], true)) {\n            return;\n        }\n\n        $stat['list'][$name][] = $deduplication;\n    }\n\n    $stat[$name]++;\n}\n\n/**\n * Print summary after processing single list (to be used after 'Processing...' message)\n *\n * @param array $statData\n * @param bool  $noSpace\n *\n * @return void\n */\nfunction printOperationSummary(array $statData, $noSpace = false)\n{\n    $summary = [];\n\n    $statData['exists'] > 0 && $summary[]   = $statData['exists'] . ' exists';\n    $statData['ignored'] > 0 && $summary[]  = $statData['ignored'] . ' ignored';\n    $statData['inserted'] > 0 && $summary[] = $statData['inserted'] . ' inserted';\n    $statData['enabled'] > 0 && $summary[]  = $statData['enabled'] . ' enabled';\n    $statData['disabled'] > 0 && $summary[] = $statData['disabled'] . ' disabled';\n    $statData['invalid'] > 0 && $summary[]  = $statData['invalid'] . ' invalid';\n    $statData['conflict'] > 0 && $summary[] = $statData['conflict'] . ' conflicts';\n    $statData['migrated'] > 0 && $summary[] = $statData['migrated'] . ' migrated';\n\n    if (!empty($summary)) {\n        printAndLog(($noSpace === false ? ' ' : 'Summary: ') . implode(', ', $summary) . PHP_EOL);\n    }\n}\n\n/**\n * Helper function that checks if comment field matches when required\n *\n * @param array  $array\n * @param string $comment\n * @param bool   $require_comment\n *\n * @return bool\n */\nfunction checkIfTouchable($array, $comment, $require_comment = true)\n{\n    return $require_comment === false || (!empty($comment) && strpos($array['comment'] ?? '', $comment) !== false);\n};\n\n/** PROCEDURAL CODE STARTS HERE */\n$startTime   = microtime(true);\n$customError = '';\ncheckDependencies(); // Check script requirements\n$options        = parseOptions(); // Parse options\n$config         = loadConfig($options); // Load config and process variables\n$configSections = processConfigSections($config); // Process sections\n\n// Make sure we have at least one remote URL set\n$remoteListsAreSet = false;\nforeach ($configSections as $configSectionName => $configSectionData) {\n    $sectionHasList = false;\n\n    foreach ($configSectionData as $var => $val) {\n        if (substr($var, -4) === '_URL' && !empty($val)) {\n            $remoteListsAreSet = true;\n            $sectionHasList    = true;\n\n            break;\n        }\n    }\n\n    if ($sectionHasList === false) {\n        $configSections[$configSectionName]['SECTION_IGNORED'] = true;\n    }\n}\n\n// Exception handler, always log detailed information\nset_exception_handler(\n    function (Throwable $e) use (&$config) {\n        if ($config['DEBUG'] === false) {\n            print 'Exception: ' . $e->getMessage() . PHP_EOL;\n        }\n\n        printAndLog($e . PHP_EOL, 'ERROR', $config['DEBUG'] === false);\n        exit(1);\n    }\n);\n\n$lock = acquireLock($config['LOCK_FILE'], $config['DEBUG']); // Make sure this is the only instance\nregister_shutdown_function('shutdownCleanup'); // Cleanup when script finishes\n\n// Handle script interruption / termination\nif (function_exists('pcntl_signal')) {\n    declare (ticks = 1);\n\n    function signalHandler($signo)\n    {\n        $definedConstants = get_defined_constants(true);\n        $signame          = null;\n\n        if (isset($definedConstants['pcntl'])) {\n            foreach ($definedConstants['pcntl'] as $name => $num) {\n                if ($num === $signo && strpos($name, 'SIG') === 0 && $name[3] !== '_') {\n                    $signame = $name;\n                }\n            }\n        }\n\n        printAndLog(PHP_EOL . 'Interrupted by ' . ($signame ?? $signo) . PHP_EOL, 'NOTICE');\n        exit(130);\n    }\n\n    pcntl_signal(SIGHUP, 'signalHandler');\n    pcntl_signal(SIGTERM, 'signalHandler');\n    pcntl_signal(SIGINT, 'signalHandler');\n}\n\n// This array holds stats data\n$stat = [\n    'errors'   => 0,\n    'warnings' => 0,\n    'exists'   => 0,\n    'ignored'  => 0,\n    'inserted' => 0,\n    'enabled'  => 0,\n    'disabled' => 0,\n    'invalid'  => 0,\n    'conflict' => 0,\n    'migrated' => 0,\n];\n\nprintHeader(); // Hi\ncheckOptionalDependencies(); // Check for optional stuff\n\n// Show initial debug messages\n$config['DEBUG'] === true && printDebugHeader($options, $config);\n\n// Show deprecated/removed options messages\n$deprecatedAndRemovedOptions      = ['VACUUM_DATABASE'];\n$deprecatedAndRemovedOptionsFound = false;\nforeach ($config as $option => $value) {\n    if (in_array($option, $deprecatedAndRemovedOptions)) {\n        printAndLog('Configuration option ' . $option . ' has been removed.' . PHP_EOL, 'WARNING');\n        incrementStat('warnings');\n        $deprecatedAndRemovedOptionsFound = true;\n    }\n}\n$deprecatedAndRemovedOptionsFound && print PHP_EOL;\n\n// Open the database\n$dbh = openDatabase($config['GRAVITY_DB'], true, $config['DEBUG']);\n\nprint PHP_EOL;\n\n// Initialize http client\n$httpOptions = [\n    'timeout'    => $config['DOWNLOAD_TIMEOUT'],\n    'user_agent' => 'Pi-hole\\'s Lists Updater (' . preg_replace('#^https?://#', '', rtrim(GITHUB_LINK, '/')) . ')',\n];\n$httpClient = createHttpClient($httpOptions);\n\n// Iterate config sections\nforeach ($configSections as $configSectionName => $configSectionData) {\n    if (isset($configSectionData['SECTION_IGNORED']) && $configSectionData['SECTION_IGNORED'] === true) {\n        continue;\n    }\n\n    if (count($configSections) > 1) {\n        printAndLog('Executing using configuration section \"' . $configSectionName . '\"...' . PHP_EOL . PHP_EOL, 'INFO');\n    }\n\n    // Make sure group exists\n    if (($absoluteGroupId = abs($configSectionData['GROUP_ID'])) > 0) {\n        $sth = $dbh->prepare('SELECT `id` FROM `group` WHERE `id` = :id');\n        $sth->bindParam(':id', $absoluteGroupId, PDO::PARAM_INT);\n\n        if ($sth->execute() && $sth->fetch(PDO::FETCH_ASSOC) === false) {\n            printAndLog('Group with ID = ' . $absoluteGroupId . ' does not exist!' . ' (skipped configuration section \"' . $configSectionName . '\")' . PHP_EOL . PHP_EOL, 'ERROR');\n            incrementStat('errors');\n            continue;\n        }\n    }\n\n    // Fetch ADLISTS\n    if (!empty($configSectionData['ADLISTS_URL'])) {\n        $multipleLists = false;\n        $statCopy      = [\n            'exists'   => $stat['exists'],\n            'ignored'  => $stat['ignored'],\n            'inserted' => $stat['inserted'],\n            'enabled'  => $stat['enabled'],\n            'disabled' => $stat['disabled'],\n            'invalid'  => $stat['invalid'],\n            'conflict' => $stat['conflict'],\n            'migrated' => $stat['migrated'],\n        ];\n        $summaryBuffer = [];\n\n        // Fetch all adlists\n        $adlistsAll = [];\n        if (($sth = $dbh->prepare('SELECT * FROM `adlist`'))->execute()) {\n            $adlistsAll = $sth->fetchAll(PDO::FETCH_ASSOC);\n\n            $tmp = [];\n            foreach ($adlistsAll as $key => $value) {\n                $tmp[$value['id']] = $value;\n            }\n\n            $adlistsAll = $tmp;\n            unset($tmp);\n        }\n\n        // Fetch adlist groups\n        $adlistsGroupsAll = [];\n        if (($sth = $dbh->prepare('SELECT * FROM `adlist_by_group`'))->execute()) {\n            $adlistsGroupsAll = $sth->fetchAll(PDO::FETCH_ASSOC);\n\n            $tmp = [];\n            foreach ($adlistsAll as $adlist) {\n                $tmp[$adlist['id']] = [];\n            }\n\n            foreach ($adlistsGroupsAll as $key => $value) {\n                if (!isset($tmp[$value['adlist_id']]) || !is_array($tmp[$value['adlist_id']])) {\n                    $tmp[$value['adlist_id']] = [];\n                }\n\n                $tmp[$value['adlist_id']][] = (int) $value['group_id'];\n            }\n\n            $adlistsGroupsAll = $tmp;\n            unset($tmp);\n        }\n\n        if (preg_match('/\\s+/', trim($configSectionData['ADLISTS_URL']))) {\n            $adlistsUrl    = preg_split('/\\s+/', $configSectionData['ADLISTS_URL']);\n            $multipleLists = true;\n\n            $contents = '';\n            foreach ($adlistsUrl as $url) {\n                if (!empty($url)) {\n                    printAndLog('Fetching ADLISTS from \\'' . $url . '\\'...');\n\n                    $listContents = @fetchFileContents($url, $httpOptions);\n\n                    if (isSingleAdlist($listContents)) {\n                        $listContents = $url;\n                    }\n\n                    if ($listContents !== false) {\n                        printAndLog(' done' . PHP_EOL);\n\n                        $contents .= PHP_EOL . $listContents;\n                    } else {\n                        if ($configSectionData['IGNORE_DOWNLOAD_FAILURE'] === false) {\n                            printAndLog(' ' . parseLastError() . PHP_EOL, 'ERROR');\n\n                            incrementStat('errors');\n                            $contents = false;\n                            break;\n                        } else {\n                            printAndLog(' ' . parseLastError() . PHP_EOL, 'WARNING');\n                            incrementStat('warnings');\n                        }\n                    }\n                }\n            }\n\n            $contents !== false && printAndLog('Merging multiple lists...');\n        } else {\n            printAndLog('Fetching ADLISTS from \\'' . $configSectionData['ADLISTS_URL'] . '\\'...');\n\n            $contents = @fetchFileContents($configSectionData['ADLISTS_URL'], $httpOptions);\n        }\n\n        if ($contents !== false) {\n            $adlists = textToArray($contents);\n            printAndLog(' done (' . count($adlists) . ' entries)' . PHP_EOL);\n\n            printAndLog('Processing...' . ($config['VERBOSE'] === true || $config['DEBUG'] === true ? PHP_EOL : ''));\n            $dbh->beginTransaction();\n\n            // Get enabled adlists managed by this script from the DB\n            $sql = 'SELECT * FROM `adlist` WHERE `enabled` = 1';\n\n            if ($config['REQUIRE_COMMENT'] === true) {\n                $sth = $dbh->prepare($sql .= ' AND `comment` LIKE :comment');\n                $sth->bindValue(':comment', '%' . $configSectionData['COMMENT'] . '%', PDO::PARAM_STR);\n            } else {\n                $sth = $dbh->prepare($sql);\n            }\n\n            $enabledLists = [];\n            if ($sth->execute()) {\n                foreach ($sth->fetchAll(PDO::FETCH_ASSOC) as $adlist) {\n                    $enabledLists[$adlist['id']] = $adlist['address'];\n                }\n            }\n\n            // Pull entries assigned to this group ID\n            if ($configSectionData['GROUP_EXCLUSIVE'] === true) {\n                $sth = $dbh->prepare('SELECT * FROM `adlist` LEFT JOIN `adlist_by_group` ON `adlist`.`id` = `adlist_by_group`.`adlist_id` WHERE `adlist`.`enabled` = 1 AND `adlist_by_group`.`group_id` = :group_id');\n                $sth->bindValue(':group_id', $absoluteGroupId, PDO::PARAM_INT);\n\n                if ($sth->execute()) {\n                    foreach ($sth->fetchAll(PDO::FETCH_ASSOC) as $adlist) {\n                        if (!isset($enabledLists[$adlist['id']])) {\n                            $enabledLists[$adlist['id']] = $adlist['address'];\n                        }\n                    }\n                }\n            }\n\n            // Entries that no longer exist in remote list\n            $removedLists = array_diff($enabledLists, $adlists);\n\n            foreach ($removedLists as $id => $address) {\n                $allConfigurationsGroups = [];\n                foreach ($configSections as $testConfigSectionName => $testConfigSectionData) {\n                    $allConfigurationsGroups[] = abs($testConfigSectionData['GROUP_ID']);\n                }\n\n                $foreignGroups = [];\n                foreach ($adlistsGroupsAll[$id] as $groupId) {\n                    if (!in_array($groupId, $allConfigurationsGroups) && ($groupId !== 0 || $configSectionData['GROUP_ID'] < 0)) {\n                        $foreignGroups[] = $groupId;\n                    }\n                }\n    \n                if (checkIfTouchable($adlistsAll[$id], $configSectionData['COMMENT'], $config['REQUIRE_COMMENT'])) {\n                    $removed = 0;\n\n                    // Remove from the set group\n                    if ($absoluteGroupId > 0) {\n                        $sth = $dbh->prepare('DELETE FROM `adlist_by_group` WHERE `adlist_id` = :adlist_id AND group_id = :group_id');\n                        $sth->bindParam(':adlist_id', $id, PDO::PARAM_INT);\n                        $sth->bindValue(':group_id', $absoluteGroupId, PDO::PARAM_INT);\n                        $sth->execute();\n                        $removed += $sth->rowCount();\n                    }\n\n                    // Remove from the default group\n                    if ($configSectionData['GROUP_ID'] >= 0) {\n                        $sth = $dbh->prepare('DELETE FROM `adlist_by_group` WHERE adlist_id = :adlist_id AND group_id = :group_id');\n                        $sth->bindParam(':adlist_id', $id, PDO::PARAM_INT);\n                        $sth->bindValue(':group_id', 0, PDO::PARAM_INT);\n                        $sth->execute();\n                        $removed += $sth->rowCount();\n                    }\n\n                    if ($removed > 0) {\n                        $config['VERBOSE'] === true && printAndLog('Disabled: ' . $address . PHP_EOL);\n                        incrementStat('disabled');\n                    }\n                }\n                \n                // Disable entry when it's touchable and no user groups are assigned\n                if (count($foreignGroups) === 0) {\n                    foreach ($configSections as $testConfigSectionName => $testConfigSectionData) {\n                        if (checkIfTouchable($adlistsAll[$id], $testConfigSectionData['COMMENT'], $config['REQUIRE_COMMENT'])) {\n                            $sth = $dbh->prepare('UPDATE `adlist` SET `enabled` = 0 WHERE `id` = :id');\n                            $sth->bindParam(':id', $id, PDO::PARAM_INT);\n\n                            if ($sth->execute()) {\n                                $adlistsAll[$id]['enabled'] = false;\n                            }\n\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Helper function to check whenever adlist already exists\n            $checkAdlistExists = static function ($address) use (&$adlistsAll) {\n                $result = array_filter(\n                    $adlistsAll,\n                    static function ($array) use ($address) {\n                        return isset($array['address']) && $array['address'] === $address;\n                    }\n                );\n\n                return count($result) === 1 ? array_values($result)[0] : false;\n            };\n\n            foreach ($adlists as $address) {\n                if (!filter_var($address, FILTER_VALIDATE_URL)) {\n                    if ($config['VERBOSE'] === true) {\n                        printAndLog('Invalid: ' . $address . PHP_EOL, 'NOTICE');\n                    } else {\n                        $summaryBuffer['invalid'][] = $address;\n                    }\n\n                    incrementStat('invalid');\n                    continue;\n                }\n\n                $adlistUrl = $checkAdlistExists($address);\n                if ($adlistUrl === false) {\n                    // Add entry if it doesn't exist\n                    $sth = $dbh->prepare('INSERT INTO `adlist` (address, enabled, comment) VALUES (:address, 1, :comment)');\n                    $sth->bindParam(':address', $address, PDO::PARAM_STR);\n\n                    $comment = $configSectionData['COMMENT'];\n                    if (isset($comments[$address])) {\n                        $comment = $comments[$address] . ($comment !== '' ? ' | ' . $comment : '');\n                    }\n                    $sth->bindParam(':comment', $comment, PDO::PARAM_STR);\n\n                    if ($sth->execute()) {\n                        $lastInsertId = $dbh->lastInsertId();\n\n                        // Insert this adlist into cached list of all adlists to prevent future duplicate errors\n                        $adlistsAll[$lastInsertId] = [\n                            'id'      => $lastInsertId,\n                            'address' => $address,\n                            'enabled' => true,\n                            'comment' => $comment,\n                        ];\n\n                        if ($absoluteGroupId > 0) {\n                            // Add to the specified group\n                            $sth = $dbh->prepare('INSERT OR IGNORE INTO `adlist_by_group` (adlist_id, group_id) VALUES (:adlist_id, :group_id)');\n                            $sth->bindParam(':adlist_id', $lastInsertId, PDO::PARAM_INT);\n                            $sth->bindParam(':group_id', $absoluteGroupId, PDO::PARAM_INT);\n                            $sth->execute();\n\n                            if ($configSectionData['GROUP_ID'] < 0) {\n                                // Remove from the default group\n                                $sth = $dbh->prepare('DELETE FROM `adlist_by_group` WHERE adlist_id = :adlist_id AND group_id = :group_id');\n                                $sth->bindParam(':adlist_id', $lastInsertId, PDO::PARAM_INT);\n                                $sth->bindValue(':group_id', 0, PDO::PARAM_INT);\n                                $sth->execute();\n                            }\n                        }\n\n                        $config['VERBOSE'] === true && printAndLog('Inserted: ' . $address . PHP_EOL);\n                        incrementStat('inserted');\n                    }\n                } else {\n                    $isTouchable          = checkIfTouchable($adlistUrl, $configSectionData['COMMENT'], $config['REQUIRE_COMMENT']);\n                    $adlistUrl['enabled'] = (bool) $adlistUrl['enabled'] === true;\n\n                    // Check if entry has any groups assigned\n                    $hasGroups = true;\n                    if ($configSectionData['PERSISTENT_GROUP'] === false) {\n                        $sth = $dbh->prepare('SELECT * FROM `adlist_by_group` WHERE `adlist_by_group`.`adlist_id` = :adlist_id');\n                        $sth->bindValue(':adlist_id', $adlistUrl['id'], PDO::PARAM_INT);\n                        if ($sth->execute() && empty($sth->fetchAll(PDO::FETCH_ASSOC))) {\n                            $hasGroups = false;\n                        }\n                    }\n\n                    // Enable existing entry but only if it's managed by this script\n                    if ($adlistUrl['enabled'] !== true && $isTouchable === true) {\n                        $sth = $dbh->prepare('UPDATE `adlist` SET `enabled` = 1 WHERE `id` = :id');\n                        $sth->bindParam(':id', $adlistUrl['id'], PDO::PARAM_INT);\n\n                        if ($sth->execute()) {\n                            $adlistsAll[$adlistUrl['id']]['enabled'] = true;\n\n                            $config['VERBOSE'] === true && printAndLog('Enabled: ' . $address . PHP_EOL);\n                            incrementStat('enabled');\n                        }\n                    } elseif ($adlistUrl['enabled'] !== false && $isTouchable === true) {\n                        $config['VERBOSE'] === true && printAndLog('Exists: ' . $address . PHP_EOL);\n                        incrementStat('exists');\n                    } elseif ($isTouchable === false) {\n                        // Migration in this context means replacing comment field if current one is also managed by the script\n                        $canBeMigrated = false;\n\n                        if ((int)$config['MIGRATION_MODE'] > 0 && $adlistUrl['enabled'] === false) {\n                            foreach ($configSections as $testConfigSectionName => $testConfigSectionData) {\n                                if (checkIfTouchable($adlistUrl, $testConfigSectionData['COMMENT'], $config['REQUIRE_COMMENT'])) {\n                                    $canBeMigrated = true;\n                                    break;\n                                }\n                            }\n\n                            if ($canBeMigrated) {\n                                if ((int)$config['MIGRATION_MODE'] === 1) {\n                                    $newComment = str_replace($testConfigSectionData['COMMENT'], $configSectionData['COMMENT'], $adlistUrl['comment']);\n                                } elseif ((int)$config['MIGRATION_MODE'] === 2) {\n                                    $newComment = $adlistUrl['comment'] . ' | ' . $configSectionData['COMMENT'];\n                                } else {\n                                    throw new RuntimeException('Invalid migration mode specified');\n                                }\n\n                                $sth = $dbh->prepare('UPDATE `adlist` SET `enabled` = 1, `comment` = :comment WHERE `id` = :id');\n                                $sth->bindParam(':id', $adlistUrl['id'], PDO::PARAM_INT);\n                                $sth->bindParam(':comment', $newComment, PDO::PARAM_STR);\n\n                                if ($sth->execute()) {\n                                    $adlistsAll[$adlistUrl['id']]['enabled'] = true;\n                                    $adlistsAll[$adlistUrl['id']]['comment'] = $newComment;\n\n                                    $oldGroupId = abs($testConfigSectionData['GROUP_ID']);\n\n                                    $sth = $dbh->prepare('DELETE FROM `adlist_by_group` WHERE `adlist_id` = :adlist_id AND `group_id` = :group_id');\n                                    $sth->bindParam(':adlist_id', $adlistUrl['id'], PDO::PARAM_INT);\n                                    $sth->bindParam(':group_id', $oldGroupId, PDO::PARAM_INT);\n                                    $sth->execute();\n\n                                    if (($key = array_search($oldGroupId, $adlistsGroupsAll[$adlistUrl['id']])) !== false) {\n                                        unset($adlistsGroupsAll[$adlistUrl['id']][$key]);\n                                    }\n\n                                    $config['VERBOSE'] === true && printAndLog('Migrated: ' . $address . PHP_EOL);\n                                    incrementStat('migrated');\n                                } else {\n                                    printAndLog('Failed to migrate: ' . $address . PHP_EOL);\n                                    incrementStat('errors');\n                                }\n                            }\n                        }\n\n                        if ($canBeMigrated === false) {\n                            $config['VERBOSE'] === true && printAndLog('Ignored: ' . $address . PHP_EOL);\n                            incrementStat('ignored');\n                        }\n                    }\n\n                    if ($configSectionData['PERSISTENT_GROUP'] === true || $hasGroups == false) {\n                        // (Re)Add to the specified group when not added\n                        if (\n                            $absoluteGroupId > 0 &&\n                            (isset($adlistsGroupsAll[$adlistUrl['id']]) && !in_array($absoluteGroupId, $adlistsGroupsAll[$adlistUrl['id']], true))\n                        ) {\n                            $sth = $dbh->prepare('INSERT OR IGNORE INTO `adlist_by_group` (adlist_id, group_id) VALUES (:adlist_id, :group_id)');\n                            $sth->bindParam(':adlist_id', $adlistUrl['id'], PDO::PARAM_INT);\n                            $sth->bindParam(':group_id', $absoluteGroupId, PDO::PARAM_INT);\n                            $sth->execute();\n\n                            $config['VERBOSE'] === true && $sth->rowCount() && printAndLog('Added \\'' . $address . '\\' to the group with ID = ' . $absoluteGroupId . PHP_EOL);\n                        }\n\n                        // (Re)Add to the default group when not added\n                        if (\n                            $configSectionData['GROUP_ID'] >= 0 &&\n                            (isset($adlistsGroupsAll[$adlistUrl['id']]) && !in_array(0, $adlistsGroupsAll[$adlistUrl['id']], true))\n                        ) {\n                            $sth = $dbh->prepare('INSERT OR IGNORE INTO `adlist_by_group` (adlist_id, group_id) VALUES (:adlist_id, :group_id)');\n                            $sth->bindParam(':adlist_id', $adlistUrl['id'], PDO::PARAM_INT);\n                            $sth->bindValue(':group_id', 0, PDO::PARAM_INT);\n                            $sth->execute();\n\n                            $config['VERBOSE'] === true && $sth->rowCount() && printAndLog('Added \\'' . $address . '\\' to the default group' . PHP_EOL);\n                        }\n                    }\n                }\n            }\n\n            $dbh->commit();\n\n            foreach ($statCopy as $var => $val) {\n                $statCopy[$var] = $stat[$var] - $statCopy[$var];\n            }\n\n            printOperationSummary($statCopy, ($config['VERBOSE'] === true || $config['DEBUG'] === true));\n\n            if ($config['VERBOSE'] === false) {\n                if (isset($summaryBuffer['invalid'])) {\n                    printAndLog('List of invalid entries:' . PHP_EOL . ' ' . implode(PHP_EOL . ' ', $summaryBuffer['invalid']) . PHP_EOL, 'NOTICE');\n                }\n            }\n        } else {\n            if ($multipleLists) {\n                printAndLog('One of the lists failed to download, operation aborted!' . PHP_EOL, 'NOTICE');\n            } else {\n                printAndLog(' ' . parseLastError() . PHP_EOL, 'ERROR');\n                incrementStat('errors');\n            }\n        }\n\n        print PHP_EOL;\n    }\n\n    // This array binds type of list to 'domainlist' table 'type' field, thanks to this we can use foreach loop instead of duplicating code\n    $domainListTypes = [\n        'WHITELIST'       => 0,\n        'REGEX_WHITELIST' => 2,\n        'BLACKLIST'       => 1,\n        'REGEX_BLACKLIST' => 3,\n    ];\n\n    // Fetch all domains from domainlist\n    $domainsAll = [];\n    if (($sth = $dbh->prepare('SELECT * FROM `domainlist`'))->execute()) {\n        $domainsAll = $sth->fetchAll(PDO::FETCH_ASSOC);\n\n        $tmp = [];\n        foreach ($domainsAll as $key => $value) {\n            $tmp[$value['id']] = $value;\n        }\n\n        $domainsAll = $tmp;\n        unset($tmp);\n    }\n\n    // Fetch domainslists entries groups\n    $domainsGroupsAll = [];\n    if (($sth = $dbh->prepare('SELECT * FROM `domainlist_by_group`'))->execute()) {\n        $domainsGroupsAll = $sth->fetchAll(PDO::FETCH_ASSOC);\n\n        $tmp = [];\n        foreach ($domainsAll as $domain) {\n            $tmp[$domain['id']] = [];\n        }\n\n        foreach ($domainsGroupsAll as $key => $value) {\n            if (!isset($tmp[$value['domainlist_id']]) || !is_array($tmp[$value['domainlist_id']])) {\n                $tmp[$value['domainlist_id']] = [];\n            }\n\n            $tmp[$value['domainlist_id']][] = $value['group_id'];\n        }\n\n        $domainsGroupsAll = $tmp;\n        unset($tmp);\n    }\n\n    // Instead of calling this function multiple times later we save the result here...\n    $canConvertIdn = extension_loaded('intl');\n\n    // Helper function to check whenever domain with specific type already exists\n    $checkDomainExists = static function ($domain, $type) use (&$domainsAll) {\n        $result = array_filter(\n            $domainsAll,\n            static function ($array) use ($domain, $type) {\n                return isset($array['domain']) && $array['domain'] === $domain && (int)$array['type'] === (int)$type;\n            }\n        );\n\n        return count($result) === 1 ? array_values($result)[0] : false;\n    };\n\n    // Fetch DOMAINLISTS\n    foreach ($domainListTypes as $typeName => $typeId) {\n        $url_key = $typeName . '_URL';\n\n        if (!empty($configSectionData[$url_key])) {\n            $multipleLists = false;\n            $statCopy      = [\n                'exists'   => $stat['exists'],\n                'ignored'  => $stat['ignored'],\n                'inserted' => $stat['inserted'],\n                'enabled'  => $stat['enabled'],\n                'disabled' => $stat['disabled'],\n                'invalid'  => $stat['invalid'],\n                'conflict' => $stat['conflict'],\n                'migrated' => $stat['migrated'],\n            ];\n            $summaryBuffer = [];\n\n            if (preg_match('/\\s+/', trim($configSectionData[$url_key]))) {\n                $domainlistUrl = preg_split('/\\s+/', $configSectionData[$url_key]);\n                $multipleLists = true;\n\n                $contents = '';\n                foreach ($domainlistUrl as $url) {\n                    if (!empty($url)) {\n                        printAndLog('Fetching ' . $typeName . ' from \\'' . $url . '\\'...');\n\n                        $listContents = @fetchFileContents($url, $httpOptions);\n\n                        if ($listContents !== false) {\n                            printAndLog(' done' . PHP_EOL);\n\n                            $contents .= PHP_EOL . $listContents;\n                        } else {\n                            if ($configSectionData['IGNORE_DOWNLOAD_FAILURE'] === false) {\n                                printAndLog(' ' . parseLastError() . PHP_EOL, 'ERROR');\n\n                                incrementStat('errors');\n                                $contents = false;\n                                break;\n                            } else {\n                                printAndLog(' ' . parseLastError() . PHP_EOL, 'WARNING');\n                                incrementStat('warnings');\n                            }\n                        }\n                    }\n                }\n\n                $contents !== false && printAndLog('Merging multiple lists...');\n            } else {\n                printAndLog('Fetching ' . $typeName . ' from \\'' . $configSectionData[$url_key] . '\\'...');\n\n                $contents = @fetchFileContents($configSectionData[$url_key], $httpOptions);\n            }\n\n            if ($contents !== false) {\n                $domainlist = textToArray($contents);\n                printAndLog(' done (' . count($domainlist) . ' entries)' . PHP_EOL);\n\n                printAndLog('Processing...' . ($config['VERBOSE'] === true || $config['DEBUG'] === true ? PHP_EOL : ''));\n                $dbh->beginTransaction();\n\n                // Get enabled domains of this type managed by this script from the DB\n                $sql = 'SELECT * FROM `domainlist` WHERE `enabled` = 1 AND `type` = :type';\n\n                if ($config['REQUIRE_COMMENT'] === false) {\n                    $sth = $dbh->prepare($sql);\n                } else {\n                    $sth = $dbh->prepare($sql .= ' AND `comment` LIKE :comment');\n                    $sth->bindValue(':comment', '%' . $configSectionData['COMMENT'] . '%', PDO::PARAM_STR);\n                }\n\n                $sth->bindParam(':type', $typeId, PDO::PARAM_INT);\n\n                $enabledDomains = [];\n                if ($sth->execute()) {\n                    foreach ($sth->fetchAll(PDO::FETCH_ASSOC) as $domain) {\n                        if (strpos($typeName, 'REGEX_') === false) {\n                            $enabledDomains[$domain['id']] = strtolower($domain['domain']);\n                        } else {\n                            $enabledDomains[$domain['id']] = $domain['domain'];\n                        }\n                    }\n                }\n\n                // Pull entries assigned to this group ID\n                if ($configSectionData['GROUP_EXCLUSIVE'] === true) {\n                    $sth = $dbh->prepare('SELECT * FROM `domainlist` LEFT JOIN `domainlist_by_group` ON `domainlist`.`id` = `domainlist_by_group`.`domainlist_id` WHERE `domainlist`.`enabled` = 1 AND `domainlist`.`type` = :type AND `domainlist_by_group`.`group_id` = :group_id');\n\n                    $sth->bindParam(':type', $typeId, PDO::PARAM_INT);\n                    $sth->bindValue(':group_id', $absoluteGroupId, PDO::PARAM_INT);\n\n                    if ($sth->execute()) {\n                        foreach ($sth->fetchAll(PDO::FETCH_ASSOC) as $domain) {\n                            if (!isset($enabledDomains[$domain['id']])) {\n                                $enabledDomains[$domain['id']] = $domain['domain'];\n                            }\n                        }\n                    }\n                }\n\n                // Process internationalized domains\n                foreach ($domainlist as &$domain) {\n                    if (strpos($typeName, 'REGEX_') === false) {\n                        // Conversion code 'borrowed' from `scripts/pi-hole/php/groups.php` - 'add_domain'\n                        if ($canConvertIdn) {\n                            $idn_domain = false;\n\n                            if (defined('INTL_IDNA_VARIANT_UTS46')) {\n                                $idn_domain = @idn_to_ascii($domain, IDNA_NONTRANSITIONAL_TO_ASCII, INTL_IDNA_VARIANT_UTS46);\n                            }\n\n                            if ($idn_domain === false && defined('INTL_IDNA_VARIANT_2003')) {\n                                $idn_domain = @idn_to_ascii($domain, IDNA_DEFAULT, INTL_IDNA_VARIANT_2003);\n                            }\n\n                            if ($idn_domain !== false) {\n                                $domain = $idn_domain;\n                            }\n                        }\n\n                        $domain = strtolower($domain);\n                    }\n                }\n                unset($domain);\n\n                // Entries that no longer exist in remote list\n                $removedDomains = array_diff($enabledDomains, $domainlist);\n\n                foreach ($removedDomains as $id => $domain) {\n                    $allConfigurationsGroups = [];\n                    foreach ($configSections as $testConfigSectionName => $testConfigSectionData) {\n                        $allConfigurationsGroups[] = abs($testConfigSectionData['GROUP_ID']);\n                    }\n\n                    $foreignGroups = [];\n                    foreach ($domainsGroupsAll[$id] as $groupId) {\n                        if (!in_array($groupId, $allConfigurationsGroups) && ($groupId !== 0 || $configSectionData['GROUP_ID'] < 0)) {\n                            $foreignGroups[] = $groupId;\n                        }\n                    }\n\n                    if (checkIfTouchable($domainsAll[$id], $configSectionData['COMMENT'], $config['REQUIRE_COMMENT'])) {\n                        $removed = 0;\n\n                        // Remove from the set group\n                        if ($absoluteGroupId > 0) {\n                            $sth = $dbh->prepare('DELETE FROM `domainlist_by_group` WHERE `domainlist_id` = :domainlist_id AND group_id = :group_id');\n                            $sth->bindParam(':domainlist_id', $id, PDO::PARAM_INT);\n                            $sth->bindValue(':group_id', $absoluteGroupId, PDO::PARAM_INT);\n                            $sth->execute();\n                            $removed += $sth->rowCount();\n                        }\n\n                        // Remove from the default group\n                        if ($configSectionData['GROUP_ID'] >= 0) {\n                            $sth = $dbh->prepare('DELETE FROM `domainlist_by_group` WHERE `domainlist_id` = :domainlist_id AND group_id = :group_id');\n                            $sth->bindParam(':domainlist_id', $id, PDO::PARAM_INT);\n                            $sth->bindValue(':group_id', 0, PDO::PARAM_INT);\n                            $sth->execute();\n                            $removed += $sth->rowCount();\n                        }\n\n                        if ($removed > 0) {\n                            $config['VERBOSE'] === true && printAndLog('Disabled: ' . $domain . PHP_EOL);\n                            incrementStat('disabled');\n                        }\n                    }\n\n                    // Disable entry when it's touchable and no user groups are assigned\n                    if (count($foreignGroups) === 0) {\n                        foreach ($configSections as $testConfigSectionName => $testConfigSectionData) {\n                            if (checkIfTouchable($domainsAll[$id], $testConfigSectionData['COMMENT'], $config['REQUIRE_COMMENT'])) {\n                                $sth = $dbh->prepare('UPDATE `domainlist` SET `enabled` = 0 WHERE `id` = :id');\n                                $sth->bindParam(':id', $id, PDO::PARAM_INT);\n\n                                if ($sth->execute()) {\n                                    $domainsAll[$id]['enabled'] = false;\n                                }\n\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                foreach ($domainlist as $domain) {\n                    if (strpos($typeName, 'REGEX_') === false) {\n                        // Check 'borrowed' from `scripts/pi-hole/php/groups.php` - 'add_domain'\n                        if (filter_var($domain, FILTER_VALIDATE_DOMAIN, FILTER_FLAG_HOSTNAME) === false) {\n                            if ($config['VERBOSE'] === true) {\n                                printAndLog('Invalid: ' . $domain . PHP_EOL, 'NOTICE');\n                            } else {\n                                $summaryBuffer['invalid'][] = $domain;\n                            }\n\n                            incrementStat('invalid');\n                            continue;\n                        }\n                    }\n\n                    $domainlistDomain = $checkDomainExists($domain, $typeId);\n                    if ($domainlistDomain === false) {\n                        // Add entry if it doesn't exist\n                        $sth = $dbh->prepare('INSERT INTO `domainlist` (domain, type, enabled, comment) VALUES (:domain, :type, 1, :comment)');\n                        $sth->bindParam(':domain', $domain, PDO::PARAM_STR);\n                        $sth->bindParam(':type', $typeId, PDO::PARAM_INT);\n\n                        $comment = $configSectionData['COMMENT'];\n                        if (isset($comments[$domain])) {\n                            $comment = $comments[$domain] . ($comment !== '' ? ' | ' . $comment : '');\n                        }\n                        $sth->bindParam(':comment', $comment, PDO::PARAM_STR);\n\n                        if ($sth->execute()) {\n                            $lastInsertId = $dbh->lastInsertId();\n\n                            // Insert this domain into cached list of all domains to prevent future duplicate errors\n                            $domainsAll[$lastInsertId] = [\n                                'id'      => $lastInsertId,\n                                'domain'  => $domain,\n                                'type'    => $typeId,\n                                'enabled' => true,\n                                'comment' => $comment,\n                            ];\n\n                            if ($absoluteGroupId > 0) {\n                                // Add to the specified group\n                                $sth = $dbh->prepare('INSERT OR IGNORE INTO `domainlist_by_group` (domainlist_id, group_id) VALUES (:domainlist_id, :group_id)');\n                                $sth->bindParam(':domainlist_id', $lastInsertId, PDO::PARAM_INT);\n                                $sth->bindParam(':group_id', $absoluteGroupId, PDO::PARAM_INT);\n                                $sth->execute();\n\n                                if ($configSectionData['GROUP_ID'] < 0) {\n                                    // Remove from the default group\n                                    $sth = $dbh->prepare('DELETE FROM `domainlist_by_group` WHERE domainlist_id = :domainlist_id AND group_id = :group_id');\n                                    $sth->bindParam(':domainlist_id', $lastInsertId, PDO::PARAM_INT);\n                                    $sth->bindValue(':group_id', 0, PDO::PARAM_INT);\n                                    $sth->execute();\n                                }\n                            }\n\n                            $config['VERBOSE'] === true && printAndLog('Inserted: ' . $domain . PHP_EOL);\n                            incrementStat('inserted');\n                        }\n                    } else {\n                        $isTouchable                 = checkIfTouchable($domainlistDomain, $configSectionData['COMMENT'], $config['REQUIRE_COMMENT']);\n                        $domainlistDomain['enabled'] = (bool) $domainlistDomain['enabled'] === true;\n                        $domainlistDomain['type']    = (int) $domainlistDomain['type'];\n                        \n                        // Check if entry has any groups assigned\n                        $hasGroups = true;\n                        if ($configSectionData['PERSISTENT_GROUP'] === false) {\n                            $sth = $dbh->prepare('SELECT * FROM `domainlist_by_group` WHERE `domainlist_by_group`.`domainlist_id` = :domainlist_id');\n                            $sth->bindValue(':domainlist_id', $domainlistDomain['id'], PDO::PARAM_INT);\n                            if ($sth->execute() && empty($sth->fetchAll(PDO::FETCH_ASSOC))) {\n                                $hasGroups = false;\n                            }\n                        }\n\n                        // Enable existing entry but only if it's managed by this script\n                        if ($domainlistDomain['type'] === $typeId && $domainlistDomain['enabled'] === false && $isTouchable === true) {\n                            $sth = $dbh->prepare('UPDATE `domainlist` SET `enabled` = 1 WHERE `id` = :id');\n                            $sth->bindParam(':id', $domainlistDomain['id'], PDO::PARAM_INT);\n\n                            if ($sth->execute()) {\n                                $domainsAll[$domainlistDomain['id']]['enabled'] = true;\n\n                                $config['VERBOSE'] === true && printAndLog('Enabled: ' . $domain . PHP_EOL);\n                                incrementStat('enabled');\n                            }\n                        } elseif ($domainlistDomain['type'] !== $typeId) { // After adding 'type' to $checkDomainExists this should never be reached\n                            $existsOnList = (array_search($domainlistDomain['type'], $domainListTypes, true) ?: 'type=' . $domainlistDomain['type']);\n\n                            if ($config['VERBOSE'] === true) {\n                                printAndLog('Conflict: ' . $domain . ' (' . $existsOnList . ')' . PHP_EOL, 'NOTICE');\n                            } else {\n                                $summaryBuffer['conflict'][$domain] = $existsOnList;\n                            }\n\n                            incrementStat('conflict', $domain);\n                        } elseif ($domainlistDomain['enabled'] === true && $isTouchable === true) {\n                            $config['VERBOSE'] === true && printAndLog('Exists: ' . $domain . PHP_EOL);\n                            incrementStat('exists', $domain);\n                        } elseif ($isTouchable === false) {\n                            // Migration in this context means replacing comment field if current one is also managed by the script\n                            $canBeMigrated = false;\n\n                            if ((int)$config['MIGRATION_MODE'] > 0 && $domainlistDomain['enabled'] === false) {\n                                foreach ($configSections as $testConfigSectionName => $testConfigSectionData) {\n                                    if (checkIfTouchable($domainlistDomain, $testConfigSectionData['COMMENT'], $config['REQUIRE_COMMENT'])) {\n                                        $canBeMigrated = true;\n                                        break;\n                                    }\n                                }\n\n                                if ($canBeMigrated) {\n                                    if ((int)$config['MIGRATION_MODE'] === 1) {\n                                        $newComment = str_replace($testConfigSectionData['COMMENT'], $configSectionData['COMMENT'], $domainlistDomain['comment']);\n                                    } elseif ((int)$config['MIGRATION_MODE'] === 2) {\n                                        $newComment = $domainlistDomain['comment'] . ' | ' . $configSectionData['COMMENT'];\n                                    } else {\n                                        throw new RuntimeException('Invalid migration mode specified');\n                                    }\n                                    \n                                    $sth = $dbh->prepare('UPDATE `domainlist` SET `enabled` = 1, `comment` = :comment WHERE `id` = :id');\n                                    $sth->bindParam(':id', $domainlistDomain['id'], PDO::PARAM_INT);\n                                    $sth->bindParam(':comment', $newComment, PDO::PARAM_STR);\n\n                                    if ($sth->execute()) {\n                                        $domainsAll[$domainlistDomain['id']]['enabled'] = true;\n                                        $domainsAll[$domainlistDomain['id']]['comment'] = $newComment;\n\n                                        $oldGroupId = abs($testConfigSectionData['GROUP_ID']);\n\n                                        $sth = $dbh->prepare('DELETE FROM `domainlist_by_group` WHERE `domainlist_id` = :domainlist_id AND `group_id` = :group_id');\n                                        $sth->bindParam(':domainlist_id', $domainlistDomain['id'], PDO::PARAM_INT);\n                                        $sth->bindParam(':group_id', $oldGroupId, PDO::PARAM_INT);\n                                        $sth->execute();\n\n                                        if (($key = array_search($oldGroupId, $domainsGroupsAll[$domainlistDomain['id']])) !== false) {\n                                            unset($domainsGroupsAll[$domainlistDomain['id']][$key]);\n                                        }\n\n                                        $config['VERBOSE'] === true && printAndLog('Migrated: ' . $domain . PHP_EOL);\n                                        incrementStat('migrated');\n                                    } else {\n                                        printAndLog('Failed to migrate: ' . $domain . PHP_EOL);\n                                        incrementStat('errors');\n                                    }\n                                }\n                            }\n\n                            if ($canBeMigrated === false) {\n                                $config['VERBOSE'] === true && printAndLog('Ignored: ' . $domain . PHP_EOL);\n                                incrementStat('ignored', $domain);\n                            }\n                        }\n\n                        if ($configSectionData['PERSISTENT_GROUP'] === true || $hasGroups === false) {\n                            // (Re)Add to the specified group when not added\n                            if (\n                                $absoluteGroupId > 0 &&\n                                (isset($domainsGroupsAll[$domainlistDomain['id']]) && !in_array($absoluteGroupId, $domainsGroupsAll[$domainlistDomain['id']], true))\n                            ) {\n                                $sth = $dbh->prepare('INSERT OR IGNORE INTO `domainlist_by_group` (domainlist_id, group_id) VALUES (:domainlist_id, :group_id)');\n                                $sth->bindParam(':domainlist_id', $domainlistDomain['id'], PDO::PARAM_INT);\n                                $sth->bindParam(':group_id', $absoluteGroupId, PDO::PARAM_INT);\n                                $sth->execute();\n\n                                $config['VERBOSE'] === true && $sth->rowCount() && printAndLog('Added \\'' . $domain . '\\' to the group with ID = ' . $absoluteGroupId . PHP_EOL);\n                            }\n\n                            // (Re)Add to the default group when not added\n                            if (\n                                $configSectionData['GROUP_ID'] >= 0 &&\n                                (isset($domainsGroupsAll[$domainlistDomain['id']]) && !in_array(0, $domainsGroupsAll[$domainlistDomain['id']], true))\n                            ) {\n                                $sth = $dbh->prepare('INSERT OR IGNORE INTO `domainlist_by_group` (domainlist_id, group_id) VALUES (:domainlist_id, :group_id)');\n                                $sth->bindParam(':domainlist_id', $domainlistDomain['id'], PDO::PARAM_INT);\n                                $sth->bindValue(':group_id', 0, PDO::PARAM_INT);\n                                $sth->execute();\n\n                                $config['VERBOSE'] === true && $sth->rowCount() && printAndLog('Added \\'' . $domain . '\\' the default group' . PHP_EOL);\n                            }\n                        }\n                    }\n                }\n\n                $dbh->commit();\n\n                foreach ($statCopy as $var => $val) {\n                    $statCopy[$var] = $stat[$var] - $statCopy[$var];\n                }\n                printOperationSummary($statCopy, ($config['VERBOSE'] === true || $config['DEBUG'] === true));\n\n                if ($config['VERBOSE'] === false) {\n                    if (isset($summaryBuffer['invalid'])) {\n                        printAndLog('List of invalid entries:' . PHP_EOL . ' ' . implode(PHP_EOL . ' ', $summaryBuffer['invalid']) . PHP_EOL, 'NOTICE');\n                    }\n\n                    if (isset($summaryBuffer['conflict'])) {\n                        foreach ($summaryBuffer['conflict'] as $duplicatedDomain => $onList) {\n                            $summaryBuffer['conflict'][$duplicatedDomain] = $duplicatedDomain . ' (' . $onList . ')';\n                        }\n\n                        printAndLog('List of conflicting entries:' . PHP_EOL . ' ' . implode(PHP_EOL . ' ', $summaryBuffer['conflict']) . PHP_EOL, 'NOTICE');\n                    }\n                }\n            } else {\n                if ($multipleLists) {\n                    printAndLog('One of the lists failed to download, operation aborted!' . PHP_EOL, 'NOTICE');\n                } else {\n                    printAndLog(' ' . parseLastError() . PHP_EOL, 'ERROR');\n                    incrementStat('errors');\n                }\n            }\n\n            print PHP_EOL;\n        }\n    }\n}\n\nif ($remoteListsAreSet === false) {\n    printAndLog('No remote lists are set in the configuration - this is required for the script to do it\\'s job!' . PHP_EOL . 'See README for instructions.' . PHP_EOL . PHP_EOL, 'ERROR');\n    $stat['errors']++;\n}\n\n// Update gravity (run `pihole updateGravity`) or sends signal to pihole-FTL to reload lists\nif ($config['UPDATE_GRAVITY'] === true) {\n    $sth = $dbh = null; // Close any database handles\n\n    if ($config['DEBUG'] === true) {\n        printAndLog('Closed database handles.' . PHP_EOL, 'DEBUG');\n    }\n\n    $command = $config['PIHOLE_CMD'] . ' updateGravity';\n    printAndLog('Updating Pi-hole\\'s gravity using command \\'' . $command . '\\'...' . PHP_EOL);\n\n    passthru($command, $return);\n\n    if ($return !== 0) {\n        printAndLog('Error occurred while updating gravity!' . PHP_EOL, 'ERROR');\n        incrementStat('errors');\n    } else {\n        printAndLog('Done' . PHP_EOL, 'INFO', true);\n    }\n\n    print PHP_EOL;\n} elseif ($config['UPDATE_GRAVITY'] === false) {\n    $command = $config['PIHOLE_CMD'] . ' restartdns reload-lists';\n    printAndLog('Reloading Pi-hole\\'s lists using command \\'' . $command . '\\'...');\n\n    system($command, $return);\n\n    if ($return !== 0) {\n        printAndLog('Error occurred while reloading lists!' . PHP_EOL, 'ERROR');\n        incrementStat('errors');\n    } else {\n        printAndLog(' done' . PHP_EOL, 'INFO');\n    }\n\n    print PHP_EOL;\n}\n\nif ($config['DEBUG'] === true) {\n    printAndLog('Memory reached peak usage of ' . formatBytes(memory_get_peak_usage()) . PHP_EOL, 'DEBUG');\n}\n\nif ($stat['invalid'] > 0) {\n    printAndLog('Ignored ' . $stat['invalid'] . ' invalid ' . ($stat['invalid'] === 1 ? 'entry' : 'entries') . '.' . PHP_EOL, 'NOTICE');\n}\n\nif ($stat['conflict'] > 0) {\n    printAndLog('Found ' . $stat['conflict'] . ' conflicting ' . ($stat['conflict'] === 1 ? 'entry' : 'entries') . ' across your lists.' . PHP_EOL, 'NOTICE');\n}\n\n$elapsedTime = round(microtime(true) - $startTime, 2) . ' seconds';\n\nif ($stat['errors'] > 0) {\n    printAndLog('Finished with ' . $stat['errors'] . ' error(s) in ' . $elapsedTime . '.' . PHP_EOL);\n    exit(1);\n}\n\nif ($stat['warnings'] > 0) {\n    printAndLog('Finished successfully with ' . $stat['warnings'] . ' warning(s) in ' . $elapsedTime . '.' . PHP_EOL);\n    exit(0);\n}\n\nprintAndLog('Finished successfully in ' . $elapsedTime . '.' . PHP_EOL);\n"
        },
        {
          "name": "pihole-updatelists.service",
          "type": "blob",
          "size": 0.2236328125,
          "content": "[Unit]\nDescription=Update Pi-hole's lists from remote sources\nAfter=network-online.target multi-user.target\nWants=network-online.target\n\n[Service]\nType=simple\nExecStart=/usr/local/sbin/pihole-updatelists\nTimeoutStartSec=infinity\n"
        },
        {
          "name": "pihole-updatelists.timer",
          "type": "blob",
          "size": 0.16015625,
          "content": "[Unit]\nDescription=Weekly update of Pi-hole's lists\n\n[Timer]\nRandomizedDelaySec=60m\nOnCalendar=Sat *-*-* 03:00:00\nPersistent=true\n\n[Install]\nWantedBy=timers.target\n"
        }
      ]
    }
  ]
}