{
  "metadata": {
    "timestamp": 1736712204074,
    "page": 899,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "reactphp/event-loop",
      "stars": 1270,
      "defaultBranch": "3.x",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1884765625,
          "content": "/.gitattributes export-ignore\n/.github/ export-ignore\n/.gitignore export-ignore\n/examples/ export-ignore\n/phpunit.xml.dist export-ignore\n/phpunit.xml.legacy export-ignore\n/tests/ export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0361328125,
          "content": "/composer.lock\n/phpunit.xml\n/vendor/\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 15.6611328125,
          "content": "# Changelog\n\n## 1.5.0 (2023-11-13)\n\n*   Feature: Improve performance by using `spl_object_id()` on PHP 7.2+.\n    (#267 by @samsonasik)\n\n*   Feature: Full PHP 8.3 compatibility.\n    (#269 by @clue)\n\n*   Update tests for `ext-uv` on PHP 8+ and legacy PHP.\n    (#270 by @clue and #268 by @SimonFrings)\n\n## 1.4.0 (2023-05-05)\n\n*   Feature: Improve performance of `Loop` by avoiding unneeded method calls.\n    (#266 by @clue)\n\n*   Feature: Support checking `EINTR` constant from `ext-pcntl` without `ext-sockets`.\n    (#265 by @clue)\n\n*   Minor documentation improvements.\n    (#254 by @nhedger)\n\n*   Improve test suite, run tests on PHP 8.2 and report failed assertions.\n    (#258 by @WyriHaximus, #264 by @clue and #251, #261 and #262 by @SimonFrings)\n\n## 1.3.0 (2022-03-17)\n\n*   Feature: Improve default `StreamSelectLoop` to report any warnings for invalid streams.\n    (#245 by @clue)\n\n*   Feature: Improve performance of `StreamSelectLoop` when no timers are scheduled.\n    (#246 by @clue)\n\n*   Fix: Fix periodic timer with zero interval for `ExtEvLoop` and legacy `ExtLibevLoop`.\n    (#243 by @lucasnetau)\n\n*   Minor documentation improvements, update PHP version references.\n    (#240, #248 and #250 by @SimonFrings, #241 by @dbu and #249 by @clue)\n\n*   Improve test suite and test against PHP 8.1.\n    (#238 by @WyriHaximus and #242 by @clue)\n\n## 1.2.0 (2021-07-11)\n\nA major new feature release, see [**release announcement**](https://clue.engineering/2021/announcing-reactphp-default-loop).\n\n*   Feature: Introduce new concept of default loop with the new `Loop` class.\n    (#226 by @WyriHaximus, #229, #231 and #232 by @clue)\n\n    The `Loop` class exists as a convenient global accessor for the event loop.\n    It provides all methods that exist on the `LoopInterface` as static methods and\n    will automatically execute the loop at the end of the program:\n\n    ```php\n    $timer = Loop::addPeriodicTimer(0.1, function () {\n        echo 'Tick' . PHP_EOL;\n    });\n\n    Loop::addTimer(1.0, function () use ($timer) {\n        Loop::cancelTimer($timer);\n        echo 'Done' . PHP_EOL;\n    });\n    ```\n\n    The explicit loop instructions are still valid and may still be useful in some applications,\n    especially for a transition period towards the more concise style.\n    The `Loop::get()` method can be used to get the currently active event loop instance.\n\n    ```php\n    // deprecated\n    $loop = React\\EventLoop\\Factory::create();\n\n    // new\n    $loop = React\\EventLoop\\Loop::get();\n    ```\n\n*   Minor documentation improvements and mark legacy extensions as deprecated.\n    (#234 by @SimonFrings, #214 by @WyriHaximus and #233 and #235 by @nhedger)\n\n*   Improve test suite, use GitHub actions for continuous integration (CI),\n    update PHPUnit config and run tests on PHP 8.\n    (#212 and #215 by @SimonFrings and #230 by @clue)\n\n## 1.1.1 (2020-01-01)\n\n*   Fix: Fix reporting connection refused errors with `ExtUvLoop` on Linux and `StreamSelectLoop` on Windows.\n    (#207 and #208 by @clue)\n\n*   Fix: Fix unsupported EventConfig and `SEGFAULT` on shutdown with `ExtEventLoop` on Windows.\n    (#205 by @clue)\n\n*   Fix: Prevent interval overflow for timers very far in the future with `ExtUvLoop`.\n    (#196 by @PabloKowalczyk)\n\n*   Fix: Check PCNTL functions for signal support instead of PCNTL extension with `StreamSelectLoop`.\n    (#195 by @clue)\n\n*   Add `.gitattributes` to exclude dev files from exports.\n    (#201 by @reedy)\n\n*   Improve test suite to fix testing `ExtUvLoop` on Travis,\n    fix Travis CI builds, do not install `libuv` on legacy PHP setups,\n    fix failing test cases due to inaccurate timers,\n    run tests on Windows via Travis CI and\n    run tests on PHP 7.4 and simplify test matrix and test setup.\n    (#197 by @WyriHaximus and #202, #203, #204 and #209 by @clue)\n\n## 1.1.0 (2019-02-07)\n\n*   New UV based event loop (ext-uv).\n    (#112 by @WyriHaximus)\n\n*   Use high resolution timer on PHP 7.3+. \n    (#182 by @clue)\n\n*   Improve PCNTL signals by using async signal dispatching if available. \n    (#179 by @CharlotteDunois)\n\n*   Improve test suite and test suite set up.\n    (#174 by @WyriHaximus, #181 by @clue)\n\n*   Fix PCNTL signals edge case. \n    (#183 by @clue)\n\n## 1.0.0 (2018-07-11)\n\n*   First stable LTS release, now following [SemVer](https://semver.org/).\n    We'd like to emphasize that this component is production ready and battle-tested.\n    We plan to support all long-term support (LTS) releases for at least 24 months,\n    so you have a rock-solid foundation to build on top of.\n\n>   Contains no other changes, so it's actually fully compatible with the v0.5.3 release.\n\n## 0.5.3 (2018-07-09)\n\n*   Improve performance by importing global functions.\n    (#167 by @Ocramius)\n\n*   Improve test suite by simplifying test bootstrap by using dev autoloader.\n    (#169 by @lcobucci)\n\n*   Minor internal changes to improved backward compatibility with PHP 5.3.\n    (#166 by @Donatello-za)\n\n## 0.5.2 (2018-04-24)\n\n*   Feature: Improve memory consumption and runtime performance for `StreamSelectLoop` timers.\n    (#164 by @clue)\n\n*   Improve test suite by removing I/O dependency at `StreamSelectLoopTest` to fix Mac OS X tests.\n    (#161 by @nawarian)\n\n## 0.5.1 (2018-04-09)\n\n*   Feature: New `ExtEvLoop` (PECL ext-ev)  (#148 by @kaduev13)\n\n## 0.5.0 (2018-04-05)\n\nA major feature release with a significant documentation overhaul and long overdue API cleanup!\n\nThis update involves a number of BC breaks due to dropped support for deprecated\nfunctionality. We've tried hard to avoid BC breaks where possible and minimize\nimpact otherwise. We expect that most consumers of this package will actually\nnot be affected by any BC breaks, see below for more details.\n\nWe realize that the changes listed below may seem overwhelming, but we've tried\nto be very clear about any possible BC breaks. Don't worry: In fact, all ReactPHP\ncomponents are already compatible and support both this new release as well as\nproviding backwards compatibility with the last release.\n\n*   Feature / BC break: Add support for signal handling via new\n    `LoopInterface::addSignal()` and `LoopInterface::removeSignal()` methods.\n    (#104 by @WyriHaximus and #111 and #150 by @clue)\n\n    ```php\n    $loop->addSignal(SIGINT, function () {\n        echo 'CTRL-C';\n    });\n    ```\n\n*   Feature: Significant documentation updates for `LoopInterface` and `Factory`.\n    (#100, #119, #126, #127, #159 and #160 by @clue, #113 by @WyriHaximus and #81 and #91 by @jsor)\n\n*   Feature: Add examples to ease getting started\n    (#99, #100 and #125 by @clue, #59 by @WyriHaximus and #143 by @jsor)\n\n*   Feature: Documentation for advanced timer concepts, such as monotonic time source vs wall-clock time\n    and high precision timers with millisecond accuracy or below.\n    (#130 and #157 by @clue)\n\n*   Feature: Documentation for advanced stream concepts, such as edge-triggered event listeners\n    and stream buffers and allow throwing Exception if stream resource is not supported.\n    (#129 and #158 by @clue)\n\n*   Feature: Throw `BadMethodCallException` on manual loop creation when required extension isn't installed.\n    (#153 by @WyriHaximus)\n\n*   Feature / BC break: First class support for legacy PHP 5.3 through PHP 7.2 and HHVM\n    and remove all `callable` type hints for consistency reasons.\n    (#141 and #151 by @clue)\n\n*   BC break: Documentation for timer API and clean up unneeded timer API.\n    (#102 by @clue)\n\n    Remove `TimerInterface::cancel()`, use `LoopInterface::cancelTimer()` instead:\n\n    ```php\n    // old (method invoked on timer instance)\n    $timer->cancel();\n    \n    // already supported before: invoke method on loop instance\n    $loop->cancelTimer($timer);\n    ```\n\n    Remove unneeded `TimerInterface::setData()` and `TimerInterface::getData()`,\n    use closure binding to add arbitrary data to timer instead:\n\n    ```php\n    // old (limited setData() and getData() only allows single variable)\n    $name = 'Tester';\n    $timer = $loop->addTimer(1.0, function ($timer) {\n        echo 'Hello ' . $timer->getData() . PHP_EOL;\n    });\n    $timer->setData($name);\n\n    // already supported before: closure binding allows any number of variables\n    $name = 'Tester';\n    $loop->addTimer(1.0, function () use ($name) {\n        echo 'Hello ' . $name . PHP_EOL;\n    });\n    ```\n\n    Remove unneeded `TimerInterface::getLoop()`, use closure binding instead:\n\n    ```php\n    // old (getLoop() called on timer instance)\n    $loop->addTimer(0.1, function ($timer) {\n        $timer->getLoop()->stop();\n    });\n\n    // already supported before: use closure binding as usual\n    $loop->addTimer(0.1, function () use ($loop) {\n        $loop->stop();\n    });\n    ```\n\n*   BC break: Remove unneeded `LoopInterface::isTimerActive()` and\n    `TimerInterface::isActive()` to reduce API surface.\n    (#133 by @clue)\n\n    ```php\n    // old (method on timer instance or on loop instance)\n    $timer->isActive();\n    $loop->isTimerActive($timer);\n    ```\n\n*   BC break: Move `TimerInterface` one level up to `React\\EventLoop\\TimerInterface`.\n    (#138 by @WyriHaximus)\n\n    ```php\n    // old (notice obsolete \"Timer\" namespace)\n    assert($timer instanceof React\\EventLoop\\Timer\\TimerInterface);\n\n    // new\n    assert($timer instanceof React\\EventLoop\\TimerInterface);\n    ```\n\n*   BC break: Remove unneeded `LoopInterface::nextTick()` (and internal `NextTickQueue`),\n    use `LoopInterface::futureTick()` instead.\n    (#30 by @clue)\n\n    ```php\n    // old (removed)\n    $loop->nextTick(function () {\n        echo 'tick';\n    });\n\n    // already supported before\n    $loop->futureTick(function () {\n        echo 'tick';\n    });\n    ```\n\n*   BC break: Remove unneeded `$loop` argument for `LoopInterface::futureTick()`\n    (and fix internal cyclic dependency).\n    (#103 by @clue)\n\n    ```php\n    // old ($loop gets passed by default)\n    $loop->futureTick(function ($loop) {\n        $loop->stop();\n    });\n\n    // already supported before: use closure binding as usual\n    $loop->futureTick(function () use ($loop) {\n        $loop->stop();\n    });\n    ```\n\n*   BC break: Remove unneeded `LoopInterface::tick()`.\n    (#72 by @jsor)\n\n    ```php\n    // old (removed)\n    $loop->tick();\n\n    // suggested work around for testing purposes only\n    $loop->futureTick(function () use ($loop) {\n        $loop->stop();\n    });\n    ```\n\n*   BC break: Documentation for advanced stream API and clean up unneeded stream API.\n    (#110 by @clue)\n\n    Remove unneeded `$loop` argument for `LoopInterface::addReadStream()`\n    and `LoopInterface::addWriteStream()`, use closure binding instead:\n\n    ```php\n    // old ($loop gets passed by default)\n    $loop->addReadStream($stream, function ($stream, $loop) {\n        $loop->removeReadStream($stream);\n    });\n\n    // already supported before: use closure binding as usual\n    $loop->addReadStream($stream, function ($stream) use ($loop) {\n        $loop->removeReadStream($stream);\n    });\n    ```\n\n*   BC break: Remove unneeded `LoopInterface::removeStream()` method,\n    use `LoopInterface::removeReadStream()` and `LoopInterface::removeWriteStream()` instead.\n    (#118 by @clue)\n\n    ```php\n    // old\n    $loop->removeStream($stream);\n\n    // already supported before\n    $loop->removeReadStream($stream);\n    $loop->removeWriteStream($stream);\n    ```\n\n*   BC break: Rename `LibEventLoop` to `ExtLibeventLoop` and `LibEvLoop` to `ExtLibevLoop`\n    for consistent naming for event loop implementations.\n    (#128 by @clue)\n\n*   BC break: Remove optional `EventBaseConfig` argument from `ExtEventLoop`\n    and make its `FEATURE_FDS` enabled by default.\n    (#156 by @WyriHaximus)\n\n*   BC break: Mark all classes as final to discourage inheritance.\n    (#131 by @clue)\n\n*   Fix: Fix `ExtEventLoop` to keep track of stream resources (refcount)\n    (#123 by @clue)\n\n*   Fix: Ensure large timer interval does not overflow on 32bit systems\n    (#132 by @clue)\n\n*   Fix: Fix separately removing readable and writable side of stream when closing\n    (#139 by @clue)\n\n*   Fix: Properly clean up event watchers for `ext-event` and `ext-libev`\n    (#149 by @clue)\n\n*   Fix: Minor code cleanup and remove unneeded references\n    (#145 by @seregazhuk)\n\n*   Fix: Discourage outdated `ext-libevent` on PHP 7\n    (#62 by @cboden)\n\n*   Improve test suite by adding forward compatibility with PHPUnit 6 and PHPUnit 5,\n    lock Travis distro so new defaults will not break the build,\n    improve test suite to be less fragile and increase test timeouts,\n    test against PHP 7.2 and reduce fwrite() call length to one chunk.\n    (#106 and #144 by @clue, #120 and #124 by @carusogabriel, #147 by nawarian and #92 by @kelunik)\n\n*   A number of changes were originally planned for this release but have been backported\n    to the last `v0.4.3` already: #74, #76, #79, #81 (refs #65, #66, #67), #88 and #93\n\n## 0.4.3 (2017-04-27)\n\n* Bug fix: Bugfix in the usage sample code #57 (@dandelionred) \n* Improvement: Remove branch-alias definition #53 (@WyriHaximus)\n* Improvement: StreamSelectLoop: Use fresh time so Timers added during stream events are accurate #51 (@andrewminerd)\n* Improvement: Avoid deprecation warnings in test suite due to deprecation of getMock() in PHPUnit #68 (@martinschroeder)\n* Improvement: Add PHPUnit 4.8 to require-dev #69 (@shaunbramley)\n* Improvement: Increase test timeouts for HHVM and unify timeout handling #70 (@clue)\n* Improvement: Travis improvements (backported from #74) #75 (@clue)\n* Improvement: Test suite now uses socket pairs instead of memory streams #66 (@martinschroeder)\n* Improvement: StreamSelectLoop: Test suite uses signal constant names in data provider #67 (@martinschroeder)\n* Improvement: ExtEventLoop: No longer suppress all errors #65 (@mamciek)\n* Improvement: Readme cleanup #89 (@jsor)\n* Improvement: Restructure and improve README #90 (@jsor)\n* Bug fix: StreamSelectLoop: Fix erroneous zero-time sleep (backport to 0.4) #94 (@jsor)\n\n## 0.4.2 (2016-03-07)\n\n* Bug fix: No longer error when signals sent to StreamSelectLoop\n* Support HHVM and PHP7 (@ondrejmirtes, @cebe)\n* Feature: Added support for EventConfig for ExtEventLoop (@steverhoades)\n* Bug fix: Fixed an issue loading loop extension libs via autoloader (@czarpino)\n\n## 0.4.1 (2014-04-13)\n\n* Bug fix: null timeout in StreamSelectLoop causing 100% CPU usage (@clue)\n* Bug fix: v0.3.4 changes merged for v0.4.1\n\n## 0.4.0 (2014-02-02)\n\n* Feature: Added `EventLoopInterface::nextTick()`, implemented in all event loops (@jmalloc)\n* Feature: Added `EventLoopInterface::futureTick()`, implemented in all event loops (@jmalloc)\n* Feature: Added `ExtEventLoop` implementation using pecl/event (@jmalloc)\n* BC break: Bump minimum PHP version to PHP 5.4, remove 5.3 specific hacks\n* BC break: New method: `EventLoopInterface::nextTick()`\n* BC break: New method: `EventLoopInterface::futureTick()`\n* Dependency: Autoloading and filesystem structure now PSR-4 instead of PSR-0\n\n## 0.3.5 (2016-12-28)\n\nThis is a compatibility release that eases upgrading to the v0.4 release branch.\nYou should consider upgrading to the v0.4 release branch.\n\n* Feature: Cap min timer interval at 1µs, thus improving compatibility with v0.4\n  (#47 by @clue)\n\n## 0.3.4 (2014-03-30)\n\n* Bug fix: Changed StreamSelectLoop to use non-blocking behavior on tick() (@astephens25)\n\n## 0.3.3 (2013-07-08)\n\n* Bug fix: No error on removing non-existent streams (@clue)\n* Bug fix: Do not silently remove feof listeners in `LibEvLoop`\n\n## 0.3.0 (2013-04-14)\n\n* BC break: New timers API (@nrk)\n* BC break: Remove check on return value from stream callbacks (@nrk)\n\n## 0.2.7 (2013-01-05)\n\n* Bug fix: Fix libevent timers with PHP 5.3\n* Bug fix: Fix libevent timer cancellation (@nrk)\n\n## 0.2.6 (2012-12-26)\n\n* Bug fix: Plug memory issue in libevent timers (@cameronjacobson)\n* Bug fix: Correctly pause LibEvLoop on stop()\n\n## 0.2.3 (2012-11-14)\n\n* Feature: LibEvLoop, integration of `php-libev`\n\n## 0.2.0 (2012-09-10)\n\n* Version bump\n\n## 0.1.1 (2012-07-12)\n\n* Version bump\n\n## 0.1.0 (2012-07-11)\n\n* First tagged release\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1142578125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2012 Christian Lück, Cees-Jan Kiewiet, Jan Sorgalla, Chris Boden, Igor Wiedler\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.412109375,
          "content": "# EventLoop\n\n[![CI status](https://github.com/reactphp/event-loop/actions/workflows/ci.yml/badge.svg)](https://github.com/reactphp/event-loop/actions)\n[![installs on Packagist](https://img.shields.io/packagist/dt/react/event-loop?color=blue&label=installs%20on%20Packagist)](https://packagist.org/packages/react/event-loop)\n\n[ReactPHP](https://reactphp.org/)'s core reactor event loop that libraries can use for evented I/O.\n\n> **Development version:** This branch contains the code for the upcoming v3 \n> release. For the code of the current stable v1 release, check out the \n> [`1.x` branch](https://github.com/reactphp/event-loop/tree/1.x).\n>\n> The upcoming v3 release will be the way forward for this package. However,\n> we will still actively support v1 for those not yet on the latest version. \n> See also [installation instructions](#install) for more details.\n\nIn order for async based libraries to be interoperable, they need to use the\nsame event loop. This component provides a common `LoopInterface` that any\nlibrary can target. This allows them to be used in the same loop, with one\nsingle [`run()`](#run) call that is controlled by the user.\n\n**Table of contents**\n\n* [Quickstart example](#quickstart-example)\n* [Usage](#usage)\n    * [Loop](#loop)\n        * [Loop methods](#loop-methods)\n        * [Loop autorun](#loop-autorun)\n        * [get()](#get)\n    * [Loop implementations](#loop-implementations)\n        * [StreamSelectLoop](#streamselectloop)\n        * [ExtEventLoop](#exteventloop)\n        * [ExtEvLoop](#extevloop)\n        * [ExtUvLoop](#extuvloop)\n    * [LoopInterface](#loopinterface)\n        * [run()](#run)\n        * [stop()](#stop)\n        * [addTimer()](#addtimer)\n        * [addPeriodicTimer()](#addperiodictimer)\n        * [cancelTimer()](#canceltimer)\n        * [futureTick()](#futuretick)\n        * [addSignal()](#addsignal)\n        * [removeSignal()](#removesignal)\n        * [addReadStream()](#addreadstream)\n        * [addWriteStream()](#addwritestream)\n        * [removeReadStream()](#removereadstream)\n        * [removeWriteStream()](#removewritestream)\n* [Install](#install)\n* [Tests](#tests)\n* [License](#license)\n* [More](#more)\n\n## Quickstart example\n\nHere is an async HTTP server built with just the event loop.\n\n```php\n<?php\n\nuse React\\EventLoop\\Loop;\n\nrequire __DIR__ . '/vendor/autoload.php';\n\n$server = stream_socket_server('tcp://127.0.0.1:8080');\nstream_set_blocking($server, false);\n\nLoop::addReadStream($server, function ($server) {\n    $conn = stream_socket_accept($server);\n    $data = \"HTTP/1.1 200 OK\\r\\nContent-Length: 3\\r\\n\\r\\nHi\\n\";\n    Loop::addWriteStream($conn, function ($conn) use (&$data) {\n        $written = fwrite($conn, $data);\n        if ($written === strlen($data)) {\n            fclose($conn);\n            Loop::removeWriteStream($conn);\n        } else {\n            $data = substr($data, $written);\n        }\n    });\n});\n\nLoop::addPeriodicTimer(5, function () {\n    $memory = memory_get_usage() / 1024;\n    $formatted = number_format($memory, 3).'K';\n    echo \"Current memory usage: {$formatted}\\n\";\n});\n```\n\nSee also the [examples](examples).\n\n## Usage\n\nTypical applications would use the [`Loop` class](#loop) to use the default\nevent loop like this:\n\n```php\nuse React\\EventLoop\\Loop;\n\n$timer = Loop::addPeriodicTimer(0.1, function () {\n    echo 'Tick' . PHP_EOL;\n});\n\nLoop::addTimer(1.0, function () use ($timer) {\n    Loop::cancelTimer($timer);\n    echo 'Done' . PHP_EOL;\n});\n```\n\nAs an alternative, you can also explicitly create an event loop instance at the\nbeginning, reuse it throughout your program and finally run it at the end of the\nprogram like this:\n\n```php\n$loop = React\\EventLoop\\Loop::get();\n\n$timer = $loop->addPeriodicTimer(0.1, function () {\n    echo 'Tick' . PHP_EOL;\n});\n\n$loop->addTimer(1.0, function () use ($loop, $timer) {\n    $loop->cancelTimer($timer);\n    echo 'Done' . PHP_EOL;\n});\n\n$loop->run();\n```\n\nWhile the former is more concise, the latter is more explicit.\nIn both cases, the program would perform the exact same steps.\n\n1. The event loop instance is created at the beginning of the program. This is\n   implicitly done the first time you call the [`Loop` class](#loop)\n   (or by manually instantiating any of the [loop implementations](#loop-implementations)).\n2. The event loop is used directly or passed as an instance to library and\n   application code. In this example, a periodic timer is registered with the\n   event loop which simply outputs `Tick` every fraction of a second until another\n   timer stops the periodic timer after a second.\n3. The event loop is run at the end of the program. This is automatically done\n   when using the [`Loop` class](#loop) or explicitly with a single [`run()`](#run)\n   call at the end of the program.\n\nAs of `v1.2.0`, we highly recommend using the [`Loop` class](#loop).\nThe explicit loop instructions are still valid and may still be useful in some\napplications, especially for a transition period towards the more concise style.\n\n### Loop\n\nThe `Loop` class exists as a convenient global accessor for the event loop.\n\n#### Loop methods\n\nThe `Loop` class provides all methods that exist on the [`LoopInterface`](#loopinterface)\nas static methods:\n\n* [run()](#run)\n* [stop()](#stop)\n* [addTimer()](#addtimer)\n* [addPeriodicTimer()](#addperiodictimer)\n* [cancelTimer()](#canceltimer)\n* [futureTick()](#futuretick)\n* [addSignal()](#addsignal)\n* [removeSignal()](#removesignal)\n* [addReadStream()](#addreadstream)\n* [addWriteStream()](#addwritestream)\n* [removeReadStream()](#removereadstream)\n* [removeWriteStream()](#removewritestream)\n\nIf you're working with the event loop in your application code, it's often\neasiest to directly interface with the static methods defined on the `Loop` class\nlike this:\n\n```php\nuse React\\EventLoop\\Loop;\n\n$timer = Loop::addPeriodicTimer(0.1, function () {\n    echo 'Tick' . PHP_EOL;\n});\n\nLoop::addTimer(1.0, function () use ($timer) {\n    Loop::cancelTimer($timer);\n    echo 'Done' . PHP_EOL;\n});\n```\n\nOn the other hand, if you're familiar with object-oriented programming (OOP) and\ndependency injection (DI), you may want to inject an event loop instance and\ninvoke instance methods on the `LoopInterface` like this:\n\n```php\nuse React\\EventLoop\\Loop;\nuse React\\EventLoop\\LoopInterface;\n\nclass Greeter\n{\n    private $loop;\n\n    public function __construct(LoopInterface $loop)\n    {\n        $this->loop = $loop;\n    }\n\n    public function greet(string $name)\n    {\n        $this->loop->addTimer(1.0, function () use ($name) {\n            echo 'Hello ' . $name . '!' . PHP_EOL;\n        });\n    }\n}\n\n$greeter = new Greeter(Loop::get());\n$greeter->greet('Alice');\n$greeter->greet('Bob');\n```\n\nEach static method call will be forwarded as-is to the underlying event loop\ninstance by using the [`Loop::get()`](#get) call internally.\nSee [`LoopInterface`](#loopinterface) for more details about available methods.\n\n#### Loop autorun\n\nWhen using the `Loop` class, it will automatically execute the loop at the end of\nthe program. This means the following example will schedule a timer and will\nautomatically execute the program until the timer event fires:\n\n```php\nuse React\\EventLoop\\Loop;\n\nLoop::addTimer(1.0, function () {\n    echo 'Hello' . PHP_EOL;\n});\n```\n\nAs of `v1.2.0`, we highly recommend using the `Loop` class this way and omitting any\nexplicit [`run()`](#run) calls. For BC reasons, the explicit [`run()`](#run)\nmethod is still valid and may still be useful in some applications, especially\nfor a transition period towards the more concise style.\n\nIf you don't want the `Loop` to run automatically, you can either explicitly\n[`run()`](#run) or [`stop()`](#stop) it. This can be useful if you're using\na global exception handler like this:\n\n```php\nuse React\\EventLoop\\Loop;\n\nLoop::addTimer(10.0, function () {\n    echo 'Never happens';\n});\n\nset_exception_handler(function (Throwable $e) {\n    echo 'Error: ' . $e->getMessage() . PHP_EOL;\n    Loop::stop();\n});\n\nthrow new RuntimeException('Demo');\n```\n\n#### get()\n\nThe `get(): LoopInterface` method can be used to\nget the currently active event loop instance.\n\nThis method will always return the same event loop instance throughout the\nlifetime of your application.\n\n```php\nuse React\\EventLoop\\Loop;\nuse React\\EventLoop\\LoopInterface;\n\n$loop = Loop::get();\n\nassert($loop instanceof LoopInterface);\nassert($loop === Loop::get());\n```\n\nThis is particularly useful if you're using object-oriented programming (OOP)\nand dependency injection (DI). In this case, you may want to inject an event\nloop instance and invoke instance methods on the `LoopInterface` like this:\n\n```php\nuse React\\EventLoop\\Loop;\nuse React\\EventLoop\\LoopInterface;\n\nclass Greeter\n{\n    private $loop;\n\n    public function __construct(LoopInterface $loop)\n    {\n        $this->loop = $loop;\n    }\n\n    public function greet(string $name)\n    {\n        $this->loop->addTimer(1.0, function () use ($name) {\n            echo 'Hello ' . $name . '!' . PHP_EOL;\n        });\n    }\n}\n\n$greeter = new Greeter(Loop::get());\n$greeter->greet('Alice');\n$greeter->greet('Bob');\n```\n\nSee [`LoopInterface`](#loopinterface) for more details about available methods.\n\n### Loop implementations\n\nIn addition to the [`LoopInterface`](#loopinterface), there are a number of\nevent loop implementations provided.\n\nAll of the event loops support these features:\n\n* File descriptor polling\n* One-off timers\n* Periodic timers\n* Deferred execution on future loop tick\n\nFor most consumers of this package, the underlying event loop implementation is\nan implementation detail.\nYou should use the [`Loop` class](#loop) to automatically create a new instance.\n\nAdvanced! If you explicitly need a certain event loop implementation, you can\nmanually instantiate one of the following classes.\nNote that you may have to install the required PHP extensions for the respective\nevent loop implementation first or they will throw a `BadMethodCallException` on creation.\n\n#### StreamSelectLoop\n\nA `stream_select()` based event loop.\n\nThis uses the [`stream_select()`](https://www.php.net/manual/en/function.stream-select.php)\nfunction and is the only implementation that works out of the box with PHP.\n\nThis event loop works out of the box on any PHP version.\nThis means that no installation is required and this library works on all\nplatforms and supported PHP versions.\nAccordingly, the [`Loop` class](#loop) will use this event loop by default if\nyou do not install any of the event loop extensions listed below.\n\nUnder the hood, it does a simple `select` system call.\nThis system call is limited to the maximum file descriptor number of\n`FD_SETSIZE` (platform dependent, commonly 1024) and scales with `O(m)`\n(`m` being the maximum file descriptor number passed).\nThis means that you may run into issues when handling thousands of streams\nconcurrently and you may want to look into using one of the alternative\nevent loop implementations listed below in this case.\nIf your use case is among the many common use cases that involve handling only\ndozens or a few hundred streams at once, then this event loop implementation\nperforms really well.\n\nIf you want to use signal handling (see also [`addSignal()`](#addsignal) below),\nthis event loop implementation requires `ext-pcntl`.\nThis extension is only available for Unix-like platforms and does not support\nWindows.\nIt is commonly installed as part of many PHP distributions.\nIf this extension is missing (or you're running on Windows), signal handling is\nnot supported and throws a `BadMethodCallException` instead.\n\nThis event loop is known to rely on wall-clock time to schedule future timers\nwhen using any version before PHP 7.3, because a monotonic time source is\nonly available as of PHP 7.3 (`hrtime()`).\nWhile this does not affect many common use cases, this is an important\ndistinction for programs that rely on a high time precision or on systems\nthat are subject to discontinuous time adjustments (time jumps).\nThis means that if you schedule a timer to trigger in 30s on PHP < 7.3 and\nthen adjust your system time forward by 20s, the timer may trigger in 10s.\nSee also [`addTimer()`](#addtimer) for more details.\n\n#### ExtEventLoop\n\nAn `ext-event` based event loop.\n\nThis uses the [`event` PECL extension](https://pecl.php.net/package/event),\nthat provides an interface to `libevent` library.\n`libevent` itself supports a number of system-specific backends (epoll, kqueue).\n\nThis loop is known to work with PHP 7.1 through PHP 8+.\n\n#### ExtEvLoop\n\nAn `ext-ev` based event loop.\n\nThis loop uses the [`ev` PECL extension](https://pecl.php.net/package/ev),\nthat provides an interface to `libev` library.\n`libev` itself supports a number of system-specific backends (epoll, kqueue).\n\n\nThis loop is known to work with PHP 7.1 through PHP 8+.\n\n#### ExtUvLoop\n\nAn `ext-uv` based event loop.\n\nThis loop uses the [`uv` PECL extension](https://pecl.php.net/package/uv),\nthat provides an interface to `libuv` library.\n`libuv` itself supports a number of system-specific backends (epoll, kqueue).\n\nThis loop is known to work with PHP 7.1 through PHP 8+.\n\n### LoopInterface\n\n#### run()\n\nThe `run(): void` method can be used to\nrun the event loop until there are no more tasks to perform.\n\nFor many applications, this method is the only directly visible\ninvocation on the event loop.\nAs a rule of thumb, it is usually recommended to attach everything to the\nsame loop instance and then run the loop once at the bottom end of the\napplication.\n\n```php\n$loop->run();\n```\n\nThis method will keep the loop running until there are no more tasks\nto perform. In other words: This method will block until the last\ntimer, stream and/or signal has been removed.\n\nLikewise, it is imperative to ensure the application actually invokes\nthis method once. Adding listeners to the loop and missing to actually\nrun it will result in the application exiting without actually waiting\nfor any of the attached listeners.\n\nThis method MUST NOT be called while the loop is already running.\nThis method MAY be called more than once after it has explicitly been\n[`stop()`ped](#stop) or after it automatically stopped because it\npreviously did no longer have anything to do.\n\n#### stop()\n\nThe `stop(): void` method can be used to\ninstruct a running event loop to stop.\n\nThis method is considered advanced usage and should be used with care.\nAs a rule of thumb, it is usually recommended to let the loop stop\nonly automatically when it no longer has anything to do.\n\nThis method can be used to explicitly instruct the event loop to stop:\n\n```php\n$loop->addTimer(3.0, function () use ($loop) {\n    $loop->stop();\n});\n```\n\nCalling this method on a loop instance that is not currently running or\non a loop instance that has already been stopped has no effect.\n\n#### addTimer()\n\nThe `addTimer(float $interval, callable $callback): TimerInterface` method can be used to\nenqueue a callback to be invoked once after the given interval.\n\nThe second parameter MUST be a timer callback function that accepts\nthe timer instance as its only parameter.\nIf you don't use the timer instance inside your timer callback function\nyou MAY use a function which has no parameters at all.\n\nThe timer callback function MUST NOT throw an `Exception`.\nThe return value of the timer callback function will be ignored and has\nno effect, so for performance reasons you're recommended to not return\nany excessive data structures.\n\nThis method returns a timer instance. The same timer instance will also be \npassed into the timer callback function as described above.\nYou can invoke [`cancelTimer`](#canceltimer) to cancel a pending timer.\nUnlike [`addPeriodicTimer()`](#addperiodictimer), this method will ensure\nthe callback will be invoked only once after the given interval.\n\n```php\n$loop->addTimer(0.8, function () {\n    echo 'world!' . PHP_EOL;\n});\n\n$loop->addTimer(0.3, function () {\n    echo 'hello ';\n});\n```\n\nSee also [example #1](examples).\n\nIf you want to access any variables within your callback function, you\ncan bind arbitrary data to a callback closure like this:\n\n```php\nfunction hello($name, LoopInterface $loop)\n{\n    $loop->addTimer(1.0, function () use ($name) {\n        echo \"hello $name\\n\";\n    });\n}\n\nhello('Tester', $loop);\n```\n\nThis interface does not enforce any particular timer resolution, so\nspecial care may have to be taken if you rely on very high precision with\nmillisecond accuracy or below. Event loop implementations SHOULD work on\na best effort basis and SHOULD provide at least millisecond accuracy\nunless otherwise noted. Many existing event loop implementations are\nknown to provide microsecond accuracy, but it's generally not recommended\nto rely on this high precision.\n\nSimilarly, the execution order of timers scheduled to execute at the\nsame time (within its possible accuracy) is not guaranteed.\n\nThis interface suggests that event loop implementations SHOULD use a\nmonotonic time source if available. Given that a monotonic time source is\nonly available as of PHP 7.3 by default, event loop implementations MAY\nfall back to using wall-clock time.\nWhile this does not affect many common use cases, this is an important\ndistinction for programs that rely on a high time precision or on systems\nthat are subject to discontinuous time adjustments (time jumps).\nThis means that if you schedule a timer to trigger in 30s and then adjust\nyour system time forward by 20s, the timer SHOULD still trigger in 30s.\nSee also [event loop implementations](#loop-implementations) for more details.\n\n#### addPeriodicTimer()\n\nThe `addPeriodicTimer(float $interval, callable $callback): TimerInterface` method can be used to\nenqueue a callback to be invoked repeatedly after the given interval.\n\nThe second parameter MUST be a timer callback function that accepts\nthe timer instance as its only parameter.\nIf you don't use the timer instance inside your timer callback function\nyou MAY use a function which has no parameters at all.\n\nThe timer callback function MUST NOT throw an `Exception`.\nThe return value of the timer callback function will be ignored and has\nno effect, so for performance reasons you're recommended to not return\nany excessive data structures.\n\nThis method returns a timer instance. The same timer instance will also be \npassed into the timer callback function as described above.\nUnlike [`addTimer()`](#addtimer), this method will ensure the callback \nwill be invoked infinitely after the given interval or until you invoke \n[`cancelTimer`](#canceltimer).\n\n```php\n$timer = $loop->addPeriodicTimer(0.1, function () {\n    echo 'tick!' . PHP_EOL;\n});\n\n$loop->addTimer(1.0, function () use ($loop, $timer) {\n    $loop->cancelTimer($timer);\n    echo 'Done' . PHP_EOL;\n});\n```\n\nSee also [example #2](examples).\n\nIf you want to limit the number of executions, you can bind\narbitrary data to a callback closure like this:\n\n```php\nfunction hello($name, LoopInterface $loop)\n{\n    $n = 3;\n    $loop->addPeriodicTimer(1.0, function ($timer) use ($name, $loop, &$n) {\n        if ($n > 0) {\n            --$n;\n            echo \"hello $name\\n\";\n        } else {\n            $loop->cancelTimer($timer);\n        }\n    });\n}\n\nhello('Tester', $loop);\n```\n\nThis interface does not enforce any particular timer resolution, so\nspecial care may have to be taken if you rely on very high precision with\nmillisecond accuracy or below. Event loop implementations SHOULD work on\na best effort basis and SHOULD provide at least millisecond accuracy\nunless otherwise noted. Many existing event loop implementations are\nknown to provide microsecond accuracy, but it's generally not recommended\nto rely on this high precision.\n\nSimilarly, the execution order of timers scheduled to execute at the\nsame time (within its possible accuracy) is not guaranteed.\n\nThis interface suggests that event loop implementations SHOULD use a\nmonotonic time source if available. Given that a monotonic time source is\nonly available as of PHP 7.3 by default, event loop implementations MAY\nfall back to using wall-clock time.\nWhile this does not affect many common use cases, this is an important\ndistinction for programs that rely on a high time precision or on systems\nthat are subject to discontinuous time adjustments (time jumps).\nThis means that if you schedule a timer to trigger in 30s and then adjust\nyour system time forward by 20s, the timer SHOULD still trigger in 30s.\nSee also [event loop implementations](#loop-implementations) for more details.\n\nAdditionally, periodic timers may be subject to timer drift due to\nre-scheduling after each invocation. As such, it's generally not\nrecommended to rely on this for high precision intervals with millisecond\naccuracy or below.\n\n#### cancelTimer()\n\nThe `cancelTimer(TimerInterface $timer): void` method can be used to\ncancel a pending timer.\n\nSee also [`addPeriodicTimer()`](#addperiodictimer) and [example #2](examples).\n\nCalling this method on a timer instance that has not been added to this\nloop instance or on a timer that has already been cancelled has no effect.\n\n#### futureTick()\n\nThe `futureTick(callable $listener): void` method can be used to\nschedule a callback to be invoked on a future tick of the event loop.\n\nThis works very much similar to timers with an interval of zero seconds,\nbut does not require the overhead of scheduling a timer queue.\n\nThe tick callback function MUST be able to accept zero parameters.\n\nThe tick callback function MUST NOT throw an `Exception`.\nThe return value of the tick callback function will be ignored and has\nno effect, so for performance reasons you're recommended to not return\nany excessive data structures.\n\nIf you want to access any variables within your callback function, you\ncan bind arbitrary data to a callback closure like this:\n\n```php\nfunction hello($name, LoopInterface $loop)\n{\n    $loop->futureTick(function () use ($name) {\n        echo \"hello $name\\n\";\n    });\n}\n\nhello('Tester', $loop);\n```\n\nUnlike timers, tick callbacks are guaranteed to be executed in the order\nthey are enqueued.\nAlso, once a callback is enqueued, there's no way to cancel this operation.\n\nThis is often used to break down bigger tasks into smaller steps (a form\nof cooperative multitasking).\n\n```php\n$loop->futureTick(function () {\n    echo 'b';\n});\n$loop->futureTick(function () {\n    echo 'c';\n});\necho 'a';\n```\n\nSee also [example #3](examples).\n\n#### addSignal()\n\nThe `addSignal(int $signal, callable $listener): void` method can be used to\nregister a listener to be notified when a signal has been caught by this process.\n\nThis is useful to catch user interrupt signals or shutdown signals from\ntools like `supervisor` or `systemd`.\n\nThe second parameter MUST be a listener callback function that accepts\nthe signal as its only parameter.\nIf you don't use the signal inside your listener callback function\nyou MAY use a function which has no parameters at all.\n\nThe listener callback function MUST NOT throw an `Exception`.\nThe return value of the listener callback function will be ignored and has\nno effect, so for performance reasons you're recommended to not return\nany excessive data structures.\n\n```php\n$loop->addSignal(SIGINT, function (int $signal) {\n    echo 'Caught user interrupt signal' . PHP_EOL;\n});\n```\n\nSee also [example #4](examples).\n\nSignaling is only available on Unix-like platforms, Windows isn't\nsupported due to operating system limitations.\nThis method may throw a `BadMethodCallException` if signals aren't\nsupported on this platform, for example when required extensions are\nmissing.\n\n**Note: A listener can only be added once to the same signal, any\nattempts to add it more than once will be ignored.**\n\n#### removeSignal()\n\nThe `removeSignal(int $signal, callable $listener): void` method can be used to\nremove a previously added signal listener.\n\n```php\n$loop->removeSignal(SIGINT, $listener);\n```\n\nAny attempts to remove listeners that aren't registered will be ignored.\n\n#### addReadStream()\n\n> Advanced! Note that this low-level API is considered advanced usage.\n  Most use cases should probably use the higher-level\n  [readable Stream API](https://github.com/reactphp/stream#readablestreaminterface)\n  instead.\n\nThe `addReadStream(resource $stream, callable $callback): void` method can be used to\nregister a listener to be notified when a stream is ready to read.\n\nThe first parameter MUST be a valid stream resource that supports\nchecking whether it is ready to read by this loop implementation.\nA single stream resource MUST NOT be added more than once.\nInstead, either call [`removeReadStream()`](#removereadstream) first or\nreact to this event with a single listener and then dispatch from this\nlistener. This method MAY throw an `Exception` if the given resource type\nis not supported by this loop implementation.\n\nThe second parameter MUST be a listener callback function that accepts\nthe stream resource as its only parameter.\nIf you don't use the stream resource inside your listener callback function\nyou MAY use a function which has no parameters at all.\n\nThe listener callback function MUST NOT throw an `Exception`.\nThe return value of the listener callback function will be ignored and has\nno effect, so for performance reasons you're recommended to not return\nany excessive data structures.\n\nIf you want to access any variables within your callback function, you\ncan bind arbitrary data to a callback closure like this:\n\n```php\n$loop->addReadStream($stream, function ($stream) use ($name) {\n    echo $name . ' said: ' . fread($stream);\n});\n```\n\nSee also [example #11](examples).\n\nYou can invoke [`removeReadStream()`](#removereadstream) to remove the\nread event listener for this stream.\n\nThe execution order of listeners when multiple streams become ready at\nthe same time is not guaranteed.\n\nSome event loop implementations are known to only trigger the listener if\nthe stream *becomes* readable (edge-triggered) and may not trigger if the\nstream has already been readable from the beginning.\nThis also implies that a stream may not be recognized as readable when data\nis still left in PHP's internal stream buffers.\nAs such, it's recommended to use `stream_set_read_buffer($stream, 0);`\nto disable PHP's internal read buffer in this case.\n\n#### addWriteStream()\n\n> Advanced! Note that this low-level API is considered advanced usage.\n  Most use cases should probably use the higher-level\n  [writable Stream API](https://github.com/reactphp/stream#writablestreaminterface)\n  instead.\n\nThe `addWriteStream(resource $stream, callable $callback): void` method can be used to\nregister a listener to be notified when a stream is ready to write.\n\nThe first parameter MUST be a valid stream resource that supports\nchecking whether it is ready to write by this loop implementation.\nA single stream resource MUST NOT be added more than once.\nInstead, either call [`removeWriteStream()`](#removewritestream) first or\nreact to this event with a single listener and then dispatch from this\nlistener. This method MAY throw an `Exception` if the given resource type\nis not supported by this loop implementation.\n\nThe second parameter MUST be a listener callback function that accepts\nthe stream resource as its only parameter.\nIf you don't use the stream resource inside your listener callback function\nyou MAY use a function which has no parameters at all.\n\nThe listener callback function MUST NOT throw an `Exception`.\nThe return value of the listener callback function will be ignored and has\nno effect, so for performance reasons you're recommended to not return\nany excessive data structures.\n\nIf you want to access any variables within your callback function, you\ncan bind arbitrary data to a callback closure like this:\n\n```php\n$loop->addWriteStream($stream, function ($stream) use ($name) {\n    fwrite($stream, 'Hello ' . $name);\n});\n```\n\nSee also [example #12](examples).\n\nYou can invoke [`removeWriteStream()`](#removewritestream) to remove the\nwrite event listener for this stream.\n\nThe execution order of listeners when multiple streams become ready at\nthe same time is not guaranteed.\n\n#### removeReadStream()\n\nThe `removeReadStream(resource $stream): void` method can be used to\nremove the read event listener for the given stream.\n\nRemoving a stream from the loop that has already been removed or trying\nto remove a stream that was never added or is invalid has no effect.\n\n#### removeWriteStream()\n\nThe `removeWriteStream(resource $stream): void` method can be used to\nremove the write event listener for the given stream.\n\nRemoving a stream from the loop that has already been removed or trying\nto remove a stream that was never added or is invalid has no effect.\n\n## Install\n\nThe recommended way to install this library is [through Composer](https://getcomposer.org/).\n[New to Composer?](https://getcomposer.org/doc/00-intro.md)\n\nOnce released, this project will follow [SemVer](https://semver.org/).\nAt the moment, this will install the latest development version:\n\n```bash\ncomposer require react/event-loop:^3@dev\n```\n\nSee also the [CHANGELOG](CHANGELOG.md) for details about version upgrades.\n\nThis project aims to run on any platform and thus does not require any PHP\nextensions and supports running on PHP 7.1 through current PHP 8+.\nIt's *highly recommended to use the latest supported PHP version* for this project.\n\nInstalling any of the event loop extensions is suggested, but entirely optional.\nSee also [event loop implementations](#loop-implementations) for more details.\n\n## Tests\n\nTo run the test suite, you first need to clone this repo and then install all\ndependencies [through Composer](https://getcomposer.org/):\n\n```bash\ncomposer install\n```\n\nTo run the test suite, go to the project root and run:\n\n```bash\nvendor/bin/phpunit\n```\n\n## License\n\nMIT, see [LICENSE file](LICENSE).\n\n## More\n\n* See our [Stream component](https://github.com/reactphp/stream) for more\n  information on how streams are used in real-world applications.\n* See our [users wiki](https://github.com/reactphp/react/wiki/Users) and the\n  [dependents on Packagist](https://packagist.org/packages/react/event-loop/dependents)\n  for a list of packages that use the EventLoop in real-world applications.\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.240234375,
          "content": "{\n    \"name\": \"react/event-loop\",\n    \"description\": \"ReactPHP's core reactor event loop that libraries can use for evented I/O.\",\n    \"keywords\": [\"event-loop\", \"asynchronous\"],\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Christian Lück\",\n            \"homepage\": \"https://clue.engineering/\",\n            \"email\": \"christian@clue.engineering\"\n        },\n        {\n            \"name\": \"Cees-Jan Kiewiet\",\n            \"homepage\": \"https://wyrihaximus.net/\",\n            \"email\": \"reactphp@ceesjankiewiet.nl\"\n        },\n        {\n            \"name\": \"Jan Sorgalla\",\n            \"homepage\": \"https://sorgalla.com/\",\n            \"email\": \"jsorgalla@gmail.com\"\n        },\n        {\n            \"name\": \"Chris Boden\",\n            \"homepage\": \"https://cboden.dev/\",\n            \"email\": \"cboden@gmail.com\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=7.1\"\n    },\n    \"require-dev\": {\n        \"phpunit/phpunit\": \"^9.6 || ^7.5\"\n    },\n    \"suggest\": {\n        \"ext-pcntl\": \"For signal handling support when using the StreamSelectLoop\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"React\\\\EventLoop\\\\\": \"src/\"\n        }\n    },\n    \"autoload-dev\": {\n        \"psr-4\": {\n            \"React\\\\Tests\\\\EventLoop\\\\\": \"tests/\"\n        }\n    }\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 1.0185546875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!-- PHPUnit configuration file with new format for PHPUnit 9.6+ -->\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/9.6/phpunit.xsd\"\n         bootstrap=\"vendor/autoload.php\"\n         cacheResult=\"false\"\n         colors=\"true\"\n         convertDeprecationsToExceptions=\"true\">\n    <testsuites>\n        <testsuite name=\"EventLoop Test Suite\">\n            <directory>./tests/</directory>\n        </testsuite>\n    </testsuites>\n    <coverage>\n        <include>\n            <directory>./src/</directory>\n        </include>\n    </coverage>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n        <!-- Evaluate assertions, requires running with \"php -d zend.assertions=1 vendor/bin/phpunit\" -->\n        <!-- <ini name=\"zend.assertions\" value=\"1\" /> -->\n        <ini name=\"assert.active\" value=\"1\" />\n        <ini name=\"assert.exception\" value=\"1\" />\n        <ini name=\"assert.bail\" value=\"0\" />\n    </php>\n</phpunit>\n"
        },
        {
          "name": "phpunit.xml.legacy",
          "type": "blob",
          "size": 0.9453125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!-- PHPUnit configuration file with old format for legacy PHPUnit -->\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/7.5/phpunit.xsd\"\n         bootstrap=\"vendor/autoload.php\"\n         colors=\"true\">\n    <testsuites>\n        <testsuite name=\"EventLoop Test Suite\">\n            <directory>./tests/</directory>\n        </testsuite>\n    </testsuites>\n    <filter>\n        <whitelist>\n            <directory>./src/</directory>\n        </whitelist>\n    </filter>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n        <!-- Evaluate assertions, requires running with \"php -d zend.assertions=1 vendor/bin/phpunit\" -->\n        <!-- <ini name=\"zend.assertions\" value=\"1\" /> -->\n        <ini name=\"assert.active\" value=\"1\" />\n        <ini name=\"assert.exception\" value=\"1\" />\n        <ini name=\"assert.bail\" value=\"0\" />\n    </php>\n</phpunit>\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}