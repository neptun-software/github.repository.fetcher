{
  "metadata": {
    "timestamp": 1736711785815,
    "page": 50,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tecnickcom/TCPDF",
      "stars": 4270,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.15234375,
          "content": "/.github export-ignore\n/.gitignore export-ignore\n/.gitattributes export-ignore\n/tests export-ignore\n/scripts export-ignore\n/phpstan.neon.dist export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0576171875,
          "content": ".idea\n.phpdoc\n*.bak\n/vendor/\n/composer.lock\n/composer.phar\n"
        },
        {
          "name": "CHANGELOG.TXT",
          "type": "blob",
          "size": 121.7802734375,
          "content": "6.8.0 (2024-12-23)\n\t- Requires PHP 7.1+ and curl extension.\n\t- Escape error message.\n\t- Use strict time-constant function to compare TCPDF-tag hashes.\n\t- Add K_CURLOPTS config array to set custom cURL options (NOTE: some defaults have changed).\n\t- Add some addTTFfont fixes from tc-lib-pdf-font.\n\n6.7.8 (2024-12-13)\n\t- Improve SVG detection by checking for (mandatory) namespace.\n\t- Use late state binding now that minimum PHP version is 5.5.\n\n6.7.7 (2024-10-26)\n\t- Update regular expression to avoid ReDoS (CVE-2024-22641)\n\t- [PHP 8.4] Fix: Curl CURLOPT_BINARYTRANSFER deprecated #675\n\t- SVG detection fix for inline data images #646\n\t- Fix count svg #647\n\t- Since the version 6.7.4, the \"0\" is considered like empty string and not displayed\n\t- Fixed handling of transparency in PDF/A mode in addExtGState method\n\t- Encrypt /DA string when document is encrypted\n\t- Improve quality of generated seed, avoid potential security pitfall\n\t- Try to use random_bytes() first if it's available\n\t- Do not include the server parameters in the generated seed, as they might contain sensitive data\n\t- Fix bug on _getannotsrefs when there are empty signature appearances but not other annot on a page\n\t- Fix SVG coordinate parser that caused drawing artifacts\n\t- Remove usage of xml_set_object() function\n\n6.7.6 (2024-10-06)\n\t- Forbid access to parent folder in HTML images.\n\n6.7.5 (2024-04-20)\n\t- Update GitHub actions\n\t- fix: CSV-2024-22640 (#712)\n\n6.7.4 (2024-03-24)\n\t- Upgrade tcpdf tag encryption algorithm.\n\t- Fix regression issue #699.\n\t- Fix security issue.\n\t- [BREAKING CHANGE] The tcpdf HTML tag syntax has changed, see example_049.php.\n\t- New K_ALLOWED_TCPDF_TAGS configuration constant to set the allowed methods for the tcdpf HTML tag.\n\t- Raised minimum PHP version to PHP 5.5.0.\n\n6.6.5 (2023-09-02)\n\t- Fix corrupted file.\n\t- Fix GitHub automation tests.\n\t- Fix SPDX license ID (#591)\n\t- Fix warning \"array offset on value of type null\" (#620)\n\t- Improve the README about the status of this library (#589)\n\t- Fix deprecation warning with PHP 8.1 (#614)\n\t- Fixes for PHP 8.2 in tcpdf_fonts.php (#632)\n\t- Fix some php 8+ edge cases (#630)\n\t- Fix composite glyph output (#581)\n\t- Fix \"access array offset on value of type bool\" with PDF/A (#583)\n\t- Fix non-numeric value warning (#627)\n\t- Fix issues with S25 barcode (#611)\n\t- Fix return type annotations (#613)\n\t- Fix some inconsistencies in type hints (#598)\n\n6.6.2 (2022-12-17)\n\t- Ensure pregSplit return type is always array.\n\t- Add ability to run tests on various operating systems (#566)\n\t- Avoid a deprecated error from PHP8.1 (#573)\n\n6.6.1 (2022-12-12)\n\t- Add PHPStan and fix level 1 errors (#307)\n\n6.6.0 (2022-12-06)\n\t- Multi-byte character support for filename during output (#561). (#562)\n\t- Fix garbage collection (#509)\n\t- FIX: PDF417 corrupt output problem, solution set bcmath scale parameter to zero (#534)\n\t- Fix TypeError: count() in PHP8 (#556)\n\t- Fix-getHTMLFontUnits (#547)\n\t- Improved embedded image in HTML allowing src=\"data:...\" format (#552)\n\t- Fix image abscissa when in RTL (#510)\n\t- fix: php 8.1 notices (#548)\n\t- Optimize PNG files (#563)\n\t- Update documentation for a known issue. (#569)\n\t- Fix for PHP 8.1 (#571)\n\n6.5.0 (2022-08-12)\n\t- encodeUrlQuery takes into account the port (#493)\n\t- Fixing undefined offset error in writeHTML() when last DOM element ha…\n\t- correct some type hints (#495)\n\t- fix: php 8.1 notices (#481)\n\t- Fixed: null check for PHP 8.1 (#476)\n\t- Fix Infinite Loop in Multicell with Auto Page Breaks Off (#473)\n\t- GetCssBorderStyle Has Problem When !important Is Specified (#467)\n\t- Support Apache 2.4 directives in htaccess file (#530)\n\t- Remove examples from dist package (#542)\n\n6.4.4 (2021-12-31)\n\t- PHP 8.1 fixes\n\n6.4.3 (2021-12-28)\n\t- Fix MultiCell PHPDoc typehint (#407)\n\t- Fix type hint for \\TCPDF_STATIC::_freadint (#414)\n\t- Footer and Header font phpdoc fixes + constructor $pdfa phpdoc fix + setHeaderData lw param fix (#402)\n\t- Fix text-annotation state options (#412)\n\t- Fix - Named links have been broken. This fixes. (#415)\n\t- Fixed type in comment for $lw header image logo width in mm\n\t- Change Set to set. Fixes #419 (#421)\n\t- Fix failing tests and failing tests not marking exit code as 1 (#426)\n\t- Fix phpdoc and prefer null as default value (#444)\n\t- Run on PHP 8.1 normally and add nightly PHP as allowed to fail (#452)\n\t- Fix AES128 encryption if the OpenSSL extension is installed (#453)\n\t- Explicitly cast values to int for imagesetpixel (#460)\n\t- Fix cell_height_ratio type (#405)\n\t- Leave &NBSP; lowercase when using text-transform (#403)\n\n6.4.2 (2021-07-20)\n\t- Fix PHP 8.1 type error with TCPDF_STATIC::pregSplit on preg_split\n\t- Fix a PHP array offset error\n\t- Fixed phpdoc blocks\n\t- Drop a PHP 4 polyfill and add a .gitattributes file\n\t- Added a test-suite\n\t- Removed pointless assignments\n\t- Fix docblock spelling error\n\t- Update version info\n\t- Fix color being filled to type 0 with PHP 8\n\t- Fix warnings for undefined tags for $lineStyle\n\t- Normalized composer.json\n\t- Allowed transparency in PDF/A-2 and PDF/A-3\n\t- Add a TCPDF composer example\n\t- Fixed implicit conversion from float to int for PHP 8.1\n\t- Removed status.txt from font directories, because of filesize\n\t- Fixed type hints\n\t- Removed \"U\" modifier from regexes\n\n6.4.1 (2021-03-27)\n\t- Update tcpdf version (no code changes)\n\n6.4.0 (2021-03-27)\n\t- allow styles on <HR> tags\n\t- check if file exists before calling unlink\n\t- Fix image file type for urls with query params\n\t- Fix SVGPath should accept 1.19.30 (equiv 1.19,.30) compacted values list\n\t- Fix Second parameter of TCPDF::cell() must be a number\n\t- PHP 8.0 function signature fixes\n\t- Fix vulnerability to roman numeral bombs\n\t- Optimized a regular expression\n\t- Cache file get contents calls\n\t- Remove mb_internal encoding handling\n\n6.3.5 (2020-02-14)\n\t- Fixed curly braces in pdf417\n\t- Fixed a syntax error issue when accessing an index of a casted variable\n\n6.3.4 (2020-02-12)\n\t- Check if imagekeys exist\n\t- Unlink only images in cache\n\n6.3.3 (2020-02-12)\n\t- Fixed PHP 7.4 - cannot use array offset on integers\n\t- Fixed PDF/A-3B validation issue caused by missing pdfaSchema:property.\n\t- Removed backup changelog files from repo\n\t- Prevents the deletion of non-existent files in /tmp\n\t- Prevent crash in case of no list access in cache path\n\t- Check existence of file before delete it\n\t- Fixed erase users pictures\n\t- Fixed problem with $imagekeys undefined or unlinked\n\t- Fix SVGPath elliptical arc with rx/ry=0 + z should return to initial point\n\t- Fixed PHP 7.4 errors\n\t- handle integers for pages\n\t- Fixed background image doesn't work in RTL\n\t- Fixed PDF/A validity\n\t- Fixed datamatrix.php for PHP 7.4\n\t- Fixed deprecated PHP features\n\n6.3.2 (2019-09-20)\n\t- Update ICC profile\n\n6.3.1 (2019-09-20)\n\t- Fix reported version\n\t- Fix Undefined property: GLPIPDF::$imagekeys\n\n6.3.0 (2019-09-19)\n\t- fix SpotColor handling in HTML\n\t- Add an additional empty test to prevent error in PHP 7.2\n\t- Fix the documentation how to calculate the cell height\n\t- Drop duplicated array indices\n\t- Fix TCPDF_STATIC::fileGetContents()\n\t- Introduce other version of pdfA (2 and 3)\n\t- Add UF and AFRelationship missing\n\t- Fix performance issue of cloned instances\n\t- Change glob to readdir which performs better\n\t- URI in PDF can result in E_NOTICE\n\t- Fix a warning for PHP 7.4\n\t- Fixed gradient offsets for percentage-based stops.\n\t- Fixed file_get_contents return value should also be checked for a non-empty string\n\t- Fix Array and string offset access syntax with curly braces is deprecated\n\t- Fix PHP Warning: chr() expects parameter 1 to be int\n\t- Add a VERSION file\n\n6.2.26 (2018-10-16)\n\t- Update sRGB.icc with the one from the Debian package icc-profiles-free\n\t- Fix unsupported operand types error when codepoints arrays are merged\n\n6.2.25 (2018-09-23)\n\t- Fix support for image URLs.\n\n6.2.24\n\t- Support remote urls when checking if file exists.\n\n6.2.23 (2018-09-22)\n\t- Simplify file_exists function.\n\n6.2.22 (2018-09-14)\n\t- Fixes on `include/tcpdf_images.php`, `include/tcpdf_static.php` and `tcpdf.php` about file handling\n\n6.2.21 (2018-09-14)\n\t- _no code changes_\n\n6.2.20 (2018-09-14)\n\t- Fix for security vulnerability: Using the phar:// wrapper it was possible to trigger the unserialization of user provided data.\n\n6.2.19 (2018-09-14)\n\t- Merge various fixes for PHP 7.3 compatibility and security.\n\n6.2.13 (2016-06-10)\n\t- IMPORTANT: A new version of this library is under development at https://github.com/tecnickcom/tc-lib-pdf and as a consequence this version will not receive any additional development or support. This version should be considered obsolete, new projects should use the new version as soon it will become stable.\n\n6.2.12 (2015-09-12)\n\t- fix composer package name to tecnickcom/tcpdf\n\n6.2.11 (2015-08-02)\n\t- Bug #1070 \"PNG regression in 6.2.9 (they appear as their alpha channel)\" was fixed.\n\t- Bug #1069 \"Encoded SRC URLs in <img> tags don't work anymore\" was fixed.\n\n6.2.10 (2015-07-28)\n\t- Minor mod to PNG parsing.\n\t- Make dependency on mcrypt optional.\n\n6.2.8 (2015-04-29)\n\t- Removed unwanted file.\n\n6.2.7 (2015-04-28)\n\t- Merged PR 17: Avoid warning when iterating a non-array variable.\n\t- Merged PR 16: Improve MuliCell param definition.\n\t- Improved column check (PR 15).\n\t- Merged PR 11: Use stream_is_local instead of limit to file://.\n\t- Merged PR 10: ImageMagick link on README.txt.\n\n6.2.6 (2015-01-28)\n\t- Bug #1008 \"UTC offset sing breaks PDF/A-1b compliance\" was fixed.\n\n6.2.5 (2015-01-24)\n\t- Bug #1019 \"$this in static context\" was fixed.\n\t- Bug #1015 \"Infinite loop in getIndirectObject method of parser\" was fixed.\n\n6.2.4 (2015-01-08)\n\t- fix warning related to empty K_PATH_URL.\n\t- fix error when a $table_colwidths key is not set.\n\n6.2.3 (2014-12-18)\n\t- New comment.\n\t- Moved the K_PATH_IMAGES definition in tcpdf_autoconfig.\n\n6.2.2 (2014-12-18)\n\t- Fixed mispelled words.\n\t- Fixed version number.\n\n6.2.1 (2014-12-18)\n\t- The constant K_TCPDF_THROW_EXCEPTION_ERROR is now set to false in the default configuration file.\n\t- An issue with the _destroy() method was fixed.\n\n6.2.0 (2014-12-10)\n\t- Bug #1005 \"Security Report, LFI posting internal files externally abusing default parameter\" was fixed.\n\t- Static methods serializeTCPDFtagParameters() and unserializeTCPDFtagParameters() were moved as non static to the main TCPDF class (see changes in example n. 49).\n\t- Deprecated methods were removed, please use the equivalents defined in other classes (i.e. TCPDF_STATIC and TCPDF_FONTS).\n\t- The constant K_TCPDF_CALLS_IN_HTML is now set by default to FALSE.\n\t- DLE, DLX and DLP page format was added.\n\t- Page format are now defined as a public property in TCPDF_STATIC.\n\n6.1.1 (2014-12-09)\n\t- Fixed bug with the register_shutdown_function().\n\n6.1.0 (2014-12-07)\n\t- The method TCPDF_STATIC::getRandomSeed() was improved.\n\t- The disk caching feature was removed.\n\t- Bug #1003 \"Backslashes become duplicated in table, using WriteHTML\" was fixed.\n\t- Bug #1002 \"SVG radialGradient within non-square Rect\" was fixed.\n\n6.0.099 (2014-11-15)\n\t- Added basic support for nested SVG images (adapted PR from SamMousa).\n\t- A bug related to setGDImageTransparency() was fixed (thanks to Maarten Boerema).\n\n6.0.098 (2014-11-08)\n\t- Bug item #996 \"getCharBBox($char) returns incorrect results for TTF glyphs without outlines\" was fixed.\n\t- Bug item #991 \"Text problem with SVG\" was fixed (only the font style part).\n\n6.0.097 (2014-10-20)\n\t- Bug item #988 \"hyphenateText - charmin parameter not work\" was fixed.\n\t- New 1D barcode method to print pre-formatted IMB - Intelligent Mail Barcode - Onecode - USPS-B-3200.\n\n6.0.096 (2014-10-06)\n\t- Bug item #982 \"Display style is not inherited in SVG\" was fixed.\n\t- Bug item #984 \"Double quote url in CSS\" was fixed.\n\n6.0.095 (2014-10-02)\n\t- Bug item #979 \"New Timezone option overwriting current timezone\" was fixed.\n\n6.0.094 (2014-09-30)\n\t- Bug item #978 \"Variable Undefined: $cborder\" was fixed.\n\n6.0.093 (2014-09-02)\n\t- Security fix: some serialize/unserialize methods were replaced with json_encode/json_decode to avoid a potential object injection with user supplied content. Thanks to ownCloud Inc. for reporting this issue.\n\t- K_TIMEZONE constant was added to the default configuration to suppress date-time warnings.\n\n6.0.092 (2014-09-01)\n\t- Bug item #956 \"Monospaced fonts are not alignd at the baseline\" was fixed.\n\t- Bug item #964 \"Problem when changing font size\" was fixed.\n\t- Bug item #969 \"ImageSVG with radialGradient problem\" was fixed.\n\t- sRGB.icc file was replaced with the one from the Debian package icc-profiles-free (2.0.1+dfsg-1) \n\n6.0.091 (2014-08-13)\n\t- Issue #325\"Division by zero when css fontsize equals 0\" was fixed.\n\n6.0.090 (2014-08-08)\n\t- Starting from this version TCPDF is also available in GitHub at https://github.com/tecnickcom/TCPDF\n\t- Function getmypid() was removed for better compatibility with shared hosting environments.\n\t- Support for pulling SVG stroke opacity value from RGBa color was mergeg [adf006].\n\t- Bug item #951 \"HTML Table within TCPDF columns doesnt flow correctly on page break ...\" was fixed. \n\n6.0.089 (2014-07-16)\n\t- Bug item #948 \"bottom line of rowspan cell not work correctly\" was fixed.\n\n6.0.088 (2014-07-09)\n\t- Bug item #946 \"Case sensitive type check causes broken match for SVG\" was fixed.\n\t- Bug item #945 \"Imagick load doesn't account for passed data string \" was fixed.\n\n6.0.087 (2014-06-25)\n\t- A bug affecting fitcell option in Multicell was fixed.\n\n6.0.086 (2014-06-20)\n\t- Bug item #938 \"Hyphenation-dash extends outside of cell\" was fixed (collateral effect).\n\n6.0.085 (2014-06-19)\n\t- Some example images were replaced.\n\t- A race condition bug was fixed.\n\t- Bug item #938 \"Hyphenation-dash extends outside of cell\" was fixed.\n\n6.0.084 (2014-06-13)\n\t- A bug related to MultiCell fitcell feature was fixed.\n\t- Bug item #931 \"Documentation error for setPageFormat()\" was fixed.\n\n6.0.083 (2014-05-29)\n\t- Bug item #928 \"setHtmlVSpace with HR element\" was fixed.\n\n6.0.082 (2014-05-23)\n\t- Bug item #926 \"test statement instead of assignment used in tcpdf_fonts.php\" was fixed.\n\t- Bug item #925 \"924 transparent images bug\" was fixed.\n\n6.0.081 (2014-05-22)\n\t- Bug item #922 \"writehtml tables thead repeating\" was fixed.\n\t- Patch #71 \"External and internal links, local and remote\" wa applied.\n\n6.0.080 (2014-05-20)\n\t- Bug item #921 \"Fatal error in hyphenateText() function\" was fixed.\n\t- Bug item #923 \"Automatic Hyphenation error\" was fixed.\n\t- Patch #70 \"Augument TCPDFBarcode classes with ability to return raw png image data\" was applied.\n\n6.0.079 (2014-05-19)\n\t- Patch item #69 \"Named destinations, HTML internal and external links\" was merged.\n\t- Bug item #920 \"hyphenateText() should not hyphenate the content of style-tags in HTML mode\" was fixed.\n\t- Image method now trigs an error in case the cache is now writeable.\n\t- Fixed issue with layer default status.\n\n6.0.078 (2014-05-12)\n\t- A warning issue in addTTFfont() method was fixed.\n\t- Fonts were updated to include cbbox metrics.\n\n6.0.077 (2014-05-06)\n\t- A Datamatrix barcode bug was fixed.\n\n6.0.076 (2014-05-06)\n\t- A bug in Datamatrix Base256 encoding was fixed.\n\t- Merged fix for SVG use/clip-gradient.\n\t- Now it is possible to prefix a page number in Link methods with the * character to avoid been changed when adding/deleting/moving pages (see example_045.php).\n\n6.0.075 (2014-05-05)\n\t- Bug #917 \"Using realtive Units like ex or em for images distort output in HTML mode\" was fixed.\n\n6.0.074 (2014-05-03)\n\t- Part of Bug #917 \"Using realtive Units like ex or em for images distort output in HTML mode\" was fixed.\n\t- Bug #915 \"Problem with SVG Image using Radial Gradients\" was fixed.\n\n6.0.073 (2014-04-29)\n\t- Bug #913 \"Possible bug with line-height\" was fixed.\n\t- Bug #914 \"MultiCell and FitCell\" was fixed.\n\t- Bug #915 \"Problem with SVG Image using Radial Gradients\" was fixed.\n\n6.0.072 (2014-04-27)\n\t- Deprecated curly braces substring syntax was replaced with square braces.\n\n6.0.071 (2014-04-25)\n\t- Bug #911 \"error with buffered png pics\" was fixed.\n\n6.0.070 (2014-04-24)\n\t- Bug #910 \"An SVG image is being cut off (with clipping mask) when you use align options\" was fixed.\n\n6.0.069 (2014-04-24)\n\t- Datamatrix Base256 encoding was fixed.\n\n6.0.068 (2014-04-22)\n\t- Some Datamatrix barcode bugs were fixed.\n\n6.0.067 (2014-04-21)\n\t- startLayer() method signature was changed to include a new \"lock\" parameter.\n\n6.0.066 (2014-04-20)\n\t- Bug #908 \"Linebreak is not considered when getting length of the next string\" was fixed.\n\n6.0.065 (2014-04-10)\n\t- Bug #905 \"RGB percentage color bug in convertHTMLColorToDec()\" was fixed.\n\n6.0.064 (2014-04-07)\n\t- Header and Footer fonts are now set by default.\n\t- Bug #904 \"PDF corrupted\" was fixed.\n\n6.0.063 (2014-04-03)\n\t- Method TCPDF_IMAGES::_parsepng() was fixed to support transparency in Indexed images.\n\n6.0.062 (2014-03-02)\n\t- The method startLayer() now accepts the NULL value for the $print parameter to not set the print layer option.\n\n6.0.061 (2014-02-18)\n\t- Bug #893 \"Parsing error on streamed xref for secured pdf\" was fixed.\n\n6.0.060 (2014-02-16)\n\t- Bug #891 \"Error on parsing hexa fields\" was fixed.\n\t- Bug #892 \"Parsing pdf with trailing space at start\" was fixed.\n\n6.0.059 (2014-02-03)\n\t- SVG 'use' support was imporved.\n\n6.0.058 (2014-01-31)\n\t- Bug #886 \"Bugs with SVG using <defs> and <use>\" was fixed.\n\n6.0.057 (2014-01-26)\n\t- Bug #883 \"Parsing error\" was fixed.\n\n6.0.056 (2014-01-25)\n\t- The automatic cache folder selection now works also with some restricted hosting environments.\n\t- CSS text-transform property is now supported (requires the multibyte string library for php) - see examle n. 061 (Thanks to Walter Ferraz).\n\t- Bug #884 \"Parsing error prev tag looking for\" was fixed.\n\n6.0.055 (2014-01-15)\n\t- Bug #880 \"Error detecting hX tags (h1,h2..)\" was fixed\n\t- Bug #879 \"Thead on the second page inherits style of previous tr\" was fixed\n\n6.0.054 (2014-01-13)\n\t- Bug #877 \"Parenteses causing corrupt text\" was fixed.\n\n6.0.053 (2014-01-03)\n\t- Bug #876 \"Cell padding should not be multiplied with number of lines in getStringHeight\" was fixed.\n\t- Patch #68 \"Empty img src attribute leads to access of uninitialized string offset\" was applied.\n\n6.0.052 (2013-12-12)\n\t- Bug #871 \"Datamatrix coding\" was fixed.\n\n6.0.051 (2013-12-02)\n\t- cbbox array values in addTTFfont() were converted to integers.\n\n6.0.050 (2013-12-01)\n\t- The method getNumLines() was extended to support hyphenation.\n\t- The CSS property line-height now supports non percentage values.\n\n6.0.050 (2013-11-27)\n\t- A bug related to PNG images was fixed.\n\n6.0.048 (2013-11-24)\n\t- SVG vars are now reset in ImageSVG() method.\n\n6.0.047 (2013-11-19)\n\t- SVG support was extended to support some nested defs.\n\n6.0.046 (2013-11-17)\n\t- preg_replace_callback functions were replaced to improve memory performances.\n\n6.0.045 (2013-11-17)\n\t- Bug #862 \"Parsing error on flate filter\" was fixed.\n\n6.0.044 (2013-11-10)\n\t- Bug #857 \"Undefined offset error\" was fixed.\n\t- The uniord method now uses a static cache to improve performances (thanks to Mathieu Masseboeuf for the sugegstion).\n\t- Two bugs in the TCPDF_FONTS class were fixed.\n\n6.0.043 (2013-10-29)\n\t- Bug #854 \"CSS instruction display\" was fixed.\n\n6.0.042 (2013-10-25)\n\t- Bug #852 \"CMYK Colors Bug\" was fixed.\n\n6.0.041 (2013-10-21)\n\t- Bug #851 \"Problem with images in PDF. PHP timing out\" was fixed.\n\n6.0.040 (2013-10-20)\n\t- Bug #849 \"SVG import bug\" was fixed.\n\n6.0.039 (2013-10-13)\n\t- Bug #843 \"Wrong call in parser\" was fixed.\n\t- Bug #844 \"Wrong object type named\" was fixed.\n\t- Bug #845 \"Parsing error on obj ref prefixed by '000000'\" was fixed.\n\n6.0.038 (2013-10-06)\n\t- Bug #841 \"Division by zero warning at writeHTML a <li> tag\" was fixed.\n\n6.0.037 (2013-09-30)\n\t- Method getAllSpotColors() was added to return all spot colors.\n\t- Method colorRegistrationBar() was extended to automatically print all spot colors and support individual spot colors.\n\t- The method registrationMarkCMYK() was added to print a registration mark for CMYK colors.\n\t- A bug related to page groups was fixed.\n\t- Gradient() method now supports CMYK equivalents of spot colors.\n\t- Example n. 56 was updated.\n\n6.0.036 (2013-09-29)\n\t- Methods for registration bars and crop marks were extended to support registration color (see example n. 56).\n\t- New default spot colors were added to tcpdf_colors.php, including the 'All' and 'None' special registration colors.\n\n6.0.035 (2013-09-25)\n\t- TCPDF_PARSER class was improved.\n\n6.0.034 (2013-09-24)\n\t- Bug #839 \"Error in xref parsing in mixed newline chars\" was fixed.\n\n6.0.033 (2013-09-23)\n\t- Bug fix related to PNG image transparency using GD library.\n\n6.0.032 (2013-09-23)\n\t- Bug #838 \"Fatal error when imagick cannot handle the image, even though GD is available and can\" was fixed.\n\n6.0.031 (2013-09-18)\n\t- Bug #836 \"Optional EOL marker before endstream\" was fixed.\n\t- Some additional controls were added to avoid \"division by zero\" error with badly formatted input.\n\n6.0.030 (2013-09-17)\n\t- Bug #835 \"PDF417 and Cyrilic simbols\" was fixed.\n\n6.0.029 (2013-09-15)\n\t- Constants K_TCPDF_PARSER_THROW_EXCEPTION_ERROR and K_TCPDF_PARSER_IGNORE_DECODING_ERRORS where removed in favor of a new configuration array in the TCPDF_PARSER class.\n\t- The TCPDF_PARSER class can now be configured using the new $cfg parameter.\n\n6.0.028 (2013-09-15)\n\t- A debug print_r was removed form tcpdf_parser.php.\n\t- TCPDF_FILTERS class now throws an exception in case of error.\n\t- TCPDF_PARSER class now throws an exception in case of error unless you define the constant K_TCPDF_PARSER_THROW_EXCEPTION_ERROR to false.\n\t- The constant K_TCPDF_PARSER_IGNORE_DECODING_ERRORS can be set to tru eto ignore decoding errors on TCPDF_PARSER.\n\n6.0.027 (2013-09-14)\n\t- A bug in tcpdf_parser wen parsing hexadecimal strings was fixed.\n\t- A bug in tcpdf_parser wen looking for statxref was fixed.\n\t- A bug on RC4 encryption was fixed.\n\n6.0.026 (2013-09-14)\n\t- A bug in tcpdf_parser wen decoding streams was fixed.\n\n6.0.025 (2013-09-04)\n\t- A pregSplit() bug was fixed.\n\t- Improved content loading from URLs.\n\t- Improved font path loading.\n\n6.0.024 (2013-09-02)\n\t- Bug #826 \"addEmptySignatureAppearance issue\" was fixed.\n\n6.0.023 (2013-08-05)\n\t- GNU Freefont fonts were updated.\n\t- Licensing and copyright information about fonts were improved.\n\t- PNG image support was improved.\n\n6.0.022 (2013-08-02)\n\t- fixing initialization problem for signature_appearance property.\n\n6.0.021 (2013-07-18)\n\t- The bug caused by the preg_split function on some PHP 5.2.x versions was fixed.\n\n6.0.020 (2013-06-04)\n\t- The method addTTFfont() was fixed (Bug item #813 Undefined offset).\n\n6.0.019 (2013-06-04)\n\t- The magic constant __DIR__ was replaced with dirname(__FILE__) for php 5.2 compatibility.\n\t- The exceptions raised by file_exists() function were suppressed.\n\n6.0.018 (2013-05-19)\n\t- The barcode examples were changed to automatically search for the barcode class path (in case the examples directory is not installed under the TCPDF root).\n\n6.0.017 (2013-05-16)\n\t- The command line tool tcpdf_addfont.php was improved.\n\t- The php logic was removed from configuration files that now contains only constant defines.\n\t- The tcpdf_autoconfig.php file was added to automatically set missing configuration values.\n\n6.0.016 (2013-05-15)\n\t- The tcpdf_addfont.php tool was improved (thanks to Remi Collet).\n\t- Constant K_PATH_IMAGES is now automatically set in configuration file.\n\n6.0.015 (2013-05-14)\n\t- Some unused vars were removed from AddFont() method.\n\t- Some directories were moved inside the examples directory.\n\t- All examples were updated to reflect the new default structure.\n\t- Source code were clean-up up to be more compatible with system packaging.\n\t- Files encodings and permissions were reset.\n\t- The command line tool tcpdf_addfont.php was added on the tools directory.\n\n6.0.014 (2013-04-13)\n\t- The signature of addTTFfont() method includes a new parameter to link existing fonts instead of copying and compressing them.\n\n6.0.013 (2013-04-10)\n\t- Add support for SVG dx and dy text/tspan attributes.\n\t- replace require() with require_once().\n\t- fix some minor typos on documentation.\n\t- fix a problem when deleting all pages.\n\n6.0.012 (2013-04-24)\n\t- An error condition in addHtmlLink() method was fixed (bug #799).\n\n6.0.011 (2013-04-22)\n\t- Minor documentation changes.\n\n6.0.010 (2013-04-03)\n\t- The method Rect() was fixed to print borders correctly.\n\n6.0.009 (2013-04-02)\n\t- Adding back some files that were not properly committed on the latest release.\n\n6.0.008 (2013-04-01)\n\t- Duplicated encoding maps was removed from tcpdf_font_data.php.\n\t- Fixing bug on AddTTFFont().\n\n6.0.007 (2013-03-29)\n\t- HTML/CSS font size conversion were improved.\n\n6.0.006 (2013-03-27)\n\t- Bug related to SVG and EPS files on xobjects were fixed.\n\n6.0.005 (2013-03-26)\n\t- Default font path was fixed.\n\n6.0.004 (2013-03-21)\n\t- Return value of addTTFfont() method was fixed.\n\n6.0.003 (2013-03-20)\n\t- A bug related to non-unicode mode was fixed.\n\n6.0.002 (2013-03-18)\n\t- _getFIXED call on tcpdf_fonts.php was fixed.\n\n6.0.001 (2013-03-18)\n\t- Fixed $uni_type call on tcpdf.php.\n\n6.0.000 (2013-03-17)\n\t- IMPORTANT: PHP4 support has been removed starting from this version.\n\t- Several TCPDF methods and vars were moved to new class files: tcpdf_static.php, tcpdf_colors.php, tcpdf_images.php, tcpdf_font_data.php, tcpdf_fonts.php.\n\t- Files htmlcolors.php, spotcolors.php, unicode_data.php and ecodings_maps.php were removed.\n\t- Barcode classes were renamed and new barcode examples were added.\n\t- Class TCPDF_PARSER was improved.\n\n********************************************************************************\n\n5.9.209 (2013-03-15)\n\t- Image method was improved.\n\n5.9.208 (2013-03-15)\n\t- objclone function was patched to support old imagick extensions.\n\t- tcpdf_parser was improved to support Cross-Reference Streams and large streams.\n\n5.9.207 (2013-03-04)\n\t- Datamatrix class was fixed (a debug echo was removed).\n\n5.9.206 (2013-02-22)\n\t- Bug item #754 \"PNG with alpha channel becomes gray scale\" was fixed.\n\t- Minor documentation fixes.\n\n5.9.205 (2013-02-06)\n\t- The constant K_TCPDF_THROW_EXCEPTION_ERROR was added on configuration file to change the behavior of Error() method.\n\t- PDF417 barcode bug was fixed.\n\n5.9.204 (2013-01-23)\n\t- The method Bookmark() was extended to include named destinations, URLs, internal links or embedded files (see example n. 15).\n\t- automatic path calculation on configuration file was fixed.\n\t- Error() method was extended to throw new Exception if PHP > 5.\n\n5.9.203 (2013-01-22)\n\t- Horizontal position of radiobuttons and checkboxes was adjusted.\n\n5.9.202 (2012-12-16)\n\t- Vertical space problem after table was fixed.\n\n5.9.201 (2012-12-10)\n\t- First 256 chars are now always included on font subset to overcome a problem reported on the forum.\n\n5.9.200 (2012-12-05)\n\t- Bug item #768 \"Rowspan with Pagebreak error\" was fixed.\n\t- Page regions now works also with limited MultiCell() cells.\n\n5.9.199 (2012-11-29)\n\t- Internal setImageBuffer() method was improved.\n\n5.9.198 (2012-11-19)\n\t- Datamatrix EDIFACT mode was fixed.\n\n5.9.197 (2012-11-06)\n\t- Bug item #756 \"TCPDF 5.9.196 shows line on top of all PDFs\" was fixed.\n\n5.9.196 (2012-11-02)\n\t- Several methods were improved to avoid output when the context is out of page.\n\t- Bug item #755 \"remove cached files before unsetting\" was fixed.\n\n5.9.195 (2012-10-24)\n\t- Method _putfonts() was improved.\n\n5.9.194 (2012-10-23)\n\t- Text alignment on TextField() method was fixed.\n\n5.9.193 (2012-09-25)\n\t- Support for named destinations on HTML links was added  (i.e.: <a href=\"#destinationname\">link to named destination</a>).\n\n5.9.192 (2012-09-24)\n\t- A problem on the releasing process was fixed.\n\n5.9.191 (2012-09-24)\n\t- SVG image naow support svg and eps images.\n\n5.9.190 (2012-09-23)\n\t- \"page\" word translation is now set to empty if not defined.\n\t- Tooltip feature was added on the radiobutton annotation.\n\n5.9.189 (2012-09-18)\n\t- Bug item #3568969 \"ini_get safe_mode error\" was fixed.\n\n5.9.188 (2012-09-15)\n\t- A datamatrix barcode bug was fixed.\n\n5.9.187 (2012-09-14)\n\t- Subset feature was extended to include the first 256 characters.\n\n5.9.186 (2012-09-13)\n\t- barcodes.php file was resynced.\n\t- Methods SetAbsX, SetAbsY, SetAbsXY where added to set the absolute pointer coordinates.\n\t- Method getCharBBox were added to get single character bounding box.\n\t- Signature of addTTFfont method was changed ($addcbbox parameter was added).\n\n5.9.185 (2012-09-12)\n\t- Method _putfontwidths() was fixed.\n\n5.9.184 (2012-09-11)\n\t- A problem with EAN barcodes was fixed.\n\n5.9.183 (2012-09-07)\n\t- A problem with font names normalization was fixed.\n\n5.9.182 (2012-09-05)\n\t- Bug item #3564982 \"Infinite loop in Write() method\" was fixed.\n\n5.9.181 (2012-08-31)\n\t- composer.json file was added.\n\t- Bug item #3563369 \"Cached images are not unlinked some time\" was fixed.\n\n5.9.180 (2012-08-22)\n\t- Bug item #3560493 \"Problems with nested cells in HTML\" was fixed.\n\n5.9.179 (2012-08-04)\n\t- SVG 'use' tag was fixed for 'circle' and 'ellipse' shift problem.\n\t- Alpha status is now correctly stored and restored by getGraphicVars() and SetGraphicVars() methods.\n\n5.9.178 (2012-08-02)\n\t- SVG 'use' tag was fixed for 'circle' and 'ellipse'.\n\n5.9.177 (2012-08-02)\n\t- An additional control on annotations was fixed.\n\n5.9.176 (2012-07-25)\n\t- A bug related to stroke width was fixed.\n\t- A problem related to font spacing in HTML was fixed.\n\n5.9.175 (2012-07-25)\n\t- The problem of missing letter on hyphen break was fixed.\n\n5.9.174 (2012-07-25)\n\t- The problem of wrong filename when downloading PDF from an Android device was fixed.\n\t- The method setHeaderData() was extended to set text and line color for header (see example n. 1).\n\t- The method setFooterData() was added to set text and line color for footer (see example n. 1).\n\t- The methods setTextShadow() and getTextShadow() were added to set text shadows (see example n. 1).\n\t- The GetCharWidth() method was fixed for negative character spacing.\n\t- A 'none' border mode is now correctly recognized.\n\t- Break on hyphen problem was fixed.\n\n5.9.173 (2012-07-23)\n\t- Some additional control wher added on barcode methods.\n\t- The option CURLOPT_FOLLOWLOCATION on Image method is now disabled if PHP safe_mode is on or open_basedir is set.\n\t- Method Bookmark() was extended to include X parameter.\n\t- Method setDestination() was extended to include X parameter.\n\t- A problem with Thai language was fixed.\n\n5.9.172 (2012-07-02)\n\t- A PNG color profile issue was fixed.\n\n5.9.171 (2012-07-01)\n\t- Some SVG rendering problems were fixed.\n\n5.9.170 (2012-06-27)\n\t- Bug #3538227 \"Numerous errors inserting shared images\" was fixed.\n\n5.9.169 (2012-06-25)\n\t- Some SVG rendering problems were fixed.\n\n5.9.168 (2012-06-22)\n\t- Thai language rendering was fixed.\n\n5.9.167 (2012-06-22)\n\t- Thai language rendering was fixed and improved.\n\t- Method isCharDefined() was improved.\n\t- Protected method replaceChar() was added.\n\t- Font \"kerning\" word was corrected to \"tracking\".\n\n5.9.166 (2012-06-21)\n\t- Array to string conversion on file_id creation was fixed.\n\t- Thai language rendering was fixed (thanks to Atsawin Chaowanakritsanakul).\n\n5.9.165 (2012-06-07)\n\t- Some HTML form related bugs were fixed.\n\n5.9.164 (2012-06-06)\n\t- A bug introduced on the latest release was fixed.\n\n5.9.163 (2012-06-05)\n\t- Method getGDgamma() was changed.\n\t- Rendering performances of PNG images with alpha channel were improved.\n\n5.9.162 (2012-05-11)\n\t- A bug related to long text on TD cells was fixed.\n\n5.9.161 (2012-05-09)\n\t- A bug on XREF table was fixed (Bug ID: 3525051).\n\t- Deprecated Imagick:clone was replaced.\n\t- Method objclone() was fixed for PHP4.\n\n5.9.160 (2012-05-03)\n\t- A bug on tcpdf_parser.php was fixed.\n\n5.9.159 (2012-04-30)\n\t- Barcode classes were updated to fix PNG export Bug (ID: 3522291).\n\n5.9.158 (2012-04-22)\n\t- Some SVG-related bugs were fixed.\n\n5.9.157 (2012-04-16)\n\t- Some SVG-related bugs were fixed.\n\n5.9.156 (2012-04-10)\n\t- Bug item #3515885 \"TOC and booklet: left and right page exchanged\".\n\t- SetAutoPageBreak(false) now works also in multicolumn mode.\n\n5.9.155 (2012-04-02)\n\t- Bug item #3512596 \"font import problems\" was fixed.\n\t- Method addTTFfont() was modified to extract only specified Platform ID and Encoding ID (check the source code documentation).\n\t- All fonts were updated.\n\t- Bug item #3513867 \"booklet and setHeaderTemplateAutoreset: header shifted left\" was fixed.\n\t- Bug item #3513749 \"TCPDF Superscript/Subscript\" was fixed.\n\n5.9.154 (2012-03-29)\n\t- A debug echo was removed.\n\n5.9.153 (2012-03-28)\n\t- A bug on font conversion was fixed.\n\t- All fonts were updated.\n\t- Method isCharDefined() was added to find if a character is defined on the selected font.\n\t- Method replaceMissingChars() was added to automatically replace missing chars on selected font.\n\t- SetFont() method was fixed.\n\n5.9.152 (2012-03-23)\n\t- The following overprint methods were added: setOverprint(), getOverprint().\n\t- Signature of setAlpha() method was changed and method getAlpha() was added.\n\t- stroke-opacity support was added on SVG.\n\t- The following date methods were added: setDocCreationTimestamp(), setDocModificationTimestamp(), getDocCreationTimestamp(), getDocModificationTimestamp(), getFormattedDate(), getTimestamp().\n\t- Signature of _datestring() method was changed.\n\t- Method getFontBBox() was added.\n\t- Method setPageBoxTypes() was aded.\n\n5.9.151 (2012-03-22)\n\t- Bug item #3509889 \"Transform() distorts PDF\" was fixed.\n\t- Precision of real number were extended.\n\t- ComboBox and ListBox methods were fixed.\n\t- Bulgarian language file was added.\n\t- addTOC() method was improved to include bookmark color and font style.\n\n5.9.150 (2012-03-16)\n\t- A bug related to form fields in PDF/A mode was fixed.\n\n5.9.149 (2012-02-21)\n\t- Bug item #3489933 \"SVG Parser treats tspan like text\" was fixed.\n\n5.9.148 (2012-02-17)\n\t- Bug item #3488600 \"Multiple radiobutton sets get first set value\" was fixed.\n\n5.9.147 (2012-02-14)\n\t- A problem with SVG gradients has been fixed.\n\n5.9.146 (2012-02-12)\n\t- Bug item #3486880 \"$filehash undefine error\" was fixed.\n\t- The default font is now the one specified at PDF_FONT_NAME_MAIN constant.\n\n5.9.145 (2012-01-28)\n\t- Japanese language file was added.\n\t- TCPDF license and README.TXT files were updated.\n\n5.9.144 (2012-01-12)\n\t- HTML output on barcode classes was improved.\n\n5.9.143 (2012-01-08)\n\t- Bug item #3471057 \"setCreator() has no effect\" was fixed.\n\n5.9.142 (2011-12-23)\n\t- Source code documentation was updated.\n\n5.9.141 (2011-12-14)\n\t- Some minor bugs were fixed.\n\n5.9.140 (2011-12-13)\n\t- SVG now supports embedded images encoded as base64.\n\n5.9.139 (2011-12-11)\n\t- Spot color methods were fixed.\n\n5.9.138 (2011-12-10)\n\t- cropMark() method was improved (check source code documentation).\n\t- Example n. 56 was updated.\n\t- Bug item #3452390 \"Check Box still not ticked when set to true\" was fixed.\n\n5.9.137 (2011-12-01)\n\t- Bug item #3447005 \"Background color and border of Form Elements is printed\" was fixed.\n\t- Color support for Form elements was improved.\n\n5.9.136 (2011-11-27)\n\t- Bug item #3443387 \"SetMargins with keep option does not work for top margin\" was fixed.\n\n5.9.135 (2011-11-04)\n\t- Bug item #3433406 \"Double keywords in description\" was fixed.\n\n5.9.134 (2011-10-29)\n\t- The default value for $defcol parameter on convertHTMLColorToDec() method was fixed.\n\t- Deafult HTTP headers were changed to avoid browser caching.\n\t- Some deprecated syntax were replaced.\n\n5.9.133 (2011-10-26)\n\t- Bug item #3428446 \"copyPage method not working when diskcache enabled\" was fixed.\n\n5.9.132 (2011-10-20)\n\t- Bug item #3426167 \"bug in function convertHTMLColorToDec()\" was fixed.\n\n5.9.131 (2011-10-13)\n\t- An error message was added to ImagePngAlpha() method.\n\n5.9.130 (2011-10-12)\n\t- Now you can set image data strings on HTML img tag by encoding the image binary data in this way: $imgsrc = '@'.base64_encode($imgdata);\n\n5.9.129 (2011-10-07)\n\t- Core fonts metrics was fixed (replace all helvetica and times php files on fonts folder).\n\t- Form fields support was improved and some problems were fixed (check the example n. 14).\n\t- Bug item #3420249 \"Issue with booklet and MultiCell\" was fixed.\n\n5.9.128 (2011-10-06)\n\t- Method addTTFfont() was improved (check the source code documentation).\n\t- Method setExtraXMP() to set custom XMP data was added.\n\n5.9.127 (2011-10-04)\n\t- Readonly mode option was activated for radiobuttons.\n\n5.9.126 (2011-10-03)\n\t- Bug item #3417989 \"Graphics State operator in form XObject fails to render\" was fixed.\n\t- Xobjects problems with transparency, gradients and spot colors were fixed.\n\n5.9.125 (2011-10-03)\n\t- Support for 8-digit CMYK hexadecimal color representation was added (to be used with XHTML and SVG).\n\t- Spot colors support was improved (check example n. 37).\n\t- Color methods were improved.\n\n5.9.124 (2011-10-02)\n\t- Core fonts were updated.\n\n5.9.123 (2011-10-02)\n\t- The method addTTFfont() wad added to automatically convert TTF fonts (check the new fonts guide at http://www.tcpdf.org).\n\t- Old font utils were removed.\n\t- All fonts were updated and new arabic fonts were added (almohanad were removed and replaced by aefurat and aealarabiya).\n\t- The file unicode_data.php was updated.\n\t- The file encodings_maps.php was added.\n\t- PDF/A files are now compressed to save space.\n\t- XHTML input form fields now support text-alignment attribute.\n\n5.9.122 (2011-09-29)\n\t- PDF/A-1b compliance was improved to pass some online testing.\n\n5.9.121 (2011-09-28)\n\t- This version includes support for PDF/A-1b format (the class constructor signature was changed - see example n. 65).\n\t- Method setSRGBmode() was added to force sRGB_IEC61966-2.1 black scaled ICC color profile for the whole document (file sRGB.icc was added).\n\t- 14 new fonts were added to allow embedding core fonts (for PDF/A compliance).\n\t- Font utils were fixed.\n\n5.9.120 (2011-09-22)\n\t- This version includes a fix for _getTrueTypeFontSubset() method.\n\n5.9.119 (2011-09-19)\n\t- This version includes a fix for extra page numbering on TOC.\n\n5.9.118 (2011-09-17)\n\t- This version includes some changes that allows you to add a bookmark for a page that do not exist.\n\n5.9.117 (2011-09-15)\n\t- TCPDFBarcode and TCPDF2DBarcode classes were extended to include a method for exporting barcodes as PNG images.\n\n5.9.116 (2011-09-14)\n\t- Datamatrix class was improved and documentation was fixed.\n\n5.9.115 (2011-09-13)\n\t- Datamatrix ECC200 barcode support was added (a new datamatrix.php file was added) - check example n. 50.\n\t- getBarcodeHTML() method was added on TCPDFBarcode and TCPDF2DBarcode classes to return an HTML representation of the barcode.\n\t- cURL options on Image() method were improved.\n\t- A bug on write2DBarcode() was fixed.\n\n5.9.114 (2011-09-04)\n\t- A bug related to column position was fixed.\n\n5.9.113 (2011-08-24)\n\t- This release include two new experimental files for parsing an existing PDF document (the integration with TCPDF is under development).\n\n5.9.112 (2011-08-18)\n\t- A newline character was added after the 'trailer' keyword for compatibility with some parsers.\n\t- Support for layers was improved.\n\n5.9.111 (2011-08-17)\n\t- Barcode CODE 39 default gap was restored at 1.\n\n5.9.110 (2011-08-17)\n\t- Barcode CODE 39 was fixed.\n\n5.9.109 (2011-08-12)\n\t- Method getNumLines() was fixed.\n\t- A bug related to page break in multi-column mode was fixed.\n\n5.9.108 (2011-08-09)\n\t- A bug on PHP4 version was fixed.\n\n5.9.107 (2011-08-08)\n\t- This version includes a minor bugfix.\n\n5.9.106 (2011-08-04)\n\t- This version includes transparency groups: check the new parameter on startTemplate() method and example 62.\n\n5.9.105 (2011-08-04)\n\t- Bug item #3386153 \"Check Box not ticked when set to true\" was fixed.\n\n5.9.104 (2011-08-01)\n\t- Bug item #3383698 \"imagemagick, resize and dpi\" was fixed.\n\n5.9.103 (2011-07-16)\n\t- Alignment of XHTML lines was improved.\n\t- Spell of the \"length\" word was fixed.\n\n5.9.102 (2011-07-13)\n\t- Methods startLayer() and endLayer() were added to support arbitrary PDF layers.\n\t- Some improvements/fixes for images were added (thanks to Brendan Abbott).\n\n5.9.101 (2011-07-07)\n\t- Support for JPEG and PNG ICC Color Profiles was added.\n\t- Method addEmptySignatureAppearance() was added to add empty signature fields (see example n. 52).\n\t- Bug item #3354332 \"Strange line spacing with reduced font-size in writeHTML\" was fixed.\n\n5.9.100 (2011-06-29)\n\t- An SVG bug has been fixed.\n\n5.9.099 (2011-06-27)\n\t- Bug item #3335045 \"Font freesans seems somehow corrupted in footer\" was fixed.\n\n5.9.098 (2011-06-23)\n\t- The Named Destination feature was fixed.\n\n5.9.097 (2011-06-23)\n\t- The method setHtmlVSpace() now can be used also for tags: div, li, br, dt and dd.\n\t- The Named Destination feature was added (check the example n. 15) - thanks to Christian Deligant.\n\n5.9.096 (2011-06-19)\n\t- Bug item #3322234 \"Surrogate pairs codes in arrUTF8ToUTF16BE\" was fixed.\n\n5.9.095 (2011-06-18)\n\t- Numbers alignment for Table-Of-Content methods was improved and fixed.\n\t- Font subsetting was fixed to include all parts of composite fonts.\n\n5.9.094 (2011-06-17)\n\t- Bug item #3317898 \"Page Group numbering broken in 5.9.093\" was fixed.\n\n5.9.093 (2011-06-16)\n\t- Method setStartingPageNumber() was added to set starting page number (for automatic page numbering).\n\n5.9.092 (2011-06-15)\n\t- Method _putpages() was improved.\n\t- Bug item #3316678 \"Memory overflow when use Rotate and SetAutoPageBreak\" was fixed.\n\t- Right alignment of page numbers was improved.\n\n5.9.090 (2011-06-14)\n\t- Methods AliasNbPages() and AliasNumPage() were re-added as deprecated for backward compatibility.\n\n5.9.089 (2011-06-13)\n\t- Example n. 8 was updated.\n\t- Method sendOutputData() was changed to remove default compression (it was incompatible with some server settings).\n\t- Bugs related to page group numbers were fixed.\n\t- Method copyPage() was fixed.\n\t- Method Image() was improved to include support for alternative and external images.\n\n5.9.088 (2011-06-01)\n\t- Method getAutoPageBreak() was added (see example n. 51).\n\t- Example n. 51 (full page background) was updated.\n\n5.9.087 (2011-06-01)\n\t- Method sendOutputData() was improved to include deflate encoding.\n\t- Barcode classes on PHP 4 version were fixed.\n\n5.9.086 (2011-05-31)\n\t- Font files were updated (the ones on the previous release were broken).\n\t- The script fonts/utils/makeallttffonts.php was updated and fixed.\n\t- Output() method was improved to use compression when available.\n\n5.9.085 (2011-05-31)\n\t- TCPDFBarcode class (barcodes.php) now includes getBarcodeSVG() and getBarcodeSVGcode() methods to get SVG image representation of the barcode.\n\t- TCPDF2DBarcode class (2dbarcodes.php) now includes getBarcodeSVG() and getBarcodeSVGcode() methods to get SVG image representation of the barcode.\n\n5.9.084 (2011-05-29)\n\t- Font files were updated.\n\t- The file fonts/utils/makeallttffonts.php was updated.\n\t- Bug item# 3308774 \"Problems with font subsetting\" was fixed.\n\n5.9.083 (2011-05-24)\n\t- Bug item #3308387 \"line height & SetCellHeightRatio\" was fixed.\n\n5.9.082 (2011-05-22)\n\t- Bug item #3305592 \"Setting fill color <> text color breaks text clipping\" was fixed.\n\n5.9.081 (2011-05-18)\n\t- Method resetHeaderTemplate() was added to reset the xobject template used by Header() method.\n\t- Method setHeaderTemplateAutoreset() was added to automatically reset the xobject template used by Header() method at each page.\n\n5.9.080 (2011-05-17)\n\t- A problem related to file path calculation for images was fixed.\n\t- A problem related to unsuppressed getimagesize() error was fixed.\n\n5.9.079 (2011-05-16)\n\t- Footer() method was changed to use C128 barcode as default (instead of the previous C128B).\n\n5.9.078 (2011-05-12)\n\t- Bug item #3300878 \"wrong rendering for html bullet list in some case\" was fixed.\n\t- Bug item #3301017 \"Emphasized vs. font-weight\" was fixed.\n\t- Barcode Code 128 was improved to include AUTO mode (automatically switch between A, B and C modes).\n\t- Examples n. 27 and 49 were updated.\n\n5.9.077 (2011-05-07)\n\t- Bug item #3298591 \"error code93\" was fixed.\n\t- SetLineStyle() function was improved.\n\n5.9.076 (2011-05-06)\n\t- Bug item #3298264 \"codebar 93 error\" was fixed.\n\n5.9.075 (2011-05-02)\n\t- Table header alignment when using WriteHTMLCell() or MultiCell() was fixed.\n\n5.9.074 (2011-04-28)\n\t- Bug item #3294306 \"CSS classes not work in <thead> table section\" was fixed.\n\n5.9.073 (2011-04-27)\n\t- A bug related to character entities on HTML cells was fixed.\n\n5.9.072 (2011-04-26)\n\t- Method resetColumns() was added to remove multiple columns and reset page margins (example n. 10 was updated).\n\n5.9.071 (2011-04-19)\n\t- Bug #3288574 \"<br/> trouble\" was fixed.\n\n5.9.069 (2011-04-19)\n\t- Bug #3288763 \"HTML-Table: non-breaking table rows: Bug\" was fixed.\n\n5.9.068 (2011-04-15)\n\t- Bookmark, addTOC and addHTMLTOC methods were improved to include font style and color (Examples 15, 49 and 59 were updated).\n\t- Default $_SERVER['DOCUMENT_ROOT'] value on tcpdf_config.php file was changed.\n\n5.9.067 (2011-04-10)\n\t- Performances were drastically improved (PDF documents are now created more quickly).\n\n5.9.066 (2011-04-09)\n\t- A bug related to digital signature + encryption was fixed.\n\t- A bug related to encryption + xobject templates was fixed.\n\n5.9.065 (2011-04-08)\n\t- Bug item #3280512 \"Text encoding iso-8859-2 crashes\" was fixed.\n\n5.9.064 (2011-04-05)\n\t- A bug related to character entities on HTML cells was fixed.\n\n5.9.063 (2011-04-01)\n\t- Bug item #3267235 \"WriteHTML() and image that doesn't fit on the page\" was fixed.\n\n5.9.062 (2011-03-23)\n\t- Bug item #3232650 \"Using Write if there are pageRegions active creates error\" was fixed.\n\t- Bug item #3221891 \"text input borders\" was fixed.\n\t- Bug item #3228958 \"Adobe Reader 9.4.2 crash\" was fixed.\n\n5.9.061 (2011-03-15)\n\t- Bug item #3213488 \"wrong function call in function Write\" was fixed.\n\t- Bug item #3203007 \"list element with black background\" was fixed.\n\n5.9.060 (2011-03-08)\n\t- addTOC() method was fixed for text alignment problems.\n\n5.9.059 (2011-02-27)\n\t- Default Header() method was improved to reduce document size.\n\n5.9.058 (2011-02-25)\n\t- Image() method was improved to cache images with transparency layers (thanks to Korneliusz Jarzębski for reporting this problem).\n\n5.9.057 (2011-02-24)\n\t- A problem with image caching system was fixed (thanks to Korneliusz Jarzębski for reporting this problem).\n\n5.9.056 (2011-02-22)\n\t- A bug on fixHTMLCode() method was fixed.\n\t- Automatic line break for HTML was fixed.\n\n5.9.055 (2011-02-17)\n\t- Another bug related to HTML table page break was fixed.\n\n5.9.054 (2011-02-16)\n\t- A bug related to HTML table page break was fixed.\n\n5.9.053 (2011-02-16)\n\t- Support for HTML attribute display=\"none\" was added.\n\n5.9.052 (2011-02-15)\n\t- A bug related to HTML automatic newlines was fixed.\n\n5.9.051 (2011-02-12)\n\t- \"Commas at beginning of new lines\" problem was fixed.\n\n5.9.050 (2011-02-11)\n\t- Bug #3177606 \"SVG Bar chart error\" was fixed.\n\n5.9.049 (2011-02-03)\n\t- Bug #3170777 \"TCPDF creates a new page after a single line in writeHTML\" was fixed.\n\n5.9.048 (2011-02-02)\n\t- No changes. Just released to override previous release that was not uploaded correctly.\n\n5.9.047 (2011-01-28)\n\t- Bug #3167115 \"PDF error in <table> (example 48)\" was fixed (was introduced in 5.8.046).\n\n5.9.046 (2011-01-18)\n\t- PDF view/print layers are now automatically turned off if not used (see setVisibility() method).\n\n5.9.045 (2011-01-17)\n\t- HTML list support were improved.\n\n5.9.044 (2011-01-15)\n\t- Bug #3158422 \"writeHTMLCell Loop\" was fixed.\n\t- Some HTML image alignment problems were fixed.\n\n5.9.043 (2011-01-14)\n\t- Bug #3158178 \"PHP Notice\" was fixed.\n\t- Bug #3158193 \"Endless loop in writeHTML\" was fixed.\n\t- Bug #3157764 \"SVG Pie chart incorrectly rendered2\".\n\n5.9.042 (2011-01-14)\n\t- Some problems of the PHP4 version were fixed.\n\n5.9.041 (2011-01-13)\n\t- A problem with SVG elliptical arc path was fixed (ref. bug #3156574).\n\t- A problem related to font weight on HTML table headers was fixed.\n\n5.9.040 (2011-01-12)\n\t- A bug related to empty pages after table was fixed.\n\n5.9.039 (2011-01-12)\n\t- Bug item #3155759 \"openssl_random_pseudo_bytes() slow under Windows\" was fixed.\n\n5.9.038 (2011-01-11)\n\t- Minor bugs were fixed.\n\n5.9.037 (2011-01-09)\n\t- An alignment problem for HTML texts was fixed.\n\n5.9.036 (2011-01-07)\n\t- A bug related to HTML tables on header was fixed.\n\n5.9.035 (2011-01-03)\n\t- A problem related to HTML table border alignment was fixed.\n\t- Bug #2996366 \"FastCGI and Header Problems\" was fixed.\n\n5.9.034 (2010-12-19)\n\t- DejaVu and GNU Free fonts were updated.\n\n5.9.033 (2010-12-18)\n\t- Source code documetnation was improved.\n\n5.9.032 (2010-12-18)\n\t- Default font stretching and spacing values are now inherited by HTML methods.\n\n5.9.031 (2010-12-16)\n\t- Source code documentation errors were fixed.\n\n5.9.030 (2010-12-16)\n\t- Several source code documentation errors were fixed.\n\t- Source code style was changed for Doxygen.\n\t- Source code documentation was moved online to http://www.tcpdf.org\n\n5.9.029 (2010-12-04)\n\t- The $fitbox parameter on Image() method was extended to specify image alignment inside the box (check the example n. 9).\n\n5.9.028 (2010-12-03)\n\t- Font utils makefont.php and makeallttffonts.php were updated.\n\n5.9.027 (2010-12-01)\n\t- Spot Colors are now better integrated with HTML mode.\n\t- Method SetDocInfoUnicode() was added to turn on/off Unicode mode for document information dictionary (meta tags) - check the example n. 19.\n\n5.9.026 (2010-12-01)\n\t- A problem with mixed text directions on HTML was fixed.\n\n5.9.025 (2010-12-01)\n\t- The AddSpotColor() now automatically fills the spotcolor array (defined on spotcolors.php file).\n\n5.9.024 (2010-11-30)\n\t- Bug item #3123612 \"SVG not use gradientTransform in percentage mode\" was fixed.\n\n5.9.023 (2010-11-25)\n\t- A potential bug on SVG transcoder was fixed.\n\n5.9.022 (2010-11-21)\n\t- Method ImageEPS includes support for EPS/AI Spot colors.\n\t- Method ImageEPS includes a new parameter $fixoutvals to remove values outside the bounding box.\n\n5.9.021 (2010-11-20)\n\t- Support for custom bullet points images was added (check the example n.6)\n\t- Examples n. 6 and 61 were update (check the comments inside).\n\n5.9.020 (2010-11-19)\n\t- A problem related to additional page when using multicolumn mode was fixed.\n\n5.9.019 (2010-11-19)\n\t- An SVG bug was fixed.\n\t- ImageSVG() and ImageEPS() methods now accepts image data streams (put the string on the $file parameter preceded by '@' character).\n\t- Option 'E' was added to the $dest parameter of Output() method to return the document as base64 mime multi-part email attachment (RFC 2045).\n\n5.9.018 (2010-11-19)\n\t- An SVG bug was fixed.\n\n5.9.017 (2010-11-16)\n\t- Tagline color was set to transparent.\n\t- The method fixHTMLCode() was added to automatically clean up HTML code (requires HTML Tidy).\n\n5.9.016 (2010-11-16)\n\t- Bug item #3109705 \"list item page break hanging bullet\" was fixed.\n\n5.9.015 (2010-11-16)\n\t- Bug item affecting QRCode was fixed.\n\t- Some bugs affecting HTML lists were fixed.\n\t- ImageSVG() and fitBlock() methods were improved to handle some SVG problems.\n\t- Some problems with PHP4 compatibility were fixed.\n\n5.9.014 (2010-11-15)\n\t- Bug item #3109464 \"QRCode error\" was fixed.\n\n5.9.013 (2010-11-15)\n\t- Bug item #3109257 \"Problem with interlaced GIFs and PNGs\" was fixed.\n\t- Image function now accepts image data streams (check example n. 9).\n\n5.9.012 (2010-11-12)\n\t- Method getTCPDFVersion() was added.\n\t- PDF_PRODUCER constant was removed.\n\t- Method convertHTMLColorToDec() was improved.\n\t- HTML colors now support spot color names defined on the new spotcolors.php file.\n\t- The default method Header() was improved to support SVG and EPS/AI images.\n\t- A bug on SVG importer was fixed.\n\n5.9.011 (2010-11-02)\n\t- Bug item #3101486 \"Bug Fix for image loading\" was fixed.\n\n5.9.010 (2010-10-27)\n\t- Support for CSS properties 'border-spacing' and 'padding' for tables were added.\n\t- Several language files were added.\n\n5.9.009 (2010-10-21)\n\t- HTML text alignment was improved to include the case of RTL text on LTR direction and LTR text on RTL direction.\n\n5.9.008 (2010-10-21)\n\t- Bug item #3091502 \"Bookmark oddity\" was fixed.\n\t- HTML internal links now accepts page number and Y position.\n\t- The method write1DBarcode() was improved to accept separate horizontal and vertical padding (see example n. 27).\n\n5.9.007 (2010-10-20)\n\t- Method adjustCellPadding() was fixed to handle bad input.\n\n5.9.006 (2010-10-19)\n\t- Support for AES 256 bit encryption was added (see example n. 16).\n\t- Method getNumLines() was fixed for the empty string case.\n\n5.9.005 (2010-10-18)\n\t- Method addPageRegion() was changed to accept regions starting exactly from the top of the page.\n\n5.9.004 (2010-10-18)\n\t- A bug related to annotations was fixed.\n\t- The file unicode_data.php was canged to encapsulate all data in a class.\n\t- The file htmlcolors.php was changed to remove the global variable.\n\n5.9.003 (2010-10-15)\n\t- Support for no-write page regions was added. Check the example n. 64 and new methods setPageRegions(), addPageRegion(), getPageRegions(), removePageRegion().\n\t- A bug on Right-To-Left alignment was fixed.\n\n5.9.002 (2010-10-08)\n\t- Cell method was improved to preserve the font stretching and spacing values when using the $stretch parameter (see example n. 4).\n\n5.9.001 (2010-10-07)\n\t- The problem of blank page for nobr table higher than a single page was fixed.\n\n5.9.000 (2010-10-06)\n\t- Support for text stretching and spacing (tracking) was added, see example n. 63 and methods setFontStretching(), getFontStretching(), setFontSpacing(), getFontSpacing().\n\t- Support for CSS properties 'font-stretch' and 'letter-spacing' was added (see example n. 63).\n\t- The cMargin state was replaced by cell_padding array that can be set/get using setCellPadding() and getCellPadding() methods.\n\t- Methods getCellPaddings() and setCellPaddings() were added to fine tune cell paddings (see example n. 5).\n\t- Methods getCellMargins() and setCellMargins() were added to fine tune cell margins (see example n. 5).\n\t- Method write1DBarcode() was improved to permit custom labels (see example n. 27).\n\t- Method ImagePngAlpha() now includes support for ImageMagick to improve performances.\n\t- XObject Template support was extended to support Multicell(), writeHTML() and writeHTMLCell() methods.\n\t- The signature of getNumLines() and getStringHeight() methods is changed.\n\t- Example n. 57 was updated.\n\n// -------------------------------------------------------------------\n\n5.8.034 (2010-09-27)\n\t- A bug related to SetFont on XObject templates was fixed.\n\n5.8.033 (2010-09-25)\n\t- A problem with Footer() and multiple columns was fixed.\n\n5.8.032 (2010-09-22)\n\t- Bug #3073165 \"Issues with changes to addHTMLVertSpace()\" was fixed.\n\n5.8.031 (2010-09-20)\n\t- Bug #3071961 \"Spaces in HTML\" was fixed.\n\n5.8.030 (2010-09-17)\n\t- SVG support was improved and some bugs were fixed.\n\n5.8.029 (2010-09-16)\n\t- A problem with HTML borders was fixed.\n\n5.8.028 (2010-09-13)\n\t- Bug #3065224 \"mcrypt_create_iv error on TCPDF 5.8.027 on PHP 5.3.2\" was fixed.\n\n5.8.027 (2010-09-13)\n\t- Bug #3065118 \"mcrypt_decrypt error on TCPDF 5.8.026 on PHP 5.3.2\" was fixed.\n\n5.8.026 (2010-09-13)\n\t- A bug on addHTMLTOC() method was fixed. Note: be sure that the #TOC_PAGE_NUMBER# template has enough width to be printed correctly.\n\n5.8.025 (2010-09-09)\n\t- Bug #3062692 \"Textarea inside a table\" was fixed.\n\n5.8.024 (2010-09-08)\n\t- Bug #3062005 \"Undefined variable: ann_obj_id\" was fixed.\n\n5.8.023 (2010-08-31)\n\t- Forms bug added on version 5.8.019 was fixed.\n\n5.8.022 (2010-08-31)\n\t- Bug #3056632 \"SVG rendered vertically flipped\" was fixed.\n\n5.8.021 (2010-08-30)\n\t- A new CID-0 'chinese' font was added for traditional Chinese.\n\t- Bug #3054287 'Inner tags are ignored due to \"align\" attribute' was fixed.\n\n5.8.020 (2010-08-26)\n\t- CSS \"catch-all\" class selector is now supported.\n\n5.8.019 (2010-08-26)\n\t- XObject Templates now includes support for links and annotations.\n\t- A problem related to link alignment on cell was fixed.\n\t- A problem related to SVG styles was fixed.\n\n5.8.018 (2010-08-25)\n\t- Method getNumberOfColumns() was added.\n\t- A problem related to table header was fixed.\n\t- Method getSVGTransformMatrix() was fixed to apply SVG transformations in the correct order.\n\t- SVG support was improved and several bugs were fixed.\n\n5.8.017 (2010-08-25)\n\t- This version includes support for XObject Templates (see the new example n. 62).\n\t- Methods starttemplate(), endTemplate() and printTemplate() were added (see the new example n. 62).\n\n5.8.016 (2010-08-24)\n\t- Alignment problem on write2DBarcode was fixed.\n\n5.8.015 (2010-08-24)\n\t- A problem arose with the latest bugfix was fixed.\n\n5.8.014 (2010-08-23)\n\t- Method _getxobjectdict() was added for better compatibility with external extensions.\n\t- A bug related to radiobuttons was fixed.\n\t- Bug #3051509 \"new line after punctuation marks\" was fixed (partially).\n\n5.8.013 (2010-08-23)\n\t- SVG support for 'direction' property was added.\n\t- A problem on default width calculation for linear barcodes was fixed.\n\t- New option was added to write1DBarcode() method to improve alignments (see example n. 27).\n\t- Bug #3050896 \"Nested HTML tables: styles are not applied\" was fixed.\n\t- Method _putresourcedict() was improved to include external XObject templates.\n\n5.8.012 (2010-08-22)\n\t- Support for SVG 'text-anchor' property was added.\n\n5.8.011 (2010-08-21)\n\t- Method write1DBarcode() was improved to be backward compatible (check the new example n. 27).\n\t- Support for CSS width and height properties on images were added.\n\n5.8.010 (2010-08-20)\n\t- Documentation of unhtmlentities() was fixed.\n\t- The 'fitwidth' option was added and border color problem was fixed on write1DBarcode() method (check the example n. 27).\n\n5.8.009 (2010-08-20)\n\t- Internal object numbering was improved.\n\t- Some errors in object encryption were fixed.\n\n5.8.008 (2010-08-19)\n\t- Method write1DBarcode() was changed, check the example n. 27.\n\t- Method Footer() was changed to account for barcode changes.\n\t- Automatic calculation of K_PATH_URL constant was fixed on configuration file.\n\t- Method setEqualColumns() was fixed for $width=0 case.\n\t- Method AddTOC() was fixed for multipage and multicolumn modes.\n\t- Better support for SVG \"font-family\" property.\n\t- A problem on default Page Zoom mode was fixed.\n\t- Several Annotation bugs were fixed.\n\n5.8.007 (2010-08-18)\n\t- A bug affecting HTML tables was fixed.\n\t- Bug #3047500 \"SVG not rendering paths properly\" was fixed.\n\n5.8.006 (2010-08-17)\n\t- A bug affecting HTML table nesting was fixed.\n\n5.8.005 (2010-08-17)\n\t- A bug affecting the HTML 'select' tag in certain conditions was fixed.\n\n5.8.004 (2010-08-17)\n\t- Better support for HTML \"font-family\" property.\n\t- A bug related to HTML multicolumn was fixed.\n\n5.8.003 (2010-08-16)\n\t- Better support for HTML \"font-family\" property.\n\n5.8.002 (2010-08-14)\n\t- HTML alignments were improved\n\t- IMPORTANT: Default regular expression to find spaces has been changed to exclude the non-breaking-space (160 DEC- A0 HEX). If you are using setSpacesRE() method, please read the new documentation.\n\t- Example n. 1 was updated.\n\n5.8.001 (2010-08-12)\n\t- Bug #3043650 \"subsetchars incorrectly cached\" was fixed.\n\n5.8.000 (2010-08-11)\n\t- A control to avoid bookmarking page 0 was added.\n\t- addTOC() method now includes support for multicolumn mode.\n\t- Support for tables in multicolumn mode was improved.\n\t- Example n.10 was updated.\n\t- All trimming functions were replaced with stringLeftTrim(), stringRightTrim() and stringTrim().\n\t- HTML alignments were improved.\n\n------------------------------------------------------------\n\n5.7.003 (2010-08-08)\n\t- Bug #3041263 \"php source ending is bad\" was fixed (all PHP files were updated, including fonts).\n\n5.7.002 (2010-08-06)\n\t- Methods copyPage(), movePage() and deletePage() were changed to account for internal markings.\n\n5.7.001 (2010-08-05)\n\t- Bug #3040105 \"Broken PDF when using TOC (example 45)\" was fixed.\n\n5.7.000 (2010-08-03)\n\t- CSS borders are now supported for HTML tables and other block tags (see example n. 61);\n\t- Cell borders were improved (see example n. 57);\n\t- Minor bugs were fixed.\n\n------------------------------------------------------------\n\n5.6.000 (2010-07-31)\n\t- A bug with object IDs was fixes.\n\t- Performances were improved.\n\n------------------------------------------------------------\n\n5.5.015 (2010-07-29)\n\t- Automatic fix for unclosed self-closing tag.\n\t- Support for deprecated 's' and 'strike' tags was added.\n\t- Empty list items problem was fixed.\n\n5.5.014 (2010-07-15)\n\t- Support for external images was improved.\n\n5.5.013 (2010-07-14)\n\t- Bug #3029338 \"FI and FO output destination filename bug\" was fixed (previous fix was wrong).\n\n5.5.012 (2010-07-14)\n\t- Bug #3029310 \"Font baseline inconsistencies with line-height and font-size\" was fixed.\n\t- Bug #3029338 \"FI and FO output destination filename bug\" was fixed.\n\n5.5.011 (2010-07-09)\n\t- Support for multiple CSS classes was added.\n\t- The method getColumn() was added to return the current column number.\n\t- Some regular Expressions were fixed to be more compatible with UTF-8.\n\n5.5.010 (2010-07-06)\n\t- Bug item #3025772 \"Borders in all image functions are still flawed\" was fixed.\n\n5.5.009 (2010-07-05)\n\t- A problem related to last page footer was fixed.\n\t- Image alignments and fit-on-page features were improved.\n\n5.5.008 (2010-07-02)\n\t- A problem on table header alignment in booklet mode was fixed.\n\t- Default graphic vars are now applied for setHeader();\n\n5.5.007 (2010-07-02)\n\t- Attribute \"readonly\" was added to input and textarea form fields.\n\t- Vertical alignment feature was added on MultiCell() method only for simple text mode (see example n. 5).\n\t- Text-Fit feature was added on MultiCell() method only for simple text mode (see example n. 5).\n\n5.5.006 (2010-06-29)\n\t- getStringHeight() and getNumLines() methods were fixed.\n\n5.5.005 (2010-06-28)\n\t- Bug #3022170 \"getFontDescent() does not return correct descent value\" was fixed.\n\t- Some problems with multicolumn mode were fixed.\n\n5.5.004 (2010-06-27)\n\t- Bug #3021803 \"SVG Border\" was fixed.\n\n5.5.003 (2010-06-26)\n\t- On Write() method, blank lines at the beginning of a page or column are now automatically removed.\n\n5.5.002 (2010-06-24)\n\t- ToUnicode Identity-H name was replaced with a full CMap (to avoid preflight syntax error).\n\t- Bug #3020638 \"str_split() not available in php4\" was fixed.\n\t- Bug #3020665 \"file_get_contents() too many parameters for php4\" was fixed.\n\n5.5.001 (2010-06-23)\n\t- A problem on image streams was fixed.\n\n5.5.000 (2010-06-22)\n\t- Several PDF syntax errors (and related bugs) were fixed.\n\t- Bug #3019090 \"/Length values are wrong if AES encryption is used\" was fixed.\n\n------------------------------------------------------------\n\n5.4.003 (2010-06-19)\n\t- A problem related to page boxes was fixed.\n\t- Bug #3016920 \"Font subsetting issues when editing pdf\" was partially fixed (Note that flattening transparency layers is currently incompatible with TrueTypeUnicode fonts).\n\n5.4.002 (2010-06-18)\n\t- A problem related with setProtection() method was fixed.\n\n5.4.001 (2010-06-18)\n\t- A problem related with setProtection() method was fixed.\n\n5.4.000 (2010-06-18)\n\t- The method setSignatureAppearance() was added, check the example n. 52.\n\t- Several problems related to font subsetting were fixed.\n\n------------------------------------------------------------\n\n5.3.010 (2010-06-15)\n\t- Previous release was corrupted.\n\n5.3.009 (2010-06-15)\n\t- Bug #3015934 \"Bullets don't display correctly\" was fixed.\n\n5.3.008 (2010-06-13)\n\t- This version fixes some problems of SVG rasterization.\n\n5.3.007 (2010-06-13)\n\t- This version improves SVG support.\n\n5.3.006 (2010-06-10)\n\t- This version includes a change in uniqid calls for backward compatibility with PHP4.\n\n5.3.005 (2010-06-09)\n\t- The method getPageSizeFromFormat() was changed to include all standard page formats (includes 281 page formats + variation).\n\n5.3.004 (2010-06-08)\n\t- Bug #3013291 \"HTML table cell width\" was fixed.\n\t- Bug #3013294 \"HTML table cell alignment\" was fixed.\n\t- The columns widths of HTML tables are now inherited from the first row.\n\n5.3.003 (2010-06-08)\n\t- Bug #3013102 \"HTML table header misaligned after page break\" was fixed.\n\n5.3.002 (2010-06-07)\n\t- The methods setFontSubsetting() and setFontSubsetting() were added to control the default font subsetting mode (see example n. 1).\n\t- Bug #3012596 \"Whitespace should not appeared after use Thai top characters\" was fixed.\n\t- Examples n. 1, 14, and 54 were updated.\n\n5.3.001 (2010-06-06)\n\t- Barcode PDF417 was improved to support Macro Code Blocks (see example n. 50).\n\n5.3.000 (2010-06-05)\n\t- License was changed to GNU-LGPLv3 (see the updated LICENSE.TXT file).\n\t- PDF417 barcode support was added (check the example n. 50).\n\t- The method write2DBarcode() was improved (some parameters were added and other changed - check example n. 50).\n\n------------------------------------------------------------\n\n5.2.000 (2010-06-02)\n\t- IMPORTANT: Support for font subsetting was added by default to reduce the size of documents using large unicode font files.\n\t\tIf you embed the whole font in the PDF, the person on the other end can make changes to it even if he didn't have your font.\n\t\tIf you subset the font, file size of the PDF will be smaller but the person who receives your PDF would need to have your same font in order to make changes to your PDF.\n\t- The signature of the SetFont() and AddFont() methods were changed to include the font subsetting option (subsetting is applied by default).\n\t- Examples 14 and 54 were updated.\n\n------------------------------------------------------------\n\n5.1.002 (2010-05-27)\n\t- Bug #3007818 \"SetAutoPageBreak fails with MultiCell\" was fixed.\n\t- A bug related to MultiCell() minimun height was fixed.\n\n5.1.001 (2010-05-26)\n\t- The problem of blank page after table was fixed.\n\n5.1.000 (2010-05-25)\n\t- This version includes support for CSS (Cascading Style Sheets) (see example n. 61).\n\t- The convertHTMLColorToDec() method was improved.\n\n------------------------------------------------------------\n\n5.0.014 (2010-05-21)\n\t- A problem on color and style of HTML links was fixed.\n\t- A bug relative to gradients was fixed.\n\t- The getStringHeight() method was added and getNumLines() method was improved.\n\t- All examples were updated.\n\n5.0.013 (2010-05-19)\n\t- A bug related to page-breaks and table cells was fixed.\n\n5.0.012 (2010-05-19)\n\t- Page orientation bug was fixed.\n\t- The access to method setPageFormat() was changed to 'protected' because it is not intended to be directly called.\n\n5.0.011 (2010-05-19)\n\t- Page orientation bug was fixed.\n\t- Bug #3003966 \"Multiple columns and nested lists\" was fixed.\n\n5.0.010 (2010-05-17)\n\t- The methods setPageFormat(), setPageOrientation() and related methods were extended to include page boxes, page rotations and page transitions.\n\t- The method setPageBoxes() was added to set page boundaries (MediaBox, CropBox, BleedBox, TrimBox, ArtBox);\n\t- A bug relative to underline, overline and linethrough was fixed.\n\n5.0.009 (2010-05-16)\n\t- Bug #3002381 \"Multiple columns and nested lists\" was fixed.\n\n5.0.008 (2010-05-15)\n\t- Bug \"Columns WriteHTML and Justification\" was fixed.\n\n5.0.007 (2010-05-14)\n\t- Bug #3001347 \"Bug when using  WriteHTML with setEqualColumns()\" was fixed.\n\t- Bug #3001505 \"problem with sup and sub tags at the beginning of a line\" was fixed.\n\n5.0.006 (2010-05-13)\n\t- Length of hr tag was fixed.\n\t- An error on 2d barcode method was fixed.\n\n5.0.005 (2010-05-12)\n\t- WARNING: The logic of permissions on the SetProtection() method has been inverted and extended (see example 16). Now you have to specify the features you want to block.\n\t- SetProtection() method was extended to support RSA and AES 128 encryption and public-keys (see example 16).\n\t- Bug #2999489 \"setEqualColumns() and TOC uses wrong columns\" was fixed (see the example 10).\n\n5.0.004 (2010-05-10)\n\t- HTML line alignment when using sub and sup tags was fixed.\n\n5.0.003 (2010-05-07)\n\t- Horizontal alignment was fixed for images and barcodes. Now the X coordinate is always relative to the left margin. Use GetAbsX() instead of GetX() to get the X relative to left margin.\n\t- Header() method was changed to account for new image alignment rules.\n\n5.0.002 (2010-05-06)\n\t- Bookmark() and related methods were fixed to accept HTML code.\n\t- A problem on HTML links was fixed.\n\n5.0.001 (2010-05-06)\n\t- Protected method _putstream was re-added for backward compatibility.\n\t- The following method were added to display HTML Table Of Content (see example n. 59):\n\t\taddTOCPage(), endTOCPage(), addHTMLTOC().\n\n5.0.000 (2010-05-05)\n\t- Method ImageSVG() was added to embedd SVG images (see example n. 58). Note that not all SVG images are supported.\n\t- Method setRasterizeVectorImages() was added to enable/disable rasterization for vector images via ImageMagick library.\n\t- Method RoundedRectXY() was added.\n\t- Method PieSectorXY() was added.\n\t- Gradient() method is now public and support new features.\n\t- Shading to transparency is now supported.\n\t- Image alignments were fixed.\n\t- Support for dynamic images were improved.\n\t- PDF_IMAGE_SCALE_RATIO has been changed to 1.25 for better compatibility with SVG.\n\t- RAW and RAW2 modes were added to 2D Barcodes (see example n. 50).\n\t- Automatic padding feature was added on barcodes (see examples n. 27 and 50).\n\t- Bug #2995003 \"Reproduced thead bug\" was fixed.\n\t- The Output() method now accepts FI and FD destinations to save the document on server before sending it to the client.\n\t- Ellipse() method was improved and fixed (see page 2 of example n. 12).\n\n------------------------------------------------------------\n\n4.9.018 (2010-04-21)\n\t- Bug item #2990356 \"Current font size not respected with more than two HTML <p>\" was fixed.\n\n4.9.017 (2010-04-21)\n\t- Bug item #2990224 \"Different behaviour for equivalent HTML strings\" was fixed.\n\t- Bug item #2990314 \"Dash is not appearing with SHY character\" was fixed.\n\n4.9.016 (2010-04-20)\n\t- An error on htmlcolors.php was fixed.\n\t- getImageFileType() method was improved.\n\t- GIF images with transparency are now better supported.\n\t- Automatic page orientation was improved.\n\n4.9.015 (2010-04-20)\n\t- A new method copyPage() was added to clone pages (see example n. 44).\n\t- Support for text overline was added.\n\t- Underline and linethrough methods were fixed.\n\t- Bug #2989058 \"SHY character causes unnecessary word-wrapping\" was fixed.\n\n4.9.014 (2010-04-18)\n\t- Bug item #2988845 was fixed.\n\n4.9.013 (2010-04-15)\n\t- Image() and ImageEPS() methods were fixed and improved; $fitonpage parameter was added.\n\n4.9.012 (2010-04-12)\n\t- The hyphenateText() method was added to automatically hyphenate text (see example n. 46).\n\n4.9.011 (2010-04-07)\n\t- Vertical alignments for Cell() method were improved (see example n. 57).\n\n4.9.010 (2010-04-06)\n\t- Signature of Cell() method now includes new parameters for vertical alignment (see example n. 57).\n\t- Text() method was extended to include all Cell() parameters.\n\t- HTML line alignment procedure was changed to fix some bugs.\n\n4.9.009 (2010-04-05)\n\t- Text() method was fixed for backward compatibility.\n\n4.9.008 (2010-04-03)\n\t- Additional line space after table header was removed.\n\t- Support for HTML lists in multicolumn mode was added.\n\t- The method setTextRenderingMode() was added to set text rendering modes (see the example n. 26).\n\t- The following HTML attributes were added to set text rendering modes (see the example n. 26): stroke, strokecolor, fill.\n\n4.9.007 (2010-04-03)\n\t- Font Descent computation was fixed (patch #2981441).\n\n4.9.006 (2010-04-02)\n\t- The constant K_TCPDF_CALLS_IN_HTML was added on configuration file to enable/disable the ability to call TCPDF methods in HTML.\n\t- The usage of tcpdf tag in HTML mode was changed to remove the possible security flaw offered by the eval() function (thanks to Matthias Hecker for spotting this security problem). See the new example n. 49 for further information.\n\n4.9.005 (2010-04-01)\n\t- Bug# 2980354 \"Wrong File attachment description with security\" was fixed.\n\t- Several problems with HTML line alignment were fixed.\n\t- The constant K_THAI_TOPCHAR was added on configuration file to enable/disable the special procedure used to avoid the overlappind of symbols on Thai language.\n\t- A problem with font name directory was fixed.\n\t- A bug on _destroy() method was fixed.\n\n4.9.004 (2010-03-31)\n\t- Patch #979681 \"GetCharWidth - default character width\" was applied (bugfix).\n\n4.9.003 (2010-03-30)\n\t- Problem of first <br /> on multiple columns was fixed.\n\t- HTML line alignment was fixed.\n\t- A QR-code bug was fixed.\n\n4.9.002 (2010-03-29)\n\t- Patch #2978349 \"$ignore_min_height is ignored in function Cell()\" was applied.\n\t- Bug #2978607 \"2D Barcodes are wrong\" was fixed.\n\t- A problem with HTML block tags was fixed.\n\t- Artificial italic for CID-0 fonts was added.\n\t- Several multicolumn bugs were fixed.\n\t- Support for HTML tables on multicolumn was added.\n\n4.9.001 (2010-03-28)\n\t- QR Code minor bug was fixed.\n\t- Multicolumn mode was added (see the new example n. 10).\n\t- The following methods were added: setEqualColumns(), setColumnsArray(), selectColumn().\n\t- Thai diacritics support were changed (note that this is incompatible with html justification).\n\n4.9.000 (2010-03-27)\n\t- QR Code (2D barcode) support was added (see example n. 50).\n\t- The following methods were added to print crop and registration marks (see example n. 56): colorRegistrationBar(), cropMark(), registrationMark().\n\t- Limited support for CSS line-height property was added.\n\t- Gradient method now supports Gray, RGB and CMYK space color.\n\t- Example n. 51 was updated.\n\t- Vertical alignment of font inside cell was fixed.\n\t- Support for multiple Thai diacritics was added.\n\t- Bug item #2974929 \"Duplicate case values\" was fixed.\n\t- Bug item #2976729 \"File attachment not working with security\" was fixed.\n\n------------------------------------------------------------\n\n4.8.039 (2010-03-20)\n\t- Problems related to custom locale settings were fixed.\n\t- Problems related to HTML on Header and Footer were fixed.\n\n4.8.038 (2010-03-13)\n\t- Various bugs related to page-break in HTML mode were fixed.\n\t- Bug item #2968974 \"Another <thead> pagebreak problem\" was fixed.\n\t- Bug item #2969276 \"justification problem\" was fixed.\n\t- Bug item #2969289 \"bug when using justified text and custom headers\" was fixed.\n\t- Images are now automatically resized to be contained on the page.\n\t- Some HTML line alignments were fixed.\n\t- Signature of AddPage() and SetMargins() methods were changed to include an option to set default page margins.\n\n4.8.037 (2010-03-03)\n\t- Bug item #2962068 was fixed.\n\t- Bug item #2967017 \"Problems with <thead> and pagebreaks\" was fixed.\n\t- Bug item #2967023 \"table header lost with pagebreak\" was fixed.\n\t- Bug item #2967032 \"Header lost with nested tables\" was fixed.\n\n4.8.036 (2010-02-24)\n\t- Automatic page break for HTML images was improved.\n\t- Example 10 was updated.\n\t- Japanese was removed from example 8 because the freeserif font doesn't contain japanese (you can display it using arialunicid0 font).\n\n4.8.035 (2010-02-23)\n\t- Automatic page break for HTML images was added.\n\t- Support for multicolumn HTML was added (example 10 was updated).\n\n4.8.034 (2010-02-17)\n\t- Language files were updated.\n\n4.8.033 (2010-02-12)\n\t- A bug related to protection mode with links was fixed.\n\n4.8.032 (2010-02-04)\n\t- A bug related to $maxh parameter on Write() and MultiCell() was fixed.\n\t- Support for body tag was added.\n\n4.8.031 (2010-01-30)\n\t- Bug item #2941589 \"paragraph justify not working on some non-C locales\" was fixed.\n\n4.8.030 (2010-01-27)\n\t- Some text alignment cases were fixed.\n\n4.8.029 (2010-01-27)\n\t- Bug item #2941057 \"TOC Error in PDF File Output\" was fixed.\n\t- Some text alignment cases were fixed.\n\n4.8.028 (2010-01-26)\n\t- Text alignment for RTL mode was fixed.\n\n4.8.027 (2010-01-25)\n\t- Bug item #2938412 \"Table related problems - thead, nobr, table width\" was fixed.\n\n4.8.026 (2010-01-19)\n\t- The misspelled word \"length\" was replaced with \"length\" in some variables and comments.\n\n4.8.025 (2010-01-18)\n\t- addExtGState() method was improved to reuse existing ExtGState objects.\n\n4.8.024 (2010-01-15)\n\t- Justification mode for HTML was fixed (Bug item #2932470).\n\n4.8.023 (2010-01-15)\n\t- Bug item #2932470 \"Some HTML entities breaks justification\" was fixed.\n\n4.8.022 (2010-01-14)\n\t- Source code documentation was fixed.\n\n4.8.021 (2010-01-03)\n\t- A Bug relative to Table Of Content index was fixed.\n\n4.8.020 (2009-12-21)\n\t- Bug item #2918545 \"Display problem of the first row of a table with larger font\" was fixed.\n\t- A Bug relative to table rowspan mode was fixed.\n\n4.8.019 (2009-12-16)\n\t- Bug item #2915684 \"Image size\" was fixed.\n\t- Bug item #2914995 \"Image jpeg quality\" was fixed.\n\t- The signature of the Image() method was changed (check the documentation for the $resize parameter).\n\n4.8.018 (2009-12-15)\n\t- Bug item #2914352 \"write error\" was fixed.\n\n4.8.017 (2009-11-27)\n\t- THEAD problem when table is used on header/footer was fixed.\n\t- A first line alignment on HTML justification was fixed.\n\t- Method getImageFileType() was added.\n\t- Images with unknown extension and type are now supported via ImageMagick PHP extension.\n\n4.8.016 (2009-11-21)\n\t- Document Information Dictionary was fixed.\n\t- CSS attributes 'page-break-before', 'page-break-after' and 'page-break-inside' are now supported.\n\t- Problem of unclosed last page was fixed.\n\t- Problem of 'thead' unnecessarily repeated on the next page was fixed.\n\n4.8.015 (2009-11-20)\n\t- A problem with some PNG transparency images was fixed.\n\t- Bug #2900762 \"Sort issues in Bookmarks\" was fixed.\n\t- Text justification was fixed for various modes: underline, strikeout and background.\n\n4.8.014 (2009-11-04)\n\t- Bug item #2891316 \"writeHTML, underlining replacing spaces\" was fixed.\n\t- The handling of temporary RTL text direction mode was fixed.\n\n4.8.013 (2009-10-26)\n\t- Bug item #2884729 \"Problem with word-wrap and hyphen\" was fixed.\n\n4.8.012 (2009-10-23)\n\t- Table cell alignments for RTL booklet mode were fixed.\n\t- Images and barcode alignments for booklet mode were fixed.\n\n4.8.011 (2009-10-22)\n\t- DejaVu fonts were updated to latest version.\n\n4.8.010 (2009-10-21)\n\t- Bookmark for TOC page was added.\n\t- Signature of addTOC() method is changed.\n\t- Bookmarks are now automatically sorted by page and Y position.\n\t- Example n. 45 was updated.\n\t- Example n. 55 was added to display all charactes available on core fonts.\n\n4.8.009 (2009-09-30)\n\t- Compatibility with PHP 5.3 was improved.\n\t- All examples were updated.\n\t- Index file for examples was added.\n\n4.8.008 (2009-09-29)\n\t- Example 49 was updated.\n\t- Underline and linethrough now works with cell stretching mode.\n\n4.8.007 (2009-09-23)\n\t- Infinite loop problem caused by nobr attribute was fixed.\n\n4.8.006 (2009-09-23)\n\t- Bug item #2864522 \"No images if DOCUMENT_ROOT=='/'\" was fixed.\n\t- Support for text-indent CSS attribute was added.\n\t- Method rollbackTransaction() was changed to support self-reassignment of previous object (check source code documentation).\n\t- Support for the HTML \"nobr\" attribute was added to avoid splitting a table or a table row on two pages (i.e.: <tr nobr=\"true\">...</tr>).\n\n4.8.005 (2009-09-17)\n\t- A bug relative to multiple transformations and annotations was fixed.\n\n4.8.004 (2009-09-16)\n\t- A bug on _putannotsrefs() method was fixed.\n\n4.8.003 (2009-09-15)\n\t- Bug item #2858754 \"Division by zero\" was fixed.\n\t- A bug relative to HTML list items was fixed.\n\t- A bug relative to form fields on multiple pages was fixed.\n\t- PolyLine() method was added (see example n. 12).\n\t- Signature of Polygon() method was changed.\n\n4.8.002 (2009-09-12)\n\t- A problem related to CID-0 fonts offset was fixed: if the $cw[1] entry on the CID-0 font file is not defined, then a CID keys offset is introduced.\n\n4.8.001 (2009-09-09)\n\t- The appearance streams (AP) for anotations form fields was fixed (see examples n. 14 and 54).\n\t- Radiobuttons were fixed.\n\n4.8.000 (2009-09-07)\n\t- This version includes some support for Forms fields (see example n. 14) and XHTML forms (see example n. 54).\n\t- The following methods were changed to work without JavaScript: TextField(), RadioButton(), ListBox(), ComboBox(), CheckBox(), Button().\n\t- Support for Widget annotations was improved.\n\t- Alignment of annotation objects was fixed (examples 36 and 41 were updated).\n\t- addJavascriptObject() method was added.\n\t- Signature of Image() method was changed.\n\t- htmlcolors.php file was updated.\n\n------------------------------------------------------------\n\n4.7.003 (2009-09-03)\n\t- Support for TCPDF methods on HTML was improved (see example n. 49).\n\n4.7.002 (2009-09-02)\n\t- Bug item #2848892 \"writeHTML + table: Gaps between rows\" was fixed.\n\t- JavaScript support was fixed (see example n. 53).\n\n4.7.001 (2009-08-30)\n\t- The Polygon() and Arrow() methods were fixed and improved (see example n. 12).\n\n4.7.000 (2009-08-29)\n\t- This is a major release.\n\t- Some procedures were internally optimized.\n\t- The problem of mixed signature and annotations was fixed (example n. 52).\n\n4.6.030 (2009-08-29)\n\t- IMPORTANT: percentages on table cell widths are now relative to the full table width (as in standard HTML).\n\t- Various minor bugs were fixed.\n\t- Example n. 52 (digital signature) was updated.\n\n4.6.029 (2009-08-26)\n\t- PHP4 version was fixed.\n\n4.6.028 (2009-08-25)\n\t- Signature algorithm was finally fixed (see example n. 52).\n\n4.6.027 (2009-08-24)\n\t- TCPDF now supports unembedded TrueTypeUnicode Fonts (just comment the $file entry on the fonts' php file.\n\n4.6.026 (2009-08-21)\n\t- Bug #2841693 \"Problem with MultiCell and ishtml and justification\" was fixed.\n\t- Signature functions were improved but not yet fixed (tcpdf.crt and example n. 52 were updated).\n\n4.6.025 (2009-08-17)\n\t- Carriage returns (\\r) were removed from source code.\n\t- Problem related to set_magic_quotes_runtime() depracated was fixed.\n\n4.6.024 (2009-08-07)\n\t- Bug item #2833556 \"justification using other units than mm\" was fixed.\n\t- Documentation was fixed/updated.\n\n4.6.023 (2009-08-02)\n\t- Bug item #2830537 \"MirrorH can show mask for transparent PNGs\" was fixed.\n\n4.6.022 (2009-07-24)\n\t- A bug relative to single line printing when using WriteHTMLCell() was fixed.\n\t- Signature support were improved but is still experimental.\n\t- Fonts Free and Dejavu were updated to latest versions.\n\n4.6.021 (2009-07-20)\n\t- Bug item #2824015 \"XHTML Ampersand &amp; in hyperlink bug\" was fixed.\n\t- Bug item #2824036 \"Image as hyperlink in table, text displaced at page break\" was fixed.\n\t- Links alignment on justified text was fixed.\n\t- Unicode \"\\u\" modifier was added to re_spaces variable by default.\n\n4.6.020 (2009-07-16)\n\t- Bug item #2821921 \"issue in example 18\" was fixed.\n\t- Signature of SetRTL() method was changed.\n\n4.6.019 (2009-07-13)\n\t- Bug item #2820703 \"xref table broken\" was fixed.\n\n4.6.018 (2009-07-10)\n\t- Bug item #2819319 \"Text over text\" was fixed.\n\t- Method Arrow() was added to print graphic arrows (example 12 was updated).\n\n4.6.017 (2009-07-05)\n\t- Bug item #2816079 \"Example 48 not working\" was fixed.\n\t- The signature of the checkPageBreak() was changed. The parameter $addpage was added to turn off the automatic page creation.\n\n4.6.016 (2009-06-16)\n\t- Method setSpacesRE() was added to set the regular expression used for detecting withespaces or word separators. If you are using chinese, try: setSpacesRE('/[\\s\\p{Z}\\p{Lo}]/');, otherwise you can use setSpacesRE('/[\\s\\p{Z}]/');\n\t- The method _putinfo() now automatically fills the metadata with '?' in case of empty string.\n\n4.6.015 (2009-06-11)\n\t- Bug #2804667 \"word wrap bug\" was fixed.\n\n4.6.014 (2009-06-04)\n\t- Bug #2800931 \"Table thead tag bug\" was fixed.\n\t- A bug related to <pre> tag was fixed.\n\n4.6.013 (2009-05-28)\n\t- List bullets position was fixed for RTL languages.\n\n4.6.012 (2009-05-23)\n\t- setUserRights() method doesn't work anymore unless you call the setSignature() method with the Adobe private key!\n\n4.6.011 (2009-05-18)\n\t- Signature of the Image() method was changed to include the new $fitbox parameter (see source code documentation).\n\n4.6.010 (2009-05-17)\n\t- Image() method was improved: now is possible to specify the maximum dimensions for a constraint box defined by $w and $h parameters, and setting the $resize parameter to null.\n\t- <tcpdf> tag indent problem was fixed.\n\t- $y parameter was added to checkPageBreak() method.\n\t- Bug n. 2791773 \"writeHTML\" was fixed.\n\n4.6.009 (2009-05-13)\n\t- xref table for embedded files was fixed.\n\n4.6.008 (2009-05-07)\n\t- setSignature() method was improved (but is still experimental).\n\t- Example n. 52 was added.\n\n4.6.007 (2009-05-05)\n\t- Bug #2786685 \"writeHtmlCell and <br /> in custom footer\" was fixed.\n\t- Table header repeating bug was fixed.\n\t- Some newlines and tabs are now automatically removed from HTML strings.\n\n4.6.006 (2009-04-28)\n\t- Support for \"<a name=\"...\">...</a>\" was added.\n\t- By default TCPDF requires PCRE Unicode support turned on but now works also without it (with limited ability to detect some Unicode blank spaces).\n\n4.6.005 (2009-04-25)\n\t- Points (pt) conversion in getHTMLUnitToUnits() was fixed.\n\t- Default tcpdf.pem certificate file was added.\n\t- Experimental support for signing document was added but it is not yet completed (some help is needed - I think that the calculation of the ByteRange is OK and the problem is on the signature calculation).\n\n4.6.004 (2009-04-23)\n\t- Method deletePage() was added to delete pages (see example n. 44).\n\n4.6.003 (2009-04-21)\n\t- The caching mechanism of the UTF8StringToArray() method was fixed.\n\n4.6.002 (2009-04-20)\n\t- Documentation of rollbackTransaction() method was fixed.\n\t- The setImageScale() and getImageScale() methods now set and get the adjusting parameter used by pixelsToUnits() method.\n\t- HTML images now support other units of measure than pixels (getHTMLUnitToUnits() is now used instead of pixelsToUnits()).\n\t- WARNING: PDF_IMAGE_SCALE_RATIO has been changed by default to 1.\n\n4.6.001 (2009-04-17)\n\t- Spaces between HTML block tags are now automatically removed.\n\t- The bug related to cMargin changes between tables was fixed.\n\n4.6.000 (2009-04-16)\n\t- WARNING: THIS VERSION CHANGES THE BEHAVIOUR OF $x and $y parameters for several TCPDF methods:\n\t\tzero coordinates for $x and $y are now valid coordinates;\n\t\tset $x and $y as empty strings to get the current value.\n\t- Some error caused by 'empty' function were fixed.\n\t- Default color for convertHTMLColorToDec() method was changed to white and the return value for invalid color is false.\n\t- HTML on footer bug was fixed.\n\t- The following examples were fixed: 5,7,10,17,19,20,21,33,42,43.\n\n4.5.043 (2009-04-15)\n\t- Barcode class (barcode.php) was extended to include new linear barcode types (see example n. 27):\n\t\tC39 : CODE 39 - ANSI MH10.8M-1983 - USD-3 - 3 of 9\n\t\tC39+ : CODE 39 with checksum\n\t\tC39E : CODE 39 EXTENDED\n\t\tC39E+ : CODE 39 EXTENDED + CHECKSUM\n\t\tC93 : CODE 93 - USS-93\n\t\tS25 : Standard 2 of 5\n\t\tS25+ : Standard 2 of 5 + CHECKSUM\n\t\tI25 : Interleaved 2 of 5\n\t\tI25+ : Interleaved 2 of 5 + CHECKSUM\n\t\tC128A : CODE 128 A\n\t\tC128B : CODE 128 B\n\t\tC128C : CODE 128 C\n\t\tEAN2 : 2-Digits UPC-Based Extension\n\t\tEAN5 : 5-Digits UPC-Based Extension\n\t\tEAN8 : EAN 8\n\t\tEAN13 : EAN 13\n\t\tUPCA : UPC-A\n\t\tUPCE : UPC-E\n\t\tMSI : MSI (Variation of Plessey code)\n\t\tMSI+ : MSI + CHECKSUM (modulo 11)\n\t\tPOSTNET : POSTNET\n\t\tPLANET : PLANET\n\t\tRMS4CC : RMS4CC (Royal Mail 4-state Customer Code) - CBC (Customer Bar Code)\n\t\tKIX : KIX (Klant index - Customer index)\n\t\tIMB: Intelligent Mail Barcode - Onecode - USPS-B-3200 (NOTE: requires BCMath PHP extension)\n\t\tCODABAR : CODABAR\n\t\tCODE11 : CODE 11\n\t\tPHARMA : PHARMACODE\n\t\tPHARMA2T : PHARMACODE TWO-TRACKS\n\n4.5.042 (2009-04-15)\n\t- Method Write() was fixed for the strings containing only zero value.\n\n4.5.041 (2009-04-14)\n\t- Barcode methods were fixed.\n\n4.5.040 (2009-04-14)\n\t- Method Write() was fixed to handle empty strings.\n\n4.5.039 (2009-04-11)\n\t- Support for linear barcodes was extended (see example n. 27 and barcodes.php documentation).\n\n4.5.038 (2009-04-10)\n\t- Write() method was improved to support separators for Japanese, Korean, Chinese Traditional and Chinese Simplified.\n\n4.5.037 (2009-04-09)\n\t- General performances were improved.\n\t- The signature of the method utf8Bidi() was changed.\n\t- The method UniArrSubString() was added.\n\t- Experimental support for 2D barcodes were added (see example n. 50 and 2dbarcodes.php class).\n\n4.5.036 (2009-04-03)\n\t- TCPDF methods can be called inside the HTML code (see example n. 49).\n\t- All tag attributes, such as <p align=\"center\"> must be enclosed within double quotes.\n\n4.5.035 (2009-03-28)\n\t- Bug #2717436 \"writeHTML rowspan problem (continued)\" was fixed.\n\t- Bug #2719090 \"writeHTML fix follow up\" was fixed.\n\t- The method _putuserrights() was changed to avoid Adobe Reader 9.1 crash. This broken the 'trick' that was used to display forms in Acrobat Reader.\n\n4.5.034 (2009-03-27)\n\t- Bug #2716914 \"Bug writeHTML of a table in body and footer related with pb\" was fixed.\n\t- Bug #2717056 ] \"writeHTML problem when setting tr style\" was fixed.\n\t- The signature of the Cell() method was changed.\n\n4.5.033 (2009-03-27)\n\t- The support for rowspan/colspan on HTML tables was improved (see example n. 48).\n\n4.5.032 (2009-03-23)\n\t- setPrintFooter(false) bug was fixed.\n\n4.5.031 (2009-03-20)\n\t- Table header support was extended to multiple pages.\n\n4.5.030 (2009-03-20)\n\t- thead tag is now supported on HTML tables (header rows are repeated after page breaks).\n\t- The startTransaction() was improved to autocommit.\n\t- List bullets now uses the foreground color (putHtmlListBullet()).\n\n4.5.029 (2009-03-19)\n\t- The following methods were added to UNDO commands (see example 47): startTransaction(), commitTransaction(), rollbackTransaction().\n\t- All examples were updated.\n\n4.5.028 (2009-03-18)\n\t- Bug #2690945 \"List Bugs\" was fixed.\n\t- HTML text alignment on lists was fixed.\n\t- The constant PDF_FONT_MONOSPACED was added to the configuration file to define the default monospaced font.\n\t- The following methods were fixed: getPageWidth(), getPageHeight(), getBreakMargin().\n\t- All examples were updated.\n\n4.5.027 (2009-03-16)\n\t- Method getPageDimensions() was added to get page dimensions.\n\t- The signature of the following methos were changed: getPageWidth(), getPageHeight(), getBreakMargin().\n\t- _parsepng() method was fixed for PNG URL images (fread bug).\n\n4.5.026 (2009-03-11)\n\t- Bug #2681793 affecting URL images with spaces was fixed.\n\n4.5.025 (2009-03-10)\n\t- A small bug affecting hyphenation support was fixed.\n\t- The method SetDefaultMonospacedFont() was added to define the default monospaced font.\n\n4.5.024 (2009-03-07)\n\t- The bug #2666493 was fixed \"Footer corrupts document\".\n\n4.5.023 (2009-03-06)\n\t- The bug #2666688 was fixed \"Rowspan in tables\".\n\n4.5.022 (2009-03-05)\n\t- The bug #2659676 was fixed \"refer to #2157099 test 4 < BR > problem still not fixed\".\n\t- addTOC() function bug was fixed.\n\n4.5.020 (2009-03-03)\n\t- The following bug was fixed: \"function removeSHY corrupts unicode\".\n\n4.5.019 (2009-02-28)\n\t- The problem of decimal separator using different locale was fixed.\n\t- The text hyphenation is now supported (see example n. 46).\n\n4.5.018 (2009-02-26)\n\t- The _destroy() method was added to unset all class variables and frees memory.\n\t- Now it's possible to call Output() method multiple times.\n\n4.5.017 (2009-02-24)\n\t- A minor bug that raises a PHP warning was fixed.\n\n4.5.016 (2009-02-24)\n\t- Bug item #2631200 \"getNumLines() counts wrong\" was fixed.\n\t- Multiple attachments bug was fixed.\n\t- All class variables are now cleared on Output() for memory otpimization.\n\n4.5.015 (2009-02-18)\n\t- Bug item #2612553 \"function Write() must not break a line on &nbsp;  character\" was fixed.\n\n4.5.014 (2009-02-13)\n\t- Bug item #2595015 \"POSTNET Barcode Checksum Error\" was fixed (on barcode.php).\n\t- Pagebreak bug for barcode was fixed.\n\n4.5.013 (2009-02-12)\n\t- border attribute is now supported on HTML images (only accepts the same values accepted by Cell()).\n\n4.5.012 (2009-02-12)\n\t- An error on image border feature was fixed.\n\n4.5.011 (2009-02-12)\n\t- HTML links for images are now supported.\n\t- height attribute is now supported on HTML cells.\n\t- $border parameter was added to Image() and ImageEps() methods.\n\t- The method getNumLines() was added to estimate the number of lines required for the specified text.\n\n4.5.010 (2009-01-29)\n\t- Bug n. 2546108 \"BarCode Y position\" was fixed.\n\n4.5.009 (2009-01-26)\n\t- Bug n. 2538094 \"Empty pdf file created\" was fixed.\n\n4.5.008 (2009-01-26)\n\t- setPage() method was fixed to correctly restore graphic states.\n\t- Source code was cleaned up for performances.\n\n4.5.007 (2009-01-24)\n\t- checkPageBreak() and write1DBarcode() methods were fixed.\n\t- Source code was cleaned up for performances.\n\t- barcodes.php was updated.\n\n4.5.006 (2009-01-23)\n\t- getHTMLUnitToPoints() method was replaced by getHTMLUnitToUnits() to fix HTML units bugs.\n\n4.5.005 (2009-01-23)\n\t- Page closing bug was fixed.\n\n4.5.004 (2009-01-21)\n\t- The access of convertHTMLColorToDec() method was changed to public\n\t- Fixed bug on UL tag.\n\n4.5.003 (2009-01-19)\n\t- Fonts on different folders are now supported.\n\n4.5.002 (2009-01-07)\n\t- addTOC() function was improved (see example n. 45).\n\n4.5.001 (2009-01-04)\n\t- The signature of startPageGroup() function was changed.\n\t- Method Footer() was improved to automatically print page or page-group number (see example n. 23).\n\t- Protected method formatTOCPageNumber() was added to customize the format of page numbers on the Table Of Content.\n\t- The signature of addTOC() was changed to include the font used for page numbers.\n\n4.5.000 (2009-01-03)\n\t- A new $diskcache parameter was added to class constructor to enable disk caching and reduce RAM memory usage (see example n. 43).\n\t- The method movePageTo() was added to move pages to previous positions (see example n. 44).\n\t- The methods getAliasNumPage() and getPageNumGroupAlias() were added to get the alias for page number (needed when using movepageTo()).\n\t- The methods addTOC() was added to print a Table Of Content (see example n. 45).\n\t- Imagick class constant was removed for better compatibility with PHP4.\n\t- All existing examples were updated and new examples were added.\n\n4.4.009 (2008-12-29)\n\t- Examples 1 and 35 were fixed.\n\n4.4.008 (2008-12-28)\n\t- Bug #2472169 \"Unordered bullet size not adjusted for unit type\" was fixed.\n\n4.4.007 (2008-12-23)\n\t- Bug #2459935 \"no unit conversion for header line\" was fixed.\n\t- Example n. 42 for image alpha channel was added.\n\t- All examples were updated.\n\n4.4.006 (2008-12-11)\n\t- Method setLIsymbol() was changed to reflect latest changes in HTML list handling.\n\n4.4.005 (2008-12-10)\n\t- Bug item #2413870 \"ordered list override value\" was fixed.\n\n4.4.004 (2008-12-10)\n\t- The protected method getHTMLUnitToPoints() was added to accept various HTML units of measure (em, ex, px, in, cm, mm, pt, pc, %).\n\t- The method intToRoman() was added to convert integer number to Roman representation.\n\t- Support fot HTML lists was improved: the CSS property list-style-type is now supported.\n\n4.4.003 (2008-12-09)\n\t- Bug item #2412147 \"Warning on line 3367\" was fixed.\n\t- Method setHtmlLinksStyle() was added to set default HTML link colors and font style.\n\t- Method addHtmlLink() was changed to use color and style defined on the inline CSS.\n\n4.4.002 (2008-12-09)\n\t- Borders on Multicell() were fixed.\n\t- Problem of Multicell() on Header function (Bug item #2407579) was fixed.\n\t- Problem on graphics tranformations applied to Multicell() was fixed.\n\t- Support for ImageMagick was added.\n\t- Width calculation for nested tables was fixed.\n\n4.4.001 (2008-12-08)\n\t- Some missing core fonts were added on fonts directory.\n\t- CID0 fonts rendering was fixed.\n\t- HTML support was improved (<pre> and <tt> tags are now supported).\n\t- Bug item #2406022 \"Left padding bug in MultiCell with maxh\" was fixed.\n\n4.4.000 (2008-12-07)\n\t- File attachments are now supported (see example n. 41).\n\t- Font functions were optimized to reduce document size.\n\t- makefont.php was updated.\n\t- Linux binaries were added on /fonts/utils\n\t- All fonts were updated.\n\t- $autopadding parameter was added to Multicell() to disable automatic padding features.\n\t- $maxh parameter was added to Multicell() and Write() to set a maximum height.\n\n4.3.009 (2008-12-05)\n\t- Bug item #2392989 (Custom header + setlinewidth + cell border bug) was fixed.\n\n4.3.008 (2008-12-05)\n\t- Bug item #2390566 \"rect bug\" was fixed.\n\t- File path was fixed for font embedded files.\n\t- SetFont() method signature was changed to include the font filename.\n\t- Some font-related methods were improved.\n\t- Methods getFontFamily() and getFontStyle() were added.\n\n4.3.007 (2008-12-03)\n\t- PNG alpha channel is now supported (GD library is required).\n\t- AddFont() function now support custom font file path on $file parameter.\n\t- The default width variable ($dw) is now always defined for any font.\n\t- The 'Style' attribute on CID-0 fonts was removed because of protection bug.\n\n4.3.006 (2008-12-01)\n\t- A regular expression on getHtmlDomArray() to find HTML tags was fixed.\n\n4.3.005 (2008-11-25)\n\t- makefont.php was fixed.\n\t- Bug item #2339877 was fixed (false loop condition detected on WriteHTML()).\n\t- Bug item #2336733 was fixed (lasth value update on Multicell() when border and fill are disabled).\n\t- Bug item #2342303 was fixed (automatic page-break on Image() and ImageEPS()).\n\n4.3.004 (2008-11-19)\n\t- Function _textstring() was fixed (bug 2309051).\n\t- All examples were updated.\n\n4.3.003 (2008-11-18)\n\t- CID-0 font bug was fixed.\n\t- Some functions were optimized.\n\t- Function getGroupPageNoFormatted() was added.\n\t- Example n. 23 was updated.\n\n4.3.002 (2008-11-17)\n\t- Bug item #2305518 \"CID-0 font don't work with encryption\" was fixed.\n\n4.3.001 (2008-11-17)\n\t- Bug item #2300007 \"download mimetype pdf\" was fixed.\n\t- Double quotes were replaced by single quotes to improve PHP performances.\n\t- A bug relative to HTML cell borders was fixed.\n\n4.3.000 (2008-11-14)\n\t- The function setOpenCell() was added to set the top/bottom cell sides to be open or closed when the cell cross the page.\n\t- A bug relative to list items indentation was fixed.\n\t- A bug relative to borders on HTML tables and Multicell was fixed.\n\t- A bug relative to rowspanned cells was fixed.\n\t- A bug relative to html images across pages was fixed.\n\n4.2.009 (2008-11-13)\n\t- Spaces between li tags are now automatically removed.\n\n4.2.008 (2008-11-12)\n\t- A bug relative to fill color on next page was fixed.\n\n4.2.007 (2008-11-12)\n\t- The function setListIndentWidth() was added to set custom indentation widht for HTML lists.\n\n4.2.006 (2008-11-06)\n\t- A bug relative to HTML justification was fixed.\n\n4.2.005 (2008-11-06)\n\t- A bug relative to HTML justification was fixed.\n\t- The methods formatPageNumber() and PageNoFormatted() were added to format page numbers.\n\t- Default Footer() method was changed to use PageNoFormatted() instead of PageNo().\n\t- Example 6 was updated.\n\n4.2.004 (2008-11-04)\n\t- Bug item n. 2217039 \"filename handling improvement\" was fixed.\n\n4.2.003 (2008-10-31)\n\t- Font style bug was fixed.\n\n4.2.002 (2008-10-31)\n\t- Bug item #2210922 (htm element br not work) was fixed.\n\t- Write() function was improved to support margin changes.\n\n4.2.001 (2008-10-30)\n\t- setHtmlVSpace($tagvs) function was added to set custom vertical spaces for HTML tags.\n\t- writeHTML() function now support margin changes during execution.\n\t- Signature of addHTMLVertSpace() function is changed.\n\n4.2.000 (2008-10-29)\n\t- htmlcolors.php was changed to support class-loaders.\n\t- ImageEps() function was improved in performances.\n\t- Signature of Link() And Annotation() functions were changed.\n\t- (Bug item #2198926) Links and Annotations alignment were fixed (support for geometric tranformations was added).\n\t- rowspan mode for HTML table cells was improved and fixed.\n\t- Booklet mode for double-sided pages was added; see SetBooklet() function and example n. 40.\n\t- lastPage() signature is changed.\n\t- Signature of Write() function is changed.\n\t- Some HTML justification problems were fixed.\n\t- Some functions were fixed to better support RTL mode.\n\t- Example n. 10 was changed to support RTL mode.\n\t- All examples were updated.\n\n4.1.004 (2008-10-23)\n\t- unicode_data.php was changed to support class-loaders.\n\t- Bug item #2186040/2 (writeHTML margin problem) was fixed.\n\n4.1.003 (2008-10-22)\n\t- Bug item #2185399 was fixed (rowspan and page break).\n\t- Bugs item #2186040 was fixed (writeHTML margin problem).\n\t- Newline after table was removed.\n\n4.1.002 (2008-10-21)\n\t- Bug item #2184525 was fixed (rowspan on HTML cell).\n\n4.1.001 (2008-10-21)\n\t- Support for \"start\" attribute was added to HTML ordered list.\n\t- unicode_data.php file was changed to include UTF-8 to ASCII table.\n\t- Some functions were modified to better support UTF-8 extensions to core fonts.\n\t- Support for images on HTML lists was improved.\n\t- Examples n. 1 and 6 were updated.\n\n4.1.000 (2008-10-18)\n\t- Page-break bug using HTML content was fixed.\n\t- The \"false\" parameter was reintroduced to class_exists function on PHP5 version to avoid autoload.\n\t- addHtmlLink() function was improved to support internal links (i.e.: <a href=\"#23\">link to page 23</a>).\n\t- Justification alignment is now supported on HTML (see example n. 39).\n\t- example_006.php was updated.\n\n4.0.033 (2008-10-13)\n\t- Bug n. 2157099 was fixed.\n\t- SetX() and SetY() functions were improved.\n\t- SetY() includes a new parameter to avoid the X reset.\n\n4.0.032 (2008-10-10)\n\t- Bug n. 2156926 was fixed (bold, italic, underlined, linethrough).\n\t- setStyle() method was removed.\n\t- Configuration file was changed to use helvetica (non-unicode) font by default.\n\t- The use of mixed font types was improved.\n\t- All examples were updated.\n\n4.0.031 (2008-10-09)\n\t- _putannots() and _putbookmarks() links alignments were fixed.\n\n4.0.030 (2008-10-07)\n\t- _putbookmarks() function was fixed.\n\t- _putannots() was fixed to include internal links.\n\n4.0.029 (2008-09-27)\n\t- Infinite loop bug was fixed [Bug item #130309].\n\t- Multicell() problem on Header() was fixed.\n\n4.0.028 (2008-09-26)\n\t- setLIsymbol() was added to set the LI symbol used on UL lists.\n\t- Missing $padding and $encryption_key variables declarations were added [Bug item #2129058].\n\n4.0.027 (2008-09-19)\n\t- Bug #2118588 \"Undefined offset in tcpdf.php on line 9581\" was fixed.\n\t- arailunicid0.php font was updated.\n\t- The problem of javascript form fields duplication after saving was fixed.\n\n4.0.026 (2008-09-17)\n\t- convertHTMLColorToDec() function was improved to support rgb(RR,GG,BB) notation.\n\t- The following inline CSS attributes are now supported: text-decoration, color, background-color and font-size names: xx-small, x-small, small, medium, large, x-large, xx-large\n\t- Example n. 6 was updated.\n\n4.0.025 (2008-09-15)\n\t- _putcidfont0 function was improved to include CJK fonts (Chinese, Japanese, Korean, CJK, Asian fonts) without embedding.\n\t- arialunicid0 font was added (see the new example n. 38).\n\t- The following Unicode to CID-0 tables were added on fonts folder: uni2cid_ak12.php, uni2cid_aj16.php, uni2cid_ag15.php, uni2cid_ac15.php.\n\n4.0.024 (2008-09-12)\n\t- \"stripos\" function was replaced with \"strpos + strtolower\" for backward compatibility with PHP4.\n\t- support for Spot Colors were added. Check the new example n. 37 and the following new functions:\n\t\tAddSpotColor()\n\t\tSetDrawSpotColor()\n\t\tSetFillSpotColor()\n\t\tSetTextSpotColor()\n\t\t_putspotcolors()\n\t- Bookmark() function was improved to fix wrong levels.\n\t- $lasth changes after header/footer calls were fixed.\n\n4.0.023 (2008-09-05)\n\t- Some HTML related problems were fixed.\n\t- Image alignment on HTML was changed, now it always defaults to the normal mode (see example_006.php).\n\n4.0.022 (2008-08-28)\n\t- Line height on HTML was fixed.\n\t- Image inside an HTML cell problem was fixed.\n\t- A new \"zarbold\" persian font was added.\n\n4.0.021 (2008-08-24)\n\t- HTTP headers were fixed on Output function().\n\t- getAliasNbPages() and getPageGroupAlias() functions were changed to support non-unicode fonts on unicode documents.\n\t- Function Write() was fixed.\n\t- The problem of additional vertical spaces on HTML was fixed.\n\t- The problem of frame around HTML links was fixed.\n\n4.0.020 (2008-08-15)\n\t- \"[2052259] WriteHTML <u> & <b>\" bug was fixed.\n\n4.0.019 (2008-08-13)\n\t- \"Rowspan on first cell\" bug was fixed.\n\n4.0.018 (2008-08-08)\n\t- Default cellpadding for HTML tables was fixed.\n\t- Annotation() function was added to support some PDF annotations (see example_036.php and section 8.4 of PDF reference 1.7).\n\t- HTML links are now correclty shifted during line alignments.\n\t- function getAliasNbPages() was added and Footer() was updated.\n\t- RowSpan mode for HTML tables was fixed.\n\t- Bugs item #2043610 \"Multiple sizes vertical align wrong\" was fixed.\n\t- ImageEPS() function was improved and RTL alignment was fixed (see example_032.php).\n\n4.0.017 (2008-08-05)\n\t- Missing CNZ and CEO style modes were added to Rect() function.\n\t- Fonts utils were updated to include support for OpenType fonts.\n\t- getLastH() function was added.\n\n4.0.016 (2008-07-30)\n\t- setPageMark() function was added. This function must be called after calling Image() function for a background image.\n\n4.0.015 (2008-07-29)\n\t- Some functions were changed to support different page formats (see example_028.php).\n\t- The signature of setPage() function is changed.\n\n4.0.014 (2008-07-29)\n\t- K_PATH_MAIN calculation on tcpdf_config.php was fixed.\n\t- HTML support for EPS/AI images was added (see example_006.php).\n\t- Bugs item #2030807 \"Truncated text on multipage html fields\" was fixed.\n\t- PDF header bug was fixed.\n\t- helvetica was added as default font family.\n\t- Stroke mode was fixed on Text function.\n\t- several minor bugs were fixed.\n\n4.0.013 (2008-07-27)\n\t- Bugs item #2027799 \" Big spaces between lines after page break\" was fixed.\n\t- K_PATH_MAIN calculation on tcpdf_config.php was changed.\n\t- Function setVisibility() was fixed to avoid the \"Incorrect PDEObject type\" error message.\n\n4.0.012 (2008-07-24)\n\t- Addpage(), Header() and Footer() functions were changed to simplify the implementation of external header/footer functions.\n\t- The following functions were added:\n\t\t\tsetHeader()\n\t\t\tsetFooter()\n\t\t\tgetImageRBX()\n\t\t\tgetImageRBY()\n\t\t\tgetCellHeightRatio()\n\t\t\tgetHeaderFont()\n\t\t\tgetFooterFont()\n\t\t\tgetRTL()\n\t\t\tgetBarcode()\n\t\t\tgetHeaderData()\n\t\t\tgetHeaderMargin()\n\t\t\tgetFooterMargin()\n\n4.0.011 (2008-07-23)\n\t- Font support was improved.\n\t- The folder /fonts/utils contains new utilities and instructions for embedd font files.\n\t- Documentation was updated.\n\n4.0.010 (2008-07-22)\n\t- HTML tables were fixed to work across pages.\n\t- Header() and Footer() functions were updated to preserve previous settings.\n\t- example_035.php was added.\n\n4.0.009 (2008-07-21)\n\t- UTF8StringToArray() function was fixed for non-unicode mode.\n\n4.0.008 (2008-07-21)\n\t- Barcodes alignment was fixed (see example_027.php).\n\t- unicode_data.php was updated.\n\t- Arabic shaping for \"Zero-Width Non-Joiner\" character (U+200C) was fixed.\n\n4.0.007 (2008-07-18)\n\t- str_split was replaced by preg_split for compatibility with PHP4 version.\n\t- Clipping mode was added to all graphic functions by using parameter $style = \"CNZ\" or \"CEO\" (see example_034.php).\n\n4.0.006 (2008-07-16)\n\t- HTML rowspan bug was fixed.\n\t- Line style for MultiCell() was fixed.\n\t- WriteHTML() function was improved.\n\t- CODE128C barcode was fixed (barcodes.php).\n\n4.0.005 (2008-07-11)\n\t- Bug [2015715] \"PHP Error/Warning\" was fixed.\n\n4.0.004 (2008-07-09)\n\t- HTML cell internal padding was fixed.\n\n4.0.003 (2008-07-08)\n\t- Removed URL encoding when F option is selected on Output() function.\n\t- fixed some minor bugs in html tables.\n\n4.0.002 (2008-07-07)\n\t- Bug [2000861] was still unfixed and has been fixed.\n\n4.0.001 (2008-07-05)\n\t- Bug [2000861] was fixed.\n\n4.0.000 (2008-07-03)\n\t- THIS IS A MAIN RELEASE THAT INCLUDES SEVERAL NEW FEATURES AND BUGFIXES\n\t- Signature fo SetTextColor() and SetFillColor() functions was changed (parameter $storeprev was removed).\n\t- HTML support was completely rewritten and improved (see example 6).\n\t- Alignments parameters were fixed.\n\t- Functions GetArrStringWidth() and GetStringWidth() now include font parameters.\n\t- Fonts support was improved.\n\t- All core fonts were replaced and moved to fonts/ directory.\n\t- The following functions were added: getMargins(), getFontSize(), getFontSizePt().\n\t- File config/tcpdf_config_old.php was renamed tcpdf_config_alt.php and updated.\n\t- Multicell and WriteHTMLCell fill function was fixed.\n\t- Several minor bugs were fixed.\n\t- barcodes.php was updated.\n\t- All examples were updated.\n\n------------------------------------------------------------\n\n3.1.001 (2008-06-13)\n\t- Bug [1992515] \"K_PATH_FONTS default value wrong\" was fixed.\n\t- Vera font was removed, DejaVu font and Free fonts were updated.\n\t- Image handling was improved.\n\t- All examples were updated.\n\n3.1.000 (2008-06-11)\n\t- setPDFVersion() was added to change the default PDF version (currently 1.7).\n\t- setViewerPreferences() was added to control the way the document is to be presented on the screen or printed (see example 29).\n\t- SetDisplayMode() signature was changed (new options were added).\n\t- LinearGradient(), RadialGradient(), CoonsPatchMesh() functions were added to print various color gradients (see example 30).\n\t- PieSector() function was added to render render pie charts (see example 31).\n\t- ImageEps() was added to display EPS and AI images with limited support (see example 32).\n\t- writeBarcode() function is now depracated, a new write1DBarcode() function was added. The barcode directory was removed and a new barcodes.php file was added.\n\t- The new write1DBarcode() function support more barcodes and do not need the GD library (see example 027). All barcodes are directly written to PDF using graphic functions.\n\t- HTML lists were improved and could be nested (you may now represent trees).\n\t- AddFont() bug was fixed.\n\t- _putfonts() bug was fixed.\n\t- graphics functions were fixed.\n\t- unicode_data.php file was updated (fixed).\n\t- almohanad font was updated.\n\t- example 18 was updated (Farsi and Arabic languages).\n\t- source code cleanup.\n\t- All examples were updated and new examples were added.\n\n3.0.015 (2008-06-06)\n\t- AddPage() function signature is changed to include page format.\n\t- example 28 was added to show page format changes.\n\t- setPageUnit() function was added to change the page units of measure.\n\t- setPageFormat() function was added to change the page format and orientation between pages.\n\t- setPageOrientation() function was added to change the page orientation.\n\t- Arabic font shaping was fixed for laa letter and square boxes (see the example 18).\n\n3.0.014 (2008-06-04)\n\t- Arabic font shaping was fixed.\n\t- setDefaultTableColumns() function was added.\n\t- $cell_height_ratio variable was added.\n\t- setCellHeightRatio() function was added to define the default height of cell repect font height.\n\n3.0.013 (2008-06-03)\n\t- Multicell height parameter was fixed.\n\t- Arabic font shaping was improved.\n\t- unicode_data.php was updated.\n\n3.0.012 (2008-05-30)\n\t- K_PATH_MAIN and K_PATH_URL constants are now automatically set on config file.\n\t- DOCUMENT_ROOT constant was fixed for IIS Webserver (config file was updated).\n\t- Arabic font shaping was improved.\n\t- TranslateY() function was fixed (bug [1977962]).\n\t- setVisibility() function was fixed.\n\t- writeBarcode() function was fixed to scale using $xref parameter.\n\t- All examples were updated.\n\n3.0.011 (2008-05-23)\n\t- CMYK color support was added to all graphic functions.\n\t- HTML table support was improved:\n\t  -- now it's possible to include additional html tags inside a cell;\n\t  -- colspan attribute was added.\n\t- example 006 was updated.\n\n3.0.010 (2008-05-21)\n\t- fixed $laa_array inclusion on utf8Bidi() function.\n\n3.0.009 (2008-05-20)\n\t- unicode_data.php was updated.\n\t- Arabic laa letter problem was fixed.\n\n3.0.008 (2008-05-12)\n\t- Arabic support was fixed and improved (unicode_data.php was updated).\n\t- Polycurve() function was added to draw a poly-Bezier curve.\n\t- list items alignment was fixed.\n\t- example 6 was updated.\n\n3.0.007 (2008-05-06)\n\t- Arabic support was fixed and improved.\n\t- AlMohanad (arabic) font was added.\n\t- C128 barcode bugs were fixed.\n\n3.0.006 (2008-04-21)\n\t- Condition to check negative width values was added.\n\n3.0.005 (2008-04-18)\n\t- back-Slash character escape was fixed on writeHTML() function.\n\t- Exampe 6 was updated.\n\n3.0.004 (2008-04-11)\n\t- Bug [1939304] (Right to Left Issue) was fixed.\n\n3.0.003 (2008-04-07)\n\t- Bug [1934523](Words between HTML tags in cell not kept on one line) was fixed.\n\t- \"face\" attribute of \"font\" tag is now fully supported.\n\n3.0.002 (2008-04-01)\n\t- Write() functions now return the number of cells and not the number of lines.\n\t- TCPDF is released under LGPL 2.1, or any later version.\n\n3.0.001 (2008-05-28)\n\t- _legacyparsejpeg() and _legacyparsepng() were renamed _parsejpeg() and _parsepng().\n\t- function writeBarcode() was fixed.\n\t- all examples were updated.\n\t- example 27 was added to show various barcodes.\n\n3.0.000 (2008-03-27)\n\t- private function pixelsToMillimeters() was changed to public function pixelsToUnits() to fix html image size bug.\n\t- Image-related functions were rewritten.\n\t- resize parameter was added to Image() signature to reduce the image size and fit width and height (see example 9).\n\t- TCPDF now supports all images supported by GD library: GD, GD2, GD2PART, GIF, JPEG, PNG, BMP, XBM, XPM.\n\t- CMYK support was added to SetDrawColor(), SetFillColor(), SetTextColor() (see example 22).\n\t- Page Groups were added (see example 23).\n\t- setVisibility() function was added to restrict the rendering of some elements to screen or printout (see example 24).\n\t- All private variables and functions were changed to protected.\n\t- setAlpha() function was added to give transparency support for all objects (see example 25).\n\t- Clipping and stroke modes were added to Text() function (see example 26).\n\t- All examples were moved to \"examples\" directory.\n\t- function setJPEGQuality() was added to set the JPEG image comrpession (see example 9).\n\n2.9.000 (2008-03-26)\n\t- htmlcolors.php file was added to include html colors.\n\t- Support for HTML color names and three-digit hexadecimal color codes was added.\n\t- private function convertColorHexToDec() was renamed convertHTMLColorToDec().\n\t- color and bgcolor attributes are now supported on all HTML tags (color nesting is also supported).\n\t- Write() function were fixed.\n\t- example_006.php was updated.\n\t- private function setUserRights() was added to release user rights on Acrobat Reader (this allows to display forms, see example 14)\n\n2.8.000 (2008-03-20)\n\t- Private variables were changed to protected.\n\t- Function Write() was fixed and improved.\n\t- Support for dl, dt, dd, del HTML tags was introduced.\n\t- Line-trought mode was added for HTML and text.\n\t- Text vertical alignment on cells were fixed.\n\t- Examples were updated to reflect changes.\n\n2.7.002 (2008-03-13)\n\t- Bug \"[1912142] Encrypted PDF created/modified date\" was fixed.\n\n2.7.001 (2008-03-10)\n\t- Cell justification was fixed for non-unicode mode.\n\n2.7.000 (2008-03-09)\n\t- Cell() stretching mode 4 (forced character spacing) was fixed.\n\t- writeHTMLCell() now uses Multicell() to write.\n\t- Multicell() has a new parameter $ishtml to act as writeHTMLCell().\n\t- Write() speed was improved for non-arabic strings.\n\t- Example n. 20 was changed.\n\n2.6.000 (2008-03-07)\n\t- various alignments bugs were fixed.\n\n2.5.000 (2008-03-07)\n\t- Several bugs were fixed.\n\t- example_019.php was added to test non-unicode mode using old fonts.\n\n2.4.000 (2008-03-06)\n\t- RTL support was deeply improved.\n\t- GetStringWidth() was fixed to support RTL languages.\n\t- Text() RTL alignment was fixed.\n\t- Some functions were added: GetArrStringWidth(), GetCharWidth(), uniord(), utf8Bidi().\n\t- example_018.php was added and test_unicode.php was removed.\n\n2.3.000 (2008-03-05)\n\t- MultiCell() signature is changed. Now support multiple columns across pages (see example_017).\n\t- Write() signature is changed. Now support the cell mode to be used with MultiCell.\n\t- Header() and Footer() were changed.\n\t- The following functions were added: UTF8ArrSubString() and unichr().\n\t- Examples were updated to reflect last changes.\n\n2.2.004 (2008-03-04)\n\t- Several examples were added.\n\t- AddPage() Header() and Footer() were fixed.\n\t- Documentation is now available on http://www.tcpdf.org\n\n2.2.003 (2008-03-03)\n\t- [1894853] Performance of MultiCell() was improved.\n\t- RadioButton and ListBox functions were added.\n\t- javascript form functions were rewritten and properties names are changed. The properties function supported by form fields are listed on Possible values are listed on http://www.adobe.com/devnet/acrobat/pdfs/js_developer_guide.pdf.\n\n2.2.002 (2008-02-28)\n\t- [1900495] html images path was fixed.\n\t- Legacy image functions were reintroduced to allow PNG and JPEG support without GD library.\n\n2.2.001 (2008-02-16)\n\t- The bug \"[1894700] bug with replace relative path\" was fixed\n\t- Justification was fixed\n\n2.2.000 (2008-02-12)\n\t- fixed javascript bug introduced with latest release\n\n2.1.002 (2008-02-12)\n\t- Justify function was fixed on PHP4 version.\n\t- Bookmank function was added ([1578250] Table of contents).\n\t- Javascript and Form fields support was added ([1796359] Form fields).\n\n2.1.001 (2008-02-10)\n\t- The bug \"[1885776] Race Condition in function justitfy\" was fixed.\n\t- The bug \"[1890217] xpdf complains that pdf is incorrect\" was fixed.\n\n2.1.000 (2008-01-07)\n\t- FPDF_FONTPATH constant was changed to K_PATH_FONTS on config file\n\t- Bidirectional Algorithm to correctly reverse bidirectional languages was added.\n\t- SetLeftMargin, SetTopMargin, SetRightMargin functions were fixed.\n\t- SetCellPadding function was added.\n\t- writeHTML was updated with new parameters.\n\t- Text function was fixed.\n\t- MultiCell function was fixed, now works also across multiple pages.\n\t- Line width was fixed on Header and Footer functions and <hr> tag.\n\t- \"GetImageSize\" was renamed \"getimagesize\".\n\t- Document version was changed from 1.3 to 1.5.\n\t- _begindoc() function was fixed.\n\t- ChangeDate was fixed and ModDate was added.\n\t- The following functions were added:\n\t  setPage() : Move pointer to the specified document page.\n\t  getPage() : Get current document page number.\n\t  lastpage() : Reset pointer to the last document page.\n\t  getNumPages() : Get the total number of inserted pages.\n\t  GetNumChars() : count the number of (UTF-8) characters in a string.\n\t- $stretch parameter was added to Cell() function to fit text on cell:\n\t\t\t0 = disabled\n\t\t\t1 = horizontal scaling only if necessary\n\t\t\t2 = forced horizontal scaling\n\t\t\t3 = character spacing only if necessary\n\t\t\t4 = forced character spacing\n\t- Line function was fixed for RTL.\n\t- Graphic transformation functions were added [1811158]:\n\t\t\tStartTransform()\n\t\t\tStopTransform()\n\t\t\tScaleX()\n\t\t\tScaleY()\n\t\t\tScaleXY()\n\t\t\tScale()\n\t\t\tMirrorH()\n\t\t\tMirrorV()\n\t\t\tMirrorP()\n\t\t\tMirrorL()\n\t\t\tTranslateX()\n\t\t\tTranslateY()\n\t\t\tTranslate()\n\t\t\tRotate()\n\t\t\tSkewX()\n\t\t\tSkewY()\n\t\t\tSkew()\n\t- Graphic function were added/updated [1688549]:\n\t\t\tSetLineStyle()\n\t\t\t_outPoint()\n\t\t\t_outLine()\n\t\t\t_outRect()\n\t\t\t_outCurve()\n\t\t\tLine()\n\t\t\tRect()\n\t\t\tCurve\n\t\t\tEllipse\n\t\t\tCircle\n\t\t\tPolygon\n\t\t\tRegularPolygon\n\n2.0.000 (2008-01-04)\n\t- RTL (Right-To-Left) languages support was added. Language direction is set using the $l['a_meta_dir'] setting on /configure/language/xxx.php language files.\n\t- setRTL($enable) method was added to manually enable/disable the RTL text direction.\n\t- The attribute \"dir\" was added to support custom text direction on HTML tags. Possible values are: ltr - for Left-To-Right and RTL for Right-To-Left.\n\t- RC4 40bit encryption was added. Check the SetProtection method.\n\t- [1815213] Improved image support for GIF, JPEG, PNG formats.\n\t- [1800094] Attribute \"value\" was added to ordered list items <li>.\n\t- Image function now has a new \"align\" parameter that indicates the alignment of the pointer next to image insertion and relative to image height. The value can be:\n\t\t\tT: top-right for LTR or top-left for RTL\n\t\t\tM: middle-right for LTR or middle-left for RTL\n\t\t\tB: bottom-right for LTR or bottom-left for RTL\n\t\t\tN: next line\n\t- Attribute \"align\" was added to <img> html tag to set the above image \"align\" parameter. Possible values are:\n\t\t\ttop: top-right for LTR or top-left for RTL\n\t\t\tmiddle: middle-right for LTR or middle-left for RTL\n\t\t\tbottom: bottom-right for LTR or bottom-left for RTL\n\t- [1798103] newline was added after </ul>, </ol> and </p> tages.\n\t- [1816393] Documentation was updated.\n\t- 'ln' parameter was fixed on writeHTMLCell. Now it's possible to print two or more columns across several pages;\n\t- The method lastPage() was added to move the pointer on the last page;\n\n------------------------------------------------------------\n\n1.53.0.TC034 (2007-07-30)\n\t- fixed htmlentities conversion.\n\t- MultiCell() function returns the number of cells.\n\n1.53.0.TC033 (2007-07-30)\n\t- fixed bug 1762550: case sensitive for font files\n\t- NOTE: all fonts files names must be in lowercase!\n\n1.53.0.TC032 (2007-07-27)\n\t- setLastH method was added to resolve bug 1689071.\n\t- all fonts names were converted in lowercase (bug 1713005).\n\t- bug 1740954 was fixed.\n\t- justification was added as Cell option.\n\n1.53.0.TC031 (2007-03-20)\n\t- ToUnicode CMap were added on _puttruetypeunicode function. Now you may search and copy unicode text.\n\n1.53.0.TC030 (2007-03-06)\n\t- fixed bug on PHP4 version.\n\n1.53.0.TC029 (2007-03-06)\n\t- DejaVu Fonts were added.\n\n1.53.0.TC028 (2007-03-03)\n\t- MultiCell function signature were changed: the $ln parameter were added. Check documentation for further information.\n\t- Greek language were added on example sentences.\n\t- setPrintHeader() and setPrintFooter() functions were added to enable or disable page header and footer.\n\n1.53.0.TC027 (2006-12-14)\n\t- $attr['face'] bug were fixed.\n\t- K_TCPDF_EXTERNAL_CONFIG control where introduced on /config/tcpdf_config.php to use external configuration files.\n\n1.53.0.TC026 (2006-10-28)\n\t- writeHTML function call were fixed on examples.\n\n1.53.0.TC025 (2006-10-27)\n\t- Bugs item #1421290 were fixed (0D - 0A substitution in some characters)\n\t- Bugs item #1573174 were fixed (MultiCell documentation)\n\n1.53.0.TC024 (2006-09-26)\n\t- getPageHeight() function were fixed (bug 1543476).\n\t- fixed missing breaks on closedHTMLTagHandler function (bug 1535263).\n\t- fixed extra spaces on Write function (bug 1535262).\n\n1.53.0.TC023 (2006-08-04)\n\t- paths to barcode directory were fixed.\n\t- documentation were updated.\n\n1.53.0.TC022 (2006-07-16)\n\t- fixed bug: [ 1516858 ] Probs with PHP autoloader and class_exists()\n\n1.53.0.TC021 (2006-07-01)\n\t- HTML attributes with whitespaces are now supported (thanks to Nelson Benitez for his support)\n\n1.53.0.TC020 (2006-06-23)\n\t- code cleanup\n\n1.53.0.TC019 (2006-05-21)\n\t- fixed <strong> and <em> closing tags\n\n1.53.0.TC018 (2006-05-18)\n\t- fixed font names bug\n\n1.53.0.TC017 (2006-05-18)\n\t- the TTF2UFM utility to convert True Type fonts for TCPDF were included on fonts folder.\n\t- new free unicode fonts were included on /fonts/freefont.\n\t- test_unicode.php example were exended.\n\t- parameter $fill were added on Write, writeHTML and writeHTMLCell functions.\n\t- documentation were updated.\n\n1.53.0.TC016 (2006-03-09)\n\t- fixed closing <strong> tag on html parser.\n\n1.53.0.TC016 (2005-08-28)\n\t- fpdf.php and tcpdf.php files were joined in one single class (you can still extend TCPDF with your own class).\n\t- fixed problem when mb_internal_encoding is set.\n\n1.53.0.TC014 (2005-05-29)\n\t- fixed WriteHTMLCell new page issue.\n\n1.53.0.TC013 (2005-05-29)\n\t- fixed WriteHTMLCell across pages.\n\n1.53.0.TC012 (2005-05-29)\n\t- font color attribute bug were fixed.\n\n1.53.0.TC011 (2005-03-31)\n\t- SetFont function were fixed (thank Sjaak Lauwers for bug notice).\n\n1.53.0.TC010 (2005-03-22)\n\t- the html functions were improved (thanks to Manfred Vervuert for bug reporting).\n\n1.53.0.TC009 (2005-03-19)\n\t- a wrong reference to convertColorHexToDec were fixed.\n\n1.53.0.TC008 (2005-02-07)\n\t- removed some extra bytes from PHP files.\n\n1.53.0.TC007 (2005-01-08)\n\t- fill attribute were removed from writeHTMLCell method.\n\n1.53.0.TC006 (2005-01-08)\n\t- the documentation were updated.\n\n1.53.0.TC005 (2005-01-05)\n\t- Steven Wittens's unicode methods were removed.\n\t- All unicode methods were rewritten from scratch.\n\t- TCPDF is now licensed as LGPL.\n\n1.53.0.TC004 (2005-01-04)\n\t- this changelog were added.\n\t- removed commercial fonts for licensing issue.\n\t- Bitstream Vera Fonts were added (http://www.bitstream.com/font_rendering/products/dev_fonts/vera.html).\n\t- Now the AddFont and SetFont functions returns the basic font if the styled version do not exist.\n\nEOF --------------------------------------------------------\n"
        },
        {
          "name": "LICENSE.TXT",
          "type": "blob",
          "size": 42.658203125,
          "content": "**********************************************************************\n* TCPDF LICENSE\n**********************************************************************\n\n  TCPDF is free software: you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as\n  published by the Free Software Foundation, either version 3 of the\n  License, or (at your option) any later version.\n  \n  2002-2024 Nicola Asuni - Tecnick.com LTD\n\n**********************************************************************\n**********************************************************************\n\n                   GNU LESSER GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\n  This version of the GNU Lesser General Public License incorporates\nthe terms and conditions of version 3 of the GNU General Public\nLicense, supplemented by the additional permissions listed below.\n\n  0. Additional Definitions.\n\n  As used herein, \"this License\" refers to version 3 of the GNU Lesser\nGeneral Public License, and the \"GNU GPL\" refers to version 3 of the GNU\nGeneral Public License.\n\n  \"The Library\" refers to a covered work governed by this License,\nother than an Application or a Combined Work as defined below.\n\n  An \"Application\" is any work that makes use of an interface provided\nby the Library, but which is not otherwise based on the Library.\nDefining a subclass of a class defined by the Library is deemed a mode\nof using an interface provided by the Library.\n\n  A \"Combined Work\" is a work produced by combining or linking an\nApplication with the Library.  The particular version of the Library\nwith which the Combined Work was made is also called the \"Linked\nVersion\".\n\n  The \"Minimal Corresponding Source\" for a Combined Work means the\nCorresponding Source for the Combined Work, excluding any source code\nfor portions of the Combined Work that, considered in isolation, are\nbased on the Application, and not on the Linked Version.\n\n  The \"Corresponding Application Code\" for a Combined Work means the\nobject code and/or source code for the Application, including any data\nand utility programs needed for reproducing the Combined Work from the\nApplication, but excluding the System Libraries of the Combined Work.\n\n  1. Exception to Section 3 of the GNU GPL.\n\n  You may convey a covered work under sections 3 and 4 of this License\nwithout being bound by section 3 of the GNU GPL.\n\n  2. Conveying Modified Versions.\n\n  If you modify a copy of the Library, and, in your modifications, a\nfacility refers to a function or data to be supplied by an Application\nthat uses the facility (other than as an argument passed when the\nfacility is invoked), then you may convey a copy of the modified\nversion:\n\n   a) under this License, provided that you make a good faith effort to\n   ensure that, in the event an Application does not supply the\n   function or data, the facility still operates, and performs\n   whatever part of its purpose remains meaningful, or\n\n   b) under the GNU GPL, with none of the additional permissions of\n   this License applicable to that copy.\n\n  3. Object Code Incorporating Material from Library Header Files.\n\n  The object code form of an Application may incorporate material from\na header file that is part of the Library.  You may convey such object\ncode under terms of your choice, provided that, if the incorporated\nmaterial is not limited to numerical parameters, data structure\nlayouts and accessors, or small macros, inline functions and templates\n(ten or fewer lines in length), you do both of the following:\n\n   a) Give prominent notice with each copy of the object code that the\n   Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the object code with a copy of the GNU GPL and this license\n   document.\n\n  4. Combined Works.\n\n  You may convey a Combined Work under terms of your choice that,\ntaken together, effectively do not restrict modification of the\nportions of the Library contained in the Combined Work and reverse\nengineering for debugging such modifications, if you also do each of\nthe following:\n\n   a) Give prominent notice with each copy of the Combined Work that\n   the Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the Combined Work with a copy of the GNU GPL and this license\n   document.\n\n   c) For a Combined Work that displays copyright notices during\n   execution, include the copyright notice for the Library among\n   these notices, as well as a reference directing the user to the\n   copies of the GNU GPL and this license document.\n\n   d) Do one of the following:\n\n       0) Convey the Minimal Corresponding Source under the terms of this\n       License, and the Corresponding Application Code in a form\n       suitable for, and under terms that permit, the user to\n       recombine or relink the Application with a modified version of\n       the Linked Version to produce a modified Combined Work, in the\n       manner specified by section 6 of the GNU GPL for conveying\n       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n       Version.\n\n   e) Provide Installation Information, but only if you would otherwise\n   be required to provide such information under section 6 of the\n   GNU GPL, and only to the extent that such information is\n   necessary to install and execute a modified version of the\n   Combined Work produced by recombining or relinking the\n   Application with a modified version of the Linked Version. (If\n   you use option 4d0, the Installation Information must accompany\n   the Minimal Corresponding Source and Corresponding Application\n   Code. If you use option 4d1, you must provide the Installation\n   Information in the manner specified by section 6 of the GNU GPL\n   for conveying Corresponding Source.)\n\n  5. Combined Libraries.\n\n  You may place library facilities that are a work based on the\nLibrary side by side in a single library together with other library\nfacilities that are not Applications and are not covered by this\nLicense, and convey such a combined library under terms of your\nchoice, if you do both of the following:\n\n   a) Accompany the combined library with a copy of the same work based\n   on the Library, uncombined with any other library facilities,\n   conveyed under the terms of this License.\n\n   b) Give prominent notice with the combined library that part of it\n   is a work based on the Library, and explaining where to find the\n   accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n  Each version is given a distinguishing version number. If the\nLibrary as you received it specifies that a certain numbered version\nof the GNU Lesser General Public License \"or any later version\"\napplies to it, you have the option of following the terms and\nconditions either of that published version or of any later version\npublished by the Free Software Foundation. If the Library as you\nreceived it does not specify a version number of the GNU Lesser\nGeneral Public License, you may choose any version of the GNU Lesser\nGeneral Public License ever published by the Free Software Foundation.\n\n  If the Library as you received it specifies that a proxy can decide\nwhether future versions of the GNU Lesser General Public License shall\napply, that proxy's public statement of acceptance of any version is\npermanent authorization for you to choose that version for the\nLibrary.\n\n**********************************************************************\n**********************************************************************\n\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n\n**********************************************************************\n**********************************************************************\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.5078125,
          "content": "# TCPDF\n*PHP PDF Library*\n\n[![Donate via PayPal](https://img.shields.io/badge/donate-paypal-87ceeb.svg)](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&currency_code=GBP&business=paypal@tecnick.com&item_name=donation%20for%20TCPDF%20project)\n*Please consider supporting this project by making a donation via [PayPal](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&currency_code=GBP&business=paypal@tecnick.com&item_name=donation%20for%20TCPDF%20project)*\n\n* **category**    Library\n* **author**      Nicola Asuni <info@tecnick.com>\n* **copyright**   2002-2024 Nicola Asuni - Tecnick.com LTD\n* **license**     http://www.gnu.org/copyleft/lesser.html GNU-LGPL v3 (see LICENSE.TXT)\n* **link**        http://www.tcpdf.org\n* **source**      https://github.com/tecnickcom/TCPDF\n\n\n## NOTE\nA new version of this library is under development at https://github.com/tecnickcom/tc-lib-pdf and as a consequence this library is in support only mode.\n\n\n\n## Description\n\nPHP library for generating PDF documents on-the-fly.\n\n### Main Features:\n* no external libraries are required for the basic functions;\n* all standard page formats, custom page formats, custom margins and units of measure;\n* UTF-8 Unicode and Right-To-Left languages;\n* TrueTypeUnicode, OpenTypeUnicode v1, TrueType, OpenType v1, Type1 and CID-0 fonts;\n* font subsetting;\n* methods to publish some XHTML + CSS code, Javascript and Forms;\n* images, graphic (geometric figures) and transformation methods;\n* supports JPEG, PNG and SVG images natively, all images supported by GD (GD, GD2, GD2PART, GIF, JPEG, PNG, BMP, XBM, XPM) and all images supported via ImagMagick (http://www.imagemagick.org/script/formats.php)\n* 1D and 2D barcodes: CODE 39, ANSI MH10.8M-1983, USD-3, 3 of 9, CODE 93, USS-93, Standard 2 of 5, Interleaved 2 of 5, CODE 128 A/B/C, 2 and 5 Digits UPC-Based Extension, EAN 8, EAN 13, UPC-A, UPC-E, MSI, POSTNET, PLANET, RMS4CC (Royal Mail 4-state Customer Code), CBC (Customer Bar Code), KIX (Klant index - Customer index), Intelligent Mail Barcode, Onecode, USPS-B-3200, CODABAR, CODE 11, PHARMACODE, PHARMACODE TWO-TRACKS, Datamatrix, QR-Code, PDF417;\n* JPEG and PNG ICC profiles, Grayscale, RGB, CMYK, Spot Colors and Transparencies;\n* automatic page header and footer management;\n* document encryption up to 256 bit and digital signature certifications;\n* transactions to UNDO commands;\n* PDF annotations, including links, text and file attachments;\n* text rendering modes (fill, stroke and clipping);\n* multiple columns mode;\n* no-write page regions;\n* bookmarks, named destinations and table of content;\n* text hyphenation;\n* text stretching and spacing (tracking);\n* automatic page break, line break and text alignments including justification;\n* automatic page numbering and page groups;\n* move and delete pages;\n* page compression (requires php-zlib extension);\n* XOBject Templates;\n* Layers and object visibility.\n* PDF/A-1b support.\n\n### Third party fonts:\n\nThis library may include third party font files released with different licenses.\n\nAll the PHP files on the fonts directory are subject to the general TCPDF license (GNU-LGPLv3),\nthey do not contain any binary data but just a description of the general properties of a particular font.\nThese files can be also generated on the fly using the font utilities and TCPDF methods.\n\nAll the original binary TTF font files have been renamed for compatibility with TCPDF and compressed using the gzcompress PHP function that uses the ZLIB data format (.z files).\n\nThe binary files (.z) that begins with the prefix \"free\" have been extracted from the GNU FreeFont collection (GNU-GPLv3).\nThe binary files (.z) that begins with the prefix \"pdfa\" have been derived from the GNU FreeFont, so they are subject to the same license.\nFor the details of Copyright, License and other information, please check the files inside the directory fonts/freefont-20120503\nLink : http://www.gnu.org/software/freefont/\n\nThe binary files (.z) that begins with the prefix \"dejavu\" have been extracted from the DejaVu fonts 2.33 (Bitstream) collection.\nFor the details of Copyright, License and other information, please check the files inside the directory fonts/dejavu-fonts-ttf-2.33\nLink : http://dejavu-fonts.org\n\nThe binary files (.z) that begins with the prefix \"ae\" have been extracted from the Arabeyes.org collection (GNU-GPLv2).\nLink : http://projects.arabeyes.org/\n\n### ICC profile:\n\nTCPDF includes the sRGB.icc profile from the icc-profiles-free Debian package:\nhttps://packages.debian.org/source/stable/icc-profiles-free\n\n\n## Developer(s) Contact\n\n* Nicola Asuni <info@tecnick.com>\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.005859375,
          "content": "6.8.0\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.314453125,
          "content": "{\n    \"name\": \"tecnickcom/tcpdf\",\n    \"type\": \"library\",\n    \"description\": \"TCPDF is a PHP class for generating PDF documents and barcodes.\",\n    \"keywords\": [\n        \"PDF\",\n        \"tcpdf\",\n        \"PDFD32000-2008\",\n        \"qrcode\",\n        \"datamatrix\",\n        \"pdf417\",\n        \"barcodes\"\n    ],\n    \"homepage\": \"http://www.tcpdf.org/\",\n    \"version\": \"6.8.0\",\n    \"license\": \"LGPL-3.0-or-later\",\n    \"authors\": [\n        {\n            \"name\": \"Nicola Asuni\",\n            \"email\": \"info@tecnick.com\",\n            \"role\": \"lead\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=7.1.0\",\n        \"ext-curl\": \"*\"\n    },\n    \"autoload\": {\n        \"classmap\": [\n            \"config\",\n            \"include\",\n            \"tcpdf.php\",\n            \"tcpdf_parser.php\",\n            \"tcpdf_import.php\",\n            \"tcpdf_barcodes_1d.php\",\n            \"tcpdf_barcodes_2d.php\",\n            \"include/tcpdf_colors.php\",\n            \"include/tcpdf_filters.php\",\n            \"include/tcpdf_font_data.php\",\n            \"include/tcpdf_fonts.php\",\n            \"include/tcpdf_images.php\",\n            \"include/tcpdf_static.php\",\n            \"include/barcodes/datamatrix.php\",\n            \"include/barcodes/pdf417.php\",\n            \"include/barcodes/qrcode.php\"\n        ]\n    },\n    \"archive\": {\n        \"exclude\": [\n            \"/examples\"\n        ]\n    }\n}\n"
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fonts",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "phpstan.neon.dist",
          "type": "blob",
          "size": 1.26171875,
          "content": "parameters:\n    level: 1\n    paths:\n        - ./\n    excludePaths:\n        - vendor/\n        - tests/\n\n    scanFiles:\n      - tcpdf_autoconfig.php\n\n    ignoreErrors:\n        - '~^Constant (PDF_HEADER_LOGO|K_PATH_CACHE|K_PATH_FONTS|K_PATH_IMAGES|K_PATH_URL) not found\\.$~'\n        - '~^Constructor of class TCPDF has an unused parameter \\$diskcache\\.$~'\n        - '~^Variable \\$\\w+ might not be defined\\.$~'\n        - '~^Method TCPDF(_FILTERS)?::\\w+\\(\\) should return .+ but return statement is missing\\.$~'\n\n        # mcrypt does not support PHP 7.2 or later\n        -\n            message: '~^(Constant MCRYPT_RIJNDAEL_128 not found\\.|Function mcrypt_get_cipher_name not found\\.)$~'\n            path: tcpdf.php\n            count: 2\n        -\n            message: '~^(Constant (MCRYPT_ARCFOUR|MCRYPT_MODE_CBC|MCRYPT_MODE_STREAM|MCRYPT_RAND|MCRYPT_RIJNDAEL_128) not found\\.|Function (mcrypt_create_iv|mcrypt_encrypt|mcrypt_get_iv_size) not found\\.)$~'\n            path: include/tcpdf_static.php\n            count: 16\n\n        -\n            message: '~^(Call to static method create\\(\\) on an unknown class Symfony\\\\Component\\\\Finder\\\\Finder\\.|Instantiated class Doctum\\\\(Doctum|RemoteRepository\\\\GitHubRemoteRepository) not found\\.)$~'\n            path: scripts/doctum.php\n            count: 3\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "tcpdf.php",
          "type": "blob",
          "size": 885.986328125,
          "content": "<?php\n//============================================================+\n// File name   : tcpdf.php\n// Version     : 6.8.0\n// Begin       : 2002-08-03\n// Last Update : 2024-12-23\n// Author      : Nicola Asuni - Tecnick.com LTD - www.tecnick.com - info@tecnick.com\n// License     : GNU-LGPL v3 (http://www.gnu.org/copyleft/lesser.html)\n// -------------------------------------------------------------------\n// Copyright (C) 2002-2024 Nicola Asuni - Tecnick.com LTD\n//\n// This file is part of TCPDF software library.\n//\n// TCPDF is free software: you can redistribute it and/or modify it\n// under the terms of the GNU Lesser General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n//\n// TCPDF is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the License\n// along with TCPDF. If not, see\n// <http://www.tecnick.com/pagefiles/tcpdf/LICENSE.TXT>.\n//\n// See LICENSE.TXT file for more information.\n// -------------------------------------------------------------------\n//\n// Description :\n//   This is a PHP class for generating PDF documents without requiring external extensions.\n//\n// NOTE:\n//   This class was originally derived in 2002 from the Public\n//   Domain FPDF class by Olivier Plathey (http://www.fpdf.org),\n//   but now is almost entirely rewritten and contains thousands of\n//   new lines of code and hundreds new features.\n//\n// Main features:\n//  * no external libraries are required for the basic functions;\n//  * all standard page formats, custom page formats, custom margins and units of measure;\n//  * UTF-8 Unicode and Right-To-Left languages;\n//  * TrueTypeUnicode, TrueType, Type1 and CID-0 fonts;\n//  * font subsetting;\n//  * methods to publish some XHTML + CSS code, Javascript and Forms;\n//  * images, graphic (geometric figures) and transformation methods;\n//  * supports JPEG, PNG and SVG images natively, all images supported by GD (GD, GD2, GD2PART, GIF, JPEG, PNG, BMP, XBM, XPM) and all images supported via ImageMagick (http://www.imagemagick.org/www/formats.html)\n//  * 1D and 2D barcodes: CODE 39, ANSI MH10.8M-1983, USD-3, 3 of 9, CODE 93, USS-93, Standard 2 of 5, Interleaved 2 of 5, CODE 128 A/B/C, 2 and 5 Digits UPC-Based Extension, EAN 8, EAN 13, UPC-A, UPC-E, MSI, POSTNET, PLANET, RMS4CC (Royal Mail 4-state Customer Code), CBC (Customer Bar Code), KIX (Klant index - Customer index), Intelligent Mail Barcode, Onecode, USPS-B-3200, CODABAR, CODE 11, PHARMACODE, PHARMACODE TWO-TRACKS, Datamatrix, QR-Code, PDF417;\n//  * JPEG and PNG ICC profiles, Grayscale, RGB, CMYK, Spot Colors and Transparencies;\n//  * automatic page header and footer management;\n//  * document encryption up to 256 bit and digital signature certifications;\n//  * transactions to UNDO commands;\n//  * PDF annotations, including links, text and file attachments;\n//  * text rendering modes (fill, stroke and clipping);\n//  * multiple columns mode;\n//  * no-write page regions;\n//  * bookmarks, named destinations and table of content;\n//  * text hyphenation;\n//  * text stretching and spacing (tracking);\n//  * automatic page break, line break and text alignments including justification;\n//  * automatic page numbering and page groups;\n//  * move and delete pages;\n//  * page compression (requires php-zlib extension);\n//  * XOBject Templates;\n//  * Layers and object visibility.\n//\t* PDF/A-1b support\n//============================================================+\n\n/**\n * @file\n * This is a PHP class for generating PDF documents without requiring external extensions.<br>\n * TCPDF project (http://www.tcpdf.org) was originally derived in 2002 from the Public Domain FPDF class by Olivier Plathey (http://www.fpdf.org), but now is almost entirely rewritten.<br>\n * <h3>TCPDF main features are:</h3>\n * <ul>\n * <li>no external libraries are required for the basic functions;</li>\n * <li>all standard page formats, custom page formats, custom margins and units of measure;</li>\n * <li>UTF-8 Unicode and Right-To-Left languages;</li>\n * <li>TrueTypeUnicode, TrueType, Type1 and CID-0 fonts;</li>\n * <li>font subsetting;</li>\n * <li>methods to publish some XHTML + CSS code, Javascript and Forms;</li>\n * <li>images, graphic (geometric figures) and transformation methods;\n * <li>supports JPEG, PNG and SVG images natively, all images supported by GD (GD, GD2, GD2PART, GIF, JPEG, PNG, BMP, XBM, XPM) and all images supported via ImageMagick (http://www.imagemagick.org/www/formats.html)</li>\n * <li>1D and 2D barcodes: CODE 39, ANSI MH10.8M-1983, USD-3, 3 of 9, CODE 93, USS-93, Standard 2 of 5, Interleaved 2 of 5, CODE 128 A/B/C, 2 and 5 Digits UPC-Based Extension, EAN 8, EAN 13, UPC-A, UPC-E, MSI, POSTNET, PLANET, RMS4CC (Royal Mail 4-state Customer Code), CBC (Customer Bar Code), KIX (Klant index - Customer index), Intelligent Mail Barcode, Onecode, USPS-B-3200, CODABAR, CODE 11, PHARMACODE, PHARMACODE TWO-TRACKS, Datamatrix, QR-Code, PDF417;</li>\n * <li>JPEG and PNG ICC profiles, Grayscale, RGB, CMYK, Spot Colors and Transparencies;</li>\n * <li>automatic page header and footer management;</li>\n * <li>document encryption up to 256 bit and digital signature certifications;</li>\n * <li>transactions to UNDO commands;</li>\n * <li>PDF annotations, including links, text and file attachments;</li>\n * <li>text rendering modes (fill, stroke and clipping);</li>\n * <li>multiple columns mode;</li>\n * <li>no-write page regions;</li>\n * <li>bookmarks, named destinations and table of content;</li>\n * <li>text hyphenation;</li>\n * <li>text stretching and spacing (tracking);</li>\n * <li>automatic page break, line break and text alignments including justification;</li>\n * <li>automatic page numbering and page groups;</li>\n * <li>move and delete pages;</li>\n * <li>page compression (requires php-zlib extension);</li>\n * <li>XOBject Templates;</li>\n * <li>Layers and object visibility;</li>\n * <li>PDF/A-1b support.</li>\n * </ul>\n * Tools to encode your unicode fonts are on fonts/utils directory.</p>\n * @package com.tecnick.tcpdf\n * @author Nicola Asuni\n * @version 6.8.0\n */\n\n// TCPDF configuration\nrequire_once(dirname(__FILE__).'/tcpdf_autoconfig.php');\n// TCPDF static font methods and data\nrequire_once(dirname(__FILE__).'/include/tcpdf_font_data.php');\n// TCPDF static font methods and data\nrequire_once(dirname(__FILE__).'/include/tcpdf_fonts.php');\n// TCPDF static color methods and data\nrequire_once(dirname(__FILE__).'/include/tcpdf_colors.php');\n// TCPDF static image methods and data\nrequire_once(dirname(__FILE__).'/include/tcpdf_images.php');\n// TCPDF static methods and data\nrequire_once(dirname(__FILE__).'/include/tcpdf_static.php');\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * @class TCPDF\n * PHP class for generating PDF documents without requiring external extensions.\n * TCPDF project (http://www.tcpdf.org) has been originally derived in 2002 from the Public Domain FPDF class by Olivier Plathey (http://www.fpdf.org), but now is almost entirely rewritten.<br>\n * @package com.tecnick.tcpdf\n * @brief PHP class for generating PDF documents without requiring external extensions.\n * @version 6.8.0\n * @author Nicola Asuni - info@tecnick.com\n * @IgnoreAnnotation(\"protected\")\n * @IgnoreAnnotation(\"public\")\n * @IgnoreAnnotation(\"pre\")\n */\nclass TCPDF {\n\n\t// Protected properties\n\n\t/**\n\t * Current page number.\n\t * @protected\n\t */\n\tprotected $page;\n\n\t/**\n\t * Current object number.\n\t * @protected\n\t */\n\tprotected $n;\n\n\t/**\n\t * Array of object offsets.\n\t * @protected\n\t */\n\tprotected $offsets = array();\n\n\t/**\n\t * Array of object IDs for each page.\n\t * @protected\n\t */\n\tprotected $pageobjects = array();\n\n\t/**\n\t * Buffer holding in-memory PDF.\n\t * @protected\n\t */\n\tprotected $buffer;\n\n\t/**\n\t * Array containing pages.\n\t * @protected\n\t */\n\tprotected $pages = array();\n\n\t/**\n\t * Current document state.\n\t * @protected\n\t */\n\tprotected $state;\n\n\t/**\n\t * Compression flag.\n\t * @protected\n\t */\n\tprotected $compress;\n\n\t/**\n\t * Current page orientation (P = Portrait, L = Landscape).\n\t * @protected\n\t */\n\tprotected $CurOrientation;\n\n\t/**\n\t * Page dimensions.\n\t * @protected\n\t */\n\tprotected $pagedim = array();\n\n\t/**\n\t * Scale factor (number of points in user unit).\n\t * @protected\n\t */\n\tprotected $k;\n\n\t/**\n\t * Width of page format in points.\n\t * @protected\n\t */\n\tprotected $fwPt;\n\n\t/**\n\t * Height of page format in points.\n\t * @protected\n\t */\n\tprotected $fhPt;\n\n\t/**\n\t * Current width of page in points.\n\t * @protected\n\t */\n\tprotected $wPt;\n\n\t/**\n\t * Current height of page in points.\n\t * @protected\n\t */\n\tprotected $hPt;\n\n\t/**\n\t * Current width of page in user unit.\n\t * @protected\n\t */\n\tprotected $w;\n\n\t/**\n\t * Current height of page in user unit.\n\t * @protected\n\t */\n\tprotected $h;\n\n\t/**\n\t * Left margin.\n\t * @protected\n\t */\n\tprotected $lMargin;\n\n\t/**\n\t * Right margin.\n\t * @protected\n\t */\n\tprotected $rMargin;\n\n\t/**\n\t * Cell left margin (used by regions).\n\t * @protected\n\t */\n\tprotected $clMargin;\n\n\t/**\n\t * Cell right margin (used by regions).\n\t * @protected\n\t */\n\tprotected $crMargin;\n\n\t/**\n\t * Top margin.\n\t * @protected\n\t */\n\tprotected $tMargin;\n\n\t/**\n\t * Page break margin.\n\t * @protected\n\t */\n\tprotected $bMargin;\n\n\t/**\n\t * Array of cell internal paddings ('T' => top, 'R' => right, 'B' => bottom, 'L' => left).\n\t * @since 5.9.000 (2010-10-03)\n\t * @protected\n\t */\n\tprotected $cell_padding = array('T' => 0, 'R' => 0, 'B' => 0, 'L' => 0);\n\n\t/**\n\t * Array of cell margins ('T' => top, 'R' => right, 'B' => bottom, 'L' => left).\n\t * @since 5.9.000 (2010-10-04)\n\t * @protected\n\t */\n\tprotected $cell_margin = array('T' => 0, 'R' => 0, 'B' => 0, 'L' => 0);\n\n\t/**\n\t * Current horizontal position in user unit for cell positioning.\n\t * @protected\n\t */\n\tprotected $x;\n\n\t/**\n\t * Current vertical position in user unit for cell positioning.\n\t * @protected\n\t */\n\tprotected $y;\n\n\t/**\n\t * Height of last cell printed.\n\t * @protected\n\t */\n\tprotected $lasth;\n\n\t/**\n\t * Line width in user unit.\n\t * @protected\n\t */\n\tprotected $LineWidth;\n\n\t/**\n\t * Array of standard font names.\n\t * @protected\n\t */\n\tprotected $CoreFonts;\n\n\t/**\n\t * Array of used fonts.\n\t * @protected\n\t */\n\tprotected $fonts = array();\n\n\t/**\n\t * Array of font files.\n\t * @protected\n\t */\n\tprotected $FontFiles = array();\n\n\t/**\n\t * Array of encoding differences.\n\t * @protected\n\t */\n\tprotected $diffs = array();\n\n\t/**\n\t * Array of used images.\n\t * @protected\n\t */\n\tprotected $images = array();\n\n\t/**\n\t * Depth of the svg tag, to keep track if the svg tag is a subtag or the root tag.\n\t * @protected\n\t */\n\tprotected $svg_tag_depth = 0;\n\n\t/**\n\t * Array of Annotations in pages.\n\t * @protected\n\t */\n\tprotected $PageAnnots = array();\n\n\t/**\n\t * Array of internal links.\n\t * @protected\n\t */\n\tprotected $links = array();\n\n\t/**\n\t * Current font family.\n\t * @protected\n\t */\n\tprotected $FontFamily;\n\n\t/**\n\t * Current font style.\n\t * @protected\n\t */\n\tprotected $FontStyle;\n\n\t/**\n\t * Current font ascent (distance between font top and baseline).\n\t * @protected\n\t * @since 2.8.000 (2007-03-29)\n\t */\n\tprotected $FontAscent;\n\n\t/**\n\t * Current font descent (distance between font bottom and baseline).\n\t * @protected\n\t * @since 2.8.000 (2007-03-29)\n\t */\n\tprotected $FontDescent;\n\n\t/**\n\t * Underlining flag.\n\t * @protected\n\t */\n\tprotected $underline;\n\n\t/**\n\t * Overlining flag.\n\t * @protected\n\t */\n\tprotected $overline;\n\n\t/**\n\t * Current font info.\n\t * @protected\n\t */\n\tprotected $CurrentFont;\n\n\t/**\n\t * Current font size in points.\n\t * @protected\n\t */\n\tprotected $FontSizePt;\n\n\t/**\n\t * Current font size in user unit.\n\t * @protected\n\t */\n\tprotected $FontSize;\n\n\t/**\n\t * Commands for drawing color.\n\t * @protected\n\t */\n\tprotected $DrawColor;\n\n\t/**\n\t * Commands for filling color.\n\t * @protected\n\t */\n\tprotected $FillColor;\n\n\t/**\n\t * Commands for text color.\n\t * @protected\n\t */\n\tprotected $TextColor;\n\n\t/**\n\t * Indicates whether fill and text colors are different.\n\t * @protected\n\t */\n\tprotected $ColorFlag;\n\n\t/**\n\t * Automatic page breaking.\n\t * @protected\n\t */\n\tprotected $AutoPageBreak;\n\n\t/**\n\t * Threshold used to trigger page breaks.\n\t * @protected\n\t */\n\tprotected $PageBreakTrigger;\n\n\t/**\n\t * Flag set when processing page header.\n\t * @protected\n\t */\n\tprotected $InHeader = false;\n\n\t/**\n\t * Flag set when processing page footer.\n\t * @protected\n\t */\n\tprotected $InFooter = false;\n\n\t/**\n\t * Zoom display mode.\n\t * @protected\n\t */\n\tprotected $ZoomMode;\n\n\t/**\n\t * Layout display mode.\n\t * @protected\n\t */\n\tprotected $LayoutMode;\n\n\t/**\n\t * If true set the document information dictionary in Unicode.\n\t * @protected\n\t */\n\tprotected $docinfounicode = true;\n\n\t/**\n\t * Document title.\n\t * @protected\n\t */\n\tprotected $title = '';\n\n\t/**\n\t * Document subject.\n\t * @protected\n\t */\n\tprotected $subject = '';\n\n\t/**\n\t * Document author.\n\t * @protected\n\t */\n\tprotected $author = '';\n\n\t/**\n\t * Document keywords.\n\t * @protected\n\t */\n\tprotected $keywords = '';\n\n\t/**\n\t * Document creator.\n\t * @protected\n\t */\n\tprotected $creator = '';\n\n\t/**\n\t * Starting page number.\n\t * @protected\n\t */\n\tprotected $starting_page_number = 1;\n\n\t/**\n\t * The right-bottom (or left-bottom for RTL) corner X coordinate of last inserted image.\n\t * @since 2002-07-31\n\t * @author Nicola Asuni\n\t * @protected\n\t */\n\tprotected $img_rb_x;\n\n\t/**\n\t * The right-bottom corner Y coordinate of last inserted image.\n\t * @since 2002-07-31\n\t * @author Nicola Asuni\n\t * @protected\n\t */\n\tprotected $img_rb_y;\n\n\t/**\n\t * Adjusting factor to convert pixels to user units.\n\t * @since 2004-06-14\n\t * @author Nicola Asuni\n\t * @protected\n\t */\n\tprotected $imgscale = 1;\n\n\t/**\n\t * Boolean flag set to true when the input text is unicode (require unicode fonts).\n\t * @since 2005-01-02\n\t * @author Nicola Asuni\n\t * @protected\n\t */\n\tprotected $isunicode = false;\n\n\t/**\n\t * PDF version.\n\t * @since 1.5.3\n\t * @protected\n\t */\n\tprotected $PDFVersion = '1.7';\n\n\t/**\n\t * ID of the stored default header template (-1 = not set).\n\t * @protected\n\t */\n\tprotected $header_xobjid = false;\n\n\t/**\n\t * If true reset the Header Xobject template at each page\n\t * @protected\n\t */\n\tprotected $header_xobj_autoreset = false;\n\n\t/**\n\t * Minimum distance between header and top page margin.\n\t * @protected\n\t * @var float\n\t */\n\tprotected $header_margin;\n\n\t/**\n\t * Minimum distance between footer and bottom page margin.\n\t * @protected\n\t * @var float\n\t */\n\tprotected $footer_margin;\n\n\t/**\n\t * Original left margin value.\n\t * @protected\n\t * @since 1.53.0.TC013\n\t */\n\tprotected $original_lMargin;\n\n\t/**\n\t * Original right margin value.\n\t * @protected\n\t * @since 1.53.0.TC013\n\t */\n\tprotected $original_rMargin;\n\n\t/**\n\t * Default font used on page header.\n\t * @protected\n\t * @var array<int,string|float|null>\n\t * @phpstan-var array{0: string, 1: string, 2: float|null}\n\t */\n\tprotected $header_font;\n\n\t/**\n\t * Default font used on page footer.\n\t * @protected\n\t * @var array<int,string|float|null>\n\t * @phpstan-var array{0: string, 1: string, 2: float|null}\n\t */\n\tprotected $footer_font;\n\n\t/**\n\t * Language templates.\n\t * @protected\n\t */\n\tprotected $l;\n\n\t/**\n\t * Barcode to print on page footer (only if set).\n\t * @protected\n\t */\n\tprotected $barcode = false;\n\n\t/**\n\t * Boolean flag to print/hide page header.\n\t * @protected\n\t */\n\tprotected $print_header = true;\n\n\t/**\n\t * Boolean flag to print/hide page footer.\n\t * @protected\n\t */\n\tprotected $print_footer = true;\n\n\t/**\n\t * Header image logo.\n\t * @protected\n\t */\n\tprotected $header_logo = '';\n\n\t/**\n\t * Width of header image logo in user units.\n\t * @protected\n\t */\n\tprotected $header_logo_width = 30;\n\n\t/**\n\t * Title to be printed on default page header.\n\t * @protected\n\t */\n\tprotected $header_title = '';\n\n\t/**\n\t * String to print on page header after title.\n\t * @protected\n\t */\n\tprotected $header_string = '';\n\n\t/**\n\t * Color for header text (RGB array).\n\t * @since 5.9.174 (2012-07-25)\n\t * @protected\n\t * @var int[]\n\t * @phpstan-var array{0: int, 1: int, 2: int}\n\t */\n\tprotected $header_text_color = array(0,0,0);\n\n\t/**\n\t * Color for header line (RGB array).\n\t * @since 5.9.174 (2012-07-25)\n\t * @protected\n\t * @var int[]\n\t * @phpstan-var array{0: int, 1: int, 2: int}\n\t */\n\tprotected $header_line_color = array(0,0,0);\n\n\t/**\n\t * Color for footer text (RGB array).\n\t * @since 5.9.174 (2012-07-25)\n\t * @protected\n\t * @var int[]\n\t * @phpstan-var array{0: int, 1: int, 2: int}\n\t */\n\tprotected $footer_text_color = array(0,0,0);\n\n\t/**\n\t * Color for footer line (RGB array).\n\t * @since 5.9.174 (2012-07-25)\n\t * @protected\n\t * @var int[]\n\t * @phpstan-var array{0: int, 1: int, 2: int}\n\t */\n\tprotected $footer_line_color = array(0,0,0);\n\n\t/**\n\t * Text shadow data array.\n\t * @since 5.9.174 (2012-07-25)\n\t * @protected\n\t */\n\tprotected $txtshadow = array('enabled'=>false, 'depth_w'=>0, 'depth_h'=>0, 'color'=>false, 'opacity'=>1, 'blend_mode'=>'Normal');\n\n\t/**\n\t * Default number of columns for html table.\n\t * @protected\n\t */\n\tprotected $default_table_columns = 4;\n\n\t// variables for html parser\n\n\t/**\n\t * HTML PARSER: array to store current link and rendering styles.\n\t * @protected\n\t */\n\tprotected $HREF = array();\n\n\t/**\n\t * List of available fonts on filesystem.\n\t * @protected\n\t */\n\tprotected $fontlist = array();\n\n\t/**\n\t * Current foreground color.\n\t * @protected\n\t */\n\tprotected $fgcolor;\n\n\t/**\n\t * HTML PARSER: array of boolean values, true in case of ordered list (OL), false otherwise.\n\t * @protected\n\t */\n\tprotected $listordered = array();\n\n\t/**\n\t * HTML PARSER: array count list items on nested lists.\n\t * @protected\n\t */\n\tprotected $listcount = array();\n\n\t/**\n\t * HTML PARSER: current list nesting level.\n\t * @protected\n\t */\n\tprotected $listnum = 0;\n\n\t/**\n\t * HTML PARSER: indent amount for lists.\n\t * @protected\n\t */\n\tprotected $listindent = 0;\n\n\t/**\n\t * HTML PARSER: current list indententation level.\n\t * @protected\n\t */\n\tprotected $listindentlevel = 0;\n\n\t/**\n\t * Current background color.\n\t * @protected\n\t */\n\tprotected $bgcolor;\n\n\t/**\n\t * Temporary font size in points.\n\t * @protected\n\t */\n\tprotected $tempfontsize = 10;\n\n\t/**\n\t * Spacer string for LI tags.\n\t * @protected\n\t */\n\tprotected $lispacer = '';\n\n\t/**\n\t * Default encoding.\n\t * @protected\n\t * @since 1.53.0.TC010\n\t */\n\tprotected $encoding = 'UTF-8';\n\n\t/**\n\t * Boolean flag to indicate if the document language is Right-To-Left.\n\t * @protected\n\t * @since 2.0.000\n\t */\n\tprotected $rtl = false;\n\n\t/**\n\t * Boolean flag used to force RTL or LTR string direction.\n\t * @protected\n\t * @since 2.0.000\n\t */\n\tprotected $tmprtl = false;\n\n\t// --- Variables used for document encryption:\n\n\t/**\n\t * IBoolean flag indicating whether document is protected.\n\t * @protected\n\t * @since 2.0.000 (2008-01-02)\n\t */\n\tprotected $encrypted;\n\n\t/**\n\t * Array containing encryption settings.\n\t * @protected\n\t * @since 5.0.005 (2010-05-11)\n\t */\n\tprotected $encryptdata = array();\n\n\t/**\n\t * Last RC4 key encrypted (cached for optimisation).\n\t * @protected\n\t * @since 2.0.000 (2008-01-02)\n\t */\n\tprotected $last_enc_key;\n\n\t/**\n\t * Last RC4 computed key.\n\t * @protected\n\t * @since 2.0.000 (2008-01-02)\n\t */\n\tprotected $last_enc_key_c;\n\n\t/**\n\t * File ID (used on document trailer).\n\t * @protected\n\t * @since 5.0.005 (2010-05-12)\n\t */\n\tprotected $file_id;\n\n\t/**\n\t * Internal secret used to encrypt data.\n\t * @protected\n\t * @since 6.7.5 (2024-03-21)\n\t */\n\tprotected $hash_key;\n\n\t// --- bookmark ---\n\n\t/**\n\t * Outlines for bookmark.\n\t * @protected\n\t * @since 2.1.002 (2008-02-12)\n\t */\n\tprotected $outlines = array();\n\n\t/**\n\t * Outline root for bookmark.\n\t * @protected\n\t * @since 2.1.002 (2008-02-12)\n\t */\n\tprotected $OutlineRoot;\n\n\t// --- javascript and form ---\n\n\t/**\n\t * Javascript code.\n\t * @protected\n\t * @since 2.1.002 (2008-02-12)\n\t */\n\tprotected $javascript = '';\n\n\t/**\n\t * Javascript counter.\n\t * @protected\n\t * @since 2.1.002 (2008-02-12)\n\t */\n\tprotected $n_js;\n\n\t/**\n\t * line through state\n\t * @protected\n\t * @since 2.8.000 (2008-03-19)\n\t */\n\tprotected $linethrough;\n\n\t/**\n\t * Array with additional document-wide usage rights for the document.\n\t * @protected\n\t * @since 5.8.014 (2010-08-23)\n\t */\n\tprotected $ur = array();\n\n\t/**\n\t * DPI (Dot Per Inch) Document Resolution (do not change).\n\t * @protected\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tprotected $dpi = 72;\n\n\t/**\n\t * Array of page numbers were a new page group was started (the page numbers are the keys of the array).\n\t * @protected\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tprotected $newpagegroup = array();\n\n\t/**\n\t * Array that contains the number of pages in each page group.\n\t * @protected\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tprotected $pagegroups = array();\n\n\t/**\n\t * Current page group number.\n\t * @protected\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tprotected $currpagegroup = 0;\n\n\t/**\n\t * Array of transparency objects and parameters.\n\t * @protected\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tprotected $extgstates;\n\n\t/**\n\t * Set the default JPEG compression quality (1-100).\n\t * @protected\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tprotected $jpeg_quality;\n\n\t/**\n\t * Default cell height ratio.\n\t * @protected\n\t * @since 3.0.014 (2008-05-23)\n\t * @var float\n\t */\n\tprotected $cell_height_ratio = K_CELL_HEIGHT_RATIO;\n\n\t/**\n\t * PDF viewer preferences.\n\t * @protected\n\t * @since 3.1.000 (2008-06-09)\n\t */\n\tprotected $viewer_preferences;\n\n\t/**\n\t * A name object specifying how the document should be displayed when opened.\n\t * @protected\n\t * @since 3.1.000 (2008-06-09)\n\t */\n\tprotected $PageMode;\n\n\t/**\n\t * Array for storing gradient information.\n\t * @protected\n\t * @since 3.1.000 (2008-06-09)\n\t */\n\tprotected $gradients = array();\n\n\t/**\n\t * Array used to store positions inside the pages buffer (keys are the page numbers).\n\t * @protected\n\t * @since 3.2.000 (2008-06-26)\n\t */\n\tprotected $intmrk = array();\n\n\t/**\n\t * Array used to store positions inside the pages buffer (keys are the page numbers).\n\t * @protected\n\t * @since 5.7.000 (2010-08-03)\n\t */\n\tprotected $bordermrk = array();\n\n\t/**\n\t * Array used to store page positions to track empty pages (keys are the page numbers).\n\t * @protected\n\t * @since 5.8.007 (2010-08-18)\n\t */\n\tprotected $emptypagemrk = array();\n\n\t/**\n\t * Array used to store content positions inside the pages buffer (keys are the page numbers).\n\t * @protected\n\t * @since 4.6.021 (2009-07-20)\n\t */\n\tprotected $cntmrk = array();\n\n\t/**\n\t * Array used to store footer positions of each page.\n\t * @protected\n\t * @since 3.2.000 (2008-07-01)\n\t */\n\tprotected $footerpos = array();\n\n\t/**\n\t * Array used to store footer length of each page.\n\t * @protected\n\t * @since 4.0.014 (2008-07-29)\n\t */\n\tprotected $footerlen = array();\n\n\t/**\n\t * Boolean flag to indicate if a new line is created.\n\t * @protected\n\t * @since 3.2.000 (2008-07-01)\n\t */\n\tprotected $newline = true;\n\n\t/**\n\t * End position of the latest inserted line.\n\t * @protected\n\t * @since 3.2.000 (2008-07-01)\n\t */\n\tprotected $endlinex = 0;\n\n\t/**\n\t * PDF string for width value of the last line.\n\t * @protected\n\t * @since 4.0.006 (2008-07-16)\n\t */\n\tprotected $linestyleWidth = '';\n\n\t/**\n\t * PDF string for CAP value of the last line.\n\t * @protected\n\t * @since 4.0.006 (2008-07-16)\n\t */\n\tprotected $linestyleCap = '0 J';\n\n\t/**\n\t * PDF string for join value of the last line.\n\t * @protected\n\t * @since 4.0.006 (2008-07-16)\n\t */\n\tprotected $linestyleJoin = '0 j';\n\n\t/**\n\t * PDF string for dash value of the last line.\n\t * @protected\n\t * @since 4.0.006 (2008-07-16)\n\t */\n\tprotected $linestyleDash = '[] 0 d';\n\n\t/**\n\t * Boolean flag to indicate if marked-content sequence is open.\n\t * @protected\n\t * @since 4.0.013 (2008-07-28)\n\t */\n\tprotected $openMarkedContent = false;\n\n\t/**\n\t * Count the latest inserted vertical spaces on HTML.\n\t * @protected\n\t * @since 4.0.021 (2008-08-24)\n\t */\n\tprotected $htmlvspace = 0;\n\n\t/**\n\t * Array of Spot colors.\n\t * @protected\n\t * @since 4.0.024 (2008-09-12)\n\t */\n\tprotected $spot_colors = array();\n\n\t/**\n\t * Symbol used for HTML unordered list items.\n\t * @protected\n\t * @since 4.0.028 (2008-09-26)\n\t */\n\tprotected $lisymbol = '';\n\n\t/**\n\t * String used to mark the beginning and end of EPS image blocks.\n\t * @protected\n\t * @since 4.1.000 (2008-10-18)\n\t */\n\tprotected $epsmarker = 'x#!#EPS#!#x';\n\n\t/**\n\t * Array of transformation matrix.\n\t * @protected\n\t * @since 4.2.000 (2008-10-29)\n\t */\n\tprotected $transfmatrix = array();\n\n\t/**\n\t * Current key for transformation matrix.\n\t * @protected\n\t * @since 4.8.005 (2009-09-17)\n\t */\n\tprotected $transfmatrix_key = 0;\n\n\t/**\n\t * Booklet mode for double-sided pages.\n\t * @protected\n\t * @since 4.2.000 (2008-10-29)\n\t */\n\tprotected $booklet = false;\n\n\t/**\n\t * Epsilon value used for float calculations.\n\t * @protected\n\t * @since 4.2.000 (2008-10-29)\n\t */\n\tprotected $feps = 0.005;\n\n\t/**\n\t * Array used for custom vertical spaces for HTML tags.\n\t * @protected\n\t * @since 4.2.001 (2008-10-30)\n\t */\n\tprotected $tagvspaces = array();\n\n\t/**\n\t * HTML PARSER: custom indent amount for lists. Negative value means disabled.\n\t * @protected\n\t * @since 4.2.007 (2008-11-12)\n\t */\n\tprotected $customlistindent = -1;\n\n\t/**\n\t * Boolean flag to indicate if the border of the cell sides that cross the page should be removed.\n\t * @protected\n\t * @since 4.2.010 (2008-11-14)\n\t */\n\tprotected $opencell = true;\n\n\t/**\n\t * Array of files to embedd.\n\t * @protected\n\t * @since 4.4.000 (2008-12-07)\n\t */\n\tprotected $embeddedfiles = array();\n\n\t/**\n\t * Boolean flag to indicate if we are inside a PRE tag.\n\t * @protected\n\t * @since 4.4.001 (2008-12-08)\n\t */\n\tprotected $premode = false;\n\n\t/**\n\t * Array used to store positions of graphics transformation blocks inside the page buffer.\n\t * keys are the page numbers\n\t * @protected\n\t * @since 4.4.002 (2008-12-09)\n\t */\n\tprotected $transfmrk = array();\n\n\t/**\n\t * Default color for html links.\n\t * @protected\n\t * @since 4.4.003 (2008-12-09)\n\t */\n\tprotected $htmlLinkColorArray = array(0, 0, 255);\n\n\t/**\n\t * Default font style to add to html links.\n\t * @protected\n\t * @since 4.4.003 (2008-12-09)\n\t */\n\tprotected $htmlLinkFontStyle = 'U';\n\n\t/**\n\t * Counts the number of pages.\n\t * @protected\n\t * @since 4.5.000 (2008-12-31)\n\t */\n\tprotected $numpages = 0;\n\n\t/**\n\t * Array containing page lengths in bytes.\n\t * @protected\n\t * @since 4.5.000 (2008-12-31)\n\t */\n\tprotected $pagelen = array();\n\n\t/**\n\t * Counts the number of pages.\n\t * @protected\n\t * @since 4.5.000 (2008-12-31)\n\t */\n\tprotected $numimages = 0;\n\n\t/**\n\t * Store the image keys.\n\t * @protected\n\t * @since 4.5.000 (2008-12-31)\n\t */\n\tprotected $imagekeys = array();\n\n\t/**\n\t * Length of the buffer in bytes.\n\t * @protected\n\t * @since 4.5.000 (2008-12-31)\n\t */\n\tprotected $bufferlen = 0;\n\n\t/**\n\t * Counts the number of fonts.\n\t * @protected\n\t * @since 4.5.000 (2009-01-02)\n\t */\n\tprotected $numfonts = 0;\n\n\t/**\n\t * Store the font keys.\n\t * @protected\n\t * @since 4.5.000 (2009-01-02)\n\t */\n\tprotected $fontkeys = array();\n\n\t/**\n\t * Store the font object IDs.\n\t * @protected\n\t * @since 4.8.001 (2009-09-09)\n\t */\n\tprotected $font_obj_ids = array();\n\n\t/**\n\t * Store the fage status (true when opened, false when closed).\n\t * @protected\n\t * @since 4.5.000 (2009-01-02)\n\t */\n\tprotected $pageopen = array();\n\n\t/**\n\t * Default monospace font.\n\t * @protected\n\t * @since 4.5.025 (2009-03-10)\n\t */\n\tprotected $default_monospaced_font = 'courier';\n\n\t/**\n\t * Cloned copy of the current class object.\n\t * @protected\n\t * @since 4.5.029 (2009-03-19)\n\t */\n\tprotected $objcopy;\n\n\t/**\n\t * Array used to store the lengths of cache files.\n\t * @protected\n\t * @since 4.5.029 (2009-03-19)\n\t */\n\tprotected $cache_file_length = array();\n\n\t/**\n\t * Table header content to be repeated on each new page.\n\t * @protected\n\t * @since 4.5.030 (2009-03-20)\n\t */\n\tprotected $thead = '';\n\n\t/**\n\t * Margins used for table header.\n\t * @protected\n\t * @since 4.5.030 (2009-03-20)\n\t */\n\tprotected $theadMargins = array();\n\n\t/**\n\t * Boolean flag to enable document digital signature.\n\t * @protected\n\t * @since 4.6.005 (2009-04-24)\n\t */\n\tprotected $sign = false;\n\n\t/**\n\t * Digital signature data.\n\t * @protected\n\t * @since 4.6.005 (2009-04-24)\n\t */\n\tprotected $signature_data = array();\n\n\t/**\n\t * Digital signature max length.\n\t * @protected\n\t * @since 4.6.005 (2009-04-24)\n\t */\n\tprotected $signature_max_length = 11742;\n\n\t/**\n\t * Data for digital signature appearance.\n\t * @protected\n\t * @since 5.3.011 (2010-06-16)\n\t */\n\tprotected $signature_appearance = array('page' => 1, 'rect' => '0 0 0 0');\n\n\t/**\n\t * Array of empty digital signature appearances.\n\t * @protected\n\t * @since 5.9.101 (2011-07-06)\n\t */\n\tprotected $empty_signature_appearance = array();\n\n\t/**\n\t * Boolean flag to enable document timestamping with TSA.\n\t * @protected\n\t * @since 6.0.085 (2014-06-19)\n\t */\n\tprotected $tsa_timestamp = false;\n\n\t/**\n\t * Timestamping data.\n\t * @protected\n\t * @since 6.0.085 (2014-06-19)\n\t */\n\tprotected $tsa_data = array();\n\n\t/**\n\t * Regular expression used to find blank characters (required for word-wrapping).\n\t * @protected\n\t * @since 4.6.006 (2009-04-28)\n\t */\n\tprotected $re_spaces = '/[^\\S\\xa0]/';\n\n\t/**\n\t * Array of $re_spaces parts.\n\t * @protected\n\t * @since 5.5.011 (2010-07-09)\n\t */\n\tprotected $re_space = array('p' => '[^\\S\\xa0]', 'm' => '');\n\n\t/**\n\t * Digital signature object ID.\n\t * @protected\n\t * @since 4.6.022 (2009-06-23)\n\t */\n\tprotected $sig_obj_id = 0;\n\n\t/**\n\t * ID of page objects.\n\t * @protected\n\t * @since 4.7.000 (2009-08-29)\n\t */\n\tprotected $page_obj_id = array();\n\n\t/**\n\t * List of form annotations IDs.\n\t * @protected\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tprotected $form_obj_id = array();\n\n\t/**\n\t * Deafult Javascript field properties. Possible values are described on official Javascript for Acrobat API reference. Annotation options can be directly specified using the 'aopt' entry.\n\t * @protected\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tprotected $default_form_prop = array('lineWidth'=>1, 'borderStyle'=>'solid', 'fillColor'=>array(255, 255, 255), 'strokeColor'=>array(128, 128, 128));\n\n\t/**\n\t * Javascript objects array.\n\t * @protected\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tprotected $js_objects = array();\n\n\t/**\n\t * Current form action (used during XHTML rendering).\n\t * @protected\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tprotected $form_action = '';\n\n\t/**\n\t * Current form encryption type (used during XHTML rendering).\n\t * @protected\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tprotected $form_enctype = 'application/x-www-form-urlencoded';\n\n\t/**\n\t * Current method to submit forms.\n\t * @protected\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tprotected $form_mode = 'post';\n\n\t/**\n\t * List of fonts used on form fields (fontname => fontkey).\n\t * @protected\n\t * @since 4.8.001 (2009-09-09)\n\t */\n\tprotected $annotation_fonts = array();\n\n\t/**\n\t * List of radio buttons parent objects.\n\t * @protected\n\t * @since 4.8.001 (2009-09-09)\n\t */\n\tprotected $radiobutton_groups = array();\n\n\t/**\n\t * List of radio group objects IDs.\n\t * @protected\n\t * @since 4.8.001 (2009-09-09)\n\t */\n\tprotected $radio_groups = array();\n\n\t/**\n\t * Text indentation value (used for text-indent CSS attribute).\n\t * @protected\n\t * @since 4.8.006 (2009-09-23)\n\t */\n\tprotected $textindent = 0;\n\n\t/**\n\t * Store page number when startTransaction() is called.\n\t * @protected\n\t * @since 4.8.006 (2009-09-23)\n\t */\n\tprotected $start_transaction_page = 0;\n\n\t/**\n\t * Store Y position when startTransaction() is called.\n\t * @protected\n\t * @since 4.9.001 (2010-03-28)\n\t */\n\tprotected $start_transaction_y = 0;\n\n\t/**\n\t * True when we are printing the thead section on a new page.\n\t * @protected\n\t * @since 4.8.027 (2010-01-25)\n\t */\n\tprotected $inthead = false;\n\n\t/**\n\t * Array of column measures (width, space, starting Y position).\n\t * @protected\n\t * @since 4.9.001 (2010-03-28)\n\t */\n\tprotected $columns = array();\n\n\t/**\n\t * Number of colums.\n\t * @protected\n\t * @since 4.9.001 (2010-03-28)\n\t */\n\tprotected $num_columns = 1;\n\n\t/**\n\t * Current column number.\n\t * @protected\n\t * @since 4.9.001 (2010-03-28)\n\t */\n\tprotected $current_column = 0;\n\n\t/**\n\t * Starting page for columns.\n\t * @protected\n\t * @since 4.9.001 (2010-03-28)\n\t */\n\tprotected $column_start_page = 0;\n\n\t/**\n\t * Maximum page and column selected.\n\t * @protected\n\t * @since 5.8.000 (2010-08-11)\n\t */\n\tprotected $maxselcol = array('page' => 0, 'column' => 0);\n\n\t/**\n\t * Array of: X difference between table cell x start and starting page margin, cellspacing, cellpadding.\n\t * @protected\n\t * @since 5.8.000 (2010-08-11)\n\t */\n\tprotected $colxshift = array('x' => 0, 's' => array('H' => 0, 'V' => 0), 'p' => array('L' => 0, 'T' => 0, 'R' => 0, 'B' => 0));\n\n\t/**\n\t * Text rendering mode: 0 = Fill text; 1 = Stroke text; 2 = Fill, then stroke text; 3 = Neither fill nor stroke text (invisible); 4 = Fill text and add to path for clipping; 5 = Stroke text and add to path for clipping; 6 = Fill, then stroke text and add to path for clipping; 7 = Add text to path for clipping.\n\t * @protected\n\t * @since 4.9.008 (2010-04-03)\n\t */\n\tprotected $textrendermode = 0;\n\n\t/**\n\t * Text stroke width in doc units.\n\t * @protected\n\t * @since 4.9.008 (2010-04-03)\n\t */\n\tprotected $textstrokewidth = 0;\n\n\t/**\n\t * Current stroke color.\n\t * @protected\n\t * @since 4.9.008 (2010-04-03)\n\t */\n\tprotected $strokecolor;\n\n\t/**\n\t * Default unit of measure for document.\n\t * @protected\n\t * @since 5.0.000 (2010-04-22)\n\t */\n\tprotected $pdfunit = 'mm';\n\n\t/**\n\t * Boolean flag true when we are on TOC (Table Of Content) page.\n\t * @protected\n\t */\n\tprotected $tocpage = false;\n\n\t/**\n\t * Boolean flag: if true convert vector images (SVG, EPS) to raster image using GD or ImageMagick library.\n\t * @protected\n\t * @since 5.0.000 (2010-04-26)\n\t */\n\tprotected $rasterize_vector_images = false;\n\n\t/**\n\t * Boolean flag: if true enables font subsetting by default.\n\t * @protected\n\t * @since 5.3.002 (2010-06-07)\n\t */\n\tprotected $font_subsetting = true;\n\n\t/**\n\t * Array of default graphic settings.\n\t * @protected\n\t * @since 5.5.008 (2010-07-02)\n\t */\n\tprotected $default_graphic_vars = array();\n\n\t/**\n\t * Array of XObjects.\n\t * @protected\n\t * @since 5.8.014 (2010-08-23)\n\t */\n\tprotected $xobjects = array();\n\n\t/**\n\t * Boolean value true when we are inside an XObject.\n\t * @protected\n\t * @since 5.8.017 (2010-08-24)\n\t */\n\tprotected $inxobj = false;\n\n\t/**\n\t * Current XObject ID.\n\t * @protected\n\t * @since 5.8.017 (2010-08-24)\n\t */\n\tprotected $xobjid = '';\n\n\t/**\n\t * Percentage of character stretching.\n\t * @protected\n\t * @since 5.9.000 (2010-09-29)\n\t */\n\tprotected $font_stretching = 100;\n\n\t/**\n\t * Increases or decreases the space between characters in a text by the specified amount (tracking).\n\t * @protected\n\t * @since 5.9.000 (2010-09-29)\n\t */\n\tprotected $font_spacing = 0;\n\n\t/**\n\t * Array of no-write regions.\n\t * ('page' => page number or empy for current page, 'xt' => X top, 'yt' => Y top, 'xb' => X bottom, 'yb' => Y bottom, 'side' => page side 'L' = left or 'R' = right)\n\t * @protected\n\t * @since 5.9.003 (2010-10-14)\n\t */\n\tprotected $page_regions = array();\n\n\t/**\n\t * Boolean value true when page region check is active.\n\t * @protected\n\t */\n\tprotected $check_page_regions = true;\n\n\t/**\n\t * Array of PDF layers data.\n\t * @protected\n\t * @since 5.9.102 (2011-07-13)\n\t */\n\tprotected $pdflayers = array();\n\n\t/**\n\t * A dictionary of names and corresponding destinations (Dests key on document Catalog).\n\t * @protected\n\t * @since 5.9.097 (2011-06-23)\n\t */\n\tprotected $dests = array();\n\n\t/**\n\t * Object ID for Named Destinations\n\t * @protected\n\t * @since 5.9.097 (2011-06-23)\n\t */\n\tprotected $n_dests;\n\n\t/**\n\t * Embedded Files Names\n\t * @protected\n\t * @since 5.9.204 (2013-01-23)\n\t */\n\tprotected $efnames = array();\n\n\t/**\n\t * Directory used for the last SVG image.\n\t * @protected\n\t * @since 5.0.000 (2010-05-05)\n\t */\n\tprotected $svgdir = '';\n\n\t/**\n\t *  Deafult unit of measure for SVG.\n\t * @protected\n\t * @since 5.0.000 (2010-05-02)\n\t */\n\tprotected $svgunit = 'px';\n\n\t/**\n\t * Array of SVG gradients.\n\t * @protected\n\t * @since 5.0.000 (2010-05-02)\n\t */\n\tprotected $svggradients = array();\n\n\t/**\n\t * ID of last SVG gradient.\n\t * @protected\n\t * @since 5.0.000 (2010-05-02)\n\t */\n\tprotected $svggradientid = 0;\n\n\t/**\n\t * Boolean value true when in SVG defs group.\n\t * @protected\n\t * @since 5.0.000 (2010-05-02)\n\t */\n\tprotected $svgdefsmode = false;\n\n\t/**\n\t * Array of SVG defs.\n\t * @protected\n\t * @since 5.0.000 (2010-05-02)\n\t */\n\tprotected $svgdefs = array();\n\n\t/**\n\t * Boolean value true when in SVG clipPath tag.\n\t * @protected\n\t * @since 5.0.000 (2010-04-26)\n\t */\n\tprotected $svgclipmode = false;\n\n\t/**\n\t * Array of SVG clipPath commands.\n\t * @protected\n\t * @since 5.0.000 (2010-05-02)\n\t */\n\tprotected $svgclippaths = array();\n\n\t/**\n\t * Array of SVG clipPath tranformation matrix.\n\t * @protected\n\t * @since 5.8.022 (2010-08-31)\n\t */\n\tprotected $svgcliptm = array();\n\n\t/**\n\t * ID of last SVG clipPath.\n\t * @protected\n\t * @since 5.0.000 (2010-05-02)\n\t */\n\tprotected $svgclipid = 0;\n\n\t/**\n\t * SVG text.\n\t * @protected\n\t * @since 5.0.000 (2010-05-02)\n\t */\n\tprotected $svgtext = '';\n\n\t/**\n\t * SVG text properties.\n\t * @protected\n\t * @since 5.8.013 (2010-08-23)\n\t */\n\tprotected $svgtextmode = array();\n\n\t/**\n\t * Array of SVG properties.\n\t * @protected\n\t * @since 5.0.000 (2010-05-02)\n\t */\n\tprotected $svgstyles = array(array(\n\t\t'alignment-baseline' => 'auto',\n\t\t'baseline-shift' => 'baseline',\n\t\t'clip' => 'auto',\n\t\t'clip-path' => 'none',\n\t\t'clip-rule' => 'nonzero',\n\t\t'color' => 'black',\n\t\t'color-interpolation' => 'sRGB',\n\t\t'color-interpolation-filters' => 'linearRGB',\n\t\t'color-profile' => 'auto',\n\t\t'color-rendering' => 'auto',\n\t\t'cursor' => 'auto',\n\t\t'direction' => 'ltr',\n\t\t'display' => 'inline',\n\t\t'dominant-baseline' => 'auto',\n\t\t'enable-background' => 'accumulate',\n\t\t'fill' => 'black',\n\t\t'fill-opacity' => 1,\n\t\t'fill-rule' => 'nonzero',\n\t\t'filter' => 'none',\n\t\t'flood-color' => 'black',\n\t\t'flood-opacity' => 1,\n\t\t'font' => '',\n\t\t'font-family' => 'helvetica',\n\t\t'font-size' => 'medium',\n\t\t'font-size-adjust' => 'none',\n\t\t'font-stretch' => 'normal',\n\t\t'font-style' => 'normal',\n\t\t'font-variant' => 'normal',\n\t\t'font-weight' => 'normal',\n\t\t'glyph-orientation-horizontal' => '0deg',\n\t\t'glyph-orientation-vertical' => 'auto',\n\t\t'image-rendering' => 'auto',\n\t\t'kerning' => 'auto',\n\t\t'letter-spacing' => 'normal',\n\t\t'lighting-color' => 'white',\n\t\t'marker' => '',\n\t\t'marker-end' => 'none',\n\t\t'marker-mid' => 'none',\n\t\t'marker-start' => 'none',\n\t\t'mask' => 'none',\n\t\t'opacity' => 1,\n\t\t'overflow' => 'auto',\n\t\t'pointer-events' => 'visiblePainted',\n\t\t'shape-rendering' => 'auto',\n\t\t'stop-color' => 'black',\n\t\t'stop-opacity' => 1,\n\t\t'stroke' => 'none',\n\t\t'stroke-dasharray' => 'none',\n\t\t'stroke-dashoffset' => 0,\n\t\t'stroke-linecap' => 'butt',\n\t\t'stroke-linejoin' => 'miter',\n\t\t'stroke-miterlimit' => 4,\n\t\t'stroke-opacity' => 1,\n\t\t'stroke-width' => 1,\n\t\t'text-anchor' => 'start',\n\t\t'text-decoration' => 'none',\n\t\t'text-rendering' => 'auto',\n\t\t'unicode-bidi' => 'normal',\n\t\t'visibility' => 'visible',\n\t\t'word-spacing' => 'normal',\n\t\t'writing-mode' => 'lr-tb',\n\t\t'text-color' => 'black',\n\t\t'transfmatrix' => array(1, 0, 0, 1, 0, 0)\n\t\t));\n\n\t/**\n\t * If true force sRGB color profile for all document.\n\t * @protected\n\t * @since 5.9.121 (2011-09-28)\n\t */\n\tprotected $force_srgb = false;\n\n\t/**\n\t * If true set the document to PDF/A mode.\n\t * @protected\n\t * @since 5.9.121 (2011-09-27)\n\t */\n\tprotected $pdfa_mode = false;\n\n\t/**\n\t * version of PDF/A mode (1 - 3).\n\t * @protected\n\t * @since 6.2.26 (2019-03-12)\n\t */\n\tprotected $pdfa_version = 1;\n\n\t/**\n\t * Document creation date-time\n\t * @protected\n\t * @since 5.9.152 (2012-03-22)\n\t */\n\tprotected $doc_creation_timestamp;\n\n\t/**\n\t * Document modification date-time\n\t * @protected\n\t * @since 5.9.152 (2012-03-22)\n\t */\n\tprotected $doc_modification_timestamp;\n\n\t/**\n\t * Custom XMP data.\n\t * @protected\n\t * @since 5.9.128 (2011-10-06)\n\t */\n\tprotected $custom_xmp = '';\n\n\t/**\n\t * Custom XMP RDF data.\n\t * @protected\n\t * @since 6.3.0 (2019-09-19)\n\t */\n\tprotected $custom_xmp_rdf = '';\n\n\t/**\n\t * Overprint mode array.\n\t * (Check the \"Entries in a Graphics State Parameter Dictionary\" on PDF 32000-1:2008).\n\t * @protected\n\t * @since 5.9.152 (2012-03-23)\n\t * @var array<string,bool|int>\n\t */\n\tprotected $overprint = array('OP' => false, 'op' => false, 'OPM' => 0);\n\n\t/**\n\t * Alpha mode array.\n\t * (Check the \"Entries in a Graphics State Parameter Dictionary\" on PDF 32000-1:2008).\n\t * @protected\n\t * @since 5.9.152 (2012-03-23)\n\t */\n\tprotected $alpha = array('CA' => 1, 'ca' => 1, 'BM' => '/Normal', 'AIS' => false);\n\n\t/**\n\t * Define the page boundaries boxes to be set on document.\n\t * @protected\n\t * @since 5.9.152 (2012-03-23)\n\t */\n\tprotected $page_boxes = array('MediaBox', 'CropBox', 'BleedBox', 'TrimBox', 'ArtBox');\n\n\t/**\n\t * If true print TCPDF meta link.\n\t * @protected\n\t * @since 5.9.152 (2012-03-23)\n\t */\n\tprotected $tcpdflink = true;\n\n\t/**\n\t * Cache array for computed GD gamma values.\n\t * @protected\n\t * @since 5.9.1632 (2012-06-05)\n\t */\n\tprotected $gdgammacache = array();\n\n    /**\n     * Cache array for file content\n     * @protected\n     * @var array\n     * @since 6.3.5 (2020-09-28)\n     */\n\tprotected $fileContentCache = array();\n\n\t/**\n\t * Whether to allow local file path in image html tags, when prefixed with file://\n\t *\n\t * @var bool\n\t * @protected\n\t * @since 6.4 (2020-07-23)\n\t */\n\tprotected $allowLocalFiles = false;\n\n\t//------------------------------------------------------------\n\t// METHODS\n\t//------------------------------------------------------------\n\n\t/**\n\t * This is the class constructor.\n\t * It allows to set up the page format, the orientation and the measure unit used in all the methods (except for the font sizes).\n\t *\n\t * @param string $orientation page orientation. Possible values are (case insensitive):<ul><li>P or Portrait (default)</li><li>L or Landscape</li><li>'' (empty string) for automatic orientation</li></ul>\n\t * @param string $unit User measure unit. Possible values are:<ul><li>pt: point</li><li>mm: millimeter (default)</li><li>cm: centimeter</li><li>in: inch</li></ul><br />A point equals 1/72 of inch, that is to say about 0.35 mm (an inch being 2.54 cm). This is a very common unit in typography; font sizes are expressed in that unit.\n\t * @param mixed $format The format used for pages. It can be either: one of the string values specified at getPageSizeFromFormat() or an array of parameters specified at setPageFormat().\n\t * @param boolean $unicode TRUE means that the input text is unicode (default = true)\n\t * @param string $encoding Charset encoding (used only when converting back html entities); default is UTF-8.\n\t * @param boolean $diskcache DEPRECATED FEATURE\n\t * @param false|integer $pdfa If not false, set the document to PDF/A mode and the good version (1 or 3).\n\t * @public\n\t * @see getPageSizeFromFormat(), setPageFormat()\n\t */\n\tpublic function __construct($orientation='P', $unit='mm', $format='A4', $unicode=true, $encoding='UTF-8', $diskcache=false, $pdfa=false) {\n\t\t// set file ID for trailer\n\t\t$serformat = (is_array($format) ? json_encode($format) : $format);\n\t\t$this->file_id = md5(TCPDF_STATIC::getRandomSeed('TCPDF'.$orientation.$unit.$serformat.$encoding));\n\t\t$this->hash_key = hash_hmac('sha256', TCPDF_STATIC::getRandomSeed($this->file_id), TCPDF_STATIC::getRandomSeed('TCPDF'), false);\n\t\t$this->font_obj_ids = array();\n\t\t$this->page_obj_id = array();\n\t\t$this->form_obj_id = array();\n\t\t// set pdf/a mode\n\t\tif ($pdfa != false) {\n\t\t\t$this->pdfa_mode = true;\n\t\t\t$this->pdfa_version = $pdfa;  // 1 or 3\n\t\t} else\n\t\t\t$this->pdfa_mode = false;\n\n\t\t$this->force_srgb = false;\n\t\t// set language direction\n\t\t$this->rtl = false;\n\t\t$this->tmprtl = false;\n\t\t// some checks\n\t\t$this->_dochecks();\n\t\t// initialization of properties\n\t\t$this->isunicode = $unicode;\n\t\t$this->page = 0;\n\t\t$this->transfmrk[0] = array();\n\t\t$this->pagedim = array();\n\t\t$this->n = 2;\n\t\t$this->buffer = '';\n\t\t$this->pages = array();\n\t\t$this->state = 0;\n\t\t$this->fonts = array();\n\t\t$this->FontFiles = array();\n\t\t$this->diffs = array();\n\t\t$this->images = array();\n\t\t$this->links = array();\n\t\t$this->gradients = array();\n\t\t$this->InFooter = false;\n\t\t$this->lasth = 0;\n\t\t$this->FontFamily = defined('PDF_FONT_NAME_MAIN')?PDF_FONT_NAME_MAIN:'helvetica';\n\t\t$this->FontStyle = '';\n\t\t$this->FontSizePt = 12;\n\t\t$this->underline = false;\n\t\t$this->overline = false;\n\t\t$this->linethrough = false;\n\t\t$this->DrawColor = '0 G';\n\t\t$this->FillColor = '0 g';\n\t\t$this->TextColor = '0 g';\n\t\t$this->ColorFlag = false;\n\t\t$this->pdflayers = array();\n\t\t// encryption values\n\t\t$this->encrypted = false;\n\t\t$this->last_enc_key = '';\n\t\t// standard Unicode fonts\n\t\t$this->CoreFonts = array(\n\t\t\t'courier'=>'Courier',\n\t\t\t'courierB'=>'Courier-Bold',\n\t\t\t'courierI'=>'Courier-Oblique',\n\t\t\t'courierBI'=>'Courier-BoldOblique',\n\t\t\t'helvetica'=>'Helvetica',\n\t\t\t'helveticaB'=>'Helvetica-Bold',\n\t\t\t'helveticaI'=>'Helvetica-Oblique',\n\t\t\t'helveticaBI'=>'Helvetica-BoldOblique',\n\t\t\t'times'=>'Times-Roman',\n\t\t\t'timesB'=>'Times-Bold',\n\t\t\t'timesI'=>'Times-Italic',\n\t\t\t'timesBI'=>'Times-BoldItalic',\n\t\t\t'symbol'=>'Symbol',\n\t\t\t'zapfdingbats'=>'ZapfDingbats'\n\t\t);\n\t\t// set scale factor\n\t\t$this->setPageUnit($unit);\n\t\t// set page format and orientation\n\t\t$this->setPageFormat($format, $orientation);\n\t\t// page margins (1 cm)\n\t\t$margin = 28.35 / $this->k;\n\t\t$this->setMargins($margin, $margin);\n\t\t$this->clMargin = $this->lMargin;\n\t\t$this->crMargin = $this->rMargin;\n\t\t// internal cell padding\n\t\t$cpadding = $margin / 10;\n\t\t$this->setCellPaddings($cpadding, 0, $cpadding, 0);\n\t\t// cell margins\n\t\t$this->setCellMargins(0, 0, 0, 0);\n\t\t// line width (0.2 mm)\n\t\t$this->LineWidth = 0.57 / $this->k;\n\t\t$this->linestyleWidth = sprintf('%F w', ($this->LineWidth * $this->k));\n\t\t$this->linestyleCap = '0 J';\n\t\t$this->linestyleJoin = '0 j';\n\t\t$this->linestyleDash = '[] 0 d';\n\t\t// automatic page break\n\t\t$this->setAutoPageBreak(true, (2 * $margin));\n\t\t// full width display mode\n\t\t$this->setDisplayMode('fullwidth');\n\t\t// compression\n\t\t$this->setCompression();\n\t\t// set default PDF version number\n\t\t$this->setPDFVersion();\n\t\t$this->tcpdflink = true;\n\t\t$this->encoding = $encoding;\n\t\t$this->HREF = array();\n\t\t$this->getFontsList();\n\t\t$this->fgcolor = array('R' => 0, 'G' => 0, 'B' => 0);\n\t\t$this->strokecolor = array('R' => 0, 'G' => 0, 'B' => 0);\n\t\t$this->bgcolor = array('R' => 255, 'G' => 255, 'B' => 255);\n\t\t$this->extgstates = array();\n\t\t$this->setTextShadow();\n\t\t// signature\n\t\t$this->sign = false;\n\t\t$this->tsa_timestamp = false;\n\t\t$this->tsa_data = array();\n\t\t$this->signature_appearance = array('page' => 1, 'rect' => '0 0 0 0', 'name' => 'Signature');\n\t\t$this->empty_signature_appearance = array();\n\t\t// user's rights\n\t\t$this->ur['enabled'] = false;\n\t\t$this->ur['document'] = '/FullSave';\n\t\t$this->ur['annots'] = '/Create/Delete/Modify/Copy/Import/Export';\n\t\t$this->ur['form'] = '/Add/Delete/FillIn/Import/Export/SubmitStandalone/SpawnTemplate';\n\t\t$this->ur['signature'] = '/Modify';\n\t\t$this->ur['ef'] = '/Create/Delete/Modify/Import';\n\t\t$this->ur['formex'] = '';\n\t\t// set default JPEG quality\n\t\t$this->jpeg_quality = 75;\n\t\t// initialize some settings\n\t\tTCPDF_FONTS::utf8Bidi(array(), '', false, $this->isunicode, $this->CurrentFont);\n\t\t// set default font\n\t\t$this->setFont($this->FontFamily, $this->FontStyle, $this->FontSizePt);\n\t\t$this->setHeaderFont(array($this->FontFamily, $this->FontStyle, $this->FontSizePt));\n\t\t$this->setFooterFont(array($this->FontFamily, $this->FontStyle, $this->FontSizePt));\n\t\t// check if PCRE Unicode support is enabled\n\t\tif ($this->isunicode AND (@preg_match('/\\pL/u', 'a') == 1)) {\n\t\t\t// PCRE unicode support is turned ON\n\t\t\t// \\s     : any whitespace character\n\t\t\t// \\p{Z}  : any separator\n\t\t\t// \\p{Lo} : Unicode letter or ideograph that does not have lowercase and uppercase variants. Is used to chunk chinese words.\n\t\t\t// \\xa0   : Unicode Character 'NO-BREAK SPACE' (U+00A0)\n\t\t\t//$this->setSpacesRE('/(?!\\xa0)[\\s\\p{Z}\\p{Lo}]/u');\n\t\t\t$this->setSpacesRE('/(?!\\xa0)[\\s\\p{Z}]/u');\n\t\t} else {\n\t\t\t// PCRE unicode support is turned OFF\n\t\t\t$this->setSpacesRE('/[^\\S\\xa0]/');\n\t\t}\n\t\t$this->default_form_prop = array('lineWidth'=>1, 'borderStyle'=>'solid', 'fillColor'=>array(255, 255, 255), 'strokeColor'=>array(128, 128, 128));\n\t\t// set document creation and modification timestamp\n\t\t$this->doc_creation_timestamp = time();\n\t\t$this->doc_modification_timestamp = $this->doc_creation_timestamp;\n\t\t// get default graphic vars\n\t\t$this->default_graphic_vars = $this->getGraphicVars();\n\t\t$this->header_xobj_autoreset = false;\n\t\t$this->custom_xmp = '';\n\t\t$this->custom_xmp_rdf = '';\n\t}\n\n\t/**\n\t * Default destructor.\n\t * @public\n\t * @since 1.53.0.TC016\n\t */\n\tpublic function __destruct() {\n\t\t// cleanup\n\t\t$this->_destroy(true);\n\t}\n\n\t/**\n\t * Set the units of measure for the document.\n\t * @param string $unit User measure unit. Possible values are:<ul><li>pt: point</li><li>mm: millimeter (default)</li><li>cm: centimeter</li><li>in: inch</li></ul><br />A point equals 1/72 of inch, that is to say about 0.35 mm (an inch being 2.54 cm). This is a very common unit in typography; font sizes are expressed in that unit.\n\t * @public\n\t * @since 3.0.015 (2008-06-06)\n\t */\n\tpublic function setPageUnit($unit) {\n\t\t$unit = strtolower($unit);\n\t\t//Set scale factor\n\t\tswitch ($unit) {\n\t\t\t// points\n\t\t\tcase 'px':\n\t\t\tcase 'pt': {\n\t\t\t\t$this->k = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// millimeters\n\t\t\tcase 'mm': {\n\t\t\t\t$this->k = $this->dpi / 25.4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// centimeters\n\t\t\tcase 'cm': {\n\t\t\t\t$this->k = $this->dpi / 2.54;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// inches\n\t\t\tcase 'in': {\n\t\t\t\t$this->k = $this->dpi;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// unsupported unit\n\t\t\tdefault : {\n\t\t\t\t$this->Error('Incorrect unit: '.$unit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$this->pdfunit = $unit;\n\t\tif (isset($this->CurOrientation)) {\n\t\t\t$this->setPageOrientation($this->CurOrientation);\n\t\t}\n\t}\n\n\t/**\n\t * Change the format of the current page\n\t * @param mixed $format The format used for pages. It can be either: one of the string values specified at getPageSizeFromFormat() documentation or an array of two numbers (width, height) or an array containing the following measures and options:<ul>\n\t * <li>['format'] = page format name (one of the above);</li>\n\t * <li>['Rotate'] : The number of degrees by which the page shall be rotated clockwise when displayed or printed. The value shall be a multiple of 90.</li>\n\t * <li>['PZ'] : The page's preferred zoom (magnification) factor.</li>\n\t * <li>['MediaBox'] : the boundaries of the physical medium on which the page shall be displayed or printed:</li>\n\t * <li>['MediaBox']['llx'] : lower-left x coordinate</li>\n\t * <li>['MediaBox']['lly'] : lower-left y coordinate</li>\n\t * <li>['MediaBox']['urx'] : upper-right x coordinate</li>\n\t * <li>['MediaBox']['ury'] : upper-right y coordinate</li>\n\t * <li>['CropBox'] : the visible region of default user space:</li>\n\t * <li>['CropBox']['llx'] : lower-left x coordinate</li>\n\t * <li>['CropBox']['lly'] : lower-left y coordinate</li>\n\t * <li>['CropBox']['urx'] : upper-right x coordinate</li>\n\t * <li>['CropBox']['ury'] : upper-right y coordinate</li>\n\t * <li>['BleedBox'] : the region to which the contents of the page shall be clipped when output in a production environment:</li>\n\t * <li>['BleedBox']['llx'] : lower-left x coordinate</li>\n\t * <li>['BleedBox']['lly'] : lower-left y coordinate</li>\n\t * <li>['BleedBox']['urx'] : upper-right x coordinate</li>\n\t * <li>['BleedBox']['ury'] : upper-right y coordinate</li>\n\t * <li>['TrimBox'] : the intended dimensions of the finished page after trimming:</li>\n\t * <li>['TrimBox']['llx'] : lower-left x coordinate</li>\n\t * <li>['TrimBox']['lly'] : lower-left y coordinate</li>\n\t * <li>['TrimBox']['urx'] : upper-right x coordinate</li>\n\t * <li>['TrimBox']['ury'] : upper-right y coordinate</li>\n\t * <li>['ArtBox'] : the extent of the page's meaningful content:</li>\n\t * <li>['ArtBox']['llx'] : lower-left x coordinate</li>\n\t * <li>['ArtBox']['lly'] : lower-left y coordinate</li>\n\t * <li>['ArtBox']['urx'] : upper-right x coordinate</li>\n\t * <li>['ArtBox']['ury'] : upper-right y coordinate</li>\n\t * <li>['BoxColorInfo'] :specify the colours and other visual characteristics that should be used in displaying guidelines on the screen for each of the possible page boundaries other than the MediaBox:</li>\n\t * <li>['BoxColorInfo'][BOXTYPE]['C'] : an array of three numbers in the range 0-255, representing the components in the DeviceRGB colour space.</li>\n\t * <li>['BoxColorInfo'][BOXTYPE]['W'] : the guideline width in default user units</li>\n\t * <li>['BoxColorInfo'][BOXTYPE]['S'] : the guideline style: S = Solid; D = Dashed</li>\n\t * <li>['BoxColorInfo'][BOXTYPE]['D'] : dash array defining a pattern of dashes and gaps to be used in drawing dashed guidelines</li>\n\t * <li>['trans'] : the style and duration of the visual transition to use when moving from another page to the given page during a presentation</li>\n\t * <li>['trans']['Dur'] : The page's display duration (also called its advance timing): the maximum length of time, in seconds, that the page shall be displayed during presentations before the viewer application shall automatically advance to the next page.</li>\n\t * <li>['trans']['S'] : transition style : Split, Blinds, Box, Wipe, Dissolve, Glitter, R, Fly, Push, Cover, Uncover, Fade</li>\n\t * <li>['trans']['D'] : The duration of the transition effect, in seconds.</li>\n\t * <li>['trans']['Dm'] : (Split and Blinds transition styles only) The dimension in which the specified transition effect shall occur: H = Horizontal, V = Vertical. Default value: H.</li>\n\t * <li>['trans']['M'] : (Split, Box and Fly transition styles only) The direction of motion for the specified transition effect: I = Inward from the edges of the page, O = Outward from the center of the pageDefault value: I.</li>\n\t * <li>['trans']['Di'] : (Wipe, Glitter, Fly, Cover, Uncover and Push transition styles only) The direction in which the specified transition effect shall moves, expressed in degrees counterclockwise starting from a left-to-right direction. If the value is a number, it shall be one of: 0 = Left to right, 90 = Bottom to top (Wipe only), 180 = Right to left (Wipe only), 270 = Top to bottom, 315 = Top-left to bottom-right (Glitter only). If the value is a name, it shall be None, which is relevant only for the Fly transition when the value of SS is not 1.0. Default value: 0.</li>\n\t * <li>['trans']['SS'] : (Fly transition style only) The starting or ending scale at which the changes shall be drawn. If M specifies an inward transition, the scale of the changes drawn shall progress from SS to 1.0 over the course of the transition. If M specifies an outward transition, the scale of the changes drawn shall progress from 1.0 to SS over the course of the transition. Default: 1.0.</li>\n\t * <li>['trans']['B'] : (Fly transition style only) If true, the area that shall be flown in is rectangular and opaque. Default: false.</li>\n\t * </ul>\n\t * @param string $orientation page orientation. Possible values are (case insensitive):<ul>\n\t * <li>P or Portrait (default)</li>\n\t * <li>L or Landscape</li>\n\t * <li>'' (empty string) for automatic orientation</li>\n\t * </ul>\n\t * @protected\n\t * @since 3.0.015 (2008-06-06)\n\t * @see getPageSizeFromFormat()\n\t */\n\tprotected function setPageFormat($format, $orientation='P') {\n\t\tif (!empty($format) AND isset($this->pagedim[$this->page])) {\n\t\t\t// remove inherited values\n\t\t\tunset($this->pagedim[$this->page]);\n\t\t}\n\t\tif (is_string($format)) {\n\t\t\t// get page measures from format name\n\t\t\t$pf = TCPDF_STATIC::getPageSizeFromFormat($format);\n\t\t\t$this->fwPt = $pf[0];\n\t\t\t$this->fhPt = $pf[1];\n\t\t} else {\n\t\t\t// the boundaries of the physical medium on which the page shall be displayed or printed\n\t\t\tif (isset($format['MediaBox'])) {\n\t\t\t\t$this->pagedim = TCPDF_STATIC::setPageBoxes($this->page, 'MediaBox', $format['MediaBox']['llx'], $format['MediaBox']['lly'], $format['MediaBox']['urx'], $format['MediaBox']['ury'], false, $this->k, $this->pagedim);\n\t\t\t\t$this->fwPt = (($format['MediaBox']['urx'] - $format['MediaBox']['llx']) * $this->k);\n\t\t\t\t$this->fhPt = (($format['MediaBox']['ury'] - $format['MediaBox']['lly']) * $this->k);\n\t\t\t} else {\n\t\t\t\tif (isset($format[0]) AND is_numeric($format[0]) AND isset($format[1]) AND is_numeric($format[1])) {\n\t\t\t\t\t$pf = array(($format[0] * $this->k), ($format[1] * $this->k));\n\t\t\t\t} else {\n\t\t\t\t\tif (!isset($format['format'])) {\n\t\t\t\t\t\t// default value\n\t\t\t\t\t\t$format['format'] = 'A4';\n\t\t\t\t\t}\n\t\t\t\t\t$pf = TCPDF_STATIC::getPageSizeFromFormat($format['format']);\n\t\t\t\t}\n\t\t\t\t$this->fwPt = $pf[0];\n\t\t\t\t$this->fhPt = $pf[1];\n\t\t\t\t$this->pagedim = TCPDF_STATIC::setPageBoxes($this->page, 'MediaBox', 0, 0, $this->fwPt, $this->fhPt, true, $this->k, $this->pagedim);\n\t\t\t}\n\t\t\t// the visible region of default user space\n\t\t\tif (isset($format['CropBox'])) {\n\t\t\t\t$this->pagedim = TCPDF_STATIC::setPageBoxes($this->page, 'CropBox', $format['CropBox']['llx'], $format['CropBox']['lly'], $format['CropBox']['urx'], $format['CropBox']['ury'], false, $this->k, $this->pagedim);\n\t\t\t}\n\t\t\t// the region to which the contents of the page shall be clipped when output in a production environment\n\t\t\tif (isset($format['BleedBox'])) {\n\t\t\t\t$this->pagedim = TCPDF_STATIC::setPageBoxes($this->page, 'BleedBox', $format['BleedBox']['llx'], $format['BleedBox']['lly'], $format['BleedBox']['urx'], $format['BleedBox']['ury'], false, $this->k, $this->pagedim);\n\t\t\t}\n\t\t\t// the intended dimensions of the finished page after trimming\n\t\t\tif (isset($format['TrimBox'])) {\n\t\t\t\t$this->pagedim = TCPDF_STATIC::setPageBoxes($this->page, 'TrimBox', $format['TrimBox']['llx'], $format['TrimBox']['lly'], $format['TrimBox']['urx'], $format['TrimBox']['ury'], false, $this->k, $this->pagedim);\n\t\t\t}\n\t\t\t// the page's meaningful content (including potential white space)\n\t\t\tif (isset($format['ArtBox'])) {\n\t\t\t\t$this->pagedim = TCPDF_STATIC::setPageBoxes($this->page, 'ArtBox', $format['ArtBox']['llx'], $format['ArtBox']['lly'], $format['ArtBox']['urx'], $format['ArtBox']['ury'], false, $this->k, $this->pagedim);\n\t\t\t}\n\t\t\t// specify the colours and other visual characteristics that should be used in displaying guidelines on the screen for the various page boundaries\n\t\t\tif (isset($format['BoxColorInfo'])) {\n\t\t\t\t$this->pagedim[$this->page]['BoxColorInfo'] = $format['BoxColorInfo'];\n\t\t\t}\n\t\t\tif (isset($format['Rotate']) AND (($format['Rotate'] % 90) == 0)) {\n\t\t\t\t// The number of degrees by which the page shall be rotated clockwise when displayed or printed. The value shall be a multiple of 90.\n\t\t\t\t$this->pagedim[$this->page]['Rotate'] = intval($format['Rotate']);\n\t\t\t}\n\t\t\tif (isset($format['PZ'])) {\n\t\t\t\t// The page's preferred zoom (magnification) factor\n\t\t\t\t$this->pagedim[$this->page]['PZ'] = floatval($format['PZ']);\n\t\t\t}\n\t\t\tif (isset($format['trans'])) {\n\t\t\t\t// The style and duration of the visual transition to use when moving from another page to the given page during a presentation\n\t\t\t\tif (isset($format['trans']['Dur'])) {\n\t\t\t\t\t// The page's display duration\n\t\t\t\t\t$this->pagedim[$this->page]['trans']['Dur'] = floatval($format['trans']['Dur']);\n\t\t\t\t}\n\t\t\t\t$stansition_styles = array('Split', 'Blinds', 'Box', 'Wipe', 'Dissolve', 'Glitter', 'R', 'Fly', 'Push', 'Cover', 'Uncover', 'Fade');\n\t\t\t\tif (isset($format['trans']['S']) AND in_array($format['trans']['S'], $stansition_styles)) {\n\t\t\t\t\t// The transition style that shall be used when moving to this page from another during a presentation\n\t\t\t\t\t$this->pagedim[$this->page]['trans']['S'] = $format['trans']['S'];\n\t\t\t\t\t$valid_effect = array('Split', 'Blinds');\n\t\t\t\t\t$valid_vals = array('H', 'V');\n\t\t\t\t\tif (isset($format['trans']['Dm']) AND in_array($format['trans']['S'], $valid_effect) AND in_array($format['trans']['Dm'], $valid_vals)) {\n\t\t\t\t\t\t$this->pagedim[$this->page]['trans']['Dm'] = $format['trans']['Dm'];\n\t\t\t\t\t}\n\t\t\t\t\t$valid_effect = array('Split', 'Box', 'Fly');\n\t\t\t\t\t$valid_vals = array('I', 'O');\n\t\t\t\t\tif (isset($format['trans']['M']) AND in_array($format['trans']['S'], $valid_effect) AND in_array($format['trans']['M'], $valid_vals)) {\n\t\t\t\t\t\t$this->pagedim[$this->page]['trans']['M'] = $format['trans']['M'];\n\t\t\t\t\t}\n\t\t\t\t\t$valid_effect = array('Wipe', 'Glitter', 'Fly', 'Cover', 'Uncover', 'Push');\n\t\t\t\t\tif (isset($format['trans']['Di']) AND in_array($format['trans']['S'], $valid_effect)) {\n\t\t\t\t\t\tif (((($format['trans']['Di'] == 90) OR ($format['trans']['Di'] == 180)) AND ($format['trans']['S'] == 'Wipe'))\n\t\t\t\t\t\t\tOR (($format['trans']['Di'] == 315) AND ($format['trans']['S'] == 'Glitter'))\n\t\t\t\t\t\t\tOR (($format['trans']['Di'] == 0) OR ($format['trans']['Di'] == 270))) {\n\t\t\t\t\t\t\t$this->pagedim[$this->page]['trans']['Di'] = intval($format['trans']['Di']);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($format['trans']['SS']) AND ($format['trans']['S'] == 'Fly')) {\n\t\t\t\t\t\t$this->pagedim[$this->page]['trans']['SS'] = floatval($format['trans']['SS']);\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($format['trans']['B']) AND ($format['trans']['B'] === true) AND ($format['trans']['S'] == 'Fly')) {\n\t\t\t\t\t\t$this->pagedim[$this->page]['trans']['B'] = 'true';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$this->pagedim[$this->page]['trans']['S'] = 'R';\n\t\t\t\t}\n\t\t\t\tif (isset($format['trans']['D'])) {\n\t\t\t\t\t// The duration of the transition effect, in seconds\n\t\t\t\t\t$this->pagedim[$this->page]['trans']['D'] = floatval($format['trans']['D']);\n\t\t\t\t} else {\n\t\t\t\t\t$this->pagedim[$this->page]['trans']['D'] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$this->setPageOrientation($orientation);\n\t}\n\n\t/**\n\t * Set page orientation.\n\t * @param string $orientation page orientation. Possible values are (case insensitive):<ul><li>P or Portrait (default)</li><li>L or Landscape</li><li>'' (empty string) for automatic orientation</li></ul>\n\t * @param boolean|null $autopagebreak Boolean indicating if auto-page-break mode should be on or off.\n\t * @param float|null $bottommargin bottom margin of the page.\n\t * @public\n\t * @since 3.0.015 (2008-06-06)\n\t */\n\tpublic function setPageOrientation($orientation, $autopagebreak=null, $bottommargin=null) {\n\t\tif (!isset($this->pagedim[$this->page]['MediaBox'])) {\n\t\t\t// the boundaries of the physical medium on which the page shall be displayed or printed\n\t\t\t$this->pagedim = TCPDF_STATIC::setPageBoxes($this->page, 'MediaBox', 0, 0, $this->fwPt, $this->fhPt, true, $this->k, $this->pagedim);\n\t\t}\n\t\tif (!isset($this->pagedim[$this->page]['CropBox'])) {\n\t\t\t// the visible region of default user space\n\t\t\t$this->pagedim = TCPDF_STATIC::setPageBoxes($this->page, 'CropBox', $this->pagedim[$this->page]['MediaBox']['llx'], $this->pagedim[$this->page]['MediaBox']['lly'], $this->pagedim[$this->page]['MediaBox']['urx'], $this->pagedim[$this->page]['MediaBox']['ury'], true, $this->k, $this->pagedim);\n\t\t}\n\t\tif (!isset($this->pagedim[$this->page]['BleedBox'])) {\n\t\t\t// the region to which the contents of the page shall be clipped when output in a production environment\n\t\t\t$this->pagedim = TCPDF_STATIC::setPageBoxes($this->page, 'BleedBox', $this->pagedim[$this->page]['CropBox']['llx'], $this->pagedim[$this->page]['CropBox']['lly'], $this->pagedim[$this->page]['CropBox']['urx'], $this->pagedim[$this->page]['CropBox']['ury'], true, $this->k, $this->pagedim);\n\t\t}\n\t\tif (!isset($this->pagedim[$this->page]['TrimBox'])) {\n\t\t\t// the intended dimensions of the finished page after trimming\n\t\t\t$this->pagedim = TCPDF_STATIC::setPageBoxes($this->page, 'TrimBox', $this->pagedim[$this->page]['CropBox']['llx'], $this->pagedim[$this->page]['CropBox']['lly'], $this->pagedim[$this->page]['CropBox']['urx'], $this->pagedim[$this->page]['CropBox']['ury'], true, $this->k, $this->pagedim);\n\t\t}\n\t\tif (!isset($this->pagedim[$this->page]['ArtBox'])) {\n\t\t\t// the page's meaningful content (including potential white space)\n\t\t\t$this->pagedim = TCPDF_STATIC::setPageBoxes($this->page, 'ArtBox', $this->pagedim[$this->page]['CropBox']['llx'], $this->pagedim[$this->page]['CropBox']['lly'], $this->pagedim[$this->page]['CropBox']['urx'], $this->pagedim[$this->page]['CropBox']['ury'], true, $this->k, $this->pagedim);\n\t\t}\n\t\tif (!isset($this->pagedim[$this->page]['Rotate'])) {\n\t\t\t// The number of degrees by which the page shall be rotated clockwise when displayed or printed. The value shall be a multiple of 90.\n\t\t\t$this->pagedim[$this->page]['Rotate'] = 0;\n\t\t}\n\t\tif (!isset($this->pagedim[$this->page]['PZ'])) {\n\t\t\t// The page's preferred zoom (magnification) factor\n\t\t\t$this->pagedim[$this->page]['PZ'] = 1;\n\t\t}\n\t\tif ($this->fwPt > $this->fhPt) {\n\t\t\t// landscape\n\t\t\t$default_orientation = 'L';\n\t\t} else {\n\t\t\t// portrait\n\t\t\t$default_orientation = 'P';\n\t\t}\n\t\t$valid_orientations = array('P', 'L');\n\t\tif (empty($orientation)) {\n\t\t\t$orientation = $default_orientation;\n\t\t} else {\n\t\t\t$orientation = strtoupper($orientation[0]);\n\t\t}\n\t\tif (in_array($orientation, $valid_orientations) AND ($orientation != $default_orientation)) {\n\t\t\t$this->CurOrientation = $orientation;\n\t\t\t$this->wPt = $this->fhPt;\n\t\t\t$this->hPt = $this->fwPt;\n\t\t} else {\n\t\t\t$this->CurOrientation = $default_orientation;\n\t\t\t$this->wPt = $this->fwPt;\n\t\t\t$this->hPt = $this->fhPt;\n\t\t}\n\t\tif ((abs($this->pagedim[$this->page]['MediaBox']['urx'] - $this->hPt) < $this->feps) AND (abs($this->pagedim[$this->page]['MediaBox']['ury'] - $this->wPt) < $this->feps)){\n\t\t\t// swap X and Y coordinates (change page orientation)\n\t\t\t$this->pagedim = TCPDF_STATIC::swapPageBoxCoordinates($this->page, $this->pagedim);\n\t\t}\n\t\t$this->w = ($this->wPt / $this->k);\n\t\t$this->h = ($this->hPt / $this->k);\n\t\tif (TCPDF_STATIC::empty_string($autopagebreak)) {\n\t\t\tif (isset($this->AutoPageBreak)) {\n\t\t\t\t$autopagebreak = $this->AutoPageBreak;\n\t\t\t} else {\n\t\t\t\t$autopagebreak = true;\n\t\t\t}\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($bottommargin)) {\n\t\t\tif (isset($this->bMargin)) {\n\t\t\t\t$bottommargin = $this->bMargin;\n\t\t\t} else {\n\t\t\t\t// default value = 2 cm\n\t\t\t\t$bottommargin = 2 * 28.35 / $this->k;\n\t\t\t}\n\t\t}\n\t\t$this->setAutoPageBreak($autopagebreak, $bottommargin);\n\t\t// store page dimensions\n\t\t$this->pagedim[$this->page]['w'] = $this->wPt;\n\t\t$this->pagedim[$this->page]['h'] = $this->hPt;\n\t\t$this->pagedim[$this->page]['wk'] = $this->w;\n\t\t$this->pagedim[$this->page]['hk'] = $this->h;\n\t\t$this->pagedim[$this->page]['tm'] = $this->tMargin;\n\t\t$this->pagedim[$this->page]['bm'] = $bottommargin;\n\t\t$this->pagedim[$this->page]['lm'] = $this->lMargin;\n\t\t$this->pagedim[$this->page]['rm'] = $this->rMargin;\n\t\t$this->pagedim[$this->page]['pb'] = $autopagebreak;\n\t\t$this->pagedim[$this->page]['or'] = $this->CurOrientation;\n\t\t$this->pagedim[$this->page]['olm'] = $this->original_lMargin;\n\t\t$this->pagedim[$this->page]['orm'] = $this->original_rMargin;\n\t}\n\n\t/**\n\t * Set regular expression to detect withespaces or word separators.\n\t * The pattern delimiter must be the forward-slash character \"/\".\n\t * Some example patterns are:\n\t * <pre>\n\t * Non-Unicode or missing PCRE unicode support: \"/[^\\S\\xa0]/\"\n\t * Unicode and PCRE unicode support: \"/(?!\\xa0)[\\s\\p{Z}]/u\"\n\t * Unicode and PCRE unicode support in Chinese mode: \"/(?!\\xa0)[\\s\\p{Z}\\p{Lo}]/u\"\n\t * if PCRE unicode support is turned ON (\"\\P\" is the negate class of \"\\p\"):\n\t *      \\s     : any whitespace character\n\t *      \\p{Z}  : any separator\n\t *      \\p{Lo} : Unicode letter or ideograph that does not have lowercase and uppercase variants. Is used to chunk chinese words.\n\t *      \\xa0   : Unicode Character 'NO-BREAK SPACE' (U+00A0)\n\t * </pre>\n\t * @param string $re regular expression (leave empty for default).\n\t * @public\n\t * @since 4.6.016 (2009-06-15)\n\t */\n\tpublic function setSpacesRE($re='/[^\\S\\xa0]/') {\n\t\t$this->re_spaces = $re;\n\t\t$re_parts = explode('/', $re);\n\t\t// get pattern parts\n\t\t$this->re_space = array();\n\t\tif (isset($re_parts[1]) AND !empty($re_parts[1])) {\n\t\t\t$this->re_space['p'] = $re_parts[1];\n\t\t} else {\n\t\t\t$this->re_space['p'] = '[\\s]';\n\t\t}\n\t\t// set pattern modifiers\n\t\tif (isset($re_parts[2]) AND !empty($re_parts[2])) {\n\t\t\t$this->re_space['m'] = $re_parts[2];\n\t\t} else {\n\t\t\t$this->re_space['m'] = '';\n\t\t}\n\t}\n\n\t/**\n\t * Enable or disable Right-To-Left language mode\n\t * @param boolean $enable if true enable Right-To-Left language mode.\n\t * @param boolean $resetx if true reset the X position on direction change.\n\t * @public\n\t * @since 2.0.000 (2008-01-03)\n\t */\n\tpublic function setRTL($enable, $resetx=true) {\n\t\t$enable = $enable ? true : false;\n\t\t$resetx = ($resetx AND ($enable != $this->rtl));\n\t\t$this->rtl = $enable;\n\t\t$this->tmprtl = false;\n\t\tif ($resetx) {\n\t\t\t$this->Ln(0);\n\t\t}\n\t}\n\n\t/**\n\t * Return the RTL status\n\t * @return bool\n\t * @public\n\t * @since 4.0.012 (2008-07-24)\n\t */\n\tpublic function getRTL() {\n\t\treturn $this->rtl;\n\t}\n\n\t/**\n\t * Force temporary RTL language direction\n\t * @param false|string $mode can be false, 'L' for LTR or 'R' for RTL\n\t * @public\n\t * @since 2.1.000 (2008-01-09)\n\t */\n\tpublic function setTempRTL($mode) {\n\t\t$newmode = false;\n\t\tswitch (strtoupper($mode)) {\n\t\t\tcase 'LTR':\n\t\t\tcase 'L': {\n\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t$newmode = 'L';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'RTL':\n\t\t\tcase 'R': {\n\t\t\t\tif (!$this->rtl) {\n\t\t\t\t\t$newmode = 'R';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase false:\n\t\t\tdefault: {\n\t\t\t\t$newmode = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$this->tmprtl = $newmode;\n\t}\n\n\t/**\n\t * Return the current temporary RTL status\n\t * @return bool\n\t * @public\n\t * @since 4.8.014 (2009-11-04)\n\t */\n\tpublic function isRTLTextDir() {\n\t\treturn ($this->rtl OR ($this->tmprtl == 'R'));\n\t}\n\n\t/**\n\t * Set the last cell height.\n\t * @param float $h cell height.\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 1.53.0.TC034\n\t */\n\tpublic function setLastH($h) {\n\t\t$this->lasth = $h;\n\t}\n\n\t/**\n\t * Return the cell height\n\t * @param int $fontsize Font size in internal units\n\t * @param boolean $padding If true add cell padding\n\t * @public\n\t * @return float\n\t */\n\tpublic function getCellHeight($fontsize, $padding=TRUE) {\n\t\t$height = ($fontsize * $this->cell_height_ratio);\n\t\tif ($padding && !empty($this->cell_padding)) {\n\t\t\t$height += ($this->cell_padding['T'] + $this->cell_padding['B']);\n\t\t}\n\t\treturn round($height, 6);\n\t}\n\n\t/**\n\t * Reset the last cell height.\n\t * @public\n\t * @since 5.9.000 (2010-10-03)\n\t */\n\tpublic function resetLastH() {\n\t\t$this->lasth = $this->getCellHeight($this->FontSize);\n\t}\n\n\t/**\n\t * Get the last cell height.\n\t * @return float last cell height\n\t * @public\n\t * @since 4.0.017 (2008-08-05)\n\t */\n\tpublic function getLastH() {\n\t\treturn $this->lasth;\n\t}\n\n\t/**\n\t * Set the adjusting factor to convert pixels to user units.\n\t * @param float $scale adjusting factor to convert pixels to user units.\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 1.5.2\n\t */\n\tpublic function setImageScale($scale) {\n\t\t$this->imgscale = $scale;\n\t}\n\n\t/**\n\t * Returns the adjusting factor to convert pixels to user units.\n\t * @return float adjusting factor to convert pixels to user units.\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 1.5.2\n\t */\n\tpublic function getImageScale() {\n\t\treturn $this->imgscale;\n\t}\n\n\t/**\n\t * Returns an array of page dimensions:\n\t * <ul><li>$this->pagedim[$this->page]['w'] = page width in points</li><li>$this->pagedim[$this->page]['h'] = height in points</li><li>$this->pagedim[$this->page]['wk'] = page width in user units</li><li>$this->pagedim[$this->page]['hk'] = page height in user units</li><li>$this->pagedim[$this->page]['tm'] = top margin</li><li>$this->pagedim[$this->page]['bm'] = bottom margin</li><li>$this->pagedim[$this->page]['lm'] = left margin</li><li>$this->pagedim[$this->page]['rm'] = right margin</li><li>$this->pagedim[$this->page]['pb'] = auto page break</li><li>$this->pagedim[$this->page]['or'] = page orientation</li><li>$this->pagedim[$this->page]['olm'] = original left margin</li><li>$this->pagedim[$this->page]['orm'] = original right margin</li><li>$this->pagedim[$this->page]['Rotate'] = The number of degrees by which the page shall be rotated clockwise when displayed or printed. The value shall be a multiple of 90.</li><li>$this->pagedim[$this->page]['PZ'] = The page's preferred zoom (magnification) factor.</li><li>$this->pagedim[$this->page]['trans'] : the style and duration of the visual transition to use when moving from another page to the given page during a presentation<ul><li>$this->pagedim[$this->page]['trans']['Dur'] = The page's display duration (also called its advance timing): the maximum length of time, in seconds, that the page shall be displayed during presentations before the viewer application shall automatically advance to the next page.</li><li>$this->pagedim[$this->page]['trans']['S'] = transition style : Split, Blinds, Box, Wipe, Dissolve, Glitter, R, Fly, Push, Cover, Uncover, Fade</li><li>$this->pagedim[$this->page]['trans']['D'] = The duration of the transition effect, in seconds.</li><li>$this->pagedim[$this->page]['trans']['Dm'] = (Split and Blinds transition styles only) The dimension in which the specified transition effect shall occur: H = Horizontal, V = Vertical. Default value: H.</li><li>$this->pagedim[$this->page]['trans']['M'] = (Split, Box and Fly transition styles only) The direction of motion for the specified transition effect: I = Inward from the edges of the page, O = Outward from the center of the pageDefault value: I.</li><li>$this->pagedim[$this->page]['trans']['Di'] = (Wipe, Glitter, Fly, Cover, Uncover and Push transition styles only) The direction in which the specified transition effect shall moves, expressed in degrees counterclockwise starting from a left-to-right direction. If the value is a number, it shall be one of: 0 = Left to right, 90 = Bottom to top (Wipe only), 180 = Right to left (Wipe only), 270 = Top to bottom, 315 = Top-left to bottom-right (Glitter only). If the value is a name, it shall be None, which is relevant only for the Fly transition when the value of SS is not 1.0. Default value: 0.</li><li>$this->pagedim[$this->page]['trans']['SS'] = (Fly transition style only) The starting or ending scale at which the changes shall be drawn. If M specifies an inward transition, the scale of the changes drawn shall progress from SS to 1.0 over the course of the transition. If M specifies an outward transition, the scale of the changes drawn shall progress from 1.0 to SS over the course of the transition. Default: 1.0. </li><li>$this->pagedim[$this->page]['trans']['B'] = (Fly transition style only) If true, the area that shall be flown in is rectangular and opaque. Default: false.</li></ul></li><li>$this->pagedim[$this->page]['MediaBox'] : the boundaries of the physical medium on which the page shall be displayed or printed<ul><li>$this->pagedim[$this->page]['MediaBox']['llx'] = lower-left x coordinate in points</li><li>$this->pagedim[$this->page]['MediaBox']['lly'] = lower-left y coordinate in points</li><li>$this->pagedim[$this->page]['MediaBox']['urx'] = upper-right x coordinate in points</li><li>$this->pagedim[$this->page]['MediaBox']['ury'] = upper-right y coordinate in points</li></ul></li><li>$this->pagedim[$this->page]['CropBox'] : the visible region of default user space<ul><li>$this->pagedim[$this->page]['CropBox']['llx'] = lower-left x coordinate in points</li><li>$this->pagedim[$this->page]['CropBox']['lly'] = lower-left y coordinate in points</li><li>$this->pagedim[$this->page]['CropBox']['urx'] = upper-right x coordinate in points</li><li>$this->pagedim[$this->page]['CropBox']['ury'] = upper-right y coordinate in points</li></ul></li><li>$this->pagedim[$this->page]['BleedBox'] : the region to which the contents of the page shall be clipped when output in a production environment<ul><li>$this->pagedim[$this->page]['BleedBox']['llx'] = lower-left x coordinate in points</li><li>$this->pagedim[$this->page]['BleedBox']['lly'] = lower-left y coordinate in points</li><li>$this->pagedim[$this->page]['BleedBox']['urx'] = upper-right x coordinate in points</li><li>$this->pagedim[$this->page]['BleedBox']['ury'] = upper-right y coordinate in points</li></ul></li><li>$this->pagedim[$this->page]['TrimBox'] : the intended dimensions of the finished page after trimming<ul><li>$this->pagedim[$this->page]['TrimBox']['llx'] = lower-left x coordinate in points</li><li>$this->pagedim[$this->page]['TrimBox']['lly'] = lower-left y coordinate in points</li><li>$this->pagedim[$this->page]['TrimBox']['urx'] = upper-right x coordinate in points</li><li>$this->pagedim[$this->page]['TrimBox']['ury'] = upper-right y coordinate in points</li></ul></li><li>$this->pagedim[$this->page]['ArtBox'] : the extent of the page's meaningful content<ul><li>$this->pagedim[$this->page]['ArtBox']['llx'] = lower-left x coordinate in points</li><li>$this->pagedim[$this->page]['ArtBox']['lly'] = lower-left y coordinate in points</li><li>$this->pagedim[$this->page]['ArtBox']['urx'] = upper-right x coordinate in points</li><li>$this->pagedim[$this->page]['ArtBox']['ury'] = upper-right y coordinate in points</li></ul></li></ul>\n\t * @param int|null $pagenum page number (empty = current page)\n\t * @return array of page dimensions.\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 4.5.027 (2009-03-16)\n\t */\n\tpublic function getPageDimensions($pagenum=null) {\n\t\tif (empty($pagenum)) {\n\t\t\t$pagenum = $this->page;\n\t\t}\n\t\treturn $this->pagedim[$pagenum];\n\t}\n\n\t/**\n\t * Returns the page width in units.\n\t * @param int|null $pagenum page number (empty = current page)\n\t * @return int|float page width.\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 1.5.2\n\t * @see getPageDimensions()\n\t */\n\tpublic function getPageWidth($pagenum=null) {\n\t\tif (empty($pagenum)) {\n\t\t\treturn $this->w;\n\t\t}\n\t\treturn $this->pagedim[$pagenum]['w'];\n\t}\n\n\t/**\n\t * Returns the page height in units.\n\t * @param int|null $pagenum page number (empty = current page)\n\t * @return int|float page height.\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 1.5.2\n\t * @see getPageDimensions()\n\t */\n\tpublic function getPageHeight($pagenum=null) {\n\t\tif (empty($pagenum)) {\n\t\t\treturn $this->h;\n\t\t}\n\t\treturn $this->pagedim[$pagenum]['h'];\n\t}\n\n\t/**\n\t * Returns the page break margin.\n\t * @param int|null $pagenum page number (empty = current page)\n\t * @return int|float page break margin.\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 1.5.2\n\t * @see getPageDimensions()\n\t */\n\tpublic function getBreakMargin($pagenum=null) {\n\t\tif (empty($pagenum)) {\n\t\t\treturn $this->bMargin;\n\t\t}\n\t\treturn $this->pagedim[$pagenum]['bm'];\n\t}\n\n\t/**\n\t * Returns the scale factor (number of points in user unit).\n\t * @return int scale factor.\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 1.5.2\n\t */\n\tpublic function getScaleFactor() {\n\t\treturn $this->k;\n\t}\n\n\t/**\n\t * Defines the left, top and right margins.\n\t * @param int|float $left Left margin.\n\t * @param int|float $top Top margin.\n\t * @param int|float|null $right Right margin. Default value is the left one.\n\t * @param boolean $keepmargins if true overwrites the default page margins\n\t * @public\n\t * @since 1.0\n\t * @see SetLeftMargin(), SetTopMargin(), SetRightMargin(), SetAutoPageBreak()\n\t */\n\tpublic function setMargins($left, $top, $right=null, $keepmargins=false) {\n\t\t//Set left, top and right margins\n\t\t$this->lMargin = $left;\n\t\t$this->tMargin = $top;\n\t\tif ($right == -1 OR $right === null) {\n\t\t\t$right = $left;\n\t\t}\n\t\t$this->rMargin = $right;\n\t\tif ($keepmargins) {\n\t\t\t// overwrite original values\n\t\t\t$this->original_lMargin = $this->lMargin;\n\t\t\t$this->original_rMargin = $this->rMargin;\n\t\t}\n\t}\n\n\t/**\n\t * Defines the left margin. The method can be called before creating the first page. If the current abscissa gets out of page, it is brought back to the margin.\n\t * @param int|float $margin The margin.\n\t * @public\n\t * @since 1.4\n\t * @see SetTopMargin(), SetRightMargin(), SetAutoPageBreak(), SetMargins()\n\t */\n\tpublic function setLeftMargin($margin) {\n\t\t//Set left margin\n\t\t$this->lMargin = $margin;\n\t\tif (($this->page > 0) AND ($this->x < $margin)) {\n\t\t\t$this->x = $margin;\n\t\t}\n\t}\n\n\t/**\n\t * Defines the top margin. The method can be called before creating the first page.\n\t * @param int|float $margin The margin.\n\t * @public\n\t * @since 1.5\n\t * @see SetLeftMargin(), SetRightMargin(), SetAutoPageBreak(), SetMargins()\n\t */\n\tpublic function setTopMargin($margin) {\n\t\t//Set top margin\n\t\t$this->tMargin = $margin;\n\t\tif (($this->page > 0) AND ($this->y < $margin)) {\n\t\t\t$this->y = $margin;\n\t\t}\n\t}\n\n\t/**\n\t * Defines the right margin. The method can be called before creating the first page.\n\t * @param int|float $margin The margin.\n\t * @public\n\t * @since 1.5\n\t * @see SetLeftMargin(), SetTopMargin(), SetAutoPageBreak(), SetMargins()\n\t */\n\tpublic function setRightMargin($margin) {\n\t\t$this->rMargin = $margin;\n\t\tif (($this->page > 0) AND ($this->x > ($this->w - $margin))) {\n\t\t\t$this->x = $this->w - $margin;\n\t\t}\n\t}\n\n\t/**\n\t * Set the same internal Cell padding for top, right, bottom, left-\n\t * @param int|float $pad internal padding.\n\t * @public\n\t * @since 2.1.000 (2008-01-09)\n\t * @see getCellPaddings(), setCellPaddings()\n\t */\n\tpublic function setCellPadding($pad) {\n\t\tif ($pad >= 0) {\n\t\t\t$this->cell_padding['L'] = $pad;\n\t\t\t$this->cell_padding['T'] = $pad;\n\t\t\t$this->cell_padding['R'] = $pad;\n\t\t\t$this->cell_padding['B'] = $pad;\n\t\t}\n\t}\n\n\t/**\n\t * Set the internal Cell paddings.\n\t * @param int|float|null $left left padding\n\t * @param int|float|null $top top padding\n\t * @param int|float|null $right right padding\n\t * @param int|float|null $bottom bottom padding\n\t * @public\n\t * @since 5.9.000 (2010-10-03)\n\t * @see getCellPaddings(), SetCellPadding()\n\t */\n\tpublic function setCellPaddings($left=null, $top=null, $right=null, $bottom=null) {\n\t\tif (!TCPDF_STATIC::empty_string($left) AND ($left >= 0)) {\n\t\t\t$this->cell_padding['L'] = $left;\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($top) AND ($top >= 0)) {\n\t\t\t$this->cell_padding['T'] = $top;\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($right) AND ($right >= 0)) {\n\t\t\t$this->cell_padding['R'] = $right;\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($bottom) AND ($bottom >= 0)) {\n\t\t\t$this->cell_padding['B'] = $bottom;\n\t\t}\n\t}\n\n\t/**\n\t * Get the internal Cell padding array.\n\t * @return array of padding values\n\t * @public\n\t * @since 5.9.000 (2010-10-03)\n\t * @see setCellPaddings(), SetCellPadding()\n\t */\n\tpublic function getCellPaddings() {\n\t\treturn $this->cell_padding;\n\t}\n\n\t/**\n\t * Set the internal Cell margins.\n\t * @param int|float|null $left left margin\n\t * @param int|float|null $top top margin\n\t * @param int|float|null $right right margin\n\t * @param int|float|null $bottom bottom margin\n\t * @public\n\t * @since 5.9.000 (2010-10-03)\n\t * @see getCellMargins()\n\t */\n\tpublic function setCellMargins($left=null, $top=null, $right=null, $bottom=null) {\n\t\tif (!TCPDF_STATIC::empty_string($left) AND ($left >= 0)) {\n\t\t\t$this->cell_margin['L'] = $left;\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($top) AND ($top >= 0)) {\n\t\t\t$this->cell_margin['T'] = $top;\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($right) AND ($right >= 0)) {\n\t\t\t$this->cell_margin['R'] = $right;\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($bottom) AND ($bottom >= 0)) {\n\t\t\t$this->cell_margin['B'] = $bottom;\n\t\t}\n\t}\n\n\t/**\n\t * Get the internal Cell margin array.\n\t * @return array of margin values\n\t * @public\n\t * @since 5.9.000 (2010-10-03)\n\t * @see setCellMargins()\n\t */\n\tpublic function getCellMargins() {\n\t\treturn $this->cell_margin;\n\t}\n\n\t/**\n\t * Adjust the internal Cell padding array to take account of the line width.\n\t * @param string|array|int|bool $brd Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))\n\t * @return void|array array of adjustments\n\t * @public\n\t * @since 5.9.000 (2010-10-03)\n\t */\n\tprotected function adjustCellPadding($brd=0) {\n\t\tif (empty($brd)) {\n\t\t\treturn;\n\t\t}\n\t\tif (is_string($brd)) {\n\t\t\t// convert string to array\n\t\t\t$slen = strlen($brd);\n\t\t\t$newbrd = array();\n\t\t\tfor ($i = 0; $i < $slen; ++$i) {\n\t\t\t\t$newbrd[$brd[$i]] = true;\n\t\t\t}\n\t\t\t$brd = $newbrd;\n\t\t} elseif (\n\t\t\t($brd === 1)\n\t\t\t|| ($brd === true)\n\t\t\t|| (is_numeric($brd) && ((int)$brd > 0))\n\t\t) {\n\t\t\t$brd = array('LRTB' => true);\n\t\t}\n\t\tif (!is_array($brd)) {\n\t\t\treturn;\n\t\t}\n\t\t// store current cell padding\n\t\t$cp = $this->cell_padding;\n\t\t// select border mode\n\t\tif (isset($brd['mode'])) {\n\t\t\t$mode = $brd['mode'];\n\t\t\tunset($brd['mode']);\n\t\t} else {\n\t\t\t$mode = 'normal';\n\t\t}\n\t\t// process borders\n\t\tforeach ($brd as $border => $style) {\n\t\t\t$line_width = $this->LineWidth;\n\t\t\tif (is_array($style) && isset($style['width'])) {\n\t\t\t\t// get border width\n\t\t\t\t$line_width = $style['width'];\n\t\t\t}\n\t\t\t$adj = 0; // line width inside the cell\n\t\t\tswitch ($mode) {\n\t\t\t\tcase 'ext': {\n\t\t\t\t\t$adj = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'int': {\n\t\t\t\t\t$adj = $line_width;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'normal':\n\t\t\t\tdefault: {\n\t\t\t\t\t$adj = ($line_width / 2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// correct internal cell padding if required to avoid overlap between text and lines\n\t\t\tif (\n\t\t\t\tis_numeric($this->cell_padding['T'])\n\t\t\t\t&& ($this->cell_padding['T'] < $adj)\n\t\t\t\t&& (strpos($border, 'T') !== false)\n\t\t\t) {\n\t\t\t\t$this->cell_padding['T'] = $adj;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tis_numeric($this->cell_padding['R'])\n\t\t\t\t&& ($this->cell_padding['R'] < $adj)\n\t\t\t\t&& (strpos($border, 'R') !== false)\n\t\t\t) {\n\t\t\t\t$this->cell_padding['R'] = $adj;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tis_numeric($this->cell_padding['B'])\n\t\t\t\t&& ($this->cell_padding['B'] < $adj)\n\t\t\t\t&& (strpos($border, 'B') !== false)\n\t\t\t) {\n\t\t\t\t$this->cell_padding['B'] = $adj;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tis_numeric($this->cell_padding['L'])\n\t\t\t\t&& ($this->cell_padding['L'] < $adj)\n\t\t\t\t&& (strpos($border, 'L') !== false)\n\t\t\t) {\n\t\t\t\t$this->cell_padding['L'] = $adj;\n\t\t\t}\n\n\t\t}\n\n\t\treturn array(\n\t\t\t'T' => ($this->cell_padding['T'] - $cp['T']),\n\t\t\t'R' => ($this->cell_padding['R'] - $cp['R']),\n\t\t\t'B' => ($this->cell_padding['B'] - $cp['B']),\n\t\t\t'L' => ($this->cell_padding['L'] - $cp['L']),\n\t\t);\n\t}\n\n\t/**\n\t * Enables or disables the automatic page breaking mode. When enabling, the second parameter is the distance from the bottom of the page that defines the triggering limit. By default, the mode is on and the margin is 2 cm.\n\t * @param boolean $auto Boolean indicating if mode should be on or off.\n\t * @param float $margin Distance from the bottom of the page.\n\t * @public\n\t * @since 1.0\n\t * @see Cell(), MultiCell(), AcceptPageBreak()\n\t */\n\tpublic function setAutoPageBreak($auto, $margin=0) {\n\t\t$this->AutoPageBreak = $auto ? true : false;\n\t\t$this->bMargin = $margin;\n\t\t$this->PageBreakTrigger = $this->h - $margin;\n\t}\n\n\t/**\n\t * Return the auto-page-break mode (true or false).\n\t * @return bool auto-page-break mode\n\t * @public\n\t * @since 5.9.088\n\t */\n\tpublic function getAutoPageBreak() {\n\t\treturn $this->AutoPageBreak;\n\t}\n\n\t/**\n\t * Defines the way the document is to be displayed by the viewer.\n\t * @param mixed $zoom The zoom to use. It can be one of the following string values or a number indicating the zooming factor to use. <ul><li>fullpage: displays the entire page on screen </li><li>fullwidth: uses maximum width of window</li><li>real: uses real size (equivalent to 100% zoom)</li><li>default: uses viewer default mode</li></ul>\n\t * @param string $layout The page layout. Possible values are:<ul><li>SinglePage Display one page at a time</li><li>OneColumn Display the pages in one column</li><li>TwoColumnLeft Display the pages in two columns, with odd-numbered pages on the left</li><li>TwoColumnRight Display the pages in two columns, with odd-numbered pages on the right</li><li>TwoPageLeft (PDF 1.5) Display the pages two at a time, with odd-numbered pages on the left</li><li>TwoPageRight (PDF 1.5) Display the pages two at a time, with odd-numbered pages on the right</li></ul>\n\t * @param string $mode A name object specifying how the document should be displayed when opened:<ul><li>UseNone Neither document outline nor thumbnail images visible</li><li>UseOutlines Document outline visible</li><li>UseThumbs Thumbnail images visible</li><li>FullScreen Full-screen mode, with no menu bar, window controls, or any other window visible</li><li>UseOC (PDF 1.5) Optional content group panel visible</li><li>UseAttachments (PDF 1.6) Attachments panel visible</li></ul>\n\t * @public\n\t * @since 1.2\n\t */\n\tpublic function setDisplayMode($zoom, $layout='SinglePage', $mode='UseNone') {\n\t\tif (($zoom == 'fullpage') OR ($zoom == 'fullwidth') OR ($zoom == 'real') OR ($zoom == 'default') OR (!is_string($zoom))) {\n\t\t\t$this->ZoomMode = $zoom;\n\t\t} else {\n\t\t\t$this->Error('Incorrect zoom display mode: '.$zoom);\n\t\t}\n\t\t$this->LayoutMode = TCPDF_STATIC::getPageLayoutMode($layout);\n\t\t$this->PageMode = TCPDF_STATIC::getPageMode($mode);\n\t}\n\n\t/**\n\t * Activates or deactivates page compression. When activated, the internal representation of each page is compressed, which leads to a compression ratio of about 2 for the resulting document. Compression is on by default.\n\t * Note: the Zlib extension is required for this feature. If not present, compression will be turned off.\n\t * @param boolean $compress Boolean indicating if compression must be enabled.\n\t * @public\n\t * @since 1.4\n\t */\n\tpublic function setCompression($compress=true) {\n\t\t$this->compress = false;\n\t\tif (function_exists('gzcompress')) {\n\t\t\tif ($compress) {\n\t\t\t\tif ( !$this->pdfa_mode) {\n\t\t\t\t\t$this->compress = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set flag to force sRGB_IEC61966-2.1 black scaled ICC color profile for the whole document.\n\t * @param boolean $mode If true force sRGB output intent.\n\t * @public\n\t * @since 5.9.121 (2011-09-28)\n\t */\n\tpublic function setSRGBmode($mode=false) {\n\t\t$this->force_srgb = $mode ? true : false;\n\t}\n\n\t/**\n\t * Turn on/off Unicode mode for document information dictionary (meta tags).\n\t * This has effect only when unicode mode is set to false.\n\t * @param boolean $unicode if true set the meta information in Unicode\n\t * @since 5.9.027 (2010-12-01)\n\t * @public\n\t */\n\tpublic function setDocInfoUnicode($unicode=true) {\n\t\t$this->docinfounicode = $unicode ? true : false;\n\t}\n\n\t/**\n\t * Defines the title of the document.\n\t * @param string $title The title.\n\t * @public\n\t * @since 1.2\n\t * @see SetAuthor(), SetCreator(), SetKeywords(), SetSubject()\n\t */\n\tpublic function setTitle($title) {\n\t\t$this->title = $title;\n\t}\n\n\t/**\n\t * Defines the subject of the document.\n\t * @param string $subject The subject.\n\t * @public\n\t * @since 1.2\n\t * @see SetAuthor(), SetCreator(), SetKeywords(), SetTitle()\n\t */\n\tpublic function setSubject($subject) {\n\t\t$this->subject = $subject;\n\t}\n\n\t/**\n\t * Defines the author of the document.\n\t * @param string $author The name of the author.\n\t * @public\n\t * @since 1.2\n\t * @see SetCreator(), SetKeywords(), SetSubject(), SetTitle()\n\t */\n\tpublic function setAuthor($author) {\n\t\t$this->author = $author;\n\t}\n\n\t/**\n\t * Associates keywords with the document, generally in the form 'keyword1 keyword2 ...'.\n\t * @param string $keywords The list of keywords.\n\t * @public\n\t * @since 1.2\n\t * @see SetAuthor(), SetCreator(), SetSubject(), SetTitle()\n\t */\n\tpublic function setKeywords($keywords) {\n\t\t$this->keywords = $keywords;\n\t}\n\n\t/**\n\t * Defines the creator of the document. This is typically the name of the application that generates the PDF.\n\t * @param string $creator The name of the creator.\n\t * @public\n\t * @since 1.2\n\t * @see SetAuthor(), SetKeywords(), SetSubject(), SetTitle()\n\t */\n\tpublic function setCreator($creator) {\n\t\t$this->creator = $creator;\n\t}\n\n\t/**\n\t * Whether to allow local file path in image html tags, when prefixed with file://\n\t *\n\t * @param bool $allowLocalFiles true, when local files should be allowed. Otherwise false.\n\t * @public\n\t * @since 6.4\n\t */\n\tpublic function setAllowLocalFiles($allowLocalFiles) {\n\t\t$this->allowLocalFiles = (bool) $allowLocalFiles;\n\t}\n\n\n\t/**\n\t * Throw an exception or print an error message and die if the K_TCPDF_PARSER_THROW_EXCEPTION_ERROR constant is set to true.\n\t * @param string $msg The error message\n\t * @public\n\t * @since 1.0\n\t */\n\tpublic function Error($msg) {\n\t\t// unset all class variables\n\t\t$this->_destroy(true);\n\t\t$msg = htmlspecialchars($msg, ENT_QUOTES, 'UTF-8');\n\t\tif (defined('K_TCPDF_THROW_EXCEPTION_ERROR') AND !K_TCPDF_THROW_EXCEPTION_ERROR) {\n\t\t\tdie('<strong>TCPDF ERROR: </strong>'.$msg);\n\t\t} else {\n\t\t\tthrow new Exception('TCPDF ERROR: '.$msg);\n\t\t}\n\t}\n\n\t/**\n\t * This method begins the generation of the PDF document.\n\t * It is not necessary to call it explicitly because AddPage() does it automatically.\n\t * Note: no page is created by this method\n\t * @public\n\t * @since 1.0\n\t * @see AddPage(), Close()\n\t */\n\tpublic function Open() {\n\t\t$this->state = 1;\n\t}\n\n\t/**\n\t * Terminates the PDF document.\n\t * It is not necessary to call this method explicitly because Output() does it automatically.\n\t * If the document contains no page, AddPage() is called to prevent from getting an invalid document.\n\t * @public\n\t * @since 1.0\n\t * @see Open(), Output()\n\t */\n\tpublic function Close() {\n\t\tif ($this->state == 3) {\n\t\t\treturn;\n\t\t}\n\t\tif ($this->page == 0) {\n\t\t\t$this->AddPage();\n\t\t}\n\t\t$this->endLayer();\n\t\tif ($this->tcpdflink) {\n\t\t\t// save current graphic settings\n\t\t\t$gvars = $this->getGraphicVars();\n\t\t\t$this->setEqualColumns();\n\t\t\t$this->lastpage(true);\n\t\t\t$this->setAutoPageBreak(false);\n\t\t\t$this->x = 0;\n\t\t\t$this->y = $this->h - (1 / $this->k);\n\t\t\t$this->lMargin = 0;\n\t\t\t$this->_outSaveGraphicsState();\n\t\t\t$font = defined('PDF_FONT_NAME_MAIN')?PDF_FONT_NAME_MAIN:'helvetica';\n\t\t\t$this->setFont($font, '', 1);\n\t\t\t$this->setTextRenderingMode(0, false, false);\n\t\t\t$msg = \"\\x50\\x6f\\x77\\x65\\x72\\x65\\x64\\x20\\x62\\x79\\x20\\x54\\x43\\x50\\x44\\x46\\x20\\x28\\x77\\x77\\x77\\x2e\\x74\\x63\\x70\\x64\\x66\\x2e\\x6f\\x72\\x67\\x29\";\n\t\t\t$lnk = \"\\x68\\x74\\x74\\x70\\x3a\\x2f\\x2f\\x77\\x77\\x77\\x2e\\x74\\x63\\x70\\x64\\x66\\x2e\\x6f\\x72\\x67\";\n\t\t\t$this->Cell(0, 0, $msg, 0, 0, 'L', 0, $lnk, 0, false, 'D', 'B');\n\t\t\t$this->_outRestoreGraphicsState();\n\t\t\t// restore graphic settings\n\t\t\t$this->setGraphicVars($gvars);\n\t\t}\n\t\t// close page\n\t\t$this->endPage();\n\t\t// close document\n\t\t$this->_enddoc();\n\t\t// unset all class variables (except critical ones)\n\t\t$this->_destroy(false);\n\t}\n\n\t/**\n\t * Move pointer at the specified document page and update page dimensions.\n\t * @param int $pnum page number (1 ... numpages)\n\t * @param boolean $resetmargins if true reset left, right, top margins and Y position.\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see getPage(), lastpage(), getNumPages()\n\t */\n\tpublic function setPage($pnum, $resetmargins=false) {\n\t\tif (($pnum == $this->page) AND ($this->state == 2)) {\n\t\t\treturn;\n\t\t}\n\t\tif (($pnum > 0) AND ($pnum <= $this->numpages)) {\n\t\t\t$this->state = 2;\n\t\t\t// save current graphic settings\n\t\t\t//$gvars = $this->getGraphicVars();\n\t\t\t$oldpage = $this->page;\n\t\t\t$this->page = $pnum;\n\t\t\t$this->wPt = $this->pagedim[$this->page]['w'];\n\t\t\t$this->hPt = $this->pagedim[$this->page]['h'];\n\t\t\t$this->w = $this->pagedim[$this->page]['wk'];\n\t\t\t$this->h = $this->pagedim[$this->page]['hk'];\n\t\t\t$this->tMargin = $this->pagedim[$this->page]['tm'];\n\t\t\t$this->bMargin = $this->pagedim[$this->page]['bm'];\n\t\t\t$this->original_lMargin = $this->pagedim[$this->page]['olm'];\n\t\t\t$this->original_rMargin = $this->pagedim[$this->page]['orm'];\n\t\t\t$this->AutoPageBreak = $this->pagedim[$this->page]['pb'];\n\t\t\t$this->CurOrientation = $this->pagedim[$this->page]['or'];\n\t\t\t$this->setAutoPageBreak($this->AutoPageBreak, $this->bMargin);\n\t\t\t// restore graphic settings\n\t\t\t//$this->setGraphicVars($gvars);\n\t\t\tif ($resetmargins) {\n\t\t\t\t$this->lMargin = $this->pagedim[$this->page]['olm'];\n\t\t\t\t$this->rMargin = $this->pagedim[$this->page]['orm'];\n\t\t\t\t$this->setY($this->tMargin);\n\t\t\t} else {\n\t\t\t\t// account for booklet mode\n\t\t\t\tif ($this->pagedim[$this->page]['olm'] != $this->pagedim[$oldpage]['olm']) {\n\t\t\t\t\t$deltam = $this->pagedim[$this->page]['olm'] - $this->pagedim[$this->page]['orm'];\n\t\t\t\t\t$this->lMargin += $deltam;\n\t\t\t\t\t$this->rMargin -= $deltam;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$this->Error('Wrong page number on setPage() function: '.$pnum);\n\t\t}\n\t}\n\n\t/**\n\t * Reset pointer to the last document page.\n\t * @param boolean $resetmargins if true reset left, right, top margins and Y position.\n\t * @public\n\t * @since 2.0.000 (2008-01-04)\n\t * @see setPage(), getPage(), getNumPages()\n\t */\n\tpublic function lastPage($resetmargins=false) {\n\t\t$this->setPage($this->getNumPages(), $resetmargins);\n\t}\n\n\t/**\n\t * Get current document page number.\n\t * @return int page number\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see setPage(), lastpage(), getNumPages()\n\t */\n\tpublic function getPage() {\n\t\treturn $this->page;\n\t}\n\n\t/**\n\t * Get the total number of insered pages.\n\t * @return int number of pages\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see setPage(), getPage(), lastpage()\n\t */\n\tpublic function getNumPages() {\n\t\treturn $this->numpages;\n\t}\n\n\t/**\n\t * Adds a new TOC (Table Of Content) page to the document.\n\t * @param string $orientation page orientation.\n\t * @param mixed $format The format used for pages. It can be either: one of the string values specified at getPageSizeFromFormat() or an array of parameters specified at setPageFormat().\n\t * @param boolean $keepmargins if true overwrites the default page margins with the current margins\n\t * @public\n\t * @since 5.0.001 (2010-05-06)\n\t * @see AddPage(), startPage(), endPage(), endTOCPage()\n\t */\n\tpublic function addTOCPage($orientation='', $format='', $keepmargins=false) {\n\t\t$this->AddPage($orientation, $format, $keepmargins, true);\n\t}\n\n\t/**\n\t * Terminate the current TOC (Table Of Content) page\n\t * @public\n\t * @since 5.0.001 (2010-05-06)\n\t * @see AddPage(), startPage(), endPage(), addTOCPage()\n\t */\n\tpublic function endTOCPage() {\n\t\t$this->endPage(true);\n\t}\n\n\t/**\n\t * Adds a new page to the document. If a page is already present, the Footer() method is called first to output the footer (if enabled). Then the page is added, the current position set to the top-left corner according to the left and top margins (or top-right if in RTL mode), and Header() is called to display the header (if enabled).\n\t * The origin of the coordinate system is at the top-left corner (or top-right for RTL) and increasing ordinates go downwards.\n\t * @param string $orientation page orientation. Possible values are (case insensitive):<ul><li>P or PORTRAIT (default)</li><li>L or LANDSCAPE</li></ul>\n\t * @param mixed $format The format used for pages. It can be either: one of the string values specified at getPageSizeFromFormat() or an array of parameters specified at setPageFormat().\n\t * @param boolean $keepmargins if true overwrites the default page margins with the current margins\n\t * @param boolean $tocpage if true set the tocpage state to true (the added page will be used to display Table Of Content).\n\t * @public\n\t * @since 1.0\n\t * @see startPage(), endPage(), addTOCPage(), endTOCPage(), getPageSizeFromFormat(), setPageFormat()\n\t */\n\tpublic function AddPage($orientation='', $format='', $keepmargins=false, $tocpage=false) {\n\t\tif ($this->inxobj) {\n\t\t\t// we are inside an XObject template\n\t\t\treturn;\n\t\t}\n\t\tif (!isset($this->original_lMargin) OR $keepmargins) {\n\t\t\t$this->original_lMargin = $this->lMargin;\n\t\t}\n\t\tif (!isset($this->original_rMargin) OR $keepmargins) {\n\t\t\t$this->original_rMargin = $this->rMargin;\n\t\t}\n\t\t// terminate previous page\n\t\t$this->endPage();\n\t\t// start new page\n\t\t$this->startPage($orientation, $format, $tocpage);\n\t}\n\n\t/**\n\t * Terminate the current page\n\t * @param boolean $tocpage if true set the tocpage state to false (end the page used to display Table Of Content).\n\t * @public\n\t * @since 4.2.010 (2008-11-14)\n\t * @see AddPage(), startPage(), addTOCPage(), endTOCPage()\n\t */\n\tpublic function endPage($tocpage=false) {\n\t\t// check if page is already closed\n\t\tif (($this->page == 0) OR ($this->numpages > $this->page) OR (!$this->pageopen[$this->page])) {\n\t\t\treturn;\n\t\t}\n\t\t// print page footer\n\t\t$this->setFooter();\n\t\t// close page\n\t\t$this->_endpage();\n\t\t// mark page as closed\n\t\t$this->pageopen[$this->page] = false;\n\t\tif ($tocpage) {\n\t\t\t$this->tocpage = false;\n\t\t}\n\t}\n\n\t/**\n\t * Starts a new page to the document. The page must be closed using the endPage() function.\n\t * The origin of the coordinate system is at the top-left corner and increasing ordinates go downwards.\n\t * @param string $orientation page orientation. Possible values are (case insensitive):<ul><li>P or PORTRAIT (default)</li><li>L or LANDSCAPE</li></ul>\n\t * @param mixed $format The format used for pages. It can be either: one of the string values specified at getPageSizeFromFormat() or an array of parameters specified at setPageFormat().\n\t * @param boolean $tocpage if true the page is designated to contain the Table-Of-Content.\n\t * @since 4.2.010 (2008-11-14)\n\t * @see AddPage(), endPage(), addTOCPage(), endTOCPage(), getPageSizeFromFormat(), setPageFormat()\n\t * @public\n\t */\n\tpublic function startPage($orientation='', $format='', $tocpage=false) {\n\t\tif ($tocpage) {\n\t\t\t$this->tocpage = true;\n\t\t}\n\t\t// move page numbers of documents to be attached\n\t\tif ($this->tocpage) {\n\t\t\t// move reference to unexistent pages (used for page attachments)\n\t\t\t// adjust outlines\n\t\t\t$tmpoutlines = $this->outlines;\n\t\t\tforeach ($tmpoutlines as $key => $outline) {\n\t\t\t\tif (!$outline['f'] AND ($outline['p'] > $this->numpages)) {\n\t\t\t\t\t$this->outlines[$key]['p'] = ($outline['p'] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// adjust dests\n\t\t\t$tmpdests = $this->dests;\n\t\t\tforeach ($tmpdests as $key => $dest) {\n\t\t\t\tif (!$dest['f'] AND ($dest['p'] > $this->numpages)) {\n\t\t\t\t\t$this->dests[$key]['p'] = ($dest['p'] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// adjust links\n\t\t\t$tmplinks = $this->links;\n\t\t\tforeach ($tmplinks as $key => $link) {\n\t\t\t\tif (!$link['f'] AND ($link['p'] > $this->numpages)) {\n\t\t\t\t\t$this->links[$key]['p'] = ($link['p'] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ($this->numpages > $this->page) {\n\t\t\t// this page has been already added\n\t\t\t$this->setPage($this->page + 1);\n\t\t\t$this->setY($this->tMargin);\n\t\t\treturn;\n\t\t}\n\t\t// start a new page\n\t\tif ($this->state == 0) {\n\t\t\t$this->Open();\n\t\t}\n\t\t++$this->numpages;\n\t\t$this->swapMargins($this->booklet);\n\t\t// save current graphic settings\n\t\t$gvars = $this->getGraphicVars();\n\t\t// start new page\n\t\t$this->_beginpage($orientation, $format);\n\t\t// mark page as open\n\t\t$this->pageopen[$this->page] = true;\n\t\t// restore graphic settings\n\t\t$this->setGraphicVars($gvars);\n\t\t// mark this point\n\t\t$this->setPageMark();\n\t\t// print page header\n\t\t$this->setHeader();\n\t\t// restore graphic settings\n\t\t$this->setGraphicVars($gvars);\n\t\t// mark this point\n\t\t$this->setPageMark();\n\t\t// print table header (if any)\n\t\t$this->setTableHeader();\n\t\t// set mark for empty page check\n\t\t$this->emptypagemrk[$this->page]= $this->pagelen[$this->page];\n\t}\n\n\t/**\n\t * Set start-writing mark on current page stream used to put borders and fills.\n\t * Borders and fills are always created after content and inserted on the position marked by this method.\n\t * This function must be called after calling Image() function for a background image.\n\t * Background images must be always inserted before calling Multicell() or WriteHTMLCell() or WriteHTML() functions.\n\t * @public\n\t * @since 4.0.016 (2008-07-30)\n\t */\n\tpublic function setPageMark() {\n\t\t$this->intmrk[$this->page] = $this->pagelen[$this->page];\n\t\t$this->bordermrk[$this->page] = $this->intmrk[$this->page];\n\t\t$this->setContentMark();\n\t}\n\n\t/**\n\t * Set start-writing mark on selected page.\n\t * Borders and fills are always created after content and inserted on the position marked by this method.\n\t * @param int $page page number (default is the current page)\n\t * @protected\n\t * @since 4.6.021 (2009-07-20)\n\t */\n\tprotected function setContentMark($page=0) {\n\t\tif ($page <= 0) {\n\t\t\t$page = $this->page;\n\t\t}\n\t\tif (isset($this->footerlen[$page])) {\n\t\t\t$this->cntmrk[$page] = $this->pagelen[$page] - $this->footerlen[$page];\n\t\t} else {\n\t\t\t$this->cntmrk[$page] = $this->pagelen[$page];\n\t\t}\n\t}\n\n\t/**\n\t * Set header data.\n\t * @param string $ln header image logo\n\t * @param int $lw header image logo width in mm\n\t * @param string $ht string to print as title on document header\n\t * @param string $hs string to print on document header\n\t * @param int[] $tc RGB array color for text.\n\t * @param int[] $lc RGB array color for line.\n\t * @public\n\t */\n\tpublic function setHeaderData($ln='', $lw=0, $ht='', $hs='', $tc=array(0,0,0), $lc=array(0,0,0)) {\n\t\t$this->header_logo = $ln;\n\t\t$this->header_logo_width = $lw;\n\t\t$this->header_title = $ht;\n\t\t$this->header_string = $hs;\n\t\t$this->header_text_color = $tc;\n\t\t$this->header_line_color = $lc;\n\t}\n\n\t/**\n\t * Set footer data.\n\t * @param int[] $tc RGB array color for text.\n\t * @param int[] $lc RGB array color for line.\n\t * @public\n\t */\n\tpublic function setFooterData($tc=array(0,0,0), $lc=array(0,0,0)) {\n\t\t$this->footer_text_color = $tc;\n\t\t$this->footer_line_color = $lc;\n\t}\n\n\t/**\n\t * Returns header data:\n\t * <ul><li>$ret['logo'] = logo image</li><li>$ret['logo_width'] = width of the image logo in user units</li><li>$ret['title'] = header title</li><li>$ret['string'] = header description string</li></ul>\n\t * @return array<string,mixed>\n\t * @public\n\t * @since 4.0.012 (2008-07-24)\n\t */\n\tpublic function getHeaderData() {\n\t\t$ret = array();\n\t\t$ret['logo'] = $this->header_logo;\n\t\t$ret['logo_width'] = $this->header_logo_width;\n\t\t$ret['title'] = $this->header_title;\n\t\t$ret['string'] = $this->header_string;\n\t\t$ret['text_color'] = $this->header_text_color;\n\t\t$ret['line_color'] = $this->header_line_color;\n\t\treturn $ret;\n\t}\n\n\t/**\n\t * Set header margin.\n\t * (minimum distance between header and top page margin)\n\t * @param float $hm distance in user units\n\t * @public\n\t */\n\tpublic function setHeaderMargin($hm=10) {\n\t\t$this->header_margin = $hm;\n\t}\n\n\t/**\n\t * Returns header margin in user units.\n\t * @return float\n\t * @since 4.0.012 (2008-07-24)\n\t * @public\n\t */\n\tpublic function getHeaderMargin() {\n\t\treturn $this->header_margin;\n\t}\n\n\t/**\n\t * Set footer margin.\n\t * (minimum distance between footer and bottom page margin)\n\t * @param float $fm distance in user units\n\t * @public\n\t */\n\tpublic function setFooterMargin($fm=10) {\n\t\t$this->footer_margin = $fm;\n\t}\n\n\t/**\n\t * Returns footer margin in user units.\n\t * @return float\n\t * @since 4.0.012 (2008-07-24)\n\t * @public\n\t */\n\tpublic function getFooterMargin() {\n\t\treturn $this->footer_margin;\n\t}\n\t/**\n\t * Set a flag to print page header.\n\t * @param boolean $val set to true to print the page header (default), false otherwise.\n\t * @public\n\t */\n\tpublic function setPrintHeader($val=true) {\n\t\t$this->print_header = $val ? true : false;\n\t}\n\n\t/**\n\t * Set a flag to print page footer.\n\t * @param boolean $val set to true to print the page footer (default), false otherwise.\n\t * @public\n\t */\n\tpublic function setPrintFooter($val=true) {\n\t\t$this->print_footer = $val ? true : false;\n\t}\n\n\t/**\n\t * Return the right-bottom (or left-bottom for RTL) corner X coordinate of last inserted image\n\t * @return float\n\t * @public\n\t */\n\tpublic function getImageRBX() {\n\t\treturn $this->img_rb_x;\n\t}\n\n\t/**\n\t * Return the right-bottom (or left-bottom for RTL) corner Y coordinate of last inserted image\n\t * @return float\n\t * @public\n\t */\n\tpublic function getImageRBY() {\n\t\treturn $this->img_rb_y;\n\t}\n\n\t/**\n\t * Reset the xobject template used by Header() method.\n\t * @public\n\t */\n\tpublic function resetHeaderTemplate() {\n\t\t$this->header_xobjid = false;\n\t}\n\n\t/**\n\t * Set a flag to automatically reset the xobject template used by Header() method at each page.\n\t * @param boolean $val set to true to reset Header xobject template at each page, false otherwise.\n\t * @public\n\t */\n\tpublic function setHeaderTemplateAutoreset($val=true) {\n\t\t$this->header_xobj_autoreset = $val ? true : false;\n\t}\n\n\t/**\n\t * This method is used to render the page header.\n\t * It is automatically called by AddPage() and could be overwritten in your own inherited class.\n\t * @public\n\t */\n\tpublic function Header() {\n\t\tif ($this->header_xobjid === false) {\n\t\t\t// start a new XObject Template\n\t\t\t$this->header_xobjid = $this->startTemplate($this->w, $this->tMargin);\n\t\t\t$headerfont = $this->getHeaderFont();\n\t\t\t$headerdata = $this->getHeaderData();\n\t\t\t$this->y = $this->header_margin;\n\t\t\tif ($this->rtl) {\n\t\t\t\t$this->x = $this->w - $this->original_rMargin;\n\t\t\t} else {\n\t\t\t\t$this->x = $this->original_lMargin;\n\t\t\t}\n\t\t\tif (($headerdata['logo']) AND ($headerdata['logo'] != K_BLANK_IMAGE)) {\n\t\t\t\t$imgtype = TCPDF_IMAGES::getImageFileType(K_PATH_IMAGES.$headerdata['logo']);\n\t\t\t\tif (($imgtype == 'eps') OR ($imgtype == 'ai')) {\n\t\t\t\t\t$this->ImageEps(K_PATH_IMAGES.$headerdata['logo'], '', '', $headerdata['logo_width']);\n\t\t\t\t} elseif ($imgtype == 'svg') {\n\t\t\t\t\t$this->ImageSVG(K_PATH_IMAGES.$headerdata['logo'], '', '', $headerdata['logo_width']);\n\t\t\t\t} else {\n\t\t\t\t\t$this->Image(K_PATH_IMAGES.$headerdata['logo'], '', '', $headerdata['logo_width']);\n\t\t\t\t}\n\t\t\t\t$imgy = $this->getImageRBY();\n\t\t\t} else {\n\t\t\t\t$imgy = $this->y;\n\t\t\t}\n\t\t\t$cell_height = $this->getCellHeight($headerfont[2] / $this->k);\n\t\t\t// set starting margin for text data cell\n\t\t\tif ($this->getRTL()) {\n\t\t\t\t$header_x = $this->original_rMargin + ($headerdata['logo_width'] * 1.1);\n\t\t\t} else {\n\t\t\t\t$header_x = $this->original_lMargin + ($headerdata['logo_width'] * 1.1);\n\t\t\t}\n\t\t\t$cw = $this->w - $this->original_lMargin - $this->original_rMargin - ($headerdata['logo_width'] * 1.1);\n\t\t\t$this->setTextColorArray($this->header_text_color);\n\t\t\t// header title\n\t\t\t$this->setFont($headerfont[0], 'B', $headerfont[2] + 1);\n\t\t\t$this->setX($header_x);\n\t\t\t$this->Cell($cw, $cell_height, $headerdata['title'], 0, 1, '', 0, '', 0);\n\t\t\t// header string\n\t\t\t$this->setFont($headerfont[0], $headerfont[1], $headerfont[2]);\n\t\t\t$this->setX($header_x);\n\t\t\t$this->MultiCell($cw, $cell_height, $headerdata['string'], 0, '', 0, 1, '', '', true, 0, false, true, 0, 'T', false);\n\t\t\t// print an ending header line\n\t\t\t$this->setLineStyle(array('width' => 0.85 / $this->k, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => $headerdata['line_color']));\n\t\t\t$this->setY((2.835 / $this->k) + max($imgy, $this->y));\n\t\t\tif ($this->rtl) {\n\t\t\t\t$this->setX($this->original_rMargin);\n\t\t\t} else {\n\t\t\t\t$this->setX($this->original_lMargin);\n\t\t\t}\n\t\t\t$this->Cell(($this->w - $this->original_lMargin - $this->original_rMargin), 0, '', 'T', 0, 'C');\n\t\t\t$this->endTemplate();\n\t\t}\n\t\t// print header template\n\t\t$x = 0;\n\t\t$dx = 0;\n\t\tif (!$this->header_xobj_autoreset AND $this->booklet AND (($this->page % 2) == 0)) {\n\t\t\t// adjust margins for booklet mode\n\t\t\t$dx = ($this->original_lMargin - $this->original_rMargin);\n\t\t}\n\t\tif ($this->rtl) {\n\t\t\t$x = $this->w + $dx;\n\t\t} else {\n\t\t\t$x = 0 + $dx;\n\t\t}\n\t\t$this->printTemplate($this->header_xobjid, $x, 0, 0, 0, '', '', false);\n\t\tif ($this->header_xobj_autoreset) {\n\t\t\t// reset header xobject template at each page\n\t\t\t$this->header_xobjid = false;\n\t\t}\n\t}\n\n\t/**\n\t * This method is used to render the page footer.\n\t * It is automatically called by AddPage() and could be overwritten in your own inherited class.\n\t * @public\n\t */\n\tpublic function Footer() {\n\t\t$cur_y = $this->y;\n\t\t$this->setTextColorArray($this->footer_text_color);\n\t\t//set style for cell border\n\t\t$line_width = (0.85 / $this->k);\n\t\t$this->setLineStyle(array('width' => $line_width, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => $this->footer_line_color));\n\t\t//print document barcode\n\t\t$barcode = $this->getBarcode();\n\t\tif (!empty($barcode)) {\n\t\t\t$this->Ln($line_width);\n\t\t\t$barcode_width = round(($this->w - $this->original_lMargin - $this->original_rMargin) / 3);\n\t\t\t$style = array(\n\t\t\t\t'position' => $this->rtl?'R':'L',\n\t\t\t\t'align' => $this->rtl?'R':'L',\n\t\t\t\t'stretch' => false,\n\t\t\t\t'fitwidth' => true,\n\t\t\t\t'cellfitalign' => '',\n\t\t\t\t'border' => false,\n\t\t\t\t'padding' => 0,\n\t\t\t\t'fgcolor' => array(0,0,0),\n\t\t\t\t'bgcolor' => false,\n\t\t\t\t'text' => false\n\t\t\t);\n\t\t\t$this->write1DBarcode($barcode, 'C128', '', $cur_y + $line_width, '', (($this->footer_margin / 3) - $line_width), 0.3, $style, '');\n\t\t}\n\t\t$w_page = isset($this->l['w_page']) ? $this->l['w_page'].' ' : '';\n\t\tif (empty($this->pagegroups)) {\n\t\t\t$pagenumtxt = $w_page.$this->getAliasNumPage().' / '.$this->getAliasNbPages();\n\t\t} else {\n\t\t\t$pagenumtxt = $w_page.$this->getPageNumGroupAlias().' / '.$this->getPageGroupAlias();\n\t\t}\n\t\t$this->setY($cur_y);\n\t\t//Print page number\n\t\tif ($this->getRTL()) {\n\t\t\t$this->setX($this->original_rMargin);\n\t\t\t$this->Cell(0, 0, $pagenumtxt, 'T', 0, 'L');\n\t\t} else {\n\t\t\t$this->setX($this->original_lMargin);\n\t\t\t$this->Cell(0, 0, $this->getAliasRightShift().$pagenumtxt, 'T', 0, 'R');\n\t\t}\n\t}\n\n\t/**\n\t * This method is used to render the page header.\n\t * @protected\n\t * @since 4.0.012 (2008-07-24)\n\t */\n\tprotected function setHeader() {\n\t\tif (!$this->print_header OR ($this->state != 2)) {\n\t\t\treturn;\n\t\t}\n\t\t$this->InHeader = true;\n\t\t$this->setGraphicVars($this->default_graphic_vars);\n\t\t$temp_thead = $this->thead;\n\t\t$temp_theadMargins = $this->theadMargins;\n\t\t$lasth = $this->lasth;\n\t\t$newline = $this->newline;\n\t\t$this->_outSaveGraphicsState();\n\t\t$this->rMargin = $this->original_rMargin;\n\t\t$this->lMargin = $this->original_lMargin;\n\t\t$this->setCellPadding(0);\n\t\t//set current position\n\t\tif ($this->rtl) {\n\t\t\t$this->setXY($this->original_rMargin, $this->header_margin);\n\t\t} else {\n\t\t\t$this->setXY($this->original_lMargin, $this->header_margin);\n\t\t}\n\t\t$this->setFont($this->header_font[0], $this->header_font[1], $this->header_font[2]);\n\t\t$this->Header();\n\t\t//restore position\n\t\tif ($this->rtl) {\n\t\t\t$this->setXY($this->original_rMargin, $this->tMargin);\n\t\t} else {\n\t\t\t$this->setXY($this->original_lMargin, $this->tMargin);\n\t\t}\n\t\t$this->_outRestoreGraphicsState();\n\t\t$this->lasth = $lasth;\n\t\t$this->thead = $temp_thead;\n\t\t$this->theadMargins = $temp_theadMargins;\n\t\t$this->newline = $newline;\n\t\t$this->InHeader = false;\n\t}\n\n\t/**\n\t * This method is used to render the page footer.\n\t * @protected\n\t * @since 4.0.012 (2008-07-24)\n\t */\n\tprotected function setFooter() {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\t$this->InFooter = true;\n\t\t// save current graphic settings\n\t\t$gvars = $this->getGraphicVars();\n\t\t// mark this point\n\t\t$this->footerpos[$this->page] = $this->pagelen[$this->page];\n\t\t$this->_out(\"\\n\");\n\t\tif ($this->print_footer) {\n\t\t\t$this->setGraphicVars($this->default_graphic_vars);\n\t\t\t$this->current_column = 0;\n\t\t\t$this->num_columns = 1;\n\t\t\t$temp_thead = $this->thead;\n\t\t\t$temp_theadMargins = $this->theadMargins;\n\t\t\t$lasth = $this->lasth;\n\t\t\t$this->_outSaveGraphicsState();\n\t\t\t$this->rMargin = $this->original_rMargin;\n\t\t\t$this->lMargin = $this->original_lMargin;\n\t\t\t$this->setCellPadding(0);\n\t\t\t//set current position\n\t\t\t$footer_y = $this->h - $this->footer_margin;\n\t\t\tif ($this->rtl) {\n\t\t\t\t$this->setXY($this->original_rMargin, $footer_y);\n\t\t\t} else {\n\t\t\t\t$this->setXY($this->original_lMargin, $footer_y);\n\t\t\t}\n\t\t\t$this->setFont($this->footer_font[0], $this->footer_font[1], $this->footer_font[2]);\n\t\t\t$this->Footer();\n\t\t\t//restore position\n\t\t\tif ($this->rtl) {\n\t\t\t\t$this->setXY($this->original_rMargin, $this->tMargin);\n\t\t\t} else {\n\t\t\t\t$this->setXY($this->original_lMargin, $this->tMargin);\n\t\t\t}\n\t\t\t$this->_outRestoreGraphicsState();\n\t\t\t$this->lasth = $lasth;\n\t\t\t$this->thead = $temp_thead;\n\t\t\t$this->theadMargins = $temp_theadMargins;\n\t\t}\n\t\t// restore graphic settings\n\t\t$this->setGraphicVars($gvars);\n\t\t$this->current_column = $gvars['current_column'];\n\t\t$this->num_columns = $gvars['num_columns'];\n\t\t// calculate footer length\n\t\t$this->footerlen[$this->page] = $this->pagelen[$this->page] - $this->footerpos[$this->page] + 1;\n\t\t$this->InFooter = false;\n\t}\n\n\t/**\n\t * Check if we are on the page body (excluding page header and footer).\n\t * @return bool true if we are not in page header nor in page footer, false otherwise.\n\t * @protected\n\t * @since 5.9.091 (2011-06-15)\n\t */\n\tprotected function inPageBody() {\n\t\treturn (($this->InHeader === false) AND ($this->InFooter === false));\n\t}\n\n\t/**\n\t * This method is used to render the table header on new page (if any).\n\t * @protected\n\t * @since 4.5.030 (2009-03-25)\n\t */\n\tprotected function setTableHeader() {\n\t\tif ($this->num_columns > 1) {\n\t\t\t// multi column mode\n\t\t\treturn;\n\t\t}\n\t\tif (isset($this->theadMargins['top'])) {\n\t\t\t// restore the original top-margin\n\t\t\t$this->tMargin = $this->theadMargins['top'];\n\t\t\t$this->pagedim[$this->page]['tm'] = $this->tMargin;\n\t\t\t$this->y = $this->tMargin;\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($this->thead) AND (!$this->inthead)) {\n\t\t\t// set margins\n\t\t\t$prev_lMargin = $this->lMargin;\n\t\t\t$prev_rMargin = $this->rMargin;\n\t\t\t$prev_cell_padding = $this->cell_padding;\n\t\t\t$this->lMargin = $this->theadMargins['lmargin'] + ($this->pagedim[$this->page]['olm'] - $this->pagedim[$this->theadMargins['page']]['olm']);\n\t\t\t$this->rMargin = $this->theadMargins['rmargin'] + ($this->pagedim[$this->page]['orm'] - $this->pagedim[$this->theadMargins['page']]['orm']);\n\t\t\t$this->cell_padding = $this->theadMargins['cell_padding'];\n\t\t\tif ($this->rtl) {\n\t\t\t\t$this->x = $this->w - $this->rMargin;\n\t\t\t} else {\n\t\t\t\t$this->x = $this->lMargin;\n\t\t\t}\n\t\t\t// account for special \"cell\" mode\n\t\t\tif ($this->theadMargins['cell']) {\n\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t$this->x -= $this->cell_padding['R'];\n\t\t\t\t} else {\n\t\t\t\t\t$this->x += $this->cell_padding['L'];\n\t\t\t\t}\n\t\t\t}\n\t\t\t$gvars = $this->getGraphicVars();\n\t\t\tif (!empty($this->theadMargins['gvars'])) {\n\t\t\t\t// set the correct graphic style\n\t\t\t\t$this->setGraphicVars($this->theadMargins['gvars']);\n\t\t\t\t$this->rMargin = $gvars['rMargin'];\n\t\t\t\t$this->lMargin = $gvars['lMargin'];\n\t\t\t}\n\t\t\t// print table header\n\t\t\t$this->writeHTML($this->thead, false, false, false, false, '');\n\t\t\t$this->setGraphicVars($gvars);\n\t\t\t// set new top margin to skip the table headers\n\t\t\tif (!isset($this->theadMargins['top'])) {\n\t\t\t\t$this->theadMargins['top'] = $this->tMargin;\n\t\t\t}\n\t\t\t// store end of header position\n\t\t\tif (!isset($this->columns[0]['th'])) {\n\t\t\t\t$this->columns[0]['th'] = array();\n\t\t\t}\n\t\t\t$this->columns[0]['th']['\\''.$this->page.'\\''] = $this->y;\n\t\t\t$this->tMargin = $this->y;\n\t\t\t$this->pagedim[$this->page]['tm'] = $this->tMargin;\n\t\t\t$this->lasth = 0;\n\t\t\t$this->lMargin = $prev_lMargin;\n\t\t\t$this->rMargin = $prev_rMargin;\n\t\t\t$this->cell_padding = $prev_cell_padding;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the current page number.\n\t * @return int page number\n\t * @public\n\t * @since 1.0\n\t * @see getAliasNbPages()\n\t */\n\tpublic function PageNo() {\n\t\treturn $this->page;\n\t}\n\n\t/**\n\t * Returns the array of spot colors.\n\t * @return array Spot colors array.\n\t * @public\n\t * @since 6.0.038 (2013-09-30)\n\t */\n\tpublic function getAllSpotColors() {\n\t\treturn $this->spot_colors;\n\t}\n\n\t/**\n\t * Defines a new spot color.\n\t * It can be expressed in RGB components or gray scale.\n\t * The method can be called before the first page is created and the value is retained from page to page.\n\t * @param string $name Full name of the spot color.\n\t * @param float $c Cyan color for CMYK. Value between 0 and 100.\n\t * @param float $m Magenta color for CMYK. Value between 0 and 100.\n\t * @param float $y Yellow color for CMYK. Value between 0 and 100.\n\t * @param float $k Key (Black) color for CMYK. Value between 0 and 100.\n\t * @public\n\t * @since 4.0.024 (2008-09-12)\n\t * @see SetDrawSpotColor(), SetFillSpotColor(), SetTextSpotColor()\n\t */\n\tpublic function AddSpotColor($name, $c, $m, $y, $k) {\n\t\tif (!isset($this->spot_colors[$name])) {\n\t\t\t$i = (1 + count($this->spot_colors));\n\t\t\t$this->spot_colors[$name] = array('C' => $c, 'M' => $m, 'Y' => $y, 'K' => $k, 'name' => $name, 'i' => $i);\n\t\t}\n\t}\n\n\t/**\n\t * Set the spot color for the specified type ('draw', 'fill', 'text').\n\t * @param string $type Type of object affected by this color: ('draw', 'fill', 'text').\n\t * @param string $name Name of the spot color.\n\t * @param float $tint Intensity of the color (from 0 to 100 ; 100 = full intensity by default).\n\t * @return string PDF color command.\n\t * @public\n\t * @since 5.9.125 (2011-10-03)\n\t */\n\tpublic function setSpotColor($type, $name, $tint=100) {\n\t\t$spotcolor = TCPDF_COLORS::getSpotColor($name, $this->spot_colors);\n\t\tif ($spotcolor === false) {\n\t\t\t$this->Error('Undefined spot color: '.$name.', you must add it using the AddSpotColor() method.');\n\t\t}\n\t\t$tint = (max(0, min(100, $tint)) / 100);\n\t\t$pdfcolor = sprintf('/CS%d ', $this->spot_colors[$name]['i']);\n\t\tswitch ($type) {\n\t\t\tcase 'draw': {\n\t\t\t\t$pdfcolor .= sprintf('CS %F SCN', $tint);\n\t\t\t\t$this->DrawColor = $pdfcolor;\n\t\t\t\t$this->strokecolor = $spotcolor;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'fill': {\n\t\t\t\t$pdfcolor .= sprintf('cs %F scn', $tint);\n\t\t\t\t$this->FillColor = $pdfcolor;\n\t\t\t\t$this->bgcolor = $spotcolor;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'text': {\n\t\t\t\t$pdfcolor .= sprintf('cs %F scn', $tint);\n\t\t\t\t$this->TextColor = $pdfcolor;\n\t\t\t\t$this->fgcolor = $spotcolor;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$this->ColorFlag = ($this->FillColor != $this->TextColor);\n\t\tif ($this->state == 2) {\n\t\t\t$this->_out($pdfcolor);\n\t\t}\n\t\tif ($this->inxobj) {\n\t\t\t// we are inside an XObject template\n\t\t\t$this->xobjects[$this->xobjid]['spot_colors'][$name] = $this->spot_colors[$name];\n\t\t}\n\t\treturn $pdfcolor;\n\t}\n\n\t/**\n\t * Defines the spot color used for all drawing operations (lines, rectangles and cell borders).\n\t * @param string $name Name of the spot color.\n\t * @param float $tint Intensity of the color (from 0 to 100 ; 100 = full intensity by default).\n\t * @public\n\t * @since 4.0.024 (2008-09-12)\n\t * @see AddSpotColor(), SetFillSpotColor(), SetTextSpotColor()\n\t */\n\tpublic function setDrawSpotColor($name, $tint=100) {\n\t\t$this->setSpotColor('draw', $name, $tint);\n\t}\n\n\t/**\n\t * Defines the spot color used for all filling operations (filled rectangles and cell backgrounds).\n\t * @param string $name Name of the spot color.\n\t * @param float $tint Intensity of the color (from 0 to 100 ; 100 = full intensity by default).\n\t * @public\n\t * @since 4.0.024 (2008-09-12)\n\t * @see AddSpotColor(), SetDrawSpotColor(), SetTextSpotColor()\n\t */\n\tpublic function setFillSpotColor($name, $tint=100) {\n\t\t$this->setSpotColor('fill', $name, $tint);\n\t}\n\n\t/**\n\t * Defines the spot color used for text.\n\t * @param string $name Name of the spot color.\n\t * @param int $tint Intensity of the color (from 0 to 100 ; 100 = full intensity by default).\n\t * @public\n\t * @since 4.0.024 (2008-09-12)\n\t * @see AddSpotColor(), SetDrawSpotColor(), SetFillSpotColor()\n\t */\n\tpublic function setTextSpotColor($name, $tint=100) {\n\t\t$this->setSpotColor('text', $name, $tint);\n\t}\n\n\t/**\n\t * Set the color array for the specified type ('draw', 'fill', 'text').\n\t * It can be expressed in RGB, CMYK or GRAY SCALE components.\n\t * The method can be called before the first page is created and the value is retained from page to page.\n\t * @param string $type Type of object affected by this color: ('draw', 'fill', 'text').\n\t * @param array $color Array of colors (1=gray, 3=RGB, 4=CMYK or 5=spotcolor=CMYK+name values).\n\t * @param boolean $ret If true do not send the PDF command.\n\t * @return string The PDF command or empty string.\n\t * @public\n\t * @since 3.1.000 (2008-06-11)\n\t */\n\tpublic function setColorArray($type, $color, $ret=false) {\n\t\tif (is_array($color)) {\n\t\t\t$color = array_values($color);\n\t\t\t// component: grey, RGB red or CMYK cyan\n\t\t\t$c = isset($color[0]) ? $color[0] : -1;\n\t\t\t// component: RGB green or CMYK magenta\n\t\t\t$m = isset($color[1]) ? $color[1] : -1;\n\t\t\t// component: RGB blue or CMYK yellow\n\t\t\t$y = isset($color[2]) ? $color[2] : -1;\n\t\t\t// component: CMYK black\n\t\t\t$k = isset($color[3]) ? $color[3] : -1;\n\t\t\t// color name\n\t\t\t$name = isset($color[4]) ? $color[4] : '';\n\t\t\tif ($c >= 0) {\n\t\t\t\treturn $this->setColor($type, $c, $m, $y, $k, $ret, $name);\n\t\t\t}\n\t\t}\n\t\treturn '';\n\t}\n\n\t/**\n\t * Defines the color used for all drawing operations (lines, rectangles and cell borders).\n\t * It can be expressed in RGB, CMYK or GRAY SCALE components.\n\t * The method can be called before the first page is created and the value is retained from page to page.\n\t * @param array $color Array of colors (1, 3 or 4 values).\n\t * @param boolean $ret If true do not send the PDF command.\n\t * @return string the PDF command\n\t * @public\n\t * @since 3.1.000 (2008-06-11)\n\t * @see SetDrawColor()\n\t */\n\tpublic function setDrawColorArray($color, $ret=false) {\n\t\treturn $this->setColorArray('draw', $color, $ret);\n\t}\n\n\t/**\n\t * Defines the color used for all filling operations (filled rectangles and cell backgrounds).\n\t * It can be expressed in RGB, CMYK or GRAY SCALE components.\n\t * The method can be called before the first page is created and the value is retained from page to page.\n\t * @param array $color Array of colors (1, 3 or 4 values).\n\t * @param boolean $ret If true do not send the PDF command.\n\t * @public\n\t * @since 3.1.000 (2008-6-11)\n\t * @see SetFillColor()\n\t */\n\tpublic function setFillColorArray($color, $ret=false) {\n\t\treturn $this->setColorArray('fill', $color, $ret);\n\t}\n\n\t/**\n\t * Defines the color used for text. It can be expressed in RGB components or gray scale.\n\t * The method can be called before the first page is created and the value is retained from page to page.\n\t * @param array $color Array of colors (1, 3 or 4 values).\n\t * @param boolean $ret If true do not send the PDF command.\n\t * @public\n\t * @since 3.1.000 (2008-6-11)\n\t * @see SetFillColor()\n\t */\n\tpublic function setTextColorArray($color, $ret=false) {\n\t\treturn $this->setColorArray('text', $color, $ret);\n\t}\n\n\t/**\n\t * Defines the color used by the specified type ('draw', 'fill', 'text').\n\t * @param string $type Type of object affected by this color: ('draw', 'fill', 'text').\n\t * @param float $col1 GRAY level for single color, or Red color for RGB (0-255), or CYAN color for CMYK (0-100).\n\t * @param float $col2 GREEN color for RGB (0-255), or MAGENTA color for CMYK (0-100).\n\t * @param float $col3 BLUE color for RGB (0-255), or YELLOW color for CMYK (0-100).\n\t * @param float $col4 KEY (BLACK) color for CMYK (0-100).\n\t * @param boolean $ret If true do not send the command.\n\t * @param string $name spot color name (if any)\n\t * @return string The PDF command or empty string.\n\t * @public\n\t * @since 5.9.125 (2011-10-03)\n\t */\n\tpublic function setColor($type, $col1=0, $col2=-1, $col3=-1, $col4=-1, $ret=false, $name='') {\n\t\t// set default values\n\t\tif (!is_numeric($col1)) {\n\t\t\t$col1 = 0;\n\t\t}\n\t\tif (!is_numeric($col2)) {\n\t\t\t$col2 = -1;\n\t\t}\n\t\tif (!is_numeric($col3)) {\n\t\t\t$col3 = -1;\n\t\t}\n\t\tif (!is_numeric($col4)) {\n\t\t\t$col4 = -1;\n\t\t}\n\t\t// set color by case\n\t\t$suffix = '';\n\t\tif (($col2 == -1) AND ($col3 == -1) AND ($col4 == -1)) {\n\t\t\t// Grey scale\n\t\t\t$col1 = max(0, min(255, $col1));\n\t\t\t$intcolor = array('G' => $col1);\n\t\t\t$pdfcolor = sprintf('%F ', ($col1 / 255));\n\t\t\t$suffix = 'g';\n\t\t} elseif ($col4 == -1) {\n\t\t\t// RGB\n\t\t\t$col1 = max(0, min(255, $col1));\n\t\t\t$col2 = max(0, min(255, $col2));\n\t\t\t$col3 = max(0, min(255, $col3));\n\t\t\t$intcolor = array('R' => $col1, 'G' => $col2, 'B' => $col3);\n\t\t\t$pdfcolor = sprintf('%F %F %F ', ($col1 / 255), ($col2 / 255), ($col3 / 255));\n\t\t\t$suffix = 'rg';\n\t\t} else {\n\t\t\t$col1 = max(0, min(100, $col1));\n\t\t\t$col2 = max(0, min(100, $col2));\n\t\t\t$col3 = max(0, min(100, $col3));\n\t\t\t$col4 = max(0, min(100, $col4));\n\t\t\tif (empty($name)) {\n\t\t\t\t// CMYK\n\t\t\t\t$intcolor = array('C' => $col1, 'M' => $col2, 'Y' => $col3, 'K' => $col4);\n\t\t\t\t$pdfcolor = sprintf('%F %F %F %F ', ($col1 / 100), ($col2 / 100), ($col3 / 100), ($col4 / 100));\n\t\t\t\t$suffix = 'k';\n\t\t\t} else {\n\t\t\t\t// SPOT COLOR\n\t\t\t\t$intcolor = array('C' => $col1, 'M' => $col2, 'Y' => $col3, 'K' => $col4, 'name' => $name);\n\t\t\t\t$this->AddSpotColor($name, $col1, $col2, $col3, $col4);\n\t\t\t\t$pdfcolor = $this->setSpotColor($type, $name, 100);\n\t\t\t}\n\t\t}\n\t\tswitch ($type) {\n\t\t\tcase 'draw': {\n\t\t\t\t$pdfcolor .= strtoupper($suffix);\n\t\t\t\t$this->DrawColor = $pdfcolor;\n\t\t\t\t$this->strokecolor = $intcolor;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'fill': {\n\t\t\t\t$pdfcolor .= $suffix;\n\t\t\t\t$this->FillColor = $pdfcolor;\n\t\t\t\t$this->bgcolor = $intcolor;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'text': {\n\t\t\t\t$pdfcolor .= $suffix;\n\t\t\t\t$this->TextColor = $pdfcolor;\n\t\t\t\t$this->fgcolor = $intcolor;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$this->ColorFlag = ($this->FillColor != $this->TextColor);\n\t\tif (($type != 'text') AND ($this->state == 2) AND $type !== 0) {\n\t\t\tif (!$ret) {\n\t\t\t\t$this->_out($pdfcolor);\n\t\t\t}\n\t\t\treturn $pdfcolor;\n\t\t}\n\t\treturn '';\n\t}\n\n\t/**\n\t * Defines the color used for all drawing operations (lines, rectangles and cell borders). It can be expressed in RGB components or gray scale. The method can be called before the first page is created and the value is retained from page to page.\n\t * @param float $col1 GRAY level for single color, or Red color for RGB (0-255), or CYAN color for CMYK (0-100).\n\t * @param float $col2 GREEN color for RGB (0-255), or MAGENTA color for CMYK (0-100).\n\t * @param float $col3 BLUE color for RGB (0-255), or YELLOW color for CMYK (0-100).\n\t * @param float $col4 KEY (BLACK) color for CMYK (0-100).\n\t * @param boolean $ret If true do not send the command.\n\t * @param string $name spot color name (if any)\n\t * @return string the PDF command\n\t * @public\n\t * @since 1.3\n\t * @see SetDrawColorArray(), SetFillColor(), SetTextColor(), Line(), Rect(), Cell(), MultiCell()\n\t */\n\tpublic function setDrawColor($col1=0, $col2=-1, $col3=-1, $col4=-1, $ret=false, $name='') {\n\t\treturn $this->setColor('draw', $col1, $col2, $col3, $col4, $ret, $name);\n\t}\n\n\t/**\n\t * Defines the color used for all filling operations (filled rectangles and cell backgrounds). It can be expressed in RGB components or gray scale. The method can be called before the first page is created and the value is retained from page to page.\n\t * @param float $col1 GRAY level for single color, or Red color for RGB (0-255), or CYAN color for CMYK (0-100).\n\t * @param float $col2 GREEN color for RGB (0-255), or MAGENTA color for CMYK (0-100).\n\t * @param float $col3 BLUE color for RGB (0-255), or YELLOW color for CMYK (0-100).\n\t * @param float $col4 KEY (BLACK) color for CMYK (0-100).\n\t * @param boolean $ret If true do not send the command.\n\t * @param string $name Spot color name (if any).\n\t * @return string The PDF command.\n\t * @public\n\t * @since 1.3\n\t * @see SetFillColorArray(), SetDrawColor(), SetTextColor(), Rect(), Cell(), MultiCell()\n\t */\n\tpublic function setFillColor($col1=0, $col2=-1, $col3=-1, $col4=-1, $ret=false, $name='') {\n\t\treturn $this->setColor('fill', $col1, $col2, $col3, $col4, $ret, $name);\n\t}\n\n\t/**\n\t * Defines the color used for text. It can be expressed in RGB components or gray scale. The method can be called before the first page is created and the value is retained from page to page.\n\t * @param float $col1 GRAY level for single color, or Red color for RGB (0-255), or CYAN color for CMYK (0-100).\n\t * @param float $col2 GREEN color for RGB (0-255), or MAGENTA color for CMYK (0-100).\n\t * @param float $col3 BLUE color for RGB (0-255), or YELLOW color for CMYK (0-100).\n\t * @param float $col4 KEY (BLACK) color for CMYK (0-100).\n\t * @param boolean $ret If true do not send the command.\n\t * @param string $name Spot color name (if any).\n\t * @return string Empty string.\n\t * @public\n\t * @since 1.3\n\t * @see SetTextColorArray(), SetDrawColor(), SetFillColor(), Text(), Cell(), MultiCell()\n\t */\n\tpublic function setTextColor($col1=0, $col2=-1, $col3=-1, $col4=-1, $ret=false, $name='') {\n\t\treturn $this->setColor('text', $col1, $col2, $col3, $col4, $ret, $name);\n\t}\n\n\t/**\n\t * Returns the length of a string in user unit. A font must be selected.<br>\n\t * @param string $s The string whose length is to be computed\n\t * @param string $fontname Family font. It can be either a name defined by AddFont() or one of the standard families. It is also possible to pass an empty string, in that case, the current family is retained.\n\t * @param string $fontstyle Font style. Possible values are (case insensitive):<ul><li>empty string: regular</li><li>B: bold</li><li>I: italic</li><li>U: underline</li><li>D: line-through</li><li>O: overline</li></ul> or any combination. The default value is regular.\n\t * @param float $fontsize Font size in points. The default value is the current size.\n\t * @param boolean $getarray if true returns an array of characters widths, if false returns the total length.\n\t * @return float[]|float total string length or array of characted widths\n\t * @phpstan-return ($getarray is true ? float[] : float) total string length or array of characted widths\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 1.2\n\t */\n\tpublic function GetStringWidth($s, $fontname='', $fontstyle='', $fontsize=0, $getarray=false) {\n\t\treturn $this->GetArrStringWidth(TCPDF_FONTS::utf8Bidi(TCPDF_FONTS::UTF8StringToArray($s, $this->isunicode, $this->CurrentFont), $s, $this->tmprtl, $this->isunicode, $this->CurrentFont), $fontname, $fontstyle, $fontsize, $getarray);\n\t}\n\n\t/**\n\t * Returns the string length of an array of chars in user unit or an array of characters widths. A font must be selected.<br>\n\t * @param array $sa The array of chars whose total length is to be computed\n\t * @param string $fontname Family font. It can be either a name defined by AddFont() or one of the standard families. It is also possible to pass an empty string, in that case, the current family is retained.\n\t * @param string $fontstyle Font style. Possible values are (case insensitive):<ul><li>empty string: regular</li><li>B: bold</li><li>I: italic</li><li>U: underline</li><li>D: line through</li><li>O: overline</li></ul> or any combination. The default value is regular.\n\t * @param float $fontsize Font size in points. The default value is the current size.\n\t * @param boolean $getarray if true returns an array of characters widths, if false returns the total length.\n\t * @return float[]|float total string length or array of characted widths\n\t * @phpstan-return ($getarray is true ? float[] : float) total string length or array of characted widths\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 2.4.000 (2008-03-06)\n\t */\n\tpublic function GetArrStringWidth($sa, $fontname='', $fontstyle='', $fontsize=0, $getarray=false) {\n\t\t// store current values\n\t\tif (!TCPDF_STATIC::empty_string($fontname)) {\n\t\t\t$prev_FontFamily = $this->FontFamily;\n\t\t\t$prev_FontStyle = $this->FontStyle;\n\t\t\t$prev_FontSizePt = $this->FontSizePt;\n\t\t\t$this->setFont($fontname, $fontstyle, $fontsize, '', 'default', false);\n\t\t}\n\t\t// convert UTF-8 array to Latin1 if required\n\t\tif ($this->isunicode AND (!$this->isUnicodeFont())) {\n\t\t\t$sa = TCPDF_FONTS::UTF8ArrToLatin1Arr($sa);\n\t\t}\n\t\t$w = 0; // total width\n\t\t$wa = array(); // array of characters widths\n\t\tforeach ($sa as $ck => $char) {\n\t\t\t// character width\n\t\t\t$cw = $this->GetCharWidth($char, isset($sa[($ck + 1)]));\n\t\t\t$wa[] = $cw;\n\t\t\t$w += $cw;\n\t\t}\n\t\t// restore previous values\n\t\tif (!TCPDF_STATIC::empty_string($fontname)) {\n\t\t\t$this->setFont($prev_FontFamily, $prev_FontStyle, $prev_FontSizePt, '', 'default', false);\n\t\t}\n\t\tif ($getarray) {\n\t\t\treturn $wa;\n\t\t}\n\t\treturn $w;\n\t}\n\n\t/**\n\t * Returns the length of the char in user unit for the current font considering current stretching and spacing (tracking).\n\t * @param int $char The char code whose length is to be returned\n\t * @param boolean $notlast If false ignore the font-spacing.\n\t * @return float char width\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 2.4.000 (2008-03-06)\n\t */\n\tpublic function GetCharWidth($char, $notlast=true) {\n\t\t// get raw width\n\t\t$chw = $this->getRawCharWidth($char);\n\t\tif (($this->font_spacing < 0) OR (($this->font_spacing > 0) AND $notlast)) {\n\t\t\t// increase/decrease font spacing\n\t\t\t$chw += $this->font_spacing;\n\t\t}\n\t\tif ($this->font_stretching != 100) {\n\t\t\t// fixed stretching mode\n\t\t\t$chw *= ($this->font_stretching / 100);\n\t\t}\n\t\treturn $chw;\n\t}\n\n\t/**\n\t * Returns the length of the char in user unit for the current font.\n\t * @param int $char The char code whose length is to be returned\n\t * @return float char width\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 5.9.000 (2010-09-28)\n\t */\n\tpublic function getRawCharWidth($char) {\n\t\tif ($char == 173) {\n\t\t\t// SHY character will not be printed\n\t\t\treturn (0);\n\t\t}\n\t\tif (isset($this->CurrentFont['cw'][intval($char)])) {\n\t\t\t$w = $this->CurrentFont['cw'][intval($char)];\n\t\t} elseif (isset($this->CurrentFont['dw'])) {\n\t\t\t// default width\n\t\t\t$w = $this->CurrentFont['dw'];\n\t\t} elseif (isset($this->CurrentFont['cw'][32])) {\n\t\t\t// default width\n\t\t\t$w = $this->CurrentFont['cw'][32];\n\t\t} else {\n\t\t\t$w = 600;\n\t\t}\n\t\treturn $this->getAbsFontMeasure($w);\n\t}\n\n\t/**\n\t * Returns the numbero of characters in a string.\n\t * @param string $s The input string.\n\t * @return int number of characters\n\t * @public\n\t * @since 2.0.0001 (2008-01-07)\n\t */\n\tpublic function GetNumChars($s) {\n\t\tif ($this->isUnicodeFont()) {\n\t\t\treturn count(TCPDF_FONTS::UTF8StringToArray($s, $this->isunicode, $this->CurrentFont));\n\t\t}\n\t\treturn strlen($s);\n\t}\n\n\t/**\n\t * Fill the list of available fonts ($this->fontlist).\n\t * @protected\n\t * @since 4.0.013 (2008-07-28)\n\t */\n\tprotected function getFontsList() {\n\t\tif (($fontsdir = opendir(TCPDF_FONTS::_getfontpath())) !== false) {\n\t\t\twhile (($file = readdir($fontsdir)) !== false) {\n\t\t\t\tif (substr($file, -4) == '.php') {\n\t\t\t\t\tarray_push($this->fontlist, strtolower(basename($file, '.php')));\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir($fontsdir);\n\t\t}\n\t}\n\n\t/**\n\t * Imports a TrueType, Type1, core, or CID0 font and makes it available.\n\t * It is necessary to generate a font definition file first (read /fonts/utils/README.TXT).\n\t * The definition file (and the font file itself when embedding) must be present either in the current directory or in the one indicated by K_PATH_FONTS if the constant is defined. If it could not be found, the error \"Could not include font definition file\" is generated.\n\t * @param string $family Font family. The name can be chosen arbitrarily. If it is a standard family name, it will override the corresponding font.\n\t * @param string $style Font style. Possible values are (case insensitive):<ul><li>empty string: regular (default)</li><li>B: bold</li><li>I: italic</li><li>BI or IB: bold italic</li></ul>\n\t * @param string $fontfile The font definition file. By default, the name is built from the family and style, in lower case with no spaces.\n\t * @return array|false array containing the font data, or false in case of error.\n\t * @param mixed $subset if true embedd only a subset of the font (stores only the information related to the used characters); if false embedd full font; if 'default' uses the default value set using setFontSubsetting(). This option is valid only for TrueTypeUnicode fonts. If you want to enable users to change the document, set this parameter to false. If you subset the font, the person who receives your PDF would need to have your same font in order to make changes to your PDF. The file size of the PDF would also be smaller because you are embedding only part of a font.\n\t * @public\n\t * @since 1.5\n\t * @see SetFont(), setFontSubsetting()\n\t */\n\tpublic function AddFont($family, $style='', $fontfile='', $subset='default') {\n\t\tif ($subset === 'default') {\n\t\t\t$subset = $this->font_subsetting;\n\t\t}\n\t\tif ($this->pdfa_mode) {\n\t\t\t$subset = false;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($family)) {\n\t\t\tif (!TCPDF_STATIC::empty_string($this->FontFamily)) {\n\t\t\t\t$family = $this->FontFamily;\n\t\t\t} else {\n\t\t\t\t$this->Error('Empty font family');\n\t\t\t}\n\t\t}\n\t\t// move embedded styles on $style\n\t\tif (substr($family, -1) == 'I') {\n\t\t\t$style .= 'I';\n\t\t\t$family = substr($family, 0, -1);\n\t\t}\n\t\tif (substr($family, -1) == 'B') {\n\t\t\t$style .= 'B';\n\t\t\t$family = substr($family, 0, -1);\n\t\t}\n\t\t// normalize family name\n\t\t$family = strtolower($family);\n\t\tif ((!$this->isunicode) AND ($family == 'arial')) {\n\t\t\t$family = 'helvetica';\n\t\t}\n\t\tif (($family == 'symbol') OR ($family == 'zapfdingbats')) {\n\t\t\t$style = '';\n\t\t}\n\t\tif ($this->pdfa_mode AND (isset($this->CoreFonts[$family]))) {\n\t\t\t// all fonts must be embedded\n\t\t\t$family = 'pdfa'.$family;\n\t\t}\n\t\t$tempstyle = strtoupper($style === null ? '' : $style);\n\t\t$style = '';\n\t\t// underline\n\t\tif (strpos($tempstyle, 'U') !== false) {\n\t\t\t$this->underline = true;\n\t\t} else {\n\t\t\t$this->underline = false;\n\t\t}\n\t\t// line-through (deleted)\n\t\tif (strpos($tempstyle, 'D') !== false) {\n\t\t\t$this->linethrough = true;\n\t\t} else {\n\t\t\t$this->linethrough = false;\n\t\t}\n\t\t// overline\n\t\tif (strpos($tempstyle, 'O') !== false) {\n\t\t\t$this->overline = true;\n\t\t} else {\n\t\t\t$this->overline = false;\n\t\t}\n\t\t// bold\n\t\tif (strpos($tempstyle, 'B') !== false) {\n\t\t\t$style .= 'B';\n\t\t}\n\t\t// oblique\n\t\tif (strpos($tempstyle, 'I') !== false) {\n\t\t\t$style .= 'I';\n\t\t}\n\t\t$bistyle = $style;\n\t\t$fontkey = $family.$style;\n\t\t$font_style = $style.($this->underline ? 'U' : '').($this->linethrough ? 'D' : '').($this->overline ? 'O' : '');\n\t\t$fontdata = array('fontkey' => $fontkey, 'family' => $family, 'style' => $font_style);\n\t\t// check if the font has been already added\n\t\t$fb = $this->getFontBuffer($fontkey);\n\t\tif ($fb !== false) {\n\t\t\tif ($this->inxobj) {\n\t\t\t\t// we are inside an XObject template\n\t\t\t\t$this->xobjects[$this->xobjid]['fonts'][$fontkey] = $fb['i'];\n\t\t\t}\n\t\t\treturn $fontdata;\n\t\t}\n\t\t// get specified font directory (if any)\n\t\t$fontdir = false;\n\t\tif (!TCPDF_STATIC::empty_string($fontfile)) {\n\t\t\t$fontdir = dirname($fontfile);\n\t\t\tif (TCPDF_STATIC::empty_string($fontdir) OR ($fontdir == '.')) {\n\t\t\t\t$fontdir = '';\n\t\t\t} else {\n\t\t\t\t$fontdir .= '/';\n\t\t\t}\n\t\t}\n\t\t// true when the font style variation is missing\n\t\t$missing_style = false;\n\t\t// search and include font file\n\t\tif (TCPDF_STATIC::empty_string($fontfile) OR (!@TCPDF_STATIC::file_exists($fontfile))) {\n\t\t\t// build a standard filenames for specified font\n\t\t\t$tmp_fontfile = str_replace(' ', '', $family).strtolower($style).'.php';\n\t\t\t$fontfile = TCPDF_FONTS::getFontFullPath($tmp_fontfile, $fontdir);\n\t\t\tif (TCPDF_STATIC::empty_string($fontfile)) {\n\t\t\t\t$missing_style = true;\n\t\t\t\t// try to remove the style part\n\t\t\t\t$tmp_fontfile = str_replace(' ', '', $family).'.php';\n\t\t\t\t$fontfile = TCPDF_FONTS::getFontFullPath($tmp_fontfile, $fontdir);\n\t\t\t}\n\t\t}\n\t\t// include font file\n\t\tif (!TCPDF_STATIC::empty_string($fontfile) AND (@TCPDF_STATIC::file_exists($fontfile))) {\n\t\t\t$type=null;\n\t\t\t$name=null;\n\t\t\t$desc=null;\n\t\t\t$up=-null;\n\t\t\t$ut=null;\n\t\t\t$cw=null;\n\t\t\t$cbbox=null;\n\t\t\t$dw=null;\n\t\t\t$enc=null;\n\t\t\t$cidinfo=null;\n\t\t\t$file=null;\n\t\t\t$ctg=null;\n\t\t\t$diff=null;\n\t\t\t$originalsize=null;\n\t\t\t$size1=null;\n\t\t\t$size2=null;\n\t\t\tinclude($fontfile);\n\t\t} else {\n\t\t\t$this->Error('Could not include font definition file: '.$family.'');\n\t\t}\n\t\t// check font parameters\n\t\tif ((!isset($type)) OR (!isset($cw))) {\n\t\t\t$this->Error('The font definition file has a bad format: '.$fontfile.'');\n\t\t}\n\t\t// SET default parameters\n\t\tif (!isset($file) OR TCPDF_STATIC::empty_string($file)) {\n\t\t\t$file = '';\n\t\t}\n\t\tif (!isset($enc) OR TCPDF_STATIC::empty_string($enc)) {\n\t\t\t$enc = '';\n\t\t}\n\t\tif (!isset($cidinfo) OR TCPDF_STATIC::empty_string($cidinfo)) {\n\t\t\t$cidinfo = array('Registry'=>'Adobe', 'Ordering'=>'Identity', 'Supplement'=>0);\n\t\t\t$cidinfo['uni2cid'] = array();\n\t\t}\n\t\tif (!isset($ctg) OR TCPDF_STATIC::empty_string($ctg)) {\n\t\t\t$ctg = '';\n\t\t}\n\t\tif (!isset($desc) OR TCPDF_STATIC::empty_string($desc)) {\n\t\t\t$desc = array();\n\t\t}\n\t\tif (!isset($up) OR TCPDF_STATIC::empty_string($up)) {\n\t\t\t$up = -100;\n\t\t}\n\t\tif (!isset($ut) OR TCPDF_STATIC::empty_string($ut)) {\n\t\t\t$ut = 50;\n\t\t}\n\t\tif (!isset($cw) OR TCPDF_STATIC::empty_string($cw)) {\n\t\t\t$cw = array();\n\t\t}\n\t\tif (!isset($dw) OR TCPDF_STATIC::empty_string($dw)) {\n\t\t\t// set default width\n\t\t\tif (isset($desc['MissingWidth']) AND ($desc['MissingWidth'] > 0)) {\n\t\t\t\t$dw = $desc['MissingWidth'];\n\t\t\t} elseif (isset($cw[32])) {\n\t\t\t\t$dw = $cw[32];\n\t\t\t} else {\n\t\t\t\t$dw = 600;\n\t\t\t}\n\t\t}\n\t\t++$this->numfonts;\n\t\tif ($type == 'core') {\n\t\t\t$name = $this->CoreFonts[$fontkey];\n\t\t\t$subset = false;\n\t\t} elseif (($type == 'TrueType') OR ($type == 'Type1')) {\n\t\t\t$subset = false;\n\t\t} elseif ($type == 'TrueTypeUnicode') {\n\t\t\t$enc = 'Identity-H';\n\t\t} elseif ($type == 'cidfont0') {\n\t\t\tif ($this->pdfa_mode) {\n\t\t\t\t$this->Error('All fonts must be embedded in PDF/A mode!');\n\t\t\t}\n\t\t} else {\n\t\t\t$this->Error('Unknow font type: '.$type.'');\n\t\t}\n\t\t// set name if unset\n\t\tif (empty($name)) {\n\t\t\t$name = $fontkey;\n\t\t}\n\t\t// create artificial font style variations if missing (only works with non-embedded fonts)\n\t\tif (($type != 'core') AND $missing_style) {\n\t\t\t// style variations\n\t\t\t$styles = array('' => '', 'B' => ',Bold', 'I' => ',Italic', 'BI' => ',BoldItalic');\n\t\t\t$name .= $styles[$bistyle];\n\t\t\t// artificial bold\n\t\t\tif (strpos($bistyle, 'B') !== false) {\n\t\t\t\tif (isset($desc['StemV'])) {\n\t\t\t\t\t// from normal to bold\n\t\t\t\t\t$desc['StemV'] = round($desc['StemV'] * 1.75);\n\t\t\t\t} else {\n\t\t\t\t\t// bold\n\t\t\t\t\t$desc['StemV'] = 123;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// artificial italic\n\t\t\tif (strpos($bistyle, 'I') !== false) {\n\t\t\t\tif (isset($desc['ItalicAngle'])) {\n\t\t\t\t\t$desc['ItalicAngle'] -= 11;\n\t\t\t\t} else {\n\t\t\t\t\t$desc['ItalicAngle'] = -11;\n\t\t\t\t}\n\t\t\t\tif (isset($desc['Flags'])) {\n\t\t\t\t\t$desc['Flags'] |= 64; //bit 7\n\t\t\t\t} else {\n\t\t\t\t\t$desc['Flags'] = 64;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// check if the array of characters bounding boxes is defined\n\t\tif (!isset($cbbox)) {\n\t\t\t$cbbox = array();\n\t\t}\n\t\t// initialize subsetchars\n\t\t$subsetchars = array_fill(0, 255, true);\n\t\t$this->setFontBuffer($fontkey, array('fontkey' => $fontkey, 'i' => $this->numfonts, 'type' => $type, 'name' => $name, 'desc' => $desc, 'up' => $up, 'ut' => $ut, 'cw' => $cw, 'cbbox' => $cbbox, 'dw' => $dw, 'enc' => $enc, 'cidinfo' => $cidinfo, 'file' => $file, 'ctg' => $ctg, 'subset' => $subset, 'subsetchars' => $subsetchars));\n\t\tif ($this->inxobj) {\n\t\t\t// we are inside an XObject template\n\t\t\t$this->xobjects[$this->xobjid]['fonts'][$fontkey] = $this->numfonts;\n\t\t}\n\t\tif (!empty($diff)) {\n\t\t\t//Search existing encodings\n\t\t\t$d = 0;\n\t\t\t$nb = count($this->diffs);\n\t\t\tfor ($i=1; $i <= $nb; ++$i) {\n\t\t\t\tif ($this->diffs[$i] == $diff) {\n\t\t\t\t\t$d = $i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($d == 0) {\n\t\t\t\t$d = $nb + 1;\n\t\t\t\t$this->diffs[$d] = $diff;\n\t\t\t}\n\t\t\t$this->setFontSubBuffer($fontkey, 'diff', $d);\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($file)) {\n\t\t\tif (!isset($this->FontFiles[$file])) {\n\t\t\t\tif ((strcasecmp($type,'TrueType') == 0) OR (strcasecmp($type, 'TrueTypeUnicode') == 0)) {\n\t\t\t\t\t$this->FontFiles[$file] = array('length1' => $originalsize, 'fontdir' => $fontdir, 'subset' => $subset, 'fontkeys' => array($fontkey));\n\t\t\t\t} elseif ($type != 'core') {\n\t\t\t\t\t$this->FontFiles[$file] = array('length1' => $size1, 'length2' => $size2, 'fontdir' => $fontdir, 'subset' => $subset, 'fontkeys' => array($fontkey));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// update fontkeys that are sharing this font file\n\t\t\t\t$this->FontFiles[$file]['subset'] = ($this->FontFiles[$file]['subset'] AND $subset);\n\t\t\t\tif (!in_array($fontkey, $this->FontFiles[$file]['fontkeys'])) {\n\t\t\t\t\t$this->FontFiles[$file]['fontkeys'][] = $fontkey;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $fontdata;\n\t}\n\n\t/**\n\t * Sets the font used to print character strings.\n\t * The font can be either a standard one or a font added via the AddFont() method. Standard fonts use Windows encoding cp1252 (Western Europe).\n\t * The method can be called before the first page is created and the font is retained from page to page.\n\t * If you just wish to change the current font size, it is simpler to call SetFontSize().\n\t * Note: for the standard fonts, the font metric files must be accessible. There are three possibilities for this:<ul><li>They are in the current directory (the one where the running script lies)</li><li>They are in one of the directories defined by the include_path parameter</li><li>They are in the directory defined by the K_PATH_FONTS constant</li></ul><br />\n\t * @param string $family Family font. It can be either a name defined by AddFont() or one of the standard Type1 families (case insensitive):<ul><li>times (Times-Roman)</li><li>timesb (Times-Bold)</li><li>timesi (Times-Italic)</li><li>timesbi (Times-BoldItalic)</li><li>helvetica (Helvetica)</li><li>helveticab (Helvetica-Bold)</li><li>helveticai (Helvetica-Oblique)</li><li>helveticabi (Helvetica-BoldOblique)</li><li>courier (Courier)</li><li>courierb (Courier-Bold)</li><li>courieri (Courier-Oblique)</li><li>courierbi (Courier-BoldOblique)</li><li>symbol (Symbol)</li><li>zapfdingbats (ZapfDingbats)</li></ul> It is also possible to pass an empty string. In that case, the current family is retained.\n\t * @param string $style Font style. Possible values are (case insensitive):<ul><li>empty string: regular</li><li>B: bold</li><li>I: italic</li><li>U: underline</li><li>D: line through</li><li>O: overline</li></ul> or any combination. The default value is regular. Bold and italic styles do not apply to Symbol and ZapfDingbats basic fonts or other fonts when not defined.\n\t * @param float|null $size Font size in points. The default value is the current size. If no size has been specified since the beginning of the document, the value taken is 12\n\t * @param string $fontfile The font definition file. By default, the name is built from the family and style, in lower case with no spaces.\n\t * @param mixed $subset if true embedd only a subset of the font (stores only the information related to the used characters); if false embedd full font; if 'default' uses the default value set using setFontSubsetting(). This option is valid only for TrueTypeUnicode fonts. If you want to enable users to change the document, set this parameter to false. If you subset the font, the person who receives your PDF would need to have your same font in order to make changes to your PDF. The file size of the PDF would also be smaller because you are embedding only part of a font.\n\t * @param boolean $out if true output the font size command, otherwise only set the font properties.\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 1.0\n\t * @see AddFont(), SetFontSize()\n\t */\n\tpublic function setFont($family, $style='', $size=null, $fontfile='', $subset='default', $out=true) {\n\t\t//Select a font; size given in points\n\t\tif ($size === null) {\n\t\t\t$size = $this->FontSizePt;\n\t\t}\n\t\tif ($size < 0) {\n\t\t\t$size = 0;\n\t\t}\n\t\t// try to add font (if not already added)\n\t\t$fontdata = $this->AddFont($family, $style, $fontfile, $subset);\n\t\t$this->FontFamily = $fontdata['family'];\n\t\t$this->FontStyle = $fontdata['style'];\n\t\tif (isset($this->CurrentFont['fontkey']) AND isset($this->CurrentFont['subsetchars'])) {\n\t\t\t// save subset chars of the previous font\n\t\t\t$this->setFontSubBuffer($this->CurrentFont['fontkey'], 'subsetchars', $this->CurrentFont['subsetchars']);\n\t\t}\n\t\t$this->CurrentFont = $this->getFontBuffer($fontdata['fontkey']);\n\t\t$this->setFontSize($size, $out);\n\t}\n\n\t/**\n\t * Defines the size of the current font.\n\t * @param float $size The font size in points.\n\t * @param boolean $out if true output the font size command, otherwise only set the font properties.\n\t * @public\n\t * @since 1.0\n\t * @see SetFont()\n\t */\n\tpublic function setFontSize($size, $out=true) {\n\t\t$size = (float)$size;\n\t\t// font size in points\n\t\t$this->FontSizePt = $size;\n\t\t// font size in user units\n\t\t$this->FontSize = $size / $this->k;\n\t\t// calculate some font metrics\n\t\tif (isset($this->CurrentFont['desc']['FontBBox'])) {\n\t\t\t$bbox = explode(' ', substr($this->CurrentFont['desc']['FontBBox'], 1, -1));\n\t\t\t$font_height = ((intval($bbox[3]) - intval($bbox[1])) * $size / 1000);\n\t\t} else {\n\t\t\t$font_height = $size * 1.219;\n\t\t}\n\t\tif (isset($this->CurrentFont['desc']['Ascent']) AND ($this->CurrentFont['desc']['Ascent'] > 0)) {\n\t\t\t$font_ascent = ($this->CurrentFont['desc']['Ascent'] * $size / 1000);\n\t\t}\n\t\tif (isset($this->CurrentFont['desc']['Descent']) AND ($this->CurrentFont['desc']['Descent'] <= 0)) {\n\t\t\t$font_descent = (- $this->CurrentFont['desc']['Descent'] * $size / 1000);\n\t\t}\n\t\tif (!isset($font_ascent) AND !isset($font_descent)) {\n\t\t\t// core font\n\t\t\t$font_ascent = 0.76 * $font_height;\n\t\t\t$font_descent = $font_height - $font_ascent;\n\t\t} elseif (!isset($font_descent)) {\n\t\t\t$font_descent = $font_height - $font_ascent;\n\t\t} elseif (!isset($font_ascent)) {\n\t\t\t$font_ascent = $font_height - $font_descent;\n\t\t}\n\t\t$this->FontAscent = ($font_ascent / $this->k);\n\t\t$this->FontDescent = ($font_descent / $this->k);\n\t\tif ($out AND ($this->page > 0) AND (isset($this->CurrentFont['i'])) AND ($this->state == 2)) {\n\t\t\t$this->_out(sprintf('BT /F%d %F Tf ET', $this->CurrentFont['i'], $this->FontSizePt));\n\t\t}\n\t}\n\n\t/**\n\t * Returns the bounding box of the current font in user units.\n\t * @return array\n\t * @public\n\t * @since 5.9.152 (2012-03-23)\n\t */\n\tpublic function getFontBBox() {\n\t\t$fbbox = array();\n\t\tif (isset($this->CurrentFont['desc']['FontBBox'])) {\n\t\t\t$tmpbbox = explode(' ', substr($this->CurrentFont['desc']['FontBBox'], 1, -1));\n\t\t\t$fbbox = array_map(array($this,'getAbsFontMeasure'), $tmpbbox);\n\t\t} else {\n\t\t\t// Find max width\n\t\t\tif (isset($this->CurrentFont['desc']['MaxWidth'])) {\n\t\t\t\t$maxw = $this->getAbsFontMeasure(intval($this->CurrentFont['desc']['MaxWidth']));\n\t\t\t} else {\n\t\t\t\t$maxw = 0;\n\t\t\t\tif (isset($this->CurrentFont['desc']['MissingWidth'])) {\n\t\t\t\t\t$maxw = max($maxw, $this->CurrentFont['desc']['MissingWidth']);\n\t\t\t\t}\n\t\t\t\tif (isset($this->CurrentFont['desc']['AvgWidth'])) {\n\t\t\t\t\t$maxw = max($maxw, $this->CurrentFont['desc']['AvgWidth']);\n\t\t\t\t}\n\t\t\t\tif (isset($this->CurrentFont['dw'])) {\n\t\t\t\t\t$maxw = max($maxw, $this->CurrentFont['dw']);\n\t\t\t\t}\n\t\t\t\tforeach ($this->CurrentFont['cw'] as $char => $w) {\n\t\t\t\t\t$maxw = max($maxw, $w);\n\t\t\t\t}\n\t\t\t\tif ($maxw == 0) {\n\t\t\t\t\t$maxw = 600;\n\t\t\t\t}\n\t\t\t\t$maxw = $this->getAbsFontMeasure($maxw);\n\t\t\t}\n\t\t\t$fbbox = array(0, (0 - $this->FontDescent), $maxw, $this->FontAscent);\n\t\t}\n\t\treturn $fbbox;\n\t}\n\n\t/**\n\t * Convert a relative font measure into absolute value.\n\t * @param int $s Font measure.\n\t * @return float Absolute measure.\n\t * @since 5.9.186 (2012-09-13)\n\t */\n\tpublic function getAbsFontMeasure($s) {\n\t\treturn ($s * $this->FontSize / 1000);\n\t}\n\n\t/**\n\t * Returns the glyph bounding box of the specified character in the current font in user units.\n\t * @param int $char Input character code.\n\t * @return false|array array(xMin, yMin, xMax, yMax) or FALSE if not defined.\n\t * @since 5.9.186 (2012-09-13)\n\t */\n\tpublic function getCharBBox($char) {\n\t\t$c = intval($char);\n\t\tif (isset($this->CurrentFont['cw'][$c])) {\n\t\t\t// glyph is defined ... use zero width & height for glyphs without outlines\n\t\t\t$result = array(0,0,0,0);\n\t\t\tif (isset($this->CurrentFont['cbbox'][$c])) {\n\t\t\t\t$result = $this->CurrentFont['cbbox'][$c];\n\t\t\t}\n\t\t\treturn array_map(array($this,'getAbsFontMeasure'), $result);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return the font descent value\n\t * @param string $font font name\n\t * @param string $style font style\n\t * @param float $size The size (in points)\n\t * @return int font descent\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.9.003 (2010-03-30)\n\t */\n\tpublic function getFontDescent($font, $style='', $size=0) {\n\t\t$fontdata = $this->AddFont($font, $style);\n\t\t$fontinfo = $this->getFontBuffer($fontdata['fontkey']);\n\t\tif (isset($fontinfo['desc']['Descent']) AND ($fontinfo['desc']['Descent'] <= 0)) {\n\t\t\t$descent = (- $fontinfo['desc']['Descent'] * $size / 1000);\n\t\t} else {\n\t\t\t$descent = (1.219 * 0.24 * $size);\n\t\t}\n\t\treturn ($descent / $this->k);\n\t}\n\n\t/**\n\t * Return the font ascent value.\n\t * @param string $font font name\n\t * @param string $style font style\n\t * @param float $size The size (in points)\n\t * @return int font ascent\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.9.003 (2010-03-30)\n\t */\n\tpublic function getFontAscent($font, $style='', $size=0) {\n\t\t$fontdata = $this->AddFont($font, $style);\n\t\t$fontinfo = $this->getFontBuffer($fontdata['fontkey']);\n\t\tif (isset($fontinfo['desc']['Ascent']) AND ($fontinfo['desc']['Ascent'] > 0)) {\n\t\t\t$ascent = ($fontinfo['desc']['Ascent'] * $size / 1000);\n\t\t} else {\n\t\t\t$ascent = 1.219 * 0.76 * $size;\n\t\t}\n\t\treturn ($ascent / $this->k);\n\t}\n\n\t/**\n\t * Return true in the character is present in the specified font.\n\t * @param mixed $char Character to check (integer value or string)\n\t * @param string $font Font name (family name).\n\t * @param string $style Font style.\n\t * @return bool true if the char is defined, false otherwise.\n\t * @public\n\t * @since 5.9.153 (2012-03-28)\n\t */\n\tpublic function isCharDefined($char, $font='', $style='') {\n\t\tif (is_string($char)) {\n\t\t\t// get character code\n\t\t\t$char = TCPDF_FONTS::UTF8StringToArray($char, $this->isunicode, $this->CurrentFont);\n\t\t\t$char = $char[0];\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($font)) {\n\t\t\tif (TCPDF_STATIC::empty_string($style)) {\n\t\t\t\treturn (isset($this->CurrentFont['cw'][intval($char)]));\n\t\t\t}\n\t\t\t$font = $this->FontFamily;\n\t\t}\n\t\t$fontdata = $this->AddFont($font, $style);\n\t\t$fontinfo = $this->getFontBuffer($fontdata['fontkey']);\n\t\treturn (isset($fontinfo['cw'][intval($char)]));\n\t}\n\n\t/**\n\t * Replace missing font characters on selected font with specified substitutions.\n\t * @param string $text Text to process.\n\t * @param string $font Font name (family name).\n\t * @param string $style Font style.\n\t * @param array $subs Array of possible character substitutions. The key is the character to check (integer value) and the value is a single intege value or an array of possible substitutes.\n\t * @return string Processed text.\n\t * @public\n\t * @since 5.9.153 (2012-03-28)\n\t */\n\tpublic function replaceMissingChars($text, $font='', $style='', $subs=array()) {\n\t\tif (empty($subs)) {\n\t\t\treturn $text;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($font)) {\n\t\t\t$font = $this->FontFamily;\n\t\t}\n\t\t$fontdata = $this->AddFont($font, $style);\n\t\t$fontinfo = $this->getFontBuffer($fontdata['fontkey']);\n\t\t$uniarr = TCPDF_FONTS::UTF8StringToArray($text, $this->isunicode, $this->CurrentFont);\n\t\tforeach ($uniarr as $k => $chr) {\n\t\t\tif (!isset($fontinfo['cw'][$chr])) {\n\t\t\t\t// this character is missing on the selected font\n\t\t\t\tif (isset($subs[$chr])) {\n\t\t\t\t\t// we have available substitutions\n\t\t\t\t\tif (is_array($subs[$chr])) {\n\t\t\t\t\t\tforeach($subs[$chr] as $s) {\n\t\t\t\t\t\t\tif (isset($fontinfo['cw'][$s])) {\n\t\t\t\t\t\t\t\t$uniarr[$k] = $s;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif (isset($fontinfo['cw'][$subs[$chr]])) {\n\t\t\t\t\t\t$uniarr[$k] = $subs[$chr];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn TCPDF_FONTS::UniArrSubString(TCPDF_FONTS::UTF8ArrayToUniArray($uniarr, $this->isunicode));\n\t}\n\n\t/**\n\t * Defines the default monospaced font.\n\t * @param string $font Font name.\n\t * @public\n\t * @since 4.5.025\n\t */\n\tpublic function setDefaultMonospacedFont($font) {\n\t\t$this->default_monospaced_font = $font;\n\t}\n\n\t/**\n\t * Creates a new internal link and returns its identifier. An internal link is a clickable area which directs to another place within the document.<br />\n\t * The identifier can then be passed to Cell(), Write(), Image() or Link(). The destination is defined with SetLink().\n\t * @public\n\t * @since 1.5\n\t * @see Cell(), Write(), Image(), Link(), SetLink()\n\t */\n\tpublic function AddLink() {\n\t\t// create a new internal link\n\t\t$n = count($this->links) + 1;\n\t\t$this->links[$n] = array('p' => 0, 'y' => 0, 'f' => false);\n\t\treturn $n;\n\t}\n\n\t/**\n\t * Defines the page and position a link points to.\n\t * @param int $link The link identifier returned by AddLink()\n\t * @param float $y Ordinate of target position; -1 indicates the current position. The default value is 0 (top of page)\n\t * @param int|string $page Number of target page; -1 indicates the current page (default value). If you prefix a page number with the * character, then this page will not be changed when adding/deleting/moving pages.\n\t * @public\n\t * @since 1.5\n\t * @see AddLink()\n\t */\n\tpublic function setLink($link, $y=0, $page=-1) {\n\t\t$fixed = false;\n\t\tif (!empty($page) AND (substr($page, 0, 1) == '*')) {\n\t\t\t$page = intval(substr($page, 1));\n\t\t\t// this page number will not be changed when moving/add/deleting pages\n\t\t\t$fixed = true;\n\t\t}\n\t\tif ($page < 0) {\n\t\t\t$page = $this->page;\n\t\t}\n\t\tif ($y == -1) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\t$this->links[$link] = array('p' => $page, 'y' => $y, 'f' => $fixed);\n\t}\n\n\t/**\n\t * Puts a link on a rectangular area of the page.\n\t * Text or image links are generally put via Cell(), Write() or Image(), but this method can be useful for instance to define a clickable area inside an image.\n\t * @param float $x Abscissa of the upper-left corner of the rectangle\n\t * @param float $y Ordinate of the upper-left corner of the rectangle\n\t * @param float $w Width of the rectangle\n\t * @param float $h Height of the rectangle\n\t * @param mixed $link URL or identifier returned by AddLink()\n\t * @param int $spaces number of spaces on the text to link\n\t * @public\n\t * @since 1.5\n\t * @see AddLink(), Annotation(), Cell(), Write(), Image()\n\t */\n\tpublic function Link($x, $y, $w, $h, $link, $spaces=0) {\n\t\t$this->Annotation($x, $y, $w, $h, $link, array('Subtype'=>'Link'), $spaces);\n\t}\n\n\t/**\n\t * Puts a markup annotation on a rectangular area of the page.\n\t * !!!!THE ANNOTATION SUPPORT IS NOT YET FULLY IMPLEMENTED !!!!\n\t * @param float $x Abscissa of the upper-left corner of the rectangle\n\t * @param float $y Ordinate of the upper-left corner of the rectangle\n\t * @param float $w Width of the rectangle\n\t * @param float $h Height of the rectangle\n\t * @param string $text annotation text or alternate content\n\t * @param array $opt array of options (see section 8.4 of PDF reference 1.7).\n\t * @param int $spaces number of spaces on the text to link\n\t * @public\n\t * @since 4.0.018 (2008-08-06)\n\t */\n\tpublic function Annotation($x, $y, $w, $h, $text, $opt=array('Subtype'=>'Text'), $spaces=0) {\n\t\tif ($this->inxobj) {\n\t\t\t// store parameters for later use on template\n\t\t\t$this->xobjects[$this->xobjid]['annotations'][] = array('x' => $x, 'y' => $y, 'w' => $w, 'h' => $h, 'text' => $text, 'opt' => $opt, 'spaces' => $spaces);\n\t\t\treturn;\n\t\t}\n\t\tif ($x === '') {\n\t\t\t$x = $this->x;\n\t\t}\n\t\tif ($y === '') {\n\t\t\t$y = $this->y;\n\t\t}\n\t\t// check page for no-write regions and adapt page margins if necessary\n\t\tlist($x, $y) = $this->checkPageRegions($h, $x, $y);\n\t\t// recalculate coordinates to account for graphic transformations\n\t\tif (isset($this->transfmatrix) AND !empty($this->transfmatrix)) {\n\t\t\tfor ($i=$this->transfmatrix_key; $i > 0; --$i) {\n\t\t\t\t$maxid = count($this->transfmatrix[$i]) - 1;\n\t\t\t\tfor ($j=$maxid; $j >= 0; --$j) {\n\t\t\t\t\t$ctm = $this->transfmatrix[$i][$j];\n\t\t\t\t\tif (isset($ctm['a'])) {\n\t\t\t\t\t\t$x = $x * $this->k;\n\t\t\t\t\t\t$y = ($this->h - $y) * $this->k;\n\t\t\t\t\t\t$w = $w * $this->k;\n\t\t\t\t\t\t$h = $h * $this->k;\n\t\t\t\t\t\t// top left\n\t\t\t\t\t\t$xt = $x;\n\t\t\t\t\t\t$yt = $y;\n\t\t\t\t\t\t$x1 = ($ctm['a'] * $xt) + ($ctm['c'] * $yt) + $ctm['e'];\n\t\t\t\t\t\t$y1 = ($ctm['b'] * $xt) + ($ctm['d'] * $yt) + $ctm['f'];\n\t\t\t\t\t\t// top right\n\t\t\t\t\t\t$xt = $x + $w;\n\t\t\t\t\t\t$yt = $y;\n\t\t\t\t\t\t$x2 = ($ctm['a'] * $xt) + ($ctm['c'] * $yt) + $ctm['e'];\n\t\t\t\t\t\t$y2 = ($ctm['b'] * $xt) + ($ctm['d'] * $yt) + $ctm['f'];\n\t\t\t\t\t\t// bottom left\n\t\t\t\t\t\t$xt = $x;\n\t\t\t\t\t\t$yt = $y - $h;\n\t\t\t\t\t\t$x3 = ($ctm['a'] * $xt) + ($ctm['c'] * $yt) + $ctm['e'];\n\t\t\t\t\t\t$y3 = ($ctm['b'] * $xt) + ($ctm['d'] * $yt) + $ctm['f'];\n\t\t\t\t\t\t// bottom right\n\t\t\t\t\t\t$xt = $x + $w;\n\t\t\t\t\t\t$yt = $y - $h;\n\t\t\t\t\t\t$x4 = ($ctm['a'] * $xt) + ($ctm['c'] * $yt) + $ctm['e'];\n\t\t\t\t\t\t$y4 = ($ctm['b'] * $xt) + ($ctm['d'] * $yt) + $ctm['f'];\n\t\t\t\t\t\t// new coordinates (rectangle area)\n\t\t\t\t\t\t$x = min($x1, $x2, $x3, $x4);\n\t\t\t\t\t\t$y = max($y1, $y2, $y3, $y4);\n\t\t\t\t\t\t$w = (max($x1, $x2, $x3, $x4) - $x) / $this->k;\n\t\t\t\t\t\t$h = ($y - min($y1, $y2, $y3, $y4)) / $this->k;\n\t\t\t\t\t\t$x = $x / $this->k;\n\t\t\t\t\t\t$y = $this->h - ($y / $this->k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ($this->page <= 0) {\n\t\t\t$page = 1;\n\t\t} else {\n\t\t\t$page = $this->page;\n\t\t}\n\t\tif (!isset($this->PageAnnots[$page])) {\n\t\t\t$this->PageAnnots[$page] = array();\n\t\t}\n\t\t$this->PageAnnots[$page][] = array('n' => ++$this->n, 'x' => $x, 'y' => $y, 'w' => $w, 'h' => $h, 'txt' => $text, 'opt' => $opt, 'numspaces' => $spaces);\n\t\tif (!$this->pdfa_mode || ($this->pdfa_mode && $this->pdfa_version == 3)) {\n\t\t\tif ((($opt['Subtype'] == 'FileAttachment') OR ($opt['Subtype'] == 'Sound')) AND (!TCPDF_STATIC::empty_string($opt['FS']))\n\t\t\t\tAND (@TCPDF_STATIC::file_exists($opt['FS']) OR TCPDF_STATIC::isValidURL($opt['FS']))\n\t\t\t\tAND (!isset($this->embeddedfiles[basename($opt['FS'])]))) {\n\t\t\t\t$this->embeddedfiles[basename($opt['FS'])] = array('f' => ++$this->n, 'n' => ++$this->n, 'file' => $opt['FS']);\n\t\t\t}\n\t\t}\n\t\t// Add widgets annotation's icons\n\t\tif (isset($opt['mk']['i']) AND @TCPDF_STATIC::file_exists($opt['mk']['i'])) {\n\t\t\t$this->Image($opt['mk']['i'], '', '', 10, 10, '', '', '', false, 300, '', false, false, 0, false, true);\n\t\t}\n\t\tif (isset($opt['mk']['ri']) AND @TCPDF_STATIC::file_exists($opt['mk']['ri'])) {\n\t\t\t$this->Image($opt['mk']['ri'], '', '', 0, 0, '', '', '', false, 300, '', false, false, 0, false, true);\n\t\t}\n\t\tif (isset($opt['mk']['ix']) AND @TCPDF_STATIC::file_exists($opt['mk']['ix'])) {\n\t\t\t$this->Image($opt['mk']['ix'], '', '', 0, 0, '', '', '', false, 300, '', false, false, 0, false, true);\n\t\t}\n\t}\n\n\t/**\n\t * Embedd the attached files.\n\t * @since 4.4.000 (2008-12-07)\n\t * @protected\n\t * @see Annotation()\n\t */\n\tprotected function _putEmbeddedFiles() {\n\t\tif ($this->pdfa_mode && $this->pdfa_version != 3)  {\n\t\t\t// embedded files are not allowed in PDF/A mode version 1 and 2\n\t\t\treturn;\n\t\t}\n\t\treset($this->embeddedfiles);\n\t\tforeach ($this->embeddedfiles as $filename => $filedata) {\n\t\t    $data = $this->getCachedFileContents($filedata['file']);\n\t\t\tif ($data !== FALSE) {\n\t\t\t\t$rawsize = strlen($data);\n\t\t\t\tif ($rawsize > 0) {\n\t\t\t\t\t// update name tree\n\t\t\t\t\t$this->efnames[$filename] = $filedata['f'].' 0 R';\n\t\t\t\t\t// embedded file specification object\n\t\t\t\t\t$out = $this->_getobj($filedata['f']).\"\\n\";\n\t\t\t\t\t$out .= '<</Type /Filespec /F '.$this->_datastring($filename, $filedata['f']);\n\t\t\t\t\t$out .= ' /UF '.$this->_datastring($filename, $filedata['f']);\n\t\t\t\t\t$out .= ' /AFRelationship /Source';\n\t\t\t\t\t$out .= ' /EF <</F '.$filedata['n'].' 0 R>> >>';\n\t\t\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t\t\t$this->_out($out);\n\t\t\t\t\t// embedded file object\n\t\t\t\t\t$filter = '';\n\t\t\t\t\tif ($this->compress) {\n\t\t\t\t\t\t$data = gzcompress($data);\n\t\t\t\t\t\t$filter = ' /Filter /FlateDecode';\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($this->pdfa_version == 3) {\n\t\t\t\t\t\t$filter = ' /Subtype /text#2Fxml';\n\t\t\t\t\t}\n\n\t\t\t\t\t$stream = $this->_getrawstream($data, $filedata['n']);\n\t\t\t\t\t$out = $this->_getobj($filedata['n']).\"\\n\";\n\t\t\t\t\t$out .= '<< /Type /EmbeddedFile'.$filter.' /Length '.strlen($stream).' /Params <</Size '.$rawsize.'>> >>';\n\t\t\t\t\t$out .= ' stream'.\"\\n\".$stream.\"\\n\".'endstream';\n\t\t\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t\t\t$this->_out($out);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Prints a text cell at the specified position.\n\t * This method allows to place a string precisely on the page.\n\t * @param float $x Abscissa of the cell origin\n\t * @param float $y Ordinate of the cell origin\n\t * @param string $txt String to print\n\t * @param int $fstroke outline size in user units (0 = disable)\n\t * @param boolean $fclip if true activate clipping mode (you must call StartTransform() before this function and StopTransform() to stop the clipping tranformation).\n\t * @param boolean $ffill if true fills the text\n\t * @param mixed $border Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))\n\t * @param int $ln Indicates where the current position should go after the call. Possible values are:<ul><li>0: to the right (or left for RTL languages)</li><li>1: to the beginning of the next line</li><li>2: below</li></ul>Putting 1 is equivalent to putting 0 and calling Ln() just after. Default value: 0.\n\t * @param string $align Allows to center or align the text. Possible values are:<ul><li>L or empty string: left align (default value)</li><li>C: center</li><li>R: right align</li><li>J: justify</li></ul>\n\t * @param boolean $fill Indicates if the cell background must be painted (true) or transparent (false).\n\t * @param mixed $link URL or identifier returned by AddLink().\n\t * @param int $stretch font stretch mode: <ul><li>0 = disabled</li><li>1 = horizontal scaling only if text is larger than cell width</li><li>2 = forced horizontal scaling to fit cell width</li><li>3 = character spacing only if text is larger than cell width</li><li>4 = forced character spacing to fit cell width</li></ul> General font stretching and scaling values will be preserved when possible.\n\t * @param boolean $ignore_min_height if true ignore automatic minimum height value.\n\t * @param string $calign cell vertical alignment relative to the specified Y value. Possible values are:<ul><li>T : cell top</li><li>A : font top</li><li>L : font baseline</li><li>D : font bottom</li><li>B : cell bottom</li></ul>\n\t * @param string $valign text vertical alignment inside the cell. Possible values are:<ul><li>T : top</li><li>C : center</li><li>B : bottom</li></ul>\n\t * @param boolean $rtloff if true uses the page top-left corner as origin of axis for $x and $y initial position.\n\t * @public\n\t * @since 1.0\n\t * @see Cell(), Write(), MultiCell(), WriteHTML(), WriteHTMLCell()\n\t */\n\tpublic function Text($x, $y, $txt, $fstroke=0, $fclip=false, $ffill=true, $border=0, $ln=0, $align='', $fill=false, $link='', $stretch=0, $ignore_min_height=false, $calign='T', $valign='M', $rtloff=false) {\n\t\t$textrendermode = $this->textrendermode;\n\t\t$textstrokewidth = $this->textstrokewidth;\n\t\t$this->setTextRenderingMode($fstroke, $ffill, $fclip);\n\t\t$this->setXY($x, $y, $rtloff);\n\t\t$this->Cell(0, 0, $txt, $border, $ln, $align, $fill, $link, $stretch, $ignore_min_height, $calign, $valign);\n\t\t// restore previous rendering mode\n\t\t$this->textrendermode = $textrendermode;\n\t\t$this->textstrokewidth = $textstrokewidth;\n\t}\n\n\t/**\n\t * Whenever a page break condition is met, the method is called, and the break is issued or not depending on the returned value.\n\t * The default implementation returns a value according to the mode selected by SetAutoPageBreak().<br />\n\t * This method is called automatically and should not be called directly by the application.\n\t * @return bool\n\t * @public\n\t * @since 1.4\n\t * @see SetAutoPageBreak()\n\t */\n\tpublic function AcceptPageBreak() {\n\t\tif ($this->num_columns > 1) {\n\t\t\t// multi column mode\n\t\t\tif ($this->current_column < ($this->num_columns - 1)) {\n\t\t\t\t// go to next column\n\t\t\t\t$this->selectColumn($this->current_column + 1);\n\t\t\t} elseif ($this->AutoPageBreak) {\n\t\t\t\t// add a new page\n\t\t\t\t$this->AddPage();\n\t\t\t\t// set first column\n\t\t\t\t$this->selectColumn(0);\n\t\t\t}\n\t\t\t// avoid page breaking from checkPageBreak()\n\t\t\treturn false;\n\t\t}\n\t\treturn $this->AutoPageBreak;\n\t}\n\n\t/**\n\t * Add page if needed.\n\t * @param float $h Cell height. Default value: 0.\n\t * @param float|null $y starting y position, leave empty for current position.\n\t * @param bool  $addpage if true add a page, otherwise only return the true/false state\n\t * @return bool true in case of page break, false otherwise.\n\t * @since 3.2.000 (2008-07-01)\n\t * @protected\n\t */\n\tprotected function checkPageBreak($h=0, $y=null, $addpage=true) {\n\t\tif (TCPDF_STATIC::empty_string($y)) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\t$current_page = $this->page;\n\t\tif ((($y + $h) > $this->PageBreakTrigger) AND ($this->inPageBody()) AND ($this->AcceptPageBreak())) {\n\t\t\tif ($addpage) {\n\t\t\t\t//Automatic page break\n\t\t\t\t$x = $this->x;\n\t\t\t\t$this->AddPage($this->CurOrientation);\n\t\t\t\t$this->y = $this->tMargin;\n\t\t\t\t$oldpage = $this->page - 1;\n\t\t\t\tif ($this->rtl) {\n\t\t\t\t\tif ($this->pagedim[$this->page]['orm'] != $this->pagedim[$oldpage]['orm']) {\n\t\t\t\t\t\t$this->x = $x - ($this->pagedim[$this->page]['orm'] - $this->pagedim[$oldpage]['orm']);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->x = $x;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ($this->pagedim[$this->page]['olm'] != $this->pagedim[$oldpage]['olm']) {\n\t\t\t\t\t\t$this->x = $x + ($this->pagedim[$this->page]['olm'] - $this->pagedim[$oldpage]['olm']);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->x = $x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif ($current_page != $this->page) {\n\t\t\t// account for columns mode\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Prints a cell (rectangular area) with optional borders, background color and character string. The upper-left corner of the cell corresponds to the current position. The text can be aligned or centered. After the call, the current position moves to the right or to the next line. It is possible to put a link on the text.<br />\n\t * If automatic page breaking is enabled and the cell goes beyond the limit, a page break is done before outputting.\n\t * @param float $w Cell width. If 0, the cell extends up to the right margin.\n\t * @param float $h Cell height. Default value: 0.\n\t * @param string $txt String to print. Default value: empty string.\n\t * @param mixed $border Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))\n\t * @param int $ln Indicates where the current position should go after the call. Possible values are:<ul><li>0: to the right (or left for RTL languages)</li><li>1: to the beginning of the next line</li><li>2: below</li></ul> Putting 1 is equivalent to putting 0 and calling Ln() just after. Default value: 0.\n\t * @param string $align Allows to center or align the text. Possible values are:<ul><li>L or empty string: left align (default value)</li><li>C: center</li><li>R: right align</li><li>J: justify</li></ul>\n\t * @param boolean $fill Indicates if the cell background must be painted (true) or transparent (false).\n\t * @param mixed $link URL or identifier returned by AddLink().\n\t * @param int $stretch font stretch mode: <ul><li>0 = disabled</li><li>1 = horizontal scaling only if text is larger than cell width</li><li>2 = forced horizontal scaling to fit cell width</li><li>3 = character spacing only if text is larger than cell width</li><li>4 = forced character spacing to fit cell width</li></ul> General font stretching and scaling values will be preserved when possible.\n\t * @param boolean $ignore_min_height if true ignore automatic minimum height value.\n\t * @param string $calign cell vertical alignment relative to the specified Y value. Possible values are:<ul><li>T : cell top</li><li>C : center</li><li>B : cell bottom</li><li>A : font top</li><li>L : font baseline</li><li>D : font bottom</li></ul>\n\t * @param string $valign text vertical alignment inside the cell. Possible values are:<ul><li>T : top</li><li>C : center</li><li>B : bottom</li></ul>\n\t * @public\n\t * @since 1.0\n\t * @see SetFont(), SetDrawColor(), SetFillColor(), SetTextColor(), SetLineWidth(), AddLink(), Ln(), MultiCell(), Write(), SetAutoPageBreak()\n\t */\n\tpublic function Cell($w, $h=0, $txt='', $border=0, $ln=0, $align='', $fill=false, $link='', $stretch=0, $ignore_min_height=false, $calign='T', $valign='M') {\n\t\t$prev_cell_margin = $this->cell_margin;\n\t\t$prev_cell_padding = $this->cell_padding;\n\t\t$this->adjustCellPadding($border);\n\t\tif (!$ignore_min_height) {\n\t\t\t$min_cell_height = $this->getCellHeight($this->FontSize);\n\t\t\tif ($h < $min_cell_height) {\n\t\t\t\t$h = $min_cell_height;\n\t\t\t}\n\t\t}\n\t\t$this->checkPageBreak($h + $this->cell_margin['T'] + $this->cell_margin['B']);\n\t\t// apply text shadow if enabled\n\t\tif ($this->txtshadow['enabled']) {\n\t\t\t// save data\n\t\t\t$x = $this->x;\n\t\t\t$y = $this->y;\n\t\t\t$bc = $this->bgcolor;\n\t\t\t$fc = $this->fgcolor;\n\t\t\t$sc = $this->strokecolor;\n\t\t\t$alpha = $this->alpha;\n\t\t\t// print shadow\n\t\t\t$this->x += $this->txtshadow['depth_w'];\n\t\t\t$this->y += $this->txtshadow['depth_h'];\n\t\t\t$this->setFillColorArray($this->txtshadow['color']);\n\t\t\t$this->setTextColorArray($this->txtshadow['color']);\n\t\t\t$this->setDrawColorArray($this->txtshadow['color']);\n\t\t\tif ($this->txtshadow['opacity'] != $alpha['CA']) {\n\t\t\t\t$this->setAlpha($this->txtshadow['opacity'], $this->txtshadow['blend_mode']);\n\t\t\t}\n\t\t\tif ($this->state == 2) {\n\t\t\t\t$this->_out($this->getCellCode($w, $h, $txt, $border, $ln, $align, $fill, $link, $stretch, true, $calign, $valign));\n\t\t\t}\n\t\t\t//restore data\n\t\t\t$this->x = $x;\n\t\t\t$this->y = $y;\n\t\t\t$this->setFillColorArray($bc);\n\t\t\t$this->setTextColorArray($fc);\n\t\t\t$this->setDrawColorArray($sc);\n\t\t\tif ($this->txtshadow['opacity'] != $alpha['CA']) {\n\t\t\t\t$this->setAlpha($alpha['CA'], $alpha['BM'], $alpha['ca'], $alpha['AIS']);\n\t\t\t}\n\t\t}\n\t\tif ($this->state == 2) {\n\t\t\t$this->_out($this->getCellCode($w, $h, $txt, $border, $ln, $align, $fill, $link, $stretch, true, $calign, $valign));\n\t\t}\n\t\t$this->cell_padding = $prev_cell_padding;\n\t\t$this->cell_margin = $prev_cell_margin;\n\t}\n\n\t/**\n\t * Returns the PDF string code to print a cell (rectangular area) with optional borders, background color and character string. The upper-left corner of the cell corresponds to the current position. The text can be aligned or centered. After the call, the current position moves to the right or to the next line. It is possible to put a link on the text.<br />\n\t * If automatic page breaking is enabled and the cell goes beyond the limit, a page break is done before outputting.\n\t * @param float $w Cell width. If 0, the cell extends up to the right margin.\n\t * @param float $h Cell height. Default value: 0.\n\t * @param string $txt String to print. Default value: empty string.\n\t * @param mixed $border Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))\n\t * @param int $ln Indicates where the current position should go after the call. Possible values are:<ul><li>0: to the right (or left for RTL languages)</li><li>1: to the beginning of the next line</li><li>2: below</li></ul>Putting 1 is equivalent to putting 0 and calling Ln() just after. Default value: 0.\n\t * @param string $align Allows to center or align the text. Possible values are:<ul><li>L or empty string: left align (default value)</li><li>C: center</li><li>R: right align</li><li>J: justify</li></ul>\n\t * @param boolean $fill Indicates if the cell background must be painted (true) or transparent (false).\n\t * @param mixed $link URL or identifier returned by AddLink().\n\t * @param int $stretch font stretch mode: <ul><li>0 = disabled</li><li>1 = horizontal scaling only if text is larger than cell width</li><li>2 = forced horizontal scaling to fit cell width</li><li>3 = character spacing only if text is larger than cell width</li><li>4 = forced character spacing to fit cell width</li></ul> General font stretching and scaling values will be preserved when possible.\n\t * @param boolean $ignore_min_height if true ignore automatic minimum height value.\n\t * @param string $calign cell vertical alignment relative to the specified Y value. Possible values are:<ul><li>T : cell top</li><li>C : center</li><li>B : cell bottom</li><li>A : font top</li><li>L : font baseline</li><li>D : font bottom</li></ul>\n\t * @param string $valign text vertical alignment inside the cell. Possible values are:<ul><li>T : top</li><li>M : middle</li><li>B : bottom</li></ul>\n\t * @return string containing cell code\n\t * @protected\n\t * @since 1.0\n\t * @see Cell()\n\t */\n\tprotected function getCellCode($w, $h=0, $txt='', $border=0, $ln=0, $align='', $fill=false, $link='', $stretch=0, $ignore_min_height=false, $calign='T', $valign='M') {\n\t\t// replace 'NO-BREAK SPACE' (U+00A0) character with a simple space\n\t\t$txt = is_null($txt) ? '' : $txt;\n\t\t$txt = str_replace(TCPDF_FONTS::unichr(160, $this->isunicode), ' ', $txt);\n\t\t$prev_cell_margin = $this->cell_margin;\n\t\t$prev_cell_padding = $this->cell_padding;\n\t\t$txt = TCPDF_STATIC::removeSHY($txt, $this->isunicode);\n\t\t$rs = ''; //string to be returned\n\t\t$this->adjustCellPadding($border);\n\t\tif (!$ignore_min_height) {\n\t\t\t$min_cell_height = $this->getCellHeight($this->FontSize);\n\t\t\tif ($h < $min_cell_height) {\n\t\t\t\t$h = $min_cell_height;\n\t\t\t}\n\t\t}\n\t\t$k = $this->k;\n\t\t// check page for no-write regions and adapt page margins if necessary\n\t\tlist($this->x, $this->y) = $this->checkPageRegions($h, $this->x, $this->y);\n\t\tif ($this->rtl) {\n\t\t\t$x = $this->x - $this->cell_margin['R'];\n\t\t} else {\n\t\t\t$x = $this->x + $this->cell_margin['L'];\n\t\t}\n\t\t$y = $this->y + $this->cell_margin['T'];\n\t\t$prev_font_stretching = $this->font_stretching;\n\t\t$prev_font_spacing = $this->font_spacing;\n\t\t// cell vertical alignment\n\t\tswitch ($calign) {\n\t\t\tcase 'A': {\n\t\t\t\t// font top\n\t\t\t\tswitch ($valign) {\n\t\t\t\t\tcase 'T': {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\t$y -= $this->cell_padding['T'];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'B': {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\t$y -= ($h - $this->cell_padding['B'] - $this->FontAscent - $this->FontDescent);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'M': {\n\t\t\t\t\t\t// center\n\t\t\t\t\t\t$y -= (($h - $this->FontAscent - $this->FontDescent) / 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'L': {\n\t\t\t\t// font baseline\n\t\t\t\tswitch ($valign) {\n\t\t\t\t\tcase 'T': {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\t$y -= ($this->cell_padding['T'] + $this->FontAscent);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'B': {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\t$y -= ($h - $this->cell_padding['B'] - $this->FontDescent);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'M': {\n\t\t\t\t\t\t// center\n\t\t\t\t\t\t$y -= (($h + $this->FontAscent - $this->FontDescent) / 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D': {\n\t\t\t\t// font bottom\n\t\t\t\tswitch ($valign) {\n\t\t\t\t\tcase 'T': {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\t$y -= ($this->cell_padding['T'] + $this->FontAscent + $this->FontDescent);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'B': {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\t$y -= ($h - $this->cell_padding['B']);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'M': {\n\t\t\t\t\t\t// center\n\t\t\t\t\t\t$y -= (($h + $this->FontAscent + $this->FontDescent) / 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'B': {\n\t\t\t\t// cell bottom\n\t\t\t\t$y -= $h;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'C':\n\t\t\tcase 'M': {\n\t\t\t\t// cell center\n\t\t\t\t$y -= ($h / 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\tcase 'T': {\n\t\t\t\t// cell top\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// text vertical alignment\n\t\tswitch ($valign) {\n\t\t\tcase 'T': {\n\t\t\t\t// top\n\t\t\t\t$yt = $y + $this->cell_padding['T'];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'B': {\n\t\t\t\t// bottom\n\t\t\t\t$yt = $y + $h - $this->cell_padding['B'] - $this->FontAscent - $this->FontDescent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\tcase 'C':\n\t\t\tcase 'M': {\n\t\t\t\t// center\n\t\t\t\t$yt = $y + (($h - $this->FontAscent - $this->FontDescent) / 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$basefonty = $yt + $this->FontAscent;\n\t\tif (TCPDF_STATIC::empty_string($w) OR ($w <= 0)) {\n\t\t\tif ($this->rtl) {\n\t\t\t\t$w = $x - $this->lMargin;\n\t\t\t} else {\n\t\t\t\t$w = $this->w - $this->rMargin - $x;\n\t\t\t}\n\t\t}\n\t\t$s = '';\n\t\t// fill and borders\n\t\tif (is_string($border) AND (strlen($border) == 4)) {\n\t\t\t// full border\n\t\t\t$border = 1;\n\t\t}\n\t\tif ($fill OR ($border == 1)) {\n\t\t\tif ($fill) {\n\t\t\t\t$op = ($border == 1) ? 'B' : 'f';\n\t\t\t} else {\n\t\t\t\t$op = 'S';\n\t\t\t}\n\t\t\tif ($this->rtl) {\n\t\t\t\t$xk = (($x - $w) * $k);\n\t\t\t} else {\n\t\t\t\t$xk = ($x * $k);\n\t\t\t}\n\t\t\t$s .= sprintf('%F %F %F %F re %s ', $xk, (($this->h - $y) * $k), ($w * $k), (-$h * $k), $op);\n\t\t}\n\t\t// draw borders\n\t\t$s .= $this->getCellBorder($x, $y, $w, $h, $border);\n\t\tif ($txt != '') {\n\t\t\t$txt2 = $txt;\n\t\t\tif ($this->isunicode) {\n\t\t\t\tif (($this->CurrentFont['type'] == 'core') OR ($this->CurrentFont['type'] == 'TrueType') OR ($this->CurrentFont['type'] == 'Type1')) {\n\t\t\t\t\t$txt2 = TCPDF_FONTS::UTF8ToLatin1($txt2, $this->isunicode, $this->CurrentFont);\n\t\t\t\t} else {\n\t\t\t\t\t$unicode = TCPDF_FONTS::UTF8StringToArray($txt, $this->isunicode, $this->CurrentFont); // array of UTF-8 unicode values\n\t\t\t\t\t$unicode = TCPDF_FONTS::utf8Bidi($unicode, '', $this->tmprtl, $this->isunicode, $this->CurrentFont);\n\t\t\t\t\t// replace thai chars (if any)\n\t\t\t\t\tif (defined('K_THAI_TOPCHARS') AND (K_THAI_TOPCHARS == true)) {\n\t\t\t\t\t\t// number of chars\n\t\t\t\t\t\t$numchars = count($unicode);\n\t\t\t\t\t\t// po pla, for far, for fan\n\t\t\t\t\t\t$longtail = array(0x0e1b, 0x0e1d, 0x0e1f);\n\t\t\t\t\t\t// do chada, to patak\n\t\t\t\t\t\t$lowtail = array(0x0e0e, 0x0e0f);\n\t\t\t\t\t\t// mai hun arkad, sara i, sara ii, sara ue, sara uee\n\t\t\t\t\t\t$upvowel = array(0x0e31, 0x0e34, 0x0e35, 0x0e36, 0x0e37);\n\t\t\t\t\t\t// mai ek, mai tho, mai tri, mai chattawa, karan\n\t\t\t\t\t\t$tonemark = array(0x0e48, 0x0e49, 0x0e4a, 0x0e4b, 0x0e4c);\n\t\t\t\t\t\t// sara u, sara uu, pinthu\n\t\t\t\t\t\t$lowvowel = array(0x0e38, 0x0e39, 0x0e3a);\n\t\t\t\t\t\t$output = array();\n\t\t\t\t\t\tfor ($i = 0; $i < $numchars; $i++) {\n\t\t\t\t\t\t\tif (($unicode[$i] >= 0x0e00) && ($unicode[$i] <= 0x0e5b)) {\n\t\t\t\t\t\t\t\t$ch0 = $unicode[$i];\n\t\t\t\t\t\t\t\t$ch1 = ($i > 0) ? $unicode[($i - 1)] : 0;\n\t\t\t\t\t\t\t\t$ch2 = ($i > 1) ? $unicode[($i - 2)] : 0;\n\t\t\t\t\t\t\t\t$chn = ($i < ($numchars - 1)) ? $unicode[($i + 1)] : 0;\n\t\t\t\t\t\t\t\tif (in_array($ch0, $tonemark)) {\n\t\t\t\t\t\t\t\t\tif ($chn == 0x0e33) {\n\t\t\t\t\t\t\t\t\t\t// sara um\n\t\t\t\t\t\t\t\t\t\tif (in_array($ch1, $longtail)) {\n\t\t\t\t\t\t\t\t\t\t\t// tonemark at upper left\n\t\t\t\t\t\t\t\t\t\t\t$output[] = $this->replaceChar($ch0, (0xf713 + $ch0 - 0x0e48));\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// tonemark at upper right (normal position)\n\t\t\t\t\t\t\t\t\t\t\t$output[] = $ch0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} elseif (in_array($ch1, $longtail) OR (in_array($ch2, $longtail) AND in_array($ch1, $lowvowel))) {\n\t\t\t\t\t\t\t\t\t\t// tonemark at lower left\n\t\t\t\t\t\t\t\t\t\t$output[] = $this->replaceChar($ch0, (0xf705 + $ch0 - 0x0e48));\n\t\t\t\t\t\t\t\t\t} elseif (in_array($ch1, $upvowel)) {\n\t\t\t\t\t\t\t\t\t\tif (in_array($ch2, $longtail)) {\n\t\t\t\t\t\t\t\t\t\t\t// tonemark at upper left\n\t\t\t\t\t\t\t\t\t\t\t$output[] = $this->replaceChar($ch0, (0xf713 + $ch0 - 0x0e48));\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// tonemark at upper right (normal position)\n\t\t\t\t\t\t\t\t\t\t\t$output[] = $ch0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// tonemark at lower right\n\t\t\t\t\t\t\t\t\t\t$output[] = $this->replaceChar($ch0, (0xf70a + $ch0 - 0x0e48));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} elseif (($ch0 == 0x0e33) AND (in_array($ch1, $longtail) OR (in_array($ch2, $longtail) AND in_array($ch1, $tonemark)))) {\n\t\t\t\t\t\t\t\t\t// add lower left nikhahit and sara aa\n\t\t\t\t\t\t\t\t\tif ($this->isCharDefined(0xf711) AND $this->isCharDefined(0x0e32)) {\n\t\t\t\t\t\t\t\t\t\t$output[] = 0xf711;\n\t\t\t\t\t\t\t\t\t\t$this->CurrentFont['subsetchars'][0xf711] = true;\n\t\t\t\t\t\t\t\t\t\t$output[] = 0x0e32;\n\t\t\t\t\t\t\t\t\t\t$this->CurrentFont['subsetchars'][0x0e32] = true;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t$output[] = $ch0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} elseif (in_array($ch1, $longtail)) {\n\t\t\t\t\t\t\t\t\tif ($ch0 == 0x0e31) {\n\t\t\t\t\t\t\t\t\t\t// lower left mai hun arkad\n\t\t\t\t\t\t\t\t\t\t$output[] = $this->replaceChar($ch0, 0xf710);\n\t\t\t\t\t\t\t\t\t} elseif (in_array($ch0, $upvowel)) {\n\t\t\t\t\t\t\t\t\t\t// lower left\n\t\t\t\t\t\t\t\t\t\t$output[] = $this->replaceChar($ch0, (0xf701 + $ch0 - 0x0e34));\n\t\t\t\t\t\t\t\t\t} elseif ($ch0 == 0x0e47) {\n\t\t\t\t\t\t\t\t\t\t// lower left mai tai koo\n\t\t\t\t\t\t\t\t\t\t$output[] = $this->replaceChar($ch0, 0xf712);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// normal character\n\t\t\t\t\t\t\t\t\t\t$output[] = $ch0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} elseif (in_array($ch1, $lowtail) AND in_array($ch0, $lowvowel)) {\n\t\t\t\t\t\t\t\t\t// lower vowel\n\t\t\t\t\t\t\t\t\t$output[] = $this->replaceChar($ch0, (0xf718 + $ch0 - 0x0e38));\n\t\t\t\t\t\t\t\t} elseif (($ch0 == 0x0e0d) AND in_array($chn, $lowvowel)) {\n\t\t\t\t\t\t\t\t\t// yo ying without lower part\n\t\t\t\t\t\t\t\t\t$output[] = $this->replaceChar($ch0, 0xf70f);\n\t\t\t\t\t\t\t\t} elseif (($ch0 == 0x0e10) AND in_array($chn, $lowvowel)) {\n\t\t\t\t\t\t\t\t\t// tho santan without lower part\n\t\t\t\t\t\t\t\t\t$output[] = $this->replaceChar($ch0, 0xf700);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$output[] = $ch0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// non-thai character\n\t\t\t\t\t\t\t\t$output[] = $unicode[$i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$unicode = $output;\n\t\t\t\t\t\t// update font subsetchars\n\t\t\t\t\t\t$this->setFontSubBuffer($this->CurrentFont['fontkey'], 'subsetchars', $this->CurrentFont['subsetchars']);\n\t\t\t\t\t} // end of K_THAI_TOPCHARS\n\t\t\t\t\t$txt2 = TCPDF_FONTS::arrUTF8ToUTF16BE($unicode, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$txt2 = TCPDF_STATIC::_escape($txt2);\n\t\t\t// get current text width (considering general font stretching and spacing)\n\t\t\t$txwidth = $this->GetStringWidth($txt);\n\t\t\t$width = $txwidth;\n\t\t\t// check for stretch mode\n\t\t\tif ($stretch > 0) {\n\t\t\t\t// calculate ratio between cell width and text width\n\t\t\t\tif ($width <= 0) {\n\t\t\t\t\t$ratio = 1;\n\t\t\t\t} else {\n\t\t\t\t\t$ratio = (($w - $this->cell_padding['L'] - $this->cell_padding['R']) / $width);\n\t\t\t\t}\n\t\t\t\t// check if stretching is required\n\t\t\t\tif (($ratio < 1) OR (($ratio > 1) AND (($stretch % 2) == 0))) {\n\t\t\t\t\t// the text will be stretched to fit cell width\n\t\t\t\t\tif ($stretch > 2) {\n\t\t\t\t\t\t// set new character spacing\n\t\t\t\t\t\t$this->font_spacing += ($w - $this->cell_padding['L'] - $this->cell_padding['R'] - $width) / (max(($this->GetNumChars($txt) - 1), 1) * ($this->font_stretching / 100));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// set new horizontal stretching\n\t\t\t\t\t\t$this->font_stretching *= $ratio;\n\t\t\t\t\t}\n\t\t\t\t\t// recalculate text width (the text fills the entire cell)\n\t\t\t\t\t$width = $w - $this->cell_padding['L'] - $this->cell_padding['R'];\n\t\t\t\t\t// reset alignment\n\t\t\t\t\t$align = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($this->font_stretching != 100) {\n\t\t\t\t// apply font stretching\n\t\t\t\t$rs .= sprintf('BT %F Tz ET ', $this->font_stretching);\n\t\t\t}\n\t\t\tif ($this->font_spacing != 0) {\n\t\t\t\t// increase/decrease font spacing\n\t\t\t\t$rs .= sprintf('BT %F Tc ET ', ($this->font_spacing * $this->k));\n\t\t\t}\n\t\t\tif ($this->ColorFlag AND ($this->textrendermode < 4)) {\n\t\t\t\t$s .= 'q '.$this->TextColor.' ';\n\t\t\t}\n\t\t\t// rendering mode\n\t\t\t$s .= sprintf('BT %d Tr %F w ET ', $this->textrendermode, ($this->textstrokewidth * $this->k));\n\t\t\t// count number of spaces\n\t\t\t$ns = substr_count($txt, chr(32));\n\t\t\t// Justification\n\t\t\t$spacewidth = 0;\n\t\t\tif (($align == 'J') AND ($ns > 0)) {\n\t\t\t\tif ($this->isUnicodeFont()) {\n\t\t\t\t\t// get string width without spaces\n\t\t\t\t\t$width = $this->GetStringWidth(str_replace(' ', '', $txt));\n\t\t\t\t\t// calculate average space width\n\t\t\t\t\t$spacewidth = -1000 * ($w - $width - $this->cell_padding['L'] - $this->cell_padding['R']) / ($ns?$ns:1) / ($this->FontSize?$this->FontSize:1);\n\t\t\t\t\tif ($this->font_stretching != 100) {\n\t\t\t\t\t\t// word spacing is affected by stretching\n\t\t\t\t\t\t$spacewidth /= ($this->font_stretching / 100);\n\t\t\t\t\t}\n\t\t\t\t\t// set word position to be used with TJ operator\n\t\t\t\t\t$txt2 = str_replace(chr(0).chr(32), ') '.sprintf('%F', $spacewidth).' (', $txt2);\n\t\t\t\t\t$unicode_justification = true;\n\t\t\t\t} else {\n\t\t\t\t\t// get string width\n\t\t\t\t\t$width = $txwidth;\n\t\t\t\t\t// new space width\n\t\t\t\t\t$spacewidth = (($w - $width - $this->cell_padding['L'] - $this->cell_padding['R']) / ($ns?$ns:1)) * $this->k;\n\t\t\t\t\tif ($this->font_stretching != 100) {\n\t\t\t\t\t\t// word spacing (Tw) is affected by stretching\n\t\t\t\t\t\t$spacewidth /= ($this->font_stretching / 100);\n\t\t\t\t\t}\n\t\t\t\t\t// set word spacing\n\t\t\t\t\t$rs .= sprintf('BT %F Tw ET ', $spacewidth);\n\t\t\t\t}\n\t\t\t\t$width = $w - $this->cell_padding['L'] - $this->cell_padding['R'];\n\t\t\t}\n\t\t\t// replace carriage return characters\n\t\t\t$txt2 = str_replace(\"\\r\", ' ', $txt2);\n\t\t\tswitch ($align) {\n\t\t\t\tcase 'C': {\n\t\t\t\t\t$dx = ($w - $width) / 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'R': {\n\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t$dx = $this->cell_padding['R'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$dx = $w - $width - $this->cell_padding['R'];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'L': {\n\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t$dx = $w - $width - $this->cell_padding['L'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$dx = $this->cell_padding['L'];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'J':\n\t\t\t\tdefault: {\n\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t$dx = $this->cell_padding['R'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$dx = $this->cell_padding['L'];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($this->rtl) {\n\t\t\t\t$xdx = $x - $dx - $width;\n\t\t\t} else {\n\t\t\t\t$xdx = $x + $dx;\n\t\t\t}\n\t\t\t$xdk = $xdx * $k;\n\t\t\t// print text\n\t\t\t$s .= sprintf('BT %F %F Td [(%s)] TJ ET', $xdk, (($this->h - $basefonty) * $k), $txt2);\n\t\t\tif (isset($uniblock)) { // @phpstan-ignore-line\n\t\t\t\t// print overlapping characters as separate string\n\t\t\t\t$xshift = 0; // horizontal shift\n\t\t\t\t$ty = (($this->h - $basefonty + (0.2 * $this->FontSize)) * $k);\n\t\t\t\t$spw = (($w - $txwidth - $this->cell_padding['L'] - $this->cell_padding['R']) / ($ns?$ns:1));\n\t\t\t\tforeach ($uniblock as $uk => $uniarr) { // @phpstan-ignore-line\n\t\t\t\t\tif (($uk % 2) == 0) {\n\t\t\t\t\t\t// x space to skip\n\t\t\t\t\t\tif ($spacewidth != 0) {\n\t\t\t\t\t\t\t// justification shift\n\t\t\t\t\t\t\t$xshift += (count(array_keys($uniarr, 32)) * $spw);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$xshift += $this->GetArrStringWidth($uniarr); // + shift justification\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// character to print\n\t\t\t\t\t\t$topchr = TCPDF_FONTS::arrUTF8ToUTF16BE($uniarr, false);\n\t\t\t\t\t\t$topchr = TCPDF_STATIC::_escape($topchr);\n\t\t\t\t\t\t$s .= sprintf(' BT %F %F Td [(%s)] TJ ET', ($xdk + ($xshift * $k)), $ty, $topchr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($this->underline) {\n\t\t\t\t$s .= ' '.$this->_dounderlinew($xdx, $basefonty, $width);\n\t\t\t}\n\t\t\tif ($this->linethrough) {\n\t\t\t\t$s .= ' '.$this->_dolinethroughw($xdx, $basefonty, $width);\n\t\t\t}\n\t\t\tif ($this->overline) {\n\t\t\t\t$s .= ' '.$this->_dooverlinew($xdx, $basefonty, $width);\n\t\t\t}\n\t\t\tif ($this->ColorFlag AND ($this->textrendermode < 4)) {\n\t\t\t\t$s .= ' Q';\n\t\t\t}\n\t\t\tif ($link) {\n\t\t\t\t$this->Link($xdx, $yt, $width, ($this->FontAscent + $this->FontDescent), $link, $ns);\n\t\t\t}\n\t\t}\n\t\t// output cell\n\t\tif ($s) {\n\t\t\t// output cell\n\t\t\t$rs .= $s;\n\t\t\tif ($this->font_spacing != 0) {\n\t\t\t\t// reset font spacing mode\n\t\t\t\t$rs .= ' BT 0 Tc ET';\n\t\t\t}\n\t\t\tif ($this->font_stretching != 100) {\n\t\t\t\t// reset font stretching mode\n\t\t\t\t$rs .= ' BT 100 Tz ET';\n\t\t\t}\n\t\t}\n\t\t// reset word spacing\n\t\tif (!$this->isUnicodeFont() AND ($align == 'J')) {\n\t\t\t$rs .= ' BT 0 Tw ET';\n\t\t}\n\t\t// reset stretching and spacing\n\t\t$this->font_stretching = $prev_font_stretching;\n\t\t$this->font_spacing = $prev_font_spacing;\n\t\t$this->lasth = $h;\n\t\tif ($ln > 0) {\n\t\t\t//Go to the beginning of the next line\n\t\t\t$this->y = $y + $h + $this->cell_margin['B'];\n\t\t\tif ($ln == 1) {\n\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t$this->x = $this->w - $this->rMargin;\n\t\t\t\t} else {\n\t\t\t\t\t$this->x = $this->lMargin;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// go left or right by case\n\t\t\tif ($this->rtl) {\n\t\t\t\t$this->x = $x - $w - $this->cell_margin['L'];\n\t\t\t} else {\n\t\t\t\t$this->x = $x + $w + $this->cell_margin['R'];\n\t\t\t}\n\t\t}\n\t\t$gstyles = ''.$this->linestyleWidth.' '.$this->linestyleCap.' '.$this->linestyleJoin.' '.$this->linestyleDash.' '.$this->DrawColor.' '.$this->FillColor.\"\\n\";\n\t\t$rs = $gstyles.$rs;\n\t\t$this->cell_padding = $prev_cell_padding;\n\t\t$this->cell_margin = $prev_cell_margin;\n\t\treturn $rs;\n\t}\n\n\t/**\n\t * Replace a char if is defined on the current font.\n\t * @param int $oldchar Integer code (unicode) of the character to replace.\n\t * @param int $newchar Integer code (unicode) of the new character.\n\t * @return int the replaced char or the old char in case the new char i not defined\n\t * @protected\n\t * @since 5.9.167 (2012-06-22)\n\t */\n\tprotected function replaceChar($oldchar, $newchar) {\n\t\tif ($this->isCharDefined($newchar)) {\n\t\t\t// add the new char on the subset list\n\t\t\t$this->CurrentFont['subsetchars'][$newchar] = true;\n\t\t\t// return the new character\n\t\t\treturn $newchar;\n\t\t}\n\t\t// return the old char\n\t\treturn $oldchar;\n\t}\n\n\t/**\n\t * Returns the code to draw the cell border\n\t * @param float $x X coordinate.\n\t * @param float $y Y coordinate.\n\t * @param float $w Cell width.\n\t * @param float $h Cell height.\n\t * @param string|array|int $brd Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))\n\t * @return string containing cell border code\n\t * @protected\n\t * @see SetLineStyle()\n\t * @since 5.7.000 (2010-08-02)\n\t */\n\tprotected function getCellBorder($x, $y, $w, $h, $brd) {\n\t\t$s = ''; // string to be returned\n\t\tif (empty($brd)) {\n\t\t\treturn $s;\n\t\t}\n\t\tif ($brd == 1) {\n\t\t\t$brd = array('LRTB' => true);\n\t\t}\n\t\t// calculate coordinates for border\n\t\t$k = $this->k;\n\t\tif ($this->rtl) {\n\t\t\t$xeL = ($x - $w) * $k;\n\t\t\t$xeR = $x * $k;\n\t\t} else {\n\t\t\t$xeL = $x * $k;\n\t\t\t$xeR = ($x + $w) * $k;\n\t\t}\n\t\t$yeL = (($this->h - ($y + $h)) * $k);\n\t\t$yeT = (($this->h - $y) * $k);\n\t\t$xeT = $xeL;\n\t\t$xeB = $xeR;\n\t\t$yeR = $yeT;\n\t\t$yeB = $yeL;\n\t\tif (is_string($brd)) {\n\t\t\t// convert string to array\n\t\t\t$slen = strlen($brd);\n\t\t\t$newbrd = array();\n\t\t\tfor ($i = 0; $i < $slen; ++$i) {\n\t\t\t\t$newbrd[$brd[$i]] = array('cap' => 'square', 'join' => 'miter');\n\t\t\t}\n\t\t\t$brd = $newbrd;\n\t\t}\n\t\tif (isset($brd['mode'])) {\n\t\t\t$mode = $brd['mode'];\n\t\t\tunset($brd['mode']);\n\t\t} else {\n\t\t\t$mode = 'normal';\n\t\t}\n\t\tforeach ($brd as $border => $style) {\n\t\t\tif (is_array($style) AND !empty($style)) {\n\t\t\t\t// apply border style\n\t\t\t\t$prev_style = $this->linestyleWidth.' '.$this->linestyleCap.' '.$this->linestyleJoin.' '.$this->linestyleDash.' '.$this->DrawColor.' ';\n\t\t\t\t$s .= $this->setLineStyle($style, true).\"\\n\";\n\t\t\t}\n\t\t\tswitch ($mode) {\n\t\t\t\tcase 'ext': {\n\t\t\t\t\t$off = (($this->LineWidth / 2) * $k);\n\t\t\t\t\t$xL = $xeL - $off;\n\t\t\t\t\t$xR = $xeR + $off;\n\t\t\t\t\t$yT = $yeT + $off;\n\t\t\t\t\t$yL = $yeL - $off;\n\t\t\t\t\t$xT = $xL;\n\t\t\t\t\t$xB = $xR;\n\t\t\t\t\t$yR = $yT;\n\t\t\t\t\t$yB = $yL;\n\t\t\t\t\t$w += $this->LineWidth;\n\t\t\t\t\t$h += $this->LineWidth;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'int': {\n\t\t\t\t\t$off = ($this->LineWidth / 2) * $k;\n\t\t\t\t\t$xL = $xeL + $off;\n\t\t\t\t\t$xR = $xeR - $off;\n\t\t\t\t\t$yT = $yeT - $off;\n\t\t\t\t\t$yL = $yeL + $off;\n\t\t\t\t\t$xT = $xL;\n\t\t\t\t\t$xB = $xR;\n\t\t\t\t\t$yR = $yT;\n\t\t\t\t\t$yB = $yL;\n\t\t\t\t\t$w -= $this->LineWidth;\n\t\t\t\t\t$h -= $this->LineWidth;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'normal':\n\t\t\t\tdefault: {\n\t\t\t\t\t$xL = $xeL;\n\t\t\t\t\t$xT = $xeT;\n\t\t\t\t\t$xB = $xeB;\n\t\t\t\t\t$xR = $xeR;\n\t\t\t\t\t$yL = $yeL;\n\t\t\t\t\t$yT = $yeT;\n\t\t\t\t\t$yB = $yeB;\n\t\t\t\t\t$yR = $yeR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// draw borders by case\n\t\t\tif (strlen($border) == 4) {\n\t\t\t\t$s .= sprintf('%F %F %F %F re S ', $xT, $yT, ($w * $k), (-$h * $k));\n\t\t\t} elseif (strlen($border) == 3) {\n\t\t\t\tif (strpos($border,'B') === false) { // LTR\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xL, $yL);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xT, $yT);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xR, $yR);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xB, $yB);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t} elseif (strpos($border,'L') === false) { // TRB\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xT, $yT);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xR, $yR);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xB, $yB);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xL, $yL);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t} elseif (strpos($border,'T') === false) { // RBL\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xR, $yR);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xB, $yB);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xL, $yL);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xT, $yT);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t} elseif (strpos($border,'R') === false) { // BLT\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xB, $yB);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xL, $yL);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xT, $yT);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xR, $yR);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t}\n\t\t\t} elseif (strlen($border) == 2) {\n\t\t\t\tif ((strpos($border,'L') !== false) AND (strpos($border,'T') !== false)) { // LT\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xL, $yL);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xT, $yT);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xR, $yR);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t} elseif ((strpos($border,'T') !== false) AND (strpos($border,'R') !== false)) { // TR\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xT, $yT);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xR, $yR);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xB, $yB);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t} elseif ((strpos($border,'R') !== false) AND (strpos($border,'B') !== false)) { // RB\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xR, $yR);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xB, $yB);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xL, $yL);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t} elseif ((strpos($border,'B') !== false) AND (strpos($border,'L') !== false)) { // BL\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xB, $yB);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xL, $yL);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xT, $yT);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t} elseif ((strpos($border,'L') !== false) AND (strpos($border,'R') !== false)) { // LR\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xL, $yL);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xT, $yT);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xR, $yR);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xB, $yB);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t} elseif ((strpos($border,'T') !== false) AND (strpos($border,'B') !== false)) { // TB\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xT, $yT);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xR, $yR);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xB, $yB);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xL, $yL);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t}\n\t\t\t} else { // strlen($border) == 1\n\t\t\t\tif (strpos($border,'L') !== false) { // L\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xL, $yL);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xT, $yT);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t} elseif (strpos($border,'T') !== false) { // T\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xT, $yT);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xR, $yR);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t} elseif (strpos($border,'R') !== false) { // R\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xR, $yR);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xB, $yB);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t} elseif (strpos($border,'B') !== false) { // B\n\t\t\t\t\t$s .= sprintf('%F %F m ', $xB, $yB);\n\t\t\t\t\t$s .= sprintf('%F %F l ', $xL, $yL);\n\t\t\t\t\t$s .= 'S ';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_array($style) AND !empty($style)) {\n\t\t\t\t// reset border style to previous value\n\t\t\t\t$s .= \"\\n\".$this->linestyleWidth.' '.$this->linestyleCap.' '.$this->linestyleJoin.' '.$this->linestyleDash.' '.$this->DrawColor.\"\\n\";\n\t\t\t}\n\t\t}\n\t\treturn $s;\n\t}\n\n\t/**\n\t * This method allows printing text with line breaks.\n\t * They can be automatic (as soon as the text reaches the right border of the cell) or explicit (via the \\n character). As many cells as necessary are output, one below the other.<br />\n\t * Text can be aligned, centered or justified. The cell block can be framed and the background painted.\n\t * @param float $w Width of cells. If 0, they extend up to the right margin of the page.\n\t * @param float $h Cell minimum height. The cell extends automatically if needed.\n\t * @param string $txt String to print\n\t * @param mixed $border Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))\n\t * @param string $align Allows to center or align the text. Possible values are:<ul><li>L or empty string: left align</li><li>C: center</li><li>R: right align</li><li>J: justification (default value when $ishtml=false)</li></ul>\n\t * @param boolean $fill Indicates if the cell background must be painted (true) or transparent (false).\n\t * @param int $ln Indicates where the current position should go after the call. Possible values are:<ul><li>0: to the right</li><li>1: to the beginning of the next line [DEFAULT]</li><li>2: below</li></ul>\n\t * @param float|null $x x position in user units\n\t * @param float|null $y y position in user units\n\t * @param boolean $reseth if true reset the last cell height (default true).\n\t * @param int $stretch font stretch mode: <ul><li>0 = disabled</li><li>1 = horizontal scaling only if text is larger than cell width</li><li>2 = forced horizontal scaling to fit cell width</li><li>3 = character spacing only if text is larger than cell width</li><li>4 = forced character spacing to fit cell width</li></ul> General font stretching and scaling values will be preserved when possible.\n\t * @param boolean $ishtml INTERNAL USE ONLY -- set to true if $txt is HTML content (default = false). Never set this parameter to true, use instead writeHTMLCell() or writeHTML() methods.\n\t * @param boolean $autopadding if true, uses internal padding and automatically adjust it to account for line width.\n\t * @param float $maxh maximum height. It should be >= $h and less then remaining space to the bottom of the page, or 0 for disable this feature. This feature works only when $ishtml=false.\n\t * @param string $valign Vertical alignment of text (requires $maxh = $h > 0). Possible values are:<ul><li>T: TOP</li><li>M: middle</li><li>B: bottom</li></ul>. This feature works only when $ishtml=false and the cell must fit in a single page.\n\t * @param boolean $fitcell if true attempt to fit all the text within the cell by reducing the font size (do not work in HTML mode). $maxh must be greater than 0 and equal to $h.\n\t * @return int Return the number of cells or 1 for html mode.\n\t * @public\n\t * @since 1.3\n\t * @see SetFont(), SetDrawColor(), SetFillColor(), SetTextColor(), SetLineWidth(), Cell(), Write(), SetAutoPageBreak()\n\t */\n\tpublic function MultiCell($w, $h, $txt, $border=0, $align='J', $fill=false, $ln=1, $x=null, $y=null, $reseth=true, $stretch=0, $ishtml=false, $autopadding=true, $maxh=0, $valign='T', $fitcell=false) {\n\t\t$prev_cell_margin = $this->cell_margin;\n\t\t$prev_cell_padding = $this->cell_padding;\n\t\t// adjust internal padding\n\t\t$this->adjustCellPadding($border);\n\t\t$mc_padding = $this->cell_padding;\n\t\t$mc_margin = $this->cell_margin;\n\t\t$this->cell_padding['T'] = 0;\n\t\t$this->cell_padding['B'] = 0;\n\t\t$this->setCellMargins(0, 0, 0, 0);\n\t\tif (TCPDF_STATIC::empty_string($this->lasth) OR $reseth) {\n\t\t\t// reset row height\n\t\t\t$this->resetLastH();\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($y)) {\n\t\t\t$this->setY($y); // set y in order to convert negative y values to positive ones\n\t\t}\n\t\t$y = $this->GetY();\n\t\t$resth = 0;\n\t\tif (($h > 0) AND $this->inPageBody() AND (($y + $h + $mc_margin['T'] + $mc_margin['B']) > $this->PageBreakTrigger)) {\n\t\t\t// spit cell in more pages/columns\n\t\t\t$newh = ($this->PageBreakTrigger - $y);\n\t\t\t$resth = ($h - $newh); // cell to be printed on the next page/column\n\t\t\t$h = $newh;\n\t\t}\n\t\t// get current page number\n\t\t$startpage = $this->page;\n\t\t// get current column\n\t\t$startcolumn = $this->current_column;\n\t\tif (!TCPDF_STATIC::empty_string($x)) {\n\t\t\t$this->setX($x);\n\t\t} else {\n\t\t\t$x = $this->GetX();\n\t\t}\n\t\t// check page for no-write regions and adapt page margins if necessary\n\t\tlist($x, $y) = $this->checkPageRegions(0, $x, $y);\n\t\t// apply margins\n\t\t$oy = $y + $mc_margin['T'];\n\t\tif ($this->rtl) {\n\t\t\t$ox = ($this->w - $x - $mc_margin['R']);\n\t\t} else {\n\t\t\t$ox = ($x + $mc_margin['L']);\n\t\t}\n\t\t$this->x = $ox;\n\t\t$this->y = $oy;\n\t\t// set width\n\t\tif (TCPDF_STATIC::empty_string($w) OR ($w <= 0)) {\n\t\t\tif ($this->rtl) {\n\t\t\t\t$w = ($this->x - $this->lMargin - $mc_margin['L']);\n\t\t\t} else {\n\t\t\t\t$w = ($this->w - $this->x - $this->rMargin - $mc_margin['R']);\n\t\t\t}\n\t\t}\n\t\t// store original margin values\n\t\t$lMargin = $this->lMargin;\n\t\t$rMargin = $this->rMargin;\n\t\tif ($this->rtl) {\n\t\t\t$this->rMargin = ($this->w - $this->x);\n\t\t\t$this->lMargin = ($this->x - $w);\n\t\t} else {\n\t\t\t$this->lMargin = ($this->x);\n\t\t\t$this->rMargin = ($this->w - $this->x - $w);\n\t\t}\n\t\t$this->clMargin = $this->lMargin;\n\t\t$this->crMargin = $this->rMargin;\n\t\tif ($autopadding) {\n\t\t\t// add top padding\n\t\t\t$this->y += $mc_padding['T'];\n\t\t}\n\t\tif ($ishtml) { // ******* Write HTML text\n\t\t\t$this->writeHTML($txt, true, false, $reseth, true, $align);\n\t\t\t$nl = 1;\n\t\t} else { // ******* Write simple text\n\t\t\t$prev_FontSizePt = $this->FontSizePt;\n\t\t\tif ($fitcell) {\n\t\t\t\t// ajust height values\n\t\t\t\t$tobottom = ($this->h - $this->y - $this->bMargin - $this->cell_padding['T'] - $this->cell_padding['B']);\n\t\t\t\t$h = $maxh = max(min($h, $tobottom), min($maxh, $tobottom));\n\t\t\t}\n\t\t\t// vertical alignment\n\t\t\tif ($maxh > 0) {\n\t\t\t\t// get text height\n\t\t\t\t$text_height = $this->getStringHeight($w, $txt, $reseth, $autopadding, $mc_padding, $border);\n\t\t\t\tif ($fitcell AND ($text_height > $maxh) AND ($this->FontSizePt > 1)) {\n\t\t\t\t\t// try to reduce font size to fit text on cell (use a quick search algorithm)\n\t\t\t\t\t$fmin = 1;\n\t\t\t\t\t$fmax = $this->FontSizePt;\n\t\t\t\t\t$diff_epsilon = (1 / $this->k); // one point (min resolution)\n\t\t\t\t\t$maxit = (2 * min(100, max(10, intval($fmax)))); // max number of iterations\n\t\t\t\t\twhile ($maxit >= 0) {\n\t\t\t\t\t\t$fmid = (($fmax + $fmin) / 2);\n\t\t\t\t\t\t$this->setFontSize($fmid, false);\n\t\t\t\t\t\t$this->resetLastH();\n\t\t\t\t\t\t$text_height = $this->getStringHeight($w, $txt, $reseth, $autopadding, $mc_padding, $border);\n\t\t\t\t\t\t$diff = ($maxh - $text_height);\n\t\t\t\t\t\tif ($diff >= 0) {\n\t\t\t\t\t\t\tif ($diff <= $diff_epsilon) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$fmin = $fmid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$fmax = $fmid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t--$maxit;\n\t\t\t\t\t}\n\t\t\t\t\tif ($maxit < 0) {\n\t\t\t\t\t\t// premature exit, we get the minimum font value to fit the cell\n\t\t\t\t\t\t$this->setFontSize($fmin);\n\t\t\t\t\t\t$this->resetLastH();\n\t\t\t\t\t\t$text_height = $this->getStringHeight($w, $txt, $reseth, $autopadding, $mc_padding, $border);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->setFontSize($fmid);\n\t\t\t\t\t\t$this->resetLastH();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($text_height < $maxh) {\n\t\t\t\t\tif ($valign == 'M') {\n\t\t\t\t\t\t// text vertically centered\n\t\t\t\t\t\t$this->y += (($maxh - $text_height) / 2);\n\t\t\t\t\t} elseif ($valign == 'B') {\n\t\t\t\t\t\t// text vertically aligned on bottom\n\t\t\t\t\t\t$this->y += ($maxh - $text_height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$nl = $this->Write($this->lasth, $txt, '', 0, $align, true, $stretch, false, true, $maxh, 0, $mc_margin);\n\t\t\tif ($fitcell) {\n\t\t\t\t// restore font size\n\t\t\t\t$this->setFontSize($prev_FontSizePt);\n\t\t\t}\n\t\t}\n\t\tif ($autopadding) {\n\t\t\t// add bottom padding\n\t\t\t$this->y += $mc_padding['B'];\n\t\t}\n\t\t// Get end-of-text Y position\n\t\t$currentY = $this->y;\n\t\t// get latest page number\n\t\t$endpage = $this->page;\n\t\tif ($resth > 0) {\n\t\t\t$skip = ($endpage - $startpage);\n\t\t\t$tmpresth = $resth;\n\t\t\twhile ($tmpresth > 0) {\n\t\t\t\tif ($skip <= 0) {\n\t\t\t\t\t// add a page (or trig AcceptPageBreak() for multicolumn mode)\n\t\t\t\t\t$this->checkPageBreak($this->PageBreakTrigger + 1);\n\t\t\t\t}\n\t\t\t\tif ($this->num_columns > 1) {\n\t\t\t\t\t$tmpresth -= ($this->h - $this->y - $this->bMargin);\n\t\t\t\t} else {\n\t\t\t\t\t$tmpresth -= ($this->h - $this->tMargin - $this->bMargin);\n\t\t\t\t}\n\t\t\t\t--$skip;\n\t\t\t}\n\t\t\t$currentY = $this->y;\n\t\t\t$endpage = $this->page;\n\t\t}\n\t\t// get latest column\n\t\t$endcolumn = $this->current_column;\n\t\tif ($this->num_columns == 0) {\n\t\t\t$this->num_columns = 1;\n\t\t}\n\t\t// disable page regions check\n\t\t$check_page_regions = $this->check_page_regions;\n\t\t$this->check_page_regions = false;\n\t\t// get border modes\n\t\t$border_start = TCPDF_STATIC::getBorderMode($border, $position='start', $this->opencell);\n\t\t$border_end = TCPDF_STATIC::getBorderMode($border, $position='end', $this->opencell);\n\t\t$border_middle = TCPDF_STATIC::getBorderMode($border, $position='middle', $this->opencell);\n\t\t// design borders around HTML cells.\n\t\tfor ($page = $startpage; $page <= $endpage; ++$page) { // for each page\n\t\t\t$ccode = '';\n\t\t\t$this->setPage($page);\n\t\t\tif ($this->num_columns < 2) {\n\t\t\t\t// single-column mode\n\t\t\t\t$this->setX($x);\n\t\t\t\t$this->y = $this->tMargin;\n\t\t\t}\n\t\t\t// account for margin changes\n\t\t\tif ($page > $startpage) {\n\t\t\t\tif (($this->rtl) AND ($this->pagedim[$page]['orm'] != $this->pagedim[$startpage]['orm'])) {\n\t\t\t\t\t$this->x -= ($this->pagedim[$page]['orm'] - $this->pagedim[$startpage]['orm']);\n\t\t\t\t} elseif ((!$this->rtl) AND ($this->pagedim[$page]['olm'] != $this->pagedim[$startpage]['olm'])) {\n\t\t\t\t\t$this->x += ($this->pagedim[$page]['olm'] - $this->pagedim[$startpage]['olm']);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($startpage == $endpage) {\n\t\t\t\t// single page\n\t\t\t\tfor ($column = $startcolumn; $column <= $endcolumn; ++$column) { // for each column\n\t\t\t\t\tif ($column != $this->current_column) {\n\t\t\t\t\t\t$this->selectColumn($column);\n\t\t\t\t\t}\n\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t$this->x -= $mc_margin['R'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->x += $mc_margin['L'];\n\t\t\t\t\t}\n\t\t\t\t\tif ($startcolumn == $endcolumn) { // single column\n\t\t\t\t\t\t$cborder = $border;\n\t\t\t\t\t\t$h = max($h, ($currentY - $oy));\n\t\t\t\t\t\t$this->y = $oy;\n\t\t\t\t\t} elseif ($column == $startcolumn) { // first column\n\t\t\t\t\t\t$cborder = $border_start;\n\t\t\t\t\t\t$this->y = $oy;\n\t\t\t\t\t\t$h = $this->h - $this->y - $this->bMargin;\n\t\t\t\t\t} elseif ($column == $endcolumn) { // end column\n\t\t\t\t\t\t$cborder = $border_end;\n\t\t\t\t\t\t$h = $currentY - $this->y;\n\t\t\t\t\t\tif ($resth > $h) {\n\t\t\t\t\t\t\t$h = $resth;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // middle column\n\t\t\t\t\t\t$cborder = $border_middle;\n\t\t\t\t\t\t$h = $this->h - $this->y - $this->bMargin;\n\t\t\t\t\t\t$resth -= $h;\n\t\t\t\t\t}\n\t\t\t\t\t$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).\"\\n\";\n\t\t\t\t} // end for each column\n\t\t\t} elseif ($page == $startpage) { // first page\n\t\t\t\tfor ($column = $startcolumn; $column < $this->num_columns; ++$column) { // for each column\n\t\t\t\t\tif ($column != $this->current_column) {\n\t\t\t\t\t\t$this->selectColumn($column);\n\t\t\t\t\t}\n\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t$this->x -= $mc_margin['R'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->x += $mc_margin['L'];\n\t\t\t\t\t}\n\t\t\t\t\tif ($column == $startcolumn) { // first column\n\t\t\t\t\t\t$cborder = $border_start;\n\t\t\t\t\t\t$this->y = $oy;\n\t\t\t\t\t\t$h = $this->h - $this->y - $this->bMargin;\n\t\t\t\t\t} else { // middle column\n\t\t\t\t\t\t$cborder = $border_middle;\n\t\t\t\t\t\t$h = $this->h - $this->y - $this->bMargin;\n\t\t\t\t\t\t$resth -= $h;\n\t\t\t\t\t}\n\t\t\t\t\t$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).\"\\n\";\n\t\t\t\t} // end for each column\n\t\t\t} elseif ($page == $endpage) { // last page\n\t\t\t\tfor ($column = 0; $column <= $endcolumn; ++$column) { // for each column\n\t\t\t\t\tif ($column != $this->current_column) {\n\t\t\t\t\t\t$this->selectColumn($column);\n\t\t\t\t\t}\n\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t$this->x -= $mc_margin['R'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->x += $mc_margin['L'];\n\t\t\t\t\t}\n\t\t\t\t\tif ($column == $endcolumn) {\n\t\t\t\t\t\t// end column\n\t\t\t\t\t\t$cborder = $border_end;\n\t\t\t\t\t\t$h = $currentY - $this->y;\n\t\t\t\t\t\tif ($resth > $h) {\n\t\t\t\t\t\t\t$h = $resth;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// middle column\n\t\t\t\t\t\t$cborder = $border_middle;\n\t\t\t\t\t\t$h = $this->h - $this->y - $this->bMargin;\n\t\t\t\t\t\t$resth -= $h;\n\t\t\t\t\t}\n\t\t\t\t\t$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).\"\\n\";\n\t\t\t\t} // end for each column\n\t\t\t} else { // middle page\n\t\t\t\tfor ($column = 0; $column < $this->num_columns; ++$column) { // for each column\n\t\t\t\t\t$this->selectColumn($column);\n\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t$this->x -= $mc_margin['R'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->x += $mc_margin['L'];\n\t\t\t\t\t}\n\t\t\t\t\t$cborder = $border_middle;\n\t\t\t\t\t$h = $this->h - $this->y - $this->bMargin;\n\t\t\t\t\t$resth -= $h;\n\t\t\t\t\t$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).\"\\n\";\n\t\t\t\t} // end for each column\n\t\t\t}\n\t\t\tif ($cborder OR $fill) {\n\t\t\t\t$offsetlen = strlen($ccode);\n\t\t\t\t// draw border and fill\n\t\t\t\tif ($this->inxobj) {\n\t\t\t\t\t// we are inside an XObject template\n\t\t\t\t\tif (end($this->xobjects[$this->xobjid]['transfmrk']) !== false) {\n\t\t\t\t\t\t$pagemarkkey = key($this->xobjects[$this->xobjid]['transfmrk']);\n\t\t\t\t\t\t$pagemark = $this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey];\n\t\t\t\t\t\t$this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey] += $offsetlen;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$pagemark = $this->xobjects[$this->xobjid]['intmrk'];\n\t\t\t\t\t\t$this->xobjects[$this->xobjid]['intmrk'] += $offsetlen;\n\t\t\t\t\t}\n\t\t\t\t\t$pagebuff = $this->xobjects[$this->xobjid]['outdata'];\n\t\t\t\t\t$pstart = substr($pagebuff, 0, $pagemark);\n\t\t\t\t\t$pend = substr($pagebuff, $pagemark);\n\t\t\t\t\t$this->xobjects[$this->xobjid]['outdata'] = $pstart.$ccode.$pend;\n\t\t\t\t} else {\n\t\t\t\t\tif (end($this->transfmrk[$this->page]) !== false) {\n\t\t\t\t\t\t$pagemarkkey = key($this->transfmrk[$this->page]);\n\t\t\t\t\t\t$pagemark = $this->transfmrk[$this->page][$pagemarkkey];\n\t\t\t\t\t\t$this->transfmrk[$this->page][$pagemarkkey] += $offsetlen;\n\t\t\t\t\t} elseif ($this->InFooter) {\n\t\t\t\t\t\t$pagemark = $this->footerpos[$this->page];\n\t\t\t\t\t\t$this->footerpos[$this->page] += $offsetlen;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$pagemark = $this->intmrk[$this->page];\n\t\t\t\t\t\t$this->intmrk[$this->page] += $offsetlen;\n\t\t\t\t\t}\n\t\t\t\t\t$pagebuff = $this->getPageBuffer($this->page);\n\t\t\t\t\t$pstart = substr($pagebuff, 0, $pagemark);\n\t\t\t\t\t$pend = substr($pagebuff, $pagemark);\n\t\t\t\t\t$this->setPageBuffer($this->page, $pstart.$ccode.$pend);\n\t\t\t\t}\n\t\t\t}\n\t\t} // end for each page\n\t\t// restore page regions check\n\t\t$this->check_page_regions = $check_page_regions;\n\t\t// Get end-of-cell Y position\n\t\t$currentY = $this->GetY();\n\t\t// restore previous values\n\t\tif ($this->num_columns > 1) {\n\t\t\t$this->selectColumn();\n\t\t} else {\n\t\t\t// restore original margins\n\t\t\t$this->lMargin = $lMargin;\n\t\t\t$this->rMargin = $rMargin;\n\t\t\tif ($this->page > $startpage) {\n\t\t\t\t// check for margin variations between pages (i.e. booklet mode)\n\t\t\t\t$dl = ($this->pagedim[$this->page]['olm'] - $this->pagedim[$startpage]['olm']);\n\t\t\t\t$dr = ($this->pagedim[$this->page]['orm'] - $this->pagedim[$startpage]['orm']);\n\t\t\t\tif (($dl != 0) OR ($dr != 0)) {\n\t\t\t\t\t$this->lMargin += $dl;\n\t\t\t\t\t$this->rMargin += $dr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ($ln > 0) {\n\t\t\t//Go to the beginning of the next line\n\t\t\t$this->setY($currentY + $mc_margin['B']);\n\t\t\tif ($ln == 2) {\n\t\t\t\t$this->setX($x + $w + $mc_margin['L'] + $mc_margin['R']);\n\t\t\t}\n\t\t} else {\n\t\t\t// go left or right by case\n\t\t\t$this->setPage($startpage);\n\t\t\t$this->y = $y;\n\t\t\t$this->setX($x + $w + $mc_margin['L'] + $mc_margin['R']);\n\t\t}\n\t\t$this->setContentMark();\n\t\t$this->cell_padding = $prev_cell_padding;\n\t\t$this->cell_margin = $prev_cell_margin;\n\t\t$this->clMargin = $this->lMargin;\n\t\t$this->crMargin = $this->rMargin;\n\t\treturn $nl;\n\t}\n\n\t/**\n\t * This method return the estimated number of lines for print a simple text string using Multicell() method.\n\t * @param string $txt String for calculating his height\n\t * @param float $w Width of cells. If 0, they extend up to the right margin of the page.\n\t * @param boolean $reseth if true reset the last cell height (default false).\n\t * @param boolean $autopadding if true, uses internal padding and automatically adjust it to account for line width (default true).\n\t * @param array|null $cellpadding Internal cell padding, if empty uses default cell padding.\n\t * @param mixed $border Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))\n\t * @return float Return the minimal height needed for multicell method for printing the $txt param.\n\t * @author Alexander Escalona Fern\\E1ndez, Nicola Asuni\n\t * @public\n\t * @since 4.5.011\n\t */\n\tpublic function getNumLines($txt, $w=0, $reseth=false, $autopadding=true, $cellpadding=null, $border=0) {\n\t\tif ($txt === NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ($txt === '') {\n\t\t\t// empty string\n\t\t\treturn 1;\n\t\t}\n\t\t// adjust internal padding\n\t\t$prev_cell_padding = $this->cell_padding;\n\t\t$prev_lasth = $this->lasth;\n\t\tif (is_array($cellpadding)) {\n\t\t\t$this->cell_padding = $cellpadding;\n\t\t}\n\t\t$this->adjustCellPadding($border);\n\t\tif (TCPDF_STATIC::empty_string($w) OR ($w <= 0)) {\n\t\t\tif ($this->rtl) {\n\t\t\t\t$w = $this->x - $this->lMargin;\n\t\t\t} else {\n\t\t\t\t$w = $this->w - $this->rMargin - $this->x;\n\t\t\t}\n\t\t}\n\t\t$wmax = $w - $this->cell_padding['L'] - $this->cell_padding['R'];\n\t\tif ($reseth) {\n\t\t\t// reset row height\n\t\t\t$this->resetLastH();\n\t\t}\n\t\t$lines = 1;\n\t\t$sum = 0;\n\t\t$chars = TCPDF_FONTS::utf8Bidi(TCPDF_FONTS::UTF8StringToArray($txt, $this->isunicode, $this->CurrentFont), $txt, $this->tmprtl, $this->isunicode, $this->CurrentFont);\n\t\t$charsWidth = $this->GetArrStringWidth($chars, '', '', 0, true);\n\t\t$length = count($chars);\n\t\t$lastSeparator = -1;\n\t\tfor ($i = 0; $i < $length; ++$i) {\n\t\t\t$c = $chars[$i];\n\t\t\t$charWidth = $charsWidth[$i];\n\t\t\tif (($c != 160)\n\t\t\t\t\tAND (($c == 173)\n\t\t\t\t\t\tOR preg_match($this->re_spaces, TCPDF_FONTS::unichr($c, $this->isunicode))\n\t\t\t\t\t\tOR (($c == 45)\n\t\t\t\t\t\t\tAND ($i > 0) AND ($i < ($length - 1))\n\t\t\t\t\t\t\tAND @preg_match('/[\\p{L}]/'.$this->re_space['m'], TCPDF_FONTS::unichr($chars[($i - 1)], $this->isunicode))\n\t\t\t\t\t\t\tAND @preg_match('/[\\p{L}]/'.$this->re_space['m'], TCPDF_FONTS::unichr($chars[($i + 1)], $this->isunicode))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t$lastSeparator = $i;\n\t\t\t}\n\t\t\tif ((($sum + $charWidth) > $wmax) OR ($c == 10)) {\n\t\t\t\t++$lines;\n\t\t\t\tif ($c == 10) {\n\t\t\t\t\t$lastSeparator = -1;\n\t\t\t\t\t$sum = 0;\n\t\t\t\t} elseif ($lastSeparator != -1) {\n\t\t\t\t\t$i = $lastSeparator;\n\t\t\t\t\t$lastSeparator = -1;\n\t\t\t\t\t$sum = 0;\n\t\t\t\t} else {\n\t\t\t\t\t$sum = $charWidth;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$sum += $charWidth;\n\t\t\t}\n\t\t}\n\t\tif ($chars[($length - 1)] == 10) {\n\t\t\t--$lines;\n\t\t}\n\t\t$this->cell_padding = $prev_cell_padding;\n\t\t$this->lasth = $prev_lasth;\n\t\treturn $lines;\n\t}\n\n\t/**\n\t * This method return the estimated height needed for printing a simple text string using the Multicell() method.\n\t * Generally, if you want to know the exact height for a block of content you can use the following alternative technique:\n\t * @pre\n\t *  // store current object\n\t *  $pdf->startTransaction();\n\t *  // store starting values\n\t *  $start_y = $pdf->GetY();\n\t *  $start_page = $pdf->getPage();\n\t *  // call your printing functions with your parameters\n\t *  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\t *  $pdf->MultiCell($w=0, $h=0, $txt, $border=1, $align='L', $fill=false, $ln=1, $x=null, $y=null, $reseth=true, $stretch=0, $ishtml=false, $autopadding=true, $maxh=0);\n\t *  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\t *  // get the new Y\n\t *  $end_y = $pdf->GetY();\n\t *  $end_page = $pdf->getPage();\n\t *  // calculate height\n\t *  $height = 0;\n\t *  if ($end_page == $start_page) {\n\t *  \t$height = $end_y - $start_y;\n\t *  } else {\n\t *  \tfor ($page=$start_page; $page <= $end_page; ++$page) {\n\t *  \t\t$this->setPage($page);\n\t *  \t\tif ($page == $start_page) {\n\t *  \t\t\t// first page\n\t *  \t\t\t$height += $this->h - $start_y - $this->bMargin;\n\t *  \t\t} elseif ($page == $end_page) {\n\t *  \t\t\t// last page\n\t *  \t\t\t$height += $end_y - $this->tMargin;\n\t *  \t\t} else {\n\t *  \t\t\t$height += $this->h - $this->tMargin - $this->bMargin;\n\t *  \t\t}\n\t *  \t}\n\t *  }\n\t *  // restore previous object\n\t *  $pdf = $pdf->rollbackTransaction();\n\t *\n\t * @param float $w Width of cells. If 0, they extend up to the right margin of the page.\n\t * @param string $txt String for calculating his height\n\t * @param boolean $reseth if true reset the last cell height (default false).\n\t * @param boolean $autopadding if true, uses internal padding and automatically adjust it to account for line width (default true).\n\t * @param array|null $cellpadding Internal cell padding, if empty uses default cell padding.\n\t * @param mixed $border Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))\n\t * @return float Return the minimal height needed for multicell method for printing the $txt param.\n\t * @author Nicola Asuni, Alexander Escalona Fern\\E1ndez\n\t * @public\n\t */\n\tpublic function getStringHeight($w, $txt, $reseth=false, $autopadding=true, $cellpadding=null, $border=0) {\n\t\t// adjust internal padding\n\t\t$prev_cell_padding = $this->cell_padding;\n\t\t$prev_lasth = $this->lasth;\n\t\tif (is_array($cellpadding)) {\n\t\t\t$this->cell_padding = $cellpadding;\n\t\t}\n\t\t$this->adjustCellPadding($border);\n\t\t$lines = $this->getNumLines($txt, $w, $reseth, $autopadding, $cellpadding, $border);\n\t\t$height = $this->getCellHeight(($lines * $this->FontSize), $autopadding);\n\t\t$this->cell_padding = $prev_cell_padding;\n\t\t$this->lasth = $prev_lasth;\n\t\treturn $height;\n\t}\n\n\t/**\n\t * This method prints text from the current position.<br />\n\t * @param float $h Line height\n\t * @param string $txt String to print\n\t * @param mixed $link URL or identifier returned by AddLink()\n\t * @param boolean $fill Indicates if the cell background must be painted (true) or transparent (false).\n\t * @param string $align Allows to center or align the text. Possible values are:<ul><li>L or empty string: left align (default value)</li><li>C: center</li><li>R: right align</li><li>J: justify</li></ul>\n\t * @param boolean $ln if true set cursor at the bottom of the line, otherwise set cursor at the top of the line.\n\t * @param int $stretch font stretch mode: <ul><li>0 = disabled</li><li>1 = horizontal scaling only if text is larger than cell width</li><li>2 = forced horizontal scaling to fit cell width</li><li>3 = character spacing only if text is larger than cell width</li><li>4 = forced character spacing to fit cell width</li></ul> General font stretching and scaling values will be preserved when possible.\n\t * @param boolean $firstline if true prints only the first line and return the remaining string.\n\t * @param boolean $firstblock if true the string is the starting of a line.\n\t * @param float $maxh maximum height. It should be >= $h and less then remaining space to the bottom of the page, or 0 for disable this feature.\n\t * @param float $wadj first line width will be reduced by this amount (used in HTML mode).\n\t * @param array|null $margin margin array of the parent container\n\t * @return mixed Return the number of cells or the remaining string if $firstline = true.\n\t * @public\n\t * @since 1.5\n\t */\n\tpublic function Write($h, $txt, $link='', $fill=false, $align='', $ln=false, $stretch=0, $firstline=false, $firstblock=false, $maxh=0, $wadj=0, $margin=null) {\n\t\t// check page for no-write regions and adapt page margins if necessary\n\t\tlist($this->x, $this->y) = $this->checkPageRegions($h, $this->x, $this->y);\n\t\tif (strlen($txt) == 0) {\n\t\t\t// fix empty text\n\t\t\t$txt = ' ';\n\t\t}\n\t\tif (!is_array($margin)) {\n\t\t\t// set default margins\n\t\t\t$margin = $this->cell_margin;\n\t\t}\n\t\t// remove carriage returns\n\t\t$s = str_replace(\"\\r\", '', $txt);\n\t\t// check if string contains arabic text\n\t\tif (preg_match(TCPDF_FONT_DATA::$uni_RE_PATTERN_ARABIC, $s)) {\n\t\t\t$arabic = true;\n\t\t} else {\n\t\t\t$arabic = false;\n\t\t}\n\t\t// check if string contains RTL text\n\t\tif ($arabic OR ($this->tmprtl == 'R') OR preg_match(TCPDF_FONT_DATA::$uni_RE_PATTERN_RTL, $s)) {\n\t\t\t$rtlmode = true;\n\t\t} else {\n\t\t\t$rtlmode = false;\n\t\t}\n\t\t// get a char width\n\t\t$chrwidth = $this->GetCharWidth(46); // dot character\n\t\t// get array of unicode values\n\t\t$chars = TCPDF_FONTS::UTF8StringToArray($s, $this->isunicode, $this->CurrentFont);\n\t\t// calculate maximum width for a single character on string\n\t\t$chrw = $this->GetArrStringWidth($chars, '', '', 0, true);\n\t\tarray_walk($chrw, array($this, 'getRawCharWidth'));\n\t\t$maxchwidth = ((is_array($chrw) || $chrw instanceof Countable) && count($chrw) > 0) ? max($chrw) : 0;\n\t\t// get array of chars\n\t\t$uchars = TCPDF_FONTS::UTF8ArrayToUniArray($chars, $this->isunicode);\n\t\t// get the number of characters\n\t\t$nb = count($chars);\n\t\t// replacement for SHY character (minus symbol)\n\t\t$shy_replacement = 45;\n\t\t$shy_replacement_char = TCPDF_FONTS::unichr($shy_replacement, $this->isunicode);\n\t\t// widht for SHY replacement\n\t\t$shy_replacement_width = $this->GetCharWidth($shy_replacement);\n\t\t// page width\n\t\t$pw = $w = $this->w - $this->lMargin - $this->rMargin;\n\t\t// calculate remaining line width ($w)\n\t\tif ($this->rtl) {\n\t\t\t$w = $this->x - $this->lMargin;\n\t\t} else {\n\t\t\t$w = $this->w - $this->rMargin - $this->x;\n\t\t}\n\t\t// max column width\n\t\t$wmax = ($w - $wadj);\n\t\tif (!$firstline) {\n\t\t\t$wmax -= ($this->cell_padding['L'] + $this->cell_padding['R']);\n\t\t}\n\t\tif ((!$firstline) AND (($chrwidth > $wmax) OR ($maxchwidth > $wmax))) {\n\t\t\t// the maximum width character do not fit on column\n\t\t\treturn '';\n\t\t}\n\t\t// minimum row height\n\t\t$row_height = max($h, $this->getCellHeight($this->FontSize));\n\t\t// max Y\n\t\t$maxy = $this->y + $maxh - max($row_height, $h);\n\t\t$start_page = $this->page;\n\t\t$i = 0; // character position\n\t\t$j = 0; // current starting position\n\t\t$sep = -1; // position of the last blank space\n\t\t$prevsep = $sep; // previous separator\n\t\t$shy = false; // true if the last blank is a soft hypen (SHY)\n\t\t$prevshy = $shy; // previous shy mode\n\t\t$l = 0; // current string length\n\t\t$nl = 0; //number of lines\n\t\t$linebreak = false;\n\t\t$pc = 0; // previous character\n\t\t// for each character\n\t\twhile ($i < $nb) {\n\t\t\tif (($maxh > 0) AND ($this->y > $maxy) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//Get the current character\n\t\t\t$c = $chars[$i];\n\t\t\tif ($c == 10) { // 10 = \"\\n\" = new line\n\t\t\t\t//Explicit line break\n\t\t\t\tif ($align == 'J') {\n\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t$talign = 'R';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$talign = 'L';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$talign = $align;\n\t\t\t\t}\n\t\t\t\t$tmpstr = TCPDF_FONTS::UniArrSubString($uchars, $j, $i);\n\t\t\t\tif ($firstline) {\n\t\t\t\t\t$startx = $this->x;\n\t\t\t\t\t$tmparr = array_slice($chars, $j, ($i - $j));\n\t\t\t\t\tif ($rtlmode) {\n\t\t\t\t\t\t$tmparr = TCPDF_FONTS::utf8Bidi($tmparr, $tmpstr, $this->tmprtl, $this->isunicode, $this->CurrentFont);\n\t\t\t\t\t}\n\t\t\t\t\t$linew = $this->GetArrStringWidth($tmparr);\n\t\t\t\t\tunset($tmparr);\n\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t$this->endlinex = $startx - $linew;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->endlinex = $startx + $linew;\n\t\t\t\t\t}\n\t\t\t\t\t$w = $linew;\n\t\t\t\t\t$tmpcellpadding = $this->cell_padding;\n\t\t\t\t\tif ($maxh == 0) {\n\t\t\t\t\t\t$this->setCellPadding(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($firstblock AND $this->isRTLTextDir()) {\n\t\t\t\t\t$tmpstr = $this->stringRightTrim($tmpstr);\n\t\t\t\t}\n\t\t\t\t// Skip newlines at the beginning of a page or column\n\t\t\t\tif (!empty($tmpstr) OR ($this->y < ($this->PageBreakTrigger - $row_height))) {\n\t\t\t\t\t$this->Cell($w, $h, $tmpstr, 0, 1, $talign, $fill, $link, $stretch);\n\t\t\t\t}\n\t\t\t\tunset($tmpstr);\n\t\t\t\tif ($firstline) {\n\t\t\t\t\t$this->cell_padding = $tmpcellpadding;\n\t\t\t\t\treturn (TCPDF_FONTS::UniArrSubString($uchars, $i));\n\t\t\t\t}\n\t\t\t\t++$nl;\n\t\t\t\t$j = $i + 1;\n\t\t\t\t$l = 0;\n\t\t\t\t$sep = -1;\n\t\t\t\t$prevsep = $sep;\n\t\t\t\t$shy = false;\n\t\t\t\t// account for margin changes\n\t\t\t\tif ((($this->y + $this->lasth) > $this->PageBreakTrigger) AND ($this->inPageBody())) {\n\t\t\t\t\tif ($this->AcceptPageBreak())\n\t\t\t\t\t{\n\t\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t\t$this->x -= $margin['R'];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$this->x += $margin['L'];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$this->lMargin += $margin['L'];\n\t\t\t\t\t\t$this->rMargin += $margin['R'];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$w = $this->getRemainingWidth();\n\t\t\t\t$wmax = ($w - $this->cell_padding['L'] - $this->cell_padding['R']);\n\t\t\t} else {\n\t\t\t\t// 160 is the non-breaking space.\n\t\t\t\t// 173 is SHY (Soft Hypen).\n\t\t\t\t// \\p{Z} or \\p{Separator}: any kind of Unicode whitespace or invisible separator.\n\t\t\t\t// \\p{Lo} or \\p{Other_Letter}: a Unicode letter or ideograph that does not have lowercase and uppercase variants.\n\t\t\t\t// \\p{Lo} is needed because Chinese characters are packed next to each other without spaces in between.\n\t\t\t\tif (($c != 160)\n\t\t\t\t\tAND (($c == 173)\n\t\t\t\t\t\tOR preg_match($this->re_spaces, TCPDF_FONTS::unichr($c, $this->isunicode))\n\t\t\t\t\t\tOR (($c == 45)\n\t\t\t\t\t\t\tAND ($i < ($nb - 1))\n\t\t\t\t\t\t\tAND @preg_match('/[\\p{L}]/'.$this->re_space['m'], TCPDF_FONTS::unichr($pc, $this->isunicode))\n\t\t\t\t\t\t\tAND @preg_match('/[\\p{L}]/'.$this->re_space['m'], TCPDF_FONTS::unichr($chars[($i + 1)], $this->isunicode))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\t// update last blank space position\n\t\t\t\t\t$prevsep = $sep;\n\t\t\t\t\t$sep = $i;\n\t\t\t\t\t// check if is a SHY\n\t\t\t\t\tif (($c == 173) OR ($c == 45)) {\n\t\t\t\t\t\t$prevshy = $shy;\n\t\t\t\t\t\t$shy = true;\n\t\t\t\t\t\tif ($pc == 45) {\n\t\t\t\t\t\t\t$tmp_shy_replacement_width = 0;\n\t\t\t\t\t\t\t$tmp_shy_replacement_char = '';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$tmp_shy_replacement_width = $shy_replacement_width;\n\t\t\t\t\t\t\t$tmp_shy_replacement_char = $shy_replacement_char;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$shy = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// update string length\n\t\t\t\tif ($this->isUnicodeFont() AND ($arabic)) {\n\t\t\t\t\t// with bidirectional algorithm some chars may be changed affecting the line length\n\t\t\t\t\t// *** very slow ***\n\t\t\t\t\t$l = $this->GetArrStringWidth(TCPDF_FONTS::utf8Bidi(array_slice($chars, $j, ($i - $j)), '', $this->tmprtl, $this->isunicode, $this->CurrentFont));\n\t\t\t\t} else {\n\t\t\t\t\t$l += $this->GetCharWidth($c, ($i+1 < $nb));\n\t\t\t\t}\n\t\t\t\tif (($l > $wmax) OR (($c == 173) AND (($l + $tmp_shy_replacement_width) >= $wmax))) {\n\t\t\t\t\tif (($c == 173) AND (($l + $tmp_shy_replacement_width) > $wmax)) {\n\t\t\t\t\t\t$sep = $prevsep;\n\t\t\t\t\t\t$shy = $prevshy;\n\t\t\t\t\t}\n\t\t\t\t\t// we have reached the end of column\n\t\t\t\t\tif ($sep == -1) {\n\t\t\t\t\t\t// check if the line was already started\n\t\t\t\t\t\tif (($this->rtl AND ($this->x <= ($this->w - $this->rMargin - $this->cell_padding['R'] - $margin['R'] - $chrwidth)))\n\t\t\t\t\t\t\tOR ((!$this->rtl) AND ($this->x >= ($this->lMargin + $this->cell_padding['L'] + $margin['L'] + $chrwidth)))) {\n\t\t\t\t\t\t\t// print a void cell and go to next line\n\t\t\t\t\t\t\t$this->Cell($w, $h, '', 0, 1);\n\t\t\t\t\t\t\t$linebreak = true;\n\t\t\t\t\t\t\tif ($firstline) {\n\t\t\t\t\t\t\t\treturn (TCPDF_FONTS::UniArrSubString($uchars, $j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// truncate the word because do not fit on column\n\t\t\t\t\t\t\t$tmpstr = TCPDF_FONTS::UniArrSubString($uchars, $j, $i);\n\t\t\t\t\t\t\tif ($firstline) {\n\t\t\t\t\t\t\t\t$startx = $this->x;\n\t\t\t\t\t\t\t\t$tmparr = array_slice($chars, $j, ($i - $j));\n\t\t\t\t\t\t\t\tif ($rtlmode) {\n\t\t\t\t\t\t\t\t\t$tmparr = TCPDF_FONTS::utf8Bidi($tmparr, $tmpstr, $this->tmprtl, $this->isunicode, $this->CurrentFont);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$linew = $this->GetArrStringWidth($tmparr);\n\t\t\t\t\t\t\t\tunset($tmparr);\n\t\t\t\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t\t\t\t$this->endlinex = $startx - $linew;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$this->endlinex = $startx + $linew;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$w = $linew;\n\t\t\t\t\t\t\t\t$tmpcellpadding = $this->cell_padding;\n\t\t\t\t\t\t\t\tif ($maxh == 0) {\n\t\t\t\t\t\t\t\t\t$this->setCellPadding(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ($firstblock AND $this->isRTLTextDir()) {\n\t\t\t\t\t\t\t\t$tmpstr = $this->stringRightTrim($tmpstr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->Cell($w, $h, $tmpstr, 0, 1, $align, $fill, $link, $stretch);\n\t\t\t\t\t\t\tunset($tmpstr);\n\t\t\t\t\t\t\tif ($firstline) {\n\t\t\t\t\t\t\t\t$this->cell_padding = $tmpcellpadding;\n\t\t\t\t\t\t\t\treturn (TCPDF_FONTS::UniArrSubString($uchars, $i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$j = $i;\n\t\t\t\t\t\t\t--$i;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// word wrapping\n\t\t\t\t\t\tif ($this->rtl AND (!$firstblock) AND ($sep < $i)) {\n\t\t\t\t\t\t\t$endspace = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$endspace = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check the length of the next string\n\t\t\t\t\t\t$strrest = TCPDF_FONTS::UniArrSubString($uchars, ($sep + $endspace));\n\t\t\t\t\t\t$nextstr = TCPDF_STATIC::pregSplit('/'.$this->re_space['p'].'/', $this->re_space['m'], $this->stringTrim($strrest));\n\t\t\t\t\t\tif (isset($nextstr[0]) AND ($this->GetStringWidth($nextstr[0]) > $pw)) {\n\t\t\t\t\t\t\t// truncate the word because do not fit on a full page width\n\t\t\t\t\t\t\t$tmpstr = TCPDF_FONTS::UniArrSubString($uchars, $j, $i);\n\t\t\t\t\t\t\tif ($firstline) {\n\t\t\t\t\t\t\t\t$startx = $this->x;\n\t\t\t\t\t\t\t\t$tmparr = array_slice($chars, $j, ($i - $j));\n\t\t\t\t\t\t\t\tif ($rtlmode) {\n\t\t\t\t\t\t\t\t\t$tmparr = TCPDF_FONTS::utf8Bidi($tmparr, $tmpstr, $this->tmprtl, $this->isunicode, $this->CurrentFont);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$linew = $this->GetArrStringWidth($tmparr);\n\t\t\t\t\t\t\t\tunset($tmparr);\n\t\t\t\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t\t\t\t$this->endlinex = ($startx - $linew);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$this->endlinex = ($startx + $linew);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$w = $linew;\n\t\t\t\t\t\t\t\t$tmpcellpadding = $this->cell_padding;\n\t\t\t\t\t\t\t\tif ($maxh == 0) {\n\t\t\t\t\t\t\t\t\t$this->setCellPadding(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ($firstblock AND $this->isRTLTextDir()) {\n\t\t\t\t\t\t\t\t$tmpstr = $this->stringRightTrim($tmpstr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->Cell($w, $h, $tmpstr, 0, 1, $align, $fill, $link, $stretch);\n\t\t\t\t\t\t\tunset($tmpstr);\n\t\t\t\t\t\t\tif ($firstline) {\n\t\t\t\t\t\t\t\t$this->cell_padding = $tmpcellpadding;\n\t\t\t\t\t\t\t\treturn (TCPDF_FONTS::UniArrSubString($uchars, $i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$j = $i;\n\t\t\t\t\t\t\t--$i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// word wrapping\n\t\t\t\t\t\t\tif ($shy) {\n\t\t\t\t\t\t\t\t// add hypen (minus symbol) at the end of the line\n\t\t\t\t\t\t\t\t$shy_width = $tmp_shy_replacement_width;\n\t\t\t\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t\t\t\t$shy_char_left = $tmp_shy_replacement_char;\n\t\t\t\t\t\t\t\t\t$shy_char_right = '';\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$shy_char_left = '';\n\t\t\t\t\t\t\t\t\t$shy_char_right = $tmp_shy_replacement_char;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$shy_width = 0;\n\t\t\t\t\t\t\t\t$shy_char_left = '';\n\t\t\t\t\t\t\t\t$shy_char_right = '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$tmpstr = TCPDF_FONTS::UniArrSubString($uchars, $j, ($sep + $endspace));\n\t\t\t\t\t\t\tif ($firstline) {\n\t\t\t\t\t\t\t\t$startx = $this->x;\n\t\t\t\t\t\t\t\t$tmparr = array_slice($chars, $j, (($sep + $endspace) - $j));\n\t\t\t\t\t\t\t\tif ($rtlmode) {\n\t\t\t\t\t\t\t\t\t$tmparr = TCPDF_FONTS::utf8Bidi($tmparr, $tmpstr, $this->tmprtl, $this->isunicode, $this->CurrentFont);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$linew = $this->GetArrStringWidth($tmparr);\n\t\t\t\t\t\t\t\tunset($tmparr);\n\t\t\t\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t\t\t\t$this->endlinex = $startx - $linew - $shy_width;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$this->endlinex = $startx + $linew + $shy_width;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$w = $linew;\n\t\t\t\t\t\t\t\t$tmpcellpadding = $this->cell_padding;\n\t\t\t\t\t\t\t\tif ($maxh == 0) {\n\t\t\t\t\t\t\t\t\t$this->setCellPadding(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// print the line\n\t\t\t\t\t\t\tif ($firstblock AND $this->isRTLTextDir()) {\n\t\t\t\t\t\t\t\t$tmpstr = $this->stringRightTrim($tmpstr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->Cell($w, $h, $shy_char_left.$tmpstr.$shy_char_right, 0, 1, $align, $fill, $link, $stretch);\n\t\t\t\t\t\t\tunset($tmpstr);\n\t\t\t\t\t\t\tif ($firstline) {\n\t\t\t\t\t\t\t\tif ($chars[$sep] == 45) {\n\t\t\t\t\t\t\t\t\t$endspace += 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// return the remaining text\n\t\t\t\t\t\t\t\t$this->cell_padding = $tmpcellpadding;\n\t\t\t\t\t\t\t\treturn (TCPDF_FONTS::UniArrSubString($uchars, ($sep + $endspace)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$i = $sep;\n\t\t\t\t\t\t\t$sep = -1;\n\t\t\t\t\t\t\t$shy = false;\n\t\t\t\t\t\t\t$j = ($i + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// account for margin changes\n\t\t\t\t\tif ((($this->y + $this->lasth) > $this->PageBreakTrigger) AND ($this->inPageBody())) {\n\t\t\t\t\t\tif ($this->AcceptPageBreak())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t\t\t$this->x -= $margin['R'];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$this->x += $margin['L'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->lMargin += $margin['L'];\n\t\t\t\t\t\t\t$this->rMargin += $margin['R'];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$w = $this->getRemainingWidth();\n\t\t\t\t\t$wmax = $w - $this->cell_padding['L'] - $this->cell_padding['R'];\n\t\t\t\t\tif ($linebreak) {\n\t\t\t\t\t\t$linebreak = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++$nl;\n\t\t\t\t\t\t$l = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// save last character\n\t\t\t$pc = $c;\n\t\t\t++$i;\n\t\t} // end while i < nb\n\t\t// print last substring (if any)\n\t\tif ($l > 0) {\n\t\t\tswitch ($align) {\n\t\t\t\tcase 'J':\n\t\t\t\tcase 'C': {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'L': {\n\t\t\t\t\tif (!$this->rtl) {\n\t\t\t\t\t\t$w = $l;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'R': {\n\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t$w = $l;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\t$w = $l;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$tmpstr = TCPDF_FONTS::UniArrSubString($uchars, $j, $nb);\n\t\t\tif ($firstline) {\n\t\t\t\t$startx = $this->x;\n\t\t\t\t$tmparr = array_slice($chars, $j, ($nb - $j));\n\t\t\t\tif ($rtlmode) {\n\t\t\t\t\t$tmparr = TCPDF_FONTS::utf8Bidi($tmparr, $tmpstr, $this->tmprtl, $this->isunicode, $this->CurrentFont);\n\t\t\t\t}\n\t\t\t\t$linew = $this->GetArrStringWidth($tmparr);\n\t\t\t\tunset($tmparr);\n\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t$this->endlinex = $startx - $linew;\n\t\t\t\t} else {\n\t\t\t\t\t$this->endlinex = $startx + $linew;\n\t\t\t\t}\n\t\t\t\t$w = $linew;\n\t\t\t\t$tmpcellpadding = $this->cell_padding;\n\t\t\t\tif ($maxh == 0) {\n\t\t\t\t\t$this->setCellPadding(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($firstblock AND $this->isRTLTextDir()) {\n\t\t\t\t$tmpstr = $this->stringRightTrim($tmpstr);\n\t\t\t}\n\t\t\t$this->Cell($w, $h, $tmpstr, 0, $ln, $align, $fill, $link, $stretch);\n\t\t\tunset($tmpstr);\n\t\t\tif ($firstline) {\n\t\t\t\t$this->cell_padding = $tmpcellpadding;\n\t\t\t\treturn (TCPDF_FONTS::UniArrSubString($uchars, $nb));\n\t\t\t}\n\t\t\t++$nl;\n\t\t}\n\t\tif ($firstline) {\n\t\t\treturn '';\n\t\t}\n\t\treturn $nl;\n\t}\n\n\t/**\n\t * Returns the remaining width between the current position and margins.\n\t * @return float Return the remaining width\n\t * @protected\n\t */\n\tprotected function getRemainingWidth() {\n\t\tlist($this->x, $this->y) = $this->checkPageRegions(0, $this->x, $this->y);\n\t\tif ($this->rtl) {\n\t\t\treturn ($this->x - $this->lMargin);\n\t\t} else {\n\t\t\treturn ($this->w - $this->rMargin - $this->x);\n\t\t}\n\t}\n\n\t/**\n\t * Set the block dimensions accounting for page breaks and page/column fitting\n\t * @param float $w width\n\t * @param float $h height\n\t * @param float $x X coordinate\n\t * @param float $y Y coodiante\n\t * @param boolean $fitonpage if true the block is resized to not exceed page dimensions.\n\t * @return array array($w, $h, $x, $y)\n\t * @protected\n\t * @since 5.5.009 (2010-07-05)\n\t */\n\tprotected function fitBlock($w, $h, $x, $y, $fitonpage=false) {\n\t\tif ($w <= 0) {\n\t\t\t// set maximum width\n\t\t\t$w = ($this->w - $this->lMargin - $this->rMargin);\n\t\t\tif ($w <= 0) {\n\t\t\t\t$w = 1;\n\t\t\t}\n\t\t}\n\t\tif ($h <= 0) {\n\t\t\t// set maximum height\n\t\t\t$h = ($this->PageBreakTrigger - $this->tMargin);\n\t\t\tif ($h <= 0) {\n\t\t\t\t$h = 1;\n\t\t\t}\n\t\t}\n\t\t// resize the block to be vertically contained on a single page or single column\n\t\tif ($fitonpage OR $this->AutoPageBreak) {\n\t\t\t$ratio_wh = ($w / $h);\n\t\t\tif ($h > ($this->PageBreakTrigger - $this->tMargin)) {\n\t\t\t\t$h = $this->PageBreakTrigger - $this->tMargin;\n\t\t\t\t$w = ($h * $ratio_wh);\n\t\t\t}\n\t\t\t// resize the block to be horizontally contained on a single page or single column\n\t\t\tif ($fitonpage) {\n\t\t\t\t$maxw = ($this->w - $this->lMargin - $this->rMargin);\n\t\t\t\tif ($w > $maxw) {\n\t\t\t\t\t$w = $maxw;\n\t\t\t\t\t$h = ($w / $ratio_wh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check whether we need a new page or new column first as this does not fit\n\t\t$prev_x = $this->x;\n\t\t$prev_y = $this->y;\n\t\tif ($this->checkPageBreak($h, $y) OR ($this->y < $prev_y)) {\n\t\t\t$y = $this->y;\n\t\t\tif ($this->rtl) {\n\t\t\t\t$x += ($prev_x - $this->x);\n\t\t\t} else {\n\t\t\t\t$x += ($this->x - $prev_x);\n\t\t\t}\n\t\t\t$this->newline = true;\n\t\t}\n\t\t// resize the block to be contained on the remaining available page or column space\n\t\tif ($fitonpage) {\n\t\t\t// fallback to avoid division by zero\n\t\t\t$h = $h == 0 ? 1 : $h;\n\t\t\t$ratio_wh = ($w / $h);\n\t\t\tif (($y + $h) > $this->PageBreakTrigger) {\n\t\t\t\t$h = $this->PageBreakTrigger - $y;\n\t\t\t\t$w = ($h * $ratio_wh);\n\t\t\t}\n\t\t\tif ((!$this->rtl) AND (($x + $w) > ($this->w - $this->rMargin))) {\n\t\t\t\t$w = $this->w - $this->rMargin - $x;\n\t\t\t\t$h = ($w / $ratio_wh);\n\t\t\t} elseif (($this->rtl) AND (($x - $w) < ($this->lMargin))) {\n\t\t\t\t$w = $x - $this->lMargin;\n\t\t\t\t$h = ($w / $ratio_wh);\n\t\t\t}\n\t\t}\n\t\treturn array($w, $h, $x, $y);\n\t}\n\n\t/**\n\t * Puts an image in the page.\n\t * The upper-left corner must be given.\n\t * The dimensions can be specified in different ways:<ul>\n\t * <li>explicit width and height (expressed in user unit)</li>\n\t * <li>one explicit dimension, the other being calculated automatically in order to keep the original proportions</li>\n\t * <li>no explicit dimension, in which case the image is put at 72 dpi</li></ul>\n\t * Supported formats are JPEG and PNG images whitout GD library and all images supported by GD: GD, GD2, GD2PART, GIF, JPEG, PNG, BMP, XBM, XPM;\n\t * The format can be specified explicitly or inferred from the file extension.<br />\n\t * It is possible to put a link on the image.<br />\n\t * Remark: if an image is used several times, only one copy will be embedded in the file.<br />\n\t * @param string $file Name of the file containing the image or a '@' character followed by the image data string. To link an image without embedding it on the document, set an asterisk character before the URL (i.e.: '*http://www.example.com/image.jpg').\n\t * @param float|null $x Abscissa of the upper-left corner (LTR) or upper-right corner (RTL).\n\t * @param float|null $y Ordinate of the upper-left corner (LTR) or upper-right corner (RTL).\n\t * @param float $w Width of the image in the page. If not specified or equal to zero, it is automatically calculated.\n\t * @param float $h Height of the image in the page. If not specified or equal to zero, it is automatically calculated.\n\t * @param string $type Image format. Possible values are (case insensitive): JPEG and PNG (whitout GD library) and all images supported by GD: GD, GD2, GD2PART, GIF, JPEG, PNG, BMP, XBM, XPM;. If not specified, the type is inferred from the file extension.\n\t * @param mixed $link URL or identifier returned by AddLink().\n\t * @param string $align Indicates the alignment of the pointer next to image insertion relative to image height. The value can be:<ul><li>T: top-right for LTR or top-left for RTL</li><li>M: middle-right for LTR or middle-left for RTL</li><li>B: bottom-right for LTR or bottom-left for RTL</li><li>N: next line</li></ul>\n\t * @param mixed $resize If true resize (reduce) the image to fit $w and $h (requires GD or ImageMagick library); if false do not resize; if 2 force resize in all cases (upscaling and downscaling).\n\t * @param int $dpi dot-per-inch resolution used on resize\n\t * @param string $palign Allows to center or align the image on the current line. Possible values are:<ul><li>L : left align</li><li>C : center</li><li>R : right align</li><li>'' : empty string : left for LTR or right for RTL</li></ul>\n\t * @param boolean $ismask true if this image is a mask, false otherwise\n\t * @param mixed $imgmask image object returned by this function or false\n\t * @param mixed $border Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))\n\t * @param mixed $fitbox If not false scale image dimensions proportionally to fit within the ($w, $h) box. $fitbox can be true or a 2 characters string indicating the image alignment inside the box. The first character indicate the horizontal alignment (L = left, C = center, R = right) the second character indicate the vertical algnment (T = top, M = middle, B = bottom).\n\t * @param boolean $hidden If true do not display the image.\n\t * @param boolean $fitonpage If true the image is resized to not exceed page dimensions.\n\t * @param boolean $alt If true the image will be added as alternative and not directly printed (the ID of the image will be returned).\n\t * @param array $altimgs Array of alternate images IDs. Each alternative image must be an array with two values: an integer representing the image ID (the value returned by the Image method) and a boolean value to indicate if the image is the default for printing.\n\t * @return mixed|false image information\n\t * @public\n\t * @since 1.1\n\t */\n\tpublic function Image($file, $x=null, $y=null, $w=0, $h=0, $type='', $link='', $align='', $resize=false, $dpi=300, $palign='', $ismask=false, $imgmask=false, $border=0, $fitbox=false, $hidden=false, $fitonpage=false, $alt=false, $altimgs=array()) {\n\t\tif ($this->state != 2) {\n\t\t\treturn false;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($x)) {\n\t\t\t$x = $this->x;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($y)) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\t// check page for no-write regions and adapt page margins if necessary\n\t\tlist($x, $y) = $this->checkPageRegions($h, $x, $y);\n\t\t$exurl = ''; // external streams\n\t\t$imsize = FALSE;\n\n        // Make sure the file variable is not empty or null because accessing $file[0] later\n        // results in error when running PHP 7.4\n        if (empty($file)) {\n            return false;\n        }\n\t\t// check if we are passing an image as file or string\n\t\tif ($file[0] === '@') {\n\t\t\t// image from string\n\t\t\t$imgdata = substr($file, 1);\n\t\t} else { // image file\n\t\t\tif ($file[0] === '*') {\n\t\t\t\t// image as external stream\n\t\t\t\t$file = substr($file, 1);\n\t\t\t\t$exurl = $file;\n\t\t\t}\n\t\t\t// check if file exist and it is valid\n\t\t\tif (!@$this->fileExists($file)) {\n\t\t\t\treturn false;\n\t\t\t}\n            if (false !== $info = $this->getImageBuffer($file)) {\n                $imsize = array($info['w'], $info['h']);\n            } elseif (($imsize = @getimagesize($file)) === FALSE && strpos($file, '__tcpdf_'.$this->file_id.'_img') === FALSE){\n                $imgdata = $this->getCachedFileContents($file);\n            }\n\t\t}\n\t\tif (!empty($imgdata)) {\n\t\t\t// copy image to cache\n\t\t\t$original_file = $file;\n\t\t\t$file = TCPDF_STATIC::getObjFilename('img', $this->file_id);\n\t\t\t$fp = TCPDF_STATIC::fopenLocal($file, 'w');\n\t\t\tif (!$fp) {\n\t\t\t\t$this->Error('Unable to write file: '.$file);\n\t\t\t}\n\t\t\tfwrite($fp, $imgdata);\n\t\t\tfclose($fp);\n\t\t\tunset($imgdata);\n\t\t\t$imsize = @getimagesize($file);\n\t\t\tif ($imsize === FALSE) {\n\t\t\t\tunlink($file);\n\t\t\t\t$file = $original_file;\n\t\t\t}\n\t\t}\n\t\tif ($imsize === FALSE) {\n\t\t\tif (($w > 0) AND ($h > 0)) {\n\t\t\t\t// get measures from specified data\n\t\t\t\t$pw = $this->getHTMLUnitToUnits($w, 0, $this->pdfunit, true) * $this->imgscale * $this->k;\n\t\t\t\t$ph = $this->getHTMLUnitToUnits($h, 0, $this->pdfunit, true) * $this->imgscale * $this->k;\n\t\t\t\t$imsize = array($pw, $ph);\n\t\t\t} else {\n\t\t\t\t$this->Error('[Image] Unable to get the size of the image: '.$file);\n\t\t\t}\n\t\t}\n\t\t// file hash\n\t\t$filehash = md5($file);\n\t\t// get original image width and height in pixels\n\t\tlist($pixw, $pixh) = $imsize;\n\t\t// calculate image width and height on document\n\t\tif (($w <= 0) AND ($h <= 0)) {\n\t\t\t// convert image size to document unit\n\t\t\t$w = $this->pixelsToUnits($pixw);\n\t\t\t$h = $this->pixelsToUnits($pixh);\n\t\t} elseif ($w <= 0) {\n\t\t\t$w = $h * $pixw / $pixh;\n\t\t} elseif ($h <= 0) {\n\t\t\t$h = $w * $pixh / $pixw;\n\t\t} elseif (($fitbox !== false) AND ($w > 0) AND ($h > 0)) {\n\t\t\tif (strlen($fitbox) !== 2) {\n\t\t\t\t// set default alignment\n\t\t\t\t$fitbox = '--';\n\t\t\t}\n\t\t\t// scale image dimensions proportionally to fit within the ($w, $h) box\n\t\t\tif ((($w * $pixh) / ($h * $pixw)) < 1) {\n\t\t\t\t// store current height\n\t\t\t\t$oldh = $h;\n\t\t\t\t// calculate new height\n\t\t\t\t$h = $w * $pixh / $pixw;\n\t\t\t\t// height difference\n\t\t\t\t$hdiff = ($oldh - $h);\n\t\t\t\t// vertical alignment\n\t\t\t\tswitch (strtoupper($fitbox[1])) {\n\t\t\t\t\tcase 'T': {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'M': {\n\t\t\t\t\t\t$y += ($hdiff / 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'B': {\n\t\t\t\t\t\t$y += $hdiff;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// store current width\n\t\t\t\t$oldw = $w;\n\t\t\t\t// calculate new width\n\t\t\t\t$w = $h * $pixw / $pixh;\n\t\t\t\t// width difference\n\t\t\t\t$wdiff = ($oldw - $w);\n\t\t\t\t// horizontal alignment\n\t\t\t\tswitch (strtoupper($fitbox[0])) {\n\t\t\t\t\tcase 'L': {\n\t\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t\t$x -= $wdiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'C': {\n\t\t\t\t\t\tif ($this->rtl) {\n\t\t\t\t\t\t\t$x -= ($wdiff / 2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$x += ($wdiff / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'R': {\n\t\t\t\t\t\tif (!$this->rtl) {\n\t\t\t\t\t\t\t$x += $wdiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// fit the image on available space\n\t\tlist($w, $h, $x, $y) = $this->fitBlock($w, $h, $x, $y, $fitonpage);\n\t\t// calculate new minimum dimensions in pixels\n\t\t$neww = round($w * $this->k * $dpi / $this->dpi);\n\t\t$newh = round($h * $this->k * $dpi / $this->dpi);\n\t\t// check if resize is necessary (resize is used only to reduce the image)\n\t\t$newsize = ($neww * $newh);\n\t\t$pixsize = ($pixw * $pixh);\n\t\tif (intval($resize) == 2) {\n\t\t\t$resize = true;\n\t\t} elseif ($newsize >= $pixsize) {\n\t\t\t$resize = false;\n\t\t}\n\t\t// check if image has been already added on document\n\t\t$newimage = true;\n\t\tif (in_array($file, $this->imagekeys)) {\n\t\t\t$newimage = false;\n\t\t\t// get existing image data\n\t\t\t$info = $this->getImageBuffer($file);\n\t\t\tif (strpos($file, '__tcpdf_'.$this->file_id.'_imgmask_') === FALSE) {\n\t\t\t\t// check if the newer image is larger\n\t\t\t\t$oldsize = ($info['w'] * $info['h']);\n\t\t\t\tif ((($oldsize < $newsize) AND ($resize)) OR (($oldsize < $pixsize) AND (!$resize))) {\n\t\t\t\t\t$newimage = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} elseif (($ismask === false) AND ($imgmask === false) AND (strpos($file, '__tcpdf_'.$this->file_id.'_imgmask_') === FALSE)) {\n\t\t\t// create temp image file (without alpha channel)\n\t\t\t$tempfile_plain = K_PATH_CACHE.'__tcpdf_'.$this->file_id.'_imgmask_plain_'.$filehash;\n\t\t\t// create temp alpha file\n\t\t\t$tempfile_alpha = K_PATH_CACHE.'__tcpdf_'.$this->file_id.'_imgmask_alpha_'.$filehash;\n\t\t\t// check for cached images\n\t\t\tif (in_array($tempfile_plain, $this->imagekeys)) {\n\t\t\t\t// get existing image data\n\t\t\t\t$info = $this->getImageBuffer($tempfile_plain);\n\t\t\t\t// check if the newer image is larger\n\t\t\t\t$oldsize = ($info['w'] * $info['h']);\n\t\t\t\tif ((($oldsize < $newsize) AND ($resize)) OR (($oldsize < $pixsize) AND (!$resize))) {\n\t\t\t\t\t$newimage = true;\n\t\t\t\t} else {\n\t\t\t\t\t$newimage = false;\n\t\t\t\t\t// embed mask image\n\t\t\t\t\t$imgmask = $this->Image($tempfile_alpha, $x, $y, $w, $h, 'PNG', '', '', $resize, $dpi, '', true, false);\n\t\t\t\t\t// embed image, masked with previously embedded mask\n\t\t\t\t\treturn $this->Image($tempfile_plain, $x, $y, $w, $h, $type, $link, $align, $resize, $dpi, $palign, false, $imgmask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ($newimage) {\n\t\t\t//First use of image, get info\n\t\t\t$type = strtolower($type);\n\t\t\tif ($type == '') {\n\t\t\t\t$type = TCPDF_IMAGES::getImageFileType($file, $imsize);\n\t\t\t} elseif ($type == 'jpg') {\n\t\t\t\t$type = 'jpeg';\n\t\t\t}\n\t\t\t// Specific image handlers (defined on TCPDF_IMAGES CLASS)\n\t\t\t$mtd = '_parse'.$type;\n\t\t\t// GD image handler function\n\t\t\t$gdfunction = 'imagecreatefrom'.$type;\n\t\t\t$info = false;\n\t\t\tif ((method_exists('TCPDF_IMAGES', $mtd)) AND (!($resize AND (function_exists($gdfunction) OR extension_loaded('imagick'))))) {\n\t\t\t\t// TCPDF image functions\n\t\t\t\t$info = TCPDF_IMAGES::$mtd($file);\n\t\t\t\tif (($ismask === false) AND ($imgmask === false) AND (strpos($file, '__tcpdf_'.$this->file_id.'_imgmask_') === FALSE)\n\t\t\t\t\tAND (($info === 'pngalpha') OR (isset($info['trns']) AND !empty($info['trns'])))) {\n\t\t\t\t\treturn $this->ImagePngAlpha($file, $x, $y, $pixw, $pixh, $w, $h, 'PNG', $link, $align, $resize, $dpi, $palign, $filehash);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (($info === false) AND function_exists($gdfunction)) {\n\t\t\t\ttry {\n\t\t\t\t\t// GD library\n\t\t\t\t\t$img = $gdfunction($file);\n\t\t\t\t\tif ($img !== false) {\n\t\t\t\t\t\tif ($resize) {\n\t\t\t\t\t\t\t$imgr = imagecreatetruecolor($neww, $newh);\n\t\t\t\t\t\t\tif (($type == 'gif') OR ($type == 'png')) {\n\t\t\t\t\t\t\t\t$imgr = TCPDF_IMAGES::setGDImageTransparency($imgr, $img);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\timagecopyresampled($imgr, $img, 0, 0, 0, 0, $neww, $newh, $pixw, $pixh);\n\t\t\t\t\t\t\t$img = $imgr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (($type == 'gif') OR ($type == 'png')) {\n\t\t\t\t\t\t\t$info = TCPDF_IMAGES::_toPNG($img, TCPDF_STATIC::getObjFilename('img', $this->file_id));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$info = TCPDF_IMAGES::_toJPEG($img, $this->jpeg_quality, TCPDF_STATIC::getObjFilename('img', $this->file_id));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch(Exception $e) {\n\t\t\t\t\t$info = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (($info === false) AND extension_loaded('imagick')) {\n\t\t\t\ttry {\n\t\t\t\t\t// ImageMagick library\n\t\t\t\t\t$img = new Imagick();\n\t\t\t\t\tif ($type == 'svg') {\n\t\t\t\t\t\tif ($file[0] === '@') {\n\t\t\t\t\t\t\t// image from string\n\t\t\t\t\t\t\t$svgimg = substr($file, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// get SVG file content\n                            $svgimg = $this->getCachedFileContents($file);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($svgimg !== FALSE) {\n\t\t\t\t\t\t\t// get width and height\n\t\t\t\t\t\t\t$regs = array();\n\t\t\t\t\t\t\tif (preg_match('/<svg([^\\>]*)>/si', $svgimg, $regs)) {\n\t\t\t\t\t\t\t\t$svgtag = $regs[1];\n\t\t\t\t\t\t\t\t$tmp = array();\n\t\t\t\t\t\t\t\tif (preg_match('/[\\s]+width[\\s]*=[\\s]*\"([^\"]*)\"/si', $svgtag, $tmp)) {\n\t\t\t\t\t\t\t\t\t$ow = $this->getHTMLUnitToUnits($tmp[1], 1, $this->svgunit, false);\n\t\t\t\t\t\t\t\t\t$owu = sprintf('%F', ($ow * $dpi / 72)).$this->pdfunit;\n\t\t\t\t\t\t\t\t\t$svgtag = preg_replace('/[\\s]+width[\\s]*=[\\s]*\"[^\"]*\"/si', ' width=\"'.$owu.'\"', $svgtag, 1);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$ow = $w;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$tmp = array();\n\t\t\t\t\t\t\t\tif (preg_match('/[\\s]+height[\\s]*=[\\s]*\"([^\"]*)\"/si', $svgtag, $tmp)) {\n\t\t\t\t\t\t\t\t\t$oh = $this->getHTMLUnitToUnits($tmp[1], 1, $this->svgunit, false);\n\t\t\t\t\t\t\t\t\t$ohu = sprintf('%F', ($oh * $dpi / 72)).$this->pdfunit;\n\t\t\t\t\t\t\t\t\t$svgtag = preg_replace('/[\\s]+height[\\s]*=[\\s]*\"[^\"]*\"/si', ' height=\"'.$ohu.'\"', $svgtag, 1);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$oh = $h;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$tmp = array();\n\t\t\t\t\t\t\t\tif (!preg_match('/[\\s]+viewBox[\\s]*=[\\s]*\"[\\s]*([0-9\\.]+)[\\s]+([0-9\\.]+)[\\s]+([0-9\\.]+)[\\s]+([0-9\\.]+)[\\s]*\"/si', $svgtag, $tmp)) {\n\t\t\t\t\t\t\t\t\t$vbw = ($ow * $this->imgscale * $this->k);\n\t\t\t\t\t\t\t\t\t$vbh = ($oh * $this->imgscale * $this->k);\n\t\t\t\t\t\t\t\t\t$vbox = sprintf(' viewBox=\"0 0 %F %F\" ', $vbw, $vbh);\n\t\t\t\t\t\t\t\t\t$svgtag = $vbox.$svgtag;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$svgimg = preg_replace('/<svg([^\\>]*)>/si', '<svg'.$svgtag.'>', $svgimg, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$img->readImageBlob($svgimg);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$img->readImage($file);\n\t\t\t\t\t}\n\t\t\t\t\tif ($resize) {\n\t\t\t\t\t\t$img->resizeImage($neww, $newh, 10, 1, false);\n\t\t\t\t\t}\n\t\t\t\t\t$img->setCompressionQuality($this->jpeg_quality);\n\t\t\t\t\t$img->setImageFormat('jpeg');\n\t\t\t\t\t$tempname = TCPDF_STATIC::getObjFilename('img', $this->file_id);\n\t\t\t\t\t$img->writeImage($tempname);\n\t\t\t\t\t$info = TCPDF_IMAGES::_parsejpeg($tempname);\n\t\t\t\t\tunlink($tempname);\n\t\t\t\t\t$img->destroy();\n\t\t\t\t} catch(Exception $e) {\n\t\t\t\t\t$info = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($info === false) {\n\t\t\t\t// unable to process image\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($ismask) {\n\t\t\t\t// force grayscale\n\t\t\t\t$info['cs'] = 'DeviceGray';\n\t\t\t}\n\t\t\tif ($imgmask !== false) {\n\t\t\t\t$info['masked'] = $imgmask;\n\t\t\t}\n\t\t\tif (!empty($exurl)) {\n\t\t\t\t$info['exurl'] = $exurl;\n\t\t\t}\n\t\t\t// array of alternative images\n\t\t\t$info['altimgs'] = $altimgs;\n\t\t\t// add image to document\n\t\t\t$info['i'] = $this->setImageBuffer($file, $info);\n\t\t}\n\t\t// set alignment\n\t\t$this->img_rb_x = $x + $w;\n\t\t$this->img_rb_y = $y + $h;\n\n\t\t// set alignment\n\t\tif ($palign == 'L') {\n\t\t\t$ximg = $this->lMargin;\n\t\t} elseif ($palign == 'C') {\n\t\t\t$ximg = ($this->w + $this->lMargin - $this->rMargin - $w) / 2;\n\t\t} elseif ($palign == 'R') {\n\t\t\t$ximg = $this->w - $this->rMargin - $w;\n\t\t} else {\n\t\t\t$ximg = $this->rtl ? $x - $w : $x;\n\t\t}\n\n\t\tif ($ismask OR $hidden) {\n\t\t\t// image is not displayed\n\t\t\treturn $info['i'];\n\t\t}\n\t\t$xkimg = $ximg * $this->k;\n\t\tif (!$alt) {\n\t\t\t// only non-alternative immages will be set\n\t\t\t$this->_out(sprintf('q %F 0 0 %F %F %F cm /I%u Do Q', ($w * $this->k), ($h * $this->k), $xkimg, (($this->h - ($y + $h)) * $this->k), $info['i']));\n\t\t}\n\t\tif (!empty($border)) {\n\t\t\t$bx = $this->x;\n\t\t\t$by = $this->y;\n\t\t\t$this->x = $ximg;\n\t\t\tif ($this->rtl) {\n\t\t\t\t$this->x += $w;\n\t\t\t}\n\t\t\t$this->y = $y;\n\t\t\t$this->Cell($w, $h, '', $border, 0, '', 0, '', 0, true);\n\t\t\t$this->x = $bx;\n\t\t\t$this->y = $by;\n\t\t}\n\t\tif ($link) {\n\t\t\t$this->Link($ximg, $y, $w, $h, $link, 0);\n\t\t}\n\t\t// set pointer to align the next text/objects\n\t\tswitch($align) {\n\t\t\tcase 'T': {\n\t\t\t\t$this->y = $y;\n\t\t\t\t$this->x = $this->img_rb_x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'M': {\n\t\t\t\t$this->y = $y + round($h/2);\n\t\t\t\t$this->x = $this->img_rb_x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'B': {\n\t\t\t\t$this->y = $this->img_rb_y;\n\t\t\t\t$this->x = $this->img_rb_x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'N': {\n\t\t\t\t$this->setY($this->img_rb_y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$this->endlinex = $this->img_rb_x;\n\t\tif ($this->inxobj) {\n\t\t\t// we are inside an XObject template\n\t\t\t$this->xobjects[$this->xobjid]['images'][] = $info['i'];\n\t\t}\n\t\treturn $info['i'];\n\t}\n\n\t/**\n\t * Extract info from a PNG image with alpha channel using the Imagick or GD library.\n\t * @param string $file Name of the file containing the image.\n\t * @param float $x Abscissa of the upper-left corner.\n\t * @param float $y Ordinate of the upper-left corner.\n\t * @param float $wpx Original width of the image in pixels.\n\t * @param float $hpx original height of the image in pixels.\n\t * @param float $w Width of the image in the page. If not specified or equal to zero, it is automatically calculated.\n\t * @param float $h Height of the image in the page. If not specified or equal to zero, it is automatically calculated.\n\t * @param string $type Image format. Possible values are (case insensitive): JPEG and PNG (whitout GD library) and all images supported by GD: GD, GD2, GD2PART, GIF, JPEG, PNG, BMP, XBM, XPM;. If not specified, the type is inferred from the file extension.\n\t * @param mixed $link URL or identifier returned by AddLink().\n\t * @param string $align Indicates the alignment of the pointer next to image insertion relative to image height. The value can be:<ul><li>T: top-right for LTR or top-left for RTL</li><li>M: middle-right for LTR or middle-left for RTL</li><li>B: bottom-right for LTR or bottom-left for RTL</li><li>N: next line</li></ul>\n\t * @param boolean $resize If true resize (reduce) the image to fit $w and $h (requires GD library).\n\t * @param int $dpi dot-per-inch resolution used on resize\n\t * @param string $palign Allows to center or align the image on the current line. Possible values are:<ul><li>L : left align</li><li>C : center</li><li>R : right align</li><li>'' : empty string : left for LTR or right for RTL</li></ul>\n\t * @param string $filehash File hash used to build unique file names.\n\t * @author Nicola Asuni\n\t * @protected\n\t * @since 4.3.007 (2008-12-04)\n\t * @see Image()\n\t */\n\tprotected function ImagePngAlpha($file, $x, $y, $wpx, $hpx, $w, $h, $type, $link, $align, $resize, $dpi, $palign, $filehash='') {\n\t\t// create temp images\n\t\tif (empty($filehash)) {\n\t\t\t$filehash = md5($file);\n\t\t}\n\t\t// create temp image file (without alpha channel)\n\t\t$tempfile_plain = K_PATH_CACHE.'__tcpdf_'.$this->file_id.'_imgmask_plain_'.$filehash;\n\t\t// create temp alpha file\n\t\t$tempfile_alpha = K_PATH_CACHE.'__tcpdf_'.$this->file_id.'_imgmask_alpha_'.$filehash;\n\t\t$parsed = false;\n\t\t$parse_error = '';\n\t\t// ImageMagick extension\n\t\tif (($parsed === false) AND extension_loaded('imagick')) {\n\t\t\ttry {\n\t\t\t\t// ImageMagick library\n\t\t\t\t$img = new Imagick();\n\t\t\t\t$img->readImage($file);\n\t\t\t\t// clone image object\n\t\t\t\t$imga = TCPDF_STATIC::objclone($img);\n\t\t\t\t// extract alpha channel\n\t\t\t\tif (method_exists($img, 'setImageAlphaChannel') AND defined('Imagick::ALPHACHANNEL_EXTRACT')) {\n\t\t\t\t\t$img->setImageAlphaChannel(Imagick::ALPHACHANNEL_EXTRACT);\n\t\t\t\t} else {\n\t\t\t\t\t$img->separateImageChannel(8); // 8 = (imagick::CHANNEL_ALPHA | imagick::CHANNEL_OPACITY | imagick::CHANNEL_MATTE);\n\t\t\t\t\t$img->negateImage(true);\n\t\t\t\t}\n\t\t\t\t$img->setImageFormat('png');\n\t\t\t\t$img->writeImage($tempfile_alpha);\n\t\t\t\t// remove alpha channel\n\t\t\t\tif (method_exists($imga, 'setImageMatte')) {\n\t\t\t\t\t$imga->setImageMatte(false);\n\t\t\t\t} else {\n\t\t\t\t\t$imga->separateImageChannel(39); // 39 = (imagick::CHANNEL_ALL & ~(imagick::CHANNEL_ALPHA | imagick::CHANNEL_OPACITY | imagick::CHANNEL_MATTE));\n\t\t\t\t}\n\t\t\t\t$imga->setImageFormat('png');\n\t\t\t\t$imga->writeImage($tempfile_plain);\n\t\t\t\t$parsed = true;\n\t\t\t} catch (Exception $e) {\n\t\t\t\t// Imagemagick fails, try with GD\n\t\t\t\t$parse_error = 'Imagick library error: '.$e->getMessage();\n\t\t\t}\n\t\t}\n\t\t// GD extension\n\t\tif (($parsed === false) AND function_exists('imagecreatefrompng')) {\n\t\t\ttry {\n\t\t\t\t// generate images\n\t\t\t\t$img = imagecreatefrompng($file);\n\t\t\t\t$imgalpha = imagecreate($wpx, $hpx);\n\t\t\t\t// generate gray scale palette (0 -> 255)\n\t\t\t\tfor ($c = 0; $c < 256; ++$c) {\n\t\t\t\t\tImageColorAllocate($imgalpha, $c, $c, $c);\n\t\t\t\t}\n\t\t\t\t// extract alpha channel\n\t\t\t\tfor ($xpx = 0; $xpx < $wpx; ++$xpx) {\n\t\t\t\t\tfor ($ypx = 0; $ypx < $hpx; ++$ypx) {\n\t\t\t\t\t\t$color = imagecolorat($img, $xpx, $ypx);\n\t\t\t\t\t\t// get and correct gamma color\n\t\t\t\t\t\t$alpha = $this->getGDgamma($img, $color);\n\t\t\t\t\t\timagesetpixel($imgalpha, (int) $xpx, (int) $ypx, (int) $alpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\timagepng($imgalpha, $tempfile_alpha);\n\t\t\t\timagedestroy($imgalpha);\n\t\t\t\t// extract image without alpha channel\n\t\t\t\t$imgplain = imagecreatetruecolor($wpx, $hpx);\n\t\t\t\timagecopy($imgplain, $img, 0, 0, 0, 0, $wpx, $hpx);\n\t\t\t\timagepng($imgplain, $tempfile_plain);\n\t\t\t\timagedestroy($imgplain);\n\t\t\t\t$parsed = true;\n\t\t\t} catch (Exception $e) {\n\t\t\t\t// GD fails\n\t\t\t\t$parse_error = 'GD library error: '.$e->getMessage();\n\t\t\t}\n\t\t}\n\t\tif ($parsed === false) {\n\t\t\tif (empty($parse_error)) {\n\t\t\t\t$this->Error('TCPDF requires the Imagick or GD extension to handle PNG images with alpha channel.');\n\t\t\t} else {\n\t\t\t\t$this->Error($parse_error);\n\t\t\t}\n\t\t}\n\t\t// embed mask image\n\t\t$imgmask = $this->Image($tempfile_alpha, $x, $y, $w, $h, 'PNG', '', '', $resize, $dpi, '', true, false);\n\t\t// embed image, masked with previously embedded mask\n\t\t$this->Image($tempfile_plain, $x, $y, $w, $h, $type, $link, $align, $resize, $dpi, $palign, false, $imgmask);\n\t}\n\n\t/**\n\t * Get the GD-corrected PNG gamma value from alpha color\n\t * @param resource $img GD image Resource ID.\n\t * @param int $c alpha color\n\t * @protected\n\t * @since 4.3.007 (2008-12-04)\n\t */\n\tprotected function getGDgamma($img, $c) {\n\t\tif (!isset($this->gdgammacache['#'.$c])) {\n\t\t\t$colors = imagecolorsforindex($img, $c);\n\t\t\t// GD alpha is only 7 bit (0 -> 127)\n\t\t\t$this->gdgammacache['#'.$c] = (int) (((127 - $colors['alpha']) / 127) * 255);\n\t\t\t// correct gamma\n\t\t\t$this->gdgammacache['#'.$c] = (int) (pow(($this->gdgammacache['#'.$c] / 255), 2.2) * 255);\n\t\t\t// store the latest values on cache to improve performances\n\t\t\tif (count($this->gdgammacache) > 8) {\n\t\t\t\t// remove one element from the cache array\n\t\t\t\tarray_shift($this->gdgammacache);\n\t\t\t}\n\t\t}\n\t\treturn $this->gdgammacache['#'.$c];\n\t}\n\n\t/**\n\t * Performs a line break.\n\t * The current abscissa goes back to the left margin and the ordinate increases by the amount passed in parameter.\n\t * @param float|null $h The height of the break. By default, the value equals the height of the last printed cell.\n\t * @param boolean $cell if true add the current left (or right o for RTL) padding to the X coordinate\n\t * @public\n\t * @since 1.0\n\t * @see Cell()\n\t */\n\tpublic function Ln($h=null, $cell=false) {\n\t\tif (($this->num_columns > 1) AND ($this->y == $this->columns[$this->current_column]['y']) AND isset($this->columns[$this->current_column]['x']) AND ($this->x == $this->columns[$this->current_column]['x'])) {\n\t\t\t// revove vertical space from the top of the column\n\t\t\treturn;\n\t\t}\n\t\tif ($cell) {\n\t\t\tif ($this->rtl) {\n\t\t\t\t$cellpadding = $this->cell_padding['R'];\n\t\t\t} else {\n\t\t\t\t$cellpadding = $this->cell_padding['L'];\n\t\t\t}\n\t\t} else {\n\t\t\t$cellpadding = 0;\n\t\t}\n\t\tif ($this->rtl) {\n\t\t\t$this->x = $this->w - $this->rMargin - $cellpadding;\n\t\t} else {\n\t\t\t$this->x = $this->lMargin + $cellpadding;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($h)) {\n\t\t\t$h = $this->lasth;\n\t\t}\n\t\t$this->y += $h;\n\t\t$this->newline = true;\n\t}\n\n\t/**\n\t * Returns the relative X value of current position.\n\t * The value is relative to the left border for LTR languages and to the right border for RTL languages.\n\t * @return float\n\t * @public\n\t * @since 1.2\n\t * @see SetX(), GetY(), SetY()\n\t */\n\tpublic function GetX() {\n\t\t//Get x position\n\t\tif ($this->rtl) {\n\t\t\treturn ($this->w - $this->x);\n\t\t} else {\n\t\t\treturn $this->x;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the absolute X value of current position.\n\t * @return float\n\t * @public\n\t * @since 1.2\n\t * @see SetX(), GetY(), SetY()\n\t */\n\tpublic function GetAbsX() {\n\t\treturn $this->x;\n\t}\n\n\t/**\n\t * Returns the ordinate of the current position.\n\t * @return float\n\t * @public\n\t * @since 1.0\n\t * @see SetY(), GetX(), SetX()\n\t */\n\tpublic function GetY() {\n\t\treturn $this->y;\n\t}\n\n\t/**\n\t * Defines the abscissa of the current position.\n\t * If the passed value is negative, it is relative to the right of the page (or left if language is RTL).\n\t * @param float $x The value of the abscissa in user units.\n\t * @param boolean $rtloff if true always uses the page top-left corner as origin of axis.\n\t * @public\n\t * @since 1.2\n\t * @see GetX(), GetY(), SetY(), SetXY()\n\t */\n\tpublic function setX($x, $rtloff=false) {\n\t\t$x = floatval($x);\n\t\tif (!$rtloff AND $this->rtl) {\n\t\t\tif ($x >= 0) {\n\t\t\t\t$this->x = $this->w - $x;\n\t\t\t} else {\n\t\t\t\t$this->x = abs($x);\n\t\t\t}\n\t\t} else {\n\t\t\tif ($x >= 0) {\n\t\t\t\t$this->x = $x;\n\t\t\t} else {\n\t\t\t\t$this->x = $this->w + $x;\n\t\t\t}\n\t\t}\n\t\tif ($this->x < 0) {\n\t\t\t$this->x = 0;\n\t\t}\n\t\tif ($this->x > $this->w) {\n\t\t\t$this->x = $this->w;\n\t\t}\n\t}\n\n\t/**\n\t * Moves the current abscissa back to the left margin and sets the ordinate.\n\t * If the passed value is negative, it is relative to the bottom of the page.\n\t * @param float $y The value of the ordinate in user units.\n\t * @param bool $resetx if true (default) reset the X position.\n\t * @param boolean $rtloff if true always uses the page top-left corner as origin of axis.\n\t * @public\n\t * @since 1.0\n\t * @see GetX(), GetY(), SetY(), SetXY()\n\t */\n\tpublic function setY($y, $resetx=true, $rtloff=false) {\n\t\t$y = floatval($y);\n\t\tif ($resetx) {\n\t\t\t//reset x\n\t\t\tif (!$rtloff AND $this->rtl) {\n\t\t\t\t$this->x = $this->w - $this->rMargin;\n\t\t\t} else {\n\t\t\t\t$this->x = $this->lMargin;\n\t\t\t}\n\t\t}\n\t\tif ($y >= 0) {\n\t\t\t$this->y = $y;\n\t\t} else {\n\t\t\t$this->y = $this->h + $y;\n\t\t}\n\t\tif ($this->y < 0) {\n\t\t\t$this->y = 0;\n\t\t}\n\t\tif ($this->y > $this->h) {\n\t\t\t$this->y = $this->h;\n\t\t}\n\t}\n\n\t/**\n\t * Defines the abscissa and ordinate of the current position.\n\t * If the passed values are negative, they are relative respectively to the right and bottom of the page.\n\t * @param float $x The value of the abscissa.\n\t * @param float $y The value of the ordinate.\n\t * @param boolean $rtloff if true always uses the page top-left corner as origin of axis.\n\t * @public\n\t * @since 1.2\n\t * @see SetX(), SetY()\n\t */\n\tpublic function setXY($x, $y, $rtloff=false) {\n\t\t$this->setY($y, false, $rtloff);\n\t\t$this->setX($x, $rtloff);\n\t}\n\n\t/**\n\t * Set the absolute X coordinate of the current pointer.\n\t * @param float $x The value of the abscissa in user units.\n\t * @public\n\t * @since 5.9.186 (2012-09-13)\n\t * @see setAbsX(), setAbsY(), SetAbsXY()\n\t */\n\tpublic function setAbsX($x) {\n\t\t$this->x = floatval($x);\n\t}\n\n\t/**\n\t * Set the absolute Y coordinate of the current pointer.\n\t * @param float $y (float) The value of the ordinate in user units.\n\t * @public\n\t * @since 5.9.186 (2012-09-13)\n\t * @see setAbsX(), setAbsY(), SetAbsXY()\n\t */\n\tpublic function setAbsY($y) {\n\t\t$this->y = floatval($y);\n\t}\n\n\t/**\n\t * Set the absolute X and Y coordinates of the current pointer.\n\t * @param float $x The value of the abscissa in user units.\n\t * @param float $y (float) The value of the ordinate in user units.\n\t * @public\n\t * @since 5.9.186 (2012-09-13)\n\t * @see setAbsX(), setAbsY(), SetAbsXY()\n\t */\n\tpublic function setAbsXY($x, $y) {\n\t\t$this->setAbsX($x);\n\t\t$this->setAbsY($y);\n\t}\n\n\t/**\n\t * Send the document to a given destination: string, local file or browser.\n\t * In the last case, the plug-in may be used (if present) or a download (\"Save as\" dialog box) may be forced.<br />\n\t * The method first calls Close() if necessary to terminate the document.\n\t * @param string $name The name of the file when saved\n\t * @param string $dest Destination where to send the document. It can take one of the following values:<ul><li>I: send the file inline to the browser (default). The plug-in is used if available. The name given by name is used when one selects the \"Save as\" option on the link generating the PDF.</li><li>D: send to the browser and force a file download with the name given by name.</li><li>F: save to a local server file with the name given by name.</li><li>S: return the document as a string (name is ignored).</li><li>FI: equivalent to F + I option</li><li>FD: equivalent to F + D option</li><li>E: return the document as base64 mime multi-part email attachment (RFC 2045)</li></ul>\n\t * @return string\n\t * @public\n\t * @since 1.0\n\t * @see Close()\n\t */\n\tpublic function Output($name='doc.pdf', $dest='I') {\n\t\t//Output PDF to some destination\n\t\t//Finish document if necessary\n\t\tif ($this->state < 3) {\n\t\t\t$this->Close();\n\t\t}\n\t\t//Normalize parameters\n\t\tif (is_bool($dest)) {\n\t\t\t$dest = $dest ? 'D' : 'F';\n\t\t}\n\t\t$dest = strtoupper($dest);\n\n\t\tif ($this->sign) {\n\t\t\t// *** apply digital signature to the document ***\n\t\t\t// get the document content\n\t\t\t$pdfdoc = $this->getBuffer();\n\t\t\t// remove last newline\n\t\t\t$pdfdoc = substr($pdfdoc, 0, -1);\n\t\t\t// remove filler space\n\t\t\t$byterange_string_len = strlen(TCPDF_STATIC::$byterange_string);\n\t\t\t// define the ByteRange\n\t\t\t$byte_range = array();\n\t\t\t$byte_range[0] = 0;\n\t\t\t$byte_range[1] = strpos($pdfdoc, TCPDF_STATIC::$byterange_string) + $byterange_string_len + 10;\n\t\t\t$byte_range[2] = $byte_range[1] + $this->signature_max_length + 2;\n\t\t\t$byte_range[3] = strlen($pdfdoc) - $byte_range[2];\n\t\t\t$pdfdoc = substr($pdfdoc, 0, $byte_range[1]).substr($pdfdoc, $byte_range[2]);\n\t\t\t// replace the ByteRange\n\t\t\t$byterange = sprintf('/ByteRange[0 %u %u %u]', $byte_range[1], $byte_range[2], $byte_range[3]);\n\t\t\t$byterange .= str_repeat(' ', ($byterange_string_len - strlen($byterange)));\n\t\t\t$pdfdoc = str_replace(TCPDF_STATIC::$byterange_string, $byterange, $pdfdoc);\n\t\t\t// write the document to a temporary folder\n\t\t\t$tempdoc = TCPDF_STATIC::getObjFilename('doc', $this->file_id);\n\t\t\t$f = TCPDF_STATIC::fopenLocal($tempdoc, 'wb');\n\t\t\tif (!$f) {\n\t\t\t\t$this->Error('Unable to create temporary file: '.$tempdoc);\n\t\t\t}\n\t\t\t$pdfdoc_length = strlen($pdfdoc);\n\t\t\tfwrite($f, $pdfdoc, $pdfdoc_length);\n\t\t\tfclose($f);\n\t\t\t// get digital signature via openssl library\n\t\t\t$tempsign = TCPDF_STATIC::getObjFilename('sig', $this->file_id);\n\t\t\tif (empty($this->signature_data['extracerts'])) {\n\t\t\t\topenssl_pkcs7_sign($tempdoc, $tempsign, $this->signature_data['signcert'], array($this->signature_data['privkey'], $this->signature_data['password']), array(), PKCS7_BINARY | PKCS7_DETACHED);\n\t\t\t} else {\n\t\t\t\topenssl_pkcs7_sign($tempdoc, $tempsign, $this->signature_data['signcert'], array($this->signature_data['privkey'], $this->signature_data['password']), array(), PKCS7_BINARY | PKCS7_DETACHED, $this->signature_data['extracerts']);\n\t\t\t}\n\t\t\t// read signature\n\t\t\t$signature = file_get_contents($tempsign);\n\t\t\t// extract signature\n\t\t\t$signature = substr($signature, $pdfdoc_length);\n\t\t\t$signature = substr($signature, (strpos($signature, \"%%EOF\\n\\n------\") + 13));\n\t\t\t$tmparr = explode(\"\\n\\n\", $signature);\n\t\t\t$signature = $tmparr[1];\n\t\t\t// decode signature\n\t\t\t$signature = base64_decode(trim($signature));\n\t\t\t// add TSA timestamp to signature\n\t\t\t$signature = $this->applyTSA($signature);\n\t\t\t// convert signature to hex\n\t\t\t$signature = current(unpack('H*', $signature));\n\t\t\t$signature = str_pad($signature, $this->signature_max_length, '0');\n\t\t\t// Add signature to the document\n\t\t\t$this->buffer = substr($pdfdoc, 0, $byte_range[1]).'<'.$signature.'>'.substr($pdfdoc, $byte_range[1]);\n\t\t\t$this->bufferlen = strlen($this->buffer);\n\t\t}\n\t\tswitch($dest) {\n\t\t\tcase 'I': {\n\t\t\t\t// Send PDF to the standard output\n\t\t\t\tif (ob_get_contents()) {\n\t\t\t\t\t$this->Error('Some data has already been output, can\\'t send PDF file');\n\t\t\t\t}\n\t\t\t\tif (php_sapi_name() != 'cli') {\n\t\t\t\t\t// send output to a browser\n\t\t\t\t\theader('Content-Type: application/pdf');\n\t\t\t\t\tif (headers_sent()) {\n\t\t\t\t\t\t$this->Error('Some data has already been output to browser, can\\'t send PDF file');\n\t\t\t\t\t}\n\t\t\t\t\theader('Cache-Control: private, must-revalidate, post-check=0, pre-check=0, max-age=1');\n\t\t\t\t\t//header('Cache-Control: public, must-revalidate, max-age=0'); // HTTP/1.1\n\t\t\t\t\theader('Pragma: public');\n\t\t\t\t\theader('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past\n\t\t\t\t\theader('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');\n\t\t\t\t\theader('Content-Disposition: inline; filename=\"' . rawurlencode(basename($name)) . '\"; ' .\n\t\t\t\t\t\t'filename*=UTF-8\\'\\'' . rawurlencode(basename($name)));\n\t\t\t\t\tTCPDF_STATIC::sendOutputData($this->getBuffer(), $this->bufferlen);\n\t\t\t\t} else {\n\t\t\t\t\techo $this->getBuffer();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D': {\n\t\t\t\t// download PDF as file\n\t\t\t\tif (ob_get_contents()) {\n\t\t\t\t\t$this->Error('Some data has already been output, can\\'t send PDF file');\n\t\t\t\t}\n\t\t\t\theader('Content-Description: File Transfer');\n\t\t\t\tif (headers_sent()) {\n\t\t\t\t\t$this->Error('Some data has already been output to browser, can\\'t send PDF file');\n\t\t\t\t}\n\t\t\t\theader('Cache-Control: private, must-revalidate, post-check=0, pre-check=0, max-age=1');\n\t\t\t\t//header('Cache-Control: public, must-revalidate, max-age=0'); // HTTP/1.1\n\t\t\t\theader('Pragma: public');\n\t\t\t\theader('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past\n\t\t\t\theader('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');\n\t\t\t\t// force download dialog\n\t\t\t\tif (strpos(php_sapi_name(), 'cgi') === false) {\n\t\t\t\t\theader('Content-Type: application/force-download');\n\t\t\t\t\theader('Content-Type: application/octet-stream', false);\n\t\t\t\t\theader('Content-Type: application/download', false);\n\t\t\t\t\theader('Content-Type: application/pdf', false);\n\t\t\t\t} else {\n\t\t\t\t\theader('Content-Type: application/pdf');\n\t\t\t\t}\n\t\t\t\t// use the Content-Disposition header to supply a recommended filename\n\t\t\t\theader('Content-Disposition: attachment; filename=\"' . rawurlencode(basename($name)) . '\"; ' .\n\t\t\t\t\t'filename*=UTF-8\\'\\'' . rawurlencode(basename($name)));\n\t\t\t\theader('Content-Transfer-Encoding: binary');\n\t\t\t\tTCPDF_STATIC::sendOutputData($this->getBuffer(), $this->bufferlen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'F':\n\t\t\tcase 'FI':\n\t\t\tcase 'FD': {\n\t\t\t\t// save PDF to a local file\n\t\t\t\t$f = TCPDF_STATIC::fopenLocal($name, 'wb');\n\t\t\t\tif (!$f) {\n\t\t\t\t\t$this->Error('Unable to create output file: '.$name);\n\t\t\t\t}\n\t\t\t\tfwrite($f, $this->getBuffer(), $this->bufferlen);\n\t\t\t\tfclose($f);\n\t\t\t\tif ($dest == 'FI') {\n\t\t\t\t\t// send headers to browser\n\t\t\t\t\theader('Content-Type: application/pdf');\n\t\t\t\t\theader('Cache-Control: private, must-revalidate, post-check=0, pre-check=0, max-age=1');\n\t\t\t\t\t//header('Cache-Control: public, must-revalidate, max-age=0'); // HTTP/1.1\n\t\t\t\t\theader('Pragma: public');\n\t\t\t\t\theader('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past\n\t\t\t\t\theader('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');\n\t\t\t\t\theader('Content-Disposition: inline; filename=\"'.basename($name).'\"');\n\t\t\t\t\tTCPDF_STATIC::sendOutputData(file_get_contents($name), filesize($name));\n\t\t\t\t} elseif ($dest == 'FD') {\n\t\t\t\t\t// send headers to browser\n\t\t\t\t\tif (ob_get_contents()) {\n\t\t\t\t\t\t$this->Error('Some data has already been output, can\\'t send PDF file');\n\t\t\t\t\t}\n\t\t\t\t\theader('Content-Description: File Transfer');\n\t\t\t\t\tif (headers_sent()) {\n\t\t\t\t\t\t$this->Error('Some data has already been output to browser, can\\'t send PDF file');\n\t\t\t\t\t}\n\t\t\t\t\theader('Cache-Control: private, must-revalidate, post-check=0, pre-check=0, max-age=1');\n\t\t\t\t\theader('Pragma: public');\n\t\t\t\t\theader('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past\n\t\t\t\t\theader('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');\n\t\t\t\t\t// force download dialog\n\t\t\t\t\tif (strpos(php_sapi_name(), 'cgi') === false) {\n\t\t\t\t\t\theader('Content-Type: application/force-download');\n\t\t\t\t\t\theader('Content-Type: application/octet-stream', false);\n\t\t\t\t\t\theader('Content-Type: application/download', false);\n\t\t\t\t\t\theader('Content-Type: application/pdf', false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\theader('Content-Type: application/pdf');\n\t\t\t\t\t}\n\t\t\t\t\t// use the Content-Disposition header to supply a recommended filename\n\t\t\t\t\theader('Content-Disposition: attachment; filename=\"'.basename($name).'\"');\n\t\t\t\t\theader('Content-Transfer-Encoding: binary');\n\t\t\t\t\tTCPDF_STATIC::sendOutputData(file_get_contents($name), filesize($name));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'E': {\n\t\t\t\t// return PDF as base64 mime multi-part email attachment (RFC 2045)\n\t\t\t\t$retval = 'Content-Type: application/pdf;'.\"\\r\\n\";\n\t\t\t\t$retval .= ' name=\"'.$name.'\"'.\"\\r\\n\";\n\t\t\t\t$retval .= 'Content-Transfer-Encoding: base64'.\"\\r\\n\";\n\t\t\t\t$retval .= 'Content-Disposition: attachment;'.\"\\r\\n\";\n\t\t\t\t$retval .= ' filename=\"'.$name.'\"'.\"\\r\\n\\r\\n\";\n\t\t\t\t$retval .= chunk_split(base64_encode($this->getBuffer()), 76, \"\\r\\n\");\n\t\t\t\treturn $retval;\n\t\t\t}\n\t\t\tcase 'S': {\n\t\t\t\t// returns PDF as a string\n\t\t\t\treturn $this->getBuffer();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t$this->Error('Incorrect output destination: '.$dest);\n\t\t\t}\n\t\t}\n\t\treturn '';\n\t}\n\n\tprotected static $cleaned_ids = array();\n\t/**\n\t * Unset all class variables except the following critical variables.\n\t * @param boolean $destroyall if true destroys all class variables, otherwise preserves critical variables.\n\t * @param boolean $preserve_objcopy if true preserves the objcopy variable\n\t * @public\n\t * @since 4.5.016 (2009-02-24)\n\t */\n\tpublic function _destroy($destroyall=false, $preserve_objcopy=false) {\n\t\tif (isset(self::$cleaned_ids[$this->file_id])) {\n\t\t\t$destroyall = false;\n\t\t}\n\t\tif ($destroyall AND !$preserve_objcopy && isset($this->file_id)) {\n\t\t\tself::$cleaned_ids[$this->file_id] = true;\n\t\t\t// remove all temporary files\n\t\t\tif ($handle = @opendir(K_PATH_CACHE)) {\n\t\t\t\twhile ( false !== ( $file_name = readdir( $handle ) ) ) {\n\t\t\t\t\tif (strpos($file_name, '__tcpdf_'.$this->file_id.'_') === 0) {\n\t\t\t\t\t\tunlink(K_PATH_CACHE.$file_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclosedir($handle);\n\t\t\t}\n\t\t\tif (isset($this->imagekeys)) {\n\t\t\t\tforeach($this->imagekeys as $file) {\n\t\t\t\t\tif (strpos($file, K_PATH_CACHE) === 0 && TCPDF_STATIC::file_exists($file)) {\n\t\t\t\t\t\t@unlink($file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$preserve = array(\n\t\t\t'file_id',\n\t\t\t'state',\n\t\t\t'bufferlen',\n\t\t\t'buffer',\n\t\t\t'cached_files',\n\t\t\t'imagekeys',\n\t\t\t'sign',\n\t\t\t'signature_data',\n\t\t\t'signature_max_length',\n\t\t\t'byterange_string',\n\t\t\t'tsa_timestamp',\n\t\t\t'tsa_data'\n\t\t);\n\t\tforeach (array_keys(get_object_vars($this)) as $val) {\n\t\t\tif ($destroyall OR !in_array($val, $preserve)) {\n\t\t\t\tif ((!$preserve_objcopy OR ($val != 'objcopy')) AND ($val != 'file_id') AND isset($this->$val)) {\n\t\t\t\t\tunset($this->$val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check for locale-related bug\n\t * @protected\n\t */\n\tprotected function _dochecks() {\n\t\t//Check for locale-related bug\n\t\tif (1.1 == 1) {\n\t\t\t$this->Error('Don\\'t alter the locale before including class file');\n\t\t}\n\t\t//Check for decimal separator\n\t\tif (sprintf('%.1F', 1.0) != '1.0') {\n\t\t\tsetlocale(LC_NUMERIC, 'C');\n\t\t}\n\t}\n\n\t/**\n\t * Return an array containing variations for the basic page number alias.\n\t * @param string $a Base alias.\n\t * @return array of page number aliases\n\t * @protected\n\t */\n\tprotected function getInternalPageNumberAliases($a= '') {\n\t\t$alias = array();\n\t\t// build array of Unicode + ASCII variants (the order is important)\n\t\t$alias = array('u' => array(), 'a' => array());\n\t\t$u = '{'.$a.'}';\n\t\t$alias['u'][] = TCPDF_STATIC::_escape($u);\n\t\tif ($this->isunicode) {\n\t\t\t$alias['u'][] = TCPDF_STATIC::_escape(TCPDF_FONTS::UTF8ToLatin1($u, $this->isunicode, $this->CurrentFont));\n\t\t\t$alias['u'][] = TCPDF_STATIC::_escape(TCPDF_FONTS::utf8StrRev($u, false, $this->tmprtl, $this->isunicode, $this->CurrentFont));\n\t\t\t$alias['a'][] = TCPDF_STATIC::_escape(TCPDF_FONTS::UTF8ToLatin1($a, $this->isunicode, $this->CurrentFont));\n\t\t\t$alias['a'][] = TCPDF_STATIC::_escape(TCPDF_FONTS::utf8StrRev($a, false, $this->tmprtl, $this->isunicode, $this->CurrentFont));\n\t\t}\n\t\t$alias['a'][] = TCPDF_STATIC::_escape($a);\n\t\treturn $alias;\n\t}\n\n\t/**\n\t * Return an array containing all internal page aliases.\n\t * @return array of page number aliases\n\t * @protected\n\t */\n\tprotected function getAllInternalPageNumberAliases() {\n\t\t$basic_alias = array(TCPDF_STATIC::$alias_tot_pages, TCPDF_STATIC::$alias_num_page, TCPDF_STATIC::$alias_group_tot_pages, TCPDF_STATIC::$alias_group_num_page, TCPDF_STATIC::$alias_right_shift);\n\t\t$pnalias = array();\n\t\tforeach($basic_alias as $k => $a) {\n\t\t\t$pnalias[$k] = $this->getInternalPageNumberAliases($a);\n\t\t}\n\t\treturn $pnalias;\n\t}\n\n\t/**\n\t * Replace right shift page number aliases with spaces to correct right alignment.\n\t * This works perfectly only when using monospaced fonts.\n\t * @param string $page Page content.\n\t * @param array $aliases Array of page aliases.\n\t * @param int $diff initial difference to add.\n\t * @return string replaced page content.\n\t * @protected\n\t */\n\tprotected function replaceRightShiftPageNumAliases($page, $aliases, $diff) {\n\t\tforeach ($aliases as $type => $alias) {\n\t\t\tforeach ($alias as $a) {\n\t\t\t\t// find position of compensation factor\n\t\t\t\t$startnum = (strpos($a, ':') + 1);\n\t\t\t\t$a = substr($a, 0, $startnum);\n\t\t\t\tif (($pos = strpos($page, $a)) !== false) {\n\t\t\t\t\t// end of alias\n\t\t\t\t\t$endnum = strpos($page, '}', $pos);\n\t\t\t\t\t// string to be replaced\n\t\t\t\t\t$aa = substr($page, $pos, ($endnum - $pos + 1));\n\t\t\t\t\t// get compensation factor\n\t\t\t\t\t$ratio = substr($page, ($pos + $startnum), ($endnum - $pos - $startnum));\n\t\t\t\t\t$ratio = preg_replace('/[^0-9\\.]/', '', $ratio);\n\t\t\t\t\t$ratio = floatval($ratio);\n\t\t\t\t\tif ($type == 'u') {\n\t\t\t\t\t\t$chrdiff = floor(($diff + 12) * $ratio);\n\t\t\t\t\t\t$shift = str_repeat(' ', $chrdiff);\n\t\t\t\t\t\t$shift = TCPDF_FONTS::UTF8ToUTF16BE($shift, false, $this->isunicode, $this->CurrentFont);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$chrdiff = floor(($diff + 11) * $ratio);\n\t\t\t\t\t\t$shift = str_repeat(' ', $chrdiff);\n\t\t\t\t\t}\n\t\t\t\t\t$page = str_replace($aa, $shift, $page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $page;\n\t}\n\n\t/**\n\t * Set page boxes to be included on page descriptions.\n\t * @param array $boxes Array of page boxes to set on document: ('MediaBox', 'CropBox', 'BleedBox', 'TrimBox', 'ArtBox').\n\t * @protected\n\t */\n\tprotected function setPageBoxTypes($boxes) {\n\t\t$this->page_boxes = array();\n\t\tforeach ($boxes as $box) {\n\t\t\tif (in_array($box, TCPDF_STATIC::$pageboxes)) {\n\t\t\t\t$this->page_boxes[] = $box;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Output pages (and replace page number aliases).\n\t * @protected\n\t */\n\tprotected function _putpages() {\n\t\t$filter = ($this->compress) ? '/Filter /FlateDecode ' : '';\n\t\t// get internal aliases for page numbers\n\t\t$pnalias = $this->getAllInternalPageNumberAliases();\n\t\t$num_pages = $this->numpages;\n\t\t$ptpa = TCPDF_STATIC::formatPageNumber(($this->starting_page_number + $num_pages - 1));\n\t\t$ptpu = TCPDF_FONTS::UTF8ToUTF16BE($ptpa, false, $this->isunicode, $this->CurrentFont);\n\t\t$ptp_num_chars = $this->GetNumChars($ptpa);\n\t\t$pagegroupnum = 0;\n\t\t$groupnum = 0;\n\t\t$ptgu = 1;\n\t\t$ptga = 1;\n\t\t$ptg_num_chars = 1;\n\t\tfor ($n = 1; $n <= $num_pages; ++$n) {\n\t\t\t// get current page\n\t\t\t$temppage = $this->getPageBuffer($n);\n\t\t\t$pagelen = strlen($temppage);\n\t\t\t// set replacements for total pages number\n\t\t\t$pnpa = TCPDF_STATIC::formatPageNumber(($this->starting_page_number + $n - 1));\n\t\t\t$pnpu = TCPDF_FONTS::UTF8ToUTF16BE($pnpa, false, $this->isunicode, $this->CurrentFont);\n\t\t\t$pnp_num_chars = $this->GetNumChars($pnpa);\n\t\t\t$pdiff = 0; // difference used for right shift alignment of page numbers\n\t\t\t$gdiff = 0; // difference used for right shift alignment of page group numbers\n\t\t\tif (!empty($this->pagegroups)) {\n\t\t\t\tif (isset($this->newpagegroup[$n])) {\n\t\t\t\t\t$pagegroupnum = 0;\n\t\t\t\t\t++$groupnum;\n\t\t\t\t\t$ptga = TCPDF_STATIC::formatPageNumber($this->pagegroups[$groupnum]);\n\t\t\t\t\t$ptgu = TCPDF_FONTS::UTF8ToUTF16BE($ptga, false, $this->isunicode, $this->CurrentFont);\n\t\t\t\t\t$ptg_num_chars = $this->GetNumChars($ptga);\n\t\t\t\t}\n\t\t\t\t++$pagegroupnum;\n\t\t\t\t$pnga = TCPDF_STATIC::formatPageNumber($pagegroupnum);\n\t\t\t\t$pngu = TCPDF_FONTS::UTF8ToUTF16BE($pnga, false, $this->isunicode, $this->CurrentFont);\n\t\t\t\t$png_num_chars = $this->GetNumChars($pnga);\n\t\t\t\t// replace page numbers\n\t\t\t\t$replace = array();\n\t\t\t\t$replace[] = array($ptgu, $ptg_num_chars, 9, $pnalias[2]['u']);\n\t\t\t\t$replace[] = array($ptga, $ptg_num_chars, 7, $pnalias[2]['a']);\n\t\t\t\t$replace[] = array($pngu, $png_num_chars, 9, $pnalias[3]['u']);\n\t\t\t\t$replace[] = array($pnga, $png_num_chars, 7, $pnalias[3]['a']);\n\t\t\t\tlist($temppage, $gdiff) = TCPDF_STATIC::replacePageNumAliases($temppage, $replace, $gdiff);\n\t\t\t}\n\t\t\t// replace page numbers\n\t\t\t$replace = array();\n\t\t\t$replace[] = array($ptpu, $ptp_num_chars, 9, $pnalias[0]['u']);\n\t\t\t$replace[] = array($ptpa, $ptp_num_chars, 7, $pnalias[0]['a']);\n\t\t\t$replace[] = array($pnpu, $pnp_num_chars, 9, $pnalias[1]['u']);\n\t\t\t$replace[] = array($pnpa, $pnp_num_chars, 7, $pnalias[1]['a']);\n\t\t\tlist($temppage, $pdiff) = TCPDF_STATIC::replacePageNumAliases($temppage, $replace, $pdiff);\n\t\t\t// replace right shift alias\n\t\t\t$temppage = $this->replaceRightShiftPageNumAliases($temppage, $pnalias[4], max($pdiff, $gdiff));\n\t\t\t// replace EPS marker\n\t\t\t$temppage = str_replace($this->epsmarker, '', $temppage);\n\t\t\t//Page\n\t\t\t$this->page_obj_id[$n] = $this->_newobj();\n\t\t\t$out = '<<';\n\t\t\t$out .= ' /Type /Page';\n\t\t\t$out .= ' /Parent 1 0 R';\n\t\t\tif (empty($this->signature_data['approval']) OR ($this->signature_data['approval'] != 'A')) {\n\t\t\t\t$out .= ' /LastModified '.$this->_datestring(0, $this->doc_modification_timestamp);\n\t\t\t}\n\t\t\t$out .= ' /Resources 2 0 R';\n\t\t\tforeach ($this->page_boxes as $box) {\n\t\t\t\t$out .= ' /'.$box;\n\t\t\t\t$out .= sprintf(' [%F %F %F %F]', $this->pagedim[$n][$box]['llx'], $this->pagedim[$n][$box]['lly'], $this->pagedim[$n][$box]['urx'], $this->pagedim[$n][$box]['ury']);\n\t\t\t}\n\t\t\tif (isset($this->pagedim[$n]['BoxColorInfo']) AND !empty($this->pagedim[$n]['BoxColorInfo'])) {\n\t\t\t\t$out .= ' /BoxColorInfo <<';\n\t\t\t\tforeach ($this->page_boxes as $box) {\n\t\t\t\t\tif (isset($this->pagedim[$n]['BoxColorInfo'][$box])) {\n\t\t\t\t\t\t$out .= ' /'.$box.' <<';\n\t\t\t\t\t\tif (isset($this->pagedim[$n]['BoxColorInfo'][$box]['C'])) {\n\t\t\t\t\t\t\t$color = $this->pagedim[$n]['BoxColorInfo'][$box]['C'];\n\t\t\t\t\t\t\t$out .= ' /C [';\n\t\t\t\t\t\t\t$out .= sprintf(' %F %F %F', ($color[0] / 255), ($color[1] / 255), ($color[2] / 255));\n\t\t\t\t\t\t\t$out .= ' ]';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isset($this->pagedim[$n]['BoxColorInfo'][$box]['W'])) {\n\t\t\t\t\t\t\t$out .= ' /W '.($this->pagedim[$n]['BoxColorInfo'][$box]['W'] * $this->k);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isset($this->pagedim[$n]['BoxColorInfo'][$box]['S'])) {\n\t\t\t\t\t\t\t$out .= ' /S /'.$this->pagedim[$n]['BoxColorInfo'][$box]['S'];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isset($this->pagedim[$n]['BoxColorInfo'][$box]['D'])) {\n\t\t\t\t\t\t\t$dashes = $this->pagedim[$n]['BoxColorInfo'][$box]['D'];\n\t\t\t\t\t\t\t$out .= ' /D [';\n\t\t\t\t\t\t\tforeach ($dashes as $dash) {\n\t\t\t\t\t\t\t\t$out .= sprintf(' %F', ($dash * $this->k));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$out .= ' ]';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$out .= ' >>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$out .= ' >>';\n\t\t\t}\n\t\t\t$out .= ' /Contents '.($this->n + 1).' 0 R';\n\t\t\t$out .= ' /Rotate '.$this->pagedim[$n]['Rotate'];\n\t\t\tif (!$this->pdfa_mode || $this->pdfa_version >= 2) {\n\t\t\t\t$out .= ' /Group << /Type /Group /S /Transparency /CS /DeviceRGB >>';\n\t\t\t}\n\t\t\tif (isset($this->pagedim[$n]['trans']) AND !empty($this->pagedim[$n]['trans'])) {\n\t\t\t\t// page transitions\n\t\t\t\tif (isset($this->pagedim[$n]['trans']['Dur'])) {\n\t\t\t\t\t$out .= ' /Dur '.$this->pagedim[$n]['trans']['Dur'];\n\t\t\t\t}\n\t\t\t\t$out .= ' /Trans <<';\n\t\t\t\t$out .= ' /Type /Trans';\n\t\t\t\tif (isset($this->pagedim[$n]['trans']['S'])) {\n\t\t\t\t\t$out .= ' /S /'.$this->pagedim[$n]['trans']['S'];\n\t\t\t\t}\n\t\t\t\tif (isset($this->pagedim[$n]['trans']['D'])) {\n\t\t\t\t\t$out .= ' /D '.$this->pagedim[$n]['trans']['D'];\n\t\t\t\t}\n\t\t\t\tif (isset($this->pagedim[$n]['trans']['Dm'])) {\n\t\t\t\t\t$out .= ' /Dm /'.$this->pagedim[$n]['trans']['Dm'];\n\t\t\t\t}\n\t\t\t\tif (isset($this->pagedim[$n]['trans']['M'])) {\n\t\t\t\t\t$out .= ' /M /'.$this->pagedim[$n]['trans']['M'];\n\t\t\t\t}\n\t\t\t\tif (isset($this->pagedim[$n]['trans']['Di'])) {\n\t\t\t\t\t$out .= ' /Di '.$this->pagedim[$n]['trans']['Di'];\n\t\t\t\t}\n\t\t\t\tif (isset($this->pagedim[$n]['trans']['SS'])) {\n\t\t\t\t\t$out .= ' /SS '.$this->pagedim[$n]['trans']['SS'];\n\t\t\t\t}\n\t\t\t\tif (isset($this->pagedim[$n]['trans']['B'])) {\n\t\t\t\t\t$out .= ' /B '.$this->pagedim[$n]['trans']['B'];\n\t\t\t\t}\n\t\t\t\t$out .= ' >>';\n\t\t\t}\n\t\t\t$out .= $this->_getannotsrefs($n);\n\t\t\t$out .= ' /PZ '.$this->pagedim[$n]['PZ'];\n\t\t\t$out .= ' >>';\n\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t$this->_out($out);\n\t\t\t//Page content\n\t\t\t$p = ($this->compress) ? gzcompress($temppage) : $temppage;\n\t\t\t$this->_newobj();\n\t\t\t$p = $this->_getrawstream($p);\n\t\t\t$this->_out('<<'.$filter.'/Length '.strlen($p).'>> stream'.\"\\n\".$p.\"\\n\".'endstream'.\"\\n\".'endobj');\n\t\t}\n\t\t//Pages root\n\t\t$out = $this->_getobj(1).\"\\n\";\n\t\t$out .= '<< /Type /Pages /Kids [';\n\t\tforeach($this->page_obj_id as $page_obj) {\n\t\t\t$out .= ' '.$page_obj.' 0 R';\n\t\t}\n\t\t$out .= ' ] /Count '.$num_pages.' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t}\n\n\t/**\n\t * Get references to page annotations.\n\t * @param int $n page number\n\t * @return string\n\t * @protected\n\t * @author Nicola Asuni\n\t * @since 5.0.010 (2010-05-17)\n\t */\n\tprotected function _getannotsrefs($n) {\n\t\tif (!(isset($this->PageAnnots[$n]) OR count($this->empty_signature_appearance)>0 OR ($this->sign AND isset($this->signature_data['cert_type'])))) {\n\t\t\treturn '';\n\t\t}\n\t\t$out = ' /Annots [';\n\t\tif (isset($this->PageAnnots[$n])) {\n\t\t\tforeach ($this->PageAnnots[$n] as $key => $val) {\n\t\t\t\tif (!in_array($val['n'], $this->radio_groups)) {\n\t\t\t\t\t$out .= ' '.$val['n'].' 0 R';\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add radiobutton groups\n\t\t\tif (isset($this->radiobutton_groups[$n])) {\n\t\t\t\tforeach ($this->radiobutton_groups[$n] as $key => $data) {\n\t\t\t\t\tif (isset($data['n'])) {\n\t\t\t\t\t\t$out .= ' '.$data['n'].' 0 R';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ($this->sign AND ($n == $this->signature_appearance['page']) AND isset($this->signature_data['cert_type'])) {\n\t\t\t// set reference for signature object\n\t\t\t$out .= ' '.$this->sig_obj_id.' 0 R';\n\t\t}\n\t\tif (!empty($this->empty_signature_appearance)) {\n\t\t\tforeach ($this->empty_signature_appearance as $esa) {\n\t\t\t\tif ($esa['page'] == $n) {\n\t\t\t\t\t// set reference for empty signature objects\n\t\t\t\t\t$out .= ' '.$esa['objid'].' 0 R';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$out .= ' ]';\n\t\treturn $out;\n\t}\n\n\t/**\n\t * Output annotations objects for all pages.\n\t * !!! THIS METHOD IS NOT YET COMPLETED !!!\n\t * See section 12.5 of PDF 32000_2008 reference.\n\t * @protected\n\t * @author Nicola Asuni\n\t * @since 4.0.018 (2008-08-06)\n\t */\n\tprotected function _putannotsobjs() {\n\t\t// reset object counter\n\t\tfor ($n=1; $n <= $this->numpages; ++$n) {\n\t\t\tif (isset($this->PageAnnots[$n])) {\n\t\t\t\t// set page annotations\n\t\t\t\tforeach ($this->PageAnnots[$n] as $key => $pl) {\n\t\t\t\t\t$annot_obj_id = $this->PageAnnots[$n][$key]['n'];\n\t\t\t\t\t// create annotation object for grouping radiobuttons\n\t\t\t\t\tif (isset($this->radiobutton_groups[$n][$pl['txt']]) AND is_array($this->radiobutton_groups[$n][$pl['txt']])) {\n\t\t\t\t\t\t$radio_button_obj_id = $this->radiobutton_groups[$n][$pl['txt']]['n'];\n\t\t\t\t\t\t$annots = '<<';\n\t\t\t\t\t\t$annots .= ' /Type /Annot';\n\t\t\t\t\t\t$annots .= ' /Subtype /Widget';\n\t\t\t\t\t\t$annots .= ' /Rect [0 0 0 0]';\n\t\t\t\t\t\tif ($this->radiobutton_groups[$n][$pl['txt']]['#readonly#']) {\n\t\t\t\t\t\t\t// read only\n\t\t\t\t\t\t\t$annots .= ' /F 68';\n\t\t\t\t\t\t\t$annots .= ' /Ff 49153';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$annots .= ' /F 4'; // default print for PDF/A\n\t\t\t\t\t\t\t$annots .= ' /Ff 49152';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$annots .= ' /T '.$this->_datastring($pl['txt'], $radio_button_obj_id);\n\t\t\t\t\t\tif (isset($pl['opt']['tu']) AND is_string($pl['opt']['tu'])) {\n\t\t\t\t\t\t\t$annots .= ' /TU '.$this->_datastring($pl['opt']['tu'], $radio_button_obj_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$annots .= ' /FT /Btn';\n\t\t\t\t\t\t$annots .= ' /Kids [';\n\t\t\t\t\t\t$defval = '';\n\t\t\t\t\t\tforeach ($this->radiobutton_groups[$n][$pl['txt']] as $key => $data) {\n\t\t\t\t\t\t\tif (isset($data['kid'])) {\n\t\t\t\t\t\t\t\t$annots .= ' '.$data['kid'].' 0 R';\n\t\t\t\t\t\t\t\tif ($data['def'] !== 'Off') {\n\t\t\t\t\t\t\t\t\t$defval = $data['def'];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$annots .= ' ]';\n\t\t\t\t\t\tif (!empty($defval)) {\n\t\t\t\t\t\t\t$annots .= ' /V /'.$defval;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$annots .= ' >>';\n\t\t\t\t\t\t$this->_out($this->_getobj($radio_button_obj_id).\"\\n\".$annots.\"\\n\".'endobj');\n\t\t\t\t\t\t$this->form_obj_id[] = $radio_button_obj_id;\n\t\t\t\t\t\t// store object id to be used on Parent entry of Kids\n\t\t\t\t\t\t$this->radiobutton_groups[$n][$pl['txt']] = $radio_button_obj_id;\n\t\t\t\t\t}\n\t\t\t\t\t$formfield = false;\n\t\t\t\t\t$pl['opt'] = array_change_key_case($pl['opt'], CASE_LOWER);\n\t\t\t\t\t$a = $pl['x'] * $this->k;\n\t\t\t\t\t$b = $this->pagedim[$n]['h'] - (($pl['y'] + $pl['h']) * $this->k);\n\t\t\t\t\t$c = $pl['w'] * $this->k;\n\t\t\t\t\t$d = $pl['h'] * $this->k;\n\t\t\t\t\t$rect = sprintf('%F %F %F %F', $a, $b, $a+$c, $b+$d);\n\t\t\t\t\t// create new annotation object\n\t\t\t\t\t$annots = '<</Type /Annot';\n\t\t\t\t\t$annots .= ' /Subtype /'.$pl['opt']['subtype'];\n\t\t\t\t\t$annots .= ' /Rect ['.$rect.']';\n\t\t\t\t\t$ft = array('Btn', 'Tx', 'Ch', 'Sig');\n\t\t\t\t\tif (isset($pl['opt']['ft']) AND in_array($pl['opt']['ft'], $ft)) {\n\t\t\t\t\t\t$annots .= ' /FT /'.$pl['opt']['ft'];\n\t\t\t\t\t\t$formfield = true;\n\t\t\t\t\t}\n\t\t\t\t\tif ($pl['opt']['subtype'] !== 'Link') {\n\t\t\t\t\t\t$annots .= ' /Contents '.$this->_textstring($pl['txt'], $annot_obj_id);\n\t\t\t\t\t}\n\t\t\t\t\t$annots .= ' /P '.$this->page_obj_id[$n].' 0 R';\n\t\t\t\t\t$annots .= ' /NM '.$this->_datastring(sprintf('%04u-%04u', $n, $key), $annot_obj_id);\n\t\t\t\t\t$annots .= ' /M '.$this->_datestring($annot_obj_id, $this->doc_modification_timestamp);\n\t\t\t\t\tif (isset($pl['opt']['f'])) {\n\t\t\t\t\t\t$fval = 0;\n\t\t\t\t\t\tif (is_array($pl['opt']['f'])) {\n\t\t\t\t\t\t\tforeach ($pl['opt']['f'] as $f) {\n\t\t\t\t\t\t\t\tswitch (strtolower($f)) {\n\t\t\t\t\t\t\t\t\tcase 'invisible': {\n\t\t\t\t\t\t\t\t\t\t$fval += 1 << 0;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'hidden': {\n\t\t\t\t\t\t\t\t\t\t$fval += 1 << 1;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'print': {\n\t\t\t\t\t\t\t\t\t\t$fval += 1 << 2;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'nozoom': {\n\t\t\t\t\t\t\t\t\t\t$fval += 1 << 3;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'norotate': {\n\t\t\t\t\t\t\t\t\t\t$fval += 1 << 4;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'noview': {\n\t\t\t\t\t\t\t\t\t\t$fval += 1 << 5;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'readonly': {\n\t\t\t\t\t\t\t\t\t\t$fval += 1 << 6;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'locked': {\n\t\t\t\t\t\t\t\t\t\t$fval += 1 << 8;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'togglenoview': {\n\t\t\t\t\t\t\t\t\t\t$fval += 1 << 9;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'lockedcontents': {\n\t\t\t\t\t\t\t\t\t\t$fval += 1 << 10;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$fval = intval($pl['opt']['f']);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$fval = 4;\n\t\t\t\t\t}\n\t\t\t\t\tif ($this->pdfa_mode) {\n\t\t\t\t\t\t// force print flag for PDF/A mode\n\t\t\t\t\t\t$fval |= 4;\n\t\t\t\t\t}\n\t\t\t\t\t$annots .= ' /F '.intval($fval);\n\t\t\t\t\tif (isset($pl['opt']['as']) AND is_string($pl['opt']['as'])) {\n\t\t\t\t\t\t$annots .= ' /AS /'.$pl['opt']['as'];\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($pl['opt']['ap'])) {\n\t\t\t\t\t\t// appearance stream\n\t\t\t\t\t\t$annots .= ' /AP <<';\n\t\t\t\t\t\tif (is_array($pl['opt']['ap'])) {\n\t\t\t\t\t\t\tforeach ($pl['opt']['ap'] as $apmode => $apdef) {\n\t\t\t\t\t\t\t\t// $apmode can be: n = normal; r = rollover; d = down;\n\t\t\t\t\t\t\t\t$annots .= ' /'.strtoupper($apmode);\n\t\t\t\t\t\t\t\tif (is_array($apdef)) {\n\t\t\t\t\t\t\t\t\t$annots .= ' <<';\n\t\t\t\t\t\t\t\t\tforeach ($apdef as $apstate => $stream) {\n\t\t\t\t\t\t\t\t\t\t// reference to XObject that define the appearance for this mode-state\n\t\t\t\t\t\t\t\t\t\t$apsobjid = $this->_putAPXObject($c, $d, $stream);\n\t\t\t\t\t\t\t\t\t\t$annots .= ' /'.$apstate.' '.$apsobjid.' 0 R';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$annots .= ' >>';\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// reference to XObject that define the appearance for this mode\n\t\t\t\t\t\t\t\t\t$apsobjid = $this->_putAPXObject($c, $d, $apdef);\n\t\t\t\t\t\t\t\t\t$annots .= ' '.$apsobjid.' 0 R';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$annots .= $pl['opt']['ap'];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$annots .= ' >>';\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($pl['opt']['bs']) AND (is_array($pl['opt']['bs']))) {\n\t\t\t\t\t\t$annots .= ' /BS <<';\n\t\t\t\t\t\t$annots .= ' /Type /Border';\n\t\t\t\t\t\tif (isset($pl['opt']['bs']['w'])) {\n\t\t\t\t\t\t\t$annots .= ' /W '.intval($pl['opt']['bs']['w']);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$bstyles = array('S', 'D', 'B', 'I', 'U');\n\t\t\t\t\t\tif (isset($pl['opt']['bs']['s']) AND in_array($pl['opt']['bs']['s'], $bstyles)) {\n\t\t\t\t\t\t\t$annots .= ' /S /'.$pl['opt']['bs']['s'];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isset($pl['opt']['bs']['d']) AND (is_array($pl['opt']['bs']['d']))) {\n\t\t\t\t\t\t\t$annots .= ' /D [';\n\t\t\t\t\t\t\tforeach ($pl['opt']['bs']['d'] as $cord) {\n\t\t\t\t\t\t\t\t$annots .= ' '.intval($cord);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$annots .= ']';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$annots .= ' >>';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$annots .= ' /Border [';\n\t\t\t\t\t\tif (isset($pl['opt']['border']) AND (count($pl['opt']['border']) >= 3)) {\n\t\t\t\t\t\t\t$annots .= intval($pl['opt']['border'][0]).' ';\n\t\t\t\t\t\t\t$annots .= intval($pl['opt']['border'][1]).' ';\n\t\t\t\t\t\t\t$annots .= intval($pl['opt']['border'][2]);\n\t\t\t\t\t\t\tif (isset($pl['opt']['border'][3]) AND is_array($pl['opt']['border'][3])) {\n\t\t\t\t\t\t\t\t$annots .= ' [';\n\t\t\t\t\t\t\t\tforeach ($pl['opt']['border'][3] as $dash) {\n\t\t\t\t\t\t\t\t\t$annots .= intval($dash).' ';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$annots .= ']';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$annots .= '0 0 0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$annots .= ']';\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($pl['opt']['be']) AND (is_array($pl['opt']['be']))) {\n\t\t\t\t\t\t$annots .= ' /BE <<';\n\t\t\t\t\t\t$bstyles = array('S', 'C');\n\t\t\t\t\t\tif (isset($pl['opt']['be']['s']) AND in_array($pl['opt']['be']['s'], $bstyles)) {\n\t\t\t\t\t\t\t$annots .= ' /S /'.$pl['opt']['bs']['s'];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$annots .= ' /S /S';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isset($pl['opt']['be']['i']) AND ($pl['opt']['be']['i'] >= 0) AND ($pl['opt']['be']['i'] <= 2)) {\n\t\t\t\t\t\t\t$annots .= ' /I '.sprintf(' %F', $pl['opt']['be']['i']);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$annots .= '>>';\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($pl['opt']['c']) AND (is_array($pl['opt']['c'])) AND !empty($pl['opt']['c'])) {\n\t\t\t\t\t\t$annots .= ' /C '.TCPDF_COLORS::getColorStringFromArray($pl['opt']['c']);\n\t\t\t\t\t}\n\t\t\t\t\t//$annots .= ' /StructParent ';\n\t\t\t\t\t//$annots .= ' /OC ';\n\t\t\t\t\t$markups = array('text', 'freetext', 'line', 'square', 'circle', 'polygon', 'polyline', 'highlight', 'underline', 'squiggly', 'strikeout', 'stamp', 'caret', 'ink', 'fileattachment', 'sound');\n\t\t\t\t\tif (in_array(strtolower($pl['opt']['subtype']), $markups)) {\n\t\t\t\t\t\t// this is a markup type\n\t\t\t\t\t\tif (isset($pl['opt']['t']) AND is_string($pl['opt']['t'])) {\n\t\t\t\t\t\t\t$annots .= ' /T '.$this->_textstring($pl['opt']['t'], $annot_obj_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//$annots .= ' /Popup ';\n\t\t\t\t\t\tif (isset($pl['opt']['ca'])) {\n\t\t\t\t\t\t\t$annots .= ' /CA '.sprintf('%F', floatval($pl['opt']['ca']));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isset($pl['opt']['rc'])) {\n\t\t\t\t\t\t\t$annots .= ' /RC '.$this->_textstring($pl['opt']['rc'], $annot_obj_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$annots .= ' /CreationDate '.$this->_datestring($annot_obj_id, $this->doc_creation_timestamp);\n\t\t\t\t\t\t//$annots .= ' /IRT ';\n\t\t\t\t\t\tif (isset($pl['opt']['subj'])) {\n\t\t\t\t\t\t\t$annots .= ' /Subj '.$this->_textstring($pl['opt']['subj'], $annot_obj_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//$annots .= ' /RT ';\n\t\t\t\t\t\t//$annots .= ' /IT ';\n\t\t\t\t\t\t//$annots .= ' /ExData ';\n\t\t\t\t\t}\n\t\t\t\t\t$lineendings = array('Square', 'Circle', 'Diamond', 'OpenArrow', 'ClosedArrow', 'None', 'Butt', 'ROpenArrow', 'RClosedArrow', 'Slash');\n\t\t\t\t\t// Annotation types\n\t\t\t\t\tswitch (strtolower($pl['opt']['subtype'])) {\n\t\t\t\t\t\tcase 'text': {\n\t\t\t\t\t\t\tif (isset($pl['opt']['open'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /Open '. (strtolower($pl['opt']['open']) == 'true' ? 'true' : 'false');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$iconsapp = array('Comment', 'Help', 'Insert', 'Key', 'NewParagraph', 'Note', 'Paragraph');\n\t\t\t\t\t\t\tif (isset($pl['opt']['name']) AND in_array($pl['opt']['name'], $iconsapp)) {\n\t\t\t\t\t\t\t\t$annots .= ' /Name /'.$pl['opt']['name'];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$annots .= ' /Name /Note';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$hasStateModel = isset($pl['opt']['statemodel']);\n\t\t\t\t\t\t\t$hasState = isset($pl['opt']['state']);\n\t\t\t\t\t\t\t$statemodels = array('Marked', 'Review');\n\t\t\t\t\t\t\tif (!$hasStateModel && !$hasState) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ($hasStateModel AND in_array($pl['opt']['statemodel'], $statemodels)) {\n\t\t\t\t\t\t\t\t$annots .= ' /StateModel /'.$pl['opt']['statemodel'];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$pl['opt']['statemodel'] = 'Marked';\n\t\t\t\t\t\t\t\t$annots .= ' /StateModel /'.$pl['opt']['statemodel'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ($pl['opt']['statemodel'] == 'Marked') {\n\t\t\t\t\t\t\t\t$states = array('Accepted', 'Unmarked');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$states = array('Accepted', 'Rejected', 'Cancelled', 'Completed', 'None');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ($hasState AND in_array($pl['opt']['state'], $states)) {\n\t\t\t\t\t\t\t\t$annots .= ' /State /'.$pl['opt']['state'];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif ($pl['opt']['statemodel'] == 'Marked') {\n\t\t\t\t\t\t\t\t\t$annots .= ' /State /Unmarked';\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$annots .= ' /State /None';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'link': {\n\t\t\t\t\t\t\tif (is_string($pl['txt']) && !empty($pl['txt'])) {\n\t\t\t\t\t\t\t\tif ($pl['txt'][0] == '#') {\n\t\t\t\t\t\t\t\t\t// internal destination\n\t\t\t\t\t\t\t\t\t$annots .= ' /A <</S /GoTo /D /'.TCPDF_STATIC::encodeNameObject(substr($pl['txt'], 1)).'>>';\n\t\t\t\t\t\t\t\t} elseif ($pl['txt'][0] == '%') {\n\t\t\t\t\t\t\t\t\t// embedded PDF file\n\t\t\t\t\t\t\t\t\t$filename = basename(substr($pl['txt'], 1));\n\t\t\t\t\t\t\t\t\t$annots .= ' /A << /S /GoToE /D [0 /Fit] /NewWindow true /T << /R /C /P '.($n - 1).' /A '.$this->embeddedfiles[$filename]['a'].' >> >>';\n\t\t\t\t\t\t\t\t} elseif ($pl['txt'][0] == '*') {\n\t\t\t\t\t\t\t\t\t// embedded generic file\n\t\t\t\t\t\t\t\t\t$filename = basename(substr($pl['txt'], 1));\n\t\t\t\t\t\t\t\t\t$jsa = 'var D=event.target.doc;var MyData=D.dataObjects;for (var i in MyData) if (MyData[i].path==\"'.$filename.'\") D.exportDataObject( { cName : MyData[i].name, nLaunch : 2});';\n\t\t\t\t\t\t\t\t\t$annots .= ' /A << /S /JavaScript /JS '.$this->_textstring($jsa, $annot_obj_id).'>>';\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$parsedUrl = parse_url($pl['txt']);\n\t\t\t\t\t\t\t\t\tif (empty($parsedUrl['scheme']) AND (!empty($parsedUrl['path']) && strtolower(substr($parsedUrl['path'], -4)) == '.pdf')) {\n\t\t\t\t\t\t\t\t\t\t// relative link to a PDF file\n\t\t\t\t\t\t\t\t\t\t$dest = '[0 /Fit]'; // default page 0\n\t\t\t\t\t\t\t\t\t\tif (!empty($parsedUrl['fragment'])) {\n\t\t\t\t\t\t\t\t\t\t\t// check for named destination\n\t\t\t\t\t\t\t\t\t\t\t$tmp = explode('=', $parsedUrl['fragment']);\n\t\t\t\t\t\t\t\t\t\t\t$dest = '('.((count($tmp) == 2) ? $tmp[1] : $tmp[0]).')';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t$annots .= ' /A <</S /GoToR /D '.$dest.' /F '.$this->_datastring($this->unhtmlentities($parsedUrl['path']), $annot_obj_id).' /NewWindow true>>';\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// external URI link\n\t\t\t\t\t\t\t\t\t\t$annots .= ' /A <</S /URI /URI '.$this->_datastring($this->unhtmlentities($pl['txt']), $annot_obj_id).'>>';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} elseif (isset($this->links[$pl['txt']])) {\n\t\t\t\t\t\t\t\t// internal link ID\n\t\t\t\t\t\t\t\t$l = $this->links[$pl['txt']];\n\t\t\t\t\t\t\t\tif (isset($this->page_obj_id[($l['p'])])) {\n\t\t\t\t\t\t\t\t\t$annots .= sprintf(' /Dest [%u 0 R /XYZ 0 %F null]', $this->page_obj_id[($l['p'])], ($this->pagedim[$l['p']]['h'] - ($l['y'] * $this->k)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$hmodes = array('N', 'I', 'O', 'P');\n\t\t\t\t\t\t\tif (isset($pl['opt']['h']) AND in_array($pl['opt']['h'], $hmodes)) {\n\t\t\t\t\t\t\t\t$annots .= ' /H /'.$pl['opt']['h'];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$annots .= ' /H /I';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//$annots .= ' /PA ';\n\t\t\t\t\t\t\t//$annots .= ' /Quadpoints ';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'freetext': {\n\t\t\t\t\t\t\tif (isset($pl['opt']['da']) AND !empty($pl['opt']['da'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /DA '.$this->_datastring($pl['opt']['da']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['q']) AND ($pl['opt']['q'] >= 0) AND ($pl['opt']['q'] <= 2)) {\n\t\t\t\t\t\t\t\t$annots .= ' /Q '.intval($pl['opt']['q']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['rc'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /RC '.$this->_textstring($pl['opt']['rc'], $annot_obj_id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['ds'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /DS '.$this->_textstring($pl['opt']['ds'], $annot_obj_id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['cl']) AND is_array($pl['opt']['cl'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /CL [';\n\t\t\t\t\t\t\t\tforeach ($pl['opt']['cl'] as $cl) {\n\t\t\t\t\t\t\t\t\t$annots .= sprintf('%F ', $cl * $this->k);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$annots .= ']';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$tfit = array('FreeText', 'FreeTextCallout', 'FreeTextTypeWriter');\n\t\t\t\t\t\t\tif (isset($pl['opt']['it']) AND in_array($pl['opt']['it'], $tfit)) {\n\t\t\t\t\t\t\t\t$annots .= ' /IT /'.$pl['opt']['it'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['rd']) AND is_array($pl['opt']['rd'])) {\n\t\t\t\t\t\t\t\t$l = $pl['opt']['rd'][0] * $this->k;\n\t\t\t\t\t\t\t\t$r = $pl['opt']['rd'][1] * $this->k;\n\t\t\t\t\t\t\t\t$t = $pl['opt']['rd'][2] * $this->k;\n\t\t\t\t\t\t\t\t$b = $pl['opt']['rd'][3] * $this->k;\n\t\t\t\t\t\t\t\t$annots .= ' /RD ['.sprintf('%F %F %F %F', $l, $r, $t, $b).']';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['le']) AND in_array($pl['opt']['le'], $lineendings)) {\n\t\t\t\t\t\t\t\t$annots .= ' /LE /'.$pl['opt']['le'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'line': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'square': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'circle': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'polygon': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'polyline': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'highlight': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'underline': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'squiggly': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'strikeout': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'stamp': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'caret': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'ink': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'popup': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'fileattachment': {\n\t\t\t\t\t\t\tif ($this->pdfa_mode && $this->pdfa_version != 3) {\n\t\t\t\t\t\t\t\t// embedded files are not allowed in PDF/A mode version 1 and 2\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!isset($pl['opt']['fs'])) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$filename = basename($pl['opt']['fs']);\n\t\t\t\t\t\t\tif (isset($this->embeddedfiles[$filename]['f'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /FS '.$this->embeddedfiles[$filename]['f'].' 0 R';\n\t\t\t\t\t\t\t\t$iconsapp = array('Graph', 'Paperclip', 'PushPin', 'Tag');\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['name']) AND in_array($pl['opt']['name'], $iconsapp)) {\n\t\t\t\t\t\t\t\t\t$annots .= ' /Name /'.$pl['opt']['name'];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$annots .= ' /Name /PushPin';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// index (zero-based) of the annotation in the Annots array of this page\n\t\t\t\t\t\t\t\t$this->embeddedfiles[$filename]['a'] = $key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'sound': {\n\t\t\t\t\t\t\tif (!isset($pl['opt']['fs'])) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$filename = basename($pl['opt']['fs']);\n\t\t\t\t\t\t\tif (isset($this->embeddedfiles[$filename]['f'])) {\n\t\t\t\t\t\t\t\t// ... TO BE COMPLETED ...\n\t\t\t\t\t\t\t\t// /R /C /B /E /CO /CP\n\t\t\t\t\t\t\t\t$annots .= ' /Sound '.$this->embeddedfiles[$filename]['f'].' 0 R';\n\t\t\t\t\t\t\t\t$iconsapp = array('Speaker', 'Mic');\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['name']) AND in_array($pl['opt']['name'], $iconsapp)) {\n\t\t\t\t\t\t\t\t\t$annots .= ' /Name /'.$pl['opt']['name'];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$annots .= ' /Name /Speaker';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'movie': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'widget': {\n\t\t\t\t\t\t\t$hmode = array('N', 'I', 'O', 'P', 'T');\n\t\t\t\t\t\t\tif (isset($pl['opt']['h']) AND in_array($pl['opt']['h'], $hmode)) {\n\t\t\t\t\t\t\t\t$annots .= ' /H /'.$pl['opt']['h'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['mk']) AND (is_array($pl['opt']['mk'])) AND !empty($pl['opt']['mk'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /MK <<';\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['r'])) {\n\t\t\t\t\t\t\t\t\t$annots .= ' /R '.$pl['opt']['mk']['r'];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['bc']) AND (is_array($pl['opt']['mk']['bc']))) {\n\t\t\t\t\t\t\t\t\t$annots .= ' /BC '.TCPDF_COLORS::getColorStringFromArray($pl['opt']['mk']['bc']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['bg']) AND (is_array($pl['opt']['mk']['bg']))) {\n\t\t\t\t\t\t\t\t\t$annots .= ' /BG '.TCPDF_COLORS::getColorStringFromArray($pl['opt']['mk']['bg']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['ca'])) {\n\t\t\t\t\t\t\t\t\t$annots .= ' /CA '.$pl['opt']['mk']['ca'];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['rc'])) {\n\t\t\t\t\t\t\t\t\t$annots .= ' /RC '.$pl['opt']['mk']['rc'];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['ac'])) {\n\t\t\t\t\t\t\t\t\t$annots .= ' /AC '.$pl['opt']['mk']['ac'];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['i'])) {\n\t\t\t\t\t\t\t\t\t$info = $this->getImageBuffer($pl['opt']['mk']['i']);\n\t\t\t\t\t\t\t\t\tif ($info !== false) {\n\t\t\t\t\t\t\t\t\t\t$annots .= ' /I '.$info['n'].' 0 R';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['ri'])) {\n\t\t\t\t\t\t\t\t\t$info = $this->getImageBuffer($pl['opt']['mk']['ri']);\n\t\t\t\t\t\t\t\t\tif ($info !== false) {\n\t\t\t\t\t\t\t\t\t\t$annots .= ' /RI '.$info['n'].' 0 R';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['ix'])) {\n\t\t\t\t\t\t\t\t\t$info = $this->getImageBuffer($pl['opt']['mk']['ix']);\n\t\t\t\t\t\t\t\t\tif ($info !== false) {\n\t\t\t\t\t\t\t\t\t\t$annots .= ' /IX '.$info['n'].' 0 R';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['if']) AND (is_array($pl['opt']['mk']['if'])) AND !empty($pl['opt']['mk']['if'])) {\n\t\t\t\t\t\t\t\t\t$annots .= ' /IF <<';\n\t\t\t\t\t\t\t\t\t$if_sw = array('A', 'B', 'S', 'N');\n\t\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['if']['sw']) AND in_array($pl['opt']['mk']['if']['sw'], $if_sw)) {\n\t\t\t\t\t\t\t\t\t\t$annots .= ' /SW /'.$pl['opt']['mk']['if']['sw'];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$if_s = array('A', 'P');\n\t\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['if']['s']) AND in_array($pl['opt']['mk']['if']['s'], $if_s)) {\n\t\t\t\t\t\t\t\t\t\t$annots .= ' /S /'.$pl['opt']['mk']['if']['s'];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['if']['a']) AND (is_array($pl['opt']['mk']['if']['a'])) AND !empty($pl['opt']['mk']['if']['a'])) {\n\t\t\t\t\t\t\t\t\t\t$annots .= sprintf(' /A [%F %F]', $pl['opt']['mk']['if']['a'][0], $pl['opt']['mk']['if']['a'][1]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['if']['fb']) AND ($pl['opt']['mk']['if']['fb'])) {\n\t\t\t\t\t\t\t\t\t\t$annots .= ' /FB true';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$annots .= '>>';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($pl['opt']['mk']['tp']) AND ($pl['opt']['mk']['tp'] >= 0) AND ($pl['opt']['mk']['tp'] <= 6)) {\n\t\t\t\t\t\t\t\t\t$annots .= ' /TP '.intval($pl['opt']['mk']['tp']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$annots .= '>>';\n\t\t\t\t\t\t\t} // end MK\n\t\t\t\t\t\t\t// --- Entries for field dictionaries ---\n\t\t\t\t\t\t\tif (isset($this->radiobutton_groups[$n][$pl['txt']])) {\n\t\t\t\t\t\t\t\t// set parent\n\t\t\t\t\t\t\t\t$annots .= ' /Parent '.$this->radiobutton_groups[$n][$pl['txt']].' 0 R';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['t']) AND is_string($pl['opt']['t'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /T '.$this->_datastring($pl['opt']['t'], $annot_obj_id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['tu']) AND is_string($pl['opt']['tu'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /TU '.$this->_datastring($pl['opt']['tu'], $annot_obj_id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['tm']) AND is_string($pl['opt']['tm'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /TM '.$this->_datastring($pl['opt']['tm'], $annot_obj_id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['ff'])) {\n\t\t\t\t\t\t\t\tif (is_array($pl['opt']['ff'])) {\n\t\t\t\t\t\t\t\t\t// array of bit settings\n\t\t\t\t\t\t\t\t\t$flag = 0;\n\t\t\t\t\t\t\t\t\tforeach($pl['opt']['ff'] as $val) {\n\t\t\t\t\t\t\t\t\t\t$flag += 1 << ($val - 1);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$flag = intval($pl['opt']['ff']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$annots .= ' /Ff '.$flag;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['maxlen'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /MaxLen '.intval($pl['opt']['maxlen']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['v'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /V';\n\t\t\t\t\t\t\t\tif (is_array($pl['opt']['v'])) {\n\t\t\t\t\t\t\t\t\tforeach ($pl['opt']['v'] AS $optval) {\n\t\t\t\t\t\t\t\t\t\tif (is_float($optval)) {\n\t\t\t\t\t\t\t\t\t\t\t$optval = sprintf('%F', $optval);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t$annots .= ' '.$optval;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$annots .= ' '.$this->_textstring($pl['opt']['v'], $annot_obj_id);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['dv'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /DV';\n\t\t\t\t\t\t\t\tif (is_array($pl['opt']['dv'])) {\n\t\t\t\t\t\t\t\t\tforeach ($pl['opt']['dv'] AS $optval) {\n\t\t\t\t\t\t\t\t\t\tif (is_float($optval)) {\n\t\t\t\t\t\t\t\t\t\t\t$optval = sprintf('%F', $optval);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t$annots .= ' '.$optval;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$annots .= ' '.$this->_textstring($pl['opt']['dv'], $annot_obj_id);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['rv'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /RV';\n\t\t\t\t\t\t\t\tif (is_array($pl['opt']['rv'])) {\n\t\t\t\t\t\t\t\t\tforeach ($pl['opt']['rv'] AS $optval) {\n\t\t\t\t\t\t\t\t\t\tif (is_float($optval)) {\n\t\t\t\t\t\t\t\t\t\t\t$optval = sprintf('%F', $optval);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t$annots .= ' '.$optval;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$annots .= ' '.$this->_textstring($pl['opt']['rv'], $annot_obj_id);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['a']) AND !empty($pl['opt']['a'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /A << '.$pl['opt']['a'].' >>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['aa']) AND !empty($pl['opt']['aa'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /AA << '.$pl['opt']['aa'].' >>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['da']) AND !empty($pl['opt']['da'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /DA '.$this->_datastring($pl['opt']['da']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['q']) AND ($pl['opt']['q'] >= 0) AND ($pl['opt']['q'] <= 2)) {\n\t\t\t\t\t\t\t\t$annots .= ' /Q '.intval($pl['opt']['q']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['opt']) AND (is_array($pl['opt']['opt'])) AND !empty($pl['opt']['opt'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /Opt [';\n\t\t\t\t\t\t\t\tforeach($pl['opt']['opt'] AS $copt) {\n\t\t\t\t\t\t\t\t\tif (is_array($copt)) {\n\t\t\t\t\t\t\t\t\t\t$annots .= ' ['.$this->_textstring($copt[0], $annot_obj_id).' '.$this->_textstring($copt[1], $annot_obj_id).']';\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t$annots .= ' '.$this->_textstring($copt, $annot_obj_id);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$annots .= ']';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['ti'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /TI '.intval($pl['opt']['ti']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($pl['opt']['i']) AND (is_array($pl['opt']['i'])) AND !empty($pl['opt']['i'])) {\n\t\t\t\t\t\t\t\t$annots .= ' /I [';\n\t\t\t\t\t\t\t\tforeach($pl['opt']['i'] AS $copt) {\n\t\t\t\t\t\t\t\t\t$annots .= intval($copt).' ';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$annots .= ']';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'screen': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'printermark': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'trapnet': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'watermark': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase '3d': {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$annots .= '>>';\n\t\t\t\t\t// create new annotation object\n\t\t\t\t\t$this->_out($this->_getobj($annot_obj_id).\"\\n\".$annots.\"\\n\".'endobj');\n\t\t\t\t\tif ($formfield AND !isset($this->radiobutton_groups[$n][$pl['txt']])) {\n\t\t\t\t\t\t// store reference of form object\n\t\t\t\t\t\t$this->form_obj_id[] = $annot_obj_id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // end for each page\n\t}\n\n\t/**\n\t * Put appearance streams XObject used to define annotation's appearance states.\n\t * @param int $w annotation width\n\t * @param int $h annotation height\n\t * @param string $stream appearance stream\n\t * @return int object ID\n\t * @protected\n\t * @since 4.8.001 (2009-09-09)\n\t */\n\tprotected function _putAPXObject($w=0, $h=0, $stream='') {\n\t\t$stream = trim($stream);\n\t\t$out = $this->_getobj().\"\\n\";\n\t\t$this->xobjects['AX'.$this->n] = array('n' => $this->n);\n\t\t$out .= '<<';\n\t\t$out .= ' /Type /XObject';\n\t\t$out .= ' /Subtype /Form';\n\t\t$out .= ' /FormType 1';\n\t\tif ($this->compress) {\n\t\t\t$stream = gzcompress($stream);\n\t\t\t$out .= ' /Filter /FlateDecode';\n\t\t}\n\t\t$rect = sprintf('%F %F', $w, $h);\n\t\t$out .= ' /BBox [0 0 '.$rect.']';\n\t\t$out .= ' /Matrix [1 0 0 1 0 0]';\n\t\t$out .= ' /Resources 2 0 R';\n\t\t$stream = $this->_getrawstream($stream);\n\t\t$out .= ' /Length '.strlen($stream);\n\t\t$out .= ' >>';\n\t\t$out .= ' stream'.\"\\n\".$stream.\"\\n\".'endstream';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t\treturn $this->n;\n\t}\n\n\t/**\n\t * Output fonts.\n\t * @author Nicola Asuni\n\t * @protected\n\t */\n\tprotected function _putfonts() {\n\t\t$nf = $this->n;\n\t\tforeach ($this->diffs as $diff) {\n\t\t\t//Encodings\n\t\t\t$this->_newobj();\n\t\t\t$this->_out('<< /Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences ['.$diff.'] >>'.\"\\n\".'endobj');\n\t\t}\n\t\tforeach ($this->FontFiles as $file => $info) {\n\t\t\t// search and get font file to embedd\n\t\t\t$fontfile = TCPDF_FONTS::getFontFullPath($file, $info['fontdir']);\n\t\t\tif (!TCPDF_STATIC::empty_string($fontfile)) {\n\t\t\t\t$font = file_get_contents($fontfile);\n\t\t\t\t$compressed = (substr($file, -2) == '.z');\n\t\t\t\tif ((!$compressed) AND (isset($info['length2']))) {\n\t\t\t\t\t$header = (ord($font[0]) == 128);\n\t\t\t\t\tif ($header) {\n\t\t\t\t\t\t// strip first binary header\n\t\t\t\t\t\t$font = substr($font, 6);\n\t\t\t\t\t}\n\t\t\t\t\tif ($header AND (ord($font[$info['length1']]) == 128)) {\n\t\t\t\t\t\t// strip second binary header\n\t\t\t\t\t\t$font = substr($font, 0, $info['length1']).substr($font, ($info['length1'] + 6));\n\t\t\t\t\t}\n\t\t\t\t} elseif ($info['subset'] AND ((!$compressed) OR ($compressed AND function_exists('gzcompress')))) {\n\t\t\t\t\tif ($compressed) {\n\t\t\t\t\t\t// uncompress font\n\t\t\t\t\t\t$font = gzuncompress($font);\n\t\t\t\t\t}\n\t\t\t\t\t// merge subset characters\n\t\t\t\t\t$subsetchars = array(); // used chars\n\t\t\t\t\tforeach ($info['fontkeys'] as $fontkey) {\n\t\t\t\t\t\t$fontinfo = $this->getFontBuffer($fontkey);\n\t\t\t\t\t\t$subsetchars += $fontinfo['subsetchars'];\n\t\t\t\t\t}\n\t\t\t\t\t// rebuild a font subset\n\t\t\t\t\t$font = TCPDF_FONTS::_getTrueTypeFontSubset($font, $subsetchars);\n\t\t\t\t\t// calculate new font length\n\t\t\t\t\t$info['length1'] = strlen($font);\n\t\t\t\t\tif ($compressed) {\n\t\t\t\t\t\t// recompress font\n\t\t\t\t\t\t$font = gzcompress($font);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$this->_newobj();\n\t\t\t\t$this->FontFiles[$file]['n'] = $this->n;\n\t\t\t\t$stream = $this->_getrawstream($font);\n\t\t\t\t$out = '<< /Length '.strlen($stream);\n\t\t\t\tif ($compressed) {\n\t\t\t\t\t$out .= ' /Filter /FlateDecode';\n\t\t\t\t}\n\t\t\t\t$out .= ' /Length1 '.$info['length1'];\n\t\t\t\tif (isset($info['length2'])) {\n\t\t\t\t\t$out .= ' /Length2 '.$info['length2'].' /Length3 0';\n\t\t\t\t}\n\t\t\t\t$out .= ' >>';\n\t\t\t\t$out .= ' stream'.\"\\n\".$stream.\"\\n\".'endstream';\n\t\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t\t$this->_out($out);\n\t\t\t}\n\t\t}\n\t\tforeach ($this->fontkeys as $k) {\n\t\t\t//Font objects\n\t\t\t$font = $this->getFontBuffer($k);\n\t\t\t$type = $font['type'];\n\t\t\t$name = $font['name'];\n\t\t\tif ($type == 'core') {\n\t\t\t\t// standard core font\n\t\t\t\t$out = $this->_getobj($this->font_obj_ids[$k]).\"\\n\";\n\t\t\t\t$out .= '<</Type /Font';\n\t\t\t\t$out .= ' /Subtype /Type1';\n\t\t\t\t$out .= ' /BaseFont /'.$name;\n\t\t\t\t$out .= ' /Name /F'.$font['i'];\n\t\t\t\tif ((strtolower($name) != 'symbol') AND (strtolower($name) != 'zapfdingbats')) {\n\t\t\t\t\t$out .= ' /Encoding /WinAnsiEncoding';\n\t\t\t\t}\n\t\t\t\tif ($k == 'helvetica') {\n\t\t\t\t\t// add default font for annotations\n\t\t\t\t\t$this->annotation_fonts[$k] = $font['i'];\n\t\t\t\t}\n\t\t\t\t$out .= ' >>';\n\t\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t\t$this->_out($out);\n\t\t\t} elseif (($type == 'Type1') OR ($type == 'TrueType')) {\n\t\t\t\t// additional Type1 or TrueType font\n\t\t\t\t$out = $this->_getobj($this->font_obj_ids[$k]).\"\\n\";\n\t\t\t\t$out .= '<</Type /Font';\n\t\t\t\t$out .= ' /Subtype /'.$type;\n\t\t\t\t$out .= ' /BaseFont /'.$name;\n\t\t\t\t$out .= ' /Name /F'.$font['i'];\n\t\t\t\t$out .= ' /FirstChar 32 /LastChar 255';\n\t\t\t\t$out .= ' /Widths '.($this->n + 1).' 0 R';\n\t\t\t\t$out .= ' /FontDescriptor '.($this->n + 2).' 0 R';\n\t\t\t\tif ($font['enc']) {\n\t\t\t\t\tif (isset($font['diff'])) {\n\t\t\t\t\t\t$out .= ' /Encoding '.($nf + $font['diff']).' 0 R';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$out .= ' /Encoding /WinAnsiEncoding';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$out .= ' >>';\n\t\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t\t$this->_out($out);\n\t\t\t\t// Widths\n\t\t\t\t$this->_newobj();\n\t\t\t\t$s = '[';\n\t\t\t\tfor ($i = 32; $i < 256; ++$i) {\n\t\t\t\t\tif (isset($font['cw'][$i])) {\n\t\t\t\t\t\t$s .= $font['cw'][$i].' ';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$s .= $font['dw'].' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$s .= ']';\n\t\t\t\t$s .= \"\\n\".'endobj';\n\t\t\t\t$this->_out($s);\n\t\t\t\t//Descriptor\n\t\t\t\t$this->_newobj();\n\t\t\t\t$s = '<</Type /FontDescriptor /FontName /'.$name;\n\t\t\t\tforeach ($font['desc'] as $fdk => $fdv) {\n\t\t\t\t\tif (is_float($fdv)) {\n\t\t\t\t\t\t$fdv = sprintf('%F', $fdv);\n\t\t\t\t\t}\n\t\t\t\t\t$s .= ' /'.$fdk.' '.$fdv.'';\n\t\t\t\t}\n\t\t\t\tif (!TCPDF_STATIC::empty_string($font['file'])) {\n\t\t\t\t\t$s .= ' /FontFile'.($type == 'Type1' ? '' : '2').' '.$this->FontFiles[$font['file']]['n'].' 0 R';\n\t\t\t\t}\n\t\t\t\t$s .= '>>';\n\t\t\t\t$s .= \"\\n\".'endobj';\n\t\t\t\t$this->_out($s);\n\t\t\t} else {\n\t\t\t\t// additional types\n\t\t\t\t$mtd = '_put'.strtolower($type);\n\t\t\t\tif (!method_exists($this, $mtd)) {\n\t\t\t\t\t$this->Error('Unsupported font type: '.$type);\n\t\t\t\t}\n\t\t\t\t$this->$mtd($font);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Adds unicode fonts.<br>\n\t * Based on PDF Reference 1.3 (section 5)\n\t * @param array $font font data\n\t * @protected\n\t * @author Nicola Asuni\n\t * @since 1.52.0.TC005 (2005-01-05)\n\t */\n\tprotected function _puttruetypeunicode($font) {\n\t\t$fontname = '';\n\t\tif ($font['subset']) {\n\t\t\t// change name for font subsetting\n\t\t\t$subtag = sprintf('%06u', $font['i']);\n\t\t\t$subtag = strtr($subtag, '0123456789', 'ABCDEFGHIJ');\n\t\t\t$fontname .= $subtag.'+';\n\t\t}\n\t\t$fontname .= $font['name'];\n\t\t// Type0 Font\n\t\t// A composite font composed of other fonts, organized hierarchically\n\t\t$out = $this->_getobj($this->font_obj_ids[$font['fontkey']]).\"\\n\";\n\t\t$out .= '<< /Type /Font';\n\t\t$out .= ' /Subtype /Type0';\n\t\t$out .= ' /BaseFont /'.$fontname;\n\t\t$out .= ' /Name /F'.$font['i'];\n\t\t$out .= ' /Encoding /'.$font['enc'];\n\t\t$out .= ' /ToUnicode '.($this->n + 1).' 0 R';\n\t\t$out .= ' /DescendantFonts ['.($this->n + 2).' 0 R]';\n\t\t$out .= ' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t\t// ToUnicode map for Identity-H\n\t\t$stream = TCPDF_FONT_DATA::$uni_identity_h;\n\t\t// ToUnicode Object\n\t\t$this->_newobj();\n\t\t$stream = ($this->compress) ? gzcompress($stream) : $stream;\n\t\t$filter = ($this->compress) ? '/Filter /FlateDecode ' : '';\n\t\t$stream = $this->_getrawstream($stream);\n\t\t$this->_out('<<'.$filter.'/Length '.strlen($stream).'>> stream'.\"\\n\".$stream.\"\\n\".'endstream'.\"\\n\".'endobj');\n\t\t// CIDFontType2\n\t\t// A CIDFont whose glyph descriptions are based on TrueType font technology\n\t\t$oid = $this->_newobj();\n\t\t$out = '<< /Type /Font';\n\t\t$out .= ' /Subtype /CIDFontType2';\n\t\t$out .= ' /BaseFont /'.$fontname;\n\t\t// A dictionary containing entries that define the character collection of the CIDFont.\n\t\t$cidinfo = '/Registry '.$this->_datastring($font['cidinfo']['Registry'], $oid);\n\t\t$cidinfo .= ' /Ordering '.$this->_datastring($font['cidinfo']['Ordering'], $oid);\n\t\t$cidinfo .= ' /Supplement '.$font['cidinfo']['Supplement'];\n\t\t$out .= ' /CIDSystemInfo << '.$cidinfo.' >>';\n\t\t$out .= ' /FontDescriptor '.($this->n + 1).' 0 R';\n\t\t$out .= ' /DW '.$font['dw']; // default width\n\t\t$out .= \"\\n\".TCPDF_FONTS::_putfontwidths($font, 0);\n\t\tif (isset($font['ctg']) AND (!TCPDF_STATIC::empty_string($font['ctg']))) {\n\t\t\t$out .= \"\\n\".'/CIDToGIDMap '.($this->n + 2).' 0 R';\n\t\t}\n\t\t$out .= ' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t\t// Font descriptor\n\t\t// A font descriptor describing the CIDFont default metrics other than its glyph widths\n\t\t$this->_newobj();\n\t\t$out = '<< /Type /FontDescriptor';\n\t\t$out .= ' /FontName /'.$fontname;\n\t\tforeach ($font['desc'] as $key => $value) {\n\t\t\tif (is_float($value)) {\n\t\t\t\t$value = sprintf('%F', $value);\n\t\t\t}\n\t\t\t$out .= ' /'.$key.' '.$value;\n\t\t}\n\t\t$fontdir = false;\n\t\tif (!TCPDF_STATIC::empty_string($font['file'])) {\n\t\t\t// A stream containing a TrueType font\n\t\t\t$out .= ' /FontFile2 '.$this->FontFiles[$font['file']]['n'].' 0 R';\n\t\t\t$fontdir = $this->FontFiles[$font['file']]['fontdir'];\n\t\t}\n\t\t$out .= ' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t\tif (isset($font['ctg']) AND (!TCPDF_STATIC::empty_string($font['ctg']))) {\n\t\t\t$this->_newobj();\n\t\t\t// Embed CIDToGIDMap\n\t\t\t// A specification of the mapping from CIDs to glyph indices\n\t\t\t// search and get CTG font file to embedd\n\t\t\t$ctgfile = strtolower($font['ctg']);\n\t\t\t// search and get ctg font file to embedd\n\t\t\t$fontfile = TCPDF_FONTS::getFontFullPath($ctgfile, $fontdir);\n\t\t\tif (TCPDF_STATIC::empty_string($fontfile)) {\n\t\t\t\t$this->Error('Font file not found: '.$ctgfile);\n\t\t\t}\n\t\t\t$stream = $this->_getrawstream(file_get_contents($fontfile));\n\t\t\t$out = '<< /Length '.strlen($stream).'';\n\t\t\tif (substr($fontfile, -2) == '.z') { // check file extension\n\t\t\t\t// Decompresses data encoded using the public-domain\n\t\t\t\t// zlib/deflate compression method, reproducing the\n\t\t\t\t// original text or binary data\n\t\t\t\t$out .= ' /Filter /FlateDecode';\n\t\t\t}\n\t\t\t$out .= ' >>';\n\t\t\t$out .= ' stream'.\"\\n\".$stream.\"\\n\".'endstream';\n\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t$this->_out($out);\n\t\t}\n\t}\n\n\t/**\n\t * Output CID-0 fonts.\n\t * A Type 0 CIDFont contains glyph descriptions based on the Adobe Type 1 font format\n\t * @param array $font font data\n\t * @protected\n\t * @author Andrew Whitehead, Nicola Asuni, Yukihiro Nakadaira\n\t * @since 3.2.000 (2008-06-23)\n\t */\n\tprotected function _putcidfont0($font) {\n\t\t$cidoffset = 0;\n\t\tif (!isset($font['cw'][1])) {\n\t\t\t$cidoffset = 31;\n\t\t}\n\t\tif (isset($font['cidinfo']['uni2cid'])) {\n\t\t\t// convert unicode to cid.\n\t\t\t$uni2cid = $font['cidinfo']['uni2cid'];\n\t\t\t$cw = array();\n\t\t\tforeach ($font['cw'] as $uni => $width) {\n\t\t\t\tif (isset($uni2cid[$uni])) {\n\t\t\t\t\t$cw[($uni2cid[$uni] + $cidoffset)] = $width;\n\t\t\t\t} elseif ($uni < 256) {\n\t\t\t\t\t$cw[$uni] = $width;\n\t\t\t\t} // else unknown character\n\t\t\t}\n\t\t\t$font = array_merge($font, array('cw' => $cw));\n\t\t}\n\t\t$name = $font['name'];\n\t\t$enc = $font['enc'];\n\t\tif ($enc) {\n\t\t\t$longname = $name.'-'.$enc;\n\t\t} else {\n\t\t\t$longname = $name;\n\t\t}\n\t\t$out = $this->_getobj($this->font_obj_ids[$font['fontkey']]).\"\\n\";\n\t\t$out .= '<</Type /Font';\n\t\t$out .= ' /Subtype /Type0';\n\t\t$out .= ' /BaseFont /'.$longname;\n\t\t$out .= ' /Name /F'.$font['i'];\n\t\tif ($enc) {\n\t\t\t$out .= ' /Encoding /'.$enc;\n\t\t}\n\t\t$out .= ' /DescendantFonts ['.($this->n + 1).' 0 R]';\n\t\t$out .= ' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t\t$oid = $this->_newobj();\n\t\t$out = '<</Type /Font';\n\t\t$out .= ' /Subtype /CIDFontType0';\n\t\t$out .= ' /BaseFont /'.$name;\n\t\t$cidinfo = '/Registry '.$this->_datastring($font['cidinfo']['Registry'], $oid);\n\t\t$cidinfo .= ' /Ordering '.$this->_datastring($font['cidinfo']['Ordering'], $oid);\n\t\t$cidinfo .= ' /Supplement '.$font['cidinfo']['Supplement'];\n\t\t$out .= ' /CIDSystemInfo <<'.$cidinfo.'>>';\n\t\t$out .= ' /FontDescriptor '.($this->n + 1).' 0 R';\n\t\t$out .= ' /DW '.$font['dw'];\n\t\t$out .= \"\\n\".TCPDF_FONTS::_putfontwidths($font, $cidoffset);\n\t\t$out .= ' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t\t$this->_newobj();\n\t\t$s = '<</Type /FontDescriptor /FontName /'.$name;\n\t\tforeach ($font['desc'] as $k => $v) {\n\t\t\tif ($k != 'Style') {\n\t\t\t\tif (is_float($v)) {\n\t\t\t\t\t$v = sprintf('%F', $v);\n\t\t\t\t}\n\t\t\t\t$s .= ' /'.$k.' '.$v.'';\n\t\t\t}\n\t\t}\n\t\t$s .= '>>';\n\t\t$s .= \"\\n\".'endobj';\n\t\t$this->_out($s);\n\t}\n\n\t/**\n\t * Output images.\n\t * @protected\n\t */\n\tprotected function _putimages() {\n\t\t$filter = ($this->compress) ? '/Filter /FlateDecode ' : '';\n\t\tforeach ($this->imagekeys as $file) {\n\t\t\t$info = $this->getImageBuffer($file);\n\t\t\t// set object for alternate images array\n\t\t\t$altoid = null;\n\t\t\tif ((!$this->pdfa_mode) AND isset($info['altimgs']) AND !empty($info['altimgs'])) {\n\t\t\t\t$altoid = $this->_newobj();\n\t\t\t\t$out = '[';\n\t\t\t\tforeach ($info['altimgs'] as $altimage) {\n\t\t\t\t\tif (isset($this->xobjects['I'.$altimage[0]]['n'])) {\n\t\t\t\t\t\t$out .= ' << /Image '.$this->xobjects['I'.$altimage[0]]['n'].' 0 R';\n\t\t\t\t\t\t$out .= ' /DefaultForPrinting';\n\t\t\t\t\t\tif ($altimage[1] === true) {\n\t\t\t\t\t\t\t$out .= ' true';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$out .= ' false';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$out .= ' >>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$out .= ' ]';\n\t\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t\t$this->_out($out);\n\t\t\t}\n\t\t\t// set image object\n\t\t\t$oid = $this->_newobj();\n\t\t\t$this->xobjects['I'.$info['i']] = array('n' => $oid);\n\t\t\t$this->setImageSubBuffer($file, 'n', $this->n);\n\t\t\t$out = '<</Type /XObject';\n\t\t\t$out .= ' /Subtype /Image';\n\t\t\t$out .= ' /Width '.$info['w'];\n\t\t\t$out .= ' /Height '.$info['h'];\n\t\t\tif (array_key_exists('masked', $info)) {\n\t\t\t\t$out .= ' /SMask '.($this->n - 1).' 0 R';\n\t\t\t}\n\t\t\t// set color space\n\t\t\t$icc = false;\n\t\t\tif (isset($info['icc']) AND ($info['icc'] !== false)) {\n\t\t\t\t// ICC Colour Space\n\t\t\t\t$icc = true;\n\t\t\t\t$out .= ' /ColorSpace [/ICCBased '.($this->n + 1).' 0 R]';\n\t\t\t} elseif ($info['cs'] == 'Indexed') {\n\t\t\t\t// Indexed Colour Space\n\t\t\t\t$out .= ' /ColorSpace [/Indexed /DeviceRGB '.((strlen($info['pal']) / 3) - 1).' '.($this->n + 1).' 0 R]';\n\t\t\t} else {\n\t\t\t\t// Device Colour Space\n\t\t\t\t$out .= ' /ColorSpace /'.$info['cs'];\n\t\t\t}\n\t\t\tif ($info['cs'] == 'DeviceCMYK') {\n\t\t\t\t$out .= ' /Decode [1 0 1 0 1 0 1 0]';\n\t\t\t}\n\t\t\t$out .= ' /BitsPerComponent '.$info['bpc'];\n\t\t\tif ($altoid > 0) {\n\t\t\t\t// reference to alternate images dictionary\n\t\t\t\t$out .= ' /Alternates '.$altoid.' 0 R';\n\t\t\t}\n\t\t\tif (isset($info['exurl']) AND !empty($info['exurl'])) {\n\t\t\t\t// external stream\n\t\t\t\t$out .= ' /Length 0';\n\t\t\t\t$out .= ' /F << /FS /URL /F '.$this->_datastring($info['exurl'], $oid).' >>';\n\t\t\t\tif (isset($info['f'])) {\n\t\t\t\t\t$out .= ' /FFilter /'.$info['f'];\n\t\t\t\t}\n\t\t\t\t$out .= ' >>';\n\t\t\t\t$out .= ' stream'.\"\\n\".'endstream';\n\t\t\t} else {\n\t\t\t\tif (isset($info['f'])) {\n\t\t\t\t\t$out .= ' /Filter /'.$info['f'];\n\t\t\t\t}\n\t\t\t\tif (isset($info['parms'])) {\n\t\t\t\t\t$out .= ' '.$info['parms'];\n\t\t\t\t}\n\t\t\t\tif (isset($info['trns']) AND is_array($info['trns'])) {\n\t\t\t\t\t$trns = '';\n\t\t\t\t\t$count_info = count($info['trns']);\n\t\t\t\t\tif ($info['cs'] == 'Indexed') {\n\t\t\t\t\t\t$maxval =(pow(2, $info['bpc']) - 1);\n\t\t\t\t\t\tfor ($i = 0; $i < $count_info; ++$i) {\n\t\t\t\t\t\t\tif (($info['trns'][$i] != 0) AND ($info['trns'][$i] != $maxval)) {\n\t\t\t\t\t\t\t\t// this is not a binary type mask @TODO: create a SMask\n\t\t\t\t\t\t\t\t$trns = '';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} elseif (empty($trns) AND ($info['trns'][$i] == 0)) {\n\t\t\t\t\t\t\t\t// store the first fully transparent value\n\t\t\t\t\t\t\t\t$trns .= $i.' '.$i.' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// grayscale or RGB\n\t\t\t\t\t\tfor ($i = 0; $i < $count_info; ++$i) {\n\t\t\t\t\t\t\tif ($info['trns'][$i] == 0) {\n\t\t\t\t\t\t\t\t$trns .= $info['trns'][$i].' '.$info['trns'][$i].' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Colour Key Masking\n\t\t\t\t\tif (!empty($trns)) {\n\t\t\t\t\t\t$out .= ' /Mask ['.$trns.']';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$stream = $this->_getrawstream($info['data']);\n\t\t\t\t$out .= ' /Length '.strlen($stream).' >>';\n\t\t\t\t$out .= ' stream'.\"\\n\".$stream.\"\\n\".'endstream';\n\t\t\t}\n\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t$this->_out($out);\n\t\t\tif ($icc) {\n\t\t\t\t// ICC colour profile\n\t\t\t\t$this->_newobj();\n\t\t\t\t$icc = ($this->compress) ? gzcompress($info['icc']) : $info['icc'];\n\t\t\t\t$icc = $this->_getrawstream($icc);\n\t\t\t\t$this->_out('<</N '.$info['ch'].' /Alternate /'.$info['cs'].' '.$filter.'/Length '.strlen($icc).'>> stream'.\"\\n\".$icc.\"\\n\".'endstream'.\"\\n\".'endobj');\n\t\t\t} elseif ($info['cs'] == 'Indexed') {\n\t\t\t\t// colour palette\n\t\t\t\t$this->_newobj();\n\t\t\t\t$pal = ($this->compress) ? gzcompress($info['pal']) : $info['pal'];\n\t\t\t\t$pal = $this->_getrawstream($pal);\n\t\t\t\t$this->_out('<<'.$filter.'/Length '.strlen($pal).'>> stream'.\"\\n\".$pal.\"\\n\".'endstream'.\"\\n\".'endobj');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Output Form XObjects Templates.\n\t * @author Nicola Asuni\n\t * @since 5.8.017 (2010-08-24)\n\t * @protected\n\t * @see startTemplate(), endTemplate(), printTemplate()\n\t */\n\tprotected function _putxobjects() {\n\t\tforeach ($this->xobjects as $key => $data) {\n\t\t\tif (isset($data['outdata'])) {\n\t\t\t\t$stream = str_replace($this->epsmarker, '', trim($data['outdata']));\n\t\t\t\t$out = $this->_getobj($data['n']).\"\\n\";\n\t\t\t\t$out .= '<<';\n\t\t\t\t$out .= ' /Type /XObject';\n\t\t\t\t$out .= ' /Subtype /Form';\n\t\t\t\t$out .= ' /FormType 1';\n\t\t\t\tif ($this->compress) {\n\t\t\t\t\t$stream = gzcompress($stream);\n\t\t\t\t\t$out .= ' /Filter /FlateDecode';\n\t\t\t\t}\n\t\t\t\t$out .= sprintf(' /BBox [%F %F %F %F]', ($data['x'] * $this->k), (-$data['y'] * $this->k), (($data['w'] + $data['x']) * $this->k), (($data['h'] - $data['y']) * $this->k));\n\t\t\t\t$out .= ' /Matrix [1 0 0 1 0 0]';\n\t\t\t\t$out .= ' /Resources <<';\n\t\t\t\t$out .= ' /ProcSet [/PDF /Text /ImageB /ImageC /ImageI]';\n\t\t\t\tif (!$this->pdfa_mode || $this->pdfa_version >= 2) {\n\t\t\t\t\t// transparency\n\t\t\t\t\tif (isset($data['extgstates']) AND !empty($data['extgstates'])) {\n\t\t\t\t\t\t$out .= ' /ExtGState <<';\n\t\t\t\t\t\tforeach ($data['extgstates'] as $k => $extgstate) {\n\t\t\t\t\t\t\tif (isset($this->extgstates[$k]['name'])) {\n\t\t\t\t\t\t\t\t$out .= ' /'.$this->extgstates[$k]['name'];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$out .= ' /GS'.$k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$out .= ' '.$this->extgstates[$k]['n'].' 0 R';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$out .= ' >>';\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($data['gradients']) AND !empty($data['gradients'])) {\n\t\t\t\t\t\t$gp = '';\n\t\t\t\t\t\t$gs = '';\n\t\t\t\t\t\tforeach ($data['gradients'] as $id => $grad) {\n\t\t\t\t\t\t\t// gradient patterns\n\t\t\t\t\t\t\t$gp .= ' /p'.$id.' '.$this->gradients[$id]['pattern'].' 0 R';\n\t\t\t\t\t\t\t// gradient shadings\n\t\t\t\t\t\t\t$gs .= ' /Sh'.$id.' '.$this->gradients[$id]['id'].' 0 R';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$out .= ' /Pattern <<'.$gp.' >>';\n\t\t\t\t\t\t$out .= ' /Shading <<'.$gs.' >>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// spot colors\n\t\t\t\tif (isset($data['spot_colors']) AND !empty($data['spot_colors'])) {\n\t\t\t\t\t$out .= ' /ColorSpace <<';\n\t\t\t\t\tforeach ($data['spot_colors'] as $name => $color) {\n\t\t\t\t\t\t$out .= ' /CS'.$color['i'].' '.$this->spot_colors[$name]['n'].' 0 R';\n\t\t\t\t\t}\n\t\t\t\t\t$out .= ' >>';\n\t\t\t\t}\n\t\t\t\t// fonts\n\t\t\t\tif (!empty($data['fonts'])) {\n\t\t\t\t\t$out .= ' /Font <<';\n\t\t\t\t\tforeach ($data['fonts'] as $fontkey => $fontid) {\n\t\t\t\t\t\t$out .= ' /F'.$fontid.' '.$this->font_obj_ids[$fontkey].' 0 R';\n\t\t\t\t\t}\n\t\t\t\t\t$out .= ' >>';\n\t\t\t\t}\n\t\t\t\t// images or nested xobjects\n\t\t\t\tif (!empty($data['images']) OR !empty($data['xobjects'])) {\n\t\t\t\t\t$out .= ' /XObject <<';\n\t\t\t\t\tforeach ($data['images'] as $imgid) {\n\t\t\t\t\t\t$out .= ' /I'.$imgid.' '.$this->xobjects['I'.$imgid]['n'].' 0 R';\n\t\t\t\t\t}\n\t\t\t\t\tforeach ($data['xobjects'] as $sub_id => $sub_objid) {\n\t\t\t\t\t\t$out .= ' /'.$sub_id.' '.$sub_objid['n'].' 0 R';\n\t\t\t\t\t}\n\t\t\t\t\t$out .= ' >>';\n\t\t\t\t}\n\t\t\t\t$out .= ' >>'; //end resources\n\t\t\t\tif (isset($data['group']) AND ($data['group'] !== false)) {\n\t\t\t\t\t// set transparency group\n\t\t\t\t\t$out .= ' /Group << /Type /Group /S /Transparency';\n\t\t\t\t\tif (is_array($data['group'])) {\n\t\t\t\t\t\tif (isset($data['group']['CS']) AND !empty($data['group']['CS'])) {\n\t\t\t\t\t\t\t$out .= ' /CS /'.$data['group']['CS'];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isset($data['group']['I'])) {\n\t\t\t\t\t\t\t$out .= ' /I /'.($data['group']['I']===true?'true':'false');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isset($data['group']['K'])) {\n\t\t\t\t\t\t\t$out .= ' /K /'.($data['group']['K']===true?'true':'false');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$out .= ' >>';\n\t\t\t\t}\n\t\t\t\t$stream = $this->_getrawstream($stream, $data['n']);\n\t\t\t\t$out .= ' /Length '.strlen($stream);\n\t\t\t\t$out .= ' >>';\n\t\t\t\t$out .= ' stream'.\"\\n\".$stream.\"\\n\".'endstream';\n\t\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t\t$this->_out($out);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Output Spot Colors Resources.\n\t * @protected\n\t * @since 4.0.024 (2008-09-12)\n\t */\n\tprotected function _putspotcolors() {\n\t\tforeach ($this->spot_colors as $name => $color) {\n\t\t\t$this->_newobj();\n\t\t\t$this->spot_colors[$name]['n'] = $this->n;\n\t\t\t$out = '[/Separation /'.str_replace(' ', '#20', $name);\n\t\t\t$out .= ' /DeviceCMYK <<';\n\t\t\t$out .= ' /Range [0 1 0 1 0 1 0 1] /C0 [0 0 0 0]';\n\t\t\t$out .= ' '.sprintf('/C1 [%F %F %F %F] ', ($color['C'] / 100), ($color['M'] / 100), ($color['Y'] / 100), ($color['K'] / 100));\n\t\t\t$out .= ' /FunctionType 2 /Domain [0 1] /N 1>>]';\n\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t$this->_out($out);\n\t\t}\n\t}\n\n\t/**\n\t * Return XObjects Dictionary.\n\t * @return string XObjects dictionary\n\t * @protected\n\t * @since 5.8.014 (2010-08-23)\n\t */\n\tprotected function _getxobjectdict() {\n\t\t$out = '';\n\t\tforeach ($this->xobjects as $id => $objid) {\n\t\t\t$out .= ' /'.$id.' '.$objid['n'].' 0 R';\n\t\t}\n\t\treturn $out;\n\t}\n\n\t/**\n\t * Output Resources Dictionary.\n\t * @protected\n\t */\n\tprotected function _putresourcedict() {\n\t\t$out = $this->_getobj(2).\"\\n\";\n\t\t$out .= '<< /ProcSet [/PDF /Text /ImageB /ImageC /ImageI]';\n\t\t$out .= ' /Font <<';\n\t\tforeach ($this->fontkeys as $fontkey) {\n\t\t\t$font = $this->getFontBuffer($fontkey);\n\t\t\t$out .= ' /F'.$font['i'].' '.$font['n'].' 0 R';\n\t\t}\n\t\t$out .= ' >>';\n\t\t$out .= ' /XObject <<';\n\t\t$out .= $this->_getxobjectdict();\n\t\t$out .= ' >>';\n\t\t// layers\n\t\tif (!empty($this->pdflayers)) {\n\t\t\t$out .= ' /Properties <<';\n\t\t\tforeach ($this->pdflayers as $layer) {\n\t\t\t\t$out .= ' /'.$layer['layer'].' '.$layer['objid'].' 0 R';\n\t\t\t}\n\t\t\t$out .= ' >>';\n\t\t}\n\t\tif (!$this->pdfa_mode || $this->pdfa_version >= 2) {\n\t\t\t// transparency\n\t\t\tif (isset($this->extgstates) AND !empty($this->extgstates)) {\n\t\t\t\t$out .= ' /ExtGState <<';\n\t\t\t\tforeach ($this->extgstates as $k => $extgstate) {\n\t\t\t\t\tif (isset($extgstate['name'])) {\n\t\t\t\t\t\t$out .= ' /'.$extgstate['name'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$out .= ' /GS'.$k;\n\t\t\t\t\t}\n\t\t\t\t\t$out .= ' '.$extgstate['n'].' 0 R';\n\t\t\t\t}\n\t\t\t\t$out .= ' >>';\n\t\t\t}\n\t\t\tif (isset($this->gradients) AND !empty($this->gradients)) {\n\t\t\t\t$gp = '';\n\t\t\t\t$gs = '';\n\t\t\t\tforeach ($this->gradients as $id => $grad) {\n\t\t\t\t\t// gradient patterns\n\t\t\t\t\t$gp .= ' /p'.$id.' '.$grad['pattern'].' 0 R';\n\t\t\t\t\t// gradient shadings\n\t\t\t\t\t$gs .= ' /Sh'.$id.' '.$grad['id'].' 0 R';\n\t\t\t\t}\n\t\t\t\t$out .= ' /Pattern <<'.$gp.' >>';\n\t\t\t\t$out .= ' /Shading <<'.$gs.' >>';\n\t\t\t}\n\t\t}\n\t\t// spot colors\n\t\tif (isset($this->spot_colors) AND !empty($this->spot_colors)) {\n\t\t\t$out .= ' /ColorSpace <<';\n\t\t\tforeach ($this->spot_colors as $color) {\n\t\t\t\t$out .= ' /CS'.$color['i'].' '.$color['n'].' 0 R';\n\t\t\t}\n\t\t\t$out .= ' >>';\n\t\t}\n\t\t$out .= ' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t}\n\n\t/**\n\t * Output Resources.\n\t * @protected\n\t */\n\tprotected function _putresources() {\n\t\t$this->_putextgstates();\n\t\t$this->_putocg();\n\t\t$this->_putfonts();\n\t\t$this->_putimages();\n\t\t$this->_putspotcolors();\n\t\t$this->_putshaders();\n\t\t$this->_putxobjects();\n\t\t$this->_putresourcedict();\n\t\t$this->_putdests();\n\t\t$this->_putEmbeddedFiles();\n\t\t$this->_putannotsobjs();\n\t\t$this->_putjavascript();\n\t\t$this->_putbookmarks();\n\t\t$this->_putencryption();\n\t}\n\n\t/**\n\t * Adds some Metadata information (Document Information Dictionary)\n\t * (see Chapter 14.3.3 Document Information Dictionary of PDF32000_2008.pdf Reference)\n\t * @return int object id\n\t * @protected\n\t */\n\tprotected function _putinfo() {\n\t\t$oid = $this->_newobj();\n\t\t$out = '<<';\n\t\t// store current isunicode value\n\t\t$prev_isunicode = $this->isunicode;\n\t\tif ($this->docinfounicode) {\n\t\t\t$this->isunicode = true;\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($this->title)) {\n\t\t\t// The document's title.\n\t\t\t$out .= ' /Title '.$this->_textstring($this->title, $oid);\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($this->author)) {\n\t\t\t// The name of the person who created the document.\n\t\t\t$out .= ' /Author '.$this->_textstring($this->author, $oid);\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($this->subject)) {\n\t\t\t// The subject of the document.\n\t\t\t$out .= ' /Subject '.$this->_textstring($this->subject, $oid);\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($this->keywords)) {\n\t\t\t// Keywords associated with the document.\n\t\t\t$out .= ' /Keywords '.$this->_textstring($this->keywords, $oid);\n\t\t}\n\t\tif (!TCPDF_STATIC::empty_string($this->creator)) {\n\t\t\t// If the document was converted to PDF from another format, the name of the conforming product that created the original document from which it was converted.\n\t\t\t$out .= ' /Creator '.$this->_textstring($this->creator, $oid);\n\t\t}\n\t\t// restore previous isunicode value\n\t\t$this->isunicode = $prev_isunicode;\n\t\t// default producer\n\t\t$out .= ' /Producer '.$this->_textstring(TCPDF_STATIC::getTCPDFProducer(), $oid);\n\t\t// The date and time the document was created, in human-readable form\n\t\t$out .= ' /CreationDate '.$this->_datestring(0, $this->doc_creation_timestamp);\n\t\t// The date and time the document was most recently modified, in human-readable form\n\t\t$out .= ' /ModDate '.$this->_datestring(0, $this->doc_modification_timestamp);\n\t\t// A name object indicating whether the document has been modified to include trapping information\n\t\t$out .= ' /Trapped /False';\n\t\t$out .= ' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t\treturn $oid;\n\t}\n\n\t/**\n\t * Set additional XMP data to be added on the default XMP data just before the end of \"x:xmpmeta\" tag.\n\t * IMPORTANT: This data is added as-is without controls, so you have to validate your data before using this method!\n\t * @param string $xmp Custom XMP data.\n\t * @since 5.9.128 (2011-10-06)\n\t * @public\n\t */\n\tpublic function setExtraXMP($xmp) {\n\t\t$this->custom_xmp = $xmp;\n\t}\n\n\t/**\n\t * Set additional XMP data to be added on the default XMP data just before the end of \"rdf:RDF\" tag.\n\t * IMPORTANT: This data is added as-is without controls, so you have to validate your data before using this method!\n\t * @param string $xmp Custom XMP RDF data.\n\t * @since 6.3.0 (2019-09-19)\n\t * @public\n\t */\n\tpublic function setExtraXMPRDF($xmp) {\n\t\t$this->custom_xmp_rdf = $xmp;\n\t}\n\n\t/**\n\t * Put XMP data object and return ID.\n\t * @return int The object ID.\n\t * @since 5.9.121 (2011-09-28)\n\t * @protected\n\t */\n\tprotected function _putXMP() {\n\t\t$oid = $this->_newobj();\n\t\t// store current isunicode value\n\t\t$prev_isunicode = $this->isunicode;\n\t\t$this->isunicode = true;\n\t\t$prev_encrypted = $this->encrypted;\n\t\t$this->encrypted = false;\n\t\t// set XMP data\n\t\t$xmp = '<?xpacket begin=\"'.TCPDF_FONTS::unichr(0xfeff, $this->isunicode).'\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?>'.\"\\n\";\n\t\t$xmp .= '<x:xmpmeta xmlns:x=\"adobe:ns:meta/\" x:xmptk=\"Adobe XMP Core 4.2.1-c043 52.372728, 2009/01/18-15:08:04\">'.\"\\n\";\n\t\t$xmp .= \"\\t\".'<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\".'<rdf:Description rdf:about=\"\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<dc:format>application/pdf</dc:format>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<dc:title>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\".'<rdf:Alt>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\".'<rdf:li xml:lang=\"x-default\">'.TCPDF_STATIC::_escapeXML($this->title).'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\".'</rdf:Alt>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'</dc:title>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<dc:creator>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\".'<rdf:Seq>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\".'<rdf:li>'.TCPDF_STATIC::_escapeXML($this->author).'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\".'</rdf:Seq>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'</dc:creator>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<dc:description>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\".'<rdf:Alt>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\".'<rdf:li xml:lang=\"x-default\">'.TCPDF_STATIC::_escapeXML($this->subject).'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\".'</rdf:Alt>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'</dc:description>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<dc:subject>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\".'<rdf:Bag>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\".'<rdf:li>'.TCPDF_STATIC::_escapeXML($this->keywords).'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\".'</rdf:Bag>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'</dc:subject>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\".'</rdf:Description>'.\"\\n\";\n\t\t// convert doc creation date format\n\t\t$dcdate = TCPDF_STATIC::getFormattedDate($this->doc_creation_timestamp);\n\t\t$doccreationdate = substr($dcdate, 0, 4).'-'.substr($dcdate, 4, 2).'-'.substr($dcdate, 6, 2);\n\t\t$doccreationdate .= 'T'.substr($dcdate, 8, 2).':'.substr($dcdate, 10, 2).':'.substr($dcdate, 12, 2);\n\t\t$doccreationdate .= substr($dcdate, 14, 3).':'.substr($dcdate, 18, 2);\n\t\t$doccreationdate = TCPDF_STATIC::_escapeXML($doccreationdate);\n\t\t// convert doc modification date format\n\t\t$dmdate = TCPDF_STATIC::getFormattedDate($this->doc_modification_timestamp);\n\t\t$docmoddate = substr($dmdate, 0, 4).'-'.substr($dmdate, 4, 2).'-'.substr($dmdate, 6, 2);\n\t\t$docmoddate .= 'T'.substr($dmdate, 8, 2).':'.substr($dmdate, 10, 2).':'.substr($dmdate, 12, 2);\n\t\t$docmoddate .= substr($dmdate, 14, 3).':'.substr($dmdate, 18, 2);\n\t\t$docmoddate = TCPDF_STATIC::_escapeXML($docmoddate);\n\t\t$xmp .= \"\\t\\t\".'<rdf:Description rdf:about=\"\" xmlns:xmp=\"http://ns.adobe.com/xap/1.0/\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<xmp:CreateDate>'.$doccreationdate.'</xmp:CreateDate>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<xmp:CreatorTool>'.$this->creator.'</xmp:CreatorTool>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<xmp:ModifyDate>'.$docmoddate.'</xmp:ModifyDate>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<xmp:MetadataDate>'.$doccreationdate.'</xmp:MetadataDate>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\".'</rdf:Description>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\".'<rdf:Description rdf:about=\"\" xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<pdf:Keywords>'.TCPDF_STATIC::_escapeXML($this->keywords).'</pdf:Keywords>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<pdf:Producer>'.TCPDF_STATIC::_escapeXML(TCPDF_STATIC::getTCPDFProducer()).'</pdf:Producer>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\".'</rdf:Description>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\".'<rdf:Description rdf:about=\"\" xmlns:xmpMM=\"http://ns.adobe.com/xap/1.0/mm/\">'.\"\\n\";\n\t\t$uuid = 'uuid:'.substr($this->file_id, 0, 8).'-'.substr($this->file_id, 8, 4).'-'.substr($this->file_id, 12, 4).'-'.substr($this->file_id, 16, 4).'-'.substr($this->file_id, 20, 12);\n\t\t$xmp .= \"\\t\\t\\t\".'<xmpMM:DocumentID>'.$uuid.'</xmpMM:DocumentID>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<xmpMM:InstanceID>'.$uuid.'</xmpMM:InstanceID>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\".'</rdf:Description>'.\"\\n\";\n\t\tif ($this->pdfa_mode) {\n\t\t\t$xmp .= \"\\t\\t\".'<rdf:Description rdf:about=\"\" xmlns:pdfaid=\"http://www.aiim.org/pdfa/ns/id/\">'.\"\\n\";\n\t\t\t$xmp .= \"\\t\\t\\t\".'<pdfaid:part>'.$this->pdfa_version.'</pdfaid:part>'.\"\\n\";\n\t\t\t$xmp .= \"\\t\\t\\t\".'<pdfaid:conformance>B</pdfaid:conformance>'.\"\\n\";\n\t\t\t$xmp .= \"\\t\\t\".'</rdf:Description>'.\"\\n\";\n\t\t}\n\t\t// XMP extension schemas\n\t\t$xmp .= \"\\t\\t\".'<rdf:Description rdf:about=\"\" xmlns:pdfaExtension=\"http://www.aiim.org/pdfa/ns/extension/\" xmlns:pdfaSchema=\"http://www.aiim.org/pdfa/ns/schema#\" xmlns:pdfaProperty=\"http://www.aiim.org/pdfa/ns/property#\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'<pdfaExtension:schemas>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\".'<rdf:Bag>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\".'<rdf:li rdf:parseType=\"Resource\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:namespaceURI>http://ns.adobe.com/pdf/1.3/</pdfaSchema:namespaceURI>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:prefix>pdf</pdfaSchema:prefix>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:schema>Adobe PDF Schema</pdfaSchema:schema>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:property>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\".'<rdf:Seq>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\".'<rdf:li rdf:parseType=\"Resource\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:category>internal</pdfaProperty:category>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:description>Adobe PDF Schema</pdfaProperty:description>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:name>InstanceID</pdfaProperty:name>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:valueType>URI</pdfaProperty:valueType>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\".'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\".'</rdf:Seq>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'</pdfaSchema:property>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\".'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\".'<rdf:li rdf:parseType=\"Resource\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:namespaceURI>http://ns.adobe.com/xap/1.0/mm/</pdfaSchema:namespaceURI>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:prefix>xmpMM</pdfaSchema:prefix>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:schema>XMP Media Management Schema</pdfaSchema:schema>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:property>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\".'<rdf:Seq>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\".'<rdf:li rdf:parseType=\"Resource\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:category>internal</pdfaProperty:category>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:description>UUID based identifier for specific incarnation of a document</pdfaProperty:description>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:name>InstanceID</pdfaProperty:name>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:valueType>URI</pdfaProperty:valueType>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\".'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\".'</rdf:Seq>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'</pdfaSchema:property>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\".'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\".'<rdf:li rdf:parseType=\"Resource\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:namespaceURI>http://www.aiim.org/pdfa/ns/id/</pdfaSchema:namespaceURI>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:prefix>pdfaid</pdfaSchema:prefix>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:schema>PDF/A ID Schema</pdfaSchema:schema>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'<pdfaSchema:property>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\".'<rdf:Seq>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\".'<rdf:li rdf:parseType=\"Resource\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:category>internal</pdfaProperty:category>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:description>Part of PDF/A standard</pdfaProperty:description>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:name>part</pdfaProperty:name>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:valueType>Integer</pdfaProperty:valueType>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\".'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\".'<rdf:li rdf:parseType=\"Resource\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:category>internal</pdfaProperty:category>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:description>Amendment of PDF/A standard</pdfaProperty:description>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:name>amd</pdfaProperty:name>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:valueType>Text</pdfaProperty:valueType>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\".'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\".'<rdf:li rdf:parseType=\"Resource\">'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:category>internal</pdfaProperty:category>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:description>Conformance level of PDF/A standard</pdfaProperty:description>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:name>conformance</pdfaProperty:name>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\".'<pdfaProperty:valueType>Text</pdfaProperty:valueType>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\\t\".'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\\t\".'</rdf:Seq>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\\t\".'</pdfaSchema:property>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\\t\".'</rdf:li>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\\t\".'</rdf:Bag>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\\t\".'</pdfaExtension:schemas>'.\"\\n\";\n\t\t$xmp .= \"\\t\\t\".'</rdf:Description>'.\"\\n\";\n\t\t$xmp .= $this->custom_xmp_rdf;\n\t\t$xmp .= \"\\t\".'</rdf:RDF>'.\"\\n\";\n\t\t$xmp .= $this->custom_xmp;\n\t\t$xmp .= '</x:xmpmeta>'.\"\\n\";\n\t\t$xmp .= '<?xpacket end=\"w\"?>';\n\t\t$out = '<< /Type /Metadata /Subtype /XML /Length '.strlen($xmp).' >> stream'.\"\\n\".$xmp.\"\\n\".'endstream'.\"\\n\".'endobj';\n\t\t// restore previous isunicode value\n\t\t$this->isunicode = $prev_isunicode;\n\t\t$this->encrypted = $prev_encrypted;\n\t\t$this->_out($out);\n\t\treturn $oid;\n\t}\n\n\t/**\n\t * Output Catalog.\n\t * @return int object id\n\t * @protected\n\t */\n\tprotected function _putcatalog() {\n\t\t// put XMP\n\t\t$xmpobj = $this->_putXMP();\n\t\t// if required, add standard sRGB ICC colour profile\n\t\tif ($this->pdfa_mode OR $this->force_srgb) {\n\t\t\t$iccobj = $this->_newobj();\n\t\t\t$icc = file_get_contents(dirname(__FILE__).'/include/sRGB.icc');\n\t\t\t$filter = '';\n\t\t\tif ($this->compress) {\n\t\t\t\t$filter = ' /Filter /FlateDecode';\n\t\t\t\t$icc = gzcompress($icc);\n\t\t\t}\n\t\t\t$icc = $this->_getrawstream($icc);\n\t\t\t$this->_out('<</N 3 '.$filter.'/Length '.strlen($icc).'>> stream'.\"\\n\".$icc.\"\\n\".'endstream'.\"\\n\".'endobj');\n\t\t}\n\t\t// start catalog\n\t\t$oid = $this->_newobj();\n\t\t$out = '<< /Type /Catalog';\n\t\t$out .= ' /Version /'.$this->PDFVersion;\n\t\t//$out .= ' /Extensions <<>>';\n\t\t$out .= ' /Pages 1 0 R';\n\t\t//$out .= ' /PageLabels ' //...;\n\t\t$out .= ' /Names <<';\n\t\tif ((!$this->pdfa_mode) AND !empty($this->n_js)) {\n\t\t\t$out .= ' /JavaScript '.$this->n_js;\n\t\t}\n\t\tif (!empty($this->efnames)) {\n\t\t\t$out .= ' /EmbeddedFiles <</Names [';\n\t\t\tforeach ($this->efnames AS $fn => $fref) {\n\t\t\t\t$out .= ' '.$this->_datastring($fn).' '.$fref;\n\t\t\t}\n\t\t\t$out .= ' ]>>';\n\t\t}\n\t\t$out .= ' >>';\n\t\tif (!empty($this->dests)) {\n\t\t\t$out .= ' /Dests '.($this->n_dests).' 0 R';\n\t\t}\n\t\t$out .= $this->_putviewerpreferences();\n\t\tif (isset($this->LayoutMode) AND (!TCPDF_STATIC::empty_string($this->LayoutMode))) {\n\t\t\t$out .= ' /PageLayout /'.$this->LayoutMode;\n\t\t}\n\t\tif (isset($this->PageMode) AND (!TCPDF_STATIC::empty_string($this->PageMode))) {\n\t\t\t$out .= ' /PageMode /'.$this->PageMode;\n\t\t}\n\t\tif (count($this->outlines) > 0) {\n\t\t\t$out .= ' /Outlines '.$this->OutlineRoot.' 0 R';\n\t\t\t$out .= ' /PageMode /UseOutlines';\n\t\t}\n\t\t//$out .= ' /Threads []';\n\t\tif ($this->ZoomMode == 'fullpage') {\n\t\t\t$out .= ' /OpenAction ['.$this->page_obj_id[1].' 0 R /Fit]';\n\t\t} elseif ($this->ZoomMode == 'fullwidth') {\n\t\t\t$out .= ' /OpenAction ['.$this->page_obj_id[1].' 0 R /FitH null]';\n\t\t} elseif ($this->ZoomMode == 'real') {\n\t\t\t$out .= ' /OpenAction ['.$this->page_obj_id[1].' 0 R /XYZ null null 1]';\n\t\t} elseif (!is_string($this->ZoomMode)) {\n\t\t\t$out .= sprintf(' /OpenAction ['.$this->page_obj_id[1].' 0 R /XYZ null null %F]', ($this->ZoomMode / 100));\n\t\t}\n\t\t//$out .= ' /AA <<>>';\n\t\t//$out .= ' /URI <<>>';\n\t\t$out .= ' /Metadata '.$xmpobj.' 0 R';\n\t\t//$out .= ' /StructTreeRoot <<>>';\n\t\t//$out .= ' /MarkInfo <<>>';\n\t\tif (isset($this->l['a_meta_language'])) {\n\t\t\t$out .= ' /Lang '.$this->_textstring($this->l['a_meta_language'], $oid);\n\t\t}\n\t\t//$out .= ' /SpiderInfo <<>>';\n\t\t// set OutputIntent to sRGB IEC61966-2.1 if required\n\t\tif ($this->pdfa_mode OR $this->force_srgb) {\n\t\t\t$out .= ' /OutputIntents [<<';\n\t\t\t$out .= ' /Type /OutputIntent';\n\t\t\t$out .= ' /S /GTS_PDFA1';\n\t\t\t$out .= ' /OutputCondition '.$this->_textstring('sRGB IEC61966-2.1', $oid);\n\t\t\t$out .= ' /OutputConditionIdentifier '.$this->_textstring('sRGB IEC61966-2.1', $oid);\n\t\t\t$out .= ' /RegistryName '.$this->_textstring('http://www.color.org', $oid);\n\t\t\t$out .= ' /Info '.$this->_textstring('sRGB IEC61966-2.1', $oid);\n\t\t\t$out .= ' /DestOutputProfile '.$iccobj.' 0 R';\n\t\t\t$out .= ' >>]';\n\t\t}\n\t\t//$out .= ' /PieceInfo <<>>';\n\t\tif (!empty($this->pdflayers)) {\n\t\t\t$lyrobjs = '';\n\t\t\t$lyrobjs_off = '';\n\t\t\t$lyrobjs_lock = '';\n\t\t\tforeach ($this->pdflayers as $layer) {\n\t\t\t\t$layer_obj_ref = ' '.$layer['objid'].' 0 R';\n\t\t\t\t$lyrobjs .= $layer_obj_ref;\n\t\t\t\tif ($layer['view'] === false) {\n\t\t\t\t\t$lyrobjs_off .= $layer_obj_ref;\n\t\t\t\t}\n\t\t\t\tif ($layer['lock']) {\n\t\t\t\t\t$lyrobjs_lock .= $layer_obj_ref;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$out .= ' /OCProperties << /OCGs ['.$lyrobjs.']';\n\t\t\t$out .= ' /D <<';\n\t\t\t$out .= ' /Name '.$this->_textstring('Layers', $oid);\n\t\t\t$out .= ' /Creator '.$this->_textstring('TCPDF', $oid);\n\t\t\t$out .= ' /BaseState /ON';\n\t\t\t$out .= ' /OFF ['.$lyrobjs_off.']';\n\t\t\t$out .= ' /Locked ['.$lyrobjs_lock.']';\n\t\t\t$out .= ' /Intent /View';\n\t\t\t$out .= ' /AS [';\n\t\t\t$out .= ' << /Event /Print /OCGs ['.$lyrobjs.'] /Category [/Print] >>';\n\t\t\t$out .= ' << /Event /View /OCGs ['.$lyrobjs.'] /Category [/View] >>';\n\t\t\t$out .= ' ]';\n\t\t\t$out .= ' /Order ['.$lyrobjs.']';\n\t\t\t$out .= ' /ListMode /AllPages';\n\t\t\t//$out .= ' /RBGroups ['..']';\n\t\t\t//$out .= ' /Locked ['..']';\n\t\t\t$out .= ' >>';\n\t\t\t$out .= ' >>';\n\t\t}\n\t\t// AcroForm\n\t\tif (!empty($this->form_obj_id)\n\t\t\tOR ($this->sign AND isset($this->signature_data['cert_type']))\n\t\t\tOR !empty($this->empty_signature_appearance)) {\n\t\t\t$out .= ' /AcroForm <<';\n\t\t\t$objrefs = '';\n\t\t\tif ($this->sign AND isset($this->signature_data['cert_type'])) {\n\t\t\t\t// set reference for signature object\n\t\t\t\t$objrefs .= $this->sig_obj_id.' 0 R';\n\t\t\t}\n\t\t\tif (!empty($this->empty_signature_appearance)) {\n\t\t\t\tforeach ($this->empty_signature_appearance as $esa) {\n\t\t\t\t\t// set reference for empty signature objects\n\t\t\t\t\t$objrefs .= ' '.$esa['objid'].' 0 R';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!empty($this->form_obj_id)) {\n\t\t\t\tforeach($this->form_obj_id as $objid) {\n\t\t\t\t\t$objrefs .= ' '.$objid.' 0 R';\n\t\t\t\t}\n\t\t\t}\n\t\t\t$out .= ' /Fields ['.$objrefs.']';\n\t\t\t// It's better to turn off this value and set the appearance stream for each annotation (/AP) to avoid conflicts with signature fields.\n\t\t\tif (empty($this->signature_data['approval']) OR ($this->signature_data['approval'] != 'A')) {\n\t\t\t\t$out .= ' /NeedAppearances false';\n\t\t\t}\n\t\t\tif ($this->sign AND isset($this->signature_data['cert_type'])) {\n\t\t\t\tif ($this->signature_data['cert_type'] > 0) {\n\t\t\t\t\t$out .= ' /SigFlags 3';\n\t\t\t\t} else {\n\t\t\t\t\t$out .= ' /SigFlags 1';\n\t\t\t\t}\n\t\t\t}\n\t\t\t//$out .= ' /CO ';\n\t\t\tif (isset($this->annotation_fonts) AND !empty($this->annotation_fonts)) {\n\t\t\t\t$out .= ' /DR <<';\n\t\t\t\t$out .= ' /Font <<';\n\t\t\t\tforeach ($this->annotation_fonts as $fontkey => $fontid) {\n\t\t\t\t\t$out .= ' /F'.$fontid.' '.$this->font_obj_ids[$fontkey].' 0 R';\n\t\t\t\t}\n\t\t\t\t$out .= ' >> >>';\n\t\t\t}\n\t\t\t$font = $this->getFontBuffer((($this->pdfa_mode) ? 'pdfa' : '') .'helvetica');\n\t\t\t$out .= ' /DA ' . $this->_datastring('/F'.$font['i'].' 0 Tf 0 g');\n\t\t\t$out .= ' /Q '.(($this->rtl)?'2':'0');\n\t\t\t//$out .= ' /XFA ';\n\t\t\t$out .= ' >>';\n\t\t\t// signatures\n\t\t\tif ($this->sign AND isset($this->signature_data['cert_type'])\n\t\t\t\tAND (empty($this->signature_data['approval']) OR ($this->signature_data['approval'] != 'A'))) {\n\t\t\t\tif ($this->signature_data['cert_type'] > 0) {\n\t\t\t\t\t$out .= ' /Perms << /DocMDP '.($this->sig_obj_id + 1).' 0 R >>';\n\t\t\t\t} else {\n\t\t\t\t\t$out .= ' /Perms << /UR3 '.($this->sig_obj_id + 1).' 0 R >>';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//$out .= ' /Legal <<>>';\n\t\t//$out .= ' /Requirements []';\n\t\t//$out .= ' /Collection <<>>';\n\t\t//$out .= ' /NeedsRendering true';\n\t\t$out .= ' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t\treturn $oid;\n\t}\n\n\t/**\n\t * Output viewer preferences.\n\t * @return string for viewer preferences\n\t * @author Nicola asuni\n\t * @since 3.1.000 (2008-06-09)\n\t * @protected\n\t */\n\tprotected function _putviewerpreferences() {\n\t\t$vp = $this->viewer_preferences;\n\t\t$out = ' /ViewerPreferences <<';\n\t\tif ($this->rtl) {\n\t\t\t$out .= ' /Direction /R2L';\n\t\t} else {\n\t\t\t$out .= ' /Direction /L2R';\n\t\t}\n\t\tif (isset($vp['HideToolbar']) AND ($vp['HideToolbar'])) {\n\t\t\t$out .= ' /HideToolbar true';\n\t\t}\n\t\tif (isset($vp['HideMenubar']) AND ($vp['HideMenubar'])) {\n\t\t\t$out .= ' /HideMenubar true';\n\t\t}\n\t\tif (isset($vp['HideWindowUI']) AND ($vp['HideWindowUI'])) {\n\t\t\t$out .= ' /HideWindowUI true';\n\t\t}\n\t\tif (isset($vp['FitWindow']) AND ($vp['FitWindow'])) {\n\t\t\t$out .= ' /FitWindow true';\n\t\t}\n\t\tif (isset($vp['CenterWindow']) AND ($vp['CenterWindow'])) {\n\t\t\t$out .= ' /CenterWindow true';\n\t\t}\n\t\tif (isset($vp['DisplayDocTitle']) AND ($vp['DisplayDocTitle'])) {\n\t\t\t$out .= ' /DisplayDocTitle true';\n\t\t}\n\t\tif (isset($vp['NonFullScreenPageMode'])) {\n\t\t\t$out .= ' /NonFullScreenPageMode /'.$vp['NonFullScreenPageMode'];\n\t\t}\n\t\tif (isset($vp['ViewArea'])) {\n\t\t\t$out .= ' /ViewArea /'.$vp['ViewArea'];\n\t\t}\n\t\tif (isset($vp['ViewClip'])) {\n\t\t\t$out .= ' /ViewClip /'.$vp['ViewClip'];\n\t\t}\n\t\tif (isset($vp['PrintArea'])) {\n\t\t\t$out .= ' /PrintArea /'.$vp['PrintArea'];\n\t\t}\n\t\tif (isset($vp['PrintClip'])) {\n\t\t\t$out .= ' /PrintClip /'.$vp['PrintClip'];\n\t\t}\n\t\tif (isset($vp['PrintScaling'])) {\n\t\t\t$out .= ' /PrintScaling /'.$vp['PrintScaling'];\n\t\t}\n\t\tif (isset($vp['Duplex']) AND (!TCPDF_STATIC::empty_string($vp['Duplex']))) {\n\t\t\t$out .= ' /Duplex /'.$vp['Duplex'];\n\t\t}\n\t\tif (isset($vp['PickTrayByPDFSize'])) {\n\t\t\tif ($vp['PickTrayByPDFSize']) {\n\t\t\t\t$out .= ' /PickTrayByPDFSize true';\n\t\t\t} else {\n\t\t\t\t$out .= ' /PickTrayByPDFSize false';\n\t\t\t}\n\t\t}\n\t\tif (isset($vp['PrintPageRange'])) {\n\t\t\t$PrintPageRangeNum = '';\n\t\t\tforeach ($vp['PrintPageRange'] as $k => $v) {\n\t\t\t\t$PrintPageRangeNum .= ' '.($v - 1).'';\n\t\t\t}\n\t\t\t$out .= ' /PrintPageRange ['.substr($PrintPageRangeNum,1).']';\n\t\t}\n\t\tif (isset($vp['NumCopies'])) {\n\t\t\t$out .= ' /NumCopies '.intval($vp['NumCopies']);\n\t\t}\n\t\t$out .= ' >>';\n\t\treturn $out;\n\t}\n\n\t/**\n\t * Output PDF File Header (7.5.2).\n\t * @protected\n\t */\n\tprotected function _putheader() {\n\t\t$this->_out('%PDF-'.$this->PDFVersion);\n\t\t$this->_out('%'.chr(0xe2).chr(0xe3).chr(0xcf).chr(0xd3));\n\t}\n\n\t/**\n\t * Output end of document (EOF).\n\t * @protected\n\t */\n\tprotected function _enddoc() {\n\t\tif (isset($this->CurrentFont['fontkey']) AND isset($this->CurrentFont['subsetchars'])) {\n\t\t\t// save subset chars of the previous font\n\t\t\t$this->setFontSubBuffer($this->CurrentFont['fontkey'], 'subsetchars', $this->CurrentFont['subsetchars']);\n\t\t}\n\t\t$this->state = 1;\n\t\t$this->_putheader();\n\t\t$this->_putpages();\n\t\t$this->_putresources();\n\t\t// empty signature fields\n\t\tif (!empty($this->empty_signature_appearance)) {\n\t\t\tforeach ($this->empty_signature_appearance as $key => $esa) {\n\t\t\t\t// widget annotation for empty signature\n\t\t\t\t$out = $this->_getobj($esa['objid']).\"\\n\";\n\t\t\t\t$out .= '<< /Type /Annot';\n\t\t\t\t$out .= ' /Subtype /Widget';\n\t\t\t\t$out .= ' /Rect ['.$esa['rect'].']';\n\t\t\t\t$out .= ' /P '.$this->page_obj_id[($esa['page'])].' 0 R'; // link to signature appearance page\n\t\t\t\t$out .= ' /F 4';\n\t\t\t\t$out .= ' /FT /Sig';\n\t\t\t\t$signame = $esa['name'].sprintf(' [%03d]', ($key + 1));\n\t\t\t\t$out .= ' /T '.$this->_textstring($signame, $esa['objid']);\n\t\t\t\t$out .= ' /Ff 0';\n\t\t\t\t$out .= ' >>';\n\t\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t\t$this->_out($out);\n\t\t\t}\n\t\t}\n\t\t// Signature\n\t\tif ($this->sign AND isset($this->signature_data['cert_type'])) {\n\t\t\t// widget annotation for signature\n\t\t\t$out = $this->_getobj($this->sig_obj_id).\"\\n\";\n\t\t\t$out .= '<< /Type /Annot';\n\t\t\t$out .= ' /Subtype /Widget';\n\t\t\t$out .= ' /Rect ['.$this->signature_appearance['rect'].']';\n\t\t\t$out .= ' /P '.$this->page_obj_id[($this->signature_appearance['page'])].' 0 R'; // link to signature appearance page\n\t\t\t$out .= ' /F 4';\n\t\t\t$out .= ' /FT /Sig';\n\t\t\t$out .= ' /T '.$this->_textstring($this->signature_appearance['name'], $this->sig_obj_id);\n\t\t\t$out .= ' /Ff 0';\n\t\t\t$out .= ' /V '.($this->sig_obj_id + 1).' 0 R';\n\t\t\t$out .= ' >>';\n\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t$this->_out($out);\n\t\t\t// signature\n\t\t\t$this->_putsignature();\n\t\t}\n\t\t// Info\n\t\t$objid_info = $this->_putinfo();\n\t\t// Catalog\n\t\t$objid_catalog = $this->_putcatalog();\n\t\t// Cross-ref\n\t\t$o = $this->bufferlen;\n\t\t// XREF section\n\t\t$this->_out('xref');\n\t\t$this->_out('0 '.($this->n + 1));\n\t\t$this->_out('0000000000 65535 f ');\n\t\t$freegen = ($this->n + 2);\n\t\tfor ($i=1; $i <= $this->n; ++$i) {\n\t\t\tif (!isset($this->offsets[$i]) AND ($i > 1)) {\n\t\t\t\t$this->_out(sprintf('0000000000 %05d f ', $freegen));\n\t\t\t\t++$freegen;\n\t\t\t} else {\n\t\t\t\t$this->_out(sprintf('%010d 00000 n ', $this->offsets[$i]));\n\t\t\t}\n\t\t}\n\t\t// TRAILER\n\t\t$out = 'trailer'.\"\\n\";\n\t\t$out .= '<<';\n\t\t$out .= ' /Size '.($this->n + 1);\n\t\t$out .= ' /Root '.$objid_catalog.' 0 R';\n\t\t$out .= ' /Info '.$objid_info.' 0 R';\n\t\tif ($this->encrypted) {\n\t\t\t$out .= ' /Encrypt '.$this->encryptdata['objid'].' 0 R';\n\t\t}\n\t\t$out .= ' /ID [ <'.$this->file_id.'> <'.$this->file_id.'> ]';\n\t\t$out .= ' >>';\n\t\t$this->_out($out);\n\t\t$this->_out('startxref');\n\t\t$this->_out($o);\n\t\t$this->_out('%%EOF');\n\t\t$this->state = 3; // end-of-doc\n\t}\n\n\t/**\n\t * Initialize a new page.\n\t * @param string $orientation page orientation. Possible values are (case insensitive):<ul><li>P or PORTRAIT (default)</li><li>L or LANDSCAPE</li></ul>\n\t * @param mixed $format The format used for pages. It can be either: one of the string values specified at getPageSizeFromFormat() or an array of parameters specified at setPageFormat().\n\t * @protected\n\t * @see getPageSizeFromFormat(), setPageFormat()\n\t */\n\tprotected function _beginpage($orientation='', $format='') {\n\t\t++$this->page;\n\t\t$this->pageobjects[$this->page] = array();\n\t\t$this->setPageBuffer($this->page, '');\n\t\t// initialize array for graphics tranformation positions inside a page buffer\n\t\t$this->transfmrk[$this->page] = array();\n\t\t$this->state = 2;\n\t\tif (TCPDF_STATIC::empty_string($orientation)) {\n\t\t\tif (isset($this->CurOrientation)) {\n\t\t\t\t$orientation = $this->CurOrientation;\n\t\t\t} elseif ($this->fwPt > $this->fhPt) {\n\t\t\t\t// landscape\n\t\t\t\t$orientation = 'L';\n\t\t\t} else {\n\t\t\t\t// portrait\n\t\t\t\t$orientation = 'P';\n\t\t\t}\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($format)) {\n\t\t\t$this->pagedim[$this->page] = $this->pagedim[($this->page - 1)];\n\t\t\t$this->setPageOrientation($orientation);\n\t\t} else {\n\t\t\t$this->setPageFormat($format, $orientation);\n\t\t}\n\t\tif ($this->rtl) {\n\t\t\t$this->x = $this->w - $this->rMargin;\n\t\t} else {\n\t\t\t$this->x = $this->lMargin;\n\t\t}\n\t\t$this->y = $this->tMargin;\n\t\tif (isset($this->newpagegroup[$this->page])) {\n\t\t\t// start a new group\n\t\t\t$this->currpagegroup = $this->newpagegroup[$this->page];\n\t\t\t$this->pagegroups[$this->currpagegroup] = 1;\n\t\t} elseif (isset($this->currpagegroup) AND ($this->currpagegroup > 0)) {\n\t\t\t++$this->pagegroups[$this->currpagegroup];\n\t\t}\n\t}\n\n\t/**\n\t * Mark end of page.\n\t * @protected\n\t */\n\tprotected function _endpage() {\n\t\t$this->setVisibility('all');\n\t\t$this->state = 1;\n\t}\n\n\t/**\n\t * Begin a new object and return the object number.\n\t * @return int object number\n\t * @protected\n\t */\n\tprotected function _newobj() {\n\t\t$this->_out($this->_getobj());\n\t\treturn $this->n;\n\t}\n\n\t/**\n\t * Return the starting object string for the selected object ID.\n\t * @param int|null $objid Object ID (leave empty to get a new ID).\n\t * @return string the starting object string\n\t * @protected\n\t * @since 5.8.009 (2010-08-20)\n\t */\n\tprotected function _getobj($objid=null) {\n\t\tif (TCPDF_STATIC::empty_string($objid)) {\n\t\t\t++$this->n;\n\t\t\t$objid = $this->n;\n\t\t}\n\t\t$this->offsets[$objid] = $this->bufferlen;\n\t\t$this->pageobjects[$this->page][] = $objid;\n\t\treturn $objid.' 0 obj';\n\t}\n\n\t/**\n\t * Underline text.\n\t * @param int $x X coordinate\n\t * @param int $y Y coordinate\n\t * @param string $txt text to underline\n\t * @protected\n\t */\n\tprotected function _dounderline($x, $y, $txt) {\n\t\t$w = $this->GetStringWidth($txt);\n\t\treturn $this->_dounderlinew($x, $y, $w);\n\t}\n\n\t/**\n\t * Underline for rectangular text area.\n\t * @param int $x X coordinate\n\t * @param int $y Y coordinate\n\t * @param int $w width to underline\n\t * @protected\n\t * @since 4.8.008 (2009-09-29)\n\t */\n\tprotected function _dounderlinew($x, $y, $w) {\n\t\t$linew = - $this->CurrentFont['ut'] / 1000 * $this->FontSizePt;\n\t\treturn sprintf('%F %F %F %F re f', $x * $this->k, ((($this->h - $y) * $this->k) + $linew), $w * $this->k, $linew);\n\t}\n\n\t/**\n\t * Line through text.\n\t * @param int $x X coordinate\n\t * @param int $y Y coordinate\n\t * @param string $txt text to linethrough\n\t * @protected\n\t */\n\tprotected function _dolinethrough($x, $y, $txt) {\n\t\t$w = $this->GetStringWidth($txt);\n\t\treturn $this->_dolinethroughw($x, $y, $w);\n\t}\n\n\t/**\n\t * Line through for rectangular text area.\n\t * @param int $x X coordinate\n\t * @param int $y Y coordinate\n\t * @param int $w line length (width)\n\t * @protected\n\t * @since 4.9.008 (2009-09-29)\n\t */\n\tprotected function _dolinethroughw($x, $y, $w) {\n\t\t$linew = - $this->CurrentFont['ut'] / 1000 * $this->FontSizePt;\n\t\treturn sprintf('%F %F %F %F re f', $x * $this->k, ((($this->h - $y) * $this->k) + $linew + ($this->FontSizePt / 3)), $w * $this->k, $linew);\n\t}\n\n\t/**\n\t * Overline text.\n\t * @param int $x X coordinate\n\t * @param int $y Y coordinate\n\t * @param string $txt text to overline\n\t * @protected\n\t * @since 4.9.015 (2010-04-19)\n\t */\n\tprotected function _dooverline($x, $y, $txt) {\n\t\t$w = $this->GetStringWidth($txt);\n\t\treturn $this->_dooverlinew($x, $y, $w);\n\t}\n\n\t/**\n\t * Overline for rectangular text area.\n\t * @param int $x X coordinate\n\t * @param int $y Y coordinate\n\t * @param int $w width to overline\n\t * @protected\n\t * @since 4.9.015 (2010-04-19)\n\t */\n\tprotected function _dooverlinew($x, $y, $w) {\n\t\t$linew = - $this->CurrentFont['ut'] / 1000 * $this->FontSizePt;\n\t\treturn sprintf('%F %F %F %F re f', $x * $this->k, (($this->h - $y + $this->FontAscent) * $this->k) - $linew, $w * $this->k, $linew);\n\n\t}\n\n\t/**\n\t * Format a data string for meta information\n\t * @param string $s data string to escape.\n\t * @param int $n object ID\n\t * @return string escaped string.\n\t * @protected\n\t */\n\tprotected function _datastring($s, $n=0) {\n\t\tif ($n == 0) {\n\t\t\t$n = $this->n;\n\t\t}\n\t\t$s = $this->_encrypt_data($n, $s);\n\t\treturn '('. TCPDF_STATIC::_escape($s).')';\n\t}\n\n\t/**\n\t * Set the document creation timestamp\n\t * @param mixed $time Document creation timestamp in seconds or date-time string.\n\t * @public\n\t * @since 5.9.152 (2012-03-23)\n\t */\n\tpublic function setDocCreationTimestamp($time) {\n\t\tif (is_string($time)) {\n\t\t\t$time = TCPDF_STATIC::getTimestamp($time);\n\t\t}\n\t\t$this->doc_creation_timestamp = intval($time);\n\t}\n\n\t/**\n\t * Set the document modification timestamp\n\t * @param mixed $time Document modification timestamp in seconds or date-time string.\n\t * @public\n\t * @since 5.9.152 (2012-03-23)\n\t */\n\tpublic function setDocModificationTimestamp($time) {\n\t\tif (is_string($time)) {\n\t\t\t$time = TCPDF_STATIC::getTimestamp($time);\n\t\t}\n\t\t$this->doc_modification_timestamp = intval($time);\n\t}\n\n\t/**\n\t * Returns document creation timestamp in seconds.\n\t * @return int Creation timestamp in seconds.\n\t * @public\n\t * @since 5.9.152 (2012-03-23)\n\t */\n\tpublic function getDocCreationTimestamp() {\n\t\treturn $this->doc_creation_timestamp;\n\t}\n\n\t/**\n\t * Returns document modification timestamp in seconds.\n\t * @return int Modfication timestamp in seconds.\n\t * @public\n\t * @since 5.9.152 (2012-03-23)\n\t */\n\tpublic function getDocModificationTimestamp() {\n\t\treturn $this->doc_modification_timestamp;\n\t}\n\n\t/**\n\t * Returns a formatted date for meta information\n\t * @param int $n Object ID.\n\t * @param int $timestamp Timestamp to convert.\n\t * @return string escaped date string.\n\t * @protected\n\t * @since 4.6.028 (2009-08-25)\n\t */\n\tprotected function _datestring($n=0, $timestamp=0) {\n\t\tif ((empty($timestamp)) OR ($timestamp < 0)) {\n\t\t\t$timestamp = $this->doc_creation_timestamp;\n\t\t}\n\t\treturn $this->_datastring('D:'.TCPDF_STATIC::getFormattedDate($timestamp), $n);\n\t}\n\n\t/**\n\t * Format a text string for meta information\n\t * @param string $s string to escape.\n\t * @param int $n object ID\n\t * @return string escaped string.\n\t * @protected\n\t */\n\tprotected function _textstring($s, $n=0) {\n\t\tif ($this->isunicode) {\n\t\t\t//Convert string to UTF-16BE\n\t\t\t$s = TCPDF_FONTS::UTF8ToUTF16BE($s, true, $this->isunicode, $this->CurrentFont);\n\t\t}\n\t\treturn $this->_datastring($s, $n);\n\t}\n\n\t/**\n\t * get raw output stream.\n\t * @param string $s string to output.\n\t * @param int $n object reference for encryption mode\n\t * @protected\n\t * @author Nicola Asuni\n\t * @since 5.5.000 (2010-06-22)\n\t */\n\tprotected function _getrawstream($s, $n=0) {\n\t\tif ($n <= 0) {\n\t\t\t// default to current object\n\t\t\t$n = $this->n;\n\t\t}\n\t\treturn $this->_encrypt_data($n, $s);\n\t}\n\n\t/**\n\t * Output a string to the document.\n\t * @param string $s string to output.\n\t * @protected\n\t */\n\tprotected function _out($s) {\n\t\tif ($this->state == 2) {\n\t\t\tif ($this->inxobj) {\n\t\t\t\t// we are inside an XObject template\n\t\t\t\t$this->xobjects[$this->xobjid]['outdata'] .= $s.\"\\n\";\n\t\t\t} elseif ((!$this->InFooter) AND isset($this->footerlen[$this->page]) AND ($this->footerlen[$this->page] > 0)) {\n\t\t\t\t// puts data before page footer\n\t\t\t\t$pagebuff = $this->getPageBuffer($this->page);\n\t\t\t\t$page = substr($pagebuff, 0, -$this->footerlen[$this->page]);\n\t\t\t\t$footer = substr($pagebuff, -$this->footerlen[$this->page]);\n\t\t\t\t$this->setPageBuffer($this->page, $page.$s.\"\\n\".$footer);\n\t\t\t\t// update footer position\n\t\t\t\t$this->footerpos[$this->page] += strlen($s.\"\\n\");\n\t\t\t} else {\n\t\t\t\t// set page data\n\t\t\t\t$this->setPageBuffer($this->page, $s.\"\\n\", true);\n\t\t\t}\n\t\t} elseif ($this->state > 0) {\n\t\t\t// set general data\n\t\t\t$this->setBuffer($s.\"\\n\");\n\t\t}\n\t}\n\n\t/**\n\t * Set header font.\n\t * @param array<int,string|float|null> $font Array describing the basic font parameters: (family, style, size).\n\t * @phpstan-param array{0: string, 1: string, 2: float|null} $font\n\t * @public\n\t * @since 1.1\n\t */\n\tpublic function setHeaderFont($font) {\n\t\t$this->header_font = $font;\n\t}\n\n\t/**\n\t * Get header font.\n\t * @return array<int,string|float|null> Array describing the basic font parameters: (family, style, size).\n\t * @phpstan-return array{0: string, 1: string, 2: float|null}\n\t * @public\n\t * @since 4.0.012 (2008-07-24)\n\t */\n\tpublic function getHeaderFont() {\n\t\treturn $this->header_font;\n\t}\n\n\t/**\n\t * Set footer font.\n\t * @param array<int,string|float|null> $font Array describing the basic font parameters: (family, style, size).\n\t * @phpstan-param array{0: string, 1: string, 2: float|null} $font\n\t * @public\n\t * @since 1.1\n\t */\n\tpublic function setFooterFont($font) {\n\t\t$this->footer_font = $font;\n\t}\n\n\t/**\n\t * Get Footer font.\n\t * @return array<int,string|float|null> Array describing the basic font parameters: (family, style, size).\n\t * @phpstan-return array{0: string, 1: string, 2: float|null} $font\n\t * @public\n\t * @since 4.0.012 (2008-07-24)\n\t */\n\tpublic function getFooterFont() {\n\t\treturn $this->footer_font;\n\t}\n\n\t/**\n\t * Set language array.\n\t * @param array $language\n\t * @public\n\t * @since 1.1\n\t */\n\tpublic function setLanguageArray($language) {\n\t\t$this->l = $language;\n\t\tif (isset($this->l['a_meta_dir'])) {\n\t\t\t$this->rtl = $this->l['a_meta_dir']=='rtl' ? true : false;\n\t\t} else {\n\t\t\t$this->rtl = false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the PDF data.\n\t * @public\n\t */\n\tpublic function getPDFData() {\n\t\tif ($this->state < 3) {\n\t\t\t$this->Close();\n\t\t}\n\t\treturn $this->buffer;\n\t}\n\n\t/**\n\t * Output anchor link.\n\t * @param string $url link URL or internal link (i.e.: &lt;a href=\"#23,4.5\"&gt;link to page 23 at 4.5 Y position&lt;/a&gt;)\n\t * @param string $name link name\n\t * @param boolean $fill Indicates if the cell background must be painted (true) or transparent (false).\n\t * @param boolean $firstline if true prints only the first line and return the remaining string.\n\t * @param array|null $color array of RGB text color\n\t * @param string $style font style (U, D, B, I)\n\t * @param boolean $firstblock if true the string is the starting of a line.\n\t * @return int the number of cells used or the remaining text if $firstline = true;\n\t * @public\n\t */\n\tpublic function addHtmlLink($url, $name, $fill=false, $firstline=false, $color=null, $style=-1, $firstblock=false) {\n\t\tif (isset($url[1]) AND ($url[0] == '#') AND is_numeric($url[1])) {\n\t\t\t// convert url to internal link\n\t\t\t$lnkdata = explode(',', $url);\n\t\t\tif (isset($lnkdata[0]) ) {\n\t\t\t\t$page = substr($lnkdata[0], 1);\n\t\t\t\tif (isset($lnkdata[1]) AND (strlen($lnkdata[1]) > 0)) {\n\t\t\t\t\t$lnky = floatval($lnkdata[1]);\n\t\t\t\t} else {\n\t\t\t\t\t$lnky = 0;\n\t\t\t\t}\n\t\t\t\t$url = $this->AddLink();\n\t\t\t\t$this->setLink($url, $lnky, $page);\n\t\t\t}\n\t\t}\n\t\t// store current settings\n\t\t$prevcolor = $this->fgcolor;\n\t\t$prevstyle = $this->FontStyle;\n\t\tif (empty($color)) {\n\t\t\t$this->setTextColorArray($this->htmlLinkColorArray);\n\t\t} else {\n\t\t\t$this->setTextColorArray($color);\n\t\t}\n\t\tif ($style == -1) {\n\t\t\t$this->setFont('', $this->FontStyle.$this->htmlLinkFontStyle);\n\t\t} else {\n\t\t\t$this->setFont('', $this->FontStyle.$style);\n\t\t}\n\t\t$ret = $this->Write($this->lasth, $name, $url, $fill, '', false, 0, $firstline, $firstblock, 0);\n\t\t// restore settings\n\t\t$this->setFont('', $prevstyle);\n\t\t$this->setTextColorArray($prevcolor);\n\t\treturn $ret;\n\t}\n\n\t/**\n\t * Converts pixels to User's Units.\n\t * @param int $px pixels\n\t * @return float value in user's unit\n\t * @public\n\t * @see setImageScale(), getImageScale()\n\t */\n\tpublic function pixelsToUnits($px) {\n\t\treturn ($px / ($this->imgscale * $this->k));\n\t}\n\n\t/**\n\t * Reverse function for htmlentities.\n\t * Convert entities in UTF-8.\n\t * @param string $text_to_convert Text to convert.\n\t * @return string converted text string\n\t * @public\n\t */\n\tpublic function unhtmlentities($text_to_convert) {\n\t\treturn @html_entity_decode($text_to_convert, ENT_QUOTES, $this->encoding);\n\t}\n\n\t// ENCRYPTION METHODS ----------------------------------\n\n\t/**\n\t * Compute encryption key depending on object number where the encrypted data is stored.\n\t * This is used for all strings and streams without crypt filter specifier.\n\t * @param int $n object number\n\t * @return int object key\n\t * @protected\n\t * @author Nicola Asuni\n\t * @since 2.0.000 (2008-01-02)\n\t */\n\tprotected function _objectkey($n) {\n\t\t$objkey = $this->encryptdata['key'].pack('VXxx', $n);\n\t\tif ($this->encryptdata['mode'] == 2) { // AES-128\n\t\t\t// AES padding\n\t\t\t$objkey .= \"\\x73\\x41\\x6C\\x54\"; // sAlT\n\t\t}\n\t\t$objkey = substr(TCPDF_STATIC::_md5_16($objkey), 0, (($this->encryptdata['Length'] / 8) + 5));\n\t\t$objkey = substr($objkey, 0, 16);\n\t\treturn $objkey;\n\t}\n\n\t/**\n\t * Encrypt the input string.\n\t * @param int $n object number\n\t * @param string $s data string to encrypt\n\t * @return string encrypted string\n\t * @protected\n\t * @author Nicola Asuni\n\t * @since 5.0.005 (2010-05-11)\n\t */\n\tprotected function _encrypt_data($n, $s) {\n\t\tif (!$this->encrypted) {\n\t\t\treturn $s;\n\t\t}\n\t\tswitch ($this->encryptdata['mode']) {\n\t\t\tcase 0:   // RC4-40\n\t\t\tcase 1: { // RC4-128\n\t\t\t\t$s = TCPDF_STATIC::_RC4($this->_objectkey($n), $s, $this->last_enc_key, $this->last_enc_key_c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: { // AES-128\n\t\t\t\t$s = TCPDF_STATIC::_AES($this->_objectkey($n), $s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3: { // AES-256\n\t\t\t\t$s = TCPDF_STATIC::_AES($this->encryptdata['key'], $s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn $s;\n\t}\n\n\t/**\n\t * Put encryption on PDF document.\n\t * @protected\n\t * @author Nicola Asuni\n\t * @since 2.0.000 (2008-01-02)\n\t */\n\tprotected function _putencryption() {\n\t\tif (!$this->encrypted) {\n\t\t\treturn;\n\t\t}\n\t\t$this->encryptdata['objid'] = $this->_newobj();\n\t\t$out = '<<';\n\t\tif (!isset($this->encryptdata['Filter']) OR empty($this->encryptdata['Filter'])) {\n\t\t\t$this->encryptdata['Filter'] = 'Standard';\n\t\t}\n\t\t$out .= ' /Filter /'.$this->encryptdata['Filter'];\n\t\tif (isset($this->encryptdata['SubFilter']) AND !empty($this->encryptdata['SubFilter'])) {\n\t\t\t$out .= ' /SubFilter /'.$this->encryptdata['SubFilter'];\n\t\t}\n\t\tif (!isset($this->encryptdata['V']) OR empty($this->encryptdata['V'])) {\n\t\t\t$this->encryptdata['V'] = 1;\n\t\t}\n\t\t// V is a code specifying the algorithm to be used in encrypting and decrypting the document\n\t\t$out .= ' /V '.$this->encryptdata['V'];\n\t\tif (isset($this->encryptdata['Length']) AND !empty($this->encryptdata['Length'])) {\n\t\t\t// The length of the encryption key, in bits. The value shall be a multiple of 8, in the range 40 to 256\n\t\t\t$out .= ' /Length '.$this->encryptdata['Length'];\n\t\t} else {\n\t\t\t$out .= ' /Length 40';\n\t\t}\n\t\tif ($this->encryptdata['V'] >= 4) {\n\t\t\tif (!isset($this->encryptdata['StmF']) OR empty($this->encryptdata['StmF'])) {\n\t\t\t\t$this->encryptdata['StmF'] = 'Identity';\n\t\t\t}\n\t\t\tif (!isset($this->encryptdata['StrF']) OR empty($this->encryptdata['StrF'])) {\n\t\t\t\t// The name of the crypt filter that shall be used when decrypting all strings in the document.\n\t\t\t\t$this->encryptdata['StrF'] = 'Identity';\n\t\t\t}\n\t\t\t// A dictionary whose keys shall be crypt filter names and whose values shall be the corresponding crypt filter dictionaries.\n\t\t\tif (isset($this->encryptdata['CF']) AND !empty($this->encryptdata['CF'])) {\n\t\t\t\t$out .= ' /CF <<';\n\t\t\t\t$out .= ' /'.$this->encryptdata['StmF'].' <<';\n\t\t\t\t$out .= ' /Type /CryptFilter';\n\t\t\t\tif (isset($this->encryptdata['CF']['CFM']) AND !empty($this->encryptdata['CF']['CFM'])) {\n\t\t\t\t\t// The method used\n\t\t\t\t\t$out .= ' /CFM /'.$this->encryptdata['CF']['CFM'];\n\t\t\t\t\tif ($this->encryptdata['pubkey']) {\n\t\t\t\t\t\t$out .= ' /Recipients [';\n\t\t\t\t\t\tforeach ($this->encryptdata['Recipients'] as $rec) {\n\t\t\t\t\t\t\t$out .= ' <'.$rec.'>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$out .= ' ]';\n\t\t\t\t\t\tif (isset($this->encryptdata['CF']['EncryptMetadata']) AND (!$this->encryptdata['CF']['EncryptMetadata'])) {\n\t\t\t\t\t\t\t$out .= ' /EncryptMetadata false';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$out .= ' /EncryptMetadata true';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$out .= ' /CFM /None';\n\t\t\t\t}\n\t\t\t\tif (isset($this->encryptdata['CF']['AuthEvent']) AND !empty($this->encryptdata['CF']['AuthEvent'])) {\n\t\t\t\t\t// The event to be used to trigger the authorization that is required to access encryption keys used by this filter.\n\t\t\t\t\t$out .= ' /AuthEvent /'.$this->encryptdata['CF']['AuthEvent'];\n\t\t\t\t} else {\n\t\t\t\t\t$out .= ' /AuthEvent /DocOpen';\n\t\t\t\t}\n\t\t\t\tif (isset($this->encryptdata['CF']['Length']) AND !empty($this->encryptdata['CF']['Length'])) {\n\t\t\t\t\t// The bit length of the encryption key.\n\t\t\t\t\t$out .= ' /Length '.$this->encryptdata['CF']['Length'];\n\t\t\t\t}\n\t\t\t\t$out .= ' >> >>';\n\t\t\t}\n\t\t\t// The name of the crypt filter that shall be used by default when decrypting streams.\n\t\t\t$out .= ' /StmF /'.$this->encryptdata['StmF'];\n\t\t\t// The name of the crypt filter that shall be used when decrypting all strings in the document.\n\t\t\t$out .= ' /StrF /'.$this->encryptdata['StrF'];\n\t\t\tif (isset($this->encryptdata['EFF']) AND !empty($this->encryptdata['EFF'])) {\n\t\t\t\t// The name of the crypt filter that shall be used when encrypting embedded file streams that do not have their own crypt filter specifier.\n\t\t\t\t$out .= ' /EFF /'.$this->encryptdata[''];\n\t\t\t}\n\t\t}\n\t\t// Additional encryption dictionary entries for the standard security handler\n\t\tif ($this->encryptdata['pubkey']) {\n\t\t\tif (($this->encryptdata['V'] < 4) AND isset($this->encryptdata['Recipients']) AND !empty($this->encryptdata['Recipients'])) {\n\t\t\t\t$out .= ' /Recipients [';\n\t\t\t\tforeach ($this->encryptdata['Recipients'] as $rec) {\n\t\t\t\t\t$out .= ' <'.$rec.'>';\n\t\t\t\t}\n\t\t\t\t$out .= ' ]';\n\t\t\t}\n\t\t} else {\n\t\t\t$out .= ' /R';\n\t\t\tif ($this->encryptdata['V'] == 5) { // AES-256\n\t\t\t\t$out .= ' 5';\n\t\t\t\t$out .= ' /OE ('.TCPDF_STATIC::_escape($this->encryptdata['OE']).')';\n\t\t\t\t$out .= ' /UE ('.TCPDF_STATIC::_escape($this->encryptdata['UE']).')';\n\t\t\t\t$out .= ' /Perms ('.TCPDF_STATIC::_escape($this->encryptdata['perms']).')';\n\t\t\t} elseif ($this->encryptdata['V'] == 4) { // AES-128\n\t\t\t\t$out .= ' 4';\n\t\t\t} elseif ($this->encryptdata['V'] < 2) { // RC-40\n\t\t\t\t$out .= ' 2';\n\t\t\t} else { // RC-128\n\t\t\t\t$out .= ' 3';\n\t\t\t}\n\t\t\t$out .= ' /O ('.TCPDF_STATIC::_escape($this->encryptdata['O']).')';\n\t\t\t$out .= ' /U ('.TCPDF_STATIC::_escape($this->encryptdata['U']).')';\n\t\t\t$out .= ' /P '.$this->encryptdata['P'];\n\t\t\tif (isset($this->encryptdata['EncryptMetadata']) AND (!$this->encryptdata['EncryptMetadata'])) {\n\t\t\t\t$out .= ' /EncryptMetadata false';\n\t\t\t} else {\n\t\t\t\t$out .= ' /EncryptMetadata true';\n\t\t\t}\n\t\t}\n\t\t$out .= ' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t}\n\n\t/**\n\t * Compute U value (used for encryption)\n\t * @return string U value\n\t * @protected\n\t * @since 2.0.000 (2008-01-02)\n\t * @author Nicola Asuni\n\t */\n\tprotected function _Uvalue() {\n\t\tif ($this->encryptdata['mode'] == 0) { // RC4-40\n\t\t\treturn TCPDF_STATIC::_RC4($this->encryptdata['key'], TCPDF_STATIC::$enc_padding, $this->last_enc_key, $this->last_enc_key_c);\n\t\t} elseif ($this->encryptdata['mode'] < 3) { // RC4-128, AES-128\n\t\t\t$tmp = TCPDF_STATIC::_md5_16(TCPDF_STATIC::$enc_padding.$this->encryptdata['fileid']);\n\t\t\t$enc = TCPDF_STATIC::_RC4($this->encryptdata['key'], $tmp, $this->last_enc_key, $this->last_enc_key_c);\n\t\t\t$len = strlen($tmp);\n\t\t\tfor ($i = 1; $i <= 19; ++$i) {\n\t\t\t\t$ek = '';\n\t\t\t\tfor ($j = 0; $j < $len; ++$j) {\n\t\t\t\t\t$ek .= chr(ord($this->encryptdata['key'][$j]) ^ $i);\n\t\t\t\t}\n\t\t\t\t$enc = TCPDF_STATIC::_RC4($ek, $enc, $this->last_enc_key, $this->last_enc_key_c);\n\t\t\t}\n\t\t\t$enc .= str_repeat(\"\\x00\", 16);\n\t\t\treturn substr($enc, 0, 32);\n\t\t} elseif ($this->encryptdata['mode'] == 3) { // AES-256\n\t\t\t$seed = TCPDF_STATIC::_md5_16(TCPDF_STATIC::getRandomSeed());\n\t\t\t// User Validation Salt\n\t\t\t$this->encryptdata['UVS'] = substr($seed, 0, 8);\n\t\t\t// User Key Salt\n\t\t\t$this->encryptdata['UKS'] = substr($seed, 8, 16);\n\t\t\treturn hash('sha256', $this->encryptdata['user_password'].$this->encryptdata['UVS'], true).$this->encryptdata['UVS'].$this->encryptdata['UKS'];\n\t\t}\n\t}\n\n\t/**\n\t * Compute UE value (used for encryption)\n\t * @return string UE value\n\t * @protected\n\t * @since 5.9.006 (2010-10-19)\n\t * @author Nicola Asuni\n\t */\n\tprotected function _UEvalue() {\n\t\t$hashkey = hash('sha256', $this->encryptdata['user_password'].$this->encryptdata['UKS'], true);\n\t\treturn TCPDF_STATIC::_AESnopad($hashkey, $this->encryptdata['key']);\n\t}\n\n\t/**\n\t * Compute O value (used for encryption)\n\t * @return string O value\n\t * @protected\n\t * @since 2.0.000 (2008-01-02)\n\t * @author Nicola Asuni\n\t */\n\tprotected function _Ovalue() {\n\t\tif ($this->encryptdata['mode'] < 3) { // RC4-40, RC4-128, AES-128\n\t\t\t$tmp = TCPDF_STATIC::_md5_16($this->encryptdata['owner_password']);\n\t\t\tif ($this->encryptdata['mode'] > 0) {\n\t\t\t\tfor ($i = 0; $i < 50; ++$i) {\n\t\t\t\t\t$tmp = TCPDF_STATIC::_md5_16($tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$owner_key = substr($tmp, 0, ($this->encryptdata['Length'] / 8));\n\t\t\t$enc = TCPDF_STATIC::_RC4($owner_key, $this->encryptdata['user_password'], $this->last_enc_key, $this->last_enc_key_c);\n\t\t\tif ($this->encryptdata['mode'] > 0) {\n\t\t\t\t$len = strlen($owner_key);\n\t\t\t\tfor ($i = 1; $i <= 19; ++$i) {\n\t\t\t\t\t$ek = '';\n\t\t\t\t\tfor ($j = 0; $j < $len; ++$j) {\n\t\t\t\t\t\t$ek .= chr(ord($owner_key[$j]) ^ $i);\n\t\t\t\t\t}\n\t\t\t\t\t$enc = TCPDF_STATIC::_RC4($ek, $enc, $this->last_enc_key, $this->last_enc_key_c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $enc;\n\t\t} elseif ($this->encryptdata['mode'] == 3) { // AES-256\n\t\t\t$seed = TCPDF_STATIC::_md5_16(TCPDF_STATIC::getRandomSeed());\n\t\t\t// Owner Validation Salt\n\t\t\t$this->encryptdata['OVS'] = substr($seed, 0, 8);\n\t\t\t// Owner Key Salt\n\t\t\t$this->encryptdata['OKS'] = substr($seed, 8, 16);\n\t\t\treturn hash('sha256', $this->encryptdata['owner_password'].$this->encryptdata['OVS'].$this->encryptdata['U'], true).$this->encryptdata['OVS'].$this->encryptdata['OKS'];\n\t\t}\n\t}\n\n\t/**\n\t * Compute OE value (used for encryption)\n\t * @return string OE value\n\t * @protected\n\t * @since 5.9.006 (2010-10-19)\n\t * @author Nicola Asuni\n\t */\n\tprotected function _OEvalue() {\n\t\t$hashkey = hash('sha256', $this->encryptdata['owner_password'].$this->encryptdata['OKS'].$this->encryptdata['U'], true);\n\t\treturn TCPDF_STATIC::_AESnopad($hashkey, $this->encryptdata['key']);\n\t}\n\n\t/**\n\t * Convert password for AES-256 encryption mode\n\t * @param string $password password\n\t * @return string password\n\t * @protected\n\t * @since 5.9.006 (2010-10-19)\n\t * @author Nicola Asuni\n\t */\n\tprotected function _fixAES256Password($password) {\n\t\t$psw = ''; // password to be returned\n\t\t$psw_array = TCPDF_FONTS::utf8Bidi(TCPDF_FONTS::UTF8StringToArray($password, $this->isunicode, $this->CurrentFont), $password, $this->rtl, $this->isunicode, $this->CurrentFont);\n\t\tforeach ($psw_array as $c) {\n\t\t\t$psw .= TCPDF_FONTS::unichr($c, $this->isunicode);\n\t\t}\n\t\treturn substr($psw, 0, 127);\n\t}\n\n\t/**\n\t * Compute encryption key\n\t * @protected\n\t * @since 2.0.000 (2008-01-02)\n\t * @author Nicola Asuni\n\t */\n\tprotected function _generateencryptionkey() {\n\t\t$keybytelen = ($this->encryptdata['Length'] / 8);\n\t\tif (!$this->encryptdata['pubkey']) { // standard mode\n\t\t\tif ($this->encryptdata['mode'] == 3) { // AES-256\n\t\t\t\t// generate 256 bit random key\n\t\t\t\t$this->encryptdata['key'] = substr(hash('sha256', TCPDF_STATIC::getRandomSeed(), true), 0, $keybytelen);\n\t\t\t\t// truncate passwords\n\t\t\t\t$this->encryptdata['user_password'] = $this->_fixAES256Password($this->encryptdata['user_password']);\n\t\t\t\t$this->encryptdata['owner_password'] = $this->_fixAES256Password($this->encryptdata['owner_password']);\n\t\t\t\t// Compute U value\n\t\t\t\t$this->encryptdata['U'] = $this->_Uvalue();\n\t\t\t\t// Compute UE value\n\t\t\t\t$this->encryptdata['UE'] = $this->_UEvalue();\n\t\t\t\t// Compute O value\n\t\t\t\t$this->encryptdata['O'] = $this->_Ovalue();\n\t\t\t\t// Compute OE value\n\t\t\t\t$this->encryptdata['OE'] = $this->_OEvalue();\n\t\t\t\t// Compute P value\n\t\t\t\t$this->encryptdata['P'] = $this->encryptdata['protection'];\n\t\t\t\t// Computing the encryption dictionary's Perms (permissions) value\n\t\t\t\t$perms = TCPDF_STATIC::getEncPermissionsString($this->encryptdata['protection']); // bytes 0-3\n\t\t\t\t$perms .= chr(255).chr(255).chr(255).chr(255); // bytes 4-7\n\t\t\t\tif (isset($this->encryptdata['CF']['EncryptMetadata']) AND (!$this->encryptdata['CF']['EncryptMetadata'])) { // byte 8\n\t\t\t\t\t$perms .= 'F';\n\t\t\t\t} else {\n\t\t\t\t\t$perms .= 'T';\n\t\t\t\t}\n\t\t\t\t$perms .= 'adb'; // bytes 9-11\n\t\t\t\t$perms .= 'nick'; // bytes 12-15\n\t\t\t\t$this->encryptdata['perms'] = TCPDF_STATIC::_AESnopad($this->encryptdata['key'], $perms);\n\t\t\t} else { // RC4-40, RC4-128, AES-128\n\t\t\t\t// Pad passwords\n\t\t\t\t$this->encryptdata['user_password'] = substr($this->encryptdata['user_password'].TCPDF_STATIC::$enc_padding, 0, 32);\n\t\t\t\t$this->encryptdata['owner_password'] = substr($this->encryptdata['owner_password'].TCPDF_STATIC::$enc_padding, 0, 32);\n\t\t\t\t// Compute O value\n\t\t\t\t$this->encryptdata['O'] = $this->_Ovalue();\n\t\t\t\t// get default permissions (reverse byte order)\n\t\t\t\t$permissions = TCPDF_STATIC::getEncPermissionsString($this->encryptdata['protection']);\n\t\t\t\t// Compute encryption key\n\t\t\t\t$tmp = TCPDF_STATIC::_md5_16($this->encryptdata['user_password'].$this->encryptdata['O'].$permissions.$this->encryptdata['fileid']);\n\t\t\t\tif ($this->encryptdata['mode'] > 0) {\n\t\t\t\t\tfor ($i = 0; $i < 50; ++$i) {\n\t\t\t\t\t\t$tmp = TCPDF_STATIC::_md5_16(substr($tmp, 0, $keybytelen));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$this->encryptdata['key'] = substr($tmp, 0, $keybytelen);\n\t\t\t\t// Compute U value\n\t\t\t\t$this->encryptdata['U'] = $this->_Uvalue();\n\t\t\t\t// Compute P value\n\t\t\t\t$this->encryptdata['P'] = $this->encryptdata['protection'];\n\t\t\t}\n\t\t} else { // Public-Key mode\n\t\t\t// random 20-byte seed\n\t\t\t$seed = sha1(TCPDF_STATIC::getRandomSeed(), true);\n\t\t\t$recipient_bytes = '';\n\t\t\tforeach ($this->encryptdata['pubkeys'] as $pubkey) {\n\t\t\t\t// for each public certificate\n\t\t\t\tif (isset($pubkey['p'])) {\n\t\t\t\t\t$pkprotection = TCPDF_STATIC::getUserPermissionCode($pubkey['p'], $this->encryptdata['mode']);\n\t\t\t\t} else {\n\t\t\t\t\t$pkprotection = $this->encryptdata['protection'];\n\t\t\t\t}\n\t\t\t\t// get default permissions (reverse byte order)\n\t\t\t\t$pkpermissions = TCPDF_STATIC::getEncPermissionsString($pkprotection);\n\t\t\t\t// envelope data\n\t\t\t\t$envelope = $seed.$pkpermissions;\n\t\t\t\t// write the envelope data to a temporary file\n\t\t\t\t$tempkeyfile = TCPDF_STATIC::getObjFilename('key', $this->file_id);\n\t\t\t\t$f = TCPDF_STATIC::fopenLocal($tempkeyfile, 'wb');\n\t\t\t\tif (!$f) {\n\t\t\t\t\t$this->Error('Unable to create temporary key file: '.$tempkeyfile);\n\t\t\t\t}\n\t\t\t\t$envelope_length = strlen($envelope);\n\t\t\t\tfwrite($f, $envelope, $envelope_length);\n\t\t\t\tfclose($f);\n\t\t\t\t$tempencfile = TCPDF_STATIC::getObjFilename('enc', $this->file_id);\n\t\t\t\tif (!openssl_pkcs7_encrypt($tempkeyfile, $tempencfile, $pubkey['c'], array(), PKCS7_BINARY | PKCS7_DETACHED)) {\n\t\t\t\t\t$this->Error('Unable to encrypt the file: '.$tempkeyfile);\n\t\t\t\t}\n\t\t\t\t// read encryption signature\n\t\t\t\t$signature = file_get_contents($tempencfile, false, null, $envelope_length);\n\t\t\t\t// extract signature\n\t\t\t\t$signature = substr($signature, strpos($signature, 'Content-Disposition'));\n\t\t\t\t$tmparr = explode(\"\\n\\n\", $signature);\n\t\t\t\t$signature = trim($tmparr[1]);\n\t\t\t\tunset($tmparr);\n\t\t\t\t// decode signature\n\t\t\t\t$signature = base64_decode($signature);\n\t\t\t\t// convert signature to hex\n\t\t\t\t$hexsignature = current(unpack('H*', $signature));\n\t\t\t\t// store signature on recipients array\n\t\t\t\t$this->encryptdata['Recipients'][] = $hexsignature;\n\t\t\t\t// The bytes of each item in the Recipients array of PKCS#7 objects in the order in which they appear in the array\n\t\t\t\t$recipient_bytes .= $signature;\n\t\t\t}\n\t\t\t// calculate encryption key\n\t\t\tif ($this->encryptdata['mode'] == 3) { // AES-256\n\t\t\t\t$this->encryptdata['key'] = substr(hash('sha256', $seed.$recipient_bytes, true), 0, $keybytelen);\n\t\t\t} else { // RC4-40, RC4-128, AES-128\n\t\t\t\t$this->encryptdata['key'] = substr(sha1($seed.$recipient_bytes, true), 0, $keybytelen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set document protection\n\t * Remark: the protection against modification is for people who have the full Acrobat product.\n\t * If you don't set any password, the document will open as usual. If you set a user password, the PDF viewer will ask for it before displaying the document. The master password, if different from the user one, can be used to get full access.\n\t * Note: protecting a document requires to encrypt it, which increases the processing time a lot. This can cause a PHP time-out in some cases, especially if the document contains images or fonts.\n\t * @param array $permissions the set of permissions (specify the ones you want to block):<ul><li>print : Print the document;</li><li>modify : Modify the contents of the document by operations other than those controlled by 'fill-forms', 'extract' and 'assemble';</li><li>copy : Copy or otherwise extract text and graphics from the document;</li><li>annot-forms : Add or modify text annotations, fill in interactive form fields, and, if 'modify' is also set, create or modify interactive form fields (including signature fields);</li><li>fill-forms : Fill in existing interactive form fields (including signature fields), even if 'annot-forms' is not specified;</li><li>extract : Extract text and graphics (in support of accessibility to users with disabilities or for other purposes);</li><li>assemble : Assemble the document (insert, rotate, or delete pages and create bookmarks or thumbnail images), even if 'modify' is not set;</li><li>print-high : Print the document to a representation from which a faithful digital copy of the PDF content could be generated. When this is not set, printing is limited to a low-level representation of the appearance, possibly of degraded quality.</li><li>owner : (inverted logic - only for public-key) when set permits change of encryption and enables all other permissions.</li></ul>\n\t * @param string $user_pass user password. Empty by default.\n\t * @param string|null $owner_pass owner password. If not specified, a random value is used.\n\t * @param int $mode encryption strength: 0 = RC4 40 bit; 1 = RC4 128 bit; 2 = AES 128 bit; 3 = AES 256 bit.\n\t * @param array|null $pubkeys array of recipients containing public-key certificates ('c') and permissions ('p'). For example: array(array('c' => 'file://../examples/data/cert/tcpdf.crt', 'p' => array('print')))\n\t * @public\n\t * @since 2.0.000 (2008-01-02)\n\t * @author Nicola Asuni\n\t */\n\tpublic function setProtection($permissions=array('print', 'modify', 'copy', 'annot-forms', 'fill-forms', 'extract', 'assemble', 'print-high'), $user_pass='', $owner_pass=null, $mode=0, $pubkeys=null) {\n\t\tif ($this->pdfa_mode) {\n\t\t\t// encryption is not allowed in PDF/A mode\n\t\t\treturn;\n\t\t}\n\t\t$this->encryptdata['protection'] = TCPDF_STATIC::getUserPermissionCode($permissions, $mode);\n\t\tif (($pubkeys !== null) AND (is_array($pubkeys))) {\n\t\t\t// public-key mode\n\t\t\t$this->encryptdata['pubkeys'] = $pubkeys;\n\t\t\tif ($mode == 0) {\n\t\t\t\t// public-Key Security requires at least 128 bit\n\t\t\t\t$mode = 1;\n\t\t\t}\n\t\t\tif (!function_exists('openssl_pkcs7_encrypt')) {\n\t\t\t\t$this->Error('Public-Key Security requires openssl library.');\n\t\t\t}\n\t\t\t// Set Public-Key filter (available are: Entrust.PPKEF, Adobe.PPKLite, Adobe.PubSec)\n\t\t\t$this->encryptdata['pubkey'] = true;\n\t\t\t$this->encryptdata['Filter'] = 'Adobe.PubSec';\n\t\t\t$this->encryptdata['StmF'] = 'DefaultCryptFilter';\n\t\t\t$this->encryptdata['StrF'] = 'DefaultCryptFilter';\n\t\t} else {\n\t\t\t// standard mode (password mode)\n\t\t\t$this->encryptdata['pubkey'] = false;\n\t\t\t$this->encryptdata['Filter'] = 'Standard';\n\t\t\t$this->encryptdata['StmF'] = 'StdCF';\n\t\t\t$this->encryptdata['StrF'] = 'StdCF';\n\t\t}\n\t\tif ($mode > 1) { // AES\n\t\t\tif (!extension_loaded('openssl') && !extension_loaded('mcrypt')) {\n\t\t\t\t$this->Error('AES encryption requires openssl or mcrypt extension (http://www.php.net/manual/en/mcrypt.requirements.php).');\n\t\t\t}\n\t\t\tif (extension_loaded('openssl') && !in_array('aes-256-cbc', openssl_get_cipher_methods())) {\n\t\t\t\t$this->Error('AES encryption requires openssl/aes-256-cbc cypher.');\n\t\t\t}\n\t\t\tif (extension_loaded('mcrypt') && mcrypt_get_cipher_name(MCRYPT_RIJNDAEL_128) === false) {\n\t\t\t\t$this->Error('AES encryption requires MCRYPT_RIJNDAEL_128 cypher.');\n\t\t\t}\n\t\t\tif (($mode == 3) AND !function_exists('hash')) {\n\t\t\t\t// the Hash extension requires no external libraries and is enabled by default as of PHP 5.1.2.\n\t\t\t\t$this->Error('AES 256 encryption requires HASH Message Digest Framework (http://www.php.net/manual/en/book.hash.php).');\n\t\t\t}\n\t\t}\n\t\tif ($owner_pass === null) {\n\t\t\t$owner_pass = md5(TCPDF_STATIC::getRandomSeed());\n\t\t}\n\t\t$this->encryptdata['user_password'] = $user_pass;\n\t\t$this->encryptdata['owner_password'] = $owner_pass;\n\t\t$this->encryptdata['mode'] = $mode;\n\t\tswitch ($mode) {\n\t\t\tcase 0: { // RC4 40 bit\n\t\t\t\t$this->encryptdata['V'] = 1;\n\t\t\t\t$this->encryptdata['Length'] = 40;\n\t\t\t\t$this->encryptdata['CF']['CFM'] = 'V2';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1: { // RC4 128 bit\n\t\t\t\t$this->encryptdata['V'] = 2;\n\t\t\t\t$this->encryptdata['Length'] = 128;\n\t\t\t\t$this->encryptdata['CF']['CFM'] = 'V2';\n\t\t\t\tif ($this->encryptdata['pubkey']) {\n\t\t\t\t\t$this->encryptdata['SubFilter'] = 'adbe.pkcs7.s4';\n\t\t\t\t\t$this->encryptdata['Recipients'] = array();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: { // AES 128 bit\n\t\t\t\t$this->encryptdata['V'] = 4;\n\t\t\t\t$this->encryptdata['Length'] = 128;\n\t\t\t\t$this->encryptdata['CF']['CFM'] = 'AESV2';\n\t\t\t\t$this->encryptdata['CF']['Length'] = 16;\n\t\t\t\tif ($this->encryptdata['pubkey']) {\n\t\t\t\t\t$this->encryptdata['SubFilter'] = 'adbe.pkcs7.s5';\n\t\t\t\t\t$this->encryptdata['Recipients'] = array();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3: { // AES 256 bit\n\t\t\t\t$this->encryptdata['V'] = 5;\n\t\t\t\t$this->encryptdata['Length'] = 256;\n\t\t\t\t$this->encryptdata['CF']['CFM'] = 'AESV3';\n\t\t\t\t$this->encryptdata['CF']['Length'] = 32;\n\t\t\t\tif ($this->encryptdata['pubkey']) {\n\t\t\t\t\t$this->encryptdata['SubFilter'] = 'adbe.pkcs7.s5';\n\t\t\t\t\t$this->encryptdata['Recipients'] = array();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$this->encrypted = true;\n\t\t$this->encryptdata['fileid'] = TCPDF_STATIC::convertHexStringToString($this->file_id);\n\t\t$this->_generateencryptionkey();\n\t}\n\n\t// END OF ENCRYPTION FUNCTIONS -------------------------\n\n\t// START TRANSFORMATIONS SECTION -----------------------\n\n\t/**\n\t * Starts a 2D tranformation saving current graphic state.\n\t * This function must be called before scaling, mirroring, translation, rotation and skewing.\n\t * Use StartTransform() before, and StopTransform() after the transformations to restore the normal behavior.\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function StartTransform() {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\t$this->_outSaveGraphicsState();\n\t\tif ($this->inxobj) {\n\t\t\t// we are inside an XObject template\n\t\t\t$this->xobjects[$this->xobjid]['transfmrk'][] = strlen($this->xobjects[$this->xobjid]['outdata']);\n\t\t} else {\n\t\t\t$this->transfmrk[$this->page][] = $this->pagelen[$this->page];\n\t\t}\n\t\t++$this->transfmatrix_key;\n\t\t$this->transfmatrix[$this->transfmatrix_key] = array();\n\t}\n\n\t/**\n\t * Stops a 2D tranformation restoring previous graphic state.\n\t * This function must be called after scaling, mirroring, translation, rotation and skewing.\n\t * Use StartTransform() before, and StopTransform() after the transformations to restore the normal behavior.\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function StopTransform() {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\t$this->_outRestoreGraphicsState();\n\t\tif (isset($this->transfmatrix[$this->transfmatrix_key])) {\n\t\t\tarray_pop($this->transfmatrix[$this->transfmatrix_key]);\n\t\t\t--$this->transfmatrix_key;\n\t\t}\n\t\tif ($this->inxobj) {\n\t\t\t// we are inside an XObject template\n\t\t\tarray_pop($this->xobjects[$this->xobjid]['transfmrk']);\n\t\t} else {\n\t\t\tarray_pop($this->transfmrk[$this->page]);\n\t\t}\n\t}\n\t/**\n\t * Horizontal Scaling.\n\t * @param float $s_x scaling factor for width as percent. 0 is not allowed.\n\t * @param int $x abscissa of the scaling center. Default is current x position\n\t * @param int $y ordinate of the scaling center. Default is current y position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function ScaleX($s_x, $x='', $y='') {\n\t\t$this->Scale($s_x, 100, $x, $y);\n\t}\n\n\t/**\n\t * Vertical Scaling.\n\t * @param float $s_y scaling factor for height as percent. 0 is not allowed.\n\t * @param int $x abscissa of the scaling center. Default is current x position\n\t * @param int $y ordinate of the scaling center. Default is current y position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function ScaleY($s_y, $x='', $y='') {\n\t\t$this->Scale(100, $s_y, $x, $y);\n\t}\n\n\t/**\n\t * Vertical and horizontal proportional Scaling.\n\t * @param float $s scaling factor for width and height as percent. 0 is not allowed.\n\t * @param int $x abscissa of the scaling center. Default is current x position\n\t * @param int $y ordinate of the scaling center. Default is current y position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function ScaleXY($s, $x='', $y='') {\n\t\t$this->Scale($s, $s, $x, $y);\n\t}\n\n\t/**\n\t * Vertical and horizontal non-proportional Scaling.\n\t * @param float $s_x scaling factor for width as percent. 0 is not allowed.\n\t * @param float $s_y scaling factor for height as percent. 0 is not allowed.\n\t * @param float|null $x abscissa of the scaling center. Default is current x position\n\t * @param float|null $y ordinate of the scaling center. Default is current y position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function Scale($s_x, $s_y, $x=null, $y=null) {\n\t\tif (TCPDF_STATIC::empty_string($x)) {\n\t\t\t$x = $this->x;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($y)) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\tif (($s_x == 0) OR ($s_y == 0)) {\n\t\t\t$this->Error('Please do not use values equal to zero for scaling');\n\t\t}\n\t\t$y = ($this->h - $y) * $this->k;\n\t\t$x *= $this->k;\n\t\t//calculate elements of transformation matrix\n\t\t$s_x /= 100;\n\t\t$s_y /= 100;\n\t\t$tm = array();\n\t\t$tm[0] = $s_x;\n\t\t$tm[1] = 0;\n\t\t$tm[2] = 0;\n\t\t$tm[3] = $s_y;\n\t\t$tm[4] = $x * (1 - $s_x);\n\t\t$tm[5] = $y * (1 - $s_y);\n\t\t//scale the coordinate system\n\t\t$this->Transform($tm);\n\t}\n\n\t/**\n\t * Horizontal Mirroring.\n\t * @param float|null $x abscissa of the point. Default is current x position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function MirrorH($x=null) {\n\t\t$this->Scale(-100, 100, $x);\n\t}\n\n\t/**\n\t * Verical Mirroring.\n\t * @param float|null $y ordinate of the point. Default is current y position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function MirrorV($y=null) {\n\t\t$this->Scale(100, -100, null, $y);\n\t}\n\n\t/**\n\t * Point reflection mirroring.\n\t * @param float|null $x abscissa of the point. Default is current x position\n\t * @param float|null $y ordinate of the point. Default is current y position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function MirrorP($x=null,$y=null) {\n\t\t$this->Scale(-100, -100, $x, $y);\n\t}\n\n\t/**\n\t * Reflection against a straight line through point (x, y) with the gradient angle (angle).\n\t * @param float $angle gradient angle of the straight line. Default is 0 (horizontal line).\n\t * @param float|null $x abscissa of the point. Default is current x position\n\t * @param float|null $y ordinate of the point. Default is current y position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function MirrorL($angle=0, $x=null,$y=null) {\n\t\t$this->Scale(-100, 100, $x, $y);\n\t\t$this->Rotate(-2*($angle-90), $x, $y);\n\t}\n\n\t/**\n\t * Translate graphic object horizontally.\n\t * @param int $t_x movement to the right (or left for RTL)\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function TranslateX($t_x) {\n\t\t$this->Translate($t_x, 0);\n\t}\n\n\t/**\n\t * Translate graphic object vertically.\n\t * @param int $t_y movement to the bottom\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function TranslateY($t_y) {\n\t\t$this->Translate(0, $t_y);\n\t}\n\n\t/**\n\t * Translate graphic object horizontally and vertically.\n\t * @param int $t_x movement to the right\n\t * @param int $t_y movement to the bottom\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function Translate($t_x, $t_y) {\n\t\t//calculate elements of transformation matrix\n\t\t$tm = array();\n\t\t$tm[0] = 1;\n\t\t$tm[1] = 0;\n\t\t$tm[2] = 0;\n\t\t$tm[3] = 1;\n\t\t$tm[4] = $t_x * $this->k;\n\t\t$tm[5] = -$t_y * $this->k;\n\t\t//translate the coordinate system\n\t\t$this->Transform($tm);\n\t}\n\n\t/**\n\t * Rotate object.\n\t * @param float $angle angle in degrees for counter-clockwise rotation\n\t * @param float|null $x abscissa of the rotation center. Default is current x position\n\t * @param float|null $y ordinate of the rotation center. Default is current y position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function Rotate($angle, $x=null, $y=null) {\n\t\tif (TCPDF_STATIC::empty_string($x)) {\n\t\t\t$x = $this->x;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($y)) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\t$y = ($this->h - $y) * $this->k;\n\t\t$x *= $this->k;\n\t\t//calculate elements of transformation matrix\n\t\t$tm = array();\n\t\t$tm[0] = cos(deg2rad($angle));\n\t\t$tm[1] = sin(deg2rad($angle));\n\t\t$tm[2] = -$tm[1];\n\t\t$tm[3] = $tm[0];\n\t\t$tm[4] = $x + ($tm[1] * $y) - ($tm[0] * $x);\n\t\t$tm[5] = $y - ($tm[0] * $y) - ($tm[1] * $x);\n\t\t//rotate the coordinate system around ($x,$y)\n\t\t$this->Transform($tm);\n\t}\n\n\t/**\n\t * Skew horizontally.\n\t * @param float $angle_x angle in degrees between -90 (skew to the left) and 90 (skew to the right)\n\t * @param float|null $x abscissa of the skewing center. default is current x position\n\t * @param float|null $y ordinate of the skewing center. default is current y position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function SkewX($angle_x, $x=null, $y=null) {\n\t\t$this->Skew($angle_x, 0, $x, $y);\n\t}\n\n\t/**\n\t * Skew vertically.\n\t * @param float $angle_y angle in degrees between -90 (skew to the bottom) and 90 (skew to the top)\n\t * @param float|null $x abscissa of the skewing center. default is current x position\n\t * @param float|null $y ordinate of the skewing center. default is current y position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function SkewY($angle_y, $x=null, $y=null) {\n\t\t$this->Skew(0, $angle_y, $x, $y);\n\t}\n\n\t/**\n\t * Skew.\n\t * @param float $angle_x angle in degrees between -90 (skew to the left) and 90 (skew to the right)\n\t * @param float $angle_y angle in degrees between -90 (skew to the bottom) and 90 (skew to the top)\n\t * @param float|null $x abscissa of the skewing center. default is current x position\n\t * @param float|null $y ordinate of the skewing center. default is current y position\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tpublic function Skew($angle_x, $angle_y, $x=null, $y=null) {\n\t\tif (TCPDF_STATIC::empty_string($x)) {\n\t\t\t$x = $this->x;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($y)) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\tif (($angle_x <= -90) OR ($angle_x >= 90) OR ($angle_y <= -90) OR ($angle_y >= 90)) {\n\t\t\t$this->Error('Please use values between -90 and +90 degrees for Skewing.');\n\t\t}\n\t\t$x *= $this->k;\n\t\t$y = ($this->h - $y) * $this->k;\n\t\t//calculate elements of transformation matrix\n\t\t$tm = array();\n\t\t$tm[0] = 1;\n\t\t$tm[1] = tan(deg2rad($angle_y));\n\t\t$tm[2] = tan(deg2rad($angle_x));\n\t\t$tm[3] = 1;\n\t\t$tm[4] = -$tm[2] * $y;\n\t\t$tm[5] = -$tm[1] * $x;\n\t\t//skew the coordinate system\n\t\t$this->Transform($tm);\n\t}\n\n\t/**\n\t * Apply graphic transformations.\n\t * @param array $tm transformation matrix\n\t * @protected\n\t * @since 2.1.000 (2008-01-07)\n\t * @see StartTransform(), StopTransform()\n\t */\n\tprotected function Transform($tm) {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\t$this->_out(sprintf('%F %F %F %F %F %F cm', $tm[0], $tm[1], $tm[2], $tm[3], $tm[4], $tm[5]));\n\t\t// add tranformation matrix\n\t\t$this->transfmatrix[$this->transfmatrix_key][] = array('a' => $tm[0], 'b' => $tm[1], 'c' => $tm[2], 'd' => $tm[3], 'e' => $tm[4], 'f' => $tm[5]);\n\t\t// update transformation mark\n\t\tif ($this->inxobj) {\n\t\t\t// we are inside an XObject template\n\t\t\tif (end($this->xobjects[$this->xobjid]['transfmrk']) !== false) {\n\t\t\t\t$key = key($this->xobjects[$this->xobjid]['transfmrk']);\n\t\t\t\t$this->xobjects[$this->xobjid]['transfmrk'][$key] = strlen($this->xobjects[$this->xobjid]['outdata']);\n\t\t\t}\n\t\t} elseif (end($this->transfmrk[$this->page]) !== false) {\n\t\t\t$key = key($this->transfmrk[$this->page]);\n\t\t\t$this->transfmrk[$this->page][$key] = $this->pagelen[$this->page];\n\t\t}\n\t}\n\n\t// END TRANSFORMATIONS SECTION -------------------------\n\n\t// START GRAPHIC FUNCTIONS SECTION ---------------------\n\t// The following section is based on the code provided by David Hernandez Sanz\n\n\t/**\n\t * Defines the line width. By default, the value equals 0.2 mm. The method can be called before the first page is created and the value is retained from page to page.\n\t * @param float $width The width.\n\t * @public\n\t * @since 1.0\n\t * @see Line(), Rect(), Cell(), MultiCell()\n\t */\n\tpublic function setLineWidth($width) {\n\t\t//Set line width\n\t\t$this->LineWidth = $width;\n\t\t$this->linestyleWidth = sprintf('%F w', ($width * $this->k));\n\t\tif ($this->state == 2) {\n\t\t\t$this->_out($this->linestyleWidth);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the current the line width.\n\t * @return int Line width\n\t * @public\n\t * @since 2.1.000 (2008-01-07)\n\t * @see Line(), SetLineWidth()\n\t */\n\tpublic function GetLineWidth() {\n\t\treturn $this->LineWidth;\n\t}\n\n\t/**\n\t * Set line style.\n\t * @param array $style Line style. Array with keys among the following:\n\t * <ul>\n\t *\t <li>width (float): Width of the line in user units.</li>\n\t *\t <li>cap (string): Type of cap to put on the line. Possible values are:\n\t * butt, round, square. The difference between \"square\" and \"butt\" is that\n\t * \"square\" projects a flat end past the end of the line.</li>\n\t *\t <li>join (string): Type of join. Possible values are: miter, round,\n\t * bevel.</li>\n\t *\t <li>dash (mixed): Dash pattern. Is 0 (without dash) or string with\n\t * series of length values, which are the lengths of the on and off dashes.\n\t * For example: \"2\" represents 2 on, 2 off, 2 on, 2 off, ...; \"2,1\" is 2 on,\n\t * 1 off, 2 on, 1 off, ...</li>\n\t *\t <li>phase (integer): Modifier on the dash pattern which is used to shift\n\t * the point at which the pattern starts.</li>\n\t *\t <li>color (array): Draw color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName).</li>\n\t * </ul>\n\t * @param boolean $ret if true do not send the command.\n\t * @return string the PDF command\n\t * @public\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tpublic function setLineStyle($style, $ret=false) {\n\t\t$s = ''; // string to be returned\n\t\tif (!is_array($style)) {\n\t\t\treturn $s;\n\t\t}\n\t\tif (isset($style['width'])) {\n\t\t\t$this->LineWidth = $style['width'];\n\t\t\t$this->linestyleWidth = sprintf('%F w', ($style['width'] * $this->k));\n\t\t\t$s .= $this->linestyleWidth.' ';\n\t\t}\n\t\tif (isset($style['cap'])) {\n\t\t\t$ca = array('butt' => 0, 'round'=> 1, 'square' => 2);\n\t\t\tif (isset($ca[$style['cap']])) {\n\t\t\t\t$this->linestyleCap = $ca[$style['cap']].' J';\n\t\t\t\t$s .= $this->linestyleCap.' ';\n\t\t\t}\n\t\t}\n\t\tif (isset($style['join'])) {\n\t\t\t$ja = array('miter' => 0, 'round' => 1, 'bevel' => 2);\n\t\t\tif (isset($ja[$style['join']])) {\n\t\t\t\t$this->linestyleJoin = $ja[$style['join']].' j';\n\t\t\t\t$s .= $this->linestyleJoin.' ';\n\t\t\t}\n\t\t}\n\t\tif (isset($style['dash'])) {\n\t\t\t$dash_string = '';\n\t\t\tif ($style['dash']) {\n\t\t\t\tif (preg_match('/^.+,/', $style['dash']) > 0) {\n\t\t\t\t\t$tab = explode(',', $style['dash']);\n\t\t\t\t} else {\n\t\t\t\t\t$tab = array($style['dash']);\n\t\t\t\t}\n\t\t\t\t$dash_string = '';\n\t\t\t\tforeach ($tab as $i => $v) {\n\t\t\t\t\tif ($i) {\n\t\t\t\t\t\t$dash_string .= ' ';\n\t\t\t\t\t}\n\t\t\t\t\t$dash_string .= sprintf('%F', $v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isset($style['phase']) OR !$style['dash']) {\n\t\t\t\t$style['phase'] = 0;\n\t\t\t}\n\t\t\t$this->linestyleDash = sprintf('[%s] %F d', $dash_string, $style['phase']);\n\t\t\t$s .= $this->linestyleDash.' ';\n\t\t}\n\t\tif (isset($style['color'])) {\n\t\t\t$s .= $this->setDrawColorArray($style['color'], true).' ';\n\t\t}\n\t\tif (!$ret AND ($this->state == 2)) {\n\t\t\t$this->_out($s);\n\t\t}\n\t\treturn $s;\n\t}\n\n\t/**\n\t * Begin a new subpath by moving the current point to coordinates (x, y), omitting any connecting line segment.\n\t * @param float $x Abscissa of point.\n\t * @param float $y Ordinate of point.\n\t * @protected\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tprotected function _outPoint($x, $y) {\n\t\tif ($this->state == 2) {\n\t\t\t$this->_out(sprintf('%F %F m', ($x * $this->k), (($this->h - $y) * $this->k)));\n\t\t}\n\t}\n\n\t/**\n\t * Append a straight line segment from the current point to the point (x, y).\n\t * The new current point shall be (x, y).\n\t * @param float $x Abscissa of end point.\n\t * @param float $y Ordinate of end point.\n\t * @protected\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tprotected function _outLine($x, $y) {\n\t\tif ($this->state == 2) {\n\t\t\t$this->_out(sprintf('%F %F l', ($x * $this->k), (($this->h - $y) * $this->k)));\n\t\t}\n\t}\n\n\t/**\n\t * Append a rectangle to the current path as a complete subpath, with lower-left corner (x, y) and dimensions widthand height in user space.\n\t * @param float $x Abscissa of upper-left corner.\n\t * @param float $y Ordinate of upper-left corner.\n\t * @param float $w Width.\n\t * @param float $h Height.\n\t * @param string $op options\n\t * @protected\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tprotected function _outRect($x, $y, $w, $h, $op) {\n\t\tif ($this->state == 2) {\n\t\t\t$this->_out(sprintf('%F %F %F %F re %s', ($x * $this->k), (($this->h - $y) * $this->k), ($w * $this->k), (-$h * $this->k), $op));\n\t\t}\n\t}\n\n\t/**\n\t * Append a cubic Bezier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using (x1, y1) and (x2, y2) as the Bezier control points.\n\t * The new current point shall be (x3, y3).\n\t * @param float $x1 Abscissa of control point 1.\n\t * @param float $y1 Ordinate of control point 1.\n\t * @param float $x2 Abscissa of control point 2.\n\t * @param float $y2 Ordinate of control point 2.\n\t * @param float $x3 Abscissa of end point.\n\t * @param float $y3 Ordinate of end point.\n\t * @protected\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tprotected function _outCurve($x1, $y1, $x2, $y2, $x3, $y3) {\n\t\tif ($this->state == 2) {\n\t\t\t$this->_out(sprintf('%F %F %F %F %F %F c', ($x1 * $this->k), (($this->h - $y1) * $this->k), ($x2 * $this->k), (($this->h - $y2) * $this->k), ($x3 * $this->k), (($this->h - $y3) * $this->k)));\n\t\t}\n\t}\n\n\t/**\n\t * Append a cubic Bezier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using the current point and (x2, y2) as the Bezier control points.\n\t * The new current point shall be (x3, y3).\n\t * @param float $x2 Abscissa of control point 2.\n\t * @param float $y2 Ordinate of control point 2.\n\t * @param float $x3 Abscissa of end point.\n\t * @param float $y3 Ordinate of end point.\n\t * @protected\n\t * @since 4.9.019 (2010-04-26)\n\t */\n\tprotected function _outCurveV($x2, $y2, $x3, $y3) {\n\t\tif ($this->state == 2) {\n\t\t\t$this->_out(sprintf('%F %F %F %F v', ($x2 * $this->k), (($this->h - $y2) * $this->k), ($x3 * $this->k), (($this->h - $y3) * $this->k)));\n\t\t}\n\t}\n\n\t/**\n\t * Append a cubic Bezier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using (x1, y1) and (x3, y3) as the Bezier control points.\n\t * The new current point shall be (x3, y3).\n\t * @param float $x1 Abscissa of control point 1.\n\t * @param float $y1 Ordinate of control point 1.\n\t * @param float $x3 Abscissa of end point.\n\t * @param float $y3 Ordinate of end point.\n\t * @protected\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tprotected function _outCurveY($x1, $y1, $x3, $y3) {\n\t\tif ($this->state == 2) {\n\t\t\t$this->_out(sprintf('%F %F %F %F y', ($x1 * $this->k), (($this->h - $y1) * $this->k), ($x3 * $this->k), (($this->h - $y3) * $this->k)));\n\t\t}\n\t}\n\n\t/**\n\t * Draws a line between two points.\n\t * @param float $x1 Abscissa of first point.\n\t * @param float $y1 Ordinate of first point.\n\t * @param float $x2 Abscissa of second point.\n\t * @param float $y2 Ordinate of second point.\n\t * @param array $style Line style. Array like for SetLineStyle(). Default value: default line style (empty array).\n\t * @public\n\t * @since 1.0\n\t * @see SetLineWidth(), SetDrawColor(), SetLineStyle()\n\t */\n\tpublic function Line($x1, $y1, $x2, $y2, $style=array()) {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\tif (is_array($style)) {\n\t\t\t$this->setLineStyle($style);\n\t\t}\n\t\t$this->_outPoint($x1, $y1);\n\t\t$this->_outLine($x2, $y2);\n\t\t$this->_out('S');\n\t}\n\n\t/**\n\t * Draws a rectangle.\n\t * @param float $x Abscissa of upper-left corner.\n\t * @param float $y Ordinate of upper-left corner.\n\t * @param float $w Width.\n\t * @param float $h Height.\n\t * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.\n\t * @param array $border_style Border style of rectangle. Array with keys among the following:\n\t * <ul>\n\t *\t <li>all: Line style of all borders. Array like for SetLineStyle().</li>\n\t *\t <li>L, T, R, B or combinations: Line style of left, top, right or bottom border. Array like for SetLineStyle().</li>\n\t * </ul>\n\t * If a key is not present or is null, the correspondent border is not drawn. Default value: default line style (empty array).\n\t * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).\n\t * @public\n\t * @since 1.0\n\t * @see SetLineStyle()\n\t */\n\tpublic function Rect($x, $y, $w, $h, $style='', $border_style=array(), $fill_color=array()) {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\tif (empty($style)) {\n\t\t\t$style = 'S';\n\t\t}\n\t\tif (!(strpos($style, 'F') === false) AND !empty($fill_color)) {\n\t\t\t// set background color\n\t\t\t$this->setFillColorArray($fill_color);\n\t\t}\n\t\tif (!empty($border_style)) {\n\t\t\tif (isset($border_style['all']) AND !empty($border_style['all'])) {\n\t\t\t\t//set global style for border\n\t\t\t\t$this->setLineStyle($border_style['all']);\n\t\t\t\t$border_style = array();\n\t\t\t} else {\n\t\t\t\t// remove stroke operator from style\n\t\t\t\t$opnostroke = array('S' => '', 'D' => '', 's' => '', 'd' => '', 'B' => 'F', 'FD' => 'F', 'DF' => 'F', 'B*' => 'F*', 'F*D' => 'F*', 'DF*' => 'F*', 'b' => 'f', 'fd' => 'f', 'df' => 'f', 'b*' => 'f*', 'f*d' => 'f*', 'df*' => 'f*' );\n\t\t\t\tif (isset($opnostroke[$style])) {\n\t\t\t\t\t$style = $opnostroke[$style];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!empty($style)) {\n\t\t\t$op = TCPDF_STATIC::getPathPaintOperator($style);\n\t\t\t$this->_outRect($x, $y, $w, $h, $op);\n\t\t}\n\t\tif (!empty($border_style)) {\n\t\t\t$border_style2 = array();\n\t\t\tforeach ($border_style as $line => $value) {\n\t\t\t\t$length = strlen($line);\n\t\t\t\tfor ($i = 0; $i < $length; ++$i) {\n\t\t\t\t\t$border_style2[$line[$i]] = $value;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$border_style = $border_style2;\n\t\t\tif (isset($border_style['L']) AND $border_style['L']) {\n\t\t\t\t$this->Line($x, $y, $x, $y + $h, $border_style['L']);\n\t\t\t}\n\t\t\tif (isset($border_style['T']) AND $border_style['T']) {\n\t\t\t\t$this->Line($x, $y, $x + $w, $y, $border_style['T']);\n\t\t\t}\n\t\t\tif (isset($border_style['R']) AND $border_style['R']) {\n\t\t\t\t$this->Line($x + $w, $y, $x + $w, $y + $h, $border_style['R']);\n\t\t\t}\n\t\t\tif (isset($border_style['B']) AND $border_style['B']) {\n\t\t\t\t$this->Line($x, $y + $h, $x + $w, $y + $h, $border_style['B']);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Draws a Bezier curve.\n\t * The Bezier curve is a tangent to the line between the control points at\n\t * either end of the curve.\n\t * @param float $x0 Abscissa of start point.\n\t * @param float $y0 Ordinate of start point.\n\t * @param float $x1 Abscissa of control point 1.\n\t * @param float $y1 Ordinate of control point 1.\n\t * @param float $x2 Abscissa of control point 2.\n\t * @param float $y2 Ordinate of control point 2.\n\t * @param float $x3 Abscissa of end point.\n\t * @param float $y3 Ordinate of end point.\n\t * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.\n\t * @param array $line_style Line style of curve. Array like for SetLineStyle(). Default value: default line style (empty array).\n\t * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).\n\t * @public\n\t * @see SetLineStyle()\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tpublic function Curve($x0, $y0, $x1, $y1, $x2, $y2, $x3, $y3, $style='', $line_style=array(), $fill_color=array()) {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\tif (!(false === strpos($style, 'F')) AND is_array($fill_color)) {\n\t\t\t$this->setFillColorArray($fill_color);\n\t\t}\n\t\t$op = TCPDF_STATIC::getPathPaintOperator($style);\n\t\tif ($line_style) {\n\t\t\t$this->setLineStyle($line_style);\n\t\t}\n\t\t$this->_outPoint($x0, $y0);\n\t\t$this->_outCurve($x1, $y1, $x2, $y2, $x3, $y3);\n\t\t$this->_out($op);\n\t}\n\n\t/**\n\t * Draws a poly-Bezier curve.\n\t * Each Bezier curve segment is a tangent to the line between the control points at\n\t * either end of the curve.\n\t * @param float $x0 Abscissa of start point.\n\t * @param float $y0 Ordinate of start point.\n\t * @param float[] $segments An array of bezier descriptions. Format: array(x1, y1, x2, y2, x3, y3).\n\t * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.\n\t * @param array $line_style Line style of curve. Array like for SetLineStyle(). Default value: default line style (empty array).\n\t * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).\n\t * @public\n\t * @see SetLineStyle()\n\t * @since 3.0008 (2008-05-12)\n\t */\n\tpublic function Polycurve($x0, $y0, $segments, $style='', $line_style=array(), $fill_color=array()) {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\tif (!(false === strpos($style, 'F')) AND is_array($fill_color)) {\n\t\t\t$this->setFillColorArray($fill_color);\n\t\t}\n\t\t$op = TCPDF_STATIC::getPathPaintOperator($style);\n\t\tif ($op == 'f') {\n\t\t\t$line_style = array();\n\t\t}\n\t\tif ($line_style) {\n\t\t\t$this->setLineStyle($line_style);\n\t\t}\n\t\t$this->_outPoint($x0, $y0);\n\t\tforeach ($segments as $segment) {\n\t\t\tlist($x1, $y1, $x2, $y2, $x3, $y3) = $segment;\n\t\t\t$this->_outCurve($x1, $y1, $x2, $y2, $x3, $y3);\n\t\t}\n\t\t$this->_out($op);\n\t}\n\n\t/**\n\t * Draws an ellipse.\n\t * An ellipse is formed from n Bezier curves.\n\t * @param float $x0 Abscissa of center point.\n\t * @param float $y0 Ordinate of center point.\n\t * @param float $rx Horizontal radius.\n\t * @param float $ry Vertical radius (if ry = 0 then is a circle, see Circle()). Default value: 0.\n\t * @param float $angle Angle oriented (anti-clockwise). Default value: 0.\n\t * @param float $astart Angle start of draw line. Default value: 0.\n\t * @param float $afinish Angle finish of draw line. Default value: 360.\n\t * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.\n\t * @param array $line_style Line style of ellipse. Array like for SetLineStyle(). Default value: default line style (empty array).\n\t * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).\n\t * @param integer $nc Number of curves used to draw a 90 degrees portion of ellipse.\n\t * @author Nicola Asuni\n\t * @public\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tpublic function Ellipse($x0, $y0, $rx, $ry=0, $angle=0, $astart=0, $afinish=360, $style='', $line_style=array(), $fill_color=array(), $nc=2) {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($ry) OR ($ry == 0)) {\n\t\t\t$ry = $rx;\n\t\t}\n\t\tif (!(false === strpos($style, 'F')) AND is_array($fill_color)) {\n\t\t\t$this->setFillColorArray($fill_color);\n\t\t}\n\t\t$op = TCPDF_STATIC::getPathPaintOperator($style);\n\t\tif ($op == 'f') {\n\t\t\t$line_style = array();\n\t\t}\n\t\tif ($line_style) {\n\t\t\t$this->setLineStyle($line_style);\n\t\t}\n\t\t$this->_outellipticalarc($x0, $y0, $rx, $ry, $angle, $astart, $afinish, false, $nc, true, true, false);\n\t\t$this->_out($op);\n\t}\n\n\t/**\n\t * Append an elliptical arc to the current path.\n\t * An ellipse is formed from n Bezier curves.\n\t * @param float $xc Abscissa of center point.\n\t * @param float $yc Ordinate of center point.\n\t * @param float $rx Horizontal radius.\n\t * @param float $ry Vertical radius (if ry = 0 then is a circle, see Circle()). Default value: 0.\n\t * @param float $xang Angle between the X-axis and the major axis of the ellipse. Default value: 0.\n\t * @param float $angs Angle start of draw line. Default value: 0.\n\t * @param float $angf Angle finish of draw line. Default value: 360.\n\t * @param boolean $pie if true do not mark the border point (used to draw pie sectors).\n\t * @param integer $nc Number of curves used to draw a 90 degrees portion of ellipse.\n\t * @param boolean $startpoint if true output a starting point.\n\t * @param boolean $ccw if true draws in counter-clockwise.\n\t * @param boolean $svg if true the angles are in svg mode (already calculated).\n\t * @return array bounding box coordinates (x min, y min, x max, y max)\n\t * @author Nicola Asuni\n\t * @protected\n\t * @since 4.9.019 (2010-04-26)\n\t */\n\tprotected function _outellipticalarc($xc, $yc, $rx, $ry, $xang=0, $angs=0, $angf=360, $pie=false, $nc=2, $startpoint=true, $ccw=true, $svg=false) {\n\t\tif (($rx <= 0) OR ($ry < 0)) {\n\t\t\treturn;\n\t\t}\n\t\t$k = $this->k;\n\t\tif ($nc < 2) {\n\t\t\t$nc = 2;\n\t\t}\n\t\t$xmin = 2147483647;\n\t\t$ymin = 2147483647;\n\t\t$xmax = 0;\n\t\t$ymax = 0;\n\t\tif ($pie) {\n\t\t\t// center of the arc\n\t\t\t$this->_outPoint($xc, $yc);\n\t\t}\n\t\t$xang = deg2rad((float) $xang);\n\t\t$angs = deg2rad((float) $angs);\n\t\t$angf = deg2rad((float) $angf);\n\t\tif ($svg) {\n\t\t\t$as = $angs;\n\t\t\t$af = $angf;\n\t\t} else {\n\t\t\t$as = atan2((sin($angs) / $ry), (cos($angs) / $rx));\n\t\t\t$af = atan2((sin($angf) / $ry), (cos($angf) / $rx));\n\t\t}\n\t\tif ($as < 0) {\n\t\t\t$as += (2 * M_PI);\n\t\t}\n\t\tif ($af < 0) {\n\t\t\t$af += (2 * M_PI);\n\t\t}\n\t\tif ($ccw AND ($as > $af)) {\n\t\t\t// reverse rotation\n\t\t\t$as -= (2 * M_PI);\n\t\t} elseif (!$ccw AND ($as < $af)) {\n\t\t\t// reverse rotation\n\t\t\t$af -= (2 * M_PI);\n\t\t}\n\t\t$total_angle = ($af - $as);\n\t\tif ($nc < 2) {\n\t\t\t$nc = 2;\n\t\t}\n\t\t// total arcs to draw\n\t\t$nc *= (2 * abs($total_angle) / M_PI);\n\t\t$nc = round($nc) + 1;\n\t\t// angle of each arc\n\t\t$arcang = ($total_angle / $nc);\n\t\t// center point in PDF coordinates\n\t\t$x0 = $xc;\n\t\t$y0 = ($this->h - $yc);\n\t\t// starting angle\n\t\t$ang = $as;\n\t\t$alpha = sin($arcang) * ((sqrt(4 + (3 * pow(tan(($arcang) / 2), 2))) - 1) / 3);\n\t\t$cos_xang = cos($xang);\n\t\t$sin_xang = sin($xang);\n\t\t$cos_ang = cos($ang);\n\t\t$sin_ang = sin($ang);\n\t\t// first arc point\n\t\t$px1 = $x0 + ($rx * $cos_xang * $cos_ang) - ($ry * $sin_xang * $sin_ang);\n\t\t$py1 = $y0 + ($rx * $sin_xang * $cos_ang) + ($ry * $cos_xang * $sin_ang);\n\t\t// first Bezier control point\n\t\t$qx1 = ($alpha * ((-$rx * $cos_xang * $sin_ang) - ($ry * $sin_xang * $cos_ang)));\n\t\t$qy1 = ($alpha * ((-$rx * $sin_xang * $sin_ang) + ($ry * $cos_xang * $cos_ang)));\n\t\tif ($pie) {\n\t\t\t// line from center to arc starting point\n\t\t\t$this->_outLine($px1, $this->h - $py1);\n\t\t} elseif ($startpoint) {\n\t\t\t// arc starting point\n\t\t\t$this->_outPoint($px1, $this->h - $py1);\n\t\t}\n\t\t// draw arcs\n\t\tfor ($i = 1; $i <= $nc; ++$i) {\n\t\t\t// starting angle\n\t\t\t$ang = $as + ($i * $arcang);\n\t\t\tif ($i == $nc) {\n\t\t\t\t$ang = $af;\n\t\t\t}\n\t\t\t$cos_ang = cos($ang);\n\t\t\t$sin_ang = sin($ang);\n\t\t\t// second arc point\n\t\t\t$px2 = $x0 + ($rx * $cos_xang * $cos_ang) - ($ry * $sin_xang * $sin_ang);\n\t\t\t$py2 = $y0 + ($rx * $sin_xang * $cos_ang) + ($ry * $cos_xang * $sin_ang);\n\t\t\t// second Bezier control point\n\t\t\t$qx2 = ($alpha * ((-$rx * $cos_xang * $sin_ang) - ($ry * $sin_xang * $cos_ang)));\n\t\t\t$qy2 = ($alpha * ((-$rx * $sin_xang * $sin_ang) + ($ry * $cos_xang * $cos_ang)));\n\t\t\t// draw arc\n\t\t\t$cx1 = ($px1 + $qx1);\n\t\t\t$cy1 = ($this->h - ($py1 + $qy1));\n\t\t\t$cx2 = ($px2 - $qx2);\n\t\t\t$cy2 = ($this->h - ($py2 - $qy2));\n\t\t\t$cx3 = $px2;\n\t\t\t$cy3 = ($this->h - $py2);\n\t\t\t$this->_outCurve($cx1, $cy1, $cx2, $cy2, $cx3, $cy3);\n\t\t\t// get bounding box coordinates\n\t\t\t$xmin = min($xmin, $cx1, $cx2, $cx3);\n\t\t\t$ymin = min($ymin, $cy1, $cy2, $cy3);\n\t\t\t$xmax = max($xmax, $cx1, $cx2, $cx3);\n\t\t\t$ymax = max($ymax, $cy1, $cy2, $cy3);\n\t\t\t// move to next point\n\t\t\t$px1 = $px2;\n\t\t\t$py1 = $py2;\n\t\t\t$qx1 = $qx2;\n\t\t\t$qy1 = $qy2;\n\t\t}\n\t\tif ($pie) {\n\t\t\t$this->_outLine($xc, $yc);\n\t\t\t// get bounding box coordinates\n\t\t\t$xmin = min($xmin, $xc);\n\t\t\t$ymin = min($ymin, $yc);\n\t\t\t$xmax = max($xmax, $xc);\n\t\t\t$ymax = max($ymax, $yc);\n\t\t}\n\t\treturn array($xmin, $ymin, $xmax, $ymax);\n\t}\n\n\t/**\n\t * Draws a circle.\n\t * A circle is formed from n Bezier curves.\n\t * @param float $x0 Abscissa of center point.\n\t * @param float $y0 Ordinate of center point.\n\t * @param float $r Radius.\n\t * @param float $angstr Angle start of draw line. Default value: 0.\n\t * @param float $angend Angle finish of draw line. Default value: 360.\n\t * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.\n\t * @param array $line_style Line style of circle. Array like for SetLineStyle(). Default value: default line style (empty array).\n\t * @param array $fill_color Fill color. Format: array(red, green, blue). Default value: default color (empty array).\n\t * @param integer $nc Number of curves used to draw a 90 degrees portion of circle.\n\t * @public\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tpublic function Circle($x0, $y0, $r, $angstr=0, $angend=360, $style='', $line_style=array(), $fill_color=array(), $nc=2) {\n\t\t$this->Ellipse($x0, $y0, $r, $r, 0, $angstr, $angend, $style, $line_style, $fill_color, $nc);\n\t}\n\n\t/**\n\t * Draws a polygonal line\n\t * @param array $p Points 0 to ($np - 1). Array with values (x0, y0, x1, y1,..., x(np-1), y(np - 1))\n\t * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.\n\t * @param array $line_style Line style of polygon. Array with keys among the following:\n\t * <ul>\n\t *\t <li>all: Line style of all lines. Array like for SetLineStyle().</li>\n\t *\t <li>0 to ($np - 1): Line style of each line. Array like for SetLineStyle().</li>\n\t * </ul>\n\t * If a key is not present or is null, not draws the line. Default value is default line style (empty array).\n\t * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).\n\t * @since 4.8.003 (2009-09-15)\n\t * @public\n\t */\n\tpublic function PolyLine($p, $style='', $line_style=array(), $fill_color=array()) {\n\t\t$this->Polygon($p, $style, $line_style, $fill_color, false);\n\t}\n\n\t/**\n\t * Draws a polygon.\n\t * @param array $p Points 0 to ($np - 1). Array with values (x0, y0, x1, y1,..., x(np-1), y(np - 1))\n\t * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.\n\t * @param array $line_style Line style of polygon. Array with keys among the following:\n\t * <ul>\n\t *\t <li>all: Line style of all lines. Array like for SetLineStyle().</li>\n\t *\t <li>0 to ($np - 1): Line style of each line. Array like for SetLineStyle().</li>\n\t * </ul>\n\t * If a key is not present or is null, not draws the line. Default value is default line style (empty array).\n\t * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).\n\t * @param boolean $closed if true the polygon is closes, otherwise will remain open\n\t * @public\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tpublic function Polygon($p, $style='', $line_style=array(), $fill_color=array(), $closed=true) {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\t$nc = count($p); // number of coordinates\n\t\t$np = $nc / 2; // number of points\n\t\tif ($closed) {\n\t\t\t// close polygon by adding the first 2 points at the end (one line)\n\t\t\tfor ($i = 0; $i < 4; ++$i) {\n\t\t\t\t$p[$nc + $i] = $p[$i];\n\t\t\t}\n\t\t\t// copy style for the last added line\n\t\t\tif (isset($line_style[0])) {\n\t\t\t\t$line_style[$np] = $line_style[0];\n\t\t\t}\n\t\t\t$nc += 4;\n\t\t}\n\t\tif (!(false === strpos($style, 'F')) AND is_array($fill_color)) {\n\t\t\t$this->setFillColorArray($fill_color);\n\t\t}\n\t\t$op = TCPDF_STATIC::getPathPaintOperator($style);\n\t\tif ($op == 'f') {\n\t\t\t$line_style = array();\n\t\t}\n\t\t$draw = true;\n\t\tif ($line_style) {\n\t\t\tif (isset($line_style['all'])) {\n\t\t\t\t$this->setLineStyle($line_style['all']);\n\t\t\t} else {\n\t\t\t\t$draw = false;\n\t\t\t\tif ($op == 'B') {\n\t\t\t\t\t// draw fill\n\t\t\t\t\t$op = 'f';\n\t\t\t\t\t$this->_outPoint($p[0], $p[1]);\n\t\t\t\t\tfor ($i = 2; $i < $nc; $i = $i + 2) {\n\t\t\t\t\t\t$this->_outLine($p[$i], $p[$i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\t$this->_out($op);\n\t\t\t\t}\n\t\t\t\t// draw outline\n\t\t\t\t$this->_outPoint($p[0], $p[1]);\n\t\t\t\tfor ($i = 2; $i < $nc; $i = $i + 2) {\n\t\t\t\t\t$line_num = ($i / 2) - 1;\n\t\t\t\t\tif (isset($line_style[$line_num])) {\n\t\t\t\t\t\tif ($line_style[$line_num] != 0) {\n\t\t\t\t\t\t\tif (is_array($line_style[$line_num])) {\n\t\t\t\t\t\t\t\t$this->_out('S');\n\t\t\t\t\t\t\t\t$this->setLineStyle($line_style[$line_num]);\n\t\t\t\t\t\t\t\t$this->_outPoint($p[$i - 2], $p[$i - 1]);\n\t\t\t\t\t\t\t\t$this->_outLine($p[$i], $p[$i + 1]);\n\t\t\t\t\t\t\t\t$this->_out('S');\n\t\t\t\t\t\t\t\t$this->_outPoint($p[$i], $p[$i + 1]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$this->_outLine($p[$i], $p[$i + 1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->_outLine($p[$i], $p[$i + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$this->_out($op);\n\t\t\t}\n\t\t}\n\t\tif ($draw) {\n\t\t\t$this->_outPoint($p[0], $p[1]);\n\t\t\tfor ($i = 2; $i < $nc; $i = $i + 2) {\n\t\t\t\t$this->_outLine($p[$i], $p[$i + 1]);\n\t\t\t}\n\t\t\t$this->_out($op);\n\t\t}\n\t}\n\n\t/**\n\t * Draws a regular polygon.\n\t * @param float $x0 Abscissa of center point.\n\t * @param float $y0 Ordinate of center point.\n\t * @param float $r Radius of inscribed circle.\n\t * @param integer $ns Number of sides.\n\t * @param float $angle Angle oriented (anti-clockwise). Default value: 0.\n\t * @param boolean $draw_circle Draw inscribed circle or not. Default value: false.\n\t * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.\n\t * @param array $line_style Line style of polygon sides. Array with keys among the following:\n\t * <ul>\n\t *\t <li>all: Line style of all sides. Array like for SetLineStyle().</li>\n\t *\t <li>0 to ($ns - 1): Line style of each side. Array like for SetLineStyle().</li>\n\t * </ul>\n\t * If a key is not present or is null, not draws the side. Default value is default line style (empty array).\n\t * @param array $fill_color Fill color. Format: array(red, green, blue). Default value: default color (empty array).\n\t * @param string $circle_style Style of rendering of inscribed circle (if draws). Possible values are:\n\t * <ul>\n\t *\t <li>D or empty string: Draw (default).</li>\n\t *\t <li>F: Fill.</li>\n\t *\t <li>DF or FD: Draw and fill.</li>\n\t *\t <li>CNZ: Clipping mode (using the even-odd rule to determine which regions lie inside the clipping path).</li>\n\t *\t <li>CEO: Clipping mode (using the nonzero winding number rule to determine which regions lie inside the clipping path).</li>\n\t * </ul>\n\t * @param array $circle_outLine_style Line style of inscribed circle (if draws). Array like for SetLineStyle(). Default value: default line style (empty array).\n\t * @param array $circle_fill_color Fill color of inscribed circle (if draws). Format: array(red, green, blue). Default value: default color (empty array).\n\t * @public\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tpublic function RegularPolygon($x0, $y0, $r, $ns, $angle=0, $draw_circle=false, $style='', $line_style=array(), $fill_color=array(), $circle_style='', $circle_outLine_style=array(), $circle_fill_color=array()) {\n\t\tif (3 > $ns) {\n\t\t\t$ns = 3;\n\t\t}\n\t\tif ($draw_circle) {\n\t\t\t$this->Circle($x0, $y0, $r, 0, 360, $circle_style, $circle_outLine_style, $circle_fill_color);\n\t\t}\n\t\t$p = array();\n\t\tfor ($i = 0; $i < $ns; ++$i) {\n\t\t\t$a = $angle + ($i * 360 / $ns);\n\t\t\t$a_rad = deg2rad((float) $a);\n\t\t\t$p[] = $x0 + ($r * sin($a_rad));\n\t\t\t$p[] = $y0 + ($r * cos($a_rad));\n\t\t}\n\t\t$this->Polygon($p, $style, $line_style, $fill_color);\n\t}\n\n\t/**\n\t * Draws a star polygon\n\t * @param float $x0 Abscissa of center point.\n\t * @param float $y0 Ordinate of center point.\n\t * @param float $r Radius of inscribed circle.\n\t * @param integer $nv Number of vertices.\n\t * @param integer $ng Number of gap (if ($ng % $nv = 1) then is a regular polygon).\n\t * @param float $angle Angle oriented (anti-clockwise). Default value: 0.\n\t * @param boolean $draw_circle Draw inscribed circle or not. Default value is false.\n\t * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.\n\t * @param array $line_style Line style of polygon sides. Array with keys among the following:\n\t * <ul>\n\t *\t <li>all: Line style of all sides. Array like for\n\t * SetLineStyle().</li>\n\t *\t <li>0 to (n - 1): Line style of each side. Array like for SetLineStyle().</li>\n\t * </ul>\n\t * If a key is not present or is null, not draws the side. Default value is default line style (empty array).\n\t * @param array $fill_color Fill color. Format: array(red, green, blue). Default value: default color (empty array).\n\t * @param string $circle_style Style of rendering of inscribed circle (if draws). Possible values are:\n\t * <ul>\n\t *\t <li>D or empty string: Draw (default).</li>\n\t *\t <li>F: Fill.</li>\n\t *\t <li>DF or FD: Draw and fill.</li>\n\t *\t <li>CNZ: Clipping mode (using the even-odd rule to determine which regions lie inside the clipping path).</li>\n\t *\t <li>CEO: Clipping mode (using the nonzero winding number rule to determine which regions lie inside the clipping path).</li>\n\t * </ul>\n\t * @param array $circle_outLine_style Line style of inscribed circle (if draws). Array like for SetLineStyle(). Default value: default line style (empty array).\n\t * @param array $circle_fill_color Fill color of inscribed circle (if draws). Format: array(red, green, blue). Default value: default color (empty array).\n\t * @public\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tpublic function StarPolygon($x0, $y0, $r, $nv, $ng, $angle=0, $draw_circle=false, $style='', $line_style=array(), $fill_color=array(), $circle_style='', $circle_outLine_style=array(), $circle_fill_color=array()) {\n\t\tif ($nv < 2) {\n\t\t\t$nv = 2;\n\t\t}\n\t\tif ($draw_circle) {\n\t\t\t$this->Circle($x0, $y0, $r, 0, 360, $circle_style, $circle_outLine_style, $circle_fill_color);\n\t\t}\n\t\t$p2 = array();\n\t\t$visited = array();\n\t\tfor ($i = 0; $i < $nv; ++$i) {\n\t\t\t$a = $angle + ($i * 360 / $nv);\n\t\t\t$a_rad = deg2rad((float) $a);\n\t\t\t$p2[] = $x0 + ($r * sin($a_rad));\n\t\t\t$p2[] = $y0 + ($r * cos($a_rad));\n\t\t\t$visited[] = false;\n\t\t}\n\t\t$p = array();\n\t\t$i = 0;\n\t\tdo {\n\t\t\t$p[] = $p2[$i * 2];\n\t\t\t$p[] = $p2[($i * 2) + 1];\n\t\t\t$visited[$i] = true;\n\t\t\t$i += $ng;\n\t\t\t$i %= $nv;\n\t\t} while (!$visited[$i]);\n\t\t$this->Polygon($p, $style, $line_style, $fill_color);\n\t}\n\n\t/**\n\t * Draws a rounded rectangle.\n\t * @param float $x Abscissa of upper-left corner.\n\t * @param float $y Ordinate of upper-left corner.\n\t * @param float $w Width.\n\t * @param float $h Height.\n\t * @param float $r the radius of the circle used to round off the corners of the rectangle.\n\t * @param string $round_corner Draws rounded corner or not. String with a 0 (not rounded i-corner) or 1 (rounded i-corner) in i-position. Positions are, in order and begin to 0: top right, bottom right, bottom left and top left. Default value: all rounded corner (\"1111\").\n\t * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.\n\t * @param array $border_style Border style of rectangle. Array like for SetLineStyle(). Default value: default line style (empty array).\n\t * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).\n\t * @public\n\t * @since 2.1.000 (2008-01-08)\n\t */\n\tpublic function RoundedRect($x, $y, $w, $h, $r, $round_corner='1111', $style='', $border_style=array(), $fill_color=array()) {\n\t\t$this->RoundedRectXY($x, $y, $w, $h, $r, $r, $round_corner, $style, $border_style, $fill_color);\n\t}\n\n\t/**\n\t * Draws a rounded rectangle.\n\t * @param float $x Abscissa of upper-left corner.\n\t * @param float $y Ordinate of upper-left corner.\n\t * @param float $w Width.\n\t * @param float $h Height.\n\t * @param float $rx the x-axis radius of the ellipse used to round off the corners of the rectangle.\n\t * @param float $ry the y-axis radius of the ellipse used to round off the corners of the rectangle.\n\t * @param string $round_corner Draws rounded corner or not. String with a 0 (not rounded i-corner) or 1 (rounded i-corner) in i-position. Positions are, in order and begin to 0: top right, bottom right, bottom left and top left. Default value: all rounded corner (\"1111\").\n\t * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.\n\t * @param array $border_style Border style of rectangle. Array like for SetLineStyle(). Default value: default line style (empty array).\n\t * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).\n\t * @public\n\t * @since 4.9.019 (2010-04-22)\n\t */\n\tpublic function RoundedRectXY($x, $y, $w, $h, $rx, $ry, $round_corner='1111', $style='', $border_style=array(), $fill_color=array()) {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\tif (($round_corner == '0000') OR (($rx == $ry) AND ($rx == 0))) {\n\t\t\t// Not rounded\n\t\t\t$this->Rect($x, $y, $w, $h, $style, $border_style, $fill_color);\n\t\t\treturn;\n\t\t}\n\t\t// Rounded\n\t\tif (!(false === strpos($style, 'F')) AND is_array($fill_color)) {\n\t\t\t$this->setFillColorArray($fill_color);\n\t\t}\n\t\t$op = TCPDF_STATIC::getPathPaintOperator($style);\n\t\tif ($op == 'f') {\n\t\t\t$border_style = array();\n\t\t}\n\t\tif ($border_style) {\n\t\t\t$this->setLineStyle($border_style);\n\t\t}\n\t\t$MyArc = 4 / 3 * (sqrt(2) - 1);\n\t\t$this->_outPoint($x + $rx, $y);\n\t\t$xc = $x + $w - $rx;\n\t\t$yc = $y + $ry;\n\t\t$this->_outLine($xc, $y);\n\t\tif ($round_corner[0]) {\n\t\t\t$this->_outCurve($xc + ($rx * $MyArc), $yc - $ry, $xc + $rx, $yc - ($ry * $MyArc), $xc + $rx, $yc);\n\t\t} else {\n\t\t\t$this->_outLine($x + $w, $y);\n\t\t}\n\t\t$xc = $x + $w - $rx;\n\t\t$yc = $y + $h - $ry;\n\t\t$this->_outLine($x + $w, $yc);\n\t\tif ($round_corner[1]) {\n\t\t\t$this->_outCurve($xc + $rx, $yc + ($ry * $MyArc), $xc + ($rx * $MyArc), $yc + $ry, $xc, $yc + $ry);\n\t\t} else {\n\t\t\t$this->_outLine($x + $w, $y + $h);\n\t\t}\n\t\t$xc = $x + $rx;\n\t\t$yc = $y + $h - $ry;\n\t\t$this->_outLine($xc, $y + $h);\n\t\tif ($round_corner[2]) {\n\t\t\t$this->_outCurve($xc - ($rx * $MyArc), $yc + $ry, $xc - $rx, $yc + ($ry * $MyArc), $xc - $rx, $yc);\n\t\t} else {\n\t\t\t$this->_outLine($x, $y + $h);\n\t\t}\n\t\t$xc = $x + $rx;\n\t\t$yc = $y + $ry;\n\t\t$this->_outLine($x, $yc);\n\t\tif ($round_corner[3]) {\n\t\t\t$this->_outCurve($xc - $rx, $yc - ($ry * $MyArc), $xc - ($rx * $MyArc), $yc - $ry, $xc, $yc - $ry);\n\t\t} else {\n\t\t\t$this->_outLine($x, $y);\n\t\t\t$this->_outLine($x + $rx, $y);\n\t\t}\n\t\t$this->_out($op);\n\t}\n\n\t/**\n\t * Draws a grahic arrow.\n\t * @param float $x0 Abscissa of first point.\n\t * @param float $y0 Ordinate of first point.\n\t * @param float $x1 Abscissa of second point.\n\t * @param float $y1 Ordinate of second point.\n\t * @param int $head_style (0 = draw only arrowhead arms, 1 = draw closed arrowhead, but no fill, 2 = closed and filled arrowhead, 3 = filled arrowhead)\n\t * @param float $arm_size length of arrowhead arms\n\t * @param int $arm_angle angle between an arm and the shaft\n\t * @author Piotr Galecki, Nicola Asuni, Andy Meier\n\t * @since 4.6.018 (2009-07-10)\n\t */\n\tpublic function Arrow($x0, $y0, $x1, $y1, $head_style=0, $arm_size=5, $arm_angle=15) {\n\t\t// getting arrow direction angle\n\t\t// 0 deg angle is when both arms go along X axis. angle grows clockwise.\n\t\t$dir_angle = atan2(($y0 - $y1), ($x0 - $x1));\n\t\tif ($dir_angle < 0) {\n\t\t\t$dir_angle += (2 * M_PI);\n\t\t}\n\t\t$arm_angle = deg2rad($arm_angle);\n\t\t$sx1 = $x1;\n\t\t$sy1 = $y1;\n\t\tif ($head_style > 0) {\n\t\t\t// calculate the stopping point for the arrow shaft\n\t\t\t$sx1 = $x1 + (($arm_size - $this->LineWidth) * cos($dir_angle));\n\t\t\t$sy1 = $y1 + (($arm_size - $this->LineWidth) * sin($dir_angle));\n\t\t}\n\t\t// main arrow line / shaft\n\t\t$this->Line($x0, $y0, $sx1, $sy1);\n\t\t// left arrowhead arm tip\n\t\t$x2L = $x1 + ($arm_size * cos($dir_angle + $arm_angle));\n\t\t$y2L = $y1 + ($arm_size * sin($dir_angle + $arm_angle));\n\t\t// right arrowhead arm tip\n\t\t$x2R = $x1 + ($arm_size * cos($dir_angle - $arm_angle));\n\t\t$y2R = $y1 + ($arm_size * sin($dir_angle - $arm_angle));\n\t\t$mode = 'D';\n\t\t$style = array();\n\t\tswitch ($head_style) {\n\t\t\tcase 0: {\n\t\t\t\t// draw only arrowhead arms\n\t\t\t\t$mode = 'D';\n\t\t\t\t$style = array(1, 1, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1: {\n\t\t\t\t// draw closed arrowhead, but no fill\n\t\t\t\t$mode = 'D';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\t// closed and filled arrowhead\n\t\t\t\t$mode = 'DF';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\t// filled arrowhead\n\t\t\t\t$mode = 'F';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$this->Polygon(array($x2L, $y2L, $x1, $y1, $x2R, $y2R), $mode, $style, array());\n\t}\n\n\t// END GRAPHIC FUNCTIONS SECTION -----------------------\n\n\t/**\n\t * Add a Named Destination.\n\t * NOTE: destination names are unique, so only last entry will be saved.\n\t * @param string $name Destination name.\n\t * @param float $y Y position in user units of the destiantion on the selected page (default = -1 = current position; 0 = page start;).\n\t * @param int|string $page Target page number (leave empty for current page). If you prefix a page number with the * character, then this page will not be changed when adding/deleting/moving pages.\n\t * @param float $x X position in user units of the destiantion on the selected page (default = -1 = current position;).\n\t * @return string|false Stripped named destination identifier or false in case of error.\n\t * @public\n\t * @author Christian Deligant, Nicola Asuni\n\t * @since 5.9.097 (2011-06-23)\n\t */\n\tpublic function setDestination($name, $y=-1, $page='', $x=-1) {\n\t\t// remove unsupported characters\n\t\t$name = TCPDF_STATIC::encodeNameObject($name);\n\t\tif (TCPDF_STATIC::empty_string($name)) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($y == -1) {\n\t\t\t$y = $this->GetY();\n\t\t} elseif ($y < 0) {\n\t\t\t$y = 0;\n\t\t} elseif ($y > $this->h) {\n\t\t\t$y = $this->h;\n\t\t}\n\t\tif ($x == -1) {\n\t\t\t$x = $this->GetX();\n\t\t} elseif ($x < 0) {\n\t\t\t$x = 0;\n\t\t} elseif ($x > $this->w) {\n\t\t\t$x = $this->w;\n\t\t}\n\t\t$fixed = false;\n\t\tif (!empty($page) AND (substr($page, 0, 1) == '*')) {\n\t\t\t$page = intval(substr($page, 1));\n\t\t\t// this page number will not be changed when moving/add/deleting pages\n\t\t\t$fixed = true;\n\t\t}\n\t\tif (empty($page)) {\n\t\t\t$page = $this->PageNo();\n\t\t\tif (empty($page)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t$this->dests[$name] = array('x' => $x, 'y' => $y, 'p' => $page, 'f' => $fixed);\n\t\treturn $name;\n\t}\n\n\t/**\n\t * Return the Named Destination array.\n\t * @return array Named Destination array.\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 5.9.097 (2011-06-23)\n\t */\n\tpublic function getDestination() {\n\t\treturn $this->dests;\n\t}\n\n\t/**\n\t * Insert Named Destinations.\n\t * @protected\n\t * @author Johannes G\\FCntert, Nicola Asuni\n\t * @since 5.9.098 (2011-06-23)\n\t */\n\tprotected function _putdests() {\n\t\tif (empty($this->dests)) {\n\t\t\treturn;\n\t\t}\n\t\t$this->n_dests = $this->_newobj();\n\t\t$out = ' <<';\n\t\tforeach($this->dests as $name => $o) {\n\t\t\t$out .= ' /'.$name.' '.sprintf('[%u 0 R /XYZ %F %F null]', $this->page_obj_id[($o['p'])], ($o['x'] * $this->k), ($this->pagedim[$o['p']]['h'] - ($o['y'] * $this->k)));\n\t\t}\n\t\t$out .= ' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t}\n\n\t/**\n\t * Adds a bookmark - alias for Bookmark().\n\t * @param string $txt Bookmark description.\n\t * @param int $level Bookmark level (minimum value is 0).\n\t * @param float $y Y position in user units of the bookmark on the selected page (default = -1 = current position; 0 = page start;).\n\t * @param int|string $page Target page number (leave empty for current page). If you prefix a page number with the * character, then this page will not be changed when adding/deleting/moving pages.\n\t * @param string $style Font style: B = Bold, I = Italic, BI = Bold + Italic.\n\t * @param array $color RGB color array (values from 0 to 255).\n\t * @param float $x X position in user units of the bookmark on the selected page (default = -1 = current position;).\n\t * @param mixed $link URL, or numerical link ID, or named destination (# character followed by the destination name), or embedded file (* character followed by the file name).\n\t * @public\n\t */\n\tpublic function setBookmark($txt, $level=0, $y=-1, $page='', $style='', $color=array(0,0,0), $x=-1, $link='') {\n\t\t$this->Bookmark($txt, $level, $y, $page, $style, $color, $x, $link);\n\t}\n\n\t/**\n\t * Adds a bookmark.\n\t * @param string $txt Bookmark description.\n\t * @param int $level Bookmark level (minimum value is 0).\n\t * @param float $y Y position in user units of the bookmark on the selected page (default = -1 = current position; 0 = page start;).\n\t * @param int|string $page Target page number (leave empty for current page). If you prefix a page number with the * character, then this page will not be changed when adding/deleting/moving pages.\n\t * @param string $style Font style: B = Bold, I = Italic, BI = Bold + Italic.\n\t * @param array $color RGB color array (values from 0 to 255).\n\t * @param float $x X position in user units of the bookmark on the selected page (default = -1 = current position;).\n\t * @param mixed $link URL, or numerical link ID, or named destination (# character followed by the destination name), or embedded file (* character followed by the file name).\n\t * @public\n\t * @since 2.1.002 (2008-02-12)\n\t */\n\tpublic function Bookmark($txt, $level=0, $y=-1, $page='', $style='', $color=array(0,0,0), $x=-1, $link='') {\n\t\tif ($level < 0) {\n\t\t\t$level = 0;\n\t\t}\n\t\tif (isset($this->outlines[0])) {\n\t\t\t$lastoutline = end($this->outlines);\n\t\t\t$maxlevel = $lastoutline['l'] + 1;\n\t\t} else {\n\t\t\t$maxlevel = 0;\n\t\t}\n\t\tif ($level > $maxlevel) {\n\t\t\t$level = $maxlevel;\n\t\t}\n\t\tif ($y == -1) {\n\t\t\t$y = $this->GetY();\n\t\t} elseif ($y < 0) {\n\t\t\t$y = 0;\n\t\t} elseif ($y > $this->h) {\n\t\t\t$y = $this->h;\n\t\t}\n\t\tif ($x == -1) {\n\t\t\t$x = $this->GetX();\n\t\t} elseif ($x < 0) {\n\t\t\t$x = 0;\n\t\t} elseif ($x > $this->w) {\n\t\t\t$x = $this->w;\n\t\t}\n\t\t$fixed = false;\n\t\t$pageAsString = (string) $page;\n\t\tif ($pageAsString && $pageAsString[0] == '*') {\n\t\t\t$page = intval(substr($page, 1));\n\t\t\t// this page number will not be changed when moving/add/deleting pages\n\t\t\t$fixed = true;\n\t\t}\n\t\tif (empty($page)) {\n\t\t\t$page = $this->PageNo();\n\t\t\tif (empty($page)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t$this->outlines[] = array('t' => $txt, 'l' => $level, 'x' => $x, 'y' => $y, 'p' => $page, 'f' => $fixed, 's' => strtoupper($style), 'c' => $color, 'u' => $link);\n\t}\n\n\t/**\n\t * Sort bookmarks for page and key.\n\t * @protected\n\t * @since 5.9.119 (2011-09-19)\n\t */\n\tprotected function sortBookmarks() {\n\t\t// get sorting columns\n\t\t$outline_p = array();\n\t\t$outline_y = array();\n\t\tforeach ($this->outlines as $key => $row) {\n\t\t\t$outline_p[$key] = $row['p'];\n\t\t\t$outline_k[$key] = $key;\n\t\t}\n\t\t// sort outlines by page and original position\n\t\tarray_multisort($outline_p, SORT_NUMERIC, SORT_ASC, $outline_k, SORT_NUMERIC, SORT_ASC, $this->outlines);\n\t}\n\n\t/**\n\t * Create a bookmark PDF string.\n\t * @protected\n\t * @author Olivier Plathey, Nicola Asuni\n\t * @since 2.1.002 (2008-02-12)\n\t */\n\tprotected function _putbookmarks() {\n\t\t$nb = count($this->outlines);\n\t\tif ($nb == 0) {\n\t\t\treturn;\n\t\t}\n\t\t// sort bookmarks\n\t\t$this->sortBookmarks();\n\t\t$lru = array();\n\t\t$level = 0;\n\t\tforeach ($this->outlines as $i => $o) {\n\t\t\tif ($o['l'] > 0) {\n\t\t\t\t$parent = $lru[($o['l'] - 1)];\n\t\t\t\t//Set parent and last pointers\n\t\t\t\t$this->outlines[$i]['parent'] = $parent;\n\t\t\t\t$this->outlines[$parent]['last'] = $i;\n\t\t\t\tif ($o['l'] > $level) {\n\t\t\t\t\t//Level increasing: set first pointer\n\t\t\t\t\t$this->outlines[$parent]['first'] = $i;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->outlines[$i]['parent'] = $nb;\n\t\t\t}\n\t\t\tif (($o['l'] <= $level) AND ($i > 0)) {\n\t\t\t\t//Set prev and next pointers\n\t\t\t\t$prev = $lru[$o['l']];\n\t\t\t\t$this->outlines[$prev]['next'] = $i;\n\t\t\t\t$this->outlines[$i]['prev'] = $prev;\n\t\t\t}\n\t\t\t$lru[$o['l']] = $i;\n\t\t\t$level = $o['l'];\n\t\t}\n\t\t//Outline items\n\t\t$n = $this->n + 1;\n\t\t$nltags = '/<br[\\s]?\\/>|<\\/(blockquote|dd|dl|div|dt|h1|h2|h3|h4|h5|h6|hr|li|ol|p|pre|ul|tcpdf|table|tr|td)>/si';\n\t\tforeach ($this->outlines as $i => $o) {\n\t\t\t$oid = $this->_newobj();\n\t\t\t// covert HTML title to string\n\t\t\t$title = preg_replace($nltags, \"\\n\", $o['t']);\n\t\t\t$title = preg_replace(\"/[\\r]+/si\", '', $title);\n\t\t\t$title = preg_replace(\"/[\\n]+/si\", \"\\n\", $title);\n\t\t\t$title = strip_tags($title);\n\t\t\t$title = $this->stringTrim($title);\n\t\t\t$out = '<</Title '.$this->_textstring($title, $oid);\n\t\t\t$out .= ' /Parent '.($n + $o['parent']).' 0 R';\n\t\t\tif (isset($o['prev'])) {\n\t\t\t\t$out .= ' /Prev '.($n + $o['prev']).' 0 R';\n\t\t\t}\n\t\t\tif (isset($o['next'])) {\n\t\t\t\t$out .= ' /Next '.($n + $o['next']).' 0 R';\n\t\t\t}\n\t\t\tif (isset($o['first'])) {\n\t\t\t\t$out .= ' /First '.($n + $o['first']).' 0 R';\n\t\t\t}\n\t\t\tif (isset($o['last'])) {\n\t\t\t\t$out .= ' /Last '.($n + $o['last']).' 0 R';\n\t\t\t}\n\t\t\tif (isset($o['u']) AND !empty($o['u'])) {\n\t\t\t\t// link\n\t\t\t\tif (is_string($o['u'])) {\n\t\t\t\t\tif ($o['u'][0] == '#') {\n\t\t\t\t\t\t// internal destination\n\t\t\t\t\t\t$out .= ' /Dest /'.TCPDF_STATIC::encodeNameObject(substr($o['u'], 1));\n\t\t\t\t\t} elseif ($o['u'][0] == '%') {\n\t\t\t\t\t\t// embedded PDF file\n\t\t\t\t\t\t$filename = basename(substr($o['u'], 1));\n\t\t\t\t\t\t$out .= ' /A <</S /GoToE /D [0 /Fit] /NewWindow true /T << /R /C /P '.($o['p'] - 1).' /A '.$this->embeddedfiles[$filename]['a'].' >> >>';\n\t\t\t\t\t} elseif ($o['u'][0] == '*') {\n\t\t\t\t\t\t// embedded generic file\n\t\t\t\t\t\t$filename = basename(substr($o['u'], 1));\n\t\t\t\t\t\t$jsa = 'var D=event.target.doc;var MyData=D.dataObjects;for (var i in MyData) if (MyData[i].path==\"'.$filename.'\") D.exportDataObject( { cName : MyData[i].name, nLaunch : 2});';\n\t\t\t\t\t\t$out .= ' /A <</S /JavaScript /JS '.$this->_textstring($jsa, $oid).'>>';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// external URI link\n\t\t\t\t\t\t$out .= ' /A <</S /URI /URI '.$this->_datastring($this->unhtmlentities($o['u']), $oid).'>>';\n\t\t\t\t\t}\n\t\t\t\t} elseif (isset($this->links[$o['u']])) {\n\t\t\t\t\t// internal link ID\n\t\t\t\t\t$l = $this->links[$o['u']];\n\t\t\t\t\tif (isset($this->page_obj_id[($l['p'])])) {\n\t\t\t\t\t\t$out .= sprintf(' /Dest [%u 0 R /XYZ 0 %F null]', $this->page_obj_id[($l['p'])], ($this->pagedim[$l['p']]['h'] - ($l['y'] * $this->k)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} elseif (isset($this->page_obj_id[($o['p'])])) {\n\t\t\t\t// link to a page\n\t\t\t\t$out .= ' '.sprintf('/Dest [%u 0 R /XYZ %F %F null]', $this->page_obj_id[($o['p'])], ($o['x'] * $this->k), ($this->pagedim[$o['p']]['h'] - ($o['y'] * $this->k)));\n\t\t\t}\n\t\t\t// set font style\n\t\t\t$style = 0;\n\t\t\tif (!empty($o['s'])) {\n\t\t\t\t// bold\n\t\t\t\tif (strpos($o['s'], 'B') !== false) {\n\t\t\t\t\t$style |= 2;\n\t\t\t\t}\n\t\t\t\t// oblique\n\t\t\t\tif (strpos($o['s'], 'I') !== false) {\n\t\t\t\t\t$style |= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$out .= sprintf(' /F %d', $style);\n\t\t\t// set bookmark color\n\t\t\tif (isset($o['c']) AND is_array($o['c']) AND (count($o['c']) == 3)) {\n\t\t\t\t$color = array_values($o['c']);\n\t\t\t\t$out .= sprintf(' /C [%F %F %F]', ($color[0] / 255), ($color[1] / 255), ($color[2] / 255));\n\t\t\t} else {\n\t\t\t\t// black\n\t\t\t\t$out .= ' /C [0.0 0.0 0.0]';\n\t\t\t}\n\t\t\t$out .= ' /Count 0'; // normally closed item\n\t\t\t$out .= ' >>';\n\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t$this->_out($out);\n\t\t}\n\t\t//Outline root\n\t\t$this->OutlineRoot = $this->_newobj();\n\t\t$this->_out('<< /Type /Outlines /First '.$n.' 0 R /Last '.($n + $lru[0]).' 0 R >>'.\"\\n\".'endobj');\n\t}\n\n\t// --- JAVASCRIPT ------------------------------------------------------\n\n\t/**\n\t * Adds a javascript\n\t * @param string $script Javascript code\n\t * @public\n\t * @author Johannes G\\FCntert, Nicola Asuni\n\t * @since 2.1.002 (2008-02-12)\n\t */\n\tpublic function IncludeJS($script) {\n\t\t$this->javascript .= $script;\n\t}\n\n\t/**\n\t * Adds a javascript object and return object ID\n\t * @param string $script Javascript code\n\t * @param boolean $onload if true executes this object when opening the document\n\t * @return int internal object ID\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tpublic function addJavascriptObject($script, $onload=false) {\n\t\tif ($this->pdfa_mode) {\n\t\t\t// javascript is not allowed in PDF/A mode\n\t\t\treturn false;\n\t\t}\n\t\t++$this->n;\n\t\t$this->js_objects[$this->n] = array('n' => $this->n, 'js' => $script, 'onload' => $onload);\n\t\treturn $this->n;\n\t}\n\n\t/**\n\t * Create a javascript PDF string.\n\t * @protected\n\t * @author Johannes G\\FCntert, Nicola Asuni\n\t * @since 2.1.002 (2008-02-12)\n\t */\n\tprotected function _putjavascript() {\n\t\tif ($this->pdfa_mode OR (empty($this->javascript) AND empty($this->js_objects))) {\n\t\t\treturn;\n\t\t}\n\t\tif (strpos($this->javascript, 'this.addField') > 0) {\n\t\t\tif (!$this->ur['enabled']) {\n\t\t\t\t//$this->setUserRights();\n\t\t\t}\n\t\t\t// the following two lines are used to avoid form fields duplication after saving\n\t\t\t// The addField method only works when releasing user rights (UR3)\n\t\t\t$jsa = sprintf(\"ftcpdfdocsaved=this.addField('%s','%s',%d,[%F,%F,%F,%F]);\", 'tcpdfdocsaved', 'text', 0, 0, 1, 0, 1);\n\t\t\t$jsb = \"getField('tcpdfdocsaved').value='saved';\";\n\t\t\t$this->javascript = $jsa.\"\\n\".$this->javascript.\"\\n\".$jsb;\n\t\t}\n\t\t// name tree for javascript\n\t\t$this->n_js = '<< /Names [';\n\t\tif (!empty($this->javascript)) {\n\t\t\t$this->n_js .= ' (EmbeddedJS) '.($this->n + 1).' 0 R';\n\t\t}\n\t\tif (!empty($this->js_objects)) {\n\t\t\tforeach ($this->js_objects as $key => $val) {\n\t\t\t\tif ($val['onload']) {\n\t\t\t\t\t$this->n_js .= ' (JS'.$key.') '.$key.' 0 R';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$this->n_js .= ' ] >>';\n\t\t// default Javascript object\n\t\tif (!empty($this->javascript)) {\n\t\t\t$obj_id = $this->_newobj();\n\t\t\t$out = '<< /S /JavaScript';\n\t\t\t$out .= ' /JS '.$this->_textstring($this->javascript, $obj_id);\n\t\t\t$out .= ' >>';\n\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t$this->_out($out);\n\t\t}\n\t\t// additional Javascript objects\n\t\tif (!empty($this->js_objects)) {\n\t\t\tforeach ($this->js_objects as $key => $val) {\n\t\t\t\t$out = $this->_getobj($key).\"\\n\".' << /S /JavaScript /JS '.$this->_textstring($val['js'], $key).' >>'.\"\\n\".'endobj';\n\t\t\t\t$this->_out($out);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Adds a javascript form field.\n\t * @param string $type field type\n\t * @param string $name field name\n\t * @param int $x horizontal position\n\t * @param int $y vertical position\n\t * @param int $w width\n\t * @param int $h height\n\t * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.\n\t * @protected\n\t * @author Denis Van Nuffelen, Nicola Asuni\n\t * @since 2.1.002 (2008-02-12)\n\t */\n\tprotected function _addfield($type, $name, $x, $y, $w, $h, $prop) {\n\t\tif ($this->rtl) {\n\t\t\t$x = $x - $w;\n\t\t}\n\t\t// the followind avoid fields duplication after saving the document\n\t\t$this->javascript .= \"if (getField('tcpdfdocsaved').value != 'saved') {\";\n\t\t$k = $this->k;\n\t\t$this->javascript .= sprintf(\"f\".$name.\"=this.addField('%s','%s',%u,[%F,%F,%F,%F]);\", $name, $type, $this->PageNo()-1, $x*$k, ($this->h-$y)*$k+1, ($x+$w)*$k, ($this->h-$y-$h)*$k+1).\"\\n\";\n\t\t$this->javascript .= 'f'.$name.'.textSize='.$this->FontSizePt.\";\\n\";\n\t\tforeach($prop as $key => $val) {\n\t\t\tif (strcmp(substr($key, -5), 'Color') == 0) {\n\t\t\t\t$val = TCPDF_COLORS::_JScolor($val);\n\t\t\t} else {\n\t\t\t\t$val = \"'\".$val.\"'\";\n\t\t\t}\n\t\t\t$this->javascript .= 'f'.$name.'.'.$key.'='.$val.\";\\n\";\n\t\t}\n\t\tif ($this->rtl) {\n\t\t\t$this->x -= $w;\n\t\t} else {\n\t\t\t$this->x += $w;\n\t\t}\n\t\t$this->javascript .= '}';\n\t}\n\n\t// --- FORM FIELDS -----------------------------------------------------\n\n\n\n\t/**\n\t * Set default properties for form fields.\n\t * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.8.000 (2009-09-06)\n\t */\n\tpublic function setFormDefaultProp($prop=array()) {\n\t\t$this->default_form_prop = $prop;\n\t}\n\n\t/**\n\t * Return the default properties for form fields.\n\t * @return array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.8.000 (2009-09-06)\n\t */\n\tpublic function getFormDefaultProp() {\n\t\treturn $this->default_form_prop;\n\t}\n\n\t/**\n\t * Creates a text field\n\t * @param string $name field name\n\t * @param float $w Width of the rectangle\n\t * @param float $h Height of the rectangle\n\t * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.\n\t * @param array $opt annotation parameters. Possible values are described on official PDF32000_2008 reference.\n\t * @param float|null $x Abscissa of the upper-left corner of the rectangle\n\t * @param float|null $y Ordinate of the upper-left corner of the rectangle\n\t * @param boolean $js if true put the field using JavaScript (requires Acrobat Writer to be rendered).\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tpublic function TextField($name, $w, $h, $prop=array(), $opt=array(), $x=null, $y=null, $js=false) {\n\t\tif (TCPDF_STATIC::empty_string($x)) {\n\t\t\t$x = $this->x;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($y)) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\t// check page for no-write regions and adapt page margins if necessary\n\t\tlist($x, $y) = $this->checkPageRegions($h, $x, $y);\n\t\tif ($js) {\n\t\t\t$this->_addfield('text', $name, $x, $y, $w, $h, $prop);\n\t\t\treturn;\n\t\t}\n\t\t// get default style\n\t\t$prop = array_merge($this->getFormDefaultProp(), $prop);\n\t\t// get annotation data\n\t\t$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);\n\t\t// set default appearance stream\n\t\t$this->annotation_fonts[$this->CurrentFont['fontkey']] = $this->CurrentFont['i'];\n\t\t$fontstyle = sprintf('/F%d %F Tf %s', $this->CurrentFont['i'], $this->FontSizePt, $this->TextColor);\n\t\t$popt['da'] = $fontstyle;\n\t\t// build appearance stream\n\t\t$popt['ap'] = array();\n\t\t$popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';\n\t\t$text = '';\n\t\tif (isset($prop['value']) AND !empty($prop['value'])) {\n\t\t\t$text = $prop['value'];\n\t\t} elseif (isset($opt['v']) AND !empty($opt['v'])) {\n\t\t\t$text = $opt['v'];\n\t\t}\n\t\t$tmpid = $this->startTemplate($w, $h, false);\n\t\t$align = '';\n\t\tif (isset($popt['q'])) {\n\t\t\tswitch ($popt['q']) {\n\t\t\t\tcase 0: {\n\t\t\t\t\t$align = 'L';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\t$align = 'C';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\t$align = 'R';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\t$align = '';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$this->MultiCell($w, $h, $text, 0, $align, false, 0, 0, 0, true, 0, false, true, 0, 'T', false);\n\t\t$this->endTemplate();\n\t\t--$this->n;\n\t\t$popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];\n\t\tunset($this->xobjects[$tmpid]);\n\t\t$popt['ap']['n'] .= 'Q EMC';\n\t\t// merge options\n\t\t$opt = array_merge($popt, $opt);\n\t\t// remove some conflicting options\n\t\tunset($opt['bs']);\n\t\t// set remaining annotation data\n\t\t$opt['Subtype'] = 'Widget';\n\t\t$opt['ft'] = 'Tx';\n\t\t$opt['t'] = $name;\n\t\t// Additional annotation's parameters (check _putannotsobj() method):\n\t\t//$opt['f']\n\t\t//$opt['as']\n\t\t//$opt['bs']\n\t\t//$opt['be']\n\t\t//$opt['c']\n\t\t//$opt['border']\n\t\t//$opt['h']\n\t\t//$opt['mk'];\n\t\t//$opt['mk']['r']\n\t\t//$opt['mk']['bc'];\n\t\t//$opt['mk']['bg'];\n\t\tunset($opt['mk']['ca']);\n\t\tunset($opt['mk']['rc']);\n\t\tunset($opt['mk']['ac']);\n\t\tunset($opt['mk']['i']);\n\t\tunset($opt['mk']['ri']);\n\t\tunset($opt['mk']['ix']);\n\t\tunset($opt['mk']['if']);\n\t\t//$opt['mk']['if']['sw'];\n\t\t//$opt['mk']['if']['s'];\n\t\t//$opt['mk']['if']['a'];\n\t\t//$opt['mk']['if']['fb'];\n\t\tunset($opt['mk']['tp']);\n\t\t//$opt['tu']\n\t\t//$opt['tm']\n\t\t//$opt['ff']\n\t\t//$opt['v']\n\t\t//$opt['dv']\n\t\t//$opt['a']\n\t\t//$opt['aa']\n\t\t//$opt['q']\n\t\t$this->Annotation($x, $y, $w, $h, $name, $opt, 0);\n\t\tif ($this->rtl) {\n\t\t\t$this->x -= $w;\n\t\t} else {\n\t\t\t$this->x += $w;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a RadioButton field.\n\t * @param string $name Field name.\n\t * @param int $w Width of the radio button.\n\t * @param array $prop Javascript field properties. Possible values are described on official Javascript for Acrobat API reference.\n\t * @param array $opt Annotation parameters. Possible values are described on official PDF32000_2008 reference.\n\t * @param string $onvalue Value to be returned if selected.\n\t * @param boolean $checked Define the initial state.\n\t * @param float|null $x Abscissa of the upper-left corner of the rectangle\n\t * @param float|null $y Ordinate of the upper-left corner of the rectangle\n\t * @param boolean $js If true put the field using JavaScript (requires Acrobat Writer to be rendered).\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tpublic function RadioButton($name, $w, $prop=array(), $opt=array(), $onvalue='On', $checked=false, $x=null, $y=null, $js=false) {\n\t\tif (TCPDF_STATIC::empty_string($x)) {\n\t\t\t$x = $this->x;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($y)) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\t// check page for no-write regions and adapt page margins if necessary\n\t\tlist($x, $y) = $this->checkPageRegions($w, $x, $y);\n\t\tif ($js) {\n\t\t\t$this->_addfield('radiobutton', $name, $x, $y, $w, $w, $prop);\n\t\t\treturn;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($onvalue)) {\n\t\t\t$onvalue = 'On';\n\t\t}\n\t\tif ($checked) {\n\t\t\t$defval = $onvalue;\n\t\t} else {\n\t\t\t$defval = 'Off';\n\t\t}\n\t\t// set font\n\t\t$font = 'zapfdingbats';\n\t\tif ($this->pdfa_mode) {\n\t\t\t// all fonts must be embedded\n\t\t\t$font = 'pdfa'.$font;\n\t\t}\n\t\t$this->AddFont($font);\n\t\t$tmpfont = $this->getFontBuffer($font);\n\t\t// set data for parent group\n\t\tif (!isset($this->radiobutton_groups[$this->page])) {\n\t\t\t$this->radiobutton_groups[$this->page] = array();\n\t\t}\n\t\tif (!isset($this->radiobutton_groups[$this->page][$name])) {\n\t\t\t$this->radiobutton_groups[$this->page][$name] = array();\n\t\t\t++$this->n;\n\t\t\t$this->radiobutton_groups[$this->page][$name]['n'] = $this->n;\n\t\t\t$this->radio_groups[] = $this->n;\n\t\t}\n\t\t$kid = ($this->n + 1);\n\t\t// save object ID to be added on Kids entry on parent object\n\t\t$this->radiobutton_groups[$this->page][$name][] = array('kid' => $kid, 'def' => $defval);\n\t\t// get default style\n\t\t$prop = array_merge($this->getFormDefaultProp(), $prop);\n\t\t$prop['NoToggleToOff'] = 'true';\n\t\t$prop['Radio'] = 'true';\n\t\t$prop['borderStyle'] = 'inset';\n\t\t// get annotation data\n\t\t$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);\n\t\t// set additional default options\n\t\t$this->annotation_fonts[$tmpfont['fontkey']] = $tmpfont['i'];\n\t\t$fontstyle = sprintf('/F%d %F Tf %s', $tmpfont['i'], $this->FontSizePt, $this->TextColor);\n\t\t$popt['da'] = $fontstyle;\n\t\t// build appearance stream\n\t\t$popt['ap'] = array();\n\t\t$popt['ap']['n'] = array();\n\t\t$fx = ((($w - $this->getAbsFontMeasure($tmpfont['cw'][108])) / 2) * $this->k);\n\t\t$fy = (($w - ((($tmpfont['desc']['Ascent'] - $tmpfont['desc']['Descent']) * $this->FontSizePt / 1000) / $this->k)) * $this->k);\n\t\t$popt['ap']['n'][$onvalue] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(108).') Tj ET Q', $this->TextColor, $tmpfont['i'], $this->FontSizePt, $fx, $fy);\n\t\t$popt['ap']['n']['Off'] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(109).') Tj ET Q', $this->TextColor, $tmpfont['i'], $this->FontSizePt, $fx, $fy);\n\t\tif (!isset($popt['mk'])) {\n\t\t\t$popt['mk'] = array();\n\t\t}\n\t\t$popt['mk']['ca'] = '(l)';\n\t\t// merge options\n\t\t$opt = array_merge($popt, $opt);\n\t\t// set remaining annotation data\n\t\t$opt['Subtype'] = 'Widget';\n\t\t$opt['ft'] = 'Btn';\n\t\tif ($checked) {\n\t\t\t$opt['v'] = array('/'.$onvalue);\n\t\t\t$opt['as'] = $onvalue;\n\t\t} else {\n\t\t\t$opt['as'] = 'Off';\n\t\t}\n\t\t// store readonly flag\n\t\tif (!isset($this->radiobutton_groups[$this->page][$name]['#readonly#'])) {\n\t\t\t$this->radiobutton_groups[$this->page][$name]['#readonly#'] = false;\n\t\t}\n\t\t$this->radiobutton_groups[$this->page][$name]['#readonly#'] |= ($opt['f'] & 64);\n\t\t$this->Annotation($x, $y, $w, $w, $name, $opt, 0);\n\t\tif ($this->rtl) {\n\t\t\t$this->x -= $w;\n\t\t} else {\n\t\t\t$this->x += $w;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a List-box field\n\t * @param string $name field name\n\t * @param int $w width\n\t * @param int $h height\n\t * @param array $values array containing the list of values.\n\t * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.\n\t * @param array $opt annotation parameters. Possible values are described on official PDF32000_2008 reference.\n\t * @param float|null $x Abscissa of the upper-left corner of the rectangle\n\t * @param float|null $y Ordinate of the upper-left corner of the rectangle\n\t * @param boolean $js if true put the field using JavaScript (requires Acrobat Writer to be rendered).\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tpublic function ListBox($name, $w, $h, $values, $prop=array(), $opt=array(), $x=null, $y=null, $js=false) {\n\t\tif (TCPDF_STATIC::empty_string($x)) {\n\t\t\t$x = $this->x;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($y)) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\t// check page for no-write regions and adapt page margins if necessary\n\t\tlist($x, $y) = $this->checkPageRegions($h, $x, $y);\n\t\tif ($js) {\n\t\t\t$this->_addfield('listbox', $name, $x, $y, $w, $h, $prop);\n\t\t\t$s = '';\n\t\t\tforeach ($values as $value) {\n\t\t\t\tif (is_array($value)) {\n\t\t\t\t\t$s .= ',[\\''.addslashes($value[1]).'\\',\\''.addslashes($value[0]).'\\']';\n\t\t\t\t} else {\n\t\t\t\t\t$s .= ',[\\''.addslashes($value).'\\',\\''.addslashes($value).'\\']';\n\t\t\t\t}\n\t\t\t}\n\t\t\t$this->javascript .= 'f'.$name.'.setItems('.substr($s, 1).');'.\"\\n\";\n\t\t\treturn;\n\t\t}\n\t\t// get default style\n\t\t$prop = array_merge($this->getFormDefaultProp(), $prop);\n\t\t// get annotation data\n\t\t$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);\n\t\t// set additional default values\n\t\t$this->annotation_fonts[$this->CurrentFont['fontkey']] = $this->CurrentFont['i'];\n\t\t$fontstyle = sprintf('/F%d %F Tf %s', $this->CurrentFont['i'], $this->FontSizePt, $this->TextColor);\n\t\t$popt['da'] = $fontstyle;\n\t\t// build appearance stream\n\t\t$popt['ap'] = array();\n\t\t$popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';\n\t\t$text = '';\n\t\tforeach($values as $item) {\n\t\t\tif (is_array($item)) {\n\t\t\t\t$text .= $item[1].\"\\n\";\n\t\t\t} else {\n\t\t\t\t$text .= $item.\"\\n\";\n\t\t\t}\n\t\t}\n\t\t$tmpid = $this->startTemplate($w, $h, false);\n\t\t$this->MultiCell($w, $h, $text, 0, '', false, 0, 0, 0, true, 0, false, true, 0, 'T', false);\n\t\t$this->endTemplate();\n\t\t--$this->n;\n\t\t$popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];\n\t\tunset($this->xobjects[$tmpid]);\n\t\t$popt['ap']['n'] .= 'Q EMC';\n\t\t// merge options\n\t\t$opt = array_merge($popt, $opt);\n\t\t// set remaining annotation data\n\t\t$opt['Subtype'] = 'Widget';\n\t\t$opt['ft'] = 'Ch';\n\t\t$opt['t'] = $name;\n\t\t$opt['opt'] = $values;\n\t\tunset($opt['mk']['ca']);\n\t\tunset($opt['mk']['rc']);\n\t\tunset($opt['mk']['ac']);\n\t\tunset($opt['mk']['i']);\n\t\tunset($opt['mk']['ri']);\n\t\tunset($opt['mk']['ix']);\n\t\tunset($opt['mk']['if']);\n\t\tunset($opt['mk']['tp']);\n\t\t$this->Annotation($x, $y, $w, $h, $name, $opt, 0);\n\t\tif ($this->rtl) {\n\t\t\t$this->x -= $w;\n\t\t} else {\n\t\t\t$this->x += $w;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a Combo-box field\n\t * @param string $name field name\n\t * @param int $w width\n\t * @param int $h height\n\t * @param array $values array containing the list of values.\n\t * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.\n\t * @param array $opt annotation parameters. Possible values are described on official PDF32000_2008 reference.\n\t * @param float|null $x Abscissa of the upper-left corner of the rectangle\n\t * @param float|null $y Ordinate of the upper-left corner of the rectangle\n\t * @param boolean $js if true put the field using JavaScript (requires Acrobat Writer to be rendered).\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tpublic function ComboBox($name, $w, $h, $values, $prop=array(), $opt=array(), $x=null, $y=null, $js=false) {\n\t\tif (TCPDF_STATIC::empty_string($x)) {\n\t\t\t$x = $this->x;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($y)) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\t// check page for no-write regions and adapt page margins if necessary\n\t\tlist($x, $y) = $this->checkPageRegions($h, $x, $y);\n\t\tif ($js) {\n\t\t\t$this->_addfield('combobox', $name, $x, $y, $w, $h, $prop);\n\t\t\t$s = '';\n\t\t\tforeach ($values as $value) {\n\t\t\t\tif (is_array($value)) {\n\t\t\t\t\t$s .= ',[\\''.addslashes($value[1]).'\\',\\''.addslashes($value[0]).'\\']';\n\t\t\t\t} else {\n\t\t\t\t\t$s .= ',[\\''.addslashes($value).'\\',\\''.addslashes($value).'\\']';\n\t\t\t\t}\n\t\t\t}\n\t\t\t$this->javascript .= 'f'.$name.'.setItems('.substr($s, 1).');'.\"\\n\";\n\t\t\treturn;\n\t\t}\n\t\t// get default style\n\t\t$prop = array_merge($this->getFormDefaultProp(), $prop);\n\t\t$prop['Combo'] = true;\n\t\t// get annotation data\n\t\t$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);\n\t\t// set additional default options\n\t\t$this->annotation_fonts[$this->CurrentFont['fontkey']] = $this->CurrentFont['i'];\n\t\t$fontstyle = sprintf('/F%d %F Tf %s', $this->CurrentFont['i'], $this->FontSizePt, $this->TextColor);\n\t\t$popt['da'] = $fontstyle;\n\t\t// build appearance stream\n\t\t$popt['ap'] = array();\n\t\t$popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';\n\t\t$text = '';\n\t\tforeach($values as $item) {\n\t\t\tif (is_array($item)) {\n\t\t\t\t$text .= $item[1].\"\\n\";\n\t\t\t} else {\n\t\t\t\t$text .= $item.\"\\n\";\n\t\t\t}\n\t\t}\n\t\t$tmpid = $this->startTemplate($w, $h, false);\n\t\t$this->MultiCell($w, $h, $text, 0, '', false, 0, 0, 0, true, 0, false, true, 0, 'T', false);\n\t\t$this->endTemplate();\n\t\t--$this->n;\n\t\t$popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];\n\t\tunset($this->xobjects[$tmpid]);\n\t\t$popt['ap']['n'] .= 'Q EMC';\n\t\t// merge options\n\t\t$opt = array_merge($popt, $opt);\n\t\t// set remaining annotation data\n\t\t$opt['Subtype'] = 'Widget';\n\t\t$opt['ft'] = 'Ch';\n\t\t$opt['t'] = $name;\n\t\t$opt['opt'] = $values;\n\t\tunset($opt['mk']['ca']);\n\t\tunset($opt['mk']['rc']);\n\t\tunset($opt['mk']['ac']);\n\t\tunset($opt['mk']['i']);\n\t\tunset($opt['mk']['ri']);\n\t\tunset($opt['mk']['ix']);\n\t\tunset($opt['mk']['if']);\n\t\tunset($opt['mk']['tp']);\n\t\t$this->Annotation($x, $y, $w, $h, $name, $opt, 0);\n\t\tif ($this->rtl) {\n\t\t\t$this->x -= $w;\n\t\t} else {\n\t\t\t$this->x += $w;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a CheckBox field\n\t * @param string $name field name\n\t * @param int $w width\n\t * @param boolean $checked define the initial state.\n\t * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.\n\t * @param array $opt annotation parameters. Possible values are described on official PDF32000_2008 reference.\n\t * @param string $onvalue value to be returned if selected.\n\t * @param float|null $x Abscissa of the upper-left corner of the rectangle\n\t * @param float|null $y Ordinate of the upper-left corner of the rectangle\n\t * @param boolean $js if true put the field using JavaScript (requires Acrobat Writer to be rendered).\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tpublic function CheckBox($name, $w, $checked=false, $prop=array(), $opt=array(), $onvalue='Yes', $x=null, $y=null, $js=false) {\n\t\tif (TCPDF_STATIC::empty_string($x)) {\n\t\t\t$x = $this->x;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($y)) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\t// check page for no-write regions and adapt page margins if necessary\n\t\tlist($x, $y) = $this->checkPageRegions($w, $x, $y);\n\t\tif ($js) {\n\t\t\t$this->_addfield('checkbox', $name, $x, $y, $w, $w, $prop);\n\t\t\treturn;\n\t\t}\n\t\tif (!isset($prop['value'])) {\n\t\t\t$prop['value'] = array('Yes');\n\t\t}\n\t\t// get default style\n\t\t$prop = array_merge($this->getFormDefaultProp(), $prop);\n\t\t$prop['borderStyle'] = 'inset';\n\t\t// get annotation data\n\t\t$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);\n\t\t// set additional default options\n\t\t$font = 'zapfdingbats';\n\t\tif ($this->pdfa_mode) {\n\t\t\t// all fonts must be embedded\n\t\t\t$font = 'pdfa'.$font;\n\t\t}\n\t\t$this->AddFont($font);\n\t\t$tmpfont = $this->getFontBuffer($font);\n\t\t$this->annotation_fonts[$tmpfont['fontkey']] = $tmpfont['i'];\n\t\t$fontstyle = sprintf('/F%d %F Tf %s', $tmpfont['i'], $this->FontSizePt, $this->TextColor);\n\t\t$popt['da'] = $fontstyle;\n\t\t// build appearance stream\n\t\t$popt['ap'] = array();\n\t\t$popt['ap']['n'] = array();\n\t\t$fx = ((($w - $this->getAbsFontMeasure($tmpfont['cw'][110])) / 2) * $this->k);\n\t\t$fy = (($w - ((($tmpfont['desc']['Ascent'] - $tmpfont['desc']['Descent']) * $this->FontSizePt / 1000) / $this->k)) * $this->k);\n\t\t$popt['ap']['n']['Yes'] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(110).') Tj ET Q', $this->TextColor, $tmpfont['i'], $this->FontSizePt, $fx, $fy);\n\t\t$popt['ap']['n']['Off'] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(111).') Tj ET Q', $this->TextColor, $tmpfont['i'], $this->FontSizePt, $fx, $fy);\n\t\t// merge options\n\t\t$opt = array_merge($popt, $opt);\n\t\t// set remaining annotation data\n\t\t$opt['Subtype'] = 'Widget';\n\t\t$opt['ft'] = 'Btn';\n\t\t$opt['t'] = $name;\n\t\tif (TCPDF_STATIC::empty_string($onvalue)) {\n\t\t\t$onvalue = 'Yes';\n\t\t}\n\t\t$opt['opt'] = array($onvalue);\n\t\tif ($checked) {\n\t\t\t$opt['v'] = array('/Yes');\n\t\t\t$opt['as'] = 'Yes';\n\t\t} else {\n\t\t\t$opt['v'] = array('/Off');\n\t\t\t$opt['as'] = 'Off';\n\t\t}\n\t\t$this->Annotation($x, $y, $w, $w, $name, $opt, 0);\n\t\tif ($this->rtl) {\n\t\t\t$this->x -= $w;\n\t\t} else {\n\t\t\t$this->x += $w;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a button field\n\t * @param string $name field name\n\t * @param int $w width\n\t * @param int $h height\n\t * @param string $caption caption.\n\t * @param mixed $action action triggered by pressing the button. Use a string to specify a javascript action. Use an array to specify a form action options as on section 12.7.5 of PDF32000_2008.\n\t * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.\n\t * @param array $opt annotation parameters. Possible values are described on official PDF32000_2008 reference.\n\t * @param float|null $x Abscissa of the upper-left corner of the rectangle\n\t * @param float|null $y Ordinate of the upper-left corner of the rectangle\n\t * @param boolean $js if true put the field using JavaScript (requires Acrobat Writer to be rendered).\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.8.000 (2009-09-07)\n\t */\n\tpublic function Button($name, $w, $h, $caption, $action, $prop=array(), $opt=array(), $x=null, $y=null, $js=false) {\n\t\tif (TCPDF_STATIC::empty_string($x)) {\n\t\t\t$x = $this->x;\n\t\t}\n\t\tif (TCPDF_STATIC::empty_string($y)) {\n\t\t\t$y = $this->y;\n\t\t}\n\t\t// check page for no-write regions and adapt page margins if necessary\n\t\tlist($x, $y) = $this->checkPageRegions($h, $x, $y);\n\t\tif ($js) {\n\t\t\t$this->_addfield('button', $name, $this->x, $this->y, $w, $h, $prop);\n\t\t\t$this->javascript .= 'f'.$name.\".buttonSetCaption('\".addslashes($caption).\"');\\n\";\n\t\t\t$this->javascript .= 'f'.$name.\".setAction('MouseUp','\".addslashes($action).\"');\\n\";\n\t\t\t$this->javascript .= 'f'.$name.\".highlight='push';\\n\";\n\t\t\t$this->javascript .= 'f'.$name.\".print=false;\\n\";\n\t\t\treturn;\n\t\t}\n\t\t// get default style\n\t\t$prop = array_merge($this->getFormDefaultProp(), $prop);\n\t\t$prop['Pushbutton'] = 'true';\n\t\t$prop['highlight'] = 'push';\n\t\t$prop['display'] = 'display.noPrint';\n\t\t// get annotation data\n\t\t$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);\n\t\t$this->annotation_fonts[$this->CurrentFont['fontkey']] = $this->CurrentFont['i'];\n\t\t$fontstyle = sprintf('/F%d %F Tf %s', $this->CurrentFont['i'], $this->FontSizePt, $this->TextColor);\n\t\t$popt['da'] = $fontstyle;\n\t\t// build appearance stream\n\t\t$popt['ap'] = array();\n\t\t$popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';\n\t\t$tmpid = $this->startTemplate($w, $h, false);\n\t\t$bw = (2 / $this->k); // border width\n\t\t$border = array(\n\t\t\t'L' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(231)),\n\t\t\t'R' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(51)),\n\t\t\t'T' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(231)),\n\t\t\t'B' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(51)));\n\t\t$this->setFillColor(204);\n\t\t$this->Cell($w, $h, $caption, $border, 0, 'C', true, '', 1, false, 'T', 'M');\n\t\t$this->endTemplate();\n\t\t--$this->n;\n\t\t$popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];\n\t\tunset($this->xobjects[$tmpid]);\n\t\t$popt['ap']['n'] .= 'Q EMC';\n\t\t// set additional default options\n\t\tif (!isset($popt['mk'])) {\n\t\t\t$popt['mk'] = array();\n\t\t}\n\t\t$ann_obj_id = ($this->n + 1);\n\t\tif (!empty($action) AND !is_array($action)) {\n\t\t\t$ann_obj_id = ($this->n + 2);\n\t\t}\n\t\t$popt['mk']['ca'] = $this->_textstring($caption, $ann_obj_id);\n\t\t$popt['mk']['rc'] = $this->_textstring($caption, $ann_obj_id);\n\t\t$popt['mk']['ac'] = $this->_textstring($caption, $ann_obj_id);\n\t\t// merge options\n\t\t$opt = array_merge($popt, $opt);\n\t\t// set remaining annotation data\n\t\t$opt['Subtype'] = 'Widget';\n\t\t$opt['ft'] = 'Btn';\n\t\t$opt['t'] = $caption;\n\t\t$opt['v'] = $name;\n\t\tif (!empty($action)) {\n\t\t\tif (is_array($action)) {\n\t\t\t\t// form action options as on section 12.7.5 of PDF32000_2008.\n\t\t\t\t$opt['aa'] = '/D <<';\n\t\t\t\t$bmode = array('SubmitForm', 'ResetForm', 'ImportData');\n\t\t\t\tforeach ($action AS $key => $val) {\n\t\t\t\t\tif (($key == 'S') AND in_array($val, $bmode)) {\n\t\t\t\t\t\t$opt['aa'] .= ' /S /'.$val;\n\t\t\t\t\t} elseif (($key == 'F') AND (!empty($val))) {\n\t\t\t\t\t\t$opt['aa'] .= ' /F '.$this->_datastring($val, $ann_obj_id);\n\t\t\t\t\t} elseif (($key == 'Fields') AND is_array($val) AND !empty($val)) {\n\t\t\t\t\t\t$opt['aa'] .= ' /Fields [';\n\t\t\t\t\t\tforeach ($val AS $field) {\n\t\t\t\t\t\t\t$opt['aa'] .= ' '.$this->_textstring($field, $ann_obj_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$opt['aa'] .= ']';\n\t\t\t\t\t} elseif (($key == 'Flags')) {\n\t\t\t\t\t\t$ff = 0;\n\t\t\t\t\t\tif (is_array($val)) {\n\t\t\t\t\t\t\tforeach ($val AS $flag) {\n\t\t\t\t\t\t\t\tswitch ($flag) {\n\t\t\t\t\t\t\t\t\tcase 'Include/Exclude': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 0;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'IncludeNoValueFields': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 1;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'ExportFormat': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 2;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'GetMethod': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 3;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'SubmitCoordinates': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 4;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'XFDF': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 5;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'IncludeAppendSaves': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 6;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'IncludeAnnotations': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 7;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'SubmitPDF': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 8;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'CanonicalFormat': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 9;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'ExclNonUserAnnots': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 10;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'ExclFKey': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 11;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'EmbedForm': {\n\t\t\t\t\t\t\t\t\t\t$ff += 1 << 13;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$ff = intval($val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$opt['aa'] .= ' /Flags '.$ff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$opt['aa'] .= ' >>';\n\t\t\t} else {\n\t\t\t\t// Javascript action or raw action command\n\t\t\t\t$js_obj_id = $this->addJavascriptObject($action);\n\t\t\t\t$opt['aa'] = '/D '.$js_obj_id.' 0 R';\n\t\t\t}\n\t\t}\n\t\t$this->Annotation($x, $y, $w, $h, $name, $opt, 0);\n\t\tif ($this->rtl) {\n\t\t\t$this->x -= $w;\n\t\t} else {\n\t\t\t$this->x += $w;\n\t\t}\n\t}\n\n\t// --- END FORMS FIELDS ------------------------------------------------\n\n\t/**\n\t * Add certification signature (DocMDP or UR3)\n\t * You can set only one signature type\n\t * @protected\n\t * @author Nicola Asuni\n\t * @since 4.6.008 (2009-05-07)\n\t */\n\tprotected function _putsignature() {\n\t\tif ((!$this->sign) OR (!isset($this->signature_data['cert_type']))) {\n\t\t\treturn;\n\t\t}\n\t\t$sigobjid = ($this->sig_obj_id + 1);\n\t\t$out = $this->_getobj($sigobjid).\"\\n\";\n\t\t$out .= '<< /Type /Sig';\n\t\t$out .= ' /Filter /Adobe.PPKLite';\n\t\t$out .= ' /SubFilter /adbe.pkcs7.detached';\n\t\t$out .= ' '.TCPDF_STATIC::$byterange_string;\n\t\t$out .= ' /Contents<'.str_repeat('0', $this->signature_max_length).'>';\n\t\tif (empty($this->signature_data['approval']) OR ($this->signature_data['approval'] != 'A')) {\n\t\t\t$out .= ' /Reference ['; // array of signature reference dictionaries\n\t\t\t$out .= ' << /Type /SigRef';\n\t\t\tif ($this->signature_data['cert_type'] > 0) {\n\t\t\t\t$out .= ' /TransformMethod /DocMDP';\n\t\t\t\t$out .= ' /TransformParams <<';\n\t\t\t\t$out .= ' /Type /TransformParams';\n\t\t\t\t$out .= ' /P '.$this->signature_data['cert_type'];\n\t\t\t\t$out .= ' /V /1.2';\n\t\t\t} else {\n\t\t\t\t$out .= ' /TransformMethod /UR3';\n\t\t\t\t$out .= ' /TransformParams <<';\n\t\t\t\t$out .= ' /Type /TransformParams';\n\t\t\t\t$out .= ' /V /2.2';\n\t\t\t\tif (!TCPDF_STATIC::empty_string($this->ur['document'])) {\n\t\t\t\t\t$out .= ' /Document['.$this->ur['document'].']';\n\t\t\t\t}\n\t\t\t\tif (!TCPDF_STATIC::empty_string($this->ur['form'])) {\n\t\t\t\t\t$out .= ' /Form['.$this->ur['form'].']';\n\t\t\t\t}\n\t\t\t\tif (!TCPDF_STATIC::empty_string($this->ur['signature'])) {\n\t\t\t\t\t$out .= ' /Signature['.$this->ur['signature'].']';\n\t\t\t\t}\n\t\t\t\tif (!TCPDF_STATIC::empty_string($this->ur['annots'])) {\n\t\t\t\t\t$out .= ' /Annots['.$this->ur['annots'].']';\n\t\t\t\t}\n\t\t\t\tif (!TCPDF_STATIC::empty_string($this->ur['ef'])) {\n\t\t\t\t\t$out .= ' /EF['.$this->ur['ef'].']';\n\t\t\t\t}\n\t\t\t\tif (!TCPDF_STATIC::empty_string($this->ur['formex'])) {\n\t\t\t\t\t$out .= ' /FormEX['.$this->ur['formex'].']';\n\t\t\t\t}\n\t\t\t}\n\t\t\t$out .= ' >>'; // close TransformParams\n\t\t\t// optional digest data (values must be calculated and replaced later)\n\t\t\t//$out .= ' /Data ********** 0 R';\n\t\t\t//$out .= ' /DigestMethod/MD5';\n\t\t\t//$out .= ' /DigestLocation[********** 34]';\n\t\t\t//$out .= ' /DigestValue<********************************>';\n\t\t\t$out .= ' >>';\n\t\t\t$out .= ' ]'; // end of reference\n\t\t}\n\t\tif (isset($this->signature_data['info']['Name']) AND !TCPDF_STATIC::empty_string($this->signature_data['info']['Name'])) {\n\t\t\t$out .= ' /Name '.$this->_textstring($this->signature_data['info']['Name'], $sigobjid);\n\t\t}\n\t\tif (isset($this->signature_data['info']['Location']) AND !TCPDF_STATIC::empty_string($this->signature_data['info']['Location'])) {\n\t\t\t$out .= ' /Location '.$this->_textstring($this->signature_data['info']['Location'], $sigobjid);\n\t\t}\n\t\tif (isset($this->signature_data['info']['Reason']) AND !TCPDF_STATIC::empty_string($this->signature_data['info']['Reason'])) {\n\t\t\t$out .= ' /Reason '.$this->_textstring($this->signature_data['info']['Reason'], $sigobjid);\n\t\t}\n\t\tif (isset($this->signature_data['info']['ContactInfo']) AND !TCPDF_STATIC::empty_string($this->signature_data['info']['ContactInfo'])) {\n\t\t\t$out .= ' /ContactInfo '.$this->_textstring($this->signature_data['info']['ContactInfo'], $sigobjid);\n\t\t}\n\t\t$out .= ' /M '.$this->_datestring($sigobjid, $this->doc_modification_timestamp);\n\t\t$out .= ' >>';\n\t\t$out .= \"\\n\".'endobj';\n\t\t$this->_out($out);\n\t}\n\n\t/**\n\t * Set User's Rights for PDF Reader\n\t * WARNING: This is experimental and currently do not work.\n\t * Check the PDF Reference 8.7.1 Transform Methods,\n\t * Table 8.105 Entries in the UR transform parameters dictionary\n\t * @param boolean $enable if true enable user's rights on PDF reader\n\t * @param string $document Names specifying additional document-wide usage rights for the document. The only defined value is \"/FullSave\", which permits a user to save the document along with modified form and/or annotation data.\n\t * @param string $annots Names specifying additional annotation-related usage rights for the document. Valid names in PDF 1.5 and later are /Create/Delete/Modify/Copy/Import/Export, which permit the user to perform the named operation on annotations.\n\t * @param string $form Names specifying additional form-field-related usage rights for the document. Valid names are: /Add/Delete/FillIn/Import/Export/SubmitStandalone/SpawnTemplate\n\t * @param string $signature Names specifying additional signature-related usage rights for the document. The only defined value is /Modify, which permits a user to apply a digital signature to an existing signature form field or clear a signed signature form field.\n\t * @param string $ef Names specifying additional usage rights for named embedded files in the document. Valid names are /Create/Delete/Modify/Import, which permit the user to perform the named operation on named embedded files\n\t Names specifying additional embedded-files-related usage rights for the document.\n\t * @param string $formex Names specifying additional form-field-related usage rights. The only valid name is BarcodePlaintext, which permits text form field data to be encoded as a plaintext two-dimensional barcode.\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 2.9.000 (2008-03-26)\n\t */\n\tpublic function setUserRights(\n\t\t\t$enable=true,\n\t\t\t$document='/FullSave',\n\t\t\t$annots='/Create/Delete/Modify/Copy/Import/Export',\n\t\t\t$form='/Add/Delete/FillIn/Import/Export/SubmitStandalone/SpawnTemplate',\n\t\t\t$signature='/Modify',\n\t\t\t$ef='/Create/Delete/Modify/Import',\n\t\t\t$formex='') {\n\t\t$this->ur['enabled'] = $enable;\n\t\t$this->ur['document'] = $document;\n\t\t$this->ur['annots'] = $annots;\n\t\t$this->ur['form'] = $form;\n\t\t$this->ur['signature'] = $signature;\n\t\t$this->ur['ef'] = $ef;\n\t\t$this->ur['formex'] = $formex;\n\t\tif (!$this->sign) {\n\t\t\t$this->setSignature('', '', '', '', 0, array());\n\t\t}\n\t}\n\n\t/**\n\t * Enable document signature (requires the OpenSSL Library).\n\t * The digital signature improve document authenticity and integrity and allows o enable extra features on Acrobat Reader.\n\t * To create self-signed signature: openssl req -x509 -nodes -days 365000 -newkey rsa:1024 -keyout tcpdf.crt -out tcpdf.crt\n\t * To export crt to p12: openssl pkcs12 -export -in tcpdf.crt -out tcpdf.p12\n\t * To convert pfx certificate to pem: openssl pkcs12 -in tcpdf.pfx -out tcpdf.crt -nodes\n\t * @param mixed $signing_cert signing certificate (string or filename prefixed with 'file://')\n\t * @param mixed $private_key private key (string or filename prefixed with 'file://')\n\t * @param string $private_key_password password\n\t * @param string $extracerts specifies the name of a file containing a bunch of extra certificates to include in the signature which can for example be used to help the recipient to verify the certificate that you used.\n\t * @param int $cert_type The access permissions granted for this document. Valid values shall be: 1 = No changes to the document shall be permitted; any change to the document shall invalidate the signature; 2 = Permitted changes shall be filling in forms, instantiating page templates, and signing; other changes shall invalidate the signature; 3 = Permitted changes shall be the same as for 2, as well as annotation creation, deletion, and modification; other changes shall invalidate the signature.\n\t * @param array $info array of option information: Name, Location, Reason, ContactInfo.\n\t * @param string $approval Enable approval signature eg. for PDF incremental update\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 4.6.005 (2009-04-24)\n\t */\n\tpublic function setSignature($signing_cert='', $private_key='', $private_key_password='', $extracerts='', $cert_type=2, $info=array(), $approval='') {\n\t\t// to create self-signed signature: openssl req -x509 -nodes -days 365000 -newkey rsa:1024 -keyout tcpdf.crt -out tcpdf.crt\n\t\t// to export crt to p12: openssl pkcs12 -export -in tcpdf.crt -out tcpdf.p12\n\t\t// to convert pfx certificate to pem: openssl\n\t\t//     OpenSSL> pkcs12 -in <cert.pfx> -out <cert.crt> -nodes\n\t\t$this->sign = true;\n\t\t++$this->n;\n\t\t$this->sig_obj_id = $this->n; // signature widget\n\t\t++$this->n; // signature object ($this->sig_obj_id + 1)\n\t\t$this->signature_data = array();\n\t\tif (strlen($signing_cert) == 0) {\n\t\t\t$this->Error('Please provide a certificate file and password!');\n\t\t}\n\t\tif (strlen($private_key) == 0) {\n\t\t\t$private_key = $signing_cert;\n\t\t}\n\t\t$this->signature_data['signcert'] = $signing_cert;\n\t\t$this->signature_data['privkey'] = $private_key;\n\t\t$this->signature_data['password'] = $private_key_password;\n\t\t$this->signature_data['extracerts'] = $extracerts;\n\t\t$this->signature_data['cert_type'] = $cert_type;\n\t\t$this->signature_data['info'] = $info;\n\t\t$this->signature_data['approval'] = $approval;\n\t}\n\n\t/**\n\t * Set the digital signature appearance (a cliccable rectangle area to get signature properties)\n\t * @param float $x Abscissa of the upper-left corner.\n\t * @param float $y Ordinate of the upper-left corner.\n\t * @param float $w Width of the signature area.\n\t * @param float $h Height of the signature area.\n\t * @param int $page option page number (if < 0 the current page is used).\n\t * @param string $name Name of the signature.\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 5.3.011 (2010-06-17)\n\t */\n\tpublic function setSignatureAppearance($x=0, $y=0, $w=0, $h=0, $page=-1, $name='') {\n\t\t$this->signature_appearance = $this->getSignatureAppearanceArray($x, $y, $w, $h, $page, $name);\n\t}\n\n\t/**\n\t * Add an empty digital signature appearance (a cliccable rectangle area to get signature properties)\n\t * @param float $x Abscissa of the upper-left corner.\n\t * @param float $y Ordinate of the upper-left corner.\n\t * @param float $w Width of the signature area.\n\t * @param float $h Height of the signature area.\n\t * @param int $page option page number (if < 0 the current page is used).\n\t * @param string $name Name of the signature.\n\t * @public\n\t * @author Nicola Asuni\n\t * @since 5.9.101 (2011-07-06)\n\t */\n\tpublic function addEmptySignatureAppearance($x=0, $y=0, $w=0, $h=0, $page=-1, $name='') {\n\t\t++$this->n;\n\t\t$this->empty_signature_appearance[] = array('objid' => $this->n) + $this->getSignatureAppearanceArray($x, $y, $w, $h, $page, $name);\n\t}\n\n\t/**\n\t * Get the array that defines the signature appearance (page and rectangle coordinates).\n\t * @param float $x Abscissa of the upper-left corner.\n\t * @param float $y Ordinate of the upper-left corner.\n\t * @param float $w Width of the signature area.\n\t * @param float $h Height of the signature area.\n\t * @param int $page option page number (if < 0 the current page is used).\n\t * @param string $name Name of the signature.\n\t * @return array Array defining page and rectangle coordinates of signature appearance.\n\t * @protected\n\t * @author Nicola Asuni\n\t * @since 5.9.101 (2011-07-06)\n\t */\n\tprotected function getSignatureAppearanceArray($x=0, $y=0, $w=0, $h=0, $page=-1, $name='') {\n\t\t$sigapp = array();\n\t\tif (($page < 1) OR ($page > $this->numpages)) {\n\t\t\t$sigapp['page'] = $this->page;\n\t\t} else {\n\t\t\t$sigapp['page'] = intval($page);\n\t\t}\n\t\tif (empty($name)) {\n\t\t\t$sigapp['name'] = 'Signature';\n\t\t} else {\n\t\t\t$sigapp['name'] = $name;\n\t\t}\n\t\t$a = $x * $this->k;\n\t\t$b = $this->pagedim[($sigapp['page'])]['h'] - (($y + $h) * $this->k);\n\t\t$c = $w * $this->k;\n\t\t$d = $h * $this->k;\n\t\t$sigapp['rect'] = sprintf('%F %F %F %F', $a, $b, ($a + $c), ($b + $d));\n\t\treturn $sigapp;\n\t}\n\n\t/**\n\t * Enable document timestamping (requires the OpenSSL Library).\n\t * The trusted timestamping improve document security that means that no one should be able to change the document once it has been recorded.\n\t * Use with digital signature only!\n\t * @param string $tsa_host Time Stamping Authority (TSA) server (prefixed with 'https://')\n\t * @param string $tsa_username Specifies the username for TSA authorization (optional) OR specifies the TSA authorization PEM file (see: example_66.php, optional)\n\t * @param string $tsa_password Specifies the password for TSA authorization (optional)\n\t * @param string $tsa_cert Specifies the location of TSA certificate for authorization (optional for cURL)\n\t * @public\n\t * @author Richard Stockinger\n\t * @since 6.0.090 (2014-06-16)\n\t */\n\tpublic function setTimeStamp($tsa_host='', $tsa_username='', $tsa_password='', $tsa_cert='') {\n\t\t$this->tsa_data = array();\n\t\tif (!function_exists('curl_init')) {\n\t\t\t$this->Error('Please enable cURL PHP extension!');\n\t\t}\n\t\tif (strlen($tsa_host) == 0) {\n\t\t\t$this->Error('Please specify the host of Time Stamping Authority (TSA)!');\n\t\t}\n\t\t$this->tsa_data['tsa_host'] = $tsa_host;\n\t\tif (is_file($tsa_username)) {\n\t\t\t$this->tsa_data['tsa_auth'] = $tsa_username;\n\t\t} else {\n\t\t\t$this->tsa_data['tsa_username'] = $tsa_username;\n\t\t}\n\t\t$this->tsa_data['tsa_password'] = $tsa_password;\n\t\t$this->tsa_data['tsa_cert'] = $tsa_cert;\n\t\t$this->tsa_timestamp = true;\n\t}\n\n\t/**\n\t * NOT YET IMPLEMENTED\n\t * Request TSA for a timestamp\n\t * @param string $signature Digital signature as binary string\n\t * @return string Timestamped digital signature\n\t * @protected\n\t * @author Richard Stockinger\n\t * @since 6.0.090 (2014-06-16)\n\t */\n\tprotected function applyTSA($signature) {\n\t\tif (!$this->tsa_timestamp) {\n\t\t\treturn $signature;\n\t\t}\n\t\t//@TODO: implement this feature\n\t\treturn $signature;\n\t}\n\n\t/**\n\t * Create a new page group.\n\t * NOTE: call this function before calling AddPage()\n\t * @param int|null $page starting group page (leave empty for next page).\n\t * @public\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tpublic function startPageGroup($page=null) {\n\t\tif (empty($page)) {\n\t\t\t$page = $this->page + 1;\n\t\t}\n\t\t$this->newpagegroup[$page] = sizeof($this->newpagegroup) + 1;\n\t}\n\n\t/**\n\t * Set the starting page number.\n\t * @param int $num Starting page number.\n\t * @since 5.9.093 (2011-06-16)\n\t * @public\n\t */\n\tpublic function setStartingPageNumber($num=1) {\n\t\t$this->starting_page_number = max(0, intval($num));\n\t}\n\n\t/**\n\t * Returns the string alias used right align page numbers.\n\t * If the current font is unicode type, the returned string wil contain an additional open curly brace.\n\t * @return string\n\t * @since 5.9.099 (2011-06-27)\n\t * @public\n\t */\n\tpublic function getAliasRightShift() {\n\t\t// calculate aproximatively the ratio between widths of aliases and replacements.\n\t\t$ref = '{'.TCPDF_STATIC::$alias_right_shift.'}{'.TCPDF_STATIC::$alias_tot_pages.'}{'.TCPDF_STATIC::$alias_num_page.'}';\n\t\t$rep = str_repeat(' ', $this->GetNumChars($ref));\n\t\t$wrep = $this->GetStringWidth($rep);\n\t\tif ($wrep > 0) {\n\t\t\t$wdiff = max(1, ($this->GetStringWidth($ref) / $wrep));\n\t\t} else {\n\t\t\t$wdiff = 1;\n\t\t}\n\t\t$sdiff = sprintf('%F', $wdiff);\n\t\t$alias = TCPDF_STATIC::$alias_right_shift.$sdiff.'}';\n\t\tif ($this->isUnicodeFont()) {\n\t\t\t$alias = '{'.$alias;\n\t\t}\n\t\treturn $alias;\n\t}\n\n\t/**\n\t * Returns the string alias used for the total number of pages.\n\t * If the current font is unicode type, the returned string is surrounded by additional curly braces.\n\t * This alias will be replaced by the total number of pages in the document.\n\t * @return string\n\t * @since 4.0.018 (2008-08-08)\n\t * @public\n\t */\n\tpublic function getAliasNbPages() {\n\t\tif ($this->isUnicodeFont()) {\n\t\t\treturn '{'.TCPDF_STATIC::$alias_tot_pages.'}';\n\t\t}\n\t\treturn TCPDF_STATIC::$alias_tot_pages;\n\t}\n\n\t/**\n\t * Returns the string alias used for the page number.\n\t * If the current font is unicode type, the returned string is surrounded by additional curly braces.\n\t * This alias will be replaced by the page number.\n\t * @return string\n\t * @since 4.5.000 (2009-01-02)\n\t * @public\n\t */\n\tpublic function getAliasNumPage() {\n\t\tif ($this->isUnicodeFont()) {\n\t\t\treturn '{'.TCPDF_STATIC::$alias_num_page.'}';\n\t\t}\n\t\treturn TCPDF_STATIC::$alias_num_page;\n\t}\n\n\t/**\n\t * Return the alias for the total number of pages in the current page group.\n\t * If the current font is unicode type, the returned string is surrounded by additional curly braces.\n\t * This alias will be replaced by the total number of pages in this group.\n\t * @return string alias of the current page group\n\t * @public\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tpublic function getPageGroupAlias() {\n\t\tif ($this->isUnicodeFont()) {\n\t\t\treturn '{'.TCPDF_STATIC::$alias_group_tot_pages.'}';\n\t\t}\n\t\treturn TCPDF_STATIC::$alias_group_tot_pages;\n\t}\n\n\t/**\n\t * Return the alias for the page number on the current page group.\n\t * If the current font is unicode type, the returned string is surrounded by additional curly braces.\n\t * This alias will be replaced by the page number (relative to the belonging group).\n\t * @return string alias of the current page group\n\t * @public\n\t * @since 4.5.000 (2009-01-02)\n\t */\n\tpublic function getPageNumGroupAlias() {\n\t\tif ($this->isUnicodeFont()) {\n\t\t\treturn '{'.TCPDF_STATIC::$alias_group_num_page.'}';\n\t\t}\n\t\treturn TCPDF_STATIC::$alias_group_num_page;\n\t}\n\n\t/**\n\t * Return the current page in the group.\n\t * @return int current page in the group\n\t * @public\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tpublic function getGroupPageNo() {\n\t\treturn $this->pagegroups[$this->currpagegroup];\n\t}\n\n\t/**\n\t * Returns the current group page number formatted as a string.\n\t * @public\n\t * @since 4.3.003 (2008-11-18)\n\t * @see PaneNo(), formatPageNumber()\n\t */\n\tpublic function getGroupPageNoFormatted() {\n\t\treturn TCPDF_STATIC::formatPageNumber($this->getGroupPageNo());\n\t}\n\n\t/**\n\t * Returns the current page number formatted as a string.\n\t * @public\n\t * @since 4.2.005 (2008-11-06)\n\t * @see PaneNo(), formatPageNumber()\n\t */\n\tpublic function PageNoFormatted() {\n\t\treturn TCPDF_STATIC::formatPageNumber($this->PageNo());\n\t}\n\n\t/**\n\t * Put pdf layers.\n\t * @protected\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tprotected function _putocg() {\n\t\tif (empty($this->pdflayers)) {\n\t\t\treturn;\n\t\t}\n\t\tforeach ($this->pdflayers as $key => $layer) {\n\t\t\t $this->pdflayers[$key]['objid'] = $this->_newobj();\n\t\t\t $out = '<< /Type /OCG';\n\t\t\t $out .= ' /Name '.$this->_textstring($layer['name'], $this->pdflayers[$key]['objid']);\n\t\t\t $out .= ' /Usage <<';\n\t\t\t if (isset($layer['print']) AND ($layer['print'] !== NULL)) {\n\t\t\t\t$out .= ' /Print <</PrintState /'.($layer['print']?'ON':'OFF').'>>';\n\t\t\t }\n\t\t\t $out .= ' /View <</ViewState /'.($layer['view']?'ON':'OFF').'>>';\n\t\t\t $out .= ' >> >>';\n\t\t\t $out .= \"\\n\".'endobj';\n\t\t\t $this->_out($out);\n\t\t}\n\t}\n\n\t/**\n\t * Start a new pdf layer.\n\t * @param string $name Layer name (only a-z letters and numbers). Leave empty for automatic name.\n\t * @param boolean|null $print Set to TRUE to print this layer, FALSE to not print and NULL to not set this option\n\t * @param boolean $view Set to true to view this layer.\n\t * @param boolean $lock If true lock the layer\n\t * @public\n\t * @since 5.9.102 (2011-07-13)\n\t */\n\tpublic function startLayer($name='', $print=true, $view=true, $lock=true) {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\t$layer = sprintf('LYR%03d', (count($this->pdflayers) + 1));\n\t\tif (empty($name)) {\n\t\t\t$name = $layer;\n\t\t} else {\n\t\t\t$name = preg_replace('/[^a-zA-Z0-9_\\-]/', '', $name);\n\t\t}\n\t\t$this->pdflayers[] = array('layer' => $layer, 'name' => $name, 'print' => $print, 'view' => $view, 'lock' => $lock);\n\t\t$this->openMarkedContent = true;\n\t\t$this->_out('/OC /'.$layer.' BDC');\n\t}\n\n\t/**\n\t * End the current PDF layer.\n\t * @public\n\t * @since 5.9.102 (2011-07-13)\n\t */\n\tpublic function endLayer() {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\tif ($this->openMarkedContent) {\n\t\t\t// close existing open marked-content layer\n\t\t\t$this->_out('EMC');\n\t\t\t$this->openMarkedContent = false;\n\t\t}\n\t}\n\n\t/**\n\t * Set the visibility of the successive elements.\n\t * This can be useful, for instance, to put a background\n\t * image or color that will show on screen but won't print.\n\t * @param string $v visibility mode. Legal values are: all, print, screen or view.\n\t * @public\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tpublic function setVisibility($v) {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\t$this->endLayer();\n\t\tswitch($v) {\n\t\t\tcase 'print': {\n\t\t\t\t$this->startLayer('Print', true, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'view':\n\t\t\tcase 'screen': {\n\t\t\t\t$this->startLayer('View', false, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'all': {\n\t\t\t\t$this->_out('');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t$this->Error('Incorrect visibility: '.$v);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Add transparency parameters to the current extgstate\n\t * @param array $parms parameters\n\t * @return int|void the number of extgstates\n\t * @protected\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tprotected function addExtGState($parms) {\n\t\tif (($this->pdfa_mode && $this->pdfa_version < 2) || ($this->state != 2)) {\n\t\t\t// transparency is not allowed in PDF/A-1 mode\n\t\t\treturn;\n\t\t}\n\t\t// check if this ExtGState already exist\n\t\tforeach ($this->extgstates as $i => $ext) {\n\t\t\tif ($ext['parms'] == $parms) {\n\t\t\t\tif ($this->inxobj) {\n\t\t\t\t\t// we are inside an XObject template\n\t\t\t\t\t$this->xobjects[$this->xobjid]['extgstates'][$i] = $ext;\n\t\t\t\t}\n\t\t\t\t// return reference to existing ExtGState\n\t\t\t\treturn $i;\n\t\t\t}\n\t\t}\n\t\t$n = (count($this->extgstates) + 1);\n\t\t$this->extgstates[$n] = array('parms' => $parms);\n\t\tif ($this->inxobj) {\n\t\t\t// we are inside an XObject template\n\t\t\t$this->xobjects[$this->xobjid]['extgstates'][$n] = $this->extgstates[$n];\n\t\t}\n\t\treturn $n;\n\t}\n\n\t/**\n\t * Add an extgstate\n\t * @param int $gs extgstate\n\t * @protected\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tprotected function setExtGState($gs) {\n\t\tif (($this->pdfa_mode && $this->pdfa_version < 2) OR ($this->state != 2)) {\n\t\t\t// transparency is not allowed in PDF/A-1 mode\n\t\t\treturn;\n\t\t}\n\t\t$this->_out(sprintf('/GS%d gs', $gs));\n\t}\n\n\t/**\n\t * Put extgstates for object transparency\n\t * @protected\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tprotected function _putextgstates() {\n\t\tforeach ($this->extgstates as $i => $ext) {\n\t\t\t$this->extgstates[$i]['n'] = $this->_newobj();\n\t\t\t$out = '<< /Type /ExtGState';\n\t\t\tforeach ($ext['parms'] as $k => $v) {\n\t\t\t\tif (is_float($v)) {\n\t\t\t\t\t$v = sprintf('%F', $v);\n\t\t\t\t} elseif ($v === true) {\n\t\t\t\t\t$v = 'true';\n\t\t\t\t} elseif ($v === false) {\n\t\t\t\t\t$v = 'false';\n\t\t\t\t}\n\t\t\t\t$out .= ' /'.$k.' '.$v;\n\t\t\t}\n\t\t\t$out .= ' >>';\n\t\t\t$out .= \"\\n\".'endobj';\n\t\t\t$this->_out($out);\n\t\t}\n\t}\n\n\t/**\n\t * Set overprint mode for stroking (OP) and non-stroking (op) painting operations.\n\t * (Check the \"Entries in a Graphics State Parameter Dictionary\" on PDF 32000-1:2008).\n\t * @param boolean $stroking If true apply overprint for stroking operations.\n\t * @param boolean|null $nonstroking If true apply overprint for painting operations other than stroking.\n\t * @param integer $mode Overprint mode: (0 = each source colour component value replaces the value previously painted for the corresponding device colorant; 1 = a tint value of 0.0 for a source colour component shall leave the corresponding component of the previously painted colour unchanged).\n\t * @public\n\t * @since 5.9.152 (2012-03-23)\n\t */\n\tpublic function setOverprint($stroking=true, $nonstroking=null, $mode=0) {\n\t\tif ($this->state != 2) {\n\t\t\treturn;\n\t\t}\n\t\t$stroking = $stroking ? true : false;\n\t\tif (TCPDF_STATIC::empty_string($nonstroking)) {\n\t\t\t// default value if not set\n\t\t\t$nonstroking = $stroking;\n\t\t} else {\n\t\t\t$nonstroking = $nonstroking ? true : false;\n\t\t}\n\t\tif (($mode != 0) AND ($mode != 1)) {\n\t\t\t$mode = 0;\n\t\t}\n\t\t$this->overprint = array('OP' => $stroking, 'op' => $nonstroking, 'OPM' => $mode);\n\t\t$gs = $this->addExtGState($this->overprint);\n\t\t$this->setExtGState($gs);\n\t}\n\n\t/**\n\t * Get the overprint mode array (OP, op, OPM).\n\t * (Check the \"Entries in a Graphics State Parameter Dictionary\" on PDF 32000-1:2008).\n\t * @return array<string,bool|int>\n\t * @public\n\t * @since 5.9.152 (2012-03-23)\n\t */\n\tpublic function getOverprint() {\n\t\treturn $this->overprint;\n\t}\n\n\t/**\n\t * Set alpha for stroking (CA) and non-stroking (ca) operations.\n\t * @param float $stroking Alpha value for stroking operations: real value from 0 (transparent) to 1 (opaque).\n\t * @param string $bm blend mode, one of the following: Normal, Multiply, Screen, Overlay, Darken, Lighten, ColorDodge, ColorBurn, HardLight, SoftLight, Difference, Exclusion, Hue, Saturation, Color, Luminosity\n\t * @param float|null $nonstroking Alpha value for non-stroking operations: real value from 0 (transparent) to 1 (opaque).\n\t * @param boolean $ais\n\t * @public\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tpublic function setAlpha($stroking=1, $bm='Normal', $nonstroking=null, $ais=false) {\n\t\tif ($this->pdfa_mode && $this->pdfa_version < 2) {\n\t\t\t// transparency is not allowed in PDF/A-1 mode\n\t\t\treturn;\n\t\t}\n\t\t$stroking = floatval($stroking);\n\t\tif (TCPDF_STATIC::empty_string($nonstroking)) {\n\t\t\t// default value if not set\n\t\t\t$nonstroking = $stroking;\n\t\t} else {\n\t\t\t$nonstroking = floatval($nonstroking);\n\t\t}\n\t\tif ($bm[0] == '/') {\n\t\t\t// remove trailing slash\n\t\t\t$bm = substr($bm, 1);\n\t\t}\n\t\tif (!in_array($bm, array('Normal', 'Multiply', 'Screen', 'Overlay', 'Darken', 'Lighten', 'ColorDodge', 'ColorBurn', 'HardLight', 'SoftLight', 'Difference', 'Exclusion', 'Hue', 'Saturation', 'Color', 'Luminosity'))) {\n\t\t\t$bm = 'Normal';\n\t\t}\n\t\t$ais = $ais ? true : false;\n\t\t$this->alpha = array('CA' => $stroking, 'ca' => $nonstroking, 'BM' => '/'.$bm, 'AIS' => $ais);\n\t\t$gs = $this->addExtGState($this->alpha);\n\t\t$this->setExtGState($gs);\n\t}\n\n\t/**\n\t * Get the alpha mode array (CA, ca, BM, AIS).\n\t * (Check the \"Entries in a Graphics State Parameter Dictionary\" on PDF 32000-1:2008).\n\t * @return array<string,bool|string>\n\t * @public\n\t * @since 5.9.152 (2012-03-23)\n\t */\n\tpublic function getAlpha() {\n\t\treturn $this->alpha;\n\t}\n\n\t/**\n\t * Set the default JPEG compression quality (1-100)\n\t * @param int $quality JPEG quality, integer between 1 and 100\n\t * @public\n\t * @since 3.0.000 (2008-03-27)\n\t */\n\tpublic function setJPEGQuality($quality) {\n\t\tif (($quality < 1) OR ($quality > 100)) {\n\t\t\t$quality = 75;\n\t\t}\n\t\t$this->jpeg_quality = intval($quality);\n\t}\n\n\t/**\n\t * Set the default number of columns in a row for HTML tables.\n\t * @param int $cols number of columns\n\t * @public\n\t * @since 3.0.014 (2008-06-04)\n\t */\n\tpublic function setDefaultTableColumns($cols=4) {\n\t\t$this->default_table_columns = intval($cols);\n\t}\n\n\t/**\n\t * Set the height of the cell (line height) respect the font height.\n\t * @param float $h cell proportion respect font height (typical value = 1.25).\n\t * @public\n\t * @since 3.0.014 (2008-06-04)\n\t */\n\tpublic function setCellHeightRatio($h) {\n\t\t$this->cell_height_ratio = $h;\n\t}\n\n\t/**\n\t * return the height of cell repect font height.\n\t * @public\n\t * @return float\n\t * @since 4.0.012 (2008-07-24)\n\t */\n\tpublic function getCellHeightRatio() {\n\t\treturn $this->cell_height_ratio;\n\t}\n\n\t/**\n\t * Set the PDF version (check PDF reference for valid values).\n\t * @param string $version PDF document version.\n\t * @public\n\t * @since 3.1.000 (2008-06-09)\n\t */\n\tpublic function setPDFVersion($version='1.7') {\n\t\tif ($this->pdfa_mode && $this->pdfa_version == 1 ) {\n\t\t\t// PDF/A-1 mode\n\t\t\t$this->PDFVersion = '1.4';\n\t\t} elseif ($this->pdfa_mode && $this->pdfa_version >= 2 ) {\n            // PDF/A-2 mode\n            $this->PDFVersion = '1.7';\n        } else {\n\t\t\t$this->PDFVersion = $version;\n\t\t}\n\t}\n\n\t/**\n\t * Set the viewer preferences dictionary controlling the way the document is to be presented on the screen or in print.\n\t * (see Section 8.1 of PDF reference, \"Viewer Preferences\").\n\t * <ul><li>HideToolbar boolean (Optional) A flag specifying whether to hide the viewer application's tool bars when the document is active. Default value: false.</li><li>HideMenubar boolean (Optional) A flag specifying whether to hide the viewer application's menu bar when the document is active. Default value: false.</li><li>HideWindowUI boolean (Optional) A flag specifying whether to hide user interface elements in the document's window (such as scroll bars and navigation controls), leaving only the document's contents displayed. Default value: false.</li><li>FitWindow boolean (Optional) A flag specifying whether to resize the document's window to fit the size of the first displayed page. Default value: false.</li><li>CenterWindow boolean (Optional) A flag specifying whether to position the document's window in the center of the screen. Default value: false.</li><li>DisplayDocTitle boolean (Optional; PDF 1.4) A flag specifying whether the window's title bar should display the document title taken from the Title entry of the document information dictionary (see Section 10.2.1, \"Document Information Dictionary\"). If false, the title bar should instead display the name of the PDF file containing the document. Default value: false.</li><li>NonFullScreenPageMode name (Optional) The document's page mode, specifying how to display the document on exiting full-screen mode:<ul><li>UseNone Neither document outline nor thumbnail images visible</li><li>UseOutlines Document outline visible</li><li>UseThumbs Thumbnail images visible</li><li>UseOC Optional content group panel visible</li></ul>This entry is meaningful only if the value of the PageMode entry in the catalog dictionary (see Section 3.6.1, \"Document Catalog\") is FullScreen; it is ignored otherwise. Default value: UseNone.</li><li>ViewArea name (Optional; PDF 1.4) The name of the page boundary representing the area of a page to be displayed when viewing the document on the screen. Valid values are (see Section 10.10.1, \"Page Boundaries\").:<ul><li>MediaBox</li><li>CropBox (default)</li><li>BleedBox</li><li>TrimBox</li><li>ArtBox</li></ul></li><li>ViewClip name (Optional; PDF 1.4) The name of the page boundary to which the contents of a page are to be clipped when viewing the document on the screen. Valid values are (see Section 10.10.1, \"Page Boundaries\").:<ul><li>MediaBox</li><li>CropBox (default)</li><li>BleedBox</li><li>TrimBox</li><li>ArtBox</li></ul></li><li>PrintArea name (Optional; PDF 1.4) The name of the page boundary representing the area of a page to be rendered when printing the document. Valid values are (see Section 10.10.1, \"Page Boundaries\").:<ul><li>MediaBox</li><li>CropBox (default)</li><li>BleedBox</li><li>TrimBox</li><li>ArtBox</li></ul></li><li>PrintClip name (Optional; PDF 1.4) The name of the page boundary to which the contents of a page are to be clipped when printing the document. Valid values are (see Section 10.10.1, \"Page Boundaries\").:<ul><li>MediaBox</li><li>CropBox (default)</li><li>BleedBox</li><li>TrimBox</li><li>ArtBox</li></ul></li><li>PrintScaling name (Optional; PDF 1.6) The page scaling option to be selected when a print dialog is displayed for this document. Valid values are: <ul><li>None, which indicates that the print dialog should reflect no page scaling</li><li>AppDefault (default), which indicates that applications should use the current print scaling</li></ul></li><li>Duplex name (Optional; PDF 1.7) The paper handling option to use when printing the file from the print dialog. The following values are valid:<ul><li>Simplex - Print single-sided</li><li>DuplexFlipShortEdge - Duplex and flip on the short edge of the sheet</li><li>DuplexFlipLongEdge - Duplex and flip on the long edge of the sheet</li></ul>Default value: none</li><li>PickTrayByPDFSize boolean (Optional; PDF 1.7) A flag specifying whether the PDF page size is used to select the input paper tray. This setting influences only the preset values used to populate the print dialog presented by a PDF viewer application. If PickTrayByPDFSize is true, the check box in the print dialog associated with input p"
        },
        {
          "name": "tcpdf_autoconfig.php",
          "type": "blob",
          "size": 7.173828125,
          "content": "<?php\n//============================================================+\n// File name   : tcpdf_autoconfig.php\n// Version     : 1.1.1\n// Begin       : 2013-05-16\n// Last Update : 2014-12-18\n// Authors     : Nicola Asuni - Tecnick.com LTD - www.tecnick.com - info@tecnick.com\n// License     : GNU-LGPL v3 (http://www.gnu.org/copyleft/lesser.html)\n// -------------------------------------------------------------------\n// Copyright (C) 2011-2014 Nicola Asuni - Tecnick.com LTD\n//\n// This file is part of TCPDF software library.\n//\n// TCPDF is free software: you can redistribute it and/or modify it\n// under the terms of the GNU Lesser General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n//\n// TCPDF is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the License\n// along with TCPDF. If not, see\n// <http://www.tecnick.com/pagefiles/tcpdf/LICENSE.TXT>.\n//\n// See LICENSE.TXT file for more information.\n// -------------------------------------------------------------------\n//\n// Description : Try to automatically configure some TCPDF\n//               constants if not defined.\n//\n//============================================================+\n\n/**\n * @file\n * Try to automatically configure some TCPDF constants if not defined.\n * @package com.tecnick.tcpdf\n * @version 1.1.1\n */\n\n// DOCUMENT_ROOT fix for IIS Webserver\nif ((!isset($_SERVER['DOCUMENT_ROOT'])) OR (empty($_SERVER['DOCUMENT_ROOT']))) {\n\tif(isset($_SERVER['SCRIPT_FILENAME'])) {\n\t\t$_SERVER['DOCUMENT_ROOT'] = str_replace( '\\\\', '/', substr($_SERVER['SCRIPT_FILENAME'], 0, 0-strlen($_SERVER['PHP_SELF'])));\n\t} elseif(isset($_SERVER['PATH_TRANSLATED'])) {\n\t\t$_SERVER['DOCUMENT_ROOT'] = str_replace( '\\\\', '/', substr(str_replace('\\\\\\\\', '\\\\', $_SERVER['PATH_TRANSLATED']), 0, 0-strlen($_SERVER['PHP_SELF'])));\n\t} else {\n\t\t// define here your DOCUMENT_ROOT path if the previous fails (e.g. '/var/www')\n\t\t$_SERVER['DOCUMENT_ROOT'] = '/';\n\t}\n}\n$_SERVER['DOCUMENT_ROOT'] = str_replace('//', '/', $_SERVER['DOCUMENT_ROOT']);\nif (substr($_SERVER['DOCUMENT_ROOT'], -1) != '/') {\n\t$_SERVER['DOCUMENT_ROOT'] .= '/';\n}\n\n// Load main configuration file only if the K_TCPDF_EXTERNAL_CONFIG constant is set to false.\nif (!defined('K_TCPDF_EXTERNAL_CONFIG') OR !K_TCPDF_EXTERNAL_CONFIG) {\n\t// define a list of default config files in order of priority\n\t$tcpdf_config_files = array(dirname(__FILE__).'/config/tcpdf_config.php', '/etc/php-tcpdf/tcpdf_config.php', '/etc/tcpdf/tcpdf_config.php', '/etc/tcpdf_config.php');\n\tforeach ($tcpdf_config_files as $tcpdf_config) {\n\t\tif (@file_exists($tcpdf_config) AND is_readable($tcpdf_config)) {\n\t\t\trequire_once($tcpdf_config);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nif (!defined('K_PATH_MAIN')) {\n\tdefine ('K_PATH_MAIN', dirname(__FILE__).'/');\n}\n\nif (!defined('K_PATH_FONTS')) {\n\tdefine ('K_PATH_FONTS', K_PATH_MAIN.'fonts/');\n}\n\nif (!defined('K_PATH_URL')) {\n\t$k_path_url = K_PATH_MAIN; // default value for console mode\n\tif (isset($_SERVER['HTTP_HOST']) AND (!empty($_SERVER['HTTP_HOST']))) {\n\t\tif(isset($_SERVER['HTTPS']) AND (!empty($_SERVER['HTTPS'])) AND (strtolower($_SERVER['HTTPS']) != 'off')) {\n\t\t\t$k_path_url = 'https://';\n\t\t} else {\n\t\t\t$k_path_url = 'http://';\n\t\t}\n\t\t$k_path_url .= $_SERVER['HTTP_HOST'];\n\t\t$k_path_url .= str_replace( '\\\\', '/', substr(K_PATH_MAIN, (strlen($_SERVER['DOCUMENT_ROOT']) - 1)));\n\t}\n\tdefine ('K_PATH_URL', $k_path_url);\n}\n\nif (!defined('K_PATH_IMAGES')) {\n\t$tcpdf_images_dirs = array(K_PATH_MAIN.'examples/images/', K_PATH_MAIN.'images/', '/usr/share/doc/php-tcpdf/examples/images/', '/usr/share/doc/tcpdf/examples/images/', '/usr/share/doc/php/tcpdf/examples/images/', '/var/www/tcpdf/images/', '/var/www/html/tcpdf/images/', '/usr/local/apache2/htdocs/tcpdf/images/', K_PATH_MAIN);\n\tforeach ($tcpdf_images_dirs as $tcpdf_images_path) {\n\t\tif (@file_exists($tcpdf_images_path)) {\n\t\t\tdefine ('K_PATH_IMAGES', $tcpdf_images_path);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nif (!defined('PDF_HEADER_LOGO')) {\n\t$tcpdf_header_logo = '';\n\tif (@file_exists(K_PATH_IMAGES.'tcpdf_logo.jpg')) {\n\t\t$tcpdf_header_logo = 'tcpdf_logo.jpg';\n\t}\n\tdefine ('PDF_HEADER_LOGO', $tcpdf_header_logo);\n}\n\nif (!defined('PDF_HEADER_LOGO_WIDTH')) {\n\tif (!empty($tcpdf_header_logo)) {\n\t\tdefine ('PDF_HEADER_LOGO_WIDTH', 30);\n\t} else {\n\t\tdefine ('PDF_HEADER_LOGO_WIDTH', 0);\n\t}\n}\n\nif (!defined('K_PATH_CACHE')) {\n\t$K_PATH_CACHE = ini_get('upload_tmp_dir') ? ini_get('upload_tmp_dir') : sys_get_temp_dir();\n\tif (substr($K_PATH_CACHE, -1) != '/') {\n\t\t$K_PATH_CACHE .= '/';\n\t}\n\tdefine ('K_PATH_CACHE', $K_PATH_CACHE);\n}\n\nif (!defined('K_BLANK_IMAGE')) {\n\tdefine ('K_BLANK_IMAGE', '_blank.png');\n}\n\nif (!defined('PDF_PAGE_FORMAT')) {\n\tdefine ('PDF_PAGE_FORMAT', 'A4');\n}\n\nif (!defined('PDF_PAGE_ORIENTATION')) {\n\tdefine ('PDF_PAGE_ORIENTATION', 'P');\n}\n\nif (!defined('PDF_CREATOR')) {\n\tdefine ('PDF_CREATOR', 'TCPDF');\n}\n\nif (!defined('PDF_AUTHOR')) {\n\tdefine ('PDF_AUTHOR', 'TCPDF');\n}\n\nif (!defined('PDF_HEADER_TITLE')) {\n\tdefine ('PDF_HEADER_TITLE', 'TCPDF Example');\n}\n\nif (!defined('PDF_HEADER_STRING')) {\n\tdefine ('PDF_HEADER_STRING', \"by Nicola Asuni - Tecnick.com\\nwww.tcpdf.org\");\n}\n\nif (!defined('PDF_UNIT')) {\n\tdefine ('PDF_UNIT', 'mm');\n}\n\nif (!defined('PDF_MARGIN_HEADER')) {\n\tdefine ('PDF_MARGIN_HEADER', 5);\n}\n\nif (!defined('PDF_MARGIN_FOOTER')) {\n\tdefine ('PDF_MARGIN_FOOTER', 10);\n}\n\nif (!defined('PDF_MARGIN_TOP')) {\n\tdefine ('PDF_MARGIN_TOP', 27);\n}\n\nif (!defined('PDF_MARGIN_BOTTOM')) {\n\tdefine ('PDF_MARGIN_BOTTOM', 25);\n}\n\nif (!defined('PDF_MARGIN_LEFT')) {\n\tdefine ('PDF_MARGIN_LEFT', 15);\n}\n\nif (!defined('PDF_MARGIN_RIGHT')) {\n\tdefine ('PDF_MARGIN_RIGHT', 15);\n}\n\nif (!defined('PDF_FONT_NAME_MAIN')) {\n\tdefine ('PDF_FONT_NAME_MAIN', 'helvetica');\n}\n\nif (!defined('PDF_FONT_SIZE_MAIN')) {\n\tdefine ('PDF_FONT_SIZE_MAIN', 10);\n}\n\nif (!defined('PDF_FONT_NAME_DATA')) {\n\tdefine ('PDF_FONT_NAME_DATA', 'helvetica');\n}\n\nif (!defined('PDF_FONT_SIZE_DATA')) {\n\tdefine ('PDF_FONT_SIZE_DATA', 8);\n}\n\nif (!defined('PDF_FONT_MONOSPACED')) {\n\tdefine ('PDF_FONT_MONOSPACED', 'courier');\n}\n\nif (!defined('PDF_IMAGE_SCALE_RATIO')) {\n\tdefine ('PDF_IMAGE_SCALE_RATIO', 1.25);\n}\n\nif (!defined('HEAD_MAGNIFICATION')) {\n\tdefine('HEAD_MAGNIFICATION', 1.1);\n}\n\nif (!defined('K_CELL_HEIGHT_RATIO')) {\n\tdefine('K_CELL_HEIGHT_RATIO', 1.25);\n}\n\nif (!defined('K_TITLE_MAGNIFICATION')) {\n\tdefine('K_TITLE_MAGNIFICATION', 1.3);\n}\n\nif (!defined('K_SMALL_RATIO')) {\n\tdefine('K_SMALL_RATIO', 2/3);\n}\n\nif (!defined('K_THAI_TOPCHARS')) {\n\tdefine('K_THAI_TOPCHARS', true);\n}\n\nif (!defined('K_TCPDF_CALLS_IN_HTML')) {\n\tdefine('K_TCPDF_CALLS_IN_HTML', false);\n}\n\nif (!defined('K_ALLOWED_TCPDF_TAGS')) {\n\tdefine('K_ALLOWED_TCPDF_TAGS', '');\n}\n\nif (!defined('K_TCPDF_THROW_EXCEPTION_ERROR')) {\n\tdefine('K_TCPDF_THROW_EXCEPTION_ERROR', false);\n}\n\nif (!defined('K_TIMEZONE')) {\n\tdefine('K_TIMEZONE', @date_default_timezone_get());\n}\n\n// Custom cURL options for curl_setopt_array.\nif (!defined('K_CURLOPTS')) {\n\tdefine('K_CURLOPTS', array());\n}\n\n//============================================================+\n// END OF FILE\n//============================================================+\n"
        },
        {
          "name": "tcpdf_barcodes_1d.php",
          "type": "blob",
          "size": 71.5888671875,
          "content": "<?php\n//============================================================+\n// File name   : tcpdf_barcodes_1d.php\n// Version     : 1.0.027\n// Begin       : 2008-06-09\n// Last Update : 2014-10-20\n// Author      : Nicola Asuni - Tecnick.com LTD - www.tecnick.com - info@tecnick.com\n// License     : GNU-LGPL v3 (http://www.gnu.org/copyleft/lesser.html)\n// -------------------------------------------------------------------\n// Copyright (C) 2008-2014 Nicola Asuni - Tecnick.com LTD\n//\n// This file is part of TCPDF software library.\n//\n// TCPDF is free software: you can redistribute it and/or modify it\n// under the terms of the GNU Lesser General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n//\n// TCPDF is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with TCPDF.  If not, see <http://www.gnu.org/licenses/>.\n//\n// See LICENSE.TXT file for more information.\n// -------------------------------------------------------------------\n//\n// Description : PHP class to creates array representations for\n//               common 1D barcodes to be used with TCPDF.\n//\n//============================================================+\n\n/**\n * @file\n * PHP class to creates array representations for common 1D barcodes to be used with TCPDF.\n * @package com.tecnick.tcpdf\n * @author Nicola Asuni\n * @version 1.0.027\n */\n\n/**\n * @class TCPDFBarcode\n * PHP class to creates array representations for common 1D barcodes to be used with TCPDF (http://www.tcpdf.org).<br>\n * @package com.tecnick.tcpdf\n * @version 1.0.027\n * @author Nicola Asuni\n */\nclass TCPDFBarcode {\n\n\t/**\n\t * Array representation of barcode.\n\t * @protected\n\t */\n\tprotected $barcode_array = array();\n\n\t/**\n\t * This is the class constructor.\n\t * Return an array representations for common 1D barcodes:<ul>\n\t * <li>$arrcode['code'] code to be printed on text label</li>\n\t * <li>$arrcode['maxh'] max barcode height</li>\n\t * <li>$arrcode['maxw'] max barcode width</li>\n\t * <li>$arrcode['bcode'][$k] single bar or space in $k position</li>\n\t * <li>$arrcode['bcode'][$k]['t'] bar type: true = bar, false = space.</li>\n\t * <li>$arrcode['bcode'][$k]['w'] bar width in units.</li>\n\t * <li>$arrcode['bcode'][$k]['h'] bar height in units.</li>\n\t * <li>$arrcode['bcode'][$k]['p'] bar top position (0 = top, 1 = middle)</li></ul>\n\t * @param string $code code to print\n \t * @param string $type type of barcode: <ul><li>C39 : CODE 39 - ANSI MH10.8M-1983 - USD-3 - 3 of 9.</li><li>C39+ : CODE 39 with checksum</li><li>C39E : CODE 39 EXTENDED</li><li>C39E+ : CODE 39 EXTENDED + CHECKSUM</li><li>C93 : CODE 93 - USS-93</li><li>S25 : Standard 2 of 5</li><li>S25+ : Standard 2 of 5 + CHECKSUM</li><li>I25 : Interleaved 2 of 5</li><li>I25+ : Interleaved 2 of 5 + CHECKSUM</li><li>C128 : CODE 128</li><li>C128A : CODE 128 A</li><li>C128B : CODE 128 B</li><li>C128C : CODE 128 C</li><li>EAN2 : 2-Digits UPC-Based Extension</li><li>EAN5 : 5-Digits UPC-Based Extension</li><li>EAN8 : EAN 8</li><li>EAN13 : EAN 13</li><li>UPCA : UPC-A</li><li>UPCE : UPC-E</li><li>MSI : MSI (Variation of Plessey code)</li><li>MSI+ : MSI + CHECKSUM (modulo 11)</li><li>POSTNET : POSTNET</li><li>PLANET : PLANET</li><li>RMS4CC : RMS4CC (Royal Mail 4-state Customer Code) - CBC (Customer Bar Code)</li><li>KIX : KIX (Klant index - Customer index)</li><li>IMB: Intelligent Mail Barcode - Onecode - USPS-B-3200</li><li>CODABAR : CODABAR</li><li>CODE11 : CODE 11</li><li>PHARMA : PHARMACODE</li><li>PHARMA2T : PHARMACODE TWO-TRACKS</li></ul>\n \t * @public\n\t */\n\tpublic function __construct($code, $type) {\n\t\t$this->setBarcode($code, $type);\n\t}\n\n\t/**\n\t * Return an array representations of barcode.\n \t * @return array\n \t * @public\n\t */\n\tpublic function getBarcodeArray() {\n\t\treturn $this->barcode_array;\n\t}\n\n\t/**\n\t * Send barcode as SVG image object to the standard output.\n\t * @param int $w Minimum width of a single bar in user units.\n\t * @param int $h Height of barcode in user units.\n\t * @param string $color Foreground color (in SVG format) for bar elements (background is transparent).\n \t * @public\n\t */\n\tpublic function getBarcodeSVG($w=2, $h=30, $color='black') {\n\t\t// send headers\n\t\t$code = $this->getBarcodeSVGcode($w, $h, $color);\n\t\theader('Content-Type: application/svg+xml');\n\t\theader('Cache-Control: public, must-revalidate, max-age=0'); // HTTP/1.1\n\t\theader('Pragma: public');\n\t\theader('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past\n\t\theader('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');\n\t\theader('Content-Disposition: inline; filename=\"'.md5($code).'.svg\";');\n\t\t//header('Content-Length: '.strlen($code));\n\t\techo $code;\n\t}\n\n\t/**\n\t * Return a SVG string representation of barcode.\n\t * @param int $w Minimum width of a single bar in user units.\n\t * @param int $h Height of barcode in user units.\n\t * @param string $color Foreground color (in SVG format) for bar elements (background is transparent).\n \t * @return string SVG code.\n \t * @public\n\t */\n\tpublic function getBarcodeSVGcode($w=2, $h=30, $color='black') {\n\t\t// replace table for special characters\n\t\t$repstr = array(\"\\0\" => '', '&' => '&amp;', '<' => '&lt;', '>' => '&gt;');\n\t\t$svg = '<'.'?'.'xml version=\"1.0\" standalone=\"no\"'.'?'.'>'.\"\\n\";\n\t\t$svg .= '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">'.\"\\n\";\n\t\t$svg .= '<svg width=\"'.round(($this->barcode_array['maxw'] * $w), 3).'\" height=\"'.$h.'\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">'.\"\\n\";\n\t\t$svg .= \"\\t\".'<desc>'.strtr($this->barcode_array['code'], $repstr).'</desc>'.\"\\n\";\n\t\t$svg .= \"\\t\".'<g id=\"bars\" fill=\"'.$color.'\" stroke=\"none\">'.\"\\n\";\n\t\t// print bars\n\t\t$x = 0;\n\t\tforeach ($this->barcode_array['bcode'] as $k => $v) {\n\t\t\t$bw = round(($v['w'] * $w), 3);\n\t\t\t$bh = round(($v['h'] * $h / $this->barcode_array['maxh']), 3);\n\t\t\tif ($v['t']) {\n\t\t\t\t$y = round(($v['p'] * $h / $this->barcode_array['maxh']), 3);\n\t\t\t\t// draw a vertical bar\n\t\t\t\t$svg .= \"\\t\\t\".'<rect x=\"'.$x.'\" y=\"'.$y.'\" width=\"'.$bw.'\" height=\"'.$bh.'\" />'.\"\\n\";\n\t\t\t}\n\t\t\t$x += $bw;\n\t\t}\n\t\t$svg .= \"\\t\".'</g>'.\"\\n\";\n\t\t$svg .= '</svg>'.\"\\n\";\n\t\treturn $svg;\n\t}\n\n\t/**\n\t * Return an HTML representation of barcode.\n\t * @param int $w Width of a single bar element in pixels.\n\t * @param int $h Height of a single bar element in pixels.\n\t * @param string $color Foreground color for bar elements (background is transparent).\n \t * @return string HTML code.\n \t * @public\n\t */\n\tpublic function getBarcodeHTML($w=2, $h=30, $color='black') {\n\t\t$html = '<div style=\"font-size:0;position:relative;width:'.($this->barcode_array['maxw'] * $w).'px;height:'.($h).'px;\">'.\"\\n\";\n\t\t// print bars\n\t\t$x = 0;\n\t\tforeach ($this->barcode_array['bcode'] as $k => $v) {\n\t\t\t$bw = round(($v['w'] * $w), 3);\n\t\t\t$bh = round(($v['h'] * $h / $this->barcode_array['maxh']), 3);\n\t\t\tif ($v['t']) {\n\t\t\t\t$y = round(($v['p'] * $h / $this->barcode_array['maxh']), 3);\n\t\t\t\t// draw a vertical bar\n\t\t\t\t$html .= '<div style=\"background-color:'.$color.';width:'.$bw.'px;height:'.$bh.'px;position:absolute;left:'.$x.'px;top:'.$y.'px;\">&nbsp;</div>'.\"\\n\";\n\t\t\t}\n\t\t\t$x += $bw;\n\t\t}\n\t\t$html .= '</div>'.\"\\n\";\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Send a PNG image representation of barcode (requires GD or Imagick library).\n\t * @param int $w Width of a single bar element in pixels.\n\t * @param int $h Height of a single bar element in pixels.\n\t * @param array $color RGB (0-255) foreground color for bar elements (background is transparent).\n \t * @public\n\t */\n\tpublic function getBarcodePNG($w=2, $h=30, $color=array(0,0,0)) {\n\t\t$data = $this->getBarcodePngData($w, $h, $color);\n\t\t// send headers\n\t\theader('Content-Type: image/png');\n\t\theader('Cache-Control: public, must-revalidate, max-age=0'); // HTTP/1.1\n\t\theader('Pragma: public');\n\t\theader('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past\n\t\theader('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');\n\t\t//header('Content-Length: '.strlen($data));\n\t\techo $data;\n\t}\n\n\t/**\n\t * Return a PNG image representation of barcode (requires GD or Imagick library).\n\t * @param int $w Width of a single bar element in pixels.\n\t * @param int $h Height of a single bar element in pixels.\n\t * @param array $color RGB (0-255) foreground color for bar elements (background is transparent).\n \t * @return string|Imagick|false image or false in case of error.\n \t * @public\n\t */\n\tpublic function getBarcodePngData($w=2, $h=30, $color=array(0,0,0)) {\n\t\t// calculate image size\n\t\t$width = ($this->barcode_array['maxw'] * $w);\n\t\t$height = $h;\n\t\tif (function_exists('imagecreate')) {\n\t\t\t// GD library\n\t\t\t$imagick = false;\n\t\t\t$png = imagecreate($width, $height);\n\t\t\t$bgcol = imagecolorallocate($png, 255, 255, 255);\n\t\t\timagecolortransparent($png, $bgcol);\n\t\t\t$fgcol = imagecolorallocate($png, $color[0], $color[1], $color[2]);\n\t\t} elseif (extension_loaded('imagick')) {\n\t\t\t$imagick = true;\n\t\t\t$bgcol = new imagickpixel('rgb(255,255,255');\n\t\t\t$fgcol = new imagickpixel('rgb('.$color[0].','.$color[1].','.$color[2].')');\n\t\t\t$png = new Imagick();\n\t\t\t$png->newImage($width, $height, 'none', 'png');\n\t\t\t$bar = new imagickdraw();\n\t\t\t$bar->setfillcolor($fgcol);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\t// print bars\n\t\t$x = 0;\n\t\tforeach ($this->barcode_array['bcode'] as $k => $v) {\n\t\t\t$bw = round(($v['w'] * $w), 3);\n\t\t\t$bh = round(($v['h'] * $h / $this->barcode_array['maxh']), 3);\n\t\t\tif ($v['t']) {\n\t\t\t\t$y = round(($v['p'] * $h / $this->barcode_array['maxh']), 3);\n\t\t\t\t// draw a vertical bar\n\t\t\t\tif ($imagick) {\n\t\t\t\t\t$bar->rectangle($x, $y, ($x + $bw - 1), ($y + $bh - 1));\n\t\t\t\t} else {\n\t\t\t\t\timagefilledrectangle($png, $x, $y, ($x + $bw - 1), ($y + $bh - 1), $fgcol);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$x += $bw;\n\t\t}\n\t\tif ($imagick) {\n\t\t\t$png->drawimage($bar);\n\t\t\treturn $png;\n\t\t} else {\n\t\t\tob_start();\n\t\t\timagepng($png);\n\t\t\t$imagedata = ob_get_clean();\n\t\t\timagedestroy($png);\n\t\t\treturn $imagedata;\n\t\t}\n\t}\n\n\t/**\n\t * Set the barcode.\n\t * @param string $code code to print\n \t * @param string $type type of barcode: <ul><li>C39 : CODE 39 - ANSI MH10.8M-1983 - USD-3 - 3 of 9.</li><li>C39+ : CODE 39 with checksum</li><li>C39E : CODE 39 EXTENDED</li><li>C39E+ : CODE 39 EXTENDED + CHECKSUM</li><li>C93 : CODE 93 - USS-93</li><li>S25 : Standard 2 of 5</li><li>S25+ : Standard 2 of 5 + CHECKSUM</li><li>I25 : Interleaved 2 of 5</li><li>I25+ : Interleaved 2 of 5 + CHECKSUM</li><li>C128 : CODE 128</li><li>C128A : CODE 128 A</li><li>C128B : CODE 128 B</li><li>C128C : CODE 128 C</li><li>EAN2 : 2-Digits UPC-Based Extension</li><li>EAN5 : 5-Digits UPC-Based Extension</li><li>EAN8 : EAN 8</li><li>EAN13 : EAN 13</li><li>UPCA : UPC-A</li><li>UPCE : UPC-E</li><li>MSI : MSI (Variation of Plessey code)</li><li>MSI+ : MSI + CHECKSUM (modulo 11)</li><li>POSTNET : POSTNET</li><li>PLANET : PLANET</li><li>RMS4CC : RMS4CC (Royal Mail 4-state Customer Code) - CBC (Customer Bar Code)</li><li>KIX : KIX (Klant index - Customer index)</li><li>IMB: Intelligent Mail Barcode - Onecode - USPS-B-3200</li><li>IMBPRE: Pre-processed Intelligent Mail Barcode - Onecode - USPS-B-3200, using only F,A,D,T letters</li><li>CODABAR : CODABAR</li><li>CODE11 : CODE 11</li><li>PHARMA : PHARMACODE</li><li>PHARMA2T : PHARMACODE TWO-TRACKS</li></ul>\n \t * @return void\n \t * @public\n\t */\n\tpublic function setBarcode($code, $type) {\n\t\tswitch (strtoupper($type)) {\n\t\t\tcase 'C39': { // CODE 39 - ANSI MH10.8M-1983 - USD-3 - 3 of 9.\n\t\t\t\t$arrcode = $this->barcode_code39($code, false, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'C39+': { // CODE 39 with checksum\n\t\t\t\t$arrcode = $this->barcode_code39($code, false, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'C39E': { // CODE 39 EXTENDED\n\t\t\t\t$arrcode = $this->barcode_code39($code, true, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'C39E+': { // CODE 39 EXTENDED + CHECKSUM\n\t\t\t\t$arrcode = $this->barcode_code39($code, true, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'C93': { // CODE 93 - USS-93\n\t\t\t\t$arrcode = $this->barcode_code93($code);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'S25': { // Standard 2 of 5\n\t\t\t\t$arrcode = $this->barcode_s25($code, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'S25+': { // Standard 2 of 5 + CHECKSUM\n\t\t\t\t$arrcode = $this->barcode_s25($code, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'I25': { // Interleaved 2 of 5\n\t\t\t\t$arrcode = $this->barcode_i25($code, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'I25+': { // Interleaved 2 of 5 + CHECKSUM\n\t\t\t\t$arrcode = $this->barcode_i25($code, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'C128': { // CODE 128\n\t\t\t\t$arrcode = $this->barcode_c128($code, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'C128A': { // CODE 128 A\n\t\t\t\t$arrcode = $this->barcode_c128($code, 'A');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'C128B': { // CODE 128 B\n\t\t\t\t$arrcode = $this->barcode_c128($code, 'B');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'C128C': { // CODE 128 C\n\t\t\t\t$arrcode = $this->barcode_c128($code, 'C');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'EAN2': { // 2-Digits UPC-Based Extension\n\t\t\t\t$arrcode = $this->barcode_eanext($code, 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'EAN5': { // 5-Digits UPC-Based Extension\n\t\t\t\t$arrcode = $this->barcode_eanext($code, 5);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'EAN8': { // EAN 8\n\t\t\t\t$arrcode = $this->barcode_eanupc($code, 8);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'EAN13': { // EAN 13\n\t\t\t\t$arrcode = $this->barcode_eanupc($code, 13);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'UPCA': { // UPC-A\n\t\t\t\t$arrcode = $this->barcode_eanupc($code, 12);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'UPCE': { // UPC-E\n\t\t\t\t$arrcode = $this->barcode_eanupc($code, 6);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'MSI': { // MSI (Variation of Plessey code)\n\t\t\t\t$arrcode = $this->barcode_msi($code, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'MSI+': { // MSI + CHECKSUM (modulo 11)\n\t\t\t\t$arrcode = $this->barcode_msi($code, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'POSTNET': { // POSTNET\n\t\t\t\t$arrcode = $this->barcode_postnet($code, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'PLANET': { // PLANET\n\t\t\t\t$arrcode = $this->barcode_postnet($code, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'RMS4CC': { // RMS4CC (Royal Mail 4-state Customer Code) - CBC (Customer Bar Code)\n\t\t\t\t$arrcode = $this->barcode_rms4cc($code, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'KIX': { // KIX (Klant index - Customer index)\n\t\t\t\t$arrcode = $this->barcode_rms4cc($code, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'IMB': { // IMB - Intelligent Mail Barcode - Onecode - USPS-B-3200\n\t\t\t\t$arrcode = $this->barcode_imb($code);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'IMBPRE': { // IMB - Intelligent Mail Barcode - Onecode - USPS-B-3200- pre-processed\n\t\t\t\t$arrcode = $this->barcode_imb_pre($code);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'CODABAR': { // CODABAR\n\t\t\t\t$arrcode = $this->barcode_codabar($code);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'CODE11': { // CODE 11\n\t\t\t\t$arrcode = $this->barcode_code11($code);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'PHARMA': { // PHARMACODE\n\t\t\t\t$arrcode = $this->barcode_pharmacode($code);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'PHARMA2T': { // PHARMACODE TWO-TRACKS\n\t\t\t\t$arrcode = $this->barcode_pharmacode2t($code);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t$this->barcode_array = array();\n\t\t\t\t$arrcode = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$this->barcode_array = $arrcode;\n\t}\n\n\t/**\n\t * CODE 39 - ANSI MH10.8M-1983 - USD-3 - 3 of 9.\n\t * General-purpose code in very wide use world-wide\n\t * @param string $code code to represent.\n\t * @param boolean $extended if true uses the extended mode.\n\t * @param boolean $checksum if true add a checksum to the code.\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_code39($code, $extended=false, $checksum=false) {\n\t\t$chr['0'] = '111331311';\n\t\t$chr['1'] = '311311113';\n\t\t$chr['2'] = '113311113';\n\t\t$chr['3'] = '313311111';\n\t\t$chr['4'] = '111331113';\n\t\t$chr['5'] = '311331111';\n\t\t$chr['6'] = '113331111';\n\t\t$chr['7'] = '111311313';\n\t\t$chr['8'] = '311311311';\n\t\t$chr['9'] = '113311311';\n\t\t$chr['A'] = '311113113';\n\t\t$chr['B'] = '113113113';\n\t\t$chr['C'] = '313113111';\n\t\t$chr['D'] = '111133113';\n\t\t$chr['E'] = '311133111';\n\t\t$chr['F'] = '113133111';\n\t\t$chr['G'] = '111113313';\n\t\t$chr['H'] = '311113311';\n\t\t$chr['I'] = '113113311';\n\t\t$chr['J'] = '111133311';\n\t\t$chr['K'] = '311111133';\n\t\t$chr['L'] = '113111133';\n\t\t$chr['M'] = '313111131';\n\t\t$chr['N'] = '111131133';\n\t\t$chr['O'] = '311131131';\n\t\t$chr['P'] = '113131131';\n\t\t$chr['Q'] = '111111333';\n\t\t$chr['R'] = '311111331';\n\t\t$chr['S'] = '113111331';\n\t\t$chr['T'] = '111131331';\n\t\t$chr['U'] = '331111113';\n\t\t$chr['V'] = '133111113';\n\t\t$chr['W'] = '333111111';\n\t\t$chr['X'] = '131131113';\n\t\t$chr['Y'] = '331131111';\n\t\t$chr['Z'] = '133131111';\n\t\t$chr['-'] = '131111313';\n\t\t$chr['.'] = '331111311';\n\t\t$chr[' '] = '133111311';\n\t\t$chr['$'] = '131313111';\n\t\t$chr['/'] = '131311131';\n\t\t$chr['+'] = '131113131';\n\t\t$chr['%'] = '111313131';\n\t\t$chr['*'] = '131131311';\n\t\t$code = strtoupper($code);\n\t\tif ($extended) {\n\t\t\t// extended mode\n\t\t\t$code = $this->encode_code39_ext($code);\n\t\t}\n\t\tif ($code === false) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($checksum) {\n\t\t\t// checksum\n\t\t\t$code .= $this->checksum_code39($code);\n\t\t}\n\t\t// add start and stop codes\n\t\t$code = '*'.$code.'*';\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\t$k = 0;\n\t\t$clen = strlen($code);\n\t\tfor ($i = 0; $i < $clen; ++$i) {\n\t\t\t$char = $code[$i];\n\t\t\tif(!isset($chr[$char])) {\n\t\t\t\t// invalid character\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor ($j = 0; $j < 9; ++$j) {\n\t\t\t\tif (($j % 2) == 0) {\n\t\t\t\t\t$t = true; // bar\n\t\t\t\t} else {\n\t\t\t\t\t$t = false; // space\n\t\t\t\t}\n\t\t\t\t$w = $chr[$char][$j];\n\t\t\t\t$bararray['bcode'][$k] = array('t' => $t, 'w' => $w, 'h' => 1, 'p' => 0);\n\t\t\t\t$bararray['maxw'] += $w;\n\t\t\t\t++$k;\n\t\t\t}\n\t\t\t// intercharacter gap\n\t\t\t$bararray['bcode'][$k] = array('t' => false, 'w' => 1, 'h' => 1, 'p' => 0);\n\t\t\t$bararray['maxw'] += 1;\n\t\t\t++$k;\n\t\t}\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * Encode a string to be used for CODE 39 Extended mode.\n\t * @param string $code code to represent.\n\t * @return string encoded string.\n\t * @protected\n\t */\n\tprotected function encode_code39_ext($code) {\n\t\t$encode = array(\n\t\t\tchr(0) => '%U', chr(1) => '$A', chr(2) => '$B', chr(3) => '$C',\n\t\t\tchr(4) => '$D', chr(5) => '$E', chr(6) => '$F', chr(7) => '$G',\n\t\t\tchr(8) => '$H', chr(9) => '$I', chr(10) => '$J', chr(11) => '£K',\n\t\t\tchr(12) => '$L', chr(13) => '$M', chr(14) => '$N', chr(15) => '$O',\n\t\t\tchr(16) => '$P', chr(17) => '$Q', chr(18) => '$R', chr(19) => '$S',\n\t\t\tchr(20) => '$T', chr(21) => '$U', chr(22) => '$V', chr(23) => '$W',\n\t\t\tchr(24) => '$X', chr(25) => '$Y', chr(26) => '$Z', chr(27) => '%A',\n\t\t\tchr(28) => '%B', chr(29) => '%C', chr(30) => '%D', chr(31) => '%E',\n\t\t\tchr(32) => ' ', chr(33) => '/A', chr(34) => '/B', chr(35) => '/C',\n\t\t\tchr(36) => '/D', chr(37) => '/E', chr(38) => '/F', chr(39) => '/G',\n\t\t\tchr(40) => '/H', chr(41) => '/I', chr(42) => '/J', chr(43) => '/K',\n\t\t\tchr(44) => '/L', chr(45) => '-', chr(46) => '.', chr(47) => '/O',\n\t\t\tchr(48) => '0', chr(49) => '1', chr(50) => '2', chr(51) => '3',\n\t\t\tchr(52) => '4', chr(53) => '5', chr(54) => '6', chr(55) => '7',\n\t\t\tchr(56) => '8', chr(57) => '9', chr(58) => '/Z', chr(59) => '%F',\n\t\t\tchr(60) => '%G', chr(61) => '%H', chr(62) => '%I', chr(63) => '%J',\n\t\t\tchr(64) => '%V', chr(65) => 'A', chr(66) => 'B', chr(67) => 'C',\n\t\t\tchr(68) => 'D', chr(69) => 'E', chr(70) => 'F', chr(71) => 'G',\n\t\t\tchr(72) => 'H', chr(73) => 'I', chr(74) => 'J', chr(75) => 'K',\n\t\t\tchr(76) => 'L', chr(77) => 'M', chr(78) => 'N', chr(79) => 'O',\n\t\t\tchr(80) => 'P', chr(81) => 'Q', chr(82) => 'R', chr(83) => 'S',\n\t\t\tchr(84) => 'T', chr(85) => 'U', chr(86) => 'V', chr(87) => 'W',\n\t\t\tchr(88) => 'X', chr(89) => 'Y', chr(90) => 'Z', chr(91) => '%K',\n\t\t\tchr(92) => '%L', chr(93) => '%M', chr(94) => '%N', chr(95) => '%O',\n\t\t\tchr(96) => '%W', chr(97) => '+A', chr(98) => '+B', chr(99) => '+C',\n\t\t\tchr(100) => '+D', chr(101) => '+E', chr(102) => '+F', chr(103) => '+G',\n\t\t\tchr(104) => '+H', chr(105) => '+I', chr(106) => '+J', chr(107) => '+K',\n\t\t\tchr(108) => '+L', chr(109) => '+M', chr(110) => '+N', chr(111) => '+O',\n\t\t\tchr(112) => '+P', chr(113) => '+Q', chr(114) => '+R', chr(115) => '+S',\n\t\t\tchr(116) => '+T', chr(117) => '+U', chr(118) => '+V', chr(119) => '+W',\n\t\t\tchr(120) => '+X', chr(121) => '+Y', chr(122) => '+Z', chr(123) => '%P',\n\t\t\tchr(124) => '%Q', chr(125) => '%R', chr(126) => '%S', chr(127) => '%T');\n\t\t$code_ext = '';\n\t\t$clen = strlen($code);\n\t\tfor ($i = 0 ; $i < $clen; ++$i) {\n\t\t\tif (ord($code[$i]) > 127) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$code_ext .= $encode[$code[$i]];\n\t\t}\n\t\treturn $code_ext;\n\t}\n\n\t/**\n\t * Calculate CODE 39 checksum (modulo 43).\n\t * @param string $code code to represent.\n\t * @return string char checksum.\n\t * @protected\n\t */\n\tprotected function checksum_code39($code) {\n\t\t$chars = array(\n\t\t\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t\t\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\n\t\t\t'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n\t\t\t'W', 'X', 'Y', 'Z', '-', '.', ' ', '$', '/', '+', '%');\n\t\t$sum = 0;\n\t\t$clen = strlen($code);\n\t\tfor ($i = 0 ; $i < $clen; ++$i) {\n\t\t\t$k = array_keys($chars, $code[$i]);\n\t\t\t$sum += $k[0];\n\t\t}\n\t\t$j = ($sum % 43);\n\t\treturn $chars[$j];\n\t}\n\n\t/**\n\t * CODE 93 - USS-93\n\t * Compact code similar to Code 39\n\t * @param string $code code to represent.\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_code93($code) {\n\t\t$chr[48] = '131112'; // 0\n\t\t$chr[49] = '111213'; // 1\n\t\t$chr[50] = '111312'; // 2\n\t\t$chr[51] = '111411'; // 3\n\t\t$chr[52] = '121113'; // 4\n\t\t$chr[53] = '121212'; // 5\n\t\t$chr[54] = '121311'; // 6\n\t\t$chr[55] = '111114'; // 7\n\t\t$chr[56] = '131211'; // 8\n\t\t$chr[57] = '141111'; // 9\n\t\t$chr[65] = '211113'; // A\n\t\t$chr[66] = '211212'; // B\n\t\t$chr[67] = '211311'; // C\n\t\t$chr[68] = '221112'; // D\n\t\t$chr[69] = '221211'; // E\n\t\t$chr[70] = '231111'; // F\n\t\t$chr[71] = '112113'; // G\n\t\t$chr[72] = '112212'; // H\n\t\t$chr[73] = '112311'; // I\n\t\t$chr[74] = '122112'; // J\n\t\t$chr[75] = '132111'; // K\n\t\t$chr[76] = '111123'; // L\n\t\t$chr[77] = '111222'; // M\n\t\t$chr[78] = '111321'; // N\n\t\t$chr[79] = '121122'; // O\n\t\t$chr[80] = '131121'; // P\n\t\t$chr[81] = '212112'; // Q\n\t\t$chr[82] = '212211'; // R\n\t\t$chr[83] = '211122'; // S\n\t\t$chr[84] = '211221'; // T\n\t\t$chr[85] = '221121'; // U\n\t\t$chr[86] = '222111'; // V\n\t\t$chr[87] = '112122'; // W\n\t\t$chr[88] = '112221'; // X\n\t\t$chr[89] = '122121'; // Y\n\t\t$chr[90] = '123111'; // Z\n\t\t$chr[45] = '121131'; // -\n\t\t$chr[46] = '311112'; // .\n\t\t$chr[32] = '311211'; //\n\t\t$chr[36] = '321111'; // $\n\t\t$chr[47] = '112131'; // /\n\t\t$chr[43] = '113121'; // +\n\t\t$chr[37] = '211131'; // %\n\t\t$chr[128] = '121221'; // ($)\n\t\t$chr[129] = '311121'; // (/)\n\t\t$chr[130] = '122211'; // (+)\n\t\t$chr[131] = '312111'; // (%)\n\t\t$chr[42] = '111141'; // start-stop\n\t\t$code = strtoupper($code);\n\t\t$encode = array(\n\t\t\tchr(0) => chr(131).'U', chr(1) => chr(128).'A', chr(2) => chr(128).'B', chr(3) => chr(128).'C',\n\t\t\tchr(4) => chr(128).'D', chr(5) => chr(128).'E', chr(6) => chr(128).'F', chr(7) => chr(128).'G',\n\t\t\tchr(8) => chr(128).'H', chr(9) => chr(128).'I', chr(10) => chr(128).'J', chr(11) => '£K',\n\t\t\tchr(12) => chr(128).'L', chr(13) => chr(128).'M', chr(14) => chr(128).'N', chr(15) => chr(128).'O',\n\t\t\tchr(16) => chr(128).'P', chr(17) => chr(128).'Q', chr(18) => chr(128).'R', chr(19) => chr(128).'S',\n\t\t\tchr(20) => chr(128).'T', chr(21) => chr(128).'U', chr(22) => chr(128).'V', chr(23) => chr(128).'W',\n\t\t\tchr(24) => chr(128).'X', chr(25) => chr(128).'Y', chr(26) => chr(128).'Z', chr(27) => chr(131).'A',\n\t\t\tchr(28) => chr(131).'B', chr(29) => chr(131).'C', chr(30) => chr(131).'D', chr(31) => chr(131).'E',\n\t\t\tchr(32) => ' ', chr(33) => chr(129).'A', chr(34) => chr(129).'B', chr(35) => chr(129).'C',\n\t\t\tchr(36) => chr(129).'D', chr(37) => chr(129).'E', chr(38) => chr(129).'F', chr(39) => chr(129).'G',\n\t\t\tchr(40) => chr(129).'H', chr(41) => chr(129).'I', chr(42) => chr(129).'J', chr(43) => chr(129).'K',\n\t\t\tchr(44) => chr(129).'L', chr(45) => '-', chr(46) => '.', chr(47) => chr(129).'O',\n\t\t\tchr(48) => '0', chr(49) => '1', chr(50) => '2', chr(51) => '3',\n\t\t\tchr(52) => '4', chr(53) => '5', chr(54) => '6', chr(55) => '7',\n\t\t\tchr(56) => '8', chr(57) => '9', chr(58) => chr(129).'Z', chr(59) => chr(131).'F',\n\t\t\tchr(60) => chr(131).'G', chr(61) => chr(131).'H', chr(62) => chr(131).'I', chr(63) => chr(131).'J',\n\t\t\tchr(64) => chr(131).'V', chr(65) => 'A', chr(66) => 'B', chr(67) => 'C',\n\t\t\tchr(68) => 'D', chr(69) => 'E', chr(70) => 'F', chr(71) => 'G',\n\t\t\tchr(72) => 'H', chr(73) => 'I', chr(74) => 'J', chr(75) => 'K',\n\t\t\tchr(76) => 'L', chr(77) => 'M', chr(78) => 'N', chr(79) => 'O',\n\t\t\tchr(80) => 'P', chr(81) => 'Q', chr(82) => 'R', chr(83) => 'S',\n\t\t\tchr(84) => 'T', chr(85) => 'U', chr(86) => 'V', chr(87) => 'W',\n\t\t\tchr(88) => 'X', chr(89) => 'Y', chr(90) => 'Z', chr(91) => chr(131).'K',\n\t\t\tchr(92) => chr(131).'L', chr(93) => chr(131).'M', chr(94) => chr(131).'N', chr(95) => chr(131).'O',\n\t\t\tchr(96) => chr(131).'W', chr(97) => chr(130).'A', chr(98) => chr(130).'B', chr(99) => chr(130).'C',\n\t\t\tchr(100) => chr(130).'D', chr(101) => chr(130).'E', chr(102) => chr(130).'F', chr(103) => chr(130).'G',\n\t\t\tchr(104) => chr(130).'H', chr(105) => chr(130).'I', chr(106) => chr(130).'J', chr(107) => chr(130).'K',\n\t\t\tchr(108) => chr(130).'L', chr(109) => chr(130).'M', chr(110) => chr(130).'N', chr(111) => chr(130).'O',\n\t\t\tchr(112) => chr(130).'P', chr(113) => chr(130).'Q', chr(114) => chr(130).'R', chr(115) => chr(130).'S',\n\t\t\tchr(116) => chr(130).'T', chr(117) => chr(130).'U', chr(118) => chr(130).'V', chr(119) => chr(130).'W',\n\t\t\tchr(120) => chr(130).'X', chr(121) => chr(130).'Y', chr(122) => chr(130).'Z', chr(123) => chr(131).'P',\n\t\t\tchr(124) => chr(131).'Q', chr(125) => chr(131).'R', chr(126) => chr(131).'S', chr(127) => chr(131).'T');\n\t\t$code_ext = '';\n\t\t$clen = strlen($code);\n\t\tfor ($i = 0 ; $i < $clen; ++$i) {\n\t\t\tif (ord($code[$i]) > 127) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$code_ext .= $encode[$code[$i]];\n\t\t}\n\t\t// checksum\n\t\t$code_ext .= $this->checksum_code93($code_ext);\n\t\t// add start and stop codes\n\t\t$code = '*'.$code_ext.'*';\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\t$k = 0;\n\t\t$clen = strlen($code);\n\t\tfor ($i = 0; $i < $clen; ++$i) {\n\t\t\t$char = ord($code[$i]);\n\t\t\tif(!isset($chr[$char])) {\n\t\t\t\t// invalid character\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor ($j = 0; $j < 6; ++$j) {\n\t\t\t\tif (($j % 2) == 0) {\n\t\t\t\t\t$t = true; // bar\n\t\t\t\t} else {\n\t\t\t\t\t$t = false; // space\n\t\t\t\t}\n\t\t\t\t$w = $chr[$char][$j];\n\t\t\t\t$bararray['bcode'][$k] = array('t' => $t, 'w' => $w, 'h' => 1, 'p' => 0);\n\t\t\t\t$bararray['maxw'] += $w;\n\t\t\t\t++$k;\n\t\t\t}\n\t\t}\n\t\t$bararray['bcode'][$k] = array('t' => true, 'w' => 1, 'h' => 1, 'p' => 0);\n\t\t$bararray['maxw'] += 1;\n\t\t++$k;\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * Calculate CODE 93 checksum (modulo 47).\n\t * @param string $code code to represent.\n\t * @return string checksum code.\n\t * @protected\n\t */\n\tprotected function checksum_code93($code) {\n\t\t$chars = array(\n\t\t\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t\t\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\n\t\t\t'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n\t\t\t'W', 'X', 'Y', 'Z', '-', '.', ' ', '$', '/', '+', '%',\n\t\t\t'<', '=', '>', '?');\n\t\t// translate special characters\n\t\t$code = strtr($code, chr(128).chr(131).chr(129).chr(130), '<=>?');\n\t\t$len = strlen($code);\n\t\t// calculate check digit C\n\t\t$p = 1;\n\t\t$check = 0;\n\t\tfor ($i = ($len - 1); $i >= 0; --$i) {\n\t\t\t$k = array_keys($chars, $code[$i]);\n\t\t\t$check += ($k[0] * $p);\n\t\t\t++$p;\n\t\t\tif ($p > 20) {\n\t\t\t\t$p = 1;\n\t\t\t}\n\t\t}\n\t\t$check %= 47;\n\t\t$c = $chars[$check];\n\t\t$code .= $c;\n\t\t// calculate check digit K\n\t\t$p = 1;\n\t\t$check = 0;\n\t\tfor ($i = $len; $i >= 0; --$i) {\n\t\t\t$k = array_keys($chars, $code[$i]);\n\t\t\t$check += ($k[0] * $p);\n\t\t\t++$p;\n\t\t\tif ($p > 15) {\n\t\t\t\t$p = 1;\n\t\t\t}\n\t\t}\n\t\t$check %= 47;\n\t\t$k = $chars[$check];\n\t\t$checksum = $c.$k;\n\t\t// resto respecial characters\n\t\t$checksum = strtr($checksum, '<=>?', chr(128).chr(131).chr(129).chr(130));\n\t\treturn $checksum;\n\t}\n\n\t/**\n\t * Checksum for standard 2 of 5 barcodes.\n\t * @param string $code code to process.\n\t * @return int checksum.\n\t * @protected\n\t */\n\tprotected function checksum_s25($code) {\n\t\t$len = strlen($code);\n\t\t$sum = 0;\n\t\tfor ($i = 0; $i < $len; $i+=2) {\n\t\t\t$sum += $code[$i];\n\t\t}\n\t\t$sum *= 3;\n\t\tfor ($i = 1; $i < $len; $i+=2) {\n\t\t\t$sum += ($code[$i]);\n\t\t}\n\t\t$r = $sum % 10;\n\t\tif($r > 0) {\n\t\t\t$r = (10 - $r);\n\t\t}\n\t\treturn $r;\n\t}\n\n\t/**\n\t * MSI.\n\t * Variation of Plessey code, with similar applications\n\t * Contains digits (0 to 9) and encodes the data only in the width of bars.\n\t * @param string $code code to represent.\n\t * @param boolean $checksum if true add a checksum to the code (modulo 11)\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_msi($code, $checksum=false) {\n\t\t$chr['0'] = '100100100100';\n\t\t$chr['1'] = '100100100110';\n\t\t$chr['2'] = '100100110100';\n\t\t$chr['3'] = '100100110110';\n\t\t$chr['4'] = '100110100100';\n\t\t$chr['5'] = '100110100110';\n\t\t$chr['6'] = '100110110100';\n\t\t$chr['7'] = '100110110110';\n\t\t$chr['8'] = '110100100100';\n\t\t$chr['9'] = '110100100110';\n\t\t$chr['A'] = '110100110100';\n\t\t$chr['B'] = '110100110110';\n\t\t$chr['C'] = '110110100100';\n\t\t$chr['D'] = '110110100110';\n\t\t$chr['E'] = '110110110100';\n\t\t$chr['F'] = '110110110110';\n\t\tif ($checksum) {\n\t\t\t// add checksum\n\t\t\t$clen = strlen($code);\n\t\t\t$p = 2;\n\t\t\t$check = 0;\n\t\t\tfor ($i = ($clen - 1); $i >= 0; --$i) {\n\t\t\t\t$check += (hexdec($code[$i]) * $p);\n\t\t\t\t++$p;\n\t\t\t\tif ($p > 7) {\n\t\t\t\t\t$p = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$check %= 11;\n\t\t\tif ($check > 0) {\n\t\t\t\t$check = 11 - $check;\n\t\t\t}\n\t\t\t$code .= $check;\n\t\t}\n\t\t$seq = '110'; // left guard\n\t\t$clen = strlen($code);\n\t\tfor ($i = 0; $i < $clen; ++$i) {\n\t\t\t$digit = $code[$i];\n\t\t\tif (!isset($chr[$digit])) {\n\t\t\t\t// invalid character\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$seq .= $chr[$digit];\n\t\t}\n\t\t$seq .= '1001'; // right guard\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\treturn $this->binseq_to_array($seq, $bararray);\n\t}\n\n\t/**\n\t * Standard 2 of 5 barcodes.\n\t * Used in airline ticket marking, photofinishing\n\t * Contains digits (0 to 9) and encodes the data only in the width of bars.\n\t * @param string $code code to represent.\n\t * @param boolean $checksum if true add a checksum to the code\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_s25($code, $checksum=false) {\n\t\t$chr['0'] = '10101110111010';\n\t\t$chr['1'] = '11101010101110';\n\t\t$chr['2'] = '10111010101110';\n\t\t$chr['3'] = '11101110101010';\n\t\t$chr['4'] = '10101110101110';\n\t\t$chr['5'] = '11101011101010';\n\t\t$chr['6'] = '10111011101010';\n\t\t$chr['7'] = '10101011101110';\n\t\t$chr['8'] = '11101010111010';\n\t\t$chr['9'] = '10111010111010';\n\t\tif ($checksum) {\n\t\t\t// add checksum\n\t\t\t$code .= $this->checksum_s25($code);\n\t\t}\n\t\tif((strlen($code) % 2) != 0) {\n\t\t\t// add leading zero if code-length is odd\n\t\t\t$code = '0'.$code;\n\t\t}\n\t\t$seq = '1110111010';\n\t\t$clen = strlen($code);\n\t\tfor ($i = 0; $i < $clen; ++$i) {\n\t\t\t$digit = $code[$i];\n\t\t\tif (!isset($chr[$digit])) {\n\t\t\t\t// invalid character\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$seq .= $chr[$digit];\n\t\t}\n\t\t$seq .= '111010111';\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\treturn $this->binseq_to_array($seq, $bararray);\n\t}\n\n\t/**\n\t * Convert binary barcode sequence to WarnockPDF barcode array.\n\t * @param string $seq barcode as binary sequence.\n\t * @param array $bararray barcode array to fill up\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function binseq_to_array($seq, $bararray) {\n\t\t$len = strlen($seq);\n\t\t$w = 0;\n\t\t$k = 0;\n\t\tfor ($i = 0; $i < $len; ++$i) {\n\t\t\t$w += 1;\n\t\t\tif (($i == ($len - 1)) OR (($i < ($len - 1)) AND ($seq[$i] != $seq[($i+1)]))) {\n\t\t\t\tif ($seq[$i] == '1') {\n\t\t\t\t\t$t = true; // bar\n\t\t\t\t} else {\n\t\t\t\t\t$t = false; // space\n\t\t\t\t}\n\t\t\t\t$bararray['bcode'][$k] = array('t' => $t, 'w' => $w, 'h' => 1, 'p' => 0);\n\t\t\t\t$bararray['maxw'] += $w;\n\t\t\t\t++$k;\n\t\t\t\t$w = 0;\n\t\t\t}\n\t\t}\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * Interleaved 2 of 5 barcodes.\n\t * Compact numeric code, widely used in industry, air cargo\n\t * Contains digits (0 to 9) and encodes the data in the width of both bars and spaces.\n\t * @param string $code code to represent.\n\t * @param boolean $checksum if true add a checksum to the code\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_i25($code, $checksum=false) {\n\t\t$chr['0'] = '11221';\n\t\t$chr['1'] = '21112';\n\t\t$chr['2'] = '12112';\n\t\t$chr['3'] = '22111';\n\t\t$chr['4'] = '11212';\n\t\t$chr['5'] = '21211';\n\t\t$chr['6'] = '12211';\n\t\t$chr['7'] = '11122';\n\t\t$chr['8'] = '21121';\n\t\t$chr['9'] = '12121';\n\t\t$chr['A'] = '11';\n\t\t$chr['Z'] = '21';\n\t\tif ($checksum) {\n\t\t\t// add checksum\n\t\t\t$code .= $this->checksum_s25($code);\n\t\t}\n\t\tif((strlen($code) % 2) != 0) {\n\t\t\t// add leading zero if code-length is odd\n\t\t\t$code = '0'.$code;\n\t\t}\n\t\t// add start and stop codes\n\t\t$code = 'AA'.strtolower($code).'ZA';\n\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\t$k = 0;\n\t\t$clen = strlen($code);\n\t\tfor ($i = 0; $i < $clen; $i = ($i + 2)) {\n\t\t\t$char_bar = $code[$i];\n\t\t\t$char_space = $code[$i+1];\n\t\t\tif((!isset($chr[$char_bar])) OR (!isset($chr[$char_space]))) {\n\t\t\t\t// invalid character\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// create a bar-space sequence\n\t\t\t$seq = '';\n\t\t\t$chrlen = strlen($chr[$char_bar]);\n\t\t\tfor ($s = 0; $s < $chrlen; $s++){\n\t\t\t\t$seq .= $chr[$char_bar][$s] . $chr[$char_space][$s];\n\t\t\t}\n\t\t\t$seqlen = strlen($seq);\n\t\t\tfor ($j = 0; $j < $seqlen; ++$j) {\n\t\t\t\tif (($j % 2) == 0) {\n\t\t\t\t\t$t = true; // bar\n\t\t\t\t} else {\n\t\t\t\t\t$t = false; // space\n\t\t\t\t}\n\t\t\t\t$w = (float)$seq[$j];\n\t\t\t\t$bararray['bcode'][$k] = array('t' => $t, 'w' => $w, 'h' => 1, 'p' => 0);\n\t\t\t\t$bararray['maxw'] += $w;\n\t\t\t\t++$k;\n\t\t\t}\n\t\t}\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * C128 barcodes.\n\t * Very capable code, excellent density, high reliability; in very wide use world-wide\n\t * @param string $code code to represent.\n\t * @param string $type barcode type: A, B, C or empty for automatic switch (AUTO mode)\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_c128($code, $type='') {\n\t\t$chr = array(\n\t\t\t'212222', /* 00 */\n\t\t\t'222122', /* 01 */\n\t\t\t'222221', /* 02 */\n\t\t\t'121223', /* 03 */\n\t\t\t'121322', /* 04 */\n\t\t\t'131222', /* 05 */\n\t\t\t'122213', /* 06 */\n\t\t\t'122312', /* 07 */\n\t\t\t'132212', /* 08 */\n\t\t\t'221213', /* 09 */\n\t\t\t'221312', /* 10 */\n\t\t\t'231212', /* 11 */\n\t\t\t'112232', /* 12 */\n\t\t\t'122132', /* 13 */\n\t\t\t'122231', /* 14 */\n\t\t\t'113222', /* 15 */\n\t\t\t'123122', /* 16 */\n\t\t\t'123221', /* 17 */\n\t\t\t'223211', /* 18 */\n\t\t\t'221132', /* 19 */\n\t\t\t'221231', /* 20 */\n\t\t\t'213212', /* 21 */\n\t\t\t'223112', /* 22 */\n\t\t\t'312131', /* 23 */\n\t\t\t'311222', /* 24 */\n\t\t\t'321122', /* 25 */\n\t\t\t'321221', /* 26 */\n\t\t\t'312212', /* 27 */\n\t\t\t'322112', /* 28 */\n\t\t\t'322211', /* 29 */\n\t\t\t'212123', /* 30 */\n\t\t\t'212321', /* 31 */\n\t\t\t'232121', /* 32 */\n\t\t\t'111323', /* 33 */\n\t\t\t'131123', /* 34 */\n\t\t\t'131321', /* 35 */\n\t\t\t'112313', /* 36 */\n\t\t\t'132113', /* 37 */\n\t\t\t'132311', /* 38 */\n\t\t\t'211313', /* 39 */\n\t\t\t'231113', /* 40 */\n\t\t\t'231311', /* 41 */\n\t\t\t'112133', /* 42 */\n\t\t\t'112331', /* 43 */\n\t\t\t'132131', /* 44 */\n\t\t\t'113123', /* 45 */\n\t\t\t'113321', /* 46 */\n\t\t\t'133121', /* 47 */\n\t\t\t'313121', /* 48 */\n\t\t\t'211331', /* 49 */\n\t\t\t'231131', /* 50 */\n\t\t\t'213113', /* 51 */\n\t\t\t'213311', /* 52 */\n\t\t\t'213131', /* 53 */\n\t\t\t'311123', /* 54 */\n\t\t\t'311321', /* 55 */\n\t\t\t'331121', /* 56 */\n\t\t\t'312113', /* 57 */\n\t\t\t'312311', /* 58 */\n\t\t\t'332111', /* 59 */\n\t\t\t'314111', /* 60 */\n\t\t\t'221411', /* 61 */\n\t\t\t'431111', /* 62 */\n\t\t\t'111224', /* 63 */\n\t\t\t'111422', /* 64 */\n\t\t\t'121124', /* 65 */\n\t\t\t'121421', /* 66 */\n\t\t\t'141122', /* 67 */\n\t\t\t'141221', /* 68 */\n\t\t\t'112214', /* 69 */\n\t\t\t'112412', /* 70 */\n\t\t\t'122114', /* 71 */\n\t\t\t'122411', /* 72 */\n\t\t\t'142112', /* 73 */\n\t\t\t'142211', /* 74 */\n\t\t\t'241211', /* 75 */\n\t\t\t'221114', /* 76 */\n\t\t\t'413111', /* 77 */\n\t\t\t'241112', /* 78 */\n\t\t\t'134111', /* 79 */\n\t\t\t'111242', /* 80 */\n\t\t\t'121142', /* 81 */\n\t\t\t'121241', /* 82 */\n\t\t\t'114212', /* 83 */\n\t\t\t'124112', /* 84 */\n\t\t\t'124211', /* 85 */\n\t\t\t'411212', /* 86 */\n\t\t\t'421112', /* 87 */\n\t\t\t'421211', /* 88 */\n\t\t\t'212141', /* 89 */\n\t\t\t'214121', /* 90 */\n\t\t\t'412121', /* 91 */\n\t\t\t'111143', /* 92 */\n\t\t\t'111341', /* 93 */\n\t\t\t'131141', /* 94 */\n\t\t\t'114113', /* 95 */\n\t\t\t'114311', /* 96 */\n\t\t\t'411113', /* 97 */\n\t\t\t'411311', /* 98 */\n\t\t\t'113141', /* 99 */\n\t\t\t'114131', /* 100 */\n\t\t\t'311141', /* 101 */\n\t\t\t'411131', /* 102 */\n\t\t\t'211412', /* 103 START A */\n\t\t\t'211214', /* 104 START B */\n\t\t\t'211232', /* 105 START C */\n\t\t\t'233111', /* STOP */\n\t\t\t'200000'  /* END */\n\t\t);\n\t\t// ASCII characters for code A (ASCII 00 - 95)\n\t\t$keys_a = ' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_';\n\t\t$keys_a .= chr(0).chr(1).chr(2).chr(3).chr(4).chr(5).chr(6).chr(7).chr(8).chr(9);\n\t\t$keys_a .= chr(10).chr(11).chr(12).chr(13).chr(14).chr(15).chr(16).chr(17).chr(18).chr(19);\n\t\t$keys_a .= chr(20).chr(21).chr(22).chr(23).chr(24).chr(25).chr(26).chr(27).chr(28).chr(29);\n\t\t$keys_a .= chr(30).chr(31);\n\t\t// ASCII characters for code B (ASCII 32 - 127)\n\t\t$keys_b = ' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'.chr(127);\n\t\t// special codes\n\t\t$fnc_a = array(241 => 102, 242 => 97, 243 => 96, 244 => 101);\n\t\t$fnc_b = array(241 => 102, 242 => 97, 243 => 96, 244 => 100);\n\t\t// array of symbols\n\t\t$code_data = array();\n\t\t// length of the code\n\t\t$len = strlen($code);\n\t\tswitch(strtoupper($type)) {\n\t\t\tcase 'A': { // MODE A\n\t\t\t\t$startid = 103;\n\t\t\t\tfor ($i = 0; $i < $len; ++$i) {\n\t\t\t\t\t$char = $code[$i];\n\t\t\t\t\t$char_id = ord($char);\n\t\t\t\t\tif (($char_id >= 241) AND ($char_id <= 244)) {\n\t\t\t\t\t\t$code_data[] = $fnc_a[$char_id];\n\t\t\t\t\t} elseif (($char_id >= 0) AND ($char_id <= 95)) {\n\t\t\t\t\t\t$code_data[] = strpos($keys_a, $char);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'B': { // MODE B\n\t\t\t\t$startid = 104;\n\t\t\t\tfor ($i = 0; $i < $len; ++$i) {\n\t\t\t\t\t$char = $code[$i];\n\t\t\t\t\t$char_id = ord($char);\n\t\t\t\t\tif (($char_id >= 241) AND ($char_id <= 244)) {\n\t\t\t\t\t\t$code_data[] = $fnc_b[$char_id];\n\t\t\t\t\t} elseif (($char_id >= 32) AND ($char_id <= 127)) {\n\t\t\t\t\t\t$code_data[] = strpos($keys_b, $char);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'C': { // MODE C\n\t\t\t\t$startid = 105;\n\t\t\t\tif (ord($code[0]) == 241) {\n\t\t\t\t\t$code_data[] = 102;\n\t\t\t\t\t$code = substr($code, 1);\n\t\t\t\t\t--$len;\n\t\t\t\t}\n\t\t\t\tif (($len % 2) != 0) {\n\t\t\t\t\t// the length must be even\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor ($i = 0; $i < $len; $i+=2) {\n\t\t\t\t\t$chrnum = $code[$i].$code[$i+1];\n\t\t\t\t\tif (preg_match('/([0-9]{2})/', $chrnum) > 0) {\n\t\t\t\t\t\t$code_data[] = intval($chrnum);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: { // MODE AUTO\n\t\t\t\t// split code into sequences\n\t\t\t\t$sequence = array();\n\t\t\t\t// get numeric sequences (if any)\n\t\t\t\t$numseq = array();\n\t\t\t\tpreg_match_all('/([0-9]{4,})/', $code, $numseq, PREG_OFFSET_CAPTURE);\n\t\t\t\tif (isset($numseq[1]) AND !empty($numseq[1])) {\n\t\t\t\t\t$end_offset = 0;\n\t\t\t\t\tforeach ($numseq[1] as $val) {\n\t\t\t\t\t\t$offset = $val[1];\n\t\t\t\t\t\tif ($offset > $end_offset) {\n\t\t\t\t\t\t\t// non numeric sequence\n\t\t\t\t\t\t\t$sequence = array_merge($sequence, $this->get128ABsequence(substr($code, $end_offset, ($offset - $end_offset))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// numeric sequence\n\t\t\t\t\t\t$slen = strlen($val[0]);\n\t\t\t\t\t\tif (($slen % 2) != 0) {\n\t\t\t\t\t\t\t// the length must be even\n\t\t\t\t\t\t\t--$slen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$sequence[] = array('C', substr($code, $offset, $slen), $slen);\n\t\t\t\t\t\t$end_offset = $offset + $slen;\n\t\t\t\t\t}\n\t\t\t\t\tif ($end_offset < $len) {\n\t\t\t\t\t\t$sequence = array_merge($sequence, $this->get128ABsequence(substr($code, $end_offset)));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// text code (non C mode)\n\t\t\t\t\t$sequence = array_merge($sequence, $this->get128ABsequence($code));\n\t\t\t\t}\n\t\t\t\t// process the sequence\n\t\t\t\tforeach ($sequence as $key => $seq) {\n\t\t\t\t\tswitch($seq[0]) {\n\t\t\t\t\t\tcase 'A': {\n\t\t\t\t\t\t\tif ($key == 0) {\n\t\t\t\t\t\t\t\t$startid = 103;\n\t\t\t\t\t\t\t} elseif ($sequence[($key - 1)][0] != 'A') {\n\t\t\t\t\t\t\t\tif (($seq[2] == 1) AND ($key > 0) AND ($sequence[($key - 1)][0] == 'B') AND (!isset($sequence[($key - 1)][3]))) {\n\t\t\t\t\t\t\t\t\t// single character shift\n\t\t\t\t\t\t\t\t\t$code_data[] = 98;\n\t\t\t\t\t\t\t\t\t// mark shift\n\t\t\t\t\t\t\t\t\t$sequence[$key][3] = true;\n\t\t\t\t\t\t\t\t} elseif (!isset($sequence[($key - 1)][3])) {\n\t\t\t\t\t\t\t\t\t$code_data[] = 101;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ($i = 0; $i < $seq[2]; ++$i) {\n\t\t\t\t\t\t\t\t$char = $seq[1][$i];\n\t\t\t\t\t\t\t\t$char_id = ord($char);\n\t\t\t\t\t\t\t\tif (($char_id >= 241) AND ($char_id <= 244)) {\n\t\t\t\t\t\t\t\t\t$code_data[] = $fnc_a[$char_id];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$code_data[] = strpos($keys_a, $char);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'B': {\n\t\t\t\t\t\t\tif ($key == 0) {\n\t\t\t\t\t\t\t\t$tmpchr = ord($seq[1][0]);\n\t\t\t\t\t\t\t\tif (($seq[2] == 1) AND ($tmpchr >= 241) AND ($tmpchr <= 244) AND isset($sequence[($key + 1)]) AND ($sequence[($key + 1)][0] != 'B')) {\n\t\t\t\t\t\t\t\t\tswitch ($sequence[($key + 1)][0]) {\n\t\t\t\t\t\t\t\t\t\tcase 'A': {\n\t\t\t\t\t\t\t\t\t\t\t$startid = 103;\n\t\t\t\t\t\t\t\t\t\t\t$sequence[$key][0] = 'A';\n\t\t\t\t\t\t\t\t\t\t\t$code_data[] = $fnc_a[$tmpchr];\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcase 'C': {\n\t\t\t\t\t\t\t\t\t\t\t$startid = 105;\n\t\t\t\t\t\t\t\t\t\t\t$sequence[$key][0] = 'C';\n\t\t\t\t\t\t\t\t\t\t\t$code_data[] = $fnc_a[$tmpchr];\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$startid = 104;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} elseif ($sequence[($key - 1)][0] != 'B') {\n\t\t\t\t\t\t\t\tif (($seq[2] == 1) AND ($key > 0) AND ($sequence[($key - 1)][0] == 'A') AND (!isset($sequence[($key - 1)][3]))) {\n\t\t\t\t\t\t\t\t\t// single character shift\n\t\t\t\t\t\t\t\t\t$code_data[] = 98;\n\t\t\t\t\t\t\t\t\t// mark shift\n\t\t\t\t\t\t\t\t\t$sequence[$key][3] = true;\n\t\t\t\t\t\t\t\t} elseif (!isset($sequence[($key - 1)][3])) {\n\t\t\t\t\t\t\t\t\t$code_data[] = 100;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ($i = 0; $i < $seq[2]; ++$i) {\n\t\t\t\t\t\t\t\t$char = $seq[1][$i];\n\t\t\t\t\t\t\t\t$char_id = ord($char);\n\t\t\t\t\t\t\t\tif (($char_id >= 241) AND ($char_id <= 244)) {\n\t\t\t\t\t\t\t\t\t$code_data[] = $fnc_b[$char_id];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$code_data[] = strpos($keys_b, $char);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'C': {\n\t\t\t\t\t\t\tif ($key == 0) {\n\t\t\t\t\t\t\t\t$startid = 105;\n\t\t\t\t\t\t\t} elseif ($sequence[($key - 1)][0] != 'C') {\n\t\t\t\t\t\t\t\t$code_data[] = 99;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ($i = 0; $i < $seq[2]; $i+=2) {\n\t\t\t\t\t\t\t\t$chrnum = $seq[1][$i].$seq[1][$i+1];\n\t\t\t\t\t\t\t\t$code_data[] = intval($chrnum);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// calculate check character\n\t\t$sum = $startid;\n\t\tforeach ($code_data as $key => $val) {\n\t\t\t$sum += ($val * ($key + 1));\n\t\t}\n\t\t// add check character\n\t\t$code_data[] = ($sum % 103);\n\t\t// add stop sequence\n\t\t$code_data[] = 106;\n\t\t$code_data[] = 107;\n\t\t// add start code at the beginning\n\t\tarray_unshift($code_data, $startid);\n\t\t// build barcode array\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\tforeach ($code_data as $val) {\n\t\t\t$seq = $chr[$val];\n\t\t\tfor ($j = 0; $j < 6; ++$j) {\n\t\t\t\tif (($j % 2) == 0) {\n\t\t\t\t\t$t = true; // bar\n\t\t\t\t} else {\n\t\t\t\t\t$t = false; // space\n\t\t\t\t}\n\t\t\t\t$w = (float)$seq[$j];\n\t\t\t\t$bararray['bcode'][] = array('t' => $t, 'w' => $w, 'h' => 1, 'p' => 0);\n\t\t\t\t$bararray['maxw'] += $w;\n\t\t\t}\n\t\t}\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * Split text code in A/B sequence for 128 code\n\t * @param string $code code to split.\n\t * @return array sequence\n\t * @protected\n\t */\n\tprotected function get128ABsequence($code) {\n\t\t$len = strlen($code);\n\t\t$sequence = array();\n\t\t// get A sequences (if any)\n\t\t$numseq = array();\n\t\tpreg_match_all('/([\\0-\\31])/', $code, $numseq, PREG_OFFSET_CAPTURE);\n\t\tif (isset($numseq[1]) AND !empty($numseq[1])) {\n\t\t\t$end_offset = 0;\n\t\t\tforeach ($numseq[1] as $val) {\n\t\t\t\t$offset = $val[1];\n\t\t\t\tif ($offset > $end_offset) {\n\t\t\t\t\t// B sequence\n\t\t\t\t\t$sequence[] = array('B', substr($code, $end_offset, ($offset - $end_offset)), ($offset - $end_offset));\n\t\t\t\t}\n\t\t\t\t// A sequence\n\t\t\t\t$slen = strlen($val[0]);\n\t\t\t\t$sequence[] = array('A', substr($code, $offset, $slen), $slen);\n\t\t\t\t$end_offset = $offset + $slen;\n\t\t\t}\n\t\t\tif ($end_offset < $len) {\n\t\t\t\t$sequence[] = array('B', substr($code, $end_offset), ($len - $end_offset));\n\t\t\t}\n\t\t} else {\n\t\t\t// only B sequence\n\t\t\t$sequence[] = array('B', $code, $len);\n\t\t}\n\t\treturn $sequence;\n\t}\n\n\t/**\n\t * EAN13 and UPC-A barcodes.\n\t * EAN13: European Article Numbering international retail product code\n\t * UPC-A: Universal product code seen on almost all retail products in the USA and Canada\n\t * UPC-E: Short version of UPC symbol\n\t * @param string $code code to represent.\n\t * @param string $len barcode type: 6 = UPC-E, 8 = EAN8, 13 = EAN13, 12 = UPC-A\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_eanupc($code, $len=13) {\n\t\t$upce = false;\n\t\tif ($len == 6) {\n\t\t\t$len = 12; // UPC-A\n\t\t\t$upce = true; // UPC-E mode\n\t\t}\n\t\t$data_len = $len - 1;\n\t\t//Padding\n\t\t$code = str_pad($code, $data_len, '0', STR_PAD_LEFT);\n\t\t$code_len = strlen($code);\n\t\t// calculate check digit\n\t\t$sum_a = 0;\n\t\tfor ($i = 1; $i < $data_len; $i+=2) {\n\t\t\t$sum_a += $code[$i];\n\t\t}\n\t\tif ($len > 12) {\n\t\t\t$sum_a *= 3;\n\t\t}\n\t\t$sum_b = 0;\n\t\tfor ($i = 0; $i < $data_len; $i+=2) {\n\t\t\t$sum_b += ($code[$i]);\n\t\t}\n\t\tif ($len < 13) {\n\t\t\t$sum_b *= 3;\n\t\t}\n\t\t$r = ($sum_a + $sum_b) % 10;\n\t\tif($r > 0) {\n\t\t\t$r = (10 - $r);\n\t\t}\n\t\tif ($code_len == $data_len) {\n\t\t\t// add check digit\n\t\t\t$code .= $r;\n\t\t} elseif ($r !== intval($code[$data_len])) {\n\t\t\t// wrong checkdigit\n\t\t\treturn false;\n\t\t}\n\t\tif ($len == 12) {\n\t\t\t// UPC-A\n\t\t\t$code = '0'.$code;\n\t\t\t++$len;\n\t\t}\n\t\tif ($upce) {\n\t\t\t// convert UPC-A to UPC-E\n\t\t\t$tmp = substr($code, 4, 3);\n\t\t\tif (($tmp == '000') OR ($tmp == '100') OR ($tmp == '200')) {\n\t\t\t\t// manufacturer code ends in 000, 100, or 200\n\t\t\t\t$upce_code = substr($code, 2, 2).substr($code, 9, 3).substr($code, 4, 1);\n\t\t\t} else {\n\t\t\t\t$tmp = substr($code, 5, 2);\n\t\t\t\tif ($tmp == '00') {\n\t\t\t\t\t// manufacturer code ends in 00\n\t\t\t\t\t$upce_code = substr($code, 2, 3).substr($code, 10, 2).'3';\n\t\t\t\t} else {\n\t\t\t\t\t$tmp = substr($code, 6, 1);\n\t\t\t\t\tif ($tmp == '0') {\n\t\t\t\t\t\t// manufacturer code ends in 0\n\t\t\t\t\t\t$upce_code = substr($code, 2, 4).substr($code, 11, 1).'4';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// manufacturer code does not end in zero\n\t\t\t\t\t\t$upce_code = substr($code, 2, 5).substr($code, 11, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//Convert digits to bars\n\t\t$codes = array(\n\t\t\t'A'=>array( // left odd parity\n\t\t\t\t'0'=>'0001101',\n\t\t\t\t'1'=>'0011001',\n\t\t\t\t'2'=>'0010011',\n\t\t\t\t'3'=>'0111101',\n\t\t\t\t'4'=>'0100011',\n\t\t\t\t'5'=>'0110001',\n\t\t\t\t'6'=>'0101111',\n\t\t\t\t'7'=>'0111011',\n\t\t\t\t'8'=>'0110111',\n\t\t\t\t'9'=>'0001011'),\n\t\t\t'B'=>array( // left even parity\n\t\t\t\t'0'=>'0100111',\n\t\t\t\t'1'=>'0110011',\n\t\t\t\t'2'=>'0011011',\n\t\t\t\t'3'=>'0100001',\n\t\t\t\t'4'=>'0011101',\n\t\t\t\t'5'=>'0111001',\n\t\t\t\t'6'=>'0000101',\n\t\t\t\t'7'=>'0010001',\n\t\t\t\t'8'=>'0001001',\n\t\t\t\t'9'=>'0010111'),\n\t\t\t'C'=>array( // right\n\t\t\t\t'0'=>'1110010',\n\t\t\t\t'1'=>'1100110',\n\t\t\t\t'2'=>'1101100',\n\t\t\t\t'3'=>'1000010',\n\t\t\t\t'4'=>'1011100',\n\t\t\t\t'5'=>'1001110',\n\t\t\t\t'6'=>'1010000',\n\t\t\t\t'7'=>'1000100',\n\t\t\t\t'8'=>'1001000',\n\t\t\t\t'9'=>'1110100')\n\t\t);\n\t\t$parities = array(\n\t\t\t'0'=>array('A','A','A','A','A','A'),\n\t\t\t'1'=>array('A','A','B','A','B','B'),\n\t\t\t'2'=>array('A','A','B','B','A','B'),\n\t\t\t'3'=>array('A','A','B','B','B','A'),\n\t\t\t'4'=>array('A','B','A','A','B','B'),\n\t\t\t'5'=>array('A','B','B','A','A','B'),\n\t\t\t'6'=>array('A','B','B','B','A','A'),\n\t\t\t'7'=>array('A','B','A','B','A','B'),\n\t\t\t'8'=>array('A','B','A','B','B','A'),\n\t\t\t'9'=>array('A','B','B','A','B','A')\n\t\t);\n\t\t$upce_parities = array();\n\t\t$upce_parities[0] = array(\n\t\t\t'0'=>array('B','B','B','A','A','A'),\n\t\t\t'1'=>array('B','B','A','B','A','A'),\n\t\t\t'2'=>array('B','B','A','A','B','A'),\n\t\t\t'3'=>array('B','B','A','A','A','B'),\n\t\t\t'4'=>array('B','A','B','B','A','A'),\n\t\t\t'5'=>array('B','A','A','B','B','A'),\n\t\t\t'6'=>array('B','A','A','A','B','B'),\n\t\t\t'7'=>array('B','A','B','A','B','A'),\n\t\t\t'8'=>array('B','A','B','A','A','B'),\n\t\t\t'9'=>array('B','A','A','B','A','B')\n\t\t);\n\t\t$upce_parities[1] = array(\n\t\t\t'0'=>array('A','A','A','B','B','B'),\n\t\t\t'1'=>array('A','A','B','A','B','B'),\n\t\t\t'2'=>array('A','A','B','B','A','B'),\n\t\t\t'3'=>array('A','A','B','B','B','A'),\n\t\t\t'4'=>array('A','B','A','A','B','B'),\n\t\t\t'5'=>array('A','B','B','A','A','B'),\n\t\t\t'6'=>array('A','B','B','B','A','A'),\n\t\t\t'7'=>array('A','B','A','B','A','B'),\n\t\t\t'8'=>array('A','B','A','B','B','A'),\n\t\t\t'9'=>array('A','B','B','A','B','A')\n\t\t);\n\t\t$k = 0;\n\t\t$seq = '101'; // left guard bar\n\t\tif ($upce) {\n\t\t\t$bararray = array('code' => $upce_code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\t\t$p = $upce_parities[$code[1]][$r];\n\t\t\tfor ($i = 0; $i < 6; ++$i) {\n\t\t\t\t$seq .= $codes[$p[$i]][$upce_code[$i]];\n\t\t\t}\n\t\t\t$seq .= '010101'; // right guard bar\n\t\t} else {\n\t\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\t\t$half_len = intval(ceil($len / 2));\n\t\t\tif ($len == 8) {\n\t\t\t\tfor ($i = 0; $i < $half_len; ++$i) {\n\t\t\t\t\t$seq .= $codes['A'][$code[$i]];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$p = $parities[$code[0]];\n\t\t\t\tfor ($i = 1; $i < $half_len; ++$i) {\n\t\t\t\t\t$seq .= $codes[$p[$i-1]][$code[$i]];\n\t\t\t\t}\n\t\t\t}\n\t\t\t$seq .= '01010'; // center guard bar\n\t\t\tfor ($i = $half_len; $i < $len; ++$i) {\n\t\t\t\t$seq .= $codes['C'][$code[$i]];\n\t\t\t}\n\t\t\t$seq .= '101'; // right guard bar\n\t\t}\n\t\t$clen = strlen($seq);\n\t\t$w = 0;\n\t\tfor ($i = 0; $i < $clen; ++$i) {\n\t\t\t$w += 1;\n\t\t\tif (($i == ($clen - 1)) OR (($i < ($clen - 1)) AND ($seq[$i] != $seq[$i+1]))) {\n\t\t\t\tif ($seq[$i] == '1') {\n\t\t\t\t\t$t = true; // bar\n\t\t\t\t} else {\n\t\t\t\t\t$t = false; // space\n\t\t\t\t}\n\t\t\t\t$bararray['bcode'][$k] = array('t' => $t, 'w' => $w, 'h' => 1, 'p' => 0);\n\t\t\t\t$bararray['maxw'] += $w;\n\t\t\t\t++$k;\n\t\t\t\t$w = 0;\n\t\t\t}\n\t\t}\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * UPC-Based Extensions\n\t * 2-Digit Ext.: Used to indicate magazines and newspaper issue numbers\n\t * 5-Digit Ext.: Used to mark suggested retail price of books\n\t * @param string $code code to represent.\n\t * @param string $len barcode type: 2 = 2-Digit, 5 = 5-Digit\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_eanext($code, $len=5) {\n\t\t//Padding\n\t\t$code = str_pad($code, $len, '0', STR_PAD_LEFT);\n\t\t// calculate check digit\n\t\tif ($len == 2) {\n\t\t\t$r = $code % 4;\n\t\t} elseif ($len == 5) {\n\t\t\t$r = (3 * ($code[0] + $code[2] + $code[4])) + (9 * ($code[1] + $code[3]));\n\t\t\t$r %= 10;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\t//Convert digits to bars\n\t\t$codes = array(\n\t\t\t'A'=>array( // left odd parity\n\t\t\t\t'0'=>'0001101',\n\t\t\t\t'1'=>'0011001',\n\t\t\t\t'2'=>'0010011',\n\t\t\t\t'3'=>'0111101',\n\t\t\t\t'4'=>'0100011',\n\t\t\t\t'5'=>'0110001',\n\t\t\t\t'6'=>'0101111',\n\t\t\t\t'7'=>'0111011',\n\t\t\t\t'8'=>'0110111',\n\t\t\t\t'9'=>'0001011'),\n\t\t\t'B'=>array( // left even parity\n\t\t\t\t'0'=>'0100111',\n\t\t\t\t'1'=>'0110011',\n\t\t\t\t'2'=>'0011011',\n\t\t\t\t'3'=>'0100001',\n\t\t\t\t'4'=>'0011101',\n\t\t\t\t'5'=>'0111001',\n\t\t\t\t'6'=>'0000101',\n\t\t\t\t'7'=>'0010001',\n\t\t\t\t'8'=>'0001001',\n\t\t\t\t'9'=>'0010111')\n\t\t);\n\t\t$parities = array();\n\t\t$parities[2] = array(\n\t\t\t'0'=>array('A','A'),\n\t\t\t'1'=>array('A','B'),\n\t\t\t'2'=>array('B','A'),\n\t\t\t'3'=>array('B','B')\n\t\t);\n\t\t$parities[5] = array(\n\t\t\t'0'=>array('B','B','A','A','A'),\n\t\t\t'1'=>array('B','A','B','A','A'),\n\t\t\t'2'=>array('B','A','A','B','A'),\n\t\t\t'3'=>array('B','A','A','A','B'),\n\t\t\t'4'=>array('A','B','B','A','A'),\n\t\t\t'5'=>array('A','A','B','B','A'),\n\t\t\t'6'=>array('A','A','A','B','B'),\n\t\t\t'7'=>array('A','B','A','B','A'),\n\t\t\t'8'=>array('A','B','A','A','B'),\n\t\t\t'9'=>array('A','A','B','A','B')\n\t\t);\n\t\t$p = $parities[$len][$r];\n\t\t$seq = '1011'; // left guard bar\n\t\t$seq .= $codes[$p[0]][$code[0]];\n\t\tfor ($i = 1; $i < $len; ++$i) {\n\t\t\t$seq .= '01'; // separator\n\t\t\t$seq .= $codes[$p[$i]][$code[$i]];\n\t\t}\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\treturn $this->binseq_to_array($seq, $bararray);\n\t}\n\n\t/**\n\t * POSTNET and PLANET barcodes.\n\t * Used by U.S. Postal Service for automated mail sorting\n\t * @param string $code zip code to represent. Must be a string containing a zip code of the form DDDDD or DDDDD-DDDD.\n\t * @param boolean $planet if true print the PLANET barcode, otherwise print POSTNET\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_postnet($code, $planet=false) {\n\t\t// bar length\n\t\tif ($planet) {\n\t\t\t$barlen = Array(\n\t\t\t\t0 => Array(1,1,2,2,2),\n\t\t\t\t1 => Array(2,2,2,1,1),\n\t\t\t\t2 => Array(2,2,1,2,1),\n\t\t\t\t3 => Array(2,2,1,1,2),\n\t\t\t\t4 => Array(2,1,2,2,1),\n\t\t\t\t5 => Array(2,1,2,1,2),\n\t\t\t\t6 => Array(2,1,1,2,2),\n\t\t\t\t7 => Array(1,2,2,2,1),\n\t\t\t\t8 => Array(1,2,2,1,2),\n\t\t\t\t9 => Array(1,2,1,2,2)\n\t\t\t);\n\t\t} else {\n\t\t\t$barlen = Array(\n\t\t\t\t0 => Array(2,2,1,1,1),\n\t\t\t\t1 => Array(1,1,1,2,2),\n\t\t\t\t2 => Array(1,1,2,1,2),\n\t\t\t\t3 => Array(1,1,2,2,1),\n\t\t\t\t4 => Array(1,2,1,1,2),\n\t\t\t\t5 => Array(1,2,1,2,1),\n\t\t\t\t6 => Array(1,2,2,1,1),\n\t\t\t\t7 => Array(2,1,1,1,2),\n\t\t\t\t8 => Array(2,1,1,2,1),\n\t\t\t\t9 => Array(2,1,2,1,1)\n\t\t\t);\n\t\t}\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 2, 'bcode' => array());\n\t\t$k = 0;\n\t\t$code = str_replace('-', '', $code);\n\t\t$code = str_replace(' ', '', $code);\n\t\t$len = strlen($code);\n\t\t// calculate checksum\n\t\t$sum = 0;\n\t\tfor ($i = 0; $i < $len; ++$i) {\n\t\t\t$sum += intval($code[$i]);\n\t\t}\n\t\t$chkd = ($sum % 10);\n\t\tif($chkd > 0) {\n\t\t\t$chkd = (10 - $chkd);\n\t\t}\n\t\t$code .= $chkd;\n\t\t$len = strlen($code);\n\t\t// start bar\n\t\t$bararray['bcode'][$k++] = array('t' => 1, 'w' => 1, 'h' => 2, 'p' => 0);\n\t\t$bararray['bcode'][$k++] = array('t' => 0, 'w' => 1, 'h' => 2, 'p' => 0);\n\t\t$bararray['maxw'] += 2;\n\t\tfor ($i = 0; $i < $len; ++$i) {\n\t\t\tfor ($j = 0; $j < 5; ++$j) {\n\t\t\t\t$h = $barlen[$code[$i]][$j];\n\t\t\t\t$p = floor(1 / $h);\n\t\t\t\t$bararray['bcode'][$k++] = array('t' => 1, 'w' => 1, 'h' => $h, 'p' => $p);\n\t\t\t\t$bararray['bcode'][$k++] = array('t' => 0, 'w' => 1, 'h' => 2, 'p' => 0);\n\t\t\t\t$bararray['maxw'] += 2;\n\t\t\t}\n\t\t}\n\t\t// end bar\n\t\t$bararray['bcode'][$k++] = array('t' => 1, 'w' => 1, 'h' => 2, 'p' => 0);\n\t\t$bararray['maxw'] += 1;\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * RMS4CC - CBC - KIX\n\t * RMS4CC (Royal Mail 4-state Customer Code) - CBC (Customer Bar Code) - KIX (Klant index - Customer index)\n\t * RM4SCC is the name of the barcode symbology used by the Royal Mail for its Cleanmail service.\n\t * @param string $code code to print\n\t * @param boolean $kix if true prints the KIX variation (doesn't use the start and end symbols, and the checksum) - in this case the house number must be sufficed with an X and placed at the end of the code.\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_rms4cc($code, $kix=false) {\n\t\t$notkix = !$kix;\n\t\t// bar mode\n\t\t// 1 = pos 1, length 2\n\t\t// 2 = pos 1, length 3\n\t\t// 3 = pos 2, length 1\n\t\t// 4 = pos 2, length 2\n\t\t$barmode = array(\n\t\t\t'0' => array(3,3,2,2),\n\t\t\t'1' => array(3,4,1,2),\n\t\t\t'2' => array(3,4,2,1),\n\t\t\t'3' => array(4,3,1,2),\n\t\t\t'4' => array(4,3,2,1),\n\t\t\t'5' => array(4,4,1,1),\n\t\t\t'6' => array(3,1,4,2),\n\t\t\t'7' => array(3,2,3,2),\n\t\t\t'8' => array(3,2,4,1),\n\t\t\t'9' => array(4,1,3,2),\n\t\t\t'A' => array(4,1,4,1),\n\t\t\t'B' => array(4,2,3,1),\n\t\t\t'C' => array(3,1,2,4),\n\t\t\t'D' => array(3,2,1,4),\n\t\t\t'E' => array(3,2,2,3),\n\t\t\t'F' => array(4,1,1,4),\n\t\t\t'G' => array(4,1,2,3),\n\t\t\t'H' => array(4,2,1,3),\n\t\t\t'I' => array(1,3,4,2),\n\t\t\t'J' => array(1,4,3,2),\n\t\t\t'K' => array(1,4,4,1),\n\t\t\t'L' => array(2,3,3,2),\n\t\t\t'M' => array(2,3,4,1),\n\t\t\t'N' => array(2,4,3,1),\n\t\t\t'O' => array(1,3,2,4),\n\t\t\t'P' => array(1,4,1,4),\n\t\t\t'Q' => array(1,4,2,3),\n\t\t\t'R' => array(2,3,1,4),\n\t\t\t'S' => array(2,3,2,3),\n\t\t\t'T' => array(2,4,1,3),\n\t\t\t'U' => array(1,1,4,4),\n\t\t\t'V' => array(1,2,3,4),\n\t\t\t'W' => array(1,2,4,3),\n\t\t\t'X' => array(2,1,3,4),\n\t\t\t'Y' => array(2,1,4,3),\n\t\t\t'Z' => array(2,2,3,3)\n\t\t);\n\t\t$code = strtoupper($code);\n\t\t$len = strlen($code);\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 3, 'bcode' => array());\n\t\tif ($notkix) {\n\t\t\t// table for checksum calculation (row,col)\n\t\t\t$checktable = array(\n\t\t\t\t'0' => array(1,1),\n\t\t\t\t'1' => array(1,2),\n\t\t\t\t'2' => array(1,3),\n\t\t\t\t'3' => array(1,4),\n\t\t\t\t'4' => array(1,5),\n\t\t\t\t'5' => array(1,0),\n\t\t\t\t'6' => array(2,1),\n\t\t\t\t'7' => array(2,2),\n\t\t\t\t'8' => array(2,3),\n\t\t\t\t'9' => array(2,4),\n\t\t\t\t'A' => array(2,5),\n\t\t\t\t'B' => array(2,0),\n\t\t\t\t'C' => array(3,1),\n\t\t\t\t'D' => array(3,2),\n\t\t\t\t'E' => array(3,3),\n\t\t\t\t'F' => array(3,4),\n\t\t\t\t'G' => array(3,5),\n\t\t\t\t'H' => array(3,0),\n\t\t\t\t'I' => array(4,1),\n\t\t\t\t'J' => array(4,2),\n\t\t\t\t'K' => array(4,3),\n\t\t\t\t'L' => array(4,4),\n\t\t\t\t'M' => array(4,5),\n\t\t\t\t'N' => array(4,0),\n\t\t\t\t'O' => array(5,1),\n\t\t\t\t'P' => array(5,2),\n\t\t\t\t'Q' => array(5,3),\n\t\t\t\t'R' => array(5,4),\n\t\t\t\t'S' => array(5,5),\n\t\t\t\t'T' => array(5,0),\n\t\t\t\t'U' => array(0,1),\n\t\t\t\t'V' => array(0,2),\n\t\t\t\t'W' => array(0,3),\n\t\t\t\t'X' => array(0,4),\n\t\t\t\t'Y' => array(0,5),\n\t\t\t\t'Z' => array(0,0)\n\t\t\t);\n\t\t\t$row = 0;\n\t\t\t$col = 0;\n\t\t\tfor ($i = 0; $i < $len; ++$i) {\n\t\t\t\t$row += $checktable[$code[$i]][0];\n\t\t\t\t$col += $checktable[$code[$i]][1];\n\t\t\t}\n\t\t\t$row %= 6;\n\t\t\t$col %= 6;\n\t\t\t$chk = array_keys($checktable, array($row,$col));\n\t\t\t$code .= $chk[0];\n\t\t\t++$len;\n\t\t}\n\t\t$k = 0;\n\t\tif ($notkix) {\n\t\t\t// start bar\n\t\t\t$bararray['bcode'][$k++] = array('t' => 1, 'w' => 1, 'h' => 2, 'p' => 0);\n\t\t\t$bararray['bcode'][$k++] = array('t' => 0, 'w' => 1, 'h' => 2, 'p' => 0);\n\t\t\t$bararray['maxw'] += 2;\n\t\t}\n\t\tfor ($i = 0; $i < $len; ++$i) {\n\t\t\tfor ($j = 0; $j < 4; ++$j) {\n\t\t\t\tswitch ($barmode[$code[$i]][$j]) {\n\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t$p = 0;\n\t\t\t\t\t\t$h = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t$p = 0;\n\t\t\t\t\t\t$h = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t$p = 1;\n\t\t\t\t\t\t$h = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 4: {\n\t\t\t\t\t\t$p = 1;\n\t\t\t\t\t\t$h = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$bararray['bcode'][$k++] = array('t' => 1, 'w' => 1, 'h' => $h, 'p' => $p);\n\t\t\t\t$bararray['bcode'][$k++] = array('t' => 0, 'w' => 1, 'h' => 2, 'p' => 0);\n\t\t\t\t$bararray['maxw'] += 2;\n\t\t\t}\n\t\t}\n\t\tif ($notkix) {\n\t\t\t// stop bar\n\t\t\t$bararray['bcode'][$k++] = array('t' => 1, 'w' => 1, 'h' => 3, 'p' => 0);\n\t\t\t$bararray['maxw'] += 1;\n\t\t}\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * CODABAR barcodes.\n\t * Older code often used in library systems, sometimes in blood banks\n\t * @param string $code code to represent.\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_codabar($code) {\n\t\t$chr = array(\n\t\t\t'0' => '11111221',\n\t\t\t'1' => '11112211',\n\t\t\t'2' => '11121121',\n\t\t\t'3' => '22111111',\n\t\t\t'4' => '11211211',\n\t\t\t'5' => '21111211',\n\t\t\t'6' => '12111121',\n\t\t\t'7' => '12112111',\n\t\t\t'8' => '12211111',\n\t\t\t'9' => '21121111',\n\t\t\t'-' => '11122111',\n\t\t\t'$' => '11221111',\n\t\t\t':' => '21112121',\n\t\t\t'/' => '21211121',\n\t\t\t'.' => '21212111',\n\t\t\t'+' => '11222221',\n\t\t\t'A' => '11221211',\n\t\t\t'B' => '12121121',\n\t\t\t'C' => '11121221',\n\t\t\t'D' => '11122211'\n\t\t);\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\t$k = 0;\n\t\t$w = 0;\n\t\t$seq = '';\n\t\t$code = 'A'.strtoupper($code).'A';\n\t\t$len = strlen($code);\n\t\tfor ($i = 0; $i < $len; ++$i) {\n\t\t\tif (!isset($chr[$code[$i]])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$seq = $chr[$code[$i]];\n\t\t\tfor ($j = 0; $j < 8; ++$j) {\n\t\t\t\tif (($j % 2) == 0) {\n\t\t\t\t\t$t = true; // bar\n\t\t\t\t} else {\n\t\t\t\t\t$t = false; // space\n\t\t\t\t}\n\t\t\t\t$w = (float)$seq[$j];\n\t\t\t\t$bararray['bcode'][$k] = array('t' => $t, 'w' => $w, 'h' => 1, 'p' => 0);\n\t\t\t\t$bararray['maxw'] += $w;\n\t\t\t\t++$k;\n\t\t\t}\n\t\t}\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * CODE11 barcodes.\n\t * Used primarily for labeling telecommunications equipment\n\t * @param string $code code to represent.\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_code11($code) {\n\t\t$chr = array(\n\t\t\t'0' => '111121',\n\t\t\t'1' => '211121',\n\t\t\t'2' => '121121',\n\t\t\t'3' => '221111',\n\t\t\t'4' => '112121',\n\t\t\t'5' => '212111',\n\t\t\t'6' => '122111',\n\t\t\t'7' => '111221',\n\t\t\t'8' => '211211',\n\t\t\t'9' => '211111',\n\t\t\t'-' => '112111',\n\t\t\t'S' => '112211'\n\t\t);\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\t$k = 0;\n\t\t$w = 0;\n\t\t$seq = '';\n\t\t$len = strlen($code);\n\t\t// calculate check digit C\n\t\t$p = 1;\n\t\t$check = 0;\n\t\tfor ($i = ($len - 1); $i >= 0; --$i) {\n\t\t\t$digit = $code[$i];\n\t\t\tif ($digit == '-') {\n\t\t\t\t$dval = 10;\n\t\t\t} else {\n\t\t\t\t$dval = intval($digit);\n\t\t\t}\n\t\t\t$check += ($dval * $p);\n\t\t\t++$p;\n\t\t\tif ($p > 10) {\n\t\t\t\t$p = 1;\n\t\t\t}\n\t\t}\n\t\t$check %= 11;\n\t\tif ($check == 10) {\n\t\t\t$check = '-';\n\t\t}\n\t\t$code .= $check;\n\t\tif ($len > 10) {\n\t\t\t// calculate check digit K\n\t\t\t$p = 1;\n\t\t\t$check = 0;\n\t\t\tfor ($i = $len; $i >= 0; --$i) {\n\t\t\t\t$digit = $code[$i];\n\t\t\t\tif ($digit == '-') {\n\t\t\t\t\t$dval = 10;\n\t\t\t\t} else {\n\t\t\t\t\t$dval = intval($digit);\n\t\t\t\t}\n\t\t\t\t$check += ($dval * $p);\n\t\t\t\t++$p;\n\t\t\t\tif ($p > 9) {\n\t\t\t\t\t$p = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$check %= 11;\n\t\t\t$code .= $check;\n\t\t\t++$len;\n\t\t}\n\t\t$code = 'S'.$code.'S';\n\t\t$len += 3;\n\t\tfor ($i = 0; $i < $len; ++$i) {\n\t\t\tif (!isset($chr[$code[$i]])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$seq = $chr[$code[$i]];\n\t\t\tfor ($j = 0; $j < 6; ++$j) {\n\t\t\t\tif (($j % 2) == 0) {\n\t\t\t\t\t$t = true; // bar\n\t\t\t\t} else {\n\t\t\t\t\t$t = false; // space\n\t\t\t\t}\n\t\t\t\t$w = (float)$seq[$j];\n\t\t\t\t$bararray['bcode'][$k] = array('t' => $t, 'w' => $w, 'h' => 1, 'p' => 0);\n\t\t\t\t$bararray['maxw'] += $w;\n\t\t\t\t++$k;\n\t\t\t}\n\t\t}\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * Pharmacode\n\t * Contains digits (0 to 9)\n\t * @param string $code code to represent.\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_pharmacode($code) {\n\t\t$seq = '';\n\t\t$code = intval($code);\n\t\twhile ($code > 0) {\n\t\t\tif (($code % 2) == 0) {\n\t\t\t\t$seq .= '11100';\n\t\t\t\t$code -= 2;\n\t\t\t} else {\n\t\t\t\t$seq .= '100';\n\t\t\t\t$code -= 1;\n\t\t\t}\n\t\t\t$code /= 2;\n\t\t}\n\t\t$seq = substr($seq, 0, -2);\n\t\t$seq = strrev($seq);\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());\n\t\treturn $this->binseq_to_array($seq, $bararray);\n\t}\n\n\t/**\n\t * Pharmacode two-track\n\t * Contains digits (0 to 9)\n\t * @param string $code code to represent.\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_pharmacode2t($code) {\n\t\t$seq = '';\n\t\t$code = intval($code);\n\t\tdo {\n\t\t\tswitch ($code % 3) {\n\t\t\t\tcase 0: {\n\t\t\t\t\t$seq .= '3';\n\t\t\t\t\t$code = ($code - 3) / 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\t$seq .= '1';\n\t\t\t\t\t$code = ($code - 1) / 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\t$seq .= '2';\n\t\t\t\t\t$code = ($code - 2) / 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while($code != 0);\n\t\t$seq = strrev($seq);\n\t\t$k = 0;\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 2, 'bcode' => array());\n\t\t$len = strlen($seq);\n\t\tfor ($i = 0; $i < $len; ++$i) {\n\t\t\tswitch ($seq[$i]) {\n\t\t\t\tcase '1': {\n\t\t\t\t\t$p = 1;\n\t\t\t\t\t$h = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase '2': {\n\t\t\t\t\t$p = 0;\n\t\t\t\t\t$h = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase '3': {\n\t\t\t\t\t$p = 0;\n\t\t\t\t\t$h = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$bararray['bcode'][$k++] = array('t' => 1, 'w' => 1, 'h' => $h, 'p' => $p);\n\t\t\t$bararray['bcode'][$k++] = array('t' => 0, 'w' => 1, 'h' => 2, 'p' => 0);\n\t\t\t$bararray['maxw'] += 2;\n\t\t}\n\t\tunset($bararray['bcode'][($k - 1)]);\n\t\t--$bararray['maxw'];\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * IMB - Intelligent Mail Barcode - Onecode - USPS-B-3200\n\t * (requires PHP bcmath extension)\n\t * Intelligent Mail barcode is a 65-bar code for use on mail in the United States.\n\t * The fields are described as follows:<ul><li>The Barcode Identifier shall be assigned by USPS to encode the presort identification that is currently printed in human readable form on the optional endorsement line (OEL) as well as for future USPS use. This shall be two digits, with the second digit in the range of 0–4. The allowable encoding ranges shall be 00–04, 10–14, 20–24, 30–34, 40–44, 50–54, 60–64, 70–74, 80–84, and 90–94.</li><li>The Service Type Identifier shall be assigned by USPS for any combination of services requested on the mailpiece. The allowable encoding range shall be 000http://it2.php.net/manual/en/function.dechex.php–999. Each 3-digit value shall correspond to a particular mail class with a particular combination of service(s). Each service program, such as OneCode Confirm and OneCode ACS, shall provide the list of Service Type Identifier values.</li><li>The Mailer or Customer Identifier shall be assigned by USPS as a unique, 6 or 9 digit number that identifies a business entity. The allowable encoding range for the 6 digit Mailer ID shall be 000000- 899999, while the allowable encoding range for the 9 digit Mailer ID shall be 900000000-999999999.</li><li>The Serial or Sequence Number shall be assigned by the mailer for uniquely identifying and tracking mailpieces. The allowable encoding range shall be 000000000–999999999 when used with a 6 digit Mailer ID and 000000-999999 when used with a 9 digit Mailer ID. e. The Delivery Point ZIP Code shall be assigned by the mailer for routing the mailpiece. This shall replace POSTNET for routing the mailpiece to its final delivery point. The length may be 0, 5, 9, or 11 digits. The allowable encoding ranges shall be no ZIP Code, 00000–99999,  000000000–999999999, and 00000000000–99999999999.</li></ul>\n\t * @param string $code code to print, separate the ZIP (routing code) from the rest using a minus char '-' (BarcodeID_ServiceTypeID_MailerID_SerialNumber-RoutingCode)\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_imb($code) {\n\t\t$asc_chr = array(4,0,2,6,3,5,1,9,8,7,1,2,0,6,4,8,2,9,5,3,0,1,3,7,4,6,8,9,2,0,5,1,9,4,3,8,6,7,1,2,4,3,9,5,7,8,3,0,2,1,4,0,9,1,7,0,2,4,6,3,7,1,9,5,8);\n\t\t$dsc_chr = array(7,1,9,5,8,0,2,4,6,3,5,8,9,7,3,0,6,1,7,4,6,8,9,2,5,1,7,5,4,3,8,7,6,0,2,5,4,9,3,0,1,6,8,2,0,4,5,9,6,7,5,2,6,3,8,5,1,9,8,7,4,0,2,6,3);\n\t\t$asc_pos = array(3,0,8,11,1,12,8,11,10,6,4,12,2,7,9,6,7,9,2,8,4,0,12,7,10,9,0,7,10,5,7,9,6,8,2,12,1,4,2,0,1,5,4,6,12,1,0,9,4,7,5,10,2,6,9,11,2,12,6,7,5,11,0,3,2);\n\t\t$dsc_pos = array(2,10,12,5,9,1,5,4,3,9,11,5,10,1,6,3,4,1,10,0,2,11,8,6,1,12,3,8,6,4,4,11,0,6,1,9,11,5,3,7,3,10,7,11,8,2,10,3,5,8,0,3,12,11,8,4,5,1,3,0,7,12,9,8,10);\n\t\t$code_arr = explode('-', $code);\n\t\t$tracking_number = $code_arr[0];\n\t\tif (isset($code_arr[1])) {\n\t\t\t$routing_code = $code_arr[1];\n\t\t} else {\n\t\t\t$routing_code = '';\n\t\t}\n\t\t// Conversion of Routing Code\n\t\tswitch (strlen($routing_code)) {\n\t\t\tcase 0: {\n\t\t\t\t$binary_code = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 5: {\n\t\t\t\t$binary_code = bcadd($routing_code, '1');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 9: {\n\t\t\t\t$binary_code = bcadd($routing_code, '100001');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 11: {\n\t\t\t\t$binary_code = bcadd($routing_code, '1000100001');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$binary_code = bcmul($binary_code, 10);\n\t\t$binary_code = bcadd($binary_code, $tracking_number[0]);\n\t\t$binary_code = bcmul($binary_code, 5);\n\t\t$binary_code = bcadd($binary_code, $tracking_number[1]);\n\t\t$binary_code .= substr($tracking_number, 2, 18);\n\t\t// convert to hexadecimal\n\t\t$binary_code = $this->dec_to_hex($binary_code);\n\t\t// pad to get 13 bytes\n\t\t$binary_code = str_pad($binary_code, 26, '0', STR_PAD_LEFT);\n\t\t// convert string to array of bytes\n\t\t$binary_code_arr = chunk_split($binary_code, 2, \"\\r\");\n\t\t$binary_code_arr = substr($binary_code_arr, 0, -1);\n\t\t$binary_code_arr = explode(\"\\r\", $binary_code_arr);\n\t\t// calculate frame check sequence\n\t\t$fcs = $this->imb_crc11fcs($binary_code_arr);\n\t\t// exclude first 2 bits from first byte\n\t\t$first_byte = sprintf('%2s', dechex((hexdec($binary_code_arr[0]) << 2) >> 2));\n\t\t$binary_code_102bit = $first_byte.substr($binary_code, 2);\n\t\t// convert binary data to codewords\n\t\t$codewords = array();\n\t\t$data = $this->hex_to_dec($binary_code_102bit);\n\t\t$codewords[0] = bcmod($data, 636) * 2;\n\t\t$data = bcdiv($data, 636);\n\t\tfor ($i = 1; $i < 9; ++$i) {\n\t\t\t$codewords[$i] = bcmod($data, 1365);\n\t\t\t$data = bcdiv($data, 1365);\n\t\t}\n\t\t$codewords[9] = $data;\n\t\tif (($fcs >> 10) == 1) {\n\t\t\t$codewords[9] += 659;\n\t\t}\n\t\t// generate lookup tables\n\t\t$table2of13 = $this->imb_tables(2, 78);\n\t\t$table5of13 = $this->imb_tables(5, 1287);\n\t\t// convert codewords to characters\n\t\t$characters = array();\n\t\t$bitmask = 512;\n\t\tforeach($codewords as $k => $val) {\n\t\t\tif ($val <= 1286) {\n\t\t\t\t$chrcode = $table5of13[$val];\n\t\t\t} else {\n\t\t\t\t$chrcode = $table2of13[($val - 1287)];\n\t\t\t}\n\t\t\tif (($fcs & $bitmask) > 0) {\n\t\t\t\t// bitwise invert\n\t\t\t\t$chrcode = ((~$chrcode) & 8191);\n\t\t\t}\n\t\t\t$characters[] = $chrcode;\n\t\t\t$bitmask /= 2;\n\t\t}\n\t\t$characters = array_reverse($characters);\n\t\t// build bars\n\t\t$k = 0;\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 3, 'bcode' => array());\n\t\tfor ($i = 0; $i < 65; ++$i) {\n\t\t\t$asc = (($characters[$asc_chr[$i]] & pow(2, $asc_pos[$i])) > 0);\n\t\t\t$dsc = (($characters[$dsc_chr[$i]] & pow(2, $dsc_pos[$i])) > 0);\n\t\t\tif ($asc AND $dsc) {\n\t\t\t\t// full bar (F)\n\t\t\t\t$p = 0;\n\t\t\t\t$h = 3;\n\t\t\t} elseif ($asc) {\n\t\t\t\t// ascender (A)\n\t\t\t\t$p = 0;\n\t\t\t\t$h = 2;\n\t\t\t} elseif ($dsc) {\n\t\t\t\t// descender (D)\n\t\t\t\t$p = 1;\n\t\t\t\t$h = 2;\n\t\t\t} else {\n\t\t\t\t// tracker (T)\n\t\t\t\t$p = 1;\n\t\t\t\t$h = 1;\n\t\t\t}\n\t\t\t$bararray['bcode'][$k++] = array('t' => 1, 'w' => 1, 'h' => $h, 'p' => $p);\n\t\t\t$bararray['bcode'][$k++] = array('t' => 0, 'w' => 1, 'h' => 2, 'p' => 0);\n\t\t\t$bararray['maxw'] += 2;\n\t\t}\n\t\tunset($bararray['bcode'][($k - 1)]);\n\t\t--$bararray['maxw'];\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * IMB - Intelligent Mail Barcode - Onecode - USPS-B-3200\n\t *\n\t * @param string $code pre-formatted IMB barcode (65 chars \"FADT\")\n\t * @return array barcode representation.\n\t * @protected\n\t */\n\tprotected function barcode_imb_pre($code) {\n\t\tif (!preg_match('/^[fadtFADT]{65}$/', $code) == 1) {\n\t\t\treturn false;\n\t\t}\n\t\t$characters = str_split(strtolower($code), 1);\n\t\t// build bars\n\t\t$k = 0;\n\t\t$bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 3, 'bcode' => array());\n\t\tfor ($i = 0; $i < 65; ++$i) {\n\t\t\tswitch($characters[$i]) {\n\t\t\t\tcase 'f': {\n\t\t\t\t\t// full bar\n\t\t\t\t\t$p = 0;\n\t\t\t\t\t$h = 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'a': {\n\t\t\t\t\t// ascender\n\t\t\t\t\t$p = 0;\n\t\t\t\t\t$h = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'd': {\n\t\t\t\t\t// descender\n\t\t\t\t\t$p = 1;\n\t\t\t\t\t$h = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 't': {\n\t\t\t\t\t// tracker (short)\n\t\t\t\t\t$p = 1;\n\t\t\t\t\t$h = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$bararray['bcode'][$k++] = array('t' => 1, 'w' => 1, 'h' => $h, 'p' => $p);\n\t\t\t$bararray['bcode'][$k++] = array('t' => 0, 'w' => 1, 'h' => 2, 'p' => 0);\n\t\t\t$bararray['maxw'] += 2;\n\t\t}\n\t\tunset($bararray['bcode'][($k - 1)]);\n\t\t--$bararray['maxw'];\n\t\treturn $bararray;\n\t}\n\n\t/**\n\t * Convert large integer number to hexadecimal representation.\n\t * (requires PHP bcmath extension)\n\t * @param string $number number to convert specified as a string\n\t * @return string hexadecimal representation\n\t */\n\tpublic function dec_to_hex($number) {\n\t\t$i = 0;\n\t\t$hex = array();\n\t\tif($number == 0) {\n\t\t\treturn '00';\n\t\t}\n\t\twhile($number > 0) {\n\t\t\tif($number == 0) {\n\t\t\t\tarray_push($hex, '0');\n\t\t\t} else {\n\t\t\t\tarray_push($hex, strtoupper(dechex(bcmod($number, '16'))));\n\t\t\t\t$number = bcdiv($number, '16', 0);\n\t\t\t}\n\t\t}\n\t\t$hex = array_reverse($hex);\n\t\treturn implode($hex);\n\t}\n\n\t/**\n\t * Convert large hexadecimal number to decimal representation (string).\n\t * (requires PHP bcmath extension)\n\t * @param string $hex hexadecimal number to convert specified as a string\n\t * @return string hexadecimal representation\n\t */\n\tpublic function hex_to_dec($hex) {\n\t\t$dec = 0;\n\t\t$bitval = 1;\n\t\t$len = strlen($hex);\n\t\tfor($pos = ($len - 1); $pos >= 0; --$pos) {\n\t\t\t$dec = bcadd($dec, bcmul(hexdec($hex[$pos]), $bitval));\n\t\t\t$bitval = bcmul($bitval, 16);\n\t\t}\n\t\treturn $dec;\n\t}\n\n\t/**\n\t * Intelligent Mail Barcode calculation of Frame Check Sequence\n\t * @param string $code_arr array of hexadecimal values (13 bytes holding 102 bits right justified).\n\t * @return int 11 bit Frame Check Sequence as integer (decimal base)\n\t * @protected\n\t */\n\tprotected function imb_crc11fcs($code_arr) {\n\t\t$genpoly = 0x0F35; // generator polynomial\n\t\t$fcs = 0x07FF; // Frame Check Sequence\n\t\t// do most significant byte skipping the 2 most significant bits\n\t\t$data = hexdec($code_arr[0]) << 5;\n\t\tfor ($bit = 2; $bit < 8; ++$bit) {\n\t\t\tif (($fcs ^ $data) & 0x400) {\n\t\t\t\t$fcs = ($fcs << 1) ^ $genpoly;\n\t\t\t} else {\n\t\t\t\t$fcs = ($fcs << 1);\n\t\t\t}\n\t\t\t$fcs &= 0x7FF;\n\t\t\t$data <<= 1;\n\t\t}\n\t\t// do rest of bytes\n\t\tfor ($byte = 1; $byte < 13; ++$byte) {\n\t\t\t$data = hexdec($code_arr[$byte]) << 3;\n\t\t\tfor ($bit = 0; $bit < 8; ++$bit) {\n\t\t\t\tif (($fcs ^ $data) & 0x400) {\n\t\t\t\t\t$fcs = ($fcs << 1) ^ $genpoly;\n\t\t\t\t} else {\n\t\t\t\t\t$fcs = ($fcs << 1);\n\t\t\t\t}\n\t\t\t\t$fcs &= 0x7FF;\n\t\t\t\t$data <<= 1;\n\t\t\t}\n\t\t}\n\t\treturn $fcs;\n\t}\n\n\t/**\n\t * Reverse unsigned short value\n\t * @param int $num value to reversr\n\t * @return int reversed value\n\t * @protected\n\t */\n\tprotected function imb_reverse_us($num) {\n\t\t$rev = 0;\n\t\tfor ($i = 0; $i < 16; ++$i) {\n\t\t\t$rev <<= 1;\n\t\t\t$rev |= ($num & 1);\n\t\t\t$num >>= 1;\n\t\t}\n\t\treturn $rev;\n\t}\n\n\t/**\n\t * generate Nof13 tables used for Intelligent Mail Barcode\n\t * @param int $n is the type of table: 2 for 2of13 table, 5 for 5of13table\n\t * @param int $size size of table (78 for n=2 and 1287 for n=5)\n\t * @return array requested table\n\t * @protected\n\t */\n\tprotected function imb_tables($n, $size) {\n\t\t$table = array();\n\t\t$lli = 0; // LUT lower index\n\t\t$lui = $size - 1; // LUT upper index\n\t\tfor ($count = 0; $count < 8192; ++$count) {\n\t\t\t$bit_count = 0;\n\t\t\tfor ($bit_index = 0; $bit_index < 13; ++$bit_index) {\n\t\t\t\t$bit_count += intval(($count & (1 << $bit_index)) != 0);\n\t\t\t}\n\t\t\t// if we don't have the right number of bits on, go on to the next value\n\t\t\tif ($bit_count == $n) {\n\t\t\t\t$reverse = ($this->imb_reverse_us($count) >> 3);\n\t\t\t\t// if the reverse is less than count, we have already visited this pair before\n\t\t\t\tif ($reverse >= $count) {\n\t\t\t\t\t// If count is symmetric, place it at the first free slot from the end of the list.\n\t\t\t\t\t// Otherwise, place it at the first free slot from the beginning of the list AND place $reverse ath the next free slot from the beginning of the list\n\t\t\t\t\tif ($reverse == $count) {\n\t\t\t\t\t\t$table[$lui] = $count;\n\t\t\t\t\t\t--$lui;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$table[$lli] = $count;\n\t\t\t\t\t\t++$lli;\n\t\t\t\t\t\t$table[$lli] = $reverse;\n\t\t\t\t\t\t++$lli;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $table;\n\t}\n\n} // end of class\n//============================================================+\n// END OF FILE\n//============================================================+\n"
        },
        {
          "name": "tcpdf_barcodes_2d.php",
          "type": "blob",
          "size": 14.3271484375,
          "content": "<?php\n//============================================================+\n// File name   : tcpdf_barcodes_2d.php\n// Version     : 1.0.015\n// Begin       : 2009-04-07\n// Last Update : 2014-05-20\n// Author      : Nicola Asuni - Tecnick.com LTD - www.tecnick.com - info@tecnick.com\n// License     : GNU-LGPL v3 (http://www.gnu.org/copyleft/lesser.html)\n// -------------------------------------------------------------------\n// Copyright (C) 2009-2014 Nicola Asuni - Tecnick.com LTD\n//\n// This file is part of TCPDF software library.\n//\n// TCPDF is free software: you can redistribute it and/or modify it\n// under the terms of the GNU Lesser General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n//\n// TCPDF is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with TCPDF.  If not, see <http://www.gnu.org/licenses/>.\n//\n// See LICENSE.TXT file for more information.\n// -------------------------------------------------------------------\n//\n// Description : PHP class to creates array representations for\n//               2D barcodes to be used with TCPDF.\n//\n//============================================================+\n\n/**\n * @file\n * PHP class to creates array representations for 2D barcodes to be used with TCPDF.\n * @package com.tecnick.tcpdf\n * @author Nicola Asuni\n * @version 1.0.015\n */\n\n/**\n * @class TCPDF2DBarcode\n * PHP class to creates array representations for 2D barcodes to be used with TCPDF (http://www.tcpdf.org).\n * @package com.tecnick.tcpdf\n * @version 1.0.015\n * @author Nicola Asuni\n */\nclass TCPDF2DBarcode {\n\n\t/**\n\t * Array representation of barcode.\n\t * @protected\n\t */\n\tprotected $barcode_array = array();\n\n\t/**\n\t * This is the class constructor.\n\t * Return an array representations for 2D barcodes:<ul>\n\t * <li>$arrcode['code'] code to be printed on text label</li>\n\t * <li>$arrcode['num_rows'] required number of rows</li>\n\t * <li>$arrcode['num_cols'] required number of columns</li>\n\t * <li>$arrcode['bcode'][$r][$c] value of the cell is $r row and $c column (0 = transparent, 1 = black)</li></ul>\n\t * @param string $code code to print\n \t * @param string $type type of barcode: <ul><li>DATAMATRIX : Datamatrix (ISO/IEC 16022)</li><li>PDF417 : PDF417 (ISO/IEC 15438:2006)</li><li>PDF417,a,e,t,s,f,o0,o1,o2,o3,o4,o5,o6 : PDF417 with parameters: a = aspect ratio (width/height); e = error correction level (0-8); t = total number of macro segments; s = macro segment index (0-99998); f = file ID; o0 = File Name (text); o1 = Segment Count (numeric); o2 = Time Stamp (numeric); o3 = Sender (text); o4 = Addressee (text); o5 = File Size (numeric); o6 = Checksum (numeric). NOTES: Parameters t, s and f are required for a Macro Control Block, all other parameters are optional. To use a comma character ',' on text options, replace it with the character 255: \"\\xff\".</li><li>QRCODE : QRcode Low error correction</li><li>QRCODE,L : QRcode Low error correction</li><li>QRCODE,M : QRcode Medium error correction</li><li>QRCODE,Q : QRcode Better error correction</li><li>QRCODE,H : QR-CODE Best error correction</li><li>RAW: raw mode - comma-separad list of array rows</li><li>RAW2: raw mode - array rows are surrounded by square parenthesis.</li><li>TEST : Test matrix</li></ul>\n\t */\n\tpublic function __construct($code, $type) {\n\t\t$this->setBarcode($code, $type);\n\t}\n\n\t/**\n\t * Return an array representations of barcode.\n \t * @return array\n\t */\n\tpublic function getBarcodeArray() {\n\t\treturn $this->barcode_array;\n\t}\n\n\t/**\n\t * Send barcode as SVG image object to the standard output.\n\t * @param int $w Width of a single rectangle element in user units.\n\t * @param int $h Height of a single rectangle element in user units.\n\t * @param string $color Foreground color (in SVG format) for bar elements (background is transparent).\n \t * @public\n\t */\n\tpublic function getBarcodeSVG($w=3, $h=3, $color='black') {\n\t\t// send headers\n\t\t$code = $this->getBarcodeSVGcode($w, $h, $color);\n\t\theader('Content-Type: application/svg+xml');\n\t\theader('Cache-Control: public, must-revalidate, max-age=0'); // HTTP/1.1\n\t\theader('Pragma: public');\n\t\theader('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past\n\t\theader('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');\n\t\theader('Content-Disposition: inline; filename=\"'.md5($code).'.svg\";');\n\t\t//header('Content-Length: '.strlen($code));\n\t\techo $code;\n\t}\n\n\t/**\n\t * Return a SVG string representation of barcode.\n\t * @param int $w Width of a single rectangle element in user units.\n\t * @param int $h Height of a single rectangle element in user units.\n\t * @param string $color Foreground color (in SVG format) for bar elements (background is transparent).\n \t * @return string SVG code.\n \t * @public\n\t */\n\tpublic function getBarcodeSVGcode($w=3, $h=3, $color='black') {\n\t\t// replace table for special characters\n\t\t$repstr = array(\"\\0\" => '', '&' => '&amp;', '<' => '&lt;', '>' => '&gt;');\n\t\t$svg = '<'.'?'.'xml version=\"1.0\" standalone=\"no\"'.'?'.'>'.\"\\n\";\n\t\t$svg .= '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">'.\"\\n\";\n\t\t$svg .= '<svg width=\"'.round(($this->barcode_array['num_cols'] * $w), 3).'\" height=\"'.round(($this->barcode_array['num_rows'] * $h), 3).'\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">'.\"\\n\";\n\t\t$svg .= \"\\t\".'<desc>'.strtr($this->barcode_array['code'], $repstr).'</desc>'.\"\\n\";\n\t\t$svg .= \"\\t\".'<g id=\"elements\" fill=\"'.$color.'\" stroke=\"none\">'.\"\\n\";\n\t\t// print barcode elements\n\t\t$y = 0;\n\t\t// for each row\n\t\tfor ($r = 0; $r < $this->barcode_array['num_rows']; ++$r) {\n\t\t\t$x = 0;\n\t\t\t// for each column\n\t\t\tfor ($c = 0; $c < $this->barcode_array['num_cols']; ++$c) {\n\t\t\t\tif ($this->barcode_array['bcode'][$r][$c] == 1) {\n\t\t\t\t\t// draw a single barcode cell\n\t\t\t\t\t$svg .= \"\\t\\t\".'<rect x=\"'.$x.'\" y=\"'.$y.'\" width=\"'.$w.'\" height=\"'.$h.'\" />'.\"\\n\";\n\t\t\t\t}\n\t\t\t\t$x += $w;\n\t\t\t}\n\t\t\t$y += $h;\n\t\t}\n\t\t$svg .= \"\\t\".'</g>'.\"\\n\";\n\t\t$svg .= '</svg>'.\"\\n\";\n\t\treturn $svg;\n\t}\n\n\t/**\n\t * Return an HTML representation of barcode.\n\t * @param int $w Width of a single rectangle element in pixels.\n\t * @param int $h Height of a single rectangle element in pixels.\n\t * @param string $color Foreground color for bar elements (background is transparent).\n \t * @return string HTML code.\n \t * @public\n\t */\n\tpublic function getBarcodeHTML($w=10, $h=10, $color='black') {\n\t\t$html = '<div style=\"font-size:0;position:relative;width:'.($w * $this->barcode_array['num_cols']).'px;height:'.($h * $this->barcode_array['num_rows']).'px;\">'.\"\\n\";\n\t\t// print barcode elements\n\t\t$y = 0;\n\t\t// for each row\n\t\tfor ($r = 0; $r < $this->barcode_array['num_rows']; ++$r) {\n\t\t\t$x = 0;\n\t\t\t// for each column\n\t\t\tfor ($c = 0; $c < $this->barcode_array['num_cols']; ++$c) {\n\t\t\t\tif ($this->barcode_array['bcode'][$r][$c] == 1) {\n\t\t\t\t\t// draw a single barcode cell\n\t\t\t\t\t$html .= '<div style=\"background-color:'.$color.';width:'.$w.'px;height:'.$h.'px;position:absolute;left:'.$x.'px;top:'.$y.'px;\">&nbsp;</div>'.\"\\n\";\n\t\t\t\t}\n\t\t\t\t$x += $w;\n\t\t\t}\n\t\t\t$y += $h;\n\t\t}\n\t\t$html .= '</div>'.\"\\n\";\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Send a PNG image representation of barcode (requires GD or Imagick library).\n\t * @param int $w Width of a single rectangle element in pixels.\n\t * @param int $h Height of a single rectangle element in pixels.\n\t * @param array $color RGB (0-255) foreground color for bar elements (background is transparent).\n \t * @public\n\t */\n\tpublic function getBarcodePNG($w=3, $h=3, $color=array(0,0,0)) {\n\t\t$data = $this->getBarcodePngData($w, $h, $color);\n\t\t// send headers\n\t\theader('Content-Type: image/png');\n\t\theader('Cache-Control: public, must-revalidate, max-age=0'); // HTTP/1.1\n\t\theader('Pragma: public');\n\t\theader('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past\n\t\theader('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');\n\t\t//header('Content-Length: '.strlen($data));\n\t\techo $data;\n\n\t}\n\n\t/**\n\t * Return a PNG image representation of barcode (requires GD or Imagick library).\n\t * @param int $w Width of a single rectangle element in pixels.\n\t * @param int $h Height of a single rectangle element in pixels.\n\t * @param array $color RGB (0-255) foreground color for bar elements (background is transparent).\n \t * @return string|Imagick|false image or false in case of error.\n \t * @public\n\t */\n\tpublic function getBarcodePngData($w=3, $h=3, $color=array(0,0,0)) {\n\t\t// calculate image size\n\t\t$width = ($this->barcode_array['num_cols'] * $w);\n\t\t$height = ($this->barcode_array['num_rows'] * $h);\n\t\tif (function_exists('imagecreate')) {\n\t\t\t// GD library\n\t\t\t$imagick = false;\n\t\t\t$png = imagecreate($width, $height);\n\t\t\t$bgcol = imagecolorallocate($png, 255, 255, 255);\n\t\t\timagecolortransparent($png, $bgcol);\n\t\t\t$fgcol = imagecolorallocate($png, $color[0], $color[1], $color[2]);\n\t\t} elseif (extension_loaded('imagick')) {\n\t\t\t$imagick = true;\n\t\t\t$bgcol = new imagickpixel('rgb(255,255,255');\n\t\t\t$fgcol = new imagickpixel('rgb('.$color[0].','.$color[1].','.$color[2].')');\n\t\t\t$png = new Imagick();\n\t\t\t$png->newImage($width, $height, 'none', 'png');\n\t\t\t$bar = new imagickdraw();\n\t\t\t$bar->setfillcolor($fgcol);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\t// print barcode elements\n\t\t$y = 0;\n\t\t// for each row\n\t\tfor ($r = 0; $r < $this->barcode_array['num_rows']; ++$r) {\n\t\t\t$x = 0;\n\t\t\t// for each column\n\t\t\tfor ($c = 0; $c < $this->barcode_array['num_cols']; ++$c) {\n\t\t\t\tif ($this->barcode_array['bcode'][$r][$c] == 1) {\n\t\t\t\t\t// draw a single barcode cell\n\t\t\t\t\tif ($imagick) {\n\t\t\t\t\t\t$bar->rectangle($x, $y, ($x + $w - 1), ($y + $h - 1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\timagefilledrectangle($png, $x, $y, ($x + $w - 1), ($y + $h - 1), $fgcol);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$x += $w;\n\t\t\t}\n\t\t\t$y += $h;\n\t\t}\n\t\tif ($imagick) {\n\t\t\t$png->drawimage($bar);\n\t\t\treturn $png;\n\t\t} else {\n\t\t\tob_start();\n\t\t\timagepng($png);\n\t\t\t$imagedata = ob_get_clean();\n\t\t\timagedestroy($png);\n\t\t\treturn $imagedata;\n\t\t}\n\t}\n\n\t/**\n\t * Set the barcode.\n\t * @param string $code code to print\n \t * @param string $type type of barcode: <ul><li>DATAMATRIX : Datamatrix (ISO/IEC 16022)</li><li>PDF417 : PDF417 (ISO/IEC 15438:2006)</li><li>PDF417,a,e,t,s,f,o0,o1,o2,o3,o4,o5,o6 : PDF417 with parameters: a = aspect ratio (width/height); e = error correction level (0-8); t = total number of macro segments; s = macro segment index (0-99998); f = file ID; o0 = File Name (text); o1 = Segment Count (numeric); o2 = Time Stamp (numeric); o3 = Sender (text); o4 = Addressee (text); o5 = File Size (numeric); o6 = Checksum (numeric). NOTES: Parameters t, s and f are required for a Macro Control Block, all other parameters are optional. To use a comma character ',' on text options, replace it with the character 255: \"\\xff\".</li><li>QRCODE : QRcode Low error correction</li><li>QRCODE,L : QRcode Low error correction</li><li>QRCODE,M : QRcode Medium error correction</li><li>QRCODE,Q : QRcode Better error correction</li><li>QRCODE,H : QR-CODE Best error correction</li><li>RAW: raw mode - comma-separad list of array rows</li><li>RAW2: raw mode - array rows are surrounded by square parenthesis.</li><li>TEST : Test matrix</li></ul>\n \t * @return void\n\t */\n\tpublic function setBarcode($code, $type) {\n\t\t$mode = explode(',', $type);\n\t\t$qrtype = strtoupper($mode[0]);\n\t\tswitch ($qrtype) {\n\t\t\tcase 'DATAMATRIX': { // DATAMATRIX (ISO/IEC 16022)\n\t\t\t\trequire_once(dirname(__FILE__).'/include/barcodes/datamatrix.php');\n\t\t\t\t$qrcode = new Datamatrix($code);\n\t\t\t\t$this->barcode_array = $qrcode->getBarcodeArray();\n\t\t\t\t$this->barcode_array['code'] = $code;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'PDF417': { // PDF417 (ISO/IEC 15438:2006)\n\t\t\t\trequire_once(dirname(__FILE__).'/include/barcodes/pdf417.php');\n\t\t\t\tif (!isset($mode[1]) OR ($mode[1] === '')) {\n\t\t\t\t\t$aspectratio = 2; // default aspect ratio (width / height)\n\t\t\t\t} else {\n\t\t\t\t\t$aspectratio = floatval($mode[1]);\n\t\t\t\t}\n\t\t\t\tif (!isset($mode[2]) OR ($mode[2] === '')) {\n\t\t\t\t\t$ecl = -1; // default error correction level (auto)\n\t\t\t\t} else {\n\t\t\t\t\t$ecl = intval($mode[2]);\n\t\t\t\t}\n\t\t\t\t// set macro block\n\t\t\t\t$macro = array();\n\t\t\t\tif (isset($mode[3]) AND ($mode[3] !== '') AND isset($mode[4]) AND ($mode[4] !== '') AND isset($mode[5]) AND ($mode[5] !== '')) {\n\t\t\t\t\t$macro['segment_total'] = intval($mode[3]);\n\t\t\t\t\t$macro['segment_index'] = intval($mode[4]);\n\t\t\t\t\t$macro['file_id'] = strtr($mode[5], \"\\xff\", ',');\n\t\t\t\t\tfor ($i = 0; $i < 7; ++$i) {\n\t\t\t\t\t\t$o = $i + 6;\n\t\t\t\t\t\tif (isset($mode[$o]) AND ($mode[$o] !== '')) {\n\t\t\t\t\t\t\t// add option\n\t\t\t\t\t\t\t$macro['option_'.$i] = strtr($mode[$o], \"\\xff\", ',');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$qrcode = new PDF417($code, $ecl, $aspectratio, $macro);\n\t\t\t\t$this->barcode_array = $qrcode->getBarcodeArray();\n\t\t\t\t$this->barcode_array['code'] = $code;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'QRCODE': { // QR-CODE\n\t\t\t\trequire_once(dirname(__FILE__).'/include/barcodes/qrcode.php');\n\t\t\t\tif (!isset($mode[1]) OR (!in_array($mode[1],array('L','M','Q','H')))) {\n\t\t\t\t\t$mode[1] = 'L'; // Ddefault: Low error correction\n\t\t\t\t}\n\t\t\t\t$qrcode = new QRcode($code, strtoupper($mode[1]));\n\t\t\t\t$this->barcode_array = $qrcode->getBarcodeArray();\n\t\t\t\t$this->barcode_array['code'] = $code;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'RAW':\n\t\t\tcase 'RAW2': { // RAW MODE\n\t\t\t\t// remove spaces\n\t\t\t\t$code = preg_replace('/[\\s]*/si', '', $code);\n\t\t\t\tif (strlen($code) < 3) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ($qrtype == 'RAW') {\n\t\t\t\t\t// comma-separated rows\n\t\t\t\t\t$rows = explode(',', $code);\n\t\t\t\t} else { // RAW2\n\t\t\t\t\t// rows enclosed in square parentheses\n\t\t\t\t\t$code = substr($code, 1, -1);\n\t\t\t\t\t$rows = explode('][', $code);\n\t\t\t\t}\n\t\t\t\t$this->barcode_array['num_rows'] = count($rows);\n\t\t\t\t$this->barcode_array['num_cols'] = strlen($rows[0]);\n\t\t\t\t$this->barcode_array['bcode'] = array();\n\t\t\t\tforeach ($rows as $r) {\n\t\t\t\t\t$this->barcode_array['bcode'][] = str_split($r, 1);\n\t\t\t\t}\n\t\t\t\t$this->barcode_array['code'] = $code;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'TEST': { // TEST MODE\n\t\t\t\t$this->barcode_array['num_rows'] = 5;\n\t\t\t\t$this->barcode_array['num_cols'] = 15;\n\t\t\t\t$this->barcode_array['bcode'] = array(\n\t\t\t\t\tarray(1,1,1,0,1,1,1,0,1,1,1,0,1,1,1),\n\t\t\t\t\tarray(0,1,0,0,1,0,0,0,1,0,0,0,0,1,0),\n\t\t\t\t\tarray(0,1,0,0,1,1,0,0,1,1,1,0,0,1,0),\n\t\t\t\t\tarray(0,1,0,0,1,0,0,0,0,0,1,0,0,1,0),\n\t\t\t\t\tarray(0,1,0,0,1,1,1,0,1,1,1,0,0,1,0));\n\t\t\t\t$this->barcode_array['code'] = $code;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t$this->barcode_array = array();\n\t\t\t}\n\t\t}\n\t}\n} // end of class\n\n//============================================================+\n// END OF FILE\n//============================================================+\n"
        },
        {
          "name": "tcpdf_import.php",
          "type": "blob",
          "size": 3.2119140625,
          "content": "<?php\n//============================================================+\n// File name   : tcpdf_import.php\n// Version     : 1.0.001\n// Begin       : 2011-05-23\n// Last Update : 2013-09-17\n// Author      : Nicola Asuni - Tecnick.com LTD - www.tecnick.com - info@tecnick.com\n// License     : GNU-LGPL v3 (http://www.gnu.org/copyleft/lesser.html)\n// -------------------------------------------------------------------\n// Copyright (C) 2011-2013 Nicola Asuni - Tecnick.com LTD\n//\n// This file is part of TCPDF software library.\n//\n// TCPDF is free software: you can redistribute it and/or modify it\n// under the terms of the GNU Lesser General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n//\n// TCPDF is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the License\n// along with TCPDF. If not, see\n// <http://www.tecnick.com/pagefiles/tcpdf/LICENSE.TXT>.\n//\n// See LICENSE.TXT file for more information.\n// -------------------------------------------------------------------\n//\n// Description : This is a PHP class extension of the TCPDF library to\n//               import existing PDF documents.\n//\n//============================================================+\n\n/**\n * @file\n * !!! THIS CLASS IS UNDER DEVELOPMENT !!!\n * This is a PHP class extension of the TCPDF (http://www.tcpdf.org) library to import existing PDF documents.<br>\n * @package com.tecnick.tcpdf\n * @author Nicola Asuni\n * @version 1.0.001\n */\n\n// include the TCPDF class\nrequire_once(dirname(__FILE__).'/tcpdf.php');\n// include PDF parser class\nrequire_once(dirname(__FILE__).'/tcpdf_parser.php');\n\n/**\n * @class TCPDF_IMPORT\n * !!! THIS CLASS IS UNDER DEVELOPMENT !!!\n * PHP class extension of the TCPDF (http://www.tcpdf.org) library to import existing PDF documents.<br>\n * @package com.tecnick.tcpdf\n * @brief PHP class extension of the TCPDF library to import existing PDF documents.\n * @version 1.0.001\n * @author Nicola Asuni - info@tecnick.com\n */\nclass TCPDF_IMPORT extends TCPDF {\n\n\t/**\n\t * Import an existing PDF document\n\t * @param string $filename Filename of the PDF document to import.\n\t * @return void\n\t * @public\n\t * @since 1.0.000 (2011-05-24)\n\t */\n\tpublic function importPDF($filename) {\n\t\t// load document\n\t\t$rawdata = file_get_contents($filename);\n\t\tif ($rawdata === false) {\n\t\t\t$this->Error('Unable to get the content of the file: '.$filename);\n\t\t}\n\t\t// configuration parameters for parser\n\t\t$cfg = array(\n\t\t\t'die_for_errors' => false,\n\t\t\t'ignore_filter_decoding_errors' => true,\n\t\t\t'ignore_missing_filter_decoders' => true,\n\t\t);\n\t\ttry {\n\t\t\t// parse PDF data\n\t\t\t$pdf = new TCPDF_PARSER($rawdata, $cfg);\n\t\t} catch (Exception $e) {\n\t\t\tdie($e->getMessage());\n\t\t}\n\t\t// get the parsed data\n\t\t$data = $pdf->getParsedData();\n\t\t// release some memory\n\t\tunset($rawdata);\n\n\t\t// ...\n\n\n\t\tprint_r($data); // DEBUG\n\n\n\t\tunset($pdf);\n\t}\n\n} // END OF CLASS\n\n//============================================================+\n// END OF FILE\n//============================================================+\n"
        },
        {
          "name": "tcpdf_parser.php",
          "type": "blob",
          "size": 26.953125,
          "content": "<?php\n//============================================================+\n// File name   : tcpdf_parser.php\n// Version     : 1.0.16\n// Begin       : 2011-05-23\n// Last Update : 2015-04-28\n// Author      : Nicola Asuni - Tecnick.com LTD - www.tecnick.com - info@tecnick.com\n// License     : http://www.tecnick.com/pagefiles/tcpdf/LICENSE.TXT GNU-LGPLv3\n// -------------------------------------------------------------------\n// Copyright (C) 2011-2015 Nicola Asuni - Tecnick.com LTD\n//\n// This file is part of TCPDF software library.\n//\n// TCPDF is free software: you can redistribute it and/or modify it\n// under the terms of the GNU Lesser General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n//\n// TCPDF is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the License\n// along with TCPDF. If not, see\n// <http://www.tecnick.com/pagefiles/tcpdf/LICENSE.TXT>.\n//\n// See LICENSE.TXT file for more information.\n// -------------------------------------------------------------------\n//\n// Description : This is a PHP class for parsing PDF documents.\n//\n//============================================================+\n\n/**\n * @file\n * This is a PHP class for parsing PDF documents.<br>\n * @package com.tecnick.tcpdf\n * @author Nicola Asuni\n * @version 1.0.15\n */\n\n// include class for decoding filters\nrequire_once(dirname(__FILE__).'/include/tcpdf_filters.php');\n\n/**\n * @class TCPDF_PARSER\n * This is a PHP class for parsing PDF documents.<br>\n * @package com.tecnick.tcpdf\n * @brief This is a PHP class for parsing PDF documents..\n * @version 1.0.15\n * @author Nicola Asuni - info@tecnick.com\n */\nclass TCPDF_PARSER {\n\n\t/**\n\t * Raw content of the PDF document.\n\t * @private\n\t */\n\tprivate $pdfdata = '';\n\n\t/**\n\t * XREF data.\n\t * @protected\n\t */\n\tprotected $xref = array();\n\n\t/**\n\t * Array of PDF objects.\n\t * @protected\n\t */\n\tprotected $objects = array();\n\n\t/**\n\t * Class object for decoding filters.\n\t * @private\n\t */\n\tprivate $FilterDecoders;\n\n\t/**\n\t * Array of configuration parameters.\n\t * @private\n\t */\n\tprivate $cfg = array(\n\t\t'die_for_errors' => false,\n\t\t'ignore_filter_decoding_errors' => true,\n\t\t'ignore_missing_filter_decoders' => true,\n\t);\n\n// -----------------------------------------------------------------------------\n\n\t/**\n\t * Parse a PDF document an return an array of objects.\n\t * @param string $data PDF data to parse.\n\t * @param array $cfg Array of configuration parameters:\n\t * \t\t\t'die_for_errors' : if true termitate the program execution in case of error, otherwise thows an exception;\n\t * \t\t\t'ignore_filter_decoding_errors' : if true ignore filter decoding errors;\n\t * \t\t\t'ignore_missing_filter_decoders' : if true ignore missing filter decoding errors.\n\t * @public\n\t * @since 1.0.000 (2011-05-24)\n\t */\n\tpublic function __construct($data, $cfg=array()) {\n\t\tif (empty($data)) {\n\t\t\t$this->Error('Empty PDF data.');\n\t\t}\n\t\t// find the pdf header starting position\n\t\tif (($trimpos = strpos($data, '%PDF-')) === FALSE) {\n\t\t\t$this->Error('Invalid PDF data: missing %PDF header.');\n\t\t}\n\t\t// get PDF content string\n\t\t$this->pdfdata = substr($data, $trimpos);\n\t\t// get length\n\t\t$pdflen = strlen($this->pdfdata);\n\t\t// set configuration parameters\n\t\t$this->setConfig($cfg);\n\t\t// get xref and trailer data\n\t\t$this->xref = $this->getXrefData();\n\t\t// parse all document objects\n\t\t$this->objects = array();\n\t\tforeach ($this->xref['xref'] as $obj => $offset) {\n\t\t\tif (!isset($this->objects[$obj]) AND ($offset > 0)) {\n\t\t\t\t// decode objects with positive offset\n\t\t\t\t$this->objects[$obj] = $this->getIndirectObject($obj, $offset, true);\n\t\t\t}\n\t\t}\n\t\t// release some memory\n\t\tunset($this->pdfdata);\n\t\t$this->pdfdata = '';\n\t}\n\n\t/**\n\t * Set the configuration parameters.\n\t * @param array $cfg Array of configuration parameters:\n\t * \t\t\t'die_for_errors' : if true termitate the program execution in case of error, otherwise thows an exception;\n\t * \t\t\t'ignore_filter_decoding_errors' : if true ignore filter decoding errors;\n\t * \t\t\t'ignore_missing_filter_decoders' : if true ignore missing filter decoding errors.\n\t * @public\n\t */\n\tprotected function setConfig($cfg) {\n\t\tif (isset($cfg['die_for_errors'])) {\n\t\t\t$this->cfg['die_for_errors'] = !!$cfg['die_for_errors'];\n\t\t}\n\t\tif (isset($cfg['ignore_filter_decoding_errors'])) {\n\t\t\t$this->cfg['ignore_filter_decoding_errors'] = !!$cfg['ignore_filter_decoding_errors'];\n\t\t}\n\t\tif (isset($cfg['ignore_missing_filter_decoders'])) {\n\t\t\t$this->cfg['ignore_missing_filter_decoders'] = !!$cfg['ignore_missing_filter_decoders'];\n\t\t}\n\t}\n\n\t/**\n\t * Return an array of parsed PDF document objects.\n\t * @return array Array of parsed PDF document objects.\n\t * @public\n\t * @since 1.0.000 (2011-06-26)\n\t */\n\tpublic function getParsedData() {\n\t\treturn array($this->xref, $this->objects);\n\t}\n\n\t/**\n\t * Get Cross-Reference (xref) table and trailer data from PDF document data.\n\t * @param int $offset xref offset (if know).\n\t * @param array $xref previous xref array (if any).\n\t * @return array containing xref and trailer data.\n\t * @protected\n\t * @since 1.0.000 (2011-05-24)\n\t */\n\tprotected function getXrefData($offset=0, $xref=array()) {\n\t\tif ($offset == 0) {\n\t\t\t// find last startxref\n\t\t\tif (preg_match_all('/[\\r\\n]startxref[\\s]*[\\r\\n]+([0-9]+)[\\s]*[\\r\\n]+%%EOF/i', $this->pdfdata, $matches, PREG_SET_ORDER, $offset) == 0) {\n\t\t\t\t$this->Error('Unable to find startxref');\n\t\t\t}\n\t\t\t$matches = array_pop($matches);\n\t\t\t$startxref = $matches[1];\n\t\t} elseif (strpos($this->pdfdata, 'xref', $offset) == $offset) {\n\t\t\t// Already pointing at the xref table\n\t\t\t$startxref = $offset;\n\t\t} elseif (preg_match('/([0-9]+[\\s][0-9]+[\\s]obj)/i', $this->pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset)) {\n\t\t\t// Cross-Reference Stream object\n\t\t\t$startxref = $offset;\n\t\t} elseif (preg_match('/[\\r\\n]startxref[\\s]*[\\r\\n]+([0-9]+)[\\s]*[\\r\\n]+%%EOF/i', $this->pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset)) {\n\t\t\t// startxref found\n\t\t\t$startxref = $matches[1][0];\n\t\t} else {\n\t\t\t$this->Error('Unable to find startxref');\n\t\t}\n\t\t// check xref position\n\t\tif (strpos($this->pdfdata, 'xref', $startxref) == $startxref) {\n\t\t\t// Cross-Reference\n\t\t\t$xref = $this->decodeXref($startxref, $xref);\n\t\t} else {\n\t\t\t// Cross-Reference Stream\n\t\t\t$xref = $this->decodeXrefStream($startxref, $xref);\n\t\t}\n\t\tif (empty($xref)) {\n\t\t\t$this->Error('Unable to find xref');\n\t\t}\n\t\treturn $xref;\n\t}\n\n\t/**\n\t * Decode the Cross-Reference section\n\t * @param int $startxref Offset at which the xref section starts (position of the 'xref' keyword).\n\t * @param array $xref Previous xref array (if any).\n\t * @return array containing xref and trailer data.\n\t * @protected\n\t * @since 1.0.000 (2011-06-20)\n\t */\n\tprotected function decodeXref($startxref, $xref=array()) {\n\t\t$startxref += 4; // 4 is the length of the word 'xref'\n\t\t// skip initial white space chars: \\x00 null (NUL), \\x09 horizontal tab (HT), \\x0A line feed (LF), \\x0C form feed (FF), \\x0D carriage return (CR), \\x20 space (SP)\n\t\t$offset = $startxref + strspn($this->pdfdata, \"\\x00\\x09\\x0a\\x0c\\x0d\\x20\", $startxref);\n\t\t// initialize object number\n\t\t$obj_num = 0;\n\t\t// search for cross-reference entries or subsection\n\t\twhile (preg_match('/([0-9]+)[\\x20]([0-9]+)[\\x20]?([nf]?)(\\r\\n|[\\x20]?[\\r\\n])/', $this->pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset) > 0) {\n\t\t\tif ($matches[0][1] != $offset) {\n\t\t\t\t// we are on another section\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$offset += strlen($matches[0][0]);\n\t\t\tif ($matches[3][0] == 'n') {\n\t\t\t\t// create unique object index: [object number]_[generation number]\n\t\t\t\t$index = $obj_num.'_'.intval($matches[2][0]);\n\t\t\t\t// check if object already exist\n\t\t\t\tif (!isset($xref['xref'][$index])) {\n\t\t\t\t\t// store object offset position\n\t\t\t\t\t$xref['xref'][$index] = intval($matches[1][0]);\n\t\t\t\t}\n\t\t\t\t++$obj_num;\n\t\t\t} elseif ($matches[3][0] == 'f') {\n\t\t\t\t++$obj_num;\n\t\t\t} else {\n\t\t\t\t// object number (index)\n\t\t\t\t$obj_num = intval($matches[1][0]);\n\t\t\t}\n\t\t}\n\t\t// get trailer data\n\t\tif (preg_match('/trailer[\\s]*<<(.*)>>/isU', $this->pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset) > 0) {\n\t\t\t$trailer_data = $matches[1][0];\n\t\t\tif (!isset($xref['trailer']) OR empty($xref['trailer'])) {\n\t\t\t\t// get only the last updated version\n\t\t\t\t$xref['trailer'] = array();\n\t\t\t\t// parse trailer_data\n\t\t\t\tif (preg_match('/Size[\\s]+([0-9]+)/i', $trailer_data, $matches) > 0) {\n\t\t\t\t\t$xref['trailer']['size'] = intval($matches[1]);\n\t\t\t\t}\n\t\t\t\tif (preg_match('/Root[\\s]+([0-9]+)[\\s]+([0-9]+)[\\s]+R/i', $trailer_data, $matches) > 0) {\n\t\t\t\t\t$xref['trailer']['root'] = intval($matches[1]).'_'.intval($matches[2]);\n\t\t\t\t}\n\t\t\t\tif (preg_match('/Encrypt[\\s]+([0-9]+)[\\s]+([0-9]+)[\\s]+R/i', $trailer_data, $matches) > 0) {\n\t\t\t\t\t$xref['trailer']['encrypt'] = intval($matches[1]).'_'.intval($matches[2]);\n\t\t\t\t}\n\t\t\t\tif (preg_match('/Info[\\s]+([0-9]+)[\\s]+([0-9]+)[\\s]+R/i', $trailer_data, $matches) > 0) {\n\t\t\t\t\t$xref['trailer']['info'] = intval($matches[1]).'_'.intval($matches[2]);\n\t\t\t\t}\n\t\t\t\tif (preg_match('/ID[\\s]*[\\[][\\s]*[<]([^>]*)[>][\\s]*[<]([^>]*)[>]/i', $trailer_data, $matches) > 0) {\n\t\t\t\t\t$xref['trailer']['id'] = array();\n\t\t\t\t\t$xref['trailer']['id'][0] = $matches[1];\n\t\t\t\t\t$xref['trailer']['id'][1] = $matches[2];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (preg_match('/Prev[\\s]+([0-9]+)/i', $trailer_data, $matches) > 0) {\n\t\t\t\t// get previous xref\n\t\t\t\t$xref = $this->getXrefData(intval($matches[1]), $xref);\n\t\t\t}\n\t\t} else {\n\t\t\t$this->Error('Unable to find trailer');\n\t\t}\n\t\treturn $xref;\n\t}\n\n\t/**\n\t * Decode the Cross-Reference Stream section\n\t * @param int $startxref Offset at which the xref section starts.\n\t * @param array $xref Previous xref array (if any).\n\t * @return array containing xref and trailer data.\n\t * @protected\n\t * @since 1.0.003 (2013-03-16)\n\t */\n\tprotected function decodeXrefStream($startxref, $xref=array()) {\n\t\t// try to read Cross-Reference Stream\n\t\t$xrefobj = $this->getRawObject($startxref);\n\t\t$xrefcrs = $this->getIndirectObject($xrefobj[1], $startxref, true);\n\t\tif (!isset($xref['trailer']) OR empty($xref['trailer'])) {\n\t\t\t// get only the last updated version\n\t\t\t$xref['trailer'] = array();\n\t\t\t$filltrailer = true;\n\t\t} else {\n\t\t\t$filltrailer = false;\n\t\t}\n\t\tif (!isset($xref['xref'])) {\n\t\t\t$xref['xref'] = array();\n\t\t}\n\t\t$valid_crs = false;\n\t\t$columns = 0;\n\t\t$sarr = $xrefcrs[0][1];\n\t\tif (!is_array($sarr)) {\n\t\t\t$sarr = array();\n\t\t}\n\t\tforeach ($sarr as $k => $v) {\n\t\t\tif (($v[0] == '/') AND ($v[1] == 'Type') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == '/') AND ($sarr[($k +1)][1] == 'XRef'))) {\n\t\t\t\t$valid_crs = true;\n\t\t\t} elseif (($v[0] == '/') AND ($v[1] == 'Index') AND (isset($sarr[($k +1)]))) {\n\t\t\t\t// first object number in the subsection\n\t\t\t\t$index_first = intval($sarr[($k +1)][1][0][1]);\n\t\t\t\t// number of entries in the subsection\n\t\t\t\t$index_entries = intval($sarr[($k +1)][1][1][1]);\n\t\t\t} elseif (($v[0] == '/') AND ($v[1] == 'Prev') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'numeric'))) {\n\t\t\t\t// get previous xref offset\n\t\t\t\t$prevxref = intval($sarr[($k +1)][1]);\n\t\t\t} elseif (($v[0] == '/') AND ($v[1] == 'W') AND (isset($sarr[($k +1)]))) {\n\t\t\t\t// number of bytes (in the decoded stream) of the corresponding field\n\t\t\t\t$wb = array();\n\t\t\t\t$wb[0] = intval($sarr[($k +1)][1][0][1]);\n\t\t\t\t$wb[1] = intval($sarr[($k +1)][1][1][1]);\n\t\t\t\t$wb[2] = intval($sarr[($k +1)][1][2][1]);\n\t\t\t} elseif (($v[0] == '/') AND ($v[1] == 'DecodeParms') AND (isset($sarr[($k +1)][1]))) {\n\t\t\t\t$decpar = $sarr[($k +1)][1];\n\t\t\t\tforeach ($decpar as $kdc => $vdc) {\n\t\t\t\t\tif (($vdc[0] == '/') AND ($vdc[1] == 'Columns') AND (isset($decpar[($kdc +1)]) AND ($decpar[($kdc +1)][0] == 'numeric'))) {\n\t\t\t\t\t\t$columns = intval($decpar[($kdc +1)][1]);\n\t\t\t\t\t} elseif (($vdc[0] == '/') AND ($vdc[1] == 'Predictor') AND (isset($decpar[($kdc +1)]) AND ($decpar[($kdc +1)][0] == 'numeric'))) {\n\t\t\t\t\t\t$predictor = intval($decpar[($kdc +1)][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} elseif ($filltrailer) {\n\t\t\t\tif (($v[0] == '/') AND ($v[1] == 'Size') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'numeric'))) {\n\t\t\t\t\t$xref['trailer']['size'] = $sarr[($k +1)][1];\n\t\t\t\t} elseif (($v[0] == '/') AND ($v[1] == 'Root') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {\n\t\t\t\t\t$xref['trailer']['root'] = $sarr[($k +1)][1];\n\t\t\t\t} elseif (($v[0] == '/') AND ($v[1] == 'Info') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {\n\t\t\t\t\t$xref['trailer']['info'] = $sarr[($k +1)][1];\n\t\t\t\t} elseif (($v[0] == '/') AND ($v[1] == 'Encrypt') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {\n\t\t\t\t\t$xref['trailer']['encrypt'] = $sarr[($k +1)][1];\n\t\t\t\t} elseif (($v[0] == '/') AND ($v[1] == 'ID') AND (isset($sarr[($k +1)]))) {\n\t\t\t\t\t$xref['trailer']['id'] = array();\n\t\t\t\t\t$xref['trailer']['id'][0] = $sarr[($k +1)][1][0][1];\n\t\t\t\t\t$xref['trailer']['id'][1] = $sarr[($k +1)][1][1][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// decode data\n\t\tif ($valid_crs AND isset($xrefcrs[1][3][0])) {\n\t\t\t// number of bytes in a row\n\t\t\t$rowlen = ($columns + 1);\n\t\t\t// convert the stream into an array of integers\n\t\t\t$sdata = unpack('C*', $xrefcrs[1][3][0]);\n\t\t\t// split the rows\n\t\t\t$sdata = array_chunk($sdata, $rowlen);\n\t\t\t// initialize decoded array\n\t\t\t$ddata = array();\n\t\t\t// initialize first row with zeros\n\t\t\t$prev_row = array_fill (0, $rowlen, 0);\n\t\t\t// for each row apply PNG unpredictor\n\t\t\tforeach ($sdata as $k => $row) {\n\t\t\t\t// initialize new row\n\t\t\t\t$ddata[$k] = array();\n\t\t\t\t// get PNG predictor value\n\t\t\t\t$predictor = (10 + $row[0]);\n\t\t\t\t// for each byte on the row\n\t\t\t\tfor ($i=1; $i<=$columns; ++$i) {\n\t\t\t\t\t// new index\n\t\t\t\t\t$j = ($i - 1);\n\t\t\t\t\t$row_up = $prev_row[$j];\n\t\t\t\t\tif ($i == 1) {\n\t\t\t\t\t\t$row_left = 0;\n\t\t\t\t\t\t$row_upleft = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$row_left = $row[($i - 1)];\n\t\t\t\t\t\t$row_upleft = $prev_row[($j - 1)];\n\t\t\t\t\t}\n\t\t\t\t\tswitch ($predictor) {\n\t\t\t\t\t\tcase 10: { // PNG prediction (on encoding, PNG None on all rows)\n\t\t\t\t\t\t\t$ddata[$k][$j] = $row[$i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 11: { // PNG prediction (on encoding, PNG Sub on all rows)\n\t\t\t\t\t\t\t$ddata[$k][$j] = (($row[$i] + $row_left) & 0xff);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 12: { // PNG prediction (on encoding, PNG Up on all rows)\n\t\t\t\t\t\t\t$ddata[$k][$j] = (($row[$i] + $row_up) & 0xff);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 13: { // PNG prediction (on encoding, PNG Average on all rows)\n\t\t\t\t\t\t\t$ddata[$k][$j] = (($row[$i] + (($row_left + $row_up) / 2)) & 0xff);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 14: { // PNG prediction (on encoding, PNG Paeth on all rows)\n\t\t\t\t\t\t\t// initial estimate\n\t\t\t\t\t\t\t$p = ($row_left + $row_up - $row_upleft);\n\t\t\t\t\t\t\t// distances\n\t\t\t\t\t\t\t$pa = abs($p - $row_left);\n\t\t\t\t\t\t\t$pb = abs($p - $row_up);\n\t\t\t\t\t\t\t$pc = abs($p - $row_upleft);\n\t\t\t\t\t\t\t$pmin = min($pa, $pb, $pc);\n\t\t\t\t\t\t\t// return minimum distance\n\t\t\t\t\t\t\tswitch ($pmin) {\n\t\t\t\t\t\t\t\tcase $pa: {\n\t\t\t\t\t\t\t\t\t$ddata[$k][$j] = (($row[$i] + $row_left) & 0xff);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase $pb: {\n\t\t\t\t\t\t\t\t\t$ddata[$k][$j] = (($row[$i] + $row_up) & 0xff);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase $pc: {\n\t\t\t\t\t\t\t\t\t$ddata[$k][$j] = (($row[$i] + $row_upleft) & 0xff);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault: { // PNG prediction (on encoding, PNG optimum)\n\t\t\t\t\t\t\t$this->Error('Unknown PNG predictor');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$prev_row = $ddata[$k];\n\t\t\t} // end for each row\n\t\t\t// complete decoding\n\t\t\t$sdata = array();\n\t\t\t// for every row\n\t\t\tforeach ($ddata as $k => $row) {\n\t\t\t\t// initialize new row\n\t\t\t\t$sdata[$k] = array(0, 0, 0);\n\t\t\t\tif ($wb[0] == 0) {\n\t\t\t\t\t// default type field\n\t\t\t\t\t$sdata[$k][0] = 1;\n\t\t\t\t}\n\t\t\t\t$i = 0; // count bytes in the row\n\t\t\t\t// for every column\n\t\t\t\tfor ($c = 0; $c < 3; ++$c) {\n\t\t\t\t\t// for every byte on the column\n\t\t\t\t\tfor ($b = 0; $b < $wb[$c]; ++$b) {\n\t\t\t\t\t\tif (isset($row[$i])) {\n\t\t\t\t\t\t\t$sdata[$k][$c] += ($row[$i] << (($wb[$c] - 1 - $b) * 8));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++$i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$ddata = array();\n\t\t\t// fill xref\n\t\t\tif (isset($index_first)) {\n\t\t\t\t$obj_num = $index_first;\n\t\t\t} else {\n\t\t\t\t$obj_num = 0;\n\t\t\t}\n\t\t\tforeach ($sdata as $k => $row) {\n\t\t\t\tswitch ($row[0]) {\n\t\t\t\t\tcase 0: { // (f) linked list of free objects\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 1: { // (n) objects that are in use but are not compressed\n\t\t\t\t\t\t// create unique object index: [object number]_[generation number]\n\t\t\t\t\t\t$index = $obj_num.'_'.$row[2];\n\t\t\t\t\t\t// check if object already exist\n\t\t\t\t\t\tif (!isset($xref['xref'][$index])) {\n\t\t\t\t\t\t\t// store object offset position\n\t\t\t\t\t\t\t$xref['xref'][$index] = $row[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 2: { // compressed objects\n\t\t\t\t\t\t// $row[1] = object number of the object stream in which this object is stored\n\t\t\t\t\t\t// $row[2] = index of this object within the object stream\n\t\t\t\t\t\t$index = $row[1].'_0_'.$row[2];\n\t\t\t\t\t\t$xref['xref'][$index] = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: { // null objects\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++$obj_num;\n\t\t\t}\n\t\t} // end decoding data\n\t\tif (isset($prevxref)) {\n\t\t\t// get previous xref\n\t\t\t$xref = $this->getXrefData($prevxref, $xref);\n\t\t}\n\t\treturn $xref;\n\t}\n\n\t/**\n\t * Get object type, raw value and offset to next object\n\t * @param int $offset Object offset.\n\t * @return array containing object type, raw value and offset to next object\n\t * @protected\n\t * @since 1.0.000 (2011-06-20)\n\t */\n\tprotected function getRawObject($offset=0) {\n\t\t$objtype = ''; // object type to be returned\n\t\t$objval = ''; // object value to be returned\n\t\t// skip initial white space chars: \\x00 null (NUL), \\x09 horizontal tab (HT), \\x0A line feed (LF), \\x0C form feed (FF), \\x0D carriage return (CR), \\x20 space (SP)\n\t\t$offset += strspn($this->pdfdata, \"\\x00\\x09\\x0a\\x0c\\x0d\\x20\", $offset);\n\t\t// get first char\n\t\t$char = $this->pdfdata[$offset];\n\t\t// get object type\n\t\tswitch ($char) {\n\t\t\tcase '%': { // \\x25 PERCENT SIGN\n\t\t\t\t// skip comment and search for next token\n\t\t\t\t$next = strcspn($this->pdfdata, \"\\r\\n\", $offset);\n\t\t\t\tif ($next > 0) {\n\t\t\t\t\t$offset += $next;\n\t\t\t\t\treturn $this->getRawObject($offset);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase '/': { // \\x2F SOLIDUS\n\t\t\t\t// name object\n\t\t\t\t$objtype = $char;\n\t\t\t\t++$offset;\n\t\t\t\tif (preg_match('/^([^\\x00\\x09\\x0a\\x0c\\x0d\\x20\\s\\x28\\x29\\x3c\\x3e\\x5b\\x5d\\x7b\\x7d\\x2f\\x25]+)/', substr($this->pdfdata, $offset, 256), $matches) == 1) {\n\t\t\t\t\t$objval = $matches[1]; // unescaped value\n\t\t\t\t\t$offset += strlen($objval);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase '(':   // \\x28 LEFT PARENTHESIS\n\t\t\tcase ')': { // \\x29 RIGHT PARENTHESIS\n\t\t\t\t// literal string object\n\t\t\t\t$objtype = $char;\n\t\t\t\t++$offset;\n\t\t\t\t$strpos = $offset;\n\t\t\t\tif ($char == '(') {\n\t\t\t\t\t$open_bracket = 1;\n\t\t\t\t\twhile ($open_bracket > 0) {\n\t\t\t\t\t\tif (!isset($this->pdfdata[$strpos])) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$ch = $this->pdfdata[$strpos];\n\t\t\t\t\t\tswitch ($ch) {\n\t\t\t\t\t\t\tcase '\\\\': { // REVERSE SOLIDUS (5Ch) (Backslash)\n\t\t\t\t\t\t\t\t// skip next character\n\t\t\t\t\t\t\t\t++$strpos;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase '(': { // LEFT PARENHESIS (28h)\n\t\t\t\t\t\t\t\t++$open_bracket;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase ')': { // RIGHT PARENTHESIS (29h)\n\t\t\t\t\t\t\t\t--$open_bracket;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++$strpos;\n\t\t\t\t\t}\n\t\t\t\t\t$objval = substr($this->pdfdata, $offset, ($strpos - $offset - 1));\n\t\t\t\t\t$offset = $strpos;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase '[':   // \\x5B LEFT SQUARE BRACKET\n\t\t\tcase ']': { // \\x5D RIGHT SQUARE BRACKET\n\t\t\t\t// array object\n\t\t\t\t$objtype = $char;\n\t\t\t\t++$offset;\n\t\t\t\tif ($char == '[') {\n\t\t\t\t\t// get array content\n\t\t\t\t\t$objval = array();\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// get element\n\t\t\t\t\t\t$element = $this->getRawObject($offset);\n\t\t\t\t\t\t$offset = $element[2];\n\t\t\t\t\t\t$objval[] = $element;\n\t\t\t\t\t} while ($element[0] != ']');\n\t\t\t\t\t// remove closing delimiter\n\t\t\t\t\tarray_pop($objval);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase '<':   // \\x3C LESS-THAN SIGN\n\t\t\tcase '>': { // \\x3E GREATER-THAN SIGN\n\t\t\t\tif (isset($this->pdfdata[($offset + 1)]) AND ($this->pdfdata[($offset + 1)] == $char)) {\n\t\t\t\t\t// dictionary object\n\t\t\t\t\t$objtype = $char.$char;\n\t\t\t\t\t$offset += 2;\n\t\t\t\t\tif ($char == '<') {\n\t\t\t\t\t\t// get array content\n\t\t\t\t\t\t$objval = array();\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t// get element\n\t\t\t\t\t\t\t$element = $this->getRawObject($offset);\n\t\t\t\t\t\t\t$offset = $element[2];\n\t\t\t\t\t\t\t$objval[] = $element;\n\t\t\t\t\t\t} while ($element[0] != '>>');\n\t\t\t\t\t\t// remove closing delimiter\n\t\t\t\t\t\tarray_pop($objval);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// hexadecimal string object\n\t\t\t\t\t$objtype = $char;\n\t\t\t\t\t++$offset;\n\t\t\t\t\tif (($char == '<') AND (preg_match('/^([0-9A-Fa-f\\x09\\x0a\\x0c\\x0d\\x20]+)>/iU', substr($this->pdfdata, $offset), $matches) == 1)) {\n\t\t\t\t\t\t// remove white space characters\n\t\t\t\t\t\t$objval = strtr($matches[1], \"\\x09\\x0a\\x0c\\x0d\\x20\", '');\n\t\t\t\t\t\t$offset += strlen($matches[0]);\n\t\t\t\t\t} elseif (($endpos = strpos($this->pdfdata, '>', $offset)) !== FALSE) {\n\t\t\t\t\t\t$offset = $endpos + 1;\n                    }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tif (substr($this->pdfdata, $offset, 6) == 'endobj') {\n\t\t\t\t\t// indirect object\n\t\t\t\t\t$objtype = 'endobj';\n\t\t\t\t\t$offset += 6;\n\t\t\t\t} elseif (substr($this->pdfdata, $offset, 4) == 'null') {\n\t\t\t\t\t// null object\n\t\t\t\t\t$objtype = 'null';\n\t\t\t\t\t$offset += 4;\n\t\t\t\t\t$objval = 'null';\n\t\t\t\t} elseif (substr($this->pdfdata, $offset, 4) == 'true') {\n\t\t\t\t\t// boolean true object\n\t\t\t\t\t$objtype = 'boolean';\n\t\t\t\t\t$offset += 4;\n\t\t\t\t\t$objval = 'true';\n\t\t\t\t} elseif (substr($this->pdfdata, $offset, 5) == 'false') {\n\t\t\t\t\t// boolean false object\n\t\t\t\t\t$objtype = 'boolean';\n\t\t\t\t\t$offset += 5;\n\t\t\t\t\t$objval = 'false';\n\t\t\t\t} elseif (substr($this->pdfdata, $offset, 6) == 'stream') {\n\t\t\t\t\t// start stream object\n\t\t\t\t\t$objtype = 'stream';\n\t\t\t\t\t$offset += 6;\n\t\t\t\t\tif (preg_match('/^([\\r]?[\\n])/isU', substr($this->pdfdata, $offset), $matches) == 1) {\n\t\t\t\t\t\t$offset += strlen($matches[0]);\n\t\t\t\t\t\tif (preg_match('/(endstream)[\\x09\\x0a\\x0c\\x0d\\x20]/isU', substr($this->pdfdata, $offset), $matches, PREG_OFFSET_CAPTURE) == 1) {\n\t\t\t\t\t\t\t$objval = substr($this->pdfdata, $offset, $matches[0][1]);\n\t\t\t\t\t\t\t$offset += $matches[1][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($this->pdfdata, $offset, 9) == 'endstream') {\n\t\t\t\t\t// end stream object\n\t\t\t\t\t$objtype = 'endstream';\n\t\t\t\t\t$offset += 9;\n\t\t\t\t} elseif (preg_match('/^([0-9]+)[\\s]+([0-9]+)[\\s]+R/iU', substr($this->pdfdata, $offset, 33), $matches) == 1) {\n\t\t\t\t\t// indirect object reference\n\t\t\t\t\t$objtype = 'objref';\n\t\t\t\t\t$offset += strlen($matches[0]);\n\t\t\t\t\t$objval = intval($matches[1]).'_'.intval($matches[2]);\n\t\t\t\t} elseif (preg_match('/^([0-9]+)[\\s]+([0-9]+)[\\s]+obj/iU', substr($this->pdfdata, $offset, 33), $matches) == 1) {\n\t\t\t\t\t// object start\n\t\t\t\t\t$objtype = 'obj';\n\t\t\t\t\t$objval = intval($matches[1]).'_'.intval($matches[2]);\n\t\t\t\t\t$offset += strlen ($matches[0]);\n\t\t\t\t} elseif (($numlen = strspn($this->pdfdata, '+-.0123456789', $offset)) > 0) {\n\t\t\t\t\t// numeric object\n\t\t\t\t\t$objtype = 'numeric';\n\t\t\t\t\t$objval = substr($this->pdfdata, $offset, $numlen);\n\t\t\t\t\t$offset += $numlen;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn array($objtype, $objval, $offset);\n\t}\n\n\t/**\n\t * Get content of indirect object.\n\t * @param string $obj_ref Object number and generation number separated by underscore character.\n\t * @param int $offset Object offset.\n\t * @param boolean $decoding If true decode streams.\n\t * @return array containing object data.\n\t * @protected\n\t * @since 1.0.000 (2011-05-24)\n\t */\n\tprotected function getIndirectObject($obj_ref, $offset=0, $decoding=true) {\n\t\t$obj = explode('_', $obj_ref);\n\t\tif (($obj === false) OR (count($obj) != 2)) {\n\t\t\t$this->Error('Invalid object reference: '.$obj);\n\t\t\treturn;\n\t\t}\n\t\t$objref = $obj[0].' '.$obj[1].' obj';\n\t\t// ignore leading zeros\n\t\t$offset += strspn($this->pdfdata, '0', $offset);\n\t\tif (strpos($this->pdfdata, $objref, $offset) != $offset) {\n\t\t\t// an indirect reference to an undefined object shall be considered a reference to the null object\n\t\t\treturn array('null', 'null', $offset);\n\t\t}\n\t\t// starting position of object content\n\t\t$offset += strlen($objref);\n\t\t// get array of object content\n\t\t$objdata = array();\n\t\t$i = 0; // object main index\n\t\tdo {\n\t\t\t$oldoffset = $offset;\n                        // get element\n\t\t\t$element = $this->getRawObject($offset);\n\t\t\t$offset = $element[2];\n\t\t\t// decode stream using stream's dictionary information\n\t\t\tif ($decoding AND ($element[0] == 'stream') AND (isset($objdata[($i - 1)][0])) AND ($objdata[($i - 1)][0] == '<<')) {\n\t\t\t\t$element[3] = $this->decodeStream($objdata[($i - 1)][1], $element[1]);\n\t\t\t}\n\t\t\t$objdata[$i] = $element;\n\t\t\t++$i;\n\t\t} while (($element[0] != 'endobj') AND ($offset != $oldoffset));\n\t\t// remove closing delimiter\n\t\tarray_pop($objdata);\n\t\t// return raw object content\n\t\treturn $objdata;\n\t}\n\n\t/**\n\t * Get the content of object, resolving indect object reference if necessary.\n\t * @param string $obj Object value.\n\t * @return array containing object data.\n\t * @protected\n\t * @since 1.0.000 (2011-06-26)\n\t */\n\tprotected function getObjectVal($obj) {\n\t\tif ($obj[0] == 'objref') {\n\t\t\t// reference to indirect object\n\t\t\tif (isset($this->objects[$obj[1]])) {\n\t\t\t\t// this object has been already parsed\n\t\t\t\treturn $this->objects[$obj[1]];\n\t\t\t} elseif (isset($this->xref[$obj[1]])) {\n\t\t\t\t// parse new object\n\t\t\t\t$this->objects[$obj[1]] = $this->getIndirectObject($obj[1], $this->xref[$obj[1]], false);\n\t\t\t\treturn $this->objects[$obj[1]];\n\t\t\t}\n\t\t}\n\t\treturn $obj;\n\t}\n\n\t/**\n\t * Decode the specified stream.\n\t * @param array $sdic Stream's dictionary array.\n\t * @param string $stream Stream to decode.\n\t * @return array containing decoded stream data and remaining filters.\n\t * @protected\n\t * @since 1.0.000 (2011-06-22)\n\t */\n\tprotected function decodeStream($sdic, $stream) {\n\t\t// get stream length and filters\n\t\t$slength = strlen($stream);\n\t\tif ($slength <= 0) {\n\t\t\treturn array('', array());\n\t\t}\n\t\t$filters = array();\n\t\tforeach ($sdic as $k => $v) {\n\t\t\tif ($v[0] == '/') {\n\t\t\t\tif (($v[1] == 'Length') AND (isset($sdic[($k + 1)])) AND ($sdic[($k + 1)][0] == 'numeric')) {\n\t\t\t\t\t// get declared stream length\n\t\t\t\t\t$declength = intval($sdic[($k + 1)][1]);\n\t\t\t\t\tif ($declength < $slength) {\n\t\t\t\t\t\t$stream = substr($stream, 0, $declength);\n\t\t\t\t\t\t$slength = $declength;\n\t\t\t\t\t}\n\t\t\t\t} elseif (($v[1] == 'Filter') AND (isset($sdic[($k + 1)]))) {\n\t\t\t\t\t// resolve indirect object\n\t\t\t\t\t$objval = $this->getObjectVal($sdic[($k + 1)]);\n\t\t\t\t\tif ($objval[0] == '/') {\n\t\t\t\t\t\t// single filter\n\t\t\t\t\t\t$filters[] = $objval[1];\n\t\t\t\t\t} elseif ($objval[0] == '[') {\n\t\t\t\t\t\t// array of filters\n\t\t\t\t\t\tforeach ($objval[1] as $flt) {\n\t\t\t\t\t\t\tif ($flt[0] == '/') {\n\t\t\t\t\t\t\t\t$filters[] = $flt[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// decode the stream\n\t\t$remaining_filters = array();\n\t\tforeach ($filters as $filter) {\n\t\t\tif (in_array($filter, TCPDF_FILTERS::getAvailableFilters())) {\n\t\t\t\ttry {\n\t\t\t\t\t$stream = TCPDF_FILTERS::decodeFilter($filter, $stream);\n\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\t$emsg = $e->getMessage();\n\t\t\t\t\tif ((($emsg[0] == '~') AND !$this->cfg['ignore_missing_filter_decoders'])\n\t\t\t\t\t\tOR (($emsg[0] != '~') AND !$this->cfg['ignore_filter_decoding_errors'])) {\n\t\t\t\t\t\t$this->Error($e->getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// add missing filter to array\n\t\t\t\t$remaining_filters[] = $filter;\n\t\t\t}\n\t\t}\n\t\treturn array($stream, $remaining_filters);\n\t}\n\n\t/**\n\t * Throw an exception or print an error message and die if the K_TCPDF_PARSER_THROW_EXCEPTION_ERROR constant is set to true.\n\t * @param string $msg The error message\n\t * @public\n\t * @since 1.0.000 (2011-05-23)\n\t */\n\tpublic function Error($msg) {\n\t\tif ($this->cfg['die_for_errors']) {\n\t\t\tdie('<strong>TCPDF_PARSER ERROR: </strong>'.$msg);\n\t\t} else {\n\t\t\tthrow new Exception('TCPDF_PARSER ERROR: '.$msg);\n\t\t}\n\t}\n\n} // END OF TCPDF_PARSER CLASS\n\n//============================================================+\n// END OF FILE\n//============================================================+\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}