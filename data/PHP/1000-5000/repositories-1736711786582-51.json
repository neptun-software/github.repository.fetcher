{
  "metadata": {
    "timestamp": 1736711786582,
    "page": 51,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "amphp/amp",
      "stars": 4268,
      "defaultBranch": "3.x",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1279296875,
          "content": "root = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\nindent_style = space\ncharset = utf-8\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.25390625,
          "content": "# Ignore all dotted files as mostly they are configs for other tools\n/.* export-ignore\ndocs export-ignore\nexamples export-ignore\ntest export-ignore\nphpunit.xml.dist export-ignore\nREADME.md export-ignore\nCONTRIBUTING.md export-ignore\nCHANGELOG.md export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.09375,
          "content": "build\ncomposer.lock\ncoverage\nphpunit.xml\nvendor\nhumbug.json\n.php_cs.cache\n.phpunit.result.cache\n"
        },
        {
          "name": ".php-cs-fixer.dist.php",
          "type": "blob",
          "size": 0.1845703125,
          "content": "<?php\n\n$config = new Amp\\CodeStyle\\Config;\n$config->getFinder()\n    ->in(__DIR__ . '/src')\n    ->in(__DIR__ . '/test');\n\n$config->setCacheFile(__DIR__ . '/.php_cs.cache');\n\nreturn $config;\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 3.5576171875,
          "content": "## 3.x\n\n### 3.0.0\n\n#### Event Loop\n\nAmp no longer ships its own event loop. It's now based on [Revolt](https://revolt.run). `Revolt\\EventLoop` is quite similar to Amp's previous `Amp\\Loop`. A very important difference is using `float $seconds` instead of `int $milliseconds` for timers though!\n\n#### Promises\n\n`Future` is a replacement for the previous `Promise`.\nThere's no need for callbacks or `yield` anymore!\nIts `await()` method is based on fibers and replaces generator based coroutines / `Amp\\Promise\\wait()`.\n\n- Renamed `Amp\\Deferred` to `Amp\\DeferredFuture`.\n- Removed `Amp\\Promise\\wait()`: Use `Amp\\Future::await()` instead, which can be called in any (nested) context unlike before.\n- Removed `Amp\\call()`: Remove the passed closure boilerplate and all `yield` keywords, interruption is handled via fibers now instead of generator coroutines.\n- Removed `Amp\\asyncCall()`: Replace invocations with `Amp\\async()`, which starts a new fiber instead of using generators.\n- Removed `Amp\\coroutine()`: There's no direct replacement.\n- Removed `Amp\\asyncCoroutine()`: There's no direct replacement.\n- Removed `Amp\\Promise\\timeout()`: `Future::await()` accepts an optional `Cancellation`, which can be used as a replacement.\n- Removed `Amp\\Promise\\rethrow()`: Unhandled errors are now automatically thrown into the event loop, so there's no need for that function anymore.\n- Unhandled errors can be ignored using `Future::ignore()` if needed, but should usually be handled in some way.\n- Removed `Amp\\Promise\\wrap()`: Use `Future::finally()` instead.\n- Renamed `Amp\\getCurrentTime()` to `Amp\\now()` returning the time in seconds instead of milliseconds.\n- Changed `Amp\\delay()` to accept the delay in seconds now instead of milliseconds.\n- Added `Amp\\weakClosure()` to allow a class to hold a self-referencing Closure without creating a circular reference that prevents automatic garbage collection.\n- Added `Amp\\trapSignal()` to await one or multiple signals.\n\n#### Promise Combinators\n\nPromise combinators have been renamed:\n\n- `Amp\\Promise\\race()` has been renamed to `Amp\\Future\\awaitFirst()`\n- `Amp\\Promise\\first()` has been renamed to `Amp\\Future\\awaitAny()`\n- `Amp\\Promise\\some()` has been renamed to `Amp\\Future\\awaitAnyN()`\n- `Amp\\Promise\\any()` has been renamed to `Amp\\Future\\awaitAll()`\n- `Amp\\Promise\\all()` has been renamed to `Amp\\Future\\await()`\n\n#### CancellationToken\n\n- `CancellationToken` has been renamed to `Cancellation`.\n- `CancellationTokenSource` has been renamed to `DeferredCancellation`.\n- `NullCancellationToken` has been renamed to `NullCancellation`.\n- `TimeoutCancellationToken` has been renamed to `TimeoutCancellation`.\n- `CombinedCancellationToken` has been renamed to `CompositeCancellation`.\n- `SignalCancellation` has been added.\n\n#### Iterators\n\nIterators have been removed from `amphp/amp` as normal PHP iterators can be used with fibers now and there's no need for a separate API.\nHowever, there's still some need for _concurrent_ iterators, which is covered by the new [`amphp/pipeline`](https://github.com/amphp/pipeline) library now.\n\n#### Closable\n\n`Amp\\Closable` has been added as a new basic interface for closable resources such as streams or sockets.\n\n#### Strict Types\n\nStrict types now declared in all library files.\nThis will affect callbacks invoked within this library's code which use scalar types as parameters.\nFunctions used with `Amp\\async()` are the most likely to be affected by this change â€” these functions will now be invoked within a strict-types context.\n\n## 2.x\n\nUnder maintenance, see corresponding branch.\n\n## 1.x\n\nNo longer maintained.\n\n## 0.x\n\nNo longer maintained.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.0576171875,
          "content": "Please follow our [rules](https://amphp.org/contributing).\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1884765625,
          "content": "\nThe MIT License (MIT)\n\nCopyright (c) 2015-2022 amphp (Daniel Lowrey, Aaron Piotrowski, Niklas Keller, Bob Weinand, and contributors)\nCopyright (c) 2016 PHP Asynchronous Interoperability Group\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.947265625,
          "content": "# amphp/amp\n\nAMPHP is a collection of event-driven libraries for PHP designed with fibers and concurrency in mind.\n`amphp/amp` specifically provides futures and cancellations as fundamental primitives for asynchronous programming.\nWe're now using [Revolt](https://revolt.run/) instead of shipping an event loop implementation with `amphp/amp`.\n\nAmp makes heavy use of fibers shipped with PHP 8.1 to write asynchronous code just like synchronous, blocking code. In\ncontrast to earlier versions, there's no need for generator based coroutines or callbacks. Similar to threads, each\nfiber has its own call stack, but fibers are scheduled cooperatively by the event loop. Use `Amp\\async()` to run things\nconcurrently.\n\n## Motivation\n\nTraditionally, PHP follows a sequential execution model.\nThe PHP engine executes one line after the other in sequential order.\nOften, however, programs consist of multiple independent sub-programs which can be executed concurrently.\n\nIf you query a database, you send the query and wait for the response from the database server in a blocking manner.\nOnce you have the response, you can start doing the next thing.\nInstead of sitting there and doing nothing while waiting, we could already send the next database query, or do an HTTP call to an API.\nLet's make use of the time we usually spend on waiting for I/O!\n\n[Revolt](https://revolt.run/) allows such concurrent I/O operations. We keep the cognitive load low by avoiding callbacks.\nOur APIs can be used like any other library, except that things _also_ work concurrently, because we use non-blocking I/O under the hood.\nRun things concurrently using `Amp\\async()` and await the result using `Future::await()` where and when you need it!\n\nThere have been various techniques for implementing concurrency in PHP over the years, e.g. callbacks and generators shipped in PHP 5.\nThese approaches suffered from the [\"What color is your function\"](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/) problem, which we solved by shipping Fibers with PHP 8.1.\nThey allow for concurrency with multiple independent call stacks.\n\nFibers are cooperatively scheduled by the [event-loop](https://revolt.run), which is why they're also called coroutines.\nIt's important to understand that only one coroutine is running at any given time, all other coroutines are suspended in the meantime.\n\nYou can compare coroutines to a computer running multiple programs using a single CPU core.\nEach program gets a timeslot to execute.\nCoroutines, however, are not preemptive.\nThey don't get their fixed timeslot.\nThey have to voluntarily give up control to the event loop.\n\nAny blocking I/O function blocks the entire process while waiting for I/O.\nYou'll want to avoid them.\nIf you haven't read the installation guide, have a look at the [Hello World example](https://v3.amphp.org/installation#hello-world) that demonstrates the effect of blocking functions.\nThe libraries provided by AMPHP avoid blocking for I/O.\n\n## Installation\n\nThis package can be installed as a [Composer](https://getcomposer.org/) dependency.\n\n```bash\ncomposer require amphp/amp\n```\n\nIf you use this library, it's very likely you want to schedule events using [Revolt](https://revolt.run),\nwhich you should require separately, even if it's automatically installed as a dependency.\n\n```bash\ncomposer require revolt/event-loop\n```\n\nThese packages provide the basic building blocks for asynchronous / concurrent applications in PHP. We offer a lot of packages\nbuilding on top of these, e.g.\n\n- [`amphp/byte-stream`](https://github.com/amphp/byte-stream) providing a stream abstraction\n- [`amphp/socket`](https://github.com/amphp/socket) providing a socket layer for UDP and TCP including TLS\n- [`amphp/parallel`](https://github.com/amphp/parallel) providing parallel processing to utilize multiple CPU cores and\n  offload blocking operations\n- [`amphp/http-client`](https://github.com/amphp/http-client) providing an HTTP/1.1 and HTTP/2 client\n- [`amphp/http-server`](https://github.com/amphp/http-server) providing an HTTP/1.1 and HTTP/2 application server\n- [`amphp/mysql`](https://github.com/amphp/mysql) and [`amphp/postgres`](https://github.com/amphp/postgres) for\n  non-blocking database access\n- and [many more packages](https://github.com/amphp?type=source)\n\n## Requirements\n\nThis package requires PHP 8.1 or later. No extensions required!\n\n[Extensions](https://revolt.run/extensions) are only needed if your app necessitates a high numbers of concurrent socket\nconnections, usually this limit is configured up to 1024 file descriptors.\n\n## Usage\n\n### Coroutines\n\nCoroutines are interruptible functions. In PHP, they can be implemented using [fibers](https://wiki.php.net/rfc/fibers).\n\n> **Note**\n> Previous versions of Amp used generators for a similar purpose, but fibers can be interrupted anywhere in the call stack making previous boilerplate like `Amp\\call()` unnecessary.\n\nAt any given time, only one fiber is running. When a coroutine suspends, execution of the coroutine is temporarily\ninterrupted, allowing other tasks to be run. Execution is resumed once a timer expires, stream operations are possible,\nor any awaited `Future` completes.\n\nLow-level suspension and resumption of coroutines is handled by Revolt's [`Suspension`](https://revolt.run/fibers) API.\n\n```php\n<?php\n\nrequire __DIR__ . '/vendor/autoload.php';\n\nuse Revolt\\EventLoop;\n\n$suspension = EventLoop::getSuspension();\n\nEventLoop::delay(5, function () use ($suspension): void {\n    print '++ Executing callback created by EventLoop::delay()' . PHP_EOL;\n\n    $suspension->resume(null);\n});\n\nprint '++ Suspending to event loop...' . PHP_EOL;\n\n$suspension->suspend();\n\nprint '++ Script end' . PHP_EOL;\n```\n\nCallbacks registered on the Revolt event-loop are automatically run as coroutines and it's safe to suspend them. Apart from the event-loop API, `Amp\\async()` can be used to start an independent call stack.\n\n```php\n<?php\n\nuse function Amp\\delay;\n\nrequire __DIR__ . '/vendor/autoload.php';\n\nAmp\\async(function () {\n    print '++ Executing callback passed to async()' . PHP_EOL;\n\n    delay(3);\n\n    print '++ Finished callback passed to async()' . PHP_EOL;\n});\n\nprint '++ Suspending to event loop...' . PHP_EOL;\ndelay(5);\n\nprint '++ Script end' . PHP_EOL;\n```\n\n### Future\n\nA `Future` is an object representing the eventual result of an asynchronous operation. There are three states:\n\n- **Completed successfully**: The future has been completed successfully.\n- **Errored**: The future failed with an exception.\n- **Pending**: The future is still pending.\n\nA successfully completed future is analog to a return value, while an errored future is analog to throwing an exception.\n\nOne way to approach asynchronous APIs is using callbacks that are passed when the operation is started and called once it completes:\n\n```php\ndoSomething(function ($error, $value) {\n    if ($error) {\n        /* ... */\n    } else {\n        /* ... */\n    }\n});\n```\n\nThe callback approach has several drawbacks.\n\n- Passing callbacks and doing further actions in them that depend on the result of the first action gets messy really\n  quickly.\n- An explicit callback is required as input parameter to the function, and the return value is simply unused. There's no\n  way to use this API without involving a callback.\n\nThat's where futures come into play.\nThey're placeholders for the result that are returned like any other return value.\nThe caller has the choice of awaiting the result using `Future::await()` or registering one or several callbacks.\n\n```php\ntry {\n    $value = doSomething()->await();\n} catch (...) {\n    /* ... */\n}\n```\n\n#### Combinators\n\nIn concurrent applications, there will be multiple futures, where you might want to await them all or just the first one.\n\n##### await\n\n`Amp\\Future\\await($iterable, $cancellation)` awaits all `Future` objects of an `iterable`. If one of the `Future` instances errors, the operation\nwill be aborted with that exception. Otherwise, the result is an array matching keys from the input `iterable` to their\ncompletion values.\n\nThe `await()` combinator is extremely powerful because it allows you to concurrently execute many asynchronous operations\nat the same time. Let's look at an example using [`amphp/http-client`](https://github.com/amphp/http-client) to\nretrieve multiple HTTP resources concurrently:\n\n```php\n<?php\n\nuse Amp\\Future;\nuse Amp\\Http\\Client\\HttpClientBuilder;\nuse Amp\\Http\\Client\\Request;\n\n$httpClient = HttpClientBuilder::buildDefault();\n$uris = [\n    \"google\" => \"https://www.google.com\",\n    \"news\"   => \"https://news.google.com\",\n    \"bing\"   => \"https://www.bing.com\",\n    \"yahoo\"  => \"https://www.yahoo.com\",\n];\n\ntry {\n    $responses = Future\\await(array_map(function ($uri) use ($httpClient) {\n        return Amp\\async(fn () => $httpClient->request(new Request($uri, 'HEAD')));\n    }, $uris));\n\n    foreach ($responses as $key => $response) {\n        printf(\n            \"%s | HTTP/%s %d %s\\n\",\n            $key,\n            $response->getProtocolVersion(),\n            $response->getStatus(),\n            $response->getReason()\n        );\n    }\n} catch (Exception $e) {\n    // If any one of the requests fails the combo will fail\n    echo $e->getMessage(), \"\\n\";\n}\n```\n\n##### awaitAnyN\n\n`Amp\\Future\\awaitAnyN($count, $iterable, $cancellation)` is the same as `await()` except that it tolerates individual errors. A result is returned once\nexactly `$count` instances in the `iterable` complete successfully. The return value is an array of values. The\nindividual keys in the component array are preserved from the `iterable` passed to the function for evaluation.\n\n##### awaitAll\n\n`Amp\\Future\\awaitAll($iterable, $cancellation)` awaits all futures and returns their results as `[$errors, $values]` array.\n\n##### awaitFirst\n\n`Amp\\Future\\awaitFirst($iterable, $cancellation)` unwraps the first completed `Future`, whether successfully completed or errored.\n\n##### awaitAny\n\n`Amp\\Future\\awaitAny($iterable, $cancellation)` unwraps the first successfully completed `Future`.\n\n#### Future Creation\n\nFutures can be created in several ways. Most code will use [`Amp\\async()`](#Coroutines) which takes a function and runs it as coroutine in another Fiber.\n\nSometimes an interface mandates a `Future` to be returned, but results are immediately available, e.g. because they're cached.\nIn these cases `Future::complete(mixed)` and `Future::error(Throwable)` can be used to construct an immediately completed `Future`.\n\n##### DeferredFuture\n\n> **Note**\n> The `DeferredFuture` API described below is an advanced API that many applications probably don't need.\n> Use [`Amp\\async()`](#Coroutines) or [combinators](#Combinators) instead where possible.\n\n`Amp\\DeferredFuture` is responsible for completing a pending `Future`.\nYou create a `Amp\\DeferredFuture` and uses its `getFuture` method to return an `Amp\\Future` to the caller.\nOnce result is ready, you complete the `Future` held by the caller using `complete` or `error` on the linked `DeferredFuture`.\n\n```php\nfinal class DeferredFuture\n{\n    public function getFuture(): Future;\n    public function complete(mixed $value = null);\n    public function error(Throwable $throwable);\n}\n```\n\n> **Warning**\n> If you're passing `DeferredFuture` objects around, you're probably doing something wrong.\n> They're supposed to be internal state of your operation.\n\n> **Warning**\n> You can't complete a future with another future; Use `Future::await()` before calling `DeferredFuture::complete()` in such cases.\n\nHere's a simple example of an asynchronous value producer `asyncMultiply()` creating a `DeferredFuture` and returning the\nassociated `Future` to its caller.\n\n```php\n<?php // Example async producer using DeferredFuture\n\nuse Revolt\\EventLoop;\n\nfunction asyncMultiply(int $x, int $y): Future\n{\n    $deferred = new Amp\\DeferredFuture;\n\n    // Complete the async result one second from now\n    EventLoop::delay(1, function () use ($deferred, $x, $y) {\n        $deferred->complete($x * $y);\n    });\n\n    return $deferred->getFuture();\n}\n\n$future = asyncMultiply(6, 7);\n$result = $future->await();\n\nvar_dump($result); // int(42)\n```\n\n### Cancellation\n\nEvery operation that supports cancellation accepts an instance of `Cancellation` as argument.\nCancellations are objects that allow registering handlers to subscribe to cancellation requests.\nThese objects are passed down to sub-operations or have to be handled by the operation itself.\n\n`$cancellation->throwIfRequested()` can be used to fail the current operation with a `CancelledException` once cancellation has been requested.\nWhile `throwIfRequested()` works well, some operations might want to subscribe with a callback instead. They can do so\nusing `Cancellation::subscribe()` to subscribe any cancellation requests that might happen.\n\nThe caller creates a `Cancellation` by using one of the implementations below.\n\n> **Note**\n> Cancellations are advisory only. A DNS resolver might ignore cancellation requests after the query has been sent as the response has to be processed anyway and can still be cached. An HTTP client might continue a nearly finished HTTP request to reuse the connection, but might abort a chunked encoding response as it cannot know whether continuing is actually cheaper than aborting.\n\n#### TimeoutCancellation\n\nA `TimeoutCancellations` automatically cancels itself after the specified number of seconds.\n\n```php\nrequest(\"...\", new Amp\\TimeoutCancellation(30));\n```\n\n#### SignalCancellation\n\nA `SignalCancellation` automatically cancels itself after a specified signal has been received by the current process.\n\n```php\nrequest(\"...\", new Amp\\SignalCancellation(SIGINT));\n```\n\n#### DeferredCancellation\n\nA `DeferredCancellation` allows manual cancellation with the call of a method.\nThis is the preferred way if you need to register some custom callback somewhere instead of shipping your own implementation.\nOnly the caller has access to the `DeferredCancellation` and can cancel the operation using `DeferredCancellation::cancel()`.\n\n```php\n$deferredCancellation = new Amp\\DeferredCancellation();\n\n// Register some custom callback somewhere\nonSomeEvent(fn () => $deferredCancellation->cancel());\n\nrequest(\"...\", $deferredCancellation->getCancellation());\n```\n\n#### NullCancellation\n\nA `NullCancellation` will never be cancelled.\nCancellation is often optional, which is usually implemented by making the parameter nullable.\nTo avoid guards like `if ($cancellation)`, a `NullCancellation` can be used instead.\n\n```php\n$cancellation ??= new NullCancellationToken();\n```\n\n#### CompositeCancellation\n\nA `CompositeCancellation` combines multiple independent cancellation objects. If any of these cancellations is cancelled, the `CompositeCancellation` itself will be cancelled.\n\n## Versioning\n\n`amphp/amp` follows the [semver](http://semver.org/) semantic versioning specification like all other `amphp` packages.\n\n## Compatible Packages\n\nCompatible packages should use the [`amphp`](https://github.com/search?utf8=%E2%9C%93&q=topic%3Aamphp) topic on GitHub.\n\n## Security\n\nIf you discover any security related issues, please email [`me@kelunik.com`](mailto:me@kelunik.com) instead of using the\nissue tracker.\n\n## License\n\nThe MIT License (MIT). Please see [`LICENSE`](./LICENSE) for more information.\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.546875,
          "content": "{\n    \"name\": \"amphp/amp\",\n    \"homepage\": \"https://amphp.org/amp\",\n    \"description\": \"A non-blocking concurrency framework for PHP applications.\",\n    \"keywords\": [\n        \"async\",\n        \"asynchronous\",\n        \"concurrency\",\n        \"promise\",\n        \"awaitable\",\n        \"future\",\n        \"non-blocking\",\n        \"event\",\n        \"event-loop\"\n    ],\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Aaron Piotrowski\",\n            \"email\": \"aaron@trowski.com\"\n        },\n        {\n            \"name\": \"Bob Weinand\",\n            \"email\": \"bobwei9@hotmail.com\"\n        },\n        {\n            \"name\": \"Niklas Keller\",\n            \"email\": \"me@kelunik.com\"\n        },\n        {\n            \"name\": \"Daniel Lowrey\",\n            \"email\": \"rdlowrey@php.net\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.1\",\n        \"revolt/event-loop\": \"^1 || ^0.2\"\n    },\n    \"require-dev\": {\n        \"amphp/php-cs-fixer-config\": \"^2\",\n        \"phpunit/phpunit\": \"^9\",\n        \"psalm/phar\": \"5.23.1\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"Amp\\\\\": \"src\"\n        },\n        \"files\": [\n            \"src/functions.php\",\n            \"src/Future/functions.php\",\n            \"src/Internal/functions.php\"\n        ]\n    },\n    \"autoload-dev\": {\n        \"psr-4\": {\n            \"Amp\\\\\": \"test\"\n        }\n    },\n    \"support\": {\n        \"issues\": \"https://github.com/amphp/amp/issues\"\n    },\n    \"scripts\": {\n        \"test\": \"@php -dzend.assertions=1 -dassert.exception=1 ./vendor/bin/phpunit\",\n        \"code-style\": \"@php ./vendor/bin/php-cs-fixer fix\"\n    }\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.6005859375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/9.3/phpunit.xsd\" bootstrap=\"vendor/autoload.php\"\n         colors=\"true\">\n    <coverage>\n        <include>\n            <directory suffix=\".php\">src</directory>\n        </include>\n    </coverage>\n    <testsuites>\n        <testsuite name=\"Main\">\n            <directory>test</directory>\n        </testsuite>\n        <testsuite name=\"PHPT tests\">\n            <directory suffix=\".phpt\">test</directory>\n        </testsuite>\n    </testsuites>\n</phpunit>\n"
        },
        {
          "name": "psalm.xml",
          "type": "blob",
          "size": 1.5107421875,
          "content": "<?xml version=\"1.0\"?>\n<psalm\n        errorLevel=\"2\"\n        phpVersion=\"8.1\"\n        resolveFromConfigFile=\"true\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns=\"https://getpsalm.org/schema/config\"\n        xsi:schemaLocation=\"https://getpsalm.org/schema/config vendor/vimeo/psalm/config.xsd\"\n>\n    <projectFiles>\n        <directory name=\"src\" />\n    </projectFiles>\n\n    <issueHandlers>\n        <StringIncrement>\n            <errorLevel type=\"suppress\">\n                <directory name=\"src\" />\n            </errorLevel>\n        </StringIncrement>\n\n        <RedundantConditionGivenDocblockType>\n            <errorLevel type=\"suppress\">\n                <directory name=\"src\" />\n            </errorLevel>\n        </RedundantConditionGivenDocblockType>\n\n        <DocblockTypeContradiction>\n            <errorLevel type=\"suppress\">\n                <directory name=\"src\" />\n            </errorLevel>\n        </DocblockTypeContradiction>\n\n        <MissingClosureParamType>\n            <errorLevel type=\"suppress\">\n                <directory name=\"src\" />\n            </errorLevel>\n        </MissingClosureParamType>\n\n        <MissingClosureReturnType>\n            <errorLevel type=\"suppress\">\n                <directory name=\"src\" />\n            </errorLevel>\n        </MissingClosureReturnType>\n\n        <UnsupportedPropertyReferenceUsage>\n            <errorLevel type=\"suppress\">\n                <directory name=\"src\" />\n            </errorLevel>\n        </UnsupportedPropertyReferenceUsage>\n    </issueHandlers>\n</psalm>\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}