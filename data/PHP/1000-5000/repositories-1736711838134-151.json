{
  "metadata": {
    "timestamp": 1736711838134,
    "page": 151,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/polyfill-intl-idn",
      "stars": 3340,
      "defaultBranch": "1.x",
      "files": [
        {
          "name": "Idn.php",
          "type": "blob",
          "size": 30.6787109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com> and Trevor Rowbotham <trevor.rowbotham@pm.me>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Intl\\Idn;\n\nuse Symfony\\Polyfill\\Intl\\Idn\\Resources\\unidata\\DisallowedRanges;\nuse Symfony\\Polyfill\\Intl\\Idn\\Resources\\unidata\\Regex;\n\n/**\n * @see https://www.unicode.org/reports/tr46/\n *\n * @internal\n */\nfinal class Idn\n{\n    public const ERROR_EMPTY_LABEL = 1;\n    public const ERROR_LABEL_TOO_LONG = 2;\n    public const ERROR_DOMAIN_NAME_TOO_LONG = 4;\n    public const ERROR_LEADING_HYPHEN = 8;\n    public const ERROR_TRAILING_HYPHEN = 0x10;\n    public const ERROR_HYPHEN_3_4 = 0x20;\n    public const ERROR_LEADING_COMBINING_MARK = 0x40;\n    public const ERROR_DISALLOWED = 0x80;\n    public const ERROR_PUNYCODE = 0x100;\n    public const ERROR_LABEL_HAS_DOT = 0x200;\n    public const ERROR_INVALID_ACE_LABEL = 0x400;\n    public const ERROR_BIDI = 0x800;\n    public const ERROR_CONTEXTJ = 0x1000;\n    public const ERROR_CONTEXTO_PUNCTUATION = 0x2000;\n    public const ERROR_CONTEXTO_DIGITS = 0x4000;\n\n    public const INTL_IDNA_VARIANT_2003 = 0;\n    public const INTL_IDNA_VARIANT_UTS46 = 1;\n\n    public const IDNA_DEFAULT = 0;\n    public const IDNA_ALLOW_UNASSIGNED = 1;\n    public const IDNA_USE_STD3_RULES = 2;\n    public const IDNA_CHECK_BIDI = 4;\n    public const IDNA_CHECK_CONTEXTJ = 8;\n    public const IDNA_NONTRANSITIONAL_TO_ASCII = 16;\n    public const IDNA_NONTRANSITIONAL_TO_UNICODE = 32;\n\n    public const MAX_DOMAIN_SIZE = 253;\n    public const MAX_LABEL_SIZE = 63;\n\n    public const BASE = 36;\n    public const TMIN = 1;\n    public const TMAX = 26;\n    public const SKEW = 38;\n    public const DAMP = 700;\n    public const INITIAL_BIAS = 72;\n    public const INITIAL_N = 128;\n    public const DELIMITER = '-';\n    public const MAX_INT = 2147483647;\n\n    /**\n     * Contains the numeric value of a basic code point (for use in representing integers) in the\n     * range 0 to BASE-1, or -1 if b is does not represent a value.\n     *\n     * @var array<int, int>\n     */\n    private static $basicToDigit = [\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1, -1,\n\n        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,\n\n        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,\n\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    ];\n\n    /**\n     * @var array<int, int>\n     */\n    private static $virama;\n\n    /**\n     * @var array<int, string>\n     */\n    private static $mapped;\n\n    /**\n     * @var array<int, bool>\n     */\n    private static $ignored;\n\n    /**\n     * @var array<int, string>\n     */\n    private static $deviation;\n\n    /**\n     * @var array<int, bool>\n     */\n    private static $disallowed;\n\n    /**\n     * @var array<int, string>\n     */\n    private static $disallowed_STD3_mapped;\n\n    /**\n     * @var array<int, bool>\n     */\n    private static $disallowed_STD3_valid;\n\n    /**\n     * @var bool\n     */\n    private static $mappingTableLoaded = false;\n\n    /**\n     * @see https://www.unicode.org/reports/tr46/#ToASCII\n     *\n     * @param string $domainName\n     * @param int    $options\n     * @param int    $variant\n     * @param array  $idna_info\n     *\n     * @return string|false\n     */\n    public static function idn_to_ascii($domainName, $options = self::IDNA_DEFAULT, $variant = self::INTL_IDNA_VARIANT_UTS46, &$idna_info = [])\n    {\n        if (\\PHP_VERSION_ID > 80400 && '' === $domainName) {\n            throw new \\ValueError('idn_to_ascii(): Argument #1 ($domain) cannot be empty');\n        }\n\n        if (self::INTL_IDNA_VARIANT_2003 === $variant) {\n            @trigger_error('idn_to_ascii(): INTL_IDNA_VARIANT_2003 is deprecated', \\E_USER_DEPRECATED);\n        }\n\n        $options = [\n            'CheckHyphens' => true,\n            'CheckBidi' => self::INTL_IDNA_VARIANT_2003 === $variant || 0 !== ($options & self::IDNA_CHECK_BIDI),\n            'CheckJoiners' => self::INTL_IDNA_VARIANT_UTS46 === $variant && 0 !== ($options & self::IDNA_CHECK_CONTEXTJ),\n            'UseSTD3ASCIIRules' => 0 !== ($options & self::IDNA_USE_STD3_RULES),\n            'Transitional_Processing' => self::INTL_IDNA_VARIANT_2003 === $variant || 0 === ($options & self::IDNA_NONTRANSITIONAL_TO_ASCII),\n            'VerifyDnsLength' => true,\n        ];\n        $info = new Info();\n        $labels = self::process((string) $domainName, $options, $info);\n\n        foreach ($labels as $i => $label) {\n            // Only convert labels to punycode that contain non-ASCII code points\n            if (1 === preg_match('/[^\\x00-\\x7F]/', $label)) {\n                try {\n                    $label = 'xn--'.self::punycodeEncode($label);\n                } catch (\\Exception $e) {\n                    $info->errors |= self::ERROR_PUNYCODE;\n                }\n\n                $labels[$i] = $label;\n            }\n        }\n\n        if ($options['VerifyDnsLength']) {\n            self::validateDomainAndLabelLength($labels, $info);\n        }\n\n        $idna_info = [\n            'result' => implode('.', $labels),\n            'isTransitionalDifferent' => $info->transitionalDifferent,\n            'errors' => $info->errors,\n        ];\n\n        return 0 === $info->errors ? $idna_info['result'] : false;\n    }\n\n    /**\n     * @see https://www.unicode.org/reports/tr46/#ToUnicode\n     *\n     * @param string $domainName\n     * @param int    $options\n     * @param int    $variant\n     * @param array  $idna_info\n     *\n     * @return string|false\n     */\n    public static function idn_to_utf8($domainName, $options = self::IDNA_DEFAULT, $variant = self::INTL_IDNA_VARIANT_UTS46, &$idna_info = [])\n    {\n        if (\\PHP_VERSION_ID > 80400 && '' === $domainName) {\n            throw new \\ValueError('idn_to_utf8(): Argument #1 ($domain) cannot be empty');\n        }\n\n        if (self::INTL_IDNA_VARIANT_2003 === $variant) {\n            @trigger_error('idn_to_utf8(): INTL_IDNA_VARIANT_2003 is deprecated', \\E_USER_DEPRECATED);\n        }\n\n        $info = new Info();\n        $labels = self::process((string) $domainName, [\n            'CheckHyphens' => true,\n            'CheckBidi' => self::INTL_IDNA_VARIANT_2003 === $variant || 0 !== ($options & self::IDNA_CHECK_BIDI),\n            'CheckJoiners' => self::INTL_IDNA_VARIANT_UTS46 === $variant && 0 !== ($options & self::IDNA_CHECK_CONTEXTJ),\n            'UseSTD3ASCIIRules' => 0 !== ($options & self::IDNA_USE_STD3_RULES),\n            'Transitional_Processing' => self::INTL_IDNA_VARIANT_2003 === $variant || 0 === ($options & self::IDNA_NONTRANSITIONAL_TO_UNICODE),\n        ], $info);\n        $idna_info = [\n            'result' => implode('.', $labels),\n            'isTransitionalDifferent' => $info->transitionalDifferent,\n            'errors' => $info->errors,\n        ];\n\n        return 0 === $info->errors ? $idna_info['result'] : false;\n    }\n\n    /**\n     * @param string $label\n     *\n     * @return bool\n     */\n    private static function isValidContextJ(array $codePoints, $label)\n    {\n        if (!isset(self::$virama)) {\n            self::$virama = require __DIR__.\\DIRECTORY_SEPARATOR.'Resources'.\\DIRECTORY_SEPARATOR.'unidata'.\\DIRECTORY_SEPARATOR.'virama.php';\n        }\n\n        $offset = 0;\n\n        foreach ($codePoints as $i => $codePoint) {\n            if (0x200C !== $codePoint && 0x200D !== $codePoint) {\n                continue;\n            }\n\n            if (!isset($codePoints[$i - 1])) {\n                return false;\n            }\n\n            // If Canonical_Combining_Class(Before(cp)) .eq. Virama Then True;\n            if (isset(self::$virama[$codePoints[$i - 1]])) {\n                continue;\n            }\n\n            // If RegExpMatch((Joining_Type:{L,D})(Joining_Type:T)*\\u200C(Joining_Type:T)*(Joining_Type:{R,D})) Then\n            // True;\n            // Generated RegExp = ([Joining_Type:{L,D}][Joining_Type:T]*\\u200C[Joining_Type:T]*)[Joining_Type:{R,D}]\n            if (0x200C === $codePoint && 1 === preg_match(Regex::ZWNJ, $label, $matches, \\PREG_OFFSET_CAPTURE, $offset)) {\n                $offset += \\strlen($matches[1][0]);\n\n                continue;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @see https://www.unicode.org/reports/tr46/#ProcessingStepMap\n     *\n     * @param string              $input\n     * @param array<string, bool> $options\n     *\n     * @return string\n     */\n    private static function mapCodePoints($input, array $options, Info $info)\n    {\n        $str = '';\n        $useSTD3ASCIIRules = $options['UseSTD3ASCIIRules'];\n        $transitional = $options['Transitional_Processing'];\n\n        foreach (self::utf8Decode($input) as $codePoint) {\n            $data = self::lookupCodePointStatus($codePoint, $useSTD3ASCIIRules);\n\n            switch ($data['status']) {\n                case 'disallowed':\n                case 'valid':\n                    $str .= mb_chr($codePoint, 'utf-8');\n\n                    break;\n\n                case 'ignored':\n                    // Do nothing.\n                    break;\n\n                case 'mapped':\n                    $str .= $transitional && 0x1E9E === $codePoint ? 'ss' : $data['mapping'];\n\n                    break;\n\n                case 'deviation':\n                    $info->transitionalDifferent = true;\n                    $str .= ($transitional ? $data['mapping'] : mb_chr($codePoint, 'utf-8'));\n\n                    break;\n            }\n        }\n\n        return $str;\n    }\n\n    /**\n     * @see https://www.unicode.org/reports/tr46/#Processing\n     *\n     * @param string              $domain\n     * @param array<string, bool> $options\n     *\n     * @return array<int, string>\n     */\n    private static function process($domain, array $options, Info $info)\n    {\n        // If VerifyDnsLength is not set, we are doing ToUnicode otherwise we are doing ToASCII and\n        // we need to respect the VerifyDnsLength option.\n        $checkForEmptyLabels = !isset($options['VerifyDnsLength']) || $options['VerifyDnsLength'];\n\n        if ($checkForEmptyLabels && '' === $domain) {\n            $info->errors |= self::ERROR_EMPTY_LABEL;\n\n            return [$domain];\n        }\n\n        // Step 1. Map each code point in the domain name string\n        $domain = self::mapCodePoints($domain, $options, $info);\n\n        // Step 2. Normalize the domain name string to Unicode Normalization Form C.\n        if (!\\Normalizer::isNormalized($domain, \\Normalizer::FORM_C)) {\n            $domain = \\Normalizer::normalize($domain, \\Normalizer::FORM_C);\n        }\n\n        // Step 3. Break the string into labels at U+002E (.) FULL STOP.\n        $labels = explode('.', $domain);\n        $lastLabelIndex = \\count($labels) - 1;\n\n        // Step 4. Convert and validate each label in the domain name string.\n        foreach ($labels as $i => $label) {\n            $validationOptions = $options;\n\n            if ('xn--' === substr($label, 0, 4)) {\n                // Step 4.1. If the label contains any non-ASCII code point (i.e., a code point greater than U+007F),\n                // record that there was an error, and continue with the next label.\n                if (preg_match('/[^\\x00-\\x7F]/', $label)) {\n                    $info->errors |= self::ERROR_PUNYCODE;\n\n                    continue;\n                }\n\n                // Step 4.2. Attempt to convert the rest of the label to Unicode according to Punycode [RFC3492]. If\n                // that conversion fails, record that there was an error, and continue\n                // with the next label. Otherwise replace the original label in the string by the results of the\n                // conversion.\n                try {\n                    $label = self::punycodeDecode(substr($label, 4));\n                } catch (\\Exception $e) {\n                    $info->errors |= self::ERROR_PUNYCODE;\n\n                    continue;\n                }\n\n                $validationOptions['Transitional_Processing'] = false;\n                $labels[$i] = $label;\n            }\n\n            self::validateLabel($label, $info, $validationOptions, $i > 0 && $i === $lastLabelIndex);\n        }\n\n        if ($info->bidiDomain && !$info->validBidiDomain) {\n            $info->errors |= self::ERROR_BIDI;\n        }\n\n        // Any input domain name string that does not record an error has been successfully\n        // processed according to this specification. Conversely, if an input domain_name string\n        // causes an error, then the processing of the input domain_name string fails. Determining\n        // what to do with error input is up to the caller, and not in the scope of this document.\n        return $labels;\n    }\n\n    /**\n     * @see https://tools.ietf.org/html/rfc5893#section-2\n     *\n     * @param string $label\n     */\n    private static function validateBidiLabel($label, Info $info)\n    {\n        if (1 === preg_match(Regex::RTL_LABEL, $label)) {\n            $info->bidiDomain = true;\n\n            // Step 1. The first character must be a character with Bidi property L, R, or AL.\n            // If it has the R or AL property, it is an RTL label\n            if (1 !== preg_match(Regex::BIDI_STEP_1_RTL, $label)) {\n                $info->validBidiDomain = false;\n\n                return;\n            }\n\n            // Step 2. In an RTL label, only characters with the Bidi properties R, AL, AN, EN, ES,\n            // CS, ET, ON, BN, or NSM are allowed.\n            if (1 === preg_match(Regex::BIDI_STEP_2, $label)) {\n                $info->validBidiDomain = false;\n\n                return;\n            }\n\n            // Step 3. In an RTL label, the end of the label must be a character with Bidi property\n            // R, AL, EN, or AN, followed by zero or more characters with Bidi property NSM.\n            if (1 !== preg_match(Regex::BIDI_STEP_3, $label)) {\n                $info->validBidiDomain = false;\n\n                return;\n            }\n\n            // Step 4. In an RTL label, if an EN is present, no AN may be present, and vice versa.\n            if (1 === preg_match(Regex::BIDI_STEP_4_AN, $label) && 1 === preg_match(Regex::BIDI_STEP_4_EN, $label)) {\n                $info->validBidiDomain = false;\n\n                return;\n            }\n\n            return;\n        }\n\n        // We are a LTR label\n        // Step 1. The first character must be a character with Bidi property L, R, or AL.\n        // If it has the L property, it is an LTR label.\n        if (1 !== preg_match(Regex::BIDI_STEP_1_LTR, $label)) {\n            $info->validBidiDomain = false;\n\n            return;\n        }\n\n        // Step 5. In an LTR label, only characters with the Bidi properties L, EN,\n        // ES, CS, ET, ON, BN, or NSM are allowed.\n        if (1 === preg_match(Regex::BIDI_STEP_5, $label)) {\n            $info->validBidiDomain = false;\n\n            return;\n        }\n\n        // Step 6.In an LTR label, the end of the label must be a character with Bidi property L or\n        // EN, followed by zero or more characters with Bidi property NSM.\n        if (1 !== preg_match(Regex::BIDI_STEP_6, $label)) {\n            $info->validBidiDomain = false;\n\n            return;\n        }\n    }\n\n    /**\n     * @param array<int, string> $labels\n     */\n    private static function validateDomainAndLabelLength(array $labels, Info $info)\n    {\n        $maxDomainSize = self::MAX_DOMAIN_SIZE;\n        $length = \\count($labels);\n\n        // Number of \".\" delimiters.\n        $domainLength = $length - 1;\n\n        // If the last label is empty and it is not the first label, then it is the root label.\n        // Increase the max size by 1, making it 254, to account for the root label's \".\"\n        // delimiter. This also means we don't need to check the last label's length for being too\n        // long.\n        if ($length > 1 && '' === $labels[$length - 1]) {\n            ++$maxDomainSize;\n            --$length;\n        }\n\n        for ($i = 0; $i < $length; ++$i) {\n            $bytes = \\strlen($labels[$i]);\n            $domainLength += $bytes;\n\n            if ($bytes > self::MAX_LABEL_SIZE) {\n                $info->errors |= self::ERROR_LABEL_TOO_LONG;\n            }\n        }\n\n        if ($domainLength > $maxDomainSize) {\n            $info->errors |= self::ERROR_DOMAIN_NAME_TOO_LONG;\n        }\n    }\n\n    /**\n     * @see https://www.unicode.org/reports/tr46/#Validity_Criteria\n     *\n     * @param string              $label\n     * @param array<string, bool> $options\n     * @param bool                $canBeEmpty\n     */\n    private static function validateLabel($label, Info $info, array $options, $canBeEmpty)\n    {\n        if ('' === $label) {\n            if (!$canBeEmpty && (!isset($options['VerifyDnsLength']) || $options['VerifyDnsLength'])) {\n                $info->errors |= self::ERROR_EMPTY_LABEL;\n            }\n\n            return;\n        }\n\n        // Step 1. The label must be in Unicode Normalization Form C.\n        if (!\\Normalizer::isNormalized($label, \\Normalizer::FORM_C)) {\n            $info->errors |= self::ERROR_INVALID_ACE_LABEL;\n        }\n\n        $codePoints = self::utf8Decode($label);\n\n        if ($options['CheckHyphens']) {\n            // Step 2. If CheckHyphens, the label must not contain a U+002D HYPHEN-MINUS character\n            // in both the thrid and fourth positions.\n            if (isset($codePoints[2], $codePoints[3]) && 0x002D === $codePoints[2] && 0x002D === $codePoints[3]) {\n                $info->errors |= self::ERROR_HYPHEN_3_4;\n            }\n\n            // Step 3. If CheckHyphens, the label must neither begin nor end with a U+002D\n            // HYPHEN-MINUS character.\n            if ('-' === substr($label, 0, 1)) {\n                $info->errors |= self::ERROR_LEADING_HYPHEN;\n            }\n\n            if ('-' === substr($label, -1, 1)) {\n                $info->errors |= self::ERROR_TRAILING_HYPHEN;\n            }\n        } elseif ('xn--' === substr($label, 0, 4)) {\n            $info->errors |= self::ERROR_PUNYCODE;\n        }\n\n        // Step 4. The label must not contain a U+002E (.) FULL STOP.\n        if (false !== strpos($label, '.')) {\n            $info->errors |= self::ERROR_LABEL_HAS_DOT;\n        }\n\n        // Step 5. The label must not begin with a combining mark, that is: General_Category=Mark.\n        if (1 === preg_match(Regex::COMBINING_MARK, $label)) {\n            $info->errors |= self::ERROR_LEADING_COMBINING_MARK;\n        }\n\n        // Step 6. Each code point in the label must only have certain status values according to\n        // Section 5, IDNA Mapping Table:\n        $transitional = $options['Transitional_Processing'];\n        $useSTD3ASCIIRules = $options['UseSTD3ASCIIRules'];\n\n        foreach ($codePoints as $codePoint) {\n            $data = self::lookupCodePointStatus($codePoint, $useSTD3ASCIIRules);\n            $status = $data['status'];\n\n            if ('valid' === $status || (!$transitional && 'deviation' === $status)) {\n                continue;\n            }\n\n            $info->errors |= self::ERROR_DISALLOWED;\n\n            break;\n        }\n\n        // Step 7. If CheckJoiners, the label must satisify the ContextJ rules from Appendix A, in\n        // The Unicode Code Points and Internationalized Domain Names for Applications (IDNA)\n        // [IDNA2008].\n        if ($options['CheckJoiners'] && !self::isValidContextJ($codePoints, $label)) {\n            $info->errors |= self::ERROR_CONTEXTJ;\n        }\n\n        // Step 8. If CheckBidi, and if the domain name is a  Bidi domain name, then the label must\n        // satisfy all six of the numbered conditions in [IDNA2008] RFC 5893, Section 2.\n        if ($options['CheckBidi'] && (!$info->bidiDomain || $info->validBidiDomain)) {\n            self::validateBidiLabel($label, $info);\n        }\n    }\n\n    /**\n     * @see https://tools.ietf.org/html/rfc3492#section-6.2\n     *\n     * @param string $input\n     *\n     * @return string\n     */\n    private static function punycodeDecode($input)\n    {\n        $n = self::INITIAL_N;\n        $out = 0;\n        $i = 0;\n        $bias = self::INITIAL_BIAS;\n        $lastDelimIndex = strrpos($input, self::DELIMITER);\n        $b = false === $lastDelimIndex ? 0 : $lastDelimIndex;\n        $inputLength = \\strlen($input);\n        $output = [];\n        $bytes = array_map('ord', str_split($input));\n\n        for ($j = 0; $j < $b; ++$j) {\n            if ($bytes[$j] > 0x7F) {\n                throw new \\Exception('Invalid input');\n            }\n\n            $output[$out++] = $input[$j];\n        }\n\n        if ($b > 0) {\n            ++$b;\n        }\n\n        for ($in = $b; $in < $inputLength; ++$out) {\n            $oldi = $i;\n            $w = 1;\n\n            for ($k = self::BASE; /* no condition */; $k += self::BASE) {\n                if ($in >= $inputLength) {\n                    throw new \\Exception('Invalid input');\n                }\n\n                $digit = self::$basicToDigit[$bytes[$in++] & 0xFF];\n\n                if ($digit < 0) {\n                    throw new \\Exception('Invalid input');\n                }\n\n                if ($digit > intdiv(self::MAX_INT - $i, $w)) {\n                    throw new \\Exception('Integer overflow');\n                }\n\n                $i += $digit * $w;\n\n                if ($k <= $bias) {\n                    $t = self::TMIN;\n                } elseif ($k >= $bias + self::TMAX) {\n                    $t = self::TMAX;\n                } else {\n                    $t = $k - $bias;\n                }\n\n                if ($digit < $t) {\n                    break;\n                }\n\n                $baseMinusT = self::BASE - $t;\n\n                if ($w > intdiv(self::MAX_INT, $baseMinusT)) {\n                    throw new \\Exception('Integer overflow');\n                }\n\n                $w *= $baseMinusT;\n            }\n\n            $outPlusOne = $out + 1;\n            $bias = self::adaptBias($i - $oldi, $outPlusOne, 0 === $oldi);\n\n            if (intdiv($i, $outPlusOne) > self::MAX_INT - $n) {\n                throw new \\Exception('Integer overflow');\n            }\n\n            $n += intdiv($i, $outPlusOne);\n            $i %= $outPlusOne;\n            array_splice($output, $i++, 0, [mb_chr($n, 'utf-8')]);\n        }\n\n        return implode('', $output);\n    }\n\n    /**\n     * @see https://tools.ietf.org/html/rfc3492#section-6.3\n     *\n     * @param string $input\n     *\n     * @return string\n     */\n    private static function punycodeEncode($input)\n    {\n        $n = self::INITIAL_N;\n        $delta = 0;\n        $out = 0;\n        $bias = self::INITIAL_BIAS;\n        $inputLength = 0;\n        $output = '';\n        $iter = self::utf8Decode($input);\n\n        foreach ($iter as $codePoint) {\n            ++$inputLength;\n\n            if ($codePoint < 0x80) {\n                $output .= \\chr($codePoint);\n                ++$out;\n            }\n        }\n\n        $h = $out;\n        $b = $out;\n\n        if ($b > 0) {\n            $output .= self::DELIMITER;\n            ++$out;\n        }\n\n        while ($h < $inputLength) {\n            $m = self::MAX_INT;\n\n            foreach ($iter as $codePoint) {\n                if ($codePoint >= $n && $codePoint < $m) {\n                    $m = $codePoint;\n                }\n            }\n\n            if ($m - $n > intdiv(self::MAX_INT - $delta, $h + 1)) {\n                throw new \\Exception('Integer overflow');\n            }\n\n            $delta += ($m - $n) * ($h + 1);\n            $n = $m;\n\n            foreach ($iter as $codePoint) {\n                if ($codePoint < $n && 0 === ++$delta) {\n                    throw new \\Exception('Integer overflow');\n                }\n\n                if ($codePoint === $n) {\n                    $q = $delta;\n\n                    for ($k = self::BASE; /* no condition */; $k += self::BASE) {\n                        if ($k <= $bias) {\n                            $t = self::TMIN;\n                        } elseif ($k >= $bias + self::TMAX) {\n                            $t = self::TMAX;\n                        } else {\n                            $t = $k - $bias;\n                        }\n\n                        if ($q < $t) {\n                            break;\n                        }\n\n                        $qMinusT = $q - $t;\n                        $baseMinusT = self::BASE - $t;\n                        $output .= self::encodeDigit($t + $qMinusT % $baseMinusT, false);\n                        ++$out;\n                        $q = intdiv($qMinusT, $baseMinusT);\n                    }\n\n                    $output .= self::encodeDigit($q, false);\n                    ++$out;\n                    $bias = self::adaptBias($delta, $h + 1, $h === $b);\n                    $delta = 0;\n                    ++$h;\n                }\n            }\n\n            ++$delta;\n            ++$n;\n        }\n\n        return $output;\n    }\n\n    /**\n     * @see https://tools.ietf.org/html/rfc3492#section-6.1\n     *\n     * @param int  $delta\n     * @param int  $numPoints\n     * @param bool $firstTime\n     *\n     * @return int\n     */\n    private static function adaptBias($delta, $numPoints, $firstTime)\n    {\n        // xxx >> 1 is a faster way of doing intdiv(xxx, 2)\n        $delta = $firstTime ? intdiv($delta, self::DAMP) : $delta >> 1;\n        $delta += intdiv($delta, $numPoints);\n        $k = 0;\n\n        while ($delta > ((self::BASE - self::TMIN) * self::TMAX) >> 1) {\n            $delta = intdiv($delta, self::BASE - self::TMIN);\n            $k += self::BASE;\n        }\n\n        return $k + intdiv((self::BASE - self::TMIN + 1) * $delta, $delta + self::SKEW);\n    }\n\n    /**\n     * @param int  $d\n     * @param bool $flag\n     *\n     * @return string\n     */\n    private static function encodeDigit($d, $flag)\n    {\n        return \\chr($d + 22 + 75 * ($d < 26 ? 1 : 0) - (($flag ? 1 : 0) << 5));\n    }\n\n    /**\n     * Takes a UTF-8 encoded string and converts it into a series of integer code points. Any\n     * invalid byte sequences will be replaced by a U+FFFD replacement code point.\n     *\n     * @see https://encoding.spec.whatwg.org/#utf-8-decoder\n     *\n     * @param string $input\n     *\n     * @return array<int, int>\n     */\n    private static function utf8Decode($input)\n    {\n        $bytesSeen = 0;\n        $bytesNeeded = 0;\n        $lowerBoundary = 0x80;\n        $upperBoundary = 0xBF;\n        $codePoint = 0;\n        $codePoints = [];\n        $length = \\strlen($input);\n\n        for ($i = 0; $i < $length; ++$i) {\n            $byte = \\ord($input[$i]);\n\n            if (0 === $bytesNeeded) {\n                if ($byte >= 0x00 && $byte <= 0x7F) {\n                    $codePoints[] = $byte;\n\n                    continue;\n                }\n\n                if ($byte >= 0xC2 && $byte <= 0xDF) {\n                    $bytesNeeded = 1;\n                    $codePoint = $byte & 0x1F;\n                } elseif ($byte >= 0xE0 && $byte <= 0xEF) {\n                    if (0xE0 === $byte) {\n                        $lowerBoundary = 0xA0;\n                    } elseif (0xED === $byte) {\n                        $upperBoundary = 0x9F;\n                    }\n\n                    $bytesNeeded = 2;\n                    $codePoint = $byte & 0xF;\n                } elseif ($byte >= 0xF0 && $byte <= 0xF4) {\n                    if (0xF0 === $byte) {\n                        $lowerBoundary = 0x90;\n                    } elseif (0xF4 === $byte) {\n                        $upperBoundary = 0x8F;\n                    }\n\n                    $bytesNeeded = 3;\n                    $codePoint = $byte & 0x7;\n                } else {\n                    $codePoints[] = 0xFFFD;\n                }\n\n                continue;\n            }\n\n            if ($byte < $lowerBoundary || $byte > $upperBoundary) {\n                $codePoint = 0;\n                $bytesNeeded = 0;\n                $bytesSeen = 0;\n                $lowerBoundary = 0x80;\n                $upperBoundary = 0xBF;\n                --$i;\n                $codePoints[] = 0xFFFD;\n\n                continue;\n            }\n\n            $lowerBoundary = 0x80;\n            $upperBoundary = 0xBF;\n            $codePoint = ($codePoint << 6) | ($byte & 0x3F);\n\n            if (++$bytesSeen !== $bytesNeeded) {\n                continue;\n            }\n\n            $codePoints[] = $codePoint;\n            $codePoint = 0;\n            $bytesNeeded = 0;\n            $bytesSeen = 0;\n        }\n\n        // String unexpectedly ended, so append a U+FFFD code point.\n        if (0 !== $bytesNeeded) {\n            $codePoints[] = 0xFFFD;\n        }\n\n        return $codePoints;\n    }\n\n    /**\n     * @param int  $codePoint\n     * @param bool $useSTD3ASCIIRules\n     *\n     * @return array{status: string, mapping?: string}\n     */\n    private static function lookupCodePointStatus($codePoint, $useSTD3ASCIIRules)\n    {\n        if (!self::$mappingTableLoaded) {\n            self::$mappingTableLoaded = true;\n            self::$mapped = require __DIR__.'/Resources/unidata/mapped.php';\n            self::$ignored = require __DIR__.'/Resources/unidata/ignored.php';\n            self::$deviation = require __DIR__.'/Resources/unidata/deviation.php';\n            self::$disallowed = require __DIR__.'/Resources/unidata/disallowed.php';\n            self::$disallowed_STD3_mapped = require __DIR__.'/Resources/unidata/disallowed_STD3_mapped.php';\n            self::$disallowed_STD3_valid = require __DIR__.'/Resources/unidata/disallowed_STD3_valid.php';\n        }\n\n        if (isset(self::$mapped[$codePoint])) {\n            return ['status' => 'mapped', 'mapping' => self::$mapped[$codePoint]];\n        }\n\n        if (isset(self::$ignored[$codePoint])) {\n            return ['status' => 'ignored'];\n        }\n\n        if (isset(self::$deviation[$codePoint])) {\n            return ['status' => 'deviation', 'mapping' => self::$deviation[$codePoint]];\n        }\n\n        if (isset(self::$disallowed[$codePoint]) || DisallowedRanges::inRange($codePoint)) {\n            return ['status' => 'disallowed'];\n        }\n\n        $isDisallowedMapped = isset(self::$disallowed_STD3_mapped[$codePoint]);\n\n        if ($isDisallowedMapped || isset(self::$disallowed_STD3_valid[$codePoint])) {\n            $status = 'disallowed';\n\n            if (!$useSTD3ASCIIRules) {\n                $status = $isDisallowedMapped ? 'mapped' : 'valid';\n            }\n\n            if ($isDisallowedMapped) {\n                return ['status' => $status, 'mapping' => self::$disallowed_STD3_mapped[$codePoint]];\n            }\n\n            return ['status' => $status];\n        }\n\n        return ['status' => 'valid'];\n    }\n}\n"
        },
        {
          "name": "Info.php",
          "type": "blob",
          "size": 0.4814453125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com> and Trevor Rowbotham <trevor.rowbotham@pm.me>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Intl\\Idn;\n\n/**\n * @internal\n */\nclass Info\n{\n    public $bidiDomain = false;\n    public $errors = 0;\n    public $validBidiDomain = true;\n    public $transitionalDifferent = false;\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.087890625,
          "content": "Copyright (c) 2018-present Fabien Potencier and Trevor Rowbotham <trevor.rowbotham@pm.me>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.4560546875,
          "content": "Symfony Polyfill / Intl: Idn\n============================\n\nThis component provides [`idn_to_ascii`](https://php.net/idn-to-ascii) and [`idn_to_utf8`](https://php.net/idn-to-utf8) functions to users who run php versions without the [Intl](https://php.net/intl) extension.\n\nMore information can be found in the\n[main Polyfill README](https://github.com/symfony/polyfill/blob/main/README.md).\n\nLicense\n=======\n\nThis library is released under the [MIT license](LICENSE).\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "bootstrap.php",
          "type": "blob",
          "size": 4.5166015625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Intl\\Idn as p;\n\nif (extension_loaded('intl')) {\n    return;\n}\n\nif (\\PHP_VERSION_ID >= 80000) {\n    return require __DIR__.'/bootstrap80.php';\n}\n\nif (!defined('U_IDNA_PROHIBITED_ERROR')) {\n    define('U_IDNA_PROHIBITED_ERROR', 66560);\n}\nif (!defined('U_IDNA_ERROR_START')) {\n    define('U_IDNA_ERROR_START', 66560);\n}\nif (!defined('U_IDNA_UNASSIGNED_ERROR')) {\n    define('U_IDNA_UNASSIGNED_ERROR', 66561);\n}\nif (!defined('U_IDNA_CHECK_BIDI_ERROR')) {\n    define('U_IDNA_CHECK_BIDI_ERROR', 66562);\n}\nif (!defined('U_IDNA_STD3_ASCII_RULES_ERROR')) {\n    define('U_IDNA_STD3_ASCII_RULES_ERROR', 66563);\n}\nif (!defined('U_IDNA_ACE_PREFIX_ERROR')) {\n    define('U_IDNA_ACE_PREFIX_ERROR', 66564);\n}\nif (!defined('U_IDNA_VERIFICATION_ERROR')) {\n    define('U_IDNA_VERIFICATION_ERROR', 66565);\n}\nif (!defined('U_IDNA_LABEL_TOO_LONG_ERROR')) {\n    define('U_IDNA_LABEL_TOO_LONG_ERROR', 66566);\n}\nif (!defined('U_IDNA_ZERO_LENGTH_LABEL_ERROR')) {\n    define('U_IDNA_ZERO_LENGTH_LABEL_ERROR', 66567);\n}\nif (!defined('U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR')) {\n    define('U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR', 66568);\n}\nif (!defined('U_IDNA_ERROR_LIMIT')) {\n    define('U_IDNA_ERROR_LIMIT', 66569);\n}\nif (!defined('U_STRINGPREP_PROHIBITED_ERROR')) {\n    define('U_STRINGPREP_PROHIBITED_ERROR', 66560);\n}\nif (!defined('U_STRINGPREP_UNASSIGNED_ERROR')) {\n    define('U_STRINGPREP_UNASSIGNED_ERROR', 66561);\n}\nif (!defined('U_STRINGPREP_CHECK_BIDI_ERROR')) {\n    define('U_STRINGPREP_CHECK_BIDI_ERROR', 66562);\n}\nif (!defined('IDNA_DEFAULT')) {\n    define('IDNA_DEFAULT', 0);\n}\nif (!defined('IDNA_ALLOW_UNASSIGNED')) {\n    define('IDNA_ALLOW_UNASSIGNED', 1);\n}\nif (!defined('IDNA_USE_STD3_RULES')) {\n    define('IDNA_USE_STD3_RULES', 2);\n}\nif (!defined('IDNA_CHECK_BIDI')) {\n    define('IDNA_CHECK_BIDI', 4);\n}\nif (!defined('IDNA_CHECK_CONTEXTJ')) {\n    define('IDNA_CHECK_CONTEXTJ', 8);\n}\nif (!defined('IDNA_NONTRANSITIONAL_TO_ASCII')) {\n    define('IDNA_NONTRANSITIONAL_TO_ASCII', 16);\n}\nif (!defined('IDNA_NONTRANSITIONAL_TO_UNICODE')) {\n    define('IDNA_NONTRANSITIONAL_TO_UNICODE', 32);\n}\nif (!defined('INTL_IDNA_VARIANT_2003')) {\n    define('INTL_IDNA_VARIANT_2003', 0);\n}\nif (!defined('INTL_IDNA_VARIANT_UTS46')) {\n    define('INTL_IDNA_VARIANT_UTS46', 1);\n}\nif (!defined('IDNA_ERROR_EMPTY_LABEL')) {\n    define('IDNA_ERROR_EMPTY_LABEL', 1);\n}\nif (!defined('IDNA_ERROR_LABEL_TOO_LONG')) {\n    define('IDNA_ERROR_LABEL_TOO_LONG', 2);\n}\nif (!defined('IDNA_ERROR_DOMAIN_NAME_TOO_LONG')) {\n    define('IDNA_ERROR_DOMAIN_NAME_TOO_LONG', 4);\n}\nif (!defined('IDNA_ERROR_LEADING_HYPHEN')) {\n    define('IDNA_ERROR_LEADING_HYPHEN', 8);\n}\nif (!defined('IDNA_ERROR_TRAILING_HYPHEN')) {\n    define('IDNA_ERROR_TRAILING_HYPHEN', 16);\n}\nif (!defined('IDNA_ERROR_HYPHEN_3_4')) {\n    define('IDNA_ERROR_HYPHEN_3_4', 32);\n}\nif (!defined('IDNA_ERROR_LEADING_COMBINING_MARK')) {\n    define('IDNA_ERROR_LEADING_COMBINING_MARK', 64);\n}\nif (!defined('IDNA_ERROR_DISALLOWED')) {\n    define('IDNA_ERROR_DISALLOWED', 128);\n}\nif (!defined('IDNA_ERROR_PUNYCODE')) {\n    define('IDNA_ERROR_PUNYCODE', 256);\n}\nif (!defined('IDNA_ERROR_LABEL_HAS_DOT')) {\n    define('IDNA_ERROR_LABEL_HAS_DOT', 512);\n}\nif (!defined('IDNA_ERROR_INVALID_ACE_LABEL')) {\n    define('IDNA_ERROR_INVALID_ACE_LABEL', 1024);\n}\nif (!defined('IDNA_ERROR_BIDI')) {\n    define('IDNA_ERROR_BIDI', 2048);\n}\nif (!defined('IDNA_ERROR_CONTEXTJ')) {\n    define('IDNA_ERROR_CONTEXTJ', 4096);\n}\n\nif (\\PHP_VERSION_ID < 70400) {\n    if (!function_exists('idn_to_ascii')) {\n        function idn_to_ascii($domain, $flags = 0, $variant = \\INTL_IDNA_VARIANT_2003, &$idna_info = null) { return p\\Idn::idn_to_ascii($domain, $flags, $variant, $idna_info); }\n    }\n    if (!function_exists('idn_to_utf8')) {\n        function idn_to_utf8($domain, $flags = 0, $variant = \\INTL_IDNA_VARIANT_2003, &$idna_info = null) { return p\\Idn::idn_to_utf8($domain, $flags, $variant, $idna_info); }\n    }\n} else {\n    if (!function_exists('idn_to_ascii')) {\n        function idn_to_ascii($domain, $flags = 0, $variant = \\INTL_IDNA_VARIANT_UTS46, &$idna_info = null) { return p\\Idn::idn_to_ascii($domain, $flags, $variant, $idna_info); }\n    }\n    if (!function_exists('idn_to_utf8')) {\n        function idn_to_utf8($domain, $flags = 0, $variant = \\INTL_IDNA_VARIANT_UTS46, &$idna_info = null) { return p\\Idn::idn_to_utf8($domain, $flags, $variant, $idna_info); }\n    }\n}\n"
        },
        {
          "name": "bootstrap80.php",
          "type": "blob",
          "size": 3.923828125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Intl\\Idn as p;\n\nif (!defined('U_IDNA_PROHIBITED_ERROR')) {\n    define('U_IDNA_PROHIBITED_ERROR', 66560);\n}\nif (!defined('U_IDNA_ERROR_START')) {\n    define('U_IDNA_ERROR_START', 66560);\n}\nif (!defined('U_IDNA_UNASSIGNED_ERROR')) {\n    define('U_IDNA_UNASSIGNED_ERROR', 66561);\n}\nif (!defined('U_IDNA_CHECK_BIDI_ERROR')) {\n    define('U_IDNA_CHECK_BIDI_ERROR', 66562);\n}\nif (!defined('U_IDNA_STD3_ASCII_RULES_ERROR')) {\n    define('U_IDNA_STD3_ASCII_RULES_ERROR', 66563);\n}\nif (!defined('U_IDNA_ACE_PREFIX_ERROR')) {\n    define('U_IDNA_ACE_PREFIX_ERROR', 66564);\n}\nif (!defined('U_IDNA_VERIFICATION_ERROR')) {\n    define('U_IDNA_VERIFICATION_ERROR', 66565);\n}\nif (!defined('U_IDNA_LABEL_TOO_LONG_ERROR')) {\n    define('U_IDNA_LABEL_TOO_LONG_ERROR', 66566);\n}\nif (!defined('U_IDNA_ZERO_LENGTH_LABEL_ERROR')) {\n    define('U_IDNA_ZERO_LENGTH_LABEL_ERROR', 66567);\n}\nif (!defined('U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR')) {\n    define('U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR', 66568);\n}\nif (!defined('U_IDNA_ERROR_LIMIT')) {\n    define('U_IDNA_ERROR_LIMIT', 66569);\n}\nif (!defined('U_STRINGPREP_PROHIBITED_ERROR')) {\n    define('U_STRINGPREP_PROHIBITED_ERROR', 66560);\n}\nif (!defined('U_STRINGPREP_UNASSIGNED_ERROR')) {\n    define('U_STRINGPREP_UNASSIGNED_ERROR', 66561);\n}\nif (!defined('U_STRINGPREP_CHECK_BIDI_ERROR')) {\n    define('U_STRINGPREP_CHECK_BIDI_ERROR', 66562);\n}\nif (!defined('IDNA_DEFAULT')) {\n    define('IDNA_DEFAULT', 0);\n}\nif (!defined('IDNA_ALLOW_UNASSIGNED')) {\n    define('IDNA_ALLOW_UNASSIGNED', 1);\n}\nif (!defined('IDNA_USE_STD3_RULES')) {\n    define('IDNA_USE_STD3_RULES', 2);\n}\nif (!defined('IDNA_CHECK_BIDI')) {\n    define('IDNA_CHECK_BIDI', 4);\n}\nif (!defined('IDNA_CHECK_CONTEXTJ')) {\n    define('IDNA_CHECK_CONTEXTJ', 8);\n}\nif (!defined('IDNA_NONTRANSITIONAL_TO_ASCII')) {\n    define('IDNA_NONTRANSITIONAL_TO_ASCII', 16);\n}\nif (!defined('IDNA_NONTRANSITIONAL_TO_UNICODE')) {\n    define('IDNA_NONTRANSITIONAL_TO_UNICODE', 32);\n}\nif (!defined('INTL_IDNA_VARIANT_UTS46')) {\n    define('INTL_IDNA_VARIANT_UTS46', 1);\n}\nif (!defined('IDNA_ERROR_EMPTY_LABEL')) {\n    define('IDNA_ERROR_EMPTY_LABEL', 1);\n}\nif (!defined('IDNA_ERROR_LABEL_TOO_LONG')) {\n    define('IDNA_ERROR_LABEL_TOO_LONG', 2);\n}\nif (!defined('IDNA_ERROR_DOMAIN_NAME_TOO_LONG')) {\n    define('IDNA_ERROR_DOMAIN_NAME_TOO_LONG', 4);\n}\nif (!defined('IDNA_ERROR_LEADING_HYPHEN')) {\n    define('IDNA_ERROR_LEADING_HYPHEN', 8);\n}\nif (!defined('IDNA_ERROR_TRAILING_HYPHEN')) {\n    define('IDNA_ERROR_TRAILING_HYPHEN', 16);\n}\nif (!defined('IDNA_ERROR_HYPHEN_3_4')) {\n    define('IDNA_ERROR_HYPHEN_3_4', 32);\n}\nif (!defined('IDNA_ERROR_LEADING_COMBINING_MARK')) {\n    define('IDNA_ERROR_LEADING_COMBINING_MARK', 64);\n}\nif (!defined('IDNA_ERROR_DISALLOWED')) {\n    define('IDNA_ERROR_DISALLOWED', 128);\n}\nif (!defined('IDNA_ERROR_PUNYCODE')) {\n    define('IDNA_ERROR_PUNYCODE', 256);\n}\nif (!defined('IDNA_ERROR_LABEL_HAS_DOT')) {\n    define('IDNA_ERROR_LABEL_HAS_DOT', 512);\n}\nif (!defined('IDNA_ERROR_INVALID_ACE_LABEL')) {\n    define('IDNA_ERROR_INVALID_ACE_LABEL', 1024);\n}\nif (!defined('IDNA_ERROR_BIDI')) {\n    define('IDNA_ERROR_BIDI', 2048);\n}\nif (!defined('IDNA_ERROR_CONTEXTJ')) {\n    define('IDNA_ERROR_CONTEXTJ', 4096);\n}\n\nif (!function_exists('idn_to_ascii')) {\n    function idn_to_ascii(?string $domain, ?int $flags = IDNA_DEFAULT, ?int $variant = INTL_IDNA_VARIANT_UTS46, &$idna_info = null): string|false { return p\\Idn::idn_to_ascii((string) $domain, (int) $flags, (int) $variant, $idna_info); }\n}\nif (!function_exists('idn_to_utf8')) {\n    function idn_to_utf8(?string $domain, ?int $flags = IDNA_DEFAULT, ?int $variant = INTL_IDNA_VARIANT_UTS46, &$idna_info = null): string|false { return p\\Idn::idn_to_utf8((string) $domain, (int) $flags, (int) $variant, $idna_info); }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.0947265625,
          "content": "{\n    \"name\": \"symfony/polyfill-intl-idn\",\n    \"type\": \"library\",\n    \"description\": \"Symfony polyfill for intl's idn_to_ascii and idn_to_utf8 functions\",\n    \"keywords\": [\"polyfill\", \"shim\", \"compatibility\", \"portable\", \"intl\", \"idn\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Laurent Bassin\",\n            \"email\": \"laurent@bassin.info\"\n        },\n        {\n            \"name\": \"Trevor Rowbotham\",\n            \"email\": \"trevor.rowbotham@pm.me\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=7.2\",\n        \"symfony/polyfill-intl-normalizer\": \"^1.10\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Polyfill\\\\Intl\\\\Idn\\\\\": \"\" },\n        \"files\": [ \"bootstrap.php\" ]\n    },\n    \"suggest\": {\n        \"ext-intl\": \"For best performance\"\n    },\n    \"minimum-stability\": \"dev\",\n    \"extra\": {\n        \"thanks\": {\n            \"name\": \"symfony/polyfill\",\n            \"url\": \"https://github.com/symfony/polyfill\"\n        }\n    }\n}\n"
        }
      ]
    }
  ]
}