{
  "metadata": {
    "timestamp": 1736712070210,
    "page": 621,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "protonemedia/laravel-ffmpeg",
      "stars": 1681,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.3046875,
          "content": "; This file is for unifying the coding style for different editors and IDEs.\n; More information at http://editorconfig.org\n\nroot = true\n\n[*]\ncharset = utf-8\nindent_size = 4\nindent_style = space\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[*.md]\ntrim_trailing_whitespace = false\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.3525390625,
          "content": "# Path-based git attributes\n# https://www.kernel.org/pub/software/scm/git/docs/gitattributes.html\n\n# Ignore all test and documentation with \"export-ignore\".\n/.gitattributes     export-ignore\n/.gitignore         export-ignore\n/.travis.yml        export-ignore\n/phpunit.xml.dist   export-ignore\n/.scrutinizer.yml   export-ignore\n/tests              export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.10546875,
          "content": "build\ncomposer.lock\ndocs\nvendor\n.phpunit.result.cache\nsrc/EncryptedHLSExporter.php\n.DS_Store\nffmpeg-passes*\n"
        },
        {
          "name": ".styleci.yml",
          "type": "blob",
          "size": 0.064453125,
          "content": "preset: laravel\n\ndisabled:\n  - single_class_element_per_statement\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 10.6630859375,
          "content": "# Changelog\n\nAll Notable changes to `pbmedia/laravel-ffmpeg` will be documented in this file\n\n## 8.1.2 - 2022-05-23\n\n-   Don't resolve driver until needed.\n\n## 8.1.1 - 2022-05-13\n\n-   Bugfix for parsing the average frame rate.\n\n## 8.1.0 - 2022-05-12\n\n-   You may now specify a separate temporary disk for processing HLS exports.\n\n## 8.0.2 - 2022-05-12\n\n-   Fix for getting the previous exception while it doesn't exist.\n\n## 8.0.1 - 2022-02-22\n\n-   The configured temporary directory is now passed to the underlying driver.\n\n## 8.0.0 - 2022-02-10\n\nSupport for Laravel 9, dropped support for Laravel 8 and earlier.\n\n### Upgrading to v8\n\n* As Laravel 9 has migrated from [Flysystem 1.x to 3.x](https://laravel.com/docs/9.x/upgrade#flysystem-3), this version is not compatible with Laravel 8 or earlier.\n* If you're using the [Watermark manipulation](#watermark-manipulation) feature, make sure you upgrade [`spatie/image`](https://github.com/spatie/image) to v2.\n* The `set_command_and_error_output_on_exception` configuration key now defaults to `true`, making exceptions more informative. Read more at the [Handling exceptions](#handling-exceptions) section.\n* The `enable_logging` configuration key has been replaced by `log_channel` to choose the log channel used when writing messages to the logs. If you still want to disable logging entirely, you may set the new configuration key to `false`.\n* The *segment length* and *keyframe interval* of [HLS exports](#HLS) should be `2` or more; less is not supported anymore.\n\n## 7.8.1 - 2022-02-10\n\n### Added\n\n-   Support for opening uploaded files\n\n## 7.8.0 - 2022-02-09\n\n### Added\n\n-   Support for the [modernized php-ffmpeg release](https://github.com/PHP-FFMpeg/PHP-FFMpeg/releases/tag/v1.0.0)\n\n## 7.7.3 - 2022-02-07\n\n### Added\n\n-   Abilty to disable the threads filter from the config (thanks @ibrainventures)\n\n## 7.7.2 - 2021-01-12\n\n### Fixed\n\n-   Fix for getting the duration of a file opened with the `openUrl` method.\n\n## 7.7.1 - 2021-01-03\n\n### Fixed\n\n-   Fix for missing `$remaining` and `$rate` values when using the progress handler on exports with multiple inputs/outputs.\n\n## 7.7.0 - 2021-12-31\n\n### Added\n\n-   Added Tile filter and factory\n-   Support for exporting frames using the Tile filter\n-   Bugfix for exporting loops using external disks\n\n## 7.6.0 - 2021-12-20\n\n### Added\n\n-   Support for PHP 8.1\n\n### Removed\n\n-   Support for PHP 7.3\n-   Support for Laravel 6 and 7\n\n## 7.5.12 - 2021-07-05\n\n### Added\n\n-   Fix for passing additional parameters to a format when using HLS exports\n\n## 7.5.11 - 2021-04-25\n\n### Added\n\n-   Added `CopyVideoFormat` format class\n\n## 7.5.10 - 2021-03-31\n\n### Added\n\n-   Add ability to disable -b:v (thanks @marbocub)\n\n## 7.5.9 - 2021-03-19\n\n### Fixed\n\n-   Prevent duplicate encryption key listeners\n\n## 7.5.8 - 2021-03-17\n\n### Fixed\n\n-   Bugfix for creating temporary directories on Windows\n-   Bugfix for HLS exports with custom framerate\n\n## 7.5.7 - 2021-03-08\n\n### Fixed\n\n-   Prevent HLS key rotation on non-rotating exports (thanks @marbocub)\n\n## 7.5.6 - 2021-03-03\n\n### Fixed\n\n-   Bugfix for HLS exports to S3 disks (thanks @chistel)\n-   Prevent duplicate progress handler when using loops\n\n## 7.5.5 - 2021-01-18\n\n### Added\n\n-   Added `beforeSaving` method to add callbacks\n\n## 7.5.4 - 2021-01-07\n\n### Added\n\n-   Added fourth optional argument to the resize method whether or not to force the use of standards ratios\n-   Improved docs\n-   Small refactor\n\n## 7.5.3 - 2021-01-02\n\n### Added\n\n-   Support for custom encryption filename when using non-rotating keys\n\n## 7.5.2 - 2021-01-02\n\n### Added\n\n-   Support for setting a custom path for temporary directories\n-   GitHub Actions now runs on Windows in addition to Ubuntu\n\n### Fixed\n\n-   HLS Encryption I/O improvements\n-   Path normalization on Windows, which solves common problems with HLS and watermarks\n-   Some refactors and documentation improvements\n\n## 7.5.1 - 2020-12-24\n\n### Added\n\n-   Support for codec in HLS playlist\n-   Fixed bitrate bug in HLS playlist\n\n## 7.5.0 - 2020-12-22\n\n### Added\n\n-   Support for PHP 8.0.\n-   Encrypted HLS.\n-   New `getProcessOutput` method to analyze media.\n-   Support for dynamic HLS playlists.\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Support for PHP 7.2\n\n## 7.4.1 - 2020-10-26\n\n### Added\n\n-   Better exceptions\n-   dd() improvements\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n## 7.4.0 - 2020-10-25\n\n### Added\n\n-   Watermark manipulations\n-   Dump and die\n-   Resize filter shortcut\n-   HLS export with multiple filters per format\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n## 7.3.0 - 2020-10-16\n\n### Added\n\n-   Built-in support for watermarks.\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n## 7.2.0 - 2020-09-17\n\n### Added\n\n-   Support for inputs from the web\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n## 7.1.0 - 2020-09-04\n\n### Added\n\n-   Support for Laravel 8.0\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n## 7.0.5 - 2020-07-04\n\n### Added\n\n-   Added `CopyFormat` to export a file without transcoding.\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n## 7.0.4 - 2020-06-03\n\n### Added\n\n-   Added an `each` method to the `MediaOpener`\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n## 7.0.3 - 2020-06-01\n\n### Added\n\n-   Added a `MediaOpenerFactory` to support pre v7.0 facade\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n## 7.0.2 - 2020-06-01\n\n### Added\n\n-   Nothing\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Audio bugfix for HLS exports with filters\n\n### Removed\n\n-   Nothing\n\n\n## 7.0.1 - 2020-05-28\n\n### Added\n\n-   Nothing\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Fixed HLS playlist creation on Windows hosts\n\n### Removed\n\n-   Nothing\n\n## 7.0.0 - 2020-05-26\n\n### Added\n\n-   Support for both Laravel 6.0 and Laravel 7.0\n-   Support for multiple inputs/outputs including mapping and complex filters\n-   Concatenation with transcoding\n-   Concatenation without transcoding\n-   Support for image sequences (timelapse)\n-   Bitrate, framerate and resolution data in HLS playlist\n-   Execute one job for HLS export instead of one job for each format\n-   Custom playlist/segment naming pattern for HLS export\n-   Support for disabling log\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Improved progress monitoring\n-   Improved handling of remote filesystems\n\n### Removed\n\n-   Nothing\n\n## 6.0.0 - 2020-03-03\n\n### Added\n\n-   Support for Laravel 7.0\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Support for Laravel 6.0\n\n## 5.0.0 - 2019-09-03\n\n### Added\n\n-   Support for Laravel 6.0\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Support for PHP 7.1\n-   Support for Laravel 5.8\n\n### Security\n\n-   Nothing\n\n## 4.1.0 - 2019-08-28\n\n### Added\n\n-   Nothing\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Lower memory usage when opening remote files\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 4.0.1 - 2019-06-17\n\n### Added\n\n-   Nothing\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Support for php-ffmpeg 0.14\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 4.0.0 - 2019-02-26\n\n### Added\n\n-   Support for Laravel 5.8.\n-   Support for PHP 7.3.\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 3.0.0 - 2018-09-03\n\n### Added\n\n-   Support for Laravel 5.7.\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 2.1.0 - 2018-04-10\n\n### Added\n\n-   Option to disable format sorting in HLS exporter.\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 2.0.1 - 2018-02-30\n\n### Added\n\n-   Nothing\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Symfony 4.0 workaround\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 2.0.0 - 2018-02-19\n\n### Added\n\n-   Support for Laravel 5.6.\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Support for Laravel 5.5 and earlier.\n\n### Security\n\n-   Nothing\n\n## 1.3.0 - 2017-11-13\n\n### Added\n\n-   Support for monitoring the progress of a HLS Export.\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Some refactoring\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.2.0 - 2017-11-13\n\n### Added\n\n-   Support for adding filters per format in the `HLSPlaylistExporter` class by giving access to the `Media` object through a callback.\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Some refactoring\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.1.12 - 2017-09-05\n\n### Added\n\n-   Support for Package Discovery in Laravel 5.5.\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Some refactoring\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.1.11 - 2017-08-31\n\n### Added\n\n-   Added `withVisibility` method to the MediaExporter\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Some refactoring\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.1.10 - 2017-08-16\n\n### Added\n\n-   Added `getFirstStream()` method to the `Media` class\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Some refactoring\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.1.9 - 2017-07-10\n\n### Added\n\n-   Support for custom filters in the `Media` class\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.1.8 - 2017-05-22\n\n### Added\n\n-   `getDurationInMiliseconds` method in Media class\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.1.7 - 2017-05-22\n\n### Added\n\n-   `fromFilesystem` method in FFMpeg class\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Fallback to format properties in `getDurationInSeconds` method (Media class)\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.1.6 - 2017-05-11\n\n### Added\n\n-   `cleanupTemporaryFiles` method\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.1.5 - 2017-03-20\n\n### Added\n\n-   Nothing\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Bugfix for saving on remote disks\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.1.4 - 2017-01-29\n\n### Added\n\n-   Nothing\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Support for php-ffmpeg 0.8.0\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.1.3 - 2017-01-05\n\n### Added\n\n-   Nothing\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   HLS segment playlists output path is now relative\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n\n## 1.1.2 - 2017-01-05\n\n### Added\n\n-   Added 'getDurationInSeconds' method to Media class.\n\n### Deprecated\n\n-   Nothing\n\n### Fixed\n\n-   Nothing\n\n### Removed\n\n-   Nothing\n\n### Security\n\n-   Nothing\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.90234375,
          "content": "# Contributing\n\nContributions are **welcome** and will be fully **credited**.\n\nPlease read and understand the contribution guide before creating an issue or pull request.\n\n## Etiquette\n\nThis project is open source, and as such, the maintainers give their free time to build and maintain the source code\nheld within. They make the code freely available in the hope that it will be of use to other developers. It would be\nextremely unfair for them to suffer abuse or anger for their hard work.\n\nPlease be considerate towards maintainers when raising issues or presenting pull requests. Let's show the\nworld that developers are civilized and selfless people.\n\nIt's the duty of the maintainer to ensure that all submissions to the project are of sufficient\nquality to benefit the project. Many developers have different skillsets, strengths, and weaknesses. Respect the maintainer's decision, and do not be upset or abusive if your submission is not used.\n\n## Viability\n\nWhen requesting or submitting new features, first consider whether it might be useful to others. Open\nsource projects are used by many developers, who may have entirely different needs to your own. Think about\nwhether or not your feature is likely to be used by other users of the project.\n\n## Procedure\n\nBefore filing an issue:\n\n- Attempt to replicate the problem, to ensure that it wasn't a coincidental incident.\n- Check to make sure your feature suggestion isn't already present within the project.\n- Check the pull requests tab to ensure that the bug doesn't have a fix in progress.\n- Check the pull requests tab to ensure that the feature isn't already in progress.\n\nBefore submitting a pull request:\n\n- Check the codebase to ensure that your feature doesn't already exist.\n- Check the pull requests to ensure that another person hasn't already submitted the feature or fix.\n\n## Requirements\n\nIf the project maintainer has any additional requirements, you will find them listed here.\n\n- **[PSR-2 Coding Standard](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md)** - The easiest way to apply the conventions is to install [PHP Code Sniffer](https://pear.php.net/package/PHP_CodeSniffer).\n\n- **Add tests!** - Your patch won't be accepted if it doesn't have tests.\n\n- **Document any change in behaviour** - Make sure the `README.md` and any other relevant documentation are kept up-to-date.\n\n- **Consider our release cycle** - We try to follow [SemVer v2.0.0](https://semver.org/). Randomly breaking public APIs is not an option.\n\n- **One pull request per feature** - If you want to do more than one thing, send multiple pull requests.\n\n- **Send coherent history** - Make sure each individual commit in your pull request is meaningful. If you had to make multiple intermediate commits while developing, please [squash them](https://www.git-scm.com/book/en/v2/Git-Tools-Rewriting-History#Changing-Multiple-Commit-Messages) before submitting.\n\n**Happy coding**!\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) Protone Media B.V.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 38.283203125,
          "content": "# Laravel FFMpeg\n\n[![Latest Version on Packagist](https://img.shields.io/packagist/v/pbmedia/laravel-ffmpeg.svg?style=flat-square)](https://packagist.org/packages/pbmedia/laravel-ffmpeg)\n[![Software License](https://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat-square)](LICENSE.md)\n![run-tests](https://github.com/protonemedia/laravel-ffmpeg/workflows/run-tests/badge.svg)\n[![Total Downloads](https://img.shields.io/packagist/dt/pbmedia/laravel-ffmpeg.svg?style=flat-square)](https://packagist.org/packages/pbmedia/laravel-ffmpeg)\n\nThis package provides an integration with FFmpeg for Laravel 10. [Laravel's Filesystem](http://laravel.com/docs/9.x/filesystem) handles the storage of the files.\n\n\n## Sponsor Us\n\n[<img src=\"https://inertiaui.com/visit-card.jpg\" />](https://inertiaui.com/inertia-table?utm_source=github&utm_campaign=laravel-ffmpeg)\n\n❤️ We proudly support the community by developing Laravel packages and giving them away for free. If this package saves you time or if you're relying on it professionally, please consider [sponsoring the maintenance and development](https://github.com/sponsors/pascalbaljet) and check out our latest premium package: [Inertia Table](https://inertiaui.com/inertia-table?utm_source=github&utm_campaign=laravel-ffmpeg). Keeping track of issues and pull requests takes time, but we're happy to help!\n\n\n## Features\n* Super easy wrapper around [PHP-FFMpeg](https://github.com/PHP-FFMpeg/PHP-FFMpeg), including support for filters and other advanced features.\n* Integration with [Laravel's Filesystem](http://laravel.com/docs/9.x/filesystem), [configuration system](https://laravel.com/docs/9.x/configuration) and [logging handling](https://laravel.com/docs/9.x/errors).\n* Compatible with Laravel 10, support for [Package Discovery](https://laravel.com/docs/9.x/packages#package-discovery).\n* Built-in support for HLS.\n* Built-in support for encrypted HLS (AES-128) and rotating keys (optional).\n* Built-in support for concatenation, multiple inputs/outputs, image sequences (timelapse), complex filters (and mapping), frame/thumbnail exports.\n* Built-in support for watermarks (positioning and manipulation).\n* Built-in support for creating a mosaic/sprite/tile from a video.\n* Built-in support for generating *VTT Preview Thumbnail* files.\n* Requires PHP 8.1 or higher.\n* Tested with FFmpeg 4.4 and 5.0.\n\n## Installation\n\nVerify you have the latest version of FFmpeg installed:\n\n```bash\nffmpeg -version\n```\n\nYou can install the package via composer:\n\n```bash\ncomposer require pbmedia/laravel-ffmpeg\n```\n\nAdd the Service Provider and Facade to your ```app.php``` config file if you're not using Package Discovery.\n\n```php\n// config/app.php\n\n'providers' => [\n    ...\n    ProtoneMedia\\LaravelFFMpeg\\Support\\ServiceProvider::class,\n    ...\n];\n\n'aliases' => [\n    ...\n    'FFMpeg' => ProtoneMedia\\LaravelFFMpeg\\Support\\FFMpeg::class\n    ...\n];\n```\n\nPublish the config file using the artisan CLI tool:\n\n```bash\nphp artisan vendor:publish --provider=\"ProtoneMedia\\LaravelFFMpeg\\Support\\ServiceProvider\"\n```\n\n## Upgrading to v8\n\n* The `set_command_and_error_output_on_exception` configuration key now defaults to `true`, making exceptions more informative. Read more at the [Handling exceptions](#handling-exceptions) section.\n* The `enable_logging` configuration key has been replaced by `log_channel` to choose the log channel used when writing messages to the logs. If you still want to disable logging entirely, you may set the new configuration key to `false`.\n* The *segment length* and *keyframe interval* of [HLS exports](#HLS) should be `2` or more; less is not supported anymore.\n* As Laravel 9 has migrated from [Flysystem 1.x to 3.x](https://laravel.com/docs/9.x/upgrade#flysystem-3), this version is not compatible with Laravel 8 or earlier.\n* If you're using the [Watermark manipulation](#watermark-manipulation) feature, make sure you upgrade [`spatie/image`](https://github.com/spatie/image) to v2.\n\n## Upgrading to v7\n\n* The namespace has changed to `ProtoneMedia\\LaravelFFMpeg`, the facade has been renamed to `ProtoneMedia\\LaravelFFMpeg\\Support\\FFMpeg`, and the Service Provider has been renamed to `ProtoneMedia\\LaravelFFMpeg\\Support\\ServiceProvider`.\n* Chaining exports are still supported, but you have to reapply filters for each export.\n* HLS playlists now include bitrate, framerate and resolution data. The segments also use a new naming pattern ([read more](#using-custom-segment-patterns)). Please verify your exports still work in your player.\n* HLS export is now executed as *one* job instead of exporting each format/stream separately. This uses FFMpeg's `map` and `filter_complex` features. It might be sufficient to replace all calls to `addFilter` with `addLegacyFilter`, but some filters should be migrated manually. Please read the [documentation on HLS](#hls) to find out more about adding filters.\n\n## Usage\n\nConvert an audio or video file:\n\n```php\nFFMpeg::fromDisk('songs')\n    ->open('yesterday.mp3')\n    ->export()\n    ->toDisk('converted_songs')\n    ->inFormat(new \\FFMpeg\\Format\\Audio\\Aac)\n    ->save('yesterday.aac');\n```\n\nInstead of the ```fromDisk()``` method you can also use the ```fromFilesystem()``` method, where ```$filesystem``` is an instance of ```Illuminate\\Contracts\\Filesystem\\Filesystem```.\n\n```php\n$media = FFMpeg::fromFilesystem($filesystem)->open('yesterday.mp3');\n```\n\n### Progress monitoring\n\nYou can monitor the transcoding progress. Use the ```onProgress``` method to provide a callback, which gives you the completed percentage. In previous versions of this package you had to pass the callback to the format object.\n\n```php\nFFMpeg::open('steve_howe.mp4')\n    ->export()\n    ->onProgress(function ($percentage) {\n        echo \"{$percentage}% transcoded\";\n    });\n```\n\nThe callback may also expose `$remaining` (in seconds) and `$rate`:\n\n```php\nFFMpeg::open('steve_howe.mp4')\n    ->export()\n    ->onProgress(function ($percentage, $remaining, $rate) {\n        echo \"{$remaining} seconds left at rate: {$rate}\";\n    });\n```\n\n### Opening uploaded files\n\nYou can open uploaded files directly from the `Request` instance. It's probably better to first save the uploaded file in case the request aborts, but if you want to, you can open a `UploadedFile` instance:\n\n```php\nclass UploadVideoController\n{\n    public function __invoke(Request $request)\n    {\n        FFMpeg::open($request->file('video'));\n    }\n}\n```\n\n### Open files from the web\n\nYou can open files from the web by using the `openUrl` method. You can specify custom HTTP headers with the optional second parameter:\n\n```php\nFFMpeg::openUrl('https://videocoursebuilder.com/lesson-1.mp4');\n\nFFMpeg::openUrl('https://videocoursebuilder.com/lesson-2.mp4', [\n    'Authorization' => 'Basic YWRtaW46MTIzNA==',\n]);\n```\n\n### Handling exceptions\n\nWhen the encoding fails, a `ProtoneMedia\\LaravelFFMpeg\\Exporters\\EncodingException` shall be thrown, which extends the underlying `FFMpeg\\Exception\\RuntimeException` class. This class has two methods that can help you identify the problem. Using the `getCommand` method, you can get the executed command with all parameters. The `getErrorOutput` method gives you a full output log.\n\nIn previous versions of this package, the message of the exception was always *Encoding failed*. You can downgrade to this message by updating the `set_command_and_error_output_on_exception` configuration key to `false`.\n\n```php\ntry {\n    FFMpeg::open('yesterday.mp3')\n        ->export()\n        ->inFormat(new Aac)\n        ->save('yesterday.aac');\n} catch (EncodingException $exception) {\n    $command = $exception->getCommand();\n    $errorLog = $exception->getErrorOutput();\n}\n```\n\n### Filters\n\nYou can add filters through a ```Closure``` or by using PHP-FFMpeg's Filter objects:\n\n```php\nuse FFMpeg\\Filters\\Video\\VideoFilters;\n\nFFMpeg::fromDisk('videos')\n    ->open('steve_howe.mp4')\n    ->addFilter(function (VideoFilters $filters) {\n        $filters->resize(new \\FFMpeg\\Coordinate\\Dimension(640, 480));\n    })\n    ->export()\n    ->toDisk('converted_videos')\n    ->inFormat(new \\FFMpeg\\Format\\Video\\X264)\n    ->save('small_steve.mkv');\n\n// or\n\n$start = \\FFMpeg\\Coordinate\\TimeCode::fromSeconds(5)\n$clipFilter = new \\FFMpeg\\Filters\\Video\\ClipFilter($start);\n\nFFMpeg::fromDisk('videos')\n    ->open('steve_howe.mp4')\n    ->addFilter($clipFilter)\n    ->export()\n    ->toDisk('converted_videos')\n    ->inFormat(new \\FFMpeg\\Format\\Video\\X264)\n    ->save('short_steve.mkv');\n```\n\nYou can also call the `addFilter` method *after* the `export` method:\n\n```php\nuse FFMpeg\\Filters\\Video\\VideoFilters;\n\nFFMpeg::fromDisk('videos')\n    ->open('steve_howe.mp4')\n    ->export()\n    ->toDisk('converted_videos')\n    ->inFormat(new \\FFMpeg\\Format\\Video\\X264)\n    ->addFilter(function (VideoFilters $filters) {\n        $filters->resize(new \\FFMpeg\\Coordinate\\Dimension(640, 480));\n    })\n    ->save('small_steve.mkv');\n```\n\n#### Resizing\n\nSince resizing is a common operation, we've added a dedicated method for it:\n\n```php\nFFMpeg::open('steve_howe.mp4')\n    ->export()\n    ->inFormat(new \\FFMpeg\\Format\\Video\\X264)\n    ->resize(640, 480)\n    ->save('steve_howe_resized.mp4');\n```\nThe first argument is the width, and the second argument the height. The optional third argument is the mode. You can choose between `fit` (default), `inset`, `width` or `height`. The optional fourth argument is a boolean whether or not to force the use of standards ratios. You can find about these modes in the `FFMpeg\\Filters\\Video\\ResizeFilter` class.\n\n### Custom filters\n\nSometimes you don't want to use the built-in filters. You can apply your own filter by providing a set of options. This can be an array or multiple strings as arguments:\n\n```php\nFFMpeg::fromDisk('videos')\n    ->open('steve_howe.mp4')\n    ->addFilter(['-itsoffset', 1]);\n\n// or\n\nFFMpeg::fromDisk('videos')\n    ->open('steve_howe.mp4')\n    ->addFilter('-itsoffset', 1);\n```\n\n### Watermark filter\n\nYou can easily add a watermark using the `addWatermark` method. With the `WatermarkFactory`, you can open your watermark file from a specific disk, just like opening an audio or video file. When you discard the `fromDisk` method, it uses the default disk specified in the `filesystems.php` configuration file.\n\nAfter opening your watermark file, you can position it with the `top`, `right`, `bottom`, and `left` methods. The first parameter of these methods is the offset, which is optional and can be negative.\n\n```php\nuse ProtoneMedia\\LaravelFFMpeg\\Filters\\WatermarkFactory;\n\nFFMpeg::fromDisk('videos')\n    ->open('steve_howe.mp4')\n    ->addWatermark(function(WatermarkFactory $watermark) {\n        $watermark->fromDisk('local')\n            ->open('logo.png')\n            ->right(25)\n            ->bottom(25);\n    });\n```\n\nInstead of using the position methods, you can also use the `horizontalAlignment` and `verticalAlignment` methods.\n\nFor horizontal alignment, you can use the `WatermarkFactory::LEFT`, `WatermarkFactory::CENTER` and `WatermarkFactory::RIGHT` constants. For vertical alignment, you can use the `WatermarkFactory::TOP`, `WatermarkFactory::CENTER` and `WatermarkFactory::BOTTOM` constants. Both methods take an optional second parameter, which is the offset.\n\n```php\nFFMpeg::open('steve_howe.mp4')\n    ->addWatermark(function(WatermarkFactory $watermark) {\n        $watermark->open('logo.png')\n            ->horizontalAlignment(WatermarkFactory::LEFT, 25)\n            ->verticalAlignment(WatermarkFactory::TOP, 25);\n    });\n```\n\nThe `WatermarkFactory` also supports opening files from the web with the `openUrl` method. It supports custom HTTP headers as well.\n\n```php\nFFMpeg::open('steve_howe.mp4')\n    ->addWatermark(function(WatermarkFactory $watermark) {\n        $watermark->openUrl('https://videocoursebuilder.com/logo.png');\n\n        // or\n\n        $watermark->openUrl('https://videocoursebuilder.com/logo.png', [\n            'Authorization' => 'Basic YWRtaW46MTIzNA==',\n        ]);\n    });\n```\n\nIf you want more control over the GET request, you can pass in an optional third parameter, which gives you the Curl resource.\n\n```php\n$watermark->openUrl('https://videocoursebuilder.com/logo.png', [\n    'Authorization' => 'Basic YWRtaW46MTIzNA==',\n], function($curl) {\n    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 0);\n    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 0);\n});\n```\n\n#### Watermark manipulation\n\nThis package can manipulate watermarks by using [Spatie's Image package](https://github.com/spatie/image). To get started, install the package with Composer:\n\n```bash\ncomposer require spatie/image\n```\n\nNow you can chain one more manipulation methods on the `WatermarkFactory` instance:\n\n```php\nFFMpeg::open('steve_howe.mp4')\n    ->addWatermark(function(WatermarkFactory $watermark) {\n        $watermark->open('logo.png')\n            ->right(25)\n            ->bottom(25)\n            ->width(100)\n            ->height(100)\n            ->greyscale();\n    });\n```\n\nCheck out [the documentation](https://spatie.be/docs/image/v1/introduction) for all available methods.\n\n### Export without transcoding\n\nThis package comes with a `ProtoneMedia\\LaravelFFMpeg\\FFMpeg\\CopyFormat` class that allows you to export a file without transcoding the streams. You might want to use this to use another container:\n\n```php\nuse ProtoneMedia\\LaravelFFMpeg\\FFMpeg\\CopyFormat;\n\nFFMpeg::open('video.mp4')\n    ->export()\n    ->inFormat(new CopyFormat)\n    ->save('video.mkv');\n```\n\n### Chain multiple convertions\n\n```php\n// The 'fromDisk()' method is not required, the file will now\n// be opened from the default 'disk', as specified in\n// the config file.\n\nFFMpeg::open('my_movie.mov')\n\n    // export to FTP, converted in WMV\n    ->export()\n    ->toDisk('ftp')\n    ->inFormat(new \\FFMpeg\\Format\\Video\\WMV)\n    ->save('my_movie.wmv')\n\n    // export to Amazon S3, converted in X264\n    ->export()\n    ->toDisk('s3')\n    ->inFormat(new \\FFMpeg\\Format\\Video\\X264)\n    ->save('my_movie.mkv');\n\n    // you could even discard the 'toDisk()' method,\n    // now the converted file will be saved to\n    // the same disk as the source!\n    ->export()\n    ->inFormat(new FFMpeg\\Format\\Video\\WebM)\n    ->save('my_movie.webm')\n\n    // optionally you could set the visibility\n    // of the exported file\n    ->export()\n    ->inFormat(new FFMpeg\\Format\\Video\\WebM)\n    ->withVisibility('public')\n    ->save('my_movie.webm')\n```\n\n### Export a frame from a video\n\n```php\nFFMpeg::fromDisk('videos')\n    ->open('steve_howe.mp4')\n    ->getFrameFromSeconds(10)\n    ->export()\n    ->toDisk('thumnails')\n    ->save('FrameAt10sec.png');\n\n// Instead of the 'getFrameFromSeconds()' method, you could\n// also use the 'getFrameFromString()' or the\n// 'getFrameFromTimecode()' methods:\n\n$media = FFMpeg::open('steve_howe.mp4');\n$frame = $media->getFrameFromString('00:00:13.37');\n\n// or\n\n$timecode = new FFMpeg\\Coordinate\\TimeCode(...);\n$frame = $media->getFrameFromTimecode($timecode);\n```\n\nYou can also get the raw contents of the frame instead of saving it to the filesystem:\n\n```php\n$contents = FFMpeg::open('video.mp4')\n    ->getFrameFromSeconds(2)\n    ->export()\n    ->getFrameContents();\n```\n\n### Export multiple frames at once\n\nThere is a `TileFilter` that powers the [Tile-feature](#creates-tiles-of-frames). To make exporting multiple frames faster and simpler, we leveraged this feature to add some helper methods. For example, you may use the `exportFramesByInterval` method to export frames by a fixed interval. Alternatively, you may pass the number of frames you want to export to the `exportFramesByAmount` method, which will then calculate the interval based on the duration of the video.\n\n```php\nFFMpeg::open('video.mp4')\n    ->exportFramesByInterval(2)\n    ->save('thumb_%05d.jpg');\n```\n\nBoth methods accept an optional second and third argument to specify to width and height of the frames. Instead of passing both the width and height, you may also pass just one of them. FFmpeg will respect the aspect ratio of the source.\n\n```php\nFFMpeg::open('video.mp4')\n    ->exportFramesByAmount(10, 320, 180)\n    ->save('thumb_%05d.png');\n```\n\nBoth methods accept an optional fourth argument to specify the quality of the image when you're exporting to a lossy format like JPEG. The range for JPEG is `2-31`, with `2` being the best quality and `31` being the worst.\n\n```php\nFFMpeg::open('video.mp4')\n    ->exportFramesByInterval(2, 640, 360, 5)\n    ->save('thumb_%05d.jpg');\n```\n\n### Creates tiles of frames\n\nYou can create tiles from a video. You may call the `exportTile` method to specify how your tiles should be generated. In the example below, each generated image consists of a 3x5 grid (thus containing 15 frames) and each frame is 160x90 pixels. A frame will be taken every 5 seconds from the video. Instead of passing both the width and height, you may also pass just one of them. FFmpeg will respect the aspect ratio of the source.\n\n```php\nuse ProtoneMedia\\LaravelFFMpeg\\Filters\\TileFactory;\n\nFFMpeg::open('steve_howe.mp4')\n    ->exportTile(function (TileFactory $factory) {\n        $factory->interval(5)\n            ->scale(160, 90)\n            ->grid(3, 5);\n    })\n    ->save('tile_%05d.jpg');\n```\n\nInstead of passing both the width and height, you may also pass just one of them like `scale(160)` or `scale(null, 90)`. The aspect ratio will be respected. The `TileFactory` has `margin`, `padding`, `width`, and `height` methods as well. There's also a `quality` method to specify the quality when exporting to a lossy format like JPEG. The range for JPEG is `2-31`, with `2` being the best quality and `31` being the worst.\n\nThis package can also generate a WebVTT file to add *Preview Thumbnails* to your video player. This is supported out-of-the-box by [JW player](https://support.jwplayer.com/articles/how-to-add-preview-thumbnails) and there are community-driven plugins for Video.js available as well. You may call the `generateVTT` method on the `TileFactory` with the desired filename:\n\n```php\nFFMpeg::open('steve_howe.mp4')\n    ->exportTile(function (TileFactory $factory) {\n        $factory->interval(10)\n            ->scale(320, 180)\n            ->grid(5, 5)\n            ->generateVTT('thumbnails.vtt');\n    })\n    ->save('tile_%05d.jpg');\n```\n\n### Multiple exports using loops\n\nChaining multiple conversions works because the `save` method of the `MediaExporter` returns a fresh instance of the `MediaOpener`. You can use this to loop through items, for example, to exports multiple frames from one video:\n\n```php\n$mediaOpener = FFMpeg::open('video.mp4');\n\nforeach ([5, 15, 25] as $key => $seconds) {\n    $mediaOpener = $mediaOpener->getFrameFromSeconds($seconds)\n        ->export()\n        ->save(\"thumb_{$key}.png\");\n}\n```\n\nThe `MediaOpener` comes with an `each` method as well. The example above could be refactored like this:\n\n```php\nFFMpeg::open('video.mp4')->each([5, 15, 25], function ($ffmpeg, $seconds, $key) {\n    $ffmpeg->getFrameFromSeconds($seconds)->export()->save(\"thumb_{$key}.png\");\n});\n```\n\n### Create a timelapse\n\nYou can create a timelapse from a sequence of images by using the `asTimelapseWithFramerate` method on the exporter\n\n```php\nFFMpeg::open('feature_%04d.png')\n    ->export()\n    ->asTimelapseWithFramerate(1)\n    ->inFormat(new X264)\n    ->save('timelapse.mp4');\n```\n\n### Multiple inputs\n\nYou can open multiple inputs, even from different disks. This uses FFMpeg's `map` and `filter_complex` features. You can open multiple files by chaining the `open` method of by using an array. You can mix inputs from different disks.\n\n```php\nFFMpeg::open('video1.mp4')->open('video2.mp4');\n\nFFMpeg::open(['video1.mp4', 'video2.mp4']);\n\nFFMpeg::fromDisk('uploads')\n    ->open('video1.mp4')\n    ->fromDisk('archive')\n    ->open('video2.mp4');\n```\n\nWhen you open multiple inputs, you have to add mappings so FFMpeg knows how to route them. This package provides a `addFormatOutputMapping` method, which takes three parameters: the format, the output, and the output labels of the `-filter_complex` part.\n\nThe output (2nd argument) should be an instanceof `ProtoneMedia\\LaravelFFMpeg\\Filesystem\\Media`. You can instantiate with the `make` method, call it with the name of the disk and the path (see example).\n\nCheck out this example, which maps separate video and audio inputs into one output.\n\n```php\nFFMpeg::fromDisk('local')\n    ->open(['video.mp4', 'audio.m4a'])\n    ->export()\n    ->addFormatOutputMapping(new X264, Media::make('local', 'new_video.mp4'), ['0:v', '1:a'])\n    ->save();\n```\n\nThis is an example [from the underlying library](https://github.com/PHP-FFMpeg/PHP-FFMpeg#base-usage):\n\n```php\n// This code takes 2 input videos, stacks they horizontally in 1 output video and\n// adds to this new video the audio from the first video. (It is impossible\n// with a simple filter graph that has only 1 input and only 1 output).\n\nFFMpeg::fromDisk('local')\n    ->open(['video.mp4', 'video2.mp4'])\n    ->export()\n    ->addFilter('[0:v][1:v]', 'hstack', '[v]')  // $in, $parameters, $out\n    ->addFormatOutputMapping(new X264, Media::make('local', 'stacked_video.mp4'), ['0:a', '[v]'])\n    ->save();\n```\n\nJust like single inputs, you can also pass a callback to the `addFilter` method. This will give you an instance of `\\FFMpeg\\Filters\\AdvancedMedia\\ComplexFilters`:\n\n```php\nuse FFMpeg\\Filters\\AdvancedMedia\\ComplexFilters;\n\nFFMpeg::open(['video.mp4', 'video2.mp4'])\n    ->export()\n    ->addFilter(function(ComplexFilters $filters) {\n        // $filters->watermark(...);\n    });\n```\n\nOpening files from the web works similarly. You can pass an array of URLs to the `openUrl` method, optionally with custom HTTP headers.\n\n```php\nFFMpeg::openUrl([\n    'https://videocoursebuilder.com/lesson-3.mp4',\n    'https://videocoursebuilder.com/lesson-4.mp4',\n]);\n\nFFMpeg::openUrl([\n    'https://videocoursebuilder.com/lesson-3.mp4',\n    'https://videocoursebuilder.com/lesson-4.mp4',\n], [\n    'Authorization' => 'Basic YWRtaW46MTIzNA==',\n]);\n```\n\nIf you want to use another set of HTTP headers for each URL, you can chain the `openUrl` method:\n\n```php\nFFMpeg::openUrl('https://videocoursebuilder.com/lesson-5.mp4', [\n    'Authorization' => 'Basic YWRtaW46MTIzNA==',\n])->openUrl('https://videocoursebuilder.com/lesson-6.mp4', [\n    'Authorization' => 'Basic bmltZGE6NDMyMQ==',\n]);\n```\n\n### Concat files without transcoding\n\n```php\nFFMpeg::fromDisk('local')\n    ->open(['video.mp4', 'video2.mp4'])\n    ->export()\n    ->concatWithoutTranscoding()\n    ->save('concat.mp4');\n```\n\n### Concat files with transcoding\n\n```php\nFFMpeg::fromDisk('local')\n    ->open(['video.mp4', 'video2.mp4'])\n    ->export()\n    ->inFormat(new X264)\n    ->concatWithTranscoding($hasVideo = true, $hasAudio = true)\n    ->save('concat.mp4');\n```\n\n### Determinate duration\n\nWith the ```Media``` class you can determinate the duration of a file:\n\n```php\n$media = FFMpeg::open('wwdc_2006.mp4');\n\n$durationInSeconds = $media->getDurationInSeconds(); // returns an int\n$durationInMiliseconds = $media->getDurationInMiliseconds(); // returns a float\n```\n\n### Handling remote disks\n\nWhen opening or saving files from or to a remote disk, temporary files will be created on your server. After you're done exporting or processing these files, you could clean them up by calling the ```cleanupTemporaryFiles()``` method:\n\n```php\nFFMpeg::cleanupTemporaryFiles();\n```\n\nBy default, the root of the temporary directories is evaluated by PHP's `sys_get_temp_dir()` method, but you can modify it by setting the `temporary_files_root` configuration key to a custom path.\n\n## HLS\n\nYou can create a M3U8 playlist to do [HLS](https://en.wikipedia.org/wiki/HTTP_Live_Streaming).\n\n```php\n$lowBitrate = (new X264)->setKiloBitrate(250);\n$midBitrate = (new X264)->setKiloBitrate(500);\n$highBitrate = (new X264)->setKiloBitrate(1000);\n\nFFMpeg::fromDisk('videos')\n    ->open('steve_howe.mp4')\n    ->exportForHLS()\n    ->setSegmentLength(10) // optional\n    ->setKeyFrameInterval(48) // optional\n    ->addFormat($lowBitrate)\n    ->addFormat($midBitrate)\n    ->addFormat($highBitrate)\n    ->save('adaptive_steve.m3u8');\n```\n\nThe ```addFormat``` method of the HLS exporter takes an optional second parameter which can be a callback method. This allows you to add different filters per format. First, check out the *Multiple inputs* section to understand how complex filters are handled.\n\nYou can use the `addFilter` method to add a complex filter (see `$lowBitrate` example). Since the `scale` filter is used a lot, there is a helper method (see `$midBitrate` example). You can also use a callable to get access to the `ComplexFilters` instance. The package provides the `$in` and `$out` arguments so you don't have to worry about it (see `$highBitrate` example).\n\nHLS export is built using FFMpeg's `map` and `filter_complex` features. This is a breaking change from earlier versions (1.x - 6.x) which performed a single export for each format. If you're upgrading, replace the `addFilter` calls with `addLegacyFilter` calls and verify the result (see `$superBitrate` example). Not all filters will work this way and some need to be upgraded manually.\n\n```php\n$lowBitrate = (new X264)->setKiloBitrate(250);\n$midBitrate = (new X264)->setKiloBitrate(500);\n$highBitrate = (new X264)->setKiloBitrate(1000);\n$superBitrate = (new X264)->setKiloBitrate(1500);\n\nFFMpeg::open('steve_howe.mp4')\n    ->exportForHLS()\n    ->addFormat($lowBitrate, function($media) {\n        $media->addFilter('scale=640:480');\n    })\n    ->addFormat($midBitrate, function($media) {\n        $media->scale(960, 720);\n    })\n    ->addFormat($highBitrate, function ($media) {\n        $media->addFilter(function ($filters, $in, $out) {\n            $filters->custom($in, 'scale=1920:1200', $out); // $in, $parameters, $out\n        });\n    })\n    ->addFormat($superBitrate, function($media) {\n        $media->addLegacyFilter(function ($filters) {\n            $filters->resize(new \\FFMpeg\\Coordinate\\Dimension(2560, 1920));\n        });\n    })\n    ->save('adaptive_steve.m3u8');\n```\n\n### Using custom segment patterns\n\nYou can use a custom pattern to name the segments and playlists. The `useSegmentFilenameGenerator` gives you 5 arguments. The first, second and third argument provide information about the basename of the export, the format of the current iteration and the key of the current iteration. The fourth argument is a callback you should call with your *segments* pattern. The fifth argument is a callback you should call with your *playlist* pattern. Note that this is not the name of the primary playlist, but the name of the playlist of each format.\n\n```php\nFFMpeg::fromDisk('videos')\n    ->open('steve_howe.mp4')\n    ->exportForHLS()\n    ->useSegmentFilenameGenerator(function ($name, $format, $key, callable $segments, callable $playlist) {\n        $segments(\"{$name}-{$format->getKiloBitrate()}-{$key}-%03d.ts\");\n        $playlist(\"{$name}-{$format->getKiloBitrate()}-{$key}.m3u8\");\n    });\n```\n\n### Encrypted HLS\n\nYou can encrypt each HLS segment using AES-128 encryption. To do this, call the `withEncryptionKey` method on the HLS exporter with a key. We provide a `generateEncryptionKey` helper method on the `HLSExporter` class to generate a key. Make sure you store the key well, as the exported result is worthless without the key. By default, the filename of the key is `secret.key`, but you can change that with the optional second parameter of the `withEncryptionKey` method.\n\n```php\nuse ProtoneMedia\\LaravelFFMpeg\\Exporters\\HLSExporter;\n\n$encryptionKey = HLSExporter::generateEncryptionKey();\n\nFFMpeg::open('steve_howe.mp4')\n    ->exportForHLS()\n    ->withEncryptionKey($encryptionKey)\n    ->addFormat($lowBitrate)\n    ->addFormat($midBitrate)\n    ->addFormat($highBitrate)\n    ->save('adaptive_steve.m3u8');\n```\n\nTo secure your HLS export even further, you can rotate the key on each exported segment. By doing so, it will generate multiple keys that you'll need to store. Use the `withRotatingEncryptionKey` method to enable this feature and provide a callback that implements the storage of the keys.\n\n```php\nFFMpeg::open('steve_howe.mp4')\n    ->exportForHLS()\n    ->withRotatingEncryptionKey(function ($filename, $contents) {\n        $videoId = 1;\n\n        // use this callback to store the encryption keys\n\n        Storage::disk('secrets')->put($videoId . '/' . $filename, $contents);\n\n        // or...\n\n        DB::table('hls_secrets')->insert([\n            'video_id' => $videoId,\n            'filename' => $filename,\n            'contents' => $contents,\n        ]);\n    })\n    ->addFormat($lowBitrate)\n    ->addFormat($midBitrate)\n    ->addFormat($highBitrate)\n    ->save('adaptive_steve.m3u8');\n```\n\nThe `withRotatingEncryptionKey` method has an optional second argument to set the number of segments that use the same key. This defaults to `1`.\n\n```php\nFFMpeg::open('steve_howe.mp4')\n    ->exportForHLS()\n    ->withRotatingEncryptionKey($callable, 10);\n```\n\nSome filesystems, especially on cheap and slow VPSs, are not fast enough to handle the rotating key. This may lead to encoding exceptions, like `No key URI specified in key info file`. One possible solution is to use a different storage for the keys, which you can specify using the `temporary_files_encrypted_hls` configuration key. On UNIX-based systems, you may use a `tmpfs` filesystem to increase read/write speeds:\n\n```php\n// config/laravel-ffmpeg.php\n\nreturn [\n\n    'temporary_files_encrypted_hls' => '/dev/shm'\n\n];\n```\n\n### Protecting your HLS encryption keys\n\nTo make working with encrypted HLS even better, we've added a `DynamicHLSPlaylist` class that modifies playlists on-the-fly and specifically for your application. This way, you can add your authentication and authorization logic. As we're using a plain Laravel controller, you can use features like [Gates](https://laravel.com/docs/master/authorization#gates) and [Middleware](https://laravel.com/docs/master/middleware#introduction).\n\nIn this example, we've saved the HLS export to the `public` disk, and we've stored the encryption keys to the `secrets` disk, which isn't publicly available. As the browser can't access the encryption keys, it won't play the video. Each playlist has paths to the encryption keys, and we need to modify those paths to point to an accessible endpoint.\n\nThis implementation consists of two routes. One that responses with an encryption key and one that responses with a modified playlist. The first route (`video.key`) is relatively simple, and this is where you should add your additional logic.\n\nThe second route (`video.playlist`) uses the `DynamicHLSPlaylist` class. Call the `dynamicHLSPlaylist` method on the `FFMpeg` facade, and similar to opening media files, you can open a playlist utilizing the `fromDisk` and `open` methods. Then you must provide three callbacks. Each of them gives you a relative path and expects a full path in return. As the `DynamicHLSPlaylist` class implements the `Illuminate\\Contracts\\Support\\Responsable` interface, you can return the instance.\n\nThe first callback (KeyUrlResolver) gives you the relative path to an encryption key. The second callback (MediaUrlResolver) gives you the relative path to a media segment (.ts files). The third callback (PlaylistUrlResolver) gives you the relative path to a playlist.\n\nNow instead of using `Storage::disk('public')->url('adaptive_steve.m3u8')` to get the full url to your primary playlist, you can use `route('video.playlist', ['playlist' => 'adaptive_steve.m3u8'])`. The `DynamicHLSPlaylist` class takes care of all the paths and urls.\n\n```php\nRoute::get('/video/secret/{key}', function ($key) {\n    return Storage::disk('secrets')->download($key);\n})->name('video.key');\n\nRoute::get('/video/{playlist}', function ($playlist) {\n    return FFMpeg::dynamicHLSPlaylist()\n        ->fromDisk('public')\n        ->open($playlist)\n        ->setKeyUrlResolver(function ($key) {\n            return route('video.key', ['key' => $key]);\n        })\n        ->setMediaUrlResolver(function ($mediaFilename) {\n            return Storage::disk('public')->url($mediaFilename);\n        })\n        ->setPlaylistUrlResolver(function ($playlistFilename) {\n            return route('video.playlist', ['playlist' => $playlistFilename]);\n        });\n})->name('video.playlist');\n```\n\n### Live Coding Session\n\nHere you can find a Live Coding Session about HLS encryption:\n\n[https://www.youtube.com/watch?v=WlbzWoAcez4](https://www.youtube.com/watch?v=WlbzWoAcez4)\n\n## Process Output\n\nYou can get the raw process output by calling the `getProcessOutput` method. Though the use-case is limited, you can use it to analyze a file (for example, with the `volumedetect` filter). It returns a `ProtoneMedia\\LaravelFFMpeg\\Support\\ProcessOutput` class that has three methods: `all`, `errors` and `output`. Each method returns an array with the corresponding lines.\n\n```php\n$processOutput = FFMpeg::open('video.mp4')\n    ->export()\n    ->addFilter(['-filter:a', 'volumedetect', '-f', 'null'])\n    ->getProcessOutput();\n\n$processOutput->all();\n$processOutput->errors();\n$processOutput->out();\n```\n\n## Advanced\n\nThe Media object you get when you 'open' a file, actually holds the Media object that belongs to the [underlying driver](https://github.com/PHP-FFMpeg/PHP-FFMpeg). It handles dynamic method calls as you can see [here](https://github.com/pascalbaljetmedia/laravel-ffmpeg/blob/master/src/Media.php#L114-L117). This way all methods of the underlying driver are still available to you.\n\n```php\n// This gives you an instance of ProtoneMedia\\LaravelFFMpeg\\MediaOpener\n$media = FFMpeg::fromDisk('videos')->open('video.mp4');\n\n// The 'getStreams' method will be called on the underlying Media object since\n// it doesn't exists on this object.\n$codec = $media->getStreams()->first()->get('codec_name');\n```\n\nIf you want direct access to the underlying object, call the object as a function (invoke):\n\n```php\n// This gives you an instance of ProtoneMedia\\LaravelFFMpeg\\MediaOpener\n$media = FFMpeg::fromDisk('videos')->open('video.mp4');\n\n// This gives you an instance of FFMpeg\\Media\\MediaTypeInterface\n$baseMedia = $media();\n```\n\n## Experimental\n\nThe [progress listener](#progress-monitoring) exposes the transcoded percentage, but the underlying package also has an internal `AbstractProgressListener` that exposes the current pass and the current time. Though the use-case is limited, you might want to get access to this listener instance. You can do this by decorating the format with the `ProgressListenerDecorator`. This feature is highly experimental, so be sure the test this thoroughly before using it in production.\n\n```php\nuse FFMpeg\\Format\\ProgressListener\\AbstractProgressListener;\nuse ProtoneMedia\\LaravelFFMpeg\\FFMpeg\\ProgressListenerDecorator;\n\n$format = new \\FFMpeg\\Format\\Video\\X264;\n$decoratedFormat = ProgressListenerDecorator::decorate($format);\n\nFFMpeg::open('video.mp4')\n    ->export()\n    ->inFormat($decoratedFormat)\n    ->onProgress(function () use ($decoratedFormat) {\n        $listeners = $decoratedFormat->getListeners();  // array of listeners\n\n        $listener = $listeners[0];  // instance of AbstractProgressListener\n\n        $listener->getCurrentPass();\n        $listener->getTotalPass();\n        $listener->getCurrentTime();\n    })\n    ->save('new_video.mp4');\n```\n\nSince we can't get rid of some of the underlying options, you can interact with the final FFmpeg command by adding a callback to the exporter. You can add one or more callbacks by using the `beforeSaving` method:\n\n```php\nFFMpeg::open('video.mp4')\n    ->export()\n    ->inFormat(new X264)\n    ->beforeSaving(function ($commands) {\n        $commands[] = '-hello';\n\n        return $commands;\n    })\n    ->save('concat.mp4');\n```\n\n*Note: this does not work with concatenation and frame exports*\n\n## Example app\n\nHere's a blog post that will help you get started with this package:\n\nhttps://protone.media/en/blog/how-to-use-ffmpeg-in-your-laravel-projects\n\n## Using Video.js to play HLS in any browser\n\nHere's a 20-minute overview how to get started with Video.js. It covers including Video.js from a CDN, importing it as an ES6 module with Laravel Mix (Webpack) and building a reusable Vue.js component.\n\n[https://www.youtube.com/watch?v=nA1Jy8BPjys](https://www.youtube.com/watch?v=nA1Jy8BPjys)\n\n## Wiki\n\n* [Custom filters](https://github.com/protonemedia/laravel-ffmpeg/wiki/Custom-filters)\n* [FFmpeg failed to execute command](https://github.com/protonemedia/laravel-ffmpeg/wiki/FFmpeg-failed-to-execute-command)\n* [Get the dimensions of a Video file](https://github.com/protonemedia/laravel-ffmpeg/wiki/Get-the-dimensions-of-a-Video-file)\n* [Monitoring the transcoding progress](https://github.com/protonemedia/laravel-ffmpeg/wiki/Monitoring-the-transcoding-progress)\n* [Unable to load FFProbe](https://github.com/protonemedia/laravel-ffmpeg/wiki/Unable-to-load-FFProbe)\n\n## Changelog\n\nPlease see [CHANGELOG](CHANGELOG.md) for more information about what has changed recently.\n\n## Testing\n\n```bash\n$ composer test\n```\n\n## Contributing\n\nPlease see [CONTRIBUTING](CONTRIBUTING.md) for details.\n\n## Other Laravel packages\n\n* [`Inertia Table`](https://inertiaui.com/inertia-table?utm_source=github&utm_campaign=laravel-ffmpeg): The Ultimate Table for Inertia.js with built-in Query Builder.\n* [`Laravel Blade On Demand`](https://github.com/protonemedia/laravel-blade-on-demand): Laravel package to compile Blade templates in memory.\n* [`Laravel Cross Eloquent Search`](https://github.com/protonemedia/laravel-cross-eloquent-search): Laravel package to search through multiple Eloquent models.\n* [`Laravel Eloquent Scope as Select`](https://github.com/protonemedia/laravel-eloquent-scope-as-select): Stop duplicating your Eloquent query scopes and constraints in PHP. This package lets you re-use your query scopes and constraints by adding them as a subquery.\n* [`Laravel MinIO Testing Tools`](https://github.com/protonemedia/laravel-minio-testing-tools): Run your tests against a MinIO S3 server.\n* [`Laravel Mixins`](https://github.com/protonemedia/laravel-mixins): A collection of Laravel goodies.\n* [`Laravel Paddle`](https://github.com/protonemedia/laravel-paddle): Paddle.com API integration for Laravel with support for webhooks/events.\n* [`Laravel Task Runner`](https://github.com/protonemedia/laravel-task-runner): Write Shell scripts like Blade Components and run them locally or on a remote server.\n* [`Laravel Verify New Email`](https://github.com/protonemedia/laravel-verify-new-email): This package adds support for verifying new email addresses: when a user updates its email address, it won't replace the old one until the new one is verified.\n* [`Laravel XSS Protection`](https://github.com/protonemedia/laravel-xss-protection): Laravel Middleware to protect your app against Cross-site scripting (XSS). It sanitizes request input, and it can sanatize Blade echo statements.\n\n## Security\n\nIf you discover any security-related issues, please email code@protone.media instead of using the issue tracker. Please do not email any questions, open an issue if you have a question.\n\n## Credits\n\n- [Pascal Baljet](https://github.com/pascalbaljet)\n- [All Contributors](../../contributors)\n\n## License\n\nThe MIT License (MIT). Please see [License File](LICENSE.md) for more information.\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.7451171875,
          "content": "{\n    \"name\": \"pbmedia/laravel-ffmpeg\",\n    \"description\": \"FFMpeg for Laravel\",\n    \"keywords\": [\n        \"laravel\",\n        \"laravel-ffmpeg\",\n        \"ffmpeg\",\n        \"protonemedia\",\n        \"protone media\"\n    ],\n    \"homepage\": \"https://github.com/protonemedia/laravel-ffmpeg\",\n    \"license\": \"MIT\",\n    \"type\": \"library\",\n    \"authors\": [\n        {\n            \"name\": \"Pascal Baljet\",\n            \"email\": \"pascal@protone.media\",\n            \"homepage\": \"https://protone.media\",\n            \"role\": \"Developer\"\n        }\n    ],\n    \"require\": {\n        \"php\": \"^8.1|^8.2|^8.3|^8.4\",\n        \"illuminate/contracts\": \"^10.0|^11.0\",\n        \"php-ffmpeg/php-ffmpeg\": \"^1.2\",\n        \"ramsey/collection\": \"^2.0\"\n    },\n    \"require-dev\": {\n        \"league/flysystem-memory\": \"^3.10\",\n        \"mockery/mockery\": \"^1.4.4\",\n        \"nesbot/carbon\": \"^2.66|^3.0\",\n        \"orchestra/testbench\": \"^8.0|^9.0\",\n        \"phpunit/phpunit\": \"^10.4\",\n        \"spatie/image\": \"^2.2|^3.3\",\n        \"spatie/phpunit-snapshot-assertions\": \"^5.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"ProtoneMedia\\\\LaravelFFMpeg\\\\\": \"src\"\n        }\n    },\n    \"autoload-dev\": {\n        \"psr-4\": {\n            \"ProtoneMedia\\\\LaravelFFMpeg\\\\Tests\\\\\": \"tests\"\n        }\n    },\n    \"scripts\": {\n        \"test\": \"vendor/bin/phpunit\",\n        \"test-coverage\": \"vendor/bin/phpunit --coverage-html coverage\"\n    },\n    \"config\": {\n        \"sort-packages\": true\n    },\n    \"minimum-stability\": \"dev\",\n    \"prefer-stable\": true,\n    \"extra\": {\n        \"laravel\": {\n            \"providers\": [\n                \"ProtoneMedia\\\\LaravelFFMpeg\\\\Support\\\\ServiceProvider\"\n            ],\n            \"aliases\": {\n                \"FFMpeg\": \"ProtoneMedia\\\\LaravelFFMpeg\\\\Support\\\\FFMpeg\"\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.32421875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit bootstrap=\"vendor/autoload.php\"\n    backupGlobals=\"false\"\n    colors=\"true\"\n    processIsolation=\"false\"\n    stopOnFailure=\"false\">\n    <testsuites>\n        <testsuite name=\"FFMpeg Test Suite\">\n            <directory>tests</directory>\n        </testsuite>\n    </testsuites>\n</phpunit>"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}