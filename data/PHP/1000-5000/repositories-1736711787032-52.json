{
  "metadata": {
    "timestamp": 1736711787032,
    "page": 52,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/config",
      "stars": 4236,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "Builder",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 5.1796875,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Add `#[WhenNot]` attribute to prevent service from being registered in a specific environment\n * Generate a meta file in JSON format for resource tracking\n * Add `SkippingResourceChecker`\n * Add support for `defaultNull()` on `BooleanNode`\n * Add `StringNode` and `StringNodeDefinition`\n * Add `ArrayNodeDefinition::stringPrototype()` method\n * Add `NodeBuilder::stringNode()` method\n\n7.1\n---\n\n * Allow custom meta location in `ResourceCheckerConfigCache`\n * Allow custom meta location in `ConfigCache`\n\n7.0\n---\n\n * Require explicit argument when calling `NodeBuilder::setParent()`\n\n6.3\n---\n\n * Allow enum values in `EnumNode`\n\n6.2\n---\n\n * Deprecate calling `NodeBuilder::setParent()` without any arguments\n * Add a more accurate typehint in generated PHP config\n\n6.1\n---\n\n * Allow using environment variables in `EnumNode`\n * Add Node's information in generated Config\n * Add `DefinitionFileLoader` class to load a TreeBuilder definition from an external file\n * Add `DefinitionConfigurator` helper\n\n6.0\n---\n\n * Remove `BaseNode::getDeprecationMessage()`\n\n5.3.0\n-----\n\n * Add support for generating `ConfigBuilder` for extensions\n\n5.1.0\n-----\n\n * updated the signature of method `NodeDefinition::setDeprecated()` to `NodeDefinition::setDeprecation(string $package, string $version, string $message)`\n * updated the signature of method `BaseNode::setDeprecated()` to `BaseNode::setDeprecation(string $package, string $version, string $message)`\n * deprecated passing a null message to `BaseNode::setDeprecated()` to un-deprecate a node\n * deprecated `BaseNode::getDeprecationMessage()`, use `BaseNode::getDeprecation()` instead\n\n5.0.0\n-----\n\n * Dropped support for constructing a `TreeBuilder` without passing root node information.\n * Removed the `root()` method in `TreeBuilder`, pass the root node information to the constructor instead\n * Added method `getChildNodeDefinitions()` to ParentNodeDefinitionInterface\n * Removed `FileLoaderLoadException`, use `LoaderLoadException` instead\n\n4.4.0\n-----\n\n * added a way to exclude patterns of resources from being imported by the `import()` method\n\n4.3.0\n-----\n\n * deprecated using environment variables with `cannotBeEmpty()` if the value is validated with `validate()`\n * made `Resource\\*` classes final and not implement `Serializable` anymore\n * deprecated the `root()` method in `TreeBuilder`, pass the root node information to the constructor instead\n\n4.2.0\n-----\n\n * deprecated constructing a `TreeBuilder` without passing root node information\n * renamed `FileLoaderLoadException` to `LoaderLoadException`\n\n4.1.0\n-----\n\n * added `setPathSeparator` method to `NodeBuilder` class\n * added third `$pathSeparator` constructor argument to `BaseNode`\n * the `Processor` class has been made final\n\n4.0.0\n-----\n\n * removed `ConfigCachePass`\n\n3.4.0\n-----\n\n * added `setDeprecated()` method to indicate a deprecated node\n * added `XmlUtils::parse()` method to parse an XML string\n * deprecated `ConfigCachePass`\n\n3.3.0\n-----\n\n * added `ReflectionClassResource` class\n * added second `$exists` constructor argument to `ClassExistenceResource`\n * made `ClassExistenceResource` work with interfaces and traits\n * added `ConfigCachePass` (originally in FrameworkBundle)\n * added `castToArray()` helper to turn any config value into an array\n\n3.0.0\n-----\n\n * removed `ReferenceDumper` class\n * removed the `ResourceInterface::isFresh()` method\n * removed `BCResourceInterfaceChecker` class\n * removed `ResourceInterface::getResource()` method\n\n2.8.0\n-----\n\nThe edge case of defining just one value for nodes of type Enum is now allowed:\n\n```php\n$rootNode\n    ->children()\n        ->enumNode('variable')\n            ->values(['value'])\n        ->end()\n    ->end()\n;\n```\n\nBefore: `InvalidArgumentException` (variable must contain at least two\ndistinct elements).\nAfter: the code will work as expected and it will restrict the values of the\n`variable` option to just `value`.\n\n * deprecated the `ResourceInterface::isFresh()` method. If you implement custom resource types and they\n   can be validated that way, make them implement the new `SelfCheckingResourceInterface`.\n * deprecated the getResource() method in ResourceInterface. You can still call this method\n   on concrete classes implementing the interface, but it does not make sense at the interface\n   level as you need to know about the particular type of resource at hand to understand the\n   semantics of the returned value.\n\n2.7.0\n-----\n\n * added `ConfigCacheInterface`, `ConfigCacheFactoryInterface` and a basic `ConfigCacheFactory`\n   implementation to delegate creation of ConfigCache instances\n\n2.2.0\n-----\n\n * added `ArrayNodeDefinition::canBeEnabled()` and `ArrayNodeDefinition::canBeDisabled()`\n   to ease configuration when some sections are respectively disabled / enabled\n   by default.\n * added a `normalizeKeys()` method for array nodes (to avoid key normalization)\n * added numerical type handling for config definitions\n * added convenience methods for optional configuration sections to `ArrayNodeDefinition`\n * added a utils class for XML manipulations\n\n2.1.0\n-----\n\n * added a way to add documentation on configuration\n * implemented `Serializable` on resources\n * `LoaderResolverInterface` is now used instead of `LoaderResolver` for type\n   hinting\n"
        },
        {
          "name": "ConfigCache.php",
          "type": "blob",
          "size": 2.0732421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Config;\n\nuse Symfony\\Component\\Config\\Resource\\ResourceInterface;\nuse Symfony\\Component\\Config\\Resource\\SelfCheckingResourceChecker;\nuse Symfony\\Component\\Config\\Resource\\SkippingResourceChecker;\n\n/**\n * ConfigCache caches arbitrary content in files on disk.\n *\n * When in debug mode, those metadata resources that implement\n * \\Symfony\\Component\\Config\\Resource\\SelfCheckingResourceInterface will\n * be used to check cache freshness.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Matthias Pigulla <mp@webfactory.de>\n */\nclass ConfigCache extends ResourceCheckerConfigCache\n{\n    /**\n     * @param string                                 $file                 The absolute cache path\n     * @param bool                                   $debug                Whether debugging is enabled or not\n     * @param string|null                            $metaFile             The absolute path to the meta file\n     * @param class-string<ResourceInterface>[]|null $skippedResourceTypes\n     */\n    public function __construct(\n        string $file,\n        private bool $debug,\n        ?string $metaFile = null,\n        array|null $skippedResourceTypes = null,\n    ) {\n        $checkers = [];\n        if ($this->debug) {\n            if (null !== $skippedResourceTypes) {\n                $checkers[] = new SkippingResourceChecker($skippedResourceTypes);\n            }\n            $checkers[] = new SelfCheckingResourceChecker();\n        }\n\n        parent::__construct($file, $checkers, $metaFile);\n    }\n\n    /**\n     * Checks if the cache is still fresh.\n     *\n     * This implementation always returns true when debug is off and the\n     * cache file exists.\n     */\n    public function isFresh(): bool\n    {\n        if (!$this->debug && is_file($this->getPath())) {\n            return true;\n        }\n\n        return parent::isFresh();\n    }\n}\n"
        },
        {
          "name": "ConfigCacheFactory.php",
          "type": "blob",
          "size": 1.0322265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Config;\n\n/**\n * Basic implementation of ConfigCacheFactoryInterface that\n * creates an instance of the default ConfigCache.\n *\n * This factory and/or cache <em>do not</em> support cache validation\n * by means of ResourceChecker instances (that is, service-based).\n *\n * @author Matthias Pigulla <mp@webfactory.de>\n */\nclass ConfigCacheFactory implements ConfigCacheFactoryInterface\n{\n    /**\n     * @param bool $debug The debug flag to pass to ConfigCache\n     */\n    public function __construct(\n        private bool $debug,\n    ) {\n    }\n\n    public function cache(string $file, callable $callback): ConfigCacheInterface\n    {\n        $cache = new ConfigCache($file, $this->debug);\n        if (!$cache->isFresh()) {\n            $callback($cache);\n        }\n\n        return $cache;\n    }\n}\n"
        },
        {
          "name": "ConfigCacheFactoryInterface.php",
          "type": "blob",
          "size": 0.9150390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Config;\n\n/**\n * Interface for a ConfigCache factory. This factory creates\n * an instance of ConfigCacheInterface and initializes the\n * cache if necessary.\n *\n * @author Matthias Pigulla <mp@webfactory.de>\n */\ninterface ConfigCacheFactoryInterface\n{\n    /**\n     * Creates a cache instance and (re-)initializes it if necessary.\n     *\n     * @param string   $file     The absolute cache file path\n     * @param callable $callable The callable to be executed when the cache needs to be filled (i. e. is not fresh). The cache will be passed as the only parameter to this callback\n     */\n    public function cache(string $file, callable $callable): ConfigCacheInterface;\n}\n"
        },
        {
          "name": "ConfigCacheInterface.php",
          "type": "blob",
          "size": 1.2177734375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Config;\n\nuse Symfony\\Component\\Config\\Resource\\ResourceInterface;\n\n/**\n * Interface for ConfigCache.\n *\n * @author Matthias Pigulla <mp@webfactory.de>\n */\ninterface ConfigCacheInterface\n{\n    /**\n     * Gets the cache file path.\n     */\n    public function getPath(): string;\n\n    /**\n     * Checks if the cache is still fresh.\n     *\n     * This check should take the metadata passed to the write() method into consideration.\n     */\n    public function isFresh(): bool;\n\n    /**\n     * Writes the given content into the cache file. Metadata will be stored\n     * independently and can be used to check cache freshness at a later time.\n     *\n     * @param string                   $content  The content to write into the cache\n     * @param ResourceInterface[]|null $metadata An array of ResourceInterface instances\n     *\n     * @throws \\RuntimeException When the cache file cannot be written\n     */\n    public function write(string $content, ?array $metadata = null): void;\n}\n"
        },
        {
          "name": "Definition",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "FileLocator.php",
          "type": "blob",
          "size": 2.6982421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Config;\n\nuse Symfony\\Component\\Config\\Exception\\FileLocatorFileNotFoundException;\n\n/**\n * FileLocator uses an array of pre-defined paths to find files.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass FileLocator implements FileLocatorInterface\n{\n    protected array $paths;\n\n    /**\n     * @param string|string[] $paths A path or an array of paths where to look for resources\n     */\n    public function __construct(string|array $paths = [])\n    {\n        $this->paths = (array) $paths;\n    }\n\n    /**\n     * @return string|string[]\n     *\n     * @psalm-return ($first is true ? string : string[])\n     */\n    public function locate(string $name, ?string $currentPath = null, bool $first = true): string|array\n    {\n        if ('' === $name) {\n            throw new \\InvalidArgumentException('An empty file name is not valid to be located.');\n        }\n\n        if ($this->isAbsolutePath($name)) {\n            if (!file_exists($name)) {\n                throw new FileLocatorFileNotFoundException(\\sprintf('The file \"%s\" does not exist.', $name), 0, null, [$name]);\n            }\n\n            return $name;\n        }\n\n        $paths = $this->paths;\n\n        if (null !== $currentPath) {\n            array_unshift($paths, $currentPath);\n        }\n\n        $paths = array_unique($paths);\n        $filepaths = $notfound = [];\n\n        foreach ($paths as $path) {\n            if (@file_exists($file = $path.\\DIRECTORY_SEPARATOR.$name)) {\n                if (true === $first) {\n                    return $file;\n                }\n                $filepaths[] = $file;\n            } else {\n                $notfound[] = $file;\n            }\n        }\n\n        if (!$filepaths) {\n            throw new FileLocatorFileNotFoundException(\\sprintf('The file \"%s\" does not exist (in: \"%s\").', $name, implode('\", \"', $paths)), 0, null, $notfound);\n        }\n\n        return $filepaths;\n    }\n\n    /**\n     * Returns whether the file path is an absolute path.\n     */\n    private function isAbsolutePath(string $file): bool\n    {\n        if ('/' === $file[0] || '\\\\' === $file[0]\n            || (\\strlen($file) > 3 && ctype_alpha($file[0])\n                && ':' === $file[1]\n                && ('\\\\' === $file[2] || '/' === $file[2])\n            )\n            || parse_url($file, \\PHP_URL_SCHEME)\n            || str_starts_with($file, 'phar:///') // \"parse_url()\" doesn't handle absolute phar path, despite being valid\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n}\n"
        },
        {
          "name": "FileLocatorInterface.php",
          "type": "blob",
          "size": 1.11328125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Config;\n\nuse Symfony\\Component\\Config\\Exception\\FileLocatorFileNotFoundException;\n\n/**\n * @author Fabien Potencier <fabien@symfony.com>\n */\ninterface FileLocatorInterface\n{\n    /**\n     * Returns a full path for a given file name.\n     *\n     * @param string      $name        The file name to locate\n     * @param string|null $currentPath The current path\n     * @param bool        $first       Whether to return the first occurrence or an array of filenames\n     *\n     * @return string|string[] The full path to the file or an array of file paths\n     *\n     * @throws \\InvalidArgumentException        If $name is empty\n     * @throws FileLocatorFileNotFoundException If a file is not found\n     *\n     * @psalm-return ($first is true ? string : string[])\n     */\n    public function locate(string $name, ?string $currentPath = null, bool $first = true): string|array;\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Loader",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.58203125,
          "content": "Config Component\n================\n\nThe Config component helps find, load, combine, autofill and validate\nconfiguration values of any kind, whatever their source may be (YAML, XML, INI\nfiles, or for instance a database).\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/config.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Resource",
          "type": "tree",
          "content": null
        },
        {
          "name": "ResourceCheckerConfigCache.php",
          "type": "blob",
          "size": 6.162109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Config;\n\nuse Symfony\\Component\\Config\\Resource\\ResourceInterface;\nuse Symfony\\Component\\Filesystem\\Exception\\IOException;\nuse Symfony\\Component\\Filesystem\\Filesystem;\n\n/**\n * ResourceCheckerConfigCache uses instances of ResourceCheckerInterface\n * to check whether cached data is still fresh.\n *\n * @author Matthias Pigulla <mp@webfactory.de>\n */\nclass ResourceCheckerConfigCache implements ConfigCacheInterface\n{\n    private string $metaFile;\n\n    /**\n     * @param string                                    $file             The absolute cache path\n     * @param iterable<mixed, ResourceCheckerInterface> $resourceCheckers The ResourceCheckers to use for the freshness check\n     * @param string|null                               $metaFile         The absolute path to the meta file, defaults to $file.meta if null\n     */\n    public function __construct(\n        private string $file,\n        private iterable $resourceCheckers = [],\n        ?string $metaFile = null,\n    ) {\n        $this->metaFile = $metaFile ?? $file.'.meta';\n    }\n\n    public function getPath(): string\n    {\n        return $this->file;\n    }\n\n    /**\n     * Checks if the cache is still fresh.\n     *\n     * This implementation will make a decision solely based on the ResourceCheckers\n     * passed in the constructor.\n     *\n     * The first ResourceChecker that supports a given resource is considered authoritative.\n     * Resources with no matching ResourceChecker will silently be ignored and considered fresh.\n     */\n    public function isFresh(): bool\n    {\n        if (!is_file($this->file)) {\n            return false;\n        }\n\n        if ($this->resourceCheckers instanceof \\Traversable && !$this->resourceCheckers instanceof \\Countable) {\n            $this->resourceCheckers = iterator_to_array($this->resourceCheckers);\n        }\n\n        if (!\\count($this->resourceCheckers)) {\n            return true; // shortcut - if we don't have any checkers we don't need to bother with the meta file at all\n        }\n\n        $metadata = $this->metaFile;\n\n        if (!is_file($metadata)) {\n            return false;\n        }\n\n        $meta = $this->safelyUnserialize($metadata);\n\n        if (false === $meta) {\n            return false;\n        }\n\n        $time = filemtime($this->file);\n\n        foreach ($meta as $resource) {\n            foreach ($this->resourceCheckers as $checker) {\n                if (!$checker->supports($resource)) {\n                    continue; // next checker\n                }\n                if ($checker->isFresh($resource, $time)) {\n                    break; // no need to further check this resource\n                }\n\n                return false; // cache is stale\n            }\n            // no suitable checker found, ignore this resource\n        }\n\n        return true;\n    }\n\n    /**\n     * Writes cache.\n     *\n     * @param string              $content  The content to write in the cache\n     * @param ResourceInterface[] $metadata An array of metadata\n     *\n     * @throws \\RuntimeException When cache file can't be written\n     */\n    public function write(string $content, ?array $metadata = null): void\n    {\n        $mode = 0666;\n        $umask = umask();\n        $filesystem = new Filesystem();\n        $filesystem->dumpFile($this->file, $content);\n        try {\n            $filesystem->chmod($this->file, $mode, $umask);\n        } catch (IOException) {\n            // discard chmod failure (some filesystem may not support it)\n        }\n\n        if (null !== $metadata) {\n            $filesystem->dumpFile($this->metaFile, $ser = serialize($metadata));\n            try {\n                $filesystem->chmod($this->metaFile, $mode, $umask);\n            } catch (IOException) {\n                // discard chmod failure (some filesystem may not support it)\n            }\n\n            $ser = preg_replace_callback('/;O:(\\d+):\"/', static fn ($m) => ';O:'.(9 + $m[1]).':\"Tracking\\\\', $ser);\n            $ser = preg_replace_callback('/s:(\\d+):\"\\0[^\\0]++\\0/', static fn ($m) => 's:'.($m[1] - \\strlen($m[0]) + 6).':\"', $ser);\n            $ser = unserialize($ser);\n            $ser = @json_encode($ser) ?: [];\n            $ser = str_replace('\"__PHP_Incomplete_Class_Name\":\"Tracking\\\\\\\\', '\"@type\":\"', $ser);\n            $ser = \\sprintf('{\"resources\":%s}', $ser);\n\n            $filesystem->dumpFile($this->metaFile.'.json', $ser);\n            try {\n                $filesystem->chmod($this->metaFile.'.json', $mode, $umask);\n            } catch (IOException) {\n                // discard chmod failure (some filesystem may not support it)\n            }\n        }\n\n        if (\\function_exists('opcache_invalidate') && filter_var(\\ini_get('opcache.enable'), \\FILTER_VALIDATE_BOOL)) {\n            @opcache_invalidate($this->file, true);\n        }\n    }\n\n    private function safelyUnserialize(string $file): mixed\n    {\n        $meta = false;\n        $content = (new Filesystem())->readFile($file);\n        $signalingException = new \\UnexpectedValueException();\n        $prevUnserializeHandler = ini_set('unserialize_callback_func', self::class.'::handleUnserializeCallback');\n        $prevErrorHandler = set_error_handler(function ($type, $msg, $file, $line, $context = []) use (&$prevErrorHandler, $signalingException) {\n            if (__FILE__ === $file && !\\in_array($type, [\\E_DEPRECATED, \\E_USER_DEPRECATED], true)) {\n                throw $signalingException;\n            }\n\n            return $prevErrorHandler ? $prevErrorHandler($type, $msg, $file, $line, $context) : false;\n        });\n\n        try {\n            $meta = unserialize($content);\n        } catch (\\Throwable $e) {\n            if ($e !== $signalingException) {\n                throw $e;\n            }\n        } finally {\n            restore_error_handler();\n            ini_set('unserialize_callback_func', $prevUnserializeHandler);\n        }\n\n        return $meta;\n    }\n\n    /**\n     * @internal\n     */\n    public static function handleUnserializeCallback(string $class): void\n    {\n        trigger_error('Class not found: '.$class);\n    }\n}\n"
        },
        {
          "name": "ResourceCheckerConfigCacheFactory.php",
          "type": "blob",
          "size": 0.9619140625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Config;\n\n/**\n * A ConfigCacheFactory implementation that validates the\n * cache with an arbitrary set of ResourceCheckers.\n *\n * @author Matthias Pigulla <mp@webfactory.de>\n */\nclass ResourceCheckerConfigCacheFactory implements ConfigCacheFactoryInterface\n{\n    /**\n     * @param iterable<int, ResourceCheckerInterface> $resourceCheckers\n     */\n    public function __construct(\n        private iterable $resourceCheckers = [],\n    ) {\n    }\n\n    public function cache(string $file, callable $callable): ConfigCacheInterface\n    {\n        $cache = new ResourceCheckerConfigCache($file, $this->resourceCheckers);\n        if (!$cache->isFresh()) {\n            $callable($cache);\n        }\n\n        return $cache;\n    }\n}\n"
        },
        {
          "name": "ResourceCheckerInterface.php",
          "type": "blob",
          "size": 1.16015625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Config;\n\nuse Symfony\\Component\\Config\\Resource\\ResourceInterface;\n\n/**\n * Interface for ResourceCheckers.\n *\n * When a ResourceCheckerConfigCache instance is checked for freshness, all its associated\n * metadata resources are passed to ResourceCheckers. The ResourceCheckers\n * can then inspect the resources and decide whether the cache can be considered\n * fresh or not.\n *\n * @author Matthias Pigulla <mp@webfactory.de>\n * @author Benjamin Klotz <bk@webfactory.de>\n */\ninterface ResourceCheckerInterface\n{\n    /**\n     * Queries the ResourceChecker whether it can validate a given\n     * resource or not.\n     */\n    public function supports(ResourceInterface $metadata): bool;\n\n    /**\n     * Validates the resource.\n     *\n     * @param int $timestamp The timestamp at which the cache associated with this resource was created\n     */\n    public function isFresh(ResourceInterface $resource, int $timestamp): bool;\n}\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "Util",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.1689453125,
          "content": "{\n    \"name\": \"symfony/config\",\n    \"type\": \"library\",\n    \"description\": \"Helps you find, load, combine, autofill and validate configuration values of any kind\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3\",\n        \"symfony/filesystem\": \"^7.1\",\n        \"symfony/polyfill-ctype\": \"~1.8\"\n    },\n    \"require-dev\": {\n        \"symfony/event-dispatcher\": \"^6.4|^7.0\",\n        \"symfony/finder\": \"^6.4|^7.0\",\n        \"symfony/messenger\": \"^6.4|^7.0\",\n        \"symfony/service-contracts\": \"^2.5|^3\",\n        \"symfony/yaml\": \"^6.4|^7.0\"\n    },\n    \"conflict\": {\n        \"symfony/finder\": \"<6.4\",\n        \"symfony/service-contracts\": \"<2.5\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Config\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.84375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Config Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Resources</directory>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}