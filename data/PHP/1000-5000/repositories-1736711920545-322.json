{
  "metadata": {
    "timestamp": 1736711920545,
    "page": 322,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/serializer",
      "stars": 2514,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "Annotation",
          "type": "tree",
          "content": null
        },
        {
          "name": "Attribute",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 17.3515625,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Deprecate the `csv_escape_char` context option of `CsvEncoder`, the `CsvEncoder::ESCAPE_CHAR_KEY` constant\n   and the `CsvEncoderContextBuilder::withEscapeChar()` method, following its deprecation in PHP 8.4\n * Add `SnakeCaseToCamelCaseNameConverter`\n * Support subclasses of `\\DateTime` and `\\DateTimeImmutable` for denormalization\n * Add the `UidNormalizer::NORMALIZATION_FORMAT_RFC9562` constant\n * Add support for configuring multiple serializer instances with different\n   default contexts, name converters, sets of normalizers and encoders\n * Add support for collection profiles of multiple serializer instances\n * Deprecate `AdvancedNameConverterInterface`, use `NameConverterInterface` instead\n\n7.1\n---\n\n * Add arguments `$class`, `$format` and `$context` to `NameConverterInterface::normalize()` and `NameConverterInterface::denormalize()`\n * Add `DateTimeNormalizer::CAST_KEY` context option\n * Add `AbstractNormalizer::FILTER_BOOL` context option\n * Add `CamelCaseToSnakeCaseNameConverter::REQUIRE_SNAKE_CASE_PROPERTIES` context option\n * Deprecate `AbstractNormalizerContextBuilder::withDefaultContructorArguments(?array $defaultContructorArguments)`, use `withDefaultConstructorArguments(?array $defaultConstructorArguments)` instead (note the missing `s` character in Contructor word in deprecated method)\n * Add `XmlEncoder::CDATA_WRAPPING_PATTERN` context option\n\n7.0\n---\n\n * Add method `getSupportedTypes()` to `DenormalizerInterface` and `NormalizerInterface`\n * Remove denormalization support for `AbstractUid` in `UidNormalizer`, use one of `AbstractUid` child class instead\n * Denormalizing to an abstract class in `UidNormalizer` now throws an `\\Error`\n * Remove `ContextAwareDenormalizerInterface`, use `DenormalizerInterface` instead\n * Remove `ContextAwareNormalizerInterface`, use `NormalizerInterface` instead\n * Remove `CacheableSupportsMethodInterface`, use `NormalizerInterface` and `DenormalizerInterface` instead\n * Require explicit argument when calling `AttributeMetadata::setSerializedName()` and `ClassMetadata::setClassDiscriminatorMapping()`\n * Add argument `$context` to `NormalizerInterface::supportsNormalization()` and `DenormalizerInterface::supportsDenormalization()`\n * Remove Doctrine annotations support in favor of native attributes\n * Remove `AnnotationLoader`, use `AttributeLoader` instead\n\n6.4\n---\n\n * Add `TranslatableNormalizer`\n * Allow `Context` attribute to target classes\n * Deprecate Doctrine annotations support in favor of native attributes\n * Allow the `Groups` attribute/annotation on classes\n * JsonDecode: Add `json_decode_detailed_errors` option\n * Make `ProblemNormalizer` give details about Messenger's `ValidationFailedException`\n * Add `XmlEncoder::CDATA_WRAPPING` context option\n * Deprecate `AnnotationLoader`, use `AttributeLoader` instead\n * Add aliases for all classes in the `Annotation` namespace to `Attribute`\n\n6.3\n---\n\n * Add `AbstractNormalizer::REQUIRE_ALL_PROPERTIES` context flag to require all properties to be listed in the input instead of falling back to null for nullable ones\n * Add `XmlEncoder::SAVE_OPTIONS` context option\n * Add `BackedEnumNormalizer::ALLOW_INVALID_VALUES` context option\n * Add `UnsupportedFormatException` which is thrown when there is no decoder for a given format\n * Add method `getSupportedTypes(?string $format)` to `NormalizerInterface` and `DenormalizerInterface`\n * Make `ProblemNormalizer` give details about `ValidationFailedException` and `PartialDenormalizationException`\n * Deprecate `CacheableSupportsMethodInterface` in favor of the new `getSupportedTypes(?string $format)` methods\n * The following Normalizer classes will become final in 7.0:\n   * `ConstraintViolationListNormalizer`\n   * `CustomNormalizer`\n   * `DataUriNormalizer`\n   * `DateIntervalNormalizer`\n   * `DateTimeNormalizer`\n   * `DateTimeZoneNormalizer`\n   * `GetSetMethodNormalizer`\n   * `JsonSerializableNormalizer`\n   * `ObjectNormalizer`\n   * `PropertyNormalizer`\n\n6.2\n---\n\n * Add support for constructor promoted properties to `Context` attribute\n * Add context option `PropertyNormalizer::NORMALIZE_VISIBILITY` with bitmask flags `PropertyNormalizer::NORMALIZE_PUBLIC`, `PropertyNormalizer::NORMALIZE_PROTECTED`, `PropertyNormalizer::NORMALIZE_PRIVATE`\n * Add method `withNormalizeVisibility` to `PropertyNormalizerContextBuilder`\n * Deprecate calling `AttributeMetadata::setSerializedName()`, `ClassMetadata::setClassDiscriminatorMapping()` without arguments\n * Change the signature of `AttributeMetadataInterface::setSerializedName()` to `setSerializedName(?string)`\n * Change the signature of `ClassMetadataInterface::setClassDiscriminatorMapping()` to `setClassDiscriminatorMapping(?ClassDiscriminatorMapping)`\n * Add option YamlEncoder::YAML_INDENTATION to YamlEncoder constructor options to configure additional indentation for each level of nesting. This allows configuring indentation in the service configuration.\n * Add `SerializedPath` annotation to flatten nested attributes\n\n6.1\n---\n\n * Add `TraceableSerializer`, `TraceableNormalizer`, `TraceableEncoder` and `SerializerDataCollector` to integrate with the web profiler\n * Add the ability to create contexts using context builders\n * Set `Context` annotation as not final\n * Deprecate `ContextAwareNormalizerInterface`, use `NormalizerInterface` instead\n * Deprecate `ContextAwareDenormalizerInterface`, use `DenormalizerInterface` instead\n * Deprecate supporting denormalization for `AbstractUid` in `UidNormalizer`, use one of `AbstractUid` child class instead\n * Deprecate denormalizing to an abstract class in `UidNormalizer`\n * Add support for `can*()` methods to `ObjectNormalizer`\n\n6.0\n---\n\n * Remove `ArrayDenormalizer::setSerializer()`, call `setDenormalizer()` instead\n * Remove the ability to create instances of the annotation classes by passing an array of parameters, use named arguments instead\n\n5.4\n---\n\n * Add support of PHP backed enumerations\n * Add support for serializing empty array as object\n * Return empty collections as `ArrayObject` from `Serializer::normalize()` when `PRESERVE_EMPTY_OBJECTS` is set\n * Add support for collecting type errors during denormalization\n * Add missing arguments in `MissingConstructorArgumentsException`\n\n5.3\n---\n\n * Add the ability to provide (de)normalization context using metadata (e.g. `@Symfony\\Component\\Serializer\\Annotation\\Context`)\n * Deprecate `ArrayDenormalizer::setSerializer()`, call `setDenormalizer()` instead\n * Add normalization formats to `UidNormalizer`\n * Add `CsvEncoder::END_OF_LINE` context option\n * Deprecate creating instances of the annotation classes by passing an array of parameters, use named arguments instead\n\n5.2.0\n-----\n\n * added `CompiledClassMetadataFactory` and `ClassMetadataFactoryCompiler` for faster metadata loading.\n * added `UidNormalizer`\n * added `FormErrorNormalizer`\n * added `MimeMessageNormalizer`\n * serializer mapping can be configured using php attributes\n\n5.1.0\n-----\n\n * added support for scalar values denormalization\n * added support for `\\stdClass` to `ObjectNormalizer`\n * added the ability to ignore properties using metadata (e.g. `@Symfony\\Component\\Serializer\\Annotation\\Ignore`)\n * added an option to serialize constraint violations payloads (e.g. severity)\n\n5.0.0\n-----\n\n * throw an exception when creating a `Serializer` with normalizers which neither implement `NormalizerInterface` nor `DenormalizerInterface`\n * throw an exception when creating a `Serializer` with encoders which neither implement `EncoderInterface` nor `DecoderInterface`\n * changed the default value of the `CsvEncoder` \"as_collection\" option to `true`\n * removed `AbstractNormalizer::$circularReferenceLimit`, `AbstractNormalizer::$circularReferenceHandler`,\n   `AbstractNormalizer::$callbacks`, `AbstractNormalizer::$ignoredAttributes`,\n   `AbstractNormalizer::$camelizedAttributes`, `AbstractNormalizer::setCircularReferenceLimit()`,\n   `AbstractNormalizer::setCircularReferenceHandler()`, `AbstractNormalizer::setCallbacks()` and\n   `AbstractNormalizer::setIgnoredAttributes()`, use the default context instead.\n * removed `AbstractObjectNormalizer::$maxDepthHandler` and `AbstractObjectNormalizer::setMaxDepthHandler()`,\n   use the default context instead.\n * removed `XmlEncoder::setRootNodeName()` & `XmlEncoder::getRootNodeName()`, use the default context instead.\n * removed individual encoders/normalizers options as constructor arguments.\n * removed support for instantiating a `DataUriNormalizer` with a default MIME type guesser when the `symfony/mime` component isn't installed.\n * removed the `XmlEncoder::TYPE_CASE_ATTRIBUTES` constant. Use `XmlEncoder::TYPE_CAST_ATTRIBUTES` instead.\n\n4.4.0\n-----\n\n * deprecated the `XmlEncoder::TYPE_CASE_ATTRIBUTES` constant, use `XmlEncoder::TYPE_CAST_ATTRIBUTES` instead\n * added option to output a UTF-8 BOM in CSV encoder via `CsvEncoder::OUTPUT_UTF8_BOM_KEY` context option\n * added `ProblemNormalizer` to normalize errors according to the API Problem spec (RFC 7807)\n\n4.3.0\n-----\n\n * added the list of constraint violations' parameters in `ConstraintViolationListNormalizer`\n * added support for serializing `DateTimeZone` objects\n * added a `deep_object_to_populate` context option to recursive denormalize on `object_to_populate` object.\n\n4.2.0\n-----\n\n * using the default context is the new recommended way to configure normalizers and encoders\n * added a `skip_null_values` context option to not serialize properties with a `null` values\n * `AbstractNormalizer::handleCircularReference` is now final and receives\n   two optional extra arguments: the format and the context\n * added support for XML comment encoding (encoding `['#comment' => ' foo ']` results `<!-- foo -->`)\n * added optional `int[] $encoderIgnoredNodeTypes` argument to `XmlEncoder::__construct`\n   to configure node types to be ignored during encoding\n * added `AdvancedNameConverterInterface` to access the class,\n   the format and the context in a name converter\n * the `AbstractNormalizer::handleCircularReference()` method will have two new `$format`\n   and `$context` arguments in version 5.0, not defining them is deprecated\n * deprecated creating a `Serializer` with normalizers which do not implement\n   either `NormalizerInterface` or `DenormalizerInterface`\n * deprecated creating a `Serializer` with normalizers which do not implement\n   either `NormalizerInterface` or `DenormalizerInterface`\n * deprecated creating a `Serializer` with encoders which do not implement\n   either `EncoderInterface` or `DecoderInterface`\n * added the optional `$objectClassResolver` argument in `AbstractObjectNormalizer`\n   and `ObjectNormalizer` constructor\n * added `MetadataAwareNameConverter` to configure the serialized name of properties through metadata\n * `YamlEncoder` now handles the `.yml` extension too\n * `AbstractNormalizer::$circularReferenceLimit`, `AbstractNormalizer::$circularReferenceHandler`,\n   `AbstractNormalizer::$callbacks`, `AbstractNormalizer::$ignoredAttributes`,\n   `AbstractNormalizer::$camelizedAttributes`, `AbstractNormalizer::setCircularReferenceLimit()`,\n   `AbstractNormalizer::setCircularReferenceHandler()`, `AbstractNormalizer::setCallbacks()` and\n   `AbstractNormalizer::setIgnoredAttributes()` are deprecated, use the default context instead.\n * `AbstractObjectNormalizer::$maxDepthHandler` and `AbstractObjectNormalizer::setMaxDepthHandler()`\n   are deprecated, use the default context instead.\n * passing configuration options directly to the constructor of `CsvEncoder`, `JsonDecode` and\n   `XmlEncoder` is deprecated since Symfony 4.2, use the default context instead.\n\n4.1.0\n-----\n\n * added `CacheableSupportsMethodInterface` for normalizers and denormalizers that use\n   only the type and the format in their `supports*()` methods\n * added `MissingConstructorArgumentsException` new exception for deserialization failure\n   of objects that needs data insertion in constructor\n * added an optional `default_constructor_arguments` option of context to specify a default data in\n   case the object is not initializable by its constructor because of data missing\n * added optional `bool $escapeFormulas = false` argument to `CsvEncoder::__construct`\n * added `AbstractObjectNormalizer::setMaxDepthHandler` to set a handler to call when the configured\n   maximum depth is reached\n * added optional `int[] $ignoredNodeTypes` argument to `XmlEncoder::__construct`. XML decoding now\n   ignores comment node types by default.\n * added `ConstraintViolationListNormalizer`\n\n4.0.0\n-----\n\n * removed the `SerializerAwareEncoder` and `SerializerAwareNormalizer` classes,\n   use the `SerializerAwareTrait` instead\n * removed the `Serializer::$normalizerCache` and `Serializer::$denormalizerCache`\n   properties\n * added an optional `string $format = null` argument to `AbstractNormalizer::instantiateObject`\n * added an optional `array $context = []` to `Serializer::supportsNormalization`, `Serializer::supportsDenormalization`,\n   `Serializer::supportsEncoding` and `Serializer::supportsDecoding`\n\n3.4.0\n-----\n\n * added `AbstractObjectNormalizer::DISABLE_TYPE_ENFORCEMENT` context option\n   to disable throwing an `UnexpectedValueException` on a type mismatch\n * added support for serializing `DateInterval` objects\n * added getter for extra attributes in `ExtraAttributesException`\n * improved `CsvEncoder` to handle variable nested structures\n * CSV headers can be passed to the `CsvEncoder` via the `csv_headers` serialization context variable\n * added `$context` when checking for encoding, decoding and normalizing in `Serializer`\n\n3.3.0\n-----\n\n * added `SerializerPass`\n\n3.1.0\n-----\n\n * added support for serializing objects that implement `JsonSerializable`\n * added the `DenormalizerAwareTrait` and `NormalizerAwareTrait` traits to\n   support normalizer/denormalizer awareness\n * added the `DenormalizerAwareInterface` and `NormalizerAwareInterface`\n   interfaces to support normalizer/denormalizer awareness\n * added a PSR-6 compatible adapter for caching metadata\n * added a `MaxDepth` option to limit the depth of the object graph when\n   serializing objects\n * added support for serializing `SplFileInfo` objects\n * added support for serializing objects that implement `DateTimeInterface`\n * added `AbstractObjectNormalizer` as a base class for normalizers that deal\n   with objects\n * added support to relation deserialization\n\n2.7.0\n-----\n\n * added support for serialization and deserialization groups including\n   annotations, XML and YAML mapping.\n * added `AbstractNormalizer` to factorise code and ease normalizers development\n * added circular references handling for `PropertyNormalizer`\n * added support for a context key called `object_to_populate` in `AbstractNormalizer`\n   to reuse existing objects in the deserialization process\n * added `NameConverterInterface` and `CamelCaseToSnakeCaseNameConverter`\n * [DEPRECATION] `GetSetMethodNormalizer::setCamelizedAttributes()` and\n   `PropertyNormalizer::setCamelizedAttributes()` are replaced by\n   `CamelCaseToSnakeCaseNameConverter`\n * [DEPRECATION] the `Exception` interface has been renamed to `ExceptionInterface`\n * added `ObjectNormalizer` leveraging the `PropertyAccess` component to normalize\n   objects containing both properties and getters / setters / issers / hassers methods.\n * added `xml_type_cast_attributes` context option for allowing users to opt-out of typecasting\n   xml attributes.\n\n2.6.0\n-----\n\n * added a new serializer: `PropertyNormalizer`. Like `GetSetMethodNormalizer`,\n   this normalizer will map an object's properties to an array.\n * added circular references handling for `GetSetMethodNormalizer`\n\n2.5.0\n-----\n\n * added support for `is.*` getters in `GetSetMethodNormalizer`\n\n2.4.0\n-----\n\n * added `$context` support for XMLEncoder.\n * [DEPRECATION] JsonEncode and JsonDecode where modified to throw\n   an exception if error found. No need for `get*Error()` functions\n\n2.3.0\n-----\n\n * added `GetSetMethodNormalizer::setCamelizedAttributes` to allow calling\n   camel cased methods for underscored properties\n\n2.2.0\n-----\n\n * [BC BREAK] All Serializer, Normalizer and Encoder interfaces have been\n   modified to include an optional `$context` array parameter.\n * The XML Root name can now be configured with the `xml_root_name`\n   parameter in the context option to the `XmlEncoder`.\n * Options to `json_encode` and `json_decode` can be passed through\n   the context options of `JsonEncode` and `JsonDecode` encoder/decoders.\n\n2.1.0\n-----\n\n * added DecoderInterface::supportsDecoding(),\n   EncoderInterface::supportsEncoding()\n * removed NormalizableInterface::denormalize(),\n   NormalizerInterface::denormalize(),\n   NormalizerInterface::supportsDenormalization()\n * removed normalize() denormalize() encode() decode() supportsSerialization()\n   supportsDeserialization() supportsEncoding() supportsDecoding()\n   getEncoder() from SerializerInterface\n * Serializer now implements NormalizerInterface, DenormalizerInterface,\n   EncoderInterface, DecoderInterface in addition to SerializerInterface\n * added DenormalizableInterface and DenormalizerInterface\n * [BC BREAK] changed `GetSetMethodNormalizer`'s key names from all lowercased\n   to camelCased (e.g. `mypropertyvalue` to `myPropertyValue`)\n * [BC BREAK] convert the `item` XML tag to an array\n\n    ``` xml\n    <?xml version=\"1.0\"?>\n    <response>\n        <item><title><![CDATA[title1]]></title></item><item><title><![CDATA[title2]]></title></item>\n    </response>\n    ```\n\n    Before:\n\n        Array()\n\n    After:\n\n        Array(\n            [item] => Array(\n                [0] => Array(\n                    [title] => title1\n                )\n                [1] => Array(\n                    [title] => title2\n                )\n            )\n        )\n"
        },
        {
          "name": "CacheWarmer",
          "type": "tree",
          "content": null
        },
        {
          "name": "Command",
          "type": "tree",
          "content": null
        },
        {
          "name": "Context",
          "type": "tree",
          "content": null
        },
        {
          "name": "DataCollector",
          "type": "tree",
          "content": null
        },
        {
          "name": "Debug",
          "type": "tree",
          "content": null
        },
        {
          "name": "DependencyInjection",
          "type": "tree",
          "content": null
        },
        {
          "name": "Encoder",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Extractor",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Mapping",
          "type": "tree",
          "content": null
        },
        {
          "name": "NameConverter",
          "type": "tree",
          "content": null
        },
        {
          "name": "Normalizer",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.572265625,
          "content": "Serializer Component\n====================\n\nThe Serializer component handles serializing and deserializing data structures,\nincluding object graphs, into array structures or other formats like XML and\nJSON.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/serializer.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Serializer.php",
          "type": "blob",
          "size": 15.77734375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Serializer;\n\nuse Symfony\\Component\\Serializer\\Encoder\\ChainDecoder;\nuse Symfony\\Component\\Serializer\\Encoder\\ChainEncoder;\nuse Symfony\\Component\\Serializer\\Encoder\\ContextAwareDecoderInterface;\nuse Symfony\\Component\\Serializer\\Encoder\\ContextAwareEncoderInterface;\nuse Symfony\\Component\\Serializer\\Encoder\\DecoderInterface;\nuse Symfony\\Component\\Serializer\\Encoder\\EncoderInterface;\nuse Symfony\\Component\\Serializer\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Serializer\\Exception\\LogicException;\nuse Symfony\\Component\\Serializer\\Exception\\NotNormalizableValueException;\nuse Symfony\\Component\\Serializer\\Exception\\PartialDenormalizationException;\nuse Symfony\\Component\\Serializer\\Exception\\UnsupportedFormatException;\nuse Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer;\nuse Symfony\\Component\\Serializer\\Normalizer\\DenormalizerAwareInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\NormalizerAwareInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface;\n\n/**\n * Serializer serializes and deserializes data.\n *\n * objects are turned into arrays by normalizers.\n * arrays are turned into various output formats by encoders.\n *\n *     $serializer->serialize($obj, 'xml')\n *     $serializer->decode($data, 'xml')\n *     $serializer->denormalize($data, 'Class', 'xml')\n *\n * @author Jordi Boggiano <j.boggiano@seld.be>\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n * @author Lukas Kahwe Smith <smith@pooteeweet.org>\n * @author Kévin Dunglas <dunglas@gmail.com>\n */\nclass Serializer implements SerializerInterface, NormalizerInterface, DenormalizerInterface, ContextAwareEncoderInterface, ContextAwareDecoderInterface\n{\n    /**\n     * Flag to control whether an empty array should be transformed to an\n     * object (in JSON: {}) or to a list (in JSON: []).\n     */\n    public const EMPTY_ARRAY_AS_OBJECT = 'empty_array_as_object';\n\n    private const SCALAR_TYPES = [\n        'int' => true,\n        'bool' => true,\n        'float' => true,\n        'string' => true,\n    ];\n\n    protected ChainEncoder $encoder;\n\n    protected ChainDecoder $decoder;\n\n    /**\n     * @var array<string, array<string, array<bool>>>\n     */\n    private array $denormalizerCache = [];\n\n    /**\n     * @var array<string, array<string, array<bool>>>\n     */\n    private array $normalizerCache = [];\n\n    /**\n     * @param array<NormalizerInterface|DenormalizerInterface> $normalizers\n     * @param array<EncoderInterface|DecoderInterface>         $encoders\n     */\n    public function __construct(\n        private array $normalizers = [],\n        array $encoders = [],\n    ) {\n        foreach ($normalizers as $normalizer) {\n            if ($normalizer instanceof SerializerAwareInterface) {\n                $normalizer->setSerializer($this);\n            }\n\n            if ($normalizer instanceof DenormalizerAwareInterface) {\n                $normalizer->setDenormalizer($this);\n            }\n\n            if ($normalizer instanceof NormalizerAwareInterface) {\n                $normalizer->setNormalizer($this);\n            }\n\n            if (!($normalizer instanceof NormalizerInterface || $normalizer instanceof DenormalizerInterface)) {\n                throw new InvalidArgumentException(\\sprintf('The class \"%s\" neither implements \"%s\" nor \"%s\".', get_debug_type($normalizer), NormalizerInterface::class, DenormalizerInterface::class));\n            }\n        }\n\n        $decoders = [];\n        $realEncoders = [];\n        foreach ($encoders as $encoder) {\n            if ($encoder instanceof SerializerAwareInterface) {\n                $encoder->setSerializer($this);\n            }\n            if ($encoder instanceof DecoderInterface) {\n                $decoders[] = $encoder;\n            }\n            if ($encoder instanceof EncoderInterface) {\n                $realEncoders[] = $encoder;\n            }\n\n            if (!($encoder instanceof EncoderInterface || $encoder instanceof DecoderInterface)) {\n                throw new InvalidArgumentException(\\sprintf('The class \"%s\" neither implements \"%s\" nor \"%s\".', get_debug_type($encoder), EncoderInterface::class, DecoderInterface::class));\n            }\n        }\n        $this->encoder = new ChainEncoder($realEncoders);\n        $this->decoder = new ChainDecoder($decoders);\n    }\n\n    final public function serialize(mixed $data, string $format, array $context = []): string\n    {\n        if (!$this->supportsEncoding($format, $context)) {\n            throw new UnsupportedFormatException(\\sprintf('Serialization for the format \"%s\" is not supported.', $format));\n        }\n\n        if ($this->encoder->needsNormalization($format, $context)) {\n            $data = $this->normalize($data, $format, $context);\n        }\n\n        return $this->encode($data, $format, $context);\n    }\n\n    final public function deserialize(mixed $data, string $type, string $format, array $context = []): mixed\n    {\n        if (!$this->supportsDecoding($format, $context)) {\n            throw new UnsupportedFormatException(\\sprintf('Deserialization for the format \"%s\" is not supported.', $format));\n        }\n\n        $data = $this->decode($data, $format, $context);\n\n        return $this->denormalize($data, $type, $format, $context);\n    }\n\n    public function normalize(mixed $data, ?string $format = null, array $context = []): array|string|int|float|bool|\\ArrayObject|null\n    {\n        // If a normalizer supports the given data, use it\n        if ($normalizer = $this->getNormalizer($data, $format, $context)) {\n            return $normalizer->normalize($data, $format, $context);\n        }\n\n        if (null === $data || \\is_scalar($data)) {\n            return $data;\n        }\n\n        if (\\is_array($data) && !$data && ($context[self::EMPTY_ARRAY_AS_OBJECT] ?? false)) {\n            return new \\ArrayObject();\n        }\n\n        if (is_iterable($data)) {\n            if ($data instanceof \\Countable && ($context[AbstractObjectNormalizer::PRESERVE_EMPTY_OBJECTS] ?? false) && !\\count($data)) {\n                return new \\ArrayObject();\n            }\n\n            $normalized = [];\n            foreach ($data as $key => $val) {\n                $normalized[$key] = $this->normalize($val, $format, $context);\n            }\n\n            return $normalized;\n        }\n\n        if (\\is_object($data)) {\n            if (!$this->normalizers) {\n                throw new LogicException('You must register at least one normalizer to be able to normalize objects.');\n            }\n\n            throw new NotNormalizableValueException(\\sprintf('Could not normalize object of type \"%s\", no supporting normalizer found.', get_debug_type($data)));\n        }\n\n        throw new NotNormalizableValueException('An unexpected value could not be normalized: '.(!\\is_resource($data) ? var_export($data, true) : \\sprintf('\"%s\" resource', get_resource_type($data))));\n    }\n\n    /**\n     * @throws NotNormalizableValueException\n     * @throws PartialDenormalizationException Occurs when one or more properties of $type fails to denormalize\n     */\n    public function denormalize(mixed $data, string $type, ?string $format = null, array $context = []): mixed\n    {\n        if (isset($context[DenormalizerInterface::COLLECT_DENORMALIZATION_ERRORS], $context['not_normalizable_value_exceptions'])) {\n            throw new LogicException('Passing a value for \"not_normalizable_value_exceptions\" context key is not allowed.');\n        }\n\n        $normalizer = $this->getDenormalizer($data, $type, $format, $context);\n\n        // Check for a denormalizer first, e.g. the data is wrapped\n        if (!$normalizer && isset(self::SCALAR_TYPES[$type])) {\n            if (!('is_'.$type)($data)) {\n                throw NotNormalizableValueException::createForUnexpectedDataType(\\sprintf('Data expected to be of type \"%s\" (\"%s\" given).', $type, get_debug_type($data)), $data, [$type], $context['deserialization_path'] ?? null, true);\n            }\n\n            return $data;\n        }\n\n        if (!$this->normalizers) {\n            throw new LogicException('You must register at least one normalizer to be able to denormalize objects.');\n        }\n\n        if (!$normalizer) {\n            throw new NotNormalizableValueException(\\sprintf('Could not denormalize object of type \"%s\", no supporting normalizer found.', $type));\n        }\n\n        if (isset($context[DenormalizerInterface::COLLECT_DENORMALIZATION_ERRORS])) {\n            unset($context[DenormalizerInterface::COLLECT_DENORMALIZATION_ERRORS]);\n            $context['not_normalizable_value_exceptions'] = [];\n            $errors = &$context['not_normalizable_value_exceptions'];\n            $denormalized = $normalizer->denormalize($data, $type, $format, $context);\n\n            if ($errors) {\n                // merge errors so that one path has only one error\n                $uniqueErrors = [];\n                foreach ($errors as $error) {\n                    if (null === $error->getPath()) {\n                        $uniqueErrors[] = $error;\n                        continue;\n                    }\n\n                    $uniqueErrors[$error->getPath()] = $uniqueErrors[$error->getPath()] ?? $error;\n                }\n\n                throw new PartialDenormalizationException($denormalized, array_values($uniqueErrors));\n            }\n\n            return $denormalized;\n        }\n\n        return $normalizer->denormalize($data, $type, $format, $context);\n    }\n\n    public function getSupportedTypes(?string $format): array\n    {\n        return ['*' => false];\n    }\n\n    public function supportsNormalization(mixed $data, ?string $format = null, array $context = []): bool\n    {\n        return null !== $this->getNormalizer($data, $format, $context);\n    }\n\n    public function supportsDenormalization(mixed $data, string $type, ?string $format = null, array $context = []): bool\n    {\n        return isset(self::SCALAR_TYPES[$type]) || null !== $this->getDenormalizer($data, $type, $format, $context);\n    }\n\n    /**\n     * Returns a matching normalizer.\n     *\n     * @param mixed       $data    Data to get the serializer for\n     * @param string|null $format  Format name, present to give the option to normalizers to act differently based on formats\n     * @param array       $context Options available to the normalizer\n     */\n    private function getNormalizer(mixed $data, ?string $format, array $context): ?NormalizerInterface\n    {\n        if (\\is_object($data)) {\n            $type = $data::class;\n            $genericType = 'object';\n        } else {\n            $type = 'native-'.\\gettype($data);\n            $genericType = '*';\n        }\n\n        if (!isset($this->normalizerCache[$format][$type])) {\n            $this->normalizerCache[$format][$type] = [];\n\n            foreach ($this->normalizers as $k => $normalizer) {\n                if (!$normalizer instanceof NormalizerInterface) {\n                    continue;\n                }\n\n                $supportedTypes = $normalizer->getSupportedTypes($format);\n\n                foreach ($supportedTypes as $supportedType => $isCacheable) {\n                    if (\\in_array($supportedType, ['*', 'object'], true)\n                        || $type !== $supportedType && ('object' !== $genericType || !is_subclass_of($type, $supportedType))\n                    ) {\n                        continue;\n                    }\n\n                    if (null === $isCacheable) {\n                        unset($supportedTypes['*'], $supportedTypes['object']);\n                    } elseif ($this->normalizerCache[$format][$type][$k] = $isCacheable && $normalizer->supportsNormalization($data, $format, $context)) {\n                        break 2;\n                    }\n\n                    break;\n                }\n\n                if (null === $isCacheable = $supportedTypes[\\array_key_exists($genericType, $supportedTypes) ? $genericType : '*'] ?? null) {\n                    continue;\n                }\n\n                if ($this->normalizerCache[$format][$type][$k] ??= $isCacheable && $normalizer->supportsNormalization($data, $format, $context)) {\n                    break;\n                }\n            }\n        }\n\n        foreach ($this->normalizerCache[$format][$type] as $k => $cached) {\n            $normalizer = $this->normalizers[$k];\n            if ($cached || $normalizer->supportsNormalization($data, $format, $context)) {\n                return $normalizer;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns a matching denormalizer.\n     *\n     * @param mixed       $data    Data to restore\n     * @param string      $class   The expected class to instantiate\n     * @param string|null $format  Format name, present to give the option to normalizers to act differently based on formats\n     * @param array       $context Options available to the denormalizer\n     */\n    private function getDenormalizer(mixed $data, string $class, ?string $format, array $context): ?DenormalizerInterface\n    {\n        if (!isset($this->denormalizerCache[$format][$class])) {\n            $this->denormalizerCache[$format][$class] = [];\n            $genericType = class_exists($class) || interface_exists($class, false) ? 'object' : '*';\n\n            foreach ($this->normalizers as $k => $normalizer) {\n                if (!$normalizer instanceof DenormalizerInterface) {\n                    continue;\n                }\n\n                $supportedTypes = $normalizer->getSupportedTypes($format);\n\n                $doesClassRepresentCollection = str_ends_with($class, '[]');\n\n                foreach ($supportedTypes as $supportedType => $isCacheable) {\n                    if (\\in_array($supportedType, ['*', 'object'], true)\n                        || $class !== $supportedType && ('object' !== $genericType || !is_subclass_of($class, $supportedType))\n                        && !($doesClassRepresentCollection && str_ends_with($supportedType, '[]') && is_subclass_of(strstr($class, '[]', true), strstr($supportedType, '[]', true)))\n                    ) {\n                        continue;\n                    }\n\n                    if (null === $isCacheable) {\n                        unset($supportedTypes['*'], $supportedTypes['object']);\n                    } elseif ($this->denormalizerCache[$format][$class][$k] = $isCacheable && $normalizer->supportsDenormalization(null, $class, $format, $context)) {\n                        break 2;\n                    }\n\n                    break;\n                }\n\n                if (null === $isCacheable = $supportedTypes[\\array_key_exists($genericType, $supportedTypes) ? $genericType : '*'] ?? null) {\n                    continue;\n                }\n\n                if ($this->denormalizerCache[$format][$class][$k] ??= $isCacheable && $normalizer->supportsDenormalization(null, $class, $format, $context)) {\n                    break;\n                }\n            }\n        }\n\n        foreach ($this->denormalizerCache[$format][$class] as $k => $cached) {\n            $normalizer = $this->normalizers[$k];\n            if ($cached || $normalizer->supportsDenormalization($data, $class, $format, $context)) {\n                return $normalizer;\n            }\n        }\n\n        return null;\n    }\n\n    final public function encode(mixed $data, string $format, array $context = []): string\n    {\n        return $this->encoder->encode($data, $format, $context);\n    }\n\n    final public function decode(string $data, string $format, array $context = []): mixed\n    {\n        return $this->decoder->decode($data, $format, $context);\n    }\n\n    public function supportsEncoding(string $format, array $context = []): bool\n    {\n        return $this->encoder->supportsEncoding($format, $context);\n    }\n\n    public function supportsDecoding(string $format, array $context = []): bool\n    {\n        return $this->decoder->supportsDecoding($format, $context);\n    }\n}\n"
        },
        {
          "name": "SerializerAwareInterface.php",
          "type": "blob",
          "size": 0.4931640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Serializer;\n\n/**\n * @author Jordi Boggiano <j.boggiano@seld.be>\n */\ninterface SerializerAwareInterface\n{\n    /**\n     * Sets the owning Serializer object.\n     */\n    public function setSerializer(SerializerInterface $serializer): void;\n}\n"
        },
        {
          "name": "SerializerAwareTrait.php",
          "type": "blob",
          "size": 0.5322265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Serializer;\n\n/**\n * @author Joel Wurtz <joel.wurtz@gmail.com>\n */\ntrait SerializerAwareTrait\n{\n    protected ?SerializerInterface $serializer = null;\n\n    public function setSerializer(SerializerInterface $serializer): void\n    {\n        $this->serializer = $serializer;\n    }\n}\n"
        },
        {
          "name": "SerializerInterface.php",
          "type": "blob",
          "size": 1.107421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Serializer;\n\n/**\n * @author Jordi Boggiano <j.boggiano@seld.be>\n */\ninterface SerializerInterface\n{\n    /**\n     * Serializes data in the appropriate format.\n     *\n     * @param array<string, mixed> $context Options normalizers/encoders have access to\n     */\n    public function serialize(mixed $data, string $format, array $context = []): string;\n\n    /**\n     * Deserializes data into the given type.\n     *\n     * @template TObject of object\n     * @template TType of string|class-string<TObject>\n     *\n     * @param TType                $type\n     * @param array<string, mixed> $context\n     *\n     * @psalm-return (TType is class-string<TObject> ? TObject : mixed)\n     *\n     * @phpstan-return ($type is class-string<TObject> ? TObject : mixed)\n     */\n    public function deserialize(mixed $data, string $type, string $format, array $context = []): mixed;\n}\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 2.19921875,
          "content": "{\n    \"name\": \"symfony/serializer\",\n    \"type\": \"library\",\n    \"description\": \"Handles serializing and deserializing data structures, including object graphs, into array structures or other formats like XML and JSON.\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3\",\n        \"symfony/polyfill-ctype\": \"~1.8\"\n    },\n    \"require-dev\": {\n        \"phpdocumentor/reflection-docblock\": \"^3.2|^4.0|^5.0\",\n        \"phpstan/phpdoc-parser\": \"^1.0|^2.0\",\n        \"seld/jsonlint\": \"^1.10\",\n        \"symfony/cache\": \"^6.4|^7.0\",\n        \"symfony/config\": \"^6.4|^7.0\",\n        \"symfony/console\": \"^6.4|^7.0\",\n        \"symfony/dependency-injection\": \"^7.2\",\n        \"symfony/error-handler\": \"^6.4|^7.0\",\n        \"symfony/filesystem\": \"^6.4|^7.0\",\n        \"symfony/form\": \"^6.4|^7.0\",\n        \"symfony/http-foundation\": \"^6.4|^7.0\",\n        \"symfony/http-kernel\": \"^6.4|^7.0\",\n        \"symfony/messenger\": \"^6.4|^7.0\",\n        \"symfony/mime\": \"^6.4|^7.0\",\n        \"symfony/property-access\": \"^6.4|^7.0\",\n        \"symfony/property-info\": \"^6.4|^7.0\",\n        \"symfony/translation-contracts\": \"^2.5|^3\",\n        \"symfony/type-info\": \"^7.1\",\n        \"symfony/uid\": \"^6.4|^7.0\",\n        \"symfony/validator\": \"^6.4|^7.0\",\n        \"symfony/var-dumper\": \"^6.4|^7.0\",\n        \"symfony/var-exporter\": \"^6.4|^7.0\",\n        \"symfony/yaml\": \"^6.4|^7.0\"\n    },\n    \"conflict\": {\n        \"phpdocumentor/reflection-docblock\": \"<3.2.2\",\n        \"phpdocumentor/type-resolver\": \"<1.4.0\",\n        \"symfony/dependency-injection\": \"<6.4\",\n        \"symfony/property-access\": \"<6.4\",\n        \"symfony/property-info\": \"<6.4\",\n        \"symfony/uid\": \"<6.4\",\n        \"symfony/validator\": \"<6.4\",\n        \"symfony/yaml\": \"<6.4\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Serializer\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.8017578125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Serializer Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}