{
  "metadata": {
    "timestamp": 1736711970866,
    "page": 432,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nette/php-generator",
      "stars": 2147,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.19140625,
          "content": ".gitattributes export-ignore\n.gitignore export-ignore\n.github export-ignore\nncs.* export-ignore\nphpstan*.neon export-ignore\ntests/ export-ignore\n\n*.sh eol=lf\n*.php* diff=php linguist-language=PHP\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0224609375,
          "content": "/vendor\n/composer.lock\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.0361328125,
          "content": "{\n\t\"name\": \"nette/php-generator\",\n\t\"description\": \"üêò Nette PHP Generator: generates neat PHP code for you. Supports new PHP 8.4 features.\",\n\t\"keywords\": [\"nette\", \"php\", \"code\", \"scaffolding\"],\n\t\"homepage\": \"https://nette.org\",\n\t\"license\": [\"BSD-3-Clause\", \"GPL-2.0-only\", \"GPL-3.0-only\"],\n\t\"authors\": [\n\t\t{\n\t\t\t\"name\": \"David Grudl\",\n\t\t\t\"homepage\": \"https://davidgrudl.com\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"Nette Community\",\n\t\t\t\"homepage\": \"https://nette.org/contributors\"\n\t\t}\n\t],\n\t\"require\": {\n\t\t\"php\": \"8.0 - 8.4\",\n\t\t\"nette/utils\": \"^3.2.9 || ^4.0\"\n\t},\n\t\"require-dev\": {\n\t\t\"nette/tester\": \"^2.4\",\n\t\t\"nikic/php-parser\": \"^4.18 || ^5.0\",\n\t\t\"tracy/tracy\": \"^2.8\",\n\t\t\"phpstan/phpstan\": \"^1.0\",\n\t\t\"jetbrains/phpstorm-attributes\": \"dev-master\"\n\t},\n\t\"suggest\": {\n\t\t\"nikic/php-parser\": \"to use ClassType::from(withBodies: true) & ClassType::fromCode()\"\n\t},\n\t\"autoload\": {\n\t\t\"classmap\": [\"src/\"]\n\t},\n\t\"minimum-stability\": \"dev\",\n\t\"scripts\": {\n\t\t\"phpstan\": \"phpstan analyse\",\n\t\t\"tester\": \"tester tests -s\"\n\t},\n\t\"extra\": {\n\t\t\"branch-alias\": {\n\t\t\t\"dev-master\": \"4.1-dev\"\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "license.md",
          "type": "blob",
          "size": 2.66015625,
          "content": "Licenses\n========\n\nGood news! You may use Nette Framework under the terms of either\nthe New BSD License or the GNU General Public License (GPL) version 2 or 3.\n\nThe BSD License is recommended for most projects. It is easy to understand and it\nplaces almost no restrictions on what you can do with the framework. If the GPL\nfits better to your project, you can use the framework under this license.\n\nYou don't have to notify anyone which license you are using. You can freely\nuse Nette Framework in commercial projects as long as the copyright header\nremains intact.\n\nPlease be advised that the name \"Nette Framework\" is a protected trademark and its\nusage has some limitations. So please do not use word \"Nette\" in the name of your\nproject or top-level domain, and choose a name that stands on its own merits.\nIf your stuff is good, it will not take long to establish a reputation for yourselves.\n\n\nNew BSD License\n---------------\n\nCopyright (c) 2004, 2014 David Grudl (https://davidgrudl.com)\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n\t* Redistributions of source code must retain the above copyright notice,\n\tthis list of conditions and the following disclaimer.\n\n\t* Redistributions in binary form must reproduce the above copyright notice,\n\tthis list of conditions and the following disclaimer in the documentation\n\tand/or other materials provided with the distribution.\n\n\t* Neither the name of \"Nette Framework\" nor the names of its contributors\n\tmay be used to endorse or promote products derived from this software\n\twithout specific prior written permission.\n\nThis software is provided by the copyright holders and contributors \"as is\" and\nany express or implied warranties, including, but not limited to, the implied\nwarranties of merchantability and fitness for a particular purpose are\ndisclaimed. In no event shall the copyright owner or contributors be liable for\nany direct, indirect, incidental, special, exemplary, or consequential damages\n(including, but not limited to, procurement of substitute goods or services;\nloss of use, data, or profits; or business interruption) however caused and on\nany theory of liability, whether in contract, strict liability, or tort\n(including negligence or otherwise) arising in any way out of the use of this\nsoftware, even if advised of the possibility of such damage.\n\n\nGNU General Public License\n--------------------------\n\nGPL licenses are very very long, so instead of including them here we offer\nyou URLs with full text:\n\n- [GPL version 2](http://www.gnu.org/licenses/gpl-2.0.html)\n- [GPL version 3](http://www.gnu.org/licenses/gpl-3.0.html)\n"
        },
        {
          "name": "ncs.php",
          "type": "blob",
          "size": 0.248046875,
          "content": "<?php\n\n/**\n * Rules for Nette Coding Standard\n * https://github.com/nette/coding-standard\n */\n\ndeclare(strict_types=1);\n\nreturn [\n\t// constant NULL, FALSE in src/PhpGenerator/Type.php\n\t'constant_case' => false,\n\t'lowercase_static_reference' => false,\n];\n"
        },
        {
          "name": "phpstan-baseline.neon",
          "type": "blob",
          "size": 3.974609375,
          "content": "parameters:\n\tignoreErrors:\n\t\t-\n\t\t\tmessage: '#^Match expression does not handle remaining value\\: true$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/ClassLike.php\n\n\t\t-\n\t\t\tmessage: '#^Method Nette\\\\PhpGenerator\\\\ClassType\\:\\:addTrait\\(\\) has parameter \\$deprecatedParam with no value type specified in iterable type array\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/ClassType.php\n\n\t\t-\n\t\t\tmessage: '#^Method Nette\\\\PhpGenerator\\\\EnumType\\:\\:addTrait\\(\\) has parameter \\$deprecatedParam with no value type specified in iterable type array\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/EnumType.php\n\n\t\t-\n\t\t\tmessage: '#^Access to an undefined property PhpParser\\\\Node\\:\\:\\$attrGroups\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Extractor.php\n\n\t\t-\n\t\t\tmessage: '#^Access to an undefined property PhpParser\\\\Node\\\\Expr\\:\\:\\$value\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Extractor.php\n\n\t\t-\n\t\t\tmessage: '#^Call to an undefined method Nette\\\\PhpGenerator\\\\ClassLike\\:\\:addConstant\\(\\)\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Extractor.php\n\n\t\t-\n\t\t\tmessage: '#^Call to an undefined method Nette\\\\PhpGenerator\\\\ClassLike\\:\\:addMethod\\(\\)\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Extractor.php\n\n\t\t-\n\t\t\tmessage: '#^Call to an undefined method Nette\\\\PhpGenerator\\\\ClassLike\\:\\:addProperty\\(\\)\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Extractor.php\n\n\t\t-\n\t\t\tmessage: '#^Call to an undefined method Nette\\\\PhpGenerator\\\\ClassLike\\:\\:addTrait\\(\\)\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Extractor.php\n\n\t\t-\n\t\t\tmessage: '#^Method Nette\\\\PhpGenerator\\\\Extractor\\:\\:addCommentAndAttributes\\(\\) has parameter \\$element with no type specified\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Extractor.php\n\n\t\t-\n\t\t\tmessage: '#^Property class@anonymous/PhpGenerator/Extractor\\.php\\:176\\:\\:\\$callback has no type specified\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Extractor.php\n\n\t\t-\n\t\t\tmessage: '#^Variable \\$trait might not be defined\\.$#'\n\t\t\tcount: 2\n\t\t\tpath: src/PhpGenerator/Extractor.php\n\n\t\t-\n\t\t\tmessage: '#^Call to an undefined method ReflectionClass\\<object\\>\\:\\:hasCase\\(\\)\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Factory.php\n\n\t\t-\n\t\t\tmessage: '#^Elseif branch is unreachable because previous condition is always true\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Factory.php\n\n\t\t-\n\t\t\tmessage: '#^Method Nette\\\\PhpGenerator\\\\Factory\\:\\:getAttributes\\(\\) has parameter \\$from with no type specified\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Factory.php\n\n\t\t-\n\t\t\tmessage: '#^Method Nette\\\\PhpGenerator\\\\Factory\\:\\:getAttributes\\(\\) return type has no value type specified in iterable type array\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Factory.php\n\n\t\t-\n\t\t\tmessage: '#^Method Nette\\\\PhpGenerator\\\\Factory\\:\\:getExtractor\\(\\) has parameter \\$from with no type specified\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Factory.php\n\n\t\t-\n\t\t\tmessage: '#^Method Nette\\\\PhpGenerator\\\\Factory\\:\\:getVisibility\\(\\) has parameter \\$from with no type specified\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Factory.php\n\n\t\t-\n\t\t\tmessage: '#^Parameter \\#1 \\$name of method Nette\\\\PhpGenerator\\\\ClassType\\:\\:setExtends\\(\\) expects string\\|null, array\\<int, string\\> given\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Factory.php\n\n\t\t-\n\t\t\tmessage: '#^Unreachable statement \\- code above always terminates\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Factory.php\n\n\t\t-\n\t\t\tmessage: '#^Variable \\$bodies on left side of \\?\\?\\= always exists and is not nullable\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Factory.php\n\n\t\t-\n\t\t\tmessage: '#^Method Nette\\\\PhpGenerator\\\\Helpers\\:\\:formatArgs\\(\\) has parameter \\$args with no value type specified in iterable type array\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Helpers.php\n\n\t\t-\n\t\t\tmessage: '#^Method Nette\\\\PhpGenerator\\\\Method\\:\\:from\\(\\) has parameter \\$method with no value type specified in iterable type array\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/Method.php\n\n\t\t-\n\t\t\tmessage: '#^Method Nette\\\\PhpGenerator\\\\TraitType\\:\\:addTrait\\(\\) has parameter \\$deprecatedParam with no value type specified in iterable type array\\.$#'\n\t\t\tcount: 1\n\t\t\tpath: src/PhpGenerator/TraitType.php\n"
        },
        {
          "name": "phpstan.neon",
          "type": "blob",
          "size": 0.0732421875,
          "content": "includes:\n\t- phpstan-baseline.neon\n\nparameters:\n\tlevel: 6\n\n\tpaths:\n\t\t- src\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 25.298828125,
          "content": "[![Nette PHP Generator](https://github.com/nette/php-generator/assets/194960/8a2c83bd-daea-475f-994c-9c951de88501)](https://doc.nette.org/en/php-generator)\n\n[![Latest Stable Version](https://poser.pugx.org/nette/php-generator/v/stable)](https://github.com/nette/php-generator/releases) [![Downloads this Month](https://img.shields.io/packagist/dm/nette/php-generator.svg)](https://packagist.org/packages/nette/php-generator)\n\n¬†<!---->\n\nAre you looking for a tool to generate PHP code for [classes](#classes), [functions](#global-functions), or complete [PHP files](#php-files)?\n\n<h3>\n\n‚úÖ Supports all the latest PHP features like [property hooks](#property-hooks), [enums](#enums), [attributes](#attributes), etc.<br>\n‚úÖ Allows you to easily modify [existing classes](#generating-from-existing-ones)<br>\n‚úÖ Output compliant with [PSR-12 / PER coding style](#printer-and-psr-compliance)<br>\n‚úÖ Highly mature, stable, and widely used library\n\n</h3>\n\n¬†<!---->\n\nInstallation\n------------\n\nDownload and install the library using the [Composer](https://doc.nette.org/en/best-practices/composer) tool:\n\n```shell\ncomposer require nette/php-generator\n```\n\nPhpGenerator 4.1 is compatible with PHP 8.0 to 8.4. Documentation can be found on the [library's website](https://doc.nette.org/php-generator).\n\n¬†<!---->\n\n[Support Me](https://github.com/sponsors/dg)\n--------------------------------------------\n\nDo you like PHP Generator? Are you looking forward to the new features?\n\n[![Buy me a coffee](https://files.nette.org/icons/donation-3.svg)](https://github.com/sponsors/dg)\n\nThank you!\n\n¬†<!---->\n\nClasses\n-------\n\nLet's start with an example of creating a class using [ClassType](https://api.nette.org/php-generator/master/Nette/PhpGenerator/ClassType.html):\n\n```php\n$class = new Nette\\PhpGenerator\\ClassType('Demo');\n\n$class\n\t->setFinal()\n\t->setExtends(ParentClass::class)\n\t->addImplement(Countable::class)\n\t->addComment(\"Class description.\\nSecond line\\n\")\n\t->addComment('@property-read Nette\\Forms\\Form $form');\n\n// generate code simply by typecasting to string or using echo:\necho $class;\n```\n\nThis will return:\n\n```php\n/**\n * Class description\n * Second line\n *\n * @property-read Nette\\Forms\\Form $form\n */\nfinal class Demo extends ParentClass implements Countable\n{\n}\n```\n\nTo generate the code, you can also use a so-called printer, which, unlike `echo $class`, can be [further configured](#printer-and-psr-compliance):\n\n```php\n$printer = new Nette\\PhpGenerator\\Printer;\necho $printer->printClass($class);\n```\n\nYou can add constants (class [Constant](https://api.nette.org/php-generator/master/Nette/PhpGenerator/Constant.html)) and properties (class [Property](https://api.nette.org/php-generator/master/Nette/PhpGenerator/Property.html)):\n\n```php\n$class->addConstant('ID', 123)\n\t->setProtected() // constant visibility\n\t->setType('int')\n\t->setFinal();\n\n$class->addProperty('items', [1, 2, 3])\n\t->setPrivate() // or setVisibility('private')\n\t->setStatic()\n\t->addComment('@var int[]');\n\n$class->addProperty('list')\n\t->setType('?array')\n\t->setInitialized(); // outputs '= null'\n```\n\nThis will generate:\n\n```php\nfinal protected const int ID = 123;\n\n/** @var int[] */\nprivate static $items = [1, 2, 3];\n\npublic ?array $list = null;\n```\n\nAnd you can add [methods](#method-and-function-signatures):\n\n```php\n$method = $class->addMethod('count')\n\t->addComment('Count it.')\n\t->setFinal()\n\t->setProtected()\n\t->setReturnType('?int') // return types for methods\n\t->setBody('return count($items ?: $this->items);');\n\n$method->addParameter('items', []) // $items = []\n\t->setReference()           // &$items = []\n\t->setType('array');        // array &$items = []\n```\n\nThe result is:\n\n```php\n/**\n * Count it.\n */\nfinal protected function count(array &$items = []): ?int\n{\n\treturn count($items ?: $this->items);\n}\n```\n\nPromoted parameters introduced in PHP 8.0 can be passed to the constructor:\n\n```php\n$method = $class->addMethod('__construct');\n$method->addPromotedParameter('name');\n$method->addPromotedParameter('args', [])\n\t->setPrivate();\n```\n\nThe result is:\n\n```php\npublic function __construct(\n\tpublic $name,\n\tprivate $args = [],\n) {\n}\n```\n\nReadonly properties and classes be marked using the `setReadOnly()` function.\n\n------\n\nIf an added property, constant, method, or parameter already exists, an exception is thrown.\n\nClass members can be removed using `removeProperty()`, `removeConstant()`, `removeMethod()`, or `removeParameter()`.\n\nYou can also add existing `Method`, `Property`, or `Constant` objects to the class:\n\n```php\n$method = new Nette\\PhpGenerator\\Method('getHandle');\n$property = new Nette\\PhpGenerator\\Property('handle');\n$const = new Nette\\PhpGenerator\\Constant('ROLE');\n\n$class = (new Nette\\PhpGenerator\\ClassType('Demo'))\n\t->addMember($method)\n\t->addMember($property)\n\t->addMember($const);\n```\n\nYou can also clone existing methods, properties, and constants under a different name using `cloneWithName()`:\n\n```php\n$methodCount = $class->getMethod('count');\n$methodRecount = $methodCount->cloneWithName('recount');\n$class->addMember($methodRecount);\n```\n\n¬†<!---->\n\nInterfaces or Traits\n--------------------\n\nYou can create interfaces and traits (classes [InterfaceType](https://api.nette.org/php-generator/master/Nette/PhpGenerator/InterfaceType.html) and [TraitType](https://api.nette.org/php-generator/master/Nette/PhpGenerator/TraitType.html)):\n\n```php\n$interface = new Nette\\PhpGenerator\\InterfaceType('MyInterface');\n$trait = new Nette\\PhpGenerator\\TraitType('MyTrait');\n```\n\nUsing a trait:\n\n```php\n$class = new Nette\\PhpGenerator\\ClassType('Demo');\n$class->addTrait('SmartObject');\n$class->addTrait('MyTrait')\n\t->addResolution('sayHello as protected')\n\t->addComment('@use MyTrait<Foo>');\necho $class;\n```\n\nThe result is:\n\n```php\nclass Demo\n{\n\tuse SmartObject;\n\t/** @use MyTrait<Foo> */\n\tuse MyTrait {\n\t\tsayHello as protected;\n\t}\n}\n```\n\n¬†<!---->\n\nEnums\n-----\n\nYou can easily create enums introduced in PHP 8.1 like this (class [EnumType](https://api.nette.org/php-generator/master/Nette/PhpGenerator/EnumType.html)):\n\n```php\n$enum = new Nette\\PhpGenerator\\EnumType('Suit');\n$enum->addCase('Clubs');\n$enum->addCase('Diamonds');\n$enum->addCase('Hearts');\n$enum->addCase('Spades');\n\necho $enum;\n```\n\nThe result is:\n\n```php\nenum Suit\n{\n\tcase Clubs;\n\tcase Diamonds;\n\tcase Hearts;\n\tcase Spades;\n}\n```\n\nYou can also define scalar equivalents and create a \"backed\" enum:\n\n```php\n$enum->addCase('Clubs', '‚ô£');\n$enum->addCase('Diamonds', '‚ô¶');\n```\n\nFor each *case*, you can add a comment or [attributes](#attributes) using `addComment()` or `addAttribute()`.\n\n¬†<!---->\n\nAnonymous Classes\n-----------------\n\nPass `null` as the name, and you have an anonymous class:\n\n```php\n$class = new Nette\\PhpGenerator\\ClassType(null);\n$class->addMethod('__construct')\n\t->addParameter('foo');\n\necho '$obj = new class ($val) ' . $class . ';';\n```\n\nThe result is:\n\n```php\n$obj = new class ($val) {\n\n\tpublic function __construct($foo)\n\t{\n\t}\n};\n```\n\n¬†<!---->\n\nGlobal Functions\n----------------\n\nThe code for functions is generated by the class [GlobalFunction](https://api.nette.org/php-generator/master/Nette/PhpGenerator/GlobalFunction.html):\n\n```php\n$function = new Nette\\PhpGenerator\\GlobalFunction('foo');\n$function->setBody('return $a + $b;');\n$function->addParameter('a');\n$function->addParameter('b');\necho $function;\n\n// or use the PsrPrinter for output compliant with PSR-2 / PSR-12 / PER\n// echo (new Nette\\PhpGenerator\\PsrPrinter)->printFunction($function);\n```\n\nThe result is:\n\n```php\nfunction foo($a, $b)\n{\n\treturn $a + $b;\n}\n```\n\n¬†<!---->\n\nAnonymous Functions\n-------------------\n\nThe code for anonymous functions is generated by the class [Closure](https://api.nette.org/php-generator/master/Nette/PhpGenerator/Closure.html):\n\n```php\n$closure = new Nette\\PhpGenerator\\Closure;\n$closure->setBody('return $a + $b;');\n$closure->addParameter('a');\n$closure->addParameter('b');\n$closure->addUse('c')\n\t->setReference();\necho $closure;\n\n// or use the PsrPrinter for output compliant with PSR-2 / PSR-12 / PER\n// echo (new Nette\\PhpGenerator\\PsrPrinter)->printClosure($closure);\n```\n\nThe result is:\n\n```php\nfunction ($a, $b) use (&$c) {\n\treturn $a + $b;\n}\n```\n\n¬†<!---->\n\nShort Arrow Functions\n---------------------\n\nYou can also output a short anonymous function using the printer:\n\n```php\n$closure = new Nette\\PhpGenerator\\Closure;\n$closure->setBody('$a + $b');\n$closure->addParameter('a');\n$closure->addParameter('b');\n\necho (new Nette\\PhpGenerator\\Printer)->printArrowFunction($closure);\n```\n\nThe result is:\n\n```php\nfn($a, $b) => $a + $b\n```\n\n¬†<!---->\n\nMethod and Function Signatures\n------------------------------\n\nMethods are represented by the class [Method](https://api.nette.org/php-generator/master/Nette/PhpGenerator/Method.html). You can set visibility, return value, add comments, [attributes](#attributes), etc.:\n\n```php\n$method = $class->addMethod('count')\n\t->addComment('Count it.')\n\t->setFinal()\n\t->setProtected()\n\t->setReturnType('?int');\n```\n\nIndividual parameters are represented by the class [Parameter](https://api.nette.org/php-generator/master/Nette/PhpGenerator/Parameter.html). Again, you can set all conceivable properties:\n\n```php\n$method->addParameter('items', []) // $items = []\n\t->setReference()           // &$items = []\n\t->setType('array');        // array &$items = []\n\n// function count(&$items = [])\n```\n\nTo define the so-called variadics parameters (or also the splat, spread, ellipsis, unpacking or three dots operator), use `setVariadic()`:\n\n```php\n$method = $class->addMethod('count');\n$method->setVariadic(true);\n$method->addParameter('items');\n```\n\nThis generates:\n\n```php\nfunction count(...$items)\n{\n}\n```\n\n¬†<!---->\n\nMethod and Function Bodies\n--------------------------\n\nThe body can be passed all at once to the `setBody()` method or gradually (line by line) by repeatedly calling `addBody()`:\n\n```php\n$function = new Nette\\PhpGenerator\\GlobalFunction('foo');\n$function->addBody('$a = rand(10, 20);');\n$function->addBody('return $a;');\necho $function;\n```\n\nThe result is:\n\n```php\nfunction foo()\n{\n\t$a = rand(10, 20);\n\treturn $a;\n}\n```\n\nYou can use special placeholders for easy variable insertion.\n\nSimple placeholders `?`\n\n```php\n$str = 'any string';\n$num = 3;\n$function = new Nette\\PhpGenerator\\GlobalFunction('foo');\n$function->addBody('return substr(?, ?);', [$str, $num]);\necho $function;\n```\n\nThe result is:\n\n```php\nfunction foo()\n{\n\treturn substr('any string', 3);\n}\n```\n\nPlaceholder for variadic `...?`\n\n```php\n$items = [1, 2, 3];\n$function = new Nette\\PhpGenerator\\GlobalFunction('foo');\n$function->setBody('myfunc(...?);', [$items]);\necho $function;\n```\n\nThe result is:\n\n```php\nfunction foo()\n{\n\tmyfunc(1, 2, 3);\n}\n```\n\nYou can also use named parameters for PHP 8 with `...?:`\n\n```php\n$items = ['foo' => 1, 'bar' => true];\n$function->setBody('myfunc(...?:);', [$items]);\n\n// myfunc(foo: 1, bar: true);\n```\n\nThe placeholder is escaped with a backslash `\\?`\n\n```php\n$num = 3;\n$function = new Nette\\PhpGenerator\\GlobalFunction('foo');\n$function->addParameter('a');\n$function->addBody('return $a \\? 10 : ?;', [$num]);\necho $function;\n```\n\nThe result is:\n\n```php\nfunction foo($a)\n{\n\treturn $a ? 10 : 3;\n}\n```\n\n¬†<!---->\n\nPrinter and PSR Compliance\n--------------------------\n\nThe [Printer](https://api.nette.org/php-generator/master/Nette/PhpGenerator/Printer.html) class is used for generating PHP code:\n\n```php\n$class = new Nette\\PhpGenerator\\ClassType('Demo');\n// ...\n\n$printer = new Nette\\PhpGenerator\\Printer;\necho $printer->printClass($class); // same as: echo $class\n```\n\nIt can generate code for all other elements, offering methods like `printFunction()`, `printNamespace()`, etc.\n\nThere's also the `PsrPrinter` class, which outputs in accordance with PSR-2 / PSR-12 / PER coding style:\n\n```php\n$printer = new Nette\\PhpGenerator\\PsrPrinter;\necho $printer->printClass($class);\n```\n\nNeed custom behavior? Create your own version by inheriting the `Printer` class. You can reconfigure these variables:\n\n```php\nclass MyPrinter extends Nette\\PhpGenerator\\Printer\n{\n\t// length of the line after which the line will break\n\tpublic int $wrapLength = 120;\n\t// indentation character, can be replaced with a sequence of spaces\n\tpublic string $indentation = \"\\t\";\n\t// number of blank lines between properties\n\tpublic int $linesBetweenProperties = 0;\n\t// number of blank lines between methods\n\tpublic int $linesBetweenMethods = 2;\n\t// number of blank lines between 'use statements' groups for classes, functions, and constants\n\tpublic int $linesBetweenUseTypes = 0;\n\t// position of the opening curly brace for functions and methods\n\tpublic bool $bracesOnNextLine = true;\n\t// place one parameter on one line, even if it has an attribute or is supported\n\tpublic bool $singleParameterOnOneLine = false;\n\t// omits namespaces that do not contain any class or function\n\tpublic bool $omitEmptyNamespaces = true;\n\t// separator between the right parenthesis and return type of functions and methods\n\tpublic string $returnTypeColon = ': ';\n}\n```\n\nHow and why does the standard `Printer` differ from `PsrPrinter`? Why isn't there just one printer, the `PsrPrinter`, in the package?\n\nThe standard `Printer` formats the code as we do throughout Nette. Since Nette was established much earlier than PSR, and also because PSR took years to deliver standards on time, sometimes even several years after introducing a new feature in PHP, it resulted in a [coding standard](https://doc.nette.org/en/contributing/coding-standard) that differs in a few minor aspects.\nThe major difference is the use of tabs instead of spaces. We know that by using tabs in our projects, we allow for width customization, which is [essential for people with visual impairments](https://doc.nette.org/en/contributing/coding-standard#toc-tabs-instead-of-spaces).\nAn example of a minor difference is placing the curly brace on a separate line for functions and methods, always. The PSR recommendation seems illogical to us and [leads to reduced code clarity](https://doc.nette.org/en/contributing/coding-standard#toc-wrapping-and-braces).\n\n¬†<!---->\n\nTypes\n-----\n\nEvery type or union/intersection type can be passed as a string; you can also use predefined constants for native types:\n\n```php\nuse Nette\\PhpGenerator\\Type;\n\n$member->setType('array'); // or Type::Array;\n$member->setType('?array'); // or Type::nullable(Type::Array);\n$member->setType('array|string'); // or Type::union(Type::Array, Type::String)\n$member->setType('Foo&Bar'); // or Type::intersection(Foo::class, Bar::class)\n$member->setType(null); // removes the type\n```\n\nThe same applies to the `setReturnType()` method.\n\n¬†<!---->\n\nLiterals\n--------\n\nUsing `Literal`, you can pass any PHP code, for example, for default property values or parameters, etc:\n\n```php\nuse Nette\\PhpGenerator\\Literal;\n\n$class = new Nette\\PhpGenerator\\ClassType('Demo');\n\n$class->addProperty('foo', new Literal('Iterator::SELF_FIRST'));\n\n$class->addMethod('bar')\n\t->addParameter('id', new Literal('1 + 2'));\n\necho $class;\n```\n\nResult:\n\n```php\nclass Demo\n{\n\tpublic $foo = Iterator::SELF_FIRST;\n\n\tpublic function bar($id = 1 + 2)\n\t{\n\t}\n}\n```\n\nYou can also pass parameters to `Literal` and have them formatted into valid PHP code using [placeholders](#method-and-function-bodies):\n\n```php\nnew Literal('substr(?, ?)', [$a, $b]);\n// generates for example: substr('hello', 5);\n```\n\nA literal representing the creation of a new object can easily be generated using the `new` method:\n\n```php\nLiteral::new(Demo::class, [$a, 'foo' => $b]);\n// generates for example: new Demo(10, foo: 20)\n```\n\n¬†<!---->\n\nAttributes\n----------\n\nWith PHP 8, you can add attributes to all classes, methods, properties, constants, enum cases, functions, closures, and parameters. You can also use [literals](#literals) as parameter values.\n\n```php\n$class = new Nette\\PhpGenerator\\ClassType('Demo');\n$class->addAttribute('Table', [\n\t'name' => 'user',\n\t'constraints' => [\n\t\tLiteral::new('UniqueConstraint', ['name' => 'ean', 'columns' => ['ean']]),\n\t],\n]);\n\n$class->addProperty('list')\n\t->addAttribute('Deprecated');\n\n$method = $class->addMethod('count')\n\t->addAttribute('Foo\\Cached', ['mode' => true]);\n\n$method->addParameter('items')\n\t->addAttribute('Bar');\n\necho $class;\n```\n\nResult:\n\n```php\n#[Table(name: 'user', constraints: [new UniqueConstraint(name: 'ean', columns: ['ean'])])]\nclass Demo\n{\n\t#[Deprecated]\n\tpublic $list;\n\n\n\t#[Foo\\Cached(mode: true)]\n\tpublic function count(\n\t\t#[Bar]\n\t\t$items,\n\t) {\n\t}\n}\n```\n\n¬†<!---->\n\nProperty Hooks\n--------------\n\nYou can also define property hooks (represented by the class [PropertyHook](https://api.nette.org/php-generator/master/Nette/PhpGenerator/PropertyHook.html)) for get and set operations, a feature introduced in PHP 8.4:\n\n```php\n$class = new Nette\\PhpGenerator\\ClassType('Demo');\n$prop = $class->addProperty('firstName')\n    ->setType('string');\n\n$prop->addHook('set', 'strtolower($value)')\n    ->addParameter('value')\n\t    ->setType('string');\n\n$prop->addHook('get')\n\t->setBody('return ucfirst($this->firstName);');\n\necho $class;\n```\n\nThis generates:\n\n```php\nclass Demo\n{\n    public string $firstName {\n        set(string $value) => strtolower($value);\n        get {\n            return ucfirst($this->firstName);\n        }\n    }\n}\n```\n\nProperties and property hooks can be abstract or final:\n\n```php\n$class->addProperty('id')\n    ->setType('int')\n    ->addHook('get')\n        ->setAbstract();\n\n$class->addProperty('role')\n    ->setType('string')\n    ->addHook('set', 'strtolower($value)')\n        ->setFinal();\n```\n\n¬†<!---->\n\nAsymmetric Visibility\n---------------------\n\nPHP 8.4 introduces asymmetric visibility for properties. You can set different access levels for reading and writing.\nThe visibility can be set using either the `setVisibility()` method with two parameters, or by using `setPublic()`, `setProtected()`, or `setPrivate()` with the `mode` parameter that specifies whether the visibility applies to getting or setting the property. The default mode is 'get'.\n\n```php\n$class = new Nette\\PhpGenerator\\ClassType('Demo');\n\n$class->addProperty('name')\n    ->setType('string')\n    ->setVisibility('public', 'private'); // public for read, private for write\n\n$class->addProperty('id')\n    ->setType('int')\n    ->setProtected('set'); // protected for write\n\necho $class;\n```\n\nThis generates:\n\n```php\nclass Demo\n{\n    public private(set) string $name;\n\n    protected(set) int $id;\n}\n```\n\n¬†<!---->\n\nNamespace\n---------\n\nClasses, traits, interfaces, and enums (hereafter referred to as classes) can be grouped into namespaces represented by the [PhpNamespace](https://api.nette.org/php-generator/master/Nette/PhpGenerator/PhpNamespace.html) class:\n\n```php\n$namespace = new Nette\\PhpGenerator\\PhpNamespace('Foo');\n\n// create new classes in the namespace\n$class = $namespace->addClass('Task');\n$interface = $namespace->addInterface('Countable');\n$trait = $namespace->addTrait('NameAware');\n\n// or insert an existing class into the namespace\n$class = new Nette\\PhpGenerator\\ClassType('Task');\n$namespace->add($class);\n```\n\nIf the class already exists, an exception is thrown.\n\nYou can define use clauses:\n\n```php\n// use Http\\Request;\n$namespace->addUse(Http\\Request::class);\n// use Http\\Request as HttpReq;\n$namespace->addUse(Http\\Request::class, 'HttpReq');\n// use function iter\\range;\n$namespace->addUseFunction('iter\\range');\n```\n\nTo simplify a fully qualified class, function, or constant name based on defined aliases, use the `simplifyName` method:\n\n```php\necho $namespace->simplifyName('Foo\\Bar'); // 'Bar', because 'Foo' is the current namespace\necho $namespace->simplifyName('iter\\range', $namespace::NameFunction); // 'range', due to the defined use-statement\n```\n\nConversely, you can convert a simplified class, function, or constant name back to a fully qualified name using the `resolveName` method:\n\n```php\necho $namespace->resolveName('Bar'); // 'Foo\\Bar'\necho $namespace->resolveName('range', $namespace::NameFunction); // 'iter\\range'\n```\n\n¬†<!---->\n\nClass Names Resolving\n---------------------\n\n**When a class is part of a namespace, it's rendered slightly differently:** all types (e.g., type hints, return types, parent class name, implemented interfaces, used traits, and attributes) are automatically *resolved* (unless you turn it off, see below).\nThis means you must use **fully qualified class names** in definitions, and they will be replaced with aliases (based on use clauses) or fully qualified names in the resulting code:\n\n```php\n$namespace = new Nette\\PhpGenerator\\PhpNamespace('Foo');\n$namespace->addUse('Bar\\AliasedClass');\n\n$class = $namespace->addClass('Demo');\n$class->addImplement('Foo\\A') // will be simplified to A\n\t->addTrait('Bar\\AliasedClass'); // will be simplified to AliasedClass\n\n$method = $class->addMethod('method');\n$method->addComment('@return ' . $namespace->simplifyType('Foo\\D')); // we manually simplify in comments\n$method->addParameter('arg')\n\t->setType('Bar\\OtherClass'); // will be translated to \\Bar\\OtherClass\n\necho $namespace;\n\n// or use the PsrPrinter for output in accordance with PSR-2 / PSR-12 / PER\n// echo (new Nette\\PhpGenerator\\PsrPrinter)->printNamespace($namespace);\n```\n\nResult:\n\n```php\nnamespace Foo;\n\nuse Bar\\AliasedClass;\n\nclass Demo implements A\n{\n\tuse AliasedClass;\n\n\t/**\n\t * @return D\n\t */\n\tpublic function method(\\Bar\\OtherClass $arg)\n\t{\n\t}\n}\n```\n\nAuto-resolving can be turned off this way:\n\n```php\n$printer = new Nette\\PhpGenerator\\Printer; // or PsrPrinter\n$printer->setTypeResolving(false);\necho $printer->printNamespace($namespace);\n```\n\n¬†<!---->\n\nPHP Files\n---------\n\nClasses, functions, and namespaces can be grouped into PHP files represented by the [PhpFile](https://api.nette.org/php-generator/master/Nette/PhpGenerator/PhpFile.html) class:\n\n```php\n$file = new Nette\\PhpGenerator\\PhpFile;\n$file->addComment('This file is auto-generated.');\n$file->setStrictTypes(); // adds declare(strict_types=1)\n\n$class = $file->addClass('Foo\\A');\n$function = $file->addFunction('Foo\\foo');\n\n// or\n// $namespace = $file->addNamespace('Foo');\n// $class = $namespace->addClass('A');\n// $function = $namespace->addFunction('foo');\n\necho $file;\n\n// or use the PsrPrinter for output in accordance with PSR-2 / PSR-12 / PER\n// echo (new Nette\\PhpGenerator\\PsrPrinter)->printFile($file);\n```\n\nResult:\n\n```php\n<?php\n\n/**\n * This file is auto-generated.\n */\n\ndeclare(strict_types=1);\n\nnamespace Foo;\n\nclass A\n{\n}\n\nfunction foo()\n{\n}\n```\n\n**Please note:** No additional code can be added to the files outside of functions and classes.\n\n¬†<!---->\n\nGenerating from Existing Ones\n-----------------------------\n\nIn addition to being able to model classes and functions using the API described above, you can also have them automatically generated using existing ones:\n\n```php\n// creates a class identical to the PDO class\n$class = Nette\\PhpGenerator\\ClassType::from(PDO::class);\n\n// creates a function identical to the trim() function\n$function = Nette\\PhpGenerator\\GlobalFunction::from('trim');\n\n// creates a closure based on the provided one\n$closure = Nette\\PhpGenerator\\Closure::from(\n\tfunction (stdClass $a, $b = null) {},\n);\n```\n\nBy default, function and method bodies are empty. If you also want to load them, use this method\n(requires the `nikic/php-parser` package to be installed):\n\n```php\n$class = Nette\\PhpGenerator\\ClassType::from(Foo::class, withBodies: true);\n\n$function = Nette\\PhpGenerator\\GlobalFunction::from('foo', withBody: true);\n```\n\n¬†<!---->\n\nLoading from PHP Files\n----------------------\n\nYou can also load functions, classes, interfaces, and enums directly from a string containing PHP code. For example, to create a `ClassType` object:\n\n```php\n$class = Nette\\PhpGenerator\\ClassType::fromCode(<<<XX\n\t<?php\n\n\tclass Demo\n\t{\n\t\tpublic $foo;\n\t}\n\tXX);\n```\n\nWhen loading classes from PHP code, single-line comments outside method bodies are ignored (e.g., for properties, etc.), as this library doesn't have an API to work with them.\n\nYou can also directly load an entire PHP file, which can contain any number of classes, functions, or even namespaces:\n\n```php\n$file = Nette\\PhpGenerator\\PhpFile::fromCode(file_get_contents('classes.php'));\n```\n\nThe file's initial comment and `strict_types` declaration are also loaded. However, all other global code is ignored.\n\nIt requires `nikic/php-parser` to be installed.\n\n*(If you need to manipulate global code in files or individual statements in method bodies, it's better to use the `nikic/php-parser` library directly.)*\n\n¬†<!---->\n\nClass Manipulator\n-----------------\n\nThe [ClassManipulator](https://api.nette.org/php-generator/master/Nette/PhpGenerator/ClassManipulator.html) class provides tools for manipulating classes.\n\n```php\n$class = new Nette\\PhpGenerator\\ClassType('Demo');\n$manipulator = new Nette\\PhpGenerator\\ClassManipulator($class);\n```\n\nThe `inheritMethod()` method copies a method from a parent class or implemented interface into your class. This allows you to override the method or extend its signature:\n\n```php\n$method = $manipulator->inheritMethod('bar');\n$method->setBody('...');\n```\n\nThe `inheritProperty()` method copies a property from a parent class into your class. This is useful when you want to have the same property in your class, but possibly with a different default value:\n\n```php\n$property = $manipulator->inheritProperty('foo');\n$property->setValue('new value');\n```\n\nThe `implement()` method automatically implements all methods and properties from the given interface or abstract class:\n\n```php\n$manipulator->implement(SomeInterface::class);\n// Now your class implements SomeInterface and includes all its methods\n```\n\n¬†<!---->\n\nVariable Dumping\n----------------\n\nThe `Dumper` class converts a variable into parseable PHP code. It provides a better and clearer output than the standard `var_export()` function.\n\n```php\n$dumper = new Nette\\PhpGenerator\\Dumper;\n\n$var = ['a', 'b', 123];\n\necho $dumper->dump($var); // outputs ['a', 'b', 123]\n```\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}