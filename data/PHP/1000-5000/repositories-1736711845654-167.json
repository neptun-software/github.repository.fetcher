{
  "metadata": {
    "timestamp": 1736711845654,
    "page": 167,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jokkedk/webgrind",
      "stars": 3287,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.13671875,
          "content": "/js/jquery.js linguist-vendored\n/js/jquery.*.js linguist-vendored\n/js/sprintf.js linguist-vendored\n\n/library/gprof2dot.py linguist-vendored\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.005859375,
          "content": ".idea\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.5390625,
          "content": "FROM php:7.4-apache as builder\n\nCOPY . /build\n\nRUN apt-get update \\\n    && apt-get install -y build-essential zlib1g-dev \\\n    && cd /build \\\n    && make \\\n    && sed 's/\\(^ *\\)\\/\\/\\(.*DOCKER:ENABLE\\)/\\1\\2/g' config.php > config-docker.php\n\nFROM php:7.4-apache\nWORKDIR /var/www/html\n\nRUN apt-get update \\\n    && apt-get install -y graphviz python3 \\\n    && rm -rf /var/lib/apt/lists/*\n\nCOPY . /var/www/html\nCOPY --from=builder /build/bin/preprocessor /var/www/html/bin/preprocessor\nCOPY --from=builder /build/config-docker.php /var/www/html/config.php\n"
        },
        {
          "name": "Nmakefile",
          "type": "blob",
          "size": 0.3896484375,
          "content": "CXX = cl.exe\nCFLAGS = /O2 /W3 /MT /GS /Gy /EHsc /Zi /nologo /analyze\nSRCS = library/preprocessor.cpp\nOUT = bin\\preprocessor.exe\n\n\nall: $(OUT)\n\nhelp:\n\t@echo \"Targets:\"\n\t@echo \"  all     - build preprocessor\"\n\t@echo \"  clean   - clear generated binaries\"\n\t@echo \"  help    - show this message\\n\"\n\nclean:\n\tdel \"$(OUT)\" > nul\n\n$(OUT): $(SRCS)\n\tcl.exe $(CFLAGS) $(SRCS) /Fe$(OUT)\n\n.PHONY: all help clean\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.685546875,
          "content": "Webgrind\n========\nWebgrind is an [Xdebug](http://www.xdebug.org) profiling web frontend in PHP. It implements a subset of the features of [kcachegrind](https://kcachegrind.github.io/) and installs in seconds and works on all platforms. For quick'n'dirty optimizations it does the job. Here's a screenshot showing the output from profiling:\n\n<a href=\"https://jokkedk.github.io/webgrind/img/webgrind_2008_large.png\"><img src=\"https://jokkedk.github.io/webgrind/img/webgrind_2008_large.png\" height=\"384\"></a>\n\nFeatures\n--------\n  * Super simple, cross platform installation - obviously :)\n  * Track time spent in functions by self cost or inclusive cost. Inclusive cost is time inside function + calls to other functions.\n  * See if time is spent in internal or user functions.\n  * See where any function was called from and which functions it calls.\n  * Generate a call graph using [gprof2dot.py](https://github.com/jrfonseca/gprof2dot)\n\nSuggestions for improvements and new features are more than welcome - this is just a start.\n\nInstallation\n------------\n  1. Download webgrind\n  2. Unzip package to favourite path accessible by webserver.\n  3. Load webgrind in browser and start profiling\n\nAlternatively, on PHP 5.4+ run the application using the PHP built-in server\nwith the command `composer serve` or `php -S 0.0.0.0:8080 index.php` if you\nare not using Composer.\n\nFor faster preprocessing, give write access to the `bin` subdirectory, or compile manually:\n  * Linux / Mac OS X: execute `make` in the unzipped folder (requires GCC or Clang.)\n  * Windows: execute `nmake -f NMakeFile` in the unzipped folder (requires Visual Studio 2015 or higher.)\n\nSee the [Installation Wiki page](https://github.com/jokkedk/webgrind/wiki/Installation) for more.\n\nUse with Docker\n---------------\n\nInstead of uploading webgrind to a web server or starting a local one, you can use the [official Docker image](https://hub.docker.com/r/jokkedk/webgrind) to\nquickly inspect existing xDebug profiling files. To use the Docker image, run the following command with\n`/path/to/xdebug/files` replaced by the actual path of your profiling files.\n\n```\ndocker run --rm -v /path/to/xdebug/files:/tmp -p 80:80 jokkedk/webgrind:latest\n```\n\nNow open `http://localhost` in your browser. After using webgrind you can stop the Docker container by pressing\n`CTRL / Strg` + `C`.\n\nTo use the built-in file viewer, mount the appropriate files under `/host` in the container.\n\nCredits\n-------\nWebgrind is written by [Joakim Nygård](http://jokke.dk) and [Jacob Oettinger](http://oettinger.dk). It would not have been possible without the great tool that Xdebug is thanks to [Derick Rethans](http://www.derickrethans.nl).\n\nCurrent maintainer is [Micah Ng](https://github.com/alpha0010).\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.9951171875,
          "content": "{\n    \"name\": \"jokkedk/webgrind\",\n    \"type\": \"application\",\n    \"description\": \"Webgrind is a Xdebug profiling web frontend in PHP5. It implements a subset of the features of kcachegrind and installs in seconds and works on all platforms. For quick'n'dirty optimizations it does the job.\",\n    \"keywords\": [\"webgrind\",\"xdebug\",\"debug\"],\n    \"homepage\": \"https://github.com/jokkedk/webgrind\",\n    \"license\": \"BSD-3-Clause\",\n    \"authors\": [\n        {\n            \"name\": \"Joakim Nygård\",\n            \"email\": \"joakim@scienta.dk\",\n            \"homepage\": \"http://jokke.dk/\"\n        },\n        {\n            \"name\": \"Jacob Oettinger\",\n            \"email\": \"jacob@oettinger.dk\",\n            \"homepage\": \"http://oettinger.dk/\"\n        }\n    ],\n    \"support\": {\n        \"issues\": \"https://github.com/jokkedk/webgrind/issues\",\n        \"wiki\": \"https://github.com/jokkedk/webgrind/wiki\",\n        \"source\": \"https://github.com/jokkedk/webgrind\"\n    },\n    \"scripts\": {\n        \"serve\": \"php -S 0.0.0.0:8080 index.php\"\n    }\n}\n"
        },
        {
          "name": "config.php",
          "type": "blob",
          "size": 7.38671875,
          "content": "<?php\n\n/**\n * Configuration for webgrind\n * @author Jacob Oettinger\n * @author Joakim Nygård\n */\nclass Webgrind_Config extends Webgrind_MasterConfig {\n    /**\n     * Automatically check if a newer version of webgrind is available for download\n     */\n    static $checkVersion = true;\n    static $hideWebgrindProfiles = true;\n\n    /**\n     * Writable dir for information storage.\n     * If empty, will use system tmp folder or xdebug tmp\n     */\n    static $storageDir = '';\n    static $profilerDir = '/tmp';\n\n    /**\n     * Suffix for preprocessed files\n     */\n    static $preprocessedSuffix = '.webgrind';\n\n    /**\n     * Image type of graph to output\n     * Can be png or svg\n     */\n    static $graphImageType = 'svg';\n\n    static $defaultTimezone = 'Europe/Copenhagen';\n    static $dateFormat = 'Y-m-d H:i:s';\n    static $defaultCostformat = 'percent'; // 'percent', 'usec' or 'msec'\n    static $defaultFunctionPercentage = 90;\n    static $defaultHideInternalFunctions = false;\n\n    /**\n     * Path to python executable\n     */\n    static $pythonExecutable = '/usr/bin/python3';\n\n    /**\n     * Path to graphviz dot executable\n     */\n    static $dotExecutable = '/usr/bin/dot';\n\n    /**\n     * sprintf compatible format for generating links to source files.\n     * %1$s will be replaced by the full path name of the file\n     * %2$d will be replaced by the linenumber\n     */\n    static $fileUrlFormat = 'index.php?op=fileviewer&file=%1$s#line%2$d'; // Built in fileviewer\n    //static $fileUrlFormat = 'txmt://open/?url=file://%1$s&line=%2$d'; // Textmate\n    //static $fileUrlFormat = 'vscode://file/%1$s:%2$d'; // VSCode\n    //static $fileUrlFormat = 'file://%1$s'; // ?\n\n    /**\n     * Enable viewing of server files.\n     *\n     * Add whatever logic necessary to determine whether a visitor can\n     * access a particular file. Access is granted if this function returns\n     * a path to a readable file.\n     */\n    static function exposeServerFile($file) {\n        // Grant access to all files remapped under the `/host` directory.\n        //$prefix = '/host/';                                    /** DOCKER:ENABLE **/\n        //$file = realpath($prefix . $file);                     /** DOCKER:ENABLE **/\n        //return strncmp($prefix, $file, strlen($prefix)) === 0  /** DOCKER:ENABLE **/\n        //    ? $file                                            /** DOCKER:ENABLE **/\n        //    : false;                                           /** DOCKER:ENABLE **/\n\n        return false; // Deny all access.\n\n        //return $file; // Grant access to all files on server.\n\n        // Limit to web root.\n        //return isset($_SERVER['DOCUMENT_ROOT'])\n        //    && ($file = realpath($file))\n        //    && preg_match('#^' . preg_quote($_SERVER['DOCUMENT_ROOT'] . DIRECTORY_SEPARATOR, '#') . '#', $file)\n        //    ? $file : false;\n    }\n\n    /**\n     * format of the trace drop down list\n     * default is: invokeurl (tracefile_name) [tracefile_size]\n     * the following options will be replaced:\n     *   %i - invoked url\n     *   %f - trace file name\n     *   %s - size of trace file\n     *   %m - modified time of file name (in dateFormat specified above)\n     */\n    static $traceFileListFormat = '%i (%f) [%s]';\n\n    /**\n     * Proxy functions are stepped over transparently. Functions listed here\n     * MUST make exactly one (though not necessarily the same one) function\n     * call per execution.\n     */\n    static $proxyFunctions = array( // resolve dynamic function calls in-place\n        'php::call_user_func',\n        'php::call_user_func_array',\n    );\n    //static $proxyFunctions = array(); // do not skip any functions\n\n    /**\n     * Specify which fields display, and the order to display them. Uncomment\n     * entries to enable, move entries to change order.\n     */\n    static $tableFields = array(\n        'Invocation Count',\n        'Total Self Cost',\n        //'Average Self Cost',\n        'Total Inclusive Cost',\n        //'Average Inclusive Cost',\n    );\n\n    #########################\n    # BELOW NOT FOR EDITING #\n    #########################\n\n    /**\n     * Regex that matches the trace files generated by xdebug\n     */\n    static function xdebugOutputFormat() {\n        $outputName = ini_get('xdebug.profiler_output_name');\n        if ($outputName=='') // Ini value not defined\n            $outputName = '/^cachegrind\\.out\\..+$/';\n        else\n            $outputName = '/^'.preg_replace('/(%[^%])+/', '.+', $outputName).'$/';\n        return $outputName;\n    }\n\n    /**\n     * Directory to search for trace files\n     *\n     * @return string xdebug output directory\n     */\n    static function xdebugOutputDir() {\n        // grab the Xdebug 3 output dir value\n        $dir = ini_get('xdebug.output_dir');\n\n        // if it's empty, check the Xdebug 2 value\n        if (empty($dir))\n            $dir = ini_get('xdebug.profiler_output_dir');\n\n        // If it's still empty, fall back to webgrind config\n        if (empty($dir))\n            $dir = Webgrind_Config::$profilerDir;\n\n        return realpath($dir).'/';\n    }\n\n    /**\n     * Writable dir for information storage\n     */\n    static function storageDir() {\n        if (!empty(Webgrind_Config::$storageDir))\n            return realpath(Webgrind_Config::$storageDir).'/';\n\n        if (!function_exists('sys_get_temp_dir') || !is_writable(sys_get_temp_dir())) {\n            // use xdebug setting\n            return Webgrind_Config::xdebugOutputDir();\n        }\n        return realpath(sys_get_temp_dir()).'/';\n    }\n\n    /**\n     * Binary version of the preprocessor (for faster preprocessing)\n     *\n     * If the proper tools are installed and the bin dir is writeable for php,\n     * automatically compile it (when necessary).\n     * Automatic compilation disabled if `bin/make-failed` exists.\n     * Run `make` in the webgrind root directory to manually compile.\n     */\n    static function getBinaryPreprocessor() {\n        $localBin = __DIR__.'/bin/';\n        $makeFailed = $localBin.'make-failed';\n        if (PHP_OS == 'WINNT') {\n            $binary = $localBin.'preprocessor.exe';\n        } else {\n            $binary = $localBin.'preprocessor';\n        }\n\n        if (!file_exists($binary) && is_writable($localBin) && !file_exists($makeFailed)) {\n            if (PHP_OS == 'WINNT') {\n                $success = static::compileBinaryPreprocessorWindows();\n            } else {\n                $success = static::compileBinaryPreprocessor();\n            }\n            if (!$success || !file_exists($binary)) {\n                touch($makeFailed);\n            }\n        }\n\n        return $binary;\n    }\n\n    static function compileBinaryPreprocessor() {\n        $make = '/usr/bin/make';\n        if (is_executable($make)) {\n            $cwd = getcwd();\n            chdir(__DIR__);\n            exec($make, $output, $retval);\n            chdir($cwd);\n            return $retval == 0;\n        }\n        return false;\n    }\n\n    static function compileBinaryPreprocessorWindows() {\n        if (getenv('VSAPPIDDIR')) {\n            $cwd = getcwd();\n            chdir(__DIR__);\n            exec('call \"%VSAPPIDDIR%\\..\\Tools\\vsdevcmd\\ext\\vcvars.bat\" && nmake -f nmakefile', $output, $retval);\n            chdir($cwd);\n            return $retval == 0;\n        } elseif (getenv('VS140COMNTOOLS')) {\n            $cwd = getcwd();\n            chdir(__DIR__);\n            exec('call \"%VS140COMNTOOLS%\\vsvars32.bat\" && nmake -f nmakefile', $output, $retval);\n            chdir($cwd);\n            return $retval == 0;\n        }\n        return false;\n    }\n}\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.2685546875,
          "content": "version: \"3\"\nservices:\n\n  webgrind:\n    image: jokkedk/webgrind:latest\n    restart: unless-stopped\n    ports:\n      - \"127.0.0.1:80:80\"\n    volumes:\n      # Replace '/path/to/xdebug/files' with the actual path of the xDebug profiling files\n      - /path/to/xdebug/files:/tmp\n"
        },
        {
          "name": "favicon.ico",
          "type": "blob",
          "size": 0.310546875,
          "content": null
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.php",
          "type": "blob",
          "size": 11.4130859375,
          "content": "<?php\n/**\n * @author Jacob Oettinger\n * @author Joakim Nygård\n */\n\n// Handle static files with PHP built-in webserver\nif (PHP_SAPI == 'cli-server') {\n    if (is_file(realpath(__DIR__ . $_SERVER['REQUEST_URI']))) {\n        return false;\n    }\n}\n\nclass Webgrind_MasterConfig\n{\n    static $webgrindVersion = '1.9.3';\n}\n\nrequire './config.php';\nrequire './library/FileHandler.php';\n\n// TODO: Errorhandling:\n//         No files, outputdir not writable\n\nset_time_limit(0);\n\n// Make sure we have a timezone for date functions.\nif (ini_get('date.timezone') == '')\n    date_default_timezone_set( Webgrind_Config::$defaultTimezone );\n\ntry {\n    switch (get('op')) {\n        case 'file_list':\n            sendJson(Webgrind_FileHandler::getInstance()->getTraceList());\n            break;\n\n        case 'function_list':\n            $dataFile = get('dataFile');\n            if ($dataFile=='0') {\n                $files = Webgrind_FileHandler::getInstance()->getTraceList();\n                $dataFile = $files[0]['filename'];\n            }\n            $reader = Webgrind_FileHandler::getInstance()->getTraceReader($dataFile, get('costFormat', Webgrind_Config::$defaultCostformat));\n            $functions = array();\n            $shownTotal = 0;\n            $breakdown = array('internal' => 0, 'procedural' => 0, 'class' => 0, 'include' => 0);\n\n            for ($i=0; $i<$reader->getFunctionCount(); $i++) {\n                $functionInfo = $reader->getFunctionInfo($i);\n\n                if (false !== strpos($functionInfo['functionName'], 'php::')) {\n                    $breakdown['internal'] += $functionInfo['summedSelfCostRaw'];\n                    $humanKind = 'internal';\n                } else if (false !== strpos($functionInfo['functionName'], 'require_once::') ||\n                          false !== strpos($functionInfo['functionName'], 'require::') ||\n                          false !== strpos($functionInfo['functionName'], 'include_once::') ||\n                          false !== strpos($functionInfo['functionName'], 'include::')) {\n                    $breakdown['include'] += $functionInfo['summedSelfCostRaw'];\n                    $humanKind = 'include';\n                } else {\n                    if (false !== strpos($functionInfo['functionName'], '->') || false !== strpos($functionInfo['functionName'], '::')) {\n                        $breakdown['class'] += $functionInfo['summedSelfCostRaw'];\n                        $humanKind = 'class';\n                    } else {\n                        $breakdown['procedural'] += $functionInfo['summedSelfCostRaw'];\n                        $humanKind = 'procedural';\n                    }\n                }\n                if (!(int)get('hideInternals', 0) || strpos($functionInfo['functionName'], 'php::') === false) {\n                    $shownTotal += $functionInfo['summedSelfCostRaw'];\n                    $functions[$i] = $functionInfo;\n                    $functions[$i]['nr'] = $i;\n                    $functions[$i]['humanKind'] = $humanKind;\n                }\n            }\n            usort($functions,'costCmp');\n\n            $remainingCost = $shownTotal*get('showFraction');\n\n            $result['functions'] = array();\n            foreach ($functions as $function) {\n                $remainingCost -= $function['summedSelfCostRaw'];\n                $function['file'] = urlencode($function['file']);\n                $result['functions'][] = $function;\n                if ($remainingCost<0)\n                    break;\n            }\n            $result['summedInvocationCount'] = $reader->getFunctionCount();\n            $result['summedRunTime'] = $reader->formatCost($reader->getHeader('summary'), 'msec');\n            $result['dataFile'] = $dataFile;\n            $result['invokeUrl'] = $reader->getHeader('cmd');\n            $result['runs'] = $reader->getHeader('runs');\n            $result['breakdown'] = $breakdown;\n            $result['mtime'] = date(Webgrind_Config::$dateFormat,filemtime(Webgrind_Config::xdebugOutputDir().$dataFile));\n\n            $creator = preg_replace('/[^0-9\\.]/', '', $reader->getHeader('creator'));\n            $result['linkToFunctionLine'] = version_compare($creator, '2.1') > 0;\n\n            sendJson($result);\n        break;\n\n        case 'callinfo_list':\n            $reader = Webgrind_FileHandler::getInstance()->getTraceReader(get('file'), get('costFormat', Webgrind_Config::$defaultCostformat));\n            $functionNr = get('functionNr');\n            $function = $reader->getFunctionInfo($functionNr);\n\n            $result = array('calledFrom'=>array(), 'subCalls'=>array());\n            $foundInvocations = 0;\n            for ($i=0; $i<$function['calledFromInfoCount']; $i++) {\n                $invo = $reader->getCalledFromInfo($functionNr, $i);\n                $foundInvocations += $invo['callCount'];\n                $callerInfo = $reader->getFunctionInfo($invo['functionNr']);\n                $invo['file'] = urlencode($callerInfo['file']);\n                $invo['callerFunctionName'] = $callerInfo['functionName'];\n                $result['calledFrom'][] = $invo;\n            }\n            $result['calledByHost'] = ($foundInvocations<$function['invocationCount']);\n\n            for ($i=0; $i<$function['subCallInfoCount']; $i++) {\n                $invo = $reader->getSubCallInfo($functionNr, $i);\n                $callInfo = $reader->getFunctionInfo($invo['functionNr']);\n                $invo['file'] = urlencode($function['file']); // Sub call to $callInfo['file'] but from $function['file']\n                $invo['callerFunctionName'] = $callInfo['functionName'];\n                $result['subCalls'][] = $invo;\n            }\n            sendJson($result);\n        break;\n\n        case 'fileviewer':\n            $file = get('file');\n\n            $message = 'No file to view.';\n            if ($file) {\n                $message = '<tt>' . htmlspecialchars($file) . '</tt> is not readable. '\n                    . 'Modify <tt>exposeServerFile()</tt> in <tt>webgrind/config.php</tt> to grant access.';\n                $file = Webgrind_Config::exposeServerFile($file);\n                if ($file && is_file($file) && is_readable($file)) {\n                    // Access granted.\n                    $message = '';\n                }\n            }\n            require 'templates/fileviewer.phtml';\n        break;\n\n        case 'function_graph':\n            $dataFile = get('dataFile');\n            $showFraction = 100 - intval(get('showFraction') * 100);\n            if ($dataFile == '0') {\n                $files = Webgrind_FileHandler::getInstance()->getTraceList();\n                $dataFile = $files[0]['filename'];\n            }\n\n            $filename = Webgrind_Config::storageDir().$dataFile.'-'.$showFraction.Webgrind_Config::$preprocessedSuffix.'.'.Webgrind_Config::$graphImageType;\n            if (!file_exists($filename)) {\n                // Add enclosing quotes if needed\n                foreach (array('pythonExecutable', 'dotExecutable') as $exe) {\n                    $item =& Webgrind_Config::$$exe;\n                    if (strpos($item, ' ') !== false && !preg_match('/^\".+\"$/', $item)) {\n                        $item = '\"'.$item.'\"';\n                    }\n                }\n                shell_exec(Webgrind_Config::$pythonExecutable.' library/gprof2dot.py -n '.$showFraction\n                           .' -f callgrind '.escapeshellarg(Webgrind_Config::xdebugOutputDir().$dataFile).' | '\n                           .Webgrind_Config::$dotExecutable.' -T'.Webgrind_Config::$graphImageType.' -o '.escapeshellarg($filename));\n            }\n\n            if (!file_exists($filename)) {\n                $file = $filename;\n                $message = 'Unable to generate <u>'.$file.'</u> via python: <u>'.Webgrind_Config::$pythonExecutable\n                          .'</u> and dot: <u>'.Webgrind_Config::$dotExecutable.'</u>. Please update config.php.';\n                require 'templates/fileviewer.phtml';\n                break;\n            }\n\n            if (Webgrind_Config::$graphImageType == 'svg') {\n                header('Content-Type: image/svg+xml');\n            } else {\n                header('Content-Type: image/'.Webgrind_Config::$graphImageType);\n            }\n            readfile($filename);\n        break;\n\n        case 'version_info':\n            $response = @file_get_contents('http://jokkedk.github.io/webgrind/webgrindupdate.json?version='.Webgrind_Config::$webgrindVersion);\n            if ($response) {\n                header('Content-type: application/json');\n                echo $response;\n            }\n        break;\n\n        case 'download_link':\n            $file = Webgrind_Config::exposeServerFile(Webgrind_Config::xdebugOutputDir().get('file'));\n\n            if (empty($file)) {\n                sendJson(array('error' => 'No file found or access denied!'));\n                exit;\n            }\n\n            $params = array('op' => 'download_file', 'file' => get('file'));\n            sendJson(array('done' => '?'.http_build_query($params)));\n        break;\n\n        case 'download_file':\n            $file = Webgrind_Config::exposeServerFile(Webgrind_Config::xdebugOutputDir().get('file'));\n\n            if (empty($file)) {\n                exit;\n            }\n\n            header('Cache-Control: public');\n            header('Content-Description: File Transfer');\n            header('Content-Disposition: attachment; filename='.get('file'));\n            header('Content-Type: text/plain');\n            header('Content-Transfer-Encoding: binary');\n\n            readfile($file);\n        break;\n\n        case 'clear_files':\n            $files = Webgrind_FileHandler::getInstance()->getTraceList();\n            if (!$files) {\n                sendJson(array('done' => 'no files found'));\n                break;\n            }\n            $format = array();\n            foreach ($files as $file) {\n                unlink(Webgrind_Config::xdebugOutputDir().$file['filename']);\n                $format[] = preg_quote($file['filename'], '/');\n            }\n            $files = preg_grep('/'.implode('|', $format).'/', scandir(Webgrind_Config::storageDir()));\n            foreach ($files as $file) {\n                unlink(Webgrind_Config::storageDir().$file);\n            }\n            sendJson(array('done' => true));\n        break;\n\n        default:\n            $welcome = '';\n            if (!file_exists(Webgrind_Config::storageDir()) || !is_writable(Webgrind_Config::storageDir())) {\n                $welcome .= 'Webgrind $storageDir does not exist or is not writeable: <code>'.Webgrind_Config::storageDir().'</code><br>';\n            }\n            if (!file_exists(Webgrind_Config::xdebugOutputDir()) || !is_readable(Webgrind_Config::xdebugOutputDir())) {\n                $welcome .= 'Webgrind $profilerDir does not exist or is not readable: <code>'.Webgrind_Config::xdebugOutputDir().'</code><br>';\n            }\n\n            if ($welcome == '') {\n                $welcome = 'Select a cachegrind file above<br>(looking in <code>'.Webgrind_Config::xdebugOutputDir().'</code> for files matching <code>'.Webgrind_Config::xdebugOutputFormat().'</code>)';\n            }\n            require 'templates/index.phtml';\n    }\n} catch (Exception $e) {\n    sendJson(array('error' => $e->getMessage().'<br>'.$e->getFile().', line '.$e->getLine()));\n    return;\n}\n\nfunction get($param, $default=false) {\n    return (isset($_GET[$param])? $_GET[$param] : $default);\n}\n\nfunction costCmp($a, $b) {\n    $a = $a['summedSelfCostRaw'];\n    $b = $b['summedSelfCostRaw'];\n\n    if ($a == $b) {\n        return 0;\n    }\n    return ($a > $b) ? -1 : 1;\n}\n\nfunction sendJson($object) {\n    header('Content-type: application/json');\n    echo json_encode($object);\n}\n"
        },
        {
          "name": "js",
          "type": "tree",
          "content": null
        },
        {
          "name": "library",
          "type": "tree",
          "content": null
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 1.591796875,
          "content": "Software License Agreement (BSD License)\n\nCopyright (c) 2008-2011, Jacob Oettinger & Joakim Nygård\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms, with or without modification, are\npermitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of Jacob Oettinger and Joakim Nygård nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of Jacob Oettinger and Joakim Nygård.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\nTORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\nADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
          "name": "makefile",
          "type": "blob",
          "size": 0.3349609375,
          "content": "CXX = g++\nSRCS = library/preprocessor.cpp\nOUT = bin/preprocessor\n\n\nall: $(OUT)\n\nhelp:\n\t@echo \"Targets:\"\n\t@echo \"  all     - build preprocessor\"\n\t@echo \"  clean   - clear generated binaries\"\n\t@echo \"  help    - show this message\\n\"\n\nclean:\n\trm -f $(OUT)\n\n$(OUT): $(SRCS)\n\t$(CXX) -o $(OUT) -O2 -s $(SRCS) -lz -DWITH_ZLIB\n\n.PHONY: all help clean\n"
        },
        {
          "name": "package.sh",
          "type": "blob",
          "size": 0.419921875,
          "content": "#!/bin/sh\nif [ -z $1 ]\nthen\n  echo \"Usage: package.sh <tag>\"\nelse\n\tmkdir package_tmp\n\trm webgrind-$1.zip\n\tcd package_tmp\n\tgit clone https://github.com/jokkedk/webgrind.git\n\tcd webgrind\n\tgit checkout $1\n\tcd ..\n\tgit clone https://github.com/jokkedk/webgrind.wiki.git webgrind/docs\n\trm -rf webgrind/.git webgrind/docs/.git webgrind/package.sh webgrind/bin/.gitignore\n\tzip -r ../webgrind-$1.zip webgrind\n\tcd ..\n\trm -rf package_tmp\nfi\n"
        },
        {
          "name": "styles",
          "type": "tree",
          "content": null
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}