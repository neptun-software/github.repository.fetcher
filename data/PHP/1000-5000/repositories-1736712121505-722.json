{
  "metadata": {
    "timestamp": 1736712121505,
    "page": 722,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjczMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fossasia/wp-recent-tweet",
      "stars": 1506,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.09765625,
          "content": "[submodule \"loklak_php_api\"]\n\tpath = loklak_php_api\n\turl = https://github.com/loklak/loklak_php_api\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "fa_twitter_plugin.css",
          "type": "blob",
          "size": 0.4677734375,
          "content": ".fa_recent_tweets {\r\n\tclear: left;\r\n\r\n}\r\n\r\n.fa_recent_tweets  li {\r\n\tbackground-image: url('assets/tweet.png');\r\n\tbackground-repeat: no-repeat;\t\r\n\tbackground-position: 0px 4px;\r\n\tpadding-left: 30px;\r\n\tpadding-bottom: 20px;\r\n\tclear: left;\r\n\tline-height: 20px;\r\n\tlist-style-type: none;\r\n}\r\n\r\n.fa_recent_tweets  li a {\r\n\tfont-weight: bold;\t\r\n}\r\n\r\n.fa_recent_tweets .twitter_time {\r\n\tdisplay:block;\r\n\tcolor: #999;\r\n\tfont-size: 12px;\r\n\tfont-style: italic;\t\r\n\tfont-weight: normal;\r\n}\r\n"
        },
        {
          "name": "index.php",
          "type": "blob",
          "size": 0.0283203125,
          "content": "<?php\n# Silence is golden.\n?>"
        },
        {
          "name": "loklak_php_api",
          "type": "commit",
          "content": null
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 2.50390625,
          "content": "=== Recent Tweets Widget ===\n\nContributors: noahkagan\nTags: recent tweets, twitter widget, twitter api v1.1, cache, twitter, tweets, social media\nRequires at least: 3.4.1\nTested up to: 4.5\nStable tag: 1.6.5\nLicense: GPLv2 or later\nLicense URI: http://www.gnu.org/licenses/gpl-2.0.html\n\nRecent Tweets Widget plugin for new Twitter API v1.1 with CACHE, so you won't be rate limited at Twitter!\n\n== Description ==\n\nRecent Tweets Widget plugin for Twitter API v1.1 with Cache. It uses the new Twitter API v1.1 and stores tweets in the cache. It means that it will read status messages from your database and it doesn't query Twitter.com for every page load so you won't be rate limited. You can set how often you want to update the cache.\n\n\n== Installation ==\n\n1. Unzip the downloaded zip file.\n2. Upload the `recent-tweets` folder and its contents into the `wp-content/plugins/` directory of your WordPress installation\n3. Activate Recent Tweets Widget from Plugins page.\n4. Go to your Widgets menu, add `* Recent Tweets` widget to a widget area.\n5. Visit [https://apps.twitter.com/](https://apps.twitter.com/ \"Twitter\") in a new tab, sign in with your account, click on `Create a new application` and create your own keys if you haven't already.\n6. Fill all your widget settings.\n7. Enjoy your new Twitter feed! :)\n\n\n== Frequently Asked Questions ==\n\n= How can I get Consumer Key, Consumer Secret, Access Token and Access Token Secret?  =\n\nYou will need to visit [https://apps.twitter.com/](https://apps.twitter.com/ \"Twitter\"), sign in with your account and create your own keys.\n\n== Screenshots ==\n\n1. The widget\n\n\t![The widget](./assets/screenshot-1.png)\n2. How it looks on frontend page\n\n\t![How it looks on frontend page](./assets/screenshot-2.png)\n\n== Changelog ==\n\n= 1.6.5 =\n* Updated twitter logo\n* Removed line break before time link and use css instead\n* Fixed some undefined array key and undefined notices\n* Fix for redeclaring OAuthException class\n\n= 1.6.4 =\n* Fix widget for WP 4.3\n\n= 1.6 =\n* Fix bug on settings page\n\n= 1.5 =\n* Settings page and other updates\n\n= 1.4 =\n* PHP 5.5 deprecated preg_replace() function fix\n* Added gettext calls for easier translation\n\n= 1.3 =\n* Fix for special 4 byte UTF8 characters\n\n= 1.2 =\n* Header output issue fix\n\n= 1.1 =\n* Some styling issues were fixed\n* Now the script checks if a function already exists\n* Special function naming are applied so function dupes are also prevented\n* Exclude replies option has been added\n\n= 1.0 =\n* The first version of this plugin! Enjoy! :)\n\n== Upgrade Notice ==\n\n= 1.0 =\n\nNone.\n\n"
        },
        {
          "name": "readme.txt",
          "type": "blob",
          "size": 2.0107421875,
          "content": "=== Recent Tweet ===\nContributors: fossasia\nTags: loklak, loklak widget, loklak api, recent tweets, twitter widget, twitter api v1.1, cache, twitter, tweets, social media\nRequires at least: 3.4.1\nTested up to: 4.5.3\nStable tag: 1.0\nLicense: GPLv2 or later\nLicense URI: http://www.gnu.org/licenses/gpl-2.0.html\n\nRecent Tweet plugin for anonymous Loklak API and new Twitter API v1.1 with CACHE, so you won't be rate limited!\n\n== Description ==\n\nRecent Tweet plugin for anonymous Loklak API and Twitter API v1.1 with Cache. It supports the new Twitter API v1.1 and stores tweets in the cache. It means that it will read status messages from your database and it doesn't query loklak.org or Twitter.com for every page load so you won't be rate limited. You can set how often you want to update the cache.\n\n\n== Installation ==\n\n1. Unzip the downloaded zip file.\n2. Upload the `recent-tweet` folder and its contents into the `wp-content/plugins/` directory of your WordPress installation\n3. Activate Recent Tweet widget from Plugins page.\n4. Go to your Widgets menu, add `* Recent Tweet` widget to a widget area.\n5. Tick the checkbox to use Loklak API\n\tOR\n   Visit [https://apps.twitter.com/](https://apps.twitter.com/ \"Twitter\") in a new tab, sign in with your account, click on `Create a new application` and create your own keys if you haven't already.\n6. Fill all your widget settings.\n7. Enjoy your new Tweet feed! :)\n\n\n== Frequently Asked Questions ==\n\n= Why should I use Loklak API?  =\n\nAPI from loklak.org is anonymous and does not require any registration. It provides twitter like experience without the cumbersome Twitter App Registration issues.\n\n= How can I get Consumer Key, Consumer Secret, Access Token and Access Token Secret?  =\n\nYou will need to visit [https://apps.twitter.com/](https://apps.twitter.com/ \"Twitter\"), sign in with your account and create your own keys.\n\n== Screenshots ==\n\n1. The widget\n2. How it looks on frontend page\n\n== Changelog ==\n\n= 1.0 =\n* The first version of this plugin! Enjoy! :)\n\n== Upgrade Notice ==\n\n= 1.0 =\nNone.\n"
        },
        {
          "name": "recent-tweet.php",
          "type": "blob",
          "size": 1.1669921875,
          "content": "<?php\r\n\r\n/*\r\nPlugin Name: Recent Tweet\r\nPlugin URI: http://wordpress.org/extend/plugins/recent-tweet/\r\nDescription: Recent Tweet plugin for anonymous Loklak API and Twitter API v1.1 with Cache. It supports the new Twitter API v1.1 and stores tweets in the cache. It means that it will read status messages from your database and it doesn't query loklak.org or Twitter.com for every page load so you won't be rate limited. You can set how often you want to update the cache.\r\nVersion: 1.0\r\nAuthor: FOSSASIA\r\nAuthor URI: http://twitter.com/fossasia\r\n*/\r\n\r\n//error_reporting(E_ALL);\r\n//ini_set('display_errors', '1');\r\n\r\n// make sure we don't expose any info if called directly\r\nif ( !function_exists( 'add_action' ) ) {\r\n\techo 'Hi there!  I\\'m just a plugin, not much I can do when called directly.';\r\n\texit;\r\n}\r\n\r\ndefine('FA_RECENT_TWEET_PATH', plugin_dir_url( __FILE__ ));\r\n\r\n//register stylesheet for widget\r\nfunction fa_twitter_plugin_styles() {\r\n\twp_enqueue_style( 'fa_twitter_plugin_css', FA_RECENT_TWEET_PATH . 'fa_twitter_plugin.css', array(), '1.0', 'screen' );\r\n}\r\nadd_action( 'wp_enqueue_scripts', 'fa_twitter_plugin_styles' );\r\n\r\n// include widget function\r\nrequire_once('widget.php');"
        },
        {
          "name": "twitteroauth.php",
          "type": "blob",
          "size": 33.2998046875,
          "content": "<?php\n\n/*\n * Abraham Williams (abraham@abrah.am) http://abrah.am\n *\n * The first PHP Library to support OAuth for Twitter's REST API.\n */\n\n/* Load OAuth lib. You can find it at http://oauth.net */\n\n\t\t/* Generic exception class\n\t\t */\n\t\tif ( ! class_exists('OAuthException')) {\n\t\t\tclass OAuthException extends Exception {\n\t\t\t  // pass\n\t\t\t}\n\t\t}\n\n\t\tclass OAuthConsumer {\n\t\t  public $key;\n\t\t  public $secret;\n\n\t\t  function __construct($key, $secret, $callback_url=NULL) {\n\t\t\t$this->key = $key;\n\t\t\t$this->secret = $secret;\n\t\t\t$this->callback_url = $callback_url;\n\t\t  }\n\n\t\t  function __toString() {\n\t\t\treturn \"OAuthConsumer[key=$this->key,secret=$this->secret]\";\n\t\t  }\n\t\t}\n\n\t\tclass OAuthToken {\n\t\t  // access tokens and request tokens\n\t\t  public $key;\n\t\t  public $secret;\n\n\t\t  /**\n\t\t   * key = the token\n\t\t   * secret = the token secret\n\t\t   */\n\t\t  function __construct($key, $secret) {\n\t\t\t$this->key = $key;\n\t\t\t$this->secret = $secret;\n\t\t  }\n\n\t\t  /**\n\t\t   * generates the basic string serialization of a token that a server\n\t\t   * would respond to request_token and access_token calls with\n\t\t   */\n\t\t  function to_string() {\n\t\t\treturn \"oauth_token=\" .\n\t\t\t\t   OAuthUtil::urlencode_rfc3986($this->key) .\n\t\t\t\t   \"&oauth_token_secret=\" .\n\t\t\t\t   OAuthUtil::urlencode_rfc3986($this->secret);\n\t\t  }\n\n\t\t  function __toString() {\n\t\t\treturn $this->to_string();\n\t\t  }\n\t\t}\n\n\t\t/**\n\t\t * A class for implementing a Signature Method\n\t\t * See section 9 (\"Signing Requests\") in the spec\n\t\t */\n\t\tabstract class OAuthSignatureMethod {\n\t\t  /**\n\t\t   * Needs to return the name of the Signature Method (ie HMAC-SHA1)\n\t\t   * @return string\n\t\t   */\n\t\t  abstract public function get_name();\n\n\t\t  /**\n\t\t   * Build up the signature\n\t\t   * NOTE: The output of this function MUST NOT be urlencoded.\n\t\t   * the encoding is handled in OAuthRequest when the final\n\t\t   * request is serialized\n\t\t   * @param OAuthRequest $request\n\t\t   * @param OAuthConsumer $consumer\n\t\t   * @param OAuthToken $token\n\t\t   * @return string\n\t\t   */\n\t\t  abstract public function build_signature($request, $consumer, $token);\n\n\t\t  /**\n\t\t   * Verifies that a given signature is correct\n\t\t   * @param OAuthRequest $request\n\t\t   * @param OAuthConsumer $consumer\n\t\t   * @param OAuthToken $token\n\t\t   * @param string $signature\n\t\t   * @return bool\n\t\t   */\n\t\t  public function check_signature($request, $consumer, $token, $signature) {\n\t\t\t$built = $this->build_signature($request, $consumer, $token);\n\t\t\treturn $built == $signature;\n\t\t  }\n\t\t}\n\n\t\t/**\n\t\t * The HMAC-SHA1 signature method uses the HMAC-SHA1 signature algorithm as defined in [RFC2104] \n\t\t * where the Signature Base String is the text and the key is the concatenated values (each first \n\t\t * encoded per Parameter Encoding) of the Consumer Secret and Token Secret, separated by an '&' \n\t\t * character (ASCII code 38) even if empty.\n\t\t *   - Chapter 9.2 (\"HMAC-SHA1\")\n\t\t */\n\t\tclass OAuthSignatureMethod_HMAC_SHA1 extends OAuthSignatureMethod {\n\t\t  function get_name() {\n\t\t\treturn \"HMAC-SHA1\";\n\t\t  }\n\n\t\t  public function build_signature($request, $consumer, $token) {\n\t\t\t$base_string = $request->get_signature_base_string();\n\t\t\t$request->base_string = $base_string;\n\n\t\t\t$key_parts = array(\n\t\t\t  $consumer->secret,\n\t\t\t  ($token) ? $token->secret : \"\"\n\t\t\t);\n\n\t\t\t$key_parts = OAuthUtil::urlencode_rfc3986($key_parts);\n\t\t\t$key = implode('&', $key_parts);\n\n\t\t\treturn base64_encode(hash_hmac('sha1', $base_string, $key, true));\n\t\t  }\n\t\t}\n\n\t\t/**\n\t\t * The PLAINTEXT method does not provide any security protection and SHOULD only be used \n\t\t * over a secure channel such as HTTPS. It does not use the Signature Base String.\n\t\t *   - Chapter 9.4 (\"PLAINTEXT\")\n\t\t */\n\t\tclass OAuthSignatureMethod_PLAINTEXT extends OAuthSignatureMethod {\n\t\t  public function get_name() {\n\t\t\treturn \"PLAINTEXT\";\n\t\t  }\n\n\t\t  /**\n\t\t   * oauth_signature is set to the concatenated encoded values of the Consumer Secret and \n\t\t   * Token Secret, separated by a '&' character (ASCII code 38), even if either secret is \n\t\t   * empty. The result MUST be encoded again.\n\t\t   *   - Chapter 9.4.1 (\"Generating Signatures\")\n\t\t   *\n\t\t   * Please note that the second encoding MUST NOT happen in the SignatureMethod, as\n\t\t   * OAuthRequest handles this!\n\t\t   */\n\t\t  public function build_signature($request, $consumer, $token) {\n\t\t\t$key_parts = array(\n\t\t\t  $consumer->secret,\n\t\t\t  ($token) ? $token->secret : \"\"\n\t\t\t);\n\n\t\t\t$key_parts = OAuthUtil::urlencode_rfc3986($key_parts);\n\t\t\t$key = implode('&', $key_parts);\n\t\t\t$request->base_string = $key;\n\n\t\t\treturn $key;\n\t\t  }\n\t\t}\n\n\t\t/**\n\t\t * The RSA-SHA1 signature method uses the RSASSA-PKCS1-v1_5 signature algorithm as defined in \n\t\t * [RFC3447] section 8.2 (more simply known as PKCS#1), using SHA-1 as the hash function for \n\t\t * EMSA-PKCS1-v1_5. It is assumed that the Consumer has provided its RSA public key in a \n\t\t * verified way to the Service Provider, in a manner which is beyond the scope of this \n\t\t * specification.\n\t\t *   - Chapter 9.3 (\"RSA-SHA1\")\n\t\t */\n\t\tabstract class OAuthSignatureMethod_RSA_SHA1 extends OAuthSignatureMethod {\n\t\t  public function get_name() {\n\t\t\treturn \"RSA-SHA1\";\n\t\t  }\n\n\t\t  // Up to the SP to implement this lookup of keys. Possible ideas are:\n\t\t  // (1) do a lookup in a table of trusted certs keyed off of consumer\n\t\t  // (2) fetch via http using a url provided by the requester\n\t\t  // (3) some sort of specific discovery code based on request\n\t\t  //\n\t\t  // Either way should return a string representation of the certificate\n\t\t  protected abstract function fetch_public_cert(&$request);\n\n\t\t  // Up to the SP to implement this lookup of keys. Possible ideas are:\n\t\t  // (1) do a lookup in a table of trusted certs keyed off of consumer\n\t\t  //\n\t\t  // Either way should return a string representation of the certificate\n\t\t  protected abstract function fetch_private_cert(&$request);\n\n\t\t  public function build_signature($request, $consumer, $token) {\n\t\t\t$base_string = $request->get_signature_base_string();\n\t\t\t$request->base_string = $base_string;\n\n\t\t\t// Fetch the private key cert based on the request\n\t\t\t$cert = $this->fetch_private_cert($request);\n\n\t\t\t// Pull the private key ID from the certificate\n\t\t\t$privatekeyid = openssl_get_privatekey($cert);\n\n\t\t\t// Sign using the key\n\t\t\t$ok = openssl_sign($base_string, $signature, $privatekeyid);\n\n\t\t\t// Release the key resource\n\t\t\topenssl_free_key($privatekeyid);\n\n\t\t\treturn base64_encode($signature);\n\t\t  }\n\n\t\t  public function check_signature($request, $consumer, $token, $signature) {\n\t\t\t$decoded_sig = base64_decode($signature);\n\n\t\t\t$base_string = $request->get_signature_base_string();\n\n\t\t\t// Fetch the public key cert based on the request\n\t\t\t$cert = $this->fetch_public_cert($request);\n\n\t\t\t// Pull the public key ID from the certificate\n\t\t\t$publickeyid = openssl_get_publickey($cert);\n\n\t\t\t// Check the computed signature against the one passed in the query\n\t\t\t$ok = openssl_verify($base_string, $decoded_sig, $publickeyid);\n\n\t\t\t// Release the key resource\n\t\t\topenssl_free_key($publickeyid);\n\n\t\t\treturn $ok == 1;\n\t\t  }\n\t\t}\n\n\t\tclass OAuthRequest {\n\t\t  private $parameters;\n\t\t  private $http_method;\n\t\t  private $http_url;\n\t\t  // for debug purposes\n\t\t  public $base_string;\n\t\t  public static $version = '1.0';\n\t\t  public static $POST_INPUT = 'php://input';\n\n\t\t  function __construct($http_method, $http_url, $parameters=NULL) {\n\t\t\t@$parameters or $parameters = array();\n\t\t\t$parameters = array_merge( OAuthUtil::parse_parameters(parse_url($http_url, PHP_URL_QUERY)), $parameters);\n\t\t\t$this->parameters = $parameters;\n\t\t\t$this->http_method = $http_method;\n\t\t\t$this->http_url = $http_url;\n\t\t  }\n\n\n\t\t  /**\n\t\t   * attempt to build up a request from what was passed to the server\n\t\t   */\n\t\t  public static function from_request($http_method=NULL, $http_url=NULL, $parameters=NULL) {\n\t\t\t$scheme = (!isset($_SERVER['HTTPS']) || $_SERVER['HTTPS'] != \"on\")\n\t\t\t\t\t  ? 'http'\n\t\t\t\t\t  : 'https';\n\t\t\t@$http_url or $http_url = $scheme .\n\t\t\t\t\t\t\t\t\t  '://' . $_SERVER['HTTP_HOST'] .\n\t\t\t\t\t\t\t\t\t  ':' .\n\t\t\t\t\t\t\t\t\t  $_SERVER['SERVER_PORT'] .\n\t\t\t\t\t\t\t\t\t  $_SERVER['REQUEST_URI'];\n\t\t\t@$http_method or $http_method = $_SERVER['REQUEST_METHOD'];\n\n\t\t\t// We weren't handed any parameters, so let's find the ones relevant to\n\t\t\t// this request.\n\t\t\t// If you run XML-RPC or similar you should use this to provide your own\n\t\t\t// parsed parameter-list\n\t\t\tif (!$parameters) {\n\t\t\t  // Find request headers\n\t\t\t  $request_headers = OAuthUtil::get_headers();\n\n\t\t\t  // Parse the query-string to find GET parameters\n\t\t\t  $parameters = OAuthUtil::parse_parameters($_SERVER['QUERY_STRING']);\n\n\t\t\t  // It's a POST request of the proper content-type, so parse POST\n\t\t\t  // parameters and add those overriding any duplicates from GET\n\t\t\t  if ($http_method == \"POST\"\n\t\t\t\t  && @strstr($request_headers[\"Content-Type\"],\n\t\t\t\t\t\t\t \"application/x-www-form-urlencoded\")\n\t\t\t\t  ) {\n\t\t\t\t$post_data = OAuthUtil::parse_parameters(\n\t\t\t\t  file_get_contents(self::$POST_INPUT)\n\t\t\t\t);\n\t\t\t\t$parameters = array_merge($parameters, $post_data);\n\t\t\t  }\n\n\t\t\t  // We have a Authorization-header with OAuth data. Parse the header\n\t\t\t  // and add those overriding any duplicates from GET or POST\n\t\t\t  if (@substr($request_headers['Authorization'], 0, 6) == \"OAuth \") {\n\t\t\t\t$header_parameters = OAuthUtil::split_header(\n\t\t\t\t  $request_headers['Authorization']\n\t\t\t\t);\n\t\t\t\t$parameters = array_merge($parameters, $header_parameters);\n\t\t\t  }\n\n\t\t\t}\n\n\t\t\treturn new OAuthRequest($http_method, $http_url, $parameters);\n\t\t  }\n\n\t\t  /**\n\t\t   * pretty much a helper function to set up the request\n\t\t   */\n\t\t  public static function from_consumer_and_token($consumer, $token, $http_method, $http_url, $parameters=NULL) {\n\t\t\t@$parameters or $parameters = array();\n\t\t\t$defaults = array(\"oauth_version\" => OAuthRequest::$version,\n\t\t\t\t\t\t\t  \"oauth_nonce\" => OAuthRequest::generate_nonce(),\n\t\t\t\t\t\t\t  \"oauth_timestamp\" => OAuthRequest::generate_timestamp(),\n\t\t\t\t\t\t\t  \"oauth_consumer_key\" => $consumer->key);\n\t\t\tif ($token)\n\t\t\t  $defaults['oauth_token'] = $token->key;\n\n\t\t\t$parameters = array_merge($defaults, $parameters);\n\n\t\t\treturn new OAuthRequest($http_method, $http_url, $parameters);\n\t\t  }\n\n\t\t  public function set_parameter($name, $value, $allow_duplicates = true) {\n\t\t\tif ($allow_duplicates && isset($this->parameters[$name])) {\n\t\t\t  // We have already added parameter(s) with this name, so add to the list\n\t\t\t  if (is_scalar($this->parameters[$name])) {\n\t\t\t\t// This is the first duplicate, so transform scalar (string)\n\t\t\t\t// into an array so we can add the duplicates\n\t\t\t\t$this->parameters[$name] = array($this->parameters[$name]);\n\t\t\t  }\n\n\t\t\t  $this->parameters[$name][] = $value;\n\t\t\t} else {\n\t\t\t  $this->parameters[$name] = $value;\n\t\t\t}\n\t\t  }\n\n\t\t  public function get_parameter($name) {\n\t\t\treturn isset($this->parameters[$name]) ? $this->parameters[$name] : null;\n\t\t  }\n\n\t\t  public function get_parameters() {\n\t\t\treturn $this->parameters;\n\t\t  }\n\n\t\t  public function unset_parameter($name) {\n\t\t\tunset($this->parameters[$name]);\n\t\t  }\n\n\t\t  /**\n\t\t   * The request parameters, sorted and concatenated into a normalized string.\n\t\t   * @return string\n\t\t   */\n\t\t  public function get_signable_parameters() {\n\t\t\t// Grab all parameters\n\t\t\t$params = $this->parameters;\n\n\t\t\t// Remove oauth_signature if present\n\t\t\t// Ref: Spec: 9.1.1 (\"The oauth_signature parameter MUST be excluded.\")\n\t\t\tif (isset($params['oauth_signature'])) {\n\t\t\t  unset($params['oauth_signature']);\n\t\t\t}\n\n\t\t\treturn OAuthUtil::build_http_query($params);\n\t\t  }\n\n\t\t  /**\n\t\t   * Returns the base string of this request\n\t\t   *\n\t\t   * The base string defined as the method, the url\n\t\t   * and the parameters (normalized), each urlencoded\n\t\t   * and the concated with &.\n\t\t   */\n\t\t  public function get_signature_base_string() {\n\t\t\t$parts = array(\n\t\t\t  $this->get_normalized_http_method(),\n\t\t\t  $this->get_normalized_http_url(),\n\t\t\t  $this->get_signable_parameters()\n\t\t\t);\n\n\t\t\t$parts = OAuthUtil::urlencode_rfc3986($parts);\n\n\t\t\treturn implode('&', $parts);\n\t\t  }\n\n\t\t  /**\n\t\t   * just uppercases the http method\n\t\t   */\n\t\t  public function get_normalized_http_method() {\n\t\t\treturn strtoupper($this->http_method);\n\t\t  }\n\n\t\t  /**\n\t\t   * parses the url and rebuilds it to be\n\t\t   * scheme://host/path\n\t\t   */\n\t\t  public function get_normalized_http_url() {\n\t\t\t$parts = parse_url($this->http_url);\n\n\t\t\t$port = @$parts['port'];\n\t\t\t$scheme = $parts['scheme'];\n\t\t\t$host = $parts['host'];\n\t\t\t$path = @$parts['path'];\n\n\t\t\t$port or $port = ($scheme == 'https') ? '443' : '80';\n\n\t\t\tif (($scheme == 'https' && $port != '443')\n\t\t\t\t|| ($scheme == 'http' && $port != '80')) {\n\t\t\t  $host = \"$host:$port\";\n\t\t\t}\n\t\t\treturn \"$scheme://$host$path\";\n\t\t  }\n\n\t\t  /**\n\t\t   * builds a url usable for a GET request\n\t\t   */\n\t\t  public function to_url() {\n\t\t\t$post_data = $this->to_postdata();\n\t\t\t$out = $this->get_normalized_http_url();\n\t\t\tif ($post_data) {\n\t\t\t  $out .= '?'.$post_data;\n\t\t\t}\n\t\t\treturn $out;\n\t\t  }\n\n\t\t  /**\n\t\t   * builds the data one would send in a POST request\n\t\t   */\n\t\t  public function to_postdata() {\n\t\t\treturn OAuthUtil::build_http_query($this->parameters);\n\t\t  }\n\n\t\t  /**\n\t\t   * builds the Authorization: header\n\t\t   */\n\t\t  public function to_header($realm=null) {\n\t\t\t$first = true;\n\t\t\tif($realm) {\n\t\t\t  $out = 'Authorization: OAuth realm=\"' . OAuthUtil::urlencode_rfc3986($realm) . '\"';\n\t\t\t  $first = false;\n\t\t\t} else\n\t\t\t  $out = 'Authorization: OAuth';\n\n\t\t\t$total = array();\n\t\t\tforeach ($this->parameters as $k => $v) {\n\t\t\t  if (substr($k, 0, 5) != \"oauth\") continue;\n\t\t\t  if (is_array($v)) {\n\t\t\t\tthrow new OAuthException('Arrays not supported in headers');\n\t\t\t  }\n\t\t\t  $out .= ($first) ? ' ' : ',';\n\t\t\t  $out .= OAuthUtil::urlencode_rfc3986($k) .\n\t\t\t\t\t  '=\"' .\n\t\t\t\t\t  OAuthUtil::urlencode_rfc3986($v) .\n\t\t\t\t\t  '\"';\n\t\t\t  $first = false;\n\t\t\t}\n\t\t\treturn $out;\n\t\t  }\n\n\t\t  public function __toString() {\n\t\t\treturn $this->to_url();\n\t\t  }\n\n\n\t\t  public function sign_request($signature_method, $consumer, $token) {\n\t\t\t$this->set_parameter(\n\t\t\t  \"oauth_signature_method\",\n\t\t\t  $signature_method->get_name(),\n\t\t\t  false\n\t\t\t);\n\t\t\t$signature = $this->build_signature($signature_method, $consumer, $token);\n\t\t\t$this->set_parameter(\"oauth_signature\", $signature, false);\n\t\t  }\n\n\t\t  public function build_signature($signature_method, $consumer, $token) {\n\t\t\t$signature = $signature_method->build_signature($this, $consumer, $token);\n\t\t\treturn $signature;\n\t\t  }\n\n\t\t  /**\n\t\t   * util function: current timestamp\n\t\t   */\n\t\t  private static function generate_timestamp() {\n\t\t\treturn time();\n\t\t  }\n\n\t\t  /**\n\t\t   * util function: current nonce\n\t\t   */\n\t\t  private static function generate_nonce() {\n\t\t\t$mt = microtime();\n\t\t\t$rand = mt_rand();\n\n\t\t\treturn md5($mt . $rand); // md5s look nicer than numbers\n\t\t  }\n\t\t}\n\n\t\tclass OAuthServer {\n\t\t  protected $timestamp_threshold = 300; // in seconds, five minutes\n\t\t  protected $version = '1.0';             // hi blaine\n\t\t  protected $signature_methods = array();\n\n\t\t  protected $data_store;\n\n\t\t  function __construct($data_store) {\n\t\t\t$this->data_store = $data_store;\n\t\t  }\n\n\t\t  public function add_signature_method($signature_method) {\n\t\t\t$this->signature_methods[$signature_method->get_name()] =\n\t\t\t  $signature_method;\n\t\t  }\n\n\t\t  // high level functions\n\n\t\t  /**\n\t\t   * process a request_token request\n\t\t   * returns the request token on success\n\t\t   */\n\t\t  public function fetch_request_token(&$request) {\n\t\t\t$this->get_version($request);\n\n\t\t\t$consumer = $this->get_consumer($request);\n\n\t\t\t// no token required for the initial token request\n\t\t\t$token = NULL;\n\n\t\t\t$this->check_signature($request, $consumer, $token);\n\n\t\t\t// Rev A change\n\t\t\t$callback = $request->get_parameter('oauth_callback');\n\t\t\t$new_token = $this->data_store->new_request_token($consumer, $callback);\n\n\t\t\treturn $new_token;\n\t\t  }\n\n\t\t  /**\n\t\t   * process an access_token request\n\t\t   * returns the access token on success\n\t\t   */\n\t\t  public function fetch_access_token(&$request) {\n\t\t\t$this->get_version($request);\n\n\t\t\t$consumer = $this->get_consumer($request);\n\n\t\t\t// requires authorized request token\n\t\t\t$token = $this->get_token($request, $consumer, \"request\");\n\n\t\t\t$this->check_signature($request, $consumer, $token);\n\n\t\t\t// Rev A change\n\t\t\t$verifier = $request->get_parameter('oauth_verifier');\n\t\t\t$new_token = $this->data_store->new_access_token($token, $consumer, $verifier);\n\n\t\t\treturn $new_token;\n\t\t  }\n\n\t\t  /**\n\t\t   * verify an api call, checks all the parameters\n\t\t   */\n\t\t  public function verify_request(&$request) {\n\t\t\t$this->get_version($request);\n\t\t\t$consumer = $this->get_consumer($request);\n\t\t\t$token = $this->get_token($request, $consumer, \"access\");\n\t\t\t$this->check_signature($request, $consumer, $token);\n\t\t\treturn array($consumer, $token);\n\t\t  }\n\n\t\t  // Internals from here\n\t\t  /**\n\t\t   * version 1\n\t\t   */\n\t\t  private function get_version(&$request) {\n\t\t\t$version = $request->get_parameter(\"oauth_version\");\n\t\t\tif (!$version) {\n\t\t\t  // Service Providers MUST assume the protocol version to be 1.0 if this parameter is not present. \n\t\t\t  // Chapter 7.0 (\"Accessing Protected Ressources\")\n\t\t\t  $version = '1.0';\n\t\t\t}\n\t\t\tif ($version !== $this->version) {\n\t\t\t  throw new OAuthException(\"OAuth version '$version' not supported\");\n\t\t\t}\n\t\t\treturn $version;\n\t\t  }\n\n\t\t  /**\n\t\t   * figure out the signature with some defaults\n\t\t   */\n\t\t  private function get_signature_method(&$request) {\n\t\t\t$signature_method =\n\t\t\t\t@$request->get_parameter(\"oauth_signature_method\");\n\n\t\t\tif (!$signature_method) {\n\t\t\t  // According to chapter 7 (\"Accessing Protected Ressources\") the signature-method\n\t\t\t  // parameter is required, and we can't just fallback to PLAINTEXT\n\t\t\t  throw new OAuthException('No signature method parameter. This parameter is required');\n\t\t\t}\n\n\t\t\tif (!in_array($signature_method,\n\t\t\t\t\t\t  array_keys($this->signature_methods))) {\n\t\t\t  throw new OAuthException(\n\t\t\t\t\"Signature method '$signature_method' not supported \" .\n\t\t\t\t\"try one of the following: \" .\n\t\t\t\timplode(\", \", array_keys($this->signature_methods))\n\t\t\t  );\n\t\t\t}\n\t\t\treturn $this->signature_methods[$signature_method];\n\t\t  }\n\n\t\t  /**\n\t\t   * try to find the consumer for the provided request's consumer key\n\t\t   */\n\t\t  private function get_consumer(&$request) {\n\t\t\t$consumer_key = @$request->get_parameter(\"oauth_consumer_key\");\n\t\t\tif (!$consumer_key) {\n\t\t\t  throw new OAuthException(\"Invalid consumer key\");\n\t\t\t}\n\n\t\t\t$consumer = $this->data_store->lookup_consumer($consumer_key);\n\t\t\tif (!$consumer) {\n\t\t\t  throw new OAuthException(\"Invalid consumer\");\n\t\t\t}\n\n\t\t\treturn $consumer;\n\t\t  }\n\n\t\t  /**\n\t\t   * try to find the token for the provided request's token key\n\t\t   */\n\t\t  private function get_token(&$request, $consumer, $token_type=\"access\") {\n\t\t\t$token_field = @$request->get_parameter('oauth_token');\n\t\t\t$token = $this->data_store->lookup_token(\n\t\t\t  $consumer, $token_type, $token_field\n\t\t\t);\n\t\t\tif (!$token) {\n\t\t\t  throw new OAuthException(\"Invalid $token_type token: $token_field\");\n\t\t\t}\n\t\t\treturn $token;\n\t\t  }\n\n\t\t  /**\n\t\t   * all-in-one function to check the signature on a request\n\t\t   * should guess the signature method appropriately\n\t\t   */\n\t\t  private function check_signature(&$request, $consumer, $token) {\n\t\t\t// this should probably be in a different method\n\t\t\t$timestamp = @$request->get_parameter('oauth_timestamp');\n\t\t\t$nonce = @$request->get_parameter('oauth_nonce');\n\n\t\t\t$this->check_timestamp($timestamp);\n\t\t\t$this->check_nonce($consumer, $token, $nonce, $timestamp);\n\n\t\t\t$signature_method = $this->get_signature_method($request);\n\n\t\t\t$signature = $request->get_parameter('oauth_signature');\n\t\t\t$valid_sig = $signature_method->check_signature(\n\t\t\t  $request,\n\t\t\t  $consumer,\n\t\t\t  $token,\n\t\t\t  $signature\n\t\t\t);\n\n\t\t\tif (!$valid_sig) {\n\t\t\t  throw new OAuthException(\"Invalid signature\");\n\t\t\t}\n\t\t  }\n\n\t\t  /**\n\t\t   * check that the timestamp is new enough\n\t\t   */\n\t\t  private function check_timestamp($timestamp) {\n\t\t\tif( ! $timestamp )\n\t\t\t  throw new OAuthException(\n\t\t\t\t'Missing timestamp parameter. The parameter is required'\n\t\t\t  );\n\t\t\t\n\t\t\t// verify that timestamp is recentish\n\t\t\t$now = time();\n\t\t\tif (abs($now - $timestamp) > $this->timestamp_threshold) {\n\t\t\t  throw new OAuthException(\n\t\t\t\t\"Expired timestamp, yours $timestamp, ours $now\"\n\t\t\t  );\n\t\t\t}\n\t\t  }\n\n\t\t  /**\n\t\t   * check that the nonce is not repeated\n\t\t   */\n\t\t  private function check_nonce($consumer, $token, $nonce, $timestamp) {\n\t\t\tif( ! $nonce )\n\t\t\t  throw new OAuthException(\n\t\t\t\t'Missing nonce parameter. The parameter is required'\n\t\t\t  );\n\n\t\t\t// verify that the nonce is uniqueish\n\t\t\t$found = $this->data_store->lookup_nonce(\n\t\t\t  $consumer,\n\t\t\t  $token,\n\t\t\t  $nonce,\n\t\t\t  $timestamp\n\t\t\t);\n\t\t\tif ($found) {\n\t\t\t  throw new OAuthException(\"Nonce already used: $nonce\");\n\t\t\t}\n\t\t  }\n\n\t\t}\n\n\t\tclass OAuthDataStore {\n\t\t  function lookup_consumer($consumer_key) {\n\t\t\t// implement me\n\t\t  }\n\n\t\t  function lookup_token($consumer, $token_type, $token) {\n\t\t\t// implement me\n\t\t  }\n\n\t\t  function lookup_nonce($consumer, $token, $nonce, $timestamp) {\n\t\t\t// implement me\n\t\t  }\n\n\t\t  function new_request_token($consumer, $callback = null) {\n\t\t\t// return a new token attached to this consumer\n\t\t  }\n\n\t\t  function new_access_token($token, $consumer, $verifier = null) {\n\t\t\t// return a new access token attached to this consumer\n\t\t\t// for the user associated with this token if the request token\n\t\t\t// is authorized\n\t\t\t// should also invalidate the request token\n\t\t  }\n\n\t\t}\n\n\t\tclass OAuthUtil {\n\t\t  public static function urlencode_rfc3986($input) {\n\t\t  if (is_array($input)) {\n\t\t\treturn array_map(array('OAuthUtil', 'urlencode_rfc3986'), $input);\n\t\t  } else if (is_scalar($input)) {\n\t\t\treturn str_replace(\n\t\t\t  '+',\n\t\t\t  ' ',\n\t\t\t  str_replace('%7E', '~', rawurlencode($input))\n\t\t\t);\n\t\t  } else {\n\t\t\treturn '';\n\t\t  }\n\t\t}\n\n\n\t\t  // This decode function isn't taking into consideration the above\n\t\t  // modifications to the encoding process. However, this method doesn't\n\t\t  // seem to be used anywhere so leaving it as is.\n\t\t  public static function urldecode_rfc3986($string) {\n\t\t\treturn urldecode($string);\n\t\t  }\n\n\t\t  // Utility function for turning the Authorization: header into\n\t\t  // parameters, has to do some unescaping\n\t\t  // Can filter out any non-oauth parameters if needed (default behaviour)\n\t\t  public static function split_header($header, $only_allow_oauth_parameters = true) {\n\t\t\t$pattern = '/(([-_a-z]*)=(\"([^\"]*)\"|([^,]*)),?)/';\n\t\t\t$offset = 0;\n\t\t\t$params = array();\n\t\t\twhile (preg_match($pattern, $header, $matches, PREG_OFFSET_CAPTURE, $offset) > 0) {\n\t\t\t  $match = $matches[0];\n\t\t\t  $header_name = $matches[2][0];\n\t\t\t  $header_content = (isset($matches[5])) ? $matches[5][0] : $matches[4][0];\n\t\t\t  if (preg_match('/^oauth_/', $header_name) || !$only_allow_oauth_parameters) {\n\t\t\t\t$params[$header_name] = OAuthUtil::urldecode_rfc3986($header_content);\n\t\t\t  }\n\t\t\t  $offset = $match[1] + strlen($match[0]);\n\t\t\t}\n\n\t\t\tif (isset($params['realm'])) {\n\t\t\t  unset($params['realm']);\n\t\t\t}\n\n\t\t\treturn $params;\n\t\t  }\n\n\t\t  // helper to try to sort out headers for people who aren't running apache\n\t\t  public static function get_headers() {\n\t\t\tif (function_exists('apache_request_headers')) {\n\t\t\t  // we need this to get the actual Authorization: header\n\t\t\t  // because apache tends to tell us it doesn't exist\n\t\t\t  $headers = apache_request_headers();\n\n\t\t\t  // sanitize the output of apache_request_headers because\n\t\t\t  // we always want the keys to be Cased-Like-This and arh()\n\t\t\t  // returns the headers in the same case as they are in the\n\t\t\t  // request\n\t\t\t  $out = array();\n\t\t\t  foreach( $headers AS $key => $value ) {\n\t\t\t\t$key = str_replace(\n\t\t\t\t\t\" \",\n\t\t\t\t\t\"-\",\n\t\t\t\t\tucwords(strtolower(str_replace(\"-\", \" \", $key)))\n\t\t\t\t  );\n\t\t\t\t$out[$key] = $value;\n\t\t\t  }\n\t\t\t} else {\n\t\t\t  // otherwise we don't have apache and are just going to have to hope\n\t\t\t  // that $_SERVER actually contains what we need\n\t\t\t  $out = array();\n\t\t\t  if( isset($_SERVER['CONTENT_TYPE']) )\n\t\t\t\t$out['Content-Type'] = $_SERVER['CONTENT_TYPE'];\n\t\t\t  if( isset($_ENV['CONTENT_TYPE']) )\n\t\t\t\t$out['Content-Type'] = $_ENV['CONTENT_TYPE'];\n\n\t\t\t  foreach ($_SERVER as $key => $value) {\n\t\t\t\tif (substr($key, 0, 5) == \"HTTP_\") {\n\t\t\t\t  // this is chaos, basically it is just there to capitalize the first\n\t\t\t\t  // letter of every word that is not an initial HTTP and strip HTTP\n\t\t\t\t  // code from przemek\n\t\t\t\t  $key = str_replace(\n\t\t\t\t\t\" \",\n\t\t\t\t\t\"-\",\n\t\t\t\t\tucwords(strtolower(str_replace(\"_\", \" \", substr($key, 5))))\n\t\t\t\t  );\n\t\t\t\t  $out[$key] = $value;\n\t\t\t\t}\n\t\t\t  }\n\t\t\t}\n\t\t\treturn $out;\n\t\t  }\n\n\t\t  // This function takes a input like a=b&a=c&d=e and returns the parsed\n\t\t  // parameters like this\n\t\t  // array('a' => array('b','c'), 'd' => 'e')\n\t\t  public static function parse_parameters( $input ) {\n\t\t\tif (!isset($input) || !$input) return array();\n\n\t\t\t$pairs = explode('&', $input);\n\n\t\t\t$parsed_parameters = array();\n\t\t\tforeach ($pairs as $pair) {\n\t\t\t  $split = explode('=', $pair, 2);\n\t\t\t  $parameter = OAuthUtil::urldecode_rfc3986($split[0]);\n\t\t\t  $value = isset($split[1]) ? OAuthUtil::urldecode_rfc3986($split[1]) : '';\n\n\t\t\t  if (isset($parsed_parameters[$parameter])) {\n\t\t\t\t// We have already recieved parameter(s) with this name, so add to the list\n\t\t\t\t// of parameters with this name\n\n\t\t\t\tif (is_scalar($parsed_parameters[$parameter])) {\n\t\t\t\t  // This is the first duplicate, so transform scalar (string) into an array\n\t\t\t\t  // so we can add the duplicates\n\t\t\t\t  $parsed_parameters[$parameter] = array($parsed_parameters[$parameter]);\n\t\t\t\t}\n\n\t\t\t\t$parsed_parameters[$parameter][] = $value;\n\t\t\t  } else {\n\t\t\t\t$parsed_parameters[$parameter] = $value;\n\t\t\t  }\n\t\t\t}\n\t\t\treturn $parsed_parameters;\n\t\t  }\n\n\t\t  public static function build_http_query($params) {\n\t\t\tif (!$params) return '';\n\n\t\t\t// Urlencode both keys and values\n\t\t\t$keys = OAuthUtil::urlencode_rfc3986(array_keys($params));\n\t\t\t$values = OAuthUtil::urlencode_rfc3986(array_values($params));\n\t\t\t$params = array_combine($keys, $values);\n\n\t\t\t// Parameters are sorted by name, using lexicographical byte value ordering.\n\t\t\t// Ref: Spec: 9.1.1 (1)\n\t\t\tuksort($params, 'strcmp');\n\n\t\t\t$pairs = array();\n\t\t\tforeach ($params as $parameter => $value) {\n\t\t\t  if (is_array($value)) {\n\t\t\t\t// If two or more parameters share the same name, they are sorted by their value\n\t\t\t\t// Ref: Spec: 9.1.1 (1)\n\t\t\t\tnatsort($value);\n\t\t\t\tforeach ($value as $duplicate_value) {\n\t\t\t\t  $pairs[] = $parameter . '=' . $duplicate_value;\n\t\t\t\t}\n\t\t\t  } else {\n\t\t\t\t$pairs[] = $parameter . '=' . $value;\n\t\t\t  }\n\t\t\t}\n\t\t\t// For each parameter, the name is separated from the corresponding value by an '=' character (ASCII code 61)\n\t\t\t// Each name-value pair is separated by an '&' character (ASCII code 38)\n\t\t\treturn implode('&', $pairs);\n\t\t  }\n\t\t}\n\n\n\n\n\n\n\n\t\t\n\n\n\n\n\n\n\n\n\n/**\n * Twitter OAuth class\n */\nclass TwitterOAuth {\n  /* Contains the last HTTP status code returned. */\n  public $http_code;\n  /* Contains the last API call. */\n  public $url;\n  /* Set up the API root URL. */\n  public $host = \"https://api.twitter.com/1/\";\n  /* Set timeout default. */\n  public $timeout = 30;\n  /* Set connect timeout. */\n  public $connecttimeout = 30; \n  /* Verify SSL Cert. */\n  public $ssl_verifypeer = FALSE;\n  /* Respons format. */\n  public $format = 'json';\n  /* Decode returned json data. */\n  public $decode_json = TRUE;\n  /* Contains the last HTTP headers returned. */\n  public $http_info;\n  /* Set the useragnet. */\n  public $useragent = 'TwitterOAuth v0.2.0-beta2';\n  /* Immediately retry the API call if the response was not successful. */\n  //public $retry = TRUE;\n\n\n\n\n  /**\n   * Set API URLS\n   */\n  function accessTokenURL()  { return 'https://api.twitter.com/oauth/access_token'; }\n  function authenticateURL() { return 'https://api.twitter.com/oauth/authenticate'; }\n  function authorizeURL()    { return 'https://api.twitter.com/oauth/authorize'; }\n  function requestTokenURL() { return 'https://api.twitter.com/oauth/request_token'; }\n\n  /**\n   * Debug helpers\n   */\n  function lastStatusCode() { return $this->http_status; }\n  function lastAPICall() { return $this->last_api_call; }\n\n  /**\n   * construct TwitterOAuth object\n   */\n  function __construct($consumer_key, $consumer_secret, $oauth_token = NULL, $oauth_token_secret = NULL) {\n    $this->sha1_method = new OAuthSignatureMethod_HMAC_SHA1();\n    $this->consumer = new OAuthConsumer($consumer_key, $consumer_secret);\n    if (!empty($oauth_token) && !empty($oauth_token_secret)) {\n      $this->token = new OAuthConsumer($oauth_token, $oauth_token_secret);\n    } else {\n      $this->token = NULL;\n    }\n  }\n\n\n  /**\n   * Get a request_token from Twitter\n   *\n   * @returns a key/value array containing oauth_token and oauth_token_secret\n   */\n  function getRequestToken($oauth_callback = NULL) {\n    $parameters = array();\n    if (!empty($oauth_callback)) {\n      $parameters['oauth_callback'] = $oauth_callback;\n    } \n    $request = $this->oAuthRequest($this->requestTokenURL(), 'GET', $parameters);\n    $token = OAuthUtil::parse_parameters($request);\n    $this->token = new OAuthConsumer($token['oauth_token'], $token['oauth_token_secret']);\n    return $token;\n  }\n\n  /**\n   * Get the authorize URL\n   *\n   * @returns a string\n   */\n  function getAuthorizeURL($token, $sign_in_with_twitter = TRUE) {\n    if (is_array($token)) {\n      $token = $token['oauth_token'];\n    }\n    if (empty($sign_in_with_twitter)) {\n      return $this->authorizeURL() . \"?oauth_token={$token}\";\n    } else {\n       return $this->authenticateURL() . \"?oauth_token={$token}\";\n    }\n  }\n\n  /**\n   * Exchange request token and secret for an access token and\n   * secret, to sign API calls.\n   *\n   * @returns array(\"oauth_token\" => \"the-access-token\",\n   *                \"oauth_token_secret\" => \"the-access-secret\",\n   *                \"user_id\" => \"9436992\",\n   *                \"screen_name\" => \"abraham\")\n   */\n  function getAccessToken($oauth_verifier = FALSE) {\n    $parameters = array();\n    if (!empty($oauth_verifier)) {\n      $parameters['oauth_verifier'] = $oauth_verifier;\n    }\n    $request = $this->oAuthRequest($this->accessTokenURL(), 'GET', $parameters);\n    $token = OAuthUtil::parse_parameters($request);\n    $this->token = new OAuthConsumer($token['oauth_token'], $token['oauth_token_secret']);\n    return $token;\n  }\n\n  /**\n   * One time exchange of username and password for access token and secret.\n   *\n   * @returns array(\"oauth_token\" => \"the-access-token\",\n   *                \"oauth_token_secret\" => \"the-access-secret\",\n   *                \"user_id\" => \"9436992\",\n   *                \"screen_name\" => \"abraham\",\n   *                \"x_auth_expires\" => \"0\")\n   */  \n  function getXAuthToken($username, $password) {\n    $parameters = array();\n    $parameters['x_auth_username'] = $username;\n    $parameters['x_auth_password'] = $password;\n    $parameters['x_auth_mode'] = 'client_auth';\n    $request = $this->oAuthRequest($this->accessTokenURL(), 'POST', $parameters);\n    $token = OAuthUtil::parse_parameters($request);\n    $this->token = new OAuthConsumer($token['oauth_token'], $token['oauth_token_secret']);\n    return $token;\n  }\n\n  /**\n   * GET wrapper for oAuthRequest.\n   */\n  function get($url, $parameters = array()) {\n    $response = $this->oAuthRequest($url, 'GET', $parameters);\n    if ($this->format === 'json' && $this->decode_json) {\n      return json_decode($response);\n    }\n    return $response;\n  }\n  \n  /**\n   * POST wrapper for oAuthRequest.\n   */\n  function post($url, $parameters = array()) {\n    $response = $this->oAuthRequest($url, 'POST', $parameters);\n    if ($this->format === 'json' && $this->decode_json) {\n      return json_decode($response);\n    }\n    return $response;\n  }\n\n  /**\n   * DELETE wrapper for oAuthReqeust.\n   */\n  function delete($url, $parameters = array()) {\n    $response = $this->oAuthRequest($url, 'DELETE', $parameters);\n    if ($this->format === 'json' && $this->decode_json) {\n      return json_decode($response);\n    }\n    return $response;\n  }\n\n  /**\n   * Format and sign an OAuth / API request\n   */\n  function oAuthRequest($url, $method, $parameters) {\n    if (strrpos($url, 'https://') !== 0 && strrpos($url, 'http://') !== 0) {\n      $url = \"{$this->host}{$url}.{$this->format}\";\n    }\n    $request = OAuthRequest::from_consumer_and_token($this->consumer, $this->token, $method, $url, $parameters);\n    $request->sign_request($this->sha1_method, $this->consumer, $this->token);\n    switch ($method) {\n    case 'GET':\n      return $this->http($request->to_url(), 'GET');\n    default:\n      return $this->http($request->get_normalized_http_url(), $method, $request->to_postdata());\n    }\n  }\n\n  /**\n   * Make an HTTP request\n   *\n   * @return API results\n   */\n  function http($url, $method, $postfields = NULL) {\n    $this->http_info = array();\n    $ci = curl_init();\n    /* Curl settings */\n    curl_setopt($ci, CURLOPT_USERAGENT, $this->useragent);\n    curl_setopt($ci, CURLOPT_CONNECTTIMEOUT, $this->connecttimeout);\n    curl_setopt($ci, CURLOPT_TIMEOUT, $this->timeout);\n    curl_setopt($ci, CURLOPT_RETURNTRANSFER, TRUE);\n    curl_setopt($ci, CURLOPT_HTTPHEADER, array('Expect:'));\n    curl_setopt($ci, CURLOPT_SSL_VERIFYPEER, $this->ssl_verifypeer);\n    curl_setopt($ci, CURLOPT_HEADERFUNCTION, array($this, 'getHeader'));\n    curl_setopt($ci, CURLOPT_HEADER, FALSE);\n\n    switch ($method) {\n      case 'POST':\n        curl_setopt($ci, CURLOPT_POST, TRUE);\n        if (!empty($postfields)) {\n          curl_setopt($ci, CURLOPT_POSTFIELDS, $postfields);\n        }\n        break;\n      case 'DELETE':\n        curl_setopt($ci, CURLOPT_CUSTOMREQUEST, 'DELETE');\n        if (!empty($postfields)) {\n          $url = \"{$url}?{$postfields}\";\n        }\n    }\n\n    curl_setopt($ci, CURLOPT_URL, $url);\n    $response = curl_exec($ci);\n    $this->http_code = curl_getinfo($ci, CURLINFO_HTTP_CODE);\n    $this->http_info = array_merge($this->http_info, curl_getinfo($ci));\n    $this->url = $url;\n    curl_close ($ci);\n    return $response;\n  }\n\n  /**\n   * Get the header info to store.\n   */\n  function getHeader($ch, $header) {\n    $i = strpos($header, ':');\n    if (!empty($i)) {\n      $key = str_replace('-', '_', strtolower(substr($header, 0, $i)));\n      $value = trim(substr($header, $i + 2));\n      $this->http_header[$key] = $value;\n    }\n    return strlen($header);\n  }\n}\n"
        },
        {
          "name": "widget.php",
          "type": "blob",
          "size": 13.7548828125,
          "content": "<?php\r\n\r\n// widget function\r\n\tclass fa_widget_recent_tweet extends WP_Widget {\r\n\t\t\r\n\t\tpublic function __construct() {\r\n\t\t\tparent::__construct(\r\n\t\t\t\t'fa_widget_recent_tweet', // Base ID\r\n\t\t\t\t'* Recent Tweet', // Name\r\n\t\t\t\tarray( 'description' => __( 'Display recent tweets', 'fa_tweets' ), ) // Args\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t\r\n\t\t//widget output\r\n\t\t\tpublic function widget($args, $instance) {\r\n\t\t\t\textract($args);\r\n\t\t\t\tif(!empty($instance['title'])){ $title = apply_filters( 'widget_title', $instance['title'] ); }\r\n\t\t\t\t\r\n\t\t\t\techo $before_widget;\t\t\t\t\r\n\t\t\t\tif ( ! empty( $title ) ){ echo $before_title . $title . $after_title; }\r\n\r\n\t\t\t\t\r\n\t\t\t\t\t//check settings and die if not set\r\n\t\t\t\t\t\tif((empty($instance['consumerkey']) || empty($instance['consumersecret']) || empty($instance['accesstoken']) || empty($instance['accesstokensecret']) || empty($instance['username'])) && empty($instance['loklak_api'])){\r\n\t\t\t\t\t\t\techo '<strong>'.__('Please fill all widget settings!','fa_tweets').'</strong>' . $after_widget;\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif( !empty($instance['loklak_api']) && ( esc_attr($instance['loklak_api']  == 'true'))){\r\n\t\t\t\t\t\t\tif(!class_exists('Loklak'))\r\n\t\t\t\t\t\t\t\trequire_once dirname(__FILE__).'/loklak_php_api/loklak.php';\r\n                \t\t\t$loklak = new Loklak();                \t\t\t\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t//check if cache needs update\r\n\t\t\t\t\t\t$fa_twitter_plugin_last_cache_time = get_option('fa_twitter_plugin_last_cache_time');\r\n\t\t\t\t\t\t$diff = time() - $fa_twitter_plugin_last_cache_time;\r\n\t\t\t\t\t\t$crt = $instance['cachetime'] * 3600;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t //\tyes, it needs update\t\t\t\r\n\t\t\t\t\t\tif($diff >= $crt || empty($fa_twitter_plugin_last_cache_time)){\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif( isset($loklak)){\r\n\t\t\t\t\t            $screen_name = explode('@', $instance['username'])[1];\r\n\t\t\t\t\t            $tweets = $loklak->search('', null, null, $screen_name, 10);\t\t\t\t\t            \r\n\t\t\t\t\t            $tweets = json_decode($tweets, true);\r\n\t\t\t\t\t            if(!($tweets = json_decode($tweets['body'], false))){\r\n\t\t\t\t\t            \techo '<strong>'.__('Couldn\\'t retrieve tweets from Loklak.org','fa_tweets').'</strong>' . $after_widget;\r\n\t\t\t\t\t            \treturn;\r\n\t\t\t\t\t            }\r\n\r\n\t\t\t\t\t            $tweets = $tweets->statuses;\r\n\t\t\t\t\t        }\r\n\t\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t\tif(!require_once('twitteroauth.php')){ \r\n\t\t\t\t\t\t\t\t\techo '<strong>'.__('Couldn\\'t find twitteroauth.php!','fa_tweets').'</strong>' . $after_widget;\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tfunction getConnectionWithAccessToken($cons_key, $cons_secret, $oauth_token, $oauth_token_secret) {\r\n\t\t\t\t\t\t\t\t  $connection = new TwitterOAuth($cons_key, $cons_secret, $oauth_token, $oauth_token_secret);\r\n\t\t\t\t\t\t\t\t  return $connection;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\t\t\t\t\t\t  \r\n\t\t\t\t\t\t\t\t$connection = getConnectionWithAccessToken($instance['consumerkey'], $instance['consumersecret'], $instance['accesstoken'], $instance['accesstokensecret']);\r\n\t\t\t\t\t\t\t\t$tweets = $connection->get(\"https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=\".$instance['username'].\"&count=10&exclude_replies=\".$instance['excludereplies']) or die('Couldn\\'t retrieve tweets! Wrong username?');\r\n\t\t\t\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(!empty($tweets->errors)){\r\n\t\t\t\t\t\t\t\tif($tweets->errors[0]->message == 'Invalid or expired token'){\r\n\t\t\t\t\t\t\t\t\techo '<strong>'.$tweets->errors[0]->message.'!</strong><br />' . __('You\\'ll need to regenerate it <a href=\"https://apps.twitter.com/\" target=\"_blank\">here</a>!','fa_tweets') . $after_widget;\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\techo '<strong>'.$tweets->errors[0]->message.'</strong>' . $after_widget;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t$tweets_array = array();\r\n\t\t\t\t\t\t\tfor($i = 0;$i <= count($tweets); $i++){\r\n\t\t\t\t\t\t\t\tif(!empty($tweets[$i])){\r\n\t\t\t\t\t\t\t\t\t$tweets_array[$i]['created_at'] = $tweets[$i]->created_at;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t//clean tweet text\r\n\t\t\t\t\t\t\t\t\t\t$tweets_array[$i]['text'] = preg_replace('/[\\x{10000}-\\x{10FFFF}]/u', '', $tweets[$i]->text);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif(!empty($tweets[$i]->id_str)){\r\n\t\t\t\t\t\t\t\t\t\t$tweets_array[$i]['status_id'] = $tweets[$i]->id_str;\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\t\r\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t//save tweets to wp option \t\t\r\n\t\t\t\t\t\t\t\tupdate_option('fa_twitter_plugin_tweets',serialize($tweets_array));\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tupdate_option('fa_twitter_plugin_last_cache_time',time());\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\techo '<!-- twitter cache has been updated! -->';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t$fa_twitter_plugin_tweets = maybe_unserialize(get_option('fa_twitter_plugin_tweets'));\r\n\t\t\t\t\tif(!empty($fa_twitter_plugin_tweets) && is_array($fa_twitter_plugin_tweets)){\r\n\t\t\t\t\t\tprint '\r\n\t\t\t\t\t\t<div class=\"fa_recent_tweets\">\r\n\t\t\t\t\t\t\t<ul>';\r\n\t\t\t\t\t\t\t$fctr = '1';\r\n\t\t\t\t\t\t\tforeach($fa_twitter_plugin_tweets as $tweet){\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif(!empty($tweet['text'])){\r\n\t\t\t\t\t\t\t\t\tif(empty($tweet['status_id'])){ $tweet['status_id'] = ''; }\r\n\t\t\t\t\t\t\t\t\tif(empty($tweet['created_at'])){ $tweet['created_at'] = ''; }\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tprint '<li><span>'.fa_convert_links($tweet['text']).'</span><a class=\"twitter_time\" target=\"_blank\" href=\"http://twitter.com/'.$instance['username'].'/statuses/'.$tweet['status_id'].'\">'.fa_relative_time($tweet['created_at']).'</a></li>';\r\n\t\t\t\t\t\t\t\t\tif($fctr == $instance['tweetstoshow']){ break; }\r\n\t\t\t\t\t\t\t\t\t$fctr++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tprint '\r\n\t\t\t\t\t\t\t</ul> \r\n\t\t\t\t\t\t</div>';\t\t\t\t\t\t\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tprint '\r\n\t\t\t\t\t\t<div class=\"fa_recent_tweets\">\r\n\t\t\t\t\t\t\t' . __('<b>Error!</b> Couldn\\'t retrieve tweets for some reason!','tp_tweets') . '\r\n\t\t\t\t\t\t</div>';\r\n\t\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\techo $after_widget;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\r\n\t\t//save widget settings \r\n\t\t\tpublic function update($new_instance, $old_instance) {\t\t\t\t\r\n\t\t\t\t$instance = array();\r\n\t\t\t\t//var_dump($new_instance);\r\n\t\t\t\t//die();\r\n\t\t\t\t$instance['title'] = strip_tags( $new_instance['title'] );\r\n\t\t\t\t$instance['consumerkey'] = strip_tags( $new_instance['consumerkey'] );\r\n\t\t\t\t$instance['consumersecret'] = strip_tags( $new_instance['consumersecret'] );\r\n\t\t\t\t$instance['accesstoken'] = strip_tags( $new_instance['accesstoken'] );\r\n\t\t\t\t$instance['accesstokensecret'] = strip_tags( $new_instance['accesstokensecret'] );\r\n\t\t\t\t$instance['cachetime'] = strip_tags( $new_instance['cachetime'] );\r\n\t\t\t\t$instance['username'] = strip_tags( $new_instance['username'] );\r\n\t\t\t\t$instance['tweetstoshow'] = strip_tags( $new_instance['tweetstoshow'] );\r\n\t\t\t\t$instance['excludereplies'] = strip_tags( $new_instance['excludereplies'] );\r\n\t\t\t\t$instance['loklak_api'] = strip_tags(  $new_instance['loklak_api'] );\r\n\r\n\t\t\t\tif($old_instance['username'] != $new_instance['username']){\r\n\t\t\t\t\tdelete_option('fa_twitter_plugin_last_cache_time');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn $instance;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t//widget settings form\t\r\n\t\t\tpublic function form($instance) {\r\n\t\t\t\t$defaults = array( 'title' => '', 'consumerkey' => '', 'consumersecret' => '', 'accesstoken' => '', 'accesstokensecret' => '', 'cachetime' => '', 'username' => '', 'tweetstoshow' => '' );\r\n\t\t\t\t$instance = wp_parse_args( (array) $instance, $defaults );\r\n\t\t\t\t\t\t\r\n\t\t\t\techo '\r\n\t\t\t\t<p>Get your API keys &amp; tokens at:<br /><a href=\"https://apps.twitter.com/\" target=\"_blank\">https://apps.twitter.com/</a></p>';\r\n\t\t\t\techo '\r\n\t\t\t\t<p>\r\n\t\t\t\t\t<input type=\"checkbox\" name=\"'.$this->get_field_name( 'loklak_api' ).'\" id=\"'.$this->get_field_id( 'loklak_api' ).'\" value=\"true\" class=\"rtw-loklak_api\"'; \r\n\t\t\t\t\tif(!empty($instance['loklak_api']) && esc_attr($instance['loklak_api']) == 'true'){\r\n\t\t\t\t\t\tprint ' checked=\"checked\"';\r\n\t\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t\tprint ' /><label>' . __('Use anonymous <a href=\"http://loklak.org/\">loklak.org</a> API instead of Twitter. <a href=\"http://loklak.org/\">Find out more</a>','fa_tweets') . '</label></p>';\r\n\t\t\t\techo '\r\n\t\t\t\t<p><label>' . __('Title:','fa_tweets') . '</label>\r\n\t\t\t\t\t<input type=\"text\" name=\"'.$this->get_field_name( 'title' ).'\" id=\"'.$this->get_field_id( 'title' ).'\" value=\"'.esc_attr($instance['title']).'\" class=\"widefat rtw-title\" /></p>\r\n\t\t\t\t<p><label>' . __('Consumer Key:','fa_tweets') . '</label>\r\n\t\t\t\t\t<input type=\"text\" name=\"'.$this->get_field_name( 'consumerkey' ).'\" id=\"'.$this->get_field_id( 'consumerkey' ).'\" value=\"'.esc_attr($instance['consumerkey']).'\" class=\"widefat rtw-consumerkey\"';\r\n\t\t\t\t\tif(!empty($instance['loklak_api']) && esc_attr($instance['loklak_api']) == 'true'){\r\n\t\t\t\t\t\tprint ' disabled=\"disabled\"';\r\n\t\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\tprint ' /></p>';\r\n\t\t\t\techo '\r\n\t\t\t\t<p><label>' . __('Consumer Secret:','fa_tweets') . '</label>\r\n\t\t\t\t\t<input type=\"text\" name=\"'.$this->get_field_name( 'consumersecret' ).'\" id=\"'.$this->get_field_id( 'consumersecret' ).' \" value=\"'.esc_attr($instance['consumersecret']).'\" class=\"widefat rtw-consumersecret\"';\r\n\t\t\t\t\tif(!empty($instance['loklak_api']) && esc_attr($instance['loklak_api']) == 'true'){\r\n\t\t\t\t\t\tprint ' disabled=\"disabled\"';\r\n\t\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\tprint ' /></p>';\t\t\t\t\t\r\n\t\t\t\techo '\r\n\t\t\t\t<p><label>' . __('Access Token:','fa_tweets') . '</label>\r\n\t\t\t\t\t<input type=\"text\" name=\"'.$this->get_field_name( 'accesstoken' ).'\" id=\"'.$this->get_field_id( 'accesstoken' ).'\" value=\"'.esc_attr($instance['accesstoken']).'\" class=\"widefat rtw-accesstoken\"';\r\n\t\t\t\t\tif(!empty($instance['loklak_api']) && esc_attr($instance['loklak_api']) == 'true'){\r\n\t\t\t\t\t\tprint ' disabled=\"disabled\"';\r\n\t\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\tprint ' /></p>';\r\n\t\t\t\techo '\t\t\t\t\t\t\t\r\n\t\t\t\t<p><label>' . __('Access Token Secret:','fa_tweets') . '</label>\t\t\r\n\t\t\t\t\t<input type=\"text\" name=\"'.$this->get_field_name( 'accesstokensecret' ).'\" id=\"'.$this->get_field_id( 'accesstokensecret' ).'\"  value=\"'.esc_attr($instance['accesstokensecret']).'\" class=\"widefat rtw-accesstokensecret\"';\r\n\t\t\t\t\tif(!empty($instance['loklak_api']) && esc_attr($instance['loklak_api']) == 'true'){\r\n\t\t\t\t\t\tprint ' disabled=\"disabled\"';\r\n\t\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\tprint ' /></p>';\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\techo '\r\n\t\t\t\t<p><label>' . __('Cache Tweets in every:','fa_tweets') . '</label>\r\n\t\t\t\t\t<input type=\"text\" name=\"'.$this->get_field_name( 'cachetime' ).'\" id=\"'.$this->get_field_id( 'cachetime' ).'\" value=\"'.esc_attr($instance['cachetime']).'\" class=\"small-text rtw-cachetime\"/> hours</p>';\r\n\r\n\t\t\t\techo '\r\n\t\t\t\t<p><label>' . __('Twitter Username:','fa_tweets') . '</label>\r\n\t\t\t\t\t<input type=\"text\" name=\"'.$this->get_field_name( 'username' ).'\" id=\"'.$this->get_field_id( 'username' ).'\" value=\"'.esc_attr($instance['username']).'\" class=\"widefat rtw-username\" /></p>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t<p><label>' . __('Tweets to display:','fa_tweets') . '</label>\r\n\t\t\t\t\t<select type=\"text\" name=\"'.$this->get_field_name( 'tweetstoshow' ).'\" id=\"'.$this->get_field_id( 'tweetstoshow' ).'\" class=\"rtw-tweetstoshow\">';\r\n\t\t\t\t\t$i = 1;\r\n\t\t\t\t\tfor($i; $i <= 10; $i++){\r\n\t\t\t\t\t\techo '<option value=\"'.$i.'\"'; if($instance['tweetstoshow'] == $i){ echo ' selected=\"selected\"'; } echo '>'.$i.'</option>';\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\techo '\r\n\t\t\t\t\t</select></p>\r\n\t\t\t\t<p><label>' . __('Exclude replies:','fa_tweets') . '</label>\r\n\t\t\t\t\t<input type=\"checkbox\" name=\"'.$this->get_field_name( 'excludereplies' ).'\" id=\"'.$this->get_field_id( 'excludereplies' ).'\" class=\"rtw-excludereplies\" value=\"true\"'; \r\n\t\t\t\t\tif(!empty($instance['excludereplies']) && esc_attr($instance['excludereplies']) == 'true'){\r\n\t\t\t\t\t\tprint ' checked=\"checked\"';\r\n\t\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\tprint ' /></p>';\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t//convert links to clickable format\r\n\t\t\t\t\tif (!function_exists('fa_convert_links')) {\r\n\t\t\t\t\t\tfunction fa_convert_links($status,$targetBlank=true,$linkMaxLen=250){\r\n\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t// the target\r\n\t\t\t\t\t\t\t\t$target=$targetBlank ? \" target=\\\"_blank\\\" \" : \"\";\r\n\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t// convert link to url\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t$status = preg_replace('/\\b(https?|ftp|file):\\/\\/[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[A-Z0-9+&@#\\/%=~_|]/i', '<a href=\"\\0\" target=\"_blank\">\\0</a>', $status);\r\n\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t// convert @ to follow\r\n\t\t\t\t\t\t\t\t$status = preg_replace(\"/(@([_a-z0-9\\-]+))/i\",\"<a href=\\\"http://twitter.com/$2\\\" title=\\\"Follow $2\\\" $target >$1</a>\",$status);\r\n\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t// convert # to search\r\n\t\t\t\t\t\t\t\t$status = preg_replace(\"/(#([_a-z0-9\\-]+))/i\",\"<a href=\\\"https://twitter.com/search?q=$2\\\" title=\\\"Search $1\\\" $target >$1</a>\",$status);\r\n\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t// return the status\r\n\t\t\t\t\t\t\t\treturn $status;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t//convert dates to readable format\t\r\n\t\t\t\t\tif (!function_exists('fa_relative_time')) {\r\n\t\t\t\t\t\tfunction fa_relative_time($a) {\r\n\t\t\t\t\t\t\t//get current timestampt\r\n\t\t\t\t\t\t\t$b = strtotime('now'); \r\n\t\t\t\t\t\t\t//get timestamp when tweet created\r\n\t\t\t\t\t\t\t$c = strtotime($a);\r\n\t\t\t\t\t\t\t//get difference\r\n\t\t\t\t\t\t\t$d = $b - $c;\r\n\t\t\t\t\t\t\t//calculate different time values\r\n\t\t\t\t\t\t\t$minute = 60;\r\n\t\t\t\t\t\t\t$hour = $minute * 60;\r\n\t\t\t\t\t\t\t$day = $hour * 24;\r\n\t\t\t\t\t\t\t$week = $day * 7;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(is_numeric($d) && $d > 0) {\r\n\t\t\t\t\t\t\t\t//if less then 3 seconds\r\n\t\t\t\t\t\t\t\tif($d < 3) return __('right now','fa_tweets');\r\n\t\t\t\t\t\t\t\t//if less then minute\r\n\t\t\t\t\t\t\t\tif($d < $minute) return floor($d) . __(' seconds ago','fa_tweets');\r\n\t\t\t\t\t\t\t\t//if less then 2 minutes\r\n\t\t\t\t\t\t\t\tif($d < $minute * 2) return __('about 1 minute ago','fa_tweets');\r\n\t\t\t\t\t\t\t\t//if less then hour\r\n\t\t\t\t\t\t\t\tif($d < $hour) return floor($d / $minute) . __(' minutes ago','fa_tweets');\r\n\t\t\t\t\t\t\t\t//if less then 2 hours\r\n\t\t\t\t\t\t\t\tif($d < $hour * 2) return __('about 1 hour ago','fa_tweets');\r\n\t\t\t\t\t\t\t\t//if less then day\r\n\t\t\t\t\t\t\t\tif($d < $day) return floor($d / $hour) . __(' hours ago','fa_tweets');\r\n\t\t\t\t\t\t\t\t//if more then day, but less then 2 days\r\n\t\t\t\t\t\t\t\tif($d > $day && $d < $day * 2) return __('yesterday','fa_tweets');\r\n\t\t\t\t\t\t\t\t//if less then year\r\n\t\t\t\t\t\t\t\tif($d < $day * 365) return floor($d / $day) . __(' days ago','fa_tweets');\r\n\t\t\t\t\t\t\t\t//else return more than a year\r\n\t\t\t\t\t\t\t\treturn __('over a year ago','fa_tweets');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\t\r\n\t\t\t\t\t}\t\r\n\t\r\n\t\r\n\t\r\n// register\twidget\r\n\tfunction register_fa_twitter_widget(){\r\n\t\tregister_widget('fa_widget_recent_tweet');\r\n\t}\r\n\tfunction add_fa_twitter_plugin_script(){\r\n\t\twp_register_script('test', plugin_dir_url( __FILE__ ).'assets/js/fa_twitter_plugin.js', array('jquery'));\r\n\t\twp_enqueue_script('test');\r\n\t}\r\n\tadd_action('admin_enqueue_scripts', 'add_fa_twitter_plugin_script' );\r\n\tadd_action('widgets_init', 'register_fa_twitter_widget', 1);\r\n\t\r\n?>"
        }
      ]
    }
  ]
}