{
  "metadata": {
    "timestamp": 1736711996180,
    "page": 484,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/http-client",
      "stars": 1962,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "AmpHttpClient.php",
          "type": "blob",
          "size": 8.125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Amp\\CancelledException;\nuse Amp\\DeferredFuture;\nuse Amp\\Http\\Client\\DelegateHttpClient;\nuse Amp\\Http\\Client\\InterceptedHttpClient;\nuse Amp\\Http\\Client\\PooledHttpClient;\nuse Amp\\Http\\Client\\Request;\nuse Amp\\Http\\HttpMessage;\nuse Amp\\Http\\Tunnel\\Http1TunnelConnector;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\nuse Symfony\\Component\\HttpClient\\Exception\\TransportException;\nuse Symfony\\Component\\HttpClient\\Internal\\AmpClientStateV4;\nuse Symfony\\Component\\HttpClient\\Internal\\AmpClientStateV5;\nuse Symfony\\Component\\HttpClient\\Response\\AmpResponseV4;\nuse Symfony\\Component\\HttpClient\\Response\\AmpResponseV5;\nuse Symfony\\Component\\HttpClient\\Response\\ResponseStream;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseStreamInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\nif (!interface_exists(DelegateHttpClient::class)) {\n    throw new \\LogicException('You cannot use \"Symfony\\Component\\HttpClient\\AmpHttpClient\" as the \"amphp/http-client\" package is not installed. Try running \"composer require amphp/http-client:^4.2.1\".');\n}\n\nif (\\PHP_VERSION_ID < 80400 && is_subclass_of(Request::class, HttpMessage::class)) {\n    throw new \\LogicException('Using \"Symfony\\Component\\HttpClient\\AmpHttpClient\" with amphp/http-client >= 5 requires PHP >= 8.4. Try running \"composer require amphp/http-client:^4.2.1\" or upgrade to PHP >= 8.4.');\n}\n\n/**\n * A portable implementation of the HttpClientInterface contracts based on Amp's HTTP client.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class AmpHttpClient implements HttpClientInterface, LoggerAwareInterface, ResetInterface\n{\n    use HttpClientTrait;\n    use LoggerAwareTrait;\n\n    public const OPTIONS_DEFAULTS = HttpClientInterface::OPTIONS_DEFAULTS + [\n        'crypto_method' => \\STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT,\n    ];\n\n    private array $defaultOptions = self::OPTIONS_DEFAULTS;\n    private static array $emptyDefaults = self::OPTIONS_DEFAULTS;\n    private AmpClientStateV4|AmpClientStateV5 $multi;\n\n    /**\n     * @param array         $defaultOptions     Default requests' options\n     * @param callable|null $clientConfigurator A callable that builds a {@see DelegateHttpClient} from a {@see PooledHttpClient};\n     *                                          passing null builds an {@see InterceptedHttpClient} with 2 retries on failures\n     * @param int           $maxHostConnections The maximum number of connections to a single host\n     * @param int           $maxPendingPushes   The maximum number of pushed responses to accept in the queue\n     *\n     * @see HttpClientInterface::OPTIONS_DEFAULTS for available options\n     */\n    public function __construct(array $defaultOptions = [], ?callable $clientConfigurator = null, int $maxHostConnections = 6, int $maxPendingPushes = 50)\n    {\n        $this->defaultOptions['buffer'] ??= self::shouldBuffer(...);\n\n        if ($defaultOptions) {\n            [, $this->defaultOptions] = self::prepareRequest(null, null, $defaultOptions, $this->defaultOptions);\n        }\n\n        if (is_subclass_of(Request::class, HttpMessage::class)) {\n            $this->multi = new AmpClientStateV5($clientConfigurator, $maxHostConnections, $maxPendingPushes, $this->logger);\n        } else {\n            $this->multi = new AmpClientStateV4($clientConfigurator, $maxHostConnections, $maxPendingPushes, $this->logger);\n        }\n    }\n\n    /**\n     * @see HttpClientInterface::OPTIONS_DEFAULTS for available options\n     */\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        [$url, $options] = self::prepareRequest($method, $url, $options, $this->defaultOptions);\n\n        $options['proxy'] = self::getProxy($options['proxy'], $url, $options['no_proxy']);\n\n        if (null !== $options['proxy'] && !class_exists(Http1TunnelConnector::class)) {\n            throw new \\LogicException('You cannot use the \"proxy\" option as the \"amphp/http-tunnel\" package is not installed. Try running \"composer require amphp/http-tunnel\".');\n        }\n\n        if ($options['bindto']) {\n            if (str_starts_with($options['bindto'], 'if!')) {\n                throw new TransportException(__CLASS__.' cannot bind to network interfaces, use e.g. CurlHttpClient instead.');\n            }\n            if (str_starts_with($options['bindto'], 'host!')) {\n                $options['bindto'] = substr($options['bindto'], 5);\n            }\n        }\n\n        if (('' !== $options['body'] || 'POST' === $method || isset($options['normalized_headers']['content-length'])) && !isset($options['normalized_headers']['content-type'])) {\n            $options['headers'][] = 'Content-Type: application/x-www-form-urlencoded';\n        }\n\n        if (!isset($options['normalized_headers']['user-agent'])) {\n            $options['headers'][] = 'User-Agent: Symfony HttpClient (Amp)';\n        }\n\n        if (0 < $options['max_duration']) {\n            $options['timeout'] = min($options['max_duration'], $options['timeout']);\n        }\n\n        if ($options['resolve']) {\n            $this->multi->dnsCache = $options['resolve'] + $this->multi->dnsCache;\n        }\n\n        if ($options['peer_fingerprint'] && !isset($options['peer_fingerprint']['pin-sha256'])) {\n            throw new TransportException(__CLASS__.' supports only \"pin-sha256\" fingerprints.');\n        }\n\n        $request = new Request(implode('', $url), $method);\n        $request->setBodySizeLimit(0);\n\n        if ($options['http_version']) {\n            $request->setProtocolVersions(match ((float) $options['http_version']) {\n                1.0 => ['1.0'],\n                1.1 => ['1.1', '1.0'],\n                default => ['2', '1.1', '1.0'],\n            });\n        }\n\n        foreach ($options['headers'] as $v) {\n            $h = explode(': ', $v, 2);\n            $request->addHeader($h[0], $h[1]);\n        }\n\n        $coef = $request instanceof HttpMessage ? 1 : 1000;\n        $request->setTcpConnectTimeout($coef * $options['timeout']);\n        $request->setTlsHandshakeTimeout($coef * $options['timeout']);\n        $request->setTransferTimeout($coef * $options['max_duration']);\n        if (method_exists($request, 'setInactivityTimeout')) {\n            $request->setInactivityTimeout(0);\n        }\n\n        if ('' !== $request->getUri()->getUserInfo() && !$request->hasHeader('authorization')) {\n            $auth = explode(':', $request->getUri()->getUserInfo(), 2);\n            $auth = array_map('rawurldecode', $auth) + [1 => ''];\n            $request->setHeader('Authorization', 'Basic '.base64_encode(implode(':', $auth)));\n        }\n\n        if ($request instanceof HttpMessage) {\n            return new AmpResponseV5($this->multi, $request, $options, $this->logger);\n        }\n\n        return new AmpResponseV4($this->multi, $request, $options, $this->logger);\n    }\n\n    public function stream(ResponseInterface|iterable $responses, ?float $timeout = null): ResponseStreamInterface\n    {\n        if ($responses instanceof AmpResponseV4 || $responses instanceof AmpResponseV5) {\n            $responses = [$responses];\n        }\n\n        if ($this->multi instanceof AmpClientStateV5) {\n            return new ResponseStream(AmpResponseV5::stream($responses, $timeout));\n        }\n\n        return new ResponseStream(AmpResponseV4::stream($responses, $timeout));\n    }\n\n    public function reset(): void\n    {\n        $this->multi->dnsCache = [];\n\n        foreach ($this->multi->pushedResponses as $pushedResponses) {\n            foreach ($pushedResponses as [$pushedUrl, $pushDeferred]) {\n                if ($pushDeferred instanceof DeferredFuture) {\n                    $pushDeferred->error(new CancelledException());\n                } else {\n                    $pushDeferred->fail(new CancelledException());\n                }\n\n                $this->logger?->debug(\\sprintf('Unused pushed response: \"%s\"', $pushedUrl));\n            }\n        }\n\n        $this->multi->pushedResponses = [];\n    }\n}\n"
        },
        {
          "name": "AsyncDecoratorTrait.php",
          "type": "blob",
          "size": 1.119140625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Symfony\\Component\\HttpClient\\Response\\AsyncResponse;\nuse Symfony\\Component\\HttpClient\\Response\\ResponseStream;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseStreamInterface;\n\n/**\n * Eases with processing responses while streaming them.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\ntrait AsyncDecoratorTrait\n{\n    use DecoratorTrait;\n\n    /**\n     * @return AsyncResponse\n     */\n    abstract public function request(string $method, string $url, array $options = []): ResponseInterface;\n\n    public function stream(ResponseInterface|iterable $responses, ?float $timeout = null): ResponseStreamInterface\n    {\n        if ($responses instanceof AsyncResponse) {\n            $responses = [$responses];\n        }\n\n        return new ResponseStream(AsyncResponse::stream($responses, $timeout, static::class));\n    }\n}\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 4.2587890625,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Add support for amphp/http-client v5 on PHP 8.4+\n\n7.1\n---\n\n * Add `HttpOptions::setHeader()` to add or replace a single header\n * Allow mocking `start_time` info in `MockResponse`\n * Add `MockResponse::fromFile()` and `JsonMockResponse::fromFile()` methods to help using fixtures files\n * Add `ThrottlingHttpClient` to enable limiting the number of requests within a certain period\n * Deprecate the `setLogger()` methods of the `NoPrivateNetworkHttpClient`, `TraceableHttpClient` and `ScopingHttpClient` classes, configure the logger of the wrapped clients directly instead\n\n7.0\n---\n\n * Remove implementing `Http\\Message\\RequestFactory` from `HttplugClient`\n\n6.4\n---\n\n * Add `HarFileResponseFactory` testing utility, allow to replay responses from `.har` files\n * Add `max_retries` option to `RetryableHttpClient` to adjust the retry logic on a per request level\n * Add `PingWehookMessage` and `PingWebhookMessageHandler`\n * Enable using EventSourceHttpClient::connect() for both GET and POST\n\n6.3\n---\n\n * Add option `crypto_method` to set the minimum TLS version and make it default to v1.2\n * Add `UriTemplateHttpClient` to use URI templates as specified in the RFC 6570\n * Add `ServerSentEvent::getArrayData()` to get the Server-Sent Event's data decoded as an array when it's a JSON payload\n * Allow array of urls as `base_uri` option value in `RetryableHttpClient` to retry on a new url each time\n * Add `JsonMockResponse`, a `MockResponse` shortcut that automatically encodes the passed body to JSON and sets the content type to `application/json` by default\n * Support file uploads by nesting resource streams in option \"body\"\n\n6.2\n---\n\n * Make `HttplugClient` implement `Psr\\Http\\Message\\RequestFactoryInterface`, `StreamFactoryInterface` and `UriFactoryInterface`\n * Deprecate implementing `Http\\Message\\RequestFactory`, `StreamFactory` and `UriFactory` on `HttplugClient`\n * Add `withOptions()` to `HttplugClient` and `Psr18Client`\n\n6.1\n---\n\n * Allow yielding `Exception` from MockResponse's `$body` to mock transport errors\n * Remove credentials from requests redirected to same host but different port\n\n5.4\n---\n\n * Add `MockHttpClient::setResponseFactory()` method to be able to set response factory after client creating\n\n5.3\n---\n\n * Implement `HttpClientInterface::withOptions()` from `symfony/contracts` v2.4\n * Add `DecoratorTrait` to ease writing simple decorators\n\n5.2.0\n-----\n\n * added `AsyncDecoratorTrait` to ease processing responses without breaking async\n * added support for pausing responses with a new `pause_handler` callable exposed as an info item\n * added `StreamableInterface` to ease turning responses into PHP streams\n * added `MockResponse::getRequestMethod()` and `getRequestUrl()` to allow inspecting which request has been sent\n * added `EventSourceHttpClient` a Server-Sent events stream implementing the [EventSource specification](https://www.w3.org/TR/eventsource/#eventsource)\n * added option \"extra.curl\" to allow setting additional curl options in `CurlHttpClient`\n * added `RetryableHttpClient` to automatically retry failed HTTP requests.\n * added `extra.trace_content` option to `TraceableHttpClient` to prevent it from keeping the content in memory\n\n5.1.0\n-----\n\n * added `NoPrivateNetworkHttpClient` decorator\n * added `AmpHttpClient`, a portable HTTP/2 implementation based on Amp\n * added `LoggerAwareInterface` to `ScopingHttpClient` and `TraceableHttpClient`\n * made `HttpClient::create()` return an `AmpHttpClient` when `amphp/http-client` is found but curl is not or too old\n\n4.4.0\n-----\n\n * added `canceled` to `ResponseInterface::getInfo()`\n * added `HttpClient::createForBaseUri()`\n * added `HttplugClient` with support for sync and async requests\n * added `max_duration` option\n * added support for NTLM authentication\n * added `StreamWrapper` to cast any `ResponseInterface` instances to PHP streams.\n * added `$response->toStream()` to cast responses to regular PHP streams\n * made `Psr18Client` implement relevant PSR-17 factories and have streaming responses\n * added `TraceableHttpClient`, `HttpClientDataCollector` and `HttpClientPass` to integrate with the web profiler\n * allow enabling buffering conditionally with a Closure\n * allow option \"buffer\" to be a stream resource\n * allow arbitrary values for the \"json\" option\n\n4.3.0\n-----\n\n * added the component\n"
        },
        {
          "name": "CachingHttpClient.php",
          "type": "blob",
          "size": 5.1962890625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Symfony\\Component\\HttpClient\\Response\\MockResponse;\nuse Symfony\\Component\\HttpClient\\Response\\ResponseStream;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\HttpCache\\HttpCache;\nuse Symfony\\Component\\HttpKernel\\HttpCache\\StoreInterface;\nuse Symfony\\Component\\HttpKernel\\HttpClientKernel;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseStreamInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * Adds caching on top of an HTTP client.\n *\n * The implementation buffers responses in memory and doesn't stream directly from the network.\n * You can disable/enable this layer by setting option \"no_cache\" under \"extra\" to true/false.\n * By default, caching is enabled unless the \"buffer\" option is set to false.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass CachingHttpClient implements HttpClientInterface, ResetInterface\n{\n    use HttpClientTrait;\n\n    private HttpCache $cache;\n    private array $defaultOptions = self::OPTIONS_DEFAULTS;\n\n    public function __construct(\n        private HttpClientInterface $client,\n        StoreInterface $store,\n        array $defaultOptions = [],\n    ) {\n        if (!class_exists(HttpClientKernel::class)) {\n            throw new \\LogicException(\\sprintf('Using \"%s\" requires the HttpKernel component, try running \"composer require symfony/http-kernel\".', __CLASS__));\n        }\n\n        $kernel = new HttpClientKernel($client);\n        $this->cache = new HttpCache($kernel, $store, null, $defaultOptions);\n\n        unset($defaultOptions['debug']);\n        unset($defaultOptions['default_ttl']);\n        unset($defaultOptions['private_headers']);\n        unset($defaultOptions['skip_response_headers']);\n        unset($defaultOptions['allow_reload']);\n        unset($defaultOptions['allow_revalidate']);\n        unset($defaultOptions['stale_while_revalidate']);\n        unset($defaultOptions['stale_if_error']);\n        unset($defaultOptions['trace_level']);\n        unset($defaultOptions['trace_header']);\n\n        if ($defaultOptions) {\n            [, $this->defaultOptions] = self::prepareRequest(null, null, $defaultOptions, $this->defaultOptions);\n        }\n    }\n\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        [$url, $options] = $this->prepareRequest($method, $url, $options, $this->defaultOptions, true);\n        $url = implode('', $url);\n\n        if (!empty($options['body']) || !empty($options['extra']['no_cache']) || !\\in_array($method, ['GET', 'HEAD', 'OPTIONS'])) {\n            return $this->client->request($method, $url, $options);\n        }\n\n        $request = Request::create($url, $method);\n        $request->attributes->set('http_client_options', $options);\n\n        foreach ($options['normalized_headers'] as $name => $values) {\n            if ('cookie' !== $name) {\n                foreach ($values as $value) {\n                    $request->headers->set($name, substr($value, 2 + \\strlen($name)), false);\n                }\n\n                continue;\n            }\n\n            foreach ($values as $cookies) {\n                foreach (explode('; ', substr($cookies, \\strlen('Cookie: '))) as $cookie) {\n                    if ('' !== $cookie) {\n                        $cookie = explode('=', $cookie, 2);\n                        $request->cookies->set($cookie[0], $cookie[1] ?? '');\n                    }\n                }\n            }\n        }\n\n        $response = $this->cache->handle($request);\n        $response = new MockResponse($response->getContent(), [\n            'http_code' => $response->getStatusCode(),\n            'response_headers' => $response->headers->allPreserveCase(),\n        ]);\n\n        return MockResponse::fromRequest($method, $url, $options, $response);\n    }\n\n    public function stream(ResponseInterface|iterable $responses, ?float $timeout = null): ResponseStreamInterface\n    {\n        if ($responses instanceof ResponseInterface) {\n            $responses = [$responses];\n        }\n\n        $mockResponses = [];\n        $clientResponses = [];\n\n        foreach ($responses as $response) {\n            if ($response instanceof MockResponse) {\n                $mockResponses[] = $response;\n            } else {\n                $clientResponses[] = $response;\n            }\n        }\n\n        if (!$mockResponses) {\n            return $this->client->stream($clientResponses, $timeout);\n        }\n\n        if (!$clientResponses) {\n            return new ResponseStream(MockResponse::stream($mockResponses, $timeout));\n        }\n\n        return new ResponseStream((function () use ($mockResponses, $clientResponses, $timeout) {\n            yield from MockResponse::stream($mockResponses, $timeout);\n            yield $this->client->stream($clientResponses, $timeout);\n        })());\n    }\n\n    public function reset(): void\n    {\n        if ($this->client instanceof ResetInterface) {\n            $this->client->reset();\n        }\n    }\n}\n"
        },
        {
          "name": "Chunk",
          "type": "tree",
          "content": null
        },
        {
          "name": "CurlHttpClient.php",
          "type": "blob",
          "size": 23.3193359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\HttpClient\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\HttpClient\\Exception\\TransportException;\nuse Symfony\\Component\\HttpClient\\Internal\\CurlClientState;\nuse Symfony\\Component\\HttpClient\\Internal\\PushedResponse;\nuse Symfony\\Component\\HttpClient\\Response\\CurlResponse;\nuse Symfony\\Component\\HttpClient\\Response\\ResponseStream;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseStreamInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * A performant implementation of the HttpClientInterface contracts based on the curl extension.\n *\n * This provides fully concurrent HTTP requests, with transparent\n * HTTP/2 push when a curl version that supports it is installed.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class CurlHttpClient implements HttpClientInterface, LoggerAwareInterface, ResetInterface\n{\n    use HttpClientTrait;\n\n    public const OPTIONS_DEFAULTS = HttpClientInterface::OPTIONS_DEFAULTS + [\n        'crypto_method' => \\STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT,\n    ];\n\n    private array $defaultOptions = self::OPTIONS_DEFAULTS + [\n        'auth_ntlm' => null, // array|string - an array containing the username as first value, and optionally the\n                             //   password as the second one; or string like username:password - enabling NTLM auth\n        'extra' => [\n            'curl' => [],    // A list of extra curl options indexed by their corresponding CURLOPT_*\n        ],\n    ];\n    private static array $emptyDefaults = self::OPTIONS_DEFAULTS + ['auth_ntlm' => null];\n\n    private ?LoggerInterface $logger = null;\n\n    private int $maxHostConnections;\n    private int $maxPendingPushes;\n\n    /**\n     * An internal object to share state between the client and its responses.\n     */\n    private CurlClientState $multi;\n\n    /**\n     * @param array $defaultOptions     Default request's options\n     * @param int   $maxHostConnections The maximum number of connections to a single host\n     * @param int   $maxPendingPushes   The maximum number of pushed responses to accept in the queue\n     *\n     * @see HttpClientInterface::OPTIONS_DEFAULTS for available options\n     */\n    public function __construct(array $defaultOptions = [], int $maxHostConnections = 6, int $maxPendingPushes = 0)\n    {\n        if (!\\extension_loaded('curl')) {\n            throw new \\LogicException('You cannot use the \"Symfony\\Component\\HttpClient\\CurlHttpClient\" as the \"curl\" extension is not installed.');\n        }\n\n        $this->maxHostConnections = $maxHostConnections;\n        $this->maxPendingPushes = $maxPendingPushes;\n\n        $this->defaultOptions['buffer'] ??= self::shouldBuffer(...);\n\n        if ($defaultOptions) {\n            [, $this->defaultOptions] = self::prepareRequest(null, null, $defaultOptions, $this->defaultOptions);\n        }\n    }\n\n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n        if (isset($this->multi)) {\n            $this->multi->logger = $logger;\n        }\n    }\n\n    /**\n     * @see HttpClientInterface::OPTIONS_DEFAULTS for available options\n     */\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        $multi = $this->ensureState();\n\n        [$url, $options] = self::prepareRequest($method, $url, $options, $this->defaultOptions);\n        $scheme = $url['scheme'];\n        $authority = $url['authority'];\n        $host = parse_url($authority, \\PHP_URL_HOST);\n        $port = parse_url($authority, \\PHP_URL_PORT) ?: ('http:' === $scheme ? 80 : 443);\n        $proxy = self::getProxyUrl($options['proxy'], $url);\n        $url = implode('', $url);\n\n        if (!isset($options['normalized_headers']['user-agent'])) {\n            $options['headers'][] = 'User-Agent: Symfony HttpClient (Curl)';\n        }\n\n        $curlopts = [\n            \\CURLOPT_URL => $url,\n            \\CURLOPT_TCP_NODELAY => true,\n            \\CURLOPT_PROTOCOLS => \\CURLPROTO_HTTP | \\CURLPROTO_HTTPS,\n            \\CURLOPT_REDIR_PROTOCOLS => \\CURLPROTO_HTTP | \\CURLPROTO_HTTPS,\n            \\CURLOPT_FOLLOWLOCATION => true,\n            \\CURLOPT_MAXREDIRS => max(0, $options['max_redirects']),\n            \\CURLOPT_COOKIEFILE => '', // Keep track of cookies during redirects\n            \\CURLOPT_TIMEOUT => 0,\n            \\CURLOPT_PROXY => $proxy,\n            \\CURLOPT_NOPROXY => $options['no_proxy'] ?? $_SERVER['no_proxy'] ?? $_SERVER['NO_PROXY'] ?? '',\n            \\CURLOPT_SSL_VERIFYPEER => $options['verify_peer'],\n            \\CURLOPT_SSL_VERIFYHOST => $options['verify_host'] ? 2 : 0,\n            \\CURLOPT_CAINFO => $options['cafile'],\n            \\CURLOPT_CAPATH => $options['capath'],\n            \\CURLOPT_SSL_CIPHER_LIST => $options['ciphers'],\n            \\CURLOPT_SSLCERT => $options['local_cert'],\n            \\CURLOPT_SSLKEY => $options['local_pk'],\n            \\CURLOPT_KEYPASSWD => $options['passphrase'],\n            \\CURLOPT_CERTINFO => $options['capture_peer_cert_chain'],\n            \\CURLOPT_SSLVERSION => match ($options['crypto_method']) {\n                \\STREAM_CRYPTO_METHOD_TLSv1_3_CLIENT => \\CURL_SSLVERSION_TLSv1_3,\n                \\STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT => \\CURL_SSLVERSION_TLSv1_2,\n                \\STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT => \\CURL_SSLVERSION_TLSv1_1,\n                \\STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT => \\CURL_SSLVERSION_TLSv1_0,\n            },\n        ];\n\n        if (1.0 === (float) $options['http_version']) {\n            $curlopts[\\CURLOPT_HTTP_VERSION] = \\CURL_HTTP_VERSION_1_0;\n        } elseif (1.1 === (float) $options['http_version']) {\n            $curlopts[\\CURLOPT_HTTP_VERSION] = \\CURL_HTTP_VERSION_1_1;\n        } elseif (\\defined('CURL_VERSION_HTTP2') && (\\CURL_VERSION_HTTP2 & CurlClientState::$curlVersion['features']) && ('https:' === $scheme || 2.0 === (float) $options['http_version'])) {\n            $curlopts[\\CURLOPT_HTTP_VERSION] = \\CURL_HTTP_VERSION_2_0;\n        }\n\n        if (isset($options['auth_ntlm'])) {\n            $curlopts[\\CURLOPT_HTTPAUTH] = \\CURLAUTH_NTLM;\n            $curlopts[\\CURLOPT_HTTP_VERSION] = \\CURL_HTTP_VERSION_1_1;\n\n            if (\\is_array($options['auth_ntlm'])) {\n                $count = \\count($options['auth_ntlm']);\n                if ($count <= 0 || $count > 2) {\n                    throw new InvalidArgumentException(\\sprintf('Option \"auth_ntlm\" must contain 1 or 2 elements, %d given.', $count));\n                }\n\n                $options['auth_ntlm'] = implode(':', $options['auth_ntlm']);\n            }\n\n            if (!\\is_string($options['auth_ntlm'])) {\n                throw new InvalidArgumentException(\\sprintf('Option \"auth_ntlm\" must be a string or an array, \"%s\" given.', get_debug_type($options['auth_ntlm'])));\n            }\n\n            $curlopts[\\CURLOPT_USERPWD] = $options['auth_ntlm'];\n        }\n\n        if (!\\ZEND_THREAD_SAFE) {\n            $curlopts[\\CURLOPT_DNS_USE_GLOBAL_CACHE] = false;\n        }\n\n        if (\\defined('CURLOPT_HEADEROPT') && \\defined('CURLHEADER_SEPARATE')) {\n            $curlopts[\\CURLOPT_HEADEROPT] = \\CURLHEADER_SEPARATE;\n        }\n\n        // curl's resolve feature varies by host:port but ours varies by host only, let's handle this with our own DNS map\n        if (isset($multi->dnsCache->hostnames[$host])) {\n            $options['resolve'] += [$host => $multi->dnsCache->hostnames[$host]];\n        }\n\n        if ($options['resolve'] || $multi->dnsCache->evictions) {\n            // First reset any old DNS cache entries then add the new ones\n            $resolve = $multi->dnsCache->evictions;\n            $multi->dnsCache->evictions = [];\n\n            if ($resolve && 0x072A00 > CurlClientState::$curlVersion['version_number']) {\n                // DNS cache removals require curl 7.42 or higher\n                $multi->reset();\n            }\n\n            foreach ($options['resolve'] as $resolveHost => $ip) {\n                $resolve[] = null === $ip ? \"-$resolveHost:$port\" : \"$resolveHost:$port:$ip\";\n                $multi->dnsCache->hostnames[$resolveHost] = $ip;\n                $multi->dnsCache->removals[\"-$resolveHost:$port\"] = \"-$resolveHost:$port\";\n            }\n\n            $curlopts[\\CURLOPT_RESOLVE] = $resolve;\n        }\n\n        $curlopts[\\CURLOPT_CUSTOMREQUEST] = $method;\n        if ('POST' === $method) {\n            // Use CURLOPT_POST to have browser-like POST-to-GET redirects for 301, 302 and 303\n            $curlopts[\\CURLOPT_POST] = true;\n        } elseif ('HEAD' === $method) {\n            $curlopts[\\CURLOPT_NOBODY] = true;\n        }\n\n        if ('\\\\' !== \\DIRECTORY_SEPARATOR && $options['timeout'] < 1) {\n            $curlopts[\\CURLOPT_NOSIGNAL] = true;\n        }\n\n        if (\\extension_loaded('zlib') && !isset($options['normalized_headers']['accept-encoding'])) {\n            $options['headers'][] = 'Accept-Encoding: gzip'; // Expose only one encoding, some servers mess up when more are provided\n        }\n        $body = $options['body'];\n\n        foreach ($options['headers'] as $i => $header) {\n            if (\\is_string($body) && '' !== $body && 0 === stripos($header, 'Content-Length: ')) {\n                // Let curl handle Content-Length headers\n                unset($options['headers'][$i]);\n                continue;\n            }\n            if (':' === $header[-2] && \\strlen($header) - 2 === strpos($header, ': ')) {\n                // curl requires a special syntax to send empty headers\n                $curlopts[\\CURLOPT_HTTPHEADER][] = substr_replace($header, ';', -2);\n            } else {\n                $curlopts[\\CURLOPT_HTTPHEADER][] = $header;\n            }\n        }\n\n        // Prevent curl from sending its default Accept and Expect headers\n        foreach (['accept', 'expect'] as $header) {\n            if (!isset($options['normalized_headers'][$header][0])) {\n                $curlopts[\\CURLOPT_HTTPHEADER][] = $header.':';\n            }\n        }\n\n        if (!\\is_string($body)) {\n            if (\\is_resource($body)) {\n                $curlopts[\\CURLOPT_INFILE] = $body;\n            } else {\n                $curlopts[\\CURLOPT_READFUNCTION] = static function ($ch, $fd, $length) use ($body) {\n                    static $eof = false;\n                    static $buffer = '';\n\n                    return self::readRequestBody($length, $body, $buffer, $eof);\n                };\n            }\n\n            if (isset($options['normalized_headers']['content-length'][0])) {\n                $curlopts[\\CURLOPT_INFILESIZE] = (int) substr($options['normalized_headers']['content-length'][0], \\strlen('Content-Length: '));\n            }\n            if (!isset($options['normalized_headers']['transfer-encoding'])) {\n                $curlopts[\\CURLOPT_HTTPHEADER][] = 'Transfer-Encoding:'.(isset($curlopts[\\CURLOPT_INFILESIZE]) ? '' : ' chunked');\n            }\n\n            if ('POST' !== $method) {\n                $curlopts[\\CURLOPT_UPLOAD] = true;\n\n                if (!isset($options['normalized_headers']['content-type']) && 0 !== ($curlopts[\\CURLOPT_INFILESIZE] ?? null)) {\n                    $curlopts[\\CURLOPT_HTTPHEADER][] = 'Content-Type: application/x-www-form-urlencoded';\n                }\n            }\n        } elseif ('' !== $body || 'POST' === $method) {\n            $curlopts[\\CURLOPT_POSTFIELDS] = $body;\n        }\n\n        if ($options['peer_fingerprint']) {\n            if (!isset($options['peer_fingerprint']['pin-sha256'])) {\n                throw new TransportException(__CLASS__.' supports only \"pin-sha256\" fingerprints.');\n            }\n\n            $curlopts[\\CURLOPT_PINNEDPUBLICKEY] = 'sha256//'.implode(';sha256//', $options['peer_fingerprint']['pin-sha256']);\n        }\n\n        if ($options['bindto']) {\n            if (file_exists($options['bindto'])) {\n                $curlopts[\\CURLOPT_UNIX_SOCKET_PATH] = $options['bindto'];\n            } elseif (!str_starts_with($options['bindto'], 'if!') && preg_match('/^(.*):(\\d+)$/', $options['bindto'], $matches)) {\n                $curlopts[\\CURLOPT_INTERFACE] = trim($matches[1], '[]');\n                $curlopts[\\CURLOPT_LOCALPORT] = $matches[2];\n            } else {\n                $curlopts[\\CURLOPT_INTERFACE] = $options['bindto'];\n            }\n        }\n\n        if (0 < $options['max_duration']) {\n            $curlopts[\\CURLOPT_TIMEOUT_MS] = 1000 * $options['max_duration'];\n        }\n\n        if (!empty($options['extra']['curl']) && \\is_array($options['extra']['curl'])) {\n            $this->validateExtraCurlOptions($options['extra']['curl']);\n            $curlopts += $options['extra']['curl'];\n        }\n\n        if ($pushedResponse = $multi->pushedResponses[$url] ?? null) {\n            unset($multi->pushedResponses[$url]);\n\n            if (self::acceptPushForRequest($method, $options, $pushedResponse)) {\n                $this->logger?->debug(\\sprintf('Accepting pushed response: \"%s %s\"', $method, $url));\n\n                // Reinitialize the pushed response with request's options\n                $ch = $pushedResponse->handle;\n                $pushedResponse = $pushedResponse->response;\n                $pushedResponse->__construct($multi, $url, $options, $this->logger);\n            } else {\n                $this->logger?->debug(\\sprintf('Rejecting pushed response: \"%s\"', $url));\n                $pushedResponse = null;\n            }\n        }\n\n        if (!$pushedResponse) {\n            $ch = curl_init();\n            $this->logger?->info(\\sprintf('Request: \"%s %s\"', $method, $url));\n            $curlopts += [\\CURLOPT_SHARE => $multi->share];\n        }\n\n        foreach ($curlopts as $opt => $value) {\n            if (null !== $value && !curl_setopt($ch, $opt, $value) && \\CURLOPT_CERTINFO !== $opt && (!\\defined('CURLOPT_HEADEROPT') || \\CURLOPT_HEADEROPT !== $opt)) {\n                $constantName = $this->findConstantName($opt);\n                throw new TransportException(\\sprintf('Curl option \"%s\" is not supported.', $constantName ?? $opt));\n            }\n        }\n\n        return $pushedResponse ?? new CurlResponse($multi, $ch, $options, $this->logger, $method, self::createRedirectResolver($options, $authority), CurlClientState::$curlVersion['version_number'], $url);\n    }\n\n    public function stream(ResponseInterface|iterable $responses, ?float $timeout = null): ResponseStreamInterface\n    {\n        if ($responses instanceof CurlResponse) {\n            $responses = [$responses];\n        }\n\n        $multi = $this->ensureState();\n\n        if ($multi->handle instanceof \\CurlMultiHandle) {\n            $active = 0;\n            while (\\CURLM_CALL_MULTI_PERFORM === curl_multi_exec($multi->handle, $active)) {\n            }\n        }\n\n        return new ResponseStream(CurlResponse::stream($responses, $timeout));\n    }\n\n    public function reset(): void\n    {\n        if (isset($this->multi)) {\n            $this->multi->reset();\n        }\n    }\n\n    /**\n     * Accepts pushed responses only if their headers related to authentication match the request.\n     */\n    private static function acceptPushForRequest(string $method, array $options, PushedResponse $pushedResponse): bool\n    {\n        if ('' !== $options['body'] || $method !== $pushedResponse->requestHeaders[':method'][0]) {\n            return false;\n        }\n\n        foreach (['proxy', 'no_proxy', 'bindto', 'local_cert', 'local_pk'] as $k) {\n            if ($options[$k] !== $pushedResponse->parentOptions[$k]) {\n                return false;\n            }\n        }\n\n        foreach (['authorization', 'cookie', 'range', 'proxy-authorization'] as $k) {\n            $normalizedHeaders = $options['normalized_headers'][$k] ?? [];\n            foreach ($normalizedHeaders as $i => $v) {\n                $normalizedHeaders[$i] = substr($v, \\strlen($k) + 2);\n            }\n\n            if (($pushedResponse->requestHeaders[$k] ?? []) !== $normalizedHeaders) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Wraps the request's body callback to allow it to return strings longer than curl requested.\n     */\n    private static function readRequestBody(int $length, \\Closure $body, string &$buffer, bool &$eof): string\n    {\n        if (!$eof && \\strlen($buffer) < $length) {\n            if (!\\is_string($data = $body($length))) {\n                throw new TransportException(\\sprintf('The return value of the \"body\" option callback must be a string, \"%s\" returned.', get_debug_type($data)));\n            }\n\n            $buffer .= $data;\n            $eof = '' === $data;\n        }\n\n        $data = substr($buffer, 0, $length);\n        $buffer = substr($buffer, $length);\n\n        return $data;\n    }\n\n    /**\n     * Resolves relative URLs on redirects and deals with authentication headers.\n     *\n     * Work around CVE-2018-1000007: Authorization and Cookie headers should not follow redirects - fixed in Curl 7.64\n     */\n    private static function createRedirectResolver(array $options, string $authority): \\Closure\n    {\n        $redirectHeaders = [];\n        if (0 < $options['max_redirects']) {\n            $redirectHeaders['authority'] = $authority;\n            $redirectHeaders['with_auth'] = $redirectHeaders['no_auth'] = array_filter($options['headers'], static fn ($h) => 0 !== stripos($h, 'Host:'));\n\n            if (isset($options['normalized_headers']['authorization'][0]) || isset($options['normalized_headers']['cookie'][0])) {\n                $redirectHeaders['no_auth'] = array_filter($options['headers'], static fn ($h) => 0 !== stripos($h, 'Authorization:') && 0 !== stripos($h, 'Cookie:'));\n            }\n        }\n\n        return static function ($ch, string $location, bool $noContent) use (&$redirectHeaders, $options) {\n            try {\n                $location = self::parseUrl($location);\n                $url = self::parseUrl(curl_getinfo($ch, \\CURLINFO_EFFECTIVE_URL));\n                $url = self::resolveUrl($location, $url);\n            } catch (InvalidArgumentException) {\n                return null;\n            }\n\n            if ($noContent && $redirectHeaders) {\n                $filterContentHeaders = static fn ($h) => 0 !== stripos($h, 'Content-Length:') && 0 !== stripos($h, 'Content-Type:') && 0 !== stripos($h, 'Transfer-Encoding:');\n                $redirectHeaders['no_auth'] = array_filter($redirectHeaders['no_auth'], $filterContentHeaders);\n                $redirectHeaders['with_auth'] = array_filter($redirectHeaders['with_auth'], $filterContentHeaders);\n            }\n\n            if ($redirectHeaders && isset($location['authority'])) {\n                $requestHeaders = $location['authority'] === $redirectHeaders['authority'] ? $redirectHeaders['with_auth'] : $redirectHeaders['no_auth'];\n                curl_setopt($ch, \\CURLOPT_HTTPHEADER, $requestHeaders);\n            } elseif ($noContent && $redirectHeaders) {\n                curl_setopt($ch, \\CURLOPT_HTTPHEADER, $redirectHeaders['with_auth']);\n            }\n\n            curl_setopt($ch, \\CURLOPT_PROXY, self::getProxyUrl($options['proxy'], $url));\n\n            return implode('', $url);\n        };\n    }\n\n    private function ensureState(): CurlClientState\n    {\n        if (!isset($this->multi)) {\n            $this->multi = new CurlClientState($this->maxHostConnections, $this->maxPendingPushes);\n            $this->multi->logger = $this->logger;\n        }\n\n        return $this->multi;\n    }\n\n    private function findConstantName(int $opt): ?string\n    {\n        $constants = array_filter(get_defined_constants(), static fn ($v, $k) => $v === $opt && 'C' === $k[0] && (str_starts_with($k, 'CURLOPT_') || str_starts_with($k, 'CURLINFO_')), \\ARRAY_FILTER_USE_BOTH);\n\n        return key($constants);\n    }\n\n    /**\n     * Prevents overriding options that are set internally throughout the request.\n     */\n    private function validateExtraCurlOptions(array $options): void\n    {\n        $curloptsToConfig = [\n            // options used in CurlHttpClient\n            \\CURLOPT_HTTPAUTH => 'auth_ntlm',\n            \\CURLOPT_USERPWD => 'auth_ntlm',\n            \\CURLOPT_RESOLVE => 'resolve',\n            \\CURLOPT_NOSIGNAL => 'timeout',\n            \\CURLOPT_HTTPHEADER => 'headers',\n            \\CURLOPT_INFILE => 'body',\n            \\CURLOPT_READFUNCTION => 'body',\n            \\CURLOPT_INFILESIZE => 'body',\n            \\CURLOPT_POSTFIELDS => 'body',\n            \\CURLOPT_UPLOAD => 'body',\n            \\CURLOPT_INTERFACE => 'bindto',\n            \\CURLOPT_TIMEOUT_MS => 'max_duration',\n            \\CURLOPT_TIMEOUT => 'max_duration',\n            \\CURLOPT_MAXREDIRS => 'max_redirects',\n            \\CURLOPT_POSTREDIR => 'max_redirects',\n            \\CURLOPT_PROXY => 'proxy',\n            \\CURLOPT_NOPROXY => 'no_proxy',\n            \\CURLOPT_SSL_VERIFYPEER => 'verify_peer',\n            \\CURLOPT_SSL_VERIFYHOST => 'verify_host',\n            \\CURLOPT_CAINFO => 'cafile',\n            \\CURLOPT_CAPATH => 'capath',\n            \\CURLOPT_SSL_CIPHER_LIST => 'ciphers',\n            \\CURLOPT_SSLCERT => 'local_cert',\n            \\CURLOPT_SSLKEY => 'local_pk',\n            \\CURLOPT_KEYPASSWD => 'passphrase',\n            \\CURLOPT_CERTINFO => 'capture_peer_cert_chain',\n            \\CURLOPT_USERAGENT => 'normalized_headers',\n            \\CURLOPT_REFERER => 'headers',\n            // options used in CurlResponse\n            \\CURLOPT_NOPROGRESS => 'on_progress',\n            \\CURLOPT_PROGRESSFUNCTION => 'on_progress',\n        ];\n\n        if (\\defined('CURLOPT_UNIX_SOCKET_PATH')) {\n            $curloptsToConfig[\\CURLOPT_UNIX_SOCKET_PATH] = 'bindto';\n        }\n\n        if (\\defined('CURLOPT_PINNEDPUBLICKEY')) {\n            $curloptsToConfig[\\CURLOPT_PINNEDPUBLICKEY] = 'peer_fingerprint';\n        }\n\n        $curloptsToCheck = [\n            \\CURLOPT_PRIVATE,\n            \\CURLOPT_HEADERFUNCTION,\n            \\CURLOPT_WRITEFUNCTION,\n            \\CURLOPT_VERBOSE,\n            \\CURLOPT_STDERR,\n            \\CURLOPT_RETURNTRANSFER,\n            \\CURLOPT_URL,\n            \\CURLOPT_FOLLOWLOCATION,\n            \\CURLOPT_HEADER,\n            \\CURLOPT_CONNECTTIMEOUT,\n            \\CURLOPT_CONNECTTIMEOUT_MS,\n            \\CURLOPT_HTTP_VERSION,\n            \\CURLOPT_PORT,\n            \\CURLOPT_DNS_USE_GLOBAL_CACHE,\n            \\CURLOPT_PROTOCOLS,\n            \\CURLOPT_REDIR_PROTOCOLS,\n            \\CURLOPT_COOKIEFILE,\n            \\CURLINFO_REDIRECT_COUNT,\n        ];\n\n        if (\\defined('CURLOPT_HTTP09_ALLOWED')) {\n            $curloptsToCheck[] = \\CURLOPT_HTTP09_ALLOWED;\n        }\n\n        if (\\defined('CURLOPT_HEADEROPT')) {\n            $curloptsToCheck[] = \\CURLOPT_HEADEROPT;\n        }\n\n        $methodOpts = [\n            \\CURLOPT_POST,\n            \\CURLOPT_PUT,\n            \\CURLOPT_CUSTOMREQUEST,\n            \\CURLOPT_HTTPGET,\n            \\CURLOPT_NOBODY,\n        ];\n\n        foreach ($options as $opt => $optValue) {\n            if (isset($curloptsToConfig[$opt])) {\n                $constName = $this->findConstantName($opt) ?? $opt;\n                throw new InvalidArgumentException(\\sprintf('Cannot set \"%s\" with \"extra.curl\", use option \"%s\" instead.', $constName, $curloptsToConfig[$opt]));\n            }\n\n            if (\\in_array($opt, $methodOpts, true)) {\n                throw new InvalidArgumentException('The HTTP method cannot be overridden using \"extra.curl\".');\n            }\n\n            if (\\in_array($opt, $curloptsToCheck, true)) {\n                $constName = $this->findConstantName($opt) ?? $opt;\n                throw new InvalidArgumentException(\\sprintf('Cannot set \"%s\" with \"extra.curl\".', $constName));\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "DataCollector",
          "type": "tree",
          "content": null
        },
        {
          "name": "DecoratorTrait.php",
          "type": "blob",
          "size": 1.443359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseStreamInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * Eases with writing decorators.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\ntrait DecoratorTrait\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        return $this->client->request($method, $url, $options);\n    }\n\n    public function stream(ResponseInterface|iterable $responses, ?float $timeout = null): ResponseStreamInterface\n    {\n        return $this->client->stream($responses, $timeout);\n    }\n\n    public function withOptions(array $options): static\n    {\n        $clone = clone $this;\n        $clone->client = $this->client->withOptions($options);\n\n        return $clone;\n    }\n\n    public function reset(): void\n    {\n        if ($this->client instanceof ResetInterface) {\n            $this->client->reset();\n        }\n    }\n}\n"
        },
        {
          "name": "DependencyInjection",
          "type": "tree",
          "content": null
        },
        {
          "name": "EventSourceHttpClient.php",
          "type": "blob",
          "size": 5.859375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Symfony\\Component\\HttpClient\\Chunk\\DataChunk;\nuse Symfony\\Component\\HttpClient\\Chunk\\ServerSentEvent;\nuse Symfony\\Component\\HttpClient\\Exception\\EventSourceException;\nuse Symfony\\Component\\HttpClient\\Response\\AsyncContext;\nuse Symfony\\Component\\HttpClient\\Response\\AsyncResponse;\nuse Symfony\\Contracts\\HttpClient\\ChunkInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * @author Antoine Bluchet <soyuka@gmail.com>\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class EventSourceHttpClient implements HttpClientInterface, ResetInterface\n{\n    use AsyncDecoratorTrait, HttpClientTrait {\n        AsyncDecoratorTrait::withOptions insteadof HttpClientTrait;\n    }\n\n    public function __construct(\n        ?HttpClientInterface $client = null,\n        private float $reconnectionTime = 10.0,\n    ) {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function connect(string $url, array $options = [], string $method = 'GET'): ResponseInterface\n    {\n        return $this->request($method, $url, self::mergeDefaultOptions($options, [\n            'buffer' => false,\n            'headers' => [\n                'Accept' => 'text/event-stream',\n                'Cache-Control' => 'no-cache',\n            ],\n        ], true));\n    }\n\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        $state = new class {\n            public ?string $buffer = null;\n            public ?string $lastEventId = null;\n            public float $reconnectionTime;\n            public ?float $lastError = null;\n        };\n        $state->reconnectionTime = $this->reconnectionTime;\n\n        if ($accept = self::normalizeHeaders($options['headers'] ?? [])['accept'] ?? []) {\n            $state->buffer = \\in_array($accept, [['Accept: text/event-stream'], ['accept: text/event-stream']], true) ? '' : null;\n\n            if (null !== $state->buffer) {\n                $options['extra']['trace_content'] = false;\n            }\n        }\n\n        return new AsyncResponse($this->client, $method, $url, $options, static function (ChunkInterface $chunk, AsyncContext $context) use ($state, $method, $url, $options) {\n            if (null !== $state->buffer) {\n                $context->setInfo('reconnection_time', $state->reconnectionTime);\n                $isTimeout = false;\n            }\n            $lastError = $state->lastError;\n            $state->lastError = null;\n\n            try {\n                $isTimeout = $chunk->isTimeout();\n\n                if (null !== $chunk->getInformationalStatus() || $context->getInfo('canceled')) {\n                    yield $chunk;\n\n                    return;\n                }\n            } catch (TransportExceptionInterface) {\n                $state->lastError = $lastError ?? hrtime(true) / 1E9;\n\n                if (null === $state->buffer || ($isTimeout && hrtime(true) / 1E9 - $state->lastError < $state->reconnectionTime)) {\n                    yield $chunk;\n                } else {\n                    $options['headers']['Last-Event-ID'] = $state->lastEventId;\n                    $state->buffer = '';\n                    $state->lastError = hrtime(true) / 1E9;\n                    $context->getResponse()->cancel();\n                    $context->replaceRequest($method, $url, $options);\n                    if ($isTimeout) {\n                        yield $chunk;\n                    } else {\n                        $context->pause($state->reconnectionTime);\n                    }\n                }\n\n                return;\n            }\n\n            if ($chunk->isFirst()) {\n                if (preg_match('/^text\\/event-stream(;|$)/i', $context->getHeaders()['content-type'][0] ?? '')) {\n                    $state->buffer = '';\n                } elseif (null !== $lastError || (null !== $state->buffer && 200 === $context->getStatusCode())) {\n                    throw new EventSourceException(\\sprintf('Response content-type is \"%s\" while \"text/event-stream\" was expected for \"%s\".', $context->getHeaders()['content-type'][0] ?? '', $context->getInfo('url')));\n                } else {\n                    $context->passthru();\n                }\n\n                if (null === $lastError) {\n                    yield $chunk;\n                }\n\n                return;\n            }\n\n            if ($chunk->isLast()) {\n                if ('' !== $content = $state->buffer) {\n                    $state->buffer = '';\n                    yield new DataChunk(-1, $content);\n                }\n\n                yield $chunk;\n\n                return;\n            }\n\n            $content = $state->buffer.$chunk->getContent();\n            $events = preg_split('/((?:\\r\\n){2,}|\\r{2,}|\\n{2,})/', $content, -1, \\PREG_SPLIT_DELIM_CAPTURE);\n            $state->buffer = array_pop($events);\n\n            for ($i = 0; isset($events[$i]); $i += 2) {\n                $content = $events[$i].$events[1 + $i];\n                if (!preg_match('/(?:^|\\r\\n|[\\r\\n])[^:\\r\\n]/', $content)) {\n                    yield new DataChunk(-1, $content);\n\n                    continue;\n                }\n\n                $event = new ServerSentEvent($content);\n\n                if ('' !== $event->getId()) {\n                    $context->setInfo('last_event_id', $state->lastEventId = $event->getId());\n                }\n\n                if ($event->getRetry()) {\n                    $context->setInfo('reconnection_time', $state->reconnectionTime = $event->getRetry());\n                }\n\n                yield $event;\n            }\n        });\n    }\n}\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "HttpClient.php",
          "type": "blob",
          "size": 3.400390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Amp\\Http\\Client\\Request as AmpRequest;\nuse Amp\\Http\\HttpMessage;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\n/**\n * A factory to instantiate the best possible HTTP client for the runtime.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class HttpClient\n{\n    /**\n     * @param array $defaultOptions     Default request's options\n     * @param int   $maxHostConnections The maximum number of connections to a single host\n     * @param int   $maxPendingPushes   The maximum number of pushed responses to accept in the queue\n     *\n     * @see HttpClientInterface::OPTIONS_DEFAULTS for available options\n     */\n    public static function create(array $defaultOptions = [], int $maxHostConnections = 6, int $maxPendingPushes = 50): HttpClientInterface\n    {\n        if ($amp = class_exists(AmpRequest::class) && (\\PHP_VERSION_ID >= 80400 || !is_subclass_of(AmpRequest::class, HttpMessage::class))) {\n            if (!\\extension_loaded('curl')) {\n                return new AmpHttpClient($defaultOptions, null, $maxHostConnections, $maxPendingPushes);\n            }\n\n            // Skip curl when HTTP/2 push is unsupported or buggy, see https://bugs.php.net/77535\n            if (!\\defined('CURLMOPT_PUSHFUNCTION')) {\n                return new AmpHttpClient($defaultOptions, null, $maxHostConnections, $maxPendingPushes);\n            }\n\n            static $curlVersion = null;\n            $curlVersion ??= curl_version();\n\n            // HTTP/2 push crashes before curl 7.61\n            if (0x073D00 > $curlVersion['version_number'] || !(\\CURL_VERSION_HTTP2 & $curlVersion['features'])) {\n                return new AmpHttpClient($defaultOptions, null, $maxHostConnections, $maxPendingPushes);\n            }\n        }\n\n        if (\\extension_loaded('curl')) {\n            if ('\\\\' !== \\DIRECTORY_SEPARATOR || isset($defaultOptions['cafile']) || isset($defaultOptions['capath']) || \\ini_get('curl.cainfo') || \\ini_get('openssl.cafile') || \\ini_get('openssl.capath')) {\n                return new CurlHttpClient($defaultOptions, $maxHostConnections, $maxPendingPushes);\n            }\n\n            @trigger_error('Configure the \"curl.cainfo\", \"openssl.cafile\" or \"openssl.capath\" php.ini setting to enable the CurlHttpClient', \\E_USER_WARNING);\n        }\n\n        if ($amp) {\n            return new AmpHttpClient($defaultOptions, null, $maxHostConnections, $maxPendingPushes);\n        }\n\n        @trigger_error((\\extension_loaded('curl') ? 'Upgrade' : 'Install').' the curl extension or run \"composer require amphp/http-client:^4.2.1\" to perform async HTTP operations, including full HTTP/2 support', \\E_USER_NOTICE);\n\n        return new NativeHttpClient($defaultOptions, $maxHostConnections);\n    }\n\n    /**\n     * Creates a client that adds options (e.g. authentication headers) only when the request URL matches the provided base URI.\n     */\n    public static function createForBaseUri(string $baseUri, array $defaultOptions = [], int $maxHostConnections = 6, int $maxPendingPushes = 50): HttpClientInterface\n    {\n        $client = self::create([], $maxHostConnections, $maxPendingPushes);\n\n        return ScopingHttpClient::forBaseUri($client, $baseUri, $defaultOptions);\n    }\n}\n"
        },
        {
          "name": "HttpClientTrait.php",
          "type": "blob",
          "size": 34.57421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Symfony\\Component\\HttpClient\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\HttpClient\\Exception\\TransportException;\nuse Symfony\\Component\\HttpClient\\Response\\StreamableInterface;\nuse Symfony\\Component\\HttpClient\\Response\\StreamWrapper;\nuse Symfony\\Component\\Mime\\MimeTypes;\n\n/**\n * Provides the common logic from writing HttpClientInterface implementations.\n *\n * All private methods are static to prevent implementers from creating memory leaks via circular references.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\ntrait HttpClientTrait\n{\n    private static int $CHUNK_SIZE = 16372;\n\n    public function withOptions(array $options): static\n    {\n        $clone = clone $this;\n        $clone->defaultOptions = self::mergeDefaultOptions($options, $this->defaultOptions);\n\n        return $clone;\n    }\n\n    /**\n     * Validates and normalizes method, URL and options, and merges them with defaults.\n     *\n     * @throws InvalidArgumentException When a not-supported option is found\n     */\n    private static function prepareRequest(?string $method, ?string $url, array $options, array $defaultOptions = [], bool $allowExtraOptions = false): array\n    {\n        if (null !== $method) {\n            if (\\strlen($method) !== strspn($method, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')) {\n                throw new InvalidArgumentException(\\sprintf('Invalid HTTP method \"%s\", only uppercase letters are accepted.', $method));\n            }\n            if (!$method) {\n                throw new InvalidArgumentException('The HTTP method cannot be empty.');\n            }\n        }\n\n        $options = self::mergeDefaultOptions($options, $defaultOptions, $allowExtraOptions);\n\n        $buffer = $options['buffer'] ?? true;\n\n        if ($buffer instanceof \\Closure) {\n            $options['buffer'] = static function (array $headers) use ($buffer) {\n                if (!\\is_bool($buffer = $buffer($headers))) {\n                    if (!\\is_array($bufferInfo = @stream_get_meta_data($buffer))) {\n                        throw new \\LogicException(\\sprintf('The closure passed as option \"buffer\" must return bool or stream resource, got \"%s\".', get_debug_type($buffer)));\n                    }\n\n                    if (false === strpbrk($bufferInfo['mode'], 'acew+')) {\n                        throw new \\LogicException(\\sprintf('The stream returned by the closure passed as option \"buffer\" must be writeable, got mode \"%s\".', $bufferInfo['mode']));\n                    }\n                }\n\n                return $buffer;\n            };\n        } elseif (!\\is_bool($buffer)) {\n            if (!\\is_array($bufferInfo = @stream_get_meta_data($buffer))) {\n                throw new InvalidArgumentException(\\sprintf('Option \"buffer\" must be bool, stream resource or Closure, \"%s\" given.', get_debug_type($buffer)));\n            }\n\n            if (false === strpbrk($bufferInfo['mode'], 'acew+')) {\n                throw new InvalidArgumentException(\\sprintf('The stream in option \"buffer\" must be writeable, mode \"%s\" given.', $bufferInfo['mode']));\n            }\n        }\n\n        if (isset($options['json'])) {\n            if (isset($options['body']) && '' !== $options['body']) {\n                throw new InvalidArgumentException('Define either the \"json\" or the \"body\" option, setting both is not supported.');\n            }\n            $options['body'] = self::jsonEncode($options['json']);\n            unset($options['json']);\n\n            if (!isset($options['normalized_headers']['content-type'])) {\n                $options['normalized_headers']['content-type'] = ['Content-Type: application/json'];\n            }\n        }\n\n        if (!isset($options['normalized_headers']['accept'])) {\n            $options['normalized_headers']['accept'] = ['Accept: */*'];\n        }\n\n        if (isset($options['body'])) {\n            $options['body'] = self::normalizeBody($options['body'], $options['normalized_headers']);\n\n            if (\\is_string($options['body'])\n                && (string) \\strlen($options['body']) !== substr($h = $options['normalized_headers']['content-length'][0] ?? '', 16)\n                && ('' !== $h || '' !== $options['body'])\n            ) {\n                if ('chunked' === substr($options['normalized_headers']['transfer-encoding'][0] ?? '', \\strlen('Transfer-Encoding: '))) {\n                    unset($options['normalized_headers']['transfer-encoding']);\n                    $options['body'] = self::dechunk($options['body']);\n                }\n\n                $options['normalized_headers']['content-length'] = [substr_replace($h ?: 'Content-Length: ', \\strlen($options['body']), 16)];\n            }\n        }\n\n        if (isset($options['peer_fingerprint'])) {\n            $options['peer_fingerprint'] = self::normalizePeerFingerprint($options['peer_fingerprint']);\n        }\n\n        if (isset($options['crypto_method']) && !\\in_array($options['crypto_method'], [\n            \\STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT,\n            \\STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT,\n            \\STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT,\n            \\STREAM_CRYPTO_METHOD_TLSv1_3_CLIENT,\n        ], true)) {\n            throw new InvalidArgumentException('Option \"crypto_method\" must be one of \"STREAM_CRYPTO_METHOD_TLSv1_*_CLIENT\".');\n        }\n\n        // Validate on_progress\n        if (isset($options['on_progress']) && !\\is_callable($onProgress = $options['on_progress'])) {\n            throw new InvalidArgumentException(\\sprintf('Option \"on_progress\" must be callable, \"%s\" given.', get_debug_type($onProgress)));\n        }\n\n        if (\\is_array($options['auth_basic'] ?? null)) {\n            $count = \\count($options['auth_basic']);\n            if ($count <= 0 || $count > 2) {\n                throw new InvalidArgumentException(\\sprintf('Option \"auth_basic\" must contain 1 or 2 elements, \"%s\" given.', $count));\n            }\n\n            $options['auth_basic'] = implode(':', $options['auth_basic']);\n        }\n\n        if (!\\is_string($options['auth_basic'] ?? '')) {\n            throw new InvalidArgumentException(\\sprintf('Option \"auth_basic\" must be string or an array, \"%s\" given.', get_debug_type($options['auth_basic'])));\n        }\n\n        if (isset($options['auth_bearer'])) {\n            if (!\\is_string($options['auth_bearer'])) {\n                throw new InvalidArgumentException(\\sprintf('Option \"auth_bearer\" must be a string, \"%s\" given.', get_debug_type($options['auth_bearer'])));\n            }\n            if (preg_match('{[^\\x21-\\x7E]}', $options['auth_bearer'])) {\n                throw new InvalidArgumentException('Invalid character found in option \"auth_bearer\": '.json_encode($options['auth_bearer']).'.');\n            }\n        }\n\n        if (isset($options['auth_basic'], $options['auth_bearer'])) {\n            throw new InvalidArgumentException('Define either the \"auth_basic\" or the \"auth_bearer\" option, setting both is not supported.');\n        }\n\n        if (null !== $url) {\n            // Merge auth with headers\n            if (($options['auth_basic'] ?? false) && !($options['normalized_headers']['authorization'] ?? false)) {\n                $options['normalized_headers']['authorization'] = ['Authorization: Basic '.base64_encode($options['auth_basic'])];\n            }\n            // Merge bearer with headers\n            if (($options['auth_bearer'] ?? false) && !($options['normalized_headers']['authorization'] ?? false)) {\n                $options['normalized_headers']['authorization'] = ['Authorization: Bearer '.$options['auth_bearer']];\n            }\n\n            unset($options['auth_basic'], $options['auth_bearer']);\n\n            // Parse base URI\n            if (\\is_string($options['base_uri'])) {\n                $options['base_uri'] = self::parseUrl($options['base_uri']);\n            }\n\n            // Validate and resolve URL\n            $url = self::parseUrl($url, $options['query']);\n            $url = self::resolveUrl($url, $options['base_uri'], $defaultOptions['query'] ?? []);\n        }\n\n        // Finalize normalization of options\n        $options['http_version'] = (string) ($options['http_version'] ?? '') ?: null;\n        if (0 > $options['timeout'] = (float) ($options['timeout'] ?? \\ini_get('default_socket_timeout'))) {\n            $options['timeout'] = 172800.0; // 2 days\n        }\n\n        $options['max_duration'] = isset($options['max_duration']) ? (float) $options['max_duration'] : 0;\n        $options['headers'] = array_merge(...array_values($options['normalized_headers']));\n\n        return [$url, $options];\n    }\n\n    /**\n     * @throws InvalidArgumentException When an invalid option is found\n     */\n    private static function mergeDefaultOptions(array $options, array $defaultOptions, bool $allowExtraOptions = false): array\n    {\n        $options['normalized_headers'] = self::normalizeHeaders($options['headers'] ?? []);\n\n        if ($defaultOptions['headers'] ?? false) {\n            $options['normalized_headers'] += self::normalizeHeaders($defaultOptions['headers']);\n        }\n\n        $options['headers'] = array_merge(...array_values($options['normalized_headers']) ?: [[]]);\n\n        if ($resolve = $options['resolve'] ?? false) {\n            $options['resolve'] = [];\n            foreach ($resolve as $k => $v) {\n                if ('' === $v = (string) $v) {\n                    $v = null;\n                } elseif ('[' === $v[0] && ']' === substr($v, -1) && str_contains($v, ':')) {\n                    $v = substr($v, 1, -1);\n                }\n\n                $options['resolve'][substr(self::parseUrl('http://'.$k)['authority'], 2)] = $v;\n            }\n        }\n\n        // Option \"query\" is never inherited from defaults\n        $options['query'] ??= [];\n\n        $options += $defaultOptions;\n\n        if (isset(self::$emptyDefaults)) {\n            foreach (self::$emptyDefaults as $k => $v) {\n                if (!isset($options[$k])) {\n                    $options[$k] = $v;\n                }\n            }\n        }\n\n        if (isset($defaultOptions['extra'])) {\n            $options['extra'] += $defaultOptions['extra'];\n        }\n\n        if ($resolve = $defaultOptions['resolve'] ?? false) {\n            foreach ($resolve as $k => $v) {\n                if ('' === $v = (string) $v) {\n                    $v = null;\n                } elseif ('[' === $v[0] && ']' === substr($v, -1) && str_contains($v, ':')) {\n                    $v = substr($v, 1, -1);\n                }\n\n                $options['resolve'] += [substr(self::parseUrl('http://'.$k)['authority'], 2) => $v];\n            }\n        }\n\n        if ($allowExtraOptions || !$defaultOptions) {\n            return $options;\n        }\n\n        // Look for unsupported options\n        foreach ($options as $name => $v) {\n            if (\\array_key_exists($name, $defaultOptions) || 'normalized_headers' === $name) {\n                continue;\n            }\n\n            if ('auth_ntlm' === $name) {\n                if (!\\extension_loaded('curl')) {\n                    $msg = 'try installing the \"curl\" extension to use \"%s\" instead.';\n                } else {\n                    $msg = 'try using \"%s\" instead.';\n                }\n\n                throw new InvalidArgumentException(\\sprintf('Option \"auth_ntlm\" is not supported by \"%s\", '.$msg, __CLASS__, CurlHttpClient::class));\n            }\n\n            if ('vars' === $name) {\n                throw new InvalidArgumentException(\\sprintf('Option \"vars\" is not supported by \"%s\", try using \"%s\" instead.', __CLASS__, UriTemplateHttpClient::class));\n            }\n\n            $alternatives = [];\n\n            foreach ($defaultOptions as $k => $v) {\n                if (levenshtein($name, $k) <= \\strlen($name) / 3 || str_contains($k, $name)) {\n                    $alternatives[] = $k;\n                }\n            }\n\n            throw new InvalidArgumentException(\\sprintf('Unsupported option \"%s\" passed to \"%s\", did you mean \"%s\"?', $name, __CLASS__, implode('\", \"', $alternatives ?: array_keys($defaultOptions))));\n        }\n\n        return $options;\n    }\n\n    /**\n     * @return string[][]\n     *\n     * @throws InvalidArgumentException When an invalid header is found\n     */\n    private static function normalizeHeaders(array $headers): array\n    {\n        $normalizedHeaders = [];\n\n        foreach ($headers as $name => $values) {\n            if ($values instanceof \\Stringable) {\n                $values = (string) $values;\n            }\n\n            if (\\is_int($name)) {\n                if (!\\is_string($values)) {\n                    throw new InvalidArgumentException(\\sprintf('Invalid value for header \"%s\": expected string, \"%s\" given.', $name, get_debug_type($values)));\n                }\n                [$name, $values] = explode(':', $values, 2);\n                $values = [ltrim($values)];\n            } elseif (!is_iterable($values)) {\n                if (\\is_object($values)) {\n                    throw new InvalidArgumentException(\\sprintf('Invalid value for header \"%s\": expected string, \"%s\" given.', $name, get_debug_type($values)));\n                }\n\n                $values = (array) $values;\n            }\n\n            $lcName = strtolower($name);\n            $normalizedHeaders[$lcName] = [];\n\n            foreach ($values as $value) {\n                $normalizedHeaders[$lcName][] = $value = $name.': '.$value;\n\n                if (\\strlen($value) !== strcspn($value, \"\\r\\n\\0\")) {\n                    throw new InvalidArgumentException(\\sprintf('Invalid header: CR/LF/NUL found in \"%s\".', $value));\n                }\n            }\n        }\n\n        return $normalizedHeaders;\n    }\n\n    /**\n     * @param array|string|resource|\\Traversable|\\Closure $body\n     *\n     * @return string|resource|\\Closure\n     *\n     * @throws InvalidArgumentException When an invalid body is passed\n     */\n    private static function normalizeBody($body, array &$normalizedHeaders = [])\n    {\n        if (\\is_array($body)) {\n            static $cookie;\n\n            $streams = [];\n            array_walk_recursive($body, $caster = static function (&$v) use (&$caster, &$streams, &$cookie) {\n                if (\\is_resource($v) || $v instanceof StreamableInterface) {\n                    $cookie = hash('xxh128', $cookie ??= random_bytes(8), true);\n                    $k = substr(strtr(base64_encode($cookie), '+/', '-_'), 0, -2);\n                    $streams[$k] = $v instanceof StreamableInterface ? $v->toStream(false) : $v;\n                    $v = $k;\n                } elseif (\\is_object($v)) {\n                    if ($vars = get_object_vars($v)) {\n                        array_walk_recursive($vars, $caster);\n                        $v = $vars;\n                    } elseif ($v instanceof \\Stringable) {\n                        $v = (string) $v;\n                    }\n                }\n            });\n\n            $body = http_build_query($body, '', '&');\n\n            if ('' === $body || !$streams && !str_contains($normalizedHeaders['content-type'][0] ?? '', 'multipart/form-data')) {\n                if (!str_contains($normalizedHeaders['content-type'][0] ?? '', 'application/x-www-form-urlencoded')) {\n                    $normalizedHeaders['content-type'] = ['Content-Type: application/x-www-form-urlencoded'];\n                }\n\n                return $body;\n            }\n\n            if (preg_match('{multipart/form-data; boundary=(?|\"([^\"\\r\\n]++)\"|([-!#$%&\\'*+.^_`|~_A-Za-z0-9]++))}', $normalizedHeaders['content-type'][0] ?? '', $boundary)) {\n                $boundary = $boundary[1];\n            } else {\n                $boundary = substr(strtr(base64_encode($cookie ??= random_bytes(8)), '+/', '-_'), 0, -2);\n                $normalizedHeaders['content-type'] = ['Content-Type: multipart/form-data; boundary='.$boundary];\n            }\n\n            $body = explode('&', $body);\n            $contentLength = 0;\n\n            foreach ($body as $i => $part) {\n                [$k, $v] = explode('=', $part, 2);\n                $part = ($i ? \"\\r\\n\" : '').\"--{$boundary}\\r\\n\";\n                $k = str_replace(['\"', \"\\r\", \"\\n\"], ['%22', '%0D', '%0A'], urldecode($k)); // see WHATWG HTML living standard\n\n                if (!isset($streams[$v])) {\n                    $part .= \"Content-Disposition: form-data; name=\\\"{$k}\\\"\\r\\n\\r\\n\".urldecode($v);\n                    $contentLength += 0 <= $contentLength ? \\strlen($part) : 0;\n                    $body[$i] = [$k, $part, null];\n                    continue;\n                }\n                $v = $streams[$v];\n\n                if (!\\is_array($m = @stream_get_meta_data($v))) {\n                    throw new TransportException(\\sprintf('Invalid \"%s\" resource found in body part \"%s\".', get_resource_type($v), $k));\n                }\n                if (feof($v)) {\n                    throw new TransportException(\\sprintf('Uploaded stream ended for body part \"%s\".', $k));\n                }\n\n                $m += stream_context_get_options($v)['http'] ?? [];\n                $filename = basename($m['filename'] ?? $m['uri'] ?? 'unknown');\n                $filename = str_replace(['\"', \"\\r\", \"\\n\"], ['%22', '%0D', '%0A'], $filename);\n                $contentType = $m['content_type'] ?? null;\n\n                if (($headers = $m['wrapper_data'] ?? []) instanceof StreamWrapper) {\n                    $hasContentLength = false;\n                    $headers = $headers->getResponse()->getInfo('response_headers');\n                } elseif ($hasContentLength = 0 < $h = fstat($v)['size'] ?? 0) {\n                    $contentLength += 0 <= $contentLength ? $h : 0;\n                }\n\n                foreach (\\is_array($headers) ? $headers : [] as $h) {\n                    if (\\is_string($h) && 0 === stripos($h, 'Content-Type: ')) {\n                        $contentType ??= substr($h, 14);\n                    } elseif (!$hasContentLength && \\is_string($h) && 0 === stripos($h, 'Content-Length: ')) {\n                        $hasContentLength = true;\n                        $contentLength += 0 <= $contentLength ? substr($h, 16) : 0;\n                    } elseif (\\is_string($h) && 0 === stripos($h, 'Content-Encoding: ')) {\n                        $contentLength = -1;\n                    }\n                }\n\n                if (!$hasContentLength) {\n                    $contentLength = -1;\n                }\n                if (null === $contentType && 'plainfile' === ($m['wrapper_type'] ?? null) && isset($m['uri'])) {\n                    $mimeTypes = class_exists(MimeTypes::class) ? MimeTypes::getDefault() : false;\n                    $contentType = $mimeTypes ? $mimeTypes->guessMimeType($m['uri']) : null;\n                }\n                $contentType ??= 'application/octet-stream';\n\n                $part .= \"Content-Disposition: form-data; name=\\\"{$k}\\\"; filename=\\\"{$filename}\\\"\\r\\n\";\n                $part .= \"Content-Type: {$contentType}\\r\\n\\r\\n\";\n\n                $contentLength += 0 <= $contentLength ? \\strlen($part) : 0;\n                $body[$i] = [$k, $part, $v];\n            }\n\n            $body[++$i] = ['', \"\\r\\n--{$boundary}--\\r\\n\", null];\n\n            if (0 < $contentLength) {\n                $normalizedHeaders['content-length'] = ['Content-Length: '.($contentLength += \\strlen($body[$i][1]))];\n            }\n\n            $body = static function ($size) use ($body) {\n                foreach ($body as $i => [$k, $part, $h]) {\n                    unset($body[$i]);\n\n                    yield $part;\n\n                    while (null !== $h && !feof($h)) {\n                        if (false === $part = fread($h, $size)) {\n                            throw new TransportException(\\sprintf('Error while reading uploaded stream for body part \"%s\".', $k));\n                        }\n\n                        yield $part;\n                    }\n                }\n                $h = null;\n            };\n        }\n\n        if (\\is_string($body)) {\n            return $body;\n        }\n\n        $generatorToCallable = static fn (\\Generator $body): \\Closure => static function () use ($body) {\n            while ($body->valid()) {\n                $chunk = $body->current();\n                $body->next();\n\n                if ('' !== $chunk) {\n                    return $chunk;\n                }\n            }\n\n            return '';\n        };\n\n        if ($body instanceof \\Generator) {\n            return $generatorToCallable($body);\n        }\n\n        if ($body instanceof \\Traversable) {\n            return $generatorToCallable((static function ($body) { yield from $body; })($body));\n        }\n\n        if ($body instanceof \\Closure) {\n            $r = new \\ReflectionFunction($body);\n            $body = $r->getClosure();\n\n            if ($r->isGenerator()) {\n                $body = $body(self::$CHUNK_SIZE);\n\n                return $generatorToCallable($body);\n            }\n\n            return $body;\n        }\n\n        if (!\\is_array(@stream_get_meta_data($body))) {\n            throw new InvalidArgumentException(\\sprintf('Option \"body\" must be string, stream resource, iterable or callable, \"%s\" given.', get_debug_type($body)));\n        }\n\n        return $body;\n    }\n\n    private static function dechunk(string $body): string\n    {\n        $h = fopen('php://temp', 'w+');\n        stream_filter_append($h, 'dechunk', \\STREAM_FILTER_WRITE);\n        fwrite($h, $body);\n        $body = stream_get_contents($h, -1, 0);\n        rewind($h);\n        ftruncate($h, 0);\n\n        if (fwrite($h, '-') && '' !== stream_get_contents($h, -1, 0)) {\n            throw new TransportException('Request body has broken chunked encoding.');\n        }\n\n        return $body;\n    }\n\n    /**\n     * @throws InvalidArgumentException When an invalid fingerprint is passed\n     */\n    private static function normalizePeerFingerprint(mixed $fingerprint): array\n    {\n        if (\\is_string($fingerprint)) {\n            $fingerprint = match (\\strlen($fingerprint = str_replace(':', '', $fingerprint))) {\n                32 => ['md5' => $fingerprint],\n                40 => ['sha1' => $fingerprint],\n                44 => ['pin-sha256' => [$fingerprint]],\n                64 => ['sha256' => $fingerprint],\n                default => throw new InvalidArgumentException(\\sprintf('Cannot auto-detect fingerprint algorithm for \"%s\".', $fingerprint)),\n            };\n        } elseif (\\is_array($fingerprint)) {\n            foreach ($fingerprint as $algo => $hash) {\n                $fingerprint[$algo] = 'pin-sha256' === $algo ? (array) $hash : str_replace(':', '', $hash);\n            }\n        } else {\n            throw new InvalidArgumentException(\\sprintf('Option \"peer_fingerprint\" must be string or array, \"%s\" given.', get_debug_type($fingerprint)));\n        }\n\n        return $fingerprint;\n    }\n\n    /**\n     * @throws InvalidArgumentException When the value cannot be json-encoded\n     */\n    private static function jsonEncode(mixed $value, ?int $flags = null, int $maxDepth = 512): string\n    {\n        $flags ??= \\JSON_HEX_TAG | \\JSON_HEX_APOS | \\JSON_HEX_AMP | \\JSON_HEX_QUOT | \\JSON_PRESERVE_ZERO_FRACTION;\n\n        try {\n            $value = json_encode($value, $flags | \\JSON_THROW_ON_ERROR, $maxDepth);\n        } catch (\\JsonException $e) {\n            throw new InvalidArgumentException('Invalid value for \"json\" option: '.$e->getMessage());\n        }\n\n        return $value;\n    }\n\n    /**\n     * Resolves a URL against a base URI.\n     *\n     * @see https://tools.ietf.org/html/rfc3986#section-5.2.2\n     *\n     * @throws InvalidArgumentException When an invalid URL is passed\n     */\n    private static function resolveUrl(array $url, ?array $base, array $queryDefaults = []): array\n    {\n        $givenUrl = $url;\n\n        if (null !== $base && '' === ($base['scheme'] ?? '').($base['authority'] ?? '')) {\n            throw new InvalidArgumentException(\\sprintf('Invalid \"base_uri\" option: host or scheme is missing in \"%s\".', implode('', $base)));\n        }\n\n        if (null === $url['scheme'] && (null === $base || null === $base['scheme'])) {\n            throw new InvalidArgumentException(\\sprintf('Invalid URL: scheme is missing in \"%s\". Did you forget to add \"http(s)://\"?', implode('', $base ?? $url)));\n        }\n\n        if (null === $base && '' === $url['scheme'].$url['authority']) {\n            throw new InvalidArgumentException(\\sprintf('Invalid URL: no \"base_uri\" option was provided and host or scheme is missing in \"%s\".', implode('', $url)));\n        }\n\n        if (null !== $url['scheme']) {\n            $url['path'] = self::removeDotSegments($url['path'] ?? '');\n        } else {\n            if (null !== $url['authority']) {\n                $url['path'] = self::removeDotSegments($url['path'] ?? '');\n            } else {\n                if (null === $url['path']) {\n                    $url['path'] = $base['path'];\n                    $url['query'] ??= $base['query'];\n                } else {\n                    if ('/' !== $url['path'][0]) {\n                        if (null === $base['path']) {\n                            $url['path'] = '/'.$url['path'];\n                        } else {\n                            $segments = explode('/', $base['path']);\n                            array_splice($segments, -1, 1, [$url['path']]);\n                            $url['path'] = implode('/', $segments);\n                        }\n                    }\n\n                    $url['path'] = self::removeDotSegments($url['path']);\n                }\n\n                $url['authority'] = $base['authority'];\n\n                if ($queryDefaults) {\n                    $url['query'] = '?'.self::mergeQueryString(substr($url['query'] ?? '', 1), $queryDefaults, false);\n                }\n            }\n\n            $url['scheme'] = $base['scheme'];\n        }\n\n        if ('' === ($url['path'] ?? '')) {\n            $url['path'] = '/';\n        }\n\n        if ('?' === ($url['query'] ?? '')) {\n            $url['query'] = null;\n        }\n\n        if (null !== $url['scheme'] && null === $url['authority']) {\n            throw new InvalidArgumentException(\\sprintf('Invalid URL: host is missing in \"%s\".', implode('', $givenUrl)));\n        }\n\n        return $url;\n    }\n\n    /**\n     * Parses a URL and fixes its encoding if needed.\n     *\n     * @throws InvalidArgumentException When an invalid URL is passed\n     */\n    private static function parseUrl(string $url, array $query = [], array $allowedSchemes = ['http' => 80, 'https' => 443]): array\n    {\n        if (false !== ($i = strpos($url, '\\\\')) && $i < strcspn($url, '?#')) {\n            throw new InvalidArgumentException(\\sprintf('Malformed URL \"%s\": backslashes are not allowed.', $url));\n        }\n        if (\\strlen($url) !== strcspn($url, \"\\r\\n\\t\")) {\n            throw new InvalidArgumentException(\\sprintf('Malformed URL \"%s\": CR/LF/TAB characters are not allowed.', $url));\n        }\n        if ('' !== $url && (\\ord($url[0]) <= 32 || \\ord($url[-1]) <= 32)) {\n            throw new InvalidArgumentException(\\sprintf('Malformed URL \"%s\": leading/trailing ASCII control characters or spaces are not allowed.', $url));\n        }\n\n        $tail = '';\n\n        if (false === $parts = parse_url(\\strlen($url) !== strcspn($url, '?#') ? $url : $url.$tail = '#')) {\n            throw new InvalidArgumentException(sprintf('Malformed URL \"%s\".', $url));\n        }\n\n        if ($query) {\n            $parts['query'] = self::mergeQueryString($parts['query'] ?? null, $query, true);\n        }\n\n        $scheme = $parts['scheme'] ?? null;\n        $host = $parts['host'] ?? null;\n\n        if (!$scheme && $host && !str_starts_with($url, '//')) {\n            $parts = parse_url(':/'.$url.$tail);\n            $parts['path'] = substr($parts['path'], 2);\n            $scheme = $host = null;\n        }\n\n        $port = $parts['port'] ?? 0;\n\n        if (null !== $scheme) {\n            if (!isset($allowedSchemes[$scheme = strtolower($scheme)])) {\n                throw new InvalidArgumentException(\\sprintf('Unsupported scheme in \"%s\": \"%s\" expected.', $url, implode('\" or \"', array_keys($allowedSchemes))));\n            }\n\n            $port = $allowedSchemes[$scheme] === $port ? 0 : $port;\n            $scheme .= ':';\n        }\n\n        if (null !== $host) {\n            if (!\\defined('INTL_IDNA_VARIANT_UTS46') && preg_match('/[\\x80-\\xFF]/', $host)) {\n                throw new InvalidArgumentException(\\sprintf('Unsupported IDN \"%s\", try enabling the \"intl\" PHP extension or running \"composer require symfony/polyfill-intl-idn\".', $host));\n            }\n\n            $host = \\defined('INTL_IDNA_VARIANT_UTS46') ? idn_to_ascii($host, \\IDNA_DEFAULT | \\IDNA_USE_STD3_RULES | \\IDNA_CHECK_BIDI | \\IDNA_CHECK_CONTEXTJ | \\IDNA_NONTRANSITIONAL_TO_ASCII, \\INTL_IDNA_VARIANT_UTS46) ?: strtolower($host) : strtolower($host);\n            $host .= $port ? ':'.$port : '';\n        }\n\n        foreach (['user', 'pass', 'path', 'query', 'fragment'] as $part) {\n            if (!isset($parts[$part])) {\n                continue;\n            }\n\n            if (str_contains($parts[$part], '%')) {\n                // https://tools.ietf.org/html/rfc3986#section-2.3\n                $parts[$part] = preg_replace_callback('/%(?:2[DE]|3[0-9]|[46][1-9A-F]|5F|[57][0-9A]|7E)++/i', fn ($m) => rawurldecode($m[0]), $parts[$part]);\n            }\n\n            // https://tools.ietf.org/html/rfc3986#section-3.3\n            $parts[$part] = preg_replace_callback(\"#[^-A-Za-z0-9._~!$&/'()[\\]*+,;=:@{}%]++#\", fn ($m) => rawurlencode($m[0]), $parts[$part]);\n        }\n\n        return [\n            'scheme' => $scheme,\n            'authority' => null !== $host ? '//'.(isset($parts['user']) ? $parts['user'].(isset($parts['pass']) ? ':'.$parts['pass'] : '').'@' : '').$host : null,\n            'path' => isset($parts['path'][0]) ? $parts['path'] : null,\n            'query' => isset($parts['query']) ? '?'.$parts['query'] : null,\n            'fragment' => isset($parts['fragment']) && !$tail ? '#'.$parts['fragment'] : null,\n        ];\n    }\n\n    /**\n     * Removes dot-segments from a path.\n     *\n     * @see https://tools.ietf.org/html/rfc3986#section-5.2.4\n     */\n    private static function removeDotSegments(string $path): string\n    {\n        $result = '';\n\n        while (!\\in_array($path, ['', '.', '..'], true)) {\n            if ('.' === $path[0] && (str_starts_with($path, $p = '../') || str_starts_with($path, $p = './'))) {\n                $path = substr($path, \\strlen($p));\n            } elseif ('/.' === $path || str_starts_with($path, '/./')) {\n                $path = substr_replace($path, '/', 0, 3);\n            } elseif ('/..' === $path || str_starts_with($path, '/../')) {\n                $i = strrpos($result, '/');\n                $result = $i ? substr($result, 0, $i) : '';\n                $path = substr_replace($path, '/', 0, 4);\n            } else {\n                $i = strpos($path, '/', 1) ?: \\strlen($path);\n                $result .= substr($path, 0, $i);\n                $path = substr($path, $i);\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Merges and encodes a query array with a query string.\n     *\n     * @throws InvalidArgumentException When an invalid query-string value is passed\n     */\n    private static function mergeQueryString(?string $queryString, array $queryArray, bool $replace): ?string\n    {\n        if (!$queryArray) {\n            return $queryString;\n        }\n\n        $query = [];\n\n        if (null !== $queryString) {\n            foreach (explode('&', $queryString) as $v) {\n                if ('' !== $v) {\n                    $k = urldecode(explode('=', $v, 2)[0]);\n                    $query[$k] = (isset($query[$k]) ? $query[$k].'&' : '').$v;\n                }\n            }\n        }\n\n        if ($replace) {\n            foreach ($queryArray as $k => $v) {\n                if (null === $v) {\n                    unset($query[$k]);\n                }\n            }\n        }\n\n        $queryString = http_build_query($queryArray, '', '&', \\PHP_QUERY_RFC3986);\n        $queryArray = [];\n\n        if ($queryString) {\n            if (str_contains($queryString, '%')) {\n                // https://tools.ietf.org/html/rfc3986#section-2.3 + some chars not encoded by browsers\n                $queryString = strtr($queryString, [\n                    '%21' => '!',\n                    '%24' => '$',\n                    '%28' => '(',\n                    '%29' => ')',\n                    '%2A' => '*',\n                    '%2F' => '/',\n                    '%3A' => ':',\n                    '%3B' => ';',\n                    '%40' => '@',\n                    '%5B' => '[',\n                    '%5D' => ']',\n                ]);\n            }\n\n            foreach (explode('&', $queryString) as $v) {\n                $queryArray[rawurldecode(explode('=', $v, 2)[0])] = $v;\n            }\n        }\n\n        return implode('&', $replace ? array_replace($query, $queryArray) : ($query + $queryArray));\n    }\n\n    /**\n     * Loads proxy configuration from the same environment variables as curl when no proxy is explicitly set.\n     */\n    private static function getProxy(?string $proxy, array $url, ?string $noProxy): ?array\n    {\n        if (null === $proxy = self::getProxyUrl($proxy, $url)) {\n            return null;\n        }\n\n        $proxy = (parse_url($proxy) ?: []) + ['scheme' => 'http'];\n\n        if (!isset($proxy['host'])) {\n            throw new TransportException('Invalid HTTP proxy: host is missing.');\n        }\n\n        if ('http' === $proxy['scheme']) {\n            $proxyUrl = 'tcp://'.$proxy['host'].':'.($proxy['port'] ?? '80');\n        } elseif ('https' === $proxy['scheme']) {\n            $proxyUrl = 'ssl://'.$proxy['host'].':'.($proxy['port'] ?? '443');\n        } else {\n            throw new TransportException(\\sprintf('Unsupported proxy scheme \"%s\": \"http\" or \"https\" expected.', $proxy['scheme']));\n        }\n\n        $noProxy ??= $_SERVER['no_proxy'] ?? $_SERVER['NO_PROXY'] ?? '';\n        $noProxy = $noProxy ? preg_split('/[\\s,]+/', $noProxy) : [];\n\n        return [\n            'url' => $proxyUrl,\n            'auth' => isset($proxy['user']) ? 'Basic '.base64_encode(rawurldecode($proxy['user']).':'.rawurldecode($proxy['pass'] ?? '')) : null,\n            'no_proxy' => $noProxy,\n        ];\n    }\n\n    private static function getProxyUrl(?string $proxy, array $url): ?string\n    {\n        if (null !== $proxy) {\n            return $proxy;\n        }\n\n        // Ignore HTTP_PROXY except on the CLI to work around httpoxy set of vulnerabilities\n        $proxy = $_SERVER['http_proxy'] ?? (\\in_array(\\PHP_SAPI, ['cli', 'phpdbg'], true) ? $_SERVER['HTTP_PROXY'] ?? null : null) ?? $_SERVER['all_proxy'] ?? $_SERVER['ALL_PROXY'] ?? null;\n\n        if ('https:' === $url['scheme']) {\n            $proxy = $_SERVER['https_proxy'] ?? $_SERVER['HTTPS_PROXY'] ?? $proxy;\n        }\n\n        return $proxy;\n    }\n\n    private static function shouldBuffer(array $headers): bool\n    {\n        if (null === $contentType = $headers['content-type'][0] ?? null) {\n            return false;\n        }\n\n        if (false !== $i = strpos($contentType, ';')) {\n            $contentType = substr($contentType, 0, $i);\n        }\n\n        return $contentType && preg_match('#^(?:text/|application/(?:.+\\+)?(?:json|xml)$)#i', $contentType);\n    }\n}\n"
        },
        {
          "name": "HttpOptions.php",
          "type": "blob",
          "size": 6.271484375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\n/**\n * A helper providing autocompletion for available options.\n *\n * @see HttpClientInterface for a description of each options.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass HttpOptions\n{\n    private array $options = [];\n\n    public function toArray(): array\n    {\n        return $this->options;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setAuthBasic(string $user, #[\\SensitiveParameter] string $password = ''): static\n    {\n        $this->options['auth_basic'] = $user;\n\n        if ('' !== $password) {\n            $this->options['auth_basic'] .= ':'.$password;\n        }\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setAuthBearer(#[\\SensitiveParameter] string $token): static\n    {\n        $this->options['auth_bearer'] = $token;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setQuery(array $query): static\n    {\n        $this->options['query'] = $query;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setHeader(string $key, string $value): static\n    {\n        $this->options['headers'][$key] = $value;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setHeaders(iterable $headers): static\n    {\n        $this->options['headers'] = $headers;\n\n        return $this;\n    }\n\n    /**\n     * @param array|string|resource|\\Traversable|\\Closure $body\n     *\n     * @return $this\n     */\n    public function setBody(mixed $body): static\n    {\n        $this->options['body'] = $body;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setJson(mixed $json): static\n    {\n        $this->options['json'] = $json;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setUserData(mixed $data): static\n    {\n        $this->options['user_data'] = $data;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setMaxRedirects(int $max): static\n    {\n        $this->options['max_redirects'] = $max;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setHttpVersion(string $version): static\n    {\n        $this->options['http_version'] = $version;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setBaseUri(string $uri): static\n    {\n        $this->options['base_uri'] = $uri;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setVars(array $vars): static\n    {\n        $this->options['vars'] = $vars;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function buffer(bool $buffer): static\n    {\n        $this->options['buffer'] = $buffer;\n\n        return $this;\n    }\n\n    /**\n     * @param callable(int, int, array, \\Closure|null=):void $callback\n     *\n     * @return $this\n     */\n    public function setOnProgress(callable $callback): static\n    {\n        $this->options['on_progress'] = $callback;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function resolve(array $hostIps): static\n    {\n        $this->options['resolve'] = $hostIps;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setProxy(string $proxy): static\n    {\n        $this->options['proxy'] = $proxy;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setNoProxy(string $noProxy): static\n    {\n        $this->options['no_proxy'] = $noProxy;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setTimeout(float $timeout): static\n    {\n        $this->options['timeout'] = $timeout;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setMaxDuration(float $maxDuration): static\n    {\n        $this->options['max_duration'] = $maxDuration;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function bindTo(string $bindto): static\n    {\n        $this->options['bindto'] = $bindto;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function verifyPeer(bool $verify): static\n    {\n        $this->options['verify_peer'] = $verify;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function verifyHost(bool $verify): static\n    {\n        $this->options['verify_host'] = $verify;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setCaFile(string $cafile): static\n    {\n        $this->options['cafile'] = $cafile;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setCaPath(string $capath): static\n    {\n        $this->options['capath'] = $capath;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setLocalCert(string $cert): static\n    {\n        $this->options['local_cert'] = $cert;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setLocalPk(string $pk): static\n    {\n        $this->options['local_pk'] = $pk;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setPassphrase(string $passphrase): static\n    {\n        $this->options['passphrase'] = $passphrase;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setCiphers(string $ciphers): static\n    {\n        $this->options['ciphers'] = $ciphers;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setPeerFingerprint(string|array $fingerprint): static\n    {\n        $this->options['peer_fingerprint'] = $fingerprint;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function capturePeerCertChain(bool $capture): static\n    {\n        $this->options['capture_peer_cert_chain'] = $capture;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setExtra(string $name, mixed $value): static\n    {\n        $this->options['extra'][$name] = $value;\n\n        return $this;\n    }\n}\n"
        },
        {
          "name": "HttplugClient.php",
          "type": "blob",
          "size": 9.5048828125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse GuzzleHttp\\Promise\\Promise as GuzzlePromise;\nuse GuzzleHttp\\Promise\\RejectedPromise;\nuse GuzzleHttp\\Promise\\Utils;\nuse Http\\Client\\Exception\\NetworkException;\nuse Http\\Client\\Exception\\RequestException;\nuse Http\\Client\\HttpAsyncClient;\nuse Http\\Discovery\\Psr17Factory;\nuse Http\\Discovery\\Psr17FactoryDiscovery;\nuse Nyholm\\Psr7\\Factory\\Psr17Factory as NyholmPsr17Factory;\nuse Nyholm\\Psr7\\Request;\nuse Nyholm\\Psr7\\Uri;\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestFactoryInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\ResponseInterface as Psr7ResponseInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Http\\Message\\StreamInterface;\nuse Psr\\Http\\Message\\UriFactoryInterface;\nuse Psr\\Http\\Message\\UriInterface;\nuse Symfony\\Component\\HttpClient\\Internal\\HttplugWaitLoop;\nuse Symfony\\Component\\HttpClient\\Response\\HttplugPromise;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\nif (!interface_exists(HttpAsyncClient::class)) {\n    throw new \\LogicException('You cannot use \"Symfony\\Component\\HttpClient\\HttplugClient\" as the \"php-http/httplug\" package is not installed. Try running \"composer require php-http/discovery php-http/async-client-implementation:*\".');\n}\n\nif (!interface_exists(RequestFactoryInterface::class)) {\n    throw new \\LogicException('You cannot use the \"Symfony\\Component\\HttpClient\\HttplugClient\" as the \"psr/http-factory\" package is not installed. Try running \"composer require php-http/discovery psr/http-factory-implementation:*\".');\n}\n\n/**\n * An adapter to turn a Symfony HttpClientInterface into an Httplug client.\n *\n * In comparison to Psr18Client, this client supports asynchronous requests.\n *\n * Run \"composer require php-http/discovery php-http/async-client-implementation:*\"\n * to get the required dependencies.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class HttplugClient implements ClientInterface, HttpAsyncClient, RequestFactoryInterface, StreamFactoryInterface, UriFactoryInterface, ResetInterface\n{\n    private HttpClientInterface $client;\n    private ResponseFactoryInterface $responseFactory;\n    private StreamFactoryInterface $streamFactory;\n\n    /**\n     * @var \\SplObjectStorage<ResponseInterface, array{RequestInterface, Promise}>|null\n     */\n    private ?\\SplObjectStorage $promisePool;\n\n    private HttplugWaitLoop $waitLoop;\n\n    public function __construct(?HttpClientInterface $client = null, ?ResponseFactoryInterface $responseFactory = null, ?StreamFactoryInterface $streamFactory = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n        $streamFactory ??= $responseFactory instanceof StreamFactoryInterface ? $responseFactory : null;\n        $this->promisePool = class_exists(Utils::class) ? new \\SplObjectStorage() : null;\n\n        if (null === $responseFactory || null === $streamFactory) {\n            if (class_exists(Psr17Factory::class)) {\n                $psr17Factory = new Psr17Factory();\n            } elseif (class_exists(NyholmPsr17Factory::class)) {\n                $psr17Factory = new NyholmPsr17Factory();\n            } else {\n                throw new \\LogicException('You cannot use the \"Symfony\\Component\\HttpClient\\HttplugClient\" as no PSR-17 factories have been provided. Try running \"composer require php-http/discovery psr/http-factory-implementation:*\".');\n            }\n\n            $responseFactory ??= $psr17Factory;\n            $streamFactory ??= $psr17Factory;\n        }\n\n        $this->responseFactory = $responseFactory;\n        $this->streamFactory = $streamFactory;\n        $this->waitLoop = new HttplugWaitLoop($this->client, $this->promisePool, $this->responseFactory, $this->streamFactory);\n    }\n\n    public function withOptions(array $options): static\n    {\n        $clone = clone $this;\n        $clone->client = $clone->client->withOptions($options);\n\n        return $clone;\n    }\n\n    public function sendRequest(RequestInterface $request): Psr7ResponseInterface\n    {\n        try {\n            return HttplugWaitLoop::createPsr7Response($this->responseFactory, $this->streamFactory, $this->client, $this->sendPsr7Request($request), true);\n        } catch (TransportExceptionInterface $e) {\n            throw new NetworkException($e->getMessage(), $request, $e);\n        }\n    }\n\n    public function sendAsyncRequest(RequestInterface $request): HttplugPromise\n    {\n        if (!$promisePool = $this->promisePool) {\n            throw new \\LogicException(\\sprintf('You cannot use \"%s()\" as the \"guzzlehttp/promises\" package is not installed. Try running \"composer require guzzlehttp/promises\".', __METHOD__));\n        }\n\n        try {\n            $response = $this->sendPsr7Request($request, true);\n        } catch (NetworkException $e) {\n            return new HttplugPromise(new RejectedPromise($e));\n        }\n\n        $waitLoop = $this->waitLoop;\n\n        $promise = new GuzzlePromise(static function () use ($response, $waitLoop) {\n            $waitLoop->wait($response);\n        }, static function () use ($response, $promisePool) {\n            $response->cancel();\n            unset($promisePool[$response]);\n        });\n\n        $promisePool[$response] = [$request, $promise];\n\n        return new HttplugPromise($promise);\n    }\n\n    /**\n     * Resolves pending promises that complete before the timeouts are reached.\n     *\n     * When $maxDuration is null and $idleTimeout is reached, promises are rejected.\n     *\n     * @return int The number of remaining pending promises\n     */\n    public function wait(?float $maxDuration = null, ?float $idleTimeout = null): int\n    {\n        return $this->waitLoop->wait(null, $maxDuration, $idleTimeout);\n    }\n\n    /**\n     * @param UriInterface|string $uri\n     */\n    public function createRequest(string $method, $uri = ''): RequestInterface\n    {\n        if ($this->responseFactory instanceof RequestFactoryInterface) {\n            $request = $this->responseFactory->createRequest($method, $uri);\n        } elseif (class_exists(Psr17FactoryDiscovery::class)) {\n            $request = Psr17FactoryDiscovery::findRequestFactory()->createRequest($method, $uri);\n        } elseif (class_exists(Request::class)) {\n            $request = new Request($method, $uri);\n        } else {\n            throw new \\LogicException(\\sprintf('You cannot use \"%s()\" as no PSR-17 factories have been found. Try running \"composer require php-http/discovery psr/http-factory-implementation:*\".', __METHOD__));\n        }\n\n        return $request;\n    }\n\n    public function createStream(string $content = ''): StreamInterface\n    {\n        return $this->streamFactory->createStream($content);\n    }\n\n    public function createStreamFromFile(string $filename, string $mode = 'r'): StreamInterface\n    {\n        return $this->streamFactory->createStreamFromFile($filename, $mode);\n    }\n\n    public function createStreamFromResource($resource): StreamInterface\n    {\n        return $this->streamFactory->createStreamFromResource($resource);\n    }\n\n    public function createUri(string $uri = ''): UriInterface\n    {\n        if ($this->responseFactory instanceof UriFactoryInterface) {\n            return $this->responseFactory->createUri($uri);\n        }\n\n        if (class_exists(Psr17FactoryDiscovery::class)) {\n            return Psr17FactoryDiscovery::findUriFactory()->createUri($uri);\n        }\n\n        if (class_exists(Uri::class)) {\n            return new Uri($uri);\n        }\n\n        throw new \\LogicException(\\sprintf('You cannot use \"%s()\" as no PSR-17 factories have been found. Try running \"composer require php-http/discovery psr/http-factory-implementation:*\".', __METHOD__));\n    }\n\n    public function __sleep(): array\n    {\n        throw new \\BadMethodCallException('Cannot serialize '.__CLASS__);\n    }\n\n    public function __wakeup(): void\n    {\n        throw new \\BadMethodCallException('Cannot unserialize '.__CLASS__);\n    }\n\n    public function __destruct()\n    {\n        $this->wait();\n    }\n\n    public function reset(): void\n    {\n        if ($this->client instanceof ResetInterface) {\n            $this->client->reset();\n        }\n    }\n\n    private function sendPsr7Request(RequestInterface $request, ?bool $buffer = null): ResponseInterface\n    {\n        try {\n            $body = $request->getBody();\n\n            if ($body->isSeekable()) {\n                $body->seek(0);\n            }\n\n            $headers = $request->getHeaders();\n            if (!$request->hasHeader('content-length') && 0 <= $size = $body->getSize() ?? -1) {\n                $headers['Content-Length'] = [$size];\n            }\n\n            $options = [\n                'headers' => $headers,\n                'body' => static fn (int $size) => $body->read($size),\n                'buffer' => $buffer,\n            ];\n\n            if ('1.0' === $request->getProtocolVersion()) {\n                $options['http_version'] = '1.0';\n            }\n\n            return $this->client->request($request->getMethod(), (string) $request->getUri(), $options);\n        } catch (\\InvalidArgumentException $e) {\n            throw new RequestException($e->getMessage(), $request, $e);\n        } catch (TransportExceptionInterface $e) {\n            throw new NetworkException($e->getMessage(), $request, $e);\n        }\n    }\n}\n"
        },
        {
          "name": "Internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2018-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Messenger",
          "type": "tree",
          "content": null
        },
        {
          "name": "MockHttpClient.php",
          "type": "blob",
          "size": 4.14453125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Symfony\\Component\\HttpClient\\Exception\\TransportException;\nuse Symfony\\Component\\HttpClient\\Response\\MockResponse;\nuse Symfony\\Component\\HttpClient\\Response\\ResponseStream;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseStreamInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * A test-friendly HttpClient that doesn't make actual HTTP requests.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass MockHttpClient implements HttpClientInterface, ResetInterface\n{\n    use HttpClientTrait;\n\n    private ResponseInterface|\\Closure|iterable|null $responseFactory;\n    private int $requestsCount = 0;\n    private array $defaultOptions = [];\n\n    /**\n     * @param callable|callable[]|ResponseInterface|ResponseInterface[]|iterable|null $responseFactory\n     */\n    public function __construct(callable|iterable|ResponseInterface|null $responseFactory = null, ?string $baseUri = 'https://example.com')\n    {\n        $this->setResponseFactory($responseFactory);\n        $this->defaultOptions['base_uri'] = $baseUri;\n    }\n\n    /**\n     * @param callable|callable[]|ResponseInterface|ResponseInterface[]|iterable|null $responseFactory\n     */\n    public function setResponseFactory($responseFactory): void\n    {\n        if ($responseFactory instanceof ResponseInterface) {\n            $responseFactory = [$responseFactory];\n        }\n\n        if (!$responseFactory instanceof \\Iterator && null !== $responseFactory && !\\is_callable($responseFactory)) {\n            $responseFactory = (static function () use ($responseFactory) {\n                yield from $responseFactory;\n            })();\n        }\n\n        $this->responseFactory = !\\is_callable($responseFactory) ? $responseFactory : $responseFactory(...);\n    }\n\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        [$url, $options] = $this->prepareRequest($method, $url, $options, $this->defaultOptions, true);\n        $url = implode('', $url);\n\n        if (null === $this->responseFactory) {\n            $response = new MockResponse();\n        } elseif (\\is_callable($this->responseFactory)) {\n            $response = ($this->responseFactory)($method, $url, $options);\n        } elseif (!$this->responseFactory->valid()) {\n            throw new TransportException($this->requestsCount ? 'No more response left in the response factory iterator passed to MockHttpClient: the number of requests exceeds the number of responses.' : 'The response factory iterator passed to MockHttpClient is empty.');\n        } else {\n            $responseFactory = $this->responseFactory->current();\n            $response = \\is_callable($responseFactory) ? $responseFactory($method, $url, $options) : $responseFactory;\n            $this->responseFactory->next();\n        }\n        ++$this->requestsCount;\n\n        if (!$response instanceof ResponseInterface) {\n            throw new TransportException(\\sprintf('The response factory passed to MockHttpClient must return/yield an instance of ResponseInterface, \"%s\" given.', get_debug_type($response)));\n        }\n\n        return MockResponse::fromRequest($method, $url, $options, $response);\n    }\n\n    public function stream(ResponseInterface|iterable $responses, ?float $timeout = null): ResponseStreamInterface\n    {\n        if ($responses instanceof ResponseInterface) {\n            $responses = [$responses];\n        }\n\n        return new ResponseStream(MockResponse::stream($responses, $timeout));\n    }\n\n    public function getRequestsCount(): int\n    {\n        return $this->requestsCount;\n    }\n\n    public function withOptions(array $options): static\n    {\n        $clone = clone $this;\n        $clone->defaultOptions = self::mergeDefaultOptions($options, $this->defaultOptions, true);\n\n        return $clone;\n    }\n\n    public function reset(): void\n    {\n        $this->requestsCount = 0;\n    }\n}\n"
        },
        {
          "name": "NativeHttpClient.php",
          "type": "blob",
          "size": 20.2705078125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\nuse Symfony\\Component\\HttpClient\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\HttpClient\\Exception\\TransportException;\nuse Symfony\\Component\\HttpClient\\Internal\\NativeClientState;\nuse Symfony\\Component\\HttpClient\\Response\\NativeResponse;\nuse Symfony\\Component\\HttpClient\\Response\\ResponseStream;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseStreamInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * A portable implementation of the HttpClientInterface contracts based on PHP stream wrappers.\n *\n * PHP stream wrappers are able to fetch response bodies concurrently,\n * but each request is opened synchronously.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class NativeHttpClient implements HttpClientInterface, LoggerAwareInterface, ResetInterface\n{\n    use HttpClientTrait;\n    use LoggerAwareTrait;\n\n    public const OPTIONS_DEFAULTS = HttpClientInterface::OPTIONS_DEFAULTS + [\n        'crypto_method' => \\STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT,\n    ];\n\n    private array $defaultOptions = self::OPTIONS_DEFAULTS;\n    private static array $emptyDefaults = self::OPTIONS_DEFAULTS;\n\n    private NativeClientState $multi;\n\n    /**\n     * @param array $defaultOptions     Default request's options\n     * @param int   $maxHostConnections The maximum number of connections to open\n     *\n     * @see HttpClientInterface::OPTIONS_DEFAULTS for available options\n     */\n    public function __construct(array $defaultOptions = [], int $maxHostConnections = 6)\n    {\n        $this->defaultOptions['buffer'] ??= self::shouldBuffer(...);\n\n        if ($defaultOptions) {\n            [, $this->defaultOptions] = self::prepareRequest(null, null, $defaultOptions, $this->defaultOptions);\n        }\n\n        $this->multi = new NativeClientState();\n        $this->multi->maxHostConnections = 0 < $maxHostConnections ? $maxHostConnections : \\PHP_INT_MAX;\n    }\n\n    /**\n     * @see HttpClientInterface::OPTIONS_DEFAULTS for available options\n     */\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        [$url, $options] = self::prepareRequest($method, $url, $options, $this->defaultOptions);\n\n        if ($options['bindto']) {\n            if (file_exists($options['bindto'])) {\n                throw new TransportException(__CLASS__.' cannot bind to local Unix sockets, use e.g. CurlHttpClient instead.');\n            }\n            if (str_starts_with($options['bindto'], 'if!')) {\n                throw new TransportException(__CLASS__.' cannot bind to network interfaces, use e.g. CurlHttpClient instead.');\n            }\n            if (str_starts_with($options['bindto'], 'host!')) {\n                $options['bindto'] = substr($options['bindto'], 5);\n            }\n            if ((\\PHP_VERSION_ID < 80223 || 80300 <= \\PHP_VERSION_ID && 80311 < \\PHP_VERSION_ID) && '\\\\' === \\DIRECTORY_SEPARATOR && '[' === $options['bindto'][0]) {\n                $options['bindto'] = preg_replace('{^\\[[^\\]]++\\]}', '[$0]', $options['bindto']);\n            }\n        }\n\n        $hasContentLength = isset($options['normalized_headers']['content-length']);\n        $hasBody = '' !== $options['body'] || 'POST' === $method || $hasContentLength;\n\n        $options['body'] = self::getBodyAsString($options['body']);\n\n        if ('chunked' === substr($options['normalized_headers']['transfer-encoding'][0] ?? '', \\strlen('Transfer-Encoding: '))) {\n            unset($options['normalized_headers']['transfer-encoding']);\n            $options['headers'] = array_merge(...array_values($options['normalized_headers']));\n            $options['body'] = self::dechunk($options['body']);\n        }\n        if ('' === $options['body'] && $hasBody && !$hasContentLength) {\n            $options['headers'][] = 'Content-Length: 0';\n        }\n        if ($hasBody && !isset($options['normalized_headers']['content-type'])) {\n            $options['headers'][] = 'Content-Type: application/x-www-form-urlencoded';\n        }\n\n        if (\\extension_loaded('zlib') && !isset($options['normalized_headers']['accept-encoding'])) {\n            // gzip is the most widely available algo, no need to deal with deflate\n            $options['headers'][] = 'Accept-Encoding: gzip';\n        }\n\n        if ($options['peer_fingerprint']) {\n            if (isset($options['peer_fingerprint']['pin-sha256']) && 1 === \\count($options['peer_fingerprint'])) {\n                throw new TransportException(__CLASS__.' cannot verify \"pin-sha256\" fingerprints, please provide a \"sha256\" one.');\n            }\n\n            unset($options['peer_fingerprint']['pin-sha256']);\n        }\n\n        $info = [\n            'response_headers' => [],\n            'url' => $url,\n            'error' => null,\n            'canceled' => false,\n            'http_method' => $method,\n            'http_code' => 0,\n            'redirect_count' => 0,\n            'start_time' => 0.0,\n            'connect_time' => 0.0,\n            'redirect_time' => 0.0,\n            'pretransfer_time' => 0.0,\n            'starttransfer_time' => 0.0,\n            'total_time' => 0.0,\n            'namelookup_time' => 0.0,\n            'size_upload' => 0,\n            'size_download' => 0,\n            'size_body' => \\strlen($options['body']),\n            'primary_ip' => '',\n            'primary_port' => 'http:' === $url['scheme'] ? 80 : 443,\n            'debug' => \\extension_loaded('curl') ? '' : \"* Enable the curl extension for better performance\\n\",\n        ];\n\n        if ($onProgress = $options['on_progress']) {\n            $maxDuration = 0 < $options['max_duration'] ? $options['max_duration'] : \\INF;\n            $onProgress = static function (...$progress) use ($onProgress, &$info, $maxDuration) {\n                if ($info['total_time'] >= $maxDuration) {\n                    throw new TransportException(\\sprintf('Max duration was reached for \"%s\".', implode('', $info['url'])));\n                }\n\n                $progressInfo = $info;\n                $progressInfo['url'] = implode('', $info['url']);\n                unset($progressInfo['size_body']);\n\n                // Memoize the last progress to ease calling the callback periodically when no network transfer happens\n                static $lastProgress = [0, 0];\n\n                if ($progress && -1 === $progress[0]) {\n                    // Response completed\n                    $lastProgress[0] = max($lastProgress);\n                } else {\n                    $lastProgress = $progress ?: $lastProgress;\n                }\n\n                $onProgress($lastProgress[0], $lastProgress[1], $progressInfo);\n            };\n        } elseif (0 < $options['max_duration']) {\n            $maxDuration = $options['max_duration'];\n            $onProgress = static function () use (&$info, $maxDuration): void {\n                if ($info['total_time'] >= $maxDuration) {\n                    throw new TransportException(\\sprintf('Max duration was reached for \"%s\".', implode('', $info['url'])));\n                }\n            };\n        }\n\n        // Always register a notification callback to compute live stats about the response\n        $notification = static function (int $code, int $severity, ?string $msg, int $msgCode, int $dlNow, int $dlSize) use ($onProgress, &$info) {\n            $info['total_time'] = microtime(true) - $info['start_time'];\n\n            if (\\STREAM_NOTIFY_PROGRESS === $code) {\n                $info['starttransfer_time'] = $info['starttransfer_time'] ?: $info['total_time'];\n                $info['size_upload'] += $dlNow ? 0 : $info['size_body'];\n                $info['size_download'] = $dlNow;\n            } elseif (\\STREAM_NOTIFY_CONNECT === $code) {\n                $info['connect_time'] = $info['total_time'];\n                $info['debug'] .= $info['request_header'];\n                unset($info['request_header']);\n            } else {\n                return;\n            }\n\n            if ($onProgress) {\n                $onProgress($dlNow, $dlSize);\n            }\n        };\n\n        if ($options['resolve']) {\n            $this->multi->dnsCache = $options['resolve'] + $this->multi->dnsCache;\n        }\n\n        $this->logger?->info(\\sprintf('Request: \"%s %s\"', $method, implode('', $url)));\n\n        if (!isset($options['normalized_headers']['user-agent'])) {\n            $options['headers'][] = 'User-Agent: Symfony HttpClient (Native)';\n        }\n\n        if (0 < $options['max_duration']) {\n            $options['timeout'] = min($options['max_duration'], $options['timeout']);\n        }\n\n        switch ($cryptoMethod = $options['crypto_method']) {\n            case \\STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT:\n                $cryptoMethod |= \\STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT;\n                // no break\n            case \\STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT:\n                $cryptoMethod |= \\STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT;\n                // no break\n            case \\STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT:\n                $cryptoMethod |= \\STREAM_CRYPTO_METHOD_TLSv1_3_CLIENT;\n        }\n\n        $context = [\n            'http' => [\n                'protocol_version' => min($options['http_version'] ?: '1.1', '1.1'),\n                'method' => $method,\n                'content' => $options['body'],\n                'ignore_errors' => true,\n                'curl_verify_ssl_peer' => $options['verify_peer'],\n                'curl_verify_ssl_host' => $options['verify_host'],\n                'auto_decode' => false, // Disable dechunk filter, it's incompatible with stream_select()\n                'timeout' => $options['timeout'],\n                'follow_location' => false, // We follow redirects ourselves - the native logic is too limited\n            ],\n            'ssl' => array_filter([\n                'verify_peer' => $options['verify_peer'],\n                'verify_peer_name' => $options['verify_host'],\n                'cafile' => $options['cafile'],\n                'capath' => $options['capath'],\n                'local_cert' => $options['local_cert'],\n                'local_pk' => $options['local_pk'],\n                'passphrase' => $options['passphrase'],\n                'ciphers' => $options['ciphers'],\n                'peer_fingerprint' => $options['peer_fingerprint'],\n                'capture_peer_cert_chain' => $options['capture_peer_cert_chain'],\n                'allow_self_signed' => (bool) $options['peer_fingerprint'],\n                'SNI_enabled' => true,\n                'disable_compression' => true,\n                'crypto_method' => $cryptoMethod,\n            ], static fn ($v) => null !== $v),\n            'socket' => [\n                'bindto' => $options['bindto'],\n                'tcp_nodelay' => true,\n            ],\n        ];\n\n        $context = stream_context_create($context, ['notification' => $notification]);\n\n        $resolver = static function ($multi) use ($context, $options, $url, &$info, $onProgress) {\n            $authority = $url['authority'];\n            [$host, $port] = self::parseHostPort($url, $info);\n\n            if (!isset($options['normalized_headers']['host'])) {\n                $options['headers'][] = 'Host: '.$host.$port;\n            }\n\n            $proxy = self::getProxy($options['proxy'], $url, $options['no_proxy']);\n\n            if (!self::configureHeadersAndProxy($context, $host, $options['headers'], $proxy, 'https:' === $url['scheme'])) {\n                $ip = self::dnsResolve($host, $multi, $info, $onProgress);\n                $url['authority'] = substr_replace($url['authority'], $ip, -\\strlen($host) - \\strlen($port), \\strlen($host));\n            }\n\n            return [self::createRedirectResolver($options, $authority, $proxy, $info, $onProgress), implode('', $url)];\n        };\n\n        return new NativeResponse($this->multi, $context, implode('', $url), $options, $info, $resolver, $onProgress, $this->logger);\n    }\n\n    public function stream(ResponseInterface|iterable $responses, ?float $timeout = null): ResponseStreamInterface\n    {\n        if ($responses instanceof NativeResponse) {\n            $responses = [$responses];\n        }\n\n        return new ResponseStream(NativeResponse::stream($responses, $timeout));\n    }\n\n    public function reset(): void\n    {\n        $this->multi->reset();\n    }\n\n    private static function getBodyAsString($body): string\n    {\n        if (\\is_resource($body)) {\n            return stream_get_contents($body);\n        }\n\n        if (!$body instanceof \\Closure) {\n            return $body;\n        }\n\n        $result = '';\n\n        while ('' !== $data = $body(self::$CHUNK_SIZE)) {\n            if (!\\is_string($data)) {\n                throw new TransportException(\\sprintf('Return value of the \"body\" option callback must be string, \"%s\" returned.', get_debug_type($data)));\n            }\n\n            $result .= $data;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Extracts the host and the port from the URL.\n     */\n    private static function parseHostPort(array $url, array &$info): array\n    {\n        if ($port = parse_url($url['authority'], \\PHP_URL_PORT) ?: '') {\n            $info['primary_port'] = $port;\n            $port = ':'.$port;\n        } else {\n            $info['primary_port'] = 'http:' === $url['scheme'] ? 80 : 443;\n        }\n\n        return [parse_url($url['authority'], \\PHP_URL_HOST), $port];\n    }\n\n    /**\n     * Resolves the IP of the host using the local DNS cache if possible.\n     */\n    private static function dnsResolve(string $host, NativeClientState $multi, array &$info, ?\\Closure $onProgress): string\n    {\n        $flag = '' !== $host && '[' === $host[0] && ']' === $host[-1] && str_contains($host, ':') ? \\FILTER_FLAG_IPV6 : \\FILTER_FLAG_IPV4;\n        $ip = \\FILTER_FLAG_IPV6 === $flag ? substr($host, 1, -1) : $host;\n\n        if (filter_var($ip, \\FILTER_VALIDATE_IP, $flag)) {\n            // The host is already an IP address\n        } elseif (null === $ip = $multi->dnsCache[$host] ?? null) {\n            $info['debug'] .= \"* Hostname was NOT found in DNS cache\\n\";\n            $now = microtime(true);\n\n            if (!$ip = gethostbynamel($host)) {\n                throw new TransportException(\\sprintf('Could not resolve host \"%s\".', $host));\n            }\n\n            $multi->dnsCache[$host] = $ip = $ip[0];\n            $info['debug'] .= \"* Added {$host}:0:{$ip} to DNS cache\\n\";\n            $host = $ip;\n        } else {\n            $info['debug'] .= \"* Hostname was found in DNS cache\\n\";\n            $host = str_contains($ip, ':') ? \"[$ip]\" : $ip;\n        }\n\n        $info['namelookup_time'] = microtime(true) - ($info['start_time'] ?: $now);\n        $info['primary_ip'] = $ip;\n\n        if ($onProgress) {\n            // Notify DNS resolution\n            $onProgress();\n        }\n\n        return $host;\n    }\n\n    /**\n     * Handles redirects - the native logic is too buggy to be used.\n     */\n    private static function createRedirectResolver(array $options, string $authority, ?array $proxy, array &$info, ?\\Closure $onProgress): \\Closure\n    {\n        $redirectHeaders = [];\n        if (0 < $maxRedirects = $options['max_redirects']) {\n            $redirectHeaders = ['authority' => $authority];\n            $redirectHeaders['with_auth'] = $redirectHeaders['no_auth'] = array_filter($options['headers'], static fn ($h) => 0 !== stripos($h, 'Host:'));\n\n            if (isset($options['normalized_headers']['authorization']) || isset($options['normalized_headers']['cookie'])) {\n                $redirectHeaders['no_auth'] = array_filter($redirectHeaders['no_auth'], static fn ($h) => 0 !== stripos($h, 'Authorization:') && 0 !== stripos($h, 'Cookie:'));\n            }\n        }\n\n        return static function (NativeClientState $multi, ?string $location, $context) use (&$redirectHeaders, $proxy, &$info, $maxRedirects, $onProgress): ?string {\n            if (null === $location || $info['http_code'] < 300 || 400 <= $info['http_code']) {\n                $info['redirect_url'] = null;\n\n                return null;\n            }\n\n            try {\n                $url = self::parseUrl($location);\n                $locationHasHost = isset($url['authority']);\n                $url = self::resolveUrl($url, $info['url']);\n            } catch (InvalidArgumentException) {\n                $info['redirect_url'] = null;\n\n                return null;\n            }\n\n            $info['redirect_url'] = implode('', $url);\n\n            if ($info['redirect_count'] >= $maxRedirects) {\n                return null;\n            }\n\n            $info['url'] = $url;\n            ++$info['redirect_count'];\n            $info['redirect_time'] = microtime(true) - $info['start_time'];\n\n            // Do like curl and browsers: turn POST to GET on 301, 302 and 303\n            if (\\in_array($info['http_code'], [301, 302, 303], true)) {\n                $options = stream_context_get_options($context)['http'];\n\n                if ('POST' === $options['method'] || 303 === $info['http_code']) {\n                    $info['http_method'] = $options['method'] = 'HEAD' === $options['method'] ? 'HEAD' : 'GET';\n                    $options['content'] = '';\n                    $filterContentHeaders = static fn ($h) => 0 !== stripos($h, 'Content-Length:') && 0 !== stripos($h, 'Content-Type:') && 0 !== stripos($h, 'Transfer-Encoding:');\n                    $options['header'] = array_filter($options['header'], $filterContentHeaders);\n                    $redirectHeaders['no_auth'] = array_filter($redirectHeaders['no_auth'], $filterContentHeaders);\n                    $redirectHeaders['with_auth'] = array_filter($redirectHeaders['with_auth'], $filterContentHeaders);\n\n                    if (\\PHP_VERSION_ID >= 80300) {\n                        stream_context_set_options($context, ['http' => $options]);\n                    } else {\n                        stream_context_set_option($context, ['http' => $options]);\n                    }\n                }\n            }\n\n            [$host, $port] = self::parseHostPort($url, $info);\n\n            if ($locationHasHost) {\n                // Authorization and Cookie headers MUST NOT follow except for the initial authority name\n                $requestHeaders = $redirectHeaders['authority'] === $url['authority'] ? $redirectHeaders['with_auth'] : $redirectHeaders['no_auth'];\n                $requestHeaders[] = 'Host: '.$host.$port;\n                $dnsResolve = !self::configureHeadersAndProxy($context, $host, $requestHeaders, $proxy, 'https:' === $url['scheme']);\n            } else {\n                $dnsResolve = isset(stream_context_get_options($context)['ssl']['peer_name']);\n            }\n\n            if ($dnsResolve) {\n                $ip = self::dnsResolve($host, $multi, $info, $onProgress);\n                $url['authority'] = substr_replace($url['authority'], $ip, -\\strlen($host) - \\strlen($port), \\strlen($host));\n            }\n\n            return implode('', $url);\n        };\n    }\n\n    private static function configureHeadersAndProxy($context, string $host, array $requestHeaders, ?array $proxy, bool $isSsl): bool\n    {\n        if (null === $proxy) {\n            stream_context_set_option($context, 'http', 'header', $requestHeaders);\n            stream_context_set_option($context, 'ssl', 'peer_name', $host);\n\n            return false;\n        }\n\n        // Matching \"no_proxy\" should follow the behavior of curl\n\n        foreach ($proxy['no_proxy'] as $rule) {\n            $dotRule = '.'.ltrim($rule, '.');\n\n            if ('*' === $rule || $host === $rule || str_ends_with($host, $dotRule)) {\n                stream_context_set_option($context, 'http', 'proxy', null);\n                stream_context_set_option($context, 'http', 'request_fulluri', false);\n                stream_context_set_option($context, 'http', 'header', $requestHeaders);\n                stream_context_set_option($context, 'ssl', 'peer_name', $host);\n\n                return false;\n            }\n        }\n\n        if (null !== $proxy['auth']) {\n            $requestHeaders[] = 'Proxy-Authorization: '.$proxy['auth'];\n        }\n\n        stream_context_set_option($context, 'http', 'proxy', $proxy['url']);\n        stream_context_set_option($context, 'http', 'request_fulluri', !$isSsl);\n        stream_context_set_option($context, 'http', 'header', $requestHeaders);\n        stream_context_set_option($context, 'ssl', 'peer_name', null);\n\n        return true;\n    }\n}\n"
        },
        {
          "name": "NoPrivateNetworkHttpClient.php",
          "type": "blob",
          "size": 9.6201171875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\HttpClient\\Exception\\TransportException;\nuse Symfony\\Component\\HttpClient\\Response\\AsyncContext;\nuse Symfony\\Component\\HttpClient\\Response\\AsyncResponse;\nuse Symfony\\Component\\HttpFoundation\\IpUtils;\nuse Symfony\\Contracts\\HttpClient\\ChunkInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * Decorator that blocks requests to private networks by default.\n *\n * @author Hallison Boaventura <hallisonboaventura@gmail.com>\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class NoPrivateNetworkHttpClient implements HttpClientInterface, LoggerAwareInterface, ResetInterface\n{\n    use HttpClientTrait;\n    use AsyncDecoratorTrait;\n\n    private array $defaultOptions = self::OPTIONS_DEFAULTS;\n    private HttpClientInterface $client;\n    private array|null $subnets;\n    private int $ipFlags;\n    private \\ArrayObject $dnsCache;\n\n    /**\n     * @param string|array|null $subnets String or array of subnets using CIDR notation that should be considered private.\n     *                                   If null is passed, the standard private subnets will be used.\n     */\n    public function __construct(HttpClientInterface $client, string|array|null $subnets = null)\n    {\n        if (!class_exists(IpUtils::class)) {\n            throw new \\LogicException(\\sprintf('You cannot use \"%s\" if the HttpFoundation component is not installed. Try running \"composer require symfony/http-foundation\".', __CLASS__));\n        }\n\n        if (null === $subnets) {\n            $ipFlags = \\FILTER_FLAG_IPV4 | \\FILTER_FLAG_IPV6;\n        } else {\n            $ipFlags = 0;\n            foreach ((array) $subnets as $subnet) {\n                $ipFlags |= str_contains($subnet, ':') ? \\FILTER_FLAG_IPV6 : \\FILTER_FLAG_IPV4;\n            }\n        }\n\n        if (!\\defined('STREAM_PF_INET6')) {\n            $ipFlags &= ~\\FILTER_FLAG_IPV6;\n        }\n\n        $this->client = $client;\n        $this->subnets = null !== $subnets ? (array) $subnets : null;\n        $this->ipFlags = $ipFlags;\n        $this->dnsCache = new \\ArrayObject();\n    }\n\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        [$url, $options] = self::prepareRequest($method, $url, $options, $this->defaultOptions, true);\n\n        $redirectHeaders = parse_url($url['authority']);\n        $host = $redirectHeaders['host'];\n        $url = implode('', $url);\n        $dnsCache = $this->dnsCache;\n\n        $ip = self::dnsResolve($dnsCache, $host, $this->ipFlags, $options);\n        self::ipCheck($ip, $this->subnets, $this->ipFlags, $host, $url);\n\n        $onProgress = $options['on_progress'] ?? null;\n        $subnets = $this->subnets;\n        $ipFlags = $this->ipFlags;\n\n        $options['on_progress'] = static function (int $dlNow, int $dlSize, array $info) use ($onProgress, $subnets, $ipFlags): void {\n            static $lastPrimaryIp = '';\n\n            if (!\\in_array($info['primary_ip'] ?? '', ['', $lastPrimaryIp], true)) {\n                self::ipCheck($info['primary_ip'], $subnets, $ipFlags, null, $info['url']);\n                $lastPrimaryIp = $info['primary_ip'];\n            }\n\n            null !== $onProgress && $onProgress($dlNow, $dlSize, $info);\n        };\n\n        if (0 >= $maxRedirects = $options['max_redirects']) {\n            return new AsyncResponse($this->client, $method, $url, $options);\n        }\n\n        $options['max_redirects'] = 0;\n        $redirectHeaders['with_auth'] = $redirectHeaders['no_auth'] = $options['headers'];\n\n        if (isset($options['normalized_headers']['host']) || isset($options['normalized_headers']['authorization']) || isset($options['normalized_headers']['cookie'])) {\n            $redirectHeaders['no_auth'] = array_filter($redirectHeaders['no_auth'], static function ($h) {\n                return 0 !== stripos($h, 'Host:') && 0 !== stripos($h, 'Authorization:') && 0 !== stripos($h, 'Cookie:');\n            });\n        }\n\n        return new AsyncResponse($this->client, $method, $url, $options, static function (ChunkInterface $chunk, AsyncContext $context) use (&$method, &$options, $maxRedirects, &$redirectHeaders, $subnets, $ipFlags, $dnsCache): \\Generator {\n            if (null !== $chunk->getError() || $chunk->isTimeout() || !$chunk->isFirst()) {\n                yield $chunk;\n\n                return;\n            }\n\n            $statusCode = $context->getStatusCode();\n\n            if ($statusCode < 300 || 400 <= $statusCode || null === $url = $context->getInfo('redirect_url')) {\n                $context->passthru();\n\n                yield $chunk;\n\n                return;\n            }\n\n            $host = parse_url($url, \\PHP_URL_HOST);\n            $ip = self::dnsResolve($dnsCache, $host, $ipFlags, $options);\n            self::ipCheck($ip, $subnets, $ipFlags, $host, $url);\n\n            // Do like curl and browsers: turn POST to GET on 301, 302 and 303\n            if (303 === $statusCode || 'POST' === $method && \\in_array($statusCode, [301, 302], true)) {\n                $method = 'HEAD' === $method ? 'HEAD' : 'GET';\n                unset($options['body'], $options['json']);\n\n                if (isset($options['normalized_headers']['content-length']) || isset($options['normalized_headers']['content-type']) || isset($options['normalized_headers']['transfer-encoding'])) {\n                    $filterContentHeaders = static function ($h) {\n                        return 0 !== stripos($h, 'Content-Length:') && 0 !== stripos($h, 'Content-Type:') && 0 !== stripos($h, 'Transfer-Encoding:');\n                    };\n                    $options['headers'] = array_filter($options['headers'], $filterContentHeaders);\n                    $redirectHeaders['no_auth'] = array_filter($redirectHeaders['no_auth'], $filterContentHeaders);\n                    $redirectHeaders['with_auth'] = array_filter($redirectHeaders['with_auth'], $filterContentHeaders);\n                }\n            }\n\n            // Authorization and Cookie headers MUST NOT follow except for the initial host name\n            $port = parse_url($url, \\PHP_URL_PORT);\n            $options['headers'] = $redirectHeaders['host'] === $host && ($redirectHeaders['port'] ?? null) === $port ? $redirectHeaders['with_auth'] : $redirectHeaders['no_auth'];\n\n            static $redirectCount = 0;\n            $context->setInfo('redirect_count', ++$redirectCount);\n\n            $context->replaceRequest($method, $url, $options);\n\n            if ($redirectCount >= $maxRedirects) {\n                $context->passthru();\n            }\n        });\n    }\n\n    /**\n     * @deprecated since Symfony 7.1, configure the logger on the wrapped HTTP client directly instead\n     */\n    public function setLogger(LoggerInterface $logger): void\n    {\n        trigger_deprecation('symfony/http-client', '7.1', 'Configure the logger on the wrapped HTTP client directly instead.');\n\n        if ($this->client instanceof LoggerAwareInterface) {\n            $this->client->setLogger($logger);\n        }\n    }\n\n    public function withOptions(array $options): static\n    {\n        $clone = clone $this;\n        $clone->client = $this->client->withOptions($options);\n        $clone->defaultOptions = self::mergeDefaultOptions($options, $this->defaultOptions);\n\n        return $clone;\n    }\n\n    public function reset(): void\n    {\n        $this->dnsCache->exchangeArray([]);\n\n        if ($this->client instanceof ResetInterface) {\n            $this->client->reset();\n        }\n    }\n\n    private static function dnsResolve(\\ArrayObject $dnsCache, string $host, int $ipFlags, array &$options): string\n    {\n        if ($ip = filter_var(trim($host, '[]'), \\FILTER_VALIDATE_IP) ?: $options['resolve'][$host] ?? false) {\n            return $ip;\n        }\n\n        if ($dnsCache->offsetExists($host)) {\n            return $dnsCache[$host];\n        }\n\n        if ((\\FILTER_FLAG_IPV4 & $ipFlags) && $ip = gethostbynamel($host)) {\n            return $options['resolve'][$host] = $dnsCache[$host] = $ip[0];\n        }\n\n        if (!(\\FILTER_FLAG_IPV6 & $ipFlags)) {\n            return $host;\n        }\n\n        if ($ip = dns_get_record($host, \\DNS_AAAA)) {\n            $ip = $ip[0]['ipv6'];\n        } elseif (extension_loaded('sockets')) {\n            if (!$info = socket_addrinfo_lookup($host, 0, ['ai_socktype' => \\SOCK_STREAM, 'ai_family' => \\AF_INET6])) {\n                return $host;\n            }\n\n            $ip = socket_addrinfo_explain($info[0])['ai_addr']['sin6_addr'];\n        } elseif ('localhost' === $host || 'localhost.' === $host) {\n            $ip = '::1';\n        } else {\n            return $host;\n        }\n\n        return $options['resolve'][$host] = $dnsCache[$host] = $ip;\n    }\n\n    private static function ipCheck(string $ip, ?array $subnets, int $ipFlags, ?string $host, string $url): void\n    {\n        if (null === $subnets) {\n            // Quick check, but not reliable enough, see https://github.com/php/php-src/issues/16944\n            $ipFlags |= \\FILTER_FLAG_NO_PRIV_RANGE | \\FILTER_FLAG_NO_RES_RANGE;\n        }\n\n        if (false !== filter_var($ip, \\FILTER_VALIDATE_IP, $ipFlags) && !IpUtils::checkIp($ip, $subnets ?? IpUtils::PRIVATE_SUBNETS)) {\n            return;\n        }\n\n        if (null !== $host) {\n            $type = 'Host';\n        } else {\n            $host = $ip;\n            $type = 'IP';\n        }\n\n        throw new TransportException($type.\\sprintf(' \"%s\" is blocked for \"%s\".', $host, $url));\n    }\n}\n"
        },
        {
          "name": "Psr18Client.php",
          "type": "blob",
          "size": 7.533203125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Http\\Discovery\\Psr17Factory;\nuse Http\\Discovery\\Psr17FactoryDiscovery;\nuse Nyholm\\Psr7\\Factory\\Psr17Factory as NyholmPsr17Factory;\nuse Nyholm\\Psr7\\Request;\nuse Nyholm\\Psr7\\Uri;\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Client\\NetworkExceptionInterface;\nuse Psr\\Http\\Client\\RequestExceptionInterface;\nuse Psr\\Http\\Message\\RequestFactoryInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Http\\Message\\StreamInterface;\nuse Psr\\Http\\Message\\UriFactoryInterface;\nuse Psr\\Http\\Message\\UriInterface;\nuse Symfony\\Component\\HttpClient\\Internal\\HttplugWaitLoop;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\nif (!interface_exists(ClientInterface::class)) {\n    throw new \\LogicException('You cannot use the \"Symfony\\Component\\HttpClient\\Psr18Client\" as the \"psr/http-client\" package is not installed. Try running \"composer require php-http/discovery psr/http-client-implementation:*\".');\n}\n\nif (!interface_exists(RequestFactoryInterface::class)) {\n    throw new \\LogicException('You cannot use the \"Symfony\\Component\\HttpClient\\Psr18Client\" as the \"psr/http-factory\" package is not installed. Try running \"composer require php-http/discovery psr/http-factory-implementation:*\".');\n}\n\n/**\n * An adapter to turn a Symfony HttpClientInterface into a PSR-18 ClientInterface.\n *\n * Run \"composer require php-http/discovery psr/http-client-implementation:*\"\n * to get the required dependencies.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class Psr18Client implements ClientInterface, RequestFactoryInterface, StreamFactoryInterface, UriFactoryInterface, ResetInterface\n{\n    private HttpClientInterface $client;\n    private ResponseFactoryInterface $responseFactory;\n    private StreamFactoryInterface $streamFactory;\n\n    public function __construct(?HttpClientInterface $client = null, ?ResponseFactoryInterface $responseFactory = null, ?StreamFactoryInterface $streamFactory = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n        $streamFactory ??= $responseFactory instanceof StreamFactoryInterface ? $responseFactory : null;\n\n        if (null === $responseFactory || null === $streamFactory) {\n            if (class_exists(Psr17Factory::class)) {\n                $psr17Factory = new Psr17Factory();\n            } elseif (class_exists(NyholmPsr17Factory::class)) {\n                $psr17Factory = new NyholmPsr17Factory();\n            } else {\n                throw new \\LogicException('You cannot use the \"Symfony\\Component\\HttpClient\\Psr18Client\" as no PSR-17 factories have been provided. Try running \"composer require php-http/discovery psr/http-factory-implementation:*\".');\n            }\n\n            $responseFactory ??= $psr17Factory;\n            $streamFactory ??= $psr17Factory;\n        }\n\n        $this->responseFactory = $responseFactory;\n        $this->streamFactory = $streamFactory;\n    }\n\n    public function withOptions(array $options): static\n    {\n        $clone = clone $this;\n        $clone->client = $clone->client->withOptions($options);\n\n        return $clone;\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        try {\n            $body = $request->getBody();\n\n            if ($body->isSeekable()) {\n                $body->seek(0);\n            }\n\n            $headers = $request->getHeaders();\n            if (!$request->hasHeader('content-length') && 0 <= $size = $body->getSize() ?? -1) {\n                $headers['Content-Length'] = [$size];\n            }\n\n            $options = [\n                'headers' => $headers,\n                'body' => static fn (int $size) => $body->read($size),\n            ];\n\n            if ('1.0' === $request->getProtocolVersion()) {\n                $options['http_version'] = '1.0';\n            }\n\n            $response = $this->client->request($request->getMethod(), (string) $request->getUri(), $options);\n\n            return HttplugWaitLoop::createPsr7Response($this->responseFactory, $this->streamFactory, $this->client, $response, false);\n        } catch (TransportExceptionInterface $e) {\n            if ($e instanceof \\InvalidArgumentException) {\n                throw new Psr18RequestException($e, $request);\n            }\n\n            throw new Psr18NetworkException($e, $request);\n        }\n    }\n\n    public function createRequest(string $method, $uri): RequestInterface\n    {\n        if ($this->responseFactory instanceof RequestFactoryInterface) {\n            return $this->responseFactory->createRequest($method, $uri);\n        }\n\n        if (class_exists(Psr17FactoryDiscovery::class)) {\n            return Psr17FactoryDiscovery::findRequestFactory()->createRequest($method, $uri);\n        }\n\n        if (class_exists(Request::class)) {\n            return new Request($method, $uri);\n        }\n\n        throw new \\LogicException(\\sprintf('You cannot use \"%s()\" as no PSR-17 factories have been found. Try running \"composer require php-http/discovery psr/http-factory-implementation:*\".', __METHOD__));\n    }\n\n    public function createStream(string $content = ''): StreamInterface\n    {\n        $stream = $this->streamFactory->createStream($content);\n\n        if ($stream->isSeekable()) {\n            $stream->seek(0);\n        }\n\n        return $stream;\n    }\n\n    public function createStreamFromFile(string $filename, string $mode = 'r'): StreamInterface\n    {\n        return $this->streamFactory->createStreamFromFile($filename, $mode);\n    }\n\n    public function createStreamFromResource($resource): StreamInterface\n    {\n        return $this->streamFactory->createStreamFromResource($resource);\n    }\n\n    public function createUri(string $uri = ''): UriInterface\n    {\n        if ($this->responseFactory instanceof UriFactoryInterface) {\n            return $this->responseFactory->createUri($uri);\n        }\n\n        if (class_exists(Psr17FactoryDiscovery::class)) {\n            return Psr17FactoryDiscovery::findUrlFactory()->createUri($uri);\n        }\n\n        if (class_exists(Uri::class)) {\n            return new Uri($uri);\n        }\n\n        throw new \\LogicException(\\sprintf('You cannot use \"%s()\" as no PSR-17 factories have been found. Try running \"composer require php-http/discovery psr/http-factory-implementation:*\".', __METHOD__));\n    }\n\n    public function reset(): void\n    {\n        if ($this->client instanceof ResetInterface) {\n            $this->client->reset();\n        }\n    }\n}\n\n/**\n * @internal\n */\nclass Psr18NetworkException extends \\RuntimeException implements NetworkExceptionInterface\n{\n    public function __construct(\n        TransportExceptionInterface $e,\n        private RequestInterface $request,\n    ) {\n        parent::__construct($e->getMessage(), 0, $e);\n    }\n\n    public function getRequest(): RequestInterface\n    {\n        return $this->request;\n    }\n}\n\n/**\n * @internal\n */\nclass Psr18RequestException extends \\InvalidArgumentException implements RequestExceptionInterface\n{\n    public function __construct(\n        TransportExceptionInterface $e,\n        private RequestInterface $request,\n    ) {\n        parent::__construct($e->getMessage(), 0, $e);\n    }\n\n    public function getRequest(): RequestInterface\n    {\n        return $this->request;\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.51953125,
          "content": "HttpClient component\n====================\n\nThe HttpClient component provides powerful methods to fetch HTTP resources synchronously or asynchronously.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/http_client.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Response",
          "type": "tree",
          "content": null
        },
        {
          "name": "Retry",
          "type": "tree",
          "content": null
        },
        {
          "name": "RetryableHttpClient.php",
          "type": "blob",
          "size": 7.1181640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\HttpClient\\Response\\AsyncContext;\nuse Symfony\\Component\\HttpClient\\Response\\AsyncResponse;\nuse Symfony\\Component\\HttpClient\\Retry\\GenericRetryStrategy;\nuse Symfony\\Component\\HttpClient\\Retry\\RetryStrategyInterface;\nuse Symfony\\Contracts\\HttpClient\\ChunkInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * Automatically retries failing HTTP requests.\n *\n * @author Jérémy Derussé <jeremy@derusse.com>\n */\nclass RetryableHttpClient implements HttpClientInterface, ResetInterface\n{\n    use AsyncDecoratorTrait;\n\n    private RetryStrategyInterface $strategy;\n    private array $baseUris = [];\n\n    /**\n     * @param int $maxRetries The maximum number of times to retry\n     */\n    public function __construct(\n        HttpClientInterface $client,\n        ?RetryStrategyInterface $strategy = null,\n        private int $maxRetries = 3,\n        private ?LoggerInterface $logger = null,\n    ) {\n        $this->client = $client;\n        $this->strategy = $strategy ?? new GenericRetryStrategy();\n    }\n\n    public function withOptions(array $options): static\n    {\n        if (\\array_key_exists('base_uri', $options)) {\n            if (\\is_array($options['base_uri'])) {\n                $this->baseUris = $options['base_uri'];\n                unset($options['base_uri']);\n            } else {\n                $this->baseUris = [];\n            }\n        }\n\n        $clone = clone $this;\n        $clone->maxRetries = (int) ($options['max_retries'] ?? $this->maxRetries);\n        unset($options['max_retries']);\n\n        $clone->client = $this->client->withOptions($options);\n\n        return $clone;\n    }\n\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        $baseUris = \\array_key_exists('base_uri', $options) ? $options['base_uri'] : $this->baseUris;\n        $baseUris = \\is_array($baseUris) ? $baseUris : [];\n        $options = self::shiftBaseUri($options, $baseUris);\n\n        $maxRetries = (int) ($options['max_retries'] ?? $this->maxRetries);\n        unset($options['max_retries']);\n\n        if ($maxRetries <= 0) {\n            return new AsyncResponse($this->client, $method, $url, $options);\n        }\n\n        return new AsyncResponse($this->client, $method, $url, $options, function (ChunkInterface $chunk, AsyncContext $context) use ($method, $url, $options, $maxRetries, &$baseUris) {\n            static $retryCount = 0;\n            static $content = '';\n            static $firstChunk;\n\n            $exception = null;\n            try {\n                if ($context->getInfo('canceled') || $chunk->isTimeout() || null !== $chunk->getInformationalStatus()) {\n                    yield $chunk;\n\n                    return;\n                }\n            } catch (TransportExceptionInterface $exception) {\n                // catch TransportExceptionInterface to send it to the strategy\n            }\n            if (null !== $exception) {\n                // always retry request that fail to resolve DNS\n                if ('' !== $context->getInfo('primary_ip')) {\n                    $shouldRetry = $this->strategy->shouldRetry($context, null, $exception);\n                    if (null === $shouldRetry) {\n                        throw new \\LogicException(\\sprintf('The \"%s::shouldRetry()\" method must not return null when called with an exception.', $this->strategy::class));\n                    }\n\n                    if (false === $shouldRetry) {\n                        yield from $this->passthru($context, $firstChunk, $content, $chunk);\n\n                        return;\n                    }\n                }\n            } elseif ($chunk->isFirst()) {\n                if (false === $shouldRetry = $this->strategy->shouldRetry($context, null, null)) {\n                    yield from $this->passthru($context, $firstChunk, $content, $chunk);\n\n                    return;\n                }\n\n                // Body is needed to decide\n                if (null === $shouldRetry) {\n                    $firstChunk = $chunk;\n                    $content = '';\n\n                    return;\n                }\n            } else {\n                if (!$chunk->isLast()) {\n                    $content .= $chunk->getContent();\n\n                    return;\n                }\n\n                if (null === $shouldRetry = $this->strategy->shouldRetry($context, $content, null)) {\n                    throw new \\LogicException(\\sprintf('The \"%s::shouldRetry()\" method must not return null when called with a body.', $this->strategy::class));\n                }\n\n                if (false === $shouldRetry) {\n                    yield from $this->passthru($context, $firstChunk, $content, $chunk);\n\n                    return;\n                }\n            }\n\n            $context->getResponse()->cancel();\n\n            $delay = $this->getDelayFromHeader($context->getHeaders()) ?? $this->strategy->getDelay($context, !$exception && $chunk->isLast() ? $content : null, $exception);\n            ++$retryCount;\n            $content = '';\n            $firstChunk = null;\n\n            $this->logger?->info('Try #{count} after {delay}ms'.($exception ? ': '.$exception->getMessage() : ', status code: '.$context->getStatusCode()), [\n                'count' => $retryCount,\n                'delay' => $delay,\n            ]);\n\n            $context->setInfo('retry_count', $retryCount);\n            $context->replaceRequest($method, $url, self::shiftBaseUri($options, $baseUris));\n            $context->pause($delay / 1000);\n\n            if ($retryCount >= $maxRetries) {\n                $context->passthru();\n            }\n        });\n    }\n\n    private function getDelayFromHeader(array $headers): ?int\n    {\n        if (null !== $after = $headers['retry-after'][0] ?? null) {\n            if (is_numeric($after)) {\n                return (int) ($after * 1000);\n            }\n\n            if (false !== $time = strtotime($after)) {\n                return max(0, $time - time()) * 1000;\n            }\n        }\n\n        return null;\n    }\n\n    private function passthru(AsyncContext $context, ?ChunkInterface $firstChunk, string &$content, ChunkInterface $lastChunk): \\Generator\n    {\n        $context->passthru();\n\n        if (null !== $firstChunk) {\n            yield $firstChunk;\n        }\n\n        if ('' !== $content) {\n            $chunk = $context->createChunk($content);\n            $content = '';\n\n            yield $chunk;\n        }\n\n        yield $lastChunk;\n    }\n\n    private static function shiftBaseUri(array $options, array &$baseUris): array\n    {\n        if ($baseUris) {\n            $baseUri = 1 < \\count($baseUris) ? array_shift($baseUris) : current($baseUris);\n            $options['base_uri'] = \\is_array($baseUri) ? $baseUri[array_rand($baseUri)] : $baseUri;\n        }\n\n        return $options;\n    }\n}\n"
        },
        {
          "name": "ScopingHttpClient.php",
          "type": "blob",
          "size": 3.99609375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\HttpClient\\Exception\\InvalidArgumentException;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseStreamInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * Auto-configure the default options based on the requested URL.\n *\n * @author Anthony Martin <anthony.martin@sensiolabs.com>\n */\nclass ScopingHttpClient implements HttpClientInterface, ResetInterface, LoggerAwareInterface\n{\n    use HttpClientTrait;\n\n    public function __construct(\n        private HttpClientInterface $client,\n        private array $defaultOptionsByRegexp,\n        private ?string $defaultRegexp = null,\n    ) {\n        if (null !== $defaultRegexp && !isset($defaultOptionsByRegexp[$defaultRegexp])) {\n            throw new InvalidArgumentException(\\sprintf('No options are mapped to the provided \"%s\" default regexp.', $defaultRegexp));\n        }\n    }\n\n    public static function forBaseUri(HttpClientInterface $client, string $baseUri, array $defaultOptions = [], ?string $regexp = null): self\n    {\n        $regexp ??= preg_quote(implode('', self::resolveUrl(self::parseUrl('.'), self::parseUrl($baseUri))));\n\n        $defaultOptions['base_uri'] = $baseUri;\n\n        return new self($client, [$regexp => $defaultOptions], $regexp);\n    }\n\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        $e = null;\n        $url = self::parseUrl($url, $options['query'] ?? []);\n\n        if (\\is_string($options['base_uri'] ?? null)) {\n            $options['base_uri'] = self::parseUrl($options['base_uri']);\n        }\n\n        try {\n            $url = implode('', self::resolveUrl($url, $options['base_uri'] ?? null));\n        } catch (InvalidArgumentException $e) {\n            if (null === $this->defaultRegexp) {\n                throw $e;\n            }\n\n            $defaultOptions = $this->defaultOptionsByRegexp[$this->defaultRegexp];\n            $options = self::mergeDefaultOptions($options, $defaultOptions, true);\n            if (\\is_string($options['base_uri'] ?? null)) {\n                $options['base_uri'] = self::parseUrl($options['base_uri']);\n            }\n            $url = implode('', self::resolveUrl($url, $options['base_uri'] ?? null, $defaultOptions['query'] ?? []));\n        }\n\n        foreach ($this->defaultOptionsByRegexp as $regexp => $defaultOptions) {\n            if (preg_match(\"{{$regexp}}A\", $url)) {\n                if (null === $e || $regexp !== $this->defaultRegexp) {\n                    $options = self::mergeDefaultOptions($options, $defaultOptions, true);\n                }\n                break;\n            }\n        }\n\n        return $this->client->request($method, $url, $options);\n    }\n\n    public function stream(ResponseInterface|iterable $responses, ?float $timeout = null): ResponseStreamInterface\n    {\n        return $this->client->stream($responses, $timeout);\n    }\n\n    public function reset(): void\n    {\n        if ($this->client instanceof ResetInterface) {\n            $this->client->reset();\n        }\n    }\n\n    /**\n     * @deprecated since Symfony 7.1, configure the logger on the wrapped HTTP client directly instead\n     */\n    public function setLogger(LoggerInterface $logger): void\n    {\n        trigger_deprecation('symfony/http-client', '7.1', 'Configure the logger on the wrapped HTTP client directly instead.');\n\n        if ($this->client instanceof LoggerAwareInterface) {\n            $this->client->setLogger($logger);\n        }\n    }\n\n    public function withOptions(array $options): static\n    {\n        $clone = clone $this;\n        $clone->client = $this->client->withOptions($options);\n\n        return $clone;\n    }\n}\n"
        },
        {
          "name": "Test",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "ThrottlingHttpClient.php",
          "type": "blob",
          "size": 1.31640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Symfony\\Component\\RateLimiter\\LimiterInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * Limits the number of requests within a certain period.\n */\nclass ThrottlingHttpClient implements HttpClientInterface, ResetInterface\n{\n    use DecoratorTrait {\n        reset as private traitReset;\n    }\n\n    public function __construct(\n        HttpClientInterface $client,\n        private readonly LimiterInterface $rateLimiter,\n    ) {\n        $this->client = $client;\n    }\n\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        $response = $this->client->request($method, $url, $options);\n\n        if (0 < $waitDuration = $this->rateLimiter->reserve()->getWaitDuration()) {\n            $response->getInfo('pause_handler')($waitDuration);\n        }\n\n        return $response;\n    }\n\n    public function reset(): void\n    {\n        $this->traitReset();\n        $this->rateLimiter->reset();\n    }\n}\n"
        },
        {
          "name": "TraceableHttpClient.php",
          "type": "blob",
          "size": 3.306640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\HttpClient\\Response\\ResponseStream;\nuse Symfony\\Component\\HttpClient\\Response\\TraceableResponse;\nuse Symfony\\Component\\Stopwatch\\Stopwatch;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseStreamInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * @author Jérémy Romey <jeremy@free-agent.fr>\n */\nfinal class TraceableHttpClient implements HttpClientInterface, ResetInterface, LoggerAwareInterface\n{\n    private \\ArrayObject $tracedRequests;\n\n    public function __construct(\n        private HttpClientInterface $client,\n        private ?Stopwatch $stopwatch = null,\n    ) {\n        $this->tracedRequests = new \\ArrayObject();\n    }\n\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        $content = null;\n        $traceInfo = [];\n        $this->tracedRequests[] = [\n            'method' => $method,\n            'url' => $url,\n            'options' => $options,\n            'info' => &$traceInfo,\n            'content' => &$content,\n        ];\n        $onProgress = $options['on_progress'] ?? null;\n\n        if (false === ($options['extra']['trace_content'] ?? true)) {\n            unset($content);\n            $content = false;\n        }\n\n        $options['on_progress'] = function (int $dlNow, int $dlSize, array $info) use (&$traceInfo, $onProgress) {\n            $traceInfo = $info;\n\n            if (null !== $onProgress) {\n                $onProgress($dlNow, $dlSize, $info);\n            }\n        };\n\n        return new TraceableResponse($this->client, $this->client->request($method, $url, $options), $content, $this->stopwatch?->start(\"$method $url\", 'http_client'));\n    }\n\n    public function stream(ResponseInterface|iterable $responses, ?float $timeout = null): ResponseStreamInterface\n    {\n        if ($responses instanceof TraceableResponse) {\n            $responses = [$responses];\n        }\n\n        return new ResponseStream(TraceableResponse::stream($this->client, $responses, $timeout));\n    }\n\n    public function getTracedRequests(): array\n    {\n        return $this->tracedRequests->getArrayCopy();\n    }\n\n    public function reset(): void\n    {\n        if ($this->client instanceof ResetInterface) {\n            $this->client->reset();\n        }\n\n        $this->tracedRequests->exchangeArray([]);\n    }\n\n    /**\n     * @deprecated since Symfony 7.1, configure the logger on the wrapped HTTP client directly instead\n     */\n    public function setLogger(LoggerInterface $logger): void\n    {\n        trigger_deprecation('symfony/http-client', '7.1', 'Configure the logger on the wrapped HTTP client directly instead.');\n\n        if ($this->client instanceof LoggerAwareInterface) {\n            $this->client->setLogger($logger);\n        }\n    }\n\n    public function withOptions(array $options): static\n    {\n        $clone = clone $this;\n        $clone->client = $this->client->withOptions($options);\n\n        return $clone;\n    }\n}\n"
        },
        {
          "name": "UriTemplateHttpClient.php",
          "type": "blob",
          "size": 2.6845703125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpClient;\n\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\nclass UriTemplateHttpClient implements HttpClientInterface, ResetInterface\n{\n    use DecoratorTrait;\n\n    /**\n     * @param (\\Closure(string $url, array $vars): string)|null $expander\n     */\n    public function __construct(?HttpClientInterface $client = null, private ?\\Closure $expander = null, private array $defaultVars = [])\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function request(string $method, string $url, array $options = []): ResponseInterface\n    {\n        $vars = $this->defaultVars;\n\n        if (\\array_key_exists('vars', $options)) {\n            if (!\\is_array($options['vars'])) {\n                throw new \\InvalidArgumentException('The \"vars\" option must be an array.');\n            }\n\n            $vars = [...$vars, ...$options['vars']];\n            unset($options['vars']);\n        }\n\n        if ($vars) {\n            $url = ($this->expander ??= $this->createExpanderFromPopularVendors())($url, $vars);\n        }\n\n        return $this->client->request($method, $url, $options);\n    }\n\n    public function withOptions(array $options): static\n    {\n        if (!\\is_array($options['vars'] ?? [])) {\n            throw new \\InvalidArgumentException('The \"vars\" option must be an array.');\n        }\n\n        $clone = clone $this;\n        $clone->defaultVars = [...$clone->defaultVars, ...$options['vars'] ?? []];\n        unset($options['vars']);\n\n        $clone->client = $this->client->withOptions($options);\n\n        return $clone;\n    }\n\n    /**\n     * @return \\Closure(string $url, array $vars): string\n     */\n    private function createExpanderFromPopularVendors(): \\Closure\n    {\n        if (class_exists(\\GuzzleHttp\\UriTemplate\\UriTemplate::class)) {\n            return \\GuzzleHttp\\UriTemplate\\UriTemplate::expand(...);\n        }\n\n        if (class_exists(\\League\\Uri\\UriTemplate::class)) {\n            return static fn (string $url, array $vars): string => (new \\League\\Uri\\UriTemplate($url))->expand($vars);\n        }\n\n        if (class_exists(\\Rize\\UriTemplate::class)) {\n            return (new \\Rize\\UriTemplate())->expand(...);\n        }\n\n        throw new \\LogicException('Support for URI template requires a vendor to expand the URI. Run \"composer require guzzlehttp/uri-template\" or pass your own expander \\Closure implementation.');\n    }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.845703125,
          "content": "{\n    \"name\": \"symfony/http-client\",\n    \"type\": \"library\",\n    \"description\": \"Provides powerful methods to fetch HTTP resources synchronously or asynchronously\",\n    \"keywords\": [\"http\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Nicolas Grekas\",\n            \"email\": \"p@tchwork.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"provide\": {\n        \"php-http/async-client-implementation\": \"*\",\n        \"php-http/client-implementation\": \"*\",\n        \"psr/http-client-implementation\": \"1.0\",\n        \"symfony/http-client-implementation\": \"3.0\"\n    },\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"psr/log\": \"^1|^2|^3\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3\",\n        \"symfony/http-client-contracts\": \"~3.4.4|^3.5.2\",\n        \"symfony/service-contracts\": \"^2.5|^3\"\n    },\n    \"require-dev\": {\n        \"amphp/http-client\": \"^4.2.1|^5.0\",\n        \"amphp/http-tunnel\": \"^1.0|^2.0\",\n        \"amphp/socket\": \"^1.1\",\n        \"guzzlehttp/promises\": \"^1.4|^2.0\",\n        \"nyholm/psr7\": \"^1.0\",\n        \"php-http/httplug\": \"^1.0|^2.0\",\n        \"psr/http-client\": \"^1.0\",\n        \"symfony/amphp-http-client-meta\": \"^1.0|^2.0\",\n        \"symfony/dependency-injection\": \"^6.4|^7.0\",\n        \"symfony/http-kernel\": \"^6.4|^7.0\",\n        \"symfony/messenger\": \"^6.4|^7.0\",\n        \"symfony/process\": \"^6.4|^7.0\",\n        \"symfony/rate-limiter\": \"^6.4|^7.0\",\n        \"symfony/stopwatch\": \"^6.4|^7.0\"\n    },\n    \"conflict\": {\n        \"amphp/amp\": \"<2.5\",\n        \"php-http/discovery\": \"<1.15\",\n        \"symfony/http-foundation\": \"<6.4\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\HttpClient\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.8017578125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony HttpClient Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}