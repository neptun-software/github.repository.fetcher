{
  "metadata": {
    "timestamp": 1736711815515,
    "page": 108,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lazychaser/laravel-nestedset",
      "stars": 3679,
      "defaultBranch": "v6",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0888671875,
          "content": "/vendor\n/.idea\n.phpunit.cache/\ncomposer.phar\ncomposer.lock\n.DS_Store\n.phpunit.result.cache\n"
        },
        {
          "name": "CHANGELOG.markdown",
          "type": "blob",
          "size": 3.9130859375,
          "content": "### 4.3.4\n*   Support Laravel 5.8\n\n### 4.3.3\n*   Support Laravel 5.7\n\n### 4.3.2\n*   Support Laravel 5.6\n*   Added `nestedSet` and `dropNestedSet` blueprint macros\n\n### 4.3.0\n*   Support Laravel 5.5\n*   Added `fixSubtree` and `rebuildSubtree` methods\n*   Increased performance of tree rebuilding\n\n### 4.2.7\n\n*   #217: parent_id, lft and rgt are reset when replicating a node\n\n### 4.2.5\n\n*   #208: dirty parent and bounds when making a root\n*   #206: fixed where has on descendants\n*   refactored ancestors and descendants relations\n\n### 4.2.4\n\n*   Fixed issues related to rebuilding tree when using `SoftDeletes` and scoping\n\n### 4.2.3\n\n*   Added `whereAncestorOrSelf`, `ancestorsAndSelf`, `descendantsOrSelf`,\n    `whereDescendantOrSelf` helper methods\n*   #186: rebuild tree removes nodes softly when model uses SoftDeletes trait\n*   #191: added `whereIsLeaf` and `leaves` method, added `isLeaf` check on node\n\n### 4.1.0\n\n*   #75: Converted to trait. Following methods were renamed:\n    -   `appendTo` to `appendToNode`\n    -   `prependTo` to `prependToNode`\n    -   `insertBefore` to `insertBeforeNode`\n    -   `insertAfter` to `insertAfterNode`\n    -   `getNext` to `getNextNode`\n    -   `getPrev` to `getPrevNode`\n*   #82: Fixing tree now handles case when nodes pointing to non-existing parent\n*   The number of missing parent is now returned when using `countErrors`\n*   #79: implemented scoping feature\n*   #81: moving node now makes model dirty before saving it\n*   #45: descendants is now a relation that can be eagerly loaded\n*   `hasChildren` and `hasParent` are now deprecated. Use `has('children')`\n    `has('parent')` instead\n*   Default order is no longer applied for `siblings()`, `descendants()`,\n    `prevNodes`, `nextNodes`\n*   #50: implemented tree rebuilding feature\n*   #85: added tree flattening feature\n\n### 3.1.1\n\n*   Fixed #42: model becomes dirty before save when parent is changed and using `appendTo`,\n    `prependTo`, `insertBefore`, `insertAfter`.\n\n### 3.1.0\n\n*   Added `fixTree` method for fixing `lft`/`rgt` values based on inheritance\n*   Dropped support of Laravel < 5.1\n*   Improved compatibility with different databases\n\n### 3.0.0\n\n*   Support Laravel 5.1.9\n*   Renamed `append` to `appendNode`, `prepend` to `prependNode`\n*   Renamed `next` to `nextNodes`, `prev` to `prevNodes`\n*   Renamed `after` to `afterNode`, `before` to `beforeNode`\n\n### 2.4.0\n\n*   Added query methods `whereNotDescendantOf`, `orWhereDescendantOf`, `orWhereNotDescendantOf`\n*   `whereAncestorOf`, `whereDescendantOf` and every method that depends on them can now accept node instance\n*   Added `Node::getBounds` that returns an array of node bounds that can be used in `whereNodeBetween`\n\n### 2.3.0\n\n*   Added `linkNodes` method to `Collection` class\n\n### 2.2.0\n\n*   Support Laravel 5\n\n### 2.1.0\n\n*   Added `isChildOf`, `isAncestorOf`, `isSiblingOf` methods\n\n### 2.0.0\n\n*   Added `insertAfter`, `insertBefore` methods.\n*   `prepend` and `append` methods now save target model.\n*   You can now call `refreshNode` to make sure that node has updated structural\n    data (lft and rgt values).\n*   The root node is not required now. You can use `saveAsRoot` or `makeRoot` method.\n    New model is saved as root by default.\n*   You can now create as many nodes and in any order as you want within single\n    request.\n*   Laravel 2 is supported but not required.\n*   `ancestorsOf` now doesn't include target node into results.\n*   New constraint methods `hasParent` and `hasChildren`.\n*   New method `isDescendantOf` that checks if node is a descendant of other node.\n*   Default order is not applied by default.\n*   New method `descendantsOf` that allows to get descendants by id of the node.\n*   Added `countErrors` and `isBroken` methods to check whether the tree is broken.\n*   `NestedSet::createRoot` has been removed.\n*   `NestedSet::column` doesn't create a foreign key anymore.\n\n### 1.1.0\n\n*   `Collection::toDictionary` is now obsolete. Use `Collection::groupBy`.\n*   Laravel 4.2 is required\n"
        },
        {
          "name": "README.markdown",
          "type": "blob",
          "size": 18.4833984375,
          "content": "[![Build Status](https://travis-ci.org/lazychaser/laravel-nestedset.svg?branch=master)](https://travis-ci.org/lazychaser/laravel-nestedset)\n[![Total Downloads](https://poser.pugx.org/kalnoy/nestedset/downloads.svg)](https://packagist.org/packages/kalnoy/nestedset)\n[![Latest Stable Version](https://poser.pugx.org/kalnoy/nestedset/v/stable.svg)](https://packagist.org/packages/kalnoy/nestedset)\n[![Latest Unstable Version](https://poser.pugx.org/kalnoy/nestedset/v/unstable.svg)](https://packagist.org/packages/kalnoy/nestedset)\n[![License](https://poser.pugx.org/kalnoy/nestedset/license.svg)](https://packagist.org/packages/kalnoy/nestedset)\n\nThis is a Laravel 4-10 package for working with trees in relational databases.\n\n*   **Laravel 11.0** is supported since v6.0.4\n*   **Laravel 10.0** is supported since v6.0.2\n*   **Laravel 9.0** is supported since v6.0.1\n*   **Laravel 8.0** is supported since v6.0.0\n*   **Laravel 5.7, 5.8, 6.0, 7.0** is supported since v5\n*   **Laravel 5.5, 5.6** is supported since v4.3\n*   **Laravel 5.2, 5.3, 5.4** is supported since v4\n*   **Laravel 5.1** is supported in v3\n*   **Laravel 4** is supported in v2\n\n__Contents:__\n\n- [Theory](#what-are-nested-sets)\n- [Documentation](#documentation)\n    -   [Inserting nodes](#inserting-nodes)\n    -   [Retrieving nodes](#retrieving-nodes)\n    -   [Deleting nodes](#deleting-nodes)\n    -   [Consistency checking & fixing](#checking-consistency)\n    -   [Scoping](#scoping)\n- [Requirements](#requirements)\n- [Installation](#installation)\n\nWhat are nested sets?\n---------------------\n\nNested sets or [Nested Set Model](http://en.wikipedia.org/wiki/Nested_set_model) is\na way to effectively store hierarchical data in a relational table. From wikipedia:\n\n> The nested set model is to number the nodes according to a tree traversal,\n> which visits each node twice, assigning numbers in the order of visiting, and\n> at both visits. This leaves two numbers for each node, which are stored as two\n> attributes. Querying becomes inexpensive: hierarchy membership can be tested by\n> comparing these numbers. Updating requires renumbering and is therefore expensive.\n\n### Applications\n\nNSM shows good performance when tree is updated rarely. It is tuned to be fast for\ngetting related nodes. It'is ideally suited for building multi-depth menu or\ncategories for shop.\n\nDocumentation\n-------------\n\nSuppose that we have a model `Category`; a `$node` variable is an instance of that model\nand the node that we are manipulating. It can be a fresh model or one from database.\n\n### Relationships\n\nNode has following relationships that are fully functional and can be eagerly loaded:\n\n-   Node belongs to `parent`\n-   Node has many `children`\n-   Node has many `ancestors`\n-   Node has many `descendants`\n\n### Inserting nodes\n\nMoving and inserting nodes includes several database queries, so it is\nhighly recommended to use transactions.\n\n__IMPORTANT!__ As of v4.2.0 transaction is not automatically started\n\nAnother important note is that __structural manipulations are deferred__ until you\nhit `save` on model (some methods implicitly call `save` and return boolean result\nof the operation).\n\nIf model is successfully saved it doesn't mean that node was moved. If your application\ndepends on whether the node has actually changed its position, use `hasMoved` method:\n\n```php\nif ($node->save()) {\n    $moved = $node->hasMoved();\n}\n```\n\n#### Creating nodes\n\nWhen you simply creating a node, it will be appended to the end of the tree:\n\n```php\nCategory::create($attributes); // Saved as root\n```\n\n```php\n$node = new Category($attributes);\n$node->save(); // Saved as root\n```\n\nIn this case the node is considered a _root_ which means that it doesn't have a parent.\n\n#### Making a root from existing node\n\n```php\n// #1 Implicit save\n$node->saveAsRoot();\n\n// #2 Explicit save\n$node->makeRoot()->save();\n```\n\nThe node will be appended to the end of the tree.\n\n#### Appending and prepending to the specified parent\n\nIf you want to make node a child of other node, you can make it last or first child.\n\n*In following examples, `$parent` is some existing node.*\n\nThere are few ways to append a node:\n\n```php\n// #1 Using deferred insert\n$node->appendToNode($parent)->save();\n\n// #2 Using parent node\n$parent->appendNode($node);\n\n// #3 Using parent's children relationship\n$parent->children()->create($attributes);\n\n// #5 Using node's parent relationship\n$node->parent()->associate($parent)->save();\n\n// #6 Using the parent attribute\n$node->parent_id = $parent->id;\n$node->save();\n\n// #7 Using static method\nCategory::create($attributes, $parent);\n```\n\nAnd only a couple ways to prepend:\n\n```php\n// #1\n$node->prependToNode($parent)->save();\n\n// #2\n$parent->prependNode($node);\n```\n\n#### Inserting before or after specified node\n\nYou can make `$node` to be a neighbor of the `$neighbor` node using following methods:\n\n*`$neighbor` must exists, target node can be fresh. If target node exists,\nit will be moved to the new position and parent will be changed if it's required.*\n\n```php\n# Explicit save\n$node->afterNode($neighbor)->save();\n$node->beforeNode($neighbor)->save();\n\n# Implicit save\n$node->insertAfterNode($neighbor);\n$node->insertBeforeNode($neighbor);\n```\n\n#### Building a tree from array\n\nWhen using static method `create` on node, it checks whether attributes contains\n`children` key. If it does, it creates more nodes recursively.\n\n```php\n$node = Category::create([\n    'name' => 'Foo',\n\n    'children' => [\n        [\n            'name' => 'Bar',\n\n            'children' => [\n                [ 'name' => 'Baz' ],\n            ],\n        ],\n    ],\n]);\n```\n\n`$node->children` now contains a list of created child nodes.\n\n#### Rebuilding a tree from array\n\nYou can easily rebuild a tree. This is useful for mass-changing the structure of\nthe tree.\n\n```php\nCategory::rebuildTree($data, $delete);\n```\n\n`$data` is an array of nodes:\n\n```php\n$data = [\n    [ 'id' => 1, 'name' => 'foo', 'children' => [ ... ] ],\n    [ 'name' => 'bar' ],\n];\n```\n\nThere is an id specified for node with the name of `foo` which means that existing\nnode will be filled and saved. If node is not exists `ModelNotFoundException` is\nthrown. Also, this node has `children` specified which is also an array of nodes;\nthey will be processed in the same manner and saved as children of node `foo`.\n\nNode `bar` has no primary key specified, so it will be created.\n\n`$delete` shows whether to delete nodes that are already exists but not present\nin `$data`. By default, nodes aren't deleted.\n\n##### Rebuilding a subtree\n\nAs of 4.2.8 you can rebuild a subtree:\n\n```php\nCategory::rebuildSubtree($root, $data);\n```\n\nThis constraints tree rebuilding to descendants of `$root` node.\n\n### Retrieving nodes\n\n*In some cases we will use an `$id` variable which is an id of the target node.*\n\n#### Ancestors and descendants\n\nAncestors make a chain of parents to the node. Helpful for displaying breadcrumbs\nto the current category.\n\nDescendants are all nodes in a sub tree, i.e. children of node, children of\nchildren, etc.\n\nBoth ancestors and descendants can be eagerly loaded.\n\n```php\n// Accessing ancestors\n$node->ancestors;\n\n// Accessing descendants\n$node->descendants;\n```\n\nIt is possible to load ancestors and descendants using custom query:\n\n```php\n$result = Category::ancestorsOf($id);\n$result = Category::ancestorsAndSelf($id);\n$result = Category::descendantsOf($id);\n$result = Category::descendantsAndSelf($id);\n```\n\nIn most cases, you need your ancestors to be ordered by the level:\n\n```php\n$result = Category::defaultOrder()->ancestorsOf($id);\n```\n\nA collection of ancestors can be eagerly loaded:\n\n```php\n$categories = Category::with('ancestors')->paginate(30);\n\n// in view for breadcrumbs:\n@foreach($categories as $i => $category)\n    <small>{{ $category->ancestors->count() ? implode(' > ', $category->ancestors->pluck('name')->toArray()) : 'Top Level' }}</small><br>\n    {{ $category->name }}\n@endforeach\n```\n\n#### Siblings\n\nSiblings are nodes that have same parent.\n\n```php\n$result = $node->getSiblings();\n\n$result = $node->siblings()->get();\n```\n\nTo get only next siblings:\n\n```php\n// Get a sibling that is immediately after the node\n$result = $node->getNextSibling();\n\n// Get all siblings that are after the node\n$result = $node->getNextSiblings();\n\n// Get all siblings using a query\n$result = $node->nextSiblings()->get();\n```\n\nTo get previous siblings:\n\n```php\n// Get a sibling that is immediately before the node\n$result = $node->getPrevSibling();\n\n// Get all siblings that are before the node\n$result = $node->getPrevSiblings();\n\n// Get all siblings using a query\n$result = $node->prevSiblings()->get();\n```\n\n#### Getting related models from other table\n\nImagine that each category `has many` goods. I.e. `HasMany` relationship is established.\nHow can you get all goods of `$category` and every its descendant? Easy!\n\n```php\n// Get ids of descendants\n$categories = $category->descendants()->pluck('id');\n\n// Include the id of category itself\n$categories[] = $category->getKey();\n\n// Get goods\n$goods = Goods::whereIn('category_id', $categories)->get();\n```\n\n#### Including node depth\n\nIf you need to know at which level the node is:\n\n```php\n$result = Category::withDepth()->find($id);\n\n$depth = $result->depth;\n```\n\nRoot node will be at level 0. Children of root nodes will have a level of 1, etc.\n\nTo get nodes of specified level, you can apply `having` constraint:\n\n```php\n$result = Category::withDepth()->having('depth', '=', 1)->get();\n```\n\n__IMPORTANT!__ This will not work in database strict mode\n\n#### Default order\n\nAll nodes are strictly organized internally. By default, no order is\napplied, so nodes may appear in random order and this doesn't affect\ndisplaying a tree. You can order nodes by alphabet or other index.\n\nBut in some cases hierarchical order is essential. It is required for\nretrieving ancestors and can be used to order menu items.\n\nTo apply tree order `defaultOrder` method is used:\n\n```php\n$result = Category::defaultOrder()->get();\n```\n\nYou can get nodes in reversed order:\n\n```php\n$result = Category::reversed()->get();\n```\n\nTo shift node up or down inside parent to affect default order:\n\n```php\n$bool = $node->down();\n$bool = $node->up();\n\n// Shift node by 3 siblings\n$bool = $node->down(3);\n```\n\nThe result of the operation is boolean value of whether the node has changed its\nposition.\n\n#### Constraints\n\nVarious constraints that can be applied to the query builder:\n\n-   __whereIsRoot()__ to get only root nodes;\n-   __hasParent()__ to get non-root nodes;\n-   __whereIsLeaf()__ to get only leaves;\n-   __hasChildren()__ to get non-leave nodes;\n-   __whereIsAfter($id)__ to get every node (not just siblings) that are after a node\n    with specified id;\n-   __whereIsBefore($id)__ to get every node that is before a node with specified id.\n\nDescendants constraints:\n\n```php\n$result = Category::whereDescendantOf($node)->get();\n$result = Category::whereNotDescendantOf($node)->get();\n$result = Category::orWhereDescendantOf($node)->get();\n$result = Category::orWhereNotDescendantOf($node)->get();\n$result = Category::whereDescendantAndSelf($id)->get();\n\n// Include target node into result set\n$result = Category::whereDescendantOrSelf($node)->get();\n```\n\nAncestor constraints:\n\n```php\n$result = Category::whereAncestorOf($node)->get();\n$result = Category::whereAncestorOrSelf($id)->get();\n```\n\n`$node` can be either a primary key of the model or model instance.\n\n#### Building a tree\n\nAfter getting a set of nodes, you can convert it to tree. For example:\n\n```php\n$tree = Category::get()->toTree();\n```\n\nThis will fill `parent` and `children` relationships on every node in the set and\nyou can render a tree using recursive algorithm:\n\n```php\n$nodes = Category::get()->toTree();\n\n$traverse = function ($categories, $prefix = '-') use (&$traverse) {\n    foreach ($categories as $category) {\n        echo PHP_EOL.$prefix.' '.$category->name;\n\n        $traverse($category->children, $prefix.'-');\n    }\n};\n\n$traverse($nodes);\n```\n\nThis will output something like this:\n\n```\n- Root\n-- Child 1\n--- Sub child 1\n-- Child 2\n- Another root\n```\n\n##### Building flat tree\n\nAlso, you can build a flat tree: a list of nodes where child nodes are immediately\nafter parent node. This is helpful when you get nodes with custom order\n(i.e. alphabetically) and don't want to use recursion to iterate over your nodes.\n\n```php\n$nodes = Category::get()->toFlatTree();\n```\n\nPrevious example will output:\n\n```\nRoot\nChild 1\nSub child 1\nChild 2\nAnother root\n```\n\n##### Getting a subtree\n\nSometimes you don't need whole tree to be loaded and just some subtree of specific node.\nIt is show in following example:\n\n```php\n$root = Category::descendantsAndSelf($rootId)->toTree()->first();\n```\n\nIn a single query we are getting a root of a subtree and all of its\ndescendants that are accessible via `children` relation.\n\nIf you don't need `$root` node itself, do following instead:\n\n```php\n$tree = Category::descendantsOf($rootId)->toTree($rootId);\n```\n\n### Deleting nodes\n\nTo delete a node:\n\n```php\n$node->delete();\n```\n\n**IMPORTANT!** Any descendant that node has will also be deleted!\n\n**IMPORTANT!** Nodes are required to be deleted as models, **don't** try do delete them using a query like so:\n\n```php\nCategory::where('id', '=', $id)->delete();\n```\n\nThis will break the tree!\n\n`SoftDeletes` trait is supported, also on model level.\n\n### Helper methods\n\nTo check if node is a descendant of other node:\n\n```php\n$bool = $node->isDescendantOf($parent);\n```\n\nTo check whether the node is a root:\n\n```php\n$bool = $node->isRoot();\n```\n\nOther checks:\n\n*   `$node->isChildOf($other);`\n*   `$node->isAncestorOf($other);`\n*   `$node->isSiblingOf($other);`\n*   `$node->isLeaf()`\n\n### Checking consistency\n\nYou can check whether a tree is broken (i.e. has some structural errors):\n\n```php\n$bool = Category::isBroken();\n```\n\nIt is possible to get error statistics:\n\n```php\n$data = Category::countErrors();\n```\n\nIt will return an array with following keys:\n\n-   `oddness` -- the number of nodes that have wrong set of `lft` and `rgt` values\n-   `duplicates` -- the number of nodes that have same `lft` or `rgt` values\n-   `wrong_parent` -- the number of nodes that have invalid `parent_id` value that\n    doesn't correspond to `lft` and `rgt` values\n-   `missing_parent` -- the number of nodes that have `parent_id` pointing to\n    node that doesn't exists\n\n#### Fixing tree\n\nSince v3.1 tree can now be fixed. Using inheritance info from `parent_id` column,\nproper `_lft` and `_rgt` values are set for every node.\n\n```php\nNode::fixTree();\n```\n\n### Scoping\n\nImagine you have `Menu` model and `MenuItems`. There is a one-to-many relationship\nset up between these models. `MenuItem` has `menu_id` attribute for joining models\ntogether. `MenuItem` incorporates nested sets. It is obvious that you would want to\nprocess each tree separately based on `menu_id` attribute. In order to do so, you\nneed to specify this attribute as scope attribute:\n\n```php\nprotected function getScopeAttributes()\n{\n    return [ 'menu_id' ];\n}\n```\n\nBut now, in order to execute some custom query, you need to provide attributes\nthat are used for scoping:\n\n```php\nMenuItem::scoped([ 'menu_id' => 5 ])->withDepth()->get(); // OK\nMenuItem::descendantsOf($id)->get(); // WRONG: returns nodes from other scope\nMenuItem::scoped([ 'menu_id' => 5 ])->fixTree(); // OK\n```\n\nWhen requesting nodes using model instance, scopes applied automatically based\non the attributes of that model:\n\n```php\n$node = MenuItem::findOrFail($id);\n\n$node->siblings()->withDepth()->get(); // OK\n```\n\nTo get scoped query builder using instance:\n\n```php\n$node->newScopedQuery();\n```\n\n#### Scoping and eager loading\n\nAlways use scoped query when eager loading:\n\n```php\nMenuItem::scoped([ 'menu_id' => 5])->with('descendants')->findOrFail($id); // OK\nMenuItem::with('descendants')->findOrFail($id); // WRONG\n```\n\nRequirements\n------------\n\n- PHP >= 5.4\n- Laravel >= 4.1\n\nIt is highly suggested to use database that supports transactions (like MySql's InnoDb)\nto secure a tree from possible corruption.\n\nInstallation\n------------\n\nTo install the package, in terminal:\n\n```\ncomposer require kalnoy/nestedset\n```\n\n### Setting up from scratch\n\n#### The schema\n\nFor Laravel 5.5 and above users:\n\n```php\nSchema::create('table', function (Blueprint $table) {\n    ...\n    $table->nestedSet();\n});\n\n// To drop columns\nSchema::table('table', function (Blueprint $table) {\n    $table->dropNestedSet();\n});\n```\n\nFor prior Laravel versions:\n\n```php\n...\nuse Kalnoy\\Nestedset\\NestedSet;\n\nSchema::create('table', function (Blueprint $table) {\n    ...\n    NestedSet::columns($table);\n});\n```\n\nTo drop columns:\n\n```php\n...\nuse Kalnoy\\Nestedset\\NestedSet;\n\nSchema::table('table', function (Blueprint $table) {\n    NestedSet::dropColumns($table);\n});\n```\n\n#### The model\n\nYour model should use `Kalnoy\\Nestedset\\NodeTrait` trait to enable nested sets:\n\n```php\nuse Kalnoy\\Nestedset\\NodeTrait;\n\nclass Foo extends Model {\n    use NodeTrait;\n}\n```\n\n### Migrating existing data\n\n#### Migrating from other nested set extension\n\nIf your previous extension used different set of columns, you just need to override\nfollowing methods on your model class:\n\n```php\npublic function getLftName()\n{\n    return 'left';\n}\n\npublic function getRgtName()\n{\n    return 'right';\n}\n\npublic function getParentIdName()\n{\n    return 'parent';\n}\n\n// Specify parent id attribute mutator\npublic function setParentAttribute($value)\n{\n    $this->setParentIdAttribute($value);\n}\n```\n\n#### Migrating from basic parentage info\n\nIf your tree contains `parent_id` info, you need to add two columns to your schema:\n\n```php\n$table->unsignedInteger('_lft');\n$table->unsignedInteger('_rgt');\n```\n\nAfter [setting up your model](#the-model) you only need to fix the tree to fill\n`_lft` and `_rgt` columns:\n\n```php\nMyModel::fixTree();\n```\n\nLicense\n=======\n\nCopyright (c) 2017 Alexander Kalnoy\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "TODO.markdown",
          "type": "blob",
          "size": 0.072265625,
          "content": "*   Convert query builder to extension\n*   Implement tree update algorithm"
        },
        {
          "name": "UPGRADE.markdown",
          "type": "blob",
          "size": 0.9541015625,
          "content": "### Upgrading from 4.0 to 4.1\n\nNested sets feature has been moved to trait `Kalnoy\\Nestedset\\NodeTrait`, but\nold `Kalnoy\\Nestedset\\Node` class is still available.\n\nSome methods on trait were renamed (see changelog), but still available on legacy\nnode class.\n\nDefault order is no longer applied for `siblings()`, `descendants()`, \n`prevNodes`, `nextNodes`.\n\n### Upgrading to 3.0\n\nSome methods were renamed, see changelog for more details.\n\n### Upgrading to 2.0\n\nCalling `$parent->append($node)` and `$parent->prepend($node)` now automatically\nsaves `$node`. Those functions returns whether the node was saved.\n\n`ancestorsOf` now return ancestors only, not including target node.\n\nDefault order is not applied automatically, so if you need nodes to be in tree-order\nyou should call `defaultOrder` on the query.\n\nSince root node is not required now, `NestedSet::createRoot` method has been removed.\n\n`NestedSet::columns` now doesn't create a foreign key for a `parent_id` column.\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.12890625,
          "content": "{\n    \"name\": \"kalnoy/nestedset\",\n    \"description\": \"Nested Set Model for Laravel 5.7 and up\",\n    \"keywords\": [\n        \"laravel\",\n        \"nested sets\",\n        \"nsm\",\n        \"database\",\n        \"hierarchy\"\n    ],\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Alexander Kalnoy\",\n            \"email\": \"lazychaser@gmail.com\"\n        }\n    ],\n    \"require\": {\n        \"php\": \"^7.2.5|^8.0\",\n        \"illuminate/support\": \"^7.0|^8.0|^9.0|^10.0|^11.0\",\n        \"illuminate/database\": \"^7.0|^8.0|^9.0|^10.0|^11.0\",\n        \"illuminate/events\": \"^7.0|^8.0|^9.0|^10.0|^11.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"Kalnoy\\\\Nestedset\\\\\": \"src/\"\n        }\n    },\n    \"require-dev\": {\n        \"phpunit/phpunit\": \"7.*|8.*|9.*|^10.5\"\n    },\n    \"minimum-stability\": \"dev\",\n    \"prefer-stable\": true,\n    \"extra\": {\n        \"branch-alias\": {\n            \"dev-master\": \"v5.0.x-dev\"\n        },\n        \"laravel\": {\n            \"providers\": [\n                \"Kalnoy\\\\Nestedset\\\\NestedSetServiceProvider\"\n            ]\n        }\n    },\n    \"scripts\": {\n        \"test\": [\n            \"@php ./vendor/bin/phpunit\"\n        ]\n    }\n}\n"
        },
        {
          "name": "phpunit.php",
          "type": "blob",
          "size": 0.3974609375,
          "content": "<?php\n\ninclude __DIR__.'/vendor/autoload.php';\n\n$capsule = new \\Illuminate\\Database\\Capsule\\Manager;\n$capsule->addConnection([ 'driver' => 'sqlite', 'database' => ':memory:', 'prefix' => 'prfx_' ]);\n$capsule->setEventDispatcher(new \\Illuminate\\Events\\Dispatcher);\n$capsule->bootEloquent();\n$capsule->setAsGlobal();\n\ninclude __DIR__.'/tests/models/Category.php';\ninclude __DIR__.'/tests/models/MenuItem.php';"
        },
        {
          "name": "phpunit.xml",
          "type": "blob",
          "size": 0.552734375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" backupGlobals=\"false\" bootstrap=\"phpunit.php\" colors=\"true\" processIsolation=\"false\" xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/10.5/phpunit.xsd\" cacheDirectory=\".phpunit.cache\" backupStaticProperties=\"false\">\n  <testsuites>\n    <testsuite name=\"Package Test Suite\">\n      <directory suffix=\".php\">./tests/</directory>\n    </testsuite>\n  </testsuites>\n  <source>\n    <include>\n      <directory>./src</directory>\n    </include>\n  </source>\n</phpunit>\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}