{
  "metadata": {
    "timestamp": 1736711909702,
    "page": 299,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/polyfill-intl-icu",
      "stars": 2593,
      "defaultBranch": "1.x",
      "files": [
        {
          "name": "Collator.php",
          "type": "blob",
          "size": 7.287109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Intl\\Icu;\n\nuse Symfony\\Polyfill\\Intl\\Icu\\Exception\\MethodArgumentValueNotImplementedException;\nuse Symfony\\Polyfill\\Intl\\Icu\\Exception\\MethodNotImplementedException;\n\n/**\n * Replacement for PHP's native {@link \\Collator} class.\n *\n * The only methods currently supported in this class are:\n *\n *  - {@link \\__construct}\n *  - {@link create}\n *  - {@link asort}\n *  - {@link getErrorCode}\n *  - {@link getErrorMessage}\n *  - {@link getLocale}\n *\n * @author Igor Wiedler <igor@wiedler.ch>\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @internal\n */\nabstract class Collator\n{\n    /* Attribute constants */\n    public const FRENCH_COLLATION = 0;\n    public const ALTERNATE_HANDLING = 1;\n    public const CASE_FIRST = 2;\n    public const CASE_LEVEL = 3;\n    public const NORMALIZATION_MODE = 4;\n    public const STRENGTH = 5;\n    public const HIRAGANA_QUATERNARY_MODE = 6;\n    public const NUMERIC_COLLATION = 7;\n\n    /* Attribute constants values */\n    public const DEFAULT_VALUE = -1;\n\n    public const PRIMARY = 0;\n    public const SECONDARY = 1;\n    public const TERTIARY = 2;\n    public const DEFAULT_STRENGTH = 2;\n    public const QUATERNARY = 3;\n    public const IDENTICAL = 15;\n\n    public const OFF = 16;\n    public const ON = 17;\n\n    public const SHIFTED = 20;\n    public const NON_IGNORABLE = 21;\n\n    public const LOWER_FIRST = 24;\n    public const UPPER_FIRST = 25;\n\n    /* Sorting options */\n    public const SORT_REGULAR = 0;\n    public const SORT_NUMERIC = 2;\n    public const SORT_STRING = 1;\n\n    /**\n     * @param string|null $locale The locale code. The only currently supported locale is \"en\" (or null using the default locale, i.e. \"en\")\n     *\n     * @throws MethodArgumentValueNotImplementedException When $locale different than \"en\" or null is passed\n     */\n    public function __construct(?string $locale)\n    {\n        if ('en' !== $locale && null !== $locale) {\n            throw new MethodArgumentValueNotImplementedException(__METHOD__, 'locale', $locale, 'Only the locale \"en\" is supported');\n        }\n    }\n\n    /**\n     * Static constructor.\n     *\n     * @param string|null $locale The locale code. The only currently supported locale is \"en\" (or null using the default locale, i.e. \"en\")\n     *\n     * @return static\n     *\n     * @throws MethodArgumentValueNotImplementedException When $locale different than \"en\" or null is passed\n     */\n    public static function create(?string $locale)\n    {\n        return new static($locale);\n    }\n\n    /**\n     * Sort array maintaining index association.\n     *\n     * @param array &$array Input array\n     * @param int   $flags  Flags for sorting, can be one of the following:\n     *                      Collator::SORT_REGULAR - compare items normally (don't change types)\n     *                      Collator::SORT_NUMERIC - compare items numerically\n     *                      Collator::SORT_STRING - compare items as strings\n     *\n     * @return bool True on success or false on failure\n     */\n    public function asort(array &$array, int $flags = self::SORT_REGULAR)\n    {\n        $intlToPlainFlagMap = [\n            self::SORT_REGULAR => \\SORT_REGULAR,\n            self::SORT_NUMERIC => \\SORT_NUMERIC,\n            self::SORT_STRING => \\SORT_STRING,\n        ];\n\n        $plainSortFlag = $intlToPlainFlagMap[$flags] ?? self::SORT_REGULAR;\n\n        return asort($array, $plainSortFlag);\n    }\n\n    /**\n     * Not supported. Compare two Unicode strings.\n     *\n     * @return int|false\n     *\n     * @see https://php.net/collator.compare\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function compare(string $string1, string $string2)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Get a value of an integer collator attribute.\n     *\n     * @return int|false The attribute value on success or false on error\n     *\n     * @see https://php.net/collator.getattribute\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function getAttribute(int $attribute)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Returns collator's last error code. Always returns the U_ZERO_ERROR class constant value.\n     *\n     * @return int|false The error code from last collator call\n     */\n    public function getErrorCode()\n    {\n        return Icu::U_ZERO_ERROR;\n    }\n\n    /**\n     * Returns collator's last error message. Always returns the U_ZERO_ERROR_MESSAGE class constant value.\n     *\n     * @return string|false The error message from last collator call\n     */\n    public function getErrorMessage()\n    {\n        return 'U_ZERO_ERROR';\n    }\n\n    /**\n     * Returns the collator's locale.\n     *\n     * @return string|false The locale used to create the collator. Currently\n     *                      always returns \"en\".\n     */\n    public function getLocale(int $type = Locale::ACTUAL_LOCALE)\n    {\n        return 'en';\n    }\n\n    /**\n     * Not supported. Get sorting key for a string.\n     *\n     * @return string|false The collation key for $string\n     *\n     * @see https://php.net/collator.getsortkey\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function getSortKey(string $string)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Get current collator's strength.\n     *\n     * @return int The current collator's strength or false on failure\n     *\n     * @see https://php.net/collator.getstrength\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function getStrength()\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Set a collator's attribute.\n     *\n     * @return bool True on success or false on failure\n     *\n     * @see https://php.net/collator.setattribute\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function setAttribute(int $attribute, int $value)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Set the collator's strength.\n     *\n     * @return bool True on success or false on failure\n     *\n     * @see https://php.net/collator.setstrength\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function setStrength(int $strength)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Sort array using specified collator and sort keys.\n     *\n     * @return bool True on success or false on failure\n     *\n     * @see https://php.net/collator.sortwithsortkeys\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function sortWithSortKeys(array &$array)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Sort array using specified collator.\n     *\n     * @return bool True on success or false on failure\n     *\n     * @see https://php.net/collator.sort\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function sort(array &$array, int $flags = self::SORT_REGULAR)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n}\n"
        },
        {
          "name": "Currencies.php",
          "type": "blob",
          "size": 1.1435546875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Intl\\Icu;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @internal\n */\nclass Currencies\n{\n    private static $data;\n\n    public static function getSymbol(string $currency): ?string\n    {\n        $data = self::$data ?? self::$data = require __DIR__.'/Resources/currencies.php';\n\n        return $data[$currency][0] ?? $data[strtoupper($currency)][0] ?? null;\n    }\n\n    public static function getFractionDigits(string $currency): int\n    {\n        $data = self::$data ?? self::$data = require __DIR__.'/Resources/currencies.php';\n\n        return $data[$currency][1] ?? $data[strtoupper($currency)][1] ?? $data['DEFAULT'][1];\n    }\n\n    public static function getRoundingIncrement(string $currency): int\n    {\n        $data = self::$data ?? self::$data = require __DIR__.'/Resources/currencies.php';\n\n        return $data[$currency][2] ?? $data[strtoupper($currency)][2] ?? $data['DEFAULT'][2];\n    }\n}\n"
        },
        {
          "name": "DateFormat",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Icu.php",
          "type": "blob",
          "size": 2.9599609375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Intl\\Icu;\n\n/**\n * Provides fake static versions of the global functions in the intl extension.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @internal\n */\nabstract class Icu\n{\n    /**\n     * Indicates that no error occurred.\n     */\n    public const U_ZERO_ERROR = 0;\n\n    /**\n     * Indicates that an invalid argument was passed.\n     */\n    public const U_ILLEGAL_ARGUMENT_ERROR = 1;\n\n    /**\n     * Indicates that the parse() operation failed.\n     */\n    public const U_PARSE_ERROR = 9;\n\n    /**\n     * All known error codes.\n     */\n    private static $errorCodes = [\n        self::U_ZERO_ERROR => 'U_ZERO_ERROR',\n        self::U_ILLEGAL_ARGUMENT_ERROR => 'U_ILLEGAL_ARGUMENT_ERROR',\n        self::U_PARSE_ERROR => 'U_PARSE_ERROR',\n    ];\n\n    /**\n     * The error code of the last operation.\n     */\n    private static $errorCode = self::U_ZERO_ERROR;\n\n    /**\n     * The error code of the last operation.\n     */\n    private static $errorMessage = 'U_ZERO_ERROR';\n\n    /**\n     * Returns whether the error code indicates a failure.\n     *\n     * @param int $errorCode The error code returned by Icu::getErrorCode()\n     */\n    public static function isFailure(int $errorCode): bool\n    {\n        return isset(self::$errorCodes[$errorCode])\n            && $errorCode > self::U_ZERO_ERROR;\n    }\n\n    /**\n     * Returns the error code of the last operation.\n     *\n     * Returns Icu::U_ZERO_ERROR if no error occurred.\n     *\n     * @return int\n     */\n    public static function getErrorCode()\n    {\n        return self::$errorCode;\n    }\n\n    /**\n     * Returns the error message of the last operation.\n     *\n     * Returns \"U_ZERO_ERROR\" if no error occurred.\n     */\n    public static function getErrorMessage(): string\n    {\n        return self::$errorMessage;\n    }\n\n    /**\n     * Returns the symbolic name for a given error code.\n     *\n     * @param int $code The error code returned by Icu::getErrorCode()\n     */\n    public static function getErrorName(int $code): string\n    {\n        return self::$errorCodes[$code] ?? '[BOGUS UErrorCode]';\n    }\n\n    /**\n     * Sets the current error.\n     *\n     * @param int    $code    One of the error constants in this class\n     * @param string $message The ICU class error message\n     *\n     * @throws \\InvalidArgumentException If the code is not one of the error constants in this class\n     */\n    public static function setError(int $code, string $message = '')\n    {\n        if (!isset(self::$errorCodes[$code])) {\n            throw new \\InvalidArgumentException(sprintf('No such error code: \"%s\".', $code));\n        }\n\n        self::$errorMessage = $message ? sprintf('%s: %s', $message, self::$errorCodes[$code]) : self::$errorCodes[$code];\n        self::$errorCode = $code;\n    }\n}\n"
        },
        {
          "name": "IntlDateFormatter.php",
          "type": "blob",
          "size": 19.681640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Intl\\Icu;\n\nuse Symfony\\Polyfill\\Intl\\Icu\\DateFormat\\FullTransformer;\nuse Symfony\\Polyfill\\Intl\\Icu\\Exception\\MethodArgumentNotImplementedException;\nuse Symfony\\Polyfill\\Intl\\Icu\\Exception\\MethodArgumentValueNotImplementedException;\nuse Symfony\\Polyfill\\Intl\\Icu\\Exception\\MethodNotImplementedException;\n\n/**\n * Replacement for PHP's native {@link \\IntlDateFormatter} class.\n *\n * The only methods currently supported in this class are:\n *\n *  - {@link __construct}\n *  - {@link create}\n *  - {@link format}\n *  - {@link getCalendar}\n *  - {@link getDateType}\n *  - {@link getErrorCode}\n *  - {@link getErrorMessage}\n *  - {@link getLocale}\n *  - {@link getPattern}\n *  - {@link getTimeType}\n *  - {@link getTimeZoneId}\n *  - {@link isLenient}\n *  - {@link parse}\n *  - {@link setLenient}\n *  - {@link setPattern}\n *  - {@link setTimeZoneId}\n *  - {@link setTimeZone}\n *\n * @author Igor Wiedler <igor@wiedler.ch>\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @internal\n */\nabstract class IntlDateFormatter\n{\n    /**\n     * The error code from the last operation.\n     *\n     * @var int\n     */\n    protected $errorCode = Icu::U_ZERO_ERROR;\n\n    /**\n     * The error message from the last operation.\n     *\n     * @var string\n     */\n    protected $errorMessage = 'U_ZERO_ERROR';\n\n    /* date/time format types */\n    public const NONE = -1;\n    public const FULL = 0;\n    public const LONG = 1;\n    public const MEDIUM = 2;\n    public const SHORT = 3;\n\n    /* date format types */\n    public const RELATIVE_FULL = 128;\n    public const RELATIVE_LONG = 129;\n    public const RELATIVE_MEDIUM = 130;\n    public const RELATIVE_SHORT = 131;\n\n    /* calendar formats */\n    public const TRADITIONAL = 0;\n    public const GREGORIAN = 1;\n\n    /**\n     * Patterns used to format the date when no pattern is provided.\n     */\n    private $defaultDateFormats = [\n        self::NONE => '',\n        self::FULL => 'EEEE, MMMM d, y',\n        self::LONG => 'MMMM d, y',\n        self::MEDIUM => 'MMM d, y',\n        self::SHORT => 'M/d/yy',\n        self::RELATIVE_FULL => 'EEEE, MMMM d, y',\n        self::RELATIVE_LONG => 'MMMM d, y',\n        self::RELATIVE_MEDIUM => 'MMM d, y',\n        self::RELATIVE_SHORT => 'M/d/yy',\n    ];\n\n    /**\n     * Patterns used to format the time when no pattern is provided.\n     */\n    private $defaultTimeFormats = [\n        self::FULL => 'h:mm:ss a zzzz',\n        self::LONG => 'h:mm:ss a z',\n        self::MEDIUM => 'h:mm:ss a',\n        self::SHORT => 'h:mm a',\n    ];\n\n    private $dateType;\n    private $timeType;\n\n    /**\n     * @var string\n     */\n    private $pattern;\n\n    /**\n     * @var \\DateTimeZone\n     */\n    private $dateTimeZone;\n\n    /**\n     * @var bool\n     */\n    private $uninitializedTimeZoneId = false;\n\n    /**\n     * @var string\n     */\n    private $timezoneId;\n\n    /**\n     * @var bool\n     */\n    private $isRelativeDateType = false;\n\n    /**\n     * @param string|null                             $locale   The locale code. The only currently supported locale is \"en\" (or null using the default locale, i.e. \"en\")\n     * @param \\IntlTimeZone|\\DateTimeZone|string|null $timezone Timezone identifier\n     * @param \\IntlCalendar|int|null                  $calendar Calendar to use for formatting or parsing. The only currently\n     *                                                          supported value is IntlDateFormatter::GREGORIAN (or null using the default calendar, i.e. \"GREGORIAN\")\n     *\n     * @see https://php.net/intldateformatter.create\n     * @see http://userguide.icu-project.org/formatparse/datetime\n     *\n     * @throws MethodArgumentValueNotImplementedException When $locale different than \"en\" or null is passed\n     * @throws MethodArgumentValueNotImplementedException When $calendar different than GREGORIAN is passed\n     */\n    public function __construct(?string $locale, ?int $dateType, ?int $timeType, $timezone = null, $calendar = null, ?string $pattern = '')\n    {\n        if ('en' !== $locale && null !== $locale) {\n            throw new MethodArgumentValueNotImplementedException(__METHOD__, 'locale', $locale, 'Only the locale \"en\" is supported');\n        }\n\n        if (self::GREGORIAN !== $calendar && null !== $calendar) {\n            throw new MethodArgumentValueNotImplementedException(__METHOD__, 'calendar', $calendar, 'Only the GREGORIAN calendar is supported');\n        }\n\n        if (\\PHP_VERSION_ID >= 80100) {\n            if (null === $dateType) {\n                @trigger_error('Passing null to parameter #2 ($dateType) of type int is deprecated', \\E_USER_DEPRECATED);\n            }\n\n            if (null === $timeType) {\n                @trigger_error('Passing null to parameter #3 ($timeType) of type int is deprecated', \\E_USER_DEPRECATED);\n            }\n        }\n\n        $this->dateType = $dateType ?? self::FULL;\n        $this->timeType = $timeType ?? self::FULL;\n\n        if ('' === ($pattern ?? '')) {\n            $pattern = $this->getDefaultPattern();\n        }\n\n        $this->setPattern($pattern);\n        $this->setTimeZone($timezone);\n\n        if (\\in_array($this->dateType, [self::RELATIVE_FULL, self::RELATIVE_LONG, self::RELATIVE_MEDIUM, self::RELATIVE_SHORT], true)) {\n            $this->isRelativeDateType = true;\n        }\n    }\n\n    /**\n     * Static constructor.\n     *\n     * @param string|null                             $locale   The locale code. The only currently supported locale is \"en\" (or null using the default locale, i.e. \"en\")\n     * @param \\IntlTimeZone|\\DateTimeZone|string|null $timezone Timezone identifier\n     * @param \\IntlCalendar|int|null                  $calendar Calendar to use for formatting or parsing; default is Gregorian\n     *                                                          One of the calendar constants\n     *\n     * @return static\n     *\n     * @see https://php.net/intldateformatter.create\n     * @see http://userguide.icu-project.org/formatparse/datetime\n     *\n     * @throws MethodArgumentValueNotImplementedException When $locale different than \"en\" or null is passed\n     * @throws MethodArgumentValueNotImplementedException When $calendar different than GREGORIAN is passed\n     */\n    public static function create(?string $locale, ?int $dateType, ?int $timeType, $timezone = null, ?int $calendar = null, ?string $pattern = '')\n    {\n        return new static($locale, $dateType, $timeType, $timezone, $calendar, $pattern);\n    }\n\n    /**\n     * Format the date/time value (timestamp) as a string.\n     *\n     * @param int|string|\\DateTimeInterface $datetime The timestamp to format\n     *\n     * @return string|false The formatted value or false if formatting failed\n     *\n     * @see https://php.net/intldateformatter.format\n     *\n     * @throws MethodArgumentValueNotImplementedException If one of the formatting characters is not implemented\n     */\n    public function format($datetime)\n    {\n        // intl allows timestamps to be passed as arrays - we don't\n        if (\\is_array($datetime)) {\n            $message = 'Only Unix timestamps and DateTime objects are supported';\n\n            throw new MethodArgumentValueNotImplementedException(__METHOD__, 'datetime', $datetime, $message);\n        }\n\n        if (\\is_string($datetime) && $dt = \\DateTime::createFromFormat('U', $datetime)) {\n            $datetime = $dt;\n        }\n\n        // behave like the intl extension\n        $argumentError = null;\n        if (!\\is_int($datetime) && !$datetime instanceof \\DateTimeInterface) {\n            $argumentError = sprintf('datefmt_format: string \\'%s\\' is not numeric, which would be required for it to be a valid date', $datetime);\n        }\n\n        if (null !== $argumentError) {\n            Icu::setError(Icu::U_ILLEGAL_ARGUMENT_ERROR, $argumentError);\n            $this->errorCode = Icu::getErrorCode();\n            $this->errorMessage = Icu::getErrorMessage();\n\n            return false;\n        }\n\n        if ($datetime instanceof \\DateTimeInterface) {\n            $datetime = $datetime->format('U');\n        }\n\n        $pattern = $this->getPattern();\n        $formatted = '';\n\n        if ($this->isRelativeDateType && $formatted = $this->getRelativeDateFormat($datetime)) {\n            if (self::NONE === $this->timeType) {\n                $pattern = '';\n            } else {\n                $pattern = $this->defaultTimeFormats[$this->timeType];\n                if (\\in_array($this->dateType, [self::RELATIVE_MEDIUM, self::RELATIVE_SHORT], true)) {\n                    $formatted .= ', ';\n                } else {\n                    $formatted .= ' at ';\n                }\n            }\n        }\n\n        $transformer = new FullTransformer($pattern, $this->getTimeZoneId());\n        $formatted .= $transformer->format($this->createDateTime($datetime));\n\n        // behave like the intl extension\n        Icu::setError(Icu::U_ZERO_ERROR);\n        $this->errorCode = Icu::getErrorCode();\n        $this->errorMessage = Icu::getErrorMessage();\n\n        return $formatted;\n    }\n\n    /**\n     * Not supported. Formats an object.\n     *\n     * @return string The formatted value\n     *\n     * @see https://php.net/intldateformatter.formatobject\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function formatObject($datetime, $format = null, ?string $locale = null)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Returns the formatter's calendar.\n     *\n     * @return int The calendar being used by the formatter. Currently always returns\n     *             IntlDateFormatter::GREGORIAN.\n     *\n     * @see https://php.net/intldateformatter.getcalendar\n     */\n    public function getCalendar()\n    {\n        return self::GREGORIAN;\n    }\n\n    /**\n     * Not supported. Returns the formatter's calendar object.\n     *\n     * @return object The calendar's object being used by the formatter\n     *\n     * @see https://php.net/intldateformatter.getcalendarobject\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function getCalendarObject()\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Returns the formatter's datetype.\n     *\n     * @return int The current value of the formatter\n     *\n     * @see https://php.net/intldateformatter.getdatetype\n     */\n    public function getDateType()\n    {\n        return $this->dateType;\n    }\n\n    /**\n     * Returns formatter's last error code. Always returns the U_ZERO_ERROR class constant value.\n     *\n     * @return int The error code from last formatter call\n     *\n     * @see https://php.net/intldateformatter.geterrorcode\n     */\n    public function getErrorCode()\n    {\n        return $this->errorCode;\n    }\n\n    /**\n     * Returns formatter's last error message. Always returns the U_ZERO_ERROR_MESSAGE class constant value.\n     *\n     * @return string The error message from last formatter call\n     *\n     * @see https://php.net/intldateformatter.geterrormessage\n     */\n    public function getErrorMessage()\n    {\n        return $this->errorMessage;\n    }\n\n    /**\n     * Returns the formatter's locale.\n     *\n     * @param int $type Not supported. The locale name type to return (Locale::VALID_LOCALE or Locale::ACTUAL_LOCALE)\n     *\n     * @return string The locale used to create the formatter. Currently always\n     *                returns \"en\".\n     *\n     * @see https://php.net/intldateformatter.getlocale\n     */\n    public function getLocale(int $type = Locale::ACTUAL_LOCALE)\n    {\n        return 'en';\n    }\n\n    /**\n     * Returns the formatter's pattern.\n     *\n     * @return string The pattern string used by the formatter\n     *\n     * @see https://php.net/intldateformatter.getpattern\n     */\n    public function getPattern()\n    {\n        return $this->pattern;\n    }\n\n    /**\n     * Returns the formatter's time type.\n     *\n     * @return int The time type used by the formatter\n     *\n     * @see https://php.net/intldateformatter.gettimetype\n     */\n    public function getTimeType()\n    {\n        return $this->timeType;\n    }\n\n    /**\n     * Returns the formatter's timezone identifier.\n     *\n     * @return string The timezone identifier used by the formatter\n     *\n     * @see https://php.net/intldateformatter.gettimezoneid\n     */\n    public function getTimeZoneId()\n    {\n        if (!$this->uninitializedTimeZoneId) {\n            return $this->timezoneId;\n        }\n\n        return date_default_timezone_get();\n    }\n\n    /**\n     * Not supported. Returns the formatter's timezone.\n     *\n     * @return mixed The timezone used by the formatter\n     *\n     * @see https://php.net/intldateformatter.gettimezone\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function getTimeZone()\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Returns whether the formatter is lenient.\n     *\n     * @return bool Currently always returns false\n     *\n     * @see https://php.net/intldateformatter.islenient\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function isLenient()\n    {\n        return false;\n    }\n\n    /**\n     * Not supported. Parse string to a field-based time value.\n     *\n     * @return string Localtime compatible array of integers: contains 24 hour clock value in tm_hour field\n     *\n     * @see https://php.net/intldateformatter.localtime\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function localtime(string $string, &$offset = null)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Parse string to a timestamp value.\n     *\n     * @return int|false Parsed value as a timestamp\n     *\n     * @see https://php.net/intldateformatter.parse\n     *\n     * @throws MethodArgumentNotImplementedException When $offset different than null, behavior not implemented\n     */\n    public function parse(string $string, &$offset = null)\n    {\n        // We don't calculate the position when parsing the value\n        if (null !== $offset) {\n            throw new MethodArgumentNotImplementedException(__METHOD__, 'offset');\n        }\n\n        $dateTime = $this->createDateTime(0);\n        $transformer = new FullTransformer($this->getPattern(), $this->getTimeZoneId());\n\n        $timestamp = $transformer->parse($dateTime, $string);\n\n        // behave like the intl extension. FullTransformer::parse() set the proper error\n        $this->errorCode = Icu::getErrorCode();\n        $this->errorMessage = Icu::getErrorMessage();\n\n        return $timestamp;\n    }\n\n    /**\n     * Not supported. Set the formatter's calendar.\n     *\n     * @param \\IntlCalendar|int|null $calendar\n     *\n     * @return bool true on success or false on failure\n     *\n     * @see https://php.net/intldateformatter.setcalendar\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function setCalendar($calendar)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Set the leniency of the parser.\n     *\n     * Define if the parser is strict or lenient in interpreting inputs that do not match the pattern\n     * exactly. Enabling lenient parsing allows the parser to accept otherwise flawed date or time\n     * patterns, parsing as much as possible to obtain a value. Extra space, unrecognized tokens, or\n     * invalid values (\"February 30th\") are not accepted.\n     *\n     * @param bool $lenient Sets whether the parser is lenient or not. Currently\n     *                      only false (strict) is supported.\n     *\n     * @return bool true on success or false on failure\n     *\n     * @see https://php.net/intldateformatter.setlenient\n     *\n     * @throws MethodArgumentValueNotImplementedException When $lenient is true\n     */\n    public function setLenient(bool $lenient)\n    {\n        if ($lenient) {\n            throw new MethodArgumentValueNotImplementedException(__METHOD__, 'lenient', $lenient, 'Only the strict parser is supported');\n        }\n\n        return true;\n    }\n\n    /**\n     * Set the formatter's pattern.\n     *\n     * @return bool true on success or false on failure\n     *\n     * @see https://php.net/intldateformatter.setpattern\n     * @see http://userguide.icu-project.org/formatparse/datetime\n     */\n    public function setPattern(string $pattern)\n    {\n        $this->pattern = $pattern;\n\n        return true;\n    }\n\n    /**\n     * Sets formatterʼs timezone.\n     *\n     * @param \\IntlTimeZone|\\DateTimeZone|string|null $timezone\n     *\n     * @return bool true on success or false on failure\n     *\n     * @see https://php.net/intldateformatter.settimezone\n     */\n    public function setTimeZone($timezone)\n    {\n        if ($timezone instanceof \\IntlTimeZone) {\n            $timezone = $timezone->getID();\n        }\n\n        if ($timezone instanceof \\DateTimeZone) {\n            $timezone = $timezone->getName();\n\n            // DateTimeZone returns the GMT offset timezones without the leading GMT, while our parsing requires it.\n            if (!empty($timezone) && ('+' === $timezone[0] || '-' === $timezone[0])) {\n                $timezone = 'GMT'.$timezone;\n            }\n        }\n\n        if (null === $timezone) {\n            $timezone = date_default_timezone_get();\n\n            $this->uninitializedTimeZoneId = true;\n        }\n\n        // Backup original passed time zone\n        $timezoneId = $timezone;\n\n        // Get an Etc/GMT time zone that is accepted for \\DateTimeZone\n        if ('GMT' !== $timezone && 0 === strpos($timezone, 'GMT')) {\n            try {\n                $timezone = DateFormat\\TimezoneTransformer::getEtcTimeZoneId($timezone);\n            } catch (\\InvalidArgumentException $e) {\n                // Does nothing, will fallback to UTC\n            }\n        }\n\n        try {\n            $this->dateTimeZone = new \\DateTimeZone($timezone);\n            if ('GMT' !== $timezone && $this->dateTimeZone->getName() !== $timezone) {\n                $timezoneId = $this->getTimeZoneId();\n            }\n        } catch (\\Exception $e) {\n            $timezoneId = $timezone = $this->getTimeZoneId();\n            $this->dateTimeZone = new \\DateTimeZone($timezone);\n        }\n\n        $this->timezoneId = $timezoneId;\n\n        return true;\n    }\n\n    /**\n     * Create and returns a DateTime object with the specified timestamp and with the\n     * current time zone.\n     *\n     * @return \\DateTime\n     */\n    protected function createDateTime($timestamp)\n    {\n        $dateTime = \\DateTime::createFromFormat('U', $timestamp);\n        $dateTime->setTimezone($this->dateTimeZone);\n\n        return $dateTime;\n    }\n\n    /**\n     * Returns a pattern string based in the datetype and timetype values.\n     *\n     * @return string\n     */\n    protected function getDefaultPattern()\n    {\n        $pattern = '';\n        if (self::NONE !== $this->dateType) {\n            $pattern = $this->defaultDateFormats[$this->dateType];\n        }\n        if (self::NONE !== $this->timeType) {\n            if (\\in_array($this->dateType, [self::FULL, self::LONG, self::RELATIVE_FULL, self::RELATIVE_LONG], true)) {\n                $pattern .= ' \\'at\\' ';\n            } elseif (self::NONE !== $this->dateType) {\n                $pattern .= ', ';\n            }\n            $pattern .= $this->defaultTimeFormats[$this->timeType];\n        }\n\n        return $pattern;\n    }\n\n    private function getRelativeDateFormat(int $timestamp): string\n    {\n        $today = $this->createDateTime(time());\n        $today->setTime(0, 0, 0);\n\n        $datetime = $this->createDateTime($timestamp);\n        $datetime->setTime(0, 0, 0);\n\n        $interval = $today->diff($datetime);\n\n        if (false !== $interval) {\n            if (0 === $interval->days) {\n                return 'today';\n            }\n\n            if (1 === $interval->days) {\n                return 1 === $interval->invert ? 'yesterday' : 'tomorrow';\n            }\n        }\n\n        return '';\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Locale.php",
          "type": "blob",
          "size": 8.734375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Intl\\Icu;\n\nuse Symfony\\Polyfill\\Intl\\Icu\\Exception\\MethodNotImplementedException;\n\n/**\n * Replacement for PHP's native {@link \\Locale} class.\n *\n * The only methods supported in this class are `getDefault` and `canonicalize`.\n * All other methods will throw an exception when used.\n *\n * @author Eriksen Costa <eriksen.costa@infranology.com.br>\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @internal\n */\nabstract class Locale\n{\n    public const DEFAULT_LOCALE = null;\n\n    /* Locale method constants */\n    public const ACTUAL_LOCALE = 0;\n    public const VALID_LOCALE = 1;\n\n    /* Language tags constants */\n    public const LANG_TAG = 'language';\n    public const EXTLANG_TAG = 'extlang';\n    public const SCRIPT_TAG = 'script';\n    public const REGION_TAG = 'region';\n    public const VARIANT_TAG = 'variant';\n    public const GRANDFATHERED_LANG_TAG = 'grandfathered';\n    public const PRIVATE_TAG = 'private';\n\n    /**\n     * Not supported. Returns the best available locale based on HTTP \"Accept-Language\" header according to RFC 2616.\n     *\n     * @return string The corresponding locale code\n     *\n     * @see https://php.net/locale.acceptfromhttp\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function acceptFromHttp(string $header)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Returns a canonicalized locale string.\n     *\n     * This polyfill doesn't implement the full-spec algorithm. It only\n     * canonicalizes locale strings handled by the `LocaleBundle` class.\n     *\n     * @return string\n     */\n    public static function canonicalize(string $locale)\n    {\n        if ('' === $locale || '.' === $locale[0]) {\n            return self::getDefault();\n        }\n\n        if (!preg_match('/^([a-z]{2})[-_]([a-z]{2})(?:([a-z]{2})(?:[-_]([a-z]{2}))?)?(?:\\..*)?$/i', $locale, $m)) {\n            return $locale;\n        }\n\n        if (!empty($m[4])) {\n            return strtolower($m[1]).'_'.ucfirst(strtolower($m[2].$m[3])).'_'.strtoupper($m[4]);\n        }\n\n        if (!empty($m[3])) {\n            return strtolower($m[1]).'_'.ucfirst(strtolower($m[2].$m[3]));\n        }\n\n        return strtolower($m[1]).'_'.strtoupper($m[2]);\n    }\n\n    /**\n     * Not supported. Returns a correctly ordered and delimited locale code.\n     *\n     * @return string The corresponding locale code\n     *\n     * @see https://php.net/locale.composelocale\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function composeLocale(array $subtags)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Checks if a language tag filter matches with locale.\n     *\n     * @return string The corresponding locale code\n     *\n     * @see https://php.net/locale.filtermatches\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function filterMatches(string $languageTag, string $locale, bool $canonicalize = false)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns the variants for the input locale.\n     *\n     * @return array The locale variants\n     *\n     * @see https://php.net/locale.getallvariants\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function getAllVariants(string $locale)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Returns the default locale.\n     *\n     * @return string The default locale code. Always returns 'en'\n     *\n     * @see https://php.net/locale.getdefault\n     */\n    public static function getDefault()\n    {\n        return 'en';\n    }\n\n    /**\n     * Not supported. Returns the localized display name for the locale language.\n     *\n     * @return string The localized language display name\n     *\n     * @see https://php.net/locale.getdisplaylanguage\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function getDisplayLanguage(string $locale, ?string $displayLocale = null)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns the localized display name for the locale.\n     *\n     * @return string The localized locale display name\n     *\n     * @see https://php.net/locale.getdisplayname\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function getDisplayName(string $locale, ?string $displayLocale = null)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns the localized display name for the locale region.\n     *\n     * @return string The localized region display name\n     *\n     * @see https://php.net/locale.getdisplayregion\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function getDisplayRegion(string $locale, ?string $displayLocale = null)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns the localized display name for the locale script.\n     *\n     * @return string The localized script display name\n     *\n     * @see https://php.net/locale.getdisplayscript\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function getDisplayScript(string $locale, ?string $displayLocale = null)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns the localized display name for the locale variant.\n     *\n     * @return string The localized variant display name\n     *\n     * @see https://php.net/locale.getdisplayvariant\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function getDisplayVariant(string $locale, ?string $displayLocale = null)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns the keywords for the locale.\n     *\n     * @return array Associative array with the extracted variants\n     *\n     * @see https://php.net/locale.getkeywords\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function getKeywords(string $locale)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns the primary language for the locale.\n     *\n     * @return string|null The extracted language code or null in case of error\n     *\n     * @see https://php.net/locale.getprimarylanguage\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function getPrimaryLanguage(string $locale)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns the region for the locale.\n     *\n     * @return string|null The extracted region code or null if not present\n     *\n     * @see https://php.net/locale.getregion\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function getRegion(string $locale)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns the script for the locale.\n     *\n     * @return string|null The extracted script code or null if not present\n     *\n     * @see https://php.net/locale.getscript\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function getScript(string $locale)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns the closest language tag for the locale.\n     *\n     * @see https://php.net/locale.lookup\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function lookup(array $languageTag, string $locale, bool $canonicalize = false, ?string $defaultLocale = null)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns an associative array of locale identifier subtags.\n     *\n     * @return array|null Associative array with the extracted subtags\n     *\n     * @see https://php.net/locale.parselocale\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function parseLocale(string $locale)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Sets the default runtime locale.\n     *\n     * @return bool true on success or false on failure\n     *\n     * @see https://php.net/locale.setdefault\n     *\n     * @throws MethodNotImplementedException\n     */\n    public static function setDefault(string $locale)\n    {\n        if ('en' !== $locale) {\n            throw new MethodNotImplementedException(__METHOD__);\n        }\n\n        return true;\n    }\n}\n"
        },
        {
          "name": "NumberFormatter.php",
          "type": "blob",
          "size": 28.328125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Intl\\Icu;\n\nuse Symfony\\Polyfill\\Intl\\Icu\\Exception\\MethodArgumentNotImplementedException;\nuse Symfony\\Polyfill\\Intl\\Icu\\Exception\\MethodArgumentValueNotImplementedException;\nuse Symfony\\Polyfill\\Intl\\Icu\\Exception\\MethodNotImplementedException;\nuse Symfony\\Polyfill\\Intl\\Icu\\Exception\\NotImplementedException;\n\n/**\n * Replacement for PHP's native {@link \\NumberFormatter} class.\n *\n * The only methods currently supported in this class are:\n *\n *  - {@link __construct}\n *  - {@link create}\n *  - {@link formatCurrency}\n *  - {@link format}\n *  - {@link getAttribute}\n *  - {@link getErrorCode}\n *  - {@link getErrorMessage}\n *  - {@link getLocale}\n *  - {@link parse}\n *  - {@link setAttribute}\n *\n * @author Eriksen Costa <eriksen.costa@infranology.com.br>\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @internal\n */\nabstract class NumberFormatter\n{\n    /* Format style constants */\n    public const PATTERN_DECIMAL = 0;\n    public const DECIMAL = 1;\n    public const CURRENCY = 2;\n    public const PERCENT = 3;\n    public const SCIENTIFIC = 4;\n    public const SPELLOUT = 5;\n    public const ORDINAL = 6;\n    public const DURATION = 7;\n    public const PATTERN_RULEBASED = 9;\n    public const IGNORE = 0;\n    public const DEFAULT_STYLE = 1;\n\n    /* Format type constants */\n    public const TYPE_DEFAULT = 0;\n    public const TYPE_INT32 = 1;\n    public const TYPE_INT64 = 2;\n    public const TYPE_DOUBLE = 3;\n    public const TYPE_CURRENCY = 4;\n\n    /* Numeric attribute constants */\n    public const PARSE_INT_ONLY = 0;\n    public const GROUPING_USED = 1;\n    public const DECIMAL_ALWAYS_SHOWN = 2;\n    public const MAX_INTEGER_DIGITS = 3;\n    public const MIN_INTEGER_DIGITS = 4;\n    public const INTEGER_DIGITS = 5;\n    public const MAX_FRACTION_DIGITS = 6;\n    public const MIN_FRACTION_DIGITS = 7;\n    public const FRACTION_DIGITS = 8;\n    public const MULTIPLIER = 9;\n    public const GROUPING_SIZE = 10;\n    public const ROUNDING_MODE = 11;\n    public const ROUNDING_INCREMENT = 12;\n    public const FORMAT_WIDTH = 13;\n    public const PADDING_POSITION = 14;\n    public const SECONDARY_GROUPING_SIZE = 15;\n    public const SIGNIFICANT_DIGITS_USED = 16;\n    public const MIN_SIGNIFICANT_DIGITS = 17;\n    public const MAX_SIGNIFICANT_DIGITS = 18;\n    public const LENIENT_PARSE = 19;\n\n    /* Text attribute constants */\n    public const POSITIVE_PREFIX = 0;\n    public const POSITIVE_SUFFIX = 1;\n    public const NEGATIVE_PREFIX = 2;\n    public const NEGATIVE_SUFFIX = 3;\n    public const PADDING_CHARACTER = 4;\n    public const CURRENCY_CODE = 5;\n    public const DEFAULT_RULESET = 6;\n    public const PUBLIC_RULESETS = 7;\n\n    /* Format symbol constants */\n    public const DECIMAL_SEPARATOR_SYMBOL = 0;\n    public const GROUPING_SEPARATOR_SYMBOL = 1;\n    public const PATTERN_SEPARATOR_SYMBOL = 2;\n    public const PERCENT_SYMBOL = 3;\n    public const ZERO_DIGIT_SYMBOL = 4;\n    public const DIGIT_SYMBOL = 5;\n    public const MINUS_SIGN_SYMBOL = 6;\n    public const PLUS_SIGN_SYMBOL = 7;\n    public const CURRENCY_SYMBOL = 8;\n    public const INTL_CURRENCY_SYMBOL = 9;\n    public const MONETARY_SEPARATOR_SYMBOL = 10;\n    public const EXPONENTIAL_SYMBOL = 11;\n    public const PERMILL_SYMBOL = 12;\n    public const PAD_ESCAPE_SYMBOL = 13;\n    public const INFINITY_SYMBOL = 14;\n    public const NAN_SYMBOL = 15;\n    public const SIGNIFICANT_DIGIT_SYMBOL = 16;\n    public const MONETARY_GROUPING_SEPARATOR_SYMBOL = 17;\n\n    /* Rounding mode values used by NumberFormatter::setAttribute() with NumberFormatter::ROUNDING_MODE attribute */\n    public const ROUND_CEILING = 0;\n    public const ROUND_FLOOR = 1;\n    public const ROUND_DOWN = 2;\n    public const ROUND_UP = 3;\n    public const ROUND_HALFEVEN = 4;\n    public const ROUND_HALFDOWN = 5;\n    public const ROUND_HALFUP = 6;\n\n    /* Pad position values used by NumberFormatter::setAttribute() with NumberFormatter::PADDING_POSITION attribute */\n    public const PAD_BEFORE_PREFIX = 0;\n    public const PAD_AFTER_PREFIX = 1;\n    public const PAD_BEFORE_SUFFIX = 2;\n    public const PAD_AFTER_SUFFIX = 3;\n\n    /**\n     * The error code from the last operation.\n     *\n     * @var int\n     */\n    protected $errorCode = Icu::U_ZERO_ERROR;\n\n    /**\n     * The error message from the last operation.\n     *\n     * @var string\n     */\n    protected $errorMessage = 'U_ZERO_ERROR';\n\n    /**\n     * @var int\n     */\n    private $style;\n\n    /**\n     * Default values for the en locale.\n     */\n    private $attributes = [\n        self::FRACTION_DIGITS => 0,\n        self::GROUPING_USED => 1,\n        self::ROUNDING_MODE => self::ROUND_HALFEVEN,\n    ];\n\n    /**\n     * Holds the initialized attributes code.\n     */\n    private $initializedAttributes = [];\n\n    /**\n     * The supported styles to the constructor $styles argument.\n     */\n    private static $supportedStyles = [\n        'CURRENCY' => self::CURRENCY,\n        'DECIMAL' => self::DECIMAL,\n    ];\n\n    /**\n     * Supported attributes to the setAttribute() $attr argument.\n     */\n    private static $supportedAttributes = [\n        'FRACTION_DIGITS' => self::FRACTION_DIGITS,\n        'GROUPING_USED' => self::GROUPING_USED,\n        'ROUNDING_MODE' => self::ROUNDING_MODE,\n    ];\n\n    /**\n     * The available rounding modes for setAttribute() usage with\n     * NumberFormatter::ROUNDING_MODE. NumberFormatter::ROUND_DOWN\n     * and NumberFormatter::ROUND_UP does not have a PHP only equivalent.\n     */\n    private static $roundingModes = [\n        'ROUND_HALFEVEN' => self::ROUND_HALFEVEN,\n        'ROUND_HALFDOWN' => self::ROUND_HALFDOWN,\n        'ROUND_HALFUP' => self::ROUND_HALFUP,\n        'ROUND_CEILING' => self::ROUND_CEILING,\n        'ROUND_FLOOR' => self::ROUND_FLOOR,\n        'ROUND_DOWN' => self::ROUND_DOWN,\n        'ROUND_UP' => self::ROUND_UP,\n    ];\n\n    /**\n     * The mapping between NumberFormatter rounding modes to the available\n     * modes in PHP's round() function.\n     *\n     * @see https://php.net/round\n     */\n    private static $phpRoundingMap = [\n        self::ROUND_HALFDOWN => \\PHP_ROUND_HALF_DOWN,\n        self::ROUND_HALFEVEN => \\PHP_ROUND_HALF_EVEN,\n        self::ROUND_HALFUP => \\PHP_ROUND_HALF_UP,\n    ];\n\n    /**\n     * The list of supported rounding modes which aren't available modes in\n     * PHP's round() function, but there's an equivalent. Keys are rounding\n     * modes, values does not matter.\n     */\n    private static $customRoundingList = [\n        self::ROUND_CEILING => true,\n        self::ROUND_FLOOR => true,\n        self::ROUND_DOWN => true,\n        self::ROUND_UP => true,\n    ];\n\n    /**\n     * The maximum value of the integer type in 32 bit platforms.\n     */\n    private static $int32Max = 2147483647;\n\n    /**\n     * The maximum value of the integer type in 64 bit platforms.\n     *\n     * @var int|float\n     */\n    private static $int64Max = 9223372036854775807;\n\n    private static $enSymbols = [\n        self::DECIMAL => ['.', ',', ';', '%', '0', '#', '-', '+', '¤', '¤¤', '.', 'E', '‰', '*', '∞', 'NaN', '@', ','],\n        self::CURRENCY => ['.', ',', ';', '%', '0', '#', '-', '+', '¤', '¤¤', '.', 'E', '‰', '*', '∞', 'NaN', '@', ','],\n    ];\n\n    private static $enTextAttributes = [\n        self::DECIMAL => ['', '', '-', '', ' ', 'XXX', ''],\n        self::CURRENCY => ['¤', '', '-¤', '', ' ', 'XXX'],\n    ];\n\n    /**\n     * @param string|null $locale  The locale code. The only currently supported locale is \"en\" (or null using the default locale, i.e. \"en\")\n     * @param int         $style   Style of the formatting, one of the format style constants.\n     *                             The only supported styles are NumberFormatter::DECIMAL\n     *                             and NumberFormatter::CURRENCY.\n     * @param string      $pattern Not supported. A pattern string in case $style is NumberFormat::PATTERN_DECIMAL or\n     *                             NumberFormat::PATTERN_RULEBASED. It must conform to  the syntax\n     *                             described in the ICU DecimalFormat or ICU RuleBasedNumberFormat documentation\n     *\n     * @see https://php.net/numberformatter.create\n     * @see https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1DecimalFormat.html#details\n     * @see https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1RuleBasedNumberFormat.html#details\n     *\n     * @throws MethodArgumentValueNotImplementedException When $locale different than \"en\" or null is passed\n     * @throws MethodArgumentValueNotImplementedException When the $style is not supported\n     * @throws MethodArgumentNotImplementedException      When the pattern value is different than null\n     */\n    public function __construct(?string $locale = 'en', ?int $style = null, ?string $pattern = null)\n    {\n        if ('en' !== $locale && null !== $locale) {\n            throw new MethodArgumentValueNotImplementedException(__METHOD__, 'locale', $locale, 'Only the locale \"en\" is supported');\n        }\n\n        if (!\\in_array($style, self::$supportedStyles)) {\n            $message = sprintf('The available styles are: %s.', implode(', ', array_keys(self::$supportedStyles)));\n            throw new MethodArgumentValueNotImplementedException(__METHOD__, 'style', $style, $message);\n        }\n\n        if (null !== $pattern) {\n            throw new MethodArgumentNotImplementedException(__METHOD__, 'pattern');\n        }\n\n        $this->style = $style;\n    }\n\n    /**\n     * Static constructor.\n     *\n     * @param string|null $locale  The locale code. The only supported locale is \"en\" (or null using the default locale, i.e. \"en\")\n     * @param int         $style   Style of the formatting, one of the format style constants.\n     *                             The only currently supported styles are NumberFormatter::DECIMAL\n     *                             and NumberFormatter::CURRENCY.\n     * @param string      $pattern Not supported. A pattern string in case $style is NumberFormat::PATTERN_DECIMAL or\n     *                             NumberFormat::PATTERN_RULEBASED. It must conform to  the syntax\n     *                             described in the ICU DecimalFormat or ICU RuleBasedNumberFormat documentation\n     *\n     * @return static\n     *\n     * @see https://php.net/numberformatter.create\n     * @see http://www.icu-project.org/apiref/icu4c/classDecimalFormat.html#_details\n     * @see http://www.icu-project.org/apiref/icu4c/classRuleBasedNumberFormat.html#_details\n     *\n     * @throws MethodArgumentValueNotImplementedException When $locale different than \"en\" or null is passed\n     * @throws MethodArgumentValueNotImplementedException When the $style is not supported\n     * @throws MethodArgumentNotImplementedException      When the pattern value is different than null\n     */\n    public static function create(?string $locale = 'en', ?int $style = null, ?string $pattern = null)\n    {\n        return new static($locale, $style, $pattern);\n    }\n\n    /**\n     * Format a currency value.\n     *\n     * @return string The formatted currency value\n     *\n     * @see https://php.net/numberformatter.formatcurrency\n     * @see https://en.wikipedia.org/wiki/ISO_4217#Active_codes\n     */\n    public function formatCurrency(float $amount, string $currency)\n    {\n        if (self::DECIMAL === $this->style) {\n            return $this->format($amount);\n        }\n\n        if (null === $symbol = Currencies::getSymbol($currency)) {\n            return false;\n        }\n        $fractionDigits = Currencies::getFractionDigits($currency);\n\n        $amount = $this->roundCurrency($amount, $currency);\n\n        $negative = false;\n        if (0 > $amount) {\n            $negative = true;\n            $amount *= -1;\n        }\n\n        $amount = $this->formatNumber($amount, $fractionDigits);\n\n        // There's a non-breaking space after the currency code (i.e. CRC 100), but not if the currency has a symbol (i.e. £100).\n        $ret = $symbol.(mb_strlen($symbol, 'UTF-8') > 2 ? \"\\xc2\\xa0\" : '').$amount;\n\n        return $negative ? '-'.$ret : $ret;\n    }\n\n    /**\n     * Format a number.\n     *\n     * @param int|float $num  The value to format\n     * @param int       $type Type of the formatting, one of the format type constants.\n     *                        Only type NumberFormatter::TYPE_DEFAULT is currently supported.\n     *\n     * @return bool|string The formatted value or false on error\n     *\n     * @see https://php.net/numberformatter.format\n     *\n     * @throws NotImplementedException                    If the method is called with the class $style 'CURRENCY'\n     * @throws MethodArgumentValueNotImplementedException If the $type is different than TYPE_DEFAULT\n     */\n    public function format($num, int $type = self::TYPE_DEFAULT)\n    {\n        // The original NumberFormatter does not support this format type\n        if (self::TYPE_CURRENCY === $type) {\n            if (\\PHP_VERSION_ID >= 80000) {\n                throw new \\ValueError(sprintf('The format type must be a NumberFormatter::TYPE_* constant (%s given).', $type));\n            }\n\n            trigger_error(__METHOD__.'(): Unsupported format type '.$type, \\E_USER_WARNING);\n\n            return false;\n        }\n\n        if (self::CURRENCY === $this->style) {\n            throw new NotImplementedException(sprintf('\"%s()\" method does not support the formatting of currencies (instance with CURRENCY style). \"%s\".', __METHOD__, NotImplementedException::INTL_INSTALL_MESSAGE));\n        }\n\n        // Only the default type is supported.\n        if (self::TYPE_DEFAULT !== $type) {\n            throw new MethodArgumentValueNotImplementedException(__METHOD__, 'type', $type, 'Only TYPE_DEFAULT is supported');\n        }\n\n        $fractionDigits = $this->getAttribute(self::FRACTION_DIGITS);\n\n        $num = $this->round($num, $fractionDigits);\n        $num = $this->formatNumber($num, $fractionDigits);\n\n        // behave like the intl extension\n        $this->resetError();\n\n        return $num;\n    }\n\n    /**\n     * Returns an attribute value.\n     *\n     * @return int|false The attribute value on success or false on error\n     *\n     * @see https://php.net/numberformatter.getattribute\n     */\n    public function getAttribute(int $attribute)\n    {\n        return $this->attributes[$attribute] ?? null;\n    }\n\n    /**\n     * Returns formatter's last error code. Always returns the U_ZERO_ERROR class constant value.\n     *\n     * @return int The error code from last formatter call\n     *\n     * @see https://php.net/numberformatter.geterrorcode\n     */\n    public function getErrorCode()\n    {\n        return $this->errorCode;\n    }\n\n    /**\n     * Returns formatter's last error message. Always returns the U_ZERO_ERROR_MESSAGE class constant value.\n     *\n     * @return string The error message from last formatter call\n     *\n     * @see https://php.net/numberformatter.geterrormessage\n     */\n    public function getErrorMessage()\n    {\n        return $this->errorMessage;\n    }\n\n    /**\n     * Returns the formatter's locale.\n     *\n     * The parameter $type is currently ignored.\n     *\n     * @param int $type Not supported. The locale name type to return (Locale::VALID_LOCALE or Locale::ACTUAL_LOCALE)\n     *\n     * @return string The locale used to create the formatter. Currently always\n     *                returns \"en\".\n     *\n     * @see https://php.net/numberformatter.getlocale\n     */\n    public function getLocale(int $type = Locale::ACTUAL_LOCALE)\n    {\n        return 'en';\n    }\n\n    /**\n     * Not supported. Returns the formatter's pattern.\n     *\n     * @return string|false The pattern string used by the formatter or false on error\n     *\n     * @see https://php.net/numberformatter.getpattern\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function getPattern()\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Returns a formatter symbol value.\n     *\n     * @return string|false The symbol value or false on error\n     *\n     * @see https://php.net/numberformatter.getsymbol\n     */\n    public function getSymbol(int $symbol)\n    {\n        return \\array_key_exists($this->style, self::$enSymbols) && \\array_key_exists($symbol, self::$enSymbols[$this->style]) ? self::$enSymbols[$this->style][$symbol] : false;\n    }\n\n    /**\n     * Not supported. Returns a formatter text attribute value.\n     *\n     * @return string|false The attribute value or false on error\n     *\n     * @see https://php.net/numberformatter.gettextattribute\n     */\n    public function getTextAttribute(int $attribute)\n    {\n        return \\array_key_exists($this->style, self::$enTextAttributes) && \\array_key_exists($attribute, self::$enTextAttributes[$this->style]) ? self::$enTextAttributes[$this->style][$attribute] : false;\n    }\n\n    /**\n     * Not supported. Parse a currency number.\n     *\n     * @return float|false The parsed numeric value or false on error\n     *\n     * @see https://php.net/numberformatter.parsecurrency\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function parseCurrency(string $string, &$currency, &$offset = null)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Parse a number.\n     *\n     * @return int|float|false The parsed value or false on error\n     *\n     * @see https://php.net/numberformatter.parse\n     */\n    public function parse(string $string, int $type = self::TYPE_DOUBLE, &$offset = null)\n    {\n        if (self::TYPE_DEFAULT === $type || self::TYPE_CURRENCY === $type) {\n            if (\\PHP_VERSION_ID >= 80000) {\n                throw new \\ValueError(sprintf('The format type must be a NumberFormatter::TYPE_* constant (%d given).', $type));\n            }\n\n            trigger_error(__METHOD__.'(): Unsupported format type '.$type, \\E_USER_WARNING);\n\n            return false;\n        }\n\n        // Any invalid number at the end of the string is removed.\n        // Only numbers and the fraction separator is expected in the string.\n        // If grouping is used, grouping separator also becomes a valid character.\n        $groupingMatch = $this->getAttribute(self::GROUPING_USED) ? '|(?P<grouping>\\d++(,{1}\\d+)++(\\.\\d*+)?)' : '';\n        if (preg_match(\"/^-?(?:\\.\\d++{$groupingMatch}|\\d++(\\.\\d*+)?)/\", $string, $matches)) {\n            $string = $matches[0];\n            $offset = \\strlen($string);\n            // value is not valid if grouping is used, but digits are not grouped in groups of three\n            if ($error = isset($matches['grouping']) && !preg_match('/^-?(?:\\d{1,3}+)?(?:(?:,\\d{3})++|\\d*+)(?:\\.\\d*+)?$/', $string)) {\n                // the position on error is 0 for positive and 1 for negative numbers\n                $offset = 0 === strpos($string, '-') ? 1 : 0;\n            }\n        } else {\n            $error = true;\n            $offset = 0;\n        }\n\n        if ($error) {\n            Icu::setError(Icu::U_PARSE_ERROR, 'Number parsing failed');\n            $this->errorCode = Icu::getErrorCode();\n            $this->errorMessage = Icu::getErrorMessage();\n\n            return false;\n        }\n\n        $string = str_replace(',', '', $string);\n        $string = $this->convertValueDataType($string, $type);\n\n        // behave like the intl extension\n        $this->resetError();\n\n        return $string;\n    }\n\n    /**\n     * Set an attribute.\n     *\n     * @param int|float $value\n     *\n     * @return bool true on success or false on failure\n     *\n     * @see https://php.net/numberformatter.setattribute\n     *\n     * @throws MethodArgumentValueNotImplementedException When the $attribute is not supported\n     * @throws MethodArgumentValueNotImplementedException When the $value is not supported\n     */\n    public function setAttribute(int $attribute, $value)\n    {\n        if (!\\in_array($attribute, self::$supportedAttributes)) {\n            $message = sprintf(\n                'The available attributes are: %s',\n                implode(', ', array_keys(self::$supportedAttributes))\n            );\n\n            throw new MethodArgumentValueNotImplementedException(__METHOD__, 'attribute', $value, $message);\n        }\n\n        if (self::$supportedAttributes['ROUNDING_MODE'] === $attribute && $this->isInvalidRoundingMode($value)) {\n            $message = sprintf(\n                'The supported values for ROUNDING_MODE are: %s',\n                implode(', ', array_keys(self::$roundingModes))\n            );\n\n            throw new MethodArgumentValueNotImplementedException(__METHOD__, 'attribute', $value, $message);\n        }\n\n        if (self::$supportedAttributes['GROUPING_USED'] === $attribute) {\n            $value = $this->normalizeGroupingUsedValue($value);\n        }\n\n        if (self::$supportedAttributes['FRACTION_DIGITS'] === $attribute) {\n            $value = $this->normalizeFractionDigitsValue($value);\n            if ($value < 0) {\n                // ignore negative values but do not raise an error\n                return true;\n            }\n        }\n\n        $this->attributes[$attribute] = $value;\n        $this->initializedAttributes[$attribute] = true;\n\n        return true;\n    }\n\n    /**\n     * Not supported. Set the formatter's pattern.\n     *\n     * @return bool true on success or false on failure\n     *\n     * @see https://php.net/numberformatter.setpattern\n     * @see http://www.icu-project.org/apiref/icu4c/classDecimalFormat.html#_details\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function setPattern(string $pattern)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Set the formatter's symbol.\n     *\n     * @return bool true on success or false on failure\n     *\n     * @see https://php.net/numberformatter.setsymbol\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function setSymbol(int $symbol, string $value)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Not supported. Set a text attribute.\n     *\n     * @return bool true on success or false on failure\n     *\n     * @see https://php.net/numberformatter.settextattribute\n     *\n     * @throws MethodNotImplementedException\n     */\n    public function setTextAttribute(int $attribute, string $value)\n    {\n        throw new MethodNotImplementedException(__METHOD__);\n    }\n\n    /**\n     * Set the error to the default U_ZERO_ERROR.\n     */\n    protected function resetError()\n    {\n        Icu::setError(Icu::U_ZERO_ERROR);\n        $this->errorCode = Icu::getErrorCode();\n        $this->errorMessage = Icu::getErrorMessage();\n    }\n\n    /**\n     * Rounds a currency value, applying increment rounding if applicable.\n     *\n     * When a currency have a rounding increment, an extra round is made after the first one. The rounding factor is\n     * determined in the ICU data and is explained as of:\n     *\n     * \"the rounding increment is given in units of 10^(-fraction_digits)\"\n     *\n     * The only actual rounding data as of this writing, is CHF.\n     *\n     * @see http://en.wikipedia.org/wiki/Swedish_rounding\n     * @see http://www.docjar.com/html/api/com/ibm/icu/util/Currency.java.html#1007\n     */\n    private function roundCurrency(float $value, string $currency): float\n    {\n        $fractionDigits = Currencies::getFractionDigits($currency);\n        $roundingIncrement = Currencies::getRoundingIncrement($currency);\n\n        // Round with the formatter rounding mode\n        $value = $this->round($value, $fractionDigits);\n\n        // Swiss rounding\n        if (0 < $roundingIncrement && 0 < $fractionDigits) {\n            $roundingFactor = $roundingIncrement / 10 ** $fractionDigits;\n            $value = round($value / $roundingFactor) * $roundingFactor;\n        }\n\n        return $value;\n    }\n\n    /**\n     * Rounds a value.\n     *\n     * @param int|float $value The value to round\n     *\n     * @return int|float The rounded value\n     */\n    private function round($value, int $precision)\n    {\n        $precision = $this->getUninitializedPrecision($value, $precision);\n\n        $roundingModeAttribute = $this->getAttribute(self::ROUNDING_MODE);\n        if (isset(self::$phpRoundingMap[$roundingModeAttribute])) {\n            $value = round($value, $precision, self::$phpRoundingMap[$roundingModeAttribute]);\n        } elseif (isset(self::$customRoundingList[$roundingModeAttribute])) {\n            $roundingCoef = 10 ** $precision;\n            $value *= $roundingCoef;\n            $value = (float) (string) $value;\n\n            switch ($roundingModeAttribute) {\n                case self::ROUND_CEILING:\n                    $value = ceil($value);\n                    break;\n                case self::ROUND_FLOOR:\n                    $value = floor($value);\n                    break;\n                case self::ROUND_UP:\n                    $value = $value > 0 ? ceil($value) : floor($value);\n                    break;\n                case self::ROUND_DOWN:\n                    $value = $value > 0 ? floor($value) : ceil($value);\n                    break;\n            }\n\n            $value /= $roundingCoef;\n        }\n\n        return $value;\n    }\n\n    /**\n     * Formats a number.\n     *\n     * @param int|float $value The numeric value to format\n     */\n    private function formatNumber($value, int $precision): string\n    {\n        $precision = $this->getUninitializedPrecision($value, $precision);\n\n        return number_format($value, $precision, '.', $this->getAttribute(self::GROUPING_USED) ? ',' : '');\n    }\n\n    /**\n     * Returns the precision value if the DECIMAL style is being used and the FRACTION_DIGITS attribute is uninitialized.\n     *\n     * @param int|float $value The value to get the precision from if the FRACTION_DIGITS attribute is uninitialized\n     */\n    private function getUninitializedPrecision($value, int $precision): int\n    {\n        if (self::CURRENCY === $this->style) {\n            return $precision;\n        }\n\n        if (!$this->isInitializedAttribute(self::FRACTION_DIGITS)) {\n            preg_match('/.*\\.(.*)/', (string) $value, $digits);\n            if (isset($digits[1])) {\n                $precision = \\strlen($digits[1]);\n            }\n        }\n\n        return $precision;\n    }\n\n    /**\n     * Check if the attribute is initialized (value set by client code).\n     */\n    private function isInitializedAttribute(string $attr): bool\n    {\n        return isset($this->initializedAttributes[$attr]);\n    }\n\n    /**\n     * Returns the numeric value using the $type to convert to the right data type.\n     *\n     * @param mixed $value The value to be converted\n     *\n     * @return int|float|false The converted value\n     */\n    private function convertValueDataType($value, int $type)\n    {\n        if (self::TYPE_DOUBLE === $type) {\n            $value = (float) $value;\n        } elseif (self::TYPE_INT32 === $type) {\n            $value = $this->getInt32Value($value);\n        } elseif (self::TYPE_INT64 === $type) {\n            $value = $this->getInt64Value($value);\n        }\n\n        return $value;\n    }\n\n    /**\n     * Convert the value data type to int or returns false if the value is out of the integer value range.\n     *\n     * @return int|false The converted value\n     */\n    private function getInt32Value($value)\n    {\n        if ($value > self::$int32Max || $value < -self::$int32Max - 1) {\n            return false;\n        }\n\n        return (int) $value;\n    }\n\n    /**\n     * Convert the value data type to int or returns false if the value is out of the integer value range.\n     *\n     * @return int|float|false The converted value\n     */\n    private function getInt64Value($value)\n    {\n        if ($value > self::$int64Max || $value < -self::$int64Max - 1) {\n            return false;\n        }\n\n        if (\\PHP_INT_SIZE !== 8 && ($value > self::$int32Max || $value < -self::$int32Max - 1)) {\n            return (float) $value;\n        }\n\n        return (int) $value;\n    }\n\n    /**\n     * Check if the rounding mode is invalid.\n     */\n    private function isInvalidRoundingMode(int $value): bool\n    {\n        if (\\in_array($value, self::$roundingModes, true)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the normalized value for the GROUPING_USED attribute. Any value that can be converted to int will be\n     * cast to Boolean and then to int again. This way, negative values are converted to 1 and string values to 0.\n     */\n    private function normalizeGroupingUsedValue($value): int\n    {\n        return (int) (bool) (int) $value;\n    }\n\n    /**\n     * Returns the normalized value for the FRACTION_DIGITS attribute.\n     */\n    private function normalizeFractionDigitsValue($value): int\n    {\n        return (int) $value;\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.83203125,
          "content": "Symfony Polyfill / Intl: ICU\n============================\n\nThis package provides fallback implementations when the\n[Intl](https://php.net/intl) extension is not installed.\nIt is limited to the \"en\" locale and to:\n\n- [`intl_is_failure()`](https://php.net/intl-is-failure)\n- [`intl_get_error_code()`](https://php.net/intl-get-error-code)\n- [`intl_get_error_message()`](https://php.net/intl-get-error-message)\n- [`intl_error_name()`](https://php.net/intl-error-name)\n- [`Collator`](https://php.net/Collator)\n- [`NumberFormatter`](https://php.net/NumberFormatter)\n- [`Locale`](https://php.net/Locale)\n- [`IntlDateFormatter`](https://php.net/IntlDateFormatter)\n\nMore information can be found in the\n[main Polyfill README](https://github.com/symfony/polyfill/blob/main/README.md).\n\nLicense\n=======\n\nThis library is released under the [MIT license](LICENSE).\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "bootstrap.php",
          "type": "blob",
          "size": 0.884765625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Intl\\Icu as p;\n\nif (extension_loaded('intl')) {\n    return;\n}\n\nif (\\PHP_VERSION_ID >= 80000) {\n    return require __DIR__.'/bootstrap80.php';\n}\n\nif (!function_exists('intl_is_failure')) {\n    function intl_is_failure($errorCode) { return p\\Icu::isFailure($errorCode); }\n}\nif (!function_exists('intl_get_error_code')) {\n    function intl_get_error_code() { return p\\Icu::getErrorCode(); }\n}\nif (!function_exists('intl_get_error_message')) {\n    function intl_get_error_message() { return p\\Icu::getErrorMessage(); }\n}\nif (!function_exists('intl_error_name')) {\n    function intl_error_name($errorCode) { return p\\Icu::getErrorName($errorCode); }\n}\n"
        },
        {
          "name": "bootstrap80.php",
          "type": "blob",
          "size": 0.806640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Intl\\Icu as p;\n\nif (!function_exists('intl_is_failure')) {\n    function intl_is_failure(?int $errorCode): bool { return p\\Icu::isFailure((int) $errorCode); }\n}\nif (!function_exists('intl_get_error_code')) {\n    function intl_get_error_code(): int { return p\\Icu::getErrorCode(); }\n}\nif (!function_exists('intl_get_error_message')) {\n    function intl_get_error_message(): string { return p\\Icu::getErrorMessage(); }\n}\nif (!function_exists('intl_error_name')) {\n    function intl_error_name(?int $errorCode): string { return p\\Icu::getErrorName((int) $errorCode); }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.0712890625,
          "content": "{\n    \"name\": \"symfony/polyfill-intl-icu\",\n    \"type\": \"library\",\n    \"description\": \"Symfony polyfill for intl's ICU-related data and classes\",\n    \"keywords\": [\"polyfill\", \"shim\", \"compatibility\", \"portable\", \"intl\", \"icu\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Nicolas Grekas\",\n            \"email\": \"p@tchwork.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=7.2\"\n    },\n    \"autoload\": {\n        \"files\": [ \"bootstrap.php\" ],\n        \"psr-4\": { \"Symfony\\\\Polyfill\\\\Intl\\\\Icu\\\\\": \"\" },\n        \"classmap\": [ \"Resources/stubs\" ],\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"suggest\": {\n        \"ext-intl\": \"For best performance and support of other locales than \\\"en\\\"\"\n    },\n    \"minimum-stability\": \"dev\",\n    \"extra\": {\n        \"thanks\": {\n            \"name\": \"symfony/polyfill\",\n            \"url\": \"https://github.com/symfony/polyfill\"\n        }\n    }\n}\n"
        }
      ]
    }
  ]
}