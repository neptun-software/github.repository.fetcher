{
  "metadata": {
    "timestamp": 1736712223968,
    "page": 944,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "segmentfault/HyperDown",
      "stars": 1206,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2763671875,
          "content": "*.swp\n.*.swp\n.*.swo\n._*\n.DS_Store\n/Debug/\n/ImgCache/\n/Backup_rar/\n/Debug/\n/debug/\n/upload/\n/avatar/\n/.idea/\n/.vagrant/\nnode_modules\nVagrantfile\n*.orig\n*.aps\n*.APS\n*.chm\n*.exp\n*.pdb\n*.rar\n.smbdelete*\n*.sublime*\n.sass-cache\nconfig.rb\nconfig.codekit\nnpm-debug.log\n*.log\n*.iml\n\n/vendor/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.51171875,
          "content": "Software License Agreement (BSD License)\n\nCopyright (c) 2015, SegmentFault\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this \n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution.\n\n* Neither the name of schillmania.com nor the names of its contributors may be\n  used to endorse or promote products derived from this software without\n  specific prior written permission from schillmania.com.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Parser.php",
          "type": "blob",
          "size": 47.58984375,
          "content": "<?php\n\nnamespace HyperDown;\n\n/**\n * Parser\n *\n * @copyright Copyright (c) 2012 SegmentFault Team. (http://segmentfault.com)\n * @author Joyqi <joyqi@segmentfault.com>\n * @license BSD License\n */\nclass Parser\n{\n    /**\n     * _whiteList\n     *\n     * @var string\n     */\n    private $_commonWhiteList = 'kbd|b|i|strong|em|sup|sub|br|code|del|a|hr|small';\n\n    /**\n     * html tags\n     *\n     * @var string\n     */\n    private $_blockHtmlTags = 'p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|address|form|fieldset|iframe|hr|legend|article|section|nav|aside|hgroup|header|footer|figcaption|svg|script|noscript';\n\n    /**\n     * _specialWhiteList\n     *\n     * @var mixed\n     * @access private\n     */\n    private $_specialWhiteList = array(\n        'table'  =>  'table|tbody|thead|tfoot|tr|td|th'\n    );\n\n    /**\n     * _footnotes\n     *\n     * @var array\n     */\n    private $_footnotes;\n\n    /**\n     * @var bool\n     */\n    private $_html = false;\n\n    /**\n     * @var bool\n     */\n    private $_line = false;\n\n    /**\n     * @var array\n     */\n    private $blockParsers = array(\n        array('code', 10),\n        array('shtml', 20),\n        array('pre', 30),\n        array('ahtml', 40),\n        array('shr', 50),\n        array('list', 60),\n        array('math', 70),\n        array('html', 80),\n        array('footnote', 90),\n        array('definition', 100),\n        array('quote', 110),\n        array('table', 120),\n        array('sh', 130),\n        array('mh', 140),\n        array('dhr', 150),\n        array('default', 9999)\n    );\n\n    /**\n     * _blocks\n     *\n     * @var array\n     */\n    private $_blocks;\n\n    /**\n     * _current\n     *\n     * @var string\n     */\n    private $_current;\n\n    /**\n     * _pos\n     *\n     * @var int\n     */\n    private $_pos;\n\n    /**\n     * _definitions\n     *\n     * @var array\n     */\n    private $_definitions;\n\n    /**\n     * @var array\n     */\n    private $_hooks = array();\n\n    /**\n     * @var array\n     */\n    private $_holders;\n\n    /**\n     * @var string\n     */\n    private $_uniqid;\n\n    /**\n     * @var int\n     */\n    private $_id;\n\n    /**\n     * @var array\n     */\n    private $_parsers = array();\n\n    /**\n     * makeHtml\n     *\n     * @param mixed $text\n     * @return string\n     */\n    public function makeHtml($text)\n    {\n        $this->_footnotes = array();\n        $this->_definitions = array();\n        $this->_holders = array();\n        $this->_uniqid = md5(uniqid());\n        $this->_id = 0;\n\n        usort($this->blockParsers, function ($a, $b) {\n            return $a[1] < $b[1] ? -1 : 1;\n        });\n\n        foreach ($this->blockParsers as $parser) {\n            list($name) = $parser;\n\n            if (isset($parser[2])) {\n                $this->_parsers[$name] = $parser[2];\n            } else {\n                $this->_parsers[$name] = array($this, 'parseBlock' . ucfirst($name));\n            }\n        }\n\n        $text = $this->initText($text);\n        $html = $this->parse($text);\n        $html = $this->makeFootnotes($html);\n        $html = $this->optimizeLines($html);\n\n        return $this->call('makeHtml', $html);\n    }\n\n    /**\n     * @param $html\n     */\n    public function enableHtml($html = true)\n    {\n        $this->_html = $html;\n    }\n\n    /**\n     * @param bool $line\n     */\n    public function enableLine($line = true)\n    {\n        $this->_line = $line;\n    }\n\n    /**\n     * @param $type\n     * @param $callback\n     */\n    public function hook($type, $callback)\n    {\n        $this->_hooks[$type][] = $callback;\n    }\n\n    /**\n     * @param $str\n     * @return string\n     */\n    public function makeHolder($str)\n    {\n        $key = \"\\r\" . $this->_uniqid . $this->_id . \"\\r\";\n        $this->_id ++;\n        $this->_holders[$key] = $str;\n\n        return $key;\n    }\n\n    /**\n     * @param $text\n     * @return mixed\n     */\n    private function initText($text)\n    {\n        $text = str_replace(array(\"\\t\", \"\\r\"),  array('    ', ''),  $text);\n        return $text;\n    }\n\n    /**\n     * @param $html\n     * @return string\n     */\n    private function makeFootnotes($html)\n    {\n        if (count($this->_footnotes) > 0) {\n            $html .= '<div class=\"footnotes\"><hr><ol>';\n            $index = 1;\n\n            while ($val = array_shift($this->_footnotes)) {\n                if (is_string($val)) {\n                    $val .= \" <a href=\\\"#fnref-{$index}\\\" class=\\\"footnote-backref\\\">&#8617;</a>\";\n                } else {\n                    $val[count($val) - 1] .= \" <a href=\\\"#fnref-{$index}\\\" class=\\\"footnote-backref\\\">&#8617;</a>\";\n                    $val = count($val) > 1 ? $this->parse(implode(\"\\n\", $val)) : $this->parseInline($val[0]);\n                }\n\n                $html .= \"<li id=\\\"fn-{$index}\\\">{$val}</li>\";\n                $index ++;\n            }\n\n            $html .= '</ol></div>';\n        }\n\n        return $html;\n    }\n\n    /**\n     * parse\n     *\n     * @param string $text\n     * @param bool $inline\n     * @param int $offset\n     * @return string\n     */\n    private function parse($text, $inline = false, $offset = 0)\n    {\n        $blocks = $this->parseBlock($text, $lines);\n        $html = '';\n\n        // inline mode for single normal block\n        if ($inline && count($blocks) == 1 && $blocks[0][0] == 'normal') {\n            $blocks[0][3] = true;\n        }\n\n        foreach ($blocks as $block) {\n            list($type, $start, $end, $value) = $block;\n            $extract = array_slice($lines, $start, $end - $start + 1);\n            $method = 'parse' . ucfirst($type);\n\n            $extract = $this->call('before' . ucfirst($method), $extract, $value);\n            $result = $this->{$method}($extract, $value, $start + $offset, $end + $offset);\n            $result = $this->call('after' . ucfirst($method), $result, $value);\n\n            $html .= $result;\n        }\n\n        return $html;\n    }\n\n    /**\n     * @param $text\n     * @param $clearHolders\n     * @return string\n     */\n    private function releaseHolder($text, $clearHolders = true)\n    {\n        $deep = 0;\n        while (strpos($text, \"\\r\") !== false && $deep < 10) {\n            $text = str_replace(array_keys($this->_holders), array_values($this->_holders), $text);\n            $deep ++;\n        }\n\n        if ($clearHolders) {\n            $this->_holders = array();\n        }\n\n        return $text;\n    }\n\n    /**\n     * @param $start\n     * @param int $end\n     * @return string\n     */\n    private function markLine($start, $end = -1)\n    {\n        if ($this->_line) {\n            $end = $end < 0 ? $start : $end;\n            return '<span class=\"line\" data-start=\"' . $start\n                . '\" data-end=\"' . $end . '\" data-id=\"' . $this->_uniqid . '\"></span>';\n        }\n\n        return '';\n    }\n\n    /**\n     * @param array $lines\n     * @param $start\n     * @return string[]\n     */\n    private function markLines(array $lines, $start)\n    {\n        $i = -1;\n\n        return $this->_line ? array_map(function ($line) use ($start, &$i) {\n            $i ++;\n            return $this->markLine($start + $i) . $line;\n        }, $lines) : $lines;\n    }\n\n    /**\n     * @param $html\n     * @return string\n     */\n    private function optimizeLines($html)\n    {\n        $last = 0;\n\n        return $this->_line ?\n            preg_replace_callback(\"/class=\\\"line\\\" data\\-start=\\\"([0-9]+)\\\" data\\-end=\\\"([0-9]+)\\\" (data\\-id=\\\"{$this->_uniqid}\\\")/\",\n                function ($matches) use (&$last) {\n                    if ($matches[1] != $last) {\n                        $replace = 'class=\"line\" data-start=\"' . $last . '\" data-start-original=\"' . $matches[1] . '\" data-end=\"' . $matches[2] . '\" ' . $matches[3];\n                    } else {\n                        $replace = $matches[0];\n                    }\n\n                    $last = $matches[2] + 1;\n                    return $replace;\n                }, $html) : $html;\n    }\n\n    /**\n     * @param $type\n     * @param $value\n     * @return mixed\n     */\n    private function call($type, $value)\n    {\n        if (empty($this->_hooks[$type])) {\n            return $value;\n        }\n\n        $args = func_get_args();\n        $args = array_slice($args, 1);\n\n        foreach ($this->_hooks[$type] as $callback) {\n            $value = call_user_func_array($callback, $args);\n            $args[0] = $value;\n        }\n\n        return $value;\n    }\n\n    /**\n     * parseInline\n     *\n     * @param string $text\n     * @param string $whiteList\n     * @param bool $clearHolders\n     * @param bool $enableAutoLink\n     * @return string\n     */\n    private function parseInline($text, $whiteList = '', $clearHolders = true, $enableAutoLink = true)\n    {\n        $text = $this->call('beforeParseInline', $text);\n\n        // code\n        $text = preg_replace_callback(\n            \"/(^|[^\\\\\\])(`+)(.+?)\\\\2/\",\n            function ($matches) {\n                return  $matches[1] . $this->makeHolder(\n                    '<code>' . htmlspecialchars($matches[3]) . '</code>'\n                );\n            },\n            $text\n        );\n\n        // mathjax\n        $text = preg_replace_callback(\n            \"/(^|[^\\\\\\])(\\\\$+)(.+?)\\\\2/\",\n            function ($matches) {\n                return  $matches[1] . $this->makeHolder(\n                    $matches[2] . htmlspecialchars($matches[3]) . $matches[2]\n                );\n            },\n            $text\n        );\n\n        // escape\n        $text = preg_replace_callback(\n            \"/\\\\\\(.)/u\",\n            function ($matches) {\n                $prefix = preg_match(\"/^[-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]$/\", $matches[1]) ? '' : '\\\\';\n                $escaped = htmlspecialchars($matches[1]);\n                $escaped = str_replace('$', '&dollar;', $escaped);\n                return  $this->makeHolder($prefix . $escaped);\n            },\n            $text\n        );\n\n        // link\n        $text = preg_replace_callback(\n            \"/<(https?:\\/\\/.+|(?:mailto:)?[_a-z0-9-\\.\\+]+@[_\\w-]+(?:\\.[a-z]{2,})+)>/i\",\n            function ($matches) {\n                $url = $this->cleanUrl($matches[1]);\n                $link = $this->call('parseLink', $url);\n\n                return $this->makeHolder(\n                    \"<a href=\\\"{$url}\\\">{$link}</a>\"\n                );\n            },\n            $text\n        );\n\n        // encode unsafe tags\n        $text = preg_replace_callback(\n            \"/<(\\/?)([a-z0-9-]+)(\\s+[^>]*)?>/i\",\n            function ($matches) use ($whiteList) {\n                if ($this->_html || false !== stripos(\n                    '|' . $this->_commonWhiteList . '|' . $whiteList . '|', '|' . $matches[2] . '|'\n                )) {\n                    return $this->makeHolder($matches[0]);\n                } else {\n                    return $this->makeHolder(htmlspecialchars($matches[0]));\n                }\n            },\n            $text\n        );\n\n        if ($this->_html) {\n            $text = preg_replace_callback(\"/<!\\-\\-(.*?)\\-\\->/\", function ($matches) {\n                return $this->makeHolder($matches[0]);\n            }, $text);\n        }\n\n        $text = str_replace(array('<', '>'),  array('&lt;', '&gt;'),  $text);\n\n        // footnote\n        $text = preg_replace_callback(\n            \"/\\[\\^((?:[^\\]]|\\\\\\\\\\]|\\\\\\\\\\[)+?)\\]/\",\n            function ($matches) {\n                $id = array_search($matches[1], $this->_footnotes);\n\n                if (false === $id) {\n                    $id = count($this->_footnotes) + 1;\n                    $this->_footnotes[$id] = $this->parseInline($matches[1], '', false);\n                }\n\n                return $this->makeHolder(\n                    \"<sup id=\\\"fnref-{$id}\\\"><a href=\\\"#fn-{$id}\\\" class=\\\"footnote-ref\\\">{$id}</a></sup>\"\n                );\n            },\n            $text\n        );\n\n        // image\n        $text = preg_replace_callback(\n            \"/!\\[((?:[^\\]]|\\\\\\\\\\]|\\\\\\\\\\[)*?)\\]\\(((?:[^\\)]|\\\\\\\\\\)|\\\\\\\\\\()+?)\\)/\",\n            function ($matches) {\n                $escaped = htmlspecialchars($this->escapeBracket($matches[1]));\n                $url = $this->escapeBracket($matches[2]);\n                list ($url, $title) = $this->cleanUrl($url, true);\n                $title = empty($title)? $escaped : \" title=\\\"{$title}\\\"\";\n\n                return $this->makeHolder(\n                    \"<img src=\\\"{$url}\\\" alt=\\\"{$title}\\\" title=\\\"{$title}\\\">\"\n                );\n            },\n            $text\n        );\n\n        $text = preg_replace_callback(\n            \"/!\\[((?:[^\\]]|\\\\\\\\\\]|\\\\\\\\\\[)*?)\\]\\[((?:[^\\]]|\\\\\\\\\\]|\\\\\\\\\\[)+?)\\]/\",\n            function ($matches) {\n                $escaped = htmlspecialchars($this->escapeBracket($matches[1]));\n\n                $result = isset( $this->_definitions[$matches[2]] ) ?\n                    \"<img src=\\\"{$this->_definitions[$matches[2]]}\\\" alt=\\\"{$escaped}\\\" title=\\\"{$escaped}\\\">\"\n                    : $escaped;\n\n                return $this->makeHolder($result);\n            },\n            $text\n        );\n\n        // link\n        $text = preg_replace_callback(\n            \"/\\[((?:[^\\]]|\\\\\\\\\\]|\\\\\\\\\\[)+?)\\]\\(((?:[^\\)]|\\\\\\\\\\)|\\\\\\\\\\()+?)\\)/\",\n            function ($matches) {\n                $escaped = $this->parseInline(\n                    $this->escapeBracket($matches[1]),  '',  false, false\n                );\n                $url = $this->escapeBracket($matches[2]);\n                list ($url, $title) = $this->cleanUrl($url, true);\n                $title = empty($title) ? '' : \" title=\\\"{$title}\\\"\";\n\n                return $this->makeHolder(\"<a href=\\\"{$url}\\\"{$title}>{$escaped}</a>\");\n            },\n            $text\n        );\n\n        $text = preg_replace_callback(\n            \"/\\[((?:[^\\]]|\\\\\\\\\\]|\\\\\\\\\\[)+?)\\]\\[((?:[^\\]]|\\\\\\\\\\]|\\\\\\\\\\[)+?)\\]/\",\n            function ($matches) {\n                $escaped = $this->parseInline(\n                    $this->escapeBracket($matches[1]),  '',  false\n                );\n                $result = isset( $this->_definitions[$matches[2]] ) ?\n                    \"<a href=\\\"{$this->_definitions[$matches[2]]}\\\">{$escaped}</a>\"\n                    : $escaped;\n\n                return $this->makeHolder($result);\n            },\n            $text\n        );\n\n        // strong and em and some fuck\n        $text = $this->parseInlineCallback($text);\n        $text = preg_replace(\n            \"/<([_a-z0-9-\\.\\+]+@[^@]+\\.[a-z]{2,})>/i\",\n            \"<a href=\\\"mailto:\\\\1\\\">\\\\1</a>\",\n            $text\n        );\n\n        // autolink url\n        if ($enableAutoLink) {\n            $text = preg_replace_callback(\n                \"/(^|[^\\\"])(https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\b([-a-zA-Z0-9@:%_\\+.~#?&\\/=]*)|(?:mailto:)?[_a-z0-9-\\.\\+]+@[_\\w-]+(?:\\.[a-z]{2,})+)($|[^\\\"])/\",\n                function ($matches) {\n                    $url = $this->cleanUrl($matches[2]);\n                    $link = $this->call('parseLink', $matches[2]);\n                    return \"{$matches[1]}<a href=\\\"{$url}\\\">{$link}</a>{$matches[5]}\";\n                },\n                $text\n            );\n        }\n\n        $text = $this->call('afterParseInlineBeforeRelease', $text);\n        $text = $this->releaseHolder($text, $clearHolders);\n\n        $text = $this->call('afterParseInline', $text);\n\n        return $text;\n    }\n\n    /**\n     * @param $text\n     * @return mixed\n     */\n    private function parseInlineCallback($text)\n    {\n        $text = preg_replace_callback(\n            \"/(\\*{3})(.+?)\\\\1/\",\n            function ($matches) {\n                return  '<strong><em>' .\n                    $this->parseInlineCallback($matches[2]) .\n                    '</em></strong>';\n            },\n            $text\n        );\n\n        $text = preg_replace_callback(\n            \"/(\\*{2})(.+?)\\\\1/\",\n            function ($matches) {\n                return  '<strong>' .\n                    $this->parseInlineCallback($matches[2]) .\n                    '</strong>';\n            },\n            $text\n        );\n\n        $text = preg_replace_callback(\n            \"/(\\*)(.+?)\\\\1/\",\n            function ($matches) {\n                return  '<em>' .\n                    $this->parseInlineCallback($matches[2]) .\n                    '</em>';\n            },\n            $text\n        );\n\n        $text = preg_replace_callback(\n            \"/(\\s+|^)(_{3})(.+?)\\\\2(\\s+|$)/\",\n            function ($matches) {\n                return  $matches[1] . '<strong><em>' .\n                    $this->parseInlineCallback($matches[3]) .\n                    '</em></strong>' . $matches[4];\n            },\n            $text\n        );\n\n        $text = preg_replace_callback(\n            \"/(\\s+|^)(_{2})(.+?)\\\\2(\\s+|$)/\",\n            function ($matches) {\n                return  $matches[1] . '<strong>' .\n                    $this->parseInlineCallback($matches[3]) .\n                    '</strong>' . $matches[4];\n            },\n            $text\n        );\n\n        $text = preg_replace_callback(\n            \"/(\\s+|^)(_)(.+?)\\\\2(\\s+|$)/\",\n            function ($matches) {\n                return  $matches[1] . '<em>' .\n                    $this->parseInlineCallback($matches[3]) .\n                    '</em>' . $matches[4];\n            },\n            $text\n        );\n\n        $text = preg_replace_callback(\n            \"/(~{2})(.+?)\\\\1/\",\n            function ($matches) {\n                return  '<del>' .\n                    $this->parseInlineCallback($matches[2]) .\n                    '</del>';\n            },\n            $text\n        );\n\n        return $text;\n    }\n\n    /**\n     * parseBlock\n     *\n     * @param string $text\n     * @param array $lines\n     * @return array\n     */\n    private function parseBlock($text, &$lines)\n    {\n        $lines = explode(\"\\n\", $text);\n        $this->_blocks = array();\n        $this->_current = 'normal';\n        $this->_pos = -1;\n\n        $state = array(\n            'special'   =>  implode(\"|\", array_keys($this->_specialWhiteList)),\n            'empty'     =>  0,\n            'html'      =>  false\n        );\n\n        // analyze by line\n        foreach ($lines as $key => $line) {\n            $block = $this->getBlock();\n            $args = array($block, $key, $line, &$state, $lines);\n\n            if ($this->_current != 'normal') {\n                $pass = call_user_func_array($this->_parsers[$this->_current], $args);\n\n                if (!$pass) {\n                    continue;\n                }\n            }\n\n            foreach ($this->_parsers as $name => $parser) {\n                if ($name != $this->_current) {\n                    $pass = call_user_func_array($parser, $args);\n\n                    if (!$pass) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return $this->optimizeBlocks($this->_blocks, $lines);\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @param $state\n     * @return bool\n     */\n    private function parseBlockList($block, $key, $line, &$state)\n    {\n        if ($this->isBlock('list') && !preg_match(\"/^\\s*\\[((?:[^\\]]|\\\\]|\\\\[)+?)\\]:\\s*(.+)$/\", $line)) {\n            if (preg_match(\"/^(\\s*)(~{3,}|`{3,})([^`~]*)$/i\", $line)) {\n                // ignore code\n                return true;\n            } elseif ($state['empty'] <= 1\n                && preg_match(\"/^(\\s*)\\S+/\", $line, $matches)\n                && strlen($matches[1]) >= ($block[3][0] + $state['empty'])) {\n\n                $state['empty'] = 0;\n                $this->setBlock($key);\n                return false;\n            } elseif (preg_match(\"/^(\\s*)$/\", $line) && $state['empty'] == 0) {\n                $state['empty'] ++;\n                $this->setBlock($key);\n                return false;\n            }\n        }\n\n        if (preg_match(\"/^(\\s*)((?:[0-9]+\\.)|\\-|\\+|\\*)\\s+/i\", $line, $matches)) {\n            $space = strlen($matches[1]);\n            $tab = strlen($matches[0]) - $space;\n            $state['empty'] = 0;\n            $type = false !== strpos('+-*', $matches[2]) ? 'ul' : 'ol';\n\n            // opened\n            if ($this->isBlock('list')) {\n                if ($space < $block[3][0] || ($space == $block[3][0] && $type != $block[3][1])) {\n                    $this->startBlock('list', $key, [$space, $type, $tab]);\n                } else {\n                    $this->setBlock($key);\n                }\n            } else {\n                $this->startBlock('list', $key, [$space, $type, $tab]);\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @param $state\n     * @return bool\n     */\n    private function parseBlockCode($block, $key, $line, &$state)\n    {\n        if (preg_match(\"/^(\\s*)(~{3,}|`{3,})([^`~]*)$/i\", $line, $matches)) {\n            if ($this->isBlock('code')) {\n                if ($state['code'] != $matches[2]) {\n                    $this->setBlock($key);\n                    return false;\n                }\n\n                $isAfterList = $block[3][2];\n\n                if ($isAfterList) {\n                    $state['empty'] = 0;\n                    $this->combineBlock()\n                        ->setBlock($key);\n                } else {\n                    $this->setBlock($key)\n                        ->endBlock();\n                }\n            } else {\n                $isAfterList = false;\n\n                if ($this->isBlock('list')) {\n                    $space = $block[3][0];\n\n                    $isAfterList = strlen($matches[1]) >= $space + $state['empty'];\n                }\n\n                $state['code'] = $matches[2];\n\n                $this->startBlock('code', $key, array(\n                    $matches[1],  $matches[3],  $isAfterList\n                ));\n            }\n\n            return false;\n        } elseif ($this->isBlock('code')) {\n            $this->setBlock($key);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @param $state\n     * @return bool\n     */\n    private function parseBlockShtml($block, $key, $line, &$state)\n    {\n        if ($this->_html) {\n            if (preg_match(\"/^(\\s*)!!!(\\s*)$/\", $line, $matches)) {\n                if ($this->isBlock('shtml')) {\n                    $this->setBlock($key)->endBlock();\n                } else {\n                    $this->startBlock('shtml', $key);\n                }\n\n                return false;\n            } elseif ($this->isBlock('shtml')) {\n                $this->setBlock($key);\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @param $state\n     * @return bool\n     */\n    private function parseBlockAhtml($block, $key, $line, &$state)\n    {\n        if ($this->_html) {\n            if (preg_match(\"/^\\s*<({$this->_blockHtmlTags})(\\s+[^>]*)?>/i\", $line, $matches)) {\n                if ($this->isBlock('ahtml')) {\n                    $this->setBlock($key);\n                    return false;\n                } elseif (empty($matches[2]) || $matches[2] != '/') {\n                    $this->startBlock('ahtml', $key);\n                    preg_match_all(\"/<({$this->_blockHtmlTags})(\\s+[^>]*)?>/i\", $line, $allMatches);\n                    $lastMatch = $allMatches[1][count($allMatches[0]) - 1];\n\n                    if (strpos($line, \"</{$lastMatch}>\") !== false) {\n                        $this->endBlock();\n                    } else {\n                        $state['html'] = $lastMatch;\n                    }\n                    return false;\n                }\n            } elseif (!!$state['html'] && strpos($line, \"</{$state['html']}>\") !== false) {\n                $this->setBlock($key)->endBlock();\n                $state['html'] = false;\n                return false;\n            } elseif ($this->isBlock('ahtml')) {\n                $this->setBlock($key);\n                return false;\n            } elseif (preg_match(\"/^\\s*<!\\-\\-(.*?)\\-\\->\\s*$/\", $line, $matches)) {\n                $this->startBlock('ahtml', $key)->endBlock();\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @return bool\n     */\n    private function parseBlockMath($block, $key, $line)\n    {\n        if (preg_match(\"/^(\\s*)\\\\$\\\\$(\\s*)$/\", $line, $matches)) {\n            if ($this->isBlock('math')) {\n                $this->setBlock($key)->endBlock();\n            } else {\n                $this->startBlock('math', $key);\n            }\n\n            return false;\n        } elseif ($this->isBlock('math')) {\n            $this->setBlock($key);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @param $state\n     * @return bool\n     */\n    private function parseBlockPre($block, $key, $line, &$state)\n    {\n        if (preg_match(\"/^ {4}/\", $line)) {\n            if ($this->isBlock('pre')) {\n                $this->setBlock($key);\n            } else {\n                $this->startBlock('pre', $key);\n            }\n\n            return false;\n        } elseif ($this->isBlock('pre') && preg_match(\"/^\\s*$/\", $line)) {\n            $this->setBlock($key);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @param $state\n     * @return bool\n     */\n    private function parseBlockHtml($block, $key, $line, &$state)\n    {\n        if (preg_match(\"/^\\s*<({$state['special']})(\\s+[^>]*)?>/i\", $line, $matches)) {\n            $tag = strtolower($matches[1]);\n            if (!$this->isBlock('html', $tag) && !$this->isBlock('pre')) {\n                $this->startBlock('html', $key, $tag);\n            }\n\n            return false;\n        } elseif (preg_match(\"/<\\/({$state['special']})>\\s*$/i\", $line, $matches)) {\n            $tag = strtolower($matches[1]);\n\n            if ($this->isBlock('html', $tag)) {\n                $this->setBlock($key)\n                    ->endBlock();\n            }\n\n            return false;\n        } elseif ($this->isBlock('html')) {\n            $this->setBlock($key);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @return bool\n     */\n    private function parseBlockFootnote($block, $key, $line)\n    {\n        if (preg_match(\"/^\\[\\^((?:[^\\]]|\\\\]|\\\\[)+?)\\]:/\", $line, $matches)) {\n            $space = strlen($matches[0]) - 1;\n            $this->startBlock('footnote', $key, array(\n                $space, $matches[1]\n            ));\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @return bool\n     */\n    private function parseBlockDefinition($block, $key, $line)\n    {\n        if (preg_match(\"/^\\s*\\[((?:[^\\]]|\\\\]|\\\\[)+?)\\]:\\s*(.+)$/\", $line, $matches)) {\n            $this->_definitions[$matches[1]] = $this->cleanUrl($matches[2]);\n            $this->startBlock('definition', $key)\n                ->endBlock();\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @return bool\n     */\n    private function parseBlockQuote($block, $key, $line)\n    {\n        if (preg_match(\"/^(\\s*)>/\", $line, $matches)) {\n            if ($this->isBlock('list') && strlen($matches[1]) > 0) {\n                $this->setBlock($key);\n            } elseif ($this->isBlock('quote')) {\n                $this->setBlock($key);\n            } else {\n                $this->startBlock('quote', $key);\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @param $state\n     * @param $lines\n     * @return bool\n     */\n    private function parseBlockTable($block, $key, $line, &$state, $lines)\n    {\n        if (preg_match(\"/^((?:(?:(?:\\||\\+)(?:[ :]*\\-+[ :]*)(?:\\||\\+))|(?:(?:[ :]*\\-+[ :]*)(?:\\||\\+)(?:[ :]*\\-+[ :]*))|(?:(?:[ :]*\\-+[ :]*)(?:\\||\\+))|(?:(?:\\||\\+)(?:[ :]*\\-+[ :]*)))+)$/\", $line, $matches)) {\n            if ($this->isBlock('table')) {\n                $block[3][0][] = $block[3][2];\n                $block[3][2]++;\n                $this->setBlock($key, $block[3]);\n            } else {\n                $head = 0;\n\n                if (empty($block) ||\n                    $block[0] != 'normal' ||\n                    preg_match(\"/^\\s*$/\", $lines[$block[2]])) {\n                    $this->startBlock('table', $key);\n                } else {\n                    $head = 1;\n                    $this->backBlock(1, 'table');\n                }\n\n                if ($matches[1][0] == '|') {\n                    $matches[1] = substr($matches[1], 1);\n\n                    if ($matches[1][strlen($matches[1]) - 1] == '|') {\n                        $matches[1] = substr($matches[1], 0, -1);\n                    }\n                }\n\n                $rows = preg_split(\"/(\\+|\\|)/\", $matches[1]);\n                $aligns = array();\n                foreach ($rows as $row) {\n                    $align = 'none';\n\n                    if (preg_match(\"/^\\s*(:?)\\-+(:?)\\s*$/\", $row, $matches)) {\n                        if (!empty($matches[1]) && !empty($matches[2])) {\n                            $align = 'center';\n                        } elseif (!empty($matches[1])) {\n                            $align = 'left';\n                        } elseif (!empty($matches[2])) {\n                            $align = 'right';\n                        }\n                    }\n\n                    $aligns[] = $align;\n                }\n\n                $this->setBlock($key, array(array($head), $aligns, $head + 1));\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @return bool\n     */\n    private function parseBlockSh($block, $key, $line)\n    {\n        if (preg_match(\"/^(#+)(.*)$/\", $line, $matches)) {\n            $num = min(strlen($matches[1]), 6);\n            $this->startBlock('sh', $key, $num)\n                ->endBlock();\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @param $state\n     * @param $lines\n     * @return bool\n     */\n    private function parseBlockMh($block, $key, $line, &$state, $lines)\n    {\n        if (preg_match(\"/^\\s*((=|-){2,})\\s*$/\", $line, $matches)\n                    && ($block && $block[0] == \"normal\" && !preg_match(\"/^\\s*$/\", $lines[$block[2]]))) {    // check if last line isn't empty\n            if ($this->isBlock('normal')) {\n                $this->backBlock(1, 'mh', $matches[1][0] == '=' ? 1 : 2)\n                    ->setBlock($key)\n                    ->endBlock();\n            } else {\n                $this->startBlock('normal', $key);\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @return bool\n     */\n    private function parseBlockShr($block, $key, $line)\n    {\n        if (preg_match(\"/^(\\* *){3,}\\s*$/\", $line)) {\n            $this->startBlock('hr', $key)\n                ->endBlock();\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @return bool\n     */\n    private function parseBlockDhr($block, $key, $line)\n    {\n        if (preg_match(\"/^(- *){3,}\\s*$/\", $line)) {\n            $this->startBlock('hr', $key)\n                ->endBlock();\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param $block\n     * @param $key\n     * @param $line\n     * @param $state\n     * @return bool\n     */\n    private function parseBlockDefault($block, $key, $line, &$state)\n    {\n        if ($this->isBlock('footnote')) {\n            preg_match(\"/^(\\s*)/\", $line, $matches);\n            if (strlen($matches[1]) >= $block[3][0]) {\n                $this->setBlock($key);\n            } else {\n                $this->startBlock('normal', $key);\n            }\n        } elseif ($this->isBlock('table')) {\n            if (false !== strpos($line, '|')) {\n                $block[3][2] ++;\n                $this->setBlock($key, $block[3]);\n            } else {\n                $this->startBlock('normal', $key);\n            }\n        } elseif ($this->isBlock('quote')) {\n            if (!preg_match(\"/^(\\s*)$/\", $line)) { // empty line\n                $this->setBlock($key);\n            } else {\n                $this->startBlock('normal', $key);\n            }\n        } else {\n            if (empty($block) || $block[0] != 'normal') {\n                $this->startBlock('normal', $key);\n            } else {\n                $this->setBlock($key);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param array $blocks\n     * @param array $lines\n     * @return array\n     */\n    private function optimizeBlocks(array $blocks, array $lines)\n    {\n        $blocks = $this->call('beforeOptimizeBlocks', $blocks, $lines);\n\n        $key = 0;\n        while (isset($blocks[$key])) {\n            $moved = false;\n\n            $block = &$blocks[$key];\n            $prevBlock = isset($blocks[$key - 1]) ? $blocks[$key - 1] : NULL;\n            $nextBlock = isset($blocks[$key + 1]) ? $blocks[$key + 1] : NULL;\n\n            list($type, $from, $to) = $block;\n\n            if ('pre' == $type) {\n                $isEmpty = array_reduce(\n                    array_slice($lines, $block[1], $block[2] - $block[1] + 1),\n                    function ($result, $line) {\n                        return preg_match(\"/^\\s*$/\", $line) && $result;\n                    },\n                    true\n                );\n\n                if ($isEmpty) {\n                    $block[0] = $type = 'normal';\n                }\n            }\n\n            if ('normal' == $type) {\n                // combine two blocks\n                $types = array('list', 'quote');\n\n                if ($from == $to && preg_match(\"/^\\s*$/\", $lines[$from])\n                    && !empty($prevBlock) && !empty($nextBlock)) {\n                    if ($prevBlock[0] == $nextBlock[0] && in_array($prevBlock[0], $types)\n                        && ($prevBlock[0] != 'list'\n                            || ($prevBlock[3][0] == $nextBlock[3][0] && $prevBlock[3][1] == $nextBlock[3][1]))) {\n                        // combine 3 blocks\n                        $blocks[$key - 1] = array(\n                            $prevBlock[0],  $prevBlock[1],  $nextBlock[2], $prevBlock[3] ?? null\n                        );\n                        array_splice($blocks, $key, 2);\n\n                        // do not move\n                        $moved = true;\n                    }\n                }\n            }\n\n            if (!$moved) {\n                $key ++;\n            }\n        }\n\n        return $this->call('afterOptimizeBlocks', $blocks, $lines);\n    }\n\n    /**\n     * parseCode\n     *\n     * @param array $lines\n     * @param array $parts\n     * @param int $start\n     * @return string\n     */\n    private function parseCode(array $lines, array $parts, $start)\n    {\n        list($blank, $lang) = $parts;\n        $lang = trim($lang);\n        $count = strlen($blank);\n\n        if (!preg_match(\"/^[_a-z0-9-\\+\\#\\:\\.]+$/i\", $lang)) {\n            $lang = NULL;\n        } else {\n            $parts = explode(':', $lang);\n            if (count($parts) > 1) {\n                list($lang, $rel) = $parts;\n                $lang = trim($lang);\n                $rel = trim($rel);\n            }\n        }\n\n        $isEmpty = true;\n\n        $lines = array_map(function ($line) use ($count, &$isEmpty) {\n            $line = preg_replace(\"/^[ ]{{$count}}/\", '', $line);\n            if ($isEmpty && !preg_match(\"/^\\s*$/\", $line)) {\n                $isEmpty = false;\n            }\n\n            return htmlspecialchars($line);\n        }, array_slice($lines, 1, -1));\n        $str = implode(\"\\n\", $this->markLines($lines, $start + 1));\n\n        return $isEmpty ? '' :\n            '<pre><code' . (!empty($lang) ? \" class=\\\"{$lang}\\\"\" : '')\n            . (!empty($rel) ? \" rel=\\\"{$rel}\\\"\" : '') . '>'\n            . $str . '</code></pre>';\n    }\n\n    /**\n     * parsePre\n     *\n     * @param array $lines\n     * @param mixed $value\n     * @param int $start\n     * @return string\n     */\n    private function parsePre(array $lines, $value, $start)\n    {\n        foreach ($lines as &$line) {\n            $line = htmlspecialchars(substr($line, 4));\n        }\n\n        $str = implode(\"\\n\", $this->markLines($lines, $start));\n        return preg_match(\"/^\\s*$/\", $str) ? '' : '<pre><code>' . $str . '</code></pre>';\n    }\n\n    /**\n     * parseAhtml\n     *\n     * @param array $lines\n     * @param mixed $value\n     * @param int $start\n     * @return string\n     */\n    private function parseAhtml(array $lines, $value, $start)\n    {\n        return trim(implode(\"\\n\", $this->markLines($lines, $start)));\n    }\n\n    /**\n     * parseShtml\n     *\n     * @param array $lines\n     * @param mixed $value\n     * @param int $start\n     * @return string\n     */\n    private function parseShtml(array $lines, $value, $start)\n    {\n        return trim(implode(\"\\n\", $this->markLines(array_slice($lines, 1, -1), $start + 1)));\n    }\n\n    /**\n     * parseMath\n     *\n     * @param array $lines\n     * @param mixed $value\n     * @param int $start\n     * @param int $end\n     * @return string\n     */\n    private function parseMath(array $lines, $value, $start, $end)\n    {\n        return '<p>' . $this->markLine($start, $end) . htmlspecialchars(implode(\"\\n\", $lines)) . '</p>';\n    }\n\n    /**\n     * parseSh\n     *\n     * @param array $lines\n     * @param int $num\n     * @param int $start\n     * @param int $end\n     * @return string\n     */\n    private function parseSh(array $lines, $num, $start, $end)\n    {\n        $line = $this->markLine($start, $end) . $this->parseInline(trim($lines[0], '# '));\n        return preg_match(\"/^\\s*$/\", $line) ? '' : \"<h{$num}>{$line}</h{$num}>\";\n    }\n\n    /**\n     * parseMh\n     *\n     * @param array $lines\n     * @param int $num\n     * @param int $start\n     * @param int $end\n     * @return string\n     */\n    private function parseMh(array $lines, $num, $start, $end)\n    {\n        return $this->parseSh($lines, $num, $start, $end);\n    }\n\n    /**\n     * parseQuote\n     *\n     * @param array $lines\n     * @param mixed $value\n     * @param int $start\n     * @return string\n     */\n    private function parseQuote(array $lines, $value, $start)\n    {\n        foreach ($lines as &$line) {\n            $line = preg_replace(\"/^\\s*> ?/\", '', $line);\n        }\n        $str = implode(\"\\n\", $lines);\n\n        return preg_match(\"/^\\s*$/\", $str) ? '' : '<blockquote>' . $this->parse($str, true, $start) . '</blockquote>';\n    }\n\n    /**\n     * parseList\n     *\n     * @param array $lines\n     * @param mixed $value\n     * @param int $start\n     * @return string\n     */\n    private function parseList(array $lines, $value, $start)\n    {\n        $html = '';\n        list($space, $type, $tab) = $value;\n        $rows = array();\n        $suffix = '';\n        $last = 0;\n\n        foreach ($lines as $key => $line) {\n            if (preg_match(\"/^(\\s{\" . $space . \"})((?:[0-9]+\\.?)|\\-|\\+|\\*)(\\s+)(.*)$/i\", $line, $matches)) {\n                if ($type == 'ol' && $key == 0) {\n                    $start = intval($matches[2]);\n\n                    if ($start != 1) {\n                        $suffix = ' start=\"' . $start . '\"';\n                    }\n                }\n\n                $rows[] = [$matches[4]];\n                $last = count($rows) - 1;\n            } else {\n                $rows[$last][] = preg_replace(\"/^\\s{\" . ($tab + $space) . \"}/\", '', $line);\n            }\n        }\n\n        foreach ($rows as $row) {\n            $html .= \"<li>\" . $this->parse(implode(\"\\n\", $row), true, $start) . \"</li>\";\n            $start += count($row);\n        }\n\n        return \"<{$type}{$suffix}>{$html}</{$type}>\";\n    }\n\n    /**\n     * @param array $lines\n     * @param array $value\n     * @param int $start\n     * @return string\n     */\n    private function parseTable(array $lines, array $value, $start)\n    {\n        list($ignores, $aligns) = $value;\n        $head = count($ignores) > 0 && array_sum($ignores) > 0;\n\n        $html = '<table>';\n        $body = $head ? NULL : true;\n        $output = false;\n\n        foreach ($lines as $key => $line) {\n            if (in_array($key, $ignores)) {\n                if ($head && $output) {\n                    $head = false;\n                    $body = true;\n                }\n\n                continue;\n            }\n\n            $line = trim($line);\n            $output = true;\n\n            if ($line[0] == '|') {\n                $line = substr($line, 1);\n\n                if ($line[strlen($line) - 1] == '|') {\n                    $line = substr($line, 0, -1);\n                }\n            }\n\n\n            $rows = array_map(function ($row) {\n                if (preg_match(\"/^\\s*$/\", $row)) {\n                    return ' ';\n                } else {\n                    return trim($row);\n                }\n            }, explode('|', $line));\n            $columns = array();\n            $last = -1;\n\n            foreach ($rows as $row) {\n                if (strlen($row) > 0) {\n                    $last ++;\n                    $columns[$last] = array(\n                        isset($columns[$last]) ? $columns[$last][0] + 1 : 1,  $row\n                    );\n                } elseif (isset($columns[$last])) {\n                    $columns[$last][0] ++;\n                } else {\n                    $columns[0] = array(1, $row);\n                }\n            }\n\n            if ($head) {\n                $html .= '<thead>';\n            } elseif ($body) {\n                $html .= '<tbody>';\n            }\n\n            $html .= '<tr' . ($this->_line ? ' class=\"line\" data-start=\"'\n                    . ($start + $key) . '\" data-end=\"' . ($start + $key)\n                    . '\" data-id=\"' . $this->_uniqid . '\"' : '') . '>';\n\n            foreach ($columns as $key => $column) {\n                list($num, $text) = $column;\n                $tag = $head ? 'th' : 'td';\n\n                $html .= \"<{$tag}\";\n                if ($num > 1) {\n                    $html .= \" colspan=\\\"{$num}\\\"\";\n                }\n\n                if (isset($aligns[$key]) && $aligns[$key] != 'none') {\n                    $html .= \" align=\\\"{$aligns[$key]}\\\"\";\n                }\n\n                $html .= '>' . $this->parseInline($text) . \"</{$tag}>\";\n            }\n\n            $html .= '</tr>';\n\n            if ($head) {\n                $html .= '</thead>';\n            } elseif ($body) {\n                $body = false;\n            }\n        }\n\n        if ($body !== NULL) {\n            $html .= '</tbody>';\n        }\n\n        $html .= '</table>';\n        return $html;\n    }\n\n    /**\n     * parseHr\n     *\n     * @param array $lines\n     * @param array $value\n     * @param int $start\n     * @return string\n     */\n    private function parseHr($lines, $value, $start)\n    {\n        return $this->_line ? '<hr class=\"line\" data-start=\"' . $start . '\" data-end=\"' . $start . '\">' : '<hr>';\n    }\n\n    /**\n     * parseNormal\n     *\n     * @param array $lines\n     * @param bool $inline\n     * @param int $start\n     * @return string\n     */\n    private function parseNormal(array $lines, $inline, $start)\n    {\n        foreach ($lines as $key => &$line) {\n            $line = $this->parseInline($line);\n\n            if (!preg_match(\"/^\\s*$/\", $line)) {\n                $line = $this->markLine($start + $key) . $line;\n            }\n        }\n\n        $str = trim(implode(\"\\n\", $lines));\n        $str = preg_replace_callback(\"/(\\n\\s*){2,}/\", function () use (&$inline) {\n            $inline = false;\n            return \"</p><p>\";\n        }, $str);\n        $str = preg_replace(\"/\\n/\", \"<br>\", $str);\n\n        return preg_match(\"/^\\s*$/\", $str) ? '' : ($inline ? $str : \"<p>{$str}</p>\");\n    }\n\n    /**\n     * parseFootnote\n     *\n     * @param array $lines\n     * @param array $value\n     * @return string\n     */\n    private function parseFootnote(array $lines, array $value)\n    {\n        list($space, $note) = $value;\n        $index = array_search($note, $this->_footnotes);\n\n        if (false !== $index) {\n            $lines[0] = preg_replace(\"/^\\[\\^((?:[^\\]]|\\\\]|\\\\[)+?)\\]:/\", '', $lines[0]);\n            $this->_footnotes[$index] = $lines;\n        }\n\n        return '';\n    }\n\n    /**\n     * parseDefine\n     *\n     * @return string\n     */\n    private function parseDefinition()\n    {\n        return '';\n    }\n\n    /**\n     * parseHtml\n     *\n     * @param array $lines\n     * @param string $type\n     * @param int $start\n     * @return string\n     */\n    private function parseHtml(array $lines, $type, $start)\n    {\n        foreach ($lines as &$line) {\n            $line = $this->parseInline($line,\n                isset($this->_specialWhiteList[$type]) ? $this->_specialWhiteList[$type] : '');\n        }\n\n        return implode(\"\\n\", $this->markLines($lines, $start));\n    }\n\n    /**\n     * @param $url\n     * @param bool $parseTitle\n     *\n     * @return mixed\n     */\n    private function cleanUrl($url, $parseTitle = false)\n    {\n        $title = null;\n        $url = trim($url);\n\n        if ($parseTitle) {\n            $pos = strpos($url, ' ');\n\n            if ($pos !== false) {\n                $title = htmlspecialchars(trim(substr($url, $pos + 1), ' \"\\''));\n                $url = substr($url, 0, $pos);\n            }\n        }\n\n        $url = preg_replace(\"/[\\\"'<>\\s]/\", '', $url);\n\n        if (preg_match(\"/^(mailto:)?[_a-z0-9-\\.\\+]+@[_\\w-]+(?:\\.[a-z]{2,})+$/i\", $url, $matches)) {\n            if (empty($matches[1])) {\n                $url = 'mailto:' . $url;\n            }\n        }\n\n        if (preg_match(\"/^\\w+:/i\", $url) && !preg_match(\"/^(https?|mailto):/i\", $url)) {\n            return '#';\n        }\n\n        return $parseTitle ? [$url, $title] : $url;\n    }\n\n    /**\n     * @param $str\n     * @return mixed\n     */\n    private function escapeBracket($str)\n    {\n        return str_replace(\n            array('\\[', '\\]', '\\(', '\\)'),  array('[', ']', '(', ')'),  $str\n        );\n    }\n\n    /**\n     * startBlock\n     *\n     * @param mixed $type\n     * @param mixed $start\n     * @param mixed $value\n     * @return $this\n     */\n    private function startBlock($type, $start, $value = NULL)\n    {\n        $this->_pos ++;\n        $this->_current = $type;\n\n        $this->_blocks[$this->_pos] = array($type, $start, $start, $value);\n\n        return $this;\n    }\n\n    /**\n     * endBlock\n     *\n     * @return $this\n     */\n    private function endBlock()\n    {\n        $this->_current = 'normal';\n        return $this;\n    }\n\n    /**\n     * isBlock\n     *\n     * @param mixed $type\n     * @param mixed $value\n     * @return bool\n     */\n    private function isBlock($type, $value = NULL)\n    {\n        return $this->_current == $type\n            && (NULL === $value ? true : $this->_blocks[$this->_pos][3] == $value);\n    }\n\n    /**\n     * getBlock\n     *\n     * @return array\n     */\n    private function getBlock()\n    {\n        return isset($this->_blocks[$this->_pos]) ? $this->_blocks[$this->_pos] : NULL;\n    }\n\n    /**\n     * setBlock\n     *\n     * @param mixed $to\n     * @param mixed $value\n     * @return $this\n     */\n    private function setBlock($to = NULL, $value = NULL)\n    {\n        if (NULL !== $to) {\n            $this->_blocks[$this->_pos][2] = $to;\n        }\n\n        if (NULL !== $value) {\n            $this->_blocks[$this->_pos][3] = $value;\n        }\n\n        return $this;\n    }\n\n    /**\n     * backBlock\n     *\n     * @param mixed $step\n     * @param mixed $type\n     * @param mixed $value\n     * @return $this\n     */\n    private function backBlock($step, $type, $value = NULL)\n    {\n        if ($this->_pos < 0) {\n            return $this->startBlock($type, 0, $value);\n        }\n\n        $last = $this->_blocks[$this->_pos][2];\n        $this->_blocks[$this->_pos][2] = $last - $step;\n\n        if ($this->_blocks[$this->_pos][1] <= $this->_blocks[$this->_pos][2]) {\n            $this->_pos ++;\n        }\n\n        $this->_current = $type;\n        $this->_blocks[$this->_pos] = array(\n            $type,  $last - $step + 1,  $last,  $value\n        );\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    private function combineBlock()\n    {\n        if ($this->_pos < 1) {\n            return $this;\n        }\n\n        $prev = $this->_blocks[$this->_pos - 1];\n        $current = $this->_blocks[$this->_pos];\n\n        $prev[2] = $current[2];\n        $this->_blocks[$this->_pos - 1] = $prev;\n        $this->_current = $prev[0];\n        unset($this->_blocks[$this->_pos]);\n        $this->_pos --;\n\n        return $this;\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.306640625,
          "content": "为何要写这样一个解析器\n======================\n\nMarkdown已经面世许多年了，国内外许多大大小小的网站都在用它，但是它的解析器却依然混乱不堪。SegmentFault 是中国较大规模使用 Markdown 语法的网站，我们一直在使用一些开源类库，包括但不限于\n\n1. [php-markdown](https://github.com/michelf/php-markdown)\n2. [CommonMark for PHP](https://github.com/thephpleague/commonmark)\n3. [Parsedown](https://github.com/erusev/parsedown)\n\n他们都有或多或少的毛病，有的性能较差，有的代码比较业余，更多的情况是由于Markdown本身解析比较复杂，因此我们几乎无法去维护另外一个人写的代码。基于这个原因，我为 SegmentFault 专门编写了这么一个Markdown解析器。\n\n使用方法\n--------\n\n与常规的解析类库没有任何区别\n\n```php\n$parser = new HyperDown\\Parser;\n$html = $parser->makeHtml($text);\n```\n\n当前支持的语法\n--------------\n\n- 标题\n- 列表（可递归）\n- 引用（可递归）\n- 缩进风格的代码块\n- Github风格的代码块\n- 各种行内文字加粗，斜体等效果\n- 链接，图片\n- 自动链接\n- 段内折行\n- 脚标\n- 分隔符\n- 表格\n- 图片和链接支持互相套用\n\n浏览器中使用请参阅 [HyperDown.js](https://github.com/SegmentFault/HyperDown.js)\n"
        },
        {
          "name": "cli.php",
          "type": "blob",
          "size": 0.611328125,
          "content": "<?php\n\n$read = false;\n$html = false;\n$line = false;\n$file = null;\n\nforeach ($argv as $val) {\n    if ($val == '-h') {\n        $html = true;\n        continue;\n    } elseif ($val == '-l') {\n        $line = true;\n        continue;\n    }\n\n    if ($read) {\n        $file = $val;\n        $read = false;\n    } elseif ($val == '-f') {\n        $read = true;\n    }\n}\n\nif (empty($file)) {\n    exit(1);\n}\n\nrequire_once __DIR__ . '/Parser.php';\n\n$parser = new \\HyperDown\\Parser();\n\nif ($html) {\n    $parser->enableHtml(true);\n}\n\nif ($line) {\n    $parser->enableLine(true);\n}\n\n$buff = file_get_contents($file);\necho $parser->makeHtml($buff);"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.50390625,
          "content": "{\n    \"name\": \"joyqi/hyper-down\",\n    \"description\": \"A light weight markdown parser library\",\n    \"keywords\": [\"markdown\", \"hyperdown\", \"segmentfault\"],\n    \"license\": \"BSD-4-Clause\",\n    \"authors\": [\n        {\n            \"name\": \"joyqi\",\n            \"email\": \"joyqi@segmentfault.com\"\n        }\n    ],\n    \"require\": {\n\t\t\"php\": \">=7.1.0\",\n        \"ext-mbstring\": \"*\"\n    },\n\t\"autoload\": {\n \t\t\"psr-4\": { \"HyperDown\\\\\": \"./\" }\n\t},\n    \"scripts\": {\n        \"test\": [\n            \"php test/test.php\"\n        ]\n    }\n}\n"
        },
        {
          "name": "composer.lock",
          "type": "blob",
          "size": 39.6650390625,
          "content": "{\n    \"_readme\": [\n        \"This file locks the dependencies of your project to a known state\",\n        \"Read more about it at https://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file\",\n        \"This file is @generated automatically\"\n    ],\n    \"hash\": \"666ba4403a5cfd7267a4b759137db9da\",\n    \"content-hash\": \"04dfedcbd6db661d73db3733ed625e6e\",\n    \"packages\": [],\n    \"packages-dev\": [\n        {\n            \"name\": \"doctrine/instantiator\",\n            \"version\": \"1.0.5\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/doctrine/instantiator.git\",\n                \"reference\": \"8e884e78f9f0eb1329e445619e04456e64d8051d\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/doctrine/instantiator/zipball/8e884e78f9f0eb1329e445619e04456e64d8051d\",\n                \"reference\": \"8e884e78f9f0eb1329e445619e04456e64d8051d\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.3,<8.0-DEV\"\n            },\n            \"require-dev\": {\n                \"athletic/athletic\": \"~0.1.8\",\n                \"ext-pdo\": \"*\",\n                \"ext-phar\": \"*\",\n                \"phpunit/phpunit\": \"~4.0\",\n                \"squizlabs/php_codesniffer\": \"~2.0\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.0.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"psr-4\": {\n                    \"Doctrine\\\\Instantiator\\\\\": \"src/Doctrine/Instantiator/\"\n                }\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Marco Pivetta\",\n                    \"email\": \"ocramius@gmail.com\",\n                    \"homepage\": \"http://ocramius.github.com/\"\n                }\n            ],\n            \"description\": \"A small, lightweight utility to instantiate objects in PHP without invoking their constructors\",\n            \"homepage\": \"https://github.com/doctrine/instantiator\",\n            \"keywords\": [\n                \"constructor\",\n                \"instantiate\"\n            ],\n            \"time\": \"2015-06-14 21:17:01\"\n        },\n        {\n            \"name\": \"myclabs/deep-copy\",\n            \"version\": \"1.5.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/myclabs/DeepCopy.git\",\n                \"reference\": \"e3abefcd7f106677fd352cd7c187d6c969aa9ddc\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/myclabs/DeepCopy/zipball/e3abefcd7f106677fd352cd7c187d6c969aa9ddc\",\n                \"reference\": \"e3abefcd7f106677fd352cd7c187d6c969aa9ddc\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.4.0\"\n            },\n            \"require-dev\": {\n                \"doctrine/collections\": \"1.*\",\n                \"phpunit/phpunit\": \"~4.1\"\n            },\n            \"type\": \"library\",\n            \"autoload\": {\n                \"psr-4\": {\n                    \"DeepCopy\\\\\": \"src/DeepCopy/\"\n                }\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"description\": \"Create deep copies (clones) of your objects\",\n            \"homepage\": \"https://github.com/myclabs/DeepCopy\",\n            \"keywords\": [\n                \"clone\",\n                \"copy\",\n                \"duplicate\",\n                \"object\",\n                \"object graph\"\n            ],\n            \"time\": \"2015-11-07 22:20:37\"\n        },\n        {\n            \"name\": \"phpdocumentor/reflection-docblock\",\n            \"version\": \"2.0.4\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/phpDocumentor/ReflectionDocBlock.git\",\n                \"reference\": \"d68dbdc53dc358a816f00b300704702b2eaff7b8\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/phpDocumentor/ReflectionDocBlock/zipball/d68dbdc53dc358a816f00b300704702b2eaff7b8\",\n                \"reference\": \"d68dbdc53dc358a816f00b300704702b2eaff7b8\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.3.3\"\n            },\n            \"require-dev\": {\n                \"phpunit/phpunit\": \"~4.0\"\n            },\n            \"suggest\": {\n                \"dflydev/markdown\": \"~1.0\",\n                \"erusev/parsedown\": \"~1.0\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"2.0.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"psr-0\": {\n                    \"phpDocumentor\": [\n                        \"src/\"\n                    ]\n                }\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Mike van Riel\",\n                    \"email\": \"mike.vanriel@naenius.com\"\n                }\n            ],\n            \"time\": \"2015-02-03 12:10:50\"\n        },\n        {\n            \"name\": \"phpspec/prophecy\",\n            \"version\": \"v1.6.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/phpspec/prophecy.git\",\n                \"reference\": \"3c91bdf81797d725b14cb62906f9a4ce44235972\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/phpspec/prophecy/zipball/3c91bdf81797d725b14cb62906f9a4ce44235972\",\n                \"reference\": \"3c91bdf81797d725b14cb62906f9a4ce44235972\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"doctrine/instantiator\": \"^1.0.2\",\n                \"php\": \"^5.3|^7.0\",\n                \"phpdocumentor/reflection-docblock\": \"~2.0\",\n                \"sebastian/comparator\": \"~1.1\",\n                \"sebastian/recursion-context\": \"~1.0\"\n            },\n            \"require-dev\": {\n                \"phpspec/phpspec\": \"~2.0\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.5.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"psr-0\": {\n                    \"Prophecy\\\\\": \"src/\"\n                }\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Konstantin Kudryashov\",\n                    \"email\": \"ever.zet@gmail.com\",\n                    \"homepage\": \"http://everzet.com\"\n                },\n                {\n                    \"name\": \"Marcello Duarte\",\n                    \"email\": \"marcello.duarte@gmail.com\"\n                }\n            ],\n            \"description\": \"Highly opinionated mocking framework for PHP 5.3+\",\n            \"homepage\": \"https://github.com/phpspec/prophecy\",\n            \"keywords\": [\n                \"Double\",\n                \"Dummy\",\n                \"fake\",\n                \"mock\",\n                \"spy\",\n                \"stub\"\n            ],\n            \"time\": \"2016-02-15 07:46:21\"\n        },\n        {\n            \"name\": \"phpunit/php-code-coverage\",\n            \"version\": \"3.3.1\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/php-code-coverage.git\",\n                \"reference\": \"2431befdd451fac43fbcde94d1a92fb3b8b68f86\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/php-code-coverage/zipball/2431befdd451fac43fbcde94d1a92fb3b8b68f86\",\n                \"reference\": \"2431befdd451fac43fbcde94d1a92fb3b8b68f86\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \"^5.6 || ^7.0\",\n                \"phpunit/php-file-iterator\": \"~1.3\",\n                \"phpunit/php-text-template\": \"~1.2\",\n                \"phpunit/php-token-stream\": \"^1.4.2\",\n                \"sebastian/code-unit-reverse-lookup\": \"~1.0\",\n                \"sebastian/environment\": \"^1.3.2\",\n                \"sebastian/version\": \"~1.0|~2.0\"\n            },\n            \"require-dev\": {\n                \"ext-xdebug\": \">=2.1.4\",\n                \"phpunit/phpunit\": \"~5\"\n            },\n            \"suggest\": {\n                \"ext-dom\": \"*\",\n                \"ext-xdebug\": \">=2.4.0\",\n                \"ext-xmlwriter\": \"*\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"3.3.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sb@sebastian-bergmann.de\",\n                    \"role\": \"lead\"\n                }\n            ],\n            \"description\": \"Library that provides collection, processing, and rendering functionality for PHP code coverage information.\",\n            \"homepage\": \"https://github.com/sebastianbergmann/php-code-coverage\",\n            \"keywords\": [\n                \"coverage\",\n                \"testing\",\n                \"xunit\"\n            ],\n            \"time\": \"2016-04-08 08:14:53\"\n        },\n        {\n            \"name\": \"phpunit/php-file-iterator\",\n            \"version\": \"1.4.1\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/php-file-iterator.git\",\n                \"reference\": \"6150bf2c35d3fc379e50c7602b75caceaa39dbf0\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/php-file-iterator/zipball/6150bf2c35d3fc379e50c7602b75caceaa39dbf0\",\n                \"reference\": \"6150bf2c35d3fc379e50c7602b75caceaa39dbf0\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.3.3\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.4.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sb@sebastian-bergmann.de\",\n                    \"role\": \"lead\"\n                }\n            ],\n            \"description\": \"FilterIterator implementation that filters files based on a list of suffixes.\",\n            \"homepage\": \"https://github.com/sebastianbergmann/php-file-iterator/\",\n            \"keywords\": [\n                \"filesystem\",\n                \"iterator\"\n            ],\n            \"time\": \"2015-06-21 13:08:43\"\n        },\n        {\n            \"name\": \"phpunit/php-text-template\",\n            \"version\": \"1.2.1\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/php-text-template.git\",\n                \"reference\": \"31f8b717e51d9a2afca6c9f046f5d69fc27c8686\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/php-text-template/zipball/31f8b717e51d9a2afca6c9f046f5d69fc27c8686\",\n                \"reference\": \"31f8b717e51d9a2afca6c9f046f5d69fc27c8686\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.3.3\"\n            },\n            \"type\": \"library\",\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\",\n                    \"role\": \"lead\"\n                }\n            ],\n            \"description\": \"Simple template engine.\",\n            \"homepage\": \"https://github.com/sebastianbergmann/php-text-template/\",\n            \"keywords\": [\n                \"template\"\n            ],\n            \"time\": \"2015-06-21 13:50:34\"\n        },\n        {\n            \"name\": \"phpunit/php-timer\",\n            \"version\": \"1.0.7\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/php-timer.git\",\n                \"reference\": \"3e82f4e9fc92665fafd9157568e4dcb01d014e5b\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/php-timer/zipball/3e82f4e9fc92665fafd9157568e4dcb01d014e5b\",\n                \"reference\": \"3e82f4e9fc92665fafd9157568e4dcb01d014e5b\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.3.3\"\n            },\n            \"type\": \"library\",\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sb@sebastian-bergmann.de\",\n                    \"role\": \"lead\"\n                }\n            ],\n            \"description\": \"Utility class for timing\",\n            \"homepage\": \"https://github.com/sebastianbergmann/php-timer/\",\n            \"keywords\": [\n                \"timer\"\n            ],\n            \"time\": \"2015-06-21 08:01:12\"\n        },\n        {\n            \"name\": \"phpunit/php-token-stream\",\n            \"version\": \"1.4.8\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/php-token-stream.git\",\n                \"reference\": \"3144ae21711fb6cac0b1ab4cbe63b75ce3d4e8da\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/php-token-stream/zipball/3144ae21711fb6cac0b1ab4cbe63b75ce3d4e8da\",\n                \"reference\": \"3144ae21711fb6cac0b1ab4cbe63b75ce3d4e8da\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"ext-tokenizer\": \"*\",\n                \"php\": \">=5.3.3\"\n            },\n            \"require-dev\": {\n                \"phpunit/phpunit\": \"~4.2\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.4-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\"\n                }\n            ],\n            \"description\": \"Wrapper around PHP's tokenizer extension.\",\n            \"homepage\": \"https://github.com/sebastianbergmann/php-token-stream/\",\n            \"keywords\": [\n                \"tokenizer\"\n            ],\n            \"time\": \"2015-09-15 10:49:45\"\n        },\n        {\n            \"name\": \"phpunit/phpunit\",\n            \"version\": \"5.3.2\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/phpunit.git\",\n                \"reference\": \"2c6da3536035617bae3fe3db37283c9e0eb63ab3\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/phpunit/zipball/2c6da3536035617bae3fe3db37283c9e0eb63ab3\",\n                \"reference\": \"2c6da3536035617bae3fe3db37283c9e0eb63ab3\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"ext-dom\": \"*\",\n                \"ext-json\": \"*\",\n                \"ext-pcre\": \"*\",\n                \"ext-reflection\": \"*\",\n                \"ext-spl\": \"*\",\n                \"myclabs/deep-copy\": \"~1.3\",\n                \"php\": \"^5.6 || ^7.0\",\n                \"phpspec/prophecy\": \"^1.3.1\",\n                \"phpunit/php-code-coverage\": \"^3.3.0\",\n                \"phpunit/php-file-iterator\": \"~1.4\",\n                \"phpunit/php-text-template\": \"~1.2\",\n                \"phpunit/php-timer\": \"^1.0.6\",\n                \"phpunit/phpunit-mock-objects\": \"^3.1\",\n                \"sebastian/comparator\": \"~1.1\",\n                \"sebastian/diff\": \"~1.2\",\n                \"sebastian/environment\": \"~1.3\",\n                \"sebastian/exporter\": \"~1.2\",\n                \"sebastian/global-state\": \"~1.0\",\n                \"sebastian/object-enumerator\": \"~1.0\",\n                \"sebastian/resource-operations\": \"~1.0\",\n                \"sebastian/version\": \"~1.0|~2.0\",\n                \"symfony/yaml\": \"~2.1|~3.0\"\n            },\n            \"suggest\": {\n                \"phpunit/php-invoker\": \"~1.1\"\n            },\n            \"bin\": [\n                \"phpunit\"\n            ],\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"5.3.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\",\n                    \"role\": \"lead\"\n                }\n            ],\n            \"description\": \"The PHP Unit Testing framework.\",\n            \"homepage\": \"https://phpunit.de/\",\n            \"keywords\": [\n                \"phpunit\",\n                \"testing\",\n                \"xunit\"\n            ],\n            \"time\": \"2016-04-12 16:20:08\"\n        },\n        {\n            \"name\": \"phpunit/phpunit-mock-objects\",\n            \"version\": \"3.1.2\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/phpunit-mock-objects.git\",\n                \"reference\": \"7c34c9bdde4131b824086457a3145e27dba10ca1\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/phpunit-mock-objects/zipball/7c34c9bdde4131b824086457a3145e27dba10ca1\",\n                \"reference\": \"7c34c9bdde4131b824086457a3145e27dba10ca1\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"doctrine/instantiator\": \"^1.0.2\",\n                \"php\": \">=5.6\",\n                \"phpunit/php-text-template\": \"~1.2\",\n                \"sebastian/exporter\": \"~1.2\"\n            },\n            \"require-dev\": {\n                \"phpunit/phpunit\": \"~5\"\n            },\n            \"suggest\": {\n                \"ext-soap\": \"*\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"3.1.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sb@sebastian-bergmann.de\",\n                    \"role\": \"lead\"\n                }\n            ],\n            \"description\": \"Mock Object library for PHPUnit\",\n            \"homepage\": \"https://github.com/sebastianbergmann/phpunit-mock-objects/\",\n            \"keywords\": [\n                \"mock\",\n                \"xunit\"\n            ],\n            \"time\": \"2016-03-24 05:58:25\"\n        },\n        {\n            \"name\": \"sebastian/code-unit-reverse-lookup\",\n            \"version\": \"1.0.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/code-unit-reverse-lookup.git\",\n                \"reference\": \"c36f5e7cfce482fde5bf8d10d41a53591e0198fe\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/code-unit-reverse-lookup/zipball/c36f5e7cfce482fde5bf8d10d41a53591e0198fe\",\n                \"reference\": \"c36f5e7cfce482fde5bf8d10d41a53591e0198fe\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.6\"\n            },\n            \"require-dev\": {\n                \"phpunit/phpunit\": \"~5\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.0.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\"\n                }\n            ],\n            \"description\": \"Looks up which function or method a line of code belongs to\",\n            \"homepage\": \"https://github.com/sebastianbergmann/code-unit-reverse-lookup/\",\n            \"time\": \"2016-02-13 06:45:14\"\n        },\n        {\n            \"name\": \"sebastian/comparator\",\n            \"version\": \"1.2.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/comparator.git\",\n                \"reference\": \"937efb279bd37a375bcadf584dec0726f84dbf22\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/comparator/zipball/937efb279bd37a375bcadf584dec0726f84dbf22\",\n                \"reference\": \"937efb279bd37a375bcadf584dec0726f84dbf22\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.3.3\",\n                \"sebastian/diff\": \"~1.2\",\n                \"sebastian/exporter\": \"~1.2\"\n            },\n            \"require-dev\": {\n                \"phpunit/phpunit\": \"~4.4\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.2.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Jeff Welch\",\n                    \"email\": \"whatthejeff@gmail.com\"\n                },\n                {\n                    \"name\": \"Volker Dusch\",\n                    \"email\": \"github@wallbash.com\"\n                },\n                {\n                    \"name\": \"Bernhard Schussek\",\n                    \"email\": \"bschussek@2bepublished.at\"\n                },\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\"\n                }\n            ],\n            \"description\": \"Provides the functionality to compare PHP values for equality\",\n            \"homepage\": \"http://www.github.com/sebastianbergmann/comparator\",\n            \"keywords\": [\n                \"comparator\",\n                \"compare\",\n                \"equality\"\n            ],\n            \"time\": \"2015-07-26 15:48:44\"\n        },\n        {\n            \"name\": \"sebastian/diff\",\n            \"version\": \"1.4.1\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/diff.git\",\n                \"reference\": \"13edfd8706462032c2f52b4b862974dd46b71c9e\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/diff/zipball/13edfd8706462032c2f52b4b862974dd46b71c9e\",\n                \"reference\": \"13edfd8706462032c2f52b4b862974dd46b71c9e\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.3.3\"\n            },\n            \"require-dev\": {\n                \"phpunit/phpunit\": \"~4.8\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.4-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Kore Nordmann\",\n                    \"email\": \"mail@kore-nordmann.de\"\n                },\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\"\n                }\n            ],\n            \"description\": \"Diff implementation\",\n            \"homepage\": \"https://github.com/sebastianbergmann/diff\",\n            \"keywords\": [\n                \"diff\"\n            ],\n            \"time\": \"2015-12-08 07:14:41\"\n        },\n        {\n            \"name\": \"sebastian/environment\",\n            \"version\": \"1.3.5\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/environment.git\",\n                \"reference\": \"dc7a29032cf72b54f36dac15a1ca5b3a1b6029bf\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/environment/zipball/dc7a29032cf72b54f36dac15a1ca5b3a1b6029bf\",\n                \"reference\": \"dc7a29032cf72b54f36dac15a1ca5b3a1b6029bf\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.3.3\"\n            },\n            \"require-dev\": {\n                \"phpunit/phpunit\": \"~4.4\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.3.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\"\n                }\n            ],\n            \"description\": \"Provides functionality to handle HHVM/PHP environments\",\n            \"homepage\": \"http://www.github.com/sebastianbergmann/environment\",\n            \"keywords\": [\n                \"Xdebug\",\n                \"environment\",\n                \"hhvm\"\n            ],\n            \"time\": \"2016-02-26 18:40:46\"\n        },\n        {\n            \"name\": \"sebastian/exporter\",\n            \"version\": \"1.2.1\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/exporter.git\",\n                \"reference\": \"7ae5513327cb536431847bcc0c10edba2701064e\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/exporter/zipball/7ae5513327cb536431847bcc0c10edba2701064e\",\n                \"reference\": \"7ae5513327cb536431847bcc0c10edba2701064e\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.3.3\",\n                \"sebastian/recursion-context\": \"~1.0\"\n            },\n            \"require-dev\": {\n                \"phpunit/phpunit\": \"~4.4\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.2.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Jeff Welch\",\n                    \"email\": \"whatthejeff@gmail.com\"\n                },\n                {\n                    \"name\": \"Volker Dusch\",\n                    \"email\": \"github@wallbash.com\"\n                },\n                {\n                    \"name\": \"Bernhard Schussek\",\n                    \"email\": \"bschussek@2bepublished.at\"\n                },\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\"\n                },\n                {\n                    \"name\": \"Adam Harvey\",\n                    \"email\": \"aharvey@php.net\"\n                }\n            ],\n            \"description\": \"Provides the functionality to export PHP variables for visualization\",\n            \"homepage\": \"http://www.github.com/sebastianbergmann/exporter\",\n            \"keywords\": [\n                \"export\",\n                \"exporter\"\n            ],\n            \"time\": \"2015-06-21 07:55:53\"\n        },\n        {\n            \"name\": \"sebastian/global-state\",\n            \"version\": \"1.1.1\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/global-state.git\",\n                \"reference\": \"bc37d50fea7d017d3d340f230811c9f1d7280af4\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/global-state/zipball/bc37d50fea7d017d3d340f230811c9f1d7280af4\",\n                \"reference\": \"bc37d50fea7d017d3d340f230811c9f1d7280af4\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.3.3\"\n            },\n            \"require-dev\": {\n                \"phpunit/phpunit\": \"~4.2\"\n            },\n            \"suggest\": {\n                \"ext-uopz\": \"*\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.0-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\"\n                }\n            ],\n            \"description\": \"Snapshotting of global state\",\n            \"homepage\": \"http://www.github.com/sebastianbergmann/global-state\",\n            \"keywords\": [\n                \"global state\"\n            ],\n            \"time\": \"2015-10-12 03:26:01\"\n        },\n        {\n            \"name\": \"sebastian/object-enumerator\",\n            \"version\": \"1.0.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/object-enumerator.git\",\n                \"reference\": \"d4ca2fb70344987502567bc50081c03e6192fb26\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/object-enumerator/zipball/d4ca2fb70344987502567bc50081c03e6192fb26\",\n                \"reference\": \"d4ca2fb70344987502567bc50081c03e6192fb26\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.6\",\n                \"sebastian/recursion-context\": \"~1.0\"\n            },\n            \"require-dev\": {\n                \"phpunit/phpunit\": \"~5\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.0.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\"\n                }\n            ],\n            \"description\": \"Traverses array structures and object graphs to enumerate all referenced objects\",\n            \"homepage\": \"https://github.com/sebastianbergmann/object-enumerator/\",\n            \"time\": \"2016-01-28 13:25:10\"\n        },\n        {\n            \"name\": \"sebastian/recursion-context\",\n            \"version\": \"1.0.2\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/recursion-context.git\",\n                \"reference\": \"913401df809e99e4f47b27cdd781f4a258d58791\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/recursion-context/zipball/913401df809e99e4f47b27cdd781f4a258d58791\",\n                \"reference\": \"913401df809e99e4f47b27cdd781f4a258d58791\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.3.3\"\n            },\n            \"require-dev\": {\n                \"phpunit/phpunit\": \"~4.4\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.0.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Jeff Welch\",\n                    \"email\": \"whatthejeff@gmail.com\"\n                },\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\"\n                },\n                {\n                    \"name\": \"Adam Harvey\",\n                    \"email\": \"aharvey@php.net\"\n                }\n            ],\n            \"description\": \"Provides functionality to recursively process PHP variables\",\n            \"homepage\": \"http://www.github.com/sebastianbergmann/recursion-context\",\n            \"time\": \"2015-11-11 19:50:13\"\n        },\n        {\n            \"name\": \"sebastian/resource-operations\",\n            \"version\": \"1.0.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/resource-operations.git\",\n                \"reference\": \"ce990bb21759f94aeafd30209e8cfcdfa8bc3f52\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/resource-operations/zipball/ce990bb21759f94aeafd30209e8cfcdfa8bc3f52\",\n                \"reference\": \"ce990bb21759f94aeafd30209e8cfcdfa8bc3f52\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.6.0\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"1.0.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\"\n                }\n            ],\n            \"description\": \"Provides a list of PHP built-in functions that operate on resources\",\n            \"homepage\": \"https://www.github.com/sebastianbergmann/resource-operations\",\n            \"time\": \"2015-07-28 20:34:47\"\n        },\n        {\n            \"name\": \"sebastian/version\",\n            \"version\": \"2.0.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/sebastianbergmann/version.git\",\n                \"reference\": \"c829badbd8fdf16a0bad8aa7fa7971c029f1b9c5\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/sebastianbergmann/version/zipball/c829badbd8fdf16a0bad8aa7fa7971c029f1b9c5\",\n                \"reference\": \"c829badbd8fdf16a0bad8aa7fa7971c029f1b9c5\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.6\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"2.0.x-dev\"\n                }\n            },\n            \"autoload\": {\n                \"classmap\": [\n                    \"src/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"BSD-3-Clause\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Sebastian Bergmann\",\n                    \"email\": \"sebastian@phpunit.de\",\n                    \"role\": \"lead\"\n                }\n            ],\n            \"description\": \"Library that helps with managing the version number of Git-hosted PHP projects\",\n            \"homepage\": \"https://github.com/sebastianbergmann/version\",\n            \"time\": \"2016-02-04 12:56:52\"\n        },\n        {\n            \"name\": \"symfony/yaml\",\n            \"version\": \"v3.0.4\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/symfony/yaml.git\",\n                \"reference\": \"0047c8366744a16de7516622c5b7355336afae96\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https://api.github.com/repos/symfony/yaml/zipball/0047c8366744a16de7516622c5b7355336afae96\",\n                \"reference\": \"0047c8366744a16de7516622c5b7355336afae96\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.5.9\"\n            },\n            \"type\": \"library\",\n            \"extra\": {\n                \"branch-alias\": {\n                    \"dev-master\": \"3.0-dev\"\n                }\n            },\n            \"autoload\": {\n                \"psr-4\": {\n                    \"Symfony\\\\Component\\\\Yaml\\\\\": \"\"\n                },\n                \"exclude-from-classmap\": [\n                    \"/Tests/\"\n                ]\n            },\n            \"notification-url\": \"https://packagist.org/downloads/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Fabien Potencier\",\n                    \"email\": \"fabien@symfony.com\"\n                },\n                {\n                    \"name\": \"Symfony Community\",\n                    \"homepage\": \"https://symfony.com/contributors\"\n                }\n            ],\n            \"description\": \"Symfony Yaml Component\",\n            \"homepage\": \"https://symfony.com\",\n            \"time\": \"2016-03-04 07:55:57\"\n        }\n    ],\n    \"aliases\": [],\n    \"minimum-stability\": \"stable\",\n    \"stability-flags\": [],\n    \"prefer-stable\": false,\n    \"prefer-lowest\": false,\n    \"platform\": {\n        \"php\": \">=5.4.0\"\n    },\n    \"platform-dev\": []\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}