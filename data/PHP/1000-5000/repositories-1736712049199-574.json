{
  "metadata": {
    "timestamp": 1736712049199,
    "page": 574,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/polyfill-iconv",
      "stars": 1770,
      "defaultBranch": "1.x",
      "files": [
        {
          "name": "Iconv.php",
          "type": "blob",
          "size": 21.4462890625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Iconv;\n\n/**\n * iconv implementation in pure PHP, UTF-8 centric.\n *\n * Implemented:\n * - iconv              - Convert string to requested character encoding\n * - iconv_mime_decode  - Decodes a MIME header field\n * - iconv_mime_decode_headers - Decodes multiple MIME header fields at once\n * - iconv_get_encoding - Retrieve internal configuration variables of iconv extension\n * - iconv_set_encoding - Set current setting for character encoding conversion\n * - iconv_mime_encode  - Composes a MIME header field\n * - iconv_strlen       - Returns the character count of string\n * - iconv_strpos       - Finds position of first occurrence of a needle within a haystack\n * - iconv_strrpos      - Finds the last occurrence of a needle within a haystack\n * - iconv_substr       - Cut out part of a string\n *\n * Charsets available for conversion are defined by files\n * in the charset/ directory and by Iconv::$alias below.\n * You're welcome to send back any addition you make.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @internal\n */\nfinal class Iconv\n{\n    public const ERROR_ILLEGAL_CHARACTER = 'iconv(): Detected an illegal character in input string';\n    public const ERROR_WRONG_CHARSET = 'iconv(): Wrong charset, conversion from `%s\\' to `%s\\' is not allowed';\n\n    public static $inputEncoding = 'utf-8';\n    public static $outputEncoding = 'utf-8';\n    public static $internalEncoding = 'utf-8';\n\n    private static $alias = [\n        'utf8' => 'utf-8',\n        'ascii' => 'us-ascii',\n        'tis-620' => 'iso-8859-11',\n        'cp1250' => 'windows-1250',\n        'cp1251' => 'windows-1251',\n        'cp1252' => 'windows-1252',\n        'cp1253' => 'windows-1253',\n        'cp1254' => 'windows-1254',\n        'cp1255' => 'windows-1255',\n        'cp1256' => 'windows-1256',\n        'cp1257' => 'windows-1257',\n        'cp1258' => 'windows-1258',\n        'shift-jis' => 'cp932',\n        'shift_jis' => 'cp932',\n        'latin1' => 'iso-8859-1',\n        'latin2' => 'iso-8859-2',\n        'latin3' => 'iso-8859-3',\n        'latin4' => 'iso-8859-4',\n        'latin5' => 'iso-8859-9',\n        'latin6' => 'iso-8859-10',\n        'latin7' => 'iso-8859-13',\n        'latin8' => 'iso-8859-14',\n        'latin9' => 'iso-8859-15',\n        'latin10' => 'iso-8859-16',\n        'iso8859-1' => 'iso-8859-1',\n        'iso8859-2' => 'iso-8859-2',\n        'iso8859-3' => 'iso-8859-3',\n        'iso8859-4' => 'iso-8859-4',\n        'iso8859-5' => 'iso-8859-5',\n        'iso8859-6' => 'iso-8859-6',\n        'iso8859-7' => 'iso-8859-7',\n        'iso8859-8' => 'iso-8859-8',\n        'iso8859-9' => 'iso-8859-9',\n        'iso8859-10' => 'iso-8859-10',\n        'iso8859-11' => 'iso-8859-11',\n        'iso8859-12' => 'iso-8859-12',\n        'iso8859-13' => 'iso-8859-13',\n        'iso8859-14' => 'iso-8859-14',\n        'iso8859-15' => 'iso-8859-15',\n        'iso8859-16' => 'iso-8859-16',\n        'iso_8859-1' => 'iso-8859-1',\n        'iso_8859-2' => 'iso-8859-2',\n        'iso_8859-3' => 'iso-8859-3',\n        'iso_8859-4' => 'iso-8859-4',\n        'iso_8859-5' => 'iso-8859-5',\n        'iso_8859-6' => 'iso-8859-6',\n        'iso_8859-7' => 'iso-8859-7',\n        'iso_8859-8' => 'iso-8859-8',\n        'iso_8859-9' => 'iso-8859-9',\n        'iso_8859-10' => 'iso-8859-10',\n        'iso_8859-11' => 'iso-8859-11',\n        'iso_8859-12' => 'iso-8859-12',\n        'iso_8859-13' => 'iso-8859-13',\n        'iso_8859-14' => 'iso-8859-14',\n        'iso_8859-15' => 'iso-8859-15',\n        'iso_8859-16' => 'iso-8859-16',\n        'iso88591' => 'iso-8859-1',\n        'iso88592' => 'iso-8859-2',\n        'iso88593' => 'iso-8859-3',\n        'iso88594' => 'iso-8859-4',\n        'iso88595' => 'iso-8859-5',\n        'iso88596' => 'iso-8859-6',\n        'iso88597' => 'iso-8859-7',\n        'iso88598' => 'iso-8859-8',\n        'iso88599' => 'iso-8859-9',\n        'iso885910' => 'iso-8859-10',\n        'iso885911' => 'iso-8859-11',\n        'iso885912' => 'iso-8859-12',\n        'iso885913' => 'iso-8859-13',\n        'iso885914' => 'iso-8859-14',\n        'iso885915' => 'iso-8859-15',\n        'iso885916' => 'iso-8859-16',\n    ];\n    private static $translitMap = [];\n    private static $convertMap = [];\n    private static $errorHandler;\n    private static $lastError;\n\n    private static $ulenMask = [\"\\xC0\" => 2, \"\\xD0\" => 2, \"\\xE0\" => 3, \"\\xF0\" => 4];\n    private static $isValidUtf8;\n\n    public static function iconv($inCharset, $outCharset, $str)\n    {\n        $str = (string) $str;\n        if ('' === $str) {\n            return '';\n        }\n\n        // Prepare for //IGNORE and //TRANSLIT\n\n        $translit = $ignore = '';\n\n        $outCharset = strtolower($outCharset);\n        $inCharset = strtolower($inCharset);\n\n        if ('' === $outCharset) {\n            $outCharset = 'iso-8859-1';\n        }\n        if ('' === $inCharset) {\n            $inCharset = 'iso-8859-1';\n        }\n\n        do {\n            $loop = false;\n\n            if ('//translit' === substr($outCharset, -10)) {\n                $loop = $translit = true;\n                $outCharset = substr($outCharset, 0, -10);\n            }\n\n            if ('//ignore' === substr($outCharset, -8)) {\n                $loop = $ignore = true;\n                $outCharset = substr($outCharset, 0, -8);\n            }\n        } while ($loop);\n\n        do {\n            $loop = false;\n\n            if ('//translit' === substr($inCharset, -10)) {\n                $loop = true;\n                $inCharset = substr($inCharset, 0, -10);\n            }\n\n            if ('//ignore' === substr($inCharset, -8)) {\n                $loop = true;\n                $inCharset = substr($inCharset, 0, -8);\n            }\n        } while ($loop);\n\n        if (isset(self::$alias[$inCharset])) {\n            $inCharset = self::$alias[$inCharset];\n        }\n        if (isset(self::$alias[$outCharset])) {\n            $outCharset = self::$alias[$outCharset];\n        }\n\n        // Load charset maps\n\n        if (('utf-8' !== $inCharset && !self::loadMap('from.', $inCharset, $inMap))\n          || ('utf-8' !== $outCharset && !self::loadMap('to.', $outCharset, $outMap))) {\n            trigger_error(sprintf(self::ERROR_WRONG_CHARSET, $inCharset, $outCharset));\n\n            return false;\n        }\n\n        if ('utf-8' !== $inCharset) {\n            // Convert input to UTF-8\n            $result = '';\n            if (self::mapToUtf8($result, $inMap, $str, $ignore)) {\n                $str = $result;\n            } else {\n                $str = false;\n            }\n            self::$isValidUtf8 = true;\n        } else {\n            self::$isValidUtf8 = preg_match('//u', $str);\n\n            if (!self::$isValidUtf8 && !$ignore) {\n                trigger_error(self::ERROR_ILLEGAL_CHARACTER);\n\n                return false;\n            }\n\n            if ('utf-8' === $outCharset) {\n                // UTF-8 validation\n                $str = self::utf8ToUtf8($str, $ignore);\n            }\n        }\n\n        if ('utf-8' !== $outCharset && false !== $str) {\n            // Convert output to UTF-8\n            $result = '';\n            if (self::mapFromUtf8($result, $outMap, $str, $ignore, $translit)) {\n                return $result;\n            }\n\n            return false;\n        }\n\n        return $str;\n    }\n\n    public static function iconv_mime_decode_headers($str, $mode = 0, $charset = null)\n    {\n        if (null === $charset) {\n            $charset = self::$internalEncoding;\n        }\n\n        if (false !== strpos($str, \"\\r\")) {\n            $str = strtr(str_replace(\"\\r\\n\", \"\\n\", $str), \"\\r\", \"\\n\");\n        }\n        $str = explode(\"\\n\\n\", $str, 2);\n\n        $headers = [];\n\n        $str = preg_split('/\\n(?![ \\t])/', $str[0]);\n        foreach ($str as $str) {\n            $str = self::iconv_mime_decode($str, $mode, $charset);\n            if (false === $str) {\n                return false;\n            }\n            $str = explode(':', $str, 2);\n\n            if (2 === \\count($str)) {\n                if (isset($headers[$str[0]])) {\n                    if (!\\is_array($headers[$str[0]])) {\n                        $headers[$str[0]] = [$headers[$str[0]]];\n                    }\n                    $headers[$str[0]][] = ltrim($str[1]);\n                } else {\n                    $headers[$str[0]] = ltrim($str[1]);\n                }\n            }\n        }\n\n        return $headers;\n    }\n\n    public static function iconv_mime_decode($str, $mode = 0, $charset = null)\n    {\n        if (null === $charset) {\n            $charset = self::$internalEncoding;\n        }\n        if (\\ICONV_MIME_DECODE_CONTINUE_ON_ERROR & $mode) {\n            $charset .= '//IGNORE';\n        }\n\n        if (false !== strpos($str, \"\\r\")) {\n            $str = strtr(str_replace(\"\\r\\n\", \"\\n\", $str), \"\\r\", \"\\n\");\n        }\n        $str = preg_split('/\\n(?![ \\t])/', rtrim($str), 2);\n        $str = preg_replace('/[ \\t]*\\n[ \\t]+/', ' ', rtrim($str[0]));\n        $str = preg_split('/=\\?([^?]+)\\?([bqBQ])\\?(.*?)\\?=/', $str, -1, \\PREG_SPLIT_DELIM_CAPTURE);\n\n        $result = self::iconv('utf-8', $charset, $str[0]);\n        if (false === $result) {\n            return false;\n        }\n\n        $i = 1;\n        $len = \\count($str);\n\n        while ($i < $len) {\n            $c = strtolower($str[$i]);\n            if ((\\ICONV_MIME_DECODE_CONTINUE_ON_ERROR & $mode)\n              && 'utf-8' !== $c\n              && !isset(self::$alias[$c])\n              && !self::loadMap('from.', $c, $d)) {\n                $d = false;\n            } elseif ('B' === strtoupper($str[$i + 1])) {\n                $d = base64_decode($str[$i + 2]);\n            } else {\n                $d = rawurldecode(strtr(str_replace('%', '%25', $str[$i + 2]), '=_', '% '));\n            }\n\n            if (false !== $d) {\n                if ('' !== $d) {\n                    if ('' === $d = self::iconv($c, $charset, $d)) {\n                        $str[$i + 3] = substr($str[$i + 3], 1);\n                    } else {\n                        $result .= $d;\n                    }\n                }\n                $d = self::iconv('utf-8', $charset, $str[$i + 3]);\n                if ('' !== trim($d)) {\n                    $result .= $d;\n                }\n            } elseif (\\ICONV_MIME_DECODE_CONTINUE_ON_ERROR & $mode) {\n                $result .= \"=?{$str[$i]}?{$str[$i + 1]}?{$str[$i + 2]}?={$str[$i + 3]}\";\n            } else {\n                $result = false;\n                break;\n            }\n\n            $i += 4;\n        }\n\n        return $result;\n    }\n\n    public static function iconv_get_encoding($type = 'all')\n    {\n        switch ($type) {\n            case 'input_encoding': return self::$inputEncoding;\n            case 'output_encoding': return self::$outputEncoding;\n            case 'internal_encoding': return self::$internalEncoding;\n        }\n\n        return [\n            'input_encoding' => self::$inputEncoding,\n            'output_encoding' => self::$outputEncoding,\n            'internal_encoding' => self::$internalEncoding,\n        ];\n    }\n\n    public static function iconv_set_encoding($type, $charset)\n    {\n        switch ($type) {\n            case 'input_encoding': self::$inputEncoding = $charset; break;\n            case 'output_encoding': self::$outputEncoding = $charset; break;\n            case 'internal_encoding': self::$internalEncoding = $charset; break;\n            default: return false;\n        }\n\n        return true;\n    }\n\n    public static function iconv_mime_encode($fieldName, $fieldValue, $pref = null)\n    {\n        if (!\\is_array($pref)) {\n            $pref = [];\n        }\n\n        $pref += [\n            'scheme' => 'B',\n            'input-charset' => self::$internalEncoding,\n            'output-charset' => self::$internalEncoding,\n            'line-length' => 76,\n            'line-break-chars' => \"\\r\\n\",\n        ];\n\n        if (preg_match('/[\\x80-\\xFF]/', $fieldName)) {\n            $fieldName = '';\n        }\n\n        $scheme = strtoupper(substr($pref['scheme'], 0, 1));\n        $in = strtolower($pref['input-charset']);\n        $out = strtolower($pref['output-charset']);\n\n        if ('utf-8' !== $in && false === $fieldValue = self::iconv($in, 'utf-8', $fieldValue)) {\n            return false;\n        }\n\n        preg_match_all('/./us', $fieldValue, $chars);\n\n        $chars = $chars[0] ?? [];\n\n        $lineBreak = (int) $pref['line-length'];\n        $lineStart = \"=?{$pref['output-charset']}?{$scheme}?\";\n        $lineLength = \\strlen($fieldName) + 2 + \\strlen($lineStart) + 2;\n        $lineOffset = \\strlen($lineStart) + 3;\n        $lineData = '';\n\n        $fieldValue = [];\n\n        $Q = 'Q' === $scheme;\n\n        foreach ($chars as $c) {\n            if ('utf-8' !== $out && false === $c = self::iconv('utf-8', $out, $c)) {\n                return false;\n            }\n\n            $o = $Q\n                ? $c = preg_replace_callback(\n                    '/[=_\\?\\x00-\\x1F\\x80-\\xFF]/',\n                    [__CLASS__, 'qpByteCallback'],\n                    $c\n                )\n                : base64_encode($lineData.$c);\n\n            if (isset($o[$lineBreak - $lineLength])) {\n                if (!$Q) {\n                    $lineData = base64_encode($lineData);\n                }\n                $fieldValue[] = $lineStart.$lineData.'?=';\n                $lineLength = $lineOffset;\n                $lineData = '';\n            }\n\n            $lineData .= $c;\n            $Q && $lineLength += \\strlen($c);\n        }\n\n        if ('' !== $lineData) {\n            if (!$Q) {\n                $lineData = base64_encode($lineData);\n            }\n            $fieldValue[] = $lineStart.$lineData.'?=';\n        }\n\n        return $fieldName.': '.implode($pref['line-break-chars'].' ', $fieldValue);\n    }\n\n    public static function iconv_strlen($s, $encoding = null)\n    {\n        if (null === $encoding) {\n            $encoding = self::$internalEncoding;\n        }\n        if (0 !== stripos($encoding, 'utf-8') && false === $s = self::iconv($encoding, 'utf-8', $s)) {\n            return false;\n        }\n\n        $ulenMask = self::$ulenMask;\n\n        $i = 0;\n        $j = 0;\n        $len = \\strlen($s);\n\n        while ($i < $len) {\n            $u = $s[$i] & \"\\xF0\";\n            $i += $ulenMask[$u] ?? 1;\n            ++$j;\n        }\n\n        return $j;\n    }\n\n    public static function iconv_strpos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        if (null === $encoding) {\n            $encoding = self::$internalEncoding;\n        }\n\n        if (0 !== stripos($encoding, 'utf-8')) {\n            if (false === $haystack = self::iconv($encoding, 'utf-8', $haystack)) {\n                return false;\n            }\n            if (false === $needle = self::iconv($encoding, 'utf-8', $needle)) {\n                return false;\n            }\n        }\n\n        if ($offset = (int) $offset) {\n            $haystack = self::iconv_substr($haystack, $offset, 2147483647, 'utf-8');\n        }\n        $pos = strpos($haystack, $needle);\n\n        return false === $pos ? false : ($offset + ($pos ? self::iconv_strlen(substr($haystack, 0, $pos), 'utf-8') : 0));\n    }\n\n    public static function iconv_strrpos($haystack, $needle, $encoding = null)\n    {\n        if (null === $encoding) {\n            $encoding = self::$internalEncoding;\n        }\n\n        if (0 !== stripos($encoding, 'utf-8')) {\n            if (false === $haystack = self::iconv($encoding, 'utf-8', $haystack)) {\n                return false;\n            }\n            if (false === $needle = self::iconv($encoding, 'utf-8', $needle)) {\n                return false;\n            }\n        }\n\n        $pos = isset($needle[0]) ? strrpos($haystack, $needle) : false;\n\n        return false === $pos ? false : self::iconv_strlen($pos ? substr($haystack, 0, $pos) : $haystack, 'utf-8');\n    }\n\n    public static function iconv_substr($s, $start, $length = 2147483647, $encoding = null)\n    {\n        if (null === $encoding) {\n            $encoding = self::$internalEncoding;\n        }\n        if (0 !== stripos($encoding, 'utf-8')) {\n            $encoding = null;\n        } elseif (false === $s = self::iconv($encoding, 'utf-8', $s)) {\n            return false;\n        }\n\n        $s = (string) $s;\n        $slen = self::iconv_strlen($s, 'utf-8');\n        $start = (int) $start;\n\n        if (0 > $start) {\n            $start += $slen;\n        }\n        if (0 > $start) {\n            if (\\PHP_VERSION_ID < 80000) {\n                return false;\n            }\n\n            $start = 0;\n        }\n        if ($start >= $slen) {\n            return \\PHP_VERSION_ID >= 80000 ? '' : false;\n        }\n\n        $rx = $slen - $start;\n\n        if (0 > $length) {\n            $length += $rx;\n        }\n        if (0 === $length) {\n            return '';\n        }\n        if (0 > $length) {\n            return \\PHP_VERSION_ID >= 80000 ? '' : false;\n        }\n\n        if ($length > $rx) {\n            $length = $rx;\n        }\n\n        $rx = '/^'.($start ? self::pregOffset($start) : '').'('.self::pregOffset($length).')/u';\n\n        $s = preg_match($rx, $s, $s) ? $s[1] : '';\n\n        if (null === $encoding) {\n            return $s;\n        }\n\n        return self::iconv('utf-8', $encoding, $s);\n    }\n\n    private static function loadMap($type, $charset, &$map)\n    {\n        if (!isset(self::$convertMap[$type.$charset])) {\n            if (false === $map = self::getData($type.$charset)) {\n                if ('to.' === $type && self::loadMap('from.', $charset, $map)) {\n                    $map = array_flip($map);\n                } else {\n                    return false;\n                }\n            }\n\n            self::$convertMap[$type.$charset] = $map;\n        } else {\n            $map = self::$convertMap[$type.$charset];\n        }\n\n        return true;\n    }\n\n    private static function utf8ToUtf8($str, $ignore)\n    {\n        $ulenMask = self::$ulenMask;\n        $valid = self::$isValidUtf8;\n\n        $u = $str;\n        $i = $j = 0;\n        $len = \\strlen($str);\n\n        while ($i < $len) {\n            if ($str[$i] < \"\\x80\") {\n                $u[$j++] = $str[$i++];\n            } else {\n                $ulen = $str[$i] & \"\\xF0\";\n                $ulen = $ulenMask[$ulen] ?? 1;\n                $uchr = substr($str, $i, $ulen);\n\n                if (1 === $ulen || !($valid || preg_match('/^.$/us', $uchr))) {\n                    if ($ignore) {\n                        ++$i;\n                        continue;\n                    }\n\n                    trigger_error(self::ERROR_ILLEGAL_CHARACTER);\n\n                    return false;\n                }\n\n                $i += $ulen;\n\n                $u[$j++] = $uchr[0];\n\n                isset($uchr[1]) && 0 !== ($u[$j++] = $uchr[1])\n                    && isset($uchr[2]) && 0 !== ($u[$j++] = $uchr[2])\n                    && isset($uchr[3]) && 0 !== ($u[$j++] = $uchr[3]);\n            }\n        }\n\n        return substr($u, 0, $j);\n    }\n\n    private static function mapToUtf8(&$result, array $map, $str, $ignore)\n    {\n        $len = \\strlen($str);\n        for ($i = 0; $i < $len; ++$i) {\n            if (isset($str[$i + 1], $map[$str[$i].$str[$i + 1]])) {\n                $result .= $map[$str[$i].$str[++$i]];\n            } elseif (isset($map[$str[$i]])) {\n                $result .= $map[$str[$i]];\n            } elseif (!$ignore) {\n                trigger_error(self::ERROR_ILLEGAL_CHARACTER);\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private static function mapFromUtf8(&$result, array $map, $str, $ignore, $translit)\n    {\n        $ulenMask = self::$ulenMask;\n        $valid = self::$isValidUtf8;\n\n        if ($translit && !self::$translitMap) {\n            self::$translitMap = self::getData('translit');\n        }\n\n        $i = 0;\n        $len = \\strlen($str);\n\n        while ($i < $len) {\n            if ($str[$i] < \"\\x80\") {\n                $uchr = $str[$i++];\n            } else {\n                $ulen = $str[$i] & \"\\xF0\";\n                $ulen = $ulenMask[$ulen] ?? 1;\n                $uchr = substr($str, $i, $ulen);\n\n                if ($ignore && (1 === $ulen || !($valid || preg_match('/^.$/us', $uchr)))) {\n                    ++$i;\n                    continue;\n                }\n\n                $i += $ulen;\n            }\n\n            if (isset($map[$uchr])) {\n                $result .= $map[$uchr];\n            } elseif ($translit) {\n                if (isset(self::$translitMap[$uchr])) {\n                    $uchr = self::$translitMap[$uchr];\n                } elseif ($uchr >= \"\\xC3\\x80\") {\n                    $uchr = \\Normalizer::normalize($uchr, \\Normalizer::NFD);\n\n                    if ($uchr[0] < \"\\x80\") {\n                        $uchr = $uchr[0];\n                    } elseif ($ignore) {\n                        continue;\n                    } else {\n                        return false;\n                    }\n                } elseif ($ignore) {\n                    continue;\n                } else {\n                    return false;\n                }\n\n                $str = $uchr.substr($str, $i);\n                $len = \\strlen($str);\n                $i = 0;\n            } elseif (!$ignore) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private static function qpByteCallback(array $m)\n    {\n        return '='.strtoupper(dechex(\\ord($m[0])));\n    }\n\n    private static function pregOffset($offset)\n    {\n        $rx = [];\n        $offset = (int) $offset;\n\n        while ($offset > 65535) {\n            $rx[] = '.{65535}';\n            $offset -= 65535;\n        }\n\n        return implode('', $rx).'.{'.$offset.'}';\n    }\n\n    private static function getData($file)\n    {\n        if (file_exists($file = __DIR__.'/Resources/charset/'.$file.'.php')) {\n            return require $file;\n        }\n\n        return false;\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2015-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.412109375,
          "content": "Symfony Polyfill / Iconv\n========================\n\nThis component provides a native PHP implementation of the\n[php.net/iconv](https://php.net/iconv) functions\n(short of [`ob_iconv_handler`](https://php.net/ob-iconv-handler)).\n\nMore information can be found in the\n[main Polyfill README](https://github.com/symfony/polyfill/blob/main/README.md).\n\nLicense\n=======\n\nThis library is released under the [MIT license](LICENSE).\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "bootstrap.php",
          "type": "blob",
          "size": 3.8544921875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Iconv as p;\n\nif (extension_loaded('iconv')) {\n    return;\n}\n\nif (\\PHP_VERSION_ID >= 80000) {\n    return require __DIR__.'/bootstrap80.php';\n}\n\nif (!defined('ICONV_IMPL')) {\n    define('ICONV_IMPL', 'Symfony');\n}\nif (!defined('ICONV_VERSION')) {\n    define('ICONV_VERSION', '1.0');\n}\nif (!defined('ICONV_MIME_DECODE_STRICT')) {\n    define('ICONV_MIME_DECODE_STRICT', 1);\n}\nif (!defined('ICONV_MIME_DECODE_CONTINUE_ON_ERROR')) {\n    define('ICONV_MIME_DECODE_CONTINUE_ON_ERROR', 2);\n}\n\nif (!function_exists('iconv')) {\n    function iconv($from_encoding, $to_encoding, $string) { return p\\Iconv::iconv($from_encoding, $to_encoding, $string); }\n}\nif (!function_exists('iconv_get_encoding')) {\n    function iconv_get_encoding($type = 'all') { return p\\Iconv::iconv_get_encoding($type); }\n}\nif (!function_exists('iconv_set_encoding')) {\n    function iconv_set_encoding($type, $encoding) { return p\\Iconv::iconv_set_encoding($type, $encoding); }\n}\nif (!function_exists('iconv_mime_encode')) {\n    function iconv_mime_encode($field_name, $field_value, $options = []) { return p\\Iconv::iconv_mime_encode($field_name, $field_value, $options); }\n}\nif (!function_exists('iconv_mime_decode_headers')) {\n    function iconv_mime_decode_headers($headers, $mode = 0, $encoding = null) { return p\\Iconv::iconv_mime_decode_headers($headers, $mode, $encoding); }\n}\n\nif (extension_loaded('mbstring')) {\n    if (!function_exists('iconv_strlen')) {\n        function iconv_strlen($string, $encoding = null) { null === $encoding && $encoding = p\\Iconv::$internalEncoding; return mb_strlen($string, $encoding); }\n    }\n    if (!function_exists('iconv_strpos')) {\n        function iconv_strpos($haystack, $needle, $offset = 0, $encoding = null) { null === $encoding && $encoding = p\\Iconv::$internalEncoding; return mb_strpos($haystack, $needle, $offset, $encoding); }\n    }\n    if (!function_exists('iconv_strrpos')) {\n        function iconv_strrpos($haystack, $needle, $encoding = null) { null === $encoding && $encoding = p\\Iconv::$internalEncoding; return mb_strrpos($haystack, $needle, 0, $encoding); }\n    }\n    if (!function_exists('iconv_substr')) {\n        function iconv_substr($string, $offset, $length = 2147483647, $encoding = null) { null === $encoding && $encoding = p\\Iconv::$internalEncoding; return mb_substr($string, $offset, $length, $encoding); }\n    }\n    if (!function_exists('iconv_mime_decode')) {\n        function iconv_mime_decode($string, $mode = 0, $encoding = null) { $currentMbEncoding = mb_internal_encoding(); null === $encoding && $encoding = p\\Iconv::$internalEncoding; mb_internal_encoding($encoding); $decoded = mb_decode_mimeheader($string); mb_internal_encoding($currentMbEncoding); return $decoded; }\n    }\n} else {\n    if (!function_exists('iconv_strlen')) {\n        function iconv_strlen($string, $encoding = null) { return p\\Iconv::iconv_strlen($string, $encoding); }\n    }\n\n    if (!function_exists('iconv_strpos')) {\n        function iconv_strpos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Iconv::iconv_strpos($haystack, $needle, $offset, $encoding); }\n    }\n    if (!function_exists('iconv_strrpos')) {\n        function iconv_strrpos($haystack, $needle, $encoding = null) { return p\\Iconv::iconv_strrpos($haystack, $needle, $encoding); }\n    }\n    if (!function_exists('iconv_substr')) {\n        function iconv_substr($string, $offset, $length = 2147483647, $encoding = null) { return p\\Iconv::iconv_substr($string, $offset, $length, $encoding); }\n    }\n    if (!function_exists('iconv_mime_decode')) {\n        function iconv_mime_decode($string, $mode = 0, $encoding = null) { return p\\Iconv::iconv_mime_decode($string, $mode, $encoding); }\n    }\n}\n"
        },
        {
          "name": "bootstrap80.php",
          "type": "blob",
          "size": 4.421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Iconv as p;\n\nif (!defined('ICONV_IMPL')) {\n    define('ICONV_IMPL', 'Symfony');\n}\nif (!defined('ICONV_VERSION')) {\n    define('ICONV_VERSION', '1.0');\n}\nif (!defined('ICONV_MIME_DECODE_STRICT')) {\n    define('ICONV_MIME_DECODE_STRICT', 1);\n}\nif (!defined('ICONV_MIME_DECODE_CONTINUE_ON_ERROR')) {\n    define('ICONV_MIME_DECODE_CONTINUE_ON_ERROR', 2);\n}\n\nif (!function_exists('iconv')) {\n    function iconv(?string $from_encoding, ?string $to_encoding, ?string $string): string|false { return p\\Iconv::iconv((string) $from_encoding, (string) $to_encoding, (string) $string); }\n}\nif (!function_exists('iconv_get_encoding')) {\n    function iconv_get_encoding(?string $type = 'all'): array|string|false { return p\\Iconv::iconv_get_encoding((string) $type); }\n}\nif (!function_exists('iconv_set_encoding')) {\n    function iconv_set_encoding(?string $type, ?string $encoding): bool { return p\\Iconv::iconv_set_encoding((string) $type, (string) $encoding); }\n}\nif (!function_exists('iconv_mime_encode')) {\n    function iconv_mime_encode(?string $field_name, ?string $field_value, ?array $options = []): string|false { return p\\Iconv::iconv_mime_encode((string) $field_name, (string) $field_value, (array) $options); }\n}\nif (!function_exists('iconv_mime_decode_headers')) {\n    function iconv_mime_decode_headers(?string $headers, ?int $mode = 0, ?string $encoding = null): array|false { return p\\Iconv::iconv_mime_decode_headers((string) $headers, (int) $mode, $encoding); }\n}\n\nif (extension_loaded('mbstring')) {\n    if (!function_exists('iconv_strlen')) {\n        function iconv_strlen(?string $string, ?string $encoding = null): int|false { null === $encoding && $encoding = p\\Iconv::$internalEncoding; return mb_strlen((string) $string, $encoding); }\n    }\n    if (!function_exists('iconv_strpos')) {\n        function iconv_strpos(?string $haystack, ?string $needle, ?int $offset = 0, ?string $encoding = null): int|false { null === $encoding && $encoding = p\\Iconv::$internalEncoding; return mb_strpos((string) $haystack, (string) $needle, (int) $offset, $encoding); }\n    }\n    if (!function_exists('iconv_strrpos')) {\n        function iconv_strrpos(?string $haystack, ?string $needle, ?string $encoding = null): int|false { null === $encoding && $encoding = p\\Iconv::$internalEncoding; return mb_strrpos((string) $haystack, (string) $needle, 0, $encoding); }\n    }\n    if (!function_exists('iconv_substr')) {\n        function iconv_substr(?string $string, ?int $offset, ?int $length = null, ?string $encoding = null): string|false { null === $encoding && $encoding = p\\Iconv::$internalEncoding; return mb_substr((string) $string, (int) $offset, $length, $encoding); }\n    }\n    if (!function_exists('iconv_mime_decode')) {\n        function iconv_mime_decode($string, $mode = 0, $encoding = null) { $currentMbEncoding = mb_internal_encoding(); null === $encoding && $encoding = p\\Iconv::$internalEncoding; mb_internal_encoding($encoding); $decoded = mb_decode_mimeheader($string); mb_internal_encoding($currentMbEncoding); return $decoded; }\n    }\n} else {\n    if (!function_exists('iconv_strlen')) {\n        function iconv_strlen(?string $string, ?string $encoding = null): int|false { return p\\Iconv::iconv_strlen((string) $string, $encoding); }\n    }\n\n    if (!function_exists('iconv_strpos')) {\n        function iconv_strpos(?string $haystack, ?string $needle, ?int $offset = 0, ?string $encoding = null): int|false { return p\\Iconv::iconv_strpos((string) $haystack, (string) $needle, (int) $offset, $encoding); }\n    }\n    if (!function_exists('iconv_strrpos')) {\n        function iconv_strrpos(?string $haystack, ?string $needle, ?string $encoding = null): int|false { return p\\Iconv::iconv_strrpos((string) $haystack, (string) $needle, $encoding); }\n    }\n    if (!function_exists('iconv_substr')) {\n        function iconv_substr(?string $string, ?int $offset, ?int $length = null, ?string $encoding = null): string|false { return p\\Iconv::iconv_substr((string) $string, (string) $offset, $length, $encoding); }\n    }\n    if (!function_exists('iconv_mime_decode')) {\n        function iconv_mime_decode(?string $string, ?int $mode = 0, ?string $encoding = null): string|false { return p\\Iconv::iconv_mime_decode((string) $string, (int) $mode, $encoding); }\n    }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.943359375,
          "content": "{\n    \"name\": \"symfony/polyfill-iconv\",\n    \"type\": \"library\",\n    \"description\": \"Symfony polyfill for the Iconv extension\",\n    \"keywords\": [\"polyfill\", \"shim\", \"compatibility\", \"portable\", \"iconv\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Nicolas Grekas\",\n            \"email\": \"p@tchwork.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=7.2\"\n    },\n    \"provide\": {\n        \"ext-iconv\": \"*\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Polyfill\\\\Iconv\\\\\": \"\" },\n        \"files\": [ \"bootstrap.php\" ]\n    },\n    \"suggest\": {\n        \"ext-iconv\": \"For best performance\"\n    },\n    \"minimum-stability\": \"dev\",\n    \"extra\": {\n        \"thanks\": {\n            \"name\": \"symfony/polyfill\",\n            \"url\": \"https://github.com/symfony/polyfill\"\n        }\n    }\n}\n"
        }
      ]
    }
  ]
}