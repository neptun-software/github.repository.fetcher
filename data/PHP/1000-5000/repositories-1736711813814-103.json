{
  "metadata": {
    "timestamp": 1736711813814,
    "page": 103,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/dotenv",
      "stars": 3754,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.5009765625,
          "content": "CHANGELOG\n=========\n\n7.1\n---\n\n * Add `SYMFONY_DOTENV_PATH` variable with the path to the `.env` file loaded by `Dotenv::loadEnv()` or `Dotenv::bootEnv()`\n\n6.2\n---\n\n * Add a new `filter` argument to `debug:dotenv` command to filter variable names\n\n5.4\n---\n\n * Add `dotenv:dump` command to compile the contents of the .env files into a PHP-optimized file called `.env.local.php`\n * Add `debug:dotenv` command to list all dotenv files with variables and values\n * Add `$overrideExistingVars` on `Dotenv::bootEnv()` and `Dotenv::loadEnv()`\n\n5.1.0\n-----\n\n * added `Dotenv::bootEnv()` to check for `.env.local.php` before calling `Dotenv::loadEnv()`\n * added `Dotenv::setProdEnvs()` and `Dotenv::usePutenv()`\n * made Dotenv's constructor accept `$envKey` and `$debugKey` arguments, to define\n   the name of the env vars that configure the env name and debug settings\n * deprecated passing `$usePutenv` argument to Dotenv's constructor\n\n5.0.0\n-----\n\n * using `putenv()` is disabled by default\n\n4.3.0\n-----\n\n * deprecated use of `putenv()` by default. This feature will be opted-in with a constructor argument to `Dotenv`\n\n4.2.0\n-----\n\n * added `Dotenv::overload()` and `$overrideExistingVars` as optional parameter of `Dotenv::populate()`\n * added `Dotenv::loadEnv()` to load a .env file and its corresponding .env.local, .env.$env and .env.$env.local files if they exist\n\n3.3.0\n-----\n\n * [BC BREAK] Since v3.3.7, the latest Dotenv files override the previous ones. Real env vars are not affected and are not overridden.\n * added the component\n"
        },
        {
          "name": "Command",
          "type": "tree",
          "content": null
        },
        {
          "name": "Dotenv.php",
          "type": "blob",
          "size": 20.591796875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Dotenv;\n\nuse Symfony\\Component\\Dotenv\\Exception\\FormatException;\nuse Symfony\\Component\\Dotenv\\Exception\\FormatExceptionContext;\nuse Symfony\\Component\\Dotenv\\Exception\\PathException;\nuse Symfony\\Component\\Process\\Exception\\ExceptionInterface as ProcessException;\nuse Symfony\\Component\\Process\\Process;\n\n/**\n * Manages .env files.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author KÃ©vin Dunglas <dunglas@gmail.com>\n */\nfinal class Dotenv\n{\n    public const VARNAME_REGEX = '(?i:_?[A-Z][A-Z0-9_]*+)';\n    public const STATE_VARNAME = 0;\n    public const STATE_VALUE = 1;\n\n    private string $path;\n    private int $cursor;\n    private int $lineno;\n    private string $data;\n    private int $end;\n    private array $values = [];\n    private array $prodEnvs = ['prod'];\n    private bool $usePutenv = false;\n\n    public function __construct(\n        private string $envKey = 'APP_ENV',\n        private string $debugKey = 'APP_DEBUG',\n    ) {\n    }\n\n    /**\n     * @return $this\n     */\n    public function setProdEnvs(array $prodEnvs): static\n    {\n        $this->prodEnvs = $prodEnvs;\n\n        return $this;\n    }\n\n    /**\n     * @param bool $usePutenv If `putenv()` should be used to define environment variables or not.\n     *                        Beware that `putenv()` is not thread safe, that's why it's not enabled by default\n     *\n     * @return $this\n     */\n    public function usePutenv(bool $usePutenv = true): static\n    {\n        $this->usePutenv = $usePutenv;\n\n        return $this;\n    }\n\n    /**\n     * Loads one or several .env files.\n     *\n     * @param string $path          A file to load\n     * @param string ...$extraPaths A list of additional files to load\n     *\n     * @throws FormatException when a file has a syntax error\n     * @throws PathException   when a file does not exist or is not readable\n     */\n    public function load(string $path, string ...$extraPaths): void\n    {\n        $this->doLoad(false, \\func_get_args());\n    }\n\n    /**\n     * Loads a .env file and the corresponding .env.local, .env.$env and .env.$env.local files if they exist.\n     *\n     * .env.local is always ignored in test env because tests should produce the same results for everyone.\n     * .env.dist is loaded when it exists and .env is not found.\n     *\n     * @param string      $path                 A file to load\n     * @param string|null $envKey               The name of the env vars that defines the app env\n     * @param string      $defaultEnv           The app env to use when none is defined\n     * @param array       $testEnvs             A list of app envs for which .env.local should be ignored\n     * @param bool        $overrideExistingVars Whether existing environment variables set by the system should be overridden\n     *\n     * @throws FormatException when a file has a syntax error\n     * @throws PathException   when a file does not exist or is not readable\n     */\n    public function loadEnv(string $path, ?string $envKey = null, string $defaultEnv = 'dev', array $testEnvs = ['test'], bool $overrideExistingVars = false): void\n    {\n        $this->populatePath($path);\n\n        $k = $envKey ?? $this->envKey;\n\n        if (is_file($path) || !is_file($p = \"$path.dist\")) {\n            $this->doLoad($overrideExistingVars, [$path]);\n        } else {\n            $this->doLoad($overrideExistingVars, [$p]);\n        }\n\n        if (null === $env = $_SERVER[$k] ?? $_ENV[$k] ?? null) {\n            $this->populate([$k => $env = $defaultEnv], $overrideExistingVars);\n        }\n\n        if (!\\in_array($env, $testEnvs, true) && is_file($p = \"$path.local\")) {\n            $this->doLoad($overrideExistingVars, [$p]);\n            $env = $_SERVER[$k] ?? $_ENV[$k] ?? $env;\n        }\n\n        if ('local' === $env) {\n            return;\n        }\n\n        if (is_file($p = \"$path.$env\")) {\n            $this->doLoad($overrideExistingVars, [$p]);\n        }\n\n        if (is_file($p = \"$path.$env.local\")) {\n            $this->doLoad($overrideExistingVars, [$p]);\n        }\n    }\n\n    /**\n     * Loads env vars from .env.local.php if the file exists or from the other .env files otherwise.\n     *\n     * This method also configures the APP_DEBUG env var according to the current APP_ENV.\n     *\n     * See method loadEnv() for rules related to .env files.\n     */\n    public function bootEnv(string $path, string $defaultEnv = 'dev', array $testEnvs = ['test'], bool $overrideExistingVars = false): void\n    {\n        $p = $path.'.local.php';\n        $env = is_file($p) ? include $p : null;\n        $k = $this->envKey;\n\n        if (\\is_array($env) && ($overrideExistingVars || !isset($env[$k]) || ($_SERVER[$k] ?? $_ENV[$k] ?? $env[$k]) === $env[$k])) {\n            $this->populatePath($path);\n            $this->populate($env, $overrideExistingVars);\n        } else {\n            $this->loadEnv($path, $k, $defaultEnv, $testEnvs, $overrideExistingVars);\n        }\n\n        $_SERVER += $_ENV;\n\n        $k = $this->debugKey;\n        $debug = $_SERVER[$k] ?? !\\in_array($_SERVER[$this->envKey], $this->prodEnvs, true);\n        $_SERVER[$k] = $_ENV[$k] = (int) $debug || (!\\is_bool($debug) && filter_var($debug, \\FILTER_VALIDATE_BOOL)) ? '1' : '0';\n    }\n\n    /**\n     * Loads one or several .env files and enables override existing vars.\n     *\n     * @param string $path          A file to load\n     * @param string ...$extraPaths A list of additional files to load\n     *\n     * @throws FormatException when a file has a syntax error\n     * @throws PathException   when a file does not exist or is not readable\n     */\n    public function overload(string $path, string ...$extraPaths): void\n    {\n        $this->doLoad(true, \\func_get_args());\n    }\n\n    /**\n     * Sets values as environment variables (via putenv, $_ENV, and $_SERVER).\n     *\n     * @param array $values               An array of env variables\n     * @param bool  $overrideExistingVars Whether existing environment variables set by the system should be overridden\n     */\n    public function populate(array $values, bool $overrideExistingVars = false): void\n    {\n        $updateLoadedVars = false;\n        $loadedVars = array_flip(explode(',', $_SERVER['SYMFONY_DOTENV_VARS'] ?? $_ENV['SYMFONY_DOTENV_VARS'] ?? ''));\n\n        foreach ($values as $name => $value) {\n            $notHttpName = !str_starts_with($name, 'HTTP_');\n            if (isset($_SERVER[$name]) && $notHttpName && !isset($_ENV[$name])) {\n                $_ENV[$name] = $_SERVER[$name];\n            }\n\n            // don't check existence with getenv() because of thread safety issues\n            if (!isset($loadedVars[$name]) && !$overrideExistingVars && isset($_ENV[$name])) {\n                continue;\n            }\n\n            if ($this->usePutenv) {\n                putenv(\"$name=$value\");\n            }\n\n            $_ENV[$name] = $value;\n            if ($notHttpName) {\n                $_SERVER[$name] = $value;\n            }\n\n            if (!isset($loadedVars[$name])) {\n                $loadedVars[$name] = $updateLoadedVars = true;\n            }\n        }\n\n        if ($updateLoadedVars) {\n            unset($loadedVars['']);\n            $loadedVars = implode(',', array_keys($loadedVars));\n            $_ENV['SYMFONY_DOTENV_VARS'] = $_SERVER['SYMFONY_DOTENV_VARS'] = $loadedVars;\n\n            if ($this->usePutenv) {\n                putenv('SYMFONY_DOTENV_VARS='.$loadedVars);\n            }\n        }\n    }\n\n    /**\n     * Parses the contents of an .env file.\n     *\n     * @param string $data The data to be parsed\n     * @param string $path The original file name where data where stored (used for more meaningful error messages)\n     *\n     * @throws FormatException when a file has a syntax error\n     */\n    public function parse(string $data, string $path = '.env'): array\n    {\n        $this->path = $path;\n        $this->data = str_replace([\"\\r\\n\", \"\\r\"], \"\\n\", $data);\n        $this->lineno = 1;\n        $this->cursor = 0;\n        $this->end = \\strlen($this->data);\n        $state = self::STATE_VARNAME;\n        $this->values = [];\n        $name = '';\n\n        $this->skipEmptyLines();\n\n        while ($this->cursor < $this->end) {\n            switch ($state) {\n                case self::STATE_VARNAME:\n                    $name = $this->lexVarname();\n                    $state = self::STATE_VALUE;\n                    break;\n\n                case self::STATE_VALUE:\n                    $this->values[$name] = $this->lexValue();\n                    $state = self::STATE_VARNAME;\n                    break;\n            }\n        }\n\n        if (self::STATE_VALUE === $state) {\n            $this->values[$name] = '';\n        }\n\n        try {\n            return $this->values;\n        } finally {\n            $this->values = [];\n            unset($this->path, $this->cursor, $this->lineno, $this->data, $this->end);\n        }\n    }\n\n    private function lexVarname(): string\n    {\n        // var name + optional export\n        if (!preg_match('/(export[ \\t]++)?('.self::VARNAME_REGEX.')/A', $this->data, $matches, 0, $this->cursor)) {\n            throw $this->createFormatException('Invalid character in variable name');\n        }\n        $this->moveCursor($matches[0]);\n\n        if ($this->cursor === $this->end || \"\\n\" === $this->data[$this->cursor] || '#' === $this->data[$this->cursor]) {\n            if ($matches[1]) {\n                throw $this->createFormatException('Unable to unset an environment variable');\n            }\n\n            throw $this->createFormatException('Missing = in the environment variable declaration');\n        }\n\n        if (' ' === $this->data[$this->cursor] || \"\\t\" === $this->data[$this->cursor]) {\n            throw $this->createFormatException('Whitespace characters are not supported after the variable name');\n        }\n\n        if ('=' !== $this->data[$this->cursor]) {\n            throw $this->createFormatException('Missing = in the environment variable declaration');\n        }\n        ++$this->cursor;\n\n        return $matches[2];\n    }\n\n    private function lexValue(): string\n    {\n        if (preg_match('/[ \\t]*+(?:#.*)?$/Am', $this->data, $matches, 0, $this->cursor)) {\n            $this->moveCursor($matches[0]);\n            $this->skipEmptyLines();\n\n            return '';\n        }\n\n        if (' ' === $this->data[$this->cursor] || \"\\t\" === $this->data[$this->cursor]) {\n            throw $this->createFormatException('Whitespace are not supported before the value');\n        }\n\n        $loadedVars = array_flip(explode(',', $_SERVER['SYMFONY_DOTENV_VARS'] ?? $_ENV['SYMFONY_DOTENV_VARS'] ?? ''));\n        unset($loadedVars['']);\n        $v = '';\n\n        do {\n            if (\"'\" === $this->data[$this->cursor]) {\n                $len = 0;\n\n                do {\n                    if ($this->cursor + ++$len === $this->end) {\n                        $this->cursor += $len;\n\n                        throw $this->createFormatException('Missing quote to end the value');\n                    }\n                } while (\"'\" !== $this->data[$this->cursor + $len]);\n\n                $v .= substr($this->data, 1 + $this->cursor, $len - 1);\n                $this->cursor += 1 + $len;\n            } elseif ('\"' === $this->data[$this->cursor]) {\n                $value = '';\n\n                if (++$this->cursor === $this->end) {\n                    throw $this->createFormatException('Missing quote to end the value');\n                }\n\n                while ('\"' !== $this->data[$this->cursor] || ('\\\\' === $this->data[$this->cursor - 1] && '\\\\' !== $this->data[$this->cursor - 2])) {\n                    $value .= $this->data[$this->cursor];\n                    ++$this->cursor;\n\n                    if ($this->cursor === $this->end) {\n                        throw $this->createFormatException('Missing quote to end the value');\n                    }\n                }\n                ++$this->cursor;\n                $value = str_replace(['\\\\\"', '\\r', '\\n'], ['\"', \"\\r\", \"\\n\"], $value);\n                $resolvedValue = $value;\n                $resolvedValue = $this->resolveCommands($resolvedValue, $loadedVars);\n                $resolvedValue = $this->resolveVariables($resolvedValue, $loadedVars);\n                $resolvedValue = str_replace('\\\\\\\\', '\\\\', $resolvedValue);\n                $v .= $resolvedValue;\n            } else {\n                $value = '';\n                $prevChr = $this->data[$this->cursor - 1];\n                while ($this->cursor < $this->end && !\\in_array($this->data[$this->cursor], [\"\\n\", '\"', \"'\"], true) && !((' ' === $prevChr || \"\\t\" === $prevChr) && '#' === $this->data[$this->cursor])) {\n                    if ('\\\\' === $this->data[$this->cursor] && isset($this->data[$this->cursor + 1]) && ('\"' === $this->data[$this->cursor + 1] || \"'\" === $this->data[$this->cursor + 1])) {\n                        ++$this->cursor;\n                    }\n\n                    $value .= $prevChr = $this->data[$this->cursor];\n\n                    if ('$' === $this->data[$this->cursor] && isset($this->data[$this->cursor + 1]) && '(' === $this->data[$this->cursor + 1]) {\n                        ++$this->cursor;\n                        $value .= '('.$this->lexNestedExpression().')';\n                    }\n\n                    ++$this->cursor;\n                }\n                $value = rtrim($value);\n                $resolvedValue = $value;\n                $resolvedValue = $this->resolveCommands($resolvedValue, $loadedVars);\n                $resolvedValue = $this->resolveVariables($resolvedValue, $loadedVars);\n                $resolvedValue = str_replace('\\\\\\\\', '\\\\', $resolvedValue);\n\n                if ($resolvedValue === $value && preg_match('/\\s+/', $value)) {\n                    throw $this->createFormatException('A value containing spaces must be surrounded by quotes');\n                }\n\n                $v .= $resolvedValue;\n\n                if ($this->cursor < $this->end && '#' === $this->data[$this->cursor]) {\n                    break;\n                }\n            }\n        } while ($this->cursor < $this->end && \"\\n\" !== $this->data[$this->cursor]);\n\n        $this->skipEmptyLines();\n\n        return $v;\n    }\n\n    private function lexNestedExpression(): string\n    {\n        ++$this->cursor;\n        $value = '';\n\n        while (\"\\n\" !== $this->data[$this->cursor] && ')' !== $this->data[$this->cursor]) {\n            $value .= $this->data[$this->cursor];\n\n            if ('(' === $this->data[$this->cursor]) {\n                $value .= $this->lexNestedExpression().')';\n            }\n\n            ++$this->cursor;\n\n            if ($this->cursor === $this->end) {\n                throw $this->createFormatException('Missing closing parenthesis.');\n            }\n        }\n\n        if (\"\\n\" === $this->data[$this->cursor]) {\n            throw $this->createFormatException('Missing closing parenthesis.');\n        }\n\n        return $value;\n    }\n\n    private function skipEmptyLines(): void\n    {\n        if (preg_match('/(?:\\s*+(?:#[^\\n]*+)?+)++/A', $this->data, $match, 0, $this->cursor)) {\n            $this->moveCursor($match[0]);\n        }\n    }\n\n    private function resolveCommands(string $value, array $loadedVars): string\n    {\n        if (!str_contains($value, '$')) {\n            return $value;\n        }\n\n        $regex = '/\n            (\\\\\\\\)?               # escaped with a backslash?\n            \\$\n            (?<cmd>\n                \\(                # require opening parenthesis\n                ([^()]|\\g<cmd>)+  # allow any number of non-parens, or balanced parens (by nesting the <cmd> expression recursively)\n                \\)                # require closing paren\n            )\n        /x';\n\n        return preg_replace_callback($regex, function ($matches) use ($loadedVars) {\n            if ('\\\\' === $matches[1]) {\n                return substr($matches[0], 1);\n            }\n\n            if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n                throw new \\LogicException('Resolving commands is not supported on Windows.');\n            }\n\n            if (!class_exists(Process::class)) {\n                throw new \\LogicException('Resolving commands requires the Symfony Process component. Try running \"composer require symfony/process\".');\n            }\n\n            $process = Process::fromShellCommandline('echo '.$matches[0]);\n\n            $env = [];\n            foreach ($this->values as $name => $value) {\n                if (isset($loadedVars[$name]) || (!isset($_ENV[$name]) && !(isset($_SERVER[$name]) && !str_starts_with($name, 'HTTP_')))) {\n                    $env[$name] = $value;\n                }\n            }\n            $process->setEnv($env);\n\n            try {\n                $process->mustRun();\n            } catch (ProcessException) {\n                throw $this->createFormatException(\\sprintf('Issue expanding a command (%s)', $process->getErrorOutput()));\n            }\n\n            return rtrim($process->getOutput(), \"\\n\\r\");\n        }, $value);\n    }\n\n    private function resolveVariables(string $value, array $loadedVars): string\n    {\n        if (!str_contains($value, '$')) {\n            return $value;\n        }\n\n        $regex = '/\n            (?<!\\\\\\\\)\n            (?P<backslashes>\\\\\\\\*)             # escaped with a backslash?\n            \\$\n            (?!\\()                             # no opening parenthesis\n            (?P<opening_brace>\\{)?             # optional brace\n            (?P<name>'.self::VARNAME_REGEX.')? # var name\n            (?P<default_value>:[-=][^\\}]*+)?   # optional default value\n            (?P<closing_brace>\\})?             # optional closing brace\n        /x';\n\n        return preg_replace_callback($regex, function ($matches) use ($loadedVars) {\n            // odd number of backslashes means the $ character is escaped\n            if (1 === \\strlen($matches['backslashes']) % 2) {\n                return substr($matches[0], 1);\n            }\n\n            // unescaped $ not followed by variable name\n            if (!isset($matches['name'])) {\n                return $matches[0];\n            }\n\n            if ('{' === $matches['opening_brace'] && !isset($matches['closing_brace'])) {\n                throw $this->createFormatException('Unclosed braces on variable expansion');\n            }\n\n            $name = $matches['name'];\n            if (isset($loadedVars[$name]) && isset($this->values[$name])) {\n                $value = $this->values[$name];\n            } elseif (isset($_ENV[$name])) {\n                $value = $_ENV[$name];\n            } elseif (isset($_SERVER[$name]) && !str_starts_with($name, 'HTTP_')) {\n                $value = $_SERVER[$name];\n            } elseif (isset($this->values[$name])) {\n                $value = $this->values[$name];\n            } else {\n                $value = (string) getenv($name);\n            }\n\n            if ('' === $value && isset($matches['default_value']) && '' !== $matches['default_value']) {\n                $unsupportedChars = strpbrk($matches['default_value'], '\\'\"{$');\n                if (false !== $unsupportedChars) {\n                    throw $this->createFormatException(\\sprintf('Unsupported character \"%s\" found in the default value of variable \"$%s\".', $unsupportedChars[0], $name));\n                }\n\n                $value = substr($matches['default_value'], 2);\n\n                if ('=' === $matches['default_value'][1]) {\n                    $this->values[$name] = $value;\n                }\n            }\n\n            if (!$matches['opening_brace'] && isset($matches['closing_brace'])) {\n                $value .= '}';\n            }\n\n            return $matches['backslashes'].$value;\n        }, $value);\n    }\n\n    private function moveCursor(string $text): void\n    {\n        $this->cursor += \\strlen($text);\n        $this->lineno += substr_count($text, \"\\n\");\n    }\n\n    private function createFormatException(string $message): FormatException\n    {\n        return new FormatException($message, new FormatExceptionContext($this->data, $this->path, $this->lineno, $this->cursor));\n    }\n\n    private function doLoad(bool $overrideExistingVars, array $paths): void\n    {\n        foreach ($paths as $path) {\n            if (!is_readable($path) || is_dir($path)) {\n                throw new PathException($path);\n            }\n\n            $data = file_get_contents($path);\n\n            if (\"\\xEF\\xBB\\xBF\" === substr($data, 0, 3)) {\n                throw new FormatException('Loading files starting with a byte-order-mark (BOM) is not supported.', new FormatExceptionContext($data, $path, 1, 0));\n            }\n\n            $this->populate($this->parse($data, $path), $overrideExistingVars);\n        }\n    }\n\n    private function populatePath(string $path): void\n    {\n        $_ENV['SYMFONY_DOTENV_PATH'] = $_SERVER['SYMFONY_DOTENV_PATH'] = $path;\n\n        if ($this->usePutenv) {\n            putenv('SYMFONY_DOTENV_PATH='.$path);\n        }\n    }\n}\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2016-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.8837890625,
          "content": "Dotenv Component\n================\n\nSymfony Dotenv parses `.env` files to make environment variables stored in them\naccessible via `$_SERVER` or `$_ENV`.\n\nGetting Started\n---------------\n\n```bash\ncomposer require symfony/dotenv\n```\n\n```php\nuse Symfony\\Component\\Dotenv\\Dotenv;\n\n$dotenv = new Dotenv();\n$dotenv->load(__DIR__.'/.env');\n\n// you can also load several files\n$dotenv->load(__DIR__.'/.env', __DIR__.'/.env.dev');\n\n// overwrites existing env variables\n$dotenv->overload(__DIR__.'/.env');\n\n// loads .env, .env.local, and .env.$APP_ENV.local or .env.$APP_ENV\n$dotenv->loadEnv(__DIR__.'/.env');\n```\n\nResources\n---------\n\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.8935546875,
          "content": "{\n    \"name\": \"symfony/dotenv\",\n    \"type\": \"library\",\n    \"description\": \"Registers environment variables from a .env file\",\n    \"keywords\": [\"environment\", \"env\", \"dotenv\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\" : \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\"\n    },\n    \"require-dev\": {\n        \"symfony/console\": \"^6.4|^7.0\",\n        \"symfony/process\": \"^6.4|^7.0\"\n    },\n    \"conflict\": {\n        \"symfony/console\": \"<6.4\",\n        \"symfony/process\": \"<6.4\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Dotenv\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.7978515625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Dotenv Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}