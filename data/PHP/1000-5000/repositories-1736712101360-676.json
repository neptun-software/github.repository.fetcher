{
  "metadata": {
    "timestamp": 1736712101360,
    "page": 676,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vlucas/valitron",
      "stars": 1579,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1650390625,
          "content": "/tests              export-ignore\n/.gitattributes     export-ignore\n/.gitignore         export-ignore\n/.travis.yml        export-ignore\n/phpunit.xml        export-ignore"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0712890625,
          "content": ".DS_Store\ncomposer.phar\ncomposer.lock\nvendor\n.idea/\n.phpunit.result.cache"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.5126953125,
          "content": "The BSD 3-Clause License\nhttp://opensource.org/licenses/BSD-3-Clause\n\nCopyright (c) 2013, Vance Lucas\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n * Redistributions of source code must retain the above copyright\n   notice,\nthis list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n * Neither the name of the Vance Lucas nor the names of its contributors\nmay be used to endorse or promote products derived from this software\nwithout specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 34.6025390625,
          "content": "## Valitron: Easy Validation That Doesn't Suck\n\nValitron is a simple, minimal and elegant stand-alone validation library\nwith NO dependencies. Valitron uses simple, straightforward validation\nmethods with a focus on readable and concise syntax. Valitron is the\nsimple and pragmatic validation library you've been looking for.\n\n[![Build\nStatus](https://github.com/vlucas/valitron/actions/workflows/test.yml/badge.svg)](https://github.com/vlucas/valitron/actions/workflows/test.yml)\n[![Latest Stable Version](https://poser.pugx.org/vlucas/valitron/v/stable.png)](https://packagist.org/packages/vlucas/valitron)\n[![Total Downloads](https://poser.pugx.org/vlucas/valitron/downloads.png)](https://packagist.org/packages/vlucas/valitron)\n\n[Get supported vlucas/valitron with the Tidelift Subscription](https://tidelift.com/subscription/pkg/packagist-vlucas-valitron?utm_source=packagist-vlucas-valitron&utm_medium=referral&utm_campaign=readme) \n\n## Why Valitron?\n\nValitron was created out of frustration with other validation libraries\nthat have dependencies on large components from other frameworks like\nSymfony's HttpFoundation, pulling in a ton of extra files that aren't\nreally needed for basic validation. It also has purposefully simple\nsyntax used to run all validations in one call instead of individually\nvalidating each value by instantiating new classes and validating values\none at a time like some other validation libraries require.\n\nIn short, Valitron is everything you've been looking for in a validation\nlibrary but haven't been able to find until now: simple pragmatic\nsyntax, lightweight code that makes sense, extensible for custom\ncallbacks and validations, well tested, and without dependencies. Let's\nget started.\n\n## Installation\n\nValitron uses [Composer](http://getcomposer.org) to install and update:\n\n```\ncurl -s http://getcomposer.org/installer | php\nphp composer.phar require vlucas/valitron\n```\n\nThe examples below use PHP 5.4 syntax, but Valitron works on PHP 5.3+.\n\n## Usage\n\nUsage is simple and straightforward. Just supply an array of data you\nwish to validate, add some rules, and then call `validate()`. If there\nare any errors, you can call `errors()` to get them.\n\n```php\n$v = new Valitron\\Validator(array('name' => 'Chester Tester'));\n$v->rule('required', 'name');\nif($v->validate()) {\n    echo \"Yay! We're all good!\";\n} else {\n    // Errors\n    print_r($v->errors());\n}\n```\n\nUsing this format, you can validate `$_POST` data directly and easily,\nand can even apply a rule like `required` to an array of fields:\n\n```php\n$v = new Valitron\\Validator($_POST);\n$v->rule('required', ['name', 'email']);\n$v->rule('email', 'email');\nif($v->validate()) {\n    echo \"Yay! We're all good!\";\n} else {\n    // Errors\n    print_r($v->errors());\n}\n```\n\nYou may use dot syntax to access members of multi-dimensional arrays,\nand an asterisk to validate each member of an array:\n\n```php\n$v = new Valitron\\Validator(array('settings' => array(\n    array('threshold' => 50),\n    array('threshold' => 90)\n)));\n$v->rule('max', 'settings.*.threshold', 100);\nif($v->validate()) {\n    echo \"Yay! We're all good!\";\n} else {\n    // Errors\n    print_r($v->errors());\n}\n```\n\nOr use dot syntax to validate all members of a numeric array:\n\n```php\n$v = new Valitron\\Validator(array('values' => array(50, 90)));\n$v->rule('max', 'values.*', 100);\nif($v->validate()) {\n    echo \"Yay! We're all good!\";\n} else {\n    // Errors\n    print_r($v->errors());\n}\n```\n\nYou can also access nested values using dot notation:\n\n```php\n$v = new Valitron\\Validator(array('user' => array('first_name' => 'Steve', 'last_name' => 'Smith', 'username' => 'Batman123')));\n$v->rule('alpha', 'user.first_name')->rule('alpha', 'user.last_name')->rule('alphaNum', 'user.username');\nif($v->validate()) {\n    echo \"Yay! We're all good!\";\n} else {\n    // Errors\n    print_r($v->errors());\n}\n```\n\nSetting language and language dir globally:\n\n```php\n\n// boot or config file\n\nuse Valitron\\Validator as V;\n\nV::langDir(__DIR__.'/validator_lang'); // always set langDir before lang.\nV::lang('ar');\n\n```\n\nDisabling the {field} name in the output of the error message. \n\n```php\nuse Valitron\\Validator as V;\n\n$v = new Valitron\\Validator(['name' => 'John']);\n$v->rule('required', ['name']);\n\n// Disable prepending the labels\n$v->setPrependLabels(false);\n\n// Error output for the \"false\" condition\n[\n    [\"name\"] => [\n        \"is required\"\n    ]\n]\n\n// Error output for the default (true) condition\n[\n    [\"name\"] => [\n        \"name is required\"\n    ]\n]\n\n```\n\nYou can conditionally require values using required conditional rules. In this example, for authentication, we're requiring either a token when both the email and password are not present, or a password when the email address is present.\n```php\n// this rule set would work for either data set...\n$data = ['email' => 'test@test.com', 'password' => 'mypassword'];\n// or...\n$data = ['token' => 'jashdjahs83rufh89y38h38h'];\n\n$v = new Valitron\\Validator($data);\n$v->rules([\n    'requiredWithout' => [\n        ['token', ['email', 'password'], true]\n    ],\n    'requiredWith' => [\n        ['password', ['email']]\n    ],\n    'email' => [\n        ['email']\n    ]\n    'optional' => [\n        ['email']\n    ]\n]);\n$this->assertTrue($v->validate());\n```\n\n## Built-in Validation Rules\n\n * `required` - Field is required\n * `requiredWith` - Field is required if any other fields are present\n * `requiredWithout` - Field is required if any other fields are NOT present\n * `equals` - Field must match another field (email/password confirmation)\n * `different` - Field must be different than another field\n * `accepted` - Checkbox or Radio must be accepted (yes, on, 1, true)\n * `numeric` - Must be numeric\n * `integer` - Must be integer number\n * `boolean` - Must be boolean\n * `array` - Must be array\n * `length` - String must be certain length\n * `lengthBetween` - String must be between given lengths\n * `lengthMin` - String must be greater than given length\n * `lengthMax` - String must be less than given length\n * `min` - Minimum\n * `max` - Maximum\n * `listContains` - Performs in_array check on given array values (the other way round than `in`)\n * `in` - Performs in_array check on given array values\n * `notIn` - Negation of `in` rule (not in array of values)\n * `ip` - Valid IP address\n * `ipv4` - Valid IP v4 address\n * `ipv6` - Valid IP v6 address\n * `email` - Valid email address\n * `emailDNS` - Valid email address with active DNS record\n * `url` - Valid URL\n * `urlActive` - Valid URL with active DNS record\n * `alpha` - Alphabetic characters only\n * `alphaNum` - Alphabetic and numeric characters only\n * `ascii` - ASCII characters only\n * `slug` - URL slug characters (a-z, 0-9, -, \\_)\n * `regex` - Field matches given regex pattern\n * `date` - Field is a valid date\n * `dateFormat` - Field is a valid date in the given format\n * `dateBefore` - Field is a valid date and is before the given date\n * `dateAfter` - Field is a valid date and is after the given date\n * `contains` - Field is a string and contains the given string\n * `subset` - Field is an array or a scalar and all elements are contained in the given array\n * `containsUnique` - Field is an array and contains unique values\n * `creditCard` - Field is a valid credit card number\n * `instanceOf` - Field contains an instance of the given class\n * `optional` - Value does not need to be included in data array. If it is however, it must pass validation.\n * `arrayHasKeys` - Field is an array and contains all specified keys.\n\n**NOTE**: If you are comparing floating-point numbers with min/max validators, you\nshould install the [BCMath](http://us3.php.net/manual/en/book.bc.php)\nextension for greater accuracy and reliability. The extension is not required\nfor Valitron to work, but Valitron will use it if available, and it is highly\nrecommended.\n\n## required fields usage\nthe `required` rule checks if a field exists in the data array, and is not null or an empty string.\n```php\n$v->rule('required', 'field_name');\n```\n\nUsing an extra parameter, you can make this rule more flexible, and only check if the field exists in the data array.\n```php\n$v->rule('required', 'field_name', true);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'spiderman', 'password' => 'Gr33nG0Blin', 'required_but_null' => null]);\n$v->rules([\n    'required' => [\n        ['username'],\n        ['password'],\n        ['required_but_null', true] // boolean flag allows empty value so long as the field name is set on the data array\n    ]\n]);\n$v->validate();\n```\n\n## requiredWith fields usage\nThe `requiredWith` rule checks that the field is required, not null, and not the empty string, if any other fields are present, not null, and not the empty string.\n```php\n// password field will be required when the username field is provided and not empty\n$v->rule('requiredWith', 'password', 'username');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'spiderman', 'password' => 'Gr33nG0Blin']);\n$v->rules([\n    'requiredWith' => [\n        ['password', 'username']\n    ]\n]);\n$v->validate();\n```\n\n*Note* You can provide multiple values as an array. In this case if ANY of the fields are present the field will be required.\n```php\n// in this case the password field will be required if the username or email fields are present\n$v->rule('requiredWith', 'password', ['username', 'email']);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'spiderman', 'password' => 'Gr33nG0Blin']);\n$v->rules([\n    'requiredWith' => [\n        ['password', ['username', 'email']]\n    ]\n]);\n$v->validate();\n```\n\n### Strict flag\nThe strict flag will change the `requiredWith` rule to `requiredWithAll` which will require the field only if ALL of the other fields are present, not null, and not the empty string.\n```php\n// in this example the suffix field is required only when both the first_name and last_name are provided\n$v->rule('requiredWith', 'suffix', ['first_name', 'last_name'], true);\n```\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['first_name' => 'steve', 'last_name' => 'holt', 'suffix' => 'Mr']);\n$v->rules([\n    'requiredWith' => [\n        ['suffix', ['first_name', 'last_name'], true]\n    ]\n]);\n$v->validate();\n```\n\nLikewise, in this case `validate()` would still return true, as the suffix field would not be required in strict mode, as not all of the fields are provided.\n```php\n$v = new Valitron\\Validator(['first_name' => 'steve']);\n$v->rules([\n    'requiredWith' => [\n        ['suffix', ['first_name', 'last_name'], true]\n    ]\n]);\n$v->validate();\n```\n\n## requiredWithout fields usage\nThe `requiredWithout` rule checks that the field is required, not null, and not the empty string, if any other fields are NOT present.\n```php\n// this rule will require the username field when the first_name is not present\n$v->rule('requiredWithout', 'username', 'first_name')\n```\n\nAlternate syntax.\n```php\n// this will return true, as the username is provided when the first_name is not provided\n$v = new Valitron\\Validator(['username' => 'spiderman']);\n$v->rules([\n    'requiredWithout' => [\n        ['username', 'first_name']\n    ]\n]);\n$v->validate();\n```\n\n*Note* You can provide multiple values as an array. In this case if ANY of the fields are NOT present the field will be required.\n```php\n// in this case the username field will be required if either the first_name or last_name fields are not present\n$v->rule('requiredWithout', 'username', ['first_name', 'last_name']);\n```\n\nAlternate syntax.\n```php\n// this passes validation because although the last_name field is not present, the username is provided\n$v = new Valitron\\Validator(['username' => 'spiderman', 'first_name' => 'Peter']);\n$v->rules([\n    'requiredWithout' => [\n        ['username', ['first_name', 'last_name']]\n    ]\n]);\n$v->validate();\n```\n\n### Strict flag\nThe strict flag will change the `requiredWithout` rule to `requiredWithoutAll` which will require the field only if ALL of the other fields are not present.\n```php\n// in this example the username field is required only when both the first_name and last_name are not provided\n$v->rule('requiredWithout', 'username', ['first_name', 'last_name'], true);\n```\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'BatMan']);\n$v->rules([\n    'requiredWithout' => [\n        ['username', ['first_name', 'last_name'], true]\n    ]\n]);\n$v->validate();\n```\n\nLikewise, in this case `validate()` would still return true, as the username field would not be required in strict mode, as all of the fields are provided.\n```php\n$v = new Valitron\\Validator(['first_name' => 'steve', 'last_name' => 'holt']);\n$v->rules([\n    'requiredWithout' => [\n        ['suffix', ['first_name', 'last_name'], true]\n    ]\n]);\n$v->validate();\n```\n\n## equals fields usage\nThe `equals` rule checks if two fields are equals in the data array, and that the second field is not null.\n```php\n$v->rule('equals', 'password', 'confirmPassword');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['password' => 'youshouldnotseethis', 'confirmPassword' => 'youshouldnotseethis']);\n$v->rules([\n    'equals' => [\n        ['password', 'confirmPassword']\n    ]\n]);\n$v->validate();\n```\n\n## different fields usage\nThe `different` rule checks if two fields are not the same, or different, in the data array and that the second field is not null.\n```php\n$v->rule('different', 'username', 'password');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'spiderman', 'password' => 'Gr33nG0Blin']);\n$v->rules([\n    'different' => [\n        ['username', 'password']\n    ]\n]);\n$v->validate();\n```\n\n## accepted fields usage\nThe `accepted` rule checks if the field is either 'yes', 'on', 1, or true.\n```php\n$v->rule('accepted', 'remember_me');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['remember_me' => true]);\n$v->rules([\n    'accepted' => [\n        ['remember_me']\n    ]\n]);\n$v->validate();\n```\n\n## numeric fields usage\nThe `numeric` rule checks if the field is number. This is analogous to php's is_numeric() function.\n```php\n$v->rule('numeric', 'amount');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['amount' => 3.14]);\n$v->rules([\n    'numeric' => [\n        ['amount']\n    ]\n]);\n$v->validate();\n```\n\n## integer fields usage\nThe `integer` rule checks if the field is an integer number.\n```php\n$v->rule('integer', 'age');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['age' => '27']);\n$v->rules([\n    'integer' => [\n        ['age']\n    ]\n]);\n$v->validate();\n```\n\n*Note* the optional boolean flag for strict mode makes sure integers are to be supplied in a strictly numeric form. So the following rule would evaluate to true:\n```php\n$v = new Valitron\\Validator(['negative' => '-27', 'positive'=>'27']);\n$v->rule('integer', 'age', true);\n$v->rule('integer', 'height', true);\n$v->validate();\n```\n\nWhereas the following will evaluate to false, as the + for the positive number in this case is redundant:\n```php\n$v = new Valitron\\Validator(['negative' => '-27', 'positive'=>'+27']);\n$v->rule('integer', 'age', true);\n$v->rule('integer', 'height', true);\n$v->validate();\n```\n\n## boolean fields usage\nThe `boolean` rule checks if the field is a boolean. This is analogous to php's is_bool() function.\n```php\n$v->rule('boolean', 'remember_me');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['remember_me' => true]);\n$v->rules([\n    'boolean' => [\n        ['remember_me']\n    ]\n]);\n$v->validate();\n```\n\n## array fields usage\nThe `array` rule checks if the field is an array. This is analogous to php's is_array() function.\n```php\n$v->rule('array', 'user_notifications');\n```\n\nAlternate Syntax.\n```php\n$v = new Valitron\\Validator(['user_notifications' => ['bulletin_notifications' => true, 'marketing_notifications' => false, 'message_notification' => true]]);\n$v->rules([\n    'array' => [\n        ['user_notifications']\n    ]\n]);\n$v->validate();\n```\n\n## length fields usage\nThe `length` rule checks if the field is exactly a given length and that the field is a valid string.\n```php\n$v->rule('length', 'username', 10);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'bobburgers']);\n$v->rules([\n    'length' => [\n        ['username', 10]\n    ]\n]);\n$v->validate();\n```\n\n## lengthBetween fields usage\nThe `lengthBetween` rule checks if the field is between a given length tange and that the field is a valid string.\n```php\n$v->rule('lengthBetween', 'username', 1, 10);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'bobburgers']);\n$v->rules([\n    'lengthBetween' => [\n        ['username', 1, 10]\n    ]\n]);\n$v->validate();\n```\n\n## lengthMin fields usage\nThe `lengthMin` rule checks if the field is at least a given length and that the field is a valid string.\n```php\n$v->rule('lengthMin', 'username', 5);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'martha']);\n$v->rules([\n    'lengthMin' => [\n        ['username', 5]\n    ]\n]);\n$v->validate();\n```\n\n## lengthMax fields usage\nThe `lengthMax` rule checks if the field is at most a given length and that the field is a valid string.\n```php\n$v->rule('lengthMax', 'username', 10);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'bruins91']);\n$v->rules([\n    'lengthMax' => [\n        ['username', 10]\n    ]\n]);\n$v->validate();\n```\n\n## min fields usage\nThe `min` rule checks if the field is at least a given value and that the provided value is numeric.\n```php\n$v->rule('min', 'age', 18);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['age' => 28]);\n$v->rules([\n    'min' => [\n        ['age', 18]\n    ]\n]);\n$v->validate();\n```\n\n## max fields usage\nThe `max` rule checks if the field is at most a given value and that the provided value is numeric.\n```php\n$v->rule('max', 'age', 12);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['age' => 10]);\n$v->rules([\n    'max' => [\n        ['age', 12]\n    ]\n]);\n$v->validate();\n```\n\n## listContains fields usage\nThe `listContains` rule checks that the field is present in a given array of values.\n```php\n$v->rule('listContains', 'color', 'yellow');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['color' => ['blue', 'green', 'red', 'yellow']]);\n$v->rules([\n    'listContains' => [\n        ['color', 'yellow']\n    ]\n]);\n$v->validate();\n```\n\n## in fields usage\nThe `in` rule checks that the field is present in a given array of values.\n```php\n$v->rule('in', 'color', ['blue', 'green', 'red', 'purple']);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['color' => 'purple']);\n$v->rules([\n    'in' => [\n        ['color', ['blue', 'green', 'red', 'purple']]\n    ]\n]);\n$v->validate();\n```\n\n## notIn fields usage\nThe `notIn` rule checks that the field is NOT present in a given array of values.\n```php\n$v->rule('notIn', 'color', ['blue', 'green', 'red', 'yellow']);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['color' => 'purple']);\n$v->rules([\n    'notIn' => [\n        ['color', ['blue', 'green', 'red', 'yellow']]\n    ]\n]);\n$v->validate();\n```\n\n## ip fields usage\nThe `ip` rule checks that the field is a valid ip address. This includes IPv4, IPv6, private, and reserved ranges.\n```php\n$v->rule('ip', 'user_ip');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['user_ip' => '127.0.0.1']);\n$v->rules([\n    'ip' => [\n        ['user_ip']\n    ]\n]);\n$v->validate();\n```\n\n## ipv4 fields usage\nThe `ipv4` rule checks that the field is a valid IPv4 address.\n```php\n$v->rule('ipv4', 'user_ip');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['user_ip' => '127.0.0.1']);\n$v->rules([\n    'ipv4' => [\n        ['user_ip']\n    ]\n]);\n$v->validate();\n```\n\n## ipv6 fields usage\nThe `ipv6` rule checks that the field is a valid IPv6 address.\n```php\n$v->rule('ipv6', 'user_ip');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['user_ip' => '0:0:0:0:0:0:0:1']);\n$v->rules([\n    'ipv6' => [\n        ['user_ip']\n    ]\n]);\n$v->validate();\n```\n\n## email fields usage\nThe `email` rule checks that the field is a valid email address.\n```php\n$v->rule('email', 'user_email');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['user_email' => 'someone@example.com']);\n$v->rules([\n    'email' => [\n        ['user_email']\n    ]\n]);\n$v->validate();\n```\n\n## emailDNS fields usage\nThe `emailDNS` rule validates the field is a valid email address with an active DNS record or any type.\n```php\n$v->rule('emailDNS', 'user_email');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['user_email' => 'some_fake_email_address@gmail.com']);\n$v->rules([\n    'emailDNS' => [\n        ['user_email']\n    ]\n]);\n$v->validate();\n```\n\n## url fields usage\nThe `url` rule checks the field is a valid url.\n```php\n$v->rule('url', 'website');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['website' => 'https://example.com/contact']);\n$v->rules([\n    'url' => [\n        ['website']\n    ]\n]);\n$v->validate();\n```\n\n## urlActive fields usage\nThe `urlActive` rule checks the field is a valid url with an active A, AAAA, or CNAME record.\n```php\n$v->rule('urlActive', 'website');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['website' => 'https://example.com/contact']);\n$v->rules([\n    'urlActive' => [\n        ['website']\n    ]\n]);\n$v->validate();\n```\n\n## alpha fields usage\nThe `alpha` rule checks the field is alphabetic characters only.\n```php\n$v->rule('alpha', 'username');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'batman']);\n$v->rules([\n    'alpha' => [\n        ['username']\n    ]\n]);\n$v->validate();\n```\n\n## alphaNum fields usage\nThe `alphaNum` rule checks the field contains only alphabetic or numeric characters.\n```php\n$v->rule('alphaNum', 'username');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'batman123']);\n$v->rules([\n    'alphaNum' => [\n        ['username']\n    ]\n]);\n$v->validate();\n```\n\n## ascii fields usage\nThe `ascii` rule checks the field contains only characters in the ascii character set.\n```php\n$v->rule('ascii', 'username');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'batman123']);\n$v->rules([\n    'ascii' => [\n        ['username']\n    ]\n]);\n$v->validate();\n```\n\n## slug fields usage\nThe `slug` rule checks that the field only contains URL slug characters (a-z, 0-9, -, _).\n```php\n$v->rule('slug', 'username');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'L337-H4ckZ0rz_123']);\n$v->rules([\n    'slug' => [\n        ['username']\n    ]\n]);\n$v->validate();\n```\n\n## regex fields usage\nThe `regex` rule ensures the field matches a given regex pattern.\n(This regex checks the string is alpha numeric between 5-10 characters).\n```php\n$v->rule('regex', 'username', '/^[a-zA-Z0-9]{5,10}$/');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'Batman123']);\n$v->rules([\n    'regex' => [\n        ['username', '/^[a-zA-Z0-9]{5,10}$/']\n    ]\n]);\n$v->validate();\n```\n\n## date fields usage\nThe `date` rule checks if the supplied field is a valid \\DateTime object or if the string can be converted to a unix timestamp via strtotime().\n```php\n$v->rule('date', 'created_at');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['created_at' => '2018-10-13']);\n$v->rules([\n    'date' => [\n        ['created_at']\n    ]\n]);\n$v->validate();\n```\n\n## dateFormat fields usage\nThe `dateFormat` rule checks that the supplied field is a valid date in a specified date format.\n```php\n$v->rule('dateFormat', 'created_at', 'Y-m-d');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['created_at' => '2018-10-13']);\n$v->rules([\n    'dateFormat' => [\n        ['created_at', 'Y-m-d']\n    ]\n]);\n$v->validate();\n```\n\n## dateBefore fields usage\nThe `dateBefore` rule checks that the supplied field is a valid date before a specified date.\n```php\n$v->rule('dateBefore', 'created_at', '2018-10-13');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['created_at' => '2018-09-01']);\n$v->rules([\n    'dateBefore' => [\n        ['created_at', '2018-10-13']\n    ]\n]);\n$v->validate();\n```\n\n## dateAfter fields usage\nThe `dateAfter` rule checks that the supplied field is a valid date after a specified date.\n```php\n$v->rule('dateAfter', 'created_at', '2018-10-13');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['created_at' => '2018-09-01']);\n$v->rules([\n    'dateAfter' => [\n        ['created_at', '2018-01-01']\n    ]\n]);\n$v->validate();\n```\n\n## contains fields usage\nThe `contains` rule checks that a given string exists within the field and checks that the field and the search value are both valid strings.\n```php\n$v->rule('contains', 'username', 'man');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['username' => 'Batman123']);\n$v->rules([\n    'contains' => [\n        ['username', 'man']\n    ]\n]);\n$v->validate();\n```\n\n*Note* You can use the optional strict flag to ensure a case-sensitive match.\nThe following example will return true:\n```php\n$v = new Valitron\\Validator(['username' => 'Batman123']);\n$v->rules([\n    'contains' => [\n        ['username', 'man']\n    ]\n]);\n$v->validate();\n```\nWhereas, this would return false, as the M in the search string is not uppercase in the provided value:\n```php\n$v = new Valitron\\Validator(['username' => 'Batman123']);\n$v->rules([\n    'contains' => [\n        ['username', 'Man', true]\n    ]\n]);\n$v->validate();\n```\n\n## subset fields usage\nThe `subset` rule checks that the field is either a scalar or array field and that all of it's values are contained within a given set of values.\n```php\n$v->rule('subset', 'colors', ['green', 'blue', 'orange']);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['colors' => ['green', 'blue']]);\n$v->rules([\n    'subset' => [\n        ['colors', ['orange', 'green', 'blue', 'red']]\n    ]\n]);\n$v->validate();\n```\nThis example would return false, as the provided color, purple, does not exist in the array of accepted values we're providing.\n```php\n$v = new Valitron\\Validator(['colors' => ['purple', 'blue']]);\n$v->rules([\n    'subset' => [\n        ['colors', ['orange', 'green', 'blue', 'red']]\n    ]\n]);\n$v->validate();\n```\n\n## containsUnique fields usage\nThe `containsUnique` rule checks that the provided field is an array and that all values contained within are unique, i.e. no duplicate values in the array.\n```php\n$v->rule('containsUnique', 'colors');\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['colors' => ['purple', 'blue']]);\n$v->rules([\n    'containsUnique' => [\n        ['colors']\n    ]\n]);\n$v->validate();\n```\nThis example would return false, as the values in the provided array are duplicates.\n```php\n$v = new Valitron\\Validator(['colors' => ['purple', 'purple']]);\n$v->rules([\n    'containsUnique' => [\n        ['colors']\n    ]\n]);\n$v->validate();\n```\n\n## Credit Card Validation usage\n\nCredit card validation currently allows you to validate a Visa `visa`,\nMastercard `mastercard`, Dinersclub `dinersclub`, American Express `amex`\nor Discover `discover`\n\nThis will check the credit card against each card type\n\n```php\n$v->rule('creditCard', 'credit_card');\n```\n\nTo optionally filter card types, add the slug to an array as the next parameter:\n\n```php\n$v->rule('creditCard', 'credit_card', ['visa', 'mastercard']);\n```\n\nIf you only want to validate one type of card, put it as a string:\n\n```php\n$v->rule('creditCard', 'credit_card', 'visa');\n```\n\nIf the card type information is coming from the client, you might also want to\nstill specify an array of valid card types:\n\n```php\n$cardType = 'amex';\n$v->rule('creditCard', 'credit_card', $cardType, ['visa', 'mastercard']);\n$v->validate(); // false\n```\n\n## instanceOf fields usage\nThe `instanceOf` rule checks that the field is an instance of a given class.\n```php\n$v->rule('instanceOf', 'date', \\DateTime);\n```\n\nAlternate syntax.\n```php\n$v = new Valitron\\Validator(['date' => new \\DateTime()]);\n$v->rules([\n    'instanceOf' => [\n        ['date', 'DateTime']\n    ]\n]);\n$v->validate();\n```\n*Note* You can also compare the value against a given object as opposed to the string class name.\nThis example would also return true:\n```php\n$v = new Valitron\\Validator(['date' => new \\DateTime()]);\n$existingDateObject = new \\DateTime();\n$v->rules([\n    'instanceOf' => [\n        ['date', $existingDateObject]\n    ]\n]);\n$v->validate();\n```\n\n## optional fields usage\nThe `optional` rule ensures that if the field is present in the data set that it passes all validation rules.\n```php\n$v->rule('optional', 'username');\n```\n\nAlternate syntax.\nThis example would return true either when the 'username' field is not present or in the case where the username is only alphabetic characters.\n```php\n$v = new Valitron\\Validator(['username' => 'batman']);\n$v->rules([\n    'alpha' => [\n        ['username']\n    ],\n    'optional' => [\n        ['username']\n    ]\n]);\n$v->validate();\n```\nThis example would return false, as although the field is optional, since it is provided it must pass all the validation rules, which in this case it does not.\n```php\n$v = new Valitron\\Validator(['username' => 'batman123']);\n$v->rules([\n    'alpha' => [\n        ['username']\n    ],\n    'optional' => [\n        ['username']\n    ]\n]);\n$v->validate();\n```\n\n## arrayHasKeys fields usage\n\nThe `arrayHasKeys` rule ensures that the field is an array and that it contains all the specified keys.\nReturns false if the field is not an array or if no required keys are specified or if some key is missing.\n\n```php\n$v = new Valitron\\Validator([\n    'address' => [\n        'name' => 'Jane Doe',\n        'street' => 'Doe Square',\n        'city' => 'Doe D.C.'\n    ]\n]);\n$v->rule('arrayHasKeys', 'address', ['name', 'street', 'city']);\n$v->validate();\n```\n\n## Adding Custom Validation Rules\n\nTo add your own validation rule, use the `addRule` method with a rule\nname, a custom callback or closure, and a error message to display in\ncase of an error. The callback provided should return boolean true or\nfalse.\n\n```php\nValitron\\Validator::addRule('alwaysFail', function($field, $value, array $params, array $fields) {\n    return false;\n}, 'Everything you do is wrong. You fail.');\n```\n\nYou can also use one-off rules that are only valid for the specified\nfields.\n\n```php\n$v = new Valitron\\Validator(array(\"foo\" => \"bar\"));\n$v->rule(function($field, $value, $params, $fields) {\n    return true;\n}, \"foo\")->message(\"{field} failed...\");\n```\n\nThis is useful because such rules can have access to variables\ndefined in the scope where the `Validator` lives. The Closure's\nsignature is identical to `Validator::addRule` callback's\nsignature.\n\nIf you wish to add your own rules that are not static (i.e.,\nyour rule is not static and available to call `Validator`\ninstances), you need to use `Validator::addInstanceRule`.\nThis rule will take the same parameters as\n`Validator::addRule` but it has to be called on a `Validator`\ninstance.\n\n## Chaining rules\n\nYou can chain multiple rules together using the following syntax.\n```php\n$v = new Valitron\\Validator(['email_address' => 'test@test.com']);\n$v->rule('required', 'email_address')->rule('email', 'email_address');\n$v->validate();\n```\n\n## Alternate syntax for adding rules\n\nAs the number of rules grows, you may prefer the alternate syntax\nfor defining multiple rules at once.\n\n```php\n$rules = [\n    'required' => 'foo',\n    'accepted' => 'bar',\n    'integer' =>  'bar'\n];\n\n$v = new Valitron\\Validator(array('foo' => 'bar', 'bar' => 1));\n$v->rules($rules);\n$v->validate();\n```\n\nIf your rule requires multiple parameters or a single parameter\nmore complex than a string, you need to wrap the rule in an array.\n\n```php\n$rules = [\n    'required' => [\n        ['foo'],\n        ['bar']\n    ],\n    'length' => [\n        ['foo', 3]\n    ]\n];\n```\nYou can also specify multiple rules for each rule type.\n\n```php\n$rules = [\n    'length'   => [\n        ['foo', 5],\n        ['bar', 5]\n    ]\n];\n```\n\nPutting these techniques together, you can create a complete\nrule definition in a relatively compact data structure.\n\nYou can continue to add individual rules with the `rule` method\neven after specifying a rule definition via an array. This is\nespecially useful if you are defining custom validation rules.\n\n```php\n$rules = [\n    'required' => 'foo',\n    'accepted' => 'bar',\n    'integer' =>  'bar'\n];\n\n$v = new Valitron\\Validator(array('foo' => 'bar', 'bar' => 1));\n$v->rules($rules);\n$v->rule('min', 'bar', 0);\n$v->validate();\n```\n\nYou can also add rules on a per-field basis:\n```php\n$rules = [\n    'required',\n    ['lengthMin', 4]\n];\n\n$v = new Valitron\\Validator(array('foo' => 'bar'));\n$v->mapFieldRules('foo', $rules);\n$v->validate();\n```\n\nOr for multiple fields at once:\n\n```php\n$rules = [\n    'foo' => ['required', 'integer'],\n    'bar'=>['email', ['lengthMin', 4]]\n];\n\n$v = new Valitron\\Validator(array('foo' => 'bar', 'bar' => 'mail@example.com));\n$v->mapFieldsRules($rules);\n$v->validate();\n```\n\n## Adding field label to messages\n\nYou can do this in two different ways, you can add a individual label to a rule or an array of all labels for the rules.\n\nTo add individual label to rule you simply add the `label` method after the rule.\n\n```php\n$v = new Valitron\\Validator(array());\n$v->rule('required', 'name')->message('{field} is required')->label('Name');\n$v->validate();\n```\n\nThere is a edge case to this method, you wouldn't be able to use a array of field names in the rule definition, so one rule per field. So this wouldn't work:\n\n```php\n$v = new Valitron\\Validator(array());\n$v->rule('required', array('name', 'email'))->message('{field} is required')->label('Name');\n$v->validate();\n```\n\nHowever we can use a array of labels to solve this issue by simply adding the `labels` method instead:\n\n```php\n$v = new Valitron\\Validator(array());\n$v->rule('required', array('name', 'email'))->message('{field} is required');\n$v->labels(array(\n    'name' => 'Name',\n    'email' => 'Email address'\n));\n$v->validate();\n```\n\nThis introduces a new set of tags to your error language file which looks like `{field}`, if you are using a rule like `equals` you can access the second value in the language file by incrementing the field with a value like `{field1}`.\n\n\n## Re-use of validation rules\n\nYou can re-use your validation rules to quickly validate different data with the same rules by using the withData method:\n\n```php\n$v = new Valitron\\Validator(array());\n$v->rule('required', 'name')->message('{field} is required');\n$v->validate(); //false\n\n$v2 = $v->withData(array('name'=>'example'));\n$v2->validate(); //true\n```\n\n## Running Tests\n\nThe test suite depends on the Composer autoloader to load and run the\nValitron files. Please ensure you have downloaded and installed Composer\nbefore running the tests:\n\n1. Download Composer `curl -s http://getcomposer.org/installer | php`\n2. Run 'install' `php composer.phar install`\n3. Run the tests `phpunit`\n\n## Contributing\n\n1. Fork it\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Make your changes\n4. Run the tests, adding new ones for your own code if necessary (`phpunit`)\n5. Commit your changes (`git commit -am 'Added some feature'`)\n6. Push to the branch (`git push origin my-new-feature`)\n7. Create new Pull Request\n8. Pat yourself on the back for being so awesome\n\n## Security Disclosures and Contact Information\n\nTo report a security vulnerability, please use the [Tidelift security contact](https://tidelift.com/security). Tidelift will coordinate the fix and disclosure.\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.9150390625,
          "content": "{\n    \"name\": \"vlucas/valitron\",\n    \"type\": \"library\",\n    \"description\": \"Simple, elegant, stand-alone validation library with NO dependencies\",\n    \"keywords\": [\"validation\", \"validator\", \"valid\"],\n    \"homepage\": \"https://github.com/vlucas/valitron\",\n    \"license\": \"BSD-3-Clause\",\n    \"authors\": [\n        {\n            \"name\": \"Vance Lucas\",\n            \"email\": \"vance@vancelucas.com\",\n            \"homepage\": \"https://www.vancelucas.com\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=5.3.2\"\n    },\n    \"require-dev\": {\n        \"phpunit/phpunit\": \">=4.8.35\"\n    },\n    \"suggest\": {\n        \"ext-mbstring\": \"It can support the multiple bytes string length.\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"Valitron\\\\\": \"src/Valitron\"\n        }\n    },\n    \"autoload-dev\": {\n        \"psr-4\": {\n            \"Valitron\\\\\": \"tests/Valitron\"\n        }\n    },\n    \"scripts\": {\n        \"test\": \"./vendor/bin/phpunit\"\n    }\n}\n"
        },
        {
          "name": "lang",
          "type": "tree",
          "content": null
        },
        {
          "name": "phpunit.xml",
          "type": "blob",
          "size": 0.521484375,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<phpunit backupGlobals=\"false\"\n         backupStaticAttributes=\"false\"\n         colors=\"true\"\n         convertErrorsToExceptions=\"true\"\n         convertNoticesToExceptions=\"true\"\n         convertWarningsToExceptions=\"true\"\n         processIsolation=\"false\"\n         stopOnFailure=\"false\"\n         bootstrap=\"tests/bootstrap.php\"\n>\n  <testsuites>\n    <testsuite name=\"Valitron Test Suite\">\n      <directory suffix=\"Test.php\">tests/Valitron</directory>\n    </testsuite>\n  </testsuites>\n</phpunit>\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}