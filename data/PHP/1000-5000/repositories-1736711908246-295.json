{
  "metadata": {
    "timestamp": 1736711908246,
    "page": 295,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/error-handler",
      "stars": 2600,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "BufferingLogger.php",
          "type": "blob",
          "size": 1.96484375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ErrorHandler;\n\nuse Psr\\Log\\AbstractLogger;\n\n/**\n * A buffering logger that stacks logs for later.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass BufferingLogger extends AbstractLogger\n{\n    private array $logs = [];\n\n    public function log($level, $message, array $context = []): void\n    {\n        $this->logs[] = [$level, $message, $context];\n    }\n\n    public function cleanLogs(): array\n    {\n        $logs = $this->logs;\n        $this->logs = [];\n\n        return $logs;\n    }\n\n    public function __sleep(): array\n    {\n        throw new \\BadMethodCallException('Cannot serialize '.__CLASS__);\n    }\n\n    public function __wakeup(): void\n    {\n        throw new \\BadMethodCallException('Cannot unserialize '.__CLASS__);\n    }\n\n    public function __destruct()\n    {\n        foreach ($this->logs as [$level, $message, $context]) {\n            if (str_contains($message, '{')) {\n                foreach ($context as $key => $val) {\n                    if (null === $val || \\is_scalar($val) || $val instanceof \\Stringable) {\n                        $message = str_replace(\"{{$key}}\", $val, $message);\n                    } elseif ($val instanceof \\DateTimeInterface) {\n                        $message = str_replace(\"{{$key}}\", $val->format(\\DateTimeInterface::RFC3339), $message);\n                    } elseif (\\is_object($val)) {\n                        $message = str_replace(\"{{$key}}\", '[object '.get_debug_type($val).']', $message);\n                    } else {\n                        $message = str_replace(\"{{$key}}\", '['.\\gettype($val).']', $message);\n                    }\n                }\n            }\n\n            error_log(\\sprintf('%s [%s] %s', date(\\DateTimeInterface::RFC3339), $level, $message));\n        }\n    }\n}\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.9833984375,
          "content": "CHANGELOG\n=========\n\n7.1\n---\n\n * Increase log level to \"error\" at least for all PHP errors\n\n6.4\n---\n\n * `FlattenExceptionNormalizer` no longer implements `ContextAwareNormalizerInterface`\n\n6.3\n---\n\n * Display exception properties in the HTML error page\n\n6.1\n---\n\n * Report overridden `@final` constants and properties\n * Read environment variable `SYMFONY_IDE` to configure file link format\n\n5.4\n---\n\n * Make `DebugClassLoader` trigger deprecation notices on missing return types\n * Add `SYMFONY_PATCH_TYPE_DECLARATIONS='force=2'` mode to `DebugClassLoader` to turn annotations into native return types\n\n5.2.0\n-----\n\n * added the ability to set `HtmlErrorRenderer::$template` to a custom template to render when not in debug mode.\n\n5.1.0\n-----\n\n * The `HtmlErrorRenderer` and `SerializerErrorRenderer` add `X-Debug-Exception` and `X-Debug-Exception-File` headers in debug mode.\n\n4.4.0\n-----\n\n * added the component\n * added `ErrorHandler::call()` method utility to turn any PHP error into `\\ErrorException`\n"
        },
        {
          "name": "Debug.php",
          "type": "blob",
          "size": 1.05078125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ErrorHandler;\n\n/**\n * Registers all the debug tools.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Debug\n{\n    public static function enable(): ErrorHandler\n    {\n        error_reporting(-1);\n\n        if (!\\in_array(\\PHP_SAPI, ['cli', 'phpdbg', 'embed'], true)) {\n            ini_set('display_errors', 0);\n        } elseif (!filter_var(\\ini_get('log_errors'), \\FILTER_VALIDATE_BOOL) || \\ini_get('error_log')) {\n            // CLI - display errors only if they're not already logged to STDERR\n            ini_set('display_errors', 1);\n        }\n\n        @ini_set('zend.assertions', 1);\n        ini_set('assert.active', 1);\n        ini_set('assert.exception', 1);\n\n        DebugClassLoader::enable();\n\n        return ErrorHandler::register(new ErrorHandler(new BufferingLogger(), true));\n    }\n}\n"
        },
        {
          "name": "DebugClassLoader.php",
          "type": "blob",
          "size": 49.19140625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ErrorHandler;\n\nuse Composer\\InstalledVersions;\nuse Doctrine\\Common\\Persistence\\Proxy as LegacyProxy;\nuse Doctrine\\Persistence\\Proxy;\nuse Mockery\\MockInterface;\nuse Phake\\IMock;\nuse PHPUnit\\Framework\\MockObject\\Matcher\\StatelessInvocation;\nuse PHPUnit\\Framework\\MockObject\\MockObject;\nuse Prophecy\\Prophecy\\ProphecySubjectInterface;\nuse ProxyManager\\Proxy\\ProxyInterface;\nuse Symfony\\Component\\DependencyInjection\\Argument\\LazyClosure;\nuse Symfony\\Component\\ErrorHandler\\Internal\\TentativeTypes;\nuse Symfony\\Component\\VarExporter\\LazyObjectInterface;\n\n/**\n * Autoloader checking if the class is really defined in the file found.\n *\n * The ClassLoader will wrap all registered autoloaders\n * and will throw an exception if a file is found but does\n * not declare the class.\n *\n * It can also patch classes to turn docblocks into actual return types.\n * This behavior is controlled by the SYMFONY_PATCH_TYPE_DECLARATIONS env var,\n * which is a url-encoded array with the follow parameters:\n *  - \"force\": any value enables deprecation notices - can be any of:\n *      - \"phpdoc\" to patch only docblock annotations\n *      - \"2\" to add all possible return types\n *      - \"1\" to add return types but only to tests/final/internal/private methods\n *  - \"php\": the target version of PHP - e.g. \"7.1\" doesn't generate \"object\" types\n *  - \"deprecations\": \"1\" to trigger a deprecation notice when a child class misses a\n *                    return type while the parent declares an \"@return\" annotation\n *\n * Note that patching doesn't care about any coding style so you'd better to run\n * php-cs-fixer after, with rules \"phpdoc_trim_consecutive_blank_line_separation\"\n * and \"no_superfluous_phpdoc_tags\" enabled typically.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Christophe Coevoet <stof@notk.org>\n * @author Nicolas Grekas <p@tchwork.com>\n * @author Guilhem Niot <guilhem.niot@gmail.com>\n */\nclass DebugClassLoader\n{\n    private const SPECIAL_RETURN_TYPES = [\n        'void' => 'void',\n        'null' => 'null',\n        'resource' => 'resource',\n        'boolean' => 'bool',\n        'true' => 'true',\n        'false' => 'false',\n        'integer' => 'int',\n        'array' => 'array',\n        'bool' => 'bool',\n        'callable' => 'callable',\n        'float' => 'float',\n        'int' => 'int',\n        'iterable' => 'iterable',\n        'object' => 'object',\n        'string' => 'string',\n        'self' => 'self',\n        'parent' => 'parent',\n        'mixed' => 'mixed',\n        'static' => 'static',\n        '$this' => 'static',\n        'list' => 'array',\n        'class-string' => 'string',\n        'never' => 'never',\n    ];\n\n    private const BUILTIN_RETURN_TYPES = [\n        'void' => true,\n        'array' => true,\n        'false' => true,\n        'bool' => true,\n        'callable' => true,\n        'float' => true,\n        'int' => true,\n        'iterable' => true,\n        'object' => true,\n        'string' => true,\n        'self' => true,\n        'parent' => true,\n        'mixed' => true,\n        'static' => true,\n        'null' => true,\n        'true' => true,\n        'never' => true,\n    ];\n\n    private const MAGIC_METHODS = [\n        '__isset' => 'bool',\n        '__sleep' => 'array',\n        '__toString' => 'string',\n        '__debugInfo' => 'array',\n        '__serialize' => 'array',\n        '__set' => 'void',\n        '__unset' => 'void',\n        '__unserialize' => 'void',\n        '__wakeup' => 'void',\n    ];\n\n    /**\n     * @var callable\n     */\n    private $classLoader;\n    private bool $isFinder;\n    private array $loaded = [];\n    private array $patchTypes = [];\n\n    private static int $caseCheck;\n    private static array $checkedClasses = [];\n    private static array $final = [];\n    private static array $finalMethods = [];\n    private static array $finalProperties = [];\n    private static array $finalConstants = [];\n    private static array $deprecated = [];\n    private static array $internal = [];\n    private static array $internalMethods = [];\n    private static array $annotatedParameters = [];\n    private static array $darwinCache = ['/' => ['/', []]];\n    private static array $method = [];\n    private static array $returnTypes = [];\n    private static array $methodTraits = [];\n    private static array $fileOffsets = [];\n\n    public function __construct(callable $classLoader)\n    {\n        $this->classLoader = $classLoader;\n        $this->isFinder = \\is_array($classLoader) && method_exists($classLoader[0], 'findFile');\n        parse_str($_ENV['SYMFONY_PATCH_TYPE_DECLARATIONS'] ?? $_SERVER['SYMFONY_PATCH_TYPE_DECLARATIONS'] ?? getenv('SYMFONY_PATCH_TYPE_DECLARATIONS') ?: '', $this->patchTypes);\n        $this->patchTypes += [\n            'force' => null,\n            'php' => \\PHP_MAJOR_VERSION.'.'.\\PHP_MINOR_VERSION,\n            'deprecations' => true,\n        ];\n\n        if ('phpdoc' === $this->patchTypes['force']) {\n            $this->patchTypes['force'] = 'docblock';\n        }\n\n        if (!isset(self::$caseCheck)) {\n            $file = is_file(__FILE__) ? __FILE__ : rtrim(realpath('.'), \\DIRECTORY_SEPARATOR);\n            $i = strrpos($file, \\DIRECTORY_SEPARATOR);\n            $dir = substr($file, 0, 1 + $i);\n            $file = substr($file, 1 + $i);\n            $test = strtoupper($file) === $file ? strtolower($file) : strtoupper($file);\n            $test = realpath($dir.$test);\n\n            if (false === $test || false === $i) {\n                // filesystem is case-sensitive\n                self::$caseCheck = 0;\n            } elseif (str_ends_with($test, $file)) {\n                // filesystem is case-insensitive and realpath() normalizes the case of characters\n                self::$caseCheck = 1;\n            } elseif ('Darwin' === \\PHP_OS_FAMILY) {\n                // on MacOSX, HFS+ is case-insensitive but realpath() doesn't normalize the case of characters\n                self::$caseCheck = 2;\n            } else {\n                // filesystem case checks failed, fallback to disabling them\n                self::$caseCheck = 0;\n            }\n        }\n    }\n\n    public function getClassLoader(): callable\n    {\n        return $this->classLoader;\n    }\n\n    /**\n     * Wraps all autoloaders.\n     */\n    public static function enable(): void\n    {\n        // Ensures we don't hit https://bugs.php.net/42098\n        class_exists(ErrorHandler::class);\n        class_exists(\\Psr\\Log\\LogLevel::class);\n\n        if (!\\is_array($functions = spl_autoload_functions())) {\n            return;\n        }\n\n        foreach ($functions as $function) {\n            spl_autoload_unregister($function);\n        }\n\n        foreach ($functions as $function) {\n            if (!\\is_array($function) || !$function[0] instanceof self) {\n                $function = [new static($function), 'loadClass'];\n            }\n\n            spl_autoload_register($function);\n        }\n    }\n\n    /**\n     * Disables the wrapping.\n     */\n    public static function disable(): void\n    {\n        if (!\\is_array($functions = spl_autoload_functions())) {\n            return;\n        }\n\n        foreach ($functions as $function) {\n            spl_autoload_unregister($function);\n        }\n\n        foreach ($functions as $function) {\n            if (\\is_array($function) && $function[0] instanceof self) {\n                $function = $function[0]->getClassLoader();\n            }\n\n            spl_autoload_register($function);\n        }\n    }\n\n    public static function checkClasses(): bool\n    {\n        if (!\\is_array($functions = spl_autoload_functions())) {\n            return false;\n        }\n\n        $loader = null;\n\n        foreach ($functions as $function) {\n            if (\\is_array($function) && $function[0] instanceof self) {\n                $loader = $function[0];\n                break;\n            }\n        }\n\n        if (null === $loader) {\n            return false;\n        }\n\n        static $offsets = [\n            'get_declared_interfaces' => 0,\n            'get_declared_traits' => 0,\n            'get_declared_classes' => 0,\n        ];\n\n        foreach ($offsets as $getSymbols => $i) {\n            $symbols = $getSymbols();\n\n            for (; $i < \\count($symbols); ++$i) {\n                if (!is_subclass_of($symbols[$i], MockObject::class)\n                    && !is_subclass_of($symbols[$i], ProphecySubjectInterface::class)\n                    && !is_subclass_of($symbols[$i], Proxy::class)\n                    && !is_subclass_of($symbols[$i], ProxyInterface::class)\n                    && !is_subclass_of($symbols[$i], LazyObjectInterface::class)\n                    && !is_subclass_of($symbols[$i], LegacyProxy::class)\n                    && !is_subclass_of($symbols[$i], MockInterface::class)\n                    && !is_subclass_of($symbols[$i], IMock::class)\n                    && !(is_subclass_of($symbols[$i], LazyClosure::class) && str_contains($symbols[$i], \"@anonymous\\0\"))\n                ) {\n                    $loader->checkClass($symbols[$i]);\n                }\n            }\n\n            $offsets[$getSymbols] = $i;\n        }\n\n        return true;\n    }\n\n    public function findFile(string $class): ?string\n    {\n        return $this->isFinder ? ($this->classLoader[0]->findFile($class) ?: null) : null;\n    }\n\n    /**\n     * Loads the given class or interface.\n     *\n     * @throws \\RuntimeException\n     */\n    public function loadClass(string $class): void\n    {\n        $e = error_reporting(error_reporting() | \\E_PARSE | \\E_ERROR | \\E_CORE_ERROR | \\E_COMPILE_ERROR);\n\n        try {\n            if ($this->isFinder && !isset($this->loaded[$class])) {\n                $this->loaded[$class] = true;\n                if (!$file = $this->classLoader[0]->findFile($class) ?: '') {\n                    // no-op\n                } elseif (\\function_exists('opcache_is_script_cached') && @opcache_is_script_cached($file)) {\n                    include $file;\n\n                    return;\n                } elseif (false === include $file) {\n                    return;\n                }\n            } else {\n                ($this->classLoader)($class);\n                $file = '';\n            }\n        } finally {\n            error_reporting($e);\n        }\n\n        $this->checkClass($class, $file);\n    }\n\n    private function checkClass(string $class, ?string $file = null): void\n    {\n        $exists = null === $file || class_exists($class, false) || interface_exists($class, false) || trait_exists($class, false);\n\n        if (null !== $file && $class && '\\\\' === $class[0]) {\n            $class = substr($class, 1);\n        }\n\n        if ($exists) {\n            if (isset(self::$checkedClasses[$class])) {\n                return;\n            }\n            self::$checkedClasses[$class] = true;\n\n            $refl = new \\ReflectionClass($class);\n            if (null === $file && $refl->isInternal()) {\n                return;\n            }\n            $name = $refl->getName();\n\n            if ($name !== $class && 0 === strcasecmp($name, $class)) {\n                throw new \\RuntimeException(\\sprintf('Case mismatch between loaded and declared class names: \"%s\" vs \"%s\".', $class, $name));\n            }\n\n            $deprecations = $this->checkAnnotations($refl, $name);\n\n            foreach ($deprecations as $message) {\n                @trigger_error($message, \\E_USER_DEPRECATED);\n            }\n        }\n\n        if (!$file) {\n            return;\n        }\n\n        if (!$exists) {\n            if (str_contains($class, '/')) {\n                throw new \\RuntimeException(\\sprintf('Trying to autoload a class with an invalid name \"%s\". Be careful that the namespace separator is \"\\\" in PHP, not \"/\".', $class));\n            }\n\n            throw new \\RuntimeException(\\sprintf('The autoloader expected class \"%s\" to be defined in file \"%s\". The file was found but the class was not in it, the class name or namespace probably has a typo.', $class, $file));\n        }\n\n        if (self::$caseCheck && $message = $this->checkCase($refl, $file, $class)) {\n            throw new \\RuntimeException(\\sprintf('Case mismatch between class and real file names: \"%s\" vs \"%s\" in \"%s\".', $message[0], $message[1], $message[2]));\n        }\n    }\n\n    public function checkAnnotations(\\ReflectionClass $refl, string $class): array\n    {\n        if (\n            'Symfony\\Bridge\\PhpUnit\\Legacy\\SymfonyTestsListenerForV7' === $class\n            || 'Symfony\\Bridge\\PhpUnit\\Legacy\\SymfonyTestsListenerForV6' === $class\n        ) {\n            return [];\n        }\n        $deprecations = [];\n\n        $className = str_contains($class, \"@anonymous\\0\") ? (get_parent_class($class) ?: key(class_implements($class)) ?: 'class').'@anonymous' : $class;\n\n        // Don't trigger deprecations for classes in the same vendor\n        if ($class !== $className) {\n            $vendor = preg_match('/^namespace ([^;\\\\\\\\\\s]++)[;\\\\\\\\]/m', @file_get_contents($refl->getFileName()), $vendor) ? $vendor[1].'\\\\' : '';\n            $vendorLen = \\strlen($vendor);\n        } elseif (2 > $vendorLen = 1 + (strpos($class, '\\\\') ?: strpos($class, '_'))) {\n            $vendorLen = 0;\n            $vendor = '';\n        } else {\n            $vendor = str_replace('_', '\\\\', substr($class, 0, $vendorLen));\n        }\n\n        $parent = get_parent_class($class) ?: null;\n        self::$returnTypes[$class] = [];\n        $classIsTemplate = false;\n\n        // Detect annotations on the class\n        if ($doc = $this->parsePhpDoc($refl)) {\n            $classIsTemplate = isset($doc['template']) || isset($doc['template-covariant']);\n\n            foreach (['final', 'deprecated', 'internal'] as $annotation) {\n                if (null !== $description = $doc[$annotation][0] ?? null) {\n                    self::${$annotation}[$class] = '' !== $description ? ' '.$description.(preg_match('/[.!]$/', $description) ? '' : '.') : '.';\n                }\n            }\n\n            if ($refl->isInterface() && isset($doc['method'])) {\n                foreach ($doc['method'] as $name => [$static, $returnType, $signature, $description]) {\n                    self::$method[$class][] = [$class, $static, $returnType, $name.$signature, $description];\n\n                    if ('' !== $returnType) {\n                        $this->setReturnType($returnType, $refl->name, $name, $refl->getFileName(), $parent);\n                    }\n                }\n            }\n        }\n\n        $parentAndOwnInterfaces = $this->getOwnInterfaces($class, $parent);\n        if ($parent) {\n            $parentAndOwnInterfaces[$parent] = $parent;\n\n            if (!isset(self::$checkedClasses[$parent])) {\n                $this->checkClass($parent);\n            }\n\n            if (isset(self::$final[$parent])) {\n                $deprecations[] = \\sprintf('The \"%s\" class is considered final%s It may change without further notice as of its next major version. You should not extend it from \"%s\".', $parent, self::$final[$parent], $className);\n            }\n        }\n\n        // Detect if the parent is annotated\n        foreach ($parentAndOwnInterfaces + class_uses($class, false) as $use) {\n            if (!isset(self::$checkedClasses[$use])) {\n                $this->checkClass($use);\n            }\n            if (isset(self::$deprecated[$use]) && strncmp($vendor, str_replace('_', '\\\\', $use), $vendorLen) && !isset(self::$deprecated[$class])) {\n                $type = class_exists($class, false) ? 'class' : (interface_exists($class, false) ? 'interface' : 'trait');\n                $verb = class_exists($use, false) || interface_exists($class, false) ? 'extends' : (interface_exists($use, false) ? 'implements' : 'uses');\n\n                $deprecations[] = \\sprintf('The \"%s\" %s %s \"%s\" that is deprecated%s', $className, $type, $verb, $use, self::$deprecated[$use]);\n            }\n            if (isset(self::$internal[$use]) && strncmp($vendor, str_replace('_', '\\\\', $use), $vendorLen)) {\n                $deprecations[] = \\sprintf('The \"%s\" %s is considered internal%s It may change without further notice. You should not use it from \"%s\".', $use, class_exists($use, false) ? 'class' : (interface_exists($use, false) ? 'interface' : 'trait'), self::$internal[$use], $className);\n            }\n            if (isset(self::$method[$use])) {\n                if ($refl->isAbstract()) {\n                    if (isset(self::$method[$class])) {\n                        self::$method[$class] = array_merge(self::$method[$class], self::$method[$use]);\n                    } else {\n                        self::$method[$class] = self::$method[$use];\n                    }\n                } elseif (!$refl->isInterface()) {\n                    if (!strncmp($vendor, str_replace('_', '\\\\', $use), $vendorLen)\n                        && str_starts_with($className, 'Symfony\\\\')\n                        && (!class_exists(InstalledVersions::class)\n                            || 'symfony/symfony' !== InstalledVersions::getRootPackage()['name'])\n                    ) {\n                        // skip \"same vendor\" @method deprecations for Symfony\\* classes unless symfony/symfony is being tested\n                        continue;\n                    }\n                    $hasCall = $refl->hasMethod('__call');\n                    $hasStaticCall = $refl->hasMethod('__callStatic');\n                    foreach (self::$method[$use] as [$interface, $static, $returnType, $name, $description]) {\n                        if ($static ? $hasStaticCall : $hasCall) {\n                            continue;\n                        }\n                        $realName = substr($name, 0, strpos($name, '('));\n                        if (!$refl->hasMethod($realName) || !($methodRefl = $refl->getMethod($realName))->isPublic() || ($static && !$methodRefl->isStatic()) || (!$static && $methodRefl->isStatic())) {\n                            $deprecations[] = \\sprintf('Class \"%s\" should implement method \"%s::%s%s\"%s', $className, ($static ? 'static ' : '').$interface, $name, $returnType ? ': '.$returnType : '', null === $description ? '.' : ': '.$description);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (trait_exists($class)) {\n            $file = $refl->getFileName();\n\n            foreach ($refl->getMethods() as $method) {\n                if ($method->getFileName() === $file) {\n                    self::$methodTraits[$file][$method->getStartLine()] = $class;\n                }\n            }\n\n            return $deprecations;\n        }\n\n        // Inherit @final, @internal, @param and @return annotations for methods\n        self::$finalMethods[$class] = [];\n        self::$internalMethods[$class] = [];\n        self::$annotatedParameters[$class] = [];\n        self::$finalProperties[$class] = [];\n        self::$finalConstants[$class] = [];\n        foreach ($parentAndOwnInterfaces as $use) {\n            foreach (['finalMethods', 'internalMethods', 'annotatedParameters', 'returnTypes', 'finalProperties', 'finalConstants'] as $property) {\n                if (isset(self::${$property}[$use])) {\n                    self::${$property}[$class] = self::${$property}[$class] ? self::${$property}[$use] + self::${$property}[$class] : self::${$property}[$use];\n                }\n            }\n\n            if (null !== (TentativeTypes::RETURN_TYPES[$use] ?? null)) {\n                foreach (TentativeTypes::RETURN_TYPES[$use] as $method => $returnType) {\n                    $returnType = explode('|', $returnType);\n                    foreach ($returnType as $i => $t) {\n                        if ('?' !== $t && !isset(self::BUILTIN_RETURN_TYPES[$t])) {\n                            $returnType[$i] = '\\\\'.$t;\n                        }\n                    }\n                    $returnType = implode('|', $returnType);\n\n                    self::$returnTypes[$class] += [$method => [$returnType, str_starts_with($returnType, '?') ? substr($returnType, 1).'|null' : $returnType, $use, '']];\n                }\n            }\n        }\n\n        foreach ($refl->getMethods() as $method) {\n            if ($method->class !== $class) {\n                continue;\n            }\n\n            if (null === $ns = self::$methodTraits[$method->getFileName()][$method->getStartLine()] ?? null) {\n                $ns = $vendor;\n                $len = $vendorLen;\n            } elseif (2 > $len = 1 + (strpos($ns, '\\\\') ?: strpos($ns, '_'))) {\n                $len = 0;\n                $ns = '';\n            } else {\n                $ns = str_replace('_', '\\\\', substr($ns, 0, $len));\n            }\n\n            if ($parent && isset(self::$finalMethods[$parent][$method->name])) {\n                [$declaringClass, $message] = self::$finalMethods[$parent][$method->name];\n                $deprecations[] = \\sprintf('The \"%s::%s()\" method is considered final%s It may change without further notice as of its next major version. You should not extend it from \"%s\".', $declaringClass, $method->name, $message, $className);\n            }\n\n            if (isset(self::$internalMethods[$class][$method->name])) {\n                [$declaringClass, $message] = self::$internalMethods[$class][$method->name];\n                if (strncmp($ns, $declaringClass, $len)) {\n                    $deprecations[] = \\sprintf('The \"%s::%s()\" method is considered internal%s It may change without further notice. You should not extend it from \"%s\".', $declaringClass, $method->name, $message, $className);\n                }\n            }\n\n            // To read method annotations\n            $doc = $this->parsePhpDoc($method);\n\n            if (($classIsTemplate || isset($doc['template']) || isset($doc['template-covariant'])) && $method->hasReturnType()) {\n                unset($doc['return']);\n            }\n\n            if (isset(self::$annotatedParameters[$class][$method->name])) {\n                $definedParameters = [];\n                foreach ($method->getParameters() as $parameter) {\n                    $definedParameters[$parameter->name] = true;\n                }\n\n                foreach (self::$annotatedParameters[$class][$method->name] as $parameterName => $deprecation) {\n                    if (!isset($definedParameters[$parameterName]) && !isset($doc['param'][$parameterName])) {\n                        $deprecations[] = \\sprintf($deprecation, $className);\n                    }\n                }\n            }\n\n            $forcePatchTypes = $this->patchTypes['force'];\n\n            if ($canAddReturnType = null !== $forcePatchTypes && !str_contains($method->getFileName(), \\DIRECTORY_SEPARATOR.'vendor'.\\DIRECTORY_SEPARATOR)) {\n                $this->patchTypes['force'] = $forcePatchTypes ?: 'docblock';\n\n                $canAddReturnType = 2 === (int) $forcePatchTypes\n                    || false !== stripos($method->getFileName(), \\DIRECTORY_SEPARATOR.'Tests'.\\DIRECTORY_SEPARATOR)\n                    || $refl->isFinal()\n                    || $method->isFinal()\n                    || $method->isPrivate()\n                    || ('.' === (self::$internal[$class] ?? null) && !$refl->isAbstract())\n                    || '.' === (self::$final[$class] ?? null)\n                    || '' === ($doc['final'][0] ?? null)\n                    || '' === ($doc['internal'][0] ?? null)\n                ;\n            }\n\n            if (null !== ($returnType = self::$returnTypes[$class][$method->name] ?? null) && 'docblock' === $this->patchTypes['force'] && !$method->hasReturnType() && isset(TentativeTypes::RETURN_TYPES[$returnType[2]][$method->name])) {\n                $this->patchReturnTypeWillChange($method);\n            }\n\n            if (null !== ($returnType ??= self::MAGIC_METHODS[$method->name] ?? null) && !$method->hasReturnType() && !isset($doc['return'])) {\n                [$normalizedType, $returnType, $declaringClass, $declaringFile] = \\is_string($returnType) ? [$returnType, $returnType, '', ''] : $returnType;\n\n                if ($canAddReturnType && 'docblock' !== $this->patchTypes['force']) {\n                    $this->patchMethod($method, $returnType, $declaringFile, $normalizedType);\n                }\n                if (!isset($doc['deprecated']) && strncmp($ns, $declaringClass, $len)) {\n                    if ('docblock' === $this->patchTypes['force']) {\n                        $this->patchMethod($method, $returnType, $declaringFile, $normalizedType);\n                    } elseif ('' !== $declaringClass && $this->patchTypes['deprecations']) {\n                        $deprecations[] = \\sprintf('Method \"%s::%s()\" might add \"%s\" as a native return type declaration in the future. Do the same in %s \"%s\" now to avoid errors or add an explicit @return annotation to suppress this message.', $declaringClass, $method->name, $normalizedType, interface_exists($declaringClass) ? 'implementation' : 'child class', $className);\n                    }\n                }\n            }\n\n            if (!$doc) {\n                $this->patchTypes['force'] = $forcePatchTypes;\n\n                continue;\n            }\n\n            if (isset($doc['return'])) {\n                $this->setReturnType($doc['return'] ?? self::MAGIC_METHODS[$method->name], $method->class, $method->name, $method->getFileName(), $parent, $method->getReturnType());\n\n                if (isset(self::$returnTypes[$class][$method->name][0]) && $canAddReturnType) {\n                    $this->fixReturnStatements($method, self::$returnTypes[$class][$method->name][0]);\n                }\n\n                if ($method->isPrivate()) {\n                    unset(self::$returnTypes[$class][$method->name]);\n                }\n            }\n\n            $this->patchTypes['force'] = $forcePatchTypes;\n\n            if ($method->isPrivate()) {\n                continue;\n            }\n\n            $finalOrInternal = false;\n\n            foreach (['final', 'internal'] as $annotation) {\n                if (null !== $description = $doc[$annotation][0] ?? null) {\n                    self::${$annotation.'Methods'}[$class][$method->name] = [$class, '' !== $description ? ' '.$description.(preg_match('/[[:punct:]]$/', $description) ? '' : '.') : '.'];\n                    $finalOrInternal = true;\n                }\n            }\n\n            if ($finalOrInternal || $method->isConstructor() || !isset($doc['param']) || StatelessInvocation::class === $class) {\n                continue;\n            }\n            if (!isset(self::$annotatedParameters[$class][$method->name])) {\n                $definedParameters = [];\n                foreach ($method->getParameters() as $parameter) {\n                    $definedParameters[$parameter->name] = true;\n                }\n            }\n            foreach ($doc['param'] as $parameterName => $parameterType) {\n                if (!isset($definedParameters[$parameterName])) {\n                    self::$annotatedParameters[$class][$method->name][$parameterName] = \\sprintf('The \"%%s::%s()\" method will require a new \"%s$%s\" argument in the next major version of its %s \"%s\", not defining it is deprecated.', $method->name, $parameterType ? $parameterType.' ' : '', $parameterName, interface_exists($className) ? 'interface' : 'parent class', $className);\n                }\n            }\n        }\n\n        $finals = isset(self::$final[$class]) || $refl->isFinal() ? [] : [\n            'finalConstants' => $refl->getReflectionConstants(\\ReflectionClassConstant::IS_PUBLIC | \\ReflectionClassConstant::IS_PROTECTED),\n            'finalProperties' => $refl->getProperties(\\ReflectionProperty::IS_PUBLIC | \\ReflectionProperty::IS_PROTECTED),\n        ];\n        foreach ($finals as $type => $reflectors) {\n            foreach ($reflectors as $r) {\n                if ($r->class !== $class) {\n                    continue;\n                }\n\n                $doc = $this->parsePhpDoc($r);\n\n                foreach ($parentAndOwnInterfaces as $use) {\n                    if (isset(self::${$type}[$use][$r->name]) && !isset($doc['deprecated']) && ('finalConstants' === $type || substr($use, 0, strrpos($use, '\\\\')) !== substr($use, 0, strrpos($class, '\\\\')))) {\n                        $msg = 'finalConstants' === $type ? '%s\" constant' : '$%s\" property';\n                        $deprecations[] = \\sprintf('The \"%s::'.$msg.' is considered final. You should not override it in \"%s\".', self::${$type}[$use][$r->name], $r->name, $class);\n                    }\n                }\n\n                if (isset($doc['final']) || ('finalProperties' === $type && str_starts_with($class, 'Symfony\\\\') && !$r->hasType())) {\n                    self::${$type}[$class][$r->name] = $class;\n                }\n            }\n        }\n\n        return $deprecations;\n    }\n\n    public function checkCase(\\ReflectionClass $refl, string $file, string $class): ?array\n    {\n        $real = explode('\\\\', $class.strrchr($file, '.'));\n        $tail = explode(\\DIRECTORY_SEPARATOR, str_replace('/', \\DIRECTORY_SEPARATOR, $file));\n\n        $i = \\count($tail) - 1;\n        $j = \\count($real) - 1;\n\n        while (isset($tail[$i], $real[$j]) && $tail[$i] === $real[$j]) {\n            --$i;\n            --$j;\n        }\n\n        array_splice($tail, 0, $i + 1);\n\n        if (!$tail) {\n            return null;\n        }\n\n        $tail = \\DIRECTORY_SEPARATOR.implode(\\DIRECTORY_SEPARATOR, $tail);\n        $tailLen = \\strlen($tail);\n        $real = $refl->getFileName();\n\n        if (2 === self::$caseCheck) {\n            $real = $this->darwinRealpath($real);\n        }\n\n        if (0 === substr_compare($real, $tail, -$tailLen, $tailLen, true)\n            && 0 !== substr_compare($real, $tail, -$tailLen, $tailLen, false)\n        ) {\n            return [substr($tail, -$tailLen + 1), substr($real, -$tailLen + 1), substr($real, 0, -$tailLen + 1)];\n        }\n\n        return null;\n    }\n\n    /**\n     * `realpath` on MacOSX doesn't normalize the case of characters.\n     */\n    private function darwinRealpath(string $real): string\n    {\n        $i = 1 + strrpos($real, '/');\n        $file = substr($real, $i);\n        $real = substr($real, 0, $i);\n\n        if (isset(self::$darwinCache[$real])) {\n            $kDir = $real;\n        } else {\n            $kDir = strtolower($real);\n\n            if (isset(self::$darwinCache[$kDir])) {\n                $real = self::$darwinCache[$kDir][0];\n            } else {\n                $dir = getcwd();\n\n                if (!@chdir($real)) {\n                    return $real.$file;\n                }\n\n                $real = getcwd().'/';\n                chdir($dir);\n\n                $dir = $real;\n                $k = $kDir;\n                $i = \\strlen($dir) - 1;\n                while (!isset(self::$darwinCache[$k])) {\n                    self::$darwinCache[$k] = [$dir, []];\n                    self::$darwinCache[$dir] = &self::$darwinCache[$k];\n\n                    while ('/' !== $dir[--$i]) {\n                    }\n                    $k = substr($k, 0, ++$i);\n                    $dir = substr($dir, 0, $i--);\n                }\n            }\n        }\n\n        $dirFiles = self::$darwinCache[$kDir][1];\n\n        if (!isset($dirFiles[$file]) && str_ends_with($file, ') : eval()\\'d code')) {\n            // Get the file name from \"file_name.php(123) : eval()'d code\"\n            $file = substr($file, 0, strrpos($file, '(', -17));\n        }\n\n        if (isset($dirFiles[$file])) {\n            return $real.$dirFiles[$file];\n        }\n\n        $kFile = strtolower($file);\n\n        if (!isset($dirFiles[$kFile])) {\n            foreach (scandir($real, 2) as $f) {\n                if ('.' !== $f[0]) {\n                    $dirFiles[$f] = $f;\n                    if ($f === $file) {\n                        $kFile = $file;\n                    } elseif ($f !== $k = strtolower($f)) {\n                        $dirFiles[$k] = $f;\n                    }\n                }\n            }\n            self::$darwinCache[$kDir][1] = $dirFiles;\n        }\n\n        return $real.$dirFiles[$kFile];\n    }\n\n    /**\n     * `class_implements` includes interfaces from the parents so we have to manually exclude them.\n     *\n     * @return string[]\n     */\n    private function getOwnInterfaces(string $class, ?string $parent): array\n    {\n        $ownInterfaces = class_implements($class, false);\n\n        if ($parent) {\n            foreach (class_implements($parent, false) as $interface) {\n                unset($ownInterfaces[$interface]);\n            }\n        }\n\n        foreach ($ownInterfaces as $interface) {\n            foreach (class_implements($interface) as $interface) {\n                unset($ownInterfaces[$interface]);\n            }\n        }\n\n        return $ownInterfaces;\n    }\n\n    private function setReturnType(string $types, string $class, string $method, string $filename, ?string $parent, ?\\ReflectionType $returnType = null): void\n    {\n        if ('__construct' === $method) {\n            return;\n        }\n\n        if ('null' === $types) {\n            self::$returnTypes[$class][$method] = ['null', 'null', $class, $filename];\n\n            return;\n        }\n\n        if ($nullable = str_starts_with($types, 'null|')) {\n            $types = substr($types, 5);\n        } elseif ($nullable = str_ends_with($types, '|null')) {\n            $types = substr($types, 0, -5);\n        }\n        $arrayType = ['array' => 'array'];\n        $typesMap = [];\n        $glue = str_contains($types, '&') ? '&' : '|';\n        foreach (explode($glue, $types) as $t) {\n            $t = self::SPECIAL_RETURN_TYPES[strtolower($t)] ?? $t;\n            $typesMap[$this->normalizeType($t, $class, $parent, $returnType)][$t] = $t;\n        }\n\n        if (isset($typesMap['array'])) {\n            if (isset($typesMap['Traversable']) || isset($typesMap['\\Traversable'])) {\n                $typesMap['iterable'] = $arrayType !== $typesMap['array'] ? $typesMap['array'] : ['iterable'];\n                unset($typesMap['array'], $typesMap['Traversable'], $typesMap['\\Traversable']);\n            } elseif ($arrayType !== $typesMap['array'] && isset(self::$returnTypes[$class][$method]) && !$returnType) {\n                return;\n            }\n        }\n\n        if (isset($typesMap['array']) && isset($typesMap['iterable'])) {\n            if ($arrayType !== $typesMap['array']) {\n                $typesMap['iterable'] = $typesMap['array'];\n            }\n            unset($typesMap['array']);\n        }\n\n        $iterable = $object = true;\n        foreach ($typesMap as $n => $t) {\n            if ('null' !== $n) {\n                $iterable = $iterable && (\\in_array($n, ['array', 'iterable']) || str_contains($n, 'Iterator'));\n                $object = $object && (\\in_array($n, ['callable', 'object', '$this', 'static']) || !isset(self::SPECIAL_RETURN_TYPES[$n]));\n            }\n        }\n\n        $phpTypes = [];\n        $docTypes = [];\n\n        foreach ($typesMap as $n => $t) {\n            if (str_contains($n, '::')) {\n                [$definingClass, $constantName] = explode('::', $n, 2);\n                $definingClass = match ($definingClass) {\n                    'self', 'static', 'parent' => $class,\n                    default => $definingClass,\n                };\n\n                if (!\\defined($definingClass.'::'.$constantName)) {\n                    return;\n                }\n\n                $constant = new \\ReflectionClassConstant($definingClass, $constantName);\n\n                if (\\PHP_VERSION_ID >= 80300 && $constantType = $constant->getType()) {\n                    if ($constantType instanceof \\ReflectionNamedType) {\n                        $n = $constantType->getName();\n                    } else {\n                        return;\n                    }\n                } else {\n                    $n = \\gettype($constant->getValue());\n                }\n            }\n\n            if ('null' === $n) {\n                $nullable = true;\n                continue;\n            }\n\n            $docTypes[] = $t;\n\n            if ('mixed' === $n || 'void' === $n) {\n                $nullable = false;\n                $phpTypes = ['' => $n];\n                continue;\n            }\n\n            if ('resource' === $n) {\n                // there is no native type for \"resource\"\n                return;\n            }\n\n            if (!preg_match('/^(?:\\\\\\\\?[a-zA-Z_\\x80-\\xff][a-zA-Z0-9_\\x80-\\xff]*)+$/', $n)) {\n                // exclude any invalid PHP class name (e.g. `Cookie::SAMESITE_*`)\n                continue;\n            }\n\n            if (!isset($phpTypes['']) && !\\in_array($n, $phpTypes, true)) {\n                $phpTypes[] = $n;\n            }\n        }\n        $docTypes = array_merge([], ...$docTypes);\n\n        if (!$phpTypes) {\n            return;\n        }\n\n        if (1 < \\count($phpTypes)) {\n            if ($iterable && '8.0' > $this->patchTypes['php']) {\n                $phpTypes = $docTypes = ['iterable'];\n            } elseif ($object && 'object' === $this->patchTypes['force']) {\n                $phpTypes = $docTypes = ['object'];\n            } elseif ('8.0' > $this->patchTypes['php']) {\n                // ignore multi-types return declarations\n                return;\n            }\n        }\n\n        $phpType = \\sprintf($nullable ? (1 < \\count($phpTypes) ? '%s|null' : '?%s') : '%s', implode($glue, $phpTypes));\n        $docType = \\sprintf($nullable ? '%s|null' : '%s', implode($glue, $docTypes));\n\n        self::$returnTypes[$class][$method] = [$phpType, $docType, $class, $filename];\n    }\n\n    private function normalizeType(string $type, string $class, ?string $parent, ?\\ReflectionType $returnType): string\n    {\n        if (isset(self::SPECIAL_RETURN_TYPES[$lcType = strtolower($type)])) {\n            if ('parent' === $lcType = self::SPECIAL_RETURN_TYPES[$lcType]) {\n                $lcType = null !== $parent ? '\\\\'.$parent : 'parent';\n            } elseif ('self' === $lcType) {\n                $lcType = '\\\\'.$class;\n            }\n\n            return $lcType;\n        }\n\n        // We could resolve \"use\" statements to return the FQDN\n        // but this would be too expensive for a runtime checker\n\n        if (!str_ends_with($type, '[]')) {\n            return $type;\n        }\n\n        if ($returnType instanceof \\ReflectionNamedType) {\n            $type = $returnType->getName();\n\n            if ('mixed' !== $type) {\n                return isset(self::SPECIAL_RETURN_TYPES[$type]) ? $type : '\\\\'.$type;\n            }\n        }\n\n        return 'array';\n    }\n\n    /**\n     * Utility method to add #[ReturnTypeWillChange] where php triggers deprecations.\n     */\n    private function patchReturnTypeWillChange(\\ReflectionMethod $method): void\n    {\n        if (\\count($method->getAttributes(\\ReturnTypeWillChange::class))) {\n            return;\n        }\n\n        if (!is_file($file = $method->getFileName())) {\n            return;\n        }\n\n        $fileOffset = self::$fileOffsets[$file] ?? 0;\n\n        $code = file($file);\n\n        $startLine = $method->getStartLine() + $fileOffset - 2;\n\n        if (false !== stripos($code[$startLine], 'ReturnTypeWillChange')) {\n            return;\n        }\n\n        $code[$startLine] .= \"    #[\\\\ReturnTypeWillChange]\\n\";\n        self::$fileOffsets[$file] = 1 + $fileOffset;\n        file_put_contents($file, $code);\n    }\n\n    /**\n     * Utility method to add @return annotations to the Symfony code-base where it triggers self-deprecations.\n     */\n    private function patchMethod(\\ReflectionMethod $method, string $returnType, string $declaringFile, string $normalizedType): void\n    {\n        static $patchedMethods = [];\n        static $useStatements = [];\n\n        if (!is_file($file = $method->getFileName()) || isset($patchedMethods[$file][$startLine = $method->getStartLine()])) {\n            return;\n        }\n\n        $patchedMethods[$file][$startLine] = true;\n        $fileOffset = self::$fileOffsets[$file] ?? 0;\n        $startLine += $fileOffset - 2;\n        if ($nullable = str_ends_with($returnType, '|null')) {\n            $returnType = substr($returnType, 0, -5);\n        }\n        $glue = str_contains($returnType, '&') ? '&' : '|';\n        $returnType = explode($glue, $returnType);\n        $code = file($file);\n\n        foreach ($returnType as $i => $type) {\n            if (preg_match('/((?:\\[\\])+)$/', $type, $m)) {\n                $type = substr($type, 0, -\\strlen($m[1]));\n                $format = '%s'.$m[1];\n            } else {\n                $format = null;\n            }\n\n            if (isset(self::SPECIAL_RETURN_TYPES[$type]) || ('\\\\' === $type[0] && !$p = strrpos($type, '\\\\', 1))) {\n                continue;\n            }\n\n            [$namespace, $useOffset, $useMap] = $useStatements[$file] ??= self::getUseStatements($file);\n\n            if ('\\\\' !== $type[0]) {\n                [$declaringNamespace, , $declaringUseMap] = $useStatements[$declaringFile] ??= self::getUseStatements($declaringFile);\n\n                $p = strpos($type, '\\\\', 1);\n                $alias = $p ? substr($type, 0, $p) : $type;\n\n                if (isset($declaringUseMap[$alias])) {\n                    $type = '\\\\'.$declaringUseMap[$alias].($p ? substr($type, $p) : '');\n                } else {\n                    $type = '\\\\'.$declaringNamespace.$type;\n                }\n\n                $p = strrpos($type, '\\\\', 1);\n            }\n\n            $alias = substr($type, 1 + $p);\n            $type = substr($type, 1);\n\n            if (!isset($useMap[$alias]) && (class_exists($c = $namespace.$alias) || interface_exists($c) || trait_exists($c))) {\n                $useMap[$alias] = $c;\n            }\n\n            if (!isset($useMap[$alias])) {\n                $useStatements[$file][2][$alias] = $type;\n                $code[$useOffset] = \"use $type;\\n\".$code[$useOffset];\n                ++$fileOffset;\n            } elseif ($useMap[$alias] !== $type) {\n                $alias .= 'FIXME';\n                $useStatements[$file][2][$alias] = $type;\n                $code[$useOffset] = \"use $type as $alias;\\n\".$code[$useOffset];\n                ++$fileOffset;\n            }\n\n            $returnType[$i] = null !== $format ? \\sprintf($format, $alias) : $alias;\n        }\n\n        if ('docblock' === $this->patchTypes['force'] || ('object' === $normalizedType && '7.1' === $this->patchTypes['php'])) {\n            $returnType = implode($glue, $returnType).($nullable ? '|null' : '');\n\n            if (str_contains($code[$startLine], '#[')) {\n                --$startLine;\n            }\n\n            if ($method->getDocComment()) {\n                $code[$startLine] = \"     * @return $returnType\\n\".$code[$startLine];\n            } else {\n                $code[$startLine] .= <<<EOTXT\n    /**\n     * @return $returnType\n     */\n\nEOTXT;\n            }\n\n            $fileOffset += substr_count($code[$startLine], \"\\n\") - 1;\n        }\n\n        self::$fileOffsets[$file] = $fileOffset;\n        file_put_contents($file, $code);\n\n        $this->fixReturnStatements($method, $normalizedType);\n    }\n\n    private static function getUseStatements(string $file): array\n    {\n        $namespace = '';\n        $useMap = [];\n        $useOffset = 0;\n\n        if (!is_file($file)) {\n            return [$namespace, $useOffset, $useMap];\n        }\n\n        $file = file($file);\n\n        for ($i = 0; $i < \\count($file); ++$i) {\n            if (preg_match('/^(class|interface|trait|abstract) /', $file[$i])) {\n                break;\n            }\n\n            if (str_starts_with($file[$i], 'namespace ')) {\n                $namespace = substr($file[$i], \\strlen('namespace '), -2).'\\\\';\n                $useOffset = $i + 2;\n            }\n\n            if (str_starts_with($file[$i], 'use ')) {\n                $useOffset = $i;\n\n                for (; str_starts_with($file[$i], 'use '); ++$i) {\n                    $u = explode(' as ', substr($file[$i], 4, -2), 2);\n\n                    if (1 === \\count($u)) {\n                        $p = strrpos($u[0], '\\\\');\n                        $useMap[substr($u[0], false !== $p ? 1 + $p : 0)] = $u[0];\n                    } else {\n                        $useMap[$u[1]] = $u[0];\n                    }\n                }\n\n                break;\n            }\n        }\n\n        return [$namespace, $useOffset, $useMap];\n    }\n\n    private function fixReturnStatements(\\ReflectionMethod $method, string $returnType): void\n    {\n        if ('docblock' !== $this->patchTypes['force']) {\n            if ('7.1' === $this->patchTypes['php'] && 'object' === ltrim($returnType, '?')) {\n                return;\n            }\n\n            if ('7.4' > $this->patchTypes['php'] && $method->hasReturnType()) {\n                return;\n            }\n\n            if ('8.0' > $this->patchTypes['php'] && (str_contains($returnType, '|') || \\in_array($returnType, ['mixed', 'static'], true))) {\n                return;\n            }\n\n            if ('8.1' > $this->patchTypes['php'] && str_contains($returnType, '&')) {\n                return;\n            }\n        }\n\n        if (!is_file($file = $method->getFileName())) {\n            return;\n        }\n\n        $fixedCode = $code = file($file);\n        $i = (self::$fileOffsets[$file] ?? 0) + $method->getStartLine();\n\n        if ('?' !== $returnType && 'docblock' !== $this->patchTypes['force']) {\n            $fixedCode[$i - 1] = preg_replace('/\\)(?::[^;\\n]++)?(;?\\n)/', \"): $returnType\\\\1\", $code[$i - 1]);\n        }\n\n        $end = $method->isGenerator() ? $i : $method->getEndLine();\n        $inClosure = false;\n        $braces = 0;\n        for (; $i < $end; ++$i) {\n            if (!$inClosure) {\n                $inClosure = str_contains($code[$i], 'function (');\n            }\n\n            if ($inClosure) {\n                $braces += substr_count($code[$i], '{') - substr_count($code[$i], '}');\n                $inClosure = $braces > 0;\n\n                continue;\n            }\n\n            if ('void' === $returnType) {\n                $fixedCode[$i] = str_replace('    return null;', '    return;', $code[$i]);\n            } elseif ('mixed' === $returnType || '?' === $returnType[0]) {\n                $fixedCode[$i] = str_replace('    return;', '    return null;', $code[$i]);\n            } else {\n                $fixedCode[$i] = str_replace('    return;', \"    return $returnType!?;\", $code[$i]);\n            }\n        }\n\n        if ($fixedCode !== $code) {\n            file_put_contents($file, $fixedCode);\n        }\n    }\n\n    /**\n     * @param \\ReflectionClass|\\ReflectionMethod|\\ReflectionProperty $reflector\n     */\n    private function parsePhpDoc(\\Reflector $reflector): array\n    {\n        if (!$doc = $reflector->getDocComment()) {\n            return [];\n        }\n\n        $tagName = '';\n        $tagContent = '';\n\n        $tags = [];\n\n        foreach (explode(\"\\n\", substr($doc, 3, -2)) as $line) {\n            $line = ltrim($line);\n            $line = ltrim($line, '*');\n\n            if ('' === $line = trim($line)) {\n                if ('' !== $tagName) {\n                    $tags[$tagName][] = $tagContent;\n                }\n                $tagName = $tagContent = '';\n                continue;\n            }\n\n            if ('@' === $line[0]) {\n                if ('' !== $tagName) {\n                    $tags[$tagName][] = $tagContent;\n                    $tagContent = '';\n                }\n\n                if (preg_match('{^@([-a-zA-Z0-9_:]++)(\\s|$)}', $line, $m)) {\n                    $tagName = $m[1];\n                    $tagContent = str_replace(\"\\t\", ' ', ltrim(substr($line, 2 + \\strlen($tagName))));\n                } else {\n                    $tagName = '';\n                }\n            } elseif ('' !== $tagName) {\n                $tagContent .= ' '.str_replace(\"\\t\", ' ', $line);\n            }\n        }\n\n        if ('' !== $tagName) {\n            $tags[$tagName][] = $tagContent;\n        }\n\n        foreach ($tags['method'] ?? [] as $i => $method) {\n            unset($tags['method'][$i]);\n\n            $parts = preg_split('{(\\s++|\\((?:[^()]*+|(?R))*\\)(?: *: *[^ ]++)?|<(?:[^<>]*+|(?R))*>|\\{(?:[^{}]*+|(?R))*\\})}', $method, -1, \\PREG_SPLIT_DELIM_CAPTURE);\n            $returnType = '';\n            $static = 'static' === $parts[0];\n\n            for ($i = $static ? 2 : 0; null !== $p = $parts[$i] ?? null; $i += 2) {\n                if (\\in_array($p, ['', '|', '&', 'callable'], true) || \\in_array(substr($returnType, -1), ['|', '&'], true)) {\n                    $returnType .= trim($parts[$i - 1] ?? '').$p;\n                    continue;\n                }\n\n                $signature = '(' === ($parts[$i + 1][0] ?? '(') ? $parts[$i + 1] ?? '()' : null;\n\n                if (null === $signature && '' === $returnType) {\n                    $returnType = $p;\n                    continue;\n                }\n\n                if ($static && 2 === $i) {\n                    $static = false;\n                    $returnType = 'static';\n                }\n\n                if (\\in_array($description = trim(implode('', \\array_slice($parts, 2 + $i))), ['', '.'], true)) {\n                    $description = null;\n                } elseif (!preg_match('/[.!]$/', $description)) {\n                    $description .= '.';\n                }\n\n                $tags['method'][$p] = [$static, $returnType, $signature ?? '()', $description];\n                break;\n            }\n        }\n\n        foreach ($tags['param'] ?? [] as $i => $param) {\n            unset($tags['param'][$i]);\n\n            if (\\strlen($param) !== strcspn($param, '<{(')) {\n                $param = preg_replace('{\\(([^()]*+|(?R))*\\)(?: *: *[^ ]++)?|<([^<>]*+|(?R))*>|\\{([^{}]*+|(?R))*\\}}', '', $param);\n            }\n\n            if (false === $i = strpos($param, '$')) {\n                continue;\n            }\n\n            $type = 0 === $i ? '' : rtrim(substr($param, 0, $i), ' &');\n            $param = substr($param, 1 + $i, (strpos($param, ' ', $i) ?: (1 + $i + \\strlen($param))) - $i - 1);\n\n            $tags['param'][$param] = $type;\n        }\n\n        foreach (['var', 'return'] as $k) {\n            if (null === $v = $tags[$k][0] ?? null) {\n                continue;\n            }\n            if (\\strlen($v) !== strcspn($v, '<{(')) {\n                $v = preg_replace('{\\(([^()]*+|(?R))*\\)(?: *: *[^ ]++)?|<([^<>]*+|(?R))*>|\\{([^{}]*+|(?R))*\\}}', '', $v);\n            }\n\n            $tags[$k] = substr($v, 0, strpos($v, ' ') ?: \\strlen($v)) ?: null;\n        }\n\n        return $tags;\n    }\n}\n"
        },
        {
          "name": "Error",
          "type": "tree",
          "content": null
        },
        {
          "name": "ErrorEnhancer",
          "type": "tree",
          "content": null
        },
        {
          "name": "ErrorHandler.php",
          "type": "blob",
          "size": 26.80859375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ErrorHandler;\n\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\LogLevel;\nuse Symfony\\Component\\ErrorHandler\\Error\\FatalError;\nuse Symfony\\Component\\ErrorHandler\\Error\\OutOfMemoryError;\nuse Symfony\\Component\\ErrorHandler\\ErrorEnhancer\\ClassNotFoundErrorEnhancer;\nuse Symfony\\Component\\ErrorHandler\\ErrorEnhancer\\ErrorEnhancerInterface;\nuse Symfony\\Component\\ErrorHandler\\ErrorEnhancer\\UndefinedFunctionErrorEnhancer;\nuse Symfony\\Component\\ErrorHandler\\ErrorEnhancer\\UndefinedMethodErrorEnhancer;\nuse Symfony\\Component\\ErrorHandler\\ErrorRenderer\\CliErrorRenderer;\nuse Symfony\\Component\\ErrorHandler\\ErrorRenderer\\HtmlErrorRenderer;\nuse Symfony\\Component\\ErrorHandler\\Exception\\SilencedErrorContext;\n\n/**\n * A generic ErrorHandler for the PHP engine.\n *\n * Provides five bit fields that control how errors are handled:\n * - thrownErrors: errors thrown as \\ErrorException\n * - loggedErrors: logged errors, when not @-silenced\n * - scopedErrors: errors thrown or logged with their local context\n * - tracedErrors: errors logged with their stack trace\n * - screamedErrors: never @-silenced errors\n *\n * Each error level can be logged by a dedicated PSR-3 logger object.\n * Screaming only applies to logging.\n * Throwing takes precedence over logging.\n * Uncaught exceptions are logged as E_ERROR.\n * E_DEPRECATED and E_USER_DEPRECATED levels never throw.\n * E_RECOVERABLE_ERROR and E_USER_ERROR levels always throw.\n * Non catchable errors that can be detected at shutdown time are logged when the scream bit field allows so.\n * As errors have a performance cost, repeated errors are all logged, so that the developer\n * can see them and weight them as more important to fix than others of the same level.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n * @author Grégoire Pineau <lyrixx@lyrixx.info>\n *\n * @final\n */\nclass ErrorHandler\n{\n    private array $levels = [\n        \\E_DEPRECATED => 'Deprecated',\n        \\E_USER_DEPRECATED => 'User Deprecated',\n        \\E_NOTICE => 'Notice',\n        \\E_USER_NOTICE => 'User Notice',\n        \\E_WARNING => 'Warning',\n        \\E_USER_WARNING => 'User Warning',\n        \\E_COMPILE_WARNING => 'Compile Warning',\n        \\E_CORE_WARNING => 'Core Warning',\n        \\E_USER_ERROR => 'User Error',\n        \\E_RECOVERABLE_ERROR => 'Catchable Fatal Error',\n        \\E_COMPILE_ERROR => 'Compile Error',\n        \\E_PARSE => 'Parse Error',\n        \\E_ERROR => 'Error',\n        \\E_CORE_ERROR => 'Core Error',\n    ];\n\n    private array $loggers = [\n        \\E_DEPRECATED => [null, LogLevel::INFO],\n        \\E_USER_DEPRECATED => [null, LogLevel::INFO],\n        \\E_NOTICE => [null, LogLevel::ERROR],\n        \\E_USER_NOTICE => [null, LogLevel::ERROR],\n        \\E_WARNING => [null, LogLevel::ERROR],\n        \\E_USER_WARNING => [null, LogLevel::ERROR],\n        \\E_COMPILE_WARNING => [null, LogLevel::ERROR],\n        \\E_CORE_WARNING => [null, LogLevel::ERROR],\n        \\E_USER_ERROR => [null, LogLevel::CRITICAL],\n        \\E_RECOVERABLE_ERROR => [null, LogLevel::CRITICAL],\n        \\E_COMPILE_ERROR => [null, LogLevel::CRITICAL],\n        \\E_PARSE => [null, LogLevel::CRITICAL],\n        \\E_ERROR => [null, LogLevel::CRITICAL],\n        \\E_CORE_ERROR => [null, LogLevel::CRITICAL],\n    ];\n\n    private int $thrownErrors = 0x1FFF; // E_ALL - E_DEPRECATED - E_USER_DEPRECATED\n    private int $scopedErrors = 0x1FFF; // E_ALL - E_DEPRECATED - E_USER_DEPRECATED\n    private int $tracedErrors = 0x77FB; // E_ALL - E_STRICT - E_PARSE\n    private int $screamedErrors = 0x55; // E_ERROR + E_CORE_ERROR + E_COMPILE_ERROR + E_PARSE\n    private int $loggedErrors = 0;\n    private \\Closure $configureException;\n\n    private bool $isRecursive = false;\n    private bool $isRoot = false;\n    /** @var callable|null */\n    private $exceptionHandler;\n    private ?BufferingLogger $bootstrappingLogger = null;\n\n    private static ?string $reservedMemory = null;\n    private static array $silencedErrorCache = [];\n    private static int $silencedErrorCount = 0;\n    private static int $exitCode = 0;\n\n    /**\n     * Registers the error handler.\n     */\n    public static function register(?self $handler = null, bool $replace = true): self\n    {\n        if (null === self::$reservedMemory) {\n            self::$reservedMemory = str_repeat('x', 32768);\n            register_shutdown_function(self::handleFatalError(...));\n        }\n\n        if ($handlerIsNew = null === $handler) {\n            $handler = new static();\n        }\n\n        if (null === $prev = set_error_handler([$handler, 'handleError'])) {\n            restore_error_handler();\n            // Specifying the error types earlier would expose us to https://bugs.php.net/63206\n            set_error_handler([$handler, 'handleError'], $handler->thrownErrors | $handler->loggedErrors);\n            $handler->isRoot = true;\n        }\n\n        if ($handlerIsNew && \\is_array($prev) && $prev[0] instanceof self) {\n            $handler = $prev[0];\n            $replace = false;\n        }\n        if (!$replace && $prev) {\n            restore_error_handler();\n            $handlerIsRegistered = \\is_array($prev) && $handler === $prev[0];\n        } else {\n            $handlerIsRegistered = true;\n        }\n        if (\\is_array($prev = set_exception_handler([$handler, 'handleException'])) && $prev[0] instanceof self) {\n            restore_exception_handler();\n            if (!$handlerIsRegistered) {\n                $handler = $prev[0];\n            } elseif ($handler !== $prev[0] && $replace) {\n                set_exception_handler([$handler, 'handleException']);\n                $p = $prev[0]->setExceptionHandler(null);\n                $handler->setExceptionHandler($p);\n                $prev[0]->setExceptionHandler($p);\n            }\n        } else {\n            $handler->setExceptionHandler($prev ?? [$handler, 'renderException']);\n        }\n\n        $handler->throwAt(\\E_ALL & $handler->thrownErrors, true);\n\n        return $handler;\n    }\n\n    /**\n     * Calls a function and turns any PHP error into \\ErrorException.\n     *\n     * @throws \\ErrorException When $function(...$arguments) triggers a PHP error\n     */\n    public static function call(callable $function, mixed ...$arguments): mixed\n    {\n        set_error_handler(static function (int $type, string $message, string $file, int $line) {\n            if (__FILE__ === $file) {\n                $trace = debug_backtrace(\\DEBUG_BACKTRACE_IGNORE_ARGS, 3);\n                $file = $trace[2]['file'] ?? $file;\n                $line = $trace[2]['line'] ?? $line;\n            }\n\n            throw new \\ErrorException($message, 0, $type, $file, $line);\n        });\n\n        try {\n            return $function(...$arguments);\n        } finally {\n            restore_error_handler();\n        }\n    }\n\n    public function __construct(\n        ?BufferingLogger $bootstrappingLogger = null,\n        private bool $debug = false,\n    ) {\n        if (\\PHP_VERSION_ID < 80400) {\n            $this->levels[\\E_STRICT] = 'Runtime Notice';\n            $this->loggers[\\E_STRICT] = [null, LogLevel::ERROR];\n        }\n\n        if ($bootstrappingLogger) {\n            $this->bootstrappingLogger = $bootstrappingLogger;\n            $this->setDefaultLogger($bootstrappingLogger);\n        }\n        $traceReflector = new \\ReflectionProperty(\\Exception::class, 'trace');\n        $this->configureException = \\Closure::bind(static function ($e, $trace, $file = null, $line = null) use ($traceReflector) {\n            $traceReflector->setValue($e, $trace);\n            $e->file = $file ?? $e->file;\n            $e->line = $line ?? $e->line;\n        }, null, new class extends \\Exception {\n        });\n    }\n\n    /**\n     * Sets a logger to non assigned errors levels.\n     *\n     * @param LoggerInterface $logger  A PSR-3 logger to put as default for the given levels\n     * @param array|int|null  $levels  An array map of E_* to LogLevel::* or an integer bit field of E_* constants\n     * @param bool            $replace Whether to replace or not any existing logger\n     */\n    public function setDefaultLogger(LoggerInterface $logger, array|int|null $levels = \\E_ALL, bool $replace = false): void\n    {\n        $loggers = [];\n\n        if (\\is_array($levels)) {\n            foreach ($levels as $type => $logLevel) {\n                if (empty($this->loggers[$type][0]) || $replace || $this->loggers[$type][0] === $this->bootstrappingLogger) {\n                    $loggers[$type] = [$logger, $logLevel];\n                }\n            }\n        } else {\n            $levels ??= \\E_ALL;\n            foreach ($this->loggers as $type => $log) {\n                if (($type & $levels) && (empty($log[0]) || $replace || $log[0] === $this->bootstrappingLogger)) {\n                    $log[0] = $logger;\n                    $loggers[$type] = $log;\n                }\n            }\n        }\n\n        $this->setLoggers($loggers);\n    }\n\n    /**\n     * Sets a logger for each error level.\n     *\n     * @param array $loggers Error levels to [LoggerInterface|null, LogLevel::*] map\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function setLoggers(array $loggers): array\n    {\n        $prevLogged = $this->loggedErrors;\n        $prev = $this->loggers;\n        $flush = [];\n\n        foreach ($loggers as $type => $log) {\n            if (!isset($prev[$type])) {\n                throw new \\InvalidArgumentException('Unknown error type: '.$type);\n            }\n            if (!\\is_array($log)) {\n                $log = [$log];\n            } elseif (!\\array_key_exists(0, $log)) {\n                throw new \\InvalidArgumentException('No logger provided.');\n            }\n            if (null === $log[0]) {\n                $this->loggedErrors &= ~$type;\n            } elseif ($log[0] instanceof LoggerInterface) {\n                $this->loggedErrors |= $type;\n            } else {\n                throw new \\InvalidArgumentException('Invalid logger provided.');\n            }\n            $this->loggers[$type] = $log + $prev[$type];\n\n            if ($this->bootstrappingLogger && $prev[$type][0] === $this->bootstrappingLogger) {\n                $flush[$type] = $type;\n            }\n        }\n        $this->reRegister($prevLogged | $this->thrownErrors);\n\n        if ($flush) {\n            foreach ($this->bootstrappingLogger->cleanLogs() as $log) {\n                $type = ThrowableUtils::getSeverity($log[2]['exception']);\n                if (!isset($flush[$type])) {\n                    $this->bootstrappingLogger->log($log[0], $log[1], $log[2]);\n                } elseif ($this->loggers[$type][0]) {\n                    $this->loggers[$type][0]->log($this->loggers[$type][1], $log[1], $log[2]);\n                }\n            }\n        }\n\n        return $prev;\n    }\n\n    public function setExceptionHandler(?callable $handler): ?callable\n    {\n        $prev = $this->exceptionHandler;\n        $this->exceptionHandler = $handler;\n\n        return $prev;\n    }\n\n    /**\n     * Sets the PHP error levels that throw an exception when a PHP error occurs.\n     *\n     * @param int  $levels  A bit field of E_* constants for thrown errors\n     * @param bool $replace Replace or amend the previous value\n     */\n    public function throwAt(int $levels, bool $replace = false): int\n    {\n        $prev = $this->thrownErrors;\n        $this->thrownErrors = ($levels | \\E_RECOVERABLE_ERROR | \\E_USER_ERROR) & ~\\E_USER_DEPRECATED & ~\\E_DEPRECATED;\n        if (!$replace) {\n            $this->thrownErrors |= $prev;\n        }\n        $this->reRegister($prev | $this->loggedErrors);\n\n        return $prev;\n    }\n\n    /**\n     * Sets the PHP error levels for which local variables are preserved.\n     *\n     * @param int  $levels  A bit field of E_* constants for scoped errors\n     * @param bool $replace Replace or amend the previous value\n     */\n    public function scopeAt(int $levels, bool $replace = false): int\n    {\n        $prev = $this->scopedErrors;\n        $this->scopedErrors = $levels;\n        if (!$replace) {\n            $this->scopedErrors |= $prev;\n        }\n\n        return $prev;\n    }\n\n    /**\n     * Sets the PHP error levels for which the stack trace is preserved.\n     *\n     * @param int  $levels  A bit field of E_* constants for traced errors\n     * @param bool $replace Replace or amend the previous value\n     */\n    public function traceAt(int $levels, bool $replace = false): int\n    {\n        $prev = $this->tracedErrors;\n        $this->tracedErrors = $levels;\n        if (!$replace) {\n            $this->tracedErrors |= $prev;\n        }\n\n        return $prev;\n    }\n\n    /**\n     * Sets the error levels where the @-operator is ignored.\n     *\n     * @param int  $levels  A bit field of E_* constants for screamed errors\n     * @param bool $replace Replace or amend the previous value\n     */\n    public function screamAt(int $levels, bool $replace = false): int\n    {\n        $prev = $this->screamedErrors;\n        $this->screamedErrors = $levels;\n        if (!$replace) {\n            $this->screamedErrors |= $prev;\n        }\n\n        return $prev;\n    }\n\n    /**\n     * Re-registers as a PHP error handler if levels changed.\n     */\n    private function reRegister(int $prev): void\n    {\n        if ($prev !== ($this->thrownErrors | $this->loggedErrors)) {\n            $handler = set_error_handler(static fn () => null);\n            $handler = \\is_array($handler) ? $handler[0] : null;\n            restore_error_handler();\n            if ($handler === $this) {\n                restore_error_handler();\n                if ($this->isRoot) {\n                    set_error_handler([$this, 'handleError'], $this->thrownErrors | $this->loggedErrors);\n                } else {\n                    set_error_handler([$this, 'handleError']);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handles errors by filtering then logging them according to the configured bit fields.\n     *\n     * @return bool Returns false when no handling happens so that the PHP engine can handle the error itself\n     *\n     * @throws \\ErrorException When $this->thrownErrors requests so\n     *\n     * @internal\n     */\n    public function handleError(int $type, string $message, string $file, int $line): bool\n    {\n        if (\\E_WARNING === $type && '\"' === $message[0] && str_contains($message, '\" targeting switch is equivalent to \"break')) {\n            $type = \\E_DEPRECATED;\n        }\n\n        // Level is the current error reporting level to manage silent error.\n        $level = error_reporting();\n        $silenced = 0 === ($level & $type);\n        // Strong errors are not authorized to be silenced.\n        $level |= \\E_RECOVERABLE_ERROR | \\E_USER_ERROR | \\E_DEPRECATED | \\E_USER_DEPRECATED;\n        $log = $this->loggedErrors & $type;\n        $throw = $this->thrownErrors & $type & $level;\n        $type &= $level | $this->screamedErrors;\n\n        // Never throw on warnings triggered by assert()\n        if (\\E_WARNING === $type && 'a' === $message[0] && 0 === strncmp($message, 'assert(): ', 10)) {\n            $throw = 0;\n        }\n\n        if (!$type || (!$log && !$throw)) {\n            return false;\n        }\n\n        $logMessage = $this->levels[$type].': '.$message;\n\n        if (!$throw && !($type & $level)) {\n            if (!isset(self::$silencedErrorCache[$id = $file.':'.$line])) {\n                $lightTrace = $this->tracedErrors & $type ? $this->cleanTrace(debug_backtrace(\\DEBUG_BACKTRACE_IGNORE_ARGS, 5), $type, $file, $line, false) : [];\n                $errorAsException = new SilencedErrorContext($type, $file, $line, isset($lightTrace[1]) ? [$lightTrace[0]] : $lightTrace);\n            } elseif (isset(self::$silencedErrorCache[$id][$message])) {\n                $lightTrace = null;\n                $errorAsException = self::$silencedErrorCache[$id][$message];\n                ++$errorAsException->count;\n            } else {\n                $lightTrace = [];\n                $errorAsException = null;\n            }\n\n            if (100 < ++self::$silencedErrorCount) {\n                self::$silencedErrorCache = $lightTrace = [];\n                self::$silencedErrorCount = 1;\n            }\n            if ($errorAsException) {\n                self::$silencedErrorCache[$id][$message] = $errorAsException;\n            }\n            if (null === $lightTrace) {\n                return true;\n            }\n        } else {\n            if (\\PHP_VERSION_ID < 80303 && str_contains($message, '@anonymous')) {\n                $backtrace = debug_backtrace(false, 5);\n\n                for ($i = 1; isset($backtrace[$i]); ++$i) {\n                    if (isset($backtrace[$i]['function'], $backtrace[$i]['args'][0])\n                        && ('trigger_error' === $backtrace[$i]['function'] || 'user_error' === $backtrace[$i]['function'])\n                    ) {\n                        if ($backtrace[$i]['args'][0] !== $message) {\n                            $message = $backtrace[$i]['args'][0];\n                        }\n\n                        break;\n                    }\n                }\n            }\n\n            if (str_contains($message, \"@anonymous\\0\")) {\n                $message = $this->parseAnonymousClass($message);\n                $logMessage = $this->levels[$type].': '.$message;\n            }\n\n            $errorAsException = new \\ErrorException($logMessage, 0, $type, $file, $line);\n\n            if ($throw || $this->tracedErrors & $type) {\n                $backtrace = $errorAsException->getTrace();\n                $backtrace = $this->cleanTrace($backtrace, $type, $file, $line, $throw);\n                ($this->configureException)($errorAsException, $backtrace, $file, $line);\n            } else {\n                ($this->configureException)($errorAsException, []);\n            }\n        }\n\n        if ($throw) {\n            throw $errorAsException;\n        }\n\n        if ($this->isRecursive) {\n            $log = 0;\n        } else {\n            try {\n                $this->isRecursive = true;\n                $level = ($type & $level) ? $this->loggers[$type][1] : LogLevel::DEBUG;\n                $this->loggers[$type][0]->log($level, $logMessage, $errorAsException ? ['exception' => $errorAsException] : []);\n            } finally {\n                $this->isRecursive = false;\n            }\n        }\n\n        return !$silenced && $type && $log;\n    }\n\n    /**\n     * Handles an exception by logging then forwarding it to another handler.\n     *\n     * @internal\n     */\n    public function handleException(\\Throwable $exception): void\n    {\n        $handlerException = null;\n\n        if (!$exception instanceof FatalError) {\n            self::$exitCode = 255;\n\n            $type = ThrowableUtils::getSeverity($exception);\n        } else {\n            $type = $exception->getError()['type'];\n        }\n\n        if ($this->loggedErrors & $type) {\n            if (str_contains($message = $exception->getMessage(), \"@anonymous\\0\")) {\n                $message = $this->parseAnonymousClass($message);\n            }\n\n            if ($exception instanceof FatalError) {\n                $message = 'Fatal '.$message;\n            } elseif ($exception instanceof \\Error) {\n                $message = 'Uncaught Error: '.$message;\n            } elseif ($exception instanceof \\ErrorException) {\n                $message = 'Uncaught '.$message;\n            } else {\n                $message = 'Uncaught Exception: '.$message;\n            }\n\n            try {\n                $this->loggers[$type][0]->log($this->loggers[$type][1], $message, ['exception' => $exception]);\n            } catch (\\Throwable $handlerException) {\n            }\n        }\n\n        $exception = $this->enhanceError($exception);\n\n        $exceptionHandler = $this->exceptionHandler;\n        $this->exceptionHandler = [$this, 'renderException'];\n\n        if (null === $exceptionHandler || $exceptionHandler === $this->exceptionHandler) {\n            $this->exceptionHandler = null;\n        }\n\n        try {\n            if (null !== $exceptionHandler) {\n                $exceptionHandler($exception);\n\n                return;\n            }\n            $handlerException ??= $exception;\n        } catch (\\Throwable $handlerException) {\n        }\n        if ($exception === $handlerException && null === $this->exceptionHandler) {\n            self::$reservedMemory = null; // Disable the fatal error handler\n            throw $exception; // Give back $exception to the native handler\n        }\n\n        $loggedErrors = $this->loggedErrors;\n        if ($exception === $handlerException) {\n            $this->loggedErrors &= ~$type;\n        }\n\n        try {\n            $this->handleException($handlerException);\n        } finally {\n            $this->loggedErrors = $loggedErrors;\n        }\n    }\n\n    /**\n     * Shutdown registered function for handling PHP fatal errors.\n     *\n     * @param array|null $error An array as returned by error_get_last()\n     *\n     * @internal\n     */\n    public static function handleFatalError(?array $error = null): void\n    {\n        if (null === self::$reservedMemory) {\n            return;\n        }\n\n        $handler = self::$reservedMemory = null;\n        $handlers = [];\n        $previousHandler = null;\n        $sameHandlerLimit = 10;\n\n        while (!\\is_array($handler) || !$handler[0] instanceof self) {\n            $handler = set_exception_handler('is_int');\n            restore_exception_handler();\n\n            if (!$handler) {\n                break;\n            }\n            restore_exception_handler();\n\n            if ($handler !== $previousHandler) {\n                array_unshift($handlers, $handler);\n                $previousHandler = $handler;\n            } elseif (0 === --$sameHandlerLimit) {\n                $handler = null;\n                break;\n            }\n        }\n        foreach ($handlers as $h) {\n            set_exception_handler($h);\n        }\n        if (!$handler) {\n            if (null === $error && $exitCode = self::$exitCode) {\n                register_shutdown_function('register_shutdown_function', function () use ($exitCode) { exit($exitCode); });\n            }\n\n            return;\n        }\n        if ($handler !== $h) {\n            $handler[0]->setExceptionHandler($h);\n        }\n        $handler = $handler[0];\n        $handlers = [];\n\n        if ($exit = null === $error) {\n            $error = error_get_last();\n        }\n\n        if ($error && $error['type'] &= \\E_PARSE | \\E_ERROR | \\E_CORE_ERROR | \\E_COMPILE_ERROR) {\n            // Let's not throw anymore but keep logging\n            $handler->throwAt(0, true);\n            $trace = $error['backtrace'] ?? null;\n\n            if (str_starts_with($error['message'], 'Allowed memory') || str_starts_with($error['message'], 'Out of memory')) {\n                $fatalError = new OutOfMemoryError($handler->levels[$error['type']].': '.$error['message'], 0, $error, 2, false, $trace);\n            } else {\n                $fatalError = new FatalError($handler->levels[$error['type']].': '.$error['message'], 0, $error, 2, true, $trace);\n            }\n        } else {\n            $fatalError = null;\n        }\n\n        try {\n            if (null !== $fatalError) {\n                self::$exitCode = 255;\n                $handler->handleException($fatalError);\n            }\n        } catch (FatalError) {\n            // Ignore this re-throw\n        }\n\n        if ($exit && $exitCode = self::$exitCode) {\n            register_shutdown_function('register_shutdown_function', function () use ($exitCode) { exit($exitCode); });\n        }\n    }\n\n    /**\n     * Renders the given exception.\n     *\n     * As this method is mainly called during boot where nothing is yet available,\n     * the output is always either HTML or CLI depending where PHP runs.\n     */\n    private function renderException(\\Throwable $exception): void\n    {\n        $renderer = \\in_array(\\PHP_SAPI, ['cli', 'phpdbg', 'embed'], true) ? new CliErrorRenderer() : new HtmlErrorRenderer($this->debug);\n\n        $exception = $renderer->render($exception);\n\n        if (!headers_sent()) {\n            http_response_code($exception->getStatusCode());\n\n            foreach ($exception->getHeaders() as $name => $value) {\n                header($name.': '.$value, false);\n            }\n        }\n\n        echo $exception->getAsString();\n    }\n\n    public function enhanceError(\\Throwable $exception): \\Throwable\n    {\n        if ($exception instanceof OutOfMemoryError) {\n            return $exception;\n        }\n\n        foreach ($this->getErrorEnhancers() as $errorEnhancer) {\n            if ($e = $errorEnhancer->enhance($exception)) {\n                return $e;\n            }\n        }\n\n        return $exception;\n    }\n\n    /**\n     * Override this method if you want to define more error enhancers.\n     *\n     * @return ErrorEnhancerInterface[]\n     */\n    protected function getErrorEnhancers(): iterable\n    {\n        return [\n            new UndefinedFunctionErrorEnhancer(),\n            new UndefinedMethodErrorEnhancer(),\n            new ClassNotFoundErrorEnhancer(),\n        ];\n    }\n\n    /**\n     * Cleans the trace by removing function arguments and the frames added by the error handler and DebugClassLoader.\n     */\n    private function cleanTrace(array $backtrace, int $type, string &$file, int &$line, bool $throw): array\n    {\n        $lightTrace = $backtrace;\n\n        for ($i = 0; isset($backtrace[$i]); ++$i) {\n            if (isset($backtrace[$i]['file'], $backtrace[$i]['line']) && $backtrace[$i]['line'] === $line && $backtrace[$i]['file'] === $file) {\n                $lightTrace = \\array_slice($lightTrace, 1 + $i);\n                break;\n            }\n        }\n        if (\\E_USER_DEPRECATED === $type) {\n            for ($i = 0; isset($lightTrace[$i]); ++$i) {\n                if (!isset($lightTrace[$i]['file'], $lightTrace[$i]['line'], $lightTrace[$i]['function'])) {\n                    continue;\n                }\n                if (!isset($lightTrace[$i]['class']) && 'trigger_deprecation' === $lightTrace[$i]['function']) {\n                    $file = $lightTrace[$i]['file'];\n                    $line = $lightTrace[$i]['line'];\n                    $lightTrace = \\array_slice($lightTrace, 1 + $i);\n                    break;\n                }\n            }\n        }\n        if (class_exists(DebugClassLoader::class, false)) {\n            for ($i = \\count($lightTrace) - 2; 0 < $i; --$i) {\n                if (DebugClassLoader::class === ($lightTrace[$i]['class'] ?? null)) {\n                    array_splice($lightTrace, --$i, 2);\n                }\n            }\n        }\n        if (!($throw || $this->scopedErrors & $type)) {\n            for ($i = 0; isset($lightTrace[$i]); ++$i) {\n                unset($lightTrace[$i]['args'], $lightTrace[$i]['object']);\n            }\n        }\n\n        return $lightTrace;\n    }\n\n    /**\n     * Parse the error message by removing the anonymous class notation\n     * and using the parent class instead if possible.\n     */\n    private function parseAnonymousClass(string $message): string\n    {\n        return preg_replace_callback('/[a-zA-Z_\\x7f-\\xff][\\\\\\\\a-zA-Z0-9_\\x7f-\\xff]*+@anonymous\\x00.*?\\.php(?:0x?|:[0-9]++\\$)?[0-9a-fA-F]++/', static fn ($m) => class_exists($m[0], false) ? (get_parent_class($m[0]) ?: key(class_implements($m[0])) ?: 'class').'@anonymous' : $m[0], $message);\n    }\n}\n"
        },
        {
          "name": "ErrorRenderer",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2019-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.3115234375,
          "content": "ErrorHandler Component\n======================\n\nThe ErrorHandler component provides tools to manage errors and ease debugging PHP code.\n\nGetting Started\n---------------\n\n```bash\ncomposer require symfony/error-handler\n```\n\n```php\nuse Symfony\\Component\\ErrorHandler\\Debug;\nuse Symfony\\Component\\ErrorHandler\\ErrorHandler;\nuse Symfony\\Component\\ErrorHandler\\DebugClassLoader;\n\nDebug::enable();\n\n// or enable only one feature\n//ErrorHandler::register();\n//DebugClassLoader::enable();\n\n// If you want a custom generic template when debug is not enabled\n// HtmlErrorRenderer::setTemplate('/path/to/custom/error.html.php');\n\n$data = ErrorHandler::call(static function () use ($filename, $datetimeFormat) {\n    // if any code executed inside this anonymous function fails, a PHP exception\n    // will be thrown, even if the code uses the '@' PHP silence operator\n    $data = json_decode(file_get_contents($filename), true);\n    $data['read_at'] = date($datetimeFormat);\n    file_put_contents($filename, json_encode($data));\n\n    return $data;\n});\n```\n\nResources\n---------\n\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "ThrowableUtils.php",
          "type": "blob",
          "size": 0.8447265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ErrorHandler;\n\nuse Symfony\\Component\\ErrorHandler\\Exception\\SilencedErrorContext;\n\n/**\n * @internal\n */\nclass ThrowableUtils\n{\n    public static function getSeverity(SilencedErrorContext|\\Throwable $throwable): int\n    {\n        if ($throwable instanceof \\ErrorException || $throwable instanceof SilencedErrorContext) {\n            return $throwable->getSeverity();\n        }\n\n        if ($throwable instanceof \\ParseError) {\n            return \\E_PARSE;\n        }\n\n        if ($throwable instanceof \\TypeError) {\n            return \\E_RECOVERABLE_ERROR;\n        }\n\n        return \\E_ERROR;\n    }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.1005859375,
          "content": "{\n    \"name\": \"symfony/error-handler\",\n    \"type\": \"library\",\n    \"description\": \"Provides tools to manage errors and ease debugging PHP code\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"psr/log\": \"^1|^2|^3\",\n        \"symfony/var-dumper\": \"^6.4|^7.0\"\n    },\n    \"require-dev\": {\n        \"symfony/http-kernel\": \"^6.4|^7.0\",\n        \"symfony/serializer\": \"^6.4|^7.0\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3\"\n    },\n    \"conflict\": {\n        \"symfony/deprecation-contracts\": \"<2.5\",\n        \"symfony/http-kernel\": \"<6.4\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\ErrorHandler\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"bin\": [\n        \"Resources/bin/patch-type-declarations\"\n    ],\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.818359375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony ErrorHandler Component Test Suite\">\n            <directory suffix=\".phpt\">./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}