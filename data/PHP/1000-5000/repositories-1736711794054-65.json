{
  "metadata": {
    "timestamp": 1736711794054,
    "page": 65,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/cache",
      "stars": 4117,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "composer.lock\nphpunit.xml\nvendor/\n"
        },
        {
          "name": "Adapter",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 5.845703125,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * `igbinary_serialize()` is no longer used instead of `serialize()` by default when the igbinary extension is installed,\n   due to behavior compatibilities between the two\n * Add optional `Psr\\Clock\\ClockInterface` parameter to `ArrayAdapter`\n\n7.1\n---\n\n * Add option `sentinel_master` as an alias for `redis_sentinel`\n * Deprecate `CouchbaseBucketAdapter`, use `CouchbaseCollectionAdapter`\n * Add support for URL encoded characters in Couchbase DSN\n * Add support for using DSN with PDOAdapter\n * The algorithm for the default cache namespace changed from SHA256 to XXH128\n\n7.0\n---\n\n * Add parameter `$isSameDatabase` to `DoctrineDbalAdapter::configureSchema()`\n * Drop support for Postgres < 9.5 and SQL Server < 2008 in `DoctrineDbalAdapter`\n\n6.4\n---\n\n * `EarlyExpirationHandler` no longer implements `MessageHandlerInterface`, rely on `AsMessageHandler` instead\n\n6.3\n---\n\n * Add support for Relay PHP extension for Redis\n * Updates to allow Redis cluster connections using predis/predis:^2.0\n * Add optional parameter `$isSameDatabase` to `DoctrineDbalAdapter::configureSchema()`\n\n6.1\n---\n\n * Add support for ACL auth in RedisAdapter\n * Improve reliability and performance of `TagAwareAdapter` by making tag versions an integral part of item value\n\n6.0\n---\n\n * Remove `DoctrineProvider` and `DoctrineAdapter`\n * Remove support of Doctrine DBAL in `PdoAdapter`\n\n5.4\n---\n\n * Deprecate `DoctrineProvider` and `DoctrineAdapter` because these classes have been added to the `doctrine/cache` package\n * Add `DoctrineDbalAdapter` identical to `PdoAdapter` for `Doctrine\\DBAL\\Connection` or DBAL URL\n * Deprecate usage of `PdoAdapter` with `Doctrine\\DBAL\\Connection` or DBAL URL\n\n5.3\n---\n\n * added support for connecting to Redis Sentinel clusters when using the Redis PHP extension\n * add support for a custom serializer to the `ApcuAdapter` class\n\n5.2.0\n-----\n\n * added integration with Messenger to allow computing cached values in a worker\n * allow ISO 8601 time intervals to specify default lifetime\n\n5.1.0\n-----\n\n * added max-items + LRU + max-lifetime capabilities to `ArrayCache`\n * added `CouchbaseBucketAdapter`\n * added context `cache-adapter` to log messages\n\n5.0.0\n-----\n\n * removed all PSR-16 implementations in the `Simple` namespace\n * removed `SimpleCacheAdapter`\n * removed `AbstractAdapter::unserialize()`\n * removed `CacheItem::getPreviousTags()`\n\n4.4.0\n-----\n\n * added support for connecting to Redis Sentinel clusters\n * added argument `$prefix` to `AdapterInterface::clear()`\n * improved `RedisTagAwareAdapter` to support Redis server >= 2.8 and up to 4B items per tag\n * added `TagAwareMarshaller` for optimized data storage when using `AbstractTagAwareAdapter`\n * added `DeflateMarshaller` to compress serialized values\n * removed support for phpredis 4 `compression`\n * [BC BREAK] `RedisTagAwareAdapter` is not compatible with `RedisCluster` from `Predis` anymore, use `phpredis` instead\n * Marked the `CacheDataCollector` class as `@final`.\n * added `SodiumMarshaller` to encrypt/decrypt values using libsodium\n\n4.3.0\n-----\n\n * removed `psr/simple-cache` dependency, run `composer require psr/simple-cache` if you need it\n * deprecated all PSR-16 adapters, use `Psr16Cache` or `Symfony\\Contracts\\Cache\\CacheInterface` implementations instead\n * deprecated `SimpleCacheAdapter`, use `Psr16Adapter` instead\n\n4.2.0\n-----\n\n * added support for connecting to Redis clusters via DSN\n * added support for configuring multiple Memcached servers via DSN\n * added `MarshallerInterface` and `DefaultMarshaller` to allow changing the serializer and provide one that automatically uses igbinary when available\n * implemented `CacheInterface`, which provides stampede protection via probabilistic early expiration and should become the preferred way to use a cache\n * added sub-second expiry accuracy for backends that support it\n * added support for phpredis 4 `compression` and `tcp_keepalive` options\n * added automatic table creation when using Doctrine DBAL with PDO-based backends\n * throw `LogicException` when `CacheItem::tag()` is called on an item coming from a non tag-aware pool\n * deprecated `CacheItem::getPreviousTags()`, use `CacheItem::getMetadata()` instead\n * deprecated the `AbstractAdapter::unserialize()` and `AbstractCache::unserialize()` methods\n * added `CacheCollectorPass` (originally in `FrameworkBundle`)\n * added `CachePoolClearerPass` (originally in `FrameworkBundle`)\n * added `CachePoolPass` (originally in `FrameworkBundle`)\n * added `CachePoolPrunerPass` (originally in `FrameworkBundle`)\n\n3.4.0\n-----\n\n * added using options from Memcached DSN\n * added PruneableInterface so PSR-6 or PSR-16 cache implementations can declare support for manual stale cache pruning\n * added prune logic to FilesystemTrait, PhpFilesTrait, PdoTrait, TagAwareAdapter and ChainTrait\n * now FilesystemAdapter, PhpFilesAdapter, FilesystemCache, PhpFilesCache, PdoAdapter, PdoCache, ChainAdapter, and\n   ChainCache implement PruneableInterface and support manual stale cache pruning\n\n3.3.0\n-----\n\n * added CacheItem::getPreviousTags() to get bound tags coming from the pool storage if any\n * added PSR-16 \"Simple Cache\" implementations for all existing PSR-6 adapters\n * added Psr6Cache and SimpleCacheAdapter for bidirectional interoperability between PSR-6 and PSR-16\n * added MemcachedAdapter (PSR-6) and MemcachedCache (PSR-16)\n * added TraceableAdapter (PSR-6) and TraceableCache (PSR-16)\n\n3.2.0\n-----\n\n * added TagAwareAdapter for tags-based invalidation\n * added PdoAdapter with PDO and Doctrine DBAL support\n * added PhpArrayAdapter and PhpFilesAdapter for OPcache-backed shared memory storage (PHP 7+ only)\n * added NullAdapter\n\n3.1.0\n-----\n\n * added the component with strict PSR-6 implementations\n * added ApcuAdapter, ArrayAdapter, FilesystemAdapter and RedisAdapter\n * added AbstractAdapter, ChainAdapter and ProxyAdapter\n * added DoctrineAdapter and DoctrineProvider for bidirectional interoperability with Doctrine Cache\n"
        },
        {
          "name": "CacheItem.php",
          "type": "blob",
          "size": 5.7919921875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Cache;\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\Cache\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Cache\\Exception\\LogicException;\nuse Symfony\\Contracts\\Cache\\ItemInterface;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class CacheItem implements ItemInterface\n{\n    private const METADATA_EXPIRY_OFFSET = 1527506807;\n    private const VALUE_WRAPPER = \"\\xA9\";\n\n    protected string $key;\n    protected mixed $value = null;\n    protected bool $isHit = false;\n    protected float|int|null $expiry = null;\n    protected array $metadata = [];\n    protected array $newMetadata = [];\n    protected ?ItemInterface $innerItem = null;\n    protected ?string $poolHash = null;\n    protected bool $isTaggable = false;\n\n    public function getKey(): string\n    {\n        return $this->key;\n    }\n\n    public function get(): mixed\n    {\n        return $this->value;\n    }\n\n    public function isHit(): bool\n    {\n        return $this->isHit;\n    }\n\n    /**\n     * @return $this\n     */\n    public function set($value): static\n    {\n        $this->value = $value;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function expiresAt(?\\DateTimeInterface $expiration): static\n    {\n        $this->expiry = null !== $expiration ? (float) $expiration->format('U.u') : null;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function expiresAfter(mixed $time): static\n    {\n        if (null === $time) {\n            $this->expiry = null;\n        } elseif ($time instanceof \\DateInterval) {\n            $this->expiry = microtime(true) + \\DateTimeImmutable::createFromFormat('U', 0)->add($time)->format('U.u');\n        } elseif (\\is_int($time)) {\n            $this->expiry = $time + microtime(true);\n        } else {\n            throw new InvalidArgumentException(\\sprintf('Expiration date must be an integer, a DateInterval or null, \"%s\" given.', get_debug_type($time)));\n        }\n\n        return $this;\n    }\n\n    public function tag(mixed $tags): static\n    {\n        if (!$this->isTaggable) {\n            throw new LogicException(\\sprintf('Cache item \"%s\" comes from a non tag-aware pool: you cannot tag it.', $this->key));\n        }\n        if (!\\is_array($tags) && !$tags instanceof \\Traversable) { // don't use is_iterable(), it's slow\n            $tags = [$tags];\n        }\n        foreach ($tags as $tag) {\n            if (!\\is_string($tag) && !$tag instanceof \\Stringable) {\n                throw new InvalidArgumentException(\\sprintf('Cache tag must be string or object that implements __toString(), \"%s\" given.', get_debug_type($tag)));\n            }\n            $tag = (string) $tag;\n            if (isset($this->newMetadata[self::METADATA_TAGS][$tag])) {\n                continue;\n            }\n            if ('' === $tag) {\n                throw new InvalidArgumentException('Cache tag length must be greater than zero.');\n            }\n            if (false !== strpbrk($tag, self::RESERVED_CHARACTERS)) {\n                throw new InvalidArgumentException(\\sprintf('Cache tag \"%s\" contains reserved characters \"%s\".', $tag, self::RESERVED_CHARACTERS));\n            }\n            $this->newMetadata[self::METADATA_TAGS][$tag] = $tag;\n        }\n\n        return $this;\n    }\n\n    public function getMetadata(): array\n    {\n        return $this->metadata;\n    }\n\n    /**\n     * Validates a cache key according to PSR-6.\n     *\n     * @param mixed $key The key to validate\n     *\n     * @throws InvalidArgumentException When $key is not valid\n     */\n    public static function validateKey($key): string\n    {\n        if (!\\is_string($key)) {\n            throw new InvalidArgumentException(\\sprintf('Cache key must be string, \"%s\" given.', get_debug_type($key)));\n        }\n        if ('' === $key) {\n            throw new InvalidArgumentException('Cache key length must be greater than zero.');\n        }\n        if (false !== strpbrk($key, self::RESERVED_CHARACTERS)) {\n            throw new InvalidArgumentException(\\sprintf('Cache key \"%s\" contains reserved characters \"%s\".', $key, self::RESERVED_CHARACTERS));\n        }\n\n        return $key;\n    }\n\n    /**\n     * Internal logging helper.\n     *\n     * @internal\n     */\n    public static function log(?LoggerInterface $logger, string $message, array $context = []): void\n    {\n        if ($logger) {\n            $logger->warning($message, $context);\n        } else {\n            $replace = [];\n            foreach ($context as $k => $v) {\n                if (\\is_scalar($v)) {\n                    $replace['{'.$k.'}'] = $v;\n                }\n            }\n            @trigger_error(strtr($message, $replace), \\E_USER_WARNING);\n        }\n    }\n\n    private function pack(): mixed\n    {\n        if (!$m = $this->newMetadata) {\n            return $this->value;\n        }\n        $valueWrapper = self::VALUE_WRAPPER;\n\n        return new $valueWrapper($this->value, $m + ['expiry' => $this->expiry]);\n    }\n\n    private function unpack(): bool\n    {\n        $v = $this->value;\n        $valueWrapper = self::VALUE_WRAPPER;\n\n        if ($v instanceof $valueWrapper) {\n            $this->value = $v->value;\n            $this->metadata = $v->metadata;\n\n            return true;\n        }\n\n        if (!\\is_array($v) || 1 !== \\count($v) || 10 !== \\strlen($k = (string) array_key_first($v)) || \"\\x9D\" !== $k[0] || \"\\0\" !== $k[5] || \"\\x5F\" !== $k[9]) {\n            return false;\n        }\n\n        // BC with pools populated before v6.1\n        $this->value = $v[$k];\n        $this->metadata = unpack('Vexpiry/Nctime', substr($k, 1, -1));\n        $this->metadata['expiry'] += self::METADATA_EXPIRY_OFFSET;\n\n        return true;\n    }\n}\n"
        },
        {
          "name": "DataCollector",
          "type": "tree",
          "content": null
        },
        {
          "name": "DependencyInjection",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2016-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "LockRegistry.php",
          "type": "blob",
          "size": 6.8564453125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Cache;\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Contracts\\Cache\\CacheInterface;\nuse Symfony\\Contracts\\Cache\\ItemInterface;\n\n/**\n * LockRegistry is used internally by existing adapters to protect against cache stampede.\n *\n * It does so by wrapping the computation of items in a pool of locks.\n * Foreach each apps, there can be at most 20 concurrent processes that\n * compute items at the same time and only one per cache-key.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class LockRegistry\n{\n    private static array $openedFiles = [];\n    private static ?array $lockedFiles = null;\n    private static \\Exception $signalingException;\n    private static \\Closure $signalingCallback;\n\n    /**\n     * The number of items in this list controls the max number of concurrent processes.\n     */\n    private static array $files = [\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'AbstractAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'AbstractTagAwareAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'AdapterInterface.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'ApcuAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'ArrayAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'ChainAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'CouchbaseBucketAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'CouchbaseCollectionAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'DoctrineDbalAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'FilesystemAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'FilesystemTagAwareAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'MemcachedAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'NullAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'ParameterNormalizer.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'PdoAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'PhpArrayAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'PhpFilesAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'ProxyAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'Psr16Adapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'RedisAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'RedisTagAwareAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'TagAwareAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'TagAwareAdapterInterface.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'TraceableAdapter.php',\n        __DIR__.\\DIRECTORY_SEPARATOR.'Adapter'.\\DIRECTORY_SEPARATOR.'TraceableTagAwareAdapter.php',\n    ];\n\n    /**\n     * Defines a set of existing files that will be used as keys to acquire locks.\n     *\n     * @return array The previously defined set of files\n     */\n    public static function setFiles(array $files): array\n    {\n        $previousFiles = self::$files;\n        self::$files = $files;\n\n        foreach (self::$openedFiles as $file) {\n            if ($file) {\n                flock($file, \\LOCK_UN);\n                fclose($file);\n            }\n        }\n        self::$openedFiles = self::$lockedFiles = [];\n\n        return $previousFiles;\n    }\n\n    public static function compute(callable $callback, ItemInterface $item, bool &$save, CacheInterface $pool, ?\\Closure $setMetadata = null, ?LoggerInterface $logger = null): mixed\n    {\n        if ('\\\\' === \\DIRECTORY_SEPARATOR && null === self::$lockedFiles) {\n            // disable locking on Windows by default\n            self::$files = self::$lockedFiles = [];\n        }\n\n        $key = self::$files ? abs(crc32($item->getKey())) % \\count(self::$files) : -1;\n\n        if ($key < 0 || self::$lockedFiles || !$lock = self::open($key)) {\n            return $callback($item, $save);\n        }\n\n        self::$signalingException ??= unserialize(\"O:9:\\\"Exception\\\":1:{s:16:\\\"\\0Exception\\0trace\\\";a:0:{}}\");\n        self::$signalingCallback ??= fn () => throw self::$signalingException;\n\n        while (true) {\n            try {\n                // race to get the lock in non-blocking mode\n                $locked = flock($lock, \\LOCK_EX | \\LOCK_NB, $wouldBlock);\n\n                if ($locked || !$wouldBlock) {\n                    $logger?->info(\\sprintf('Lock %s, now computing item \"{key}\"', $locked ? 'acquired' : 'not supported'), ['key' => $item->getKey()]);\n                    self::$lockedFiles[$key] = true;\n\n                    $value = $callback($item, $save);\n\n                    if ($save) {\n                        if ($setMetadata) {\n                            $setMetadata($item);\n                        }\n\n                        $pool->save($item->set($value));\n                        $save = false;\n                    }\n\n                    return $value;\n                }\n                // if we failed the race, retry locking in blocking mode to wait for the winner\n                $logger?->info('Item \"{key}\" is locked, waiting for it to be released', ['key' => $item->getKey()]);\n                flock($lock, \\LOCK_SH);\n            } finally {\n                flock($lock, \\LOCK_UN);\n                unset(self::$lockedFiles[$key]);\n            }\n\n            try {\n                $value = $pool->get($item->getKey(), self::$signalingCallback, 0);\n                $logger?->info('Item \"{key}\" retrieved after lock was released', ['key' => $item->getKey()]);\n                $save = false;\n\n                return $value;\n            } catch (\\Exception $e) {\n                if (self::$signalingException !== $e) {\n                    throw $e;\n                }\n                $logger?->info('Item \"{key}\" not found while lock was released, now retrying', ['key' => $item->getKey()]);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @return resource|false\n     */\n    private static function open(int $key)\n    {\n        if (null !== $h = self::$openedFiles[$key] ?? null) {\n            return $h;\n        }\n        set_error_handler(static fn () => null);\n        try {\n            $h = fopen(self::$files[$key], 'r+');\n        } finally {\n            restore_error_handler();\n        }\n\n        return self::$openedFiles[$key] = $h ?: @fopen(self::$files[$key], 'r');\n    }\n}\n"
        },
        {
          "name": "Marshaller",
          "type": "tree",
          "content": null
        },
        {
          "name": "Messenger",
          "type": "tree",
          "content": null
        },
        {
          "name": "PruneableInterface.php",
          "type": "blob",
          "size": 0.4443359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Cache;\n\n/**\n * Interface extends psr-6 and psr-16 caches to allow for pruning (deletion) of all expired cache items.\n */\ninterface PruneableInterface\n{\n    public function prune(): bool;\n}\n"
        },
        {
          "name": "Psr16Cache.php",
          "type": "blob",
          "size": 7.5947265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Cache;\n\nuse Psr\\Cache\\CacheException as Psr6CacheException;\nuse Psr\\Cache\\CacheItemPoolInterface;\nuse Psr\\SimpleCache\\CacheException as SimpleCacheException;\nuse Psr\\SimpleCache\\CacheInterface;\nuse Symfony\\Component\\Cache\\Adapter\\AdapterInterface;\nuse Symfony\\Component\\Cache\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Cache\\Traits\\ProxyTrait;\n\n/**\n * Turns a PSR-6 cache into a PSR-16 one.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass Psr16Cache implements CacheInterface, PruneableInterface, ResettableInterface\n{\n    use ProxyTrait;\n\n    private ?\\Closure $createCacheItem = null;\n    private ?CacheItem $cacheItemPrototype = null;\n    private static \\Closure $packCacheItem;\n\n    public function __construct(CacheItemPoolInterface $pool)\n    {\n        $this->pool = $pool;\n\n        if (!$pool instanceof AdapterInterface) {\n            return;\n        }\n        $cacheItemPrototype = &$this->cacheItemPrototype;\n        $createCacheItem = \\Closure::bind(\n            static function ($key, $value, $allowInt = false) use (&$cacheItemPrototype) {\n                $item = clone $cacheItemPrototype;\n                $item->poolHash = $item->innerItem = null;\n                if ($allowInt && \\is_int($key)) {\n                    $item->key = (string) $key;\n                } else {\n                    \\assert('' !== CacheItem::validateKey($key));\n                    $item->key = $key;\n                }\n                $item->value = $value;\n                $item->isHit = false;\n\n                return $item;\n            },\n            null,\n            CacheItem::class\n        );\n        $this->createCacheItem = function ($key, $value, $allowInt = false) use ($createCacheItem) {\n            if (null === $this->cacheItemPrototype) {\n                $this->get($allowInt && \\is_int($key) ? (string) $key : $key);\n            }\n            $this->createCacheItem = $createCacheItem;\n\n            return $createCacheItem($key, null, $allowInt)->set($value);\n        };\n        self::$packCacheItem ??= \\Closure::bind(\n            static function (CacheItem $item) {\n                $item->newMetadata = $item->metadata;\n\n                return $item->pack();\n            },\n            null,\n            CacheItem::class\n        );\n    }\n\n    public function get($key, $default = null): mixed\n    {\n        try {\n            $item = $this->pool->getItem($key);\n        } catch (SimpleCacheException $e) {\n            throw $e;\n        } catch (Psr6CacheException $e) {\n            throw new InvalidArgumentException($e->getMessage(), $e->getCode(), $e);\n        }\n        if (null === $this->cacheItemPrototype) {\n            $this->cacheItemPrototype = clone $item;\n            $this->cacheItemPrototype->set(null);\n        }\n\n        return $item->isHit() ? $item->get() : $default;\n    }\n\n    public function set($key, $value, $ttl = null): bool\n    {\n        try {\n            if (null !== $f = $this->createCacheItem) {\n                $item = $f($key, $value);\n            } else {\n                $item = $this->pool->getItem($key)->set($value);\n            }\n        } catch (SimpleCacheException $e) {\n            throw $e;\n        } catch (Psr6CacheException $e) {\n            throw new InvalidArgumentException($e->getMessage(), $e->getCode(), $e);\n        }\n        if (null !== $ttl) {\n            $item->expiresAfter($ttl);\n        }\n\n        return $this->pool->save($item);\n    }\n\n    public function delete($key): bool\n    {\n        try {\n            return $this->pool->deleteItem($key);\n        } catch (SimpleCacheException $e) {\n            throw $e;\n        } catch (Psr6CacheException $e) {\n            throw new InvalidArgumentException($e->getMessage(), $e->getCode(), $e);\n        }\n    }\n\n    public function clear(): bool\n    {\n        return $this->pool->clear();\n    }\n\n    public function getMultiple($keys, $default = null): iterable\n    {\n        if ($keys instanceof \\Traversable) {\n            $keys = iterator_to_array($keys, false);\n        } elseif (!\\is_array($keys)) {\n            throw new InvalidArgumentException(\\sprintf('Cache keys must be array or Traversable, \"%s\" given.', get_debug_type($keys)));\n        }\n\n        try {\n            $items = $this->pool->getItems($keys);\n        } catch (SimpleCacheException $e) {\n            throw $e;\n        } catch (Psr6CacheException $e) {\n            throw new InvalidArgumentException($e->getMessage(), $e->getCode(), $e);\n        }\n        $values = [];\n\n        if (!$this->pool instanceof AdapterInterface) {\n            foreach ($items as $key => $item) {\n                $values[$key] = $item->isHit() ? $item->get() : $default;\n            }\n\n            return $values;\n        }\n\n        foreach ($items as $key => $item) {\n            $values[$key] = $item->isHit() ? (self::$packCacheItem)($item) : $default;\n        }\n\n        return $values;\n    }\n\n    public function setMultiple($values, $ttl = null): bool\n    {\n        $valuesIsArray = \\is_array($values);\n        if (!$valuesIsArray && !$values instanceof \\Traversable) {\n            throw new InvalidArgumentException(\\sprintf('Cache values must be array or Traversable, \"%s\" given.', get_debug_type($values)));\n        }\n        $items = [];\n\n        try {\n            if (null !== $f = $this->createCacheItem) {\n                $valuesIsArray = false;\n                foreach ($values as $key => $value) {\n                    $items[$key] = $f($key, $value, true);\n                }\n            } elseif ($valuesIsArray) {\n                $items = [];\n                foreach ($values as $key => $value) {\n                    $items[] = (string) $key;\n                }\n                $items = $this->pool->getItems($items);\n            } else {\n                foreach ($values as $key => $value) {\n                    if (\\is_int($key)) {\n                        $key = (string) $key;\n                    }\n                    $items[$key] = $this->pool->getItem($key)->set($value);\n                }\n            }\n        } catch (SimpleCacheException $e) {\n            throw $e;\n        } catch (Psr6CacheException $e) {\n            throw new InvalidArgumentException($e->getMessage(), $e->getCode(), $e);\n        }\n        $ok = true;\n\n        foreach ($items as $key => $item) {\n            if ($valuesIsArray) {\n                $item->set($values[$key]);\n            }\n            if (null !== $ttl) {\n                $item->expiresAfter($ttl);\n            }\n            $ok = $this->pool->saveDeferred($item) && $ok;\n        }\n\n        return $this->pool->commit() && $ok;\n    }\n\n    public function deleteMultiple($keys): bool\n    {\n        if ($keys instanceof \\Traversable) {\n            $keys = iterator_to_array($keys, false);\n        } elseif (!\\is_array($keys)) {\n            throw new InvalidArgumentException(\\sprintf('Cache keys must be array or Traversable, \"%s\" given.', get_debug_type($keys)));\n        }\n\n        try {\n            return $this->pool->deleteItems($keys);\n        } catch (SimpleCacheException $e) {\n            throw $e;\n        } catch (Psr6CacheException $e) {\n            throw new InvalidArgumentException($e->getMessage(), $e->getCode(), $e);\n        }\n    }\n\n    public function has($key): bool\n    {\n        try {\n            return $this->pool->hasItem($key);\n        } catch (SimpleCacheException $e) {\n            throw $e;\n        } catch (Psr6CacheException $e) {\n            throw new InvalidArgumentException($e->getMessage(), $e->getCode(), $e);\n        }\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.919921875,
          "content": "Symfony PSR-6 implementation for caching\n========================================\n\nThe Cache component provides extended\n[PSR-6](https://www.php-fig.org/psr/psr-6/) implementations for adding cache to\nyour applications. It is designed to have a low overhead so that caching is\nfastest. It ships with adapters for the most widespread caching backends.\nIt also provides a [PSR-16](https://www.php-fig.org/psr/psr-16/) adapter,\nand implementations for [symfony/cache-contracts](https://github.com/symfony/cache-contracts)'\n`CacheInterface` and `TagAwareCacheInterface`.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/cache.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "ResettableInterface.php",
          "type": "blob",
          "size": 0.408203125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Cache;\n\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * Resets a pool's local state.\n */\ninterface ResettableInterface extends ResetInterface\n{\n}\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "Traits",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.8505859375,
          "content": "{\n    \"name\": \"symfony/cache\",\n    \"type\": \"library\",\n    \"description\": \"Provides extended PSR-6, PSR-16 (and tags) implementations\",\n    \"keywords\": [\"caching\", \"psr6\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Nicolas Grekas\",\n            \"email\": \"p@tchwork.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"provide\": {\n        \"psr/cache-implementation\": \"2.0|3.0\",\n        \"psr/simple-cache-implementation\": \"1.0|2.0|3.0\",\n        \"symfony/cache-implementation\": \"1.1|2.0|3.0\"\n    },\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"psr/cache\": \"^2.0|^3.0\",\n        \"psr/log\": \"^1.1|^2|^3\",\n        \"symfony/cache-contracts\": \"^2.5|^3\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3.0\",\n        \"symfony/service-contracts\": \"^2.5|^3\",\n        \"symfony/var-exporter\": \"^6.4|^7.0\"\n    },\n    \"require-dev\": {\n        \"cache/integration-tests\": \"dev-master\",\n        \"doctrine/dbal\": \"^3.6|^4\",\n        \"predis/predis\": \"^1.1|^2.0\",\n        \"psr/simple-cache\": \"^1.0|^2.0|^3.0\",\n        \"symfony/clock\": \"^6.4|^7.0\",\n        \"symfony/config\": \"^6.4|^7.0\",\n        \"symfony/dependency-injection\": \"^6.4|^7.0\",\n        \"symfony/filesystem\": \"^6.4|^7.0\",\n        \"symfony/http-kernel\": \"^6.4|^7.0\",\n        \"symfony/messenger\": \"^6.4|^7.0\",\n        \"symfony/var-dumper\": \"^6.4|^7.0\"\n    },\n    \"conflict\": {\n        \"doctrine/dbal\": \"<3.6\",\n        \"symfony/dependency-injection\": \"<6.4\",\n        \"symfony/http-kernel\": \"<6.4\",\n        \"symfony/var-dumper\": \"<6.4\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Cache\\\\\": \"\" },\n        \"classmap\": [\n            \"Traits/ValueWrapper.php\"\n        ],\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 2.0068359375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n        <env name=\"REDIS_HOST\" value=\"localhost\" />\n        <env name=\"REDIS_SOCKET\" value=\"/var/run/redis/redis-server.sock\" />\n        <env name=\"MEMCACHED_HOST\" value=\"localhost\" />\n        <env name=\"COUCHBASE_HOST\" value=\"localhost\" />\n        <env name=\"COUCHBASE_USER\" value=\"Administrator\" />\n        <env name=\"COUCHBASE_PASS\" value=\"111111@\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Cache Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n\n    <listeners>\n        <listener class=\"Symfony\\Bridge\\PhpUnit\\SymfonyTestsListener\">\n            <arguments>\n                <array>\n                    <element key=\"time-sensitive\">\n                        <array>\n                            <element key=\"0\"><string>Cache\\IntegrationTests</string></element>\n                            <element key=\"1\"><string>Symfony\\Component\\Cache</string></element>\n                            <element key=\"2\"><string>Symfony\\Component\\Cache\\Tests\\Fixtures</string></element>\n                            <element key=\"3\"><string>Symfony\\Component\\Cache\\Tests\\Traits</string></element>\n                            <element key=\"4\"><string>Symfony\\Component\\Cache\\Traits</string></element>\n                        </array>\n                    </element>\n                </array>\n            </arguments>\n        </listener>\n    </listeners>\n</phpunit>\n"
        }
      ]
    }
  ]
}