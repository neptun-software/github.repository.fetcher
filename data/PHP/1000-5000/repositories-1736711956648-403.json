{
  "metadata": {
    "timestamp": 1736711956648,
    "page": 403,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "etrepat/baum",
      "stars": 2242,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.2412109375,
          "content": "* text=auto\n\n/tests export-ignore\n/.gitattributes export-ignore\n/.gitignore export-ignore\n/.travis.yml export-ignore\n/phpunit.xml export-ignore\n/CHANGELOG.md export-ignore\n/README.md export-ignore\n/boris export-ignore\n/bootstrap.php export-ignore\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.021484375,
          "content": "/vendor\ncomposer.lock\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.216796875,
          "content": "language: php\n\nphp:\n  - 5.4\n  - 5.5\n  - 5.6\n  - hhvm\n\nbefore_script:\n  - travis_retry composer self-update\n  - travis_retry composer install --no-interaction --prefer-source --dev\n\nscript:\n  - vendor/bin/phpunit --verbose\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 5.40625,
          "content": "## 1.1.1\n_Mar 4 2015_\n* bug fixes\n  - Fix README.md typos [PR #134 and #131]\n  - Use table prefixes in `rebuild` command [PR #133]\n  - Fix `limitDepth` query scope [PR #125]\n\n## 1.1.0\n_Mar 3 2015_\n* enhancements\n  - Add support for Laravel 5.x, leave a [1.0.x](https://github.com/etrepat/baum/tree/1.0.x-stable) branch for backwards compatibility.\n\n## 1.0.13\n_Sep 30 2014_\n* bug fixes\n  - Fix node depth recomputation when moving nodes. Closes [#109] & [#106].\n  - Laravel 5, composer compatibility.\n\n## 1.0.12\n_Aug 25 2014_\n* bug fixes\n  - Fix check for `Node->storeNewParent()` to avoid moving a node which was already root. Fixes [#79] and closes [#81].\n  - Several git fixes by @GrahamCampbell [PR #96].\n  - `.travis.yml` improvements by @GrahamCampbell [PR #95].\n  - Rename `isValid` static method to `isValidNestedSet` to avoid name clashes with validator packages. Closes [#89].\n  - Moving to root has been now reimplemented to be more consistent.\n\n* enhancements\n  - Add pessimistic locking into the library. Closes [#89].\n  - Add `trunks` family of methods: `allTrunks`, `trunks`, `getTrunks` and `isTrunk`. Closes [#59].\n  - Add a `force` option to the `rebuild` static method.\n\n## 1.0.11\n_Jul 3 2014_\n* bug fixes\n  - Target Laravel stable version in `composer.json` file. Merges [#67].\n  - Use qualified order column name on `newNestedSetQuery` method. Merges [#70].\n  - Cleaned up migration stub. Merges [#84].\n  - Enforce sorting for `$orderColumn` when calling `toHierarchy`. Merges [#73], fixing [#71].\n\n* enhancements\n  - [#77] Add `makeFirstChildOf` and `makeLastChildOf` helper methods.\n  - [#62] Implement `limitDepth` query scope to allow query depth limiting for huge descendancy chains. Also allow to pass the depth limit as the first parameter of `getDescendants` and `getDescendantsAndSelf`.\n  - [#67] Should work with Laravel 4.2\n  - [#68] Implement `buildTree`, `makeTree` mass-assignment (seeding) methods.\n\n## 1.0.10\n_May 2 2014_\n* bug fixes\n  - Fix inserting a new model with a defined scope. Fixes [#27].\n  - Static methods now do not take into account scoped column values, which\n  would not make sense.\n  - Properly set a model's relations when reloading an instance via `reload()`.\n  - Fix `getObservableEvents()` function to include node's `moving` and `moved`\n  events.\n  - Fix `reload()` to consider trashed node objects via soft-delete operations.\n  Fixes [#35].\n  - Preliminar support for soft-delete operations. Should fix [#23].\n  - Assigning `null` to the `parent_id` column value and saving the node now\n  performs the same operation as `makeRoot()`. Fixes [#54].\n  - Reimplement `toHierarchy` as yielded inconsistent results, even worse with custom sorting of the collection results. Merges [#61], fixes [#63].\n\n* enhancements\n  - Implement tree *structure validation* via `Node::isValid`.\n  - Implement tree *index rebuilding* via `Node::rebuild`. Very useful when a tree\n  structure has been messed up or to convert from a `parent_id` only table.\n  - Preliminar support for soft-delete operations.\n  - Allow the user to change the default sorting column name (defaulting to `lft`).\n  - Add support for non-numeric keys. Merges & fixes [#52].\n\n\n## 1.0.9\n_Jan 14 2014_\n\n* bug fixes\n  - [#26] Prevent impossible moves to the left or right. Now moving a node too\n  further to the left or right raises a `MoveNotPossibleException`. Thanks to\n  @ziadoz for spotting this issue and providing a patch.\n\n* enhancenments\n  - [#5] Implement `toHierarchy` method which returns a nested collection\n  representing the queried tree. Great thanks go to @Surt for his patch on this.\n  - Add a static `all` method which works as the regular `Eloquent\\Model::all`\n  method but sorts for the `lft` column.\n\n## 1.0.8\n_Oct 11 2013_\n\n* bug fixes\n  - Properly wrap column names when used inside raw queries.\n  - Correct examples from README.\n\n## 1.0.6\n_July 31 2013_\n\n* enhancements\n  - Implement `withoutNode`, `withoutRoot`, `withoutSelf` query scopes.\n  - [#15] Add `Node::getNestedList` static method thanks to @gerp.\n\n## 1.0.5\n_July 22 2013_\n\n* enhancements\n  - Implement simple means to implement \"scopes\" for a Nested Set tree, allowing\n  for multiple trees in the same database table.\n\n## 1.0.4\n_July 18 2013_\n\n* bug fixes\n  - Full support for PHP >= 5.3.7. Baum should work if Eloquent works.\n\n## 1.0.3\n_July 5th 2013_\n\n* enhanments\n  - Add support for PHP 5.3 to make Baum match the requirements of Eloquent.\n  - Improve Postgres friendliness\n\n* bug fixes\n  - `insideSubtree` was inside incorrectly to guard against impossible moves. Fixed.\n  - Due to default ordering by `lft` column, Postgres complained when using\n  aggregate methods on queries which had SORT BY clauses. Now those are pruned\n  before running aggregates.\n\n\n## 1.0.2\n_July 3rd 2013_\n\n* enhancements\n  - Add `immediateDescendants`, 'getImmediateDescendants' methods.\n  - Implement a test suite.\n\n* bug fixes\n  - [#8] Add `lft` logic ordering by default to every scope method. Thanks to\n  @dirkpostma for spotting this out.\n  - [#9], [#10] Fix an SQL generation bug when moving root nodes between them.\n  Thanks to @daxborges for providing the fix.\n  - Fix `getLeftSibling` method which was not behaving properly because of\n  the previosly stated bugs.\n\n## 1.0.1\n_May 7th 2013_\n\n* enhancements\n  - Add indexes to `parent_id`, `lft`, `rgt` columns by default on generated\n  migration.\n\n* bug fix\n  - [#1] Fix a bug which caused model events not to fire on subclassed instances\n  of `Baum\\Node`.\n\n\n## 1.0.0\n_May 4th 2013_\n\n* First release.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.6376953125,
          "content": "# Contributing to Baum\n\nThinking of contributing? Maybe you've found some nasty bug? That's great news!\n\n## Reporting a Bug\n\n1. Update to the most recent *master release* if possible. The bug you're experiencing may have already been fixed.\n2. Search for similar issues. It's possible somebody has encountered the same bug already.\n3. If you keep experiencing the issue and cannot find a similar bug report: Open a new issue and report the bug as explicitly as you can.\n4. If possible, try to add a link to a gist with some failing code and/or stack traces or submit a Pull Request with a failing test. Better yet, take\na stab at fixing the bug yourself if you can!\n\nThe more information you provide, the easier it is to validate that there is a bug and the faster it is for me or anyone to provide a fix.\n\n## Requesting a Feature\n\n1. Search [Issues](https://github.com/etrepat/baum/issues) for similar feature requests. It's possible somebody has already asked for this feature or provided a pull request that's still in discussion.\n2. Provide a clear and detailed explanation of the feature you want and why it's important to add.\n3. If the feature is complex, consider writing some initial documentation for it. This will help everyone understand its use cases and if it is finally implemented it will serve as the base for its documentation.\n4. Attempt a Pull Request. If you're at all able, start writing some code. Please understand that this is an open source side-project, so the time devoted to it is quite limited. If you can write some code then that will speed the process greatly.\n\n## Pull Requests\n\n1. Fork & clone the project: `git clone git@github.com:your-username/baum.git`.\n2. Run the tests and make sure that they pass with your setup: `phpunit`.\n3. Create your bugfix/feature branch and code away your changes. Add tests for your changes. If you're adding functionality or fixing a bug, tests make it easier for the merge to be possible. Also, they make sure I don't break your changes incidentally.\n4. Make sure all the tests still pass: `phpunit`.\n5. Commit your changes. If your pull request fixes an specific issue make sure you say so in the commit message. For example: `git commit -m \"Fix auto-imploding nasty bug. Fixes #90.\"`.\n6. Push to your fork and submit a pull request. Please provide some\nexplanation of why you made the changes you made. For new features make sure to\nexplain a standard use case.\n\nAt this point you're waiting on me to respond. I'd like to say I'd get back to you immediately but understand that it may not be possible for me to do that. Please, be patient. I may suggest some changes or improvements or even complete alternative implementations.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05859375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Estanislau Trepat\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 25.78125,
          "content": "# Baum\n\n[![Build Status](https://travis-ci.org/etrepat/baum.png?branch=master)](https://travis-ci.org/etrepat/baum)\n\nBaum is an implementation of the [Nested Set](http://en.wikipedia.org/wiki/Nested_set_model) pattern for [Laravel 5's](http://laravel.com/) Eloquent ORM.\n\n> For **Laravel 4.2.x compatibility**, check the [1.0.x branch](https://github.com/etrepat/baum/tree/1.0.x-stable) branch or use the latest [1.0.x tagged release](https://github.com/etrepat/baum/releases).\n\n## Documentation\n\n* [About Nested Sets](#about)\n* [The theory behind, a TL;DR version](#theory)\n* [Installation](#installation)\n* [Getting started](#getting-started)\n* [Usage](#usage)\n* [Further information](#further-information)\n* [Contributing](#contributing)\n\n<a name=\"about\"></a>\n## About Nested Sets\n\nA nested set is a smart way to implement an _ordered_ tree that allows for fast,\nnon-recursive queries. For example, you can fetch all descendants of a node in a\nsingle query, no matter how deep the tree. The drawback is that insertions/moves/deletes\nrequire complex SQL, but that is handled behind the curtains by this package!\n\nNested sets are appropriate for ordered trees (e.g. menus, commercial categories)\nand big trees that must be queried efficiently (e.g. threaded posts).\n\nSee the [wikipedia entry for nested sets](http://en.wikipedia.org/wiki/Nested_set_model)\nfor more info. Also, this is a good introductory tutorial:\n[http://www.evanpetersen.com/item/nested-sets.html](http://www.evanpetersen.com/item/nested-sets.html)\n\n<a name=\"theory\"></a>\n## The theory behind, a TL;DR version\n\nAn easy way to visualize how a nested set works is to think of a parent entity surrounding all\nof its children, and its parent surrounding it, etc. So this tree:\n\n    root\n      |_ Child 1\n        |_ Child 1.1\n        |_ Child 1.2\n      |_ Child 2\n        |_ Child 2.1\n        |_ Child 2.2\n\n\nCould be visualized like this:\n\n     ___________________________________________________________________\n    |  Root                                                             |\n    |    ____________________________    ____________________________   |\n    |   |  Child 1                  |   |  Child 2                  |   |\n    |   |   __________   _________  |   |   __________   _________  |   |\n    |   |  |  C 1.1  |  |  C 1.2 |  |   |  |  C 2.1  |  |  C 2.2 |  |   |\n    1   2  3_________4  5________6  7   8  9_________10 11_______12 13  14\n    |   |___________________________|   |___________________________|   |\n    |___________________________________________________________________|\n\nThe numbers represent the left and right boundaries.  The table then might\nlook like this:\n\n    id | parent_id | lft  | rgt  | depth | data\n     1 |           |    1 |   14 |     0 | root\n     2 |         1 |    2 |    7 |     1 | Child 1\n     3 |         2 |    3 |    4 |     2 | Child 1.1\n     4 |         2 |    5 |    6 |     2 | Child 1.2\n     5 |         1 |    8 |   13 |     1 | Child 2\n     6 |         5 |    9 |   10 |     2 | Child 2.1\n     7 |         5 |   11 |   12 |     2 | Child 2.2\n\nTo get all children of a _parent_ node, you\n\n```sql\nSELECT * WHERE lft IS BETWEEN parent.lft AND parent.rgt\n```\n\nTo get the number of children, it's\n\n```sql\n(right - left - 1)/2\n```\n\nTo get a node and all its ancestors going back to the root, you\n\n```sql\nSELECT * WHERE node.lft IS BETWEEN lft AND rgt\n```\n\nAs you can see, queries that would be recursive and prohibitively slow on\nordinary trees are suddenly quite fast. Nifty, isn't it?\n\n<a name=\"installation\"></a>\n## Installation\n\nBaum works with Laravel 5 onwards. You can add it to your `composer.json` file\nwith:\n\n    \"baum/baum\": \"~1.1\"\n\nRun `composer install` to install it.\n\nAs with most Laravel 5 packages you'll then need to register the Baum\n*service provider*. To do that, head over your `config/app.php` file and add\nthe following line into the `providers` array:\n\n    'Baum\\Providers\\BaumServiceProvider',\n\n<a name=\"getting-started\"></a>\n## Getting started\n\nAfter the package is correctly installed the easiest way to get started is to\nrun the provided generator:\n\n    php artisan baum:install MODEL\n\nReplace model by the class name you plan to use for your Nested Set model.\n\nThe generator will install a migration and a model file into your application\nconfigured to work with the Nested Set behaviour provided by Baum. You SHOULD\ntake a look at those files, as each of them describes how they can be customized.\n\nNext, you would probably run `artisan migrate` to apply the migration.\n\n### Model configuration\n\nIn order to work with Baum, you must ensure that your model class extends\n`Baum\\Node`.\n\nThis is the easiest it can get:\n\n```php\nclass Category extends Baum\\Node {\n\n}\n```\n\nThis is a *slightly* more complex example where we have the column names customized:\n\n```php\nclass Dictionary extends Baum\\Node {\n\n  protected $table = 'dictionary';\n\n  // 'parent_id' column name\n  protected $parentColumn = 'parent_id';\n\n  // 'lft' column name\n  protected $leftColumn = 'lidx';\n\n  // 'rgt' column name\n  protected $rightColumn = 'ridx';\n\n  // 'depth' column name\n  protected $depthColumn = 'nesting';\n\n  // guard attributes from mass-assignment\n  protected $guarded = array('id', 'parent_id', 'lidx', 'ridx', 'nesting');\n\n}\n```\n\nRemember that, obviously, the column names must match those in the database table.\n\n### Migration configuration\n\nYou must ensure that the database table that supports your Baum models has the\nfollowing columns:\n\n* `parent_id`: a reference to the parent (int)\n* `lft`: left index bound (int)\n* `rgt`: right index bound (int)\n* `depth`: depth or nesting level (int)\n\nHere is a sample migration file:\n\n```php\nclass Category extends Migration {\n\n  public function up() {\n    Schema::create('categories', function(Blueprint $table) {\n      $table->increments('id');\n\n      $table->integer('parent_id')->nullable();\n      $table->integer('lft')->nullable();\n      $table->integer('rgt')->nullable();\n      $table->integer('depth')->nullable();\n\n      $table->string('name', 255);\n\n      $table->timestamps();\n    });\n  }\n\n  public function down() {\n    Schema::drop('categories');\n  }\n\n}\n```\n\nYou may freely modify the column names, provided you change them both in the\nmigration and the model.\n\n<a name=\"usage\"></a>\n## Usage\n\nAfter you've configured your model and run the migration, you are now ready\nto use Baum with your model. Below are some examples.\n\n* [Creating a root node](#creating-root-node)\n* [Inserting nodes](#inserting-nodes)\n* [Deleting nodes](#deleting-nodes)\n* [Getting the nesting level of a node](#node-level)\n* [Moving nodes around](#moving-nodes)\n* [Asking questions to your nodes](#node-questions)\n* [Relations](#node-relations)\n* [Root and Leaf scopes](#node-basic-scopes)\n* [Accessing the ancestry/descendancy chain](#node-chains)\n* [Limiting levels of children returned](#limiting-depth)\n* [Custom sorting column](#custom-sorting-column)\n* [Dumping the hierarchy tree](#hierarchy-tree)\n* [Model events: `moving` and `moved`](#node-model-events)\n* [Scope support](#scope-support)\n* [Validation](#validation)\n* [Tree rebuilding](#rebuilding)\n* [Soft deletes](#soft-deletes)\n* [Seeding/Mass assignment](#seeding)\n* [Misc/Utility functions](#misc-utilities)\n\n<a name=\"creating-root-node\"></a>\n### Creating a root node\n\nBy default, all nodes are created as roots:\n\n```php\n$root = Category::create(['name' => 'Root category']);\n```\n\nAlternatively, you may find yourself in the need of *converting* an existing node\ninto a *root node*:\n\n```php\n$node->makeRoot();\n```\n\nYou may also nullify it's `parent_id` column to accomplish the same behaviour:\n\n```php\n// This works the same as makeRoot()\n$node->parent_id = null;\n$node->save();\n```\n\n<a name=\"inserting-nodes\"></a>\n### Inserting nodes\n\n```php\n// Directly with a relation\n$child1 = $root->children()->create(['name' => 'Child 1']);\n\n// with the `makeChildOf` method\n$child2 = Category::create(['name' => 'Child 2']);\n$child2->makeChildOf($root);\n```\n\n<a name=\"deleting-nodes\"></a>\n### Deleting nodes\n\n```php\n$child1->delete();\n```\n\nDescendants of deleted nodes will also be deleted and all the `lft` and `rgt`\nbound will be recalculated. Pleases note that, for now, `deleting` and `deleted`\nmodel events for the descendants will not be fired.\n\n<a name=\"node-level\"></a>\n### Getting the nesting level of a node\n\nThe `getLevel()` method will return current nesting level, or depth, of a node.\n\n```php\n$node->getLevel() // 0 when root\n```\n\n<a name=\"moving-nodes\"></a>\n### Moving nodes around\n\nBaum provides several methods for moving nodes around:\n\n* `moveLeft()`: Find the left sibling and move to the left of it.\n* `moveRight()`: Find the right sibling and move to the right of it.\n* `moveToLeftOf($otherNode)`: Move to the node to the left of ...\n* `moveToRightOf($otherNode)`: Move to the node to the right of ...\n* `makeNextSiblingOf($otherNode)`: Alias for `moveToRightOf`.\n* `makeSiblingOf($otherNode)`: Alias for `makeNextSiblingOf`.\n* `makePreviousSiblingOf($otherNode)`: Alias for `moveToLeftOf`.\n* `makeChildOf($otherNode)`: Make the node a child of ...\n* `makeFirstChildOf($otherNode)`: Make the node the first child of ...\n* `makeLastChildOf($otherNode)`: Alias for `makeChildOf`.\n* `makeRoot()`: Make current node a root node.\n\nFor example:\n\n```php\n$root = Creatures::create(['name' => 'The Root of All Evil']);\n\n$dragons = Creatures::create(['name' => 'Here Be Dragons']);\n$dragons->makeChildOf($root);\n\n$monsters = new Creatures(['name' => 'Horrible Monsters']);\n$monsters->save();\n\n$monsters->makeSiblingOf($dragons);\n\n$demons = Creatures::where('name', '=', 'demons')->first();\n$demons->moveToLeftOf($dragons);\n```\n\n<a name=\"node-questions\"></a>\n### Asking questions to your nodes\n\nYou can ask some questions to your Baum nodes:\n\n* `isRoot()`: Returns true if this is a root node.\n* `isLeaf()`: Returns true if this is a leaf node (end of a branch).\n* `isChild()`: Returns true if this is a child node.\n* `isDescendantOf($other)`: Returns true if node is a descendant of the other.\n* `isSelfOrDescendantOf($other)`: Returns true if node is self or a descendant.\n* `isAncestorOf($other)`: Returns true if node is an ancestor of the other.\n* `isSelfOrAncestorOf($other)`: Returns true if node is self or an ancestor.\n* `equals($node)`: current node instance equals the other.\n* `insideSubtree($node)`: Checks whether the given node is inside the subtree\ndefined by the left and right indices.\n* `inSameScope($node)`: Returns true if the given node is in the same scope\nas the current one. That is, if *every* column in the `scoped` property has\nthe same value in both nodes.\n\nUsing the nodes from the previous example:\n\n```php\n$demons->isRoot(); // => false\n\n$demons->isDescendantOf($root) // => true\n```\n\n<a name=\"node-relations\"></a>\n### Relations\n\nBaum provides two self-referential Eloquent relations for your nodes: `parent`\nand `children`.\n\n```php\n$parent = $node->parent()->get();\n\n$children = $node->children()->get();\n```\n\n<a name=\"node-basic-scopes\"></a>\n### Root and Leaf scopes\n\nBaum provides some very basic query scopes for accessing the root and leaf nodes:\n\n```php\n// Query scope which targets all root nodes\nCategory::roots()\n\n// All leaf nodes (nodes at the end of a branch)\nCategory:allLeaves()\n```\n\nYou may also be interested in only the first root:\n\n```php\n$firstRootNode = Category::root();\n```\n\n<a name=\"node-chains\"></a>\n### Accessing the ancestry/descendancy chain\n\nThere are several methods which Baum offers to access the ancestry/descendancy\nchain of a node in the Nested Set tree. The main thing to keep in mind is that\nthey are provided in two ways:\n\nFirst as **query scopes**, returning an `Illuminate\\Database\\Eloquent\\Builder`\ninstance to continue to query further. To get *actual* results from these,\nremember to call `get()` or `first()`.\n\n* `ancestorsAndSelf()`: Targets all the ancestor chain nodes including the current one.\n* `ancestors()`: Query the ancestor chain nodes excluding the current one.\n* `siblingsAndSelf()`: Instance scope which targets all children of the parent, including self.\n* `siblings()`: Instance scope targeting all children of the parent, except self.\n* `leaves()`: Instance scope targeting all of its nested children which do not have children.\n* `descendantsAndSelf()`: Scope targeting itself and all of its nested children.\n* `descendants()`: Set of all children & nested children.\n* `immediateDescendants()`: Set of all children nodes (non-recursive).\n\nSecond, as **methods** which return actual `Baum\\Node` instances (inside a `Collection`\nobject where appropiate):\n\n* `getRoot()`: Returns the root node starting at the current node.\n* `getAncestorsAndSelf()`: Retrieve all of the ancestor chain including the current node.\n* `getAncestorsAndSelfWithoutRoot()`: All ancestors (including the current node) except the root node.\n* `getAncestors()`: Get all of the ancestor chain from the database excluding the current node.\n* `getAncestorsWithoutRoot()`: All ancestors except the current node and the root node.\n* `getSiblingsAndSelf()`: Get all children of the parent, including self.\n* `getSiblings()`: Return all children of the parent, except self.\n* `getLeaves()`: Return all of its nested children which do not have children.\n* `getDescendantsAndSelf()`: Retrieve all nested children and self.\n* `getDescendants()`: Retrieve all of its children & nested children.\n* `getImmediateDescendants()`: Retrieve all of its children nodes (non-recursive).\n\nHere's a simple example for iterating a node's descendants (provided a name\nattribute is available):\n\n```php\n$node = Category::where('name', '=', 'Books')->first();\n\nforeach($node->getDescendantsAndSelf() as $descendant) {\n  echo \"{$descendant->name}\";\n}\n```\n\n<a name=\"limiting-depth\"></a>\n### Limiting the levels of children returned\n\nIn some situations where the hierarchy depth is huge it might be desirable to limit the number of levels of children returned (depth). You can do this in Baum by using the `limitDepth` query scope.\n\nThe following snippet will get the current node's descendants up to a maximum\nof 5 depth levels below it:\n\n```php\n$node->descendants()->limitDepth(5)->get();\n```\n\nSimilarly, you can limit the descendancy levels with both the `getDescendants` and `getDescendantsAndSelf` methods by supplying the desired depth limit as the first argument:\n\n```php\n// This will work without depth limiting\n// 1. As usual\n$node->getDescendants();\n// 2. Selecting only some attributes\n$other->getDescendants(array('id', 'parent_id', 'name'));\n...\n// With depth limiting\n// 1. A maximum of 5 levels of children will be returned\n$node->getDescendants(5);\n// 2. A max. of 5 levels of children will be returned selecting only some attrs\n$other->getDescendants(5, array('id', 'parent_id', 'name'));\n```\n\n<a name=\"custom-sorting-column\"></a>\n### Custom sorting column\n\nBy default in Baum all results are returned sorted by the `lft` index column\nvalue for consistency.\n\nIf you wish to change this default behaviour you need to specify in your model\nthe name of the column you wish to use to sort your results like this:\n\n```php\nprotected $orderColumn = 'name';\n```\n\n<a name=\"hierarchy-tree\"></a>\n### Dumping the hierarchy tree\n\nBaum extends the default `Eloquent\\Collection` class and provides the\n`toHierarchy` method to it which returns a nested collection representing the\nqueried tree.\n\nRetrieving a complete tree hierarchy into a regular `Collection` object with\nits children *properly nested* is as simple as:\n\n```php\n$tree = Category::where('name', '=', 'Books')->first()->getDescendantsAndSelf()->toHierarchy();\n```\n\n<a name=\"node-model-events\"></a>\n### Model events: `moving` and `moved`\n\nBaum models fire the following events: `moving` and `moved` every time a node\nis *moved* around the Nested Set tree. This allows you to hook into those points\nin the node movement process. As with normal Eloquent model events, if `false`\nis returned from the `moving` event, the movement operation will be cancelled.\n\nThe recommended way to hook into those events is by using the model's boot\nmethod:\n\n```php\nclass Category extends Baum\\Node {\n\n  public static function boot() {\n    parent::boot();\n\n    static::moving(function($node) {\n      // Before moving the node this function will be called.\n    });\n\n    static::moved(function($node) {\n      // After the move operation is processed this function will be\n      // called.\n    });\n  }\n\n}\n```\n\n<a name=\"scope-support\"></a>\n### Scope support\n\nBaum provides a simple method to provide Nested Set \"scoping\" which restricts\nwhat we consider part of a nested set tree. This should allow for multiple nested\nset trees in the same database table.\n\nTo make use of the scoping funcionality you may override the `scoped` model\nattribute in your subclass. This attribute should contain an array of the column\nnames (database fields) which shall be used to restrict Nested Set queries:\n\n```php\nclass Category extends Baum\\Node {\n  ...\n  protected $scoped = array('company_id');\n  ...\n}\n```\n\nIn the previous example, `company_id` effectively restricts (or \"scopes\") a\nNested Set tree. So, for each value of that field we may be able to construct\na full different tree.\n\n```php\n$root1 = Category::create(['name' => 'R1', 'company_id' => 1]);\n$root2 = Category::create(['name' => 'R2', 'company_id' => 2]);\n\n$child1 = Category::create(['name' => 'C1', 'company_id' => 1]);\n$child2 = Category::create(['name' => 'C2', 'company_id' => 2]);\n\n$child1->makeChildOf($root1);\n$child2->makeChildOf($root2);\n\n$root1->children()->get(); // <- returns $child1\n$root2->children()->get(); // <- returns $child2\n```\n\nAll methods which ask or traverse the Nested Set tree will use the `scoped`\nattribute (if provided).\n\n**Please note** that, for now, moving nodes between scopes is not supported.\n\n<a name=\"validation\"></a>\n### Validation\n\nThe `::isValidNestedSet()` static method allows you to check if your underlying tree structure is correct. It mainly checks for these 3 things:\n\n* Check that the bound indexes `lft`, `rgt` are not null, `rgt` values greater\nthan `lft` and within the bounds of the parent node (if set).\n* That there are no duplicates for the `lft` and `rgt` column values.\n* As the first check does not actually check root nodes, see if each root has\nthe `lft` and `rgt` indexes within the bounds of its children.\n\nAll of the checks are *scope aware* and will check each scope separately if needed.\n\nExample usage, given a `Category` node class:\n\n```php\nCategory::isValidNestedSet()\n=> true\n```\n\n<a name=\"rebuilding\"></a>\n### Tree rebuilding\n\nBaum supports for complete tree-structure rebuilding (or reindexing) via the\n`::rebuild()` static method.\n\nThis method will re-index all your `lft`, `rgt` and `depth` column values,\ninspecting your tree only from the parent <-> children relation\nstandpoint. Which means that you only need a correctly filled `parent_id` column\nand Baum will try its best to recompute the rest.\n\nThis can prove quite useful when something has gone horribly wrong with the index\nvalues or it may come quite handy when *converting* from another implementation\n(which would probably have a `parent_id` column).\n\nThis operation is also *scope aware* and will rebuild all of the scopes\nseparately if they are defined.\n\nSimple example usage, given a `Category` node class:\n\n```php\nCategory::rebuild()\n```\n\nValid trees (per the `isValidNestedSet` method) will not get rebuilt. To force the index rebuilding process simply call the rebuild method with `true` as the first parameter:\n\n```php\nCategory::rebuild(true);\n```\n\n<a name=\"soft-deletes\"></a>\n### Soft deletes\n\nBaum comes with **limited support** for soft-delete operations. What I mean\nby *limited* is that the testing is still limited and the *soft delete*\nfunctionality is changing in the upcoming 4.2 version of the framework, so use\nthis feature wisely.\n\nFor now, you may consider a **safe** `restore()` operation to be one of:\n\n* Restoring a leaf node\n* Restoring a whole sub-tree in which the parent is not soft-deleted\n\n<a name=\"seeding\"></a>\n### Seeding/Mass-assignment\n\nBecause Nested Set structures usually involve a number of method calls to build a hierarchy structure (which result in several database queries), Baum provides two convenient methods which will map the supplied array of node attributes and create a hierarchy tree from them:\n\n* `buildTree($nodeList)`: (static method) Maps the supplied array of node attributes into the database.\n* `makeTree($nodeList)`: (instance method) Maps the supplied array of node attributes into the database using the current node instance as the parent for the provided subtree.\n\nBoth methods will *create* new nodes when the primary key is not supplied, *update* or *create* if it is, and *delete* all nodes which are not present in the *affecting scope*. Understand that the *affecting scope* for the `buildTree` static method is the whole nested set tree and for the `makeTree` instance method are all of the current node's descendants.\n\nFor example, imagine we wanted to map the following category hierarchy into our database:\n\n- TV & Home Theater\n- Tablets & E-Readers\n- Computers\n  + Laptops\n    * PC Laptops\n    * Macbooks (Air/Pro)\n  + Desktops\n  + Monitors\n- Cell Phones\n\nThis could be easily accomplished with the following code:\n\n```php\n$categories = [\n  ['id' => 1, 'name' => 'TV & Home Theather'],\n  ['id' => 2, 'name' => 'Tablets & E-Readers'],\n  ['id' => 3, 'name' => 'Computers', 'children' => [\n    ['id' => 4, 'name' => 'Laptops', 'children' => [\n      ['id' => 5, 'name' => 'PC Laptops'],\n      ['id' => 6, 'name' => 'Macbooks (Air/Pro)']\n    ]],\n    ['id' => 7, 'name' => 'Desktops'],\n    ['id' => 8, 'name' => 'Monitors']\n  ]],\n  ['id' => 9, 'name' => 'Cell Phones']\n];\n\nCategory::buildTree($categories) // => true\n```\n\nAfter that, we may just update the hierarchy as needed:\n\n```php\n$categories = [\n  ['id' => 1, 'name' => 'TV & Home Theather'],\n  ['id' => 2, 'name' => 'Tablets & E-Readers'],\n  ['id' => 3, 'name' => 'Computers', 'children' => [\n    ['id' => 4, 'name' => 'Laptops', 'children' => [\n      ['id' => 5, 'name' => 'PC Laptops'],\n      ['id' => 6, 'name' => 'Macbooks (Air/Pro)']\n    ]],\n    ['id' => 7, 'name' => 'Desktops', 'children' => [\n      // These will be created\n      ['name' => 'Towers Only'],\n      ['name' => 'Desktop Packages'],\n      ['name' => 'All-in-One Computers'],\n      ['name' => 'Gaming Desktops']\n    ]]\n    // This one, as it's not present, will be deleted\n    // ['id' => 8, 'name' => 'Monitors'],\n  ]],\n  ['id' => 9, 'name' => 'Cell Phones']\n];\n\nCategory::buildTree($categories); // => true\n```\n\nThe `makeTree` instance method works in a similar fashion. The only difference\nis that it will only perform operations on the *descendants* of the calling node instance.\n\nSo now imagine we already have the following hierarchy in the database:\n\n- Electronics\n- Health Fitness & Beaty\n- Small Appliances\n- Major Appliances\n\nIf we execute the following code:\n\n```php\n$children = [\n  ['name' => 'TV & Home Theather'],\n  ['name' => 'Tablets & E-Readers'],\n  ['name' => 'Computers', 'children' => [\n    ['name' => 'Laptops', 'children' => [\n      ['name' => 'PC Laptops'],\n      ['name' => 'Macbooks (Air/Pro)']\n    ]],\n    ['name' => 'Desktops'],\n    ['name' => 'Monitors']\n  ]],\n  ['name' => 'Cell Phones']\n];\n\n$electronics = Category::where('name', '=', 'Electronics')->first();\n$electronics->makeTree($children); // => true\n```\n\nWould result in:\n\n- Electronics\n  + TV & Home Theater\n  + Tablets & E-Readers\n  + Computers\n    * Laptops\n      - PC Laptops\n      - Macbooks (Air/Pro)\n    * Desktops\n    * Monitors\n  + Cell Phones\n- Health Fitness & Beaty\n- Small Appliances\n- Major Appliances\n\nUpdating and deleting nodes from the subtree works the same way.\n\n<a name=\"misc-utilities\"></a>\n### Misc/Utility functions\n\n#### Node extraction query scopes\n\nBaum provides some query scopes which may be used to extract (remove) selected nodes\nfrom the current results set.\n\n* `withoutNode(node)`: Extracts the specified node from the current results set.\n* `withoutSelf()`: Extracts itself from the current results set.\n* `withoutRoot()`: Extracts the current root node from the results set.\n\n```php\n$node = Category::where('name', '=', 'Some category I do not want to see.')->first();\n\n$root = Category::where('name', '=', 'Old boooks')->first();\nvar_dump($root->descendantsAndSelf()->withoutNode($node)->get());\n... // <- This result set will not contain $node\n```\n\n#### Get a nested list of column values\n\nThe `::getNestedList()` static method returns a key-value pair array indicating\na node's depth. Useful for silling `select` elements, etc.\n\nIt expects the column name to return, and optionally: the column\nto use for array keys (will use `id` if none supplied) and/or a separator:\n\n```php\npublic static function getNestedList($column, $key = null, $seperator = ' ');\n```\n\nAn example use case:\n\n```php\n$nestedList = Category::getNestedList('name');\n// $nestedList will contain an array like the following:\n// array(\n//   1 => 'Root 1',\n//   2 => ' Child 1',\n//   3 => ' Child 2',\n//   4 => '  Child 2.1',\n//   5 => ' Child 3',\n//   6 => 'Root 2'\n// );\n```\n\n<a name=\"further-information\"></a>\n## Further information\n\nYou may find additional information, usage examples and/or frequently\nasked questions about Baum in the [wiki](https://github.com/etrepat/baum/wiki).\n\nFeel free to browse the wiki after finishing this README:\n\n[https://github.com/etrepat/baum/wiki](https://github.com/etrepat/baum/wiki)\n\n<a name=\"contributing\"></a>\n## Contributing\n\nThinking of contributing? Maybe you've found some nasty bug? That's great news!\n\n1. Fork & clone the project: `git clone git@github.com:your-username/baum.git`.\n2. Run the tests and make sure that they pass with your setup: `phpunit`.\n3. Create your bugfix/feature branch and code away your changes. Add tests for your changes.\n4. Make sure all the tests still pass: `phpunit`.\n5. Push to your fork and submit new a pull request.\n\nPlease see the [CONTRIBUTING.md](https://github.com/etrepat/baum/blob/master/CONTRIBUTING.md) file for extended guidelines and/or recommendations.\n\n## License\n\nBaum is licensed under the terms of the [MIT License](http://opensource.org/licenses/MIT)\n(See LICENSE file for details).\n\n---\n\nCoded by [Estanislau Trepat (etrepat)](http://etrepat.com). I'm also\n[@etrepat](http://twitter.com/etrepat) on twitter.\n"
        },
        {
          "name": "bootstrap.php",
          "type": "blob",
          "size": 0.8447265625,
          "content": "<?php\n\n/**\n * Register composer auto  loader\n */\nrequire __DIR__.'/vendor/autoload.php';\n\n/**\n * Initialize Capsule\n */\n$capsule = new Illuminate\\Database\\Capsule\\Manager;\n\n$capsule->addConnection(require(__DIR__.'/tests/config/database.php'));\n\n$capsule->setEventDispatcher(new Illuminate\\Events\\Dispatcher(new Illuminate\\Container\\Container));\n\n$capsule->bootEloquent();\n\n$capsule->setAsGlobal();\n\n/**\n * Autoload required libraries\n */\n$__autoload_paths = array('models', 'migrators', 'seeders');\n\nforeach($__autoload_paths as $path) {\n  foreach(glob(__DIR__ . \"/tests/$path/*.php\") as $dep) {\n    require_once $dep;\n  }\n}\n\n/**\n * Require test helpers\n */\nrequire __DIR__ . '/tests/suite/support.php';\nrequire __DIR__ . '/tests/suite/BaumTestCase.php';\nrequire __DIR__ . '/tests/suite/CategoryTestCase.php';\nrequire __DIR__ . '/tests/suite/ClusterTestCase.php';\n"
        },
        {
          "name": "boris",
          "type": "blob",
          "size": 0.802734375,
          "content": "#!/usr/bin/env php\n<?php\n\nrequire __DIR__.'/bootstrap.php';\n\n// Prepare the DB\nwith(new CategoryMigrator)->up();\nwith(new ClusterMigrator)->up();\n\n// Seed the database with some data\n// ...\n\n// Set up a custom inspector for our models\nclass BaumNodeInspector extends \\Boris\\ColoredInspector {\n  public function objectVars($value) {\n    if ( $value instanceof Baum\\Node )\n      return array_merge($value->getAttributes(), get_object_vars($value));\n\n    return parent::objectVars($value);\n  }\n}\n\n// Start-up boris REPL and import any defined var (in scope) which happens to be\n// a Baum\\Node instance into the context\n$boris = new \\Boris\\Boris('> ');\n\n$boris->setInspector(new BaumNodeInspector);\n\n$boris->setLocal(array_filter(get_defined_vars(), function($var) {\n  return $var instanceof Baum\\Node; }));\n\n$boris->start();\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.7646484375,
          "content": "{\n  \"name\": \"baum/baum\",\n  \"type\": \"library\",\n  \"description\": \"Baum is an implementation of the Nested Set pattern for Eloquent models.\",\n  \"keywords\": [\"nested set\", \"laravel\", \"laravel 4\", \"laravel 5\", \"eloquent\", \"database\"],\n  \"license\": \"MIT\",\n  \"authors\": [\n    {\n      \"name\": \"Estanislau Trepat\",\n      \"email\": \"estanis@etrepat.com\",\n      \"homepage\": \"http://etrepat.com\"\n    }\n  ],\n  \"require\": {\n    \"php\": \">=5.4.0\",\n    \"illuminate/console\": \"5.*\",\n    \"illuminate/database\": \"5.*\",\n    \"illuminate/events\": \"5.*\",\n    \"illuminate/filesystem\": \"5.*\",\n    \"illuminate/support\": \"5.*\"\n  },\n  \"require-dev\": {\n    \"phpunit/phpunit\": \"~4.0\",\n    \"mockery/mockery\": \"~0.9\",\n    \"d11wtq/boris\": \"~1.0.10\"\n  },\n  \"autoload\": {\n    \"psr-0\": {\n      \"Baum\": \"src/\"\n    }\n  }\n}\n"
        },
        {
          "name": "phpunit.xml",
          "type": "blob",
          "size": 0.6923828125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit backupGlobals=\"false\"\n         backupStaticAttributes=\"false\"\n         bootstrap=\"bootstrap.php\"\n         colors=\"true\"\n         convertErrorsToExceptions=\"true\"\n         convertNoticesToExceptions=\"true\"\n         convertWarningsToExceptions=\"true\"\n         processIsolation=\"false\"\n         stopOnFailure=\"false\"\n         syntaxCheck=\"false\">\n  <testsuites>\n    <testsuite name=\"Baum Test Suite\">\n      <file>tests/suite/QueryBuilderExtensionTest.php</file>\n      <file>tests/suite/NodeModelExtensionsTest.php</file>\n      <directory>tests/suite/Category</directory>\n      <directory>tests/suite/Cluster</directory>\n    </testsuite>\n  </testsuites>\n</phpunit>\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}