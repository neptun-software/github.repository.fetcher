{
  "metadata": {
    "timestamp": 1736711810884,
    "page": 96,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/yaml",
      "stars": 3820,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 7.4384765625,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Deprecate parsing duplicate mapping keys whose value is `null`\n\n7.1\n---\n\n * Add support for getting all the enum cases with `!php/enum Foo`\n\n7.0\n---\n\n * Remove the `!php/const:` tag, use `!php/const` instead (without the colon)\n\n6.3\n---\n\n * Add support to dump int keys as strings by using the `Yaml::DUMP_NUMERIC_KEY_AS_STRING` flag\n\n6.2\n---\n\n * Add support for `!php/enum` and `!php/enum *->value`\n * Deprecate the `!php/const:` tag in key which will be replaced by the `!php/const` tag (without the colon) since 3.4\n\n6.1\n---\n\n * In cases where it will likely improve readability, strings containing single quotes will be double-quoted\n\n5.4\n---\n\n * Add new `lint:yaml dirname --exclude=/dirname/foo.yaml --exclude=/dirname/bar.yaml`\n   option to exclude one or more specific files from multiple file list\n * Allow negatable for the parse tags option with `--no-parse-tags`\n\n5.3\n---\n\n * Added `github` format support & autodetection to render errors as annotations\n   when running the YAML linter command in a Github Action environment.\n\n5.1.0\n-----\n\n * Added support for parsing numbers prefixed with `0o` as octal numbers.\n * Deprecated support for parsing numbers starting with `0` as octal numbers. They will be parsed as strings as of Symfony 6.0. Prefix numbers with `0o`\n   so that they are parsed as octal numbers.\n\n   Before:\n\n   ```yaml\n   Yaml::parse('072');\n   ```\n\n   After:\n\n   ```yaml\n   Yaml::parse('0o72');\n   ```\n\n * Added `yaml-lint` binary.\n * Deprecated using the `!php/object` and `!php/const` tags without a value.\n\n5.0.0\n-----\n\n * Removed support for mappings inside multi-line strings.\n * removed support for implicit STDIN usage in the `lint:yaml` command, use `lint:yaml -` (append a dash) instead to make it explicit.\n\n4.4.0\n-----\n\n * Added support for parsing the inline notation spanning multiple lines.\n * Added support to dump `null` as `~` by using the `Yaml::DUMP_NULL_AS_TILDE` flag.\n * deprecated accepting STDIN implicitly when using the `lint:yaml` command, use `lint:yaml -` (append a dash) instead to make it explicit.\n\n4.3.0\n-----\n\n * Using a mapping inside a multi-line string is deprecated and will throw a `ParseException` in 5.0.\n\n4.2.0\n-----\n\n * added support for multiple files or directories in `LintCommand`\n\n4.0.0\n-----\n\n * The behavior of the non-specific tag `!` is changed and now forces\n   non-evaluating your values.\n * complex mappings will throw a `ParseException`\n * support for the comma as a group separator for floats has been dropped, use\n   the underscore instead\n * support for the `!!php/object` tag has been dropped, use the `!php/object`\n   tag instead\n * duplicate mapping keys throw a `ParseException`\n * non-string mapping keys throw a `ParseException`, use the `Yaml::PARSE_KEYS_AS_STRINGS`\n   flag to cast them to strings\n * `%` at the beginning of an unquoted string throw a `ParseException`\n * mappings with a colon (`:`) that is not followed by a whitespace throw a\n   `ParseException`\n * the `Dumper::setIndentation()` method has been removed\n * being able to pass boolean options to the `Yaml::parse()`, `Yaml::dump()`,\n   `Parser::parse()`, and `Dumper::dump()` methods to configure the behavior of\n   the parser and dumper is no longer supported, pass bitmask flags instead\n * the constructor arguments of the `Parser` class have been removed\n * the `Inline` class is internal and no longer part of the BC promise\n * removed support for the `!str` tag, use the `!!str` tag instead\n * added support for tagged scalars.\n\n   ```yml\n   Yaml::parse('!foo bar', Yaml::PARSE_CUSTOM_TAGS);\n   // returns TaggedValue('foo', 'bar');\n   ```\n\n3.4.0\n-----\n\n * added support for parsing YAML files using the `Yaml::parseFile()` or `Parser::parseFile()` method\n\n * the `Dumper`, `Parser`, and `Yaml` classes are marked as final\n\n * Deprecated the `!php/object:` tag which will be replaced by the\n   `!php/object` tag (without the colon) in 4.0.\n\n * Deprecated the `!php/const:` tag which will be replaced by the\n   `!php/const` tag (without the colon) in 4.0.\n\n * Support for the `!str` tag is deprecated, use the `!!str` tag instead.\n\n * Deprecated using the non-specific tag `!` as its behavior will change in 4.0.\n   It will force non-evaluating your values in 4.0. Use plain integers or `!!float` instead.\n\n3.3.0\n-----\n\n * Starting an unquoted string with a question mark followed by a space is\n   deprecated and will throw a `ParseException` in Symfony 4.0.\n\n * Deprecated support for implicitly parsing non-string mapping keys as strings.\n   Mapping keys that are no strings will lead to a `ParseException` in Symfony\n   4.0. Use quotes to opt-in for keys to be parsed as strings.\n\n   Before:\n\n   ```php\n   $yaml = <<<YAML\n   null: null key\n   true: boolean true\n   2.0: float key\n   YAML;\n\n   Yaml::parse($yaml);\n   ```\n\n   After:\n\n   ```php\n\n   $yaml = <<<YAML\n   \"null\": null key\n   \"true\": boolean true\n   \"2.0\": float key\n   YAML;\n\n   Yaml::parse($yaml);\n   ```\n\n * Omitted mapping values will be parsed as `null`.\n\n * Omitting the key of a mapping is deprecated and will throw a `ParseException` in Symfony 4.0.\n\n * Added support for dumping empty PHP arrays as YAML sequences:\n\n   ```php\n   Yaml::dump([], 0, 0, Yaml::DUMP_EMPTY_ARRAY_AS_SEQUENCE);\n   ```\n\n3.2.0\n-----\n\n * Mappings with a colon (`:`) that is not followed by a whitespace are deprecated\n   when the mapping key is not quoted and will lead to a `ParseException` in\n   Symfony 4.0 (e.g. `foo:bar` must be `foo: bar`).\n\n * Added support for parsing PHP constants:\n\n   ```php\n   Yaml::parse('!php/const:PHP_INT_MAX', Yaml::PARSE_CONSTANT);\n   ```\n\n * Support for silently ignoring duplicate mapping keys in YAML has been\n   deprecated and will lead to a `ParseException` in Symfony 4.0.\n\n3.1.0\n-----\n\n * Added support to dump `stdClass` and `ArrayAccess` objects as YAML mappings\n   through the `Yaml::DUMP_OBJECT_AS_MAP` flag.\n\n * Strings that are not UTF-8 encoded will be dumped as base64 encoded binary\n   data.\n\n * Added support for dumping multi line strings as literal blocks.\n\n * Added support for parsing base64 encoded binary data when they are tagged\n   with the `!!binary` tag.\n\n * Added support for parsing timestamps as `\\DateTime` objects:\n\n   ```php\n   Yaml::parse('2001-12-15 21:59:43.10 -5', Yaml::PARSE_DATETIME);\n   ```\n\n * `\\DateTime` and `\\DateTimeImmutable` objects are dumped as YAML timestamps.\n\n * Deprecated usage of `%` at the beginning of an unquoted string.\n\n * Added support for customizing the YAML parser behavior through an optional bit field:\n\n   ```php\n   Yaml::parse('{ \"foo\": \"bar\", \"fiz\": \"cat\" }', Yaml::PARSE_EXCEPTION_ON_INVALID_TYPE | Yaml::PARSE_OBJECT | Yaml::PARSE_OBJECT_FOR_MAP);\n   ```\n\n * Added support for customizing the dumped YAML string through an optional bit field:\n\n   ```php\n   Yaml::dump(['foo' => new A(), 'bar' => 1], 0, 0, Yaml::DUMP_EXCEPTION_ON_INVALID_TYPE | Yaml::DUMP_OBJECT);\n   ```\n\n3.0.0\n-----\n\n * Yaml::parse() now throws an exception when a blackslash is not escaped\n   in double-quoted strings\n\n2.8.0\n-----\n\n * Deprecated usage of a colon in an unquoted mapping value\n * Deprecated usage of @, \\`, | and > at the beginning of an unquoted string\n * When surrounding strings with double-quotes, you must now escape `\\` characters. Not\n   escaping those characters (when surrounded by double-quotes) is deprecated.\n\n   Before:\n\n   ```yml\n   class: \"Foo\\Var\"\n   ```\n\n   After:\n\n   ```yml\n   class: \"Foo\\\\Var\"\n   ```\n\n2.1.0\n-----\n\n * Yaml::parse() does not evaluate loaded files as PHP files by default\n   anymore (call Yaml::enablePhpParsing() to get back the old behavior)\n"
        },
        {
          "name": "Command",
          "type": "tree",
          "content": null
        },
        {
          "name": "Dumper.php",
          "type": "blob",
          "size": 7.0703125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Yaml;\n\nuse Symfony\\Component\\Yaml\\Tag\\TaggedValue;\n\n/**\n * Dumper dumps PHP variables to YAML strings.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @final\n */\nclass Dumper\n{\n    /**\n     * @param int $indentation The amount of spaces to use for indentation of nested nodes\n     */\n    public function __construct(private int $indentation = 4)\n    {\n        if ($indentation < 1) {\n            throw new \\InvalidArgumentException('The indentation must be greater than zero.');\n        }\n    }\n\n    /**\n     * Dumps a PHP value to YAML.\n     *\n     * @param mixed                     $input  The PHP value\n     * @param int                       $inline The level where you switch to inline YAML\n     * @param int                       $indent The level of indentation (used internally)\n     * @param int-mask-of<Yaml::DUMP_*> $flags  A bit field of Yaml::DUMP_* constants to customize the dumped YAML string\n     */\n    public function dump(mixed $input, int $inline = 0, int $indent = 0, int $flags = 0): string\n    {\n        $output = '';\n        $prefix = $indent ? str_repeat(' ', $indent) : '';\n        $dumpObjectAsInlineMap = true;\n\n        if (Yaml::DUMP_OBJECT_AS_MAP & $flags && ($input instanceof \\ArrayObject || $input instanceof \\stdClass)) {\n            $dumpObjectAsInlineMap = !(array) $input;\n        }\n\n        if ($inline <= 0 || (!\\is_array($input) && !$input instanceof TaggedValue && $dumpObjectAsInlineMap) || !$input) {\n            $output .= $prefix.Inline::dump($input, $flags);\n        } elseif ($input instanceof TaggedValue) {\n            $output .= $this->dumpTaggedValue($input, $inline, $indent, $flags, $prefix);\n        } else {\n            $dumpAsMap = Inline::isHash($input);\n\n            foreach ($input as $key => $value) {\n                if ('' !== $output && \"\\n\" !== $output[-1]) {\n                    $output .= \"\\n\";\n                }\n\n                if (\\is_int($key) && Yaml::DUMP_NUMERIC_KEY_AS_STRING & $flags) {\n                    $key = (string) $key;\n                }\n\n                if (Yaml::DUMP_MULTI_LINE_LITERAL_BLOCK & $flags && \\is_string($value) && str_contains($value, \"\\n\") && !str_contains($value, \"\\r\")) {\n                    $blockIndentationIndicator = $this->getBlockIndentationIndicator($value);\n\n                    if (isset($value[-2]) && \"\\n\" === $value[-2] && \"\\n\" === $value[-1]) {\n                        $blockChompingIndicator = '+';\n                    } elseif (\"\\n\" === $value[-1]) {\n                        $blockChompingIndicator = '';\n                    } else {\n                        $blockChompingIndicator = '-';\n                    }\n\n                    $output .= \\sprintf('%s%s%s |%s%s', $prefix, $dumpAsMap ? Inline::dump($key, $flags).':' : '-', '', $blockIndentationIndicator, $blockChompingIndicator);\n\n                    foreach (explode(\"\\n\", $value) as $row) {\n                        if ('' === $row) {\n                            $output .= \"\\n\";\n                        } else {\n                            $output .= \\sprintf(\"\\n%s%s%s\", $prefix, str_repeat(' ', $this->indentation), $row);\n                        }\n                    }\n\n                    continue;\n                }\n\n                if ($value instanceof TaggedValue) {\n                    $output .= \\sprintf('%s%s !%s', $prefix, $dumpAsMap ? Inline::dump($key, $flags).':' : '-', $value->getTag());\n\n                    if (Yaml::DUMP_MULTI_LINE_LITERAL_BLOCK & $flags && \\is_string($value->getValue()) && str_contains($value->getValue(), \"\\n\") && !str_contains($value->getValue(), \"\\r\\n\")) {\n                        $blockIndentationIndicator = $this->getBlockIndentationIndicator($value->getValue());\n                        $output .= \\sprintf(' |%s', $blockIndentationIndicator);\n\n                        foreach (explode(\"\\n\", $value->getValue()) as $row) {\n                            $output .= \\sprintf(\"\\n%s%s%s\", $prefix, str_repeat(' ', $this->indentation), $row);\n                        }\n\n                        continue;\n                    }\n\n                    if ($inline - 1 <= 0 || null === $value->getValue() || \\is_scalar($value->getValue())) {\n                        $output .= ' '.$this->dump($value->getValue(), $inline - 1, 0, $flags).\"\\n\";\n                    } else {\n                        $output .= \"\\n\";\n                        $output .= $this->dump($value->getValue(), $inline - 1, $dumpAsMap ? $indent + $this->indentation : $indent + 2, $flags);\n                    }\n\n                    continue;\n                }\n\n                $dumpObjectAsInlineMap = true;\n\n                if (Yaml::DUMP_OBJECT_AS_MAP & $flags && ($value instanceof \\ArrayObject || $value instanceof \\stdClass)) {\n                    $dumpObjectAsInlineMap = !(array) $value;\n                }\n\n                $willBeInlined = $inline - 1 <= 0 || !\\is_array($value) && $dumpObjectAsInlineMap || !$value;\n\n                $output .= \\sprintf('%s%s%s%s',\n                    $prefix,\n                    $dumpAsMap ? Inline::dump($key, $flags).':' : '-',\n                    $willBeInlined ? ' ' : \"\\n\",\n                    $this->dump($value, $inline - 1, $willBeInlined ? 0 : $indent + $this->indentation, $flags)\n                ).($willBeInlined ? \"\\n\" : '');\n            }\n        }\n\n        return $output;\n    }\n\n    private function dumpTaggedValue(TaggedValue $value, int $inline, int $indent, int $flags, string $prefix): string\n    {\n        $output = \\sprintf('%s!%s', $prefix ? $prefix.' ' : '', $value->getTag());\n\n        if (Yaml::DUMP_MULTI_LINE_LITERAL_BLOCK & $flags && \\is_string($value->getValue()) && str_contains($value->getValue(), \"\\n\") && !str_contains($value->getValue(), \"\\r\\n\")) {\n            $blockIndentationIndicator = $this->getBlockIndentationIndicator($value->getValue());\n            $output .= \\sprintf(' |%s', $blockIndentationIndicator);\n\n            foreach (explode(\"\\n\", $value->getValue()) as $row) {\n                $output .= \\sprintf(\"\\n%s%s%s\", $prefix, str_repeat(' ', $this->indentation), $row);\n            }\n\n            return $output;\n        }\n\n        if ($inline - 1 <= 0 || null === $value->getValue() || \\is_scalar($value->getValue())) {\n            return $output.' '.$this->dump($value->getValue(), $inline - 1, 0, $flags).\"\\n\";\n        }\n\n        return $output.\"\\n\".$this->dump($value->getValue(), $inline - 1, $indent, $flags);\n    }\n\n    private function getBlockIndentationIndicator(string $value): string\n    {\n        $lines = explode(\"\\n\", $value);\n\n        // If the first line (that is neither empty nor contains only spaces)\n        // starts with a space character, the spec requires a block indentation indicator\n        // http://www.yaml.org/spec/1.2/spec.html#id2793979\n        foreach ($lines as $line) {\n            if ('' !== trim($line, ' ')) {\n                return str_starts_with($line, ' ') ? (string) $this->indentation : '';\n            }\n        }\n\n        return '';\n    }\n}\n"
        },
        {
          "name": "Escaper.php",
          "type": "blob",
          "size": 3.7197265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Yaml;\n\n/**\n * Escaper encapsulates escaping rules for single and double-quoted\n * YAML strings.\n *\n * @author Matthew Lewinski <matthew@lewinski.org>\n *\n * @internal\n */\nclass Escaper\n{\n    // Characters that would cause a dumped string to require double quoting.\n    public const REGEX_CHARACTER_TO_ESCAPE = \"[\\\\x00-\\\\x1f]|\\x7f|\\xc2\\x85|\\xc2\\xa0|\\xe2\\x80\\xa8|\\xe2\\x80\\xa9\";\n\n    // Mapping arrays for escaping a double quoted string. The backslash is\n    // first to ensure proper escaping because str_replace operates iteratively\n    // on the input arrays. This ordering of the characters avoids the use of strtr,\n    // which performs more slowly.\n    private const ESCAPEES = ['\\\\', '\\\\\\\\', '\\\\\"', '\"',\n                                     \"\\x00\",  \"\\x01\",  \"\\x02\",  \"\\x03\",  \"\\x04\",  \"\\x05\",  \"\\x06\",  \"\\x07\",\n                                     \"\\x08\",  \"\\x09\",  \"\\x0a\",  \"\\x0b\",  \"\\x0c\",  \"\\x0d\",  \"\\x0e\",  \"\\x0f\",\n                                     \"\\x10\",  \"\\x11\",  \"\\x12\",  \"\\x13\",  \"\\x14\",  \"\\x15\",  \"\\x16\",  \"\\x17\",\n                                     \"\\x18\",  \"\\x19\",  \"\\x1a\",  \"\\x1b\",  \"\\x1c\",  \"\\x1d\",  \"\\x1e\",  \"\\x1f\",\n                                     \"\\x7f\",\n                                     \"\\xc2\\x85\", \"\\xc2\\xa0\", \"\\xe2\\x80\\xa8\", \"\\xe2\\x80\\xa9\",\n                               ];\n    private const ESCAPED = ['\\\\\\\\', '\\\\\"', '\\\\\\\\', '\\\\\"',\n                                     '\\\\0',   '\\\\x01', '\\\\x02', '\\\\x03', '\\\\x04', '\\\\x05', '\\\\x06', '\\\\a',\n                                     '\\\\b',   '\\\\t',   '\\\\n',   '\\\\v',   '\\\\f',   '\\\\r',   '\\\\x0e', '\\\\x0f',\n                                     '\\\\x10', '\\\\x11', '\\\\x12', '\\\\x13', '\\\\x14', '\\\\x15', '\\\\x16', '\\\\x17',\n                                     '\\\\x18', '\\\\x19', '\\\\x1a', '\\\\e',   '\\\\x1c', '\\\\x1d', '\\\\x1e', '\\\\x1f',\n                                     '\\\\x7f',\n                                     '\\\\N', '\\\\_', '\\\\L', '\\\\P',\n                              ];\n\n    /**\n     * Determines if a PHP value would require double quoting in YAML.\n     *\n     * @param string $value A PHP value\n     */\n    public static function requiresDoubleQuoting(string $value): bool\n    {\n        return 0 < preg_match('/'.self::REGEX_CHARACTER_TO_ESCAPE.'/u', $value);\n    }\n\n    /**\n     * Escapes and surrounds a PHP value with double quotes.\n     *\n     * @param string $value A PHP value\n     */\n    public static function escapeWithDoubleQuotes(string $value): string\n    {\n        return \\sprintf('\"%s\"', str_replace(self::ESCAPEES, self::ESCAPED, $value));\n    }\n\n    /**\n     * Determines if a PHP value would require single quoting in YAML.\n     *\n     * @param string $value A PHP value\n     */\n    public static function requiresSingleQuoting(string $value): bool\n    {\n        // Determines if a PHP value is entirely composed of a value that would\n        // require single quoting in YAML.\n        if (\\in_array(strtolower($value), ['null', '~', 'true', 'false', 'y', 'n', 'yes', 'no', 'on', 'off'])) {\n            return true;\n        }\n\n        // Determines if the PHP value contains any single characters that would\n        // cause it to require single quoting in YAML.\n        return 0 < preg_match('/[\\s\\'\"\\:\\{\\}\\[\\],&\\*\\#\\?] | \\A[\\-?|<>=!%@`\\p{Zs}]/xu', $value);\n    }\n\n    /**\n     * Escapes and surrounds a PHP value with single quotes.\n     *\n     * @param string $value A PHP value\n     */\n    public static function escapeWithSingleQuotes(string $value): string\n    {\n        return \\sprintf(\"'%s'\", str_replace('\\'', '\\'\\'', $value));\n    }\n}\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Inline.php",
          "type": "blob",
          "size": 35.2880859375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Yaml;\n\nuse Symfony\\Component\\Yaml\\Exception\\DumpException;\nuse Symfony\\Component\\Yaml\\Exception\\ParseException;\nuse Symfony\\Component\\Yaml\\Tag\\TaggedValue;\n\n/**\n * Inline implements a YAML parser/dumper for the YAML inline syntax.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @internal\n */\nclass Inline\n{\n    public const REGEX_QUOTED_STRING = '(?:\"([^\"\\\\\\\\]*+(?:\\\\\\\\.[^\"\\\\\\\\]*+)*+)\"|\\'([^\\']*+(?:\\'\\'[^\\']*+)*+)\\')';\n\n    public static int $parsedLineNumber = -1;\n    public static ?string $parsedFilename = null;\n\n    private static bool $exceptionOnInvalidType = false;\n    private static bool $objectSupport = false;\n    private static bool $objectForMap = false;\n    private static bool $constantSupport = false;\n\n    public static function initialize(int $flags, ?int $parsedLineNumber = null, ?string $parsedFilename = null): void\n    {\n        self::$exceptionOnInvalidType = (bool) (Yaml::PARSE_EXCEPTION_ON_INVALID_TYPE & $flags);\n        self::$objectSupport = (bool) (Yaml::PARSE_OBJECT & $flags);\n        self::$objectForMap = (bool) (Yaml::PARSE_OBJECT_FOR_MAP & $flags);\n        self::$constantSupport = (bool) (Yaml::PARSE_CONSTANT & $flags);\n        self::$parsedFilename = $parsedFilename;\n\n        if (null !== $parsedLineNumber) {\n            self::$parsedLineNumber = $parsedLineNumber;\n        }\n    }\n\n    /**\n     * Converts a YAML string to a PHP value.\n     *\n     * @param int   $flags      A bit field of Yaml::PARSE_* constants to customize the YAML parser behavior\n     * @param array $references Mapping of variable names to values\n     *\n     * @throws ParseException\n     */\n    public static function parse(string $value, int $flags = 0, array &$references = []): mixed\n    {\n        self::initialize($flags);\n\n        $value = trim($value);\n\n        if ('' === $value) {\n            return '';\n        }\n\n        $i = 0;\n        $tag = self::parseTag($value, $i, $flags);\n        switch ($value[$i]) {\n            case '[':\n                $result = self::parseSequence($value, $flags, $i, $references);\n                ++$i;\n                break;\n            case '{':\n                $result = self::parseMapping($value, $flags, $i, $references);\n                ++$i;\n                break;\n            default:\n                $result = self::parseScalar($value, $flags, null, $i, true, $references);\n        }\n\n        // some comments are allowed at the end\n        if (preg_replace('/\\s*#.*$/A', '', substr($value, $i))) {\n            throw new ParseException(\\sprintf('Unexpected characters near \"%s\".', substr($value, $i)), self::$parsedLineNumber + 1, $value, self::$parsedFilename);\n        }\n\n        if (null !== $tag && '' !== $tag) {\n            return new TaggedValue($tag, $result);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Dumps a given PHP variable to a YAML string.\n     *\n     * @param mixed $value The PHP variable to convert\n     * @param int   $flags A bit field of Yaml::DUMP_* constants to customize the dumped YAML string\n     *\n     * @throws DumpException When trying to dump PHP resource\n     */\n    public static function dump(mixed $value, int $flags = 0): string\n    {\n        switch (true) {\n            case \\is_resource($value):\n                if (Yaml::DUMP_EXCEPTION_ON_INVALID_TYPE & $flags) {\n                    throw new DumpException(\\sprintf('Unable to dump PHP resources in a YAML file (\"%s\").', get_resource_type($value)));\n                }\n\n                return self::dumpNull($flags);\n            case $value instanceof \\DateTimeInterface:\n                return $value->format(match (true) {\n                    !$length = \\strlen(rtrim($value->format('u'), '0')) => 'c',\n                    $length < 4 => 'Y-m-d\\TH:i:s.vP',\n                    default => 'Y-m-d\\TH:i:s.uP',\n                });\n            case $value instanceof \\UnitEnum:\n                return \\sprintf('!php/enum %s::%s', $value::class, $value->name);\n            case \\is_object($value):\n                if ($value instanceof TaggedValue) {\n                    return '!'.$value->getTag().' '.self::dump($value->getValue(), $flags);\n                }\n\n                if (Yaml::DUMP_OBJECT & $flags) {\n                    return '!php/object '.self::dump(serialize($value));\n                }\n\n                if (Yaml::DUMP_OBJECT_AS_MAP & $flags && ($value instanceof \\stdClass || $value instanceof \\ArrayObject)) {\n                    return self::dumpHashArray($value, $flags);\n                }\n\n                if (Yaml::DUMP_EXCEPTION_ON_INVALID_TYPE & $flags) {\n                    throw new DumpException('Object support when dumping a YAML file has been disabled.');\n                }\n\n                return self::dumpNull($flags);\n            case \\is_array($value):\n                return self::dumpArray($value, $flags);\n            case null === $value:\n                return self::dumpNull($flags);\n            case true === $value:\n                return 'true';\n            case false === $value:\n                return 'false';\n            case \\is_int($value):\n                return $value;\n            case is_numeric($value) && false === strpbrk($value, \"\\f\\n\\r\\t\\v\"):\n                $locale = setlocale(\\LC_NUMERIC, 0);\n                if (false !== $locale) {\n                    setlocale(\\LC_NUMERIC, 'C');\n                }\n                if (\\is_float($value)) {\n                    $repr = (string) $value;\n                    if (is_infinite($value)) {\n                        $repr = str_ireplace('INF', '.Inf', $repr);\n                    } elseif (floor($value) == $value && $repr == $value) {\n                        // Preserve float data type since storing a whole number will result in integer value.\n                        if (!str_contains($repr, 'E')) {\n                            $repr .= '.0';\n                        }\n                    }\n                } else {\n                    $repr = \\is_string($value) ? \"'$value'\" : (string) $value;\n                }\n                if (false !== $locale) {\n                    setlocale(\\LC_NUMERIC, $locale);\n                }\n\n                return $repr;\n            case '' == $value:\n                return \"''\";\n            case self::isBinaryString($value):\n                return '!!binary '.base64_encode($value);\n            case Escaper::requiresDoubleQuoting($value):\n                return Escaper::escapeWithDoubleQuotes($value);\n            case Escaper::requiresSingleQuoting($value):\n                $singleQuoted = Escaper::escapeWithSingleQuotes($value);\n                if (!str_contains($value, \"'\")) {\n                    return $singleQuoted;\n                }\n                // Attempt double-quoting the string instead to see if it's more efficient.\n                $doubleQuoted = Escaper::escapeWithDoubleQuotes($value);\n\n                return \\strlen($doubleQuoted) < \\strlen($singleQuoted) ? $doubleQuoted : $singleQuoted;\n            case Parser::preg_match('{^[0-9]+[_0-9]*$}', $value):\n            case Parser::preg_match(self::getHexRegex(), $value):\n            case Parser::preg_match(self::getTimestampRegex(), $value):\n                return Escaper::escapeWithSingleQuotes($value);\n            default:\n                return $value;\n        }\n    }\n\n    /**\n     * Check if given array is hash or just normal indexed array.\n     */\n    public static function isHash(array|\\ArrayObject|\\stdClass $value): bool\n    {\n        if ($value instanceof \\stdClass || $value instanceof \\ArrayObject) {\n            return true;\n        }\n\n        $expectedKey = 0;\n\n        foreach ($value as $key => $val) {\n            if ($key !== $expectedKey++) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Dumps a PHP array to a YAML string.\n     *\n     * @param array $value The PHP array to dump\n     * @param int   $flags A bit field of Yaml::DUMP_* constants to customize the dumped YAML string\n     */\n    private static function dumpArray(array $value, int $flags): string\n    {\n        // array\n        if (($value || Yaml::DUMP_EMPTY_ARRAY_AS_SEQUENCE & $flags) && !self::isHash($value)) {\n            $output = [];\n            foreach ($value as $val) {\n                $output[] = self::dump($val, $flags);\n            }\n\n            return \\sprintf('[%s]', implode(', ', $output));\n        }\n\n        return self::dumpHashArray($value, $flags);\n    }\n\n    /**\n     * Dumps hash array to a YAML string.\n     *\n     * @param array|\\ArrayObject|\\stdClass $value The hash array to dump\n     * @param int                          $flags A bit field of Yaml::DUMP_* constants to customize the dumped YAML string\n     */\n    private static function dumpHashArray(array|\\ArrayObject|\\stdClass $value, int $flags): string\n    {\n        $output = [];\n        foreach ($value as $key => $val) {\n            if (\\is_int($key) && Yaml::DUMP_NUMERIC_KEY_AS_STRING & $flags) {\n                $key = (string) $key;\n            }\n\n            $output[] = \\sprintf('%s: %s', self::dump($key, $flags), self::dump($val, $flags));\n        }\n\n        return \\sprintf('{ %s }', implode(', ', $output));\n    }\n\n    private static function dumpNull(int $flags): string\n    {\n        if (Yaml::DUMP_NULL_AS_TILDE & $flags) {\n            return '~';\n        }\n\n        return 'null';\n    }\n\n    /**\n     * Parses a YAML scalar.\n     *\n     * @throws ParseException When malformed inline YAML string is parsed\n     */\n    public static function parseScalar(string $scalar, int $flags = 0, ?array $delimiters = null, int &$i = 0, bool $evaluate = true, array &$references = [], ?bool &$isQuoted = null): mixed\n    {\n        if (\\in_array($scalar[$i], ['\"', \"'\"], true)) {\n            // quoted scalar\n            $isQuoted = true;\n            $output = self::parseQuotedScalar($scalar, $i);\n\n            if (null !== $delimiters) {\n                $tmp = ltrim(substr($scalar, $i), \" \\n\");\n                if ('' === $tmp) {\n                    throw new ParseException(\\sprintf('Unexpected end of line, expected one of \"%s\".', implode('', $delimiters)), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                }\n                if (!\\in_array($tmp[0], $delimiters)) {\n                    throw new ParseException(\\sprintf('Unexpected characters (%s).', substr($scalar, $i)), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                }\n            }\n        } else {\n            // \"normal\" string\n            $isQuoted = false;\n\n            if (!$delimiters) {\n                $output = substr($scalar, $i);\n                $i += \\strlen($output);\n\n                // remove comments\n                if (Parser::preg_match('/[ \\t]+#/', $output, $match, \\PREG_OFFSET_CAPTURE)) {\n                    $output = substr($output, 0, $match[0][1]);\n                }\n            } elseif (Parser::preg_match('/^(.*?)('.implode('|', $delimiters).')/', substr($scalar, $i), $match)) {\n                $output = $match[1];\n                $i += \\strlen($output);\n                $output = trim($output);\n            } else {\n                throw new ParseException(\\sprintf('Malformed inline YAML string: \"%s\".', $scalar), self::$parsedLineNumber + 1, null, self::$parsedFilename);\n            }\n\n            // a non-quoted string cannot start with @ or ` (reserved) nor with a scalar indicator (| or >)\n            if ($output && ('@' === $output[0] || '`' === $output[0] || '|' === $output[0] || '>' === $output[0] || '%' === $output[0])) {\n                throw new ParseException(\\sprintf('The reserved indicator \"%s\" cannot start a plain scalar; you need to quote the scalar.', $output[0]), self::$parsedLineNumber + 1, $output, self::$parsedFilename);\n            }\n\n            if ($evaluate) {\n                $output = self::evaluateScalar($output, $flags, $references, $isQuoted);\n            }\n        }\n\n        return $output;\n    }\n\n    /**\n     * Parses a YAML quoted scalar.\n     *\n     * @throws ParseException When malformed inline YAML string is parsed\n     */\n    private static function parseQuotedScalar(string $scalar, int &$i = 0): string\n    {\n        if (!Parser::preg_match('/'.self::REGEX_QUOTED_STRING.'/Au', substr($scalar, $i), $match)) {\n            throw new ParseException(\\sprintf('Malformed inline YAML string: \"%s\".', substr($scalar, $i)), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n        }\n\n        $output = substr($match[0], 1, -1);\n\n        $unescaper = new Unescaper();\n        if ('\"' == $scalar[$i]) {\n            $output = $unescaper->unescapeDoubleQuotedString($output);\n        } else {\n            $output = $unescaper->unescapeSingleQuotedString($output);\n        }\n\n        $i += \\strlen($match[0]);\n\n        return $output;\n    }\n\n    /**\n     * Parses a YAML sequence.\n     *\n     * @throws ParseException When malformed inline YAML string is parsed\n     */\n    private static function parseSequence(string $sequence, int $flags, int &$i = 0, array &$references = []): array\n    {\n        $output = [];\n        $len = \\strlen($sequence);\n        ++$i;\n\n        // [foo, bar, ...]\n        $lastToken = null;\n        while ($i < $len) {\n            if (']' === $sequence[$i]) {\n                return $output;\n            }\n            if (',' === $sequence[$i] || ' ' === $sequence[$i]) {\n                if (',' === $sequence[$i] && (null === $lastToken || 'separator' === $lastToken)) {\n                    $output[] = null;\n                } elseif (',' === $sequence[$i]) {\n                    $lastToken = 'separator';\n                }\n\n                ++$i;\n\n                continue;\n            }\n\n            $tag = self::parseTag($sequence, $i, $flags);\n            switch ($sequence[$i]) {\n                case '[':\n                    // nested sequence\n                    $value = self::parseSequence($sequence, $flags, $i, $references);\n                    break;\n                case '{':\n                    // nested mapping\n                    $value = self::parseMapping($sequence, $flags, $i, $references);\n                    break;\n                default:\n                    $value = self::parseScalar($sequence, $flags, [',', ']'], $i, null === $tag, $references, $isQuoted);\n\n                    // the value can be an array if a reference has been resolved to an array var\n                    if (\\is_string($value) && !$isQuoted && str_contains($value, ': ')) {\n                        // embedded mapping?\n                        try {\n                            $pos = 0;\n                            $value = self::parseMapping('{'.$value.'}', $flags, $pos, $references);\n                        } catch (\\InvalidArgumentException) {\n                            // no, it's not\n                        }\n                    }\n\n                    if (!$isQuoted && \\is_string($value) && '' !== $value && '&' === $value[0] && Parser::preg_match(Parser::REFERENCE_PATTERN, $value, $matches)) {\n                        $references[$matches['ref']] = $matches['value'];\n                        $value = $matches['value'];\n                    }\n\n                    --$i;\n            }\n\n            if (null !== $tag && '' !== $tag) {\n                $value = new TaggedValue($tag, $value);\n            }\n\n            $output[] = $value;\n\n            $lastToken = 'value';\n            ++$i;\n        }\n\n        throw new ParseException(\\sprintf('Malformed inline YAML string: \"%s\".', $sequence), self::$parsedLineNumber + 1, null, self::$parsedFilename);\n    }\n\n    /**\n     * Parses a YAML mapping.\n     *\n     * @throws ParseException When malformed inline YAML string is parsed\n     */\n    private static function parseMapping(string $mapping, int $flags, int &$i = 0, array &$references = []): array|\\stdClass\n    {\n        $output = [];\n        $len = \\strlen($mapping);\n        ++$i;\n        $allowOverwrite = false;\n\n        // {foo: bar, bar:foo, ...}\n        while ($i < $len) {\n            switch ($mapping[$i]) {\n                case ' ':\n                case ',':\n                case \"\\n\":\n                    ++$i;\n                    continue 2;\n                case '}':\n                    if (self::$objectForMap) {\n                        return (object) $output;\n                    }\n\n                    return $output;\n            }\n\n            // key\n            $offsetBeforeKeyParsing = $i;\n            $isKeyQuoted = \\in_array($mapping[$i], ['\"', \"'\"], true);\n            $key = self::parseScalar($mapping, $flags, [':', ' '], $i, false);\n\n            if ($offsetBeforeKeyParsing === $i) {\n                throw new ParseException('Missing mapping key.', self::$parsedLineNumber + 1, $mapping);\n            }\n\n            if ('!php/const' === $key || '!php/enum' === $key) {\n                $key .= ' '.self::parseScalar($mapping, $flags, [':'], $i, false);\n                $key = self::evaluateScalar($key, $flags);\n            }\n\n            if (false === $i = strpos($mapping, ':', $i)) {\n                break;\n            }\n\n            if (!$isKeyQuoted) {\n                $evaluatedKey = self::evaluateScalar($key, $flags, $references);\n\n                if ('' !== $key && $evaluatedKey !== $key && !\\is_string($evaluatedKey) && !\\is_int($evaluatedKey)) {\n                    throw new ParseException('Implicit casting of incompatible mapping keys to strings is not supported. Quote your evaluable mapping keys instead.', self::$parsedLineNumber + 1, $mapping);\n                }\n            }\n\n            if (!$isKeyQuoted && (!isset($mapping[$i + 1]) || !\\in_array($mapping[$i + 1], [' ', ',', '[', ']', '{', '}', \"\\n\"], true))) {\n                throw new ParseException('Colons must be followed by a space or an indication character (i.e. \" \", \",\", \"[\", \"]\", \"{\", \"}\").', self::$parsedLineNumber + 1, $mapping);\n            }\n\n            if ('<<' === $key) {\n                $allowOverwrite = true;\n            }\n\n            while ($i < $len) {\n                if (':' === $mapping[$i] || ' ' === $mapping[$i] || \"\\n\" === $mapping[$i]) {\n                    ++$i;\n\n                    continue;\n                }\n\n                $tag = self::parseTag($mapping, $i, $flags);\n                switch ($mapping[$i]) {\n                    case '[':\n                        // nested sequence\n                        $value = self::parseSequence($mapping, $flags, $i, $references);\n                        // Spec: Keys MUST be unique; first one wins.\n                        // Parser cannot abort this mapping earlier, since lines\n                        // are processed sequentially.\n                        // But overwriting is allowed when a merge node is used in current block.\n                        if ('<<' === $key) {\n                            foreach ($value as $parsedValue) {\n                                $output += $parsedValue;\n                            }\n                        } elseif ($allowOverwrite || !isset($output[$key])) {\n                            if (null !== $tag) {\n                                $output[$key] = new TaggedValue($tag, $value);\n                            } else {\n                                $output[$key] = $value;\n                            }\n                        } elseif (isset($output[$key])) {\n                            throw new ParseException(\\sprintf('Duplicate key \"%s\" detected.', $key), self::$parsedLineNumber + 1, $mapping);\n                        }\n                        break;\n                    case '{':\n                        // nested mapping\n                        $value = self::parseMapping($mapping, $flags, $i, $references);\n                        // Spec: Keys MUST be unique; first one wins.\n                        // Parser cannot abort this mapping earlier, since lines\n                        // are processed sequentially.\n                        // But overwriting is allowed when a merge node is used in current block.\n                        if ('<<' === $key) {\n                            $output += $value;\n                        } elseif ($allowOverwrite || !isset($output[$key])) {\n                            if (null !== $tag) {\n                                $output[$key] = new TaggedValue($tag, $value);\n                            } else {\n                                $output[$key] = $value;\n                            }\n                        } elseif (isset($output[$key])) {\n                            throw new ParseException(\\sprintf('Duplicate key \"%s\" detected.', $key), self::$parsedLineNumber + 1, $mapping);\n                        }\n                        break;\n                    default:\n                        $value = self::parseScalar($mapping, $flags, [',', '}', \"\\n\"], $i, null === $tag, $references, $isValueQuoted);\n                        // Spec: Keys MUST be unique; first one wins.\n                        // Parser cannot abort this mapping earlier, since lines\n                        // are processed sequentially.\n                        // But overwriting is allowed when a merge node is used in current block.\n                        if ('<<' === $key) {\n                            $output += $value;\n                        } elseif ($allowOverwrite || !isset($output[$key])) {\n                            if (!$isValueQuoted && \\is_string($value) && '' !== $value && '&' === $value[0] && !self::isBinaryString($value) && Parser::preg_match(Parser::REFERENCE_PATTERN, $value, $matches)) {\n                                $references[$matches['ref']] = $matches['value'];\n                                $value = $matches['value'];\n                            }\n\n                            if (null !== $tag) {\n                                $output[$key] = new TaggedValue($tag, $value);\n                            } else {\n                                $output[$key] = $value;\n                            }\n                        } elseif (isset($output[$key])) {\n                            throw new ParseException(\\sprintf('Duplicate key \"%s\" detected.', $key), self::$parsedLineNumber + 1, $mapping);\n                        }\n                        --$i;\n                }\n                ++$i;\n\n                continue 2;\n            }\n        }\n\n        throw new ParseException(\\sprintf('Malformed inline YAML string: \"%s\".', $mapping), self::$parsedLineNumber + 1, null, self::$parsedFilename);\n    }\n\n    /**\n     * Evaluates scalars and replaces magic values.\n     *\n     * @throws ParseException when object parsing support was disabled and the parser detected a PHP object or when a reference could not be resolved\n     */\n    private static function evaluateScalar(string $scalar, int $flags, array &$references = [], ?bool &$isQuotedString = null): mixed\n    {\n        $isQuotedString = false;\n        $scalar = trim($scalar);\n\n        if (str_starts_with($scalar, '*')) {\n            if (false !== $pos = strpos($scalar, '#')) {\n                $value = substr($scalar, 1, $pos - 2);\n            } else {\n                $value = substr($scalar, 1);\n            }\n\n            // an unquoted *\n            if ('' === $value) {\n                throw new ParseException('A reference must contain at least one character.', self::$parsedLineNumber + 1, $value, self::$parsedFilename);\n            }\n\n            if (!\\array_key_exists($value, $references)) {\n                throw new ParseException(\\sprintf('Reference \"%s\" does not exist.', $value), self::$parsedLineNumber + 1, $value, self::$parsedFilename);\n            }\n\n            return $references[$value];\n        }\n\n        $scalarLower = strtolower($scalar);\n\n        switch (true) {\n            case 'null' === $scalarLower:\n            case '' === $scalar:\n            case '~' === $scalar:\n                return null;\n            case 'true' === $scalarLower:\n                return true;\n            case 'false' === $scalarLower:\n                return false;\n            case '!' === $scalar[0]:\n                switch (true) {\n                    case str_starts_with($scalar, '!!str '):\n                        $s = substr($scalar, 6);\n\n                        if (\\in_array($s[0] ?? '', ['\"', \"'\"], true)) {\n                            $isQuotedString = true;\n                            $s = self::parseQuotedScalar($s);\n                        }\n\n                        return $s;\n                    case str_starts_with($scalar, '! '):\n                        return substr($scalar, 2);\n                    case str_starts_with($scalar, '!php/object'):\n                        if (self::$objectSupport) {\n                            if (!isset($scalar[12])) {\n                                throw new ParseException('Missing value for tag \"!php/object\".', self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                            }\n\n                            return unserialize(self::parseScalar(substr($scalar, 12)));\n                        }\n\n                        if (self::$exceptionOnInvalidType) {\n                            throw new ParseException('Object support when parsing a YAML file has been disabled.', self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                        }\n\n                        return null;\n                    case str_starts_with($scalar, '!php/const'):\n                        if (self::$constantSupport) {\n                            if (!isset($scalar[11])) {\n                                throw new ParseException('Missing value for tag \"!php/const\".', self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                            }\n\n                            $i = 0;\n                            if (\\defined($const = self::parseScalar(substr($scalar, 11), 0, null, $i, false))) {\n                                return \\constant($const);\n                            }\n\n                            throw new ParseException(\\sprintf('The constant \"%s\" is not defined.', $const), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                        }\n                        if (self::$exceptionOnInvalidType) {\n                            throw new ParseException(\\sprintf('The string \"%s\" could not be parsed as a constant. Did you forget to pass the \"Yaml::PARSE_CONSTANT\" flag to the parser?', $scalar), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                        }\n\n                        return null;\n                    case str_starts_with($scalar, '!php/enum'):\n                        if (self::$constantSupport) {\n                            if (!isset($scalar[11])) {\n                                throw new ParseException('Missing value for tag \"!php/enum\".', self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                            }\n\n                            $i = 0;\n                            $enumName = self::parseScalar(substr($scalar, 10), 0, null, $i, false);\n                            $useName = str_contains($enumName, '::');\n                            $enum = $useName ? strstr($enumName, '::', true) : $enumName;\n\n                            if (!enum_exists($enum)) {\n                                throw new ParseException(\\sprintf('The enum \"%s\" is not defined.', $enum), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                            }\n                            if (!$useName) {\n                                return $enum::cases();\n                            }\n                            if ($useValue = str_ends_with($enumName, '->value')) {\n                                $enumName = substr($enumName, 0, -7);\n                            }\n\n                            if (!\\defined($enumName)) {\n                                throw new ParseException(\\sprintf('The string \"%s\" is not the name of a valid enum.', $enumName), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                            }\n\n                            $value = \\constant($enumName);\n\n                            if (!$useValue) {\n                                return $value;\n                            }\n                            if (!$value instanceof \\BackedEnum) {\n                                throw new ParseException(\\sprintf('The enum \"%s\" defines no value next to its name.', $enumName), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                            }\n\n                            return $value->value;\n                        }\n                        if (self::$exceptionOnInvalidType) {\n                            throw new ParseException(\\sprintf('The string \"%s\" could not be parsed as an enum. Did you forget to pass the \"Yaml::PARSE_CONSTANT\" flag to the parser?', $scalar), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n                        }\n\n                        return null;\n                    case str_starts_with($scalar, '!!float '):\n                        return (float) substr($scalar, 8);\n                    case str_starts_with($scalar, '!!binary '):\n                        return self::evaluateBinaryScalar(substr($scalar, 9));\n                }\n\n                throw new ParseException(\\sprintf('The string \"%s\" could not be parsed as it uses an unsupported built-in tag.', $scalar), self::$parsedLineNumber, $scalar, self::$parsedFilename);\n            case preg_match('/^(?:\\+|-)?0o(?P<value>[0-7_]++)$/', $scalar, $matches):\n                $value = str_replace('_', '', $matches['value']);\n\n                if ('-' === $scalar[0]) {\n                    return -octdec($value);\n                }\n\n                return octdec($value);\n            case \\in_array($scalar[0], ['+', '-', '.'], true) || is_numeric($scalar[0]):\n                if (Parser::preg_match('{^[+-]?[0-9][0-9_]*$}', $scalar)) {\n                    $scalar = str_replace('_', '', $scalar);\n                }\n\n                switch (true) {\n                    case ctype_digit($scalar):\n                    case '-' === $scalar[0] && ctype_digit(substr($scalar, 1)):\n                        $cast = (int) $scalar;\n\n                        return ($scalar === (string) $cast) ? $cast : $scalar;\n                    case is_numeric($scalar):\n                    case Parser::preg_match(self::getHexRegex(), $scalar):\n                        $scalar = str_replace('_', '', $scalar);\n\n                        return '0x' === $scalar[0].$scalar[1] ? hexdec($scalar) : (float) $scalar;\n                    case '.inf' === $scalarLower:\n                    case '.nan' === $scalarLower:\n                        return -log(0);\n                    case '-.inf' === $scalarLower:\n                        return log(0);\n                    case Parser::preg_match('/^(-|\\+)?[0-9][0-9_]*(\\.[0-9_]+)?$/', $scalar):\n                        return (float) str_replace('_', '', $scalar);\n                    case Parser::preg_match(self::getTimestampRegex(), $scalar):\n                        try {\n                            // When no timezone is provided in the parsed date, YAML spec says we must assume UTC.\n                            $time = new \\DateTimeImmutable($scalar, new \\DateTimeZone('UTC'));\n                        } catch (\\Exception $e) {\n                            // Some dates accepted by the regex are not valid dates.\n                            throw new ParseException(\\sprintf('The date \"%s\" could not be parsed as it is an invalid date.', $scalar), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename, $e);\n                        }\n\n                        if (Yaml::PARSE_DATETIME & $flags) {\n                            return $time;\n                        }\n\n                        if ('' !== rtrim($time->format('u'), '0')) {\n                            return (float) $time->format('U.u');\n                        }\n\n                        try {\n                            if (false !== $scalar = $time->getTimestamp()) {\n                                return $scalar;\n                            }\n                        } catch (\\ValueError) {\n                            // no-op\n                        }\n\n                        return $time->format('U');\n                }\n        }\n\n        return (string) $scalar;\n    }\n\n    private static function parseTag(string $value, int &$i, int $flags): ?string\n    {\n        if ('!' !== $value[$i]) {\n            return null;\n        }\n\n        $tagLength = strcspn($value, \" \\t\\n[]{},\", $i + 1);\n        $tag = substr($value, $i + 1, $tagLength);\n\n        $nextOffset = $i + $tagLength + 1;\n        $nextOffset += strspn($value, ' ', $nextOffset);\n\n        if ('' === $tag && (!isset($value[$nextOffset]) || \\in_array($value[$nextOffset], [']', '}', ','], true))) {\n            throw new ParseException('Using the unquoted scalar value \"!\" is not supported. You must quote it.', self::$parsedLineNumber + 1, $value, self::$parsedFilename);\n        }\n\n        // Is followed by a scalar and is a built-in tag\n        if ('' !== $tag && (!isset($value[$nextOffset]) || !\\in_array($value[$nextOffset], ['[', '{'], true)) && ('!' === $tag[0] || \\in_array($tag, ['str', 'php/const', 'php/enum', 'php/object'], true))) {\n            // Manage in {@link self::evaluateScalar()}\n            return null;\n        }\n\n        $i = $nextOffset;\n\n        // Built-in tags\n        if ('' !== $tag && '!' === $tag[0]) {\n            throw new ParseException(\\sprintf('The built-in tag \"!%s\" is not implemented.', $tag), self::$parsedLineNumber + 1, $value, self::$parsedFilename);\n        }\n\n        if ('' !== $tag && !isset($value[$i])) {\n            throw new ParseException(\\sprintf('Missing value for tag \"%s\".', $tag), self::$parsedLineNumber + 1, $value, self::$parsedFilename);\n        }\n\n        if ('' === $tag || Yaml::PARSE_CUSTOM_TAGS & $flags) {\n            return $tag;\n        }\n\n        throw new ParseException(\\sprintf('Tags support is not enabled. Enable the \"Yaml::PARSE_CUSTOM_TAGS\" flag to use \"!%s\".', $tag), self::$parsedLineNumber + 1, $value, self::$parsedFilename);\n    }\n\n    public static function evaluateBinaryScalar(string $scalar): string\n    {\n        $parsedBinaryData = self::parseScalar(preg_replace('/\\s/', '', $scalar));\n\n        if (0 !== (\\strlen($parsedBinaryData) % 4)) {\n            throw new ParseException(\\sprintf('The normalized base64 encoded data (data without whitespace characters) length must be a multiple of four (%d bytes given).', \\strlen($parsedBinaryData)), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n        }\n\n        if (!Parser::preg_match('#^[A-Z0-9+/]+={0,2}$#i', $parsedBinaryData)) {\n            throw new ParseException(\\sprintf('The base64 encoded data (%s) contains invalid characters.', $parsedBinaryData), self::$parsedLineNumber + 1, $scalar, self::$parsedFilename);\n        }\n\n        return base64_decode($parsedBinaryData, true);\n    }\n\n    private static function isBinaryString(string $value): bool\n    {\n        return !preg_match('//u', $value) || preg_match('/[^\\x00\\x07-\\x0d\\x1B\\x20-\\xff]/', $value);\n    }\n\n    /**\n     * Gets a regex that matches a YAML date.\n     *\n     * @see http://www.yaml.org/spec/1.2/spec.html#id2761573\n     */\n    private static function getTimestampRegex(): string\n    {\n        return <<<EOF\n        ~^\n        (?P<year>[0-9][0-9][0-9][0-9])\n        -(?P<month>[0-9][0-9]?)\n        -(?P<day>[0-9][0-9]?)\n        (?:(?:[Tt]|[ \\t]+)\n        (?P<hour>[0-9][0-9]?)\n        :(?P<minute>[0-9][0-9])\n        :(?P<second>[0-9][0-9])\n        (?:\\.(?P<fraction>[0-9]*))?\n        (?:[ \\t]*(?P<tz>Z|(?P<tz_sign>[-+])(?P<tz_hour>[0-9][0-9]?)\n        (?::(?P<tz_minute>[0-9][0-9]))?))?)?\n        $~x\nEOF;\n    }\n\n    /**\n     * Gets a regex that matches a YAML number in hexadecimal notation.\n     */\n    private static function getHexRegex(): string\n    {\n        return '~^0x[0-9a-f_]++$~i';\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Parser.php",
          "type": "blob",
          "size": 50.376953125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Yaml;\n\nuse Symfony\\Component\\Yaml\\Exception\\ParseException;\nuse Symfony\\Component\\Yaml\\Tag\\TaggedValue;\n\n/**\n * Parser parses YAML strings to convert them to PHP arrays.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @final\n */\nclass Parser\n{\n    public const TAG_PATTERN = '(?P<tag>![\\w!.\\/:-]+)';\n    public const BLOCK_SCALAR_HEADER_PATTERN = '(?P<separator>\\||>)(?P<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?P<comments> +#.*)?';\n    public const REFERENCE_PATTERN = '#^&(?P<ref>[^ ]++) *+(?P<value>.*)#u';\n\n    private ?string $filename = null;\n    private int $offset = 0;\n    private int $numberOfParsedLines = 0;\n    private ?int $totalNumberOfLines = null;\n    private array $lines = [];\n    private int $currentLineNb = -1;\n    private string $currentLine = '';\n    private array $refs = [];\n    private array $skippedLineNumbers = [];\n    private array $locallySkippedLineNumbers = [];\n    private array $refsBeingParsed = [];\n\n    /**\n     * Parses a YAML file into a PHP value.\n     *\n     * @param string                     $filename The path to the YAML file to be parsed\n     * @param int-mask-of<Yaml::PARSE_*> $flags    A bit field of Yaml::PARSE_* constants to customize the YAML parser behavior\n     *\n     * @throws ParseException If the file could not be read or the YAML is not valid\n     */\n    public function parseFile(string $filename, int $flags = 0): mixed\n    {\n        if (!is_file($filename)) {\n            throw new ParseException(\\sprintf('File \"%s\" does not exist.', $filename));\n        }\n\n        if (!is_readable($filename)) {\n            throw new ParseException(\\sprintf('File \"%s\" cannot be read.', $filename));\n        }\n\n        $this->filename = $filename;\n\n        try {\n            return $this->parse(file_get_contents($filename), $flags);\n        } finally {\n            $this->filename = null;\n        }\n    }\n\n    /**\n     * Parses a YAML string to a PHP value.\n     *\n     * @param string                     $value A YAML string\n     * @param int-mask-of<Yaml::PARSE_*> $flags A bit field of Yaml::PARSE_* constants to customize the YAML parser behavior\n     *\n     * @throws ParseException If the YAML is not valid\n     */\n    public function parse(string $value, int $flags = 0): mixed\n    {\n        if (false === preg_match('//u', $value)) {\n            throw new ParseException('The YAML value does not appear to be valid UTF-8.', -1, null, $this->filename);\n        }\n\n        $this->refs = [];\n\n        try {\n            $data = $this->doParse($value, $flags);\n        } finally {\n            $this->refsBeingParsed = [];\n            $this->offset = 0;\n            $this->lines = [];\n            $this->currentLine = '';\n            $this->numberOfParsedLines = 0;\n            $this->refs = [];\n            $this->skippedLineNumbers = [];\n            $this->locallySkippedLineNumbers = [];\n            $this->totalNumberOfLines = null;\n        }\n\n        return $data;\n    }\n\n    private function doParse(string $value, int $flags): mixed\n    {\n        $this->currentLineNb = -1;\n        $this->currentLine = '';\n        $value = $this->cleanup($value);\n        $this->lines = explode(\"\\n\", $value);\n        $this->numberOfParsedLines = \\count($this->lines);\n        $this->locallySkippedLineNumbers = [];\n        $this->totalNumberOfLines ??= $this->numberOfParsedLines;\n\n        if (!$this->moveToNextLine()) {\n            return null;\n        }\n\n        $data = [];\n        $context = null;\n        $allowOverwrite = false;\n\n        while ($this->isCurrentLineEmpty()) {\n            if (!$this->moveToNextLine()) {\n                return null;\n            }\n        }\n\n        // Resolves the tag and returns if end of the document\n        if (null !== ($tag = $this->getLineTag($this->currentLine, $flags, false)) && !$this->moveToNextLine()) {\n            return new TaggedValue($tag, '');\n        }\n\n        do {\n            if ($this->isCurrentLineEmpty()) {\n                continue;\n            }\n\n            // tab?\n            if (\"\\t\" === $this->currentLine[0]) {\n                throw new ParseException('A YAML file cannot contain tabs as indentation.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n            }\n\n            Inline::initialize($flags, $this->getRealCurrentLineNb(), $this->filename);\n\n            $isRef = $mergeNode = false;\n            if ('-' === $this->currentLine[0] && self::preg_match('#^\\-((?P<leadspaces>\\s+)(?P<value>.+))?$#u', rtrim($this->currentLine), $values)) {\n                if ($context && 'mapping' == $context) {\n                    throw new ParseException('You cannot define a sequence item when in a mapping.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n                }\n                $context = 'sequence';\n\n                if (isset($values['value']) && '&' === $values['value'][0] && self::preg_match(self::REFERENCE_PATTERN, $values['value'], $matches)) {\n                    $isRef = $matches['ref'];\n                    $this->refsBeingParsed[] = $isRef;\n                    $values['value'] = $matches['value'];\n                }\n\n                if (isset($values['value'][1]) && '?' === $values['value'][0] && ' ' === $values['value'][1]) {\n                    throw new ParseException('Complex mappings are not supported.', $this->getRealCurrentLineNb() + 1, $this->currentLine);\n                }\n\n                // array\n                if (isset($values['value']) && str_starts_with(ltrim($values['value'], ' '), '-')) {\n                    // Inline first child\n                    $currentLineNumber = $this->getRealCurrentLineNb();\n\n                    $sequenceIndentation = \\strlen($values['leadspaces']) + 1;\n                    $sequenceYaml = substr($this->currentLine, $sequenceIndentation);\n                    $sequenceYaml .= \"\\n\".$this->getNextEmbedBlock($sequenceIndentation, true);\n\n                    $data[] = $this->parseBlock($currentLineNumber, rtrim($sequenceYaml), $flags);\n                } elseif (!isset($values['value']) || '' == trim($values['value'], ' ') || str_starts_with(ltrim($values['value'], ' '), '#')) {\n                    $data[] = $this->parseBlock($this->getRealCurrentLineNb() + 1, $this->getNextEmbedBlock(null, true) ?? '', $flags);\n                } elseif (null !== $subTag = $this->getLineTag(ltrim($values['value'], ' '), $flags)) {\n                    $data[] = new TaggedValue(\n                        $subTag,\n                        $this->parseBlock($this->getRealCurrentLineNb() + 1, $this->getNextEmbedBlock(null, true), $flags)\n                    );\n                } else {\n                    if (\n                        isset($values['leadspaces'])\n                        && (\n                            '!' === $values['value'][0]\n                            || self::preg_match('#^(?P<key>'.Inline::REGEX_QUOTED_STRING.'|[^ \\'\"\\{\\[].*?) *\\:(\\s+(?P<value>.+?))?\\s*$#u', $this->trimTag($values['value']), $matches)\n                        )\n                    ) {\n                        $block = $values['value'];\n                        if ($this->isNextLineIndented() || isset($matches['value']) && '>-' === $matches['value']) {\n                            $block .= \"\\n\".$this->getNextEmbedBlock($this->getCurrentLineIndentation() + \\strlen($values['leadspaces']) + 1);\n                        }\n\n                        $data[] = $this->parseBlock($this->getRealCurrentLineNb(), $block, $flags);\n                    } else {\n                        $data[] = $this->parseValue($values['value'], $flags, $context);\n                    }\n                }\n                if ($isRef) {\n                    $this->refs[$isRef] = end($data);\n                    array_pop($this->refsBeingParsed);\n                }\n            } elseif (\n                self::preg_match('#^(?P<key>(?:![^\\s]++\\s++)?(?:'.Inline::REGEX_QUOTED_STRING.'|[^ \\'\"\\[\\{!].*?)) *\\:(( |\\t)++(?P<value>.+))?$#u', rtrim($this->currentLine), $values)\n                && (!str_contains($values['key'], ' #') || \\in_array($values['key'][0], ['\"', \"'\"]))\n            ) {\n                if ($context && 'sequence' == $context) {\n                    throw new ParseException('You cannot define a mapping item when in a sequence.', $this->currentLineNb + 1, $this->currentLine, $this->filename);\n                }\n                $context = 'mapping';\n\n                try {\n                    $key = Inline::parseScalar($values['key']);\n                } catch (ParseException $e) {\n                    $e->setParsedLine($this->getRealCurrentLineNb() + 1);\n                    $e->setSnippet($this->currentLine);\n\n                    throw $e;\n                }\n\n                if (!\\is_string($key) && !\\is_int($key)) {\n                    throw new ParseException((is_numeric($key) ? 'Numeric' : 'Non-string').' keys are not supported. Quote your evaluable mapping keys instead.', $this->getRealCurrentLineNb() + 1, $this->currentLine);\n                }\n\n                // Convert float keys to strings, to avoid being converted to integers by PHP\n                if (\\is_float($key)) {\n                    $key = (string) $key;\n                }\n\n                if ('<<' === $key && (!isset($values['value']) || '&' !== $values['value'][0] || !self::preg_match('#^&(?P<ref>[^ ]+)#u', $values['value'], $refMatches))) {\n                    $mergeNode = true;\n                    $allowOverwrite = true;\n                    if (isset($values['value'][0]) && '*' === $values['value'][0]) {\n                        $refName = substr(rtrim($values['value']), 1);\n                        if (!\\array_key_exists($refName, $this->refs)) {\n                            if (false !== $pos = array_search($refName, $this->refsBeingParsed, true)) {\n                                throw new ParseException(\\sprintf('Circular reference [%s] detected for reference \"%s\".', implode(', ', array_merge(\\array_slice($this->refsBeingParsed, $pos), [$refName])), $refName), $this->currentLineNb + 1, $this->currentLine, $this->filename);\n                            }\n\n                            throw new ParseException(\\sprintf('Reference \"%s\" does not exist.', $refName), $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n                        }\n\n                        $refValue = $this->refs[$refName];\n\n                        if (Yaml::PARSE_OBJECT_FOR_MAP & $flags && $refValue instanceof \\stdClass) {\n                            $refValue = (array) $refValue;\n                        }\n\n                        if (!\\is_array($refValue)) {\n                            throw new ParseException('YAML merge keys used with a scalar value instead of an array.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n                        }\n\n                        $data += $refValue; // array union\n                    } else {\n                        if (isset($values['value']) && '' !== $values['value']) {\n                            $value = $values['value'];\n                        } else {\n                            $value = $this->getNextEmbedBlock();\n                        }\n                        $parsed = $this->parseBlock($this->getRealCurrentLineNb() + 1, $value, $flags);\n\n                        if (Yaml::PARSE_OBJECT_FOR_MAP & $flags && $parsed instanceof \\stdClass) {\n                            $parsed = (array) $parsed;\n                        }\n\n                        if (!\\is_array($parsed)) {\n                            throw new ParseException('YAML merge keys used with a scalar value instead of an array.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n                        }\n\n                        if (isset($parsed[0])) {\n                            // If the value associated with the merge key is a sequence, then this sequence is expected to contain mapping nodes\n                            // and each of these nodes is merged in turn according to its order in the sequence. Keys in mapping nodes earlier\n                            // in the sequence override keys specified in later mapping nodes.\n                            foreach ($parsed as $parsedItem) {\n                                if (Yaml::PARSE_OBJECT_FOR_MAP & $flags && $parsedItem instanceof \\stdClass) {\n                                    $parsedItem = (array) $parsedItem;\n                                }\n\n                                if (!\\is_array($parsedItem)) {\n                                    throw new ParseException('Merge items must be arrays.', $this->getRealCurrentLineNb() + 1, $parsedItem, $this->filename);\n                                }\n\n                                $data += $parsedItem; // array union\n                            }\n                        } else {\n                            // If the value associated with the key is a single mapping node, each of its key/value pairs is inserted into the\n                            // current mapping, unless the key already exists in it.\n                            $data += $parsed; // array union\n                        }\n                    }\n                } elseif ('<<' !== $key && isset($values['value']) && '&' === $values['value'][0] && self::preg_match(self::REFERENCE_PATTERN, $values['value'], $matches)) {\n                    $isRef = $matches['ref'];\n                    $this->refsBeingParsed[] = $isRef;\n                    $values['value'] = $matches['value'];\n                }\n\n                $subTag = null;\n                if ($mergeNode) {\n                    // Merge keys\n                } elseif (!isset($values['value']) || '' === $values['value'] || str_starts_with($values['value'], '#') || (null !== $subTag = $this->getLineTag($values['value'], $flags)) || '<<' === $key) {\n                    // hash\n                    // if next line is less indented or equal, then it means that the current value is null\n                    if (!$this->isNextLineIndented() && !$this->isNextLineUnIndentedCollection()) {\n                        // Spec: Keys MUST be unique; first one wins.\n                        // But overwriting is allowed when a merge node is used in current block.\n                        if ($allowOverwrite || !isset($data[$key])) {\n                            if (!$allowOverwrite && \\array_key_exists($key, $data)) {\n                                trigger_deprecation('symfony/yaml', '7.2', 'Duplicate key \"%s\" detected on line %d whilst parsing YAML. Silent handling of duplicate mapping keys in YAML is deprecated and will throw a ParseException in 8.0.', $key, $this->getRealCurrentLineNb() + 1);\n                            }\n\n                            if (null !== $subTag) {\n                                $data[$key] = new TaggedValue($subTag, '');\n                            } else {\n                                $data[$key] = null;\n                            }\n                        } else {\n                            throw new ParseException(\\sprintf('Duplicate key \"%s\" detected.', $key), $this->getRealCurrentLineNb() + 1, $this->currentLine);\n                        }\n                    } else {\n                        // remember the parsed line number here in case we need it to provide some contexts in error messages below\n                        $realCurrentLineNbKey = $this->getRealCurrentLineNb();\n                        $value = $this->parseBlock($this->getRealCurrentLineNb() + 1, $this->getNextEmbedBlock(), $flags);\n                        if ('<<' === $key) {\n                            $this->refs[$refMatches['ref']] = $value;\n\n                            if (Yaml::PARSE_OBJECT_FOR_MAP & $flags && $value instanceof \\stdClass) {\n                                $value = (array) $value;\n                            }\n\n                            $data += $value;\n                        } elseif ($allowOverwrite || !isset($data[$key])) {\n                            if (!$allowOverwrite && \\array_key_exists($key, $data)) {\n                                trigger_deprecation('symfony/yaml', '7.2', 'Duplicate key \"%s\" detected on line %d whilst parsing YAML. Silent handling of duplicate mapping keys in YAML is deprecated and will throw a ParseException in 8.0.', $key, $this->getRealCurrentLineNb() + 1);\n                            }\n\n                            // Spec: Keys MUST be unique; first one wins.\n                            // But overwriting is allowed when a merge node is used in current block.\n                            if (null !== $subTag) {\n                                $data[$key] = new TaggedValue($subTag, $value);\n                            } else {\n                                $data[$key] = $value;\n                            }\n                        } else {\n                            throw new ParseException(\\sprintf('Duplicate key \"%s\" detected.', $key), $realCurrentLineNbKey + 1, $this->currentLine);\n                        }\n                    }\n                } else {\n                    $value = $this->parseValue(rtrim($values['value']), $flags, $context);\n                    // Spec: Keys MUST be unique; first one wins.\n                    // But overwriting is allowed when a merge node is used in current block.\n                    if ($allowOverwrite || !isset($data[$key])) {\n                        if (!$allowOverwrite && \\array_key_exists($key, $data)) {\n                            trigger_deprecation('symfony/yaml', '7.2', 'Duplicate key \"%s\" detected on line %d whilst parsing YAML. Silent handling of duplicate mapping keys in YAML is deprecated and will throw a ParseException in 8.0.', $key, $this->getRealCurrentLineNb() + 1);\n                        }\n\n                        $data[$key] = $value;\n                    } else {\n                        throw new ParseException(\\sprintf('Duplicate key \"%s\" detected.', $key), $this->getRealCurrentLineNb() + 1, $this->currentLine);\n                    }\n                }\n                if ($isRef) {\n                    $this->refs[$isRef] = $data[$key];\n                    array_pop($this->refsBeingParsed);\n                }\n            } elseif ('\"' === $this->currentLine[0] || \"'\" === $this->currentLine[0]) {\n                if (null !== $context) {\n                    throw new ParseException('Unable to parse.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n                }\n\n                try {\n                    return Inline::parse($this->lexInlineQuotedString(), $flags, $this->refs);\n                } catch (ParseException $e) {\n                    $e->setParsedLine($this->getRealCurrentLineNb() + 1);\n                    $e->setSnippet($this->currentLine);\n\n                    throw $e;\n                }\n            } elseif ('{' === $this->currentLine[0]) {\n                if (null !== $context) {\n                    throw new ParseException('Unable to parse.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n                }\n\n                try {\n                    $parsedMapping = Inline::parse($this->lexInlineMapping(), $flags, $this->refs);\n\n                    while ($this->moveToNextLine()) {\n                        if (!$this->isCurrentLineEmpty()) {\n                            throw new ParseException('Unable to parse.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n                        }\n                    }\n\n                    return $parsedMapping;\n                } catch (ParseException $e) {\n                    $e->setParsedLine($this->getRealCurrentLineNb() + 1);\n                    $e->setSnippet($this->currentLine);\n\n                    throw $e;\n                }\n            } elseif ('[' === $this->currentLine[0]) {\n                if (null !== $context) {\n                    throw new ParseException('Unable to parse.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n                }\n\n                try {\n                    $parsedSequence = Inline::parse($this->lexInlineSequence(), $flags, $this->refs);\n\n                    while ($this->moveToNextLine()) {\n                        if (!$this->isCurrentLineEmpty()) {\n                            throw new ParseException('Unable to parse.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n                        }\n                    }\n\n                    return $parsedSequence;\n                } catch (ParseException $e) {\n                    $e->setParsedLine($this->getRealCurrentLineNb() + 1);\n                    $e->setSnippet($this->currentLine);\n\n                    throw $e;\n                }\n            } else {\n                // multiple documents are not supported\n                if ('---' === $this->currentLine) {\n                    throw new ParseException('Multiple documents are not supported.', $this->currentLineNb + 1, $this->currentLine, $this->filename);\n                }\n\n                if (isset($this->currentLine[1]) && '?' === $this->currentLine[0] && ' ' === $this->currentLine[1]) {\n                    throw new ParseException('Complex mappings are not supported.', $this->getRealCurrentLineNb() + 1, $this->currentLine);\n                }\n\n                // 1-liner optionally followed by newline(s)\n                if (\\is_string($value) && $this->lines[0] === trim($value)) {\n                    try {\n                        $value = Inline::parse($this->lines[0], $flags, $this->refs);\n                    } catch (ParseException $e) {\n                        $e->setParsedLine($this->getRealCurrentLineNb() + 1);\n                        $e->setSnippet($this->currentLine);\n\n                        throw $e;\n                    }\n\n                    return $value;\n                }\n\n                // try to parse the value as a multi-line string as a last resort\n                if (0 === $this->currentLineNb) {\n                    $previousLineWasNewline = false;\n                    $previousLineWasTerminatedWithBackslash = false;\n                    $value = '';\n\n                    foreach ($this->lines as $line) {\n                        $trimmedLine = trim($line);\n                        if ('#' === ($trimmedLine[0] ?? '')) {\n                            continue;\n                        }\n                        // If the indentation is not consistent at offset 0, it is to be considered as a ParseError\n                        if (0 === $this->offset && isset($line[0]) && ' ' === $line[0]) {\n                            throw new ParseException('Unable to parse.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n                        }\n\n                        if (str_contains($line, ': ')) {\n                            throw new ParseException('Mapping values are not allowed in multi-line blocks.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n                        }\n\n                        if ('' === $trimmedLine) {\n                            $value .= \"\\n\";\n                        } elseif (!$previousLineWasNewline && !$previousLineWasTerminatedWithBackslash) {\n                            $value .= ' ';\n                        }\n\n                        if ('' !== $trimmedLine && str_ends_with($line, '\\\\')) {\n                            $value .= ltrim(substr($line, 0, -1));\n                        } elseif ('' !== $trimmedLine) {\n                            $value .= $trimmedLine;\n                        }\n\n                        if ('' === $trimmedLine) {\n                            $previousLineWasNewline = true;\n                            $previousLineWasTerminatedWithBackslash = false;\n                        } elseif (str_ends_with($line, '\\\\')) {\n                            $previousLineWasNewline = false;\n                            $previousLineWasTerminatedWithBackslash = true;\n                        } else {\n                            $previousLineWasNewline = false;\n                            $previousLineWasTerminatedWithBackslash = false;\n                        }\n                    }\n\n                    try {\n                        return Inline::parse(trim($value));\n                    } catch (ParseException) {\n                        // fall-through to the ParseException thrown below\n                    }\n                }\n\n                throw new ParseException('Unable to parse.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n            }\n        } while ($this->moveToNextLine());\n\n        if (null !== $tag) {\n            $data = new TaggedValue($tag, $data);\n        }\n\n        if (Yaml::PARSE_OBJECT_FOR_MAP & $flags && 'mapping' === $context && !\\is_object($data)) {\n            $object = new \\stdClass();\n\n            foreach ($data as $key => $value) {\n                $object->$key = $value;\n            }\n\n            $data = $object;\n        }\n\n        return $data ?: null;\n    }\n\n    private function parseBlock(int $offset, string $yaml, int $flags): mixed\n    {\n        $skippedLineNumbers = $this->skippedLineNumbers;\n\n        foreach ($this->locallySkippedLineNumbers as $lineNumber) {\n            if ($lineNumber < $offset) {\n                continue;\n            }\n\n            $skippedLineNumbers[] = $lineNumber;\n        }\n\n        $parser = new self();\n        $parser->offset = $offset;\n        $parser->totalNumberOfLines = $this->totalNumberOfLines;\n        $parser->skippedLineNumbers = $skippedLineNumbers;\n        $parser->refs = &$this->refs;\n        $parser->refsBeingParsed = $this->refsBeingParsed;\n\n        return $parser->doParse($yaml, $flags);\n    }\n\n    /**\n     * Returns the current line number (takes the offset into account).\n     *\n     * @internal\n     */\n    public function getRealCurrentLineNb(): int\n    {\n        $realCurrentLineNumber = $this->currentLineNb + $this->offset;\n\n        foreach ($this->skippedLineNumbers as $skippedLineNumber) {\n            if ($skippedLineNumber > $realCurrentLineNumber) {\n                break;\n            }\n\n            ++$realCurrentLineNumber;\n        }\n\n        return $realCurrentLineNumber;\n    }\n\n    private function getCurrentLineIndentation(): int\n    {\n        if (' ' !== ($this->currentLine[0] ?? '')) {\n            return 0;\n        }\n\n        return \\strlen($this->currentLine) - \\strlen(ltrim($this->currentLine, ' '));\n    }\n\n    /**\n     * Returns the next embed block of YAML.\n     *\n     * @param int|null $indentation The indent level at which the block is to be read, or null for default\n     * @param bool     $inSequence  True if the enclosing data structure is a sequence\n     *\n     * @throws ParseException When indentation problem are detected\n     */\n    private function getNextEmbedBlock(?int $indentation = null, bool $inSequence = false): string\n    {\n        $oldLineIndentation = $this->getCurrentLineIndentation();\n\n        if (!$this->moveToNextLine()) {\n            return '';\n        }\n\n        if (null === $indentation) {\n            $newIndent = null;\n            $movements = 0;\n\n            do {\n                $EOF = false;\n\n                // empty and comment-like lines do not influence the indentation depth\n                if ($this->isCurrentLineEmpty() || $this->isCurrentLineComment()) {\n                    $EOF = !$this->moveToNextLine();\n\n                    if (!$EOF) {\n                        ++$movements;\n                    }\n                } else {\n                    $newIndent = $this->getCurrentLineIndentation();\n                }\n            } while (!$EOF && null === $newIndent);\n\n            for ($i = 0; $i < $movements; ++$i) {\n                $this->moveToPreviousLine();\n            }\n\n            $unindentedEmbedBlock = $this->isStringUnIndentedCollectionItem();\n\n            if (!$this->isCurrentLineEmpty() && 0 === $newIndent && !$unindentedEmbedBlock) {\n                throw new ParseException('Indentation problem.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n            }\n        } else {\n            $newIndent = $indentation;\n        }\n\n        $data = [];\n\n        if ($this->getCurrentLineIndentation() >= $newIndent) {\n            $data[] = substr($this->currentLine, $newIndent ?? 0);\n        } elseif ($this->isCurrentLineEmpty() || $this->isCurrentLineComment()) {\n            $data[] = $this->currentLine;\n        } else {\n            $this->moveToPreviousLine();\n\n            return '';\n        }\n\n        if ($inSequence && $oldLineIndentation === $newIndent && isset($data[0][0]) && '-' === $data[0][0]) {\n            // the previous line contained a dash but no item content, this line is a sequence item with the same indentation\n            // and therefore no nested list or mapping\n            $this->moveToPreviousLine();\n\n            return '';\n        }\n\n        $isItUnindentedCollection = $this->isStringUnIndentedCollectionItem();\n        $isItComment = $this->isCurrentLineComment();\n\n        while ($this->moveToNextLine()) {\n            if ($isItComment && !$isItUnindentedCollection) {\n                $isItUnindentedCollection = $this->isStringUnIndentedCollectionItem();\n                $isItComment = $this->isCurrentLineComment();\n            }\n\n            $indent = $this->getCurrentLineIndentation();\n\n            if ($isItUnindentedCollection && !$this->isCurrentLineEmpty() && !$this->isStringUnIndentedCollectionItem() && $newIndent === $indent) {\n                $this->moveToPreviousLine();\n                break;\n            }\n\n            if ($this->isCurrentLineBlank()) {\n                $data[] = substr($this->currentLine, $newIndent ?? 0);\n                continue;\n            }\n\n            if ($indent >= $newIndent) {\n                $data[] = substr($this->currentLine, $newIndent ?? 0);\n            } elseif ($this->isCurrentLineComment()) {\n                $data[] = $this->currentLine;\n            } elseif (0 == $indent) {\n                $this->moveToPreviousLine();\n\n                break;\n            } else {\n                throw new ParseException('Indentation problem.', $this->getRealCurrentLineNb() + 1, $this->currentLine, $this->filename);\n            }\n        }\n\n        return implode(\"\\n\", $data);\n    }\n\n    private function hasMoreLines(): bool\n    {\n        return (\\count($this->lines) - 1) > $this->currentLineNb;\n    }\n\n    /**\n     * Moves the parser to the next line.\n     */\n    private function moveToNextLine(): bool\n    {\n        if ($this->currentLineNb >= $this->numberOfParsedLines - 1) {\n            return false;\n        }\n\n        $this->currentLine = $this->lines[++$this->currentLineNb];\n\n        return true;\n    }\n\n    /**\n     * Moves the parser to the previous line.\n     */\n    private function moveToPreviousLine(): bool\n    {\n        if ($this->currentLineNb < 1) {\n            return false;\n        }\n\n        $this->currentLine = $this->lines[--$this->currentLineNb];\n\n        return true;\n    }\n\n    /**\n     * Parses a YAML value.\n     *\n     * @param string $value   A YAML value\n     * @param int    $flags   A bit field of Yaml::PARSE_* constants to customize the YAML parser behavior\n     * @param string $context The parser context (either sequence or mapping)\n     *\n     * @throws ParseException When reference does not exist\n     */\n    private function parseValue(string $value, int $flags, string $context): mixed\n    {\n        if (str_starts_with($value, '*')) {\n            if (false !== $pos = strpos($value, '#')) {\n                $value = substr($value, 1, $pos - 2);\n            } else {\n                $value = substr($value, 1);\n            }\n\n            if (!\\array_key_exists($value, $this->refs)) {\n                if (false !== $pos = array_search($value, $this->refsBeingParsed, true)) {\n                    throw new ParseException(\\sprintf('Circular reference [%s] detected for reference \"%s\".', implode(', ', array_merge(\\array_slice($this->refsBeingParsed, $pos), [$value])), $value), $this->currentLineNb + 1, $this->currentLine, $this->filename);\n                }\n\n                throw new ParseException(\\sprintf('Reference \"%s\" does not exist.', $value), $this->currentLineNb + 1, $this->currentLine, $this->filename);\n            }\n\n            return $this->refs[$value];\n        }\n\n        if (\\in_array($value[0], ['!', '|', '>'], true) && self::preg_match('/^(?:'.self::TAG_PATTERN.' +)?'.self::BLOCK_SCALAR_HEADER_PATTERN.'$/', $value, $matches)) {\n            $modifiers = $matches['modifiers'] ?? '';\n\n            $data = $this->parseBlockScalar($matches['separator'], preg_replace('#\\d+#', '', $modifiers), abs((int) $modifiers));\n\n            if ('' !== $matches['tag'] && '!' !== $matches['tag']) {\n                if ('!!binary' === $matches['tag']) {\n                    return Inline::evaluateBinaryScalar($data);\n                }\n\n                return new TaggedValue(substr($matches['tag'], 1), $data);\n            }\n\n            return $data;\n        }\n\n        try {\n            if ('' !== $value && '{' === $value[0]) {\n                $cursor = \\strlen(rtrim($this->currentLine)) - \\strlen(rtrim($value));\n\n                return Inline::parse($this->lexInlineMapping($cursor), $flags, $this->refs);\n            } elseif ('' !== $value && '[' === $value[0]) {\n                $cursor = \\strlen(rtrim($this->currentLine)) - \\strlen(rtrim($value));\n\n                return Inline::parse($this->lexInlineSequence($cursor), $flags, $this->refs);\n            }\n\n            switch ($value[0] ?? '') {\n                case '\"':\n                case \"'\":\n                    $cursor = \\strlen(rtrim($this->currentLine)) - \\strlen(rtrim($value));\n                    $parsedValue = Inline::parse($this->lexInlineQuotedString($cursor), $flags, $this->refs);\n\n                    if (isset($this->currentLine[$cursor]) && preg_replace('/\\s*(#.*)?$/A', '', substr($this->currentLine, $cursor))) {\n                        throw new ParseException(\\sprintf('Unexpected characters near \"%s\".', substr($this->currentLine, $cursor)));\n                    }\n\n                    return $parsedValue;\n                default:\n                    $lines = [];\n\n                    while ($this->moveToNextLine()) {\n                        // unquoted strings end before the first unindented line\n                        if (0 === $this->getCurrentLineIndentation()) {\n                            $this->moveToPreviousLine();\n\n                            break;\n                        }\n\n                        $lines[] = trim($this->currentLine);\n                    }\n\n                    for ($i = 0, $linesCount = \\count($lines), $previousLineBlank = false; $i < $linesCount; ++$i) {\n                        if ('' === $lines[$i]) {\n                            $value .= \"\\n\";\n                            $previousLineBlank = true;\n                        } elseif ($previousLineBlank) {\n                            $value .= $lines[$i];\n                            $previousLineBlank = false;\n                        } else {\n                            $value .= ' '.$lines[$i];\n                            $previousLineBlank = false;\n                        }\n                    }\n\n                    Inline::$parsedLineNumber = $this->getRealCurrentLineNb();\n\n                    $parsedValue = Inline::parse($value, $flags, $this->refs);\n\n                    if ('mapping' === $context && \\is_string($parsedValue) && '\"' !== $value[0] && \"'\" !== $value[0] && '[' !== $value[0] && '{' !== $value[0] && '!' !== $value[0] && str_contains($parsedValue, ': ')) {\n                        throw new ParseException('A colon cannot be used in an unquoted mapping value.', $this->getRealCurrentLineNb() + 1, $value, $this->filename);\n                    }\n\n                    return $parsedValue;\n            }\n        } catch (ParseException $e) {\n            $e->setParsedLine($this->getRealCurrentLineNb() + 1);\n            $e->setSnippet($this->currentLine);\n\n            throw $e;\n        }\n    }\n\n    /**\n     * Parses a block scalar.\n     *\n     * @param string $style       The style indicator that was used to begin this block scalar (| or >)\n     * @param string $chomping    The chomping indicator that was used to begin this block scalar (+ or -)\n     * @param int    $indentation The indentation indicator that was used to begin this block scalar\n     */\n    private function parseBlockScalar(string $style, string $chomping = '', int $indentation = 0): string\n    {\n        $notEOF = $this->moveToNextLine();\n        if (!$notEOF) {\n            return '';\n        }\n\n        $isCurrentLineBlank = $this->isCurrentLineBlank();\n        $blockLines = [];\n\n        // leading blank lines are consumed before determining indentation\n        while ($notEOF && $isCurrentLineBlank) {\n            // newline only if not EOF\n            if ($notEOF = $this->moveToNextLine()) {\n                $blockLines[] = '';\n                $isCurrentLineBlank = $this->isCurrentLineBlank();\n            }\n        }\n\n        // determine indentation if not specified\n        if (0 === $indentation) {\n            $currentLineLength = \\strlen($this->currentLine);\n\n            for ($i = 0; $i < $currentLineLength && ' ' === $this->currentLine[$i]; ++$i) {\n                ++$indentation;\n            }\n        }\n\n        if ($indentation > 0) {\n            $pattern = \\sprintf('/^ {%d}(.*)$/', $indentation);\n\n            while (\n                $notEOF && (\n                    $isCurrentLineBlank\n                    || self::preg_match($pattern, $this->currentLine, $matches)\n                )\n            ) {\n                if ($isCurrentLineBlank && \\strlen($this->currentLine) > $indentation) {\n                    $blockLines[] = substr($this->currentLine, $indentation);\n                } elseif ($isCurrentLineBlank) {\n                    $blockLines[] = '';\n                } else {\n                    $blockLines[] = $matches[1];\n                }\n\n                // newline only if not EOF\n                if ($notEOF = $this->moveToNextLine()) {\n                    $isCurrentLineBlank = $this->isCurrentLineBlank();\n                }\n            }\n        } elseif ($notEOF) {\n            $blockLines[] = '';\n        }\n\n        if ($notEOF) {\n            $blockLines[] = '';\n            $this->moveToPreviousLine();\n        } elseif (!$this->isCurrentLineLastLineInDocument()) {\n            $blockLines[] = '';\n        }\n\n        // folded style\n        if ('>' === $style) {\n            $text = '';\n            $previousLineIndented = false;\n            $previousLineBlank = false;\n\n            for ($i = 0, $blockLinesCount = \\count($blockLines); $i < $blockLinesCount; ++$i) {\n                if ('' === $blockLines[$i]) {\n                    $text .= \"\\n\";\n                    $previousLineIndented = false;\n                    $previousLineBlank = true;\n                } elseif (' ' === $blockLines[$i][0]) {\n                    $text .= \"\\n\".$blockLines[$i];\n                    $previousLineIndented = true;\n                    $previousLineBlank = false;\n                } elseif ($previousLineIndented) {\n                    $text .= \"\\n\".$blockLines[$i];\n                    $previousLineIndented = false;\n                    $previousLineBlank = false;\n                } elseif ($previousLineBlank || 0 === $i) {\n                    $text .= $blockLines[$i];\n                    $previousLineIndented = false;\n                    $previousLineBlank = false;\n                } else {\n                    $text .= ' '.$blockLines[$i];\n                    $previousLineIndented = false;\n                    $previousLineBlank = false;\n                }\n            }\n        } else {\n            $text = implode(\"\\n\", $blockLines);\n        }\n\n        // deal with trailing newlines\n        if ('' === $chomping) {\n            $text = preg_replace('/\\n+$/', \"\\n\", $text);\n        } elseif ('-' === $chomping) {\n            $text = preg_replace('/\\n+$/', '', $text);\n        }\n\n        return $text;\n    }\n\n    /**\n     * Returns true if the next line is indented.\n     */\n    private function isNextLineIndented(): bool\n    {\n        $currentIndentation = $this->getCurrentLineIndentation();\n        $movements = 0;\n\n        do {\n            $EOF = !$this->moveToNextLine();\n\n            if (!$EOF) {\n                ++$movements;\n            }\n        } while (!$EOF && ($this->isCurrentLineEmpty() || $this->isCurrentLineComment()));\n\n        if ($EOF) {\n            for ($i = 0; $i < $movements; ++$i) {\n                $this->moveToPreviousLine();\n            }\n\n            return false;\n        }\n\n        $ret = $this->getCurrentLineIndentation() > $currentIndentation;\n\n        for ($i = 0; $i < $movements; ++$i) {\n            $this->moveToPreviousLine();\n        }\n\n        return $ret;\n    }\n\n    private function isCurrentLineEmpty(): bool\n    {\n        return $this->isCurrentLineBlank() || $this->isCurrentLineComment();\n    }\n\n    private function isCurrentLineBlank(): bool\n    {\n        return '' === $this->currentLine || '' === trim($this->currentLine, ' ');\n    }\n\n    private function isCurrentLineComment(): bool\n    {\n        // checking explicitly the first char of the trim is faster than loops or strpos\n        $ltrimmedLine = '' !== $this->currentLine && ' ' === $this->currentLine[0] ? ltrim($this->currentLine, ' ') : $this->currentLine;\n\n        return '' !== $ltrimmedLine && '#' === $ltrimmedLine[0];\n    }\n\n    private function isCurrentLineLastLineInDocument(): bool\n    {\n        return ($this->offset + $this->currentLineNb) >= ($this->totalNumberOfLines - 1);\n    }\n\n    private function cleanup(string $value): string\n    {\n        $value = str_replace([\"\\r\\n\", \"\\r\"], \"\\n\", $value);\n\n        // strip YAML header\n        $count = 0;\n        $value = preg_replace('#^\\%YAML[: ][\\d\\.]+.*\\n#u', '', $value, -1, $count);\n        $this->offset += $count;\n\n        // remove leading comments\n        $trimmedValue = preg_replace('#^(\\#.*?\\n)+#s', '', $value, -1, $count);\n        if (1 === $count) {\n            // items have been removed, update the offset\n            $this->offset += substr_count($value, \"\\n\") - substr_count($trimmedValue, \"\\n\");\n            $value = $trimmedValue;\n        }\n\n        // remove start of the document marker (---)\n        $trimmedValue = preg_replace('#^\\-\\-\\-.*?\\n#s', '', $value, -1, $count);\n        if (1 === $count) {\n            // items have been removed, update the offset\n            $this->offset += substr_count($value, \"\\n\") - substr_count($trimmedValue, \"\\n\");\n            $value = $trimmedValue;\n\n            // remove end of the document marker (...)\n            $value = preg_replace('#\\.\\.\\.\\s*$#', '', $value);\n        }\n\n        return $value;\n    }\n\n    private function isNextLineUnIndentedCollection(): bool\n    {\n        $currentIndentation = $this->getCurrentLineIndentation();\n        $movements = 0;\n\n        do {\n            $EOF = !$this->moveToNextLine();\n\n            if (!$EOF) {\n                ++$movements;\n            }\n        } while (!$EOF && ($this->isCurrentLineEmpty() || $this->isCurrentLineComment()));\n\n        if ($EOF) {\n            return false;\n        }\n\n        $ret = $this->getCurrentLineIndentation() === $currentIndentation && $this->isStringUnIndentedCollectionItem();\n\n        for ($i = 0; $i < $movements; ++$i) {\n            $this->moveToPreviousLine();\n        }\n\n        return $ret;\n    }\n\n    private function isStringUnIndentedCollectionItem(): bool\n    {\n        return '-' === rtrim($this->currentLine) || str_starts_with($this->currentLine, '- ');\n    }\n\n    /**\n     * A local wrapper for \"preg_match\" which will throw a ParseException if there\n     * is an internal error in the PCRE engine.\n     *\n     * This avoids us needing to check for \"false\" every time PCRE is used\n     * in the YAML engine\n     *\n     * @throws ParseException on a PCRE internal error\n     *\n     * @internal\n     */\n    public static function preg_match(string $pattern, string $subject, ?array &$matches = null, int $flags = 0, int $offset = 0): int\n    {\n        if (false === $ret = preg_match($pattern, $subject, $matches, $flags, $offset)) {\n            throw new ParseException(preg_last_error_msg());\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Trim the tag on top of the value.\n     *\n     * Prevent values such as \"!foo {quz: bar}\" to be considered as\n     * a mapping block.\n     */\n    private function trimTag(string $value): string\n    {\n        if ('!' === $value[0]) {\n            return ltrim(substr($value, 1, strcspn($value, \" \\r\\n\", 1)), ' ');\n        }\n\n        return $value;\n    }\n\n    private function getLineTag(string $value, int $flags, bool $nextLineCheck = true): ?string\n    {\n        if ('' === $value || '!' !== $value[0] || 1 !== self::preg_match('/^'.self::TAG_PATTERN.' *( +#.*)?$/', $value, $matches)) {\n            return null;\n        }\n\n        if ($nextLineCheck && !$this->isNextLineIndented()) {\n            return null;\n        }\n\n        $tag = substr($matches['tag'], 1);\n\n        // Built-in tags\n        if ($tag && '!' === $tag[0]) {\n            throw new ParseException(\\sprintf('The built-in tag \"!%s\" is not implemented.', $tag), $this->getRealCurrentLineNb() + 1, $value, $this->filename);\n        }\n\n        if (Yaml::PARSE_CUSTOM_TAGS & $flags) {\n            return $tag;\n        }\n\n        throw new ParseException(\\sprintf('Tags support is not enabled. You must use the flag \"Yaml::PARSE_CUSTOM_TAGS\" to use \"%s\".', $matches['tag']), $this->getRealCurrentLineNb() + 1, $value, $this->filename);\n    }\n\n    private function lexInlineQuotedString(int &$cursor = 0): string\n    {\n        $quotation = $this->currentLine[$cursor];\n        $value = $quotation;\n        ++$cursor;\n\n        $previousLineWasNewline = true;\n        $previousLineWasTerminatedWithBackslash = false;\n        $lineNumber = 0;\n\n        do {\n            if (++$lineNumber > 1) {\n                $cursor += strspn($this->currentLine, ' ', $cursor);\n            }\n\n            if ($this->isCurrentLineBlank()) {\n                $value .= \"\\n\";\n            } elseif (!$previousLineWasNewline && !$previousLineWasTerminatedWithBackslash) {\n                $value .= ' ';\n            }\n\n            for (; \\strlen($this->currentLine) > $cursor; ++$cursor) {\n                switch ($this->currentLine[$cursor]) {\n                    case '\\\\':\n                        if (\"'\" === $quotation) {\n                            $value .= '\\\\';\n                        } elseif (isset($this->currentLine[++$cursor])) {\n                            $value .= '\\\\'.$this->currentLine[$cursor];\n                        }\n\n                        break;\n                    case $quotation:\n                        ++$cursor;\n\n                        if (\"'\" === $quotation && isset($this->currentLine[$cursor]) && \"'\" === $this->currentLine[$cursor]) {\n                            $value .= \"''\";\n                            break;\n                        }\n\n                        return $value.$quotation;\n                    default:\n                        $value .= $this->currentLine[$cursor];\n                }\n            }\n\n            if ($this->isCurrentLineBlank()) {\n                $previousLineWasNewline = true;\n                $previousLineWasTerminatedWithBackslash = false;\n            } elseif ('\\\\' === $this->currentLine[-1]) {\n                $previousLineWasNewline = false;\n                $previousLineWasTerminatedWithBackslash = true;\n            } else {\n                $previousLineWasNewline = false;\n                $previousLineWasTerminatedWithBackslash = false;\n            }\n\n            if ($this->hasMoreLines()) {\n                $cursor = 0;\n            }\n        } while ($this->moveToNextLine());\n\n        throw new ParseException('Malformed inline YAML string.');\n    }\n\n    private function lexUnquotedString(int &$cursor): string\n    {\n        $offset = $cursor;\n        $cursor += strcspn($this->currentLine, '[]{},:', $cursor);\n\n        if ($cursor === $offset) {\n            throw new ParseException('Malformed unquoted YAML string.');\n        }\n\n        return substr($this->currentLine, $offset, $cursor - $offset);\n    }\n\n    private function lexInlineMapping(int &$cursor = 0, bool $consumeUntilEol = true): string\n    {\n        return $this->lexInlineStructure($cursor, '}', $consumeUntilEol);\n    }\n\n    private function lexInlineSequence(int &$cursor = 0, bool $consumeUntilEol = true): string\n    {\n        return $this->lexInlineStructure($cursor, ']', $consumeUntilEol);\n    }\n\n    private function lexInlineStructure(int &$cursor, string $closingTag, bool $consumeUntilEol = true): string\n    {\n        $value = $this->currentLine[$cursor];\n        ++$cursor;\n\n        do {\n            $this->consumeWhitespaces($cursor);\n\n            while (isset($this->currentLine[$cursor])) {\n                switch ($this->currentLine[$cursor]) {\n                    case '\"':\n                    case \"'\":\n                        $value .= $this->lexInlineQuotedString($cursor);\n                        break;\n                    case ':':\n                    case ',':\n                        $value .= $this->currentLine[$cursor];\n                        ++$cursor;\n                        break;\n                    case '{':\n                        $value .= $this->lexInlineMapping($cursor, false);\n                        break;\n                    case '[':\n                        $value .= $this->lexInlineSequence($cursor, false);\n                        break;\n                    case $closingTag:\n                        $value .= $this->currentLine[$cursor];\n                        ++$cursor;\n\n                        if ($consumeUntilEol && isset($this->currentLine[$cursor]) && ($whitespaces = strspn($this->currentLine, ' ', $cursor) + $cursor) < strlen($this->currentLine) && '#' !== $this->currentLine[$whitespaces]) {\n                            throw new ParseException(sprintf('Unexpected token \"%s\".', trim(substr($this->currentLine, $cursor))));\n                        }\n\n                        return $value;\n                    case '#':\n                        break 2;\n                    default:\n                        $value .= $this->lexUnquotedString($cursor);\n                }\n\n                if ($this->consumeWhitespaces($cursor)) {\n                    $value .= ' ';\n                }\n            }\n\n            if ($this->hasMoreLines()) {\n                $cursor = 0;\n            }\n        } while ($this->moveToNextLine());\n\n        throw new ParseException('Malformed inline YAML string.');\n    }\n\n    private function consumeWhitespaces(int &$cursor): bool\n    {\n        $whitespacesConsumed = 0;\n\n        do {\n            $whitespaceOnlyTokenLength = strspn($this->currentLine, ' ', $cursor);\n            $whitespacesConsumed += $whitespaceOnlyTokenLength;\n            $cursor += $whitespaceOnlyTokenLength;\n\n            if (isset($this->currentLine[$cursor])) {\n                return 0 < $whitespacesConsumed;\n            }\n\n            if ($this->hasMoreLines()) {\n                $cursor = 0;\n            }\n        } while ($this->moveToNextLine());\n\n        return 0 < $whitespacesConsumed;\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.44140625,
          "content": "Yaml Component\n==============\n\nThe Yaml component loads and dumps YAML files.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/yaml.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tag",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "Unescaper.php",
          "type": "blob",
          "size": 3.0517578125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Yaml;\n\nuse Symfony\\Component\\Yaml\\Exception\\ParseException;\n\n/**\n * Unescaper encapsulates unescaping rules for single and double-quoted\n * YAML strings.\n *\n * @author Matthew Lewinski <matthew@lewinski.org>\n *\n * @internal\n */\nclass Unescaper\n{\n    /**\n     * Regex fragment that matches an escaped character in a double quoted string.\n     */\n    public const REGEX_ESCAPED_CHARACTER = '\\\\\\\\(x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8}|.)';\n\n    /**\n     * Unescapes a single quoted string.\n     *\n     * @param string $value A single quoted string\n     */\n    public function unescapeSingleQuotedString(string $value): string\n    {\n        return str_replace('\\'\\'', '\\'', $value);\n    }\n\n    /**\n     * Unescapes a double quoted string.\n     *\n     * @param string $value A double quoted string\n     */\n    public function unescapeDoubleQuotedString(string $value): string\n    {\n        $callback = fn ($match) => $this->unescapeCharacter($match[0]);\n\n        // evaluate the string\n        return preg_replace_callback('/'.self::REGEX_ESCAPED_CHARACTER.'/u', $callback, $value);\n    }\n\n    /**\n     * Unescapes a character that was found in a double-quoted string.\n     *\n     * @param string $value An escaped character\n     */\n    private function unescapeCharacter(string $value): string\n    {\n        return match ($value[1]) {\n            '0' => \"\\x0\",\n            'a' => \"\\x7\",\n            'b' => \"\\x8\",\n            't' => \"\\t\",\n            \"\\t\" => \"\\t\",\n            'n' => \"\\n\",\n            'v' => \"\\xB\",\n            'f' => \"\\xC\",\n            'r' => \"\\r\",\n            'e' => \"\\x1B\",\n            ' ' => ' ',\n            '\"' => '\"',\n            '/' => '/',\n            '\\\\' => '\\\\',\n            // U+0085 NEXT LINE\n            'N' => \"\\xC2\\x85\",\n            // U+00A0 NO-BREAK SPACE\n            '_' => \"\\xC2\\xA0\",\n            // U+2028 LINE SEPARATOR\n            'L' => \"\\xE2\\x80\\xA8\",\n            // U+2029 PARAGRAPH SEPARATOR\n            'P' => \"\\xE2\\x80\\xA9\",\n            'x' => self::utf8chr(hexdec(substr($value, 2, 2))),\n            'u' => self::utf8chr(hexdec(substr($value, 2, 4))),\n            'U' => self::utf8chr(hexdec(substr($value, 2, 8))),\n            default => throw new ParseException(\\sprintf('Found unknown escape character \"%s\".', $value)),\n        };\n    }\n\n    /**\n     * Get the UTF-8 character for the given code point.\n     */\n    private static function utf8chr(int $c): string\n    {\n        if (0x80 > $c %= 0x200000) {\n            return \\chr($c);\n        }\n        if (0x800 > $c) {\n            return \\chr(0xC0 | $c >> 6).\\chr(0x80 | $c & 0x3F);\n        }\n        if (0x10000 > $c) {\n            return \\chr(0xE0 | $c >> 12).\\chr(0x80 | $c >> 6 & 0x3F).\\chr(0x80 | $c & 0x3F);\n        }\n\n        return \\chr(0xF0 | $c >> 18).\\chr(0x80 | $c >> 12 & 0x3F).\\chr(0x80 | $c >> 6 & 0x3F).\\chr(0x80 | $c & 0x3F);\n    }\n}\n"
        },
        {
          "name": "Yaml.php",
          "type": "blob",
          "size": 3.0322265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Yaml;\n\nuse Symfony\\Component\\Yaml\\Exception\\ParseException;\n\n/**\n * Yaml offers convenience methods to load and dump YAML.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @final\n */\nclass Yaml\n{\n    public const DUMP_OBJECT = 1;\n    public const PARSE_EXCEPTION_ON_INVALID_TYPE = 2;\n    public const PARSE_OBJECT = 4;\n    public const PARSE_OBJECT_FOR_MAP = 8;\n    public const DUMP_EXCEPTION_ON_INVALID_TYPE = 16;\n    public const PARSE_DATETIME = 32;\n    public const DUMP_OBJECT_AS_MAP = 64;\n    public const DUMP_MULTI_LINE_LITERAL_BLOCK = 128;\n    public const PARSE_CONSTANT = 256;\n    public const PARSE_CUSTOM_TAGS = 512;\n    public const DUMP_EMPTY_ARRAY_AS_SEQUENCE = 1024;\n    public const DUMP_NULL_AS_TILDE = 2048;\n    public const DUMP_NUMERIC_KEY_AS_STRING = 4096;\n\n    /**\n     * Parses a YAML file into a PHP value.\n     *\n     * Usage:\n     *\n     *     $array = Yaml::parseFile('config.yml');\n     *     print_r($array);\n     *\n     * @param string                     $filename The path to the YAML file to be parsed\n     * @param int-mask-of<self::PARSE_*> $flags    A bit field of PARSE_* constants to customize the YAML parser behavior\n     *\n     * @throws ParseException If the file could not be read or the YAML is not valid\n     */\n    public static function parseFile(string $filename, int $flags = 0): mixed\n    {\n        $yaml = new Parser();\n\n        return $yaml->parseFile($filename, $flags);\n    }\n\n    /**\n     * Parses YAML into a PHP value.\n     *\n     *  Usage:\n     *  <code>\n     *   $array = Yaml::parse(file_get_contents('config.yml'));\n     *   print_r($array);\n     *  </code>\n     *\n     * @param string                     $input A string containing YAML\n     * @param int-mask-of<self::PARSE_*> $flags A bit field of PARSE_* constants to customize the YAML parser behavior\n     *\n     * @throws ParseException If the YAML is not valid\n     */\n    public static function parse(string $input, int $flags = 0): mixed\n    {\n        $yaml = new Parser();\n\n        return $yaml->parse($input, $flags);\n    }\n\n    /**\n     * Dumps a PHP value to a YAML string.\n     *\n     * The dump method, when supplied with an array, will do its best\n     * to convert the array into friendly YAML.\n     *\n     * @param mixed                     $input  The PHP value\n     * @param int                       $inline The level where you switch to inline YAML\n     * @param int                       $indent The amount of spaces to use for indentation of nested nodes\n     * @param int-mask-of<self::DUMP_*> $flags  A bit field of DUMP_* constants to customize the dumped YAML string\n     */\n    public static function dump(mixed $input, int $inline = 2, int $indent = 4, int $flags = 0): string\n    {\n        $yaml = new Dumper($indent);\n\n        return $yaml->dump($input, $inline, 0, $flags);\n    }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.9111328125,
          "content": "{\n    \"name\": \"symfony/yaml\",\n    \"type\": \"library\",\n    \"description\": \"Loads and dumps YAML files\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3.0\",\n        \"symfony/polyfill-ctype\": \"^1.8\"\n    },\n    \"require-dev\": {\n        \"symfony/console\": \"^6.4|^7.0\"\n    },\n    \"conflict\": {\n        \"symfony/console\": \"<6.4\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Yaml\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"bin\": [\n        \"Resources/bin/yaml-lint\"\n    ],\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.7958984375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Yaml Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}