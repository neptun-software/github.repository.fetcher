{
  "metadata": {
    "timestamp": 1736711898446,
    "page": 272,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "illuminate/database",
      "stars": 2699,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.05078125,
          "content": "/.github export-ignore\n.gitattributes export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "Capsule",
          "type": "tree",
          "content": null
        },
        {
          "name": "ClassMorphViolationException.php",
          "type": "blob",
          "size": 0.5126953125,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse RuntimeException;\n\nclass ClassMorphViolationException extends RuntimeException\n{\n    /**\n     * The name of the affected Eloquent model.\n     *\n     * @var string\n     */\n    public $model;\n\n    /**\n     * Create a new exception instance.\n     *\n     * @param  object  $model\n     */\n    public function __construct($model)\n    {\n        $class = get_class($model);\n\n        parent::__construct(\"No morph map defined for model [{$class}].\");\n\n        $this->model = $class;\n    }\n}\n"
        },
        {
          "name": "Concerns",
          "type": "tree",
          "content": null
        },
        {
          "name": "ConfigurationUrlParser.php",
          "type": "blob",
          "size": 0.1875,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Illuminate\\Support\\ConfigurationUrlParser as BaseConfigurationUrlParser;\n\nclass ConfigurationUrlParser extends BaseConfigurationUrlParser\n{\n    //\n}\n"
        },
        {
          "name": "Connection.php",
          "type": "blob",
          "size": 41.7763671875,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Carbon\\CarbonInterval;\nuse Closure;\nuse DateTimeInterface;\nuse Exception;\nuse Illuminate\\Contracts\\Events\\Dispatcher;\nuse Illuminate\\Database\\Events\\QueryExecuted;\nuse Illuminate\\Database\\Events\\StatementPrepared;\nuse Illuminate\\Database\\Events\\TransactionBeginning;\nuse Illuminate\\Database\\Events\\TransactionCommitted;\nuse Illuminate\\Database\\Events\\TransactionCommitting;\nuse Illuminate\\Database\\Events\\TransactionRolledBack;\nuse Illuminate\\Database\\Query\\Builder as QueryBuilder;\nuse Illuminate\\Database\\Query\\Expression;\nuse Illuminate\\Database\\Query\\Grammars\\Grammar as QueryGrammar;\nuse Illuminate\\Database\\Query\\Processors\\Processor;\nuse Illuminate\\Database\\Schema\\Builder as SchemaBuilder;\nuse Illuminate\\Support\\Arr;\nuse Illuminate\\Support\\InteractsWithTime;\nuse Illuminate\\Support\\Traits\\Macroable;\nuse PDO;\nuse PDOStatement;\nuse RuntimeException;\n\nclass Connection implements ConnectionInterface\n{\n    use DetectsConcurrencyErrors,\n        DetectsLostConnections,\n        Concerns\\ManagesTransactions,\n        InteractsWithTime,\n        Macroable;\n\n    /**\n     * The active PDO connection.\n     *\n     * @var \\PDO|\\Closure\n     */\n    protected $pdo;\n\n    /**\n     * The active PDO connection used for reads.\n     *\n     * @var \\PDO|\\Closure\n     */\n    protected $readPdo;\n\n    /**\n     * The name of the connected database.\n     *\n     * @var string\n     */\n    protected $database;\n\n    /**\n     * The type of the connection.\n     *\n     * @var string|null\n     */\n    protected $readWriteType;\n\n    /**\n     * The table prefix for the connection.\n     *\n     * @var string\n     */\n    protected $tablePrefix = '';\n\n    /**\n     * The database connection configuration options.\n     *\n     * @var array\n     */\n    protected $config = [];\n\n    /**\n     * The reconnector instance for the connection.\n     *\n     * @var callable\n     */\n    protected $reconnector;\n\n    /**\n     * The query grammar implementation.\n     *\n     * @var \\Illuminate\\Database\\Query\\Grammars\\Grammar\n     */\n    protected $queryGrammar;\n\n    /**\n     * The schema grammar implementation.\n     *\n     * @var \\Illuminate\\Database\\Schema\\Grammars\\Grammar\n     */\n    protected $schemaGrammar;\n\n    /**\n     * The query post processor implementation.\n     *\n     * @var \\Illuminate\\Database\\Query\\Processors\\Processor\n     */\n    protected $postProcessor;\n\n    /**\n     * The event dispatcher instance.\n     *\n     * @var \\Illuminate\\Contracts\\Events\\Dispatcher|null\n     */\n    protected $events;\n\n    /**\n     * The default fetch mode of the connection.\n     *\n     * @var int\n     */\n    protected $fetchMode = PDO::FETCH_OBJ;\n\n    /**\n     * The number of active transactions.\n     *\n     * @var int\n     */\n    protected $transactions = 0;\n\n    /**\n     * The transaction manager instance.\n     *\n     * @var \\Illuminate\\Database\\DatabaseTransactionsManager|null\n     */\n    protected $transactionsManager;\n\n    /**\n     * Indicates if changes have been made to the database.\n     *\n     * @var bool\n     */\n    protected $recordsModified = false;\n\n    /**\n     * Indicates if the connection should use the \"write\" PDO connection.\n     *\n     * @var bool\n     */\n    protected $readOnWriteConnection = false;\n\n    /**\n     * All of the queries run against the connection.\n     *\n     * @var array\n     */\n    protected $queryLog = [];\n\n    /**\n     * Indicates whether queries are being logged.\n     *\n     * @var bool\n     */\n    protected $loggingQueries = false;\n\n    /**\n     * The duration of all executed queries in milliseconds.\n     *\n     * @var float\n     */\n    protected $totalQueryDuration = 0.0;\n\n    /**\n     * All of the registered query duration handlers.\n     *\n     * @var array\n     */\n    protected $queryDurationHandlers = [];\n\n    /**\n     * Indicates if the connection is in a \"dry run\".\n     *\n     * @var bool\n     */\n    protected $pretending = false;\n\n    /**\n     * All of the callbacks that should be invoked before a transaction is started.\n     *\n     * @var \\Closure[]\n     */\n    protected $beforeStartingTransaction = [];\n\n    /**\n     * All of the callbacks that should be invoked before a query is executed.\n     *\n     * @var \\Closure[]\n     */\n    protected $beforeExecutingCallbacks = [];\n\n    /**\n     * The connection resolvers.\n     *\n     * @var \\Closure[]\n     */\n    protected static $resolvers = [];\n\n    /**\n     * Create a new database connection instance.\n     *\n     * @param  \\PDO|\\Closure  $pdo\n     * @param  string  $database\n     * @param  string  $tablePrefix\n     * @param  array  $config\n     * @return void\n     */\n    public function __construct($pdo, $database = '', $tablePrefix = '', array $config = [])\n    {\n        $this->pdo = $pdo;\n\n        // First we will setup the default properties. We keep track of the DB\n        // name we are connected to since it is needed when some reflective\n        // type commands are run such as checking whether a table exists.\n        $this->database = $database;\n\n        $this->tablePrefix = $tablePrefix;\n\n        $this->config = $config;\n\n        // We need to initialize a query grammar and the query post processors\n        // which are both very important parts of the database abstractions\n        // so we initialize these to their default values while starting.\n        $this->useDefaultQueryGrammar();\n\n        $this->useDefaultPostProcessor();\n    }\n\n    /**\n     * Set the query grammar to the default implementation.\n     *\n     * @return void\n     */\n    public function useDefaultQueryGrammar()\n    {\n        $this->queryGrammar = $this->getDefaultQueryGrammar();\n    }\n\n    /**\n     * Get the default query grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Grammars\\Grammar\n     */\n    protected function getDefaultQueryGrammar()\n    {\n        ($grammar = new QueryGrammar)->setConnection($this);\n\n        return $grammar;\n    }\n\n    /**\n     * Set the schema grammar to the default implementation.\n     *\n     * @return void\n     */\n    public function useDefaultSchemaGrammar()\n    {\n        $this->schemaGrammar = $this->getDefaultSchemaGrammar();\n    }\n\n    /**\n     * Get the default schema grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Schema\\Grammars\\Grammar|null\n     */\n    protected function getDefaultSchemaGrammar()\n    {\n        //\n    }\n\n    /**\n     * Set the query post processor to the default implementation.\n     *\n     * @return void\n     */\n    public function useDefaultPostProcessor()\n    {\n        $this->postProcessor = $this->getDefaultPostProcessor();\n    }\n\n    /**\n     * Get the default post processor instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Processors\\Processor\n     */\n    protected function getDefaultPostProcessor()\n    {\n        return new Processor;\n    }\n\n    /**\n     * Get a schema builder instance for the connection.\n     *\n     * @return \\Illuminate\\Database\\Schema\\Builder\n     */\n    public function getSchemaBuilder()\n    {\n        if (is_null($this->schemaGrammar)) {\n            $this->useDefaultSchemaGrammar();\n        }\n\n        return new SchemaBuilder($this);\n    }\n\n    /**\n     * Begin a fluent query against a database table.\n     *\n     * @param  \\Closure|\\Illuminate\\Database\\Query\\Builder|\\Illuminate\\Contracts\\Database\\Query\\Expression|string  $table\n     * @param  string|null  $as\n     * @return \\Illuminate\\Database\\Query\\Builder\n     */\n    public function table($table, $as = null)\n    {\n        return $this->query()->from($table, $as);\n    }\n\n    /**\n     * Get a new query builder instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Builder\n     */\n    public function query()\n    {\n        return new QueryBuilder(\n            $this, $this->getQueryGrammar(), $this->getPostProcessor()\n        );\n    }\n\n    /**\n     * Run a select statement and return a single result.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  bool  $useReadPdo\n     * @return mixed\n     */\n    public function selectOne($query, $bindings = [], $useReadPdo = true)\n    {\n        $records = $this->select($query, $bindings, $useReadPdo);\n\n        return array_shift($records);\n    }\n\n    /**\n     * Run a select statement and return the first column of the first row.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  bool  $useReadPdo\n     * @return mixed\n     *\n     * @throws \\Illuminate\\Database\\MultipleColumnsSelectedException\n     */\n    public function scalar($query, $bindings = [], $useReadPdo = true)\n    {\n        $record = $this->selectOne($query, $bindings, $useReadPdo);\n\n        if (is_null($record)) {\n            return null;\n        }\n\n        $record = (array) $record;\n\n        if (count($record) > 1) {\n            throw new MultipleColumnsSelectedException;\n        }\n\n        return reset($record);\n    }\n\n    /**\n     * Run a select statement against the database.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @return array\n     */\n    public function selectFromWriteConnection($query, $bindings = [])\n    {\n        return $this->select($query, $bindings, false);\n    }\n\n    /**\n     * Run a select statement against the database.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  bool  $useReadPdo\n     * @return array\n     */\n    public function select($query, $bindings = [], $useReadPdo = true)\n    {\n        return $this->run($query, $bindings, function ($query, $bindings) use ($useReadPdo) {\n            if ($this->pretending()) {\n                return [];\n            }\n\n            // For select statements, we'll simply execute the query and return an array\n            // of the database result set. Each element in the array will be a single\n            // row from the database table, and will either be an array or objects.\n            $statement = $this->prepared(\n                $this->getPdoForSelect($useReadPdo)->prepare($query)\n            );\n\n            $this->bindValues($statement, $this->prepareBindings($bindings));\n\n            $statement->execute();\n\n            return $statement->fetchAll();\n        });\n    }\n\n    /**\n     * Run a select statement against the database and returns all of the result sets.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  bool  $useReadPdo\n     * @return array\n     */\n    public function selectResultSets($query, $bindings = [], $useReadPdo = true)\n    {\n        return $this->run($query, $bindings, function ($query, $bindings) use ($useReadPdo) {\n            if ($this->pretending()) {\n                return [];\n            }\n\n            $statement = $this->prepared(\n                $this->getPdoForSelect($useReadPdo)->prepare($query)\n            );\n\n            $this->bindValues($statement, $this->prepareBindings($bindings));\n\n            $statement->execute();\n\n            $sets = [];\n\n            do {\n                $sets[] = $statement->fetchAll();\n            } while ($statement->nextRowset());\n\n            return $sets;\n        });\n    }\n\n    /**\n     * Run a select statement against the database and returns a generator.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  bool  $useReadPdo\n     * @return \\Generator<int, \\stdClass>\n     */\n    public function cursor($query, $bindings = [], $useReadPdo = true)\n    {\n        $statement = $this->run($query, $bindings, function ($query, $bindings) use ($useReadPdo) {\n            if ($this->pretending()) {\n                return [];\n            }\n\n            // First we will create a statement for the query. Then, we will set the fetch\n            // mode and prepare the bindings for the query. Once that's done we will be\n            // ready to execute the query against the database and return the cursor.\n            $statement = $this->prepared($this->getPdoForSelect($useReadPdo)\n                              ->prepare($query));\n\n            $this->bindValues(\n                $statement, $this->prepareBindings($bindings)\n            );\n\n            // Next, we'll execute the query against the database and return the statement\n            // so we can return the cursor. The cursor will use a PHP generator to give\n            // back one row at a time without using a bunch of memory to render them.\n            $statement->execute();\n\n            return $statement;\n        });\n\n        while ($record = $statement->fetch()) {\n            yield $record;\n        }\n    }\n\n    /**\n     * Configure the PDO prepared statement.\n     *\n     * @param  \\PDOStatement  $statement\n     * @return \\PDOStatement\n     */\n    protected function prepared(PDOStatement $statement)\n    {\n        $statement->setFetchMode($this->fetchMode);\n\n        $this->event(new StatementPrepared($this, $statement));\n\n        return $statement;\n    }\n\n    /**\n     * Get the PDO connection to use for a select query.\n     *\n     * @param  bool  $useReadPdo\n     * @return \\PDO\n     */\n    protected function getPdoForSelect($useReadPdo = true)\n    {\n        return $useReadPdo ? $this->getReadPdo() : $this->getPdo();\n    }\n\n    /**\n     * Run an insert statement against the database.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @return bool\n     */\n    public function insert($query, $bindings = [])\n    {\n        return $this->statement($query, $bindings);\n    }\n\n    /**\n     * Run an update statement against the database.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @return int\n     */\n    public function update($query, $bindings = [])\n    {\n        return $this->affectingStatement($query, $bindings);\n    }\n\n    /**\n     * Run a delete statement against the database.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @return int\n     */\n    public function delete($query, $bindings = [])\n    {\n        return $this->affectingStatement($query, $bindings);\n    }\n\n    /**\n     * Execute an SQL statement and return the boolean result.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @return bool\n     */\n    public function statement($query, $bindings = [])\n    {\n        return $this->run($query, $bindings, function ($query, $bindings) {\n            if ($this->pretending()) {\n                return true;\n            }\n\n            $statement = $this->getPdo()->prepare($query);\n\n            $this->bindValues($statement, $this->prepareBindings($bindings));\n\n            $this->recordsHaveBeenModified();\n\n            return $statement->execute();\n        });\n    }\n\n    /**\n     * Run an SQL statement and get the number of rows affected.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @return int\n     */\n    public function affectingStatement($query, $bindings = [])\n    {\n        return $this->run($query, $bindings, function ($query, $bindings) {\n            if ($this->pretending()) {\n                return 0;\n            }\n\n            // For update or delete statements, we want to get the number of rows affected\n            // by the statement and return that back to the developer. We'll first need\n            // to execute the statement and then we'll use PDO to fetch the affected.\n            $statement = $this->getPdo()->prepare($query);\n\n            $this->bindValues($statement, $this->prepareBindings($bindings));\n\n            $statement->execute();\n\n            $this->recordsHaveBeenModified(\n                ($count = $statement->rowCount()) > 0\n            );\n\n            return $count;\n        });\n    }\n\n    /**\n     * Run a raw, unprepared query against the PDO connection.\n     *\n     * @param  string  $query\n     * @return bool\n     */\n    public function unprepared($query)\n    {\n        return $this->run($query, [], function ($query) {\n            if ($this->pretending()) {\n                return true;\n            }\n\n            $this->recordsHaveBeenModified(\n                $change = $this->getPdo()->exec($query) !== false\n            );\n\n            return $change;\n        });\n    }\n\n    /**\n     * Get the number of open connections for the database.\n     *\n     * @return int|null\n     */\n    public function threadCount()\n    {\n        $query = $this->getQueryGrammar()->compileThreadCount();\n\n        return $query ? $this->scalar($query) : null;\n    }\n\n    /**\n     * Execute the given callback in \"dry run\" mode.\n     *\n     * @param  \\Closure  $callback\n     * @return array\n     */\n    public function pretend(Closure $callback)\n    {\n        return $this->withFreshQueryLog(function () use ($callback) {\n            $this->pretending = true;\n\n            // Basically to make the database connection \"pretend\", we will just return\n            // the default values for all the query methods, then we will return an\n            // array of queries that were \"executed\" within the Closure callback.\n            $callback($this);\n\n            $this->pretending = false;\n\n            return $this->queryLog;\n        });\n    }\n\n    /**\n     * Execute the given callback without \"pretending\".\n     *\n     * @param  \\Closure  $callback\n     * @return mixed\n     */\n    public function withoutPretending(Closure $callback)\n    {\n        if (! $this->pretending) {\n            return $callback();\n        }\n\n        $this->pretending = false;\n\n        try {\n            return $callback();\n        } finally {\n            $this->pretending = true;\n        }\n    }\n\n    /**\n     * Execute the given callback in \"dry run\" mode.\n     *\n     * @param  \\Closure  $callback\n     * @return array\n     */\n    protected function withFreshQueryLog($callback)\n    {\n        $loggingQueries = $this->loggingQueries;\n\n        // First we will back up the value of the logging queries property and then\n        // we'll be ready to run callbacks. This query log will also get cleared\n        // so we will have a new log of all the queries that are executed now.\n        $this->enableQueryLog();\n\n        $this->queryLog = [];\n\n        // Now we'll execute this callback and capture the result. Once it has been\n        // executed we will restore the value of query logging and give back the\n        // value of the callback so the original callers can have the results.\n        $result = $callback();\n\n        $this->loggingQueries = $loggingQueries;\n\n        return $result;\n    }\n\n    /**\n     * Bind values to their parameters in the given statement.\n     *\n     * @param  \\PDOStatement  $statement\n     * @param  array  $bindings\n     * @return void\n     */\n    public function bindValues($statement, $bindings)\n    {\n        foreach ($bindings as $key => $value) {\n            $statement->bindValue(\n                is_string($key) ? $key : $key + 1,\n                $value,\n                match (true) {\n                    is_int($value) => PDO::PARAM_INT,\n                    is_resource($value) => PDO::PARAM_LOB,\n                    default => PDO::PARAM_STR\n                },\n            );\n        }\n    }\n\n    /**\n     * Prepare the query bindings for execution.\n     *\n     * @param  array  $bindings\n     * @return array\n     */\n    public function prepareBindings(array $bindings)\n    {\n        $grammar = $this->getQueryGrammar();\n\n        foreach ($bindings as $key => $value) {\n            // We need to transform all instances of DateTimeInterface into the actual\n            // date string. Each query grammar maintains its own date string format\n            // so we'll just ask the grammar for the format to get from the date.\n            if ($value instanceof DateTimeInterface) {\n                $bindings[$key] = $value->format($grammar->getDateFormat());\n            } elseif (is_bool($value)) {\n                $bindings[$key] = (int) $value;\n            }\n        }\n\n        return $bindings;\n    }\n\n    /**\n     * Run a SQL statement and log its execution context.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  \\Closure  $callback\n     * @return mixed\n     *\n     * @throws \\Illuminate\\Database\\QueryException\n     */\n    protected function run($query, $bindings, Closure $callback)\n    {\n        foreach ($this->beforeExecutingCallbacks as $beforeExecutingCallback) {\n            $beforeExecutingCallback($query, $bindings, $this);\n        }\n\n        $this->reconnectIfMissingConnection();\n\n        $start = microtime(true);\n\n        // Here we will run this query. If an exception occurs we'll determine if it was\n        // caused by a connection that has been lost. If that is the cause, we'll try\n        // to re-establish connection and re-run the query with a fresh connection.\n        try {\n            $result = $this->runQueryCallback($query, $bindings, $callback);\n        } catch (QueryException $e) {\n            $result = $this->handleQueryException(\n                $e, $query, $bindings, $callback\n            );\n        }\n\n        // Once we have run the query we will calculate the time that it took to run and\n        // then log the query, bindings, and execution time so we will report them on\n        // the event that the developer needs them. We'll log time in milliseconds.\n        $this->logQuery(\n            $query, $bindings, $this->getElapsedTime($start)\n        );\n\n        return $result;\n    }\n\n    /**\n     * Run a SQL statement.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  \\Closure  $callback\n     * @return mixed\n     *\n     * @throws \\Illuminate\\Database\\QueryException\n     */\n    protected function runQueryCallback($query, $bindings, Closure $callback)\n    {\n        // To execute the statement, we'll simply call the callback, which will actually\n        // run the SQL against the PDO connection. Then we can calculate the time it\n        // took to execute and log the query SQL, bindings and time in our memory.\n        try {\n            return $callback($query, $bindings);\n        }\n\n        // If an exception occurs when attempting to run a query, we'll format the error\n        // message to include the bindings with SQL, which will make this exception a\n        // lot more helpful to the developer instead of just the database's errors.\n        catch (Exception $e) {\n            if ($this->isUniqueConstraintError($e)) {\n                throw new UniqueConstraintViolationException(\n                    $this->getName(), $query, $this->prepareBindings($bindings), $e\n                );\n            }\n\n            throw new QueryException(\n                $this->getName(), $query, $this->prepareBindings($bindings), $e\n            );\n        }\n    }\n\n    /**\n     * Determine if the given database exception was caused by a unique constraint violation.\n     *\n     * @param  \\Exception  $exception\n     * @return bool\n     */\n    protected function isUniqueConstraintError(Exception $exception)\n    {\n        return false;\n    }\n\n    /**\n     * Log a query in the connection's query log.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  float|null  $time\n     * @return void\n     */\n    public function logQuery($query, $bindings, $time = null)\n    {\n        $this->totalQueryDuration += $time ?? 0.0;\n\n        $this->event(new QueryExecuted($query, $bindings, $time, $this));\n\n        $query = $this->pretending === true\n            ? $this->queryGrammar?->substituteBindingsIntoRawSql($query, $bindings) ?? $query\n            : $query;\n\n        if ($this->loggingQueries) {\n            $this->queryLog[] = compact('query', 'bindings', 'time');\n        }\n    }\n\n    /**\n     * Get the elapsed time since a given starting point.\n     *\n     * @param  float  $start\n     * @return float\n     */\n    protected function getElapsedTime($start)\n    {\n        return round((microtime(true) - $start) * 1000, 2);\n    }\n\n    /**\n     * Register a callback to be invoked when the connection queries for longer than a given amount of time.\n     *\n     * @param  \\DateTimeInterface|\\Carbon\\CarbonInterval|float|int  $threshold\n     * @param  callable  $handler\n     * @return void\n     */\n    public function whenQueryingForLongerThan($threshold, $handler)\n    {\n        $threshold = $threshold instanceof DateTimeInterface\n            ? $this->secondsUntil($threshold) * 1000\n            : $threshold;\n\n        $threshold = $threshold instanceof CarbonInterval\n            ? $threshold->totalMilliseconds\n            : $threshold;\n\n        $this->queryDurationHandlers[] = [\n            'has_run' => false,\n            'handler' => $handler,\n        ];\n\n        $key = count($this->queryDurationHandlers) - 1;\n\n        $this->listen(function ($event) use ($threshold, $handler, $key) {\n            if (! $this->queryDurationHandlers[$key]['has_run'] && $this->totalQueryDuration() > $threshold) {\n                $handler($this, $event);\n\n                $this->queryDurationHandlers[$key]['has_run'] = true;\n            }\n        });\n    }\n\n    /**\n     * Allow all the query duration handlers to run again, even if they have already run.\n     *\n     * @return void\n     */\n    public function allowQueryDurationHandlersToRunAgain()\n    {\n        foreach ($this->queryDurationHandlers as $key => $queryDurationHandler) {\n            $this->queryDurationHandlers[$key]['has_run'] = false;\n        }\n    }\n\n    /**\n     * Get the duration of all run queries in milliseconds.\n     *\n     * @return float\n     */\n    public function totalQueryDuration()\n    {\n        return $this->totalQueryDuration;\n    }\n\n    /**\n     * Reset the duration of all run queries.\n     *\n     * @return void\n     */\n    public function resetTotalQueryDuration()\n    {\n        $this->totalQueryDuration = 0.0;\n    }\n\n    /**\n     * Handle a query exception.\n     *\n     * @param  \\Illuminate\\Database\\QueryException  $e\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  \\Closure  $callback\n     * @return mixed\n     *\n     * @throws \\Illuminate\\Database\\QueryException\n     */\n    protected function handleQueryException(QueryException $e, $query, $bindings, Closure $callback)\n    {\n        if ($this->transactions >= 1) {\n            throw $e;\n        }\n\n        return $this->tryAgainIfCausedByLostConnection(\n            $e, $query, $bindings, $callback\n        );\n    }\n\n    /**\n     * Handle a query exception that occurred during query execution.\n     *\n     * @param  \\Illuminate\\Database\\QueryException  $e\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  \\Closure  $callback\n     * @return mixed\n     *\n     * @throws \\Illuminate\\Database\\QueryException\n     */\n    protected function tryAgainIfCausedByLostConnection(QueryException $e, $query, $bindings, Closure $callback)\n    {\n        if ($this->causedByLostConnection($e->getPrevious())) {\n            $this->reconnect();\n\n            return $this->runQueryCallback($query, $bindings, $callback);\n        }\n\n        throw $e;\n    }\n\n    /**\n     * Reconnect to the database.\n     *\n     * @return mixed|false\n     *\n     * @throws \\Illuminate\\Database\\LostConnectionException\n     */\n    public function reconnect()\n    {\n        if (is_callable($this->reconnector)) {\n            return call_user_func($this->reconnector, $this);\n        }\n\n        throw new LostConnectionException('Lost connection and no reconnector available.');\n    }\n\n    /**\n     * Reconnect to the database if a PDO connection is missing.\n     *\n     * @return void\n     */\n    public function reconnectIfMissingConnection()\n    {\n        if (is_null($this->pdo)) {\n            $this->reconnect();\n        }\n    }\n\n    /**\n     * Disconnect from the underlying PDO connection.\n     *\n     * @return void\n     */\n    public function disconnect()\n    {\n        $this->setPdo(null)->setReadPdo(null);\n    }\n\n    /**\n     * Register a hook to be run just before a database transaction is started.\n     *\n     * @param  \\Closure  $callback\n     * @return $this\n     */\n    public function beforeStartingTransaction(Closure $callback)\n    {\n        $this->beforeStartingTransaction[] = $callback;\n\n        return $this;\n    }\n\n    /**\n     * Register a hook to be run just before a database query is executed.\n     *\n     * @param  \\Closure  $callback\n     * @return $this\n     */\n    public function beforeExecuting(Closure $callback)\n    {\n        $this->beforeExecutingCallbacks[] = $callback;\n\n        return $this;\n    }\n\n    /**\n     * Register a database query listener with the connection.\n     *\n     * @param  \\Closure  $callback\n     * @return void\n     */\n    public function listen(Closure $callback)\n    {\n        $this->events?->listen(Events\\QueryExecuted::class, $callback);\n    }\n\n    /**\n     * Fire an event for this connection.\n     *\n     * @param  string  $event\n     * @return array|null\n     */\n    protected function fireConnectionEvent($event)\n    {\n        return $this->events?->dispatch(match ($event) {\n            'beganTransaction' => new TransactionBeginning($this),\n            'committed' => new TransactionCommitted($this),\n            'committing' => new TransactionCommitting($this),\n            'rollingBack' => new TransactionRolledBack($this),\n            default => null,\n        });\n    }\n\n    /**\n     * Fire the given event if possible.\n     *\n     * @param  mixed  $event\n     * @return void\n     */\n    protected function event($event)\n    {\n        $this->events?->dispatch($event);\n    }\n\n    /**\n     * Get a new raw query expression.\n     *\n     * @param  mixed  $value\n     * @return \\Illuminate\\Contracts\\Database\\Query\\Expression\n     */\n    public function raw($value)\n    {\n        return new Expression($value);\n    }\n\n    /**\n     * Escape a value for safe SQL embedding.\n     *\n     * @param  string|float|int|bool|null  $value\n     * @param  bool  $binary\n     * @return string\n     */\n    public function escape($value, $binary = false)\n    {\n        if ($value === null) {\n            return 'null';\n        } elseif ($binary) {\n            return $this->escapeBinary($value);\n        } elseif (is_int($value) || is_float($value)) {\n            return (string) $value;\n        } elseif (is_bool($value)) {\n            return $this->escapeBool($value);\n        } elseif (is_array($value)) {\n            throw new RuntimeException('The database connection does not support escaping arrays.');\n        } else {\n            if (str_contains($value, \"\\00\")) {\n                throw new RuntimeException('Strings with null bytes cannot be escaped. Use the binary escape option.');\n            }\n\n            if (preg_match('//u', $value) === false) {\n                throw new RuntimeException('Strings with invalid UTF-8 byte sequences cannot be escaped.');\n            }\n\n            return $this->escapeString($value);\n        }\n    }\n\n    /**\n     * Escape a string value for safe SQL embedding.\n     *\n     * @param  string  $value\n     * @return string\n     */\n    protected function escapeString($value)\n    {\n        return $this->getReadPdo()->quote($value);\n    }\n\n    /**\n     * Escape a boolean value for safe SQL embedding.\n     *\n     * @param  bool  $value\n     * @return string\n     */\n    protected function escapeBool($value)\n    {\n        return $value ? '1' : '0';\n    }\n\n    /**\n     * Escape a binary value for safe SQL embedding.\n     *\n     * @param  string  $value\n     * @return string\n     */\n    protected function escapeBinary($value)\n    {\n        throw new RuntimeException('The database connection does not support escaping binary values.');\n    }\n\n    /**\n     * Determine if the database connection has modified any database records.\n     *\n     * @return bool\n     */\n    public function hasModifiedRecords()\n    {\n        return $this->recordsModified;\n    }\n\n    /**\n     * Indicate if any records have been modified.\n     *\n     * @param  bool  $value\n     * @return void\n     */\n    public function recordsHaveBeenModified($value = true)\n    {\n        if (! $this->recordsModified) {\n            $this->recordsModified = $value;\n        }\n    }\n\n    /**\n     * Set the record modification state.\n     *\n     * @param  bool  $value\n     * @return $this\n     */\n    public function setRecordModificationState(bool $value)\n    {\n        $this->recordsModified = $value;\n\n        return $this;\n    }\n\n    /**\n     * Reset the record modification state.\n     *\n     * @return void\n     */\n    public function forgetRecordModificationState()\n    {\n        $this->recordsModified = false;\n    }\n\n    /**\n     * Indicate that the connection should use the write PDO connection for reads.\n     *\n     * @param  bool  $value\n     * @return $this\n     */\n    public function useWriteConnectionWhenReading($value = true)\n    {\n        $this->readOnWriteConnection = $value;\n\n        return $this;\n    }\n\n    /**\n     * Get the current PDO connection.\n     *\n     * @return \\PDO\n     */\n    public function getPdo()\n    {\n        if ($this->pdo instanceof Closure) {\n            return $this->pdo = call_user_func($this->pdo);\n        }\n\n        return $this->pdo;\n    }\n\n    /**\n     * Get the current PDO connection parameter without executing any reconnect logic.\n     *\n     * @return \\PDO|\\Closure|null\n     */\n    public function getRawPdo()\n    {\n        return $this->pdo;\n    }\n\n    /**\n     * Get the current PDO connection used for reading.\n     *\n     * @return \\PDO\n     */\n    public function getReadPdo()\n    {\n        if ($this->transactions > 0) {\n            return $this->getPdo();\n        }\n\n        if ($this->readOnWriteConnection ||\n            ($this->recordsModified && $this->getConfig('sticky'))) {\n            return $this->getPdo();\n        }\n\n        if ($this->readPdo instanceof Closure) {\n            return $this->readPdo = call_user_func($this->readPdo);\n        }\n\n        return $this->readPdo ?: $this->getPdo();\n    }\n\n    /**\n     * Get the current read PDO connection parameter without executing any reconnect logic.\n     *\n     * @return \\PDO|\\Closure|null\n     */\n    public function getRawReadPdo()\n    {\n        return $this->readPdo;\n    }\n\n    /**\n     * Set the PDO connection.\n     *\n     * @param  \\PDO|\\Closure|null  $pdo\n     * @return $this\n     */\n    public function setPdo($pdo)\n    {\n        $this->transactions = 0;\n\n        $this->pdo = $pdo;\n\n        return $this;\n    }\n\n    /**\n     * Set the PDO connection used for reading.\n     *\n     * @param  \\PDO|\\Closure|null  $pdo\n     * @return $this\n     */\n    public function setReadPdo($pdo)\n    {\n        $this->readPdo = $pdo;\n\n        return $this;\n    }\n\n    /**\n     * Set the reconnect instance on the connection.\n     *\n     * @param  callable  $reconnector\n     * @return $this\n     */\n    public function setReconnector(callable $reconnector)\n    {\n        $this->reconnector = $reconnector;\n\n        return $this;\n    }\n\n    /**\n     * Get the database connection name.\n     *\n     * @return string|null\n     */\n    public function getName()\n    {\n        return $this->getConfig('name');\n    }\n\n    /**\n     * Get the database connection full name.\n     *\n     * @return string|null\n     */\n    public function getNameWithReadWriteType()\n    {\n        return $this->getName().($this->readWriteType ? '::'.$this->readWriteType : '');\n    }\n\n    /**\n     * Get an option from the configuration options.\n     *\n     * @param  string|null  $option\n     * @return mixed\n     */\n    public function getConfig($option = null)\n    {\n        return Arr::get($this->config, $option);\n    }\n\n    /**\n     * Get the PDO driver name.\n     *\n     * @return string\n     */\n    public function getDriverName()\n    {\n        return $this->getConfig('driver');\n    }\n\n    /**\n     * Get a human-readable name for the given connection driver.\n     *\n     * @return string\n     */\n    public function getDriverTitle()\n    {\n        return $this->getDriverName();\n    }\n\n    /**\n     * Get the query grammar used by the connection.\n     *\n     * @return \\Illuminate\\Database\\Query\\Grammars\\Grammar\n     */\n    public function getQueryGrammar()\n    {\n        return $this->queryGrammar;\n    }\n\n    /**\n     * Set the query grammar used by the connection.\n     *\n     * @param  \\Illuminate\\Database\\Query\\Grammars\\Grammar  $grammar\n     * @return $this\n     */\n    public function setQueryGrammar(Query\\Grammars\\Grammar $grammar)\n    {\n        $this->queryGrammar = $grammar;\n\n        return $this;\n    }\n\n    /**\n     * Get the schema grammar used by the connection.\n     *\n     * @return \\Illuminate\\Database\\Schema\\Grammars\\Grammar\n     */\n    public function getSchemaGrammar()\n    {\n        return $this->schemaGrammar;\n    }\n\n    /**\n     * Set the schema grammar used by the connection.\n     *\n     * @param  \\Illuminate\\Database\\Schema\\Grammars\\Grammar  $grammar\n     * @return $this\n     */\n    public function setSchemaGrammar(Schema\\Grammars\\Grammar $grammar)\n    {\n        $this->schemaGrammar = $grammar;\n\n        return $this;\n    }\n\n    /**\n     * Get the query post processor used by the connection.\n     *\n     * @return \\Illuminate\\Database\\Query\\Processors\\Processor\n     */\n    public function getPostProcessor()\n    {\n        return $this->postProcessor;\n    }\n\n    /**\n     * Set the query post processor used by the connection.\n     *\n     * @param  \\Illuminate\\Database\\Query\\Processors\\Processor  $processor\n     * @return $this\n     */\n    public function setPostProcessor(Processor $processor)\n    {\n        $this->postProcessor = $processor;\n\n        return $this;\n    }\n\n    /**\n     * Get the event dispatcher used by the connection.\n     *\n     * @return \\Illuminate\\Contracts\\Events\\Dispatcher\n     */\n    public function getEventDispatcher()\n    {\n        return $this->events;\n    }\n\n    /**\n     * Set the event dispatcher instance on the connection.\n     *\n     * @param  \\Illuminate\\Contracts\\Events\\Dispatcher  $events\n     * @return $this\n     */\n    public function setEventDispatcher(Dispatcher $events)\n    {\n        $this->events = $events;\n\n        return $this;\n    }\n\n    /**\n     * Unset the event dispatcher for this connection.\n     *\n     * @return void\n     */\n    public function unsetEventDispatcher()\n    {\n        $this->events = null;\n    }\n\n    /**\n     * Set the transaction manager instance on the connection.\n     *\n     * @param  \\Illuminate\\Database\\DatabaseTransactionsManager  $manager\n     * @return $this\n     */\n    public function setTransactionManager($manager)\n    {\n        $this->transactionsManager = $manager;\n\n        return $this;\n    }\n\n    /**\n     * Unset the transaction manager for this connection.\n     *\n     * @return void\n     */\n    public function unsetTransactionManager()\n    {\n        $this->transactionsManager = null;\n    }\n\n    /**\n     * Determine if the connection is in a \"dry run\".\n     *\n     * @return bool\n     */\n    public function pretending()\n    {\n        return $this->pretending === true;\n    }\n\n    /**\n     * Get the connection query log.\n     *\n     * @return array\n     */\n    public function getQueryLog()\n    {\n        return $this->queryLog;\n    }\n\n    /**\n     * Get the connection query log with embedded bindings.\n     *\n     * @return array\n     */\n    public function getRawQueryLog()\n    {\n        return array_map(fn (array $log) => [\n            'raw_query' => $this->queryGrammar->substituteBindingsIntoRawSql(\n                $log['query'],\n                $this->prepareBindings($log['bindings'])\n            ),\n            'time' => $log['time'],\n        ], $this->getQueryLog());\n    }\n\n    /**\n     * Clear the query log.\n     *\n     * @return void\n     */\n    public function flushQueryLog()\n    {\n        $this->queryLog = [];\n    }\n\n    /**\n     * Enable the query log on the connection.\n     *\n     * @return void\n     */\n    public function enableQueryLog()\n    {\n        $this->loggingQueries = true;\n    }\n\n    /**\n     * Disable the query log on the connection.\n     *\n     * @return void\n     */\n    public function disableQueryLog()\n    {\n        $this->loggingQueries = false;\n    }\n\n    /**\n     * Determine whether we're logging queries.\n     *\n     * @return bool\n     */\n    public function logging()\n    {\n        return $this->loggingQueries;\n    }\n\n    /**\n     * Get the name of the connected database.\n     *\n     * @return string\n     */\n    public function getDatabaseName()\n    {\n        return $this->database;\n    }\n\n    /**\n     * Set the name of the connected database.\n     *\n     * @param  string  $database\n     * @return $this\n     */\n    public function setDatabaseName($database)\n    {\n        $this->database = $database;\n\n        return $this;\n    }\n\n    /**\n     * Set the read / write type of the connection.\n     *\n     * @param  string|null  $readWriteType\n     * @return $this\n     */\n    public function setReadWriteType($readWriteType)\n    {\n        $this->readWriteType = $readWriteType;\n\n        return $this;\n    }\n\n    /**\n     * Get the table prefix for the connection.\n     *\n     * @return string\n     */\n    public function getTablePrefix()\n    {\n        return $this->tablePrefix;\n    }\n\n    /**\n     * Set the table prefix in use by the connection.\n     *\n     * @param  string  $prefix\n     * @return $this\n     */\n    public function setTablePrefix($prefix)\n    {\n        $this->tablePrefix = $prefix;\n\n        $this->getQueryGrammar()->setTablePrefix($prefix);\n\n        return $this;\n    }\n\n    /**\n     * Set the table prefix and return the grammar.\n     *\n     * @template TGrammar of \\Illuminate\\Database\\Grammar\n     *\n     * @param  TGrammar  $grammar\n     * @return TGrammar\n     */\n    public function withTablePrefix(Grammar $grammar)\n    {\n        $grammar->setTablePrefix($this->tablePrefix);\n\n        return $grammar;\n    }\n\n    /**\n     * Execute the given callback without table prefix.\n     *\n     * @param  \\Closure  $callback\n     * @return void\n     */\n    public function withoutTablePrefix(Closure $callback): void\n    {\n        $tablePrefix = $this->getTablePrefix();\n\n        $this->setTablePrefix('');\n\n        $callback($this);\n\n        $this->setTablePrefix($tablePrefix);\n    }\n\n    /**\n     * Get the server version for the connection.\n     *\n     * @return string\n     */\n    public function getServerVersion(): string\n    {\n        return $this->getPdo()->getAttribute(PDO::ATTR_SERVER_VERSION);\n    }\n\n    /**\n     * Register a connection resolver.\n     *\n     * @param  string  $driver\n     * @param  \\Closure  $callback\n     * @return void\n     */\n    public static function resolverFor($driver, Closure $callback)\n    {\n        static::$resolvers[$driver] = $callback;\n    }\n\n    /**\n     * Get the connection resolver for the given driver.\n     *\n     * @param  string  $driver\n     * @return \\Closure|null\n     */\n    public static function getResolver($driver)\n    {\n        return static::$resolvers[$driver] ?? null;\n    }\n}\n"
        },
        {
          "name": "ConnectionInterface.php",
          "type": "blob",
          "size": 4.1640625,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Closure;\n\ninterface ConnectionInterface\n{\n    /**\n     * Begin a fluent query against a database table.\n     *\n     * @param  \\Closure|\\Illuminate\\Database\\Query\\Builder|string  $table\n     * @param  string|null  $as\n     * @return \\Illuminate\\Database\\Query\\Builder\n     */\n    public function table($table, $as = null);\n\n    /**\n     * Get a new raw query expression.\n     *\n     * @param  mixed  $value\n     * @return \\Illuminate\\Contracts\\Database\\Query\\Expression\n     */\n    public function raw($value);\n\n    /**\n     * Run a select statement and return a single result.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  bool  $useReadPdo\n     * @return mixed\n     */\n    public function selectOne($query, $bindings = [], $useReadPdo = true);\n\n    /**\n     * Run a select statement and return the first column of the first row.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  bool  $useReadPdo\n     * @return mixed\n     *\n     * @throws \\Illuminate\\Database\\MultipleColumnsSelectedException\n     */\n    public function scalar($query, $bindings = [], $useReadPdo = true);\n\n    /**\n     * Run a select statement against the database.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  bool  $useReadPdo\n     * @return array\n     */\n    public function select($query, $bindings = [], $useReadPdo = true);\n\n    /**\n     * Run a select statement against the database and returns a generator.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  bool  $useReadPdo\n     * @return \\Generator\n     */\n    public function cursor($query, $bindings = [], $useReadPdo = true);\n\n    /**\n     * Run an insert statement against the database.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @return bool\n     */\n    public function insert($query, $bindings = []);\n\n    /**\n     * Run an update statement against the database.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @return int\n     */\n    public function update($query, $bindings = []);\n\n    /**\n     * Run a delete statement against the database.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @return int\n     */\n    public function delete($query, $bindings = []);\n\n    /**\n     * Execute an SQL statement and return the boolean result.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @return bool\n     */\n    public function statement($query, $bindings = []);\n\n    /**\n     * Run an SQL statement and get the number of rows affected.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @return int\n     */\n    public function affectingStatement($query, $bindings = []);\n\n    /**\n     * Run a raw, unprepared query against the PDO connection.\n     *\n     * @param  string  $query\n     * @return bool\n     */\n    public function unprepared($query);\n\n    /**\n     * Prepare the query bindings for execution.\n     *\n     * @param  array  $bindings\n     * @return array\n     */\n    public function prepareBindings(array $bindings);\n\n    /**\n     * Execute a Closure within a transaction.\n     *\n     * @param  \\Closure  $callback\n     * @param  int  $attempts\n     * @return mixed\n     *\n     * @throws \\Throwable\n     */\n    public function transaction(Closure $callback, $attempts = 1);\n\n    /**\n     * Start a new database transaction.\n     *\n     * @return void\n     */\n    public function beginTransaction();\n\n    /**\n     * Commit the active database transaction.\n     *\n     * @return void\n     */\n    public function commit();\n\n    /**\n     * Rollback the active database transaction.\n     *\n     * @return void\n     */\n    public function rollBack();\n\n    /**\n     * Get the number of active transactions.\n     *\n     * @return int\n     */\n    public function transactionLevel();\n\n    /**\n     * Execute the given callback in \"dry run\" mode.\n     *\n     * @param  \\Closure  $callback\n     * @return array\n     */\n    public function pretend(Closure $callback);\n\n    /**\n     * Get the name of the connected database.\n     *\n     * @return string\n     */\n    public function getDatabaseName();\n}\n"
        },
        {
          "name": "ConnectionResolver.php",
          "type": "blob",
          "size": 1.953125,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nclass ConnectionResolver implements ConnectionResolverInterface\n{\n    /**\n     * All of the registered connections.\n     *\n     * @var \\Illuminate\\Database\\ConnectionInterface[]\n     */\n    protected $connections = [];\n\n    /**\n     * The default connection name.\n     *\n     * @var string\n     */\n    protected $default;\n\n    /**\n     * Create a new connection resolver instance.\n     *\n     * @param  array<string, \\Illuminate\\Database\\ConnectionInterface>  $connections\n     * @return void\n     */\n    public function __construct(array $connections = [])\n    {\n        foreach ($connections as $name => $connection) {\n            $this->addConnection($name, $connection);\n        }\n    }\n\n    /**\n     * Get a database connection instance.\n     *\n     * @param  string|null  $name\n     * @return \\Illuminate\\Database\\ConnectionInterface\n     */\n    public function connection($name = null)\n    {\n        if (is_null($name)) {\n            $name = $this->getDefaultConnection();\n        }\n\n        return $this->connections[$name];\n    }\n\n    /**\n     * Add a connection to the resolver.\n     *\n     * @param  string  $name\n     * @param  \\Illuminate\\Database\\ConnectionInterface  $connection\n     * @return void\n     */\n    public function addConnection($name, ConnectionInterface $connection)\n    {\n        $this->connections[$name] = $connection;\n    }\n\n    /**\n     * Check if a connection has been registered.\n     *\n     * @param  string  $name\n     * @return bool\n     */\n    public function hasConnection($name)\n    {\n        return isset($this->connections[$name]);\n    }\n\n    /**\n     * Get the default connection name.\n     *\n     * @return string\n     */\n    public function getDefaultConnection()\n    {\n        return $this->default;\n    }\n\n    /**\n     * Set the default connection name.\n     *\n     * @param  string  $name\n     * @return void\n     */\n    public function setDefaultConnection($name)\n    {\n        $this->default = $name;\n    }\n}\n"
        },
        {
          "name": "ConnectionResolverInterface.php",
          "type": "blob",
          "size": 0.5615234375,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\ninterface ConnectionResolverInterface\n{\n    /**\n     * Get a database connection instance.\n     *\n     * @param  string|null  $name\n     * @return \\Illuminate\\Database\\ConnectionInterface\n     */\n    public function connection($name = null);\n\n    /**\n     * Get the default connection name.\n     *\n     * @return string\n     */\n    public function getDefaultConnection();\n\n    /**\n     * Set the default connection name.\n     *\n     * @param  string  $name\n     * @return void\n     */\n    public function setDefaultConnection($name);\n}\n"
        },
        {
          "name": "Connectors",
          "type": "tree",
          "content": null
        },
        {
          "name": "Console",
          "type": "tree",
          "content": null
        },
        {
          "name": "DatabaseManager.php",
          "type": "blob",
          "size": 13.541015625,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Illuminate\\Database\\Connectors\\ConnectionFactory;\nuse Illuminate\\Database\\Events\\ConnectionEstablished;\nuse Illuminate\\Support\\Arr;\nuse Illuminate\\Support\\Collection;\nuse Illuminate\\Support\\ConfigurationUrlParser;\nuse Illuminate\\Support\\Str;\nuse Illuminate\\Support\\Traits\\Macroable;\nuse InvalidArgumentException;\nuse PDO;\nuse RuntimeException;\n\n/**\n * @mixin \\Illuminate\\Database\\Connection\n */\nclass DatabaseManager implements ConnectionResolverInterface\n{\n    use Macroable {\n        __call as macroCall;\n    }\n\n    /**\n     * The application instance.\n     *\n     * @var \\Illuminate\\Contracts\\Foundation\\Application\n     */\n    protected $app;\n\n    /**\n     * The database connection factory instance.\n     *\n     * @var \\Illuminate\\Database\\Connectors\\ConnectionFactory\n     */\n    protected $factory;\n\n    /**\n     * The active connection instances.\n     *\n     * @var array<string, \\Illuminate\\Database\\Connection>\n     */\n    protected $connections = [];\n\n    /**\n     * The dynamically configured (DB::build) connection configurations.\n     *\n     * @var array<string, array>\n     */\n    protected $dynamicConnectionConfigurations = [];\n\n    /**\n     * The custom connection resolvers.\n     *\n     * @var array<string, callable>\n     */\n    protected $extensions = [];\n\n    /**\n     * The callback to be executed to reconnect to a database.\n     *\n     * @var callable\n     */\n    protected $reconnector;\n\n    /**\n     * Create a new database manager instance.\n     *\n     * @param  \\Illuminate\\Contracts\\Foundation\\Application  $app\n     * @param  \\Illuminate\\Database\\Connectors\\ConnectionFactory  $factory\n     * @return void\n     */\n    public function __construct($app, ConnectionFactory $factory)\n    {\n        $this->app = $app;\n        $this->factory = $factory;\n\n        $this->reconnector = function ($connection) {\n            $connection->setPdo(\n                $this->reconnect($connection->getNameWithReadWriteType())->getRawPdo()\n            );\n        };\n    }\n\n    /**\n     * Get a database connection instance.\n     *\n     * @param  string|null  $name\n     * @return \\Illuminate\\Database\\Connection\n     */\n    public function connection($name = null)\n    {\n        $name = $name ?: $this->getDefaultConnection();\n\n        [$database, $type] = $this->parseConnectionName($name);\n\n        // If we haven't created this connection, we'll create it based on the config\n        // provided in the application. Once we've created the connections we will\n        // set the \"fetch mode\" for PDO which determines the query return types.\n        if (! isset($this->connections[$name])) {\n            $this->connections[$name] = $this->configure(\n                $this->makeConnection($database), $type\n            );\n\n            $this->dispatchConnectionEstablishedEvent($this->connections[$name]);\n        }\n\n        return $this->connections[$name];\n    }\n\n    /**\n     * Build a database connection instance from the given configuration.\n     *\n     * @param  array  $config\n     * @return \\Illuminate\\Database\\ConnectionInterface\n     */\n    public function build(array $config)\n    {\n        if (! isset($config['name'])) {\n            $config['name'] = static::calculateDynamicConnectionName($config);\n        }\n\n        $this->dynamicConnectionConfigurations[$config['name']] = $config;\n\n        return $this->connectUsing($config['name'], $config, true);\n    }\n\n    /**\n     * Calculate the dynamic connection name for an on-demand connection based on its configuration.\n     *\n     * @param  array  $config\n     * @return string\n     */\n    public static function calculateDynamicConnectionName(array $config)\n    {\n        return 'dynamic_'.md5((new Collection($config))->map(function ($value, $key) {\n            return $key.(is_string($value) || is_int($value) ? $value : '');\n        })->implode(''));\n    }\n\n    /**\n     * Get a database connection instance from the given configuration.\n     *\n     * @param  string  $name\n     * @param  array  $config\n     * @param  bool  $force\n     * @return \\Illuminate\\Database\\ConnectionInterface\n     */\n    public function connectUsing(string $name, array $config, bool $force = false)\n    {\n        if ($force) {\n            $this->purge($name);\n        }\n\n        if (isset($this->connections[$name])) {\n            throw new RuntimeException(\"Cannot establish connection [$name] because another connection with that name already exists.\");\n        }\n\n        $connection = $this->configure(\n            $this->factory->make($config, $name), null\n        );\n\n        $this->dispatchConnectionEstablishedEvent($connection);\n\n        return tap($connection, fn ($connection) => $this->connections[$name] = $connection);\n    }\n\n    /**\n     * Parse the connection into an array of the name and read / write type.\n     *\n     * @param  string  $name\n     * @return array\n     */\n    protected function parseConnectionName($name)\n    {\n        $name = $name ?: $this->getDefaultConnection();\n\n        return Str::endsWith($name, ['::read', '::write'])\n                            ? explode('::', $name, 2) : [$name, null];\n    }\n\n    /**\n     * Make the database connection instance.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Database\\Connection\n     */\n    protected function makeConnection($name)\n    {\n        $config = $this->configuration($name);\n\n        // First we will check by the connection name to see if an extension has been\n        // registered specifically for that connection. If it has we will call the\n        // Closure and pass it the config allowing it to resolve the connection.\n        if (isset($this->extensions[$name])) {\n            return call_user_func($this->extensions[$name], $config, $name);\n        }\n\n        // Next we will check to see if an extension has been registered for a driver\n        // and will call the Closure if so, which allows us to have a more generic\n        // resolver for the drivers themselves which applies to all connections.\n        if (isset($this->extensions[$driver = $config['driver']])) {\n            return call_user_func($this->extensions[$driver], $config, $name);\n        }\n\n        return $this->factory->make($config, $name);\n    }\n\n    /**\n     * Get the configuration for a connection.\n     *\n     * @param  string  $name\n     * @return array\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function configuration($name)\n    {\n        $name = $name ?: $this->getDefaultConnection();\n\n        $connections = $this->app['config']['database.connections'];\n\n        $config = $this->dynamicConnectionConfigurations[$name] ?? Arr::get($connections, $name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Database connection [{$name}] not configured.\");\n        }\n\n        return (new ConfigurationUrlParser)\n                    ->parseConfiguration($config);\n    }\n\n    /**\n     * Prepare the database connection instance.\n     *\n     * @param  \\Illuminate\\Database\\Connection  $connection\n     * @param  string  $type\n     * @return \\Illuminate\\Database\\Connection\n     */\n    protected function configure(Connection $connection, $type)\n    {\n        $connection = $this->setPdoForType($connection, $type)->setReadWriteType($type);\n\n        // First we'll set the fetch mode and a few other dependencies of the database\n        // connection. This method basically just configures and prepares it to get\n        // used by the application. Once we're finished we'll return it back out.\n        if ($this->app->bound('events')) {\n            $connection->setEventDispatcher($this->app['events']);\n        }\n\n        if ($this->app->bound('db.transactions')) {\n            $connection->setTransactionManager($this->app['db.transactions']);\n        }\n\n        // Here we'll set a reconnector callback. This reconnector can be any callable\n        // so we will set a Closure to reconnect from this manager with the name of\n        // the connection, which will allow us to reconnect from the connections.\n        $connection->setReconnector($this->reconnector);\n\n        return $connection;\n    }\n\n    /**\n     * Dispatch the ConnectionEstablished event if the event dispatcher is available.\n     *\n     * @param  \\Illuminate\\Database\\Connection  $connection\n     * @return void\n     */\n    protected function dispatchConnectionEstablishedEvent(Connection $connection)\n    {\n        if (! $this->app->bound('events')) {\n            return;\n        }\n\n        $this->app['events']->dispatch(\n            new ConnectionEstablished($connection)\n        );\n    }\n\n    /**\n     * Prepare the read / write mode for database connection instance.\n     *\n     * @param  \\Illuminate\\Database\\Connection  $connection\n     * @param  string|null  $type\n     * @return \\Illuminate\\Database\\Connection\n     */\n    protected function setPdoForType(Connection $connection, $type = null)\n    {\n        if ($type === 'read') {\n            $connection->setPdo($connection->getReadPdo());\n        } elseif ($type === 'write') {\n            $connection->setReadPdo($connection->getPdo());\n        }\n\n        return $connection;\n    }\n\n    /**\n     * Disconnect from the given database and remove from local cache.\n     *\n     * @param  string|null  $name\n     * @return void\n     */\n    public function purge($name = null)\n    {\n        $name = $name ?: $this->getDefaultConnection();\n\n        $this->disconnect($name);\n\n        unset($this->connections[$name]);\n    }\n\n    /**\n     * Disconnect from the given database.\n     *\n     * @param  string|null  $name\n     * @return void\n     */\n    public function disconnect($name = null)\n    {\n        if (isset($this->connections[$name = $name ?: $this->getDefaultConnection()])) {\n            $this->connections[$name]->disconnect();\n        }\n    }\n\n    /**\n     * Reconnect to the given database.\n     *\n     * @param  string|null  $name\n     * @return \\Illuminate\\Database\\Connection\n     */\n    public function reconnect($name = null)\n    {\n        $this->disconnect($name = $name ?: $this->getDefaultConnection());\n\n        if (! isset($this->connections[$name])) {\n            return $this->connection($name);\n        }\n\n        return $this->refreshPdoConnections($name);\n    }\n\n    /**\n     * Set the default database connection for the callback execution.\n     *\n     * @param  string  $name\n     * @param  callable  $callback\n     * @return mixed\n     */\n    public function usingConnection($name, callable $callback)\n    {\n        $previousName = $this->getDefaultConnection();\n\n        $this->setDefaultConnection($name);\n\n        return tap($callback(), function () use ($previousName) {\n            $this->setDefaultConnection($previousName);\n        });\n    }\n\n    /**\n     * Refresh the PDO connections on a given connection.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Database\\Connection\n     */\n    protected function refreshPdoConnections($name)\n    {\n        [$database, $type] = $this->parseConnectionName($name);\n\n        $fresh = $this->configure(\n            $this->makeConnection($database), $type\n        );\n\n        return $this->connections[$name]\n                    ->setPdo($fresh->getRawPdo())\n                    ->setReadPdo($fresh->getRawReadPdo());\n    }\n\n    /**\n     * Get the default connection name.\n     *\n     * @return string\n     */\n    public function getDefaultConnection()\n    {\n        return $this->app['config']['database.default'];\n    }\n\n    /**\n     * Set the default connection name.\n     *\n     * @param  string  $name\n     * @return void\n     */\n    public function setDefaultConnection($name)\n    {\n        $this->app['config']['database.default'] = $name;\n    }\n\n    /**\n     * Get all of the supported drivers.\n     *\n     * @return string[]\n     */\n    public function supportedDrivers()\n    {\n        return ['mysql', 'mariadb', 'pgsql', 'sqlite', 'sqlsrv'];\n    }\n\n    /**\n     * Get all of the drivers that are actually available.\n     *\n     * @return string[]\n     */\n    public function availableDrivers()\n    {\n        return array_intersect(\n            $this->supportedDrivers(),\n            str_replace('dblib', 'sqlsrv', PDO::getAvailableDrivers())\n        );\n    }\n\n    /**\n     * Register an extension connection resolver.\n     *\n     * @param  string  $name\n     * @param  callable  $resolver\n     * @return void\n     */\n    public function extend($name, callable $resolver)\n    {\n        $this->extensions[$name] = $resolver;\n    }\n\n    /**\n     * Remove an extension connection resolver.\n     *\n     * @param  string  $name\n     * @return void\n     */\n    public function forgetExtension($name)\n    {\n        unset($this->extensions[$name]);\n    }\n\n    /**\n     * Return all of the created connections.\n     *\n     * @return array<string, \\Illuminate\\Database\\Connection>\n     */\n    public function getConnections()\n    {\n        return $this->connections;\n    }\n\n    /**\n     * Set the database reconnector callback.\n     *\n     * @param  callable  $reconnector\n     * @return void\n     */\n    public function setReconnector(callable $reconnector)\n    {\n        $this->reconnector = $reconnector;\n    }\n\n    /**\n     * Set the application instance used by the manager.\n     *\n     * @param  \\Illuminate\\Contracts\\Foundation\\Application  $app\n     * @return $this\n     */\n    public function setApplication($app)\n    {\n        $this->app = $app;\n\n        return $this;\n    }\n\n    /**\n     * Dynamically pass methods to the default connection.\n     *\n     * @param  string  $method\n     * @param  array  $parameters\n     * @return mixed\n     */\n    public function __call($method, $parameters)\n    {\n        if (static::hasMacro($method)) {\n            return $this->macroCall($method, $parameters);\n        }\n\n        return $this->connection()->$method(...$parameters);\n    }\n}\n"
        },
        {
          "name": "DatabaseServiceProvider.php",
          "type": "blob",
          "size": 3.1875,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Faker\\Factory as FakerFactory;\nuse Faker\\Generator as FakerGenerator;\nuse Illuminate\\Contracts\\Queue\\EntityResolver;\nuse Illuminate\\Database\\Connectors\\ConnectionFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\QueueEntityResolver;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass DatabaseServiceProvider extends ServiceProvider\n{\n    /**\n     * The array of resolved Faker instances.\n     *\n     * @var array\n     */\n    protected static $fakers = [];\n\n    /**\n     * Bootstrap the application events.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        Model::setConnectionResolver($this->app['db']);\n\n        Model::setEventDispatcher($this->app['events']);\n    }\n\n    /**\n     * Register the service provider.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        Model::clearBootedModels();\n\n        $this->registerConnectionServices();\n        $this->registerFakerGenerator();\n        $this->registerQueueableEntityResolver();\n    }\n\n    /**\n     * Register the primary database bindings.\n     *\n     * @return void\n     */\n    protected function registerConnectionServices()\n    {\n        // The connection factory is used to create the actual connection instances on\n        // the database. We will inject the factory into the manager so that it may\n        // make the connections while they are actually needed and not of before.\n        $this->app->singleton('db.factory', function ($app) {\n            return new ConnectionFactory($app);\n        });\n\n        // The database manager is used to resolve various connections, since multiple\n        // connections might be managed. It also implements the connection resolver\n        // interface which may be used by other components requiring connections.\n        $this->app->singleton('db', function ($app) {\n            return new DatabaseManager($app, $app['db.factory']);\n        });\n\n        $this->app->bind('db.connection', function ($app) {\n            return $app['db']->connection();\n        });\n\n        $this->app->bind('db.schema', function ($app) {\n            return $app['db']->connection()->getSchemaBuilder();\n        });\n\n        $this->app->singleton('db.transactions', function ($app) {\n            return new DatabaseTransactionsManager;\n        });\n    }\n\n    /**\n     * Register the Faker Generator instance in the container.\n     *\n     * @return void\n     */\n    protected function registerFakerGenerator()\n    {\n        $this->app->singleton(FakerGenerator::class, function ($app, $parameters) {\n            $locale = $parameters['locale'] ?? $app['config']->get('app.faker_locale', 'en_US');\n\n            if (! isset(static::$fakers[$locale])) {\n                static::$fakers[$locale] = FakerFactory::create($locale);\n            }\n\n            static::$fakers[$locale]->unique(true);\n\n            return static::$fakers[$locale];\n        });\n    }\n\n    /**\n     * Register the queueable entity resolver implementation.\n     *\n     * @return void\n     */\n    protected function registerQueueableEntityResolver()\n    {\n        $this->app->singleton(EntityResolver::class, function () {\n            return new QueueEntityResolver;\n        });\n    }\n}\n"
        },
        {
          "name": "DatabaseTransactionRecord.php",
          "type": "blob",
          "size": 1.5849609375,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nclass DatabaseTransactionRecord\n{\n    /**\n     * The name of the database connection.\n     *\n     * @var string\n     */\n    public $connection;\n\n    /**\n     * The transaction level.\n     *\n     * @var int\n     */\n    public $level;\n\n    /**\n     * The parent instance of this transaction.\n     *\n     * @var \\Illuminate\\Database\\DatabaseTransactionRecord\n     */\n    public $parent;\n\n    /**\n     * The callbacks that should be executed after committing.\n     *\n     * @var array\n     */\n    protected $callbacks = [];\n\n    /**\n     * Create a new database transaction record instance.\n     *\n     * @param  string  $connection\n     * @param  int  $level\n     * @param  \\Illuminate\\Database\\DatabaseTransactionRecord|null  $parent\n     * @return void\n     */\n    public function __construct($connection, $level, ?DatabaseTransactionRecord $parent = null)\n    {\n        $this->connection = $connection;\n        $this->level = $level;\n        $this->parent = $parent;\n    }\n\n    /**\n     * Register a callback to be executed after committing.\n     *\n     * @param  callable  $callback\n     * @return void\n     */\n    public function addCallback($callback)\n    {\n        $this->callbacks[] = $callback;\n    }\n\n    /**\n     * Execute all of the callbacks.\n     *\n     * @return void\n     */\n    public function executeCallbacks()\n    {\n        foreach ($this->callbacks as $callback) {\n            $callback();\n        }\n    }\n\n    /**\n     * Get all of the callbacks.\n     *\n     * @return array\n     */\n    public function getCallbacks()\n    {\n        return $this->callbacks;\n    }\n}\n"
        },
        {
          "name": "DatabaseTransactionsManager.php",
          "type": "blob",
          "size": 7.7490234375,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Illuminate\\Support\\Collection;\n\nclass DatabaseTransactionsManager\n{\n    /**\n     * All of the committed transactions.\n     *\n     * @var \\Illuminate\\Support\\Collection<int, \\Illuminate\\Database\\DatabaseTransactionRecord>\n     */\n    protected $committedTransactions;\n\n    /**\n     * All of the pending transactions.\n     *\n     * @var \\Illuminate\\Support\\Collection<int, \\Illuminate\\Database\\DatabaseTransactionRecord>\n     */\n    protected $pendingTransactions;\n\n    /**\n     * The current transaction.\n     *\n     * @var array\n     */\n    protected $currentTransaction = [];\n\n    /**\n     * Create a new database transactions manager instance.\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        $this->committedTransactions = new Collection;\n        $this->pendingTransactions = new Collection;\n    }\n\n    /**\n     * Start a new database transaction.\n     *\n     * @param  string  $connection\n     * @param  int  $level\n     * @return void\n     */\n    public function begin($connection, $level)\n    {\n        $this->pendingTransactions->push(\n            $newTransaction = new DatabaseTransactionRecord(\n                $connection,\n                $level,\n                $this->currentTransaction[$connection] ?? null\n            )\n        );\n\n        $this->currentTransaction[$connection] = $newTransaction;\n    }\n\n    /**\n     * Commit the root database transaction and execute callbacks.\n     *\n     * @param  string  $connection\n     * @param  int  $levelBeingCommitted\n     * @param  int  $newTransactionLevel\n     * @return array\n     */\n    public function commit($connection, $levelBeingCommitted, $newTransactionLevel)\n    {\n        $this->stageTransactions($connection, $levelBeingCommitted);\n\n        if (isset($this->currentTransaction[$connection])) {\n            $this->currentTransaction[$connection] = $this->currentTransaction[$connection]->parent;\n        }\n\n        if (! $this->afterCommitCallbacksShouldBeExecuted($newTransactionLevel) &&\n            $newTransactionLevel !== 0) {\n            return [];\n        }\n\n        // This method is only called when the root database transaction is committed so there\n        // shouldn't be any pending transactions, but going to clear them here anyways just\n        // in case. This method could be refactored to receive a level in the future too.\n        $this->pendingTransactions = $this->pendingTransactions->reject(\n            fn ($transaction) => $transaction->connection === $connection &&\n                $transaction->level >= $levelBeingCommitted\n        )->values();\n\n        [$forThisConnection, $forOtherConnections] = $this->committedTransactions->partition(\n            fn ($transaction) => $transaction->connection == $connection\n        );\n\n        $this->committedTransactions = $forOtherConnections->values();\n\n        $forThisConnection->map->executeCallbacks();\n\n        return $forThisConnection;\n    }\n\n    /**\n     * Move relevant pending transactions to a committed state.\n     *\n     * @param  string  $connection\n     * @param  int  $levelBeingCommitted\n     * @return void\n     */\n    public function stageTransactions($connection, $levelBeingCommitted)\n    {\n        $this->committedTransactions = $this->committedTransactions->merge(\n            $this->pendingTransactions->filter(\n                fn ($transaction) => $transaction->connection === $connection &&\n                                     $transaction->level >= $levelBeingCommitted\n            )\n        );\n\n        $this->pendingTransactions = $this->pendingTransactions->reject(\n            fn ($transaction) => $transaction->connection === $connection &&\n                                 $transaction->level >= $levelBeingCommitted\n        );\n    }\n\n    /**\n     * Rollback the active database transaction.\n     *\n     * @param  string  $connection\n     * @param  int  $newTransactionLevel\n     * @return void\n     */\n    public function rollback($connection, $newTransactionLevel)\n    {\n        if ($newTransactionLevel === 0) {\n            $this->removeAllTransactionsForConnection($connection);\n        } else {\n            $this->pendingTransactions = $this->pendingTransactions->reject(\n                fn ($transaction) => $transaction->connection == $connection &&\n                                     $transaction->level > $newTransactionLevel\n            )->values();\n\n            if ($this->currentTransaction) {\n                do {\n                    $this->removeCommittedTransactionsThatAreChildrenOf($this->currentTransaction[$connection]);\n\n                    $this->currentTransaction[$connection] = $this->currentTransaction[$connection]->parent;\n                } while (\n                    isset($this->currentTransaction[$connection]) &&\n                    $this->currentTransaction[$connection]->level > $newTransactionLevel\n                );\n            }\n        }\n    }\n\n    /**\n     * Remove all pending, completed, and current transactions for the given connection name.\n     *\n     * @param  string  $connection\n     * @return void\n     */\n    protected function removeAllTransactionsForConnection($connection)\n    {\n        $this->currentTransaction[$connection] = null;\n\n        $this->pendingTransactions = $this->pendingTransactions->reject(\n            fn ($transaction) => $transaction->connection == $connection\n        )->values();\n\n        $this->committedTransactions = $this->committedTransactions->reject(\n            fn ($transaction) => $transaction->connection == $connection\n        )->values();\n    }\n\n    /**\n     * Remove all transactions that are children of the given transaction.\n     *\n     * @param  \\Illuminate\\Database\\DatabaseTransactionRecord  $transaction\n     * @return void\n     */\n    protected function removeCommittedTransactionsThatAreChildrenOf(DatabaseTransactionRecord $transaction)\n    {\n        [$removedTransactions, $this->committedTransactions] = $this->committedTransactions->partition(\n            fn ($committed) => $committed->connection == $transaction->connection &&\n                               $committed->parent === $transaction\n        );\n\n        // There may be multiple deeply nested transactions that have already committed that we\n        // also need to remove. We will recurse down the children of all removed transaction\n        // instances until there are no more deeply nested child transactions for removal.\n        $removedTransactions->each(\n            fn ($transaction) => $this->removeCommittedTransactionsThatAreChildrenOf($transaction)\n        );\n    }\n\n    /**\n     * Register a transaction callback.\n     *\n     * @param  callable  $callback\n     * @return void\n     */\n    public function addCallback($callback)\n    {\n        if ($current = $this->callbackApplicableTransactions()->last()) {\n            return $current->addCallback($callback);\n        }\n\n        $callback();\n    }\n\n    /**\n     * Get the transactions that are applicable to callbacks.\n     *\n     * @return \\Illuminate\\Support\\Collection<int, \\Illuminate\\Database\\DatabaseTransactionRecord>\n     */\n    public function callbackApplicableTransactions()\n    {\n        return $this->pendingTransactions;\n    }\n\n    /**\n     * Determine if after commit callbacks should be executed for the given transaction level.\n     *\n     * @param  int  $level\n     * @return bool\n     */\n    public function afterCommitCallbacksShouldBeExecuted($level)\n    {\n        return $level === 0;\n    }\n\n    /**\n     * Get all of the pending transactions.\n     *\n     * @return \\Illuminate\\Support\\Collection\n     */\n    public function getPendingTransactions()\n    {\n        return $this->pendingTransactions;\n    }\n\n    /**\n     * Get all of the committed transactions.\n     *\n     * @return \\Illuminate\\Support\\Collection\n     */\n    public function getCommittedTransactions()\n    {\n        return $this->committedTransactions;\n    }\n}\n"
        },
        {
          "name": "DeadlockException.php",
          "type": "blob",
          "size": 0.111328125,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse PDOException;\n\nclass DeadlockException extends PDOException\n{\n    //\n}\n"
        },
        {
          "name": "DetectsConcurrencyErrors.php",
          "type": "blob",
          "size": 1.087890625,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Illuminate\\Support\\Str;\nuse PDOException;\nuse Throwable;\n\ntrait DetectsConcurrencyErrors\n{\n    /**\n     * Determine if the given exception was caused by a concurrency error such as a deadlock or serialization failure.\n     *\n     * @param  \\Throwable  $e\n     * @return bool\n     */\n    protected function causedByConcurrencyError(Throwable $e)\n    {\n        if ($e instanceof PDOException && ($e->getCode() === 40001 || $e->getCode() === '40001')) {\n            return true;\n        }\n\n        $message = $e->getMessage();\n\n        return Str::contains($message, [\n            'Deadlock found when trying to get lock',\n            'deadlock detected',\n            'The database file is locked',\n            'database is locked',\n            'database table is locked',\n            'A table in the database is locked',\n            'has been chosen as the deadlock victim',\n            'Lock wait timeout exceeded; try restarting transaction',\n            'WSREP detected deadlock/conflict and aborted the transaction. Try restarting the transaction',\n        ]);\n    }\n}\n"
        },
        {
          "name": "DetectsLostConnections.php",
          "type": "blob",
          "size": 4.294921875,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Illuminate\\Support\\Str;\nuse Throwable;\n\ntrait DetectsLostConnections\n{\n    /**\n     * Determine if the given exception was caused by a lost connection.\n     *\n     * @param  \\Throwable  $e\n     * @return bool\n     */\n    protected function causedByLostConnection(Throwable $e)\n    {\n        $message = $e->getMessage();\n\n        return Str::contains($message, [\n            'server has gone away',\n            'Server has gone away',\n            'no connection to the server',\n            'Lost connection',\n            'is dead or not enabled',\n            'Error while sending',\n            'decryption failed or bad record mac',\n            'server closed the connection unexpectedly',\n            'SSL connection has been closed unexpectedly',\n            'Error writing data to the connection',\n            'Resource deadlock avoided',\n            'Transaction() on null',\n            'child connection forced to terminate due to client_idle_limit',\n            'query_wait_timeout',\n            'reset by peer',\n            'Physical connection is not usable',\n            'TCP Provider: Error code 0x68',\n            'ORA-03114',\n            'Packets out of order. Expected',\n            'Adaptive Server connection failed',\n            'Communication link failure',\n            'connection is no longer usable',\n            'Login timeout expired',\n            'SQLSTATE[HY000] [2002] Connection refused',\n            'running with the --read-only option so it cannot execute this statement',\n            'The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.',\n            'SQLSTATE[HY000] [2002] php_network_getaddresses: getaddrinfo failed: Try again',\n            'SQLSTATE[HY000] [2002] php_network_getaddresses: getaddrinfo failed: Name or service not known',\n            'SQLSTATE[HY000] [2002] php_network_getaddresses: getaddrinfo for',\n            'SQLSTATE[HY000]: General error: 7 SSL SYSCALL error: EOF detected',\n            'SQLSTATE[HY000] [2002] Connection timed out',\n            'SSL: Connection timed out',\n            'SQLSTATE[HY000]: General error: 1105 The last transaction was aborted due to Seamless Scaling. Please retry.',\n            'Temporary failure in name resolution',\n            'SQLSTATE[08S01]: Communication link failure',\n            'SQLSTATE[08006] [7] could not connect to server: Connection refused Is the server running on host',\n            'SQLSTATE[HY000]: General error: 7 SSL SYSCALL error: No route to host',\n            'The client was disconnected by the server because of inactivity. See wait_timeout and interactive_timeout for configuring this behavior.',\n            'SQLSTATE[08006] [7] could not translate host name',\n            'TCP Provider: Error code 0x274C',\n            'SQLSTATE[HY000] [2002] No such file or directory',\n            'SSL: Operation timed out',\n            'Reason: Server is in script upgrade mode. Only administrator can connect at this time.',\n            'Unknown $curl_error_code: 77',\n            'SSL: Handshake timed out',\n            'SQLSTATE[08006] [7] SSL error: sslv3 alert unexpected message',\n            'SQLSTATE[08006] [7] unrecognized SSL error code:',\n            'SQLSTATE[HY000] [2002] No connection could be made because the target machine actively refused it',\n            'SQLSTATE[HY000] [2002] A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond',\n            'SQLSTATE[HY000] [2002] Network is unreachable',\n            'SQLSTATE[HY000] [2002] The requested address is not valid in its context',\n            'SQLSTATE[HY000] [2002] A socket operation was attempted to an unreachable network',\n            'SQLSTATE[HY000] [2002] Operation now in progress',\n            'SQLSTATE[HY000] [2002] Operation in progress',\n            'SQLSTATE[HY000]: General error: 3989',\n            'went away',\n            'No such file or directory',\n            'server is shutting down',\n            'failed to connect to',\n            'Channel connection is closed',\n            'Connection lost',\n            'Broken pipe',\n            'SQLSTATE[25006]: Read only sql transaction: 7',\n        ]);\n    }\n}\n"
        },
        {
          "name": "Eloquent",
          "type": "tree",
          "content": null
        },
        {
          "name": "Events",
          "type": "tree",
          "content": null
        },
        {
          "name": "Grammar.php",
          "type": "blob",
          "size": 7.892578125,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Illuminate\\Contracts\\Database\\Query\\Expression;\nuse Illuminate\\Support\\Collection;\nuse Illuminate\\Support\\Traits\\Macroable;\nuse RuntimeException;\n\nabstract class Grammar\n{\n    use Macroable;\n\n    /**\n     * The connection used for escaping values.\n     *\n     * @var \\Illuminate\\Database\\Connection\n     */\n    protected $connection;\n\n    /**\n     * The grammar table prefix.\n     *\n     * @var string\n     */\n    protected $tablePrefix = '';\n\n    /**\n     * Wrap an array of values.\n     *\n     * @param  array  $values\n     * @return array\n     */\n    public function wrapArray(array $values)\n    {\n        return array_map($this->wrap(...), $values);\n    }\n\n    /**\n     * Wrap a table in keyword identifiers.\n     *\n     * @param  \\Illuminate\\Contracts\\Database\\Query\\Expression|string  $table\n     * @return string\n     */\n    public function wrapTable($table)\n    {\n        if ($this->isExpression($table)) {\n            return $this->getValue($table);\n        }\n\n        // If the table being wrapped has an alias we'll need to separate the pieces\n        // so we can prefix the table and then wrap each of the segments on their\n        // own and then join these both back together using the \"as\" connector.\n        if (stripos($table, ' as ') !== false) {\n            return $this->wrapAliasedTable($table);\n        }\n\n        // If the table being wrapped has a custom schema name specified, we need to\n        // prefix the last segment as the table name then wrap each segment alone\n        // and eventually join them both back together using the dot connector.\n        if (str_contains($table, '.')) {\n            $table = substr_replace($table, '.'.$this->tablePrefix, strrpos($table, '.'), 1);\n\n            return (new Collection(explode('.', $table)))\n                ->map($this->wrapValue(...))\n                ->implode('.');\n        }\n\n        return $this->wrapValue($this->tablePrefix.$table);\n    }\n\n    /**\n     * Wrap a value in keyword identifiers.\n     *\n     * @param  \\Illuminate\\Contracts\\Database\\Query\\Expression|string  $value\n     * @return string\n     */\n    public function wrap($value)\n    {\n        if ($this->isExpression($value)) {\n            return $this->getValue($value);\n        }\n\n        // If the value being wrapped has a column alias we will need to separate out\n        // the pieces so we can wrap each of the segments of the expression on its\n        // own, and then join these both back together using the \"as\" connector.\n        if (stripos($value, ' as ') !== false) {\n            return $this->wrapAliasedValue($value);\n        }\n\n        // If the given value is a JSON selector we will wrap it differently than a\n        // traditional value. We will need to split this path and wrap each part\n        // wrapped, etc. Otherwise, we will simply wrap the value as a string.\n        if ($this->isJsonSelector($value)) {\n            return $this->wrapJsonSelector($value);\n        }\n\n        return $this->wrapSegments(explode('.', $value));\n    }\n\n    /**\n     * Wrap a value that has an alias.\n     *\n     * @param  string  $value\n     * @return string\n     */\n    protected function wrapAliasedValue($value)\n    {\n        $segments = preg_split('/\\s+as\\s+/i', $value);\n\n        return $this->wrap($segments[0]).' as '.$this->wrapValue($segments[1]);\n    }\n\n    /**\n     * Wrap a table that has an alias.\n     *\n     * @param  string  $value\n     * @return string\n     */\n    protected function wrapAliasedTable($value)\n    {\n        $segments = preg_split('/\\s+as\\s+/i', $value);\n\n        return $this->wrapTable($segments[0]).' as '.$this->wrapValue($this->tablePrefix.$segments[1]);\n    }\n\n    /**\n     * Wrap the given value segments.\n     *\n     * @param  array  $segments\n     * @return string\n     */\n    protected function wrapSegments($segments)\n    {\n        return (new Collection($segments))->map(function ($segment, $key) use ($segments) {\n            return $key == 0 && count($segments) > 1\n                            ? $this->wrapTable($segment)\n                            : $this->wrapValue($segment);\n        })->implode('.');\n    }\n\n    /**\n     * Wrap a single string in keyword identifiers.\n     *\n     * @param  string  $value\n     * @return string\n     */\n    protected function wrapValue($value)\n    {\n        if ($value !== '*') {\n            return '\"'.str_replace('\"', '\"\"', $value).'\"';\n        }\n\n        return $value;\n    }\n\n    /**\n     * Wrap the given JSON selector.\n     *\n     * @param  string  $value\n     * @return string\n     *\n     * @throws \\RuntimeException\n     */\n    protected function wrapJsonSelector($value)\n    {\n        throw new RuntimeException('This database engine does not support JSON operations.');\n    }\n\n    /**\n     * Determine if the given string is a JSON selector.\n     *\n     * @param  string  $value\n     * @return bool\n     */\n    protected function isJsonSelector($value)\n    {\n        return str_contains($value, '->');\n    }\n\n    /**\n     * Convert an array of column names into a delimited string.\n     *\n     * @param  array  $columns\n     * @return string\n     */\n    public function columnize(array $columns)\n    {\n        return implode(', ', array_map($this->wrap(...), $columns));\n    }\n\n    /**\n     * Create query parameter place-holders for an array.\n     *\n     * @param  array  $values\n     * @return string\n     */\n    public function parameterize(array $values)\n    {\n        return implode(', ', array_map($this->parameter(...), $values));\n    }\n\n    /**\n     * Get the appropriate query parameter place-holder for a value.\n     *\n     * @param  mixed  $value\n     * @return string\n     */\n    public function parameter($value)\n    {\n        return $this->isExpression($value) ? $this->getValue($value) : '?';\n    }\n\n    /**\n     * Quote the given string literal.\n     *\n     * @param  string|array  $value\n     * @return string\n     */\n    public function quoteString($value)\n    {\n        if (is_array($value)) {\n            return implode(', ', array_map([$this, __FUNCTION__], $value));\n        }\n\n        return \"'$value'\";\n    }\n\n    /**\n     * Escapes a value for safe SQL embedding.\n     *\n     * @param  string|float|int|bool|null  $value\n     * @param  bool  $binary\n     * @return string\n     */\n    public function escape($value, $binary = false)\n    {\n        if (is_null($this->connection)) {\n            throw new RuntimeException(\"The database driver's grammar implementation does not support escaping values.\");\n        }\n\n        return $this->connection->escape($value, $binary);\n    }\n\n    /**\n     * Determine if the given value is a raw expression.\n     *\n     * @param  mixed  $value\n     * @return bool\n     */\n    public function isExpression($value)\n    {\n        return $value instanceof Expression;\n    }\n\n    /**\n     * Transforms expressions to their scalar types.\n     *\n     * @param  \\Illuminate\\Contracts\\Database\\Query\\Expression|string|int|float  $expression\n     * @return string|int|float\n     */\n    public function getValue($expression)\n    {\n        if ($this->isExpression($expression)) {\n            return $this->getValue($expression->getValue($this));\n        }\n\n        return $expression;\n    }\n\n    /**\n     * Get the format for database stored dates.\n     *\n     * @return string\n     */\n    public function getDateFormat()\n    {\n        return 'Y-m-d H:i:s';\n    }\n\n    /**\n     * Get the grammar's table prefix.\n     *\n     * @return string\n     */\n    public function getTablePrefix()\n    {\n        return $this->tablePrefix;\n    }\n\n    /**\n     * Set the grammar's table prefix.\n     *\n     * @param  string  $prefix\n     * @return $this\n     */\n    public function setTablePrefix($prefix)\n    {\n        $this->tablePrefix = $prefix;\n\n        return $this;\n    }\n\n    /**\n     * Set the grammar's database connection.\n     *\n     * @param  \\Illuminate\\Database\\Connection  $connection\n     * @return $this\n     */\n    public function setConnection($connection)\n    {\n        $this->connection = $connection;\n\n        return $this;\n    }\n}\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0498046875,
          "content": "The MIT License (MIT)\n\nCopyright (c) Taylor Otwell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "LazyLoadingViolationException.php",
          "type": "blob",
          "size": 0.7509765625,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse RuntimeException;\n\nclass LazyLoadingViolationException extends RuntimeException\n{\n    /**\n     * The name of the affected Eloquent model.\n     *\n     * @var string\n     */\n    public $model;\n\n    /**\n     * The name of the relation.\n     *\n     * @var string\n     */\n    public $relation;\n\n    /**\n     * Create a new exception instance.\n     *\n     * @param  object  $model\n     * @param  string  $relation\n     * @return void\n     */\n    public function __construct($model, $relation)\n    {\n        $class = get_class($model);\n\n        parent::__construct(\"Attempted to lazy load [{$relation}] on model [{$class}] but lazy loading is disabled.\");\n\n        $this->model = $class;\n        $this->relation = $relation;\n    }\n}\n"
        },
        {
          "name": "LostConnectionException.php",
          "type": "blob",
          "size": 0.12109375,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse LogicException;\n\nclass LostConnectionException extends LogicException\n{\n    //\n}\n"
        },
        {
          "name": "MariaDbConnection.php",
          "type": "blob",
          "size": 2.5322265625,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Illuminate\\Database\\Query\\Grammars\\MariaDbGrammar as QueryGrammar;\nuse Illuminate\\Database\\Query\\Processors\\MariaDbProcessor;\nuse Illuminate\\Database\\Schema\\Grammars\\MariaDbGrammar as SchemaGrammar;\nuse Illuminate\\Database\\Schema\\MariaDbBuilder;\nuse Illuminate\\Database\\Schema\\MariaDbSchemaState;\nuse Illuminate\\Filesystem\\Filesystem;\nuse Illuminate\\Support\\Str;\n\nclass MariaDbConnection extends MySqlConnection\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function getDriverTitle()\n    {\n        return 'MariaDB';\n    }\n\n    /**\n     * Determine if the connected database is a MariaDB database.\n     *\n     * @return bool\n     */\n    public function isMaria()\n    {\n        return true;\n    }\n\n    /**\n     * Get the server version for the connection.\n     *\n     * @return string\n     */\n    public function getServerVersion(): string\n    {\n        return Str::between(parent::getServerVersion(), '5.5.5-', '-MariaDB');\n    }\n\n    /**\n     * Get the default query grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Grammars\\MariaDbGrammar\n     */\n    protected function getDefaultQueryGrammar()\n    {\n        ($grammar = new QueryGrammar)->setConnection($this);\n\n        return $this->withTablePrefix($grammar);\n    }\n\n    /**\n     * Get a schema builder instance for the connection.\n     *\n     * @return \\Illuminate\\Database\\Schema\\MariaDbBuilder\n     */\n    public function getSchemaBuilder()\n    {\n        if (is_null($this->schemaGrammar)) {\n            $this->useDefaultSchemaGrammar();\n        }\n\n        return new MariaDbBuilder($this);\n    }\n\n    /**\n     * Get the default schema grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Schema\\Grammars\\MariaDbGrammar\n     */\n    protected function getDefaultSchemaGrammar()\n    {\n        ($grammar = new SchemaGrammar)->setConnection($this);\n\n        return $this->withTablePrefix($grammar);\n    }\n\n    /**\n     * Get the schema state for the connection.\n     *\n     * @param  \\Illuminate\\Filesystem\\Filesystem|null  $files\n     * @param  callable|null  $processFactory\n     * @return \\Illuminate\\Database\\Schema\\MariaDbSchemaState\n     */\n    public function getSchemaState(?Filesystem $files = null, ?callable $processFactory = null)\n    {\n        return new MariaDbSchemaState($this, $files, $processFactory);\n    }\n\n    /**\n     * Get the default post processor instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Processors\\MariaDbProcessor\n     */\n    protected function getDefaultPostProcessor()\n    {\n        return new MariaDbProcessor;\n    }\n}\n"
        },
        {
          "name": "MigrationServiceProvider.php",
          "type": "blob",
          "size": 6.0751953125,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Illuminate\\Contracts\\Events\\Dispatcher;\nuse Illuminate\\Contracts\\Support\\DeferrableProvider;\nuse Illuminate\\Database\\Console\\Migrations\\FreshCommand;\nuse Illuminate\\Database\\Console\\Migrations\\InstallCommand;\nuse Illuminate\\Database\\Console\\Migrations\\MigrateCommand;\nuse Illuminate\\Database\\Console\\Migrations\\MigrateMakeCommand;\nuse Illuminate\\Database\\Console\\Migrations\\RefreshCommand;\nuse Illuminate\\Database\\Console\\Migrations\\ResetCommand;\nuse Illuminate\\Database\\Console\\Migrations\\RollbackCommand;\nuse Illuminate\\Database\\Console\\Migrations\\StatusCommand;\nuse Illuminate\\Database\\Migrations\\DatabaseMigrationRepository;\nuse Illuminate\\Database\\Migrations\\MigrationCreator;\nuse Illuminate\\Database\\Migrations\\Migrator;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass MigrationServiceProvider extends ServiceProvider implements DeferrableProvider\n{\n    /**\n     * The commands to be registered.\n     *\n     * @var array\n     */\n    protected $commands = [\n        'Migrate' => MigrateCommand::class,\n        'MigrateFresh' => FreshCommand::class,\n        'MigrateInstall' => InstallCommand::class,\n        'MigrateRefresh' => RefreshCommand::class,\n        'MigrateReset' => ResetCommand::class,\n        'MigrateRollback' => RollbackCommand::class,\n        'MigrateStatus' => StatusCommand::class,\n        'MigrateMake' => MigrateMakeCommand::class,\n    ];\n\n    /**\n     * Register the service provider.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        $this->registerRepository();\n\n        $this->registerMigrator();\n\n        $this->registerCreator();\n\n        $this->registerCommands($this->commands);\n    }\n\n    /**\n     * Register the migration repository service.\n     *\n     * @return void\n     */\n    protected function registerRepository()\n    {\n        $this->app->singleton('migration.repository', function ($app) {\n            $migrations = $app['config']['database.migrations'];\n\n            $table = is_array($migrations) ? ($migrations['table'] ?? null) : $migrations;\n\n            return new DatabaseMigrationRepository($app['db'], $table);\n        });\n    }\n\n    /**\n     * Register the migrator service.\n     *\n     * @return void\n     */\n    protected function registerMigrator()\n    {\n        // The migrator is responsible for actually running and rollback the migration\n        // files in the application. We'll pass in our database connection resolver\n        // so the migrator can resolve any of these connections when it needs to.\n        $this->app->singleton('migrator', function ($app) {\n            $repository = $app['migration.repository'];\n\n            return new Migrator($repository, $app['db'], $app['files'], $app['events']);\n        });\n    }\n\n    /**\n     * Register the migration creator.\n     *\n     * @return void\n     */\n    protected function registerCreator()\n    {\n        $this->app->singleton('migration.creator', function ($app) {\n            return new MigrationCreator($app['files'], $app->basePath('stubs'));\n        });\n    }\n\n    /**\n     * Register the given commands.\n     *\n     * @param  array  $commands\n     * @return void\n     */\n    protected function registerCommands(array $commands)\n    {\n        foreach (array_keys($commands) as $command) {\n            $this->{\"register{$command}Command\"}();\n        }\n\n        $this->commands(array_values($commands));\n    }\n\n    /**\n     * Register the command.\n     *\n     * @return void\n     */\n    protected function registerMigrateCommand()\n    {\n        $this->app->singleton(MigrateCommand::class, function ($app) {\n            return new MigrateCommand($app['migrator'], $app[Dispatcher::class]);\n        });\n    }\n\n    /**\n     * Register the command.\n     *\n     * @return void\n     */\n    protected function registerMigrateFreshCommand()\n    {\n        $this->app->singleton(FreshCommand::class, function ($app) {\n            return new FreshCommand($app['migrator']);\n        });\n    }\n\n    /**\n     * Register the command.\n     *\n     * @return void\n     */\n    protected function registerMigrateInstallCommand()\n    {\n        $this->app->singleton(InstallCommand::class, function ($app) {\n            return new InstallCommand($app['migration.repository']);\n        });\n    }\n\n    /**\n     * Register the command.\n     *\n     * @return void\n     */\n    protected function registerMigrateMakeCommand()\n    {\n        $this->app->singleton(MigrateMakeCommand::class, function ($app) {\n            // Once we have the migration creator registered, we will create the command\n            // and inject the creator. The creator is responsible for the actual file\n            // creation of the migrations, and may be extended by these developers.\n            $creator = $app['migration.creator'];\n\n            $composer = $app['composer'];\n\n            return new MigrateMakeCommand($creator, $composer);\n        });\n    }\n\n    /**\n     * Register the command.\n     *\n     * @return void\n     */\n    protected function registerMigrateRefreshCommand()\n    {\n        $this->app->singleton(RefreshCommand::class);\n    }\n\n    /**\n     * Register the command.\n     *\n     * @return void\n     */\n    protected function registerMigrateResetCommand()\n    {\n        $this->app->singleton(ResetCommand::class, function ($app) {\n            return new ResetCommand($app['migrator']);\n        });\n    }\n\n    /**\n     * Register the command.\n     *\n     * @return void\n     */\n    protected function registerMigrateRollbackCommand()\n    {\n        $this->app->singleton(RollbackCommand::class, function ($app) {\n            return new RollbackCommand($app['migrator']);\n        });\n    }\n\n    /**\n     * Register the command.\n     *\n     * @return void\n     */\n    protected function registerMigrateStatusCommand()\n    {\n        $this->app->singleton(StatusCommand::class, function ($app) {\n            return new StatusCommand($app['migrator']);\n        });\n    }\n\n    /**\n     * Get the services provided by the provider.\n     *\n     * @return array\n     */\n    public function provides()\n    {\n        return array_merge([\n            'migrator', 'migration.repository', 'migration.creator',\n        ], array_values($this->commands));\n    }\n}\n"
        },
        {
          "name": "Migrations",
          "type": "tree",
          "content": null
        },
        {
          "name": "MultipleColumnsSelectedException.php",
          "type": "blob",
          "size": 0.1337890625,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse RuntimeException;\n\nclass MultipleColumnsSelectedException extends RuntimeException\n{\n    //\n}\n"
        },
        {
          "name": "MultipleRecordsFoundException.php",
          "type": "blob",
          "size": 0.7275390625,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse RuntimeException;\n\nclass MultipleRecordsFoundException extends RuntimeException\n{\n    /**\n     * The number of records found.\n     *\n     * @var int\n     */\n    public $count;\n\n    /**\n     * Create a new exception instance.\n     *\n     * @param  int  $count\n     * @param  int  $code\n     * @param  \\Throwable|null  $previous\n     * @return void\n     */\n    public function __construct($count, $code = 0, $previous = null)\n    {\n        $this->count = $count;\n\n        parent::__construct(\"$count records were found.\", $code, $previous);\n    }\n\n    /**\n     * Get the number of records found.\n     *\n     * @return int\n     */\n    public function getCount()\n    {\n        return $this->count;\n    }\n}\n"
        },
        {
          "name": "MySqlConnection.php",
          "type": "blob",
          "size": 4.39453125,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Exception;\nuse Illuminate\\Database\\Query\\Grammars\\MySqlGrammar as QueryGrammar;\nuse Illuminate\\Database\\Query\\Processors\\MySqlProcessor;\nuse Illuminate\\Database\\Schema\\Grammars\\MySqlGrammar as SchemaGrammar;\nuse Illuminate\\Database\\Schema\\MySqlBuilder;\nuse Illuminate\\Database\\Schema\\MySqlSchemaState;\nuse Illuminate\\Filesystem\\Filesystem;\nuse Illuminate\\Support\\Str;\nuse PDO;\n\nclass MySqlConnection extends Connection\n{\n    /**\n     * The last inserted ID generated by the server.\n     *\n     * @var string|int|null\n     */\n    protected $lastInsertId;\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getDriverTitle()\n    {\n        return $this->isMaria() ? 'MariaDB' : 'MySQL';\n    }\n\n    /**\n     * Run an insert statement against the database.\n     *\n     * @param  string  $query\n     * @param  array  $bindings\n     * @param  string|null  $sequence\n     * @return bool\n     */\n    public function insert($query, $bindings = [], $sequence = null)\n    {\n        return $this->run($query, $bindings, function ($query, $bindings) use ($sequence) {\n            if ($this->pretending()) {\n                return true;\n            }\n\n            $statement = $this->getPdo()->prepare($query);\n\n            $this->bindValues($statement, $this->prepareBindings($bindings));\n\n            $this->recordsHaveBeenModified();\n\n            $result = $statement->execute();\n\n            $this->lastInsertId = $this->getPdo()->lastInsertId($sequence);\n\n            return $result;\n        });\n    }\n\n    /**\n     * Escape a binary value for safe SQL embedding.\n     *\n     * @param  string  $value\n     * @return string\n     */\n    protected function escapeBinary($value)\n    {\n        $hex = bin2hex($value);\n\n        return \"x'{$hex}'\";\n    }\n\n    /**\n     * Determine if the given database exception was caused by a unique constraint violation.\n     *\n     * @param  \\Exception  $exception\n     * @return bool\n     */\n    protected function isUniqueConstraintError(Exception $exception)\n    {\n        return boolval(preg_match('#Integrity constraint violation: 1062#i', $exception->getMessage()));\n    }\n\n    /**\n     * Get the connection's last insert ID.\n     *\n     * @return string|int|null\n     */\n    public function getLastInsertId()\n    {\n        return $this->lastInsertId;\n    }\n\n    /**\n     * Determine if the connected database is a MariaDB database.\n     *\n     * @return bool\n     */\n    public function isMaria()\n    {\n        return str_contains($this->getPdo()->getAttribute(PDO::ATTR_SERVER_VERSION), 'MariaDB');\n    }\n\n    /**\n     * Get the server version for the connection.\n     *\n     * @return string\n     */\n    public function getServerVersion(): string\n    {\n        return str_contains($version = parent::getServerVersion(), 'MariaDB')\n            ? Str::between($version, '5.5.5-', '-MariaDB')\n            : $version;\n    }\n\n    /**\n     * Get the default query grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Grammars\\MySqlGrammar\n     */\n    protected function getDefaultQueryGrammar()\n    {\n        ($grammar = new QueryGrammar)->setConnection($this);\n\n        return $this->withTablePrefix($grammar);\n    }\n\n    /**\n     * Get a schema builder instance for the connection.\n     *\n     * @return \\Illuminate\\Database\\Schema\\MySqlBuilder\n     */\n    public function getSchemaBuilder()\n    {\n        if (is_null($this->schemaGrammar)) {\n            $this->useDefaultSchemaGrammar();\n        }\n\n        return new MySqlBuilder($this);\n    }\n\n    /**\n     * Get the default schema grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Schema\\Grammars\\MySqlGrammar\n     */\n    protected function getDefaultSchemaGrammar()\n    {\n        ($grammar = new SchemaGrammar)->setConnection($this);\n\n        return $this->withTablePrefix($grammar);\n    }\n\n    /**\n     * Get the schema state for the connection.\n     *\n     * @param  \\Illuminate\\Filesystem\\Filesystem|null  $files\n     * @param  callable|null  $processFactory\n     * @return \\Illuminate\\Database\\Schema\\MySqlSchemaState\n     */\n    public function getSchemaState(?Filesystem $files = null, ?callable $processFactory = null)\n    {\n        return new MySqlSchemaState($this, $files, $processFactory);\n    }\n\n    /**\n     * Get the default post processor instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Processors\\MySqlProcessor\n     */\n    protected function getDefaultPostProcessor()\n    {\n        return new MySqlProcessor;\n    }\n}\n"
        },
        {
          "name": "PostgresConnection.php",
          "type": "blob",
          "size": 2.8974609375,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Exception;\nuse Illuminate\\Database\\Query\\Grammars\\PostgresGrammar as QueryGrammar;\nuse Illuminate\\Database\\Query\\Processors\\PostgresProcessor;\nuse Illuminate\\Database\\Schema\\Grammars\\PostgresGrammar as SchemaGrammar;\nuse Illuminate\\Database\\Schema\\PostgresBuilder;\nuse Illuminate\\Database\\Schema\\PostgresSchemaState;\nuse Illuminate\\Filesystem\\Filesystem;\n\nclass PostgresConnection extends Connection\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function getDriverTitle()\n    {\n        return 'PostgreSQL';\n    }\n\n    /**\n     * Escape a binary value for safe SQL embedding.\n     *\n     * @param  string  $value\n     * @return string\n     */\n    protected function escapeBinary($value)\n    {\n        $hex = bin2hex($value);\n\n        return \"'\\x{$hex}'::bytea\";\n    }\n\n    /**\n     * Escape a bool value for safe SQL embedding.\n     *\n     * @param  bool  $value\n     * @return string\n     */\n    protected function escapeBool($value)\n    {\n        return $value ? 'true' : 'false';\n    }\n\n    /**\n     * Determine if the given database exception was caused by a unique constraint violation.\n     *\n     * @param  \\Exception  $exception\n     * @return bool\n     */\n    protected function isUniqueConstraintError(Exception $exception)\n    {\n        return '23505' === $exception->getCode();\n    }\n\n    /**\n     * Get the default query grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Grammars\\PostgresGrammar\n     */\n    protected function getDefaultQueryGrammar()\n    {\n        ($grammar = new QueryGrammar)->setConnection($this);\n\n        return $this->withTablePrefix($grammar);\n    }\n\n    /**\n     * Get a schema builder instance for the connection.\n     *\n     * @return \\Illuminate\\Database\\Schema\\PostgresBuilder\n     */\n    public function getSchemaBuilder()\n    {\n        if (is_null($this->schemaGrammar)) {\n            $this->useDefaultSchemaGrammar();\n        }\n\n        return new PostgresBuilder($this);\n    }\n\n    /**\n     * Get the default schema grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Schema\\Grammars\\PostgresGrammar\n     */\n    protected function getDefaultSchemaGrammar()\n    {\n        ($grammar = new SchemaGrammar)->setConnection($this);\n\n        return $this->withTablePrefix($grammar);\n    }\n\n    /**\n     * Get the schema state for the connection.\n     *\n     * @param  \\Illuminate\\Filesystem\\Filesystem|null  $files\n     * @param  callable|null  $processFactory\n     * @return \\Illuminate\\Database\\Schema\\PostgresSchemaState\n     */\n    public function getSchemaState(?Filesystem $files = null, ?callable $processFactory = null)\n    {\n        return new PostgresSchemaState($this, $files, $processFactory);\n    }\n\n    /**\n     * Get the default post processor instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Processors\\PostgresProcessor\n     */\n    protected function getDefaultPostProcessor()\n    {\n        return new PostgresProcessor;\n    }\n}\n"
        },
        {
          "name": "Query",
          "type": "tree",
          "content": null
        },
        {
          "name": "QueryException.php",
          "type": "blob",
          "size": 2.08203125,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Illuminate\\Support\\Str;\nuse PDOException;\nuse Throwable;\n\nclass QueryException extends PDOException\n{\n    /**\n     * The database connection name.\n     *\n     * @var string\n     */\n    public $connectionName;\n\n    /**\n     * The SQL for the query.\n     *\n     * @var string\n     */\n    protected $sql;\n\n    /**\n     * The bindings for the query.\n     *\n     * @var array\n     */\n    protected $bindings;\n\n    /**\n     * Create a new query exception instance.\n     *\n     * @param  string  $connectionName\n     * @param  string  $sql\n     * @param  array  $bindings\n     * @param  \\Throwable  $previous\n     * @return void\n     */\n    public function __construct($connectionName, $sql, array $bindings, Throwable $previous)\n    {\n        parent::__construct('', 0, $previous);\n\n        $this->connectionName = $connectionName;\n        $this->sql = $sql;\n        $this->bindings = $bindings;\n        $this->code = $previous->getCode();\n        $this->message = $this->formatMessage($connectionName, $sql, $bindings, $previous);\n\n        if ($previous instanceof PDOException) {\n            $this->errorInfo = $previous->errorInfo;\n        }\n    }\n\n    /**\n     * Format the SQL error message.\n     *\n     * @param  string  $connectionName\n     * @param  string  $sql\n     * @param  array  $bindings\n     * @param  \\Throwable  $previous\n     * @return string\n     */\n    protected function formatMessage($connectionName, $sql, $bindings, Throwable $previous)\n    {\n        return $previous->getMessage().' (Connection: '.$connectionName.', SQL: '.Str::replaceArray('?', $bindings, $sql).')';\n    }\n\n    /**\n     * Get the connection name for the query.\n     *\n     * @return string\n     */\n    public function getConnectionName()\n    {\n        return $this->connectionName;\n    }\n\n    /**\n     * Get the SQL for the query.\n     *\n     * @return string\n     */\n    public function getSql()\n    {\n        return $this->sql;\n    }\n\n    /**\n     * Get the bindings for the query.\n     *\n     * @return array\n     */\n    public function getBindings()\n    {\n        return $this->bindings;\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.15625,
          "content": "## Illuminate Database\n\nThe Illuminate Database component is a full database toolkit for PHP, providing an expressive query builder, ActiveRecord style ORM, and schema builder. It currently supports MySQL, Postgres, SQL Server, and SQLite. It also serves as the database layer of the Laravel PHP framework.\n\n### Usage Instructions\n\nFirst, create a new \"Capsule\" manager instance. Capsule aims to make configuring the library for usage outside of the Laravel framework as easy as possible.\n\n```PHP\nuse Illuminate\\Database\\Capsule\\Manager as Capsule;\n\n$capsule = new Capsule;\n\n$capsule->addConnection([\n    'driver' => 'mysql',\n    'host' => 'localhost',\n    'database' => 'database',\n    'username' => 'root',\n    'password' => 'password',\n    'charset' => 'utf8',\n    'collation' => 'utf8_unicode_ci',\n    'prefix' => '',\n]);\n\n// Set the event dispatcher used by Eloquent models... (optional)\nuse Illuminate\\Events\\Dispatcher;\nuse Illuminate\\Container\\Container;\n$capsule->setEventDispatcher(new Dispatcher(new Container));\n\n// Make this Capsule instance available globally via static methods... (optional)\n$capsule->setAsGlobal();\n\n// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())\n$capsule->bootEloquent();\n```\n\n> `composer require \"illuminate/events\"` required when you need to use observers with Eloquent.\n\nOnce the Capsule instance has been registered. You may use it like so:\n\n**Using The Query Builder**\n\n```PHP\n$users = Capsule::table('users')->where('votes', '>', 100)->get();\n```\nOther core methods may be accessed directly from the Capsule in the same manner as from the DB facade:\n```PHP\n$results = Capsule::select('select * from users where id = ?', [1]);\n```\n\n**Using The Schema Builder**\n\n```PHP\nCapsule::schema()->create('users', function ($table) {\n    $table->increments('id');\n    $table->string('email')->unique();\n    $table->timestamps();\n});\n```\n\n**Using The Eloquent ORM**\n\n```PHP\nclass User extends Illuminate\\Database\\Eloquent\\Model {}\n\n$users = User::where('votes', '>', 1)->get();\n```\n\nFor further documentation on using the various database facilities this library provides, consult the [Laravel framework documentation](https://laravel.com/docs).\n"
        },
        {
          "name": "RecordNotFoundException.php",
          "type": "blob",
          "size": 0.125,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse RuntimeException;\n\nclass RecordNotFoundException extends RuntimeException\n{\n    //\n}\n"
        },
        {
          "name": "RecordsNotFoundException.php",
          "type": "blob",
          "size": 0.1259765625,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse RuntimeException;\n\nclass RecordsNotFoundException extends RuntimeException\n{\n    //\n}\n"
        },
        {
          "name": "SQLiteConnection.php",
          "type": "blob",
          "size": 5.533203125,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Exception;\nuse Illuminate\\Database\\Query\\Grammars\\SQLiteGrammar as QueryGrammar;\nuse Illuminate\\Database\\Query\\Processors\\SQLiteProcessor;\nuse Illuminate\\Database\\Schema\\Grammars\\SQLiteGrammar as SchemaGrammar;\nuse Illuminate\\Database\\Schema\\SQLiteBuilder;\nuse Illuminate\\Database\\Schema\\SqliteSchemaState;\nuse Illuminate\\Filesystem\\Filesystem;\n\nclass SQLiteConnection extends Connection\n{\n    /**\n     * Create a new database connection instance.\n     *\n     * @param  \\PDO|\\Closure  $pdo\n     * @param  string  $database\n     * @param  string  $tablePrefix\n     * @param  array  $config\n     * @return void\n     */\n    public function __construct($pdo, $database = '', $tablePrefix = '', array $config = [])\n    {\n        parent::__construct($pdo, $database, $tablePrefix, $config);\n\n        $this->configureForeignKeyConstraints();\n        $this->configureBusyTimeout();\n        $this->configureJournalMode();\n        $this->configureSynchronous();\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getDriverTitle()\n    {\n        return 'SQLite';\n    }\n\n    /**\n     * Enable or disable foreign key constraints if configured.\n     *\n     * @return void\n     */\n    protected function configureForeignKeyConstraints(): void\n    {\n        $enableForeignKeyConstraints = $this->getConfig('foreign_key_constraints');\n\n        if ($enableForeignKeyConstraints === null) {\n            return;\n        }\n\n        $schemaBuilder = $this->getSchemaBuilder();\n\n        try {\n            $enableForeignKeyConstraints\n                ? $schemaBuilder->enableForeignKeyConstraints()\n                : $schemaBuilder->disableForeignKeyConstraints();\n        } catch (QueryException $e) {\n            if (! $e->getPrevious() instanceof SQLiteDatabaseDoesNotExistException) {\n                throw $e;\n            }\n        }\n    }\n\n    /**\n     * Set the busy timeout if configured.\n     *\n     * @return void\n     */\n    protected function configureBusyTimeout(): void\n    {\n        $milliseconds = $this->getConfig('busy_timeout');\n\n        if ($milliseconds === null) {\n            return;\n        }\n\n        try {\n            $this->getSchemaBuilder()->setBusyTimeout($milliseconds);\n        } catch (QueryException $e) {\n            if (! $e->getPrevious() instanceof SQLiteDatabaseDoesNotExistException) {\n                throw $e;\n            }\n        }\n    }\n\n    /**\n     * Set the journal mode if configured.\n     *\n     * @return void\n     */\n    protected function configureJournalMode(): void\n    {\n        $mode = $this->getConfig('journal_mode');\n\n        if ($mode === null) {\n            return;\n        }\n\n        try {\n            $this->getSchemaBuilder()->setJournalMode($mode);\n        } catch (QueryException $e) {\n            if (! $e->getPrevious() instanceof SQLiteDatabaseDoesNotExistException) {\n                throw $e;\n            }\n        }\n    }\n\n    /**\n     * Set the synchronous mode if configured.\n     *\n     * @return void\n     */\n    protected function configureSynchronous(): void\n    {\n        $mode = $this->getConfig('synchronous');\n\n        if ($mode === null) {\n            return;\n        }\n\n        try {\n            $this->getSchemaBuilder()->setSynchronous($mode);\n        } catch (QueryException $e) {\n            if (! $e->getPrevious() instanceof SQLiteDatabaseDoesNotExistException) {\n                throw $e;\n            }\n        }\n    }\n\n    /**\n     * Escape a binary value for safe SQL embedding.\n     *\n     * @param  string  $value\n     * @return string\n     */\n    protected function escapeBinary($value)\n    {\n        $hex = bin2hex($value);\n\n        return \"x'{$hex}'\";\n    }\n\n    /**\n     * Determine if the given database exception was caused by a unique constraint violation.\n     *\n     * @param  \\Exception  $exception\n     * @return bool\n     */\n    protected function isUniqueConstraintError(Exception $exception)\n    {\n        return boolval(preg_match('#(column(s)? .* (is|are) not unique|UNIQUE constraint failed: .*)#i', $exception->getMessage()));\n    }\n\n    /**\n     * Get the default query grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Grammars\\SQLiteGrammar\n     */\n    protected function getDefaultQueryGrammar()\n    {\n        ($grammar = new QueryGrammar)->setConnection($this);\n\n        return $this->withTablePrefix($grammar);\n    }\n\n    /**\n     * Get a schema builder instance for the connection.\n     *\n     * @return \\Illuminate\\Database\\Schema\\SQLiteBuilder\n     */\n    public function getSchemaBuilder()\n    {\n        if (is_null($this->schemaGrammar)) {\n            $this->useDefaultSchemaGrammar();\n        }\n\n        return new SQLiteBuilder($this);\n    }\n\n    /**\n     * Get the default schema grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Schema\\Grammars\\SQLiteGrammar\n     */\n    protected function getDefaultSchemaGrammar()\n    {\n        ($grammar = new SchemaGrammar)->setConnection($this);\n\n        return $this->withTablePrefix($grammar);\n    }\n\n    /**\n     * Get the schema state for the connection.\n     *\n     * @param  \\Illuminate\\Filesystem\\Filesystem|null  $files\n     * @param  callable|null  $processFactory\n     *\n     * @throws \\RuntimeException\n     */\n    public function getSchemaState(?Filesystem $files = null, ?callable $processFactory = null)\n    {\n        return new SqliteSchemaState($this, $files, $processFactory);\n    }\n\n    /**\n     * Get the default post processor instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Processors\\SQLiteProcessor\n     */\n    protected function getDefaultPostProcessor()\n    {\n        return new SQLiteProcessor;\n    }\n}\n"
        },
        {
          "name": "SQLiteDatabaseDoesNotExistException.php",
          "type": "blob",
          "size": 0.5517578125,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse InvalidArgumentException;\n\nclass SQLiteDatabaseDoesNotExistException extends InvalidArgumentException\n{\n    /**\n     * The path to the database.\n     *\n     * @var string\n     */\n    public $path;\n\n    /**\n     * Create a new exception instance.\n     *\n     * @param  string  $path\n     * @return void\n     */\n    public function __construct($path)\n    {\n        parent::__construct(\"Database file at path [{$path}] does not exist. Ensure this is an absolute path to the database.\");\n\n        $this->path = $path;\n    }\n}\n"
        },
        {
          "name": "Schema",
          "type": "tree",
          "content": null
        },
        {
          "name": "Seeder.php",
          "type": "blob",
          "size": 4.6318359375,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Illuminate\\Console\\Command;\nuse Illuminate\\Console\\View\\Components\\TwoColumnDetail;\nuse Illuminate\\Contracts\\Container\\Container;\nuse Illuminate\\Database\\Console\\Seeds\\WithoutModelEvents;\nuse Illuminate\\Support\\Arr;\nuse InvalidArgumentException;\n\nabstract class Seeder\n{\n    /**\n     * The container instance.\n     *\n     * @var \\Illuminate\\Contracts\\Container\\Container\n     */\n    protected $container;\n\n    /**\n     * The console command instance.\n     *\n     * @var \\Illuminate\\Console\\Command\n     */\n    protected $command;\n\n    /**\n     * Seeders that have been called at least one time.\n     *\n     * @var array\n     */\n    protected static $called = [];\n\n    /**\n     * Run the given seeder class.\n     *\n     * @param  array|string  $class\n     * @param  bool  $silent\n     * @param  array  $parameters\n     * @return $this\n     */\n    public function call($class, $silent = false, array $parameters = [])\n    {\n        $classes = Arr::wrap($class);\n\n        foreach ($classes as $class) {\n            $seeder = $this->resolve($class);\n\n            $name = get_class($seeder);\n\n            if ($silent === false && isset($this->command)) {\n                with(new TwoColumnDetail($this->command->getOutput()))->render(\n                    $name,\n                    '<fg=yellow;options=bold>RUNNING</>'\n                );\n            }\n\n            $startTime = microtime(true);\n\n            $seeder->__invoke($parameters);\n\n            if ($silent === false && isset($this->command)) {\n                $runTime = number_format((microtime(true) - $startTime) * 1000);\n\n                with(new TwoColumnDetail($this->command->getOutput()))->render(\n                    $name,\n                    \"<fg=gray>$runTime ms</> <fg=green;options=bold>DONE</>\"\n                );\n\n                $this->command->getOutput()->writeln('');\n            }\n\n            static::$called[] = $class;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Run the given seeder class.\n     *\n     * @param  array|string  $class\n     * @param  array  $parameters\n     * @return void\n     */\n    public function callWith($class, array $parameters = [])\n    {\n        $this->call($class, false, $parameters);\n    }\n\n    /**\n     * Silently run the given seeder class.\n     *\n     * @param  array|string  $class\n     * @param  array  $parameters\n     * @return void\n     */\n    public function callSilent($class, array $parameters = [])\n    {\n        $this->call($class, true, $parameters);\n    }\n\n    /**\n     * Run the given seeder class once.\n     *\n     * @param  array|string  $class\n     * @param  bool  $silent\n     * @return void\n     */\n    public function callOnce($class, $silent = false, array $parameters = [])\n    {\n        if (in_array($class, static::$called)) {\n            return;\n        }\n\n        $this->call($class, $silent, $parameters);\n    }\n\n    /**\n     * Resolve an instance of the given seeder class.\n     *\n     * @param  string  $class\n     * @return \\Illuminate\\Database\\Seeder\n     */\n    protected function resolve($class)\n    {\n        if (isset($this->container)) {\n            $instance = $this->container->make($class);\n\n            $instance->setContainer($this->container);\n        } else {\n            $instance = new $class;\n        }\n\n        if (isset($this->command)) {\n            $instance->setCommand($this->command);\n        }\n\n        return $instance;\n    }\n\n    /**\n     * Set the IoC container instance.\n     *\n     * @param  \\Illuminate\\Contracts\\Container\\Container  $container\n     * @return $this\n     */\n    public function setContainer(Container $container)\n    {\n        $this->container = $container;\n\n        return $this;\n    }\n\n    /**\n     * Set the console command instance.\n     *\n     * @param  \\Illuminate\\Console\\Command  $command\n     * @return $this\n     */\n    public function setCommand(Command $command)\n    {\n        $this->command = $command;\n\n        return $this;\n    }\n\n    /**\n     * Run the database seeds.\n     *\n     * @param  array  $parameters\n     * @return mixed\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function __invoke(array $parameters = [])\n    {\n        if (! method_exists($this, 'run')) {\n            throw new InvalidArgumentException('Method [run] missing from '.get_class($this));\n        }\n\n        $callback = fn () => isset($this->container)\n            ? $this->container->call([$this, 'run'], $parameters)\n            : $this->run(...$parameters);\n\n        $uses = array_flip(class_uses_recursive(static::class));\n\n        if (isset($uses[WithoutModelEvents::class])) {\n            $callback = $this->withoutModelEvents($callback);\n        }\n\n        return $callback();\n    }\n}\n"
        },
        {
          "name": "SqlServerConnection.php",
          "type": "blob",
          "size": 3.982421875,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nuse Closure;\nuse Exception;\nuse Illuminate\\Database\\Query\\Grammars\\SqlServerGrammar as QueryGrammar;\nuse Illuminate\\Database\\Query\\Processors\\SqlServerProcessor;\nuse Illuminate\\Database\\Schema\\Grammars\\SqlServerGrammar as SchemaGrammar;\nuse Illuminate\\Database\\Schema\\SqlServerBuilder;\nuse Illuminate\\Filesystem\\Filesystem;\nuse RuntimeException;\nuse Throwable;\n\nclass SqlServerConnection extends Connection\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function getDriverTitle()\n    {\n        return 'SQL Server';\n    }\n\n    /**\n     * Execute a Closure within a transaction.\n     *\n     * @param  \\Closure  $callback\n     * @param  int  $attempts\n     * @return mixed\n     *\n     * @throws \\Throwable\n     */\n    public function transaction(Closure $callback, $attempts = 1)\n    {\n        for ($a = 1; $a <= $attempts; $a++) {\n            if ($this->getDriverName() === 'sqlsrv') {\n                return parent::transaction($callback, $attempts);\n            }\n\n            $this->getPdo()->exec('BEGIN TRAN');\n\n            // We'll simply execute the given callback within a try / catch block\n            // and if we catch any exception we can rollback the transaction\n            // so that none of the changes are persisted to the database.\n            try {\n                $result = $callback($this);\n\n                $this->getPdo()->exec('COMMIT TRAN');\n            }\n\n            // If we catch an exception, we will rollback so nothing gets messed\n            // up in the database. Then we'll re-throw the exception so it can\n            // be handled how the developer sees fit for their applications.\n            catch (Throwable $e) {\n                $this->getPdo()->exec('ROLLBACK TRAN');\n\n                throw $e;\n            }\n\n            return $result;\n        }\n    }\n\n    /**\n     * Escape a binary value for safe SQL embedding.\n     *\n     * @param  string  $value\n     * @return string\n     */\n    protected function escapeBinary($value)\n    {\n        $hex = bin2hex($value);\n\n        return \"0x{$hex}\";\n    }\n\n    /**\n     * Determine if the given database exception was caused by a unique constraint violation.\n     *\n     * @param  \\Exception  $exception\n     * @return bool\n     */\n    protected function isUniqueConstraintError(Exception $exception)\n    {\n        return boolval(preg_match('#Cannot insert duplicate key row in object#i', $exception->getMessage()));\n    }\n\n    /**\n     * Get the default query grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Grammars\\SqlServerGrammar\n     */\n    protected function getDefaultQueryGrammar()\n    {\n        ($grammar = new QueryGrammar)->setConnection($this);\n\n        return $this->withTablePrefix($grammar);\n    }\n\n    /**\n     * Get a schema builder instance for the connection.\n     *\n     * @return \\Illuminate\\Database\\Schema\\SqlServerBuilder\n     */\n    public function getSchemaBuilder()\n    {\n        if (is_null($this->schemaGrammar)) {\n            $this->useDefaultSchemaGrammar();\n        }\n\n        return new SqlServerBuilder($this);\n    }\n\n    /**\n     * Get the default schema grammar instance.\n     *\n     * @return \\Illuminate\\Database\\Schema\\Grammars\\SqlServerGrammar\n     */\n    protected function getDefaultSchemaGrammar()\n    {\n        ($grammar = new SchemaGrammar)->setConnection($this);\n\n        return $this->withTablePrefix($grammar);\n    }\n\n    /**\n     * Get the schema state for the connection.\n     *\n     * @param  \\Illuminate\\Filesystem\\Filesystem|null  $files\n     * @param  callable|null  $processFactory\n     *\n     * @throws \\RuntimeException\n     */\n    public function getSchemaState(?Filesystem $files = null, ?callable $processFactory = null)\n    {\n        throw new RuntimeException('Schema dumping is not supported when using SQL Server.');\n    }\n\n    /**\n     * Get the default post processor instance.\n     *\n     * @return \\Illuminate\\Database\\Query\\Processors\\SqlServerProcessor\n     */\n    protected function getDefaultPostProcessor()\n    {\n        return new SqlServerProcessor;\n    }\n}\n"
        },
        {
          "name": "UniqueConstraintViolationException.php",
          "type": "blob",
          "size": 0.1044921875,
          "content": "<?php\n\nnamespace Illuminate\\Database;\n\nclass UniqueConstraintViolationException extends QueryException\n{\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.669921875,
          "content": "{\n    \"name\": \"illuminate/database\",\n    \"description\": \"The Illuminate Database package.\",\n    \"license\": \"MIT\",\n    \"homepage\": \"https://laravel.com\",\n    \"support\": {\n        \"issues\": \"https://github.com/laravel/framework/issues\",\n        \"source\": \"https://github.com/laravel/framework\"\n    },\n    \"keywords\": [\"laravel\", \"database\", \"sql\", \"orm\"],\n    \"authors\": [\n        {\n            \"name\": \"Taylor Otwell\",\n            \"email\": \"taylor@laravel.com\"\n        }\n    ],\n    \"require\": {\n        \"php\": \"^8.2\",\n        \"ext-pdo\": \"*\",\n        \"brick/math\": \"^0.9.3|^0.10.2|^0.11|^0.12\",\n        \"illuminate/collections\": \"^12.0\",\n        \"illuminate/container\": \"^12.0\",\n        \"illuminate/contracts\": \"^12.0\",\n        \"illuminate/macroable\": \"^12.0\",\n        \"illuminate/support\": \"^12.0\",\n        \"laravel/serializable-closure\": \"^1.3|^2.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"Illuminate\\\\Database\\\\\": \"\"\n        }\n    },\n    \"extra\": {\n        \"branch-alias\": {\n            \"dev-master\": \"12.x-dev\"\n        }\n    },\n    \"suggest\": {\n        \"ext-filter\": \"Required to use the Postgres database driver.\",\n        \"fakerphp/faker\": \"Required to use the eloquent factory builder (^1.24).\",\n        \"illuminate/console\": \"Required to use the database commands (^12.0).\",\n        \"illuminate/events\": \"Required to use the observers with Eloquent (^12.0).\",\n        \"illuminate/filesystem\": \"Required to use the migrations (^12.0).\",\n        \"illuminate/pagination\": \"Required to paginate the result set (^12.0).\",\n        \"symfony/finder\": \"Required to use Eloquent model factories (^7.2).\"\n    },\n    \"config\": {\n        \"sort-packages\": true\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        }
      ]
    }
  ]
}