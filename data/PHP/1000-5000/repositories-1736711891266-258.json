{
  "metadata": {
    "timestamp": 1736711891266,
    "page": 258,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/form",
      "stars": 2753,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "AbstractExtension.php",
          "type": "blob",
          "size": 4.4453125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Form\\Exception\\UnexpectedTypeException;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nabstract class AbstractExtension implements FormExtensionInterface\n{\n    /**\n     * The types provided by this extension.\n     *\n     * @var FormTypeInterface[]\n     */\n    private array $types;\n\n    /**\n     * The type extensions provided by this extension.\n     *\n     * @var FormTypeExtensionInterface[][]\n     */\n    private array $typeExtensions;\n\n    /**\n     * The type guesser provided by this extension.\n     */\n    private ?FormTypeGuesserInterface $typeGuesser = null;\n\n    /**\n     * Whether the type guesser has been loaded.\n     */\n    private bool $typeGuesserLoaded = false;\n\n    public function getType(string $name): FormTypeInterface\n    {\n        if (!isset($this->types)) {\n            $this->initTypes();\n        }\n\n        if (!isset($this->types[$name])) {\n            throw new InvalidArgumentException(\\sprintf('The type \"%s\" cannot be loaded by this extension.', $name));\n        }\n\n        return $this->types[$name];\n    }\n\n    public function hasType(string $name): bool\n    {\n        if (!isset($this->types)) {\n            $this->initTypes();\n        }\n\n        return isset($this->types[$name]);\n    }\n\n    public function getTypeExtensions(string $name): array\n    {\n        if (!isset($this->typeExtensions)) {\n            $this->initTypeExtensions();\n        }\n\n        return $this->typeExtensions[$name]\n            ?? [];\n    }\n\n    public function hasTypeExtensions(string $name): bool\n    {\n        if (!isset($this->typeExtensions)) {\n            $this->initTypeExtensions();\n        }\n\n        return isset($this->typeExtensions[$name]) && \\count($this->typeExtensions[$name]) > 0;\n    }\n\n    public function getTypeGuesser(): ?FormTypeGuesserInterface\n    {\n        if (!$this->typeGuesserLoaded) {\n            $this->initTypeGuesser();\n        }\n\n        return $this->typeGuesser;\n    }\n\n    /**\n     * Registers the types.\n     *\n     * @return FormTypeInterface[]\n     */\n    protected function loadTypes(): array\n    {\n        return [];\n    }\n\n    /**\n     * Registers the type extensions.\n     *\n     * @return FormTypeExtensionInterface[]\n     */\n    protected function loadTypeExtensions(): array\n    {\n        return [];\n    }\n\n    /**\n     * Registers the type guesser.\n     */\n    protected function loadTypeGuesser(): ?FormTypeGuesserInterface\n    {\n        return null;\n    }\n\n    /**\n     * Initializes the types.\n     *\n     * @throws UnexpectedTypeException if any registered type is not an instance of FormTypeInterface\n     */\n    private function initTypes(): void\n    {\n        $this->types = [];\n\n        foreach ($this->loadTypes() as $type) {\n            if (!$type instanceof FormTypeInterface) {\n                throw new UnexpectedTypeException($type, FormTypeInterface::class);\n            }\n\n            $this->types[$type::class] = $type;\n        }\n    }\n\n    /**\n     * Initializes the type extensions.\n     *\n     * @throws UnexpectedTypeException if any registered type extension is not\n     *                                 an instance of FormTypeExtensionInterface\n     */\n    private function initTypeExtensions(): void\n    {\n        $this->typeExtensions = [];\n\n        foreach ($this->loadTypeExtensions() as $extension) {\n            if (!$extension instanceof FormTypeExtensionInterface) {\n                throw new UnexpectedTypeException($extension, FormTypeExtensionInterface::class);\n            }\n\n            foreach ($extension::getExtendedTypes() as $extendedType) {\n                $this->typeExtensions[$extendedType][] = $extension;\n            }\n        }\n    }\n\n    /**\n     * Initializes the type guesser.\n     *\n     * @throws UnexpectedTypeException if the type guesser is not an instance of FormTypeGuesserInterface\n     */\n    private function initTypeGuesser(): void\n    {\n        $this->typeGuesserLoaded = true;\n\n        $this->typeGuesser = $this->loadTypeGuesser();\n        if (null !== $this->typeGuesser && !$this->typeGuesser instanceof FormTypeGuesserInterface) {\n            throw new UnexpectedTypeException($this->typeGuesser, FormTypeGuesserInterface::class);\n        }\n    }\n}\n"
        },
        {
          "name": "AbstractRendererEngine.php",
          "type": "blob",
          "size": 6.80078125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * Default implementation of {@link FormRendererEngineInterface}.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nabstract class AbstractRendererEngine implements FormRendererEngineInterface, ResetInterface\n{\n    /**\n     * The variable in {@link FormView} used as cache key.\n     */\n    public const CACHE_KEY_VAR = 'cache_key';\n\n    /**\n     * @var array[]\n     */\n    protected array $themes = [];\n\n    /**\n     * @var bool[]\n     */\n    protected array $useDefaultThemes = [];\n\n    /**\n     * @var array[]\n     */\n    protected array $resources = [];\n\n    /**\n     * @var array<array<int|false>>\n     */\n    private array $resourceHierarchyLevels = [];\n\n    /**\n     * Creates a new renderer engine.\n     *\n     * @param array $defaultThemes The default themes. The type of these\n     *                             themes is open to the implementation.\n     */\n    public function __construct(\n        protected array $defaultThemes = [],\n    ) {\n    }\n\n    public function setTheme(FormView $view, mixed $themes, bool $useDefaultThemes = true): void\n    {\n        $cacheKey = $view->vars[self::CACHE_KEY_VAR];\n\n        // Do not cast, as casting turns objects into arrays of properties\n        $this->themes[$cacheKey] = \\is_array($themes) ? $themes : [$themes];\n        $this->useDefaultThemes[$cacheKey] = $useDefaultThemes;\n\n        // Unset instead of resetting to an empty array, in order to allow\n        // implementations (like TwigRendererEngine) to check whether $cacheKey\n        // is set at all.\n        unset($this->resources[$cacheKey], $this->resourceHierarchyLevels[$cacheKey]);\n    }\n\n    public function getResourceForBlockName(FormView $view, string $blockName): mixed\n    {\n        $cacheKey = $view->vars[self::CACHE_KEY_VAR];\n\n        if (!isset($this->resources[$cacheKey][$blockName])) {\n            $this->loadResourceForBlockName($cacheKey, $view, $blockName);\n        }\n\n        return $this->resources[$cacheKey][$blockName];\n    }\n\n    public function getResourceForBlockNameHierarchy(FormView $view, array $blockNameHierarchy, int $hierarchyLevel): mixed\n    {\n        $cacheKey = $view->vars[self::CACHE_KEY_VAR];\n        $blockName = $blockNameHierarchy[$hierarchyLevel];\n\n        if (!isset($this->resources[$cacheKey][$blockName])) {\n            $this->loadResourceForBlockNameHierarchy($cacheKey, $view, $blockNameHierarchy, $hierarchyLevel);\n        }\n\n        return $this->resources[$cacheKey][$blockName];\n    }\n\n    public function getResourceHierarchyLevel(FormView $view, array $blockNameHierarchy, int $hierarchyLevel): int|false\n    {\n        $cacheKey = $view->vars[self::CACHE_KEY_VAR];\n        $blockName = $blockNameHierarchy[$hierarchyLevel];\n\n        if (!isset($this->resources[$cacheKey][$blockName])) {\n            $this->loadResourceForBlockNameHierarchy($cacheKey, $view, $blockNameHierarchy, $hierarchyLevel);\n        }\n\n        // If $block was previously rendered loaded with loadTemplateForBlock(), the template\n        // is cached but the hierarchy level is not. In this case, we know that the  block\n        // exists at this very hierarchy level, so we can just set it.\n        if (!isset($this->resourceHierarchyLevels[$cacheKey][$blockName])) {\n            $this->resourceHierarchyLevels[$cacheKey][$blockName] = $hierarchyLevel;\n        }\n\n        return $this->resourceHierarchyLevels[$cacheKey][$blockName];\n    }\n\n    /**\n     * Loads the cache with the resource for a given block name.\n     *\n     * @see getResourceForBlock()\n     */\n    abstract protected function loadResourceForBlockName(string $cacheKey, FormView $view, string $blockName): bool;\n\n    /**\n     * Loads the cache with the resource for a specific level of a block hierarchy.\n     *\n     * @see getResourceForBlockHierarchy()\n     */\n    private function loadResourceForBlockNameHierarchy(string $cacheKey, FormView $view, array $blockNameHierarchy, int $hierarchyLevel): bool\n    {\n        $blockName = $blockNameHierarchy[$hierarchyLevel];\n\n        // Try to find a template for that block\n        if ($this->loadResourceForBlockName($cacheKey, $view, $blockName)) {\n            // If loadTemplateForBlock() returns true, it was able to populate the\n            // cache. The only missing thing is to set the hierarchy level at which\n            // the template was found.\n            $this->resourceHierarchyLevels[$cacheKey][$blockName] = $hierarchyLevel;\n\n            return true;\n        }\n\n        if ($hierarchyLevel > 0) {\n            $parentLevel = $hierarchyLevel - 1;\n            $parentBlockName = $blockNameHierarchy[$parentLevel];\n\n            // The next two if statements contain slightly duplicated code. This is by intention\n            // and tries to avoid execution of unnecessary checks in order to increase performance.\n\n            if (isset($this->resources[$cacheKey][$parentBlockName])) {\n                // It may happen that the parent block is already loaded, but its level is not.\n                // In this case, the parent block must have been loaded by loadResourceForBlock(),\n                // which does not check the hierarchy of the block. Subsequently the block must have\n                // been found directly on the parent level.\n                if (!isset($this->resourceHierarchyLevels[$cacheKey][$parentBlockName])) {\n                    $this->resourceHierarchyLevels[$cacheKey][$parentBlockName] = $parentLevel;\n                }\n\n                // Cache the shortcuts for further accesses\n                $this->resources[$cacheKey][$blockName] = $this->resources[$cacheKey][$parentBlockName];\n                $this->resourceHierarchyLevels[$cacheKey][$blockName] = $this->resourceHierarchyLevels[$cacheKey][$parentBlockName];\n\n                return true;\n            }\n\n            if ($this->loadResourceForBlockNameHierarchy($cacheKey, $view, $blockNameHierarchy, $parentLevel)) {\n                // Cache the shortcuts for further accesses\n                $this->resources[$cacheKey][$blockName] = $this->resources[$cacheKey][$parentBlockName];\n                $this->resourceHierarchyLevels[$cacheKey][$blockName] = $this->resourceHierarchyLevels[$cacheKey][$parentBlockName];\n\n                return true;\n            }\n        }\n\n        // Cache the result for further accesses\n        $this->resources[$cacheKey][$blockName] = false;\n        $this->resourceHierarchyLevels[$cacheKey][$blockName] = false;\n\n        return false;\n    }\n\n    public function reset(): void\n    {\n        $this->themes = [];\n        $this->useDefaultThemes = [];\n        $this->resources = [];\n        $this->resourceHierarchyLevels = [];\n    }\n}\n"
        },
        {
          "name": "AbstractType.php",
          "type": "blob",
          "size": 1.296875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\FormType;\nuse Symfony\\Component\\Form\\Util\\StringUtil;\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nabstract class AbstractType implements FormTypeInterface\n{\n    /**\n     * @return string|null\n     */\n    public function getParent()\n    {\n        return FormType::class;\n    }\n\n    /**\n     * @return void\n     */\n    public function configureOptions(OptionsResolver $resolver)\n    {\n    }\n\n    /**\n     * @return void\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n    }\n\n    /**\n     * @return void\n     */\n    public function buildView(FormView $view, FormInterface $form, array $options)\n    {\n    }\n\n    /**\n     * @return void\n     */\n    public function finishView(FormView $view, FormInterface $form, array $options)\n    {\n    }\n\n    /**\n     * @return string\n     */\n    public function getBlockPrefix()\n    {\n        return StringUtil::fqcnToBlockPrefix(static::class) ?: '';\n    }\n}\n"
        },
        {
          "name": "AbstractTypeExtension.php",
          "type": "blob",
          "size": 0.830078125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nabstract class AbstractTypeExtension implements FormTypeExtensionInterface\n{\n    public function configureOptions(OptionsResolver $resolver): void\n    {\n    }\n\n    public function buildForm(FormBuilderInterface $builder, array $options): void\n    {\n    }\n\n    public function buildView(FormView $view, FormInterface $form, array $options): void\n    {\n    }\n\n    public function finishView(FormView $view, FormInterface $form, array $options): void\n    {\n    }\n}\n"
        },
        {
          "name": "Button.php",
          "type": "blob",
          "size": 7.6787109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Exception\\AlreadySubmittedException;\nuse Symfony\\Component\\Form\\Exception\\BadMethodCallException;\nuse Symfony\\Component\\Form\\Exception\\TransformationFailedException;\nuse Symfony\\Component\\PropertyAccess\\PropertyPathInterface;\n\n/**\n * A form button.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @implements \\IteratorAggregate<string, FormInterface>\n */\nclass Button implements \\IteratorAggregate, FormInterface\n{\n    private ?FormInterface $parent = null;\n    private bool $submitted = false;\n\n    /**\n     * Creates a new button from a form configuration.\n     */\n    public function __construct(\n        private FormConfigInterface $config,\n    ) {\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function offsetExists(mixed $offset): bool\n    {\n        return false;\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * This method should not be invoked.\n     *\n     * @throws BadMethodCallException\n     */\n    public function offsetGet(mixed $offset): FormInterface\n    {\n        throw new BadMethodCallException('Buttons cannot have children.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * This method should not be invoked.\n     *\n     * @throws BadMethodCallException\n     */\n    public function offsetSet(mixed $offset, mixed $value): void\n    {\n        throw new BadMethodCallException('Buttons cannot have children.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * This method should not be invoked.\n     *\n     * @throws BadMethodCallException\n     */\n    public function offsetUnset(mixed $offset): void\n    {\n        throw new BadMethodCallException('Buttons cannot have children.');\n    }\n\n    public function setParent(?FormInterface $parent): static\n    {\n        if ($this->submitted) {\n            throw new AlreadySubmittedException('You cannot set the parent of a submitted button.');\n        }\n\n        $this->parent = $parent;\n\n        return $this;\n    }\n\n    public function getParent(): ?FormInterface\n    {\n        return $this->parent;\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * This method should not be invoked.\n     *\n     * @throws BadMethodCallException\n     */\n    public function add(string|FormInterface $child, ?string $type = null, array $options = []): static\n    {\n        throw new BadMethodCallException('Buttons cannot have children.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * This method should not be invoked.\n     *\n     * @throws BadMethodCallException\n     */\n    public function get(string $name): FormInterface\n    {\n        throw new BadMethodCallException('Buttons cannot have children.');\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function has(string $name): bool\n    {\n        return false;\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * This method should not be invoked.\n     *\n     * @throws BadMethodCallException\n     */\n    public function remove(string $name): static\n    {\n        throw new BadMethodCallException('Buttons cannot have children.');\n    }\n\n    public function all(): array\n    {\n        return [];\n    }\n\n    public function getErrors(bool $deep = false, bool $flatten = true): FormErrorIterator\n    {\n        return new FormErrorIterator($this, []);\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * This method should not be invoked.\n     *\n     * @return $this\n     */\n    public function setData(mixed $modelData): static\n    {\n        // no-op, called during initialization of the form tree\n        return $this;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getData(): mixed\n    {\n        return null;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getNormData(): mixed\n    {\n        return null;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getViewData(): mixed\n    {\n        return null;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getExtraData(): array\n    {\n        return [];\n    }\n\n    /**\n     * Returns the button's configuration.\n     */\n    public function getConfig(): FormConfigInterface\n    {\n        return $this->config;\n    }\n\n    /**\n     * Returns whether the button is submitted.\n     */\n    public function isSubmitted(): bool\n    {\n        return $this->submitted;\n    }\n\n    /**\n     * Returns the name by which the button is identified in forms.\n     */\n    public function getName(): string\n    {\n        return $this->config->getName();\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getPropertyPath(): ?PropertyPathInterface\n    {\n        return null;\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function addError(FormError $error): static\n    {\n        throw new BadMethodCallException('Buttons cannot have errors.');\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function isValid(): bool\n    {\n        return true;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function isRequired(): bool\n    {\n        return false;\n    }\n\n    public function isDisabled(): bool\n    {\n        if ($this->parent?->isDisabled()) {\n            return true;\n        }\n\n        return $this->config->getDisabled();\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function isEmpty(): bool\n    {\n        return true;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function isSynchronized(): bool\n    {\n        return true;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getTransformationFailure(): ?TransformationFailedException\n    {\n        return null;\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function initialize(): static\n    {\n        throw new BadMethodCallException('Buttons cannot be initialized. Call initialize() on the root form instead.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function handleRequest(mixed $request = null): static\n    {\n        throw new BadMethodCallException('Buttons cannot handle requests. Call handleRequest() on the root form instead.');\n    }\n\n    /**\n     * Submits data to the button.\n     *\n     * @return $this\n     *\n     * @throws AlreadySubmittedException if the button has already been submitted\n     */\n    public function submit(array|string|null $submittedData, bool $clearMissing = true): static\n    {\n        if ($this->submitted) {\n            throw new AlreadySubmittedException('A form can only be submitted once.');\n        }\n\n        $this->submitted = true;\n\n        return $this;\n    }\n\n    public function getRoot(): FormInterface\n    {\n        return $this->parent ? $this->parent->getRoot() : $this;\n    }\n\n    public function isRoot(): bool\n    {\n        return null === $this->parent;\n    }\n\n    public function createView(?FormView $parent = null): FormView\n    {\n        if (null === $parent && $this->parent) {\n            $parent = $this->parent->createView();\n        }\n\n        $type = $this->config->getType();\n        $options = $this->config->getOptions();\n\n        $view = $type->createView($this, $parent);\n\n        $type->buildView($view, $this, $options);\n        $type->finishView($view, $this, $options);\n\n        return $view;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function count(): int\n    {\n        return 0;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getIterator(): \\EmptyIterator\n    {\n        return new \\EmptyIterator();\n    }\n}\n"
        },
        {
          "name": "ButtonBuilder.php",
          "type": "blob",
          "size": 14.4375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\Form\\Exception\\BadMethodCallException;\nuse Symfony\\Component\\Form\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\PropertyAccess\\PropertyPathInterface;\n\n/**\n * A builder for {@link Button} instances.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @implements \\IteratorAggregate<string, FormBuilderInterface>\n */\nclass ButtonBuilder implements \\IteratorAggregate, FormBuilderInterface\n{\n    protected bool $locked = false;\n\n    private bool $disabled = false;\n    private ResolvedFormTypeInterface $type;\n    private string $name;\n    private array $attributes = [];\n\n    /**\n     * @throws InvalidArgumentException if the name is empty\n     */\n    public function __construct(\n        ?string $name,\n        private array $options = [],\n    ) {\n        if ('' === $name || null === $name) {\n            throw new InvalidArgumentException('Buttons cannot have empty names.');\n        }\n\n        $this->name = $name;\n\n        FormConfigBuilder::validateName($name);\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function add(string|FormBuilderInterface $child, ?string $type = null, array $options = []): never\n    {\n        throw new BadMethodCallException('Buttons cannot have children.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function create(string $name, ?string $type = null, array $options = []): never\n    {\n        throw new BadMethodCallException('Buttons cannot have children.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function get(string $name): never\n    {\n        throw new BadMethodCallException('Buttons cannot have children.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function remove(string $name): never\n    {\n        throw new BadMethodCallException('Buttons cannot have children.');\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function has(string $name): bool\n    {\n        return false;\n    }\n\n    /**\n     * Returns the children.\n     */\n    public function all(): array\n    {\n        return [];\n    }\n\n    /**\n     * Creates the button.\n     */\n    public function getForm(): Button\n    {\n        return new Button($this->getFormConfig());\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function addEventListener(string $eventName, callable $listener, int $priority = 0): never\n    {\n        throw new BadMethodCallException('Buttons do not support event listeners.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function addEventSubscriber(EventSubscriberInterface $subscriber): never\n    {\n        throw new BadMethodCallException('Buttons do not support event subscribers.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function addViewTransformer(DataTransformerInterface $viewTransformer, bool $forcePrepend = false): never\n    {\n        throw new BadMethodCallException('Buttons do not support data transformers.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function resetViewTransformers(): never\n    {\n        throw new BadMethodCallException('Buttons do not support data transformers.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function addModelTransformer(DataTransformerInterface $modelTransformer, bool $forceAppend = false): never\n    {\n        throw new BadMethodCallException('Buttons do not support data transformers.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function resetModelTransformers(): never\n    {\n        throw new BadMethodCallException('Buttons do not support data transformers.');\n    }\n\n    /**\n     * @return $this\n     */\n    public function setAttribute(string $name, mixed $value): static\n    {\n        $this->attributes[$name] = $value;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setAttributes(array $attributes): static\n    {\n        $this->attributes = $attributes;\n\n        return $this;\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setDataMapper(?DataMapperInterface $dataMapper): never\n    {\n        throw new BadMethodCallException('Buttons do not support data mappers.');\n    }\n\n    /**\n     * Set whether the button is disabled.\n     *\n     * @return $this\n     */\n    public function setDisabled(bool $disabled): static\n    {\n        $this->disabled = $disabled;\n\n        return $this;\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setEmptyData(mixed $emptyData): never\n    {\n        throw new BadMethodCallException('Buttons do not support empty data.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setErrorBubbling(bool $errorBubbling): never\n    {\n        throw new BadMethodCallException('Buttons do not support error bubbling.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setRequired(bool $required): never\n    {\n        throw new BadMethodCallException('Buttons cannot be required.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setPropertyPath(string|PropertyPathInterface|null $propertyPath): never\n    {\n        throw new BadMethodCallException('Buttons do not support property paths.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setMapped(bool $mapped): never\n    {\n        throw new BadMethodCallException('Buttons do not support data mapping.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setByReference(bool $byReference): never\n    {\n        throw new BadMethodCallException('Buttons do not support data mapping.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setCompound(bool $compound): never\n    {\n        throw new BadMethodCallException('Buttons cannot be compound.');\n    }\n\n    /**\n     * Sets the type of the button.\n     *\n     * @return $this\n     */\n    public function setType(ResolvedFormTypeInterface $type): static\n    {\n        $this->type = $type;\n\n        return $this;\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setData(mixed $data): never\n    {\n        throw new BadMethodCallException('Buttons do not support data.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setDataLocked(bool $locked): never\n    {\n        throw new BadMethodCallException('Buttons do not support data locking.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setFormFactory(FormFactoryInterface $formFactory): never\n    {\n        throw new BadMethodCallException('Buttons do not support form factories.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setAction(string $action): never\n    {\n        throw new BadMethodCallException('Buttons do not support actions.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setMethod(string $method): never\n    {\n        throw new BadMethodCallException('Buttons do not support methods.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setRequestHandler(RequestHandlerInterface $requestHandler): never\n    {\n        throw new BadMethodCallException('Buttons do not support request handlers.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @return $this\n     *\n     * @throws BadMethodCallException\n     */\n    public function setAutoInitialize(bool $initialize): static\n    {\n        if (true === $initialize) {\n            throw new BadMethodCallException('Buttons do not support automatic initialization.');\n        }\n\n        return $this;\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setInheritData(bool $inheritData): never\n    {\n        throw new BadMethodCallException('Buttons do not support data inheritance.');\n    }\n\n    /**\n     * Builds and returns the button configuration.\n     */\n    public function getFormConfig(): FormConfigInterface\n    {\n        // This method should be idempotent, so clone the builder\n        $config = clone $this;\n        $config->locked = true;\n\n        return $config;\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function setIsEmptyCallback(?callable $isEmptyCallback): never\n    {\n        throw new BadMethodCallException('Buttons do not support \"is empty\" callback.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function getEventDispatcher(): never\n    {\n        throw new BadMethodCallException('Buttons do not support event dispatching.');\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getPropertyPath(): ?PropertyPathInterface\n    {\n        return null;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getMapped(): bool\n    {\n        return false;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getByReference(): bool\n    {\n        return false;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getCompound(): bool\n    {\n        return false;\n    }\n\n    /**\n     * Returns the form type used to construct the button.\n     */\n    public function getType(): ResolvedFormTypeInterface\n    {\n        return $this->type;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getViewTransformers(): array\n    {\n        return [];\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getModelTransformers(): array\n    {\n        return [];\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getDataMapper(): ?DataMapperInterface\n    {\n        return null;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getRequired(): bool\n    {\n        return false;\n    }\n\n    /**\n     * Returns whether the button is disabled.\n     */\n    public function getDisabled(): bool\n    {\n        return $this->disabled;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getErrorBubbling(): bool\n    {\n        return false;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getEmptyData(): mixed\n    {\n        return null;\n    }\n\n    /**\n     * Returns additional attributes of the button.\n     */\n    public function getAttributes(): array\n    {\n        return $this->attributes;\n    }\n\n    /**\n     * Returns whether the attribute with the given name exists.\n     */\n    public function hasAttribute(string $name): bool\n    {\n        return \\array_key_exists($name, $this->attributes);\n    }\n\n    /**\n     * Returns the value of the given attribute.\n     */\n    public function getAttribute(string $name, mixed $default = null): mixed\n    {\n        return \\array_key_exists($name, $this->attributes) ? $this->attributes[$name] : $default;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getData(): mixed\n    {\n        return null;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getDataClass(): ?string\n    {\n        return null;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getDataLocked(): bool\n    {\n        return false;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getFormFactory(): never\n    {\n        throw new BadMethodCallException('Buttons do not support adding children.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function getAction(): never\n    {\n        throw new BadMethodCallException('Buttons do not support actions.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function getMethod(): never\n    {\n        throw new BadMethodCallException('Buttons do not support methods.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function getRequestHandler(): never\n    {\n        throw new BadMethodCallException('Buttons do not support request handlers.');\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getAutoInitialize(): bool\n    {\n        return false;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getInheritData(): bool\n    {\n        return false;\n    }\n\n    /**\n     * Returns all options passed during the construction of the button.\n     */\n    public function getOptions(): array\n    {\n        return $this->options;\n    }\n\n    /**\n     * Returns whether a specific option exists.\n     */\n    public function hasOption(string $name): bool\n    {\n        return \\array_key_exists($name, $this->options);\n    }\n\n    /**\n     * Returns the value of a specific option.\n     */\n    public function getOption(string $name, mixed $default = null): mixed\n    {\n        return \\array_key_exists($name, $this->options) ? $this->options[$name] : $default;\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function getIsEmptyCallback(): never\n    {\n        throw new BadMethodCallException('Buttons do not support \"is empty\" callback.');\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function count(): int\n    {\n        return 0;\n    }\n\n    /**\n     * Unsupported method.\n     */\n    public function getIterator(): \\EmptyIterator\n    {\n        return new \\EmptyIterator();\n    }\n}\n"
        },
        {
          "name": "ButtonTypeInterface.php",
          "type": "blob",
          "size": 0.451171875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * A type that should be converted into a {@link Button} instance.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface ButtonTypeInterface extends FormTypeInterface\n{\n}\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 33.87109375,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Deprecate the `VersionAwareTest` trait, use feature detection instead\n * Add support for the `calendar` option in `DateType`\n * Add `LazyChoiceLoader` and `choice_lazy` option in `ChoiceType` for loading and rendering choices on demand\n * Use `form.post_set_data` instead of `form.pre_set_data` in `ResizeFormListener`\n * Change the priority of `DataCollectorListener` from 255 to -255\n\n7.1\n---\n\n * Add option `separator` to `ChoiceType` to use a custom separator after preferred choices (use the new `separator_html` option to display the separator text as HTML)\n * Deprecate not configuring the `default_protocol` option of the `UrlType`, it will default to `null` in 8.0 (the current default is `'http'`)\n * Add a `keep_as_list` option to `CollectionType`\n * Add an `input` option to `MoneyType`, to be able to cast the transformed value to `integer`\n\n7.0\n---\n\n * Throw when using `DateTime` or `DateTimeImmutable` model data with a different timezone than configured with the\n   `model_timezone` option in `DateType`, `DateTimeType`, and `TimeType`\n * Make the \"widget\" option of date/time form types default to \"single_text\"\n * Require explicit argument when calling `Button/Form::setParent()`, `ButtonBuilder/FormConfigBuilder::setDataMapper()`, `TransformationFailedException::setInvalidMessage()`\n\n6.4\n---\n\n * Deprecate using `DateTime` or `DateTimeImmutable` model data with a different timezone than configured with the\n   `model_timezone` option in `DateType`, `DateTimeType`, and `TimeType`\n * Deprecate `PostSetDataEvent::setData()`, use `PreSetDataEvent::setData()` instead\n * Deprecate `PostSubmitEvent::setData()`, use `PreSubmitDataEvent::setData()` or `SubmitDataEvent::setData()` instead\n * Add `duplicate_preferred_choices` option in `ChoiceType`\n * Add `$duplicatePreferredChoices` parameter to `ChoiceListFactoryInterface::createView()`\n\n6.3\n---\n\n * Don't render seconds for HTML5 date pickers unless \"with_seconds\" is explicitly set\n * Add a `placeholder_attr` option to `ChoiceType`\n * Deprecate not configuring the \"widget\" option of date/time form types, it will default to \"single_text\" in v7\n\n6.2\n---\n\n * Allow passing `TranslatableInterface` objects to the `ChoiceView` label\n * Allow passing `TranslatableInterface` objects to the `help` option\n * Deprecate calling `Button/Form::setParent()`, `ButtonBuilder/FormConfigBuilder::setDataMapper()`, `TransformationFailedException::setInvalidMessage()` without arguments\n * Change the signature of `FormConfigBuilderInterface::setDataMapper()` to `setDataMapper(?DataMapperInterface)`\n * Change the signature of `FormInterface::setParent()` to `setParent(?self)`\n * Add `PasswordHasherExtension` with support for `hash_property_path` option in `PasswordType`\n\n6.1\n---\n\n * Add a `prototype_options` option to `CollectionType`\n\n6.0\n---\n\n * Remove `PropertyPathMaper`\n * Remove `Symfony\\Component\\Form\\Extension\\Validator\\Util\\ServerParams`\n * Remove `FormPass` configuration\n * Remove the `NumberToLocalizedStringTransformer::ROUND_*` constants, use `\\NumberFormatter::ROUND_*` instead\n * The `rounding_mode` option of the `PercentType` defaults to `\\NumberFormatter::ROUND_HALFUP`\n * The rounding mode argument of the constructor of `PercentToLocalizedStringTransformer` defaults to `\\NumberFormatter::ROUND_HALFUP`\n * Add `FormConfigInterface::getIsEmptyCallback()` and `FormConfigBuilderInterface::setIsEmptyCallback()`\n * Change `$forms` parameter type of the `DataMapper::mapDataToForms()` method from `iterable` to `\\Traversable`\n * Change `$forms` parameter type of the `DataMapper::mapFormsToData()` method from `iterable` to `\\Traversable`\n * Change `$checkboxes` parameter type of the `CheckboxListMapper::mapDataToForms()` method from `iterable` to `\\Traversable`\n * Change `$checkboxes` parameter type of the `CheckboxListMapper::mapFormsToData()` method from `iterable` to `\\Traversable`\n * Change `$radios` parameter type of the `RadioListMapper::mapDataToForms()` method from `iterable` to `\\Traversable`\n * Change `$radios` parameter type of the `RadioListMapper::mapFormsToData()` method from `iterable` to `\\Traversable`\n\n5.4\n---\n\n * Deprecate calling `FormErrorIterator::children()` if the current element is not iterable.\n * Allow to pass `TranslatableMessage` objects to the `help` option\n * Add the `EnumType`\n\n5.3\n---\n\n * Changed `$forms` parameter type of the `DataMapperInterface::mapDataToForms()` method from `iterable` to `\\Traversable`.\n * Changed `$forms` parameter type of the `DataMapperInterface::mapFormsToData()` method from `iterable` to `\\Traversable`.\n * Deprecated passing an array as the second argument of the `DataMapper::mapDataToForms()` method, pass `\\Traversable` instead.\n * Deprecated passing an array as the first argument of the `DataMapper::mapFormsToData()` method, pass `\\Traversable` instead.\n * Deprecated passing an array as the second argument of the `CheckboxListMapper::mapDataToForms()` method, pass `\\Traversable` instead.\n * Deprecated passing an array as the first argument of the `CheckboxListMapper::mapFormsToData()` method, pass `\\Traversable` instead.\n * Deprecated passing an array as the second argument of the `RadioListMapper::mapDataToForms()` method, pass `\\Traversable` instead.\n * Deprecated passing an array as the first argument of the `RadioListMapper::mapFormsToData()` method, pass `\\Traversable` instead.\n * Added a `choice_translation_parameters` option to `ChoiceType`\n * Add `UuidType` and `UlidType`\n * Dependency on `symfony/intl` was removed. Install `symfony/intl` if you are using `LocaleType`, `CountryType`, `CurrencyType`, `LanguageType` or `TimezoneType`.\n * Add `priority` option to `BaseType` and sorting view fields\n\n5.2.0\n-----\n\n * Added support for using the `{{ label }}` placeholder in constraint messages, which is replaced in the `ViolationMapper` by the corresponding field form label.\n * Added `DataMapper`, `ChainAccessor`, `PropertyPathAccessor` and `CallbackAccessor` with new callable `getter` and `setter` options for each form type\n * Deprecated `PropertyPathMapper` in favor of `DataMapper` and `PropertyPathAccessor`\n * Added an `html5` option to `MoneyType` and `PercentType`, to use `<input type=\"number\" />`\n\n5.1.0\n-----\n\n * Deprecated not configuring the `rounding_mode` option of the `PercentType`. It will default to `\\NumberFormatter::ROUND_HALFUP` in Symfony 6.\n * Deprecated not passing a rounding mode to the constructor of `PercentToLocalizedStringTransformer`. It will default to `\\NumberFormatter::ROUND_HALFUP` in Symfony 6.\n * Added `collection_entry` block prefix to `CollectionType` entries\n * Added a `choice_filter` option to `ChoiceType`\n * Added argument `callable|null $filter` to `ChoiceListFactoryInterface::createListFromChoices()` and `createListFromLoader()` - not defining them is deprecated.\n * Added a `ChoiceList` facade to leverage explicit choice list caching based on options\n * Added an `AbstractChoiceLoader` to simplify implementations and handle global optimizations\n * The `view_timezone` option defaults to the `model_timezone` if no `reference_date` is configured.\n * Implementing the `FormConfigInterface` without implementing the `getIsEmptyCallback()` method\n   is deprecated. The method will be added to the interface in 6.0.\n * Implementing the `FormConfigBuilderInterface` without implementing the `setIsEmptyCallback()` method\n   is deprecated. The method will be added to the interface in 6.0.\n * Added a `rounding_mode` option for the PercentType and correctly round the value when submitted\n * Deprecated `Symfony\\Component\\Form\\Extension\\Validator\\Util\\ServerParams` in favor of its parent class `Symfony\\Component\\Form\\Util\\ServerParams`\n * Added the `html5` option to the `ColorType` to validate the input\n * Deprecated `NumberToLocalizedStringTransformer::ROUND_*` constants, use `\\NumberFormatter::ROUND_*` instead\n\n5.0.0\n-----\n\n * Removed support for using different values for the \"model_timezone\" and \"view_timezone\" options of the `TimeType`\n   without configuring a reference date.\n * Removed the `scale` option of the `IntegerType`.\n * Using the `date_format`, `date_widget`, and `time_widget` options of the `DateTimeType` when the `widget` option is\n   set to `single_text` is not supported anymore.\n * The `format` option of `DateType` and `DateTimeType` cannot be used when the `html5` option is enabled.\n * Using names for buttons that do not start with a letter, a digit, or an underscore throw an exception\n * Using names for buttons that do not contain only letters, digits, underscores, hyphens, and colons throw an exception.\n * removed the `ChoiceLoaderInterface` implementation in `CountryType`, `LanguageType`, `LocaleType` and `CurrencyType`\n * removed `getExtendedType()` method of the `FormTypeExtensionInterface`\n * added static `getExtendedTypes()` method to the `FormTypeExtensionInterface`\n * calling to `FormRenderer::searchAndRenderBlock()` method for fields which were already rendered throw a `BadMethodCallException`\n * removed the `regions` option of the `TimezoneType`\n * removed the `$scale` argument of the `IntegerToLocalizedStringTransformer`\n * removed `TemplatingExtension` and `TemplatingRendererEngine` classes, use Twig instead\n * passing a null message when instantiating a `Symfony\\Component\\Form\\FormError` is not allowed\n * removed support for using `int` or `float` as data for the `NumberType` when the `input` option is set to `string`\n\n4.4.0\n-----\n\n * add new `WeekType`\n * using different values for the \"model_timezone\" and \"view_timezone\" options of the `TimeType` without configuring a\n   reference date is deprecated\n * preferred choices are repeated in the list of all choices\n * deprecated using `int` or `float` as data for the `NumberType` when the `input` option is set to `string`\n * The type guesser guesses the HTML accept attribute when a mime type is configured in the File or Image constraint.\n * Overriding the methods `FormIntegrationTestCase::setUp()`, `TypeTestCase::setUp()` and `TypeTestCase::tearDown()` without the `void` return-type is deprecated.\n * marked all dispatched event classes as `@final`\n * Added the `validate` option to `SubmitType` to toggle the browser built-in form validation.\n * Added the `alpha3` option to `LanguageType` and `CountryType` to use alpha3 instead of alpha2 codes\n\n4.3.0\n-----\n\n * added a `symbol` option to the `PercentType` that allows to disable or customize the output of the percent character\n * Using the `format` option of `DateType` and `DateTimeType` when the `html5` option is enabled is deprecated.\n * Using names for buttons that do not start with a letter, a digit, or an underscore is deprecated and will lead to an\n   exception in 5.0.\n * Using names for buttons that do not contain only letters, digits, underscores, hyphens, and colons is deprecated and\n   will lead to an exception in 5.0.\n * added `html5` option to `NumberType` that allows to render `type=\"number\"` input fields\n * deprecated using the `date_format`, `date_widget`, and `time_widget` options of the `DateTimeType` when the `widget`\n   option is set to `single_text`\n * added `block_prefix` option to `BaseType`.\n * added `help_html` option to display the `help` text as HTML.\n * `FormError` doesn't implement `Serializable` anymore\n * `FormDataCollector` has been marked as `final`\n * added `label_translation_parameters`, `attr_translation_parameters`, `help_translation_parameters` options\n   to `FormType` to pass translation parameters to form labels, attributes (`placeholder` and `title`) and help text respectively.\n   The passed parameters will replace placeholders in translation messages.\n\n   ```php\n   class OrderType extends AbstractType\n   {\n       public function buildForm(FormBuilderInterface $builder, array $options)\n       {\n           $builder->add('comment', TextType::class, [\n               'label' => 'Comment to the order to %company%',\n               'label_translation_parameters' => [\n                   '%company%' => 'Acme',\n               ],\n               'help' => 'The address of the %company% is %address%',\n               'help_translation_parameters' => [\n                   '%company%' => 'Acme Ltd.',\n                   '%address%' => '4 Form street, Symfonyville',\n               ],\n           ])\n       }\n   }\n   ```\n * added the `input_format` option to `DateType`, `DateTimeType`, and `TimeType` to specify the input format when setting\n   the `input` option to `string`\n * dispatch `PreSubmitEvent` on `form.pre_submit`\n * dispatch `SubmitEvent` on `form.submit`\n * dispatch `PostSubmitEvent` on `form.post_submit`\n * dispatch `PreSetDataEvent` on `form.pre_set_data`\n * dispatch `PostSetDataEvent` on `form.post_set_data`\n * added an `input` option to `NumberType`\n * removed default option grouping in `TimezoneType`, use `group_by` instead\n\n4.2.0\n-----\n\n * The `getExtendedType()` method of the `FormTypeExtensionInterface` is deprecated and will be removed in 5.0. Type\n   extensions must implement the static `getExtendedTypes()` method instead and return an iterable of extended types.\n\n   Before:\n\n   ```php\n   class FooTypeExtension extends AbstractTypeExtension\n   {\n       public function getExtendedType()\n       {\n           return FormType::class;\n       }\n\n       // ...\n   }\n   ```\n\n   After:\n\n   ```php\n   class FooTypeExtension extends AbstractTypeExtension\n   {\n       public static function getExtendedTypes(): iterable\n       {\n           return [FormType::class];\n       }\n\n       // ...\n   }\n   ```\n * deprecated the `$scale` argument of the `IntegerToLocalizedStringTransformer`\n * added `Symfony\\Component\\Form\\ClearableErrorsInterface`\n * deprecated calling `FormRenderer::searchAndRenderBlock` for fields which were already rendered\n * added a cause when a CSRF error has occurred\n * deprecated the `scale` option of the `IntegerType`\n * removed restriction on allowed HTTP methods\n * deprecated the `regions` option of the `TimezoneType`\n\n4.1.0\n-----\n\n * added `input=datetime_immutable` to `DateType`, `TimeType`, `DateTimeType`\n * added `rounding_mode` option to `MoneyType`\n * added `choice_translation_locale` option to `CountryType`, `LanguageType`, `LocaleType` and `CurrencyType`\n * deprecated the `ChoiceLoaderInterface` implementation in `CountryType`, `LanguageType`, `LocaleType` and `CurrencyType`\n * added `input=datetime_immutable` to DateType, TimeType, DateTimeType\n * added `rounding_mode` option to MoneyType\n\n4.0.0\n-----\n\n * using the `choices` option in `CountryType`, `CurrencyType`, `LanguageType`,\n   `LocaleType`, and `TimezoneType` when the `choice_loader` option is not `null`\n   is not supported anymore and the configured choices will be ignored\n * callable strings that are passed to the options of the `ChoiceType` are\n   treated as property paths\n * the `choices_as_values` option of the `ChoiceType` has been removed\n * removed the support for caching loaded choice lists in `LazyChoiceList`,\n   cache the choice list in the used `ChoiceLoaderInterface` implementation\n   instead\n * removed the support for objects implementing both `\\Traversable` and `\\ArrayAccess` in `ResizeFormListener::preSubmit()`\n * removed the ability to use `FormDataCollector` without the `symfony/var-dumper` component\n * removed passing a `ValueExporter` instance to the `FormDataExtractor::__construct()` method\n * removed passing guesser services ids as the fourth argument of `DependencyInjectionExtension::__construct()`\n * removed the ability to validate an unsubmitted form.\n * removed `ChoiceLoaderInterface` implementation in `TimezoneType`\n * added the `false_values` option to the `CheckboxType` which allows to configure custom values which will be treated as `false` during submission\n\n3.4.0\n-----\n\n * added `DebugCommand`\n * deprecated `ChoiceLoaderInterface` implementation in `TimezoneType`\n * added options \"input\" and \"regions\" to `TimezoneType`\n * added an option to ``Symfony\\Component\\Form\\FormRendererEngineInterface::setTheme()`` and\n   ``Symfony\\Component\\Form\\FormRendererInterface::setTheme()`` to disable usage of default themes when rendering a form\n\n3.3.0\n-----\n\n * deprecated using \"choices\" option in ``CountryType``, ``CurrencyType``, ``LanguageType``, ``LocaleType``, and\n   ``TimezoneType`` when \"choice_loader\" is not ``null``\n * added `Symfony\\Component\\Form\\FormErrorIterator::findByCodes()`\n * added `getTypedExtensions`, `getTypes`, and `getTypeGuessers` to `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase`\n * added `FormPass`\n\n3.2.0\n-----\n\n * added `CallbackChoiceLoader`\n * implemented `ChoiceLoaderInterface` in children of `ChoiceType`\n\n3.1.0\n-----\n\n * deprecated the \"choices_as_values\" option of ChoiceType\n * deprecated support for data objects that implements both `Traversable` and\n   `ArrayAccess` in `ResizeFormListener::preSubmit` method\n * Using callable strings as choice options in `ChoiceType` has been deprecated\n   and will be used as `PropertyPath` instead of callable in Symfony 4.0.\n * implemented `DataTransformerInterface` in `TextType`\n * deprecated caching loaded choice list in `LazyChoiceList::$loadedList`\n\n3.0.0\n-----\n\n * removed `FormTypeInterface::setDefaultOptions()` method\n * removed `AbstractType::setDefaultOptions()` method\n * removed `FormTypeExtensionInterface::setDefaultOptions()` method\n * removed `AbstractTypeExtension::setDefaultOptions()` method\n * added `FormTypeInterface::configureOptions()` method\n * added `FormTypeExtensionInterface::configureOptions()` method\n\n2.8.0\n-----\n\n * added option \"choice_translation_domain\" to DateType, TimeType and DateTimeType.\n * deprecated option \"read_only\" in favor of \"attr['readonly']\"\n * added the html5 \"range\" FormType\n * deprecated the \"cascade_validation\" option in favor of setting \"constraints\"\n   with the Valid constraint\n * moved data trimming logic of TrimListener into StringUtil\n * [BC BREAK] When registering a type extension through the DI extension, the tag alias has to match the actual extended type.\n\n2.7.38\n------\n\n * [BC BREAK] the `isFileUpload()` method was added to the `RequestHandlerInterface`\n\n2.7.0\n-----\n\n * added option \"choice_translation_domain\" to ChoiceType.\n * deprecated option \"precision\" in favor of \"scale\"\n * deprecated the overwriting of AbstractType::setDefaultOptions() in favor of overwriting AbstractType::configureOptions().\n * deprecated the overwriting of AbstractTypeExtension::setDefaultOptions() in favor of overwriting AbstractTypeExtension::configureOptions().\n * added new ChoiceList interface and implementations in the Symfony\\Component\\Form\\ChoiceList namespace\n * added new ChoiceView in the Symfony\\Component\\Form\\ChoiceList\\View namespace\n * choice groups are now represented by ChoiceGroupView objects in the view\n * deprecated the old ChoiceList interface and implementations\n * deprecated the old ChoiceView class\n * added CheckboxListMapper and RadioListMapper\n * deprecated ChoiceToBooleanArrayTransformer and ChoicesToBooleanArrayTransformer\n * deprecated FixCheckboxInputListener and FixRadioInputListener\n * deprecated the \"choice_list\" option of ChoiceType\n * added new options to ChoiceType:\n   * \"choices_as_values\"\n   * \"choice_loader\"\n   * \"choice_label\"\n   * \"choice_name\"\n   * \"choice_value\"\n   * \"choice_attr\"\n   * \"group_by\"\n\n2.6.2\n-----\n\n * Added back the `model_timezone` and `view_timezone` options for `TimeType`, `DateType`\n   and `BirthdayType`\n\n2.6.0\n-----\n\n * added \"html5\" option to Date, Time and DateTimeFormType to be able to\n   enable/disable HTML5 input date when widget option is \"single_text\"\n * added \"label_format\" option with possible placeholders \"%name%\" and \"%id%\"\n * [BC BREAK] drop support for model_timezone and view_timezone options in TimeType, DateType and BirthdayType,\n   update to 2.6.2 to get back support for these options\n\n2.5.0\n------\n\n * deprecated options \"max_length\" and \"pattern\" in favor of putting these values in \"attr\" option\n * added an option for multiple files upload\n * form errors now reference their cause (constraint violation, exception, ...)\n * form errors now remember which form they were originally added to\n * [BC BREAK] added two optional parameters to FormInterface::getErrors() and\n   changed the method to return a Symfony\\Component\\Form\\FormErrorIterator\n   instance instead of an array\n * errors mapped to unsubmitted forms are discarded now\n * ObjectChoiceList now compares choices by their value, if a value path is\n   given\n * you can now pass interface names in the \"data_class\" option\n * [BC BREAK] added `FormInterface::getTransformationFailure()`\n\n2.4.0\n-----\n\n * moved CSRF implementation to the new Security CSRF sub-component\n * deprecated CsrfProviderInterface and its implementations\n * deprecated options \"csrf_provider\" and \"intention\" in favor of the new options \"csrf_token_manager\" and \"csrf_token_id\"\n\n2.3.0\n-----\n\n * deprecated FormPerformanceTestCase and FormIntegrationTestCase in the Symfony\\Component\\Form\\Tests namespace and moved them to the Symfony\\Component\\Form\\Test namespace\n * deprecated TypeTestCase in the Symfony\\Component\\Form\\Tests\\Extension\\Core\\Type namespace and moved it to the Symfony\\Component\\Form\\Test namespace\n * changed FormRenderer::humanize() to humanize also camel cased field name\n * added RequestHandlerInterface and FormInterface::handleRequest()\n * deprecated passing a Request instance to FormInterface::bind()\n * added options \"method\" and \"action\" to FormType\n * deprecated option \"virtual\" in favor \"inherit_data\"\n * deprecated VirtualFormAwareIterator in favor of InheritDataAwareIterator\n * [BC BREAK] removed the \"array\" type hint from DataMapperInterface\n * improved forms inheriting their parent data to actually return that data from getData(), getNormData() and getViewData()\n * added component-level exceptions for various SPL exceptions\n   changed all uses of the deprecated Exception class to use more specialized exceptions instead\n   removed NotInitializedException, NotValidException, TypeDefinitionException, TypeLoaderException, CreationException\n * added events PRE_SUBMIT, SUBMIT and POST_SUBMIT\n * deprecated events PRE_BIND, BIND and POST_BIND\n * [BC BREAK] renamed bind() and isBound() in FormInterface to submit() and isSubmitted()\n * added methods submit() and isSubmitted() to Form\n * deprecated bind() and isBound() in Form\n * deprecated AlreadyBoundException in favor of AlreadySubmittedException\n * added support for PATCH requests\n * [BC BREAK] added initialize() to FormInterface\n * [BC BREAK] added getAutoInitialize() to FormConfigInterface\n * [BC BREAK] added setAutoInitialize() to FormConfigBuilderInterface\n * [BC BREAK] initialization for Form instances added to a form tree must be manually disabled\n * PRE_SET_DATA is now guaranteed to be called after children were added by the form builder,\n   unless FormInterface::setData() is called manually\n * fixed CSRF error message to be translated\n * custom CSRF error messages can now be set through the \"csrf_message\" option\n * fixed: expanded single-choice fields now show a radio button for the empty value\n\n2.2.0\n-----\n\n * TrimListener now removes unicode whitespaces\n * deprecated getParent(), setParent() and hasParent() in FormBuilderInterface\n * FormInterface::add() now accepts a FormInterface instance OR a field's name, type and options\n * removed special characters between the choice or text fields of DateType unless\n   the option \"format\" is set to a custom value\n * deprecated FormException and introduced ExceptionInterface instead\n * [BC BREAK] FormException is now an interface\n * protected FormBuilder methods from being called when it is turned into a FormConfigInterface with getFormConfig()\n * [BC BREAK] inserted argument `$message` in the constructor of `FormError`\n * the PropertyPath class and related classes were moved to a dedicated\n   PropertyAccess component. During the move, InvalidPropertyException was\n   renamed to NoSuchPropertyException. FormUtil was split: FormUtil::singularify()\n   can now be found in Symfony\\Component\\PropertyAccess\\StringUtil. The methods\n   getValue() and setValue() from PropertyPath were extracted into a new class\n   PropertyAccessor.\n * added an optional PropertyAccessorInterface parameter to FormType,\n   ObjectChoiceList and PropertyPathMapper\n * [BC BREAK] PropertyPathMapper and FormType now have a constructor\n * [BC BREAK] setting the option \"validation_groups\" to ``false`` now disables validation\n   instead of assuming group \"Default\"\n\n2.1.0\n-----\n\n * [BC BREAK] ``read_only`` field attribute now renders as ``readonly=\"readonly\"``, use ``disabled`` instead\n * [BC BREAK] child forms now aren't validated anymore by default\n * made validation of form children configurable (new option: cascade_validation)\n * added support for validation groups as callbacks\n * made the translation catalogue configurable via the \"translation_domain\" option\n * added Form::getErrorsAsString() to help debugging forms\n * allowed setting different options for RepeatedType fields (like the label)\n * added support for empty form name at root level, this enables rendering forms\n   without form name prefix in field names\n * [BC BREAK] form and field names must start with a letter, digit or underscore\n   and only contain letters, digits, underscores, hyphens and colons\n * [BC BREAK] changed default name of the prototype in the \"collection\" type\n   from \"$$name$$\" to \"\\__name\\__\". No dollars are appended/prepended to custom\n   names anymore.\n * [BC BREAK] improved ChoiceListInterface\n * [BC BREAK] added SimpleChoiceList and LazyChoiceList as replacement of\n   ArrayChoiceList\n * added ChoiceList and ObjectChoiceList to use objects as choices\n * [BC BREAK] removed EntitiesToArrayTransformer and EntityToIdTransformer.\n   The former has been replaced by CollectionToArrayTransformer in combination\n   with EntityChoiceList, the latter is not required in the core anymore.\n * [BC BREAK] renamed\n   * ArrayToBooleanChoicesTransformer to ChoicesToBooleanArrayTransformer\n   * ScalarToBooleanChoicesTransformer to ChoiceToBooleanArrayTransformer\n   * ArrayToChoicesTransformer to ChoicesToValuesTransformer\n   * ScalarToChoiceTransformer to ChoiceToValueTransformer\n   to be consistent with the naming in ChoiceListInterface.\n   They were merged into ChoiceList and have no public equivalent anymore.\n * choice fields now throw a FormException if neither the \"choices\" nor the\n   \"choice_list\" option is set\n * the radio type is now a child of the checkbox type\n * the collection, choice (with multiple selection) and entity (with multiple\n   selection) types now make use of addXxx() and removeXxx() methods in your\n   model if you set \"by_reference\" to false. For a custom, non-recognized\n   singular form, set the \"property_path\" option like this: \"plural|singular\"\n * forms now don't create an empty object anymore if they are completely\n   empty and not required. The empty value for such forms is null.\n * added constant Guess::VERY_HIGH_CONFIDENCE\n * [BC BREAK] The methods `add`, `remove`, `setParent`, `bind` and `setData`\n   in class Form now throw an exception if the form is already bound\n * fields of constrained classes without a NotBlank or NotNull constraint are\n   set to not required now, as stated in the docs\n * fixed TimeType and DateTimeType to not display seconds when \"widget\" is\n   \"single_text\" unless \"with_seconds\" is set to true\n * checkboxes of in an expanded multiple-choice field don't include the choice\n   in their name anymore. Their names terminate with \"[]\" now.\n * deprecated FormValidatorInterface and substituted its implementations\n   by event subscribers\n * simplified CSRF protection and removed the csrf type\n * deprecated FieldType and merged it into FormType\n * added new option \"compound\" that lets you switch between field and form behavior\n * [BC BREAK] renamed theme blocks\n   * \"field_*\" to \"form_*\"\n   * \"field_widget\" to \"form_widget_simple\"\n   * \"widget_choice_options\" to \"choice_widget_options\"\n   * \"generic_label\" to \"form_label\"\n * added theme blocks \"form_widget_compound\", \"choice_widget_expanded\" and\n   \"choice_widget_collapsed\" to make theming more modular\n * ValidatorTypeGuesser now guesses \"collection\" for array type constraint\n * added method `guessPattern` to FormTypeGuesserInterface to guess which pattern to use in the HTML5 attribute \"pattern\"\n * deprecated method `guessMinLength` in favor of `guessPattern`\n * labels don't display field attributes anymore. Label attributes can be\n   passed in the \"label_attr\" option/variable\n * added option \"mapped\" which should be used instead of setting \"property_path\" to false\n * [BC BREAK] \"data_class\" now *must* be set if a form maps to an object and should be left empty otherwise\n * improved error mapping on forms\n   * dot (\".\") rules are now allowed to map errors assigned to a form to\n     one of its children\n * errors are not mapped to unsynchronized forms anymore\n * [BC BREAK] changed Form constructor to accept a single `FormConfigInterface` object\n * [BC BREAK] changed argument order in the FormBuilder constructor\n * added Form method `getViewData`\n * deprecated Form methods\n   * `getTypes`\n   * `getErrorBubbling`\n   * `getNormTransformers`\n   * `getClientTransformers`\n   * `getAttribute`\n   * `hasAttribute`\n   * `getClientData`\n * added FormBuilder methods\n   * `getTypes`\n   * `addViewTransformer`\n   * `getViewTransformers`\n   * `resetViewTransformers`\n   * `addModelTransformer`\n   * `getModelTransformers`\n   * `resetModelTransformers`\n * deprecated FormBuilder methods\n   * `prependClientTransformer`\n   * `appendClientTransformer`\n   * `getClientTransformers`\n   * `resetClientTransformers`\n   * `prependNormTransformer`\n   * `appendNormTransformer`\n   * `getNormTransformers`\n   * `resetNormTransformers`\n * deprecated the option \"validation_constraint\" in favor of the new\n   option \"constraints\"\n * removed superfluous methods from DataMapperInterface\n   * `mapFormToData`\n   * `mapDataToForm`\n * added `setDefaultOptions` to FormTypeInterface and FormTypeExtensionInterface\n   which accepts an OptionsResolverInterface instance\n * deprecated the methods `getDefaultOptions` and `getAllowedOptionValues`\n   in FormTypeInterface and FormTypeExtensionInterface\n * options passed during construction can now be accessed from FormConfigInterface\n * added FormBuilderInterface and FormConfigEditorInterface\n * [BC BREAK] the method `buildForm` in FormTypeInterface and FormTypeExtensionInterface\n   now receives a FormBuilderInterface instead of a FormBuilder instance\n * [BC BREAK] the method `buildViewBottomUp` was renamed to `finishView` in\n   FormTypeInterface and FormTypeExtensionInterface\n * [BC BREAK] the options array is now passed as last argument of the\n   methods\n   * `buildView`\n   * `finishView`\n   in FormTypeInterface and FormTypeExtensionInterface\n * [BC BREAK] no options are passed to `getParent` of FormTypeInterface anymore\n * deprecated DataEvent and FilterDataEvent in favor of the new FormEvent which is\n   now passed to all events thrown by the component\n * FormEvents::BIND now replaces FormEvents::BIND_NORM_DATA\n * FormEvents::PRE_SET_DATA now replaces FormEvents::SET_DATA\n * FormEvents::PRE_BIND now replaces FormEvents::BIND_CLIENT_DATA\n * deprecated FormEvents::SET_DATA, FormEvents::BIND_CLIENT_DATA and\n   FormEvents::BIND_NORM_DATA\n * [BC BREAK] reversed the order of the first two arguments to `createNamed`\n   and `createNamedBuilder` in `FormFactoryInterface`\n * deprecated `getChildren` in Form and FormBuilder in favor of `all`\n * deprecated `hasChildren` in Form and FormBuilder in favor of `count`\n * FormBuilder now implements \\IteratorAggregate\n * [BC BREAK] compound forms now always need a data mapper\n * FormBuilder now maintains the order when explicitly adding form builders as children\n * ChoiceType now doesn't add the empty value anymore if the choices already contain an empty element\n * DateType, TimeType and DateTimeType now show empty values again if not required\n * [BC BREAK] fixed rendering of errors for DateType, BirthdayType and similar ones\n * [BC BREAK] fixed: form constraints are only validated if they belong to the validated group\n * deprecated `bindRequest` in `Form` and replaced it by a listener to FormEvents::PRE_BIND\n * fixed: the \"data\" option supersedes default values from the model\n * changed DateType to refer to the \"format\" option for calculating the year and day choices instead\n   of padding them automatically\n * [BC BREAK] DateType defaults to the format \"yyyy-MM-dd\" now if the widget is\n   \"single_text\", in order to support the HTML 5 date field out of the box\n * added the option \"format\" to DateTimeType\n * [BC BREAK] DateTimeType now outputs RFC 3339 dates by default, as generated and\n   consumed by HTML5 browsers, if the widget is \"single_text\"\n * deprecated the options \"data_timezone\" and \"user_timezone\" in DateType, DateTimeType and TimeType\n   and renamed them to \"model_timezone\" and \"view_timezone\"\n * fixed: TransformationFailedExceptions thrown in the model transformer are now caught by the form\n * added FormRegistryInterface, ResolvedFormTypeInterface and ResolvedFormTypeFactoryInterface\n * deprecated FormFactory methods\n   * `addType`\n   * `hasType`\n   * `getType`\n * [BC BREAK] FormFactory now expects a FormRegistryInterface and a ResolvedFormTypeFactoryInterface as constructor argument\n * [BC BREAK] The method `createBuilder` in FormTypeInterface is not supported anymore for performance reasons\n * [BC BREAK] Removed `setTypes` from FormBuilder\n * deprecated AbstractType methods\n   * `getExtensions`\n   * `setExtensions`\n * ChoiceType now caches its created choice lists to improve performance\n * [BC BREAK] Rows of a collection field cannot be themed individually anymore. All rows in the collection\n   field now have the same block names, which contains \"entry\" where it previously contained the row index.\n * [BC BREAK] When registering a type through the DI extension, the tag alias has to match the actual type name.\n * added FormRendererInterface, FormRendererEngineInterface and implementations of these interfaces\n * [BC BREAK] removed the following methods from FormUtil:\n   * `toArrayKey`\n   * `toArrayKeys`\n   * `isChoiceGroup`\n   * `isChoiceSelected`\n * [BC BREAK] renamed method `renderBlock` in FormHelper to `block` and changed its signature\n * made FormView properties public and deprecated their accessor methods\n * made the normalized data of a form accessible in the template through the variable \"form.vars.data\"\n * made the original data of a choice accessible in the template through the property \"choice.data\"\n * added convenience class Forms and FormFactoryBuilderInterface\n"
        },
        {
          "name": "CallbackTransformer.php",
          "type": "blob",
          "size": 0.8125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nclass CallbackTransformer implements DataTransformerInterface\n{\n    private \\Closure $transform;\n    private \\Closure $reverseTransform;\n\n    public function __construct(callable $transform, callable $reverseTransform)\n    {\n        $this->transform = $transform(...);\n        $this->reverseTransform = $reverseTransform(...);\n    }\n\n    public function transform(mixed $data): mixed\n    {\n        return ($this->transform)($data);\n    }\n\n    public function reverseTransform(mixed $data): mixed\n    {\n        return ($this->reverseTransform)($data);\n    }\n}\n"
        },
        {
          "name": "ChoiceList",
          "type": "tree",
          "content": null
        },
        {
          "name": "ClearableErrorsInterface.php",
          "type": "blob",
          "size": 0.6328125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * A form element whose errors can be cleared.\n *\n * @author Colin O'Dell <colinodell@gmail.com>\n */\ninterface ClearableErrorsInterface\n{\n    /**\n     * Removes all the errors of this form.\n     *\n     * @param bool $deep Whether to remove errors from child forms as well\n     *\n     * @return $this\n     */\n    public function clearErrors(bool $deep = false): static;\n}\n"
        },
        {
          "name": "ClickableInterface.php",
          "type": "blob",
          "size": 0.4892578125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * A clickable form element.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface ClickableInterface\n{\n    /**\n     * Returns whether this element was clicked.\n     */\n    public function isClicked(): bool;\n}\n"
        },
        {
          "name": "Command",
          "type": "tree",
          "content": null
        },
        {
          "name": "Console",
          "type": "tree",
          "content": null
        },
        {
          "name": "DataAccessorInterface.php",
          "type": "blob",
          "size": 1.5693359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * Writes and reads values to/from an object or array bound to a form.\n *\n * @author Yonel Ceruto <yonelceruto@gmail.com>\n */\ninterface DataAccessorInterface\n{\n    /**\n     * Returns the value at the end of the property of the object graph.\n     *\n     * @throws Exception\\AccessException If unable to read from the given form data\n     */\n    public function getValue(object|array $viewData, FormInterface $form): mixed;\n\n    /**\n     * Sets the value at the end of the property of the object graph.\n     *\n     * @throws Exception\\AccessException If unable to write the given value\n     */\n    public function setValue(object|array &$viewData, mixed $value, FormInterface $form): void;\n\n    /**\n     * Returns whether a value can be read from an object graph.\n     *\n     * Whenever this method returns true, {@link getValue()} is guaranteed not\n     * to throw an exception when called with the same arguments.\n     */\n    public function isReadable(object|array $viewData, FormInterface $form): bool;\n\n    /**\n     * Returns whether a value can be written at a given object graph.\n     *\n     * Whenever this method returns true, {@link setValue()} is guaranteed not\n     * to throw an exception when called with the same arguments.\n     */\n    public function isWritable(object|array $viewData, FormInterface $form): bool;\n}\n"
        },
        {
          "name": "DataMapperInterface.php",
          "type": "blob",
          "size": 2.4248046875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface DataMapperInterface\n{\n    /**\n     * Maps the view data of a compound form to its children.\n     *\n     * The method is responsible for calling {@link FormInterface::setData()}\n     * on the children of compound forms, defining their underlying model data.\n     *\n     * @param mixed                              $viewData View data of the compound form being initialized\n     * @param \\Traversable<mixed, FormInterface> $forms    A list of {@link FormInterface} instances\n     *\n     * @throws Exception\\UnexpectedTypeException if the type of the data parameter is not supported\n     */\n    public function mapDataToForms(mixed $viewData, \\Traversable $forms): void;\n\n    /**\n     * Maps the model data of a list of children forms into the view data of their parent.\n     *\n     * This is the internal cascade call of FormInterface::submit for compound forms, since they\n     * cannot be bound to any input nor the request as scalar, but their children may:\n     *\n     *     $compoundForm->submit($arrayOfChildrenViewData)\n     *     // inside:\n     *     $childForm->submit($childViewData);\n     *     // for each entry, do the same and/or reverse transform\n     *     $this->dataMapper->mapFormsToData($compoundForm, $compoundInitialViewData)\n     *     // then reverse transform\n     *\n     * When a simple form is submitted the following is happening:\n     *\n     *     $simpleForm->submit($submittedViewData)\n     *     // inside:\n     *     $this->viewData = $submittedViewData\n     *     // then reverse transform\n     *\n     * The model data can be an array or an object, so this second argument is always passed\n     * by reference.\n     *\n     * @param \\Traversable<mixed, FormInterface> $forms     A list of {@link FormInterface} instances\n     * @param mixed                              &$viewData The compound form's view data that get mapped\n     *                                                      its children model data\n     *\n     * @throws Exception\\UnexpectedTypeException if the type of the data parameter is not supported\n     */\n    public function mapFormsToData(\\Traversable $forms, mixed &$viewData): void;\n}\n"
        },
        {
          "name": "DataTransformerInterface.php",
          "type": "blob",
          "size": 3.833984375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Exception\\TransformationFailedException;\n\n/**\n * Transforms a value between different representations.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @template TValue\n * @template TTransformedValue\n */\ninterface DataTransformerInterface\n{\n    /**\n     * Transforms a value from the original representation to a transformed representation.\n     *\n     * This method is called when the form field is initialized with its default data, on\n     * two occasions for two types of transformers:\n     *\n     * 1. Model transformers which normalize the model data.\n     *    This is mainly useful when the same form type (the same configuration)\n     *    has to handle different kind of underlying data, e.g The DateType can\n     *    deal with strings or \\DateTime objects as input.\n     *\n     * 2. View transformers which adapt the normalized data to the view format.\n     *    a/ When the form is simple, the value returned by convention is used\n     *       directly in the view and thus can only be a string or an array. In\n     *       this case the data class should be null.\n     *\n     *    b/ When the form is compound the returned value should be an array or\n     *       an object to be mapped to the children. Each property of the compound\n     *       data will be used as model data by each child and will be transformed\n     *       too. In this case data class should be the class of the object, or null\n     *       when it is an array.\n     *\n     * All transformers are called in a configured order from model data to view value.\n     * At the end of this chain the view data will be validated against the data class\n     * setting.\n     *\n     * This method must be able to deal with empty values. Usually this will\n     * be NULL, but depending on your implementation other empty values are\n     * possible as well (such as empty strings). The reasoning behind this is\n     * that data transformers must be chainable. If the transform() method\n     * of the first data transformer outputs NULL, the second must be able to\n     * process that value.\n     *\n     * @param TValue|null $value The value in the original representation\n     *\n     * @return TTransformedValue|null\n     *\n     * @throws TransformationFailedException when the transformation fails\n     */\n    public function transform(mixed $value): mixed;\n\n    /**\n     * Transforms a value from the transformed representation to its original\n     * representation.\n     *\n     * This method is called when {@link Form::submit()} is called to transform the requests tainted data\n     * into an acceptable format.\n     *\n     * The same transformers are called in the reverse order so the responsibility is to\n     * return one of the types that would be expected as input of transform().\n     *\n     * This method must be able to deal with empty values. Usually this will\n     * be an empty string, but depending on your implementation other empty\n     * values are possible as well (such as NULL). The reasoning behind\n     * this is that value transformers must be chainable. If the\n     * reverseTransform() method of the first value transformer outputs an\n     * empty string, the second value transformer must be able to process that\n     * value.\n     *\n     * By convention, reverseTransform() should return NULL if an empty string\n     * is passed.\n     *\n     * @param TTransformedValue|null $value The value in the transformed representation\n     *\n     * @return TValue|null\n     *\n     * @throws TransformationFailedException when the transformation fails\n     */\n    public function reverseTransform(mixed $value): mixed;\n}\n"
        },
        {
          "name": "DependencyInjection",
          "type": "tree",
          "content": null
        },
        {
          "name": "Event",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Extension",
          "type": "tree",
          "content": null
        },
        {
          "name": "FileUploadError.php",
          "type": "blob",
          "size": 0.330078125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * @internal\n */\nclass FileUploadError extends FormError\n{\n}\n"
        },
        {
          "name": "Form.php",
          "type": "blob",
          "size": 35.576171875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Event\\PostSetDataEvent;\nuse Symfony\\Component\\Form\\Event\\PostSubmitEvent;\nuse Symfony\\Component\\Form\\Event\\PreSetDataEvent;\nuse Symfony\\Component\\Form\\Event\\PreSubmitEvent;\nuse Symfony\\Component\\Form\\Event\\SubmitEvent;\nuse Symfony\\Component\\Form\\Exception\\AlreadySubmittedException;\nuse Symfony\\Component\\Form\\Exception\\LogicException;\nuse Symfony\\Component\\Form\\Exception\\OutOfBoundsException;\nuse Symfony\\Component\\Form\\Exception\\RuntimeException;\nuse Symfony\\Component\\Form\\Exception\\TransformationFailedException;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\nuse Symfony\\Component\\Form\\Util\\FormUtil;\nuse Symfony\\Component\\Form\\Util\\InheritDataAwareIterator;\nuse Symfony\\Component\\Form\\Util\\OrderedHashMap;\nuse Symfony\\Component\\PropertyAccess\\PropertyPath;\nuse Symfony\\Component\\PropertyAccess\\PropertyPathInterface;\n\n/**\n * Form represents a form.\n *\n * To implement your own form fields, you need to have a thorough understanding\n * of the data flow within a form. A form stores its data in three different\n * representations:\n *\n *   (1) the \"model\" format required by the form's object\n *   (2) the \"normalized\" format for internal processing\n *   (3) the \"view\" format used for display simple fields\n *       or map children model data for compound fields\n *\n * A date field, for example, may store a date as \"Y-m-d\" string (1) in the\n * object. To facilitate processing in the field, this value is normalized\n * to a DateTime object (2). In the HTML representation of your form, a\n * localized string (3) may be presented to and modified by the user, or it could be an array of values\n * to be mapped to choices fields.\n *\n * In most cases, format (1) and format (2) will be the same. For example,\n * a checkbox field uses a Boolean value for both internal processing and\n * storage in the object. In these cases you need to set a view transformer\n * to convert between formats (2) and (3). You can do this by calling\n * addViewTransformer().\n *\n * In some cases though it makes sense to make format (1) configurable. To\n * demonstrate this, let's extend our above date field to store the value\n * either as \"Y-m-d\" string or as timestamp. Internally we still want to\n * use a DateTime object for processing. To convert the data from string/integer\n * to DateTime you can set a model transformer by calling\n * addModelTransformer(). The normalized data is then converted to the displayed\n * data as described before.\n *\n * The conversions (1) -> (2) -> (3) use the transform methods of the transformers.\n * The conversions (3) -> (2) -> (1) use the reverseTransform methods of the transformers.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @implements \\IteratorAggregate<string, FormInterface>\n */\nclass Form implements \\IteratorAggregate, FormInterface, ClearableErrorsInterface\n{\n    private ?FormInterface $parent = null;\n\n    /**\n     * A map of FormInterface instances.\n     *\n     * @var OrderedHashMap<FormInterface>\n     */\n    private OrderedHashMap $children;\n\n    /**\n     * @var FormError[]\n     */\n    private array $errors = [];\n\n    private bool $submitted = false;\n\n    /**\n     * The button that was used to submit the form.\n     */\n    private FormInterface|ClickableInterface|null $clickedButton = null;\n\n    private mixed $modelData = null;\n    private mixed $normData = null;\n    private mixed $viewData = null;\n\n    /**\n     * The submitted values that don't belong to any children.\n     */\n    private array $extraData = [];\n\n    /**\n     * The transformation failure generated during submission, if any.\n     */\n    private ?TransformationFailedException $transformationFailure = null;\n\n    /**\n     * Whether the form's data has been initialized.\n     *\n     * When the data is initialized with its default value, that default value\n     * is passed through the transformer chain in order to synchronize the\n     * model, normalized and view format for the first time. This is done\n     * lazily in order to save performance when {@link setData()} is called\n     * manually, making the initialization with the configured default value\n     * superfluous.\n     */\n    private bool $defaultDataSet = false;\n\n    /**\n     * Whether setData() is currently being called.\n     */\n    private bool $lockSetData = false;\n\n    private string $name = '';\n\n    /**\n     * Whether the form inherits its underlying data from its parent.\n     */\n    private bool $inheritData;\n\n    private ?PropertyPathInterface $propertyPath = null;\n\n    /**\n     * @throws LogicException if a data mapper is not provided for a compound form\n     */\n    public function __construct(\n        private FormConfigInterface $config,\n    ) {\n        // Compound forms always need a data mapper, otherwise calls to\n        // `setData` and `add` will not lead to the correct population of\n        // the child forms.\n        if ($config->getCompound() && !$config->getDataMapper()) {\n            throw new LogicException('Compound forms need a data mapper.');\n        }\n\n        // If the form inherits the data from its parent, it is not necessary\n        // to call setData() with the default data.\n        if ($this->inheritData = $config->getInheritData()) {\n            $this->defaultDataSet = true;\n        }\n\n        $this->children = new OrderedHashMap();\n        $this->name = $config->getName();\n    }\n\n    public function __clone()\n    {\n        $this->children = clone $this->children;\n\n        foreach ($this->children as $key => $child) {\n            $this->children[$key] = clone $child;\n        }\n    }\n\n    public function getConfig(): FormConfigInterface\n    {\n        return $this->config;\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    public function getPropertyPath(): ?PropertyPathInterface\n    {\n        if ($this->propertyPath || $this->propertyPath = $this->config->getPropertyPath()) {\n            return $this->propertyPath;\n        }\n\n        if ('' === $this->name) {\n            return null;\n        }\n\n        $parent = $this->parent;\n\n        while ($parent?->getConfig()->getInheritData()) {\n            $parent = $parent->getParent();\n        }\n\n        if ($parent && null === $parent->getConfig()->getDataClass()) {\n            $this->propertyPath = new PropertyPath('['.$this->name.']');\n        } else {\n            $this->propertyPath = new PropertyPath($this->name);\n        }\n\n        return $this->propertyPath;\n    }\n\n    public function isRequired(): bool\n    {\n        if (null === $this->parent || $this->parent->isRequired()) {\n            return $this->config->getRequired();\n        }\n\n        return false;\n    }\n\n    public function isDisabled(): bool\n    {\n        if (null === $this->parent || !$this->parent->isDisabled()) {\n            return $this->config->getDisabled();\n        }\n\n        return true;\n    }\n\n    public function setParent(?FormInterface $parent): static\n    {\n        if ($this->submitted) {\n            throw new AlreadySubmittedException('You cannot set the parent of a submitted form.');\n        }\n\n        if (null !== $parent && '' === $this->name) {\n            throw new LogicException('A form with an empty name cannot have a parent form.');\n        }\n\n        $this->parent = $parent;\n\n        return $this;\n    }\n\n    public function getParent(): ?FormInterface\n    {\n        return $this->parent;\n    }\n\n    public function getRoot(): FormInterface\n    {\n        return $this->parent ? $this->parent->getRoot() : $this;\n    }\n\n    public function isRoot(): bool\n    {\n        return null === $this->parent;\n    }\n\n    public function setData(mixed $modelData): static\n    {\n        // If the form is submitted while disabled, it is set to submitted, but the data is not\n        // changed. In such cases (i.e. when the form is not initialized yet) don't\n        // abort this method.\n        if ($this->submitted && $this->defaultDataSet) {\n            throw new AlreadySubmittedException('You cannot change the data of a submitted form.');\n        }\n\n        // If the form inherits its parent's data, disallow data setting to\n        // prevent merge conflicts\n        if ($this->inheritData) {\n            throw new RuntimeException('You cannot change the data of a form inheriting its parent data.');\n        }\n\n        // Don't allow modifications of the configured data if the data is locked\n        if ($this->config->getDataLocked() && $modelData !== $this->config->getData()) {\n            return $this;\n        }\n\n        if (\\is_object($modelData) && !$this->config->getByReference()) {\n            $modelData = clone $modelData;\n        }\n\n        if ($this->lockSetData) {\n            throw new RuntimeException('A cycle was detected. Listeners to the PRE_SET_DATA event must not call setData(). You should call setData() on the FormEvent object instead.');\n        }\n\n        $this->lockSetData = true;\n        $dispatcher = $this->config->getEventDispatcher();\n\n        // Hook to change content of the model data before transformation and mapping children\n        if ($dispatcher->hasListeners(FormEvents::PRE_SET_DATA)) {\n            $event = new PreSetDataEvent($this, $modelData);\n            $dispatcher->dispatch($event, FormEvents::PRE_SET_DATA);\n            $modelData = $event->getData();\n        }\n\n        // Treat data as strings unless a transformer exists\n        if (\\is_scalar($modelData) && !$this->config->getViewTransformers() && !$this->config->getModelTransformers()) {\n            $modelData = (string) $modelData;\n        }\n\n        // Synchronize representations - must not change the content!\n        // Transformation exceptions are not caught on initialization\n        $normData = $this->modelToNorm($modelData);\n        $viewData = $this->normToView($normData);\n\n        // Validate if view data matches data class (unless empty)\n        if (!FormUtil::isEmpty($viewData)) {\n            $dataClass = $this->config->getDataClass();\n\n            if (null !== $dataClass && !$viewData instanceof $dataClass) {\n                $actualType = get_debug_type($viewData);\n\n                throw new LogicException('The form\\'s view data is expected to be a \"'.$dataClass.'\", but it is a \"'.$actualType.'\". You can avoid this error by setting the \"data_class\" option to null or by adding a view transformer that transforms \"'.$actualType.'\" to an instance of \"'.$dataClass.'\".');\n            }\n        }\n\n        $this->modelData = $modelData;\n        $this->normData = $normData;\n        $this->viewData = $viewData;\n        $this->defaultDataSet = true;\n        $this->lockSetData = false;\n\n        // Compound forms don't need to invoke this method if they don't have children\n        if (\\count($this->children) > 0) {\n            // Update child forms from the data (unless their config data is locked)\n            $this->config->getDataMapper()->mapDataToForms($viewData, new \\RecursiveIteratorIterator(new InheritDataAwareIterator($this->children)));\n        }\n\n        if ($dispatcher->hasListeners(FormEvents::POST_SET_DATA)) {\n            $event = new PostSetDataEvent($this, $modelData);\n            $dispatcher->dispatch($event, FormEvents::POST_SET_DATA);\n        }\n\n        return $this;\n    }\n\n    public function getData(): mixed\n    {\n        if ($this->inheritData) {\n            if (!$this->parent) {\n                throw new RuntimeException('The form is configured to inherit its parent\\'s data, but does not have a parent.');\n            }\n\n            return $this->parent->getData();\n        }\n\n        if (!$this->defaultDataSet) {\n            if ($this->lockSetData) {\n                throw new RuntimeException('A cycle was detected. Listeners to the PRE_SET_DATA event must not call getData() if the form data has not already been set. You should call getData() on the FormEvent object instead.');\n            }\n\n            $this->setData($this->config->getData());\n        }\n\n        return $this->modelData;\n    }\n\n    public function getNormData(): mixed\n    {\n        if ($this->inheritData) {\n            if (!$this->parent) {\n                throw new RuntimeException('The form is configured to inherit its parent\\'s data, but does not have a parent.');\n            }\n\n            return $this->parent->getNormData();\n        }\n\n        if (!$this->defaultDataSet) {\n            if ($this->lockSetData) {\n                throw new RuntimeException('A cycle was detected. Listeners to the PRE_SET_DATA event must not call getNormData() if the form data has not already been set.');\n            }\n\n            $this->setData($this->config->getData());\n        }\n\n        return $this->normData;\n    }\n\n    public function getViewData(): mixed\n    {\n        if ($this->inheritData) {\n            if (!$this->parent) {\n                throw new RuntimeException('The form is configured to inherit its parent\\'s data, but does not have a parent.');\n            }\n\n            return $this->parent->getViewData();\n        }\n\n        if (!$this->defaultDataSet) {\n            if ($this->lockSetData) {\n                throw new RuntimeException('A cycle was detected. Listeners to the PRE_SET_DATA event must not call getViewData() if the form data has not already been set.');\n            }\n\n            $this->setData($this->config->getData());\n        }\n\n        return $this->viewData;\n    }\n\n    public function getExtraData(): array\n    {\n        return $this->extraData;\n    }\n\n    public function initialize(): static\n    {\n        if (null !== $this->parent) {\n            throw new RuntimeException('Only root forms should be initialized.');\n        }\n\n        // Guarantee that the *_SET_DATA events have been triggered once the\n        // form is initialized. This makes sure that dynamically added or\n        // removed fields are already visible after initialization.\n        if (!$this->defaultDataSet) {\n            $this->setData($this->config->getData());\n        }\n\n        return $this;\n    }\n\n    public function handleRequest(mixed $request = null): static\n    {\n        $this->config->getRequestHandler()->handleRequest($this, $request);\n\n        return $this;\n    }\n\n    public function submit(mixed $submittedData, bool $clearMissing = true): static\n    {\n        if ($this->submitted) {\n            throw new AlreadySubmittedException('A form can only be submitted once.');\n        }\n\n        // Initialize errors in the very beginning so we're sure\n        // they are collectable during submission only\n        $this->errors = [];\n\n        // Obviously, a disabled form should not change its data upon submission.\n        if ($this->isDisabled()) {\n            $this->submitted = true;\n\n            return $this;\n        }\n\n        // The data must be initialized if it was not initialized yet.\n        // This is necessary to guarantee that the *_SET_DATA listeners\n        // are always invoked before submit() takes place.\n        if (!$this->defaultDataSet) {\n            $this->setData($this->config->getData());\n        }\n\n        // Treat false as NULL to support binding false to checkboxes.\n        // Don't convert NULL to a string here in order to determine later\n        // whether an empty value has been submitted or whether no value has\n        // been submitted at all. This is important for processing checkboxes\n        // and radio buttons with empty values.\n        if (false === $submittedData) {\n            $submittedData = null;\n        } elseif (\\is_scalar($submittedData)) {\n            $submittedData = (string) $submittedData;\n        } elseif ($this->config->getRequestHandler()->isFileUpload($submittedData)) {\n            if (!$this->config->getOption('allow_file_upload')) {\n                $submittedData = null;\n                $this->transformationFailure = new TransformationFailedException('Submitted data was expected to be text or number, file upload given.');\n            }\n        } elseif (\\is_array($submittedData) && !$this->config->getCompound() && !$this->config->getOption('multiple', false)) {\n            $submittedData = null;\n            $this->transformationFailure = new TransformationFailedException('Submitted data was expected to be text or number, array given.');\n        }\n\n        $dispatcher = $this->config->getEventDispatcher();\n\n        $modelData = null;\n        $normData = null;\n        $viewData = null;\n\n        try {\n            if (null !== $this->transformationFailure) {\n                throw $this->transformationFailure;\n            }\n\n            // Hook to change content of the data submitted by the browser\n            if ($dispatcher->hasListeners(FormEvents::PRE_SUBMIT)) {\n                $event = new PreSubmitEvent($this, $submittedData);\n                $dispatcher->dispatch($event, FormEvents::PRE_SUBMIT);\n                $submittedData = $event->getData();\n            }\n\n            // Check whether the form is compound.\n            // This check is preferable over checking the number of children,\n            // since forms without children may also be compound.\n            // (think of empty collection forms)\n            if ($this->config->getCompound()) {\n                if (!\\is_array($submittedData ??= [])) {\n                    throw new TransformationFailedException('Compound forms expect an array or NULL on submission.');\n                }\n\n                foreach ($this->children as $name => $child) {\n                    $isSubmitted = \\array_key_exists($name, $submittedData);\n\n                    if ($isSubmitted || $clearMissing) {\n                        $child->submit($isSubmitted ? $submittedData[$name] : null, $clearMissing);\n                        unset($submittedData[$name]);\n\n                        if (null !== $this->clickedButton) {\n                            continue;\n                        }\n\n                        if ($child instanceof ClickableInterface && $child->isClicked()) {\n                            $this->clickedButton = $child;\n\n                            continue;\n                        }\n\n                        if (method_exists($child, 'getClickedButton') && null !== $child->getClickedButton()) {\n                            $this->clickedButton = $child->getClickedButton();\n                        }\n                    }\n                }\n\n                $this->extraData = $submittedData;\n            }\n\n            // Forms that inherit their parents' data also are not processed,\n            // because then it would be too difficult to merge the changes in\n            // the child and the parent form. Instead, the parent form also takes\n            // changes in the grandchildren (i.e. children of the form that inherits\n            // its parent's data) into account.\n            // (see InheritDataAwareIterator below)\n            if (!$this->inheritData) {\n                // If the form is compound, the view data is merged with the data\n                // of the children using the data mapper.\n                // If the form is not compound, the view data is assigned to the submitted data.\n                $viewData = $this->config->getCompound() ? $this->viewData : $submittedData;\n\n                if (FormUtil::isEmpty($viewData)) {\n                    $emptyData = $this->config->getEmptyData();\n\n                    if ($emptyData instanceof \\Closure) {\n                        $emptyData = $emptyData($this, $viewData);\n                    }\n\n                    $viewData = $emptyData;\n                }\n\n                // Merge form data from children into existing view data\n                // It is not necessary to invoke this method if the form has no children,\n                // even if it is compound.\n                if (\\count($this->children) > 0) {\n                    // Use InheritDataAwareIterator to process children of\n                    // descendants that inherit this form's data.\n                    // These descendants will not be submitted normally (see the check\n                    // for $this->config->getInheritData() above)\n                    $this->config->getDataMapper()->mapFormsToData(\n                        new \\RecursiveIteratorIterator(new InheritDataAwareIterator($this->children)),\n                        $viewData\n                    );\n                }\n\n                // Normalize data to unified representation\n                $normData = $this->viewToNorm($viewData);\n\n                // Hook to change content of the data in the normalized\n                // representation\n                if ($dispatcher->hasListeners(FormEvents::SUBMIT)) {\n                    $event = new SubmitEvent($this, $normData);\n                    $dispatcher->dispatch($event, FormEvents::SUBMIT);\n                    $normData = $event->getData();\n                }\n\n                // Synchronize representations - must not change the content!\n                $modelData = $this->normToModel($normData);\n                $viewData = $this->normToView($normData);\n            }\n        } catch (TransformationFailedException $e) {\n            $this->transformationFailure = $e;\n\n            // If $viewData was not yet set, set it to $submittedData so that\n            // the erroneous data is accessible on the form.\n            // Forms that inherit data never set any data, because the getters\n            // forward to the parent form's getters anyway.\n            if (null === $viewData && !$this->inheritData) {\n                $viewData = $submittedData;\n            }\n        }\n\n        $this->submitted = true;\n        $this->modelData = $modelData;\n        $this->normData = $normData;\n        $this->viewData = $viewData;\n\n        if ($dispatcher->hasListeners(FormEvents::POST_SUBMIT)) {\n            $event = new PostSubmitEvent($this, $viewData);\n            $dispatcher->dispatch($event, FormEvents::POST_SUBMIT);\n        }\n\n        return $this;\n    }\n\n    public function addError(FormError $error): static\n    {\n        if (null === $error->getOrigin()) {\n            $error->setOrigin($this);\n        }\n\n        if ($this->parent && $this->config->getErrorBubbling()) {\n            $this->parent->addError($error);\n        } else {\n            $this->errors[] = $error;\n        }\n\n        return $this;\n    }\n\n    public function isSubmitted(): bool\n    {\n        return $this->submitted;\n    }\n\n    public function isSynchronized(): bool\n    {\n        return null === $this->transformationFailure;\n    }\n\n    public function getTransformationFailure(): ?TransformationFailedException\n    {\n        return $this->transformationFailure;\n    }\n\n    public function isEmpty(): bool\n    {\n        foreach ($this->children as $child) {\n            if (!$child->isEmpty()) {\n                return false;\n            }\n        }\n\n        if (null !== $isEmptyCallback = $this->config->getIsEmptyCallback()) {\n            return $isEmptyCallback($this->modelData);\n        }\n\n        return FormUtil::isEmpty($this->modelData)\n            // arrays, countables\n            || (is_countable($this->modelData) && 0 === \\count($this->modelData))\n            // traversables that are not countable\n            || ($this->modelData instanceof \\Traversable && 0 === iterator_count($this->modelData));\n    }\n\n    public function isValid(): bool\n    {\n        if (!$this->submitted) {\n            throw new LogicException('Cannot check if an unsubmitted form is valid. Call Form::isSubmitted() and ensure that it\\'s true before calling Form::isValid().');\n        }\n\n        if ($this->isDisabled()) {\n            return true;\n        }\n\n        return 0 === \\count($this->getErrors(true));\n    }\n\n    /**\n     * Returns the button that was used to submit the form.\n     */\n    public function getClickedButton(): FormInterface|ClickableInterface|null\n    {\n        if ($this->clickedButton) {\n            return $this->clickedButton;\n        }\n\n        return $this->parent && method_exists($this->parent, 'getClickedButton') ? $this->parent->getClickedButton() : null;\n    }\n\n    public function getErrors(bool $deep = false, bool $flatten = true): FormErrorIterator\n    {\n        $errors = $this->errors;\n\n        // Copy the errors of nested forms to the $errors array\n        if ($deep) {\n            foreach ($this as $child) {\n                /** @var FormInterface $child */\n                if ($child->isSubmitted() && $child->isValid()) {\n                    continue;\n                }\n\n                $iterator = $child->getErrors(true, $flatten);\n\n                if (0 === \\count($iterator)) {\n                    continue;\n                }\n\n                if ($flatten) {\n                    foreach ($iterator as $error) {\n                        $errors[] = $error;\n                    }\n                } else {\n                    $errors[] = $iterator;\n                }\n            }\n        }\n\n        return new FormErrorIterator($this, $errors);\n    }\n\n    public function clearErrors(bool $deep = false): static\n    {\n        $this->errors = [];\n\n        if ($deep) {\n            // Clear errors from children\n            foreach ($this as $child) {\n                if ($child instanceof ClearableErrorsInterface) {\n                    $child->clearErrors(true);\n                }\n            }\n        }\n\n        return $this;\n    }\n\n    public function all(): array\n    {\n        return iterator_to_array($this->children);\n    }\n\n    public function add(FormInterface|string $child, ?string $type = null, array $options = []): static\n    {\n        if ($this->submitted) {\n            throw new AlreadySubmittedException('You cannot add children to a submitted form.');\n        }\n\n        if (!$this->config->getCompound()) {\n            throw new LogicException('You cannot add children to a simple form. Maybe you should set the option \"compound\" to true?');\n        }\n\n        if (!$child instanceof FormInterface) {\n            // Never initialize child forms automatically\n            $options['auto_initialize'] = false;\n\n            if (null === $type && null === $this->config->getDataClass()) {\n                $type = TextType::class;\n            }\n\n            if (null === $type) {\n                $child = $this->config->getFormFactory()->createForProperty($this->config->getDataClass(), $child, null, $options);\n            } else {\n                $child = $this->config->getFormFactory()->createNamed($child, $type, null, $options);\n            }\n        } elseif ($child->getConfig()->getAutoInitialize()) {\n            throw new RuntimeException(\\sprintf('Automatic initialization is only supported on root forms. You should set the \"auto_initialize\" option to false on the field \"%s\".', $child->getName()));\n        }\n\n        $this->children[$child->getName()] = $child;\n\n        $child->setParent($this);\n\n        // If setData() is currently being called, there is no need to call\n        // mapDataToForms() here, as mapDataToForms() is called at the end\n        // of setData() anyway. Not doing this check leads to an endless\n        // recursion when initializing the form lazily and an event listener\n        // (such as ResizeFormListener) adds fields depending on the data:\n        //\n        //  * setData() is called, the form is not initialized yet\n        //  * add() is called by the listener (setData() is not complete, so\n        //    the form is still not initialized)\n        //  * getViewData() is called\n        //  * setData() is called since the form is not initialized yet\n        //  * ... endless recursion ...\n        //\n        // Also skip data mapping if setData() has not been called yet.\n        // setData() will be called upon form initialization and data mapping\n        // will take place by then.\n        if (!$this->lockSetData && $this->defaultDataSet && !$this->inheritData) {\n            $viewData = $this->getViewData();\n            $this->config->getDataMapper()->mapDataToForms(\n                $viewData,\n                new \\RecursiveIteratorIterator(new InheritDataAwareIterator(new \\ArrayIterator([$child->getName() => $child])))\n            );\n        }\n\n        return $this;\n    }\n\n    public function remove(string $name): static\n    {\n        if ($this->submitted) {\n            throw new AlreadySubmittedException('You cannot remove children from a submitted form.');\n        }\n\n        if (isset($this->children[$name])) {\n            if (!$this->children[$name]->isSubmitted()) {\n                $this->children[$name]->setParent(null);\n            }\n\n            unset($this->children[$name]);\n        }\n\n        return $this;\n    }\n\n    public function has(string $name): bool\n    {\n        return isset($this->children[$name]);\n    }\n\n    public function get(string $name): FormInterface\n    {\n        if (isset($this->children[$name])) {\n            return $this->children[$name];\n        }\n\n        throw new OutOfBoundsException(\\sprintf('Child \"%s\" does not exist.', $name));\n    }\n\n    /**\n     * Returns whether a child with the given name exists (implements the \\ArrayAccess interface).\n     *\n     * @param string $name The name of the child\n     */\n    public function offsetExists(mixed $name): bool\n    {\n        return $this->has($name);\n    }\n\n    /**\n     * Returns the child with the given name (implements the \\ArrayAccess interface).\n     *\n     * @param string $name The name of the child\n     *\n     * @throws OutOfBoundsException if the named child does not exist\n     */\n    public function offsetGet(mixed $name): FormInterface\n    {\n        return $this->get($name);\n    }\n\n    /**\n     * Adds a child to the form (implements the \\ArrayAccess interface).\n     *\n     * @param string        $name  Ignored. The name of the child is used\n     * @param FormInterface $child The child to be added\n     *\n     * @throws AlreadySubmittedException if the form has already been submitted\n     * @throws LogicException            when trying to add a child to a non-compound form\n     *\n     * @see self::add()\n     */\n    public function offsetSet(mixed $name, mixed $child): void\n    {\n        $this->add($child);\n    }\n\n    /**\n     * Removes the child with the given name from the form (implements the \\ArrayAccess interface).\n     *\n     * @param string $name The name of the child to remove\n     *\n     * @throws AlreadySubmittedException if the form has already been submitted\n     */\n    public function offsetUnset(mixed $name): void\n    {\n        $this->remove($name);\n    }\n\n    /**\n     * Returns the iterator for this group.\n     *\n     * @return \\Traversable<string, FormInterface>\n     */\n    public function getIterator(): \\Traversable\n    {\n        return $this->children;\n    }\n\n    /**\n     * Returns the number of form children (implements the \\Countable interface).\n     */\n    public function count(): int\n    {\n        return \\count($this->children);\n    }\n\n    public function createView(?FormView $parent = null): FormView\n    {\n        if (null === $parent && $this->parent) {\n            $parent = $this->parent->createView();\n        }\n\n        $type = $this->config->getType();\n        $options = $this->config->getOptions();\n\n        // The methods createView(), buildView() and finishView() are called\n        // explicitly here in order to be able to override either of them\n        // in a custom resolved form type.\n        $view = $type->createView($this, $parent);\n\n        $type->buildView($view, $this, $options);\n\n        foreach ($this->children as $name => $child) {\n            $view->children[$name] = $child->createView($view);\n        }\n\n        $this->sort($view->children);\n\n        $type->finishView($view, $this, $options);\n\n        return $view;\n    }\n\n    /**\n     * Sorts view fields based on their priority value.\n     */\n    private function sort(array &$children): void\n    {\n        $c = [];\n        $i = 0;\n        $needsSorting = false;\n        foreach ($children as $name => $child) {\n            $c[$name] = ['p' => $child->vars['priority'] ?? 0, 'i' => $i++];\n\n            if (0 !== $c[$name]['p']) {\n                $needsSorting = true;\n            }\n        }\n\n        if (!$needsSorting) {\n            return;\n        }\n\n        uksort($children, static fn ($a, $b): int => [$c[$b]['p'], $c[$a]['i']] <=> [$c[$a]['p'], $c[$b]['i']]);\n    }\n\n    /**\n     * Normalizes the underlying data if a model transformer is set.\n     *\n     * @throws TransformationFailedException If the underlying data cannot be transformed to \"normalized\" format\n     */\n    private function modelToNorm(mixed $value): mixed\n    {\n        try {\n            foreach ($this->config->getModelTransformers() as $transformer) {\n                $value = $transformer->transform($value);\n            }\n        } catch (TransformationFailedException $exception) {\n            throw new TransformationFailedException(\\sprintf('Unable to transform data for property path \"%s\": ', $this->getPropertyPath()).$exception->getMessage(), $exception->getCode(), $exception, $exception->getInvalidMessage(), $exception->getInvalidMessageParameters());\n        }\n\n        return $value;\n    }\n\n    /**\n     * Reverse transforms a value if a model transformer is set.\n     *\n     * @throws TransformationFailedException If the value cannot be transformed to \"model\" format\n     */\n    private function normToModel(mixed $value): mixed\n    {\n        try {\n            $transformers = $this->config->getModelTransformers();\n\n            for ($i = \\count($transformers) - 1; $i >= 0; --$i) {\n                $value = $transformers[$i]->reverseTransform($value);\n            }\n        } catch (TransformationFailedException $exception) {\n            throw new TransformationFailedException(\\sprintf('Unable to reverse value for property path \"%s\": ', $this->getPropertyPath()).$exception->getMessage(), $exception->getCode(), $exception, $exception->getInvalidMessage(), $exception->getInvalidMessageParameters());\n        }\n\n        return $value;\n    }\n\n    /**\n     * Transforms the value if a view transformer is set.\n     *\n     * @throws TransformationFailedException If the normalized value cannot be transformed to \"view\" format\n     */\n    private function normToView(mixed $value): mixed\n    {\n        // Scalar values should  be converted to strings to\n        // facilitate differentiation between empty (\"\") and zero (0).\n        // Only do this for simple forms, as the resulting value in\n        // compound forms is passed to the data mapper and thus should\n        // not be converted to a string before.\n        if (!($transformers = $this->config->getViewTransformers()) && !$this->config->getCompound()) {\n            return null === $value || \\is_scalar($value) ? (string) $value : $value;\n        }\n\n        try {\n            foreach ($transformers as $transformer) {\n                $value = $transformer->transform($value);\n            }\n        } catch (TransformationFailedException $exception) {\n            throw new TransformationFailedException(\\sprintf('Unable to transform value for property path \"%s\": ', $this->getPropertyPath()).$exception->getMessage(), $exception->getCode(), $exception, $exception->getInvalidMessage(), $exception->getInvalidMessageParameters());\n        }\n\n        return $value;\n    }\n\n    /**\n     * Reverse transforms a value if a view transformer is set.\n     *\n     * @throws TransformationFailedException If the submitted value cannot be transformed to \"normalized\" format\n     */\n    private function viewToNorm(mixed $value): mixed\n    {\n        if (!$transformers = $this->config->getViewTransformers()) {\n            return '' === $value ? null : $value;\n        }\n\n        try {\n            for ($i = \\count($transformers) - 1; $i >= 0; --$i) {\n                $value = $transformers[$i]->reverseTransform($value);\n            }\n        } catch (TransformationFailedException $exception) {\n            throw new TransformationFailedException(\\sprintf('Unable to reverse value for property path \"%s\": ', $this->getPropertyPath()).$exception->getMessage(), $exception->getCode(), $exception, $exception->getInvalidMessage(), $exception->getInvalidMessageParameters());\n        }\n\n        return $value;\n    }\n}\n"
        },
        {
          "name": "FormBuilder.php",
          "type": "blob",
          "size": 6.6181640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Component\\Form\\Exception\\BadMethodCallException;\nuse Symfony\\Component\\Form\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\n\n/**\n * A builder for creating {@link Form} instances.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @implements \\IteratorAggregate<string, FormBuilderInterface>\n */\nclass FormBuilder extends FormConfigBuilder implements \\IteratorAggregate, FormBuilderInterface\n{\n    /**\n     * The children of the form builder.\n     *\n     * @var FormBuilderInterface[]\n     */\n    private array $children = [];\n\n    /**\n     * The data of children who haven't been converted to form builders yet.\n     */\n    private array $unresolvedChildren = [];\n\n    public function __construct(?string $name, ?string $dataClass, EventDispatcherInterface $dispatcher, FormFactoryInterface $factory, array $options = [])\n    {\n        parent::__construct($name, $dataClass, $dispatcher, $options);\n\n        $this->setFormFactory($factory);\n    }\n\n    public function add(FormBuilderInterface|string $child, ?string $type = null, array $options = []): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        if ($child instanceof FormBuilderInterface) {\n            $this->children[$child->getName()] = $child;\n\n            // In case an unresolved child with the same name exists\n            unset($this->unresolvedChildren[$child->getName()]);\n\n            return $this;\n        }\n\n        // Add to \"children\" to maintain order\n        $this->children[$child] = null;\n        $this->unresolvedChildren[$child] = [$type, $options];\n\n        return $this;\n    }\n\n    public function create(string $name, ?string $type = null, array $options = []): FormBuilderInterface\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        if (null === $type && null === $this->getDataClass()) {\n            $type = TextType::class;\n        }\n\n        if (null !== $type) {\n            return $this->getFormFactory()->createNamedBuilder($name, $type, null, $options);\n        }\n\n        return $this->getFormFactory()->createBuilderForProperty($this->getDataClass(), $name, null, $options);\n    }\n\n    public function get(string $name): FormBuilderInterface\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        if (isset($this->unresolvedChildren[$name])) {\n            return $this->resolveChild($name);\n        }\n\n        if (isset($this->children[$name])) {\n            return $this->children[$name];\n        }\n\n        throw new InvalidArgumentException(\\sprintf('The child with the name \"%s\" does not exist.', $name));\n    }\n\n    public function remove(string $name): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        unset($this->unresolvedChildren[$name], $this->children[$name]);\n\n        return $this;\n    }\n\n    public function has(string $name): bool\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        return isset($this->unresolvedChildren[$name]) || isset($this->children[$name]);\n    }\n\n    public function all(): array\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->resolveChildren();\n\n        return $this->children;\n    }\n\n    public function count(): int\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        return \\count($this->children);\n    }\n\n    public function getFormConfig(): FormConfigInterface\n    {\n        /** @var self $config */\n        $config = parent::getFormConfig();\n\n        $config->children = [];\n        $config->unresolvedChildren = [];\n\n        return $config;\n    }\n\n    public function getForm(): FormInterface\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->resolveChildren();\n\n        $form = new Form($this->getFormConfig());\n\n        foreach ($this->children as $child) {\n            // Automatic initialization is only supported on root forms\n            $form->add($child->setAutoInitialize(false)->getForm());\n        }\n\n        if ($this->getAutoInitialize()) {\n            // Automatically initialize the form if it is configured so\n            $form->initialize();\n        }\n\n        return $form;\n    }\n\n    /**\n     * @return \\Traversable<string, FormBuilderInterface>\n     */\n    public function getIterator(): \\Traversable\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        return new \\ArrayIterator($this->all());\n    }\n\n    /**\n     * Converts an unresolved child into a {@link FormBuilderInterface} instance.\n     */\n    private function resolveChild(string $name): FormBuilderInterface\n    {\n        [$type, $options] = $this->unresolvedChildren[$name];\n\n        unset($this->unresolvedChildren[$name]);\n\n        return $this->children[$name] = $this->create($name, $type, $options);\n    }\n\n    /**\n     * Converts all unresolved children into {@link FormBuilder} instances.\n     */\n    private function resolveChildren(): void\n    {\n        foreach ($this->unresolvedChildren as $name => $info) {\n            $this->children[$name] = $this->create($name, $info[0], $info[1]);\n        }\n\n        $this->unresolvedChildren = [];\n    }\n}\n"
        },
        {
          "name": "FormBuilderInterface.php",
          "type": "blob",
          "size": 1.86328125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @extends \\Traversable<string, FormBuilderInterface>\n */\ninterface FormBuilderInterface extends \\Traversable, \\Countable, FormConfigBuilderInterface\n{\n    /**\n     * Adds a new field to this group. A field must have a unique name within\n     * the group. Otherwise the existing field is overwritten.\n     *\n     * If you add a nested group, this group should also be represented in the\n     * object hierarchy.\n     *\n     * @param array<string, mixed> $options\n     */\n    public function add(string|self $child, ?string $type = null, array $options = []): static;\n\n    /**\n     * Creates a form builder.\n     *\n     * @param string               $name    The name of the form or the name of the property\n     * @param string|null          $type    The type of the form or null if name is a property\n     * @param array<string, mixed> $options\n     */\n    public function create(string $name, ?string $type = null, array $options = []): self;\n\n    /**\n     * Returns a child by name.\n     *\n     * @throws Exception\\InvalidArgumentException if the given child does not exist\n     */\n    public function get(string $name): self;\n\n    /**\n     * Removes the field with the given name.\n     */\n    public function remove(string $name): static;\n\n    /**\n     * Returns whether a field with the given name exists.\n     */\n    public function has(string $name): bool;\n\n    /**\n     * Returns the children.\n     *\n     * @return array<string, self>\n     */\n    public function all(): array;\n\n    /**\n     * Creates the form.\n     */\n    public function getForm(): FormInterface;\n}\n"
        },
        {
          "name": "FormConfigBuilder.php",
          "type": "blob",
          "size": 17.8515625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\EventDispatcher\\ImmutableEventDispatcher;\nuse Symfony\\Component\\Form\\Exception\\BadMethodCallException;\nuse Symfony\\Component\\Form\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\PropertyAccess\\PropertyPath;\nuse Symfony\\Component\\PropertyAccess\\PropertyPathInterface;\n\n/**\n * A basic form configuration.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass FormConfigBuilder implements FormConfigBuilderInterface\n{\n    protected bool $locked = false;\n\n    /**\n     * Caches a globally unique {@link NativeRequestHandler} instance.\n     */\n    private static NativeRequestHandler $nativeRequestHandler;\n\n    private string $name;\n    private ?PropertyPathInterface $propertyPath = null;\n    private bool $mapped = true;\n    private bool $byReference = true;\n    private bool $inheritData = false;\n    private bool $compound = false;\n    private ResolvedFormTypeInterface $type;\n    private array $viewTransformers = [];\n    private array $modelTransformers = [];\n    private ?DataMapperInterface $dataMapper = null;\n    private bool $required = true;\n    private bool $disabled = false;\n    private bool $errorBubbling = false;\n    private mixed $emptyData = null;\n    private array $attributes = [];\n    private mixed $data = null;\n    private ?string $dataClass;\n    private bool $dataLocked = false;\n    private FormFactoryInterface $formFactory;\n    private string $action = '';\n    private string $method = 'POST';\n    private RequestHandlerInterface $requestHandler;\n    private bool $autoInitialize = false;\n    private ?\\Closure $isEmptyCallback = null;\n\n    /**\n     * Creates an empty form configuration.\n     *\n     * @param string|null $name      The form name\n     * @param string|null $dataClass The class of the form's data\n     *\n     * @throws InvalidArgumentException if the data class is not a valid class or if\n     *                                  the name contains invalid characters\n     */\n    public function __construct(\n        ?string $name,\n        ?string $dataClass,\n        private EventDispatcherInterface $dispatcher,\n        private array $options = [],\n    ) {\n        self::validateName($name);\n\n        if (null !== $dataClass && !class_exists($dataClass) && !interface_exists($dataClass, false)) {\n            throw new InvalidArgumentException(\\sprintf('Class \"%s\" not found. Is the \"data_class\" form option set correctly?', $dataClass));\n        }\n\n        $this->name = (string) $name;\n        $this->dataClass = $dataClass;\n    }\n\n    public function addEventListener(string $eventName, callable $listener, int $priority = 0): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->dispatcher->addListener($eventName, $listener, $priority);\n\n        return $this;\n    }\n\n    public function addEventSubscriber(EventSubscriberInterface $subscriber): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->dispatcher->addSubscriber($subscriber);\n\n        return $this;\n    }\n\n    public function addViewTransformer(DataTransformerInterface $viewTransformer, bool $forcePrepend = false): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        if ($forcePrepend) {\n            array_unshift($this->viewTransformers, $viewTransformer);\n        } else {\n            $this->viewTransformers[] = $viewTransformer;\n        }\n\n        return $this;\n    }\n\n    public function resetViewTransformers(): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->viewTransformers = [];\n\n        return $this;\n    }\n\n    public function addModelTransformer(DataTransformerInterface $modelTransformer, bool $forceAppend = false): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        if ($forceAppend) {\n            $this->modelTransformers[] = $modelTransformer;\n        } else {\n            array_unshift($this->modelTransformers, $modelTransformer);\n        }\n\n        return $this;\n    }\n\n    public function resetModelTransformers(): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->modelTransformers = [];\n\n        return $this;\n    }\n\n    public function getEventDispatcher(): EventDispatcherInterface\n    {\n        if ($this->locked && !$this->dispatcher instanceof ImmutableEventDispatcher) {\n            $this->dispatcher = new ImmutableEventDispatcher($this->dispatcher);\n        }\n\n        return $this->dispatcher;\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    public function getPropertyPath(): ?PropertyPathInterface\n    {\n        return $this->propertyPath;\n    }\n\n    public function getMapped(): bool\n    {\n        return $this->mapped;\n    }\n\n    public function getByReference(): bool\n    {\n        return $this->byReference;\n    }\n\n    public function getInheritData(): bool\n    {\n        return $this->inheritData;\n    }\n\n    public function getCompound(): bool\n    {\n        return $this->compound;\n    }\n\n    public function getType(): ResolvedFormTypeInterface\n    {\n        return $this->type;\n    }\n\n    public function getViewTransformers(): array\n    {\n        return $this->viewTransformers;\n    }\n\n    public function getModelTransformers(): array\n    {\n        return $this->modelTransformers;\n    }\n\n    public function getDataMapper(): ?DataMapperInterface\n    {\n        return $this->dataMapper;\n    }\n\n    public function getRequired(): bool\n    {\n        return $this->required;\n    }\n\n    public function getDisabled(): bool\n    {\n        return $this->disabled;\n    }\n\n    public function getErrorBubbling(): bool\n    {\n        return $this->errorBubbling;\n    }\n\n    public function getEmptyData(): mixed\n    {\n        return $this->emptyData;\n    }\n\n    public function getAttributes(): array\n    {\n        return $this->attributes;\n    }\n\n    public function hasAttribute(string $name): bool\n    {\n        return \\array_key_exists($name, $this->attributes);\n    }\n\n    public function getAttribute(string $name, mixed $default = null): mixed\n    {\n        return \\array_key_exists($name, $this->attributes) ? $this->attributes[$name] : $default;\n    }\n\n    public function getData(): mixed\n    {\n        return $this->data;\n    }\n\n    public function getDataClass(): ?string\n    {\n        return $this->dataClass;\n    }\n\n    public function getDataLocked(): bool\n    {\n        return $this->dataLocked;\n    }\n\n    public function getFormFactory(): FormFactoryInterface\n    {\n        if (!isset($this->formFactory)) {\n            throw new BadMethodCallException('The form factory must be set before retrieving it.');\n        }\n\n        return $this->formFactory;\n    }\n\n    public function getAction(): string\n    {\n        return $this->action;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getRequestHandler(): RequestHandlerInterface\n    {\n        return $this->requestHandler ??= self::$nativeRequestHandler ??= new NativeRequestHandler();\n    }\n\n    public function getAutoInitialize(): bool\n    {\n        return $this->autoInitialize;\n    }\n\n    public function getOptions(): array\n    {\n        return $this->options;\n    }\n\n    public function hasOption(string $name): bool\n    {\n        return \\array_key_exists($name, $this->options);\n    }\n\n    public function getOption(string $name, mixed $default = null): mixed\n    {\n        return \\array_key_exists($name, $this->options) ? $this->options[$name] : $default;\n    }\n\n    public function getIsEmptyCallback(): ?callable\n    {\n        return $this->isEmptyCallback;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setAttribute(string $name, mixed $value): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->attributes[$name] = $value;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setAttributes(array $attributes): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->attributes = $attributes;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setDataMapper(?DataMapperInterface $dataMapper): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->dataMapper = $dataMapper;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setDisabled(bool $disabled): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->disabled = $disabled;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setEmptyData(mixed $emptyData): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->emptyData = $emptyData;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setErrorBubbling(bool $errorBubbling): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->errorBubbling = $errorBubbling;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setRequired(bool $required): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->required = $required;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setPropertyPath(string|PropertyPathInterface|null $propertyPath): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        if (null !== $propertyPath && !$propertyPath instanceof PropertyPathInterface) {\n            $propertyPath = new PropertyPath($propertyPath);\n        }\n\n        $this->propertyPath = $propertyPath;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setMapped(bool $mapped): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->mapped = $mapped;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setByReference(bool $byReference): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->byReference = $byReference;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setInheritData(bool $inheritData): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->inheritData = $inheritData;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setCompound(bool $compound): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->compound = $compound;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setType(ResolvedFormTypeInterface $type): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->type = $type;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setData(mixed $data): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->data = $data;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setDataLocked(bool $locked): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->dataLocked = $locked;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setFormFactory(FormFactoryInterface $formFactory): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->formFactory = $formFactory;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setAction(string $action): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('The config builder cannot be modified anymore.');\n        }\n\n        $this->action = $action;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setMethod(string $method): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('The config builder cannot be modified anymore.');\n        }\n\n        $this->method = strtoupper($method);\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setRequestHandler(RequestHandlerInterface $requestHandler): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('The config builder cannot be modified anymore.');\n        }\n\n        $this->requestHandler = $requestHandler;\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setAutoInitialize(bool $initialize): static\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        $this->autoInitialize = $initialize;\n\n        return $this;\n    }\n\n    public function getFormConfig(): FormConfigInterface\n    {\n        if ($this->locked) {\n            throw new BadMethodCallException('FormConfigBuilder methods cannot be accessed anymore once the builder is turned into a FormConfigInterface instance.');\n        }\n\n        // This method should be idempotent, so clone the builder\n        $config = clone $this;\n        $config->locked = true;\n\n        return $config;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setIsEmptyCallback(?callable $isEmptyCallback): static\n    {\n        $this->isEmptyCallback = null === $isEmptyCallback ? null : $isEmptyCallback(...);\n\n        return $this;\n    }\n\n    /**\n     * Validates whether the given variable is a valid form name.\n     *\n     * @throws InvalidArgumentException if the name contains invalid characters\n     *\n     * @internal\n     */\n    final public static function validateName(?string $name): void\n    {\n        if (!self::isValidName($name)) {\n            throw new InvalidArgumentException(\\sprintf('The name \"%s\" contains illegal characters. Names should start with a letter, digit or underscore and only contain letters, digits, numbers, underscores (\"_\"), hyphens (\"-\") and colons (\":\").', $name));\n        }\n    }\n\n    /**\n     * Returns whether the given variable contains a valid form name.\n     *\n     * A name is accepted if it\n     *\n     *   * is empty\n     *   * starts with a letter, digit or underscore\n     *   * contains only letters, digits, numbers, underscores (\"_\"),\n     *     hyphens (\"-\") and colons (\":\")\n     */\n    final public static function isValidName(?string $name): bool\n    {\n        return '' === $name || null === $name || preg_match('/^[a-zA-Z0-9_][a-zA-Z0-9_\\-:]*$/D', $name);\n    }\n}\n"
        },
        {
          "name": "FormConfigBuilderInterface.php",
          "type": "blob",
          "size": 7.1552734375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\PropertyAccess\\PropertyPathInterface;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface FormConfigBuilderInterface extends FormConfigInterface\n{\n    /**\n     * Adds an event listener to an event on this form.\n     *\n     * @param int $priority The priority of the listener. Listeners\n     *                      with a higher priority are called before\n     *                      listeners with a lower priority.\n     *\n     * @return $this\n     */\n    public function addEventListener(string $eventName, callable $listener, int $priority = 0): static;\n\n    /**\n     * Adds an event subscriber for events on this form.\n     *\n     * @return $this\n     */\n    public function addEventSubscriber(EventSubscriberInterface $subscriber): static;\n\n    /**\n     * Appends / prepends a transformer to the view transformer chain.\n     *\n     * The transform method of the transformer is used to convert data from the\n     * normalized to the view format.\n     * The reverseTransform method of the transformer is used to convert from the\n     * view to the normalized format.\n     *\n     * @param bool $forcePrepend If set to true, prepend instead of appending\n     *\n     * @return $this\n     */\n    public function addViewTransformer(DataTransformerInterface $viewTransformer, bool $forcePrepend = false): static;\n\n    /**\n     * Clears the view transformers.\n     *\n     * @return $this\n     */\n    public function resetViewTransformers(): static;\n\n    /**\n     * Prepends / appends a transformer to the normalization transformer chain.\n     *\n     * The transform method of the transformer is used to convert data from the\n     * model to the normalized format.\n     * The reverseTransform method of the transformer is used to convert from the\n     * normalized to the model format.\n     *\n     * @param bool $forceAppend If set to true, append instead of prepending\n     *\n     * @return $this\n     */\n    public function addModelTransformer(DataTransformerInterface $modelTransformer, bool $forceAppend = false): static;\n\n    /**\n     * Clears the normalization transformers.\n     *\n     * @return $this\n     */\n    public function resetModelTransformers(): static;\n\n    /**\n     * Sets the value for an attribute.\n     *\n     * @param mixed $value The value of the attribute\n     *\n     * @return $this\n     */\n    public function setAttribute(string $name, mixed $value): static;\n\n    /**\n     * Sets the attributes.\n     *\n     * @return $this\n     */\n    public function setAttributes(array $attributes): static;\n\n    /**\n     * Sets the data mapper used by the form.\n     *\n     * @return $this\n     */\n    public function setDataMapper(?DataMapperInterface $dataMapper): static;\n\n    /**\n     * Sets whether the form is disabled.\n     *\n     * @return $this\n     */\n    public function setDisabled(bool $disabled): static;\n\n    /**\n     * Sets the data used for the client data when no value is submitted.\n     *\n     * @param mixed $emptyData The empty data\n     *\n     * @return $this\n     */\n    public function setEmptyData(mixed $emptyData): static;\n\n    /**\n     * Sets whether errors bubble up to the parent.\n     *\n     * @return $this\n     */\n    public function setErrorBubbling(bool $errorBubbling): static;\n\n    /**\n     * Sets whether this field is required to be filled out when submitted.\n     *\n     * @return $this\n     */\n    public function setRequired(bool $required): static;\n\n    /**\n     * Sets the property path that the form should be mapped to.\n     *\n     * @param string|PropertyPathInterface|null $propertyPath The property path or null if the path should be set\n     *                                                        automatically based on the form's name\n     *\n     * @return $this\n     */\n    public function setPropertyPath(string|PropertyPathInterface|null $propertyPath): static;\n\n    /**\n     * Sets whether the form should be mapped to an element of its\n     * parent's data.\n     *\n     * @return $this\n     */\n    public function setMapped(bool $mapped): static;\n\n    /**\n     * Sets whether the form's data should be modified by reference.\n     *\n     * @return $this\n     */\n    public function setByReference(bool $byReference): static;\n\n    /**\n     * Sets whether the form should read and write the data of its parent.\n     *\n     * @return $this\n     */\n    public function setInheritData(bool $inheritData): static;\n\n    /**\n     * Sets whether the form should be compound.\n     *\n     * @return $this\n     *\n     * @see FormConfigInterface::getCompound()\n     */\n    public function setCompound(bool $compound): static;\n\n    /**\n     * Sets the resolved type.\n     *\n     * @return $this\n     */\n    public function setType(ResolvedFormTypeInterface $type): static;\n\n    /**\n     * Sets the initial data of the form.\n     *\n     * @param mixed $data The data of the form in model format\n     *\n     * @return $this\n     */\n    public function setData(mixed $data): static;\n\n    /**\n     * Locks the form's data to the data passed in the configuration.\n     *\n     * A form with locked data is restricted to the data passed in\n     * this configuration. The data can only be modified then by\n     * submitting the form or using PRE_SET_DATA event.\n     *\n     * It means data passed to a factory method or mapped from the\n     * parent will be ignored.\n     *\n     * @return $this\n     */\n    public function setDataLocked(bool $locked): static;\n\n    /**\n     * Sets the form factory used for creating new forms.\n     *\n     * @return $this\n     */\n    public function setFormFactory(FormFactoryInterface $formFactory): static;\n\n    /**\n     * Sets the target URL of the form.\n     *\n     * @return $this\n     */\n    public function setAction(string $action): static;\n\n    /**\n     * Sets the HTTP method used by the form.\n     *\n     * @return $this\n     */\n    public function setMethod(string $method): static;\n\n    /**\n     * Sets the request handler used by the form.\n     *\n     * @return $this\n     */\n    public function setRequestHandler(RequestHandlerInterface $requestHandler): static;\n\n    /**\n     * Sets whether the form should be initialized automatically.\n     *\n     * Should be set to true only for root forms.\n     *\n     * @param bool $initialize True to initialize the form automatically,\n     *                         false to suppress automatic initialization.\n     *                         In the second case, you need to call\n     *                         {@link FormInterface::initialize()} manually.\n     *\n     * @return $this\n     */\n    public function setAutoInitialize(bool $initialize): static;\n\n    /**\n     * Builds and returns the form configuration.\n     */\n    public function getFormConfig(): FormConfigInterface;\n\n    /**\n     * Sets the callback that will be called to determine if the model\n     * data of the form is empty or not.\n     *\n     * @return $this\n     */\n    public function setIsEmptyCallback(?callable $isEmptyCallback): static;\n}\n"
        },
        {
          "name": "FormConfigInterface.php",
          "type": "blob",
          "size": 5.1259765625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Component\\PropertyAccess\\PropertyPathInterface;\n\n/**\n * The configuration of a {@link Form} object.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface FormConfigInterface\n{\n    /**\n     * Returns the event dispatcher used to dispatch form events.\n     */\n    public function getEventDispatcher(): EventDispatcherInterface;\n\n    /**\n     * Returns the name of the form used as HTTP parameter.\n     */\n    public function getName(): string;\n\n    /**\n     * Returns the property path that the form should be mapped to.\n     */\n    public function getPropertyPath(): ?PropertyPathInterface;\n\n    /**\n     * Returns whether the form should be mapped to an element of its\n     * parent's data.\n     */\n    public function getMapped(): bool;\n\n    /**\n     * Returns whether the form's data should be modified by reference.\n     */\n    public function getByReference(): bool;\n\n    /**\n     * Returns whether the form should read and write the data of its parent.\n     */\n    public function getInheritData(): bool;\n\n    /**\n     * Returns whether the form is compound.\n     *\n     * This property is independent of whether the form actually has\n     * children. A form can be compound and have no children at all, like\n     * for example an empty collection form.\n     * The contrary is not possible, a form which is not compound\n     * cannot have any children.\n     */\n    public function getCompound(): bool;\n\n    /**\n     * Returns the resolved form type used to construct the form.\n     */\n    public function getType(): ResolvedFormTypeInterface;\n\n    /**\n     * Returns the view transformers of the form.\n     *\n     * @return DataTransformerInterface[]\n     */\n    public function getViewTransformers(): array;\n\n    /**\n     * Returns the model transformers of the form.\n     *\n     * @return DataTransformerInterface[]\n     */\n    public function getModelTransformers(): array;\n\n    /**\n     * Returns the data mapper of the compound form or null for a simple form.\n     */\n    public function getDataMapper(): ?DataMapperInterface;\n\n    /**\n     * Returns whether the form is required.\n     */\n    public function getRequired(): bool;\n\n    /**\n     * Returns whether the form is disabled.\n     */\n    public function getDisabled(): bool;\n\n    /**\n     * Returns whether errors attached to the form will bubble to its parent.\n     */\n    public function getErrorBubbling(): bool;\n\n    /**\n     * Used when the view data is empty on submission.\n     *\n     * When the form is compound it will also be used to map the\n     * children data.\n     *\n     * The empty data must match the view format as it will passed to the first view transformer's\n     * \"reverseTransform\" method.\n     */\n    public function getEmptyData(): mixed;\n\n    /**\n     * Returns additional attributes of the form.\n     */\n    public function getAttributes(): array;\n\n    /**\n     * Returns whether the attribute with the given name exists.\n     */\n    public function hasAttribute(string $name): bool;\n\n    /**\n     * Returns the value of the given attribute.\n     */\n    public function getAttribute(string $name, mixed $default = null): mixed;\n\n    /**\n     * Returns the initial data of the form.\n     */\n    public function getData(): mixed;\n\n    /**\n     * Returns the class of the view data or null if the data is scalar or an array.\n     */\n    public function getDataClass(): ?string;\n\n    /**\n     * Returns whether the form's data is locked.\n     *\n     * A form with locked data is restricted to the data passed in\n     * this configuration. The data can only be modified then by\n     * submitting the form.\n     */\n    public function getDataLocked(): bool;\n\n    /**\n     * Returns the form factory used for creating new forms.\n     */\n    public function getFormFactory(): FormFactoryInterface;\n\n    /**\n     * Returns the target URL of the form.\n     */\n    public function getAction(): string;\n\n    /**\n     * Returns the HTTP method used by the form.\n     */\n    public function getMethod(): string;\n\n    /**\n     * Returns the request handler used by the form.\n     */\n    public function getRequestHandler(): RequestHandlerInterface;\n\n    /**\n     * Returns whether the form should be initialized upon creation.\n     */\n    public function getAutoInitialize(): bool;\n\n    /**\n     * Returns all options passed during the construction of the form.\n     *\n     * @return array<string, mixed> The passed options\n     */\n    public function getOptions(): array;\n\n    /**\n     * Returns whether a specific option exists.\n     */\n    public function hasOption(string $name): bool;\n\n    /**\n     * Returns the value of a specific option.\n     */\n    public function getOption(string $name, mixed $default = null): mixed;\n\n    /**\n     * Returns a callable that takes the model data as argument and that returns if it is empty or not.\n     */\n    public function getIsEmptyCallback(): ?callable;\n}\n"
        },
        {
          "name": "FormError.php",
          "type": "blob",
          "size": 2.90234375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Exception\\BadMethodCallException;\n\n/**\n * Wraps errors in forms.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass FormError\n{\n    protected string $messageTemplate;\n\n    /**\n     * The form that spawned this error.\n     */\n    private ?FormInterface $origin = null;\n\n    /**\n     * Any array key in $messageParameters will be used as a placeholder in\n     * $messageTemplate.\n     *\n     * @param string      $message              The translated error message\n     * @param string|null $messageTemplate      The template for the error message\n     * @param array       $messageParameters    The parameters that should be\n     *                                          substituted in the message template\n     * @param int|null    $messagePluralization The value for error message pluralization\n     * @param mixed       $cause                The cause of the error\n     *\n     * @see \\Symfony\\Component\\Translation\\Translator\n     */\n    public function __construct(\n        private string $message,\n        ?string $messageTemplate = null,\n        protected array $messageParameters = [],\n        protected ?int $messagePluralization = null,\n        private mixed $cause = null,\n    ) {\n        $this->messageTemplate = $messageTemplate ?: $message;\n    }\n\n    /**\n     * Returns the error message.\n     */\n    public function getMessage(): string\n    {\n        return $this->message;\n    }\n\n    /**\n     * Returns the error message template.\n     */\n    public function getMessageTemplate(): string\n    {\n        return $this->messageTemplate;\n    }\n\n    /**\n     * Returns the parameters to be inserted in the message template.\n     */\n    public function getMessageParameters(): array\n    {\n        return $this->messageParameters;\n    }\n\n    /**\n     * Returns the value for error message pluralization.\n     */\n    public function getMessagePluralization(): ?int\n    {\n        return $this->messagePluralization;\n    }\n\n    /**\n     * Returns the cause of this error.\n     */\n    public function getCause(): mixed\n    {\n        return $this->cause;\n    }\n\n    /**\n     * Sets the form that caused this error.\n     *\n     * This method must only be called once.\n     *\n     * @throws BadMethodCallException If the method is called more than once\n     */\n    public function setOrigin(FormInterface $origin): void\n    {\n        if (null !== $this->origin) {\n            throw new BadMethodCallException('setOrigin() must only be called once.');\n        }\n\n        $this->origin = $origin;\n    }\n\n    /**\n     * Returns the form that caused this error.\n     */\n    public function getOrigin(): ?FormInterface\n    {\n        return $this->origin;\n    }\n}\n"
        },
        {
          "name": "FormErrorIterator.php",
          "type": "blob",
          "size": 7.353515625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Exception\\BadMethodCallException;\nuse Symfony\\Component\\Form\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Form\\Exception\\LogicException;\nuse Symfony\\Component\\Form\\Exception\\OutOfBoundsException;\nuse Symfony\\Component\\Validator\\ConstraintViolation;\n\n/**\n * Iterates over the errors of a form.\n *\n * This class supports recursive iteration. In order to iterate recursively,\n * pass a structure of {@link FormError} and {@link FormErrorIterator} objects\n * to the $errors constructor argument.\n *\n * You can also wrap the iterator into a {@link \\RecursiveIteratorIterator} to\n * flatten the recursive structure into a flat list of errors.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @template T of FormError|FormErrorIterator\n *\n * @implements \\ArrayAccess<int, T>\n * @implements \\RecursiveIterator<int, T>\n * @implements \\SeekableIterator<int, T>\n */\nclass FormErrorIterator implements \\RecursiveIterator, \\SeekableIterator, \\ArrayAccess, \\Countable, \\Stringable\n{\n    /**\n     * The prefix used for indenting nested error messages.\n     */\n    public const INDENTATION = '    ';\n\n    /**\n     * @var list<T>\n     */\n    private array $errors;\n\n    /**\n     * @param list<T> $errors\n     *\n     * @throws InvalidArgumentException If the errors are invalid\n     */\n    public function __construct(\n        private FormInterface $form,\n        array $errors,\n    ) {\n        foreach ($errors as $error) {\n            if (!($error instanceof FormError || $error instanceof self)) {\n                throw new InvalidArgumentException(\\sprintf('The errors must be instances of \"Symfony\\Component\\Form\\FormError\" or \"%s\". Got: \"%s\".', __CLASS__, get_debug_type($error)));\n            }\n        }\n\n        $this->errors = $errors;\n    }\n\n    /**\n     * Returns all iterated error messages as string.\n     */\n    public function __toString(): string\n    {\n        $string = '';\n\n        foreach ($this->errors as $error) {\n            if ($error instanceof FormError) {\n                $string .= 'ERROR: '.$error->getMessage().\"\\n\";\n            } else {\n                /* @var self $error */\n                $string .= $error->getForm()->getName().\":\\n\";\n                $string .= self::indent((string) $error);\n            }\n        }\n\n        return $string;\n    }\n\n    /**\n     * Returns the iterated form.\n     */\n    public function getForm(): FormInterface\n    {\n        return $this->form;\n    }\n\n    /**\n     * Returns the current element of the iterator.\n     *\n     * @return T An error or an iterator containing nested errors\n     */\n    public function current(): FormError|self\n    {\n        return current($this->errors);\n    }\n\n    /**\n     * Advances the iterator to the next position.\n     */\n    public function next(): void\n    {\n        next($this->errors);\n    }\n\n    /**\n     * Returns the current position of the iterator.\n     */\n    public function key(): int\n    {\n        return key($this->errors);\n    }\n\n    /**\n     * Returns whether the iterator's position is valid.\n     */\n    public function valid(): bool\n    {\n        return null !== key($this->errors);\n    }\n\n    /**\n     * Sets the iterator's position to the beginning.\n     *\n     * This method detects if errors have been added to the form since the\n     * construction of the iterator.\n     */\n    public function rewind(): void\n    {\n        reset($this->errors);\n    }\n\n    /**\n     * Returns whether a position exists in the iterator.\n     *\n     * @param int $position The position\n     */\n    public function offsetExists(mixed $position): bool\n    {\n        return isset($this->errors[$position]);\n    }\n\n    /**\n     * Returns the element at a position in the iterator.\n     *\n     * @param int $position The position\n     *\n     * @return T\n     *\n     * @throws OutOfBoundsException If the given position does not exist\n     */\n    public function offsetGet(mixed $position): FormError|self\n    {\n        if (!isset($this->errors[$position])) {\n            throw new OutOfBoundsException('The offset '.$position.' does not exist.');\n        }\n\n        return $this->errors[$position];\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function offsetSet(mixed $position, mixed $value): void\n    {\n        throw new BadMethodCallException('The iterator doesn\\'t support modification of elements.');\n    }\n\n    /**\n     * Unsupported method.\n     *\n     * @throws BadMethodCallException\n     */\n    public function offsetUnset(mixed $position): void\n    {\n        throw new BadMethodCallException('The iterator doesn\\'t support modification of elements.');\n    }\n\n    /**\n     * Returns whether the current element of the iterator can be recursed\n     * into.\n     */\n    public function hasChildren(): bool\n    {\n        return current($this->errors) instanceof self;\n    }\n\n    public function getChildren(): self\n    {\n        if (!$this->hasChildren()) {\n            throw new LogicException(\\sprintf('The current element is not iterable. Use \"%s\" to get the current element.', self::class.'::current()'));\n        }\n\n        /** @var self $children */\n        $children = current($this->errors);\n\n        return $children;\n    }\n\n    /**\n     * Returns the number of elements in the iterator.\n     *\n     * Note that this is not the total number of errors, if the constructor\n     * parameter $deep was set to true! In that case, you should wrap the\n     * iterator into a {@link \\RecursiveIteratorIterator} with the standard mode\n     * {@link \\RecursiveIteratorIterator::LEAVES_ONLY} and count the result.\n     *\n     *     $iterator = new \\RecursiveIteratorIterator($form->getErrors(true));\n     *     $count = count(iterator_to_array($iterator));\n     *\n     * Alternatively, set the constructor argument $flatten to true as well.\n     *\n     *     $count = count($form->getErrors(true, true));\n     */\n    public function count(): int\n    {\n        return \\count($this->errors);\n    }\n\n    /**\n     * Sets the position of the iterator.\n     *\n     * @throws OutOfBoundsException If the position is invalid\n     */\n    public function seek(int $position): void\n    {\n        if (!isset($this->errors[$position])) {\n            throw new OutOfBoundsException('The offset '.$position.' does not exist.');\n        }\n\n        reset($this->errors);\n\n        while ($position !== key($this->errors)) {\n            next($this->errors);\n        }\n    }\n\n    /**\n     * Creates iterator for errors with specific codes.\n     *\n     * @param string|string[] $codes The codes to find\n     */\n    public function findByCodes(string|array $codes): static\n    {\n        $codes = (array) $codes;\n        $errors = [];\n        foreach ($this as $error) {\n            $cause = $error->getCause();\n            if ($cause instanceof ConstraintViolation && \\in_array($cause->getCode(), $codes, true)) {\n                $errors[] = $error;\n            }\n        }\n\n        return new static($this->form, $errors);\n    }\n\n    /**\n     * Utility function for indenting multi-line strings.\n     */\n    private static function indent(string $string): string\n    {\n        return rtrim(self::INDENTATION.str_replace(\"\\n\", \"\\n\".self::INDENTATION, $string), ' ');\n    }\n}\n"
        },
        {
          "name": "FormEvent.php",
          "type": "blob",
          "size": 0.95703125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Contracts\\EventDispatcher\\Event;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass FormEvent extends Event\n{\n    public function __construct(\n        private FormInterface $form,\n        protected mixed $data,\n    ) {\n    }\n\n    /**\n     * Returns the form at the source of the event.\n     */\n    public function getForm(): FormInterface\n    {\n        return $this->form;\n    }\n\n    /**\n     * Returns the data associated with this event.\n     */\n    public function getData(): mixed\n    {\n        return $this->data;\n    }\n\n    /**\n     * Allows updating with some filtered data.\n     */\n    public function setData(mixed $data): void\n    {\n        $this->data = $data;\n    }\n}\n"
        },
        {
          "name": "FormEvents.php",
          "type": "blob",
          "size": 4.0244140625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Event\\PostSetDataEvent;\nuse Symfony\\Component\\Form\\Event\\PostSubmitEvent;\nuse Symfony\\Component\\Form\\Event\\PreSetDataEvent;\nuse Symfony\\Component\\Form\\Event\\PreSubmitEvent;\nuse Symfony\\Component\\Form\\Event\\SubmitEvent;\n\n/**\n * To learn more about how form events work check the documentation\n * entry at {@link https://symfony.com/doc/any/components/form/form_events.html}.\n *\n * To learn how to dynamically modify forms using events check the cookbook\n * entry at {@link https://symfony.com/doc/any/cookbook/form/dynamic_form_modification.html}.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nfinal class FormEvents\n{\n    /**\n     * The PRE_SUBMIT event is dispatched at the beginning of the Form::submit() method.\n     *\n     * It can be used to:\n     *  - Change data from the request, before submitting the data to the form.\n     *  - Add or remove form fields, before submitting the data to the form.\n     *\n     * @Event(\"Symfony\\Component\\Form\\Event\\PreSubmitEvent\")\n     */\n    public const PRE_SUBMIT = 'form.pre_submit';\n\n    /**\n     * The SUBMIT event is dispatched after the Form::submit() method\n     * has changed the view data by the request data, or submitted and mapped\n     * the children if the form is compound, and after reverse transformation\n     * to normalized representation.\n     *\n     * It's also dispatched just before the Form::submit() method transforms back\n     * the normalized data to the model and view data.\n     *\n     * So at this stage children of compound forms are submitted and synchronized, unless\n     * their transformation failed, but a parent would still be at the PRE_SUBMIT level.\n     *\n     * Since the current form is not synchronized yet, it is still possible to add and\n     * remove fields.\n     *\n     * @Event(\"Symfony\\Component\\Form\\Event\\SubmitEvent\")\n     */\n    public const SUBMIT = 'form.submit';\n\n    /**\n     * The FormEvents::POST_SUBMIT event is dispatched at the very end of the Form::submit().\n     *\n     * It this stage the model and view data may have been denormalized. Otherwise the form\n     * is desynchronized because transformation failed during submission.\n     *\n     * It can be used to fetch data after denormalization.\n     *\n     * The event attaches the current view data. To know whether this is the renormalized data\n     * or the invalid request data, call Form::isSynchronized() first.\n     *\n     * @Event(\"Symfony\\Component\\Form\\Event\\PostSubmitEvent\")\n     */\n    public const POST_SUBMIT = 'form.post_submit';\n\n    /**\n     * The FormEvents::PRE_SET_DATA event is dispatched at the beginning of the Form::setData() method.\n     *\n     * It can be used to:\n     *  - Modify the data given during pre-population;\n     *  - Keep synchronized the form depending on the data (adding or removing fields dynamically).\n     *\n     * @Event(\"Symfony\\Component\\Form\\Event\\PreSetDataEvent\")\n     */\n    public const PRE_SET_DATA = 'form.pre_set_data';\n\n    /**\n     * The FormEvents::POST_SET_DATA event is dispatched at the end of the Form::setData() method.\n     *\n     * This event can be used to modify the form depending on the final state of the underlying data\n     * accessible in every representation: model, normalized and view.\n     *\n     * @Event(\"Symfony\\Component\\Form\\Event\\PostSetDataEvent\")\n     */\n    public const POST_SET_DATA = 'form.post_set_data';\n\n    /**\n     * Event aliases.\n     *\n     * These aliases can be consumed by RegisterListenersPass.\n     */\n    public const ALIASES = [\n        PreSubmitEvent::class => self::PRE_SUBMIT,\n        SubmitEvent::class => self::SUBMIT,\n        PostSubmitEvent::class => self::POST_SUBMIT,\n        PreSetDataEvent::class => self::PRE_SET_DATA,\n        PostSetDataEvent::class => self::POST_SET_DATA,\n    ];\n\n    private function __construct()\n    {\n    }\n}\n"
        },
        {
          "name": "FormExtensionInterface.php",
          "type": "blob",
          "size": 1.400390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * Interface for extensions which provide types, type extensions and a guesser.\n */\ninterface FormExtensionInterface\n{\n    /**\n     * Returns a type by name.\n     *\n     * @param string $name The name of the type\n     *\n     * @throws Exception\\InvalidArgumentException if the given type is not supported by this extension\n     */\n    public function getType(string $name): FormTypeInterface;\n\n    /**\n     * Returns whether the given type is supported.\n     *\n     * @param string $name The name of the type\n     */\n    public function hasType(string $name): bool;\n\n    /**\n     * Returns the extensions for the given type.\n     *\n     * @param string $name The name of the type\n     *\n     * @return FormTypeExtensionInterface[]\n     */\n    public function getTypeExtensions(string $name): array;\n\n    /**\n     * Returns whether this extension provides type extensions for the given type.\n     *\n     * @param string $name The name of the type\n     */\n    public function hasTypeExtensions(string $name): bool;\n\n    /**\n     * Returns the type guesser provided by this extension.\n     */\n    public function getTypeGuesser(): ?FormTypeGuesserInterface;\n}\n"
        },
        {
          "name": "FormFactory.php",
          "type": "blob",
          "size": 3.693359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\FormType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\n\nclass FormFactory implements FormFactoryInterface\n{\n    public function __construct(\n        private FormRegistryInterface $registry,\n    ) {\n    }\n\n    public function create(string $type = FormType::class, mixed $data = null, array $options = []): FormInterface\n    {\n        return $this->createBuilder($type, $data, $options)->getForm();\n    }\n\n    public function createNamed(string $name, string $type = FormType::class, mixed $data = null, array $options = []): FormInterface\n    {\n        return $this->createNamedBuilder($name, $type, $data, $options)->getForm();\n    }\n\n    public function createForProperty(string $class, string $property, mixed $data = null, array $options = []): FormInterface\n    {\n        return $this->createBuilderForProperty($class, $property, $data, $options)->getForm();\n    }\n\n    public function createBuilder(string $type = FormType::class, mixed $data = null, array $options = []): FormBuilderInterface\n    {\n        return $this->createNamedBuilder($this->registry->getType($type)->getBlockPrefix(), $type, $data, $options);\n    }\n\n    public function createNamedBuilder(string $name, string $type = FormType::class, mixed $data = null, array $options = []): FormBuilderInterface\n    {\n        if (null !== $data && !\\array_key_exists('data', $options)) {\n            $options['data'] = $data;\n        }\n\n        $type = $this->registry->getType($type);\n\n        $builder = $type->createBuilder($this, $name, $options);\n\n        // Explicitly call buildForm() in order to be able to override either\n        // createBuilder() or buildForm() in the resolved form type\n        $type->buildForm($builder, $builder->getOptions());\n\n        return $builder;\n    }\n\n    public function createBuilderForProperty(string $class, string $property, mixed $data = null, array $options = []): FormBuilderInterface\n    {\n        if (null === $guesser = $this->registry->getTypeGuesser()) {\n            return $this->createNamedBuilder($property, TextType::class, $data, $options);\n        }\n\n        $typeGuess = $guesser->guessType($class, $property);\n        $maxLengthGuess = $guesser->guessMaxLength($class, $property);\n        $requiredGuess = $guesser->guessRequired($class, $property);\n        $patternGuess = $guesser->guessPattern($class, $property);\n\n        $type = $typeGuess ? $typeGuess->getType() : TextType::class;\n\n        $maxLength = $maxLengthGuess?->getValue();\n        $pattern = $patternGuess?->getValue();\n\n        if (null !== $pattern) {\n            $options = array_replace_recursive(['attr' => ['pattern' => $pattern]], $options);\n        }\n\n        if (null !== $maxLength) {\n            $options = array_replace_recursive(['attr' => ['maxlength' => $maxLength]], $options);\n        }\n\n        if ($requiredGuess) {\n            $options = array_merge(['required' => $requiredGuess->getValue()], $options);\n        }\n\n        // user options may override guessed options\n        if ($typeGuess) {\n            $attrs = [];\n            $typeGuessOptions = $typeGuess->getOptions();\n            if (isset($typeGuessOptions['attr']) && isset($options['attr'])) {\n                $attrs = ['attr' => array_merge($typeGuessOptions['attr'], $options['attr'])];\n            }\n\n            $options = array_merge($typeGuessOptions, $options, $attrs);\n        }\n\n        return $this->createNamedBuilder($property, $type, $data, $options);\n    }\n}\n"
        },
        {
          "name": "FormFactoryBuilder.php",
          "type": "blob",
          "size": 3.7734375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Extension\\Core\\CoreExtension;\n\n/**\n * The default implementation of FormFactoryBuilderInterface.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass FormFactoryBuilder implements FormFactoryBuilderInterface\n{\n    private ResolvedFormTypeFactoryInterface $resolvedTypeFactory;\n\n    /**\n     * @var FormExtensionInterface[]\n     */\n    private array $extensions = [];\n\n    /**\n     * @var FormTypeInterface[]\n     */\n    private array $types = [];\n\n    /**\n     * @var FormTypeExtensionInterface[][]\n     */\n    private array $typeExtensions = [];\n\n    /**\n     * @var FormTypeGuesserInterface[]\n     */\n    private array $typeGuessers = [];\n\n    public function __construct(\n        private bool $forceCoreExtension = false,\n    ) {\n    }\n\n    public function setResolvedTypeFactory(ResolvedFormTypeFactoryInterface $resolvedTypeFactory): static\n    {\n        $this->resolvedTypeFactory = $resolvedTypeFactory;\n\n        return $this;\n    }\n\n    public function addExtension(FormExtensionInterface $extension): static\n    {\n        $this->extensions[] = $extension;\n\n        return $this;\n    }\n\n    public function addExtensions(array $extensions): static\n    {\n        $this->extensions = array_merge($this->extensions, $extensions);\n\n        return $this;\n    }\n\n    public function addType(FormTypeInterface $type): static\n    {\n        $this->types[] = $type;\n\n        return $this;\n    }\n\n    public function addTypes(array $types): static\n    {\n        foreach ($types as $type) {\n            $this->types[] = $type;\n        }\n\n        return $this;\n    }\n\n    public function addTypeExtension(FormTypeExtensionInterface $typeExtension): static\n    {\n        foreach ($typeExtension::getExtendedTypes() as $extendedType) {\n            $this->typeExtensions[$extendedType][] = $typeExtension;\n        }\n\n        return $this;\n    }\n\n    public function addTypeExtensions(array $typeExtensions): static\n    {\n        foreach ($typeExtensions as $typeExtension) {\n            $this->addTypeExtension($typeExtension);\n        }\n\n        return $this;\n    }\n\n    public function addTypeGuesser(FormTypeGuesserInterface $typeGuesser): static\n    {\n        $this->typeGuessers[] = $typeGuesser;\n\n        return $this;\n    }\n\n    public function addTypeGuessers(array $typeGuessers): static\n    {\n        $this->typeGuessers = array_merge($this->typeGuessers, $typeGuessers);\n\n        return $this;\n    }\n\n    public function getFormFactory(): FormFactoryInterface\n    {\n        $extensions = $this->extensions;\n\n        if ($this->forceCoreExtension) {\n            $hasCoreExtension = false;\n\n            foreach ($extensions as $extension) {\n                if ($extension instanceof CoreExtension) {\n                    $hasCoreExtension = true;\n                    break;\n                }\n            }\n\n            if (!$hasCoreExtension) {\n                array_unshift($extensions, new CoreExtension());\n            }\n        }\n\n        if (\\count($this->types) > 0 || \\count($this->typeExtensions) > 0 || \\count($this->typeGuessers) > 0) {\n            if (\\count($this->typeGuessers) > 1) {\n                $typeGuesser = new FormTypeGuesserChain($this->typeGuessers);\n            } else {\n                $typeGuesser = $this->typeGuessers[0] ?? null;\n            }\n\n            $extensions[] = new PreloadedExtension($this->types, $this->typeExtensions, $typeGuesser);\n        }\n\n        $registry = new FormRegistry($extensions, $this->resolvedTypeFactory ?? new ResolvedFormTypeFactory());\n\n        return new FormFactory($registry);\n    }\n}\n"
        },
        {
          "name": "FormFactoryBuilderInterface.php",
          "type": "blob",
          "size": 2.345703125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * A builder for FormFactoryInterface objects.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface FormFactoryBuilderInterface\n{\n    /**\n     * Sets the factory for creating ResolvedFormTypeInterface instances.\n     *\n     * @return $this\n     */\n    public function setResolvedTypeFactory(ResolvedFormTypeFactoryInterface $resolvedTypeFactory): static;\n\n    /**\n     * Adds an extension to be loaded by the factory.\n     *\n     * @return $this\n     */\n    public function addExtension(FormExtensionInterface $extension): static;\n\n    /**\n     * Adds a list of extensions to be loaded by the factory.\n     *\n     * @param FormExtensionInterface[] $extensions The extensions\n     *\n     * @return $this\n     */\n    public function addExtensions(array $extensions): static;\n\n    /**\n     * Adds a form type to the factory.\n     *\n     * @return $this\n     */\n    public function addType(FormTypeInterface $type): static;\n\n    /**\n     * Adds a list of form types to the factory.\n     *\n     * @param FormTypeInterface[] $types The form types\n     *\n     * @return $this\n     */\n    public function addTypes(array $types): static;\n\n    /**\n     * Adds a form type extension to the factory.\n     *\n     * @return $this\n     */\n    public function addTypeExtension(FormTypeExtensionInterface $typeExtension): static;\n\n    /**\n     * Adds a list of form type extensions to the factory.\n     *\n     * @param FormTypeExtensionInterface[] $typeExtensions The form type extensions\n     *\n     * @return $this\n     */\n    public function addTypeExtensions(array $typeExtensions): static;\n\n    /**\n     * Adds a type guesser to the factory.\n     *\n     * @return $this\n     */\n    public function addTypeGuesser(FormTypeGuesserInterface $typeGuesser): static;\n\n    /**\n     * Adds a list of type guessers to the factory.\n     *\n     * @param FormTypeGuesserInterface[] $typeGuessers The type guessers\n     *\n     * @return $this\n     */\n    public function addTypeGuessers(array $typeGuessers): static;\n\n    /**\n     * Builds and returns the factory.\n     */\n    public function getFormFactory(): FormFactoryInterface;\n}\n"
        },
        {
          "name": "FormFactoryInterface.php",
          "type": "blob",
          "size": 3.0634765625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\FormType;\nuse Symfony\\Component\\OptionsResolver\\Exception\\InvalidOptionsException;\n\n/**\n * Allows creating a form based on a name, a class or a property.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface FormFactoryInterface\n{\n    /**\n     * Returns a form.\n     *\n     * @see createBuilder()\n     *\n     * @param mixed $data The initial data\n     *\n     * @throws InvalidOptionsException if any given option is not applicable to the given type\n     */\n    public function create(string $type = FormType::class, mixed $data = null, array $options = []): FormInterface;\n\n    /**\n     * Returns a form.\n     *\n     * @see createNamedBuilder()\n     *\n     * @param mixed $data The initial data\n     *\n     * @throws InvalidOptionsException if any given option is not applicable to the given type\n     */\n    public function createNamed(string $name, string $type = FormType::class, mixed $data = null, array $options = []): FormInterface;\n\n    /**\n     * Returns a form for a property of a class.\n     *\n     * @see createBuilderForProperty()\n     *\n     * @param string $class    The fully qualified class name\n     * @param string $property The name of the property to guess for\n     * @param mixed  $data     The initial data\n     *\n     * @throws InvalidOptionsException if any given option is not applicable to the form type\n     */\n    public function createForProperty(string $class, string $property, mixed $data = null, array $options = []): FormInterface;\n\n    /**\n     * Returns a form builder.\n     *\n     * @param mixed $data The initial data\n     *\n     * @throws InvalidOptionsException if any given option is not applicable to the given type\n     */\n    public function createBuilder(string $type = FormType::class, mixed $data = null, array $options = []): FormBuilderInterface;\n\n    /**\n     * Returns a form builder.\n     *\n     * @param mixed $data The initial data\n     *\n     * @throws InvalidOptionsException if any given option is not applicable to the given type\n     */\n    public function createNamedBuilder(string $name, string $type = FormType::class, mixed $data = null, array $options = []): FormBuilderInterface;\n\n    /**\n     * Returns a form builder for a property of a class.\n     *\n     * If any of the 'required' and type options can be guessed,\n     * and are not provided in the options argument, the guessed value is used.\n     *\n     * @param string $class    The fully qualified class name\n     * @param string $property The name of the property to guess for\n     * @param mixed  $data     The initial data\n     *\n     * @throws InvalidOptionsException if any given option is not applicable to the form type\n     */\n    public function createBuilderForProperty(string $class, string $property, mixed $data = null, array $options = []): FormBuilderInterface;\n}\n"
        },
        {
          "name": "FormInterface.php",
          "type": "blob",
          "size": 9.263671875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\PropertyAccess\\PropertyPathInterface;\n\n/**\n * A form group bundling multiple forms in a hierarchical structure.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @extends \\ArrayAccess<string, FormInterface>\n * @extends \\Traversable<string, FormInterface>\n */\ninterface FormInterface extends \\ArrayAccess, \\Traversable, \\Countable\n{\n    /**\n     * Sets the parent form.\n     *\n     * @param FormInterface|null $parent The parent form or null if it's the root\n     *\n     * @return $this\n     *\n     * @throws Exception\\AlreadySubmittedException if the form has already been submitted\n     * @throws Exception\\LogicException            when trying to set a parent for a form with\n     *                                             an empty name\n     */\n    public function setParent(?self $parent): static;\n\n    /**\n     * Returns the parent form.\n     */\n    public function getParent(): ?self;\n\n    /**\n     * Adds or replaces a child to the form.\n     *\n     * @param FormInterface|string $child   The FormInterface instance or the name of the child\n     * @param string|null          $type    The child's type, if a name was passed\n     * @param array                $options The child's options, if a name was passed\n     *\n     * @return $this\n     *\n     * @throws Exception\\AlreadySubmittedException if the form has already been submitted\n     * @throws Exception\\LogicException            when trying to add a child to a non-compound form\n     * @throws Exception\\UnexpectedTypeException   if $child or $type has an unexpected type\n     */\n    public function add(self|string $child, ?string $type = null, array $options = []): static;\n\n    /**\n     * Returns the child with the given name.\n     *\n     * @throws Exception\\OutOfBoundsException if the named child does not exist\n     */\n    public function get(string $name): self;\n\n    /**\n     * Returns whether a child with the given name exists.\n     */\n    public function has(string $name): bool;\n\n    /**\n     * Removes a child from the form.\n     *\n     * @return $this\n     *\n     * @throws Exception\\AlreadySubmittedException if the form has already been submitted\n     */\n    public function remove(string $name): static;\n\n    /**\n     * Returns all children in this group.\n     *\n     * @return self[]\n     */\n    public function all(): array;\n\n    /**\n     * Returns the errors of this form.\n     *\n     * @param bool $deep    Whether to include errors of child forms as well\n     * @param bool $flatten Whether to flatten the list of errors in case\n     *                      $deep is set to true\n     */\n    public function getErrors(bool $deep = false, bool $flatten = true): FormErrorIterator;\n\n    /**\n     * Updates the form with default model data.\n     *\n     * @param mixed $modelData The data formatted as expected for the underlying object\n     *\n     * @return $this\n     *\n     * @throws Exception\\AlreadySubmittedException     If the form has already been submitted\n     * @throws Exception\\LogicException                if the view data does not match the expected type\n     *                                                 according to {@link FormConfigInterface::getDataClass}\n     * @throws Exception\\RuntimeException              If listeners try to call setData in a cycle or if\n     *                                                 the form inherits data from its parent\n     * @throws Exception\\TransformationFailedException if the synchronization failed\n     */\n    public function setData(mixed $modelData): static;\n\n    /**\n     * Returns the model data in the format needed for the underlying object.\n     *\n     * @return mixed When the field is not submitted, the default data is returned.\n     *               When the field is submitted, the default data has been bound\n     *               to the submitted view data.\n     *\n     * @throws Exception\\RuntimeException If the form inherits data but has no parent\n     */\n    public function getData(): mixed;\n\n    /**\n     * Returns the normalized data of the field, used as internal bridge\n     * between model data and view data.\n     *\n     * @return mixed When the field is not submitted, the default data is returned.\n     *               When the field is submitted, the normalized submitted data\n     *               is returned if the field is synchronized with the view data,\n     *               null otherwise.\n     *\n     * @throws Exception\\RuntimeException If the form inherits data but has no parent\n     */\n    public function getNormData(): mixed;\n\n    /**\n     * Returns the view data of the field.\n     *\n     * It may be defined by {@link FormConfigInterface::getDataClass}.\n     *\n     * There are two cases:\n     *\n     * - When the form is compound the view data is mapped to the children.\n     *   Each child will use its mapped data as model data.\n     *   It can be an array, an object or null.\n     *\n     * - When the form is simple its view data is used to be bound\n     *   to the submitted data.\n     *   It can be a string or an array.\n     *\n     * In both cases the view data is the actual altered data on submission.\n     *\n     * @throws Exception\\RuntimeException If the form inherits data but has no parent\n     */\n    public function getViewData(): mixed;\n\n    /**\n     * Returns the extra submitted data.\n     *\n     * @return array The submitted data which do not belong to a child\n     */\n    public function getExtraData(): array;\n\n    /**\n     * Returns the form's configuration.\n     */\n    public function getConfig(): FormConfigInterface;\n\n    /**\n     * Returns whether the form is submitted.\n     */\n    public function isSubmitted(): bool;\n\n    /**\n     * Returns the name by which the form is identified in forms.\n     *\n     * Only root forms are allowed to have an empty name.\n     */\n    public function getName(): string;\n\n    /**\n     * Returns the property path that the form is mapped to.\n     */\n    public function getPropertyPath(): ?PropertyPathInterface;\n\n    /**\n     * Adds an error to this form.\n     *\n     * @return $this\n     */\n    public function addError(FormError $error): static;\n\n    /**\n     * Returns whether the form and all children are valid.\n     *\n     * @throws Exception\\LogicException if the form is not submitted\n     */\n    public function isValid(): bool;\n\n    /**\n     * Returns whether the form is required to be filled out.\n     *\n     * If the form has a parent and the parent is not required, this method\n     * will always return false. Otherwise the value set with setRequired()\n     * is returned.\n     */\n    public function isRequired(): bool;\n\n    /**\n     * Returns whether this form is disabled.\n     *\n     * The content of a disabled form is displayed, but not allowed to be\n     * modified. The validation of modified disabled forms should fail.\n     *\n     * Forms whose parents are disabled are considered disabled regardless of\n     * their own state.\n     */\n    public function isDisabled(): bool;\n\n    /**\n     * Returns whether the form is empty.\n     */\n    public function isEmpty(): bool;\n\n    /**\n     * Returns whether the data in the different formats is synchronized.\n     *\n     * If the data is not synchronized, you can get the transformation failure\n     * by calling {@link getTransformationFailure()}.\n     *\n     * If the form is not submitted, this method always returns true.\n     */\n    public function isSynchronized(): bool;\n\n    /**\n     * Returns the data transformation failure, if any, during submission.\n     */\n    public function getTransformationFailure(): ?Exception\\TransformationFailedException;\n\n    /**\n     * Initializes the form tree.\n     *\n     * Should be called on the root form after constructing the tree.\n     *\n     * @return $this\n     *\n     * @throws Exception\\RuntimeException If the form is not the root\n     */\n    public function initialize(): static;\n\n    /**\n     * Inspects the given request and calls {@link submit()} if the form was\n     * submitted.\n     *\n     * Internally, the request is forwarded to the configured\n     * {@link RequestHandlerInterface} instance, which determines whether to\n     * submit the form or not.\n     *\n     * @return $this\n     */\n    public function handleRequest(mixed $request = null): static;\n\n    /**\n     * Submits data to the form.\n     *\n     * @param string|array|null $submittedData The submitted data\n     * @param bool              $clearMissing  Whether to set fields to NULL\n     *                                         when they are missing in the\n     *                                         submitted data. This argument\n     *                                         is only used in compound form\n     *\n     * @return $this\n     *\n     * @throws Exception\\AlreadySubmittedException if the form has already been submitted\n     */\n    public function submit(string|array|null $submittedData, bool $clearMissing = true): static;\n\n    /**\n     * Returns the root of the form tree.\n     */\n    public function getRoot(): self;\n\n    /**\n     * Returns whether the field is the root of the form tree.\n     */\n    public function isRoot(): bool;\n\n    public function createView(?FormView $parent = null): FormView;\n}\n"
        },
        {
          "name": "FormRegistry.php",
          "type": "blob",
          "size": 4.46875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Exception\\ExceptionInterface;\nuse Symfony\\Component\\Form\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Form\\Exception\\LogicException;\nuse Symfony\\Component\\Form\\Exception\\UnexpectedTypeException;\n\n/**\n * The central registry of the Form component.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass FormRegistry implements FormRegistryInterface\n{\n    /**\n     * @var FormExtensionInterface[]\n     */\n    private array $extensions = [];\n\n    /**\n     * @var ResolvedFormTypeInterface[]\n     */\n    private array $types = [];\n\n    private FormTypeGuesserInterface|false|null $guesser = false;\n    private array $checkedTypes = [];\n\n    /**\n     * @param FormExtensionInterface[] $extensions\n     *\n     * @throws UnexpectedTypeException if any extension does not implement FormExtensionInterface\n     */\n    public function __construct(\n        array $extensions,\n        private ResolvedFormTypeFactoryInterface $resolvedTypeFactory,\n    ) {\n        foreach ($extensions as $extension) {\n            if (!$extension instanceof FormExtensionInterface) {\n                throw new UnexpectedTypeException($extension, FormExtensionInterface::class);\n            }\n        }\n\n        $this->extensions = $extensions;\n    }\n\n    public function getType(string $name): ResolvedFormTypeInterface\n    {\n        if (!isset($this->types[$name])) {\n            $type = null;\n\n            foreach ($this->extensions as $extension) {\n                if ($extension->hasType($name)) {\n                    $type = $extension->getType($name);\n                    break;\n                }\n            }\n\n            if (!$type) {\n                // Support fully-qualified class names\n                if (!class_exists($name)) {\n                    throw new InvalidArgumentException(\\sprintf('Could not load type \"%s\": class does not exist.', $name));\n                }\n                if (!is_subclass_of($name, FormTypeInterface::class)) {\n                    throw new InvalidArgumentException(\\sprintf('Could not load type \"%s\": class does not implement \"Symfony\\Component\\Form\\FormTypeInterface\".', $name));\n                }\n\n                $type = new $name();\n            }\n\n            $this->types[$name] = $this->resolveType($type);\n        }\n\n        return $this->types[$name];\n    }\n\n    /**\n     * Wraps a type into a ResolvedFormTypeInterface implementation and connects it with its parent type.\n     */\n    private function resolveType(FormTypeInterface $type): ResolvedFormTypeInterface\n    {\n        $parentType = $type->getParent();\n        $fqcn = $type::class;\n\n        if (isset($this->checkedTypes[$fqcn])) {\n            $types = implode(' > ', array_merge(array_keys($this->checkedTypes), [$fqcn]));\n            throw new LogicException(\\sprintf('Circular reference detected for form type \"%s\" (%s).', $fqcn, $types));\n        }\n\n        $this->checkedTypes[$fqcn] = true;\n\n        $typeExtensions = [];\n        try {\n            foreach ($this->extensions as $extension) {\n                $typeExtensions[] = $extension->getTypeExtensions($fqcn);\n            }\n\n            return $this->resolvedTypeFactory->createResolvedType(\n                $type,\n                array_merge([], ...$typeExtensions),\n                $parentType ? $this->getType($parentType) : null\n            );\n        } finally {\n            unset($this->checkedTypes[$fqcn]);\n        }\n    }\n\n    public function hasType(string $name): bool\n    {\n        if (isset($this->types[$name])) {\n            return true;\n        }\n\n        try {\n            $this->getType($name);\n        } catch (ExceptionInterface) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public function getTypeGuesser(): ?FormTypeGuesserInterface\n    {\n        if (false === $this->guesser) {\n            $guessers = [];\n\n            foreach ($this->extensions as $extension) {\n                $guesser = $extension->getTypeGuesser();\n\n                if ($guesser) {\n                    $guessers[] = $guesser;\n                }\n            }\n\n            $this->guesser = $guessers ? new FormTypeGuesserChain($guessers) : null;\n        }\n\n        return $this->guesser;\n    }\n\n    public function getExtensions(): array\n    {\n        return $this->extensions;\n    }\n}\n"
        },
        {
          "name": "FormRegistryInterface.php",
          "type": "blob",
          "size": 1.1298828125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * The central registry of the Form component.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface FormRegistryInterface\n{\n    /**\n     * Returns a form type by name.\n     *\n     * This method registers the type extensions from the form extensions.\n     *\n     * @throws Exception\\InvalidArgumentException if the type cannot be retrieved from any extension\n     */\n    public function getType(string $name): ResolvedFormTypeInterface;\n\n    /**\n     * Returns whether the given form type is supported.\n     */\n    public function hasType(string $name): bool;\n\n    /**\n     * Returns the guesser responsible for guessing types.\n     */\n    public function getTypeGuesser(): ?FormTypeGuesserInterface;\n\n    /**\n     * Returns the extensions loaded by the framework.\n     *\n     * @return FormExtensionInterface[]\n     */\n    public function getExtensions(): array;\n}\n"
        },
        {
          "name": "FormRenderer.php",
          "type": "blob",
          "size": 11.6591796875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Exception\\BadMethodCallException;\nuse Symfony\\Component\\Form\\Exception\\LogicException;\nuse Symfony\\Component\\Security\\Csrf\\CsrfTokenManagerInterface;\nuse Twig\\Environment;\n\n/**\n * Renders a form into HTML using a rendering engine.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass FormRenderer implements FormRendererInterface\n{\n    public const CACHE_KEY_VAR = 'unique_block_prefix';\n\n    private array $blockNameHierarchyMap = [];\n    private array $hierarchyLevelMap = [];\n    private array $variableStack = [];\n\n    public function __construct(\n        private FormRendererEngineInterface $engine,\n        private ?CsrfTokenManagerInterface $csrfTokenManager = null,\n    ) {\n    }\n\n    public function getEngine(): FormRendererEngineInterface\n    {\n        return $this->engine;\n    }\n\n    public function setTheme(FormView $view, mixed $themes, bool $useDefaultThemes = true): void\n    {\n        $this->engine->setTheme($view, $themes, $useDefaultThemes);\n    }\n\n    public function renderCsrfToken(string $tokenId): string\n    {\n        if (null === $this->csrfTokenManager) {\n            throw new BadMethodCallException('CSRF tokens can only be generated if a CsrfTokenManagerInterface is injected in FormRenderer::__construct(). Try running \"composer require symfony/security-csrf\".');\n        }\n\n        return $this->csrfTokenManager->getToken($tokenId)->getValue();\n    }\n\n    public function renderBlock(FormView $view, string $blockName, array $variables = []): string\n    {\n        $resource = $this->engine->getResourceForBlockName($view, $blockName);\n\n        if (!$resource) {\n            throw new LogicException(\\sprintf('No block \"%s\" found while rendering the form.', $blockName));\n        }\n\n        $viewCacheKey = $view->vars[self::CACHE_KEY_VAR];\n\n        // The variables are cached globally for a view (instead of for the\n        // current suffix)\n        if (!isset($this->variableStack[$viewCacheKey])) {\n            $this->variableStack[$viewCacheKey] = [];\n\n            // The default variable scope contains all view variables, merged with\n            // the variables passed explicitly to the helper\n            $scopeVariables = $view->vars;\n\n            $varInit = true;\n        } else {\n            // Reuse the current scope and merge it with the explicitly passed variables\n            $scopeVariables = end($this->variableStack[$viewCacheKey]);\n\n            $varInit = false;\n        }\n\n        // Merge the passed with the existing attributes\n        if (isset($variables['attr']) && isset($scopeVariables['attr'])) {\n            $variables['attr'] = array_replace($scopeVariables['attr'], $variables['attr']);\n        }\n\n        // Merge the passed with the exist *label* attributes\n        if (isset($variables['label_attr']) && isset($scopeVariables['label_attr'])) {\n            $variables['label_attr'] = array_replace($scopeVariables['label_attr'], $variables['label_attr']);\n        }\n\n        // Do not use array_replace_recursive(), otherwise array variables\n        // cannot be overwritten\n        $variables = array_replace($scopeVariables, $variables);\n\n        $this->variableStack[$viewCacheKey][] = $variables;\n\n        // Do the rendering\n        $html = $this->engine->renderBlock($view, $resource, $blockName, $variables);\n\n        // Clear the stack\n        array_pop($this->variableStack[$viewCacheKey]);\n\n        if ($varInit) {\n            unset($this->variableStack[$viewCacheKey]);\n        }\n\n        return $html;\n    }\n\n    public function searchAndRenderBlock(FormView $view, string $blockNameSuffix, array $variables = []): string\n    {\n        $renderOnlyOnce = 'row' === $blockNameSuffix || 'widget' === $blockNameSuffix;\n\n        if ($renderOnlyOnce && $view->isRendered()) {\n            // This is not allowed, because it would result in rendering same IDs multiple times, which is not valid.\n            throw new BadMethodCallException(\\sprintf('Field \"%s\" has already been rendered, save the result of previous render call to a variable and output that instead.', $view->vars['name']));\n        }\n\n        // The cache key for storing the variables and types\n        $viewCacheKey = $view->vars[self::CACHE_KEY_VAR];\n        $viewAndSuffixCacheKey = $viewCacheKey.$blockNameSuffix;\n\n        // In templates, we have to deal with two kinds of block hierarchies:\n        //\n        //   +---------+          +---------+\n        //   | Theme B | -------> | Theme A |\n        //   +---------+          +---------+\n        //\n        //   form_widget -------> form_widget\n        //       ^\n        //       |\n        //  choice_widget -----> choice_widget\n        //\n        // The first kind of hierarchy is the theme hierarchy. This allows to\n        // override the block \"choice_widget\" from Theme A in the extending\n        // Theme B. This kind of inheritance needs to be supported by the\n        // template engine and, for example, offers \"parent()\" or similar\n        // functions to fall back from the custom to the parent implementation.\n        //\n        // The second kind of hierarchy is the form type hierarchy. This allows\n        // to implement a custom \"choice_widget\" block (no matter in which theme),\n        // or to fallback to the block of the parent type, which would be\n        // \"form_widget\" in this example (again, no matter in which theme).\n        // If the designer wants to explicitly fallback to \"form_widget\" in their\n        // custom \"choice_widget\", for example because they only want to wrap\n        // a <div> around the original implementation, they can call the\n        // widget() function again to render the block for the parent type.\n        //\n        // The second kind is implemented in the following blocks.\n        if (!isset($this->blockNameHierarchyMap[$viewAndSuffixCacheKey])) {\n            // INITIAL CALL\n            // Calculate the hierarchy of template blocks and start on\n            // the bottom level of the hierarchy (= \"_<id>_<section>\" block)\n            $blockNameHierarchy = [];\n            foreach ($view->vars['block_prefixes'] as $blockNamePrefix) {\n                $blockNameHierarchy[] = $blockNamePrefix.'_'.$blockNameSuffix;\n            }\n            $hierarchyLevel = \\count($blockNameHierarchy) - 1;\n\n            $hierarchyInit = true;\n        } else {\n            // RECURSIVE CALL\n            // If a block recursively calls searchAndRenderBlock() again, resume rendering\n            // using the parent type in the hierarchy.\n            $blockNameHierarchy = $this->blockNameHierarchyMap[$viewAndSuffixCacheKey];\n            $hierarchyLevel = $this->hierarchyLevelMap[$viewAndSuffixCacheKey] - 1;\n\n            $hierarchyInit = false;\n        }\n\n        // The variables are cached globally for a view (instead of for the\n        // current suffix)\n        if (!isset($this->variableStack[$viewCacheKey])) {\n            $this->variableStack[$viewCacheKey] = [];\n\n            // The default variable scope contains all view variables, merged with\n            // the variables passed explicitly to the helper\n            $scopeVariables = $view->vars;\n\n            $varInit = true;\n        } else {\n            // Reuse the current scope and merge it with the explicitly passed variables\n            $scopeVariables = end($this->variableStack[$viewCacheKey]);\n\n            $varInit = false;\n        }\n\n        // Load the resource where this block can be found\n        $resource = $this->engine->getResourceForBlockNameHierarchy($view, $blockNameHierarchy, $hierarchyLevel);\n\n        // Update the current hierarchy level to the one at which the resource was\n        // found. For example, if looking for \"choice_widget\", but only a resource\n        // is found for its parent \"form_widget\", then the level is updated here\n        // to the parent level.\n        $hierarchyLevel = $this->engine->getResourceHierarchyLevel($view, $blockNameHierarchy, $hierarchyLevel);\n\n        // The actually existing block name in $resource\n        $blockName = $blockNameHierarchy[$hierarchyLevel];\n\n        // Escape if no resource exists for this block\n        if (!$resource) {\n            if (\\count($blockNameHierarchy) !== \\count(array_unique($blockNameHierarchy))) {\n                throw new LogicException(\\sprintf('Unable to render the form because the block names array contains duplicates: \"%s\".', implode('\", \"', array_reverse($blockNameHierarchy))));\n            }\n\n            throw new LogicException(\\sprintf('Unable to render the form as none of the following blocks exist: \"%s\".', implode('\", \"', array_reverse($blockNameHierarchy))));\n        }\n\n        // Merge the passed with the existing attributes\n        if (isset($variables['attr']) && isset($scopeVariables['attr'])) {\n            $variables['attr'] = array_replace($scopeVariables['attr'], $variables['attr']);\n        }\n\n        // Merge the passed with the exist *label* attributes\n        if (isset($variables['label_attr']) && isset($scopeVariables['label_attr'])) {\n            $variables['label_attr'] = array_replace($scopeVariables['label_attr'], $variables['label_attr']);\n        }\n\n        // Do not use array_replace_recursive(), otherwise array variables\n        // cannot be overwritten\n        $variables = array_replace($scopeVariables, $variables);\n\n        // In order to make recursive calls possible, we need to store the block hierarchy,\n        // the current level of the hierarchy and the variables so that this method can\n        // resume rendering one level higher of the hierarchy when it is called recursively.\n        //\n        // We need to store these values in maps (associative arrays) because within a\n        // call to widget() another call to widget() can be made, but for a different view\n        // object. These nested calls should not override each other.\n        $this->blockNameHierarchyMap[$viewAndSuffixCacheKey] = $blockNameHierarchy;\n        $this->hierarchyLevelMap[$viewAndSuffixCacheKey] = $hierarchyLevel;\n\n        // We also need to store the variables for the view so that we can render other\n        // blocks for the same view using the same variables as in the outer block.\n        $this->variableStack[$viewCacheKey][] = $variables;\n\n        // Do the rendering\n        $html = $this->engine->renderBlock($view, $resource, $blockName, $variables);\n\n        // Clear the stack\n        array_pop($this->variableStack[$viewCacheKey]);\n\n        // Clear the caches if they were filled for the first time within\n        // this function call\n        if ($hierarchyInit) {\n            unset($this->blockNameHierarchyMap[$viewAndSuffixCacheKey], $this->hierarchyLevelMap[$viewAndSuffixCacheKey]);\n        }\n\n        if ($varInit) {\n            unset($this->variableStack[$viewCacheKey]);\n        }\n\n        if ($renderOnlyOnce) {\n            $view->setRendered();\n        }\n\n        return $html;\n    }\n\n    public function humanize(string $text): string\n    {\n        return ucfirst(strtolower(trim(preg_replace(['/([A-Z])/', '/[_\\s]+/'], ['_$1', ' '], $text))));\n    }\n\n    /**\n     * @internal\n     */\n    public function encodeCurrency(Environment $environment, string $text, string $widget = ''): string\n    {\n        if ('UTF-8' === $charset = $environment->getCharset()) {\n            $text = htmlspecialchars($text, \\ENT_QUOTES | \\ENT_SUBSTITUTE, 'UTF-8');\n        } else {\n            $text = htmlentities($text, \\ENT_QUOTES | \\ENT_SUBSTITUTE, 'UTF-8');\n            $text = iconv('UTF-8', $charset, $text);\n            $widget = iconv('UTF-8', $charset, $widget);\n        }\n\n        return str_replace('{{ widget }}', $widget, $text);\n    }\n}\n"
        },
        {
          "name": "FormRendererEngineInterface.php",
          "type": "blob",
          "size": 6.068359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * Adapter for rendering form templates with a specific templating engine.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface FormRendererEngineInterface\n{\n    /**\n     * Sets the theme(s) to be used for rendering a view and its children.\n     *\n     * @param FormView $view   The view to assign the theme(s) to\n     * @param mixed    $themes The theme(s). The type of these themes\n     *                         is open to the implementation.\n     */\n    public function setTheme(FormView $view, mixed $themes, bool $useDefaultThemes = true): void;\n\n    /**\n     * Returns the resource for a block name.\n     *\n     * The resource is first searched in the themes attached to $view, then\n     * in the themes of its parent view and so on, until a resource was found.\n     *\n     * The type of the resource is decided by the implementation. The resource\n     * is later passed to {@link renderBlock()} by the rendering algorithm.\n     *\n     * @param FormView $view The view for determining the used themes.\n     *                       First the themes attached directly to the\n     *                       view with {@link setTheme()} are considered,\n     *                       then the ones of its parent etc.\n     *\n     * @return mixed the renderer resource or false, if none was found\n     */\n    public function getResourceForBlockName(FormView $view, string $blockName): mixed;\n\n    /**\n     * Returns the resource for a block hierarchy.\n     *\n     * A block hierarchy is an array which starts with the root of the hierarchy\n     * and continues with the child of that root, the child of that child etc.\n     * The following is an example for a block hierarchy:\n     *\n     *     form_widget\n     *     text_widget\n     *     url_widget\n     *\n     * In this example, \"url_widget\" is the most specific block, while the other\n     * blocks are its ancestors in the hierarchy.\n     *\n     * The second parameter $hierarchyLevel determines the level of the hierarchy\n     * that should be rendered. For example, if $hierarchyLevel is 2 for the\n     * above hierarchy, the engine will first look for the block \"url_widget\",\n     * then, if that does not exist, for the block \"text_widget\" etc.\n     *\n     * The type of the resource is decided by the implementation. The resource\n     * is later passed to {@link renderBlock()} by the rendering algorithm.\n     *\n     * @param FormView $view               The view for determining the used themes.\n     *                                     First the themes  attached directly to\n     *                                     the view with {@link setTheme()} are\n     *                                     considered, then the ones of its parent etc.\n     * @param string[] $blockNameHierarchy The block name hierarchy, with the root block\n     *                                     at the beginning\n     * @param int      $hierarchyLevel     The level in the hierarchy at which to start\n     *                                     looking. Level 0 indicates the root block, i.e.\n     *                                     the first element of $blockNameHierarchy.\n     *\n     * @return mixed The renderer resource or false, if none was found\n     */\n    public function getResourceForBlockNameHierarchy(FormView $view, array $blockNameHierarchy, int $hierarchyLevel): mixed;\n\n    /**\n     * Returns the hierarchy level at which a resource can be found.\n     *\n     * A block hierarchy is an array which starts with the root of the hierarchy\n     * and continues with the child of that root, the child of that child etc.\n     * The following is an example for a block hierarchy:\n     *\n     *     form_widget\n     *     text_widget\n     *     url_widget\n     *\n     * The second parameter $hierarchyLevel determines the level of the hierarchy\n     * that should be rendered.\n     *\n     * If we call this method with the hierarchy level 2, the engine will first\n     * look for a resource for block \"url_widget\". If such a resource exists,\n     * the method returns 2. Otherwise it tries to find a resource for block\n     * \"text_widget\" (at level 1) and, again, returns 1 if a resource was found.\n     * The method continues to look for resources until the root level was\n     * reached and nothing was found. In this case false is returned.\n     *\n     * The type of the resource is decided by the implementation. The resource\n     * is later passed to {@link renderBlock()} by the rendering algorithm.\n     *\n     * @param FormView $view               The view for determining the used themes.\n     *                                     First the themes  attached directly to\n     *                                     the view with {@link setTheme()} are\n     *                                     considered, then the ones of its parent etc.\n     * @param string[] $blockNameHierarchy The block name hierarchy, with the root block\n     *                                     at the beginning\n     * @param int      $hierarchyLevel     The level in the hierarchy at which to start\n     *                                     looking. Level 0 indicates the root block, i.e.\n     *                                     the first element of $blockNameHierarchy.\n     */\n    public function getResourceHierarchyLevel(FormView $view, array $blockNameHierarchy, int $hierarchyLevel): int|false;\n\n    /**\n     * Renders a block in the given renderer resource.\n     *\n     * The resource can be obtained by calling {@link getResourceForBlock()}\n     * or {@link getResourceForBlockHierarchy()}. The type of the resource is\n     * decided by the implementation.\n     *\n     * @param FormView $view      The view to render\n     * @param mixed    $resource  The renderer resource\n     * @param array    $variables The variables to pass to the template\n     */\n    public function renderBlock(FormView $view, mixed $resource, string $blockName, array $variables = []): string;\n}\n"
        },
        {
          "name": "FormRendererInterface.php",
          "type": "blob",
          "size": 2.978515625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * Renders a form into HTML.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface FormRendererInterface\n{\n    /**\n     * Returns the engine used by this renderer.\n     */\n    public function getEngine(): FormRendererEngineInterface;\n\n    /**\n     * Sets the theme(s) to be used for rendering a view and its children.\n     *\n     * @param FormView $view             The view to assign the theme(s) to\n     * @param mixed    $themes           The theme(s). The type of these themes\n     *                                   is open to the implementation.\n     * @param bool     $useDefaultThemes If true, will use default themes specified\n     *                                   in the renderer\n     */\n    public function setTheme(FormView $view, mixed $themes, bool $useDefaultThemes = true): void;\n\n    /**\n     * Renders a named block of the form theme.\n     *\n     * @param FormView $view      The view for which to render the block\n     * @param array    $variables The variables to pass to the template\n     */\n    public function renderBlock(FormView $view, string $blockName, array $variables = []): string;\n\n    /**\n     * Searches and renders a block for a given name suffix.\n     *\n     * The block is searched by combining the block names stored in the\n     * form view with the given suffix. If a block name is found, that\n     * block is rendered.\n     *\n     * If this method is called recursively, the block search is continued\n     * where a block was found before.\n     *\n     * @param FormView $view      The view for which to render the block\n     * @param array    $variables The variables to pass to the template\n     */\n    public function searchAndRenderBlock(FormView $view, string $blockNameSuffix, array $variables = []): string;\n\n    /**\n     * Renders a CSRF token.\n     *\n     * Use this helper for CSRF protection without the overhead of creating a\n     * form.\n     *\n     *     <input type=\"hidden\" name=\"token\" value=\"<?php $renderer->renderCsrfToken('rm_user_'.$user->getId()) ?>\">\n     *\n     * Check the token in your action using the same token ID.\n     *\n     *     // $csrfProvider being an instance of Symfony\\Component\\Security\\Csrf\\TokenGenerator\\TokenGeneratorInterface\n     *     if (!$csrfProvider->isCsrfTokenValid('rm_user_'.$user->getId(), $token)) {\n     *         throw new \\RuntimeException('CSRF attack detected.');\n     *     }\n     */\n    public function renderCsrfToken(string $tokenId): string;\n\n    /**\n     * Makes a technical name human readable.\n     *\n     * Sequences of underscores are replaced by single spaces. The first letter\n     * of the resulting string is capitalized, while all other letters are\n     * turned to lowercase.\n     */\n    public function humanize(string $text): string;\n}\n"
        },
        {
          "name": "FormTypeExtensionInterface.php",
          "type": "blob",
          "size": 1.619140625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface FormTypeExtensionInterface\n{\n    /**\n     * Gets the extended types.\n     *\n     * @return string[]\n     */\n    public static function getExtendedTypes(): iterable;\n\n    public function configureOptions(OptionsResolver $resolver): void;\n\n    /**\n     * Builds the form.\n     *\n     * This method is called after the extended type has built the form to\n     * further modify it.\n     *\n     * @param array<string, mixed> $options\n     *\n     * @see FormTypeInterface::buildForm()\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options): void;\n\n    /**\n     * Builds the view.\n     *\n     * This method is called after the extended type has built the view to\n     * further modify it.\n     *\n     * @param array<string, mixed> $options\n     *\n     * @see FormTypeInterface::buildView()\n     */\n    public function buildView(FormView $view, FormInterface $form, array $options): void;\n\n    /**\n     * Finishes the view.\n     *\n     * This method is called after the extended type has finished the view to\n     * further modify it.\n     *\n     * @param array<string, mixed> $options\n     *\n     * @see FormTypeInterface::finishView()\n     */\n    public function finishView(FormView $view, FormInterface $form, array $options): void;\n}\n"
        },
        {
          "name": "FormTypeGuesserChain.php",
          "type": "blob",
          "size": 2.5546875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Exception\\UnexpectedTypeException;\nuse Symfony\\Component\\Form\\Guess\\Guess;\nuse Symfony\\Component\\Form\\Guess\\TypeGuess;\nuse Symfony\\Component\\Form\\Guess\\ValueGuess;\n\nclass FormTypeGuesserChain implements FormTypeGuesserInterface\n{\n    private array $guessers = [];\n\n    /**\n     * @param FormTypeGuesserInterface[] $guessers\n     *\n     * @throws UnexpectedTypeException if any guesser does not implement FormTypeGuesserInterface\n     */\n    public function __construct(iterable $guessers)\n    {\n        $tmpGuessers = [];\n        foreach ($guessers as $guesser) {\n            if (!$guesser instanceof FormTypeGuesserInterface) {\n                throw new UnexpectedTypeException($guesser, FormTypeGuesserInterface::class);\n            }\n\n            if ($guesser instanceof self) {\n                $tmpGuessers[] = $guesser->guessers;\n            } else {\n                $tmpGuessers[] = [$guesser];\n            }\n        }\n\n        $this->guessers = array_merge([], ...$tmpGuessers);\n    }\n\n    public function guessType(string $class, string $property): ?TypeGuess\n    {\n        return $this->guess(static fn ($guesser) => $guesser->guessType($class, $property));\n    }\n\n    public function guessRequired(string $class, string $property): ?ValueGuess\n    {\n        return $this->guess(static fn ($guesser) => $guesser->guessRequired($class, $property));\n    }\n\n    public function guessMaxLength(string $class, string $property): ?ValueGuess\n    {\n        return $this->guess(static fn ($guesser) => $guesser->guessMaxLength($class, $property));\n    }\n\n    public function guessPattern(string $class, string $property): ?ValueGuess\n    {\n        return $this->guess(static fn ($guesser) => $guesser->guessPattern($class, $property));\n    }\n\n    /**\n     * Executes a closure for each guesser and returns the best guess from the\n     * return values.\n     *\n     * @param \\Closure $closure The closure to execute. Accepts a guesser\n     *                          as argument and should return a Guess instance\n     */\n    private function guess(\\Closure $closure): ?Guess\n    {\n        $guesses = [];\n\n        foreach ($this->guessers as $guesser) {\n            if ($guess = $closure($guesser)) {\n                $guesses[] = $guess;\n            }\n        }\n\n        return Guess::getBestGuess($guesses);\n    }\n}\n"
        },
        {
          "name": "FormTypeGuesserInterface.php",
          "type": "blob",
          "size": 0.9912109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface FormTypeGuesserInterface\n{\n    /**\n     * Returns a field guess for a property name of a class.\n     */\n    public function guessType(string $class, string $property): ?Guess\\TypeGuess;\n\n    /**\n     * Returns a guess whether a property of a class is required.\n     */\n    public function guessRequired(string $class, string $property): ?Guess\\ValueGuess;\n\n    /**\n     * Returns a guess about the field's maximum length.\n     */\n    public function guessMaxLength(string $class, string $property): ?Guess\\ValueGuess;\n\n    /**\n     * Returns a guess about the field's pattern.\n     */\n    public function guessPattern(string $class, string $property): ?Guess\\ValueGuess;\n}\n"
        },
        {
          "name": "FormTypeInterface.php",
          "type": "blob",
          "size": 2.8896484375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface FormTypeInterface\n{\n    /**\n     * Returns the name of the parent type.\n     *\n     * The parent type and its extensions will configure the form with the\n     * following methods before the current implementation.\n     *\n     * @return string|null\n     */\n    public function getParent();\n\n    /**\n     * Configures the options for this type.\n     *\n     * @return void\n     */\n    public function configureOptions(OptionsResolver $resolver);\n\n    /**\n     * Builds the form.\n     *\n     * This method is called for each type in the hierarchy starting from the\n     * top most type. Type extensions can further modify the form.\n     *\n     * @param array<string, mixed> $options\n     *\n     * @return void\n     *\n     * @see FormTypeExtensionInterface::buildForm()\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options);\n\n    /**\n     * Builds the form view.\n     *\n     * This method is called for each type in the hierarchy starting from the\n     * top most type. Type extensions can further modify the view.\n     *\n     * A view of a form is built before the views of the child forms are built.\n     * This means that you cannot access child views in this method. If you need\n     * to do so, move your logic to {@link finishView()} instead.\n     *\n     * @param array<string, mixed> $options\n     *\n     * @return void\n     *\n     * @see FormTypeExtensionInterface::buildView()\n     */\n    public function buildView(FormView $view, FormInterface $form, array $options);\n\n    /**\n     * Finishes the form view.\n     *\n     * This method gets called for each type in the hierarchy starting from the\n     * top most type. Type extensions can further modify the view.\n     *\n     * When this method is called, views of the form's children have already\n     * been built and finished and can be accessed. You should only implement\n     * such logic in this method that actually accesses child views. For everything\n     * else you are recommended to implement {@link buildView()} instead.\n     *\n     * @param array<string, mixed> $options\n     *\n     * @return void\n     *\n     * @see FormTypeExtensionInterface::finishView()\n     */\n    public function finishView(FormView $view, FormInterface $form, array $options);\n\n    /**\n     * Returns the prefix of the template block name for this type.\n     *\n     * The block prefix defaults to the underscored short class name with\n     * the \"Type\" suffix removed (e.g. \"UserProfileType\" => \"user_profile\").\n     *\n     * @return string\n     */\n    public function getBlockPrefix();\n}\n"
        },
        {
          "name": "FormView.php",
          "type": "blob",
          "size": 3.4306640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Exception\\BadMethodCallException;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @implements \\ArrayAccess<int|string, FormView>\n * @implements \\IteratorAggregate<int|string, FormView>\n */\nclass FormView implements \\ArrayAccess, \\IteratorAggregate, \\Countable\n{\n    /**\n     * The variables assigned to this view.\n     */\n    public array $vars = [\n        'value' => null,\n        'attr' => [],\n    ];\n\n    /**\n     * The child views.\n     *\n     * @var array<int|string, FormView>\n     */\n    public array $children = [];\n\n    /**\n     * Is the form attached to this renderer rendered?\n     *\n     * Rendering happens when either the widget or the row method was called.\n     * Row implicitly includes widget, however certain rendering mechanisms\n     * have to skip widget rendering when a row is rendered.\n     */\n    private bool $rendered = false;\n\n    private bool $methodRendered = false;\n\n    /**\n     * @param FormView|null $parent The parent view\n     */\n    public function __construct(\n        public ?self $parent = null,\n    ) {\n    }\n\n    /**\n     * Returns whether the view was already rendered.\n     */\n    public function isRendered(): bool\n    {\n        if (true === $this->rendered || 0 === \\count($this->children)) {\n            return $this->rendered;\n        }\n\n        foreach ($this->children as $child) {\n            if (!$child->isRendered()) {\n                return false;\n            }\n        }\n\n        return $this->rendered = true;\n    }\n\n    /**\n     * Marks the view as rendered.\n     *\n     * @return $this\n     */\n    public function setRendered(): static\n    {\n        $this->rendered = true;\n\n        return $this;\n    }\n\n    public function isMethodRendered(): bool\n    {\n        return $this->methodRendered;\n    }\n\n    public function setMethodRendered(): void\n    {\n        $this->methodRendered = true;\n    }\n\n    /**\n     * Returns a child by name (implements \\ArrayAccess).\n     *\n     * @param int|string $name The child name\n     */\n    public function offsetGet(mixed $name): self\n    {\n        return $this->children[$name];\n    }\n\n    /**\n     * Returns whether the given child exists (implements \\ArrayAccess).\n     *\n     * @param int|string $name The child name\n     */\n    public function offsetExists(mixed $name): bool\n    {\n        return isset($this->children[$name]);\n    }\n\n    /**\n     * Implements \\ArrayAccess.\n     *\n     * @throws BadMethodCallException always as setting a child by name is not allowed\n     */\n    public function offsetSet(mixed $name, mixed $value): void\n    {\n        throw new BadMethodCallException('Not supported.');\n    }\n\n    /**\n     * Removes a child (implements \\ArrayAccess).\n     *\n     * @param int|string $name The child name\n     */\n    public function offsetUnset(mixed $name): void\n    {\n        unset($this->children[$name]);\n    }\n\n    /**\n     * Returns an iterator to iterate over children (implements \\IteratorAggregate).\n     *\n     * @return \\ArrayIterator<int|string, FormView>\n     */\n    public function getIterator(): \\ArrayIterator\n    {\n        return new \\ArrayIterator($this->children);\n    }\n\n    public function count(): int\n    {\n        return \\count($this->children);\n    }\n}\n"
        },
        {
          "name": "Forms.php",
          "type": "blob",
          "size": 2.7265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * Entry point of the Form component.\n *\n * Use this class to conveniently create new form factories:\n *\n *     use Symfony\\Component\\Form\\Forms;\n *\n *     $formFactory = Forms::createFormFactory();\n *\n *     $form = $formFactory->createBuilder()\n *         ->add('firstName', 'Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType')\n *         ->add('lastName', 'Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType')\n *         ->add('age', 'Symfony\\Component\\Form\\Extension\\Core\\Type\\IntegerType')\n *         ->add('color', 'Symfony\\Component\\Form\\Extension\\Core\\Type\\ChoiceType', [\n *             'choices' => ['Red' => 'r', 'Blue' => 'b'],\n *         ])\n *         ->getForm();\n *\n * You can also add custom extensions to the form factory:\n *\n *     $formFactory = Forms::createFormFactoryBuilder()\n *         ->addExtension(new AcmeExtension())\n *         ->getFormFactory();\n *\n * If you create custom form types or type extensions, it is\n * generally recommended to create your own extensions that lazily\n * load these types and type extensions. In projects where performance\n * does not matter that much, you can also pass them directly to the\n * form factory:\n *\n *     $formFactory = Forms::createFormFactoryBuilder()\n *         ->addType(new PersonType())\n *         ->addType(new PhoneNumberType())\n *         ->addTypeExtension(new FormTypeHelpTextExtension())\n *         ->getFormFactory();\n *\n * Support for the Validator component is provided by ValidatorExtension.\n * This extension needs a validator object to function properly:\n *\n *     use Symfony\\Component\\Validator\\Validation;\n *     use Symfony\\Component\\Form\\Extension\\Validator\\ValidatorExtension;\n *\n *     $validator = Validation::createValidator();\n *     $formFactory = Forms::createFormFactoryBuilder()\n *         ->addExtension(new ValidatorExtension($validator))\n *         ->getFormFactory();\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nfinal class Forms\n{\n    /**\n     * Creates a form factory with the default configuration.\n     */\n    public static function createFormFactory(): FormFactoryInterface\n    {\n        return self::createFormFactoryBuilder()->getFormFactory();\n    }\n\n    /**\n     * Creates a form factory builder with the default configuration.\n     */\n    public static function createFormFactoryBuilder(): FormFactoryBuilderInterface\n    {\n        return new FormFactoryBuilder(true);\n    }\n\n    /**\n     * This class cannot be instantiated.\n     */\n    private function __construct()\n    {\n    }\n}\n"
        },
        {
          "name": "Guess",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "NativeRequestHandler.php",
          "type": "blob",
          "size": 7.4091796875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Exception\\UnexpectedTypeException;\nuse Symfony\\Component\\Form\\Util\\FormUtil;\nuse Symfony\\Component\\Form\\Util\\ServerParams;\n\n/**\n * A request handler using PHP super globals $_GET, $_POST and $_SERVER.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass NativeRequestHandler implements RequestHandlerInterface\n{\n    private ServerParams $serverParams;\n\n    /**\n     * The allowed keys of the $_FILES array.\n     */\n    private const FILE_KEYS = [\n        'error',\n        'full_path',\n        'name',\n        'size',\n        'tmp_name',\n        'type',\n    ];\n\n    public function __construct(?ServerParams $params = null)\n    {\n        $this->serverParams = $params ?? new ServerParams();\n    }\n\n    /**\n     * @throws UnexpectedTypeException If the $request is not null\n     */\n    public function handleRequest(FormInterface $form, mixed $request = null): void\n    {\n        if (null !== $request) {\n            throw new UnexpectedTypeException($request, 'null');\n        }\n\n        $name = $form->getName();\n        $method = $form->getConfig()->getMethod();\n\n        if ($method !== self::getRequestMethod()) {\n            return;\n        }\n\n        // For request methods that must not have a request body we fetch data\n        // from the query string. Otherwise we look for data in the request body.\n        if ('GET' === $method || 'HEAD' === $method || 'TRACE' === $method) {\n            if ('' === $name) {\n                $data = $_GET;\n            } else {\n                // Don't submit GET requests if the form's name does not exist\n                // in the request\n                if (!isset($_GET[$name])) {\n                    return;\n                }\n\n                $data = $_GET[$name];\n            }\n        } else {\n            // Mark the form with an error if the uploaded size was too large\n            // This is done here and not in FormValidator because $_POST is\n            // empty when that error occurs. Hence the form is never submitted.\n            if ($this->serverParams->hasPostMaxSizeBeenExceeded()) {\n                // Submit the form, but don't clear the default values\n                $form->submit(null, false);\n\n                $form->addError(new FormError(\n                    $form->getConfig()->getOption('upload_max_size_message')(),\n                    null,\n                    ['{{ max }}' => $this->serverParams->getNormalizedIniPostMaxSize()]\n                ));\n\n                return;\n            }\n\n            $fixedFiles = [];\n            foreach ($_FILES as $fileKey => $file) {\n                $fixedFiles[$fileKey] = self::stripEmptyFiles(self::fixPhpFilesArray($file));\n            }\n\n            if ('' === $name) {\n                $params = $_POST;\n                $files = $fixedFiles;\n            } elseif (\\array_key_exists($name, $_POST) || \\array_key_exists($name, $fixedFiles)) {\n                $default = $form->getConfig()->getCompound() ? [] : null;\n                $params = \\array_key_exists($name, $_POST) ? $_POST[$name] : $default;\n                $files = \\array_key_exists($name, $fixedFiles) ? $fixedFiles[$name] : $default;\n            } else {\n                // Don't submit the form if it is not present in the request\n                return;\n            }\n\n            if (\\is_array($params) && \\is_array($files)) {\n                $data = FormUtil::mergeParamsAndFiles($params, $files);\n            } else {\n                $data = $params ?: $files;\n            }\n        }\n\n        // Don't auto-submit the form unless at least one field is present.\n        if ('' === $name && \\count(array_intersect_key($data, $form->all())) <= 0) {\n            return;\n        }\n\n        if (\\is_array($data) && \\array_key_exists('_method', $data) && $method === $data['_method'] && !$form->has('_method')) {\n            unset($data['_method']);\n        }\n\n        $form->submit($data, 'PATCH' !== $method);\n    }\n\n    public function isFileUpload(mixed $data): bool\n    {\n        // POST data will always be strings or arrays of strings. Thus, we can be sure\n        // that the submitted data is a file upload if the \"error\" value is an integer\n        // (this value must have been injected by PHP itself).\n        return \\is_array($data) && isset($data['error']) && \\is_int($data['error']);\n    }\n\n    public function getUploadFileError(mixed $data): ?int\n    {\n        if (!\\is_array($data)) {\n            return null;\n        }\n\n        if (!isset($data['error'])) {\n            return null;\n        }\n\n        if (!\\is_int($data['error'])) {\n            return null;\n        }\n\n        if (\\UPLOAD_ERR_OK === $data['error']) {\n            return null;\n        }\n\n        return $data['error'];\n    }\n\n    private static function getRequestMethod(): string\n    {\n        $method = isset($_SERVER['REQUEST_METHOD'])\n            ? strtoupper($_SERVER['REQUEST_METHOD'])\n            : 'GET';\n\n        if ('POST' === $method && isset($_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE'])) {\n            $method = strtoupper($_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE']);\n        }\n\n        return $method;\n    }\n\n    /**\n     * Fixes a malformed PHP $_FILES array.\n     *\n     * PHP has a bug that the format of the $_FILES array differs, depending on\n     * whether the uploaded file fields had normal field names or array-like\n     * field names (\"normal\" vs. \"parent[child]\").\n     *\n     * This method fixes the array to look like the \"normal\" $_FILES array.\n     *\n     * It's safe to pass an already converted array, in which case this method\n     * just returns the original array unmodified.\n     *\n     * This method is identical to {@link \\Symfony\\Component\\HttpFoundation\\FileBag::fixPhpFilesArray}\n     * and should be kept as such in order to port fixes quickly and easily.\n     */\n    private static function fixPhpFilesArray(mixed $data): mixed\n    {\n        if (!\\is_array($data)) {\n            return $data;\n        }\n\n        $keys = array_keys($data + ['full_path' => null]);\n        sort($keys);\n\n        if (self::FILE_KEYS !== $keys || !isset($data['name']) || !\\is_array($data['name'])) {\n            return $data;\n        }\n\n        $files = $data;\n        foreach (self::FILE_KEYS as $k) {\n            unset($files[$k]);\n        }\n\n        foreach ($data['name'] as $key => $name) {\n            $files[$key] = self::fixPhpFilesArray([\n                'error' => $data['error'][$key],\n                'name' => $name,\n                'type' => $data['type'][$key],\n                'tmp_name' => $data['tmp_name'][$key],\n                'size' => $data['size'][$key],\n            ] + (isset($data['full_path'][$key]) ? [\n                'full_path' => $data['full_path'][$key],\n            ] : []));\n        }\n\n        return $files;\n    }\n\n    private static function stripEmptyFiles(mixed $data): mixed\n    {\n        if (!\\is_array($data)) {\n            return $data;\n        }\n\n        $keys = array_keys($data + ['full_path' => null]);\n        sort($keys);\n\n        if (self::FILE_KEYS === $keys) {\n            if (\\UPLOAD_ERR_NO_FILE === $data['error']) {\n                return null;\n            }\n\n            return $data;\n        }\n\n        foreach ($data as $key => $value) {\n            $data[$key] = self::stripEmptyFiles($value);\n        }\n\n        return $data;\n    }\n}\n"
        },
        {
          "name": "PreloadedExtension.php",
          "type": "blob",
          "size": 1.833984375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\Form\\Exception\\InvalidArgumentException;\n\n/**\n * A form extension with preloaded types, type extensions and type guessers.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass PreloadedExtension implements FormExtensionInterface\n{\n    private array $types = [];\n\n    /**\n     * Creates a new preloaded extension.\n     *\n     * @param FormTypeInterface[]            $types          The types that the extension should support\n     * @param FormTypeExtensionInterface[][] $typeExtensions The type extensions that the extension should support\n     */\n    public function __construct(\n        array $types,\n        private array $typeExtensions,\n        private ?FormTypeGuesserInterface $typeGuesser = null,\n    ) {\n        foreach ($types as $type) {\n            $this->types[$type::class] = $type;\n        }\n    }\n\n    public function getType(string $name): FormTypeInterface\n    {\n        if (!isset($this->types[$name])) {\n            throw new InvalidArgumentException(\\sprintf('The type \"%s\" cannot be loaded by this extension.', $name));\n        }\n\n        return $this->types[$name];\n    }\n\n    public function hasType(string $name): bool\n    {\n        return isset($this->types[$name]);\n    }\n\n    public function getTypeExtensions(string $name): array\n    {\n        return $this->typeExtensions[$name]\n            ?? [];\n    }\n\n    public function hasTypeExtensions(string $name): bool\n    {\n        return !empty($this->typeExtensions[$name]);\n    }\n\n    public function getTypeGuesser(): ?FormTypeGuesserInterface\n    {\n        return $this->typeGuesser;\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.4716796875,
          "content": "Form Component\n==============\n\nThe Form component allows you to easily create, process and reuse HTML forms.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/form.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "RequestHandlerInterface.php",
          "type": "blob",
          "size": 0.66796875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * Submits forms if they were submitted.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface RequestHandlerInterface\n{\n    /**\n     * Submits a form if it was submitted.\n     */\n    public function handleRequest(FormInterface $form, mixed $request = null): void;\n\n    /**\n     * Returns true if the given data is a file upload.\n     */\n    public function isFileUpload(mixed $data): bool;\n}\n"
        },
        {
          "name": "ResolvedFormType.php",
          "type": "blob",
          "size": 5.1201171875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\EventDispatcher\\EventDispatcher;\nuse Symfony\\Component\\Form\\Exception\\UnexpectedTypeException;\nuse Symfony\\Component\\OptionsResolver\\Exception\\ExceptionInterface;\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\n/**\n * A wrapper for a form type and its extensions.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass ResolvedFormType implements ResolvedFormTypeInterface\n{\n    /**\n     * @var FormTypeExtensionInterface[]\n     */\n    private array $typeExtensions;\n\n    private OptionsResolver $optionsResolver;\n\n    /**\n     * @param FormTypeExtensionInterface[] $typeExtensions\n     */\n    public function __construct(\n        private FormTypeInterface $innerType,\n        array $typeExtensions = [],\n        private ?ResolvedFormTypeInterface $parent = null,\n    ) {\n        foreach ($typeExtensions as $extension) {\n            if (!$extension instanceof FormTypeExtensionInterface) {\n                throw new UnexpectedTypeException($extension, FormTypeExtensionInterface::class);\n            }\n        }\n\n        $this->typeExtensions = $typeExtensions;\n    }\n\n    public function getBlockPrefix(): string\n    {\n        return $this->innerType->getBlockPrefix();\n    }\n\n    public function getParent(): ?ResolvedFormTypeInterface\n    {\n        return $this->parent;\n    }\n\n    public function getInnerType(): FormTypeInterface\n    {\n        return $this->innerType;\n    }\n\n    public function getTypeExtensions(): array\n    {\n        return $this->typeExtensions;\n    }\n\n    public function createBuilder(FormFactoryInterface $factory, string $name, array $options = []): FormBuilderInterface\n    {\n        try {\n            $options = $this->getOptionsResolver()->resolve($options);\n        } catch (ExceptionInterface $e) {\n            throw new $e(\\sprintf('An error has occurred resolving the options of the form \"%s\": ', get_debug_type($this->getInnerType())).$e->getMessage(), $e->getCode(), $e);\n        }\n\n        // Should be decoupled from the specific option at some point\n        $dataClass = $options['data_class'] ?? null;\n\n        $builder = $this->newBuilder($name, $dataClass, $factory, $options);\n        $builder->setType($this);\n\n        return $builder;\n    }\n\n    public function createView(FormInterface $form, ?FormView $parent = null): FormView\n    {\n        return $this->newView($parent);\n    }\n\n    public function buildForm(FormBuilderInterface $builder, array $options): void\n    {\n        $this->parent?->buildForm($builder, $options);\n\n        $this->innerType->buildForm($builder, $options);\n\n        foreach ($this->typeExtensions as $extension) {\n            $extension->buildForm($builder, $options);\n        }\n    }\n\n    public function buildView(FormView $view, FormInterface $form, array $options): void\n    {\n        $this->parent?->buildView($view, $form, $options);\n\n        $this->innerType->buildView($view, $form, $options);\n\n        foreach ($this->typeExtensions as $extension) {\n            $extension->buildView($view, $form, $options);\n        }\n    }\n\n    public function finishView(FormView $view, FormInterface $form, array $options): void\n    {\n        $this->parent?->finishView($view, $form, $options);\n\n        $this->innerType->finishView($view, $form, $options);\n\n        foreach ($this->typeExtensions as $extension) {\n            /* @var FormTypeExtensionInterface $extension */\n            $extension->finishView($view, $form, $options);\n        }\n    }\n\n    public function getOptionsResolver(): OptionsResolver\n    {\n        if (!isset($this->optionsResolver)) {\n            if (null !== $this->parent) {\n                $this->optionsResolver = clone $this->parent->getOptionsResolver();\n            } else {\n                $this->optionsResolver = new OptionsResolver();\n            }\n\n            $this->innerType->configureOptions($this->optionsResolver);\n\n            foreach ($this->typeExtensions as $extension) {\n                $extension->configureOptions($this->optionsResolver);\n            }\n        }\n\n        return $this->optionsResolver;\n    }\n\n    /**\n     * Creates a new builder instance.\n     *\n     * Override this method if you want to customize the builder class.\n     */\n    protected function newBuilder(string $name, ?string $dataClass, FormFactoryInterface $factory, array $options): FormBuilderInterface\n    {\n        if ($this->innerType instanceof ButtonTypeInterface) {\n            return new ButtonBuilder($name, $options);\n        }\n\n        if ($this->innerType instanceof SubmitButtonTypeInterface) {\n            return new SubmitButtonBuilder($name, $options);\n        }\n\n        return new FormBuilder($name, $dataClass, new EventDispatcher(), $factory, $options);\n    }\n\n    /**\n     * Creates a new view instance.\n     *\n     * Override this method if you want to customize the view class.\n     */\n    protected function newView(?FormView $parent = null): FormView\n    {\n        return new FormView($parent);\n    }\n}\n"
        },
        {
          "name": "ResolvedFormTypeFactory.php",
          "type": "blob",
          "size": 0.6337890625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass ResolvedFormTypeFactory implements ResolvedFormTypeFactoryInterface\n{\n    public function createResolvedType(FormTypeInterface $type, array $typeExtensions, ?ResolvedFormTypeInterface $parent = null): ResolvedFormTypeInterface\n    {\n        return new ResolvedFormType($type, $typeExtensions, $parent);\n    }\n}\n"
        },
        {
          "name": "ResolvedFormTypeFactoryInterface.php",
          "type": "blob",
          "size": 1.1474609375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * Creates ResolvedFormTypeInterface instances.\n *\n * This interface allows you to use your custom ResolvedFormTypeInterface\n * implementation, within which you can customize the concrete FormBuilderInterface\n * implementations or FormView subclasses that are used by the framework.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface ResolvedFormTypeFactoryInterface\n{\n    /**\n     * Resolves a form type.\n     *\n     * @param FormTypeExtensionInterface[] $typeExtensions\n     *\n     * @throws Exception\\UnexpectedTypeException  if the types parent {@link FormTypeInterface::getParent()} is not a string\n     * @throws Exception\\InvalidArgumentException if the types parent cannot be retrieved from any extension\n     */\n    public function createResolvedType(FormTypeInterface $type, array $typeExtensions, ?ResolvedFormTypeInterface $parent = null): ResolvedFormTypeInterface;\n}\n"
        },
        {
          "name": "ResolvedFormTypeInterface.php",
          "type": "blob",
          "size": 2.107421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\n/**\n * A wrapper for a form type and its extensions.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface ResolvedFormTypeInterface\n{\n    /**\n     * Returns the prefix of the template block name for this type.\n     */\n    public function getBlockPrefix(): string;\n\n    /**\n     * Returns the parent type.\n     */\n    public function getParent(): ?self;\n\n    /**\n     * Returns the wrapped form type.\n     */\n    public function getInnerType(): FormTypeInterface;\n\n    /**\n     * Returns the extensions of the wrapped form type.\n     *\n     * @return FormTypeExtensionInterface[]\n     */\n    public function getTypeExtensions(): array;\n\n    /**\n     * Creates a new form builder for this type.\n     *\n     * @param string $name The name for the builder\n     */\n    public function createBuilder(FormFactoryInterface $factory, string $name, array $options = []): FormBuilderInterface;\n\n    /**\n     * Creates a new form view for a form of this type.\n     */\n    public function createView(FormInterface $form, ?FormView $parent = null): FormView;\n\n    /**\n     * Configures a form builder for the type hierarchy.\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options): void;\n\n    /**\n     * Configures a form view for the type hierarchy.\n     *\n     * It is called before the children of the view are built.\n     */\n    public function buildView(FormView $view, FormInterface $form, array $options): void;\n\n    /**\n     * Finishes a form view for the type hierarchy.\n     *\n     * It is called after the children of the view have been built.\n     */\n    public function finishView(FormView $view, FormInterface $form, array $options): void;\n\n    /**\n     * Returns the configured options resolver used for this type.\n     */\n    public function getOptionsResolver(): OptionsResolver;\n}\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "ReversedTransformer.php",
          "type": "blob",
          "size": 0.9111328125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * Reverses a transformer.\n *\n * When the transform() method is called, the reversed transformer's\n * reverseTransform() method is called and vice versa.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass ReversedTransformer implements DataTransformerInterface\n{\n    public function __construct(\n        protected DataTransformerInterface $reversedTransformer,\n    ) {\n    }\n\n    public function transform(mixed $value): mixed\n    {\n        return $this->reversedTransformer->reverseTransform($value);\n    }\n\n    public function reverseTransform(mixed $value): mixed\n    {\n        return $this->reversedTransformer->transform($value);\n    }\n}\n"
        },
        {
          "name": "SubmitButton.php",
          "type": "blob",
          "size": 1.06640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * A button that submits the form.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass SubmitButton extends Button implements ClickableInterface\n{\n    private bool $clicked = false;\n\n    public function isClicked(): bool\n    {\n        return $this->clicked;\n    }\n\n    /**\n     * Submits data to the button.\n     *\n     * @return $this\n     *\n     * @throws Exception\\AlreadySubmittedException if the form has already been submitted\n     */\n    public function submit(array|string|null $submittedData, bool $clearMissing = true): static\n    {\n        if ($this->getConfig()->getDisabled()) {\n            $this->clicked = false;\n\n            return $this;\n        }\n\n        parent::submit($submittedData, $clearMissing);\n\n        $this->clicked = null !== $submittedData;\n\n        return $this;\n    }\n}\n"
        },
        {
          "name": "SubmitButtonBuilder.php",
          "type": "blob",
          "size": 0.578125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * A builder for {@link SubmitButton} instances.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass SubmitButtonBuilder extends ButtonBuilder\n{\n    /**\n     * Creates the button.\n     */\n    public function getForm(): SubmitButton\n    {\n        return new SubmitButton($this->getFormConfig());\n    }\n}\n"
        },
        {
          "name": "SubmitButtonTypeInterface.php",
          "type": "blob",
          "size": 0.462890625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Form;\n\n/**\n * A type that should be converted into a {@link SubmitButton} instance.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface SubmitButtonTypeInterface extends FormTypeInterface\n{\n}\n"
        },
        {
          "name": "Test",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "Util",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 2.12109375,
          "content": "{\n    \"name\": \"symfony/form\",\n    \"type\": \"library\",\n    \"description\": \"Allows to easily create, process and reuse HTML forms\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3\",\n        \"symfony/event-dispatcher\": \"^6.4|^7.0\",\n        \"symfony/options-resolver\": \"^6.4|^7.0\",\n        \"symfony/polyfill-ctype\": \"~1.8\",\n        \"symfony/polyfill-intl-icu\": \"^1.21\",\n        \"symfony/polyfill-mbstring\": \"~1.0\",\n        \"symfony/property-access\": \"^6.4|^7.0\",\n        \"symfony/service-contracts\": \"^2.5|^3\"\n    },\n    \"require-dev\": {\n        \"doctrine/collections\": \"^1.0|^2.0\",\n        \"symfony/validator\": \"^6.4|^7.0\",\n        \"symfony/dependency-injection\": \"^6.4|^7.0\",\n        \"symfony/expression-language\": \"^6.4|^7.0\",\n        \"symfony/config\": \"^6.4|^7.0\",\n        \"symfony/console\": \"^6.4|^7.0\",\n        \"symfony/html-sanitizer\": \"^6.4|^7.0\",\n        \"symfony/http-foundation\": \"^6.4|^7.0\",\n        \"symfony/http-kernel\": \"^6.4|^7.0\",\n        \"symfony/intl\": \"^6.4|^7.0\",\n        \"symfony/security-core\": \"^6.4|^7.0\",\n        \"symfony/security-csrf\": \"^6.4|^7.0\",\n        \"symfony/translation\": \"^6.4.3|^7.0.3\",\n        \"symfony/var-dumper\": \"^6.4|^7.0\",\n        \"symfony/uid\": \"^6.4|^7.0\"\n    },\n    \"conflict\": {\n        \"symfony/console\": \"<6.4\",\n        \"symfony/dependency-injection\": \"<6.4\",\n        \"symfony/doctrine-bridge\": \"<6.4\",\n        \"symfony/error-handler\": \"<6.4\",\n        \"symfony/framework-bundle\": \"<6.4\",\n        \"symfony/http-kernel\": \"<6.4\",\n        \"symfony/translation\": \"<6.4.3|>=7.0,<7.0.3\",\n        \"symfony/translation-contracts\": \"<2.5\",\n        \"symfony/twig-bridge\": \"<6.4\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Form\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.841796875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Form Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Resources</directory>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}