{
  "metadata": {
    "timestamp": 1736711793588,
    "page": 64,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/dependency-injection",
      "stars": 4120,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "Alias.php",
          "type": "blob",
          "size": 2.828125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Symfony\\Component\\DependencyInjection\\Exception\\InvalidArgumentException;\n\nclass Alias\n{\n    private const DEFAULT_DEPRECATION_TEMPLATE = 'The \"%alias_id%\" service alias is deprecated. You should stop using it, as it will be removed in the future.';\n\n    private array $deprecation = [];\n\n    public function __construct(\n        private string $id,\n        private bool $public = false,\n    ) {\n    }\n\n    /**\n     * Checks if this DI Alias should be public or not.\n     */\n    public function isPublic(): bool\n    {\n        return $this->public;\n    }\n\n    /**\n     * Sets if this Alias is public.\n     *\n     * @return $this\n     */\n    public function setPublic(bool $boolean): static\n    {\n        $this->public = $boolean;\n\n        return $this;\n    }\n\n    /**\n     * Whether this alias is private.\n     */\n    public function isPrivate(): bool\n    {\n        return !$this->public;\n    }\n\n    /**\n     * Whether this alias is deprecated, that means it should not be referenced\n     * anymore.\n     *\n     * @param string $package The name of the composer package that is triggering the deprecation\n     * @param string $version The version of the package that introduced the deprecation\n     * @param string $message The deprecation message to use\n     *\n     * @return $this\n     *\n     * @throws InvalidArgumentException when the message template is invalid\n     */\n    public function setDeprecated(string $package, string $version, string $message): static\n    {\n        if ('' !== $message) {\n            if (preg_match('#[\\r\\n]|\\*/#', $message)) {\n                throw new InvalidArgumentException('Invalid characters found in deprecation template.');\n            }\n\n            if (!str_contains($message, '%alias_id%')) {\n                throw new InvalidArgumentException('The deprecation template must contain the \"%alias_id%\" placeholder.');\n            }\n        }\n\n        $this->deprecation = ['package' => $package, 'version' => $version, 'message' => $message ?: self::DEFAULT_DEPRECATION_TEMPLATE];\n\n        return $this;\n    }\n\n    public function isDeprecated(): bool\n    {\n        return (bool) $this->deprecation;\n    }\n\n    /**\n     * @param string $id Service id relying on this definition\n     */\n    public function getDeprecation(string $id): array\n    {\n        return [\n            'package' => $this->deprecation['package'],\n            'version' => $this->deprecation['version'],\n            'message' => str_replace('%alias_id%', $id, $this->deprecation['message']),\n        ];\n    }\n\n    public function __toString(): string\n    {\n        return $this->id;\n    }\n}\n"
        },
        {
          "name": "Argument",
          "type": "tree",
          "content": null
        },
        {
          "name": "Attribute",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 20.783203125,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Deprecate `!tagged` tag, use `!tagged_iterator` instead\n * Add a `ContainerBuilder::registerChild()` shortcut method for registering child definitions\n * Add support for `key-type` in `XmlFileLoader`\n * Enable non-empty parameters with `ParameterBag::cannotBeEmpty()` and `ContainerBuilder::parameterCannotBeEmpty()` methods\n * Resolve parameters found in index attribute of service tags\n\n7.1\n---\n\n * Add `CheckAliasValidityPass` to check service compatibility with aliased interface\n * Add argument `$prepend` to `ContainerConfigurator::extension()` to prepend the configuration instead of appending it\n * Have `ServiceLocator` implement `ServiceCollectionInterface`\n * Add `#[Lazy]` attribute as shortcut for `#[Autowire(lazy: [bool|string])]` and `#[Autoconfigure(lazy: [bool|string])]`\n * Add `#[AutowireMethodOf]` attribute to autowire a method of a service as a callable\n * Make `ContainerBuilder::registerAttributeForAutoconfiguration()` propagate to attribute classes that extend the registered class\n * Add argument `$prepend` to `FileLoader::construct()` to prepend loaded configuration instead of appending it\n * [BC BREAK] When used in the `prependExtension()` method, the `ContainerConfigurator::import()` method now prepends the configuration instead of appending it\n * Cast env vars to null or bool when referencing them using `#[Autowire(env: '...')]` depending on the signature of the corresponding parameter\n * Add `#[AutowireInline]` attribute to allow service definition at the class level\n * Add `StaticEnvVarLoader`\n\n7.0\n---\n\n * Remove `#[MapDecorated]`, use `#[AutowireDecorated]` instead\n * Remove `ProxyHelper`, use `Symfony\\Component\\VarExporter\\ProxyHelper` instead\n * Remove `ReferenceSetArgumentTrait`\n * Remove support of `@required` annotation, use the `Symfony\\Contracts\\Service\\Attribute\\Required` attribute instead\n * Require explicit argument when calling `ContainerAwareTrait::setContainer()`\n * Remove `PhpDumper` options `inline_factories_parameter` and `inline_class_loader_parameter`, use options `inline_factories` and `inline_class_loader` instead\n * Parameter names of `ParameterBag` cannot be numerics\n * Remove `ContainerAwareInterface` and `ContainerAwareTrait`, use dependency injection instead\n * Add argument `$id` and `$asGhostObject` to `DumperInterface::isProxyCandidate()` and `getProxyCode()`\n * Add argument `$source` to `FileLoader::registerClasses()`\n\n6.4\n---\n\n * Allow using `#[Target]` with no arguments to state that a parameter must match a named autowiring alias\n * Deprecate `ContainerAwareInterface` and `ContainerAwareTrait`, use dependency injection instead\n * Add `defined` env var processor that returns `true` for defined and neither null nor empty env vars\n * Add `#[AutowireLocator]` and `#[AutowireIterator]` attributes\n * Add `urlencode` env var processor that url encodes a string value\n\n6.3\n---\n\n * Add options `inline_factories` and `inline_class_loader` to `PhpDumper::dump()`\n * Deprecate `PhpDumper` options `inline_factories_parameter` and `inline_class_loader_parameter`\n * Add `RemoveBuildParametersPass`, which removes parameters starting with a dot during compilation\n * Add support for nesting autowiring-related attributes into `#[Autowire(...)]`\n * Deprecate undefined and numeric keys with `service_locator` config\n * Fail if Target attribute does not exist during compilation\n * Enable deprecating parameters with `ContainerBuilder::deprecateParameter()`\n * Add `#[AsAlias]` attribute to tell under which alias a service should be registered or to use the implemented interface if no parameter is given\n * Allow to trim XML service parameters value by using `trim=\"true\"` attribute\n * Allow extending the `Autowire` attribute\n * Add `#[Exclude]` to skip autoregistering a class\n * Add support for generating lazy closures\n * Add support for autowiring services as closures using `#[AutowireCallable]` or `#[AutowireServiceClosure]`\n * Add support for `#[Autowire(lazy: true|class-string)]`\n * Make it possible to cast callables into single-method interfaces\n * Deprecate `#[MapDecorated]`, use `#[AutowireDecorated]` instead\n * Deprecate the `@required` annotation, use the `Symfony\\Contracts\\Service\\Attribute\\Required` attribute instead\n * Add `constructor` option to services declaration and to `#[Autoconfigure]`\n\n6.2\n---\n\n * Use lazy-loading ghost objects and virtual proxies out of the box\n * Add arguments `&$asGhostObject` and `$id` to LazyProxy's `DumperInterface` to allow using ghost objects for lazy loading services\n * Add `enum` env var processor\n * Add `shuffle` env var processor\n * Allow #[When] to be extended\n * Change the signature of `ContainerAwareInterface::setContainer()` to `setContainer(?ContainerInterface)`\n * Deprecate calling `ContainerAwareTrait::setContainer()` without arguments\n * Deprecate using numeric parameter names\n * Add support for tagged iterators/locators `exclude` option to the xml and yaml loaders/dumpers\n * Allow injecting `string $env` into php config closures\n * Add `excludeSelf` parameter to `TaggedIteratorArgument` with default value to `true`\n   to control whether the referencing service should be automatically excluded from the iterator\n\n6.1\n---\n\n * Add `#[MapDecorated]` attribute telling to which parameter the decorated service should be mapped in a decorator\n * Add `#[AsDecorator]` attribute to make a service decorates another\n * Add `$exclude` to `TaggedIterator` and `TaggedLocator` attributes\n * Add `$exclude` to `tagged_iterator` and `tagged_locator` configurator\n * Add an `env` function to the expression language provider\n * Add an `Autowire` attribute to tell a parameter how to be autowired\n * Allow using expressions as service factories\n * Add argument type `closure` to help passing closures to services\n * Deprecate `ReferenceSetArgumentTrait`\n * Add `AbstractExtension` class for DI configuration/definition on a single file\n\n6.0\n---\n\n * Remove `Definition::setPrivate()` and `Alias::setPrivate()`, use `setPublic()` instead\n * Remove `inline()` in favor of `inline_service()` and `ref()` in favor of `service()` when using the PHP-DSL\n * Remove `Definition::getDeprecationMessage()`, use `Definition::getDeprecation()` instead\n * Remove `Alias::getDeprecationMessage()`, use `Alias::getDeprecation()` instead\n * Remove the `Psr\\Container\\ContainerInterface` and `Symfony\\Component\\DependencyInjection\\ContainerInterface` aliases of the `service_container` service\n\n5.4\n---\n * Add `$defaultIndexMethod` and `$defaultPriorityMethod` to `TaggedIterator` and `TaggedLocator` attributes\n * Add `service_closure()` to the PHP-DSL\n * Add support for autoconfigurable attributes on methods, properties and parameters\n * Make auto-aliases private by default\n * Add support for autowiring union and intersection types\n\n5.3\n---\n\n * Add `ServicesConfigurator::remove()` in the PHP-DSL\n * Add `%env(not:...)%` processor to negate boolean values\n * Add support for loading autoconfiguration rules via the `#[Autoconfigure]` and `#[AutoconfigureTag]` attributes on PHP 8\n * Add `#[AsTaggedItem]` attribute for defining the index and priority of classes found in tagged iterators/locators\n * Add autoconfigurable attributes\n * Add support for autowiring tagged iterators and locators via attributes on PHP 8\n * Add support for per-env configuration in XML and Yaml loaders\n * Add `ContainerBuilder::willBeAvailable()` to help with conditional configuration\n * Add support an integer return value for default_index_method\n * Add `#[When(env: 'foo')]` to skip autoregistering a class when the env doesn't match\n * Add `env()` and `EnvConfigurator` in the PHP-DSL\n * Add support for `ConfigBuilder` in the `PhpFileLoader`\n * Add `ContainerConfigurator::env()` to get the current environment\n * Add `#[Target]` to tell how a dependency is used and hint named autowiring aliases\n\n5.2.0\n-----\n\n * added `param()` and `abstract_arg()` in the PHP-DSL\n * deprecated `Definition::setPrivate()` and `Alias::setPrivate()`, use `setPublic()` instead\n * added support for the `#[Required]` attribute\n\n5.1.0\n-----\n\n * deprecated `inline()` in favor of `inline_service()` and `ref()` in favor of `service()` when using the PHP-DSL\n * allow decorators to reference their decorated service using the special `.inner` id\n * added support to autowire public typed properties in php 7.4\n * added support for defining method calls, a configurator, and property setters in `InlineServiceConfigurator`\n * added possibility to define abstract service arguments\n * allowed mixing \"parent\" and instanceof-conditionals/defaults/bindings\n * updated the signature of method `Definition::setDeprecated()` to `Definition::setDeprecation(string $package, string $version, string $message)`\n * updated the signature of method `Alias::setDeprecated()` to `Alias::setDeprecation(string $package, string $version, string $message)`\n * updated the signature of method `DeprecateTrait::deprecate()` to `DeprecateTrait::deprecation(string $package, string $version, string $message)`\n * deprecated the `Psr\\Container\\ContainerInterface` and `Symfony\\Component\\DependencyInjection\\ContainerInterface` aliases of the `service_container` service,\n   configure them explicitly instead\n * added class `Symfony\\Component\\DependencyInjection\\Dumper\\Preloader` to help with preloading on PHP 7.4+\n * added tags `container.preload`/`.no_preload` to declare extra classes to preload/services to not preload\n * allowed loading and dumping tags with an attribute named \"name\"\n * deprecated `Definition::getDeprecationMessage()`, use `Definition::getDeprecation()` instead\n * deprecated `Alias::getDeprecationMessage()`, use `Alias::getDeprecation()` instead\n * added support of PHP8 static return type for withers\n * added `AliasDeprecatedPublicServicesPass` to deprecate public services to private\n\n5.0.0\n-----\n\n * removed support for auto-discovered extension configuration class which does not implement `ConfigurationInterface`\n * removed support for non-string default env() parameters\n * moved `ServiceSubscriberInterface` to the `Symfony\\Contracts\\Service` namespace\n * removed `RepeatedPass` and `RepeatablePassInterface`\n * removed support for short factory/configurator syntax from `YamlFileLoader`\n * removed `ResettableContainerInterface`, use `ResetInterface` instead\n * added argument `$returnsClone` to `Definition::addMethodCall()`\n * removed `tagged`, use `tagged_iterator` instead\n\n4.4.0\n-----\n\n * added `CheckTypeDeclarationsPass` to check injected parameters type during compilation\n * added support for opcache.preload by generating a preloading script in the cache folder\n * added support for dumping the container in one file instead of many files\n * deprecated support for short factories and short configurators in Yaml\n * added `tagged_iterator` alias for `tagged` which might be deprecated in a future version\n * deprecated passing an instance of `Symfony\\Component\\DependencyInjection\\Parameter` as class name to `Symfony\\Component\\DependencyInjection\\Definition`\n * added support for binding iterable and tagged services\n * made singly-implemented interfaces detection be scoped by file\n * added ability to define a static priority method for tagged service\n * added support for improved syntax to define method calls in Yaml\n * made the `%env(base64:...)%` processor able to decode base64url\n * added ability to choose behavior of decorations on non existent decorated services\n\n4.3.0\n-----\n\n * added `%env(trim:...)%` processor to trim a string value\n * added `%env(default:param_name:...)%` processor to fallback to a parameter or to null when using `%env(default::...)%`\n * added `%env(url:...)%` processor to convert a URL or DNS into an array of components\n * added `%env(query_string:...)%` processor to convert a query string into an array of key values\n * added support for deprecating aliases\n * made `ContainerParametersResource` final and not implement `Serializable` anymore\n * added `ReverseContainer`: a container that turns services back to their ids\n * added ability to define an index for a tagged collection\n * added ability to define an index for services in an injected service locator argument\n * made `ServiceLocator` implement `ServiceProviderInterface`\n * deprecated support for non-string default env() parameters\n * added `%env(require:...)%` processor to `require()` a PHP file and use the value returned from it\n\n4.2.0\n-----\n\n * added `ContainerBuilder::registerAliasForArgument()` to support autowiring by type+name\n * added support for binding by type+name\n * added `ServiceSubscriberTrait` to ease implementing `ServiceSubscriberInterface` using methods' return types\n * added `ServiceLocatorArgument` and `!service_locator` config tag for creating optimized service-locators\n * added support for autoconfiguring bindings\n * added `%env(key:...)%` processor to fetch a specific key from an array\n * deprecated `ServiceSubscriberInterface`, use the same interface from the `Symfony\\Contracts\\Service` namespace instead\n * deprecated `ResettableContainerInterface`, use `Symfony\\Contracts\\Service\\ResetInterface` instead\n\n4.1.0\n-----\n\n * added support for variadics in named arguments\n * added PSR-11 `ContainerBagInterface` and its `ContainerBag` implementation to access parameters as-a-service\n * added support for service's decorators autowiring\n * deprecated the `TypedReference::canBeAutoregistered()` and  `TypedReference::getRequiringClass()` methods\n * environment variables are validated when used in extension configuration\n * deprecated support for auto-discovered extension configuration class which does not implement `ConfigurationInterface`\n\n4.0.0\n-----\n\n * Relying on service auto-registration while autowiring is not supported anymore.\n   Explicitly inject your dependencies or create services whose ids are\n   their fully-qualified class name.\n\n   Before:\n\n   ```php\n   namespace App\\Controller;\n\n   use App\\Mailer;\n\n   class DefaultController\n   {\n       public function __construct(Mailer $mailer) {\n           // ...\n       }\n\n       // ...\n   }\n   ```\n   ```yml\n   services:\n       App\\Controller\\DefaultController:\n           autowire: true\n   ```\n\n   After:\n\n   ```php\n   // same PHP code\n   ```\n   ```yml\n   services:\n       App\\Controller\\DefaultController:\n           autowire: true\n\n       # or\n       # App\\Controller\\DefaultController:\n       #     arguments: { $mailer: \"@App\\Mailer\" }\n\n       App\\Mailer:\n           autowire: true\n    ```\n * removed autowiring services based on the types they implement\n * added a third `$methodName` argument to the `getProxyFactoryCode()` method\n   of the `DumperInterface`\n * removed support for autowiring types\n * removed `Container::isFrozen`\n * removed support for dumping an ucompiled container in `PhpDumper`\n * removed support for generating a dumped `Container` without populating the method map\n * removed support for case insensitive service identifiers\n * removed the `DefinitionDecorator` class, replaced by `ChildDefinition`\n * removed the `AutowireServiceResource` class and related `AutowirePass::createResourceForClass()` method\n * removed `LoggingFormatter`, `Compiler::getLoggingFormatter()` and `addLogMessage()` class and methods, use the `ContainerBuilder::log()` method instead\n * removed `FactoryReturnTypePass`\n * removed `ContainerBuilder::addClassResource()`, use the `addObjectResource()` or the `getReflectionClass()` method instead.\n * removed support for top-level anonymous services\n * removed silent behavior for unused attributes and elements\n * removed support for setting and accessing private services in `Container`\n * removed support for setting pre-defined services in `Container`\n * removed support for case insensitivity of parameter names\n * removed `AutowireExceptionPass` and `AutowirePass::getAutowiringExceptions()`, use `Definition::addError()` and the `DefinitionErrorExceptionPass` instead\n\n3.4.0\n-----\n\n * moved the `ExtensionCompilerPass` to before-optimization passes with priority -1000\n * deprecated \"public-by-default\" definitions and aliases, the new default will be \"private\" in 4.0\n * added `EnvVarProcessorInterface` and corresponding \"container.env_var_processor\" tag for processing env vars\n * added support for ignore-on-uninitialized references\n * deprecated service auto-registration while autowiring\n * deprecated the ability to check for the initialization of a private service with the `Container::initialized()` method\n * deprecated support for top-level anonymous services in XML\n * deprecated case insensitivity of parameter names\n * deprecated the `ResolveDefinitionTemplatesPass` class in favor of `ResolveChildDefinitionsPass`\n * added `TaggedIteratorArgument` with YAML (`!tagged foo`) and XML (`<service type=\"tagged\"/>`) support\n * deprecated `AutowireExceptionPass` and `AutowirePass::getAutowiringExceptions()`, use `Definition::addError()` and the `DefinitionErrorExceptionPass` instead\n\n3.3.0\n-----\n\n * deprecated autowiring services based on the types they implement;\n   rename (or alias) your services to their FQCN id to make them autowirable\n * added \"ServiceSubscriberInterface\" - to allow for per-class explicit service-locator definitions\n * added \"container.service_locator\" tag for defining service-locator services\n * added anonymous services support in YAML configuration files using the `!service` tag.\n * added \"TypedReference\" and \"ServiceClosureArgument\" for creating service-locator services\n * added `ServiceLocator` - a PSR-11 container holding a set of services to be lazily loaded\n * added \"instanceof\" section for local interface-defined configs\n * added prototype services for PSR4-based discovery and registration\n * added `ContainerBuilder::getReflectionClass()` for retrieving and tracking reflection class info\n * deprecated `ContainerBuilder::getClassResource()`, use `ContainerBuilder::getReflectionClass()` or `ContainerBuilder::addObjectResource()` instead\n * added `ContainerBuilder::fileExists()` for checking and tracking file or directory existence\n * deprecated autowiring-types, use aliases instead\n * added support for omitting the factory class name in a service definition if the definition class is set\n * deprecated case insensitivity of service identifiers\n * added \"iterator\" argument type for lazy iteration over a set of values and services\n * added file-wide configurable defaults for service attributes \"public\", \"tags\",\n   \"autowire\" and \"autoconfigure\"\n * made the \"class\" attribute optional, using the \"id\" as fallback\n * using the `PhpDumper` with an uncompiled `ContainerBuilder` is deprecated and\n   will not be supported anymore in 4.0\n * deprecated the `DefinitionDecorator` class in favor of `ChildDefinition`\n * allow config files to be loaded using a glob pattern\n * [BC BREAK] the `NullDumper` class is now final\n\n3.2.0\n-----\n\n * allowed to prioritize compiler passes by introducing a third argument to `PassConfig::addPass()`, to `Compiler::addPass` and to `ContainerBuilder::addCompilerPass()`\n * added support for PHP constants in YAML configuration files\n * deprecated the ability to set or unset a private service with the `Container::set()` method\n * deprecated the ability to check for the existence of a private service with the `Container::has()` method\n * deprecated the ability to request a private service with the `Container::get()` method\n * deprecated support for generating a dumped `Container` without populating the method map\n\n3.0.0\n-----\n\n * removed all deprecated codes from 2.x versions\n\n2.8.0\n-----\n\n * deprecated the abstract ContainerAware class in favor of ContainerAwareTrait\n * deprecated IntrospectableContainerInterface, to be merged with ContainerInterface in 3.0\n * allowed specifying a directory to recursively load all configuration files it contains\n * deprecated the concept of scopes\n * added `Definition::setShared()` and `Definition::isShared()`\n * added ResettableContainerInterface to be able to reset the container to release memory on shutdown\n * added a way to define the priority of service decoration\n * added support for service autowiring\n\n2.7.0\n-----\n\n * deprecated synchronized services\n\n2.6.0\n-----\n\n * added new factory syntax and deprecated the old one\n\n2.5.0\n-----\n\n * added DecoratorServicePass and a way to override a service definition (Definition::setDecoratedService())\n * deprecated SimpleXMLElement class.\n\n2.4.0\n-----\n\n * added support for expressions in service definitions\n * added ContainerAwareTrait to add default container aware behavior to a class\n\n2.2.0\n-----\n\n * added Extension::isConfigEnabled() to ease working with enableable configurations\n * added an Extension base class with sensible defaults to be used in conjunction\n   with the Config component.\n * added PrependExtensionInterface (to be able to allow extensions to prepend\n   application configuration settings for any Bundle)\n\n2.1.0\n-----\n\n * added IntrospectableContainerInterface (to be able to check if a service\n   has been initialized or not)\n * added ConfigurationExtensionInterface\n * added Definition::clearTag()\n * component exceptions that inherit base SPL classes are now used exclusively\n   (this includes dumped containers)\n * [BC BREAK] fixed unescaping of class arguments, method\n   ParameterBag::unescapeValue() was made public\n"
        },
        {
          "name": "ChildDefinition.php",
          "type": "blob",
          "size": 2.5224609375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Symfony\\Component\\DependencyInjection\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\OutOfBoundsException;\n\n/**\n * This definition extends another definition.\n *\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n */\nclass ChildDefinition extends Definition\n{\n    /**\n     * @param string $parent The id of Definition instance to decorate\n     */\n    public function __construct(\n        private string $parent,\n    ) {\n    }\n\n    /**\n     * Returns the Definition to inherit from.\n     */\n    public function getParent(): string\n    {\n        return $this->parent;\n    }\n\n    /**\n     * Sets the Definition to inherit from.\n     *\n     * @return $this\n     */\n    public function setParent(string $parent): static\n    {\n        $this->parent = $parent;\n\n        return $this;\n    }\n\n    /**\n     * Gets an argument to pass to the service constructor/factory method.\n     *\n     * If replaceArgument() has been used to replace an argument, this method\n     * will return the replacement value.\n     *\n     * @throws OutOfBoundsException When the argument does not exist\n     */\n    public function getArgument(int|string $index): mixed\n    {\n        if (\\array_key_exists('index_'.$index, $this->arguments)) {\n            return $this->arguments['index_'.$index];\n        }\n\n        return parent::getArgument($index);\n    }\n\n    /**\n     * You should always use this method when overwriting existing arguments\n     * of the parent definition.\n     *\n     * If you directly call setArguments() keep in mind that you must follow\n     * certain conventions when you want to overwrite the arguments of the\n     * parent definition, otherwise your arguments will only be appended.\n     *\n     * @return $this\n     *\n     * @throws InvalidArgumentException when $index isn't an integer\n     */\n    public function replaceArgument(int|string $index, mixed $value): static\n    {\n        if (\\is_int($index)) {\n            $this->arguments['index_'.$index] = $value;\n        } elseif (str_starts_with($index, '$')) {\n            $this->arguments[$index] = $value;\n        } else {\n            throw new InvalidArgumentException('The argument must be an existing index or the name of a constructor\\'s parameter.');\n        }\n\n        return $this;\n    }\n}\n"
        },
        {
          "name": "Compiler",
          "type": "tree",
          "content": null
        },
        {
          "name": "Config",
          "type": "tree",
          "content": null
        },
        {
          "name": "Container.php",
          "type": "blob",
          "size": 13.650390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Symfony\\Component\\DependencyInjection\\Argument\\RewindableGenerator;\nuse Symfony\\Component\\DependencyInjection\\Argument\\ServiceLocator as ArgumentServiceLocator;\nuse Symfony\\Component\\DependencyInjection\\Exception\\EnvNotFoundException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ParameterCircularReferenceException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ParameterNotFoundException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\RuntimeException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ServiceCircularReferenceException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ServiceNotFoundException;\nuse Symfony\\Component\\DependencyInjection\\ParameterBag\\EnvPlaceholderParameterBag;\nuse Symfony\\Component\\DependencyInjection\\ParameterBag\\FrozenParameterBag;\nuse Symfony\\Component\\DependencyInjection\\ParameterBag\\ParameterBag;\nuse Symfony\\Component\\DependencyInjection\\ParameterBag\\ParameterBagInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(RewindableGenerator::class);\nclass_exists(ArgumentServiceLocator::class);\n\n/**\n * Container is a dependency injection container.\n *\n * It gives access to object instances (services).\n * Services and parameters are simple key/pair stores.\n * The container can have four possible behaviors when a service\n * does not exist (or is not initialized for the last case):\n *\n *  * EXCEPTION_ON_INVALID_REFERENCE: Throws an exception at compilation time (the default)\n *  * NULL_ON_INVALID_REFERENCE:      Returns null\n *  * IGNORE_ON_INVALID_REFERENCE:    Ignores the wrapping command asking for the reference\n *                                    (for instance, ignore a setter if the service does not exist)\n *  * IGNORE_ON_UNINITIALIZED_REFERENCE: Ignores/returns null for uninitialized services or invalid references\n *  * RUNTIME_EXCEPTION_ON_INVALID_REFERENCE: Throws an exception at runtime\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n */\nclass Container implements ContainerInterface, ResetInterface\n{\n    protected ParameterBagInterface $parameterBag;\n    protected array $services = [];\n    protected array $privates = [];\n    protected array $fileMap = [];\n    protected array $methodMap = [];\n    protected array $factories = [];\n    protected array $aliases = [];\n    protected array $loading = [];\n    protected array $resolving = [];\n    protected array $syntheticIds = [];\n\n    private array $envCache = [];\n    private bool $compiled = false;\n    private \\Closure $getEnv;\n\n    private static \\Closure $make;\n\n    public function __construct(?ParameterBagInterface $parameterBag = null)\n    {\n        $this->parameterBag = $parameterBag ?? new EnvPlaceholderParameterBag();\n    }\n\n    /**\n     * Compiles the container.\n     *\n     * This method does two things:\n     *\n     *  * Parameter values are resolved;\n     *  * The parameter bag is frozen.\n     */\n    public function compile(): void\n    {\n        $this->parameterBag->resolve();\n\n        $this->parameterBag = new FrozenParameterBag(\n            $this->parameterBag->all(),\n            $this->parameterBag instanceof ParameterBag ? $this->parameterBag->allDeprecated() : [],\n            $this->parameterBag instanceof ParameterBag ? $this->parameterBag->allNonEmpty() : [],\n        );\n\n        $this->compiled = true;\n    }\n\n    /**\n     * Returns true if the container is compiled.\n     */\n    public function isCompiled(): bool\n    {\n        return $this->compiled;\n    }\n\n    /**\n     * Gets the service container parameter bag.\n     */\n    public function getParameterBag(): ParameterBagInterface\n    {\n        return $this->parameterBag;\n    }\n\n    /**\n     * Gets a parameter.\n     *\n     * @throws ParameterNotFoundException if the parameter is not defined\n     */\n    public function getParameter(string $name): array|bool|string|int|float|\\UnitEnum|null\n    {\n        return $this->parameterBag->get($name);\n    }\n\n    public function hasParameter(string $name): bool\n    {\n        return $this->parameterBag->has($name);\n    }\n\n    public function setParameter(string $name, array|bool|string|int|float|\\UnitEnum|null $value): void\n    {\n        $this->parameterBag->set($name, $value);\n    }\n\n    /**\n     * Sets a service.\n     *\n     * Setting a synthetic service to null resets it: has() returns false and get()\n     * behaves in the same way as if the service was never created.\n     */\n    public function set(string $id, ?object $service): void\n    {\n        // Runs the internal initializer; used by the dumped container to include always-needed files\n        if (isset($this->privates['service_container']) && $this->privates['service_container'] instanceof \\Closure) {\n            $initialize = $this->privates['service_container'];\n            unset($this->privates['service_container']);\n            $initialize($this);\n        }\n\n        if ('service_container' === $id) {\n            throw new InvalidArgumentException('You cannot set service \"service_container\".');\n        }\n\n        if (!(isset($this->fileMap[$id]) || isset($this->methodMap[$id]))) {\n            if (isset($this->syntheticIds[$id]) || !isset($this->getRemovedIds()[$id])) {\n                // no-op\n            } elseif (null === $service) {\n                throw new InvalidArgumentException(\\sprintf('The \"%s\" service is private, you cannot unset it.', $id));\n            } else {\n                throw new InvalidArgumentException(\\sprintf('The \"%s\" service is private, you cannot replace it.', $id));\n            }\n        } elseif (isset($this->services[$id])) {\n            throw new InvalidArgumentException(\\sprintf('The \"%s\" service is already initialized, you cannot replace it.', $id));\n        }\n\n        if (isset($this->aliases[$id])) {\n            unset($this->aliases[$id]);\n        }\n\n        if (null === $service) {\n            unset($this->services[$id]);\n\n            return;\n        }\n\n        $this->services[$id] = $service;\n    }\n\n    public function has(string $id): bool\n    {\n        if (isset($this->aliases[$id])) {\n            $id = $this->aliases[$id];\n        }\n        if (isset($this->services[$id])) {\n            return true;\n        }\n        if ('service_container' === $id) {\n            return true;\n        }\n\n        return isset($this->fileMap[$id]) || isset($this->methodMap[$id]);\n    }\n\n    /**\n     * Gets a service.\n     *\n     * @throws ServiceCircularReferenceException When a circular reference is detected\n     * @throws ServiceNotFoundException          When the service is not defined\n     *\n     * @see Reference\n     */\n    public function get(string $id, int $invalidBehavior = self::EXCEPTION_ON_INVALID_REFERENCE): ?object\n    {\n        return $this->services[$id]\n            ?? $this->services[$id = $this->aliases[$id] ?? $id]\n            ?? ('service_container' === $id ? $this : ($this->factories[$id] ?? self::$make ??= self::make(...))($this, $id, $invalidBehavior));\n    }\n\n    /**\n     * Creates a service.\n     *\n     * As a separate method to allow \"get()\" to use the really fast `??` operator.\n     */\n    private static function make(self $container, string $id, int $invalidBehavior): ?object\n    {\n        if (isset($container->loading[$id])) {\n            throw new ServiceCircularReferenceException($id, array_merge(array_keys($container->loading), [$id]));\n        }\n\n        $container->loading[$id] = true;\n\n        try {\n            if (isset($container->fileMap[$id])) {\n                return /* self::IGNORE_ON_UNINITIALIZED_REFERENCE */ 4 === $invalidBehavior ? null : $container->load($container->fileMap[$id]);\n            } elseif (isset($container->methodMap[$id])) {\n                return /* self::IGNORE_ON_UNINITIALIZED_REFERENCE */ 4 === $invalidBehavior ? null : $container->{$container->methodMap[$id]}($container);\n            }\n        } catch (\\Exception $e) {\n            unset($container->services[$id]);\n\n            throw $e;\n        } finally {\n            unset($container->loading[$id]);\n        }\n\n        if (self::EXCEPTION_ON_INVALID_REFERENCE === $invalidBehavior) {\n            if (!$id) {\n                throw new ServiceNotFoundException($id);\n            }\n            if (isset($container->syntheticIds[$id])) {\n                throw new ServiceNotFoundException($id, null, null, [], \\sprintf('The \"%s\" service is synthetic, it needs to be set at boot time before it can be used.', $id));\n            }\n            if (isset($container->getRemovedIds()[$id])) {\n                throw new ServiceNotFoundException($id, null, null, [], \\sprintf('The \"%s\" service or alias has been removed or inlined when the container was compiled. You should either make it public, or stop using the container directly and use dependency injection instead.', $id));\n            }\n\n            $alternatives = [];\n            foreach ($container->getServiceIds() as $knownId) {\n                if ('' === $knownId || '.' === $knownId[0]) {\n                    continue;\n                }\n                $lev = levenshtein($id, $knownId);\n                if ($lev <= \\strlen($id) / 3 || str_contains($knownId, $id)) {\n                    $alternatives[] = $knownId;\n                }\n            }\n\n            throw new ServiceNotFoundException($id, null, null, $alternatives);\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns true if the given service has actually been initialized.\n     */\n    public function initialized(string $id): bool\n    {\n        if (isset($this->aliases[$id])) {\n            $id = $this->aliases[$id];\n        }\n\n        if ('service_container' === $id) {\n            return false;\n        }\n\n        return isset($this->services[$id]);\n    }\n\n    public function reset(): void\n    {\n        $services = $this->services + $this->privates;\n\n        foreach ($services as $service) {\n            try {\n                if ($service instanceof ResetInterface) {\n                    $service->reset();\n                }\n            } catch (\\Throwable) {\n                continue;\n            }\n        }\n\n        $this->envCache = $this->services = $this->factories = $this->privates = [];\n    }\n\n    /**\n     * Gets all service ids.\n     *\n     * @return string[]\n     */\n    public function getServiceIds(): array\n    {\n        return array_map('strval', array_unique(array_merge(['service_container'], array_keys($this->fileMap), array_keys($this->methodMap), array_keys($this->aliases), array_keys($this->services))));\n    }\n\n    /**\n     * Gets service ids that existed at compile time.\n     */\n    public function getRemovedIds(): array\n    {\n        return [];\n    }\n\n    /**\n     * Camelizes a string.\n     */\n    public static function camelize(string $id): string\n    {\n        return strtr(ucwords(strtr($id, ['_' => ' ', '.' => '_ ', '\\\\' => '_ '])), [' ' => '']);\n    }\n\n    /**\n     * A string to underscore.\n     */\n    public static function underscore(string $id): string\n    {\n        return strtolower(preg_replace(['/([A-Z]+)([A-Z][a-z])/', '/([a-z\\d])([A-Z])/'], ['\\\\1_\\\\2', '\\\\1_\\\\2'], str_replace('_', '.', $id)));\n    }\n\n    /**\n     * Creates a service by requiring its factory file.\n     */\n    protected function load(string $file): mixed\n    {\n        return require $file;\n    }\n\n    /**\n     * Fetches a variable from the environment.\n     *\n     * @throws EnvNotFoundException When the environment variable is not found and has no default value\n     */\n    protected function getEnv(string $name): mixed\n    {\n        if (isset($this->resolving[$envName = \"env($name)\"])) {\n            throw new ParameterCircularReferenceException(array_keys($this->resolving));\n        }\n        if (isset($this->envCache[$name]) || \\array_key_exists($name, $this->envCache)) {\n            return $this->envCache[$name];\n        }\n        if (!$this->has($id = 'container.env_var_processors_locator')) {\n            $this->set($id, new ServiceLocator([]));\n        }\n        $this->getEnv ??= $this->getEnv(...);\n        $processors = $this->get($id);\n\n        if (false !== $i = strpos($name, ':')) {\n            $prefix = substr($name, 0, $i);\n            $localName = substr($name, 1 + $i);\n        } else {\n            $prefix = 'string';\n            $localName = $name;\n        }\n\n        $processor = $processors->has($prefix) ? $processors->get($prefix) : new EnvVarProcessor($this);\n        if (false === $i) {\n            $prefix = '';\n        }\n\n        $this->resolving[$envName] = true;\n        try {\n            return $this->envCache[$name] = $processor->getEnv($prefix, $localName, $this->getEnv);\n        } finally {\n            unset($this->resolving[$envName]);\n        }\n    }\n\n    /**\n     * @internal\n     */\n    final protected function getService(string|false $registry, string $id, ?string $method, string|bool $load): mixed\n    {\n        if ('service_container' === $id) {\n            return $this;\n        }\n        if (\\is_string($load)) {\n            throw new RuntimeException($load);\n        }\n        if (null === $method) {\n            return false !== $registry ? $this->{$registry}[$id] ?? null : null;\n        }\n        if (false !== $registry) {\n            return $this->{$registry}[$id] ??= $load ? $this->load($method) : $this->{$method}($this);\n        }\n        if (!$load) {\n            return $this->{$method}($this);\n        }\n\n        return ($factory = $this->factories[$id] ?? $this->factories['service_container'][$id] ?? null) ? $factory($this) : $this->load($method);\n    }\n\n    private function __clone()\n    {\n    }\n}\n"
        },
        {
          "name": "ContainerBuilder.php",
          "type": "blob",
          "size": 61.779296875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Composer\\Autoload\\ClassLoader;\nuse Composer\\InstalledVersions;\nuse Symfony\\Component\\Config\\Resource\\ClassExistenceResource;\nuse Symfony\\Component\\Config\\Resource\\ComposerResource;\nuse Symfony\\Component\\Config\\Resource\\DirectoryResource;\nuse Symfony\\Component\\Config\\Resource\\FileExistenceResource;\nuse Symfony\\Component\\Config\\Resource\\FileResource;\nuse Symfony\\Component\\Config\\Resource\\GlobResource;\nuse Symfony\\Component\\Config\\Resource\\ReflectionClassResource;\nuse Symfony\\Component\\Config\\Resource\\ResourceInterface;\nuse Symfony\\Component\\DependencyInjection\\Argument\\AbstractArgument;\nuse Symfony\\Component\\DependencyInjection\\Argument\\IteratorArgument;\nuse Symfony\\Component\\DependencyInjection\\Argument\\LazyClosure;\nuse Symfony\\Component\\DependencyInjection\\Argument\\RewindableGenerator;\nuse Symfony\\Component\\DependencyInjection\\Argument\\ServiceClosureArgument;\nuse Symfony\\Component\\DependencyInjection\\Argument\\ServiceLocator;\nuse Symfony\\Component\\DependencyInjection\\Argument\\ServiceLocatorArgument;\nuse Symfony\\Component\\DependencyInjection\\Attribute\\Target;\nuse Symfony\\Component\\DependencyInjection\\Compiler\\Compiler;\nuse Symfony\\Component\\DependencyInjection\\Compiler\\CompilerPassInterface;\nuse Symfony\\Component\\DependencyInjection\\Compiler\\PassConfig;\nuse Symfony\\Component\\DependencyInjection\\Compiler\\ResolveEnvPlaceholdersPass;\nuse Symfony\\Component\\DependencyInjection\\Exception\\BadMethodCallException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\LogicException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ParameterNotFoundException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\RuntimeException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ServiceCircularReferenceException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ServiceNotFoundException;\nuse Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface;\nuse Symfony\\Component\\DependencyInjection\\LazyProxy\\Instantiator\\InstantiatorInterface;\nuse Symfony\\Component\\DependencyInjection\\LazyProxy\\Instantiator\\LazyServiceInstantiator;\nuse Symfony\\Component\\DependencyInjection\\LazyProxy\\Instantiator\\RealServiceInstantiator;\nuse Symfony\\Component\\DependencyInjection\\ParameterBag\\EnvPlaceholderParameterBag;\nuse Symfony\\Component\\DependencyInjection\\ParameterBag\\ParameterBag;\nuse Symfony\\Component\\DependencyInjection\\ParameterBag\\ParameterBagInterface;\nuse Symfony\\Component\\ErrorHandler\\DebugClassLoader;\nuse Symfony\\Component\\ExpressionLanguage\\Expression;\nuse Symfony\\Component\\ExpressionLanguage\\ExpressionFunctionProviderInterface;\n\n/**\n * ContainerBuilder is a DI container that provides an API to easily describe services.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass ContainerBuilder extends Container implements TaggedContainerInterface\n{\n    /**\n     * @var array<string, ExtensionInterface>\n     */\n    private array $extensions = [];\n\n    /**\n     * @var array<string, ExtensionInterface>\n     */\n    private array $extensionsByNs = [];\n\n    /**\n     * @var array<string, Definition>\n     */\n    private array $definitions = [];\n\n    /**\n     * @var array<string, Alias>\n     */\n    private array $aliasDefinitions = [];\n\n    /**\n     * @var array<string, ResourceInterface>\n     */\n    private array $resources = [];\n\n    /**\n     * @var array<string, array<array<string, mixed>>>\n     */\n    private array $extensionConfigs = [];\n\n    private Compiler $compiler;\n    private bool $trackResources;\n    private InstantiatorInterface $proxyInstantiator;\n    private ExpressionLanguage $expressionLanguage;\n\n    /**\n     * @var ExpressionFunctionProviderInterface[]\n     */\n    private array $expressionLanguageProviders = [];\n\n    /**\n     * @var string[] with tag names used by findTaggedServiceIds\n     */\n    private array $usedTags = [];\n\n    /**\n     * @var string[][] a map of env var names to their placeholders\n     */\n    private array $envPlaceholders = [];\n\n    /**\n     * @var int[] a map of env vars to their resolution counter\n     */\n    private array $envCounters = [];\n\n    /**\n     * @var string[] the list of vendor directories\n     */\n    private array $vendors;\n\n    /**\n     * @var array<string, bool> whether a path is in a vendor directory\n     */\n    private array $pathsInVendor = [];\n\n    /**\n     * @var array<string, ChildDefinition>\n     */\n    private array $autoconfiguredInstanceof = [];\n\n    /**\n     * @var array<string, callable>\n     */\n    private array $autoconfiguredAttributes = [];\n\n    /**\n     * @var array<string, bool>\n     */\n    private array $removedIds = [];\n\n    /**\n     * @var array<int, bool>\n     */\n    private array $removedBindingIds = [];\n\n    private const INTERNAL_TYPES = [\n        'int' => true,\n        'float' => true,\n        'string' => true,\n        'bool' => true,\n        'resource' => true,\n        'object' => true,\n        'array' => true,\n        'null' => true,\n        'callable' => true,\n        'iterable' => true,\n        'mixed' => true,\n    ];\n\n    public function __construct(?ParameterBagInterface $parameterBag = null)\n    {\n        parent::__construct($parameterBag);\n\n        $this->trackResources = interface_exists(ResourceInterface::class);\n        $this->setDefinition('service_container', (new Definition(ContainerInterface::class))->setSynthetic(true)->setPublic(true));\n    }\n\n    /**\n     * @var array<string, \\ReflectionClass>\n     */\n    private array $classReflectors;\n\n    /**\n     * Sets the track resources flag.\n     *\n     * If you are not using the loaders and therefore don't want\n     * to depend on the Config component, set this flag to false.\n     */\n    public function setResourceTracking(bool $track): void\n    {\n        $this->trackResources = $track;\n    }\n\n    /**\n     * Checks if resources are tracked.\n     */\n    public function isTrackingResources(): bool\n    {\n        return $this->trackResources;\n    }\n\n    /**\n     * Sets the instantiator to be used when fetching proxies.\n     */\n    public function setProxyInstantiator(InstantiatorInterface $proxyInstantiator): void\n    {\n        $this->proxyInstantiator = $proxyInstantiator;\n    }\n\n    public function registerExtension(ExtensionInterface $extension): void\n    {\n        $this->extensions[$extension->getAlias()] = $extension;\n\n        if (false !== $extension->getNamespace()) {\n            $this->extensionsByNs[$extension->getNamespace()] = $extension;\n        }\n    }\n\n    /**\n     * Returns an extension by alias or namespace.\n     *\n     * @throws LogicException if the extension is not registered\n     */\n    public function getExtension(string $name): ExtensionInterface\n    {\n        if (isset($this->extensions[$name])) {\n            return $this->extensions[$name];\n        }\n\n        if (isset($this->extensionsByNs[$name])) {\n            return $this->extensionsByNs[$name];\n        }\n\n        throw new LogicException(\\sprintf('Container extension \"%s\" is not registered.', $name));\n    }\n\n    /**\n     * Returns all registered extensions.\n     *\n     * @return array<string, ExtensionInterface>\n     */\n    public function getExtensions(): array\n    {\n        return $this->extensions;\n    }\n\n    /**\n     * Checks if we have an extension.\n     */\n    public function hasExtension(string $name): bool\n    {\n        return isset($this->extensions[$name]) || isset($this->extensionsByNs[$name]);\n    }\n\n    /**\n     * Returns an array of resources loaded to build this configuration.\n     *\n     * @return ResourceInterface[]\n     */\n    public function getResources(): array\n    {\n        return array_values($this->resources);\n    }\n\n    /**\n     * @return $this\n     */\n    public function addResource(ResourceInterface $resource): static\n    {\n        if (!$this->trackResources) {\n            return $this;\n        }\n\n        if ($resource instanceof GlobResource && $this->inVendors($resource->getPrefix())) {\n            return $this;\n        }\n        if ($resource instanceof FileExistenceResource && $this->inVendors($resource->getResource())) {\n            return $this;\n        }\n        if ($resource instanceof FileResource && $this->inVendors($resource->getResource())) {\n            return $this;\n        }\n        if ($resource instanceof DirectoryResource && $this->inVendors($resource->getResource())) {\n            return $this;\n        }\n        if ($resource instanceof ClassExistenceResource) {\n            $class = $resource->getResource();\n\n            $inVendor = false;\n            foreach (spl_autoload_functions() as $autoloader) {\n                if (!\\is_array($autoloader)) {\n                    continue;\n                }\n\n                if ($autoloader[0] instanceof DebugClassLoader) {\n                    $autoloader = $autoloader[0]->getClassLoader();\n                }\n\n                if (!\\is_array($autoloader) || !$autoloader[0] instanceof ClassLoader || !$autoloader[0]->findFile(__CLASS__)) {\n                    continue;\n                }\n\n                foreach ($autoloader[0]->getPrefixesPsr4() as $prefix => $dirs) {\n                    if ('' === $prefix || !str_starts_with($class, $prefix)) {\n                        continue;\n                    }\n\n                    foreach ($dirs as $dir) {\n                        if (!$dir = realpath($dir)) {\n                            continue;\n                        }\n\n                        if (!$inVendor = $this->inVendors($dir)) {\n                            break 3;\n                        }\n                    }\n                }\n            }\n\n            if ($inVendor) {\n                return $this;\n            }\n        }\n\n        $this->resources[(string) $resource] = $resource;\n\n        return $this;\n    }\n\n    /**\n     * Sets the resources for this configuration.\n     *\n     * @param array<string, ResourceInterface> $resources\n     *\n     * @return $this\n     */\n    public function setResources(array $resources): static\n    {\n        if (!$this->trackResources) {\n            return $this;\n        }\n\n        $this->resources = $resources;\n\n        return $this;\n    }\n\n    /**\n     * Adds the object class hierarchy as resources.\n     *\n     * @param object|string $object An object instance or class name\n     *\n     * @return $this\n     */\n    public function addObjectResource(object|string $object): static\n    {\n        if ($this->trackResources) {\n            if (\\is_object($object)) {\n                $object = $object::class;\n            }\n            if (!isset($this->classReflectors[$object])) {\n                $this->classReflectors[$object] = new \\ReflectionClass($object);\n            }\n            $class = $this->classReflectors[$object];\n\n            foreach ($class->getInterfaceNames() as $name) {\n                if (null === $interface = &$this->classReflectors[$name]) {\n                    $interface = new \\ReflectionClass($name);\n                }\n                $file = $interface->getFileName();\n                if (false !== $file && file_exists($file)) {\n                    $this->fileExists($file);\n                }\n            }\n            do {\n                $file = $class->getFileName();\n                if (false !== $file && file_exists($file)) {\n                    $this->fileExists($file);\n                }\n                foreach ($class->getTraitNames() as $name) {\n                    $this->addObjectResource($name);\n                }\n            } while ($class = $class->getParentClass());\n        }\n\n        return $this;\n    }\n\n    /**\n     * Retrieves the requested reflection class and registers it for resource tracking.\n     *\n     * @throws \\ReflectionException when a parent class/interface/trait is not found and $throw is true\n     *\n     * @final\n     */\n    public function getReflectionClass(?string $class, bool $throw = true): ?\\ReflectionClass\n    {\n        if (!$class = $this->getParameterBag()->resolveValue($class)) {\n            return null;\n        }\n\n        if (isset(self::INTERNAL_TYPES[$class])) {\n            return null;\n        }\n\n        $resource = $classReflector = null;\n\n        try {\n            if (isset($this->classReflectors[$class])) {\n                $classReflector = $this->classReflectors[$class];\n            } elseif (class_exists(ClassExistenceResource::class)) {\n                $resource = new ClassExistenceResource($class, false);\n                $classReflector = $resource->isFresh(0) ? false : new \\ReflectionClass($class);\n            } else {\n                $classReflector = class_exists($class) || interface_exists($class, false) ? new \\ReflectionClass($class) : false;\n            }\n        } catch (\\ReflectionException $e) {\n            if ($throw) {\n                throw $e;\n            }\n        }\n\n        if ($this->trackResources) {\n            if (!$classReflector) {\n                $this->addResource($resource ?? new ClassExistenceResource($class, false));\n            } elseif (!$classReflector->isInternal()) {\n                $path = $classReflector->getFileName();\n\n                if (!$this->inVendors($path)) {\n                    $this->addResource(new ReflectionClassResource($classReflector, $this->vendors));\n                }\n            }\n            $this->classReflectors[$class] = $classReflector;\n        }\n\n        return $classReflector ?: null;\n    }\n\n    /**\n     * Checks whether the requested file or directory exists and registers the result for resource tracking.\n     *\n     * @param string      $path          The file or directory path for which to check the existence\n     * @param bool|string $trackContents Whether to track contents of the given resource. If a string is passed,\n     *                                   it will be used as pattern for tracking contents of the requested directory\n     *\n     * @final\n     */\n    public function fileExists(string $path, bool|string $trackContents = true): bool\n    {\n        $exists = file_exists($path);\n\n        if (!$this->trackResources || $this->inVendors($path)) {\n            return $exists;\n        }\n\n        if (!$exists) {\n            $this->addResource(new FileExistenceResource($path));\n\n            return false;\n        }\n\n        if (is_dir($path)) {\n            if ($trackContents) {\n                $this->addResource(new DirectoryResource($path, \\is_string($trackContents) ? $trackContents : null));\n            } else {\n                $this->addResource(new GlobResource($path, '/*', false));\n            }\n        } elseif ($trackContents) {\n            $this->addResource(new FileResource($path));\n        }\n\n        return true;\n    }\n\n    /**\n     * Loads the configuration for an extension.\n     *\n     * @param string                    $extension The extension alias or namespace\n     * @param array<string, mixed>|null $values    An array of values that customizes the extension\n     *\n     * @return $this\n     *\n     * @throws BadMethodCallException When this ContainerBuilder is compiled\n     * @throws \\LogicException        if the extension is not registered\n     */\n    public function loadFromExtension(string $extension, ?array $values = null): static\n    {\n        if ($this->isCompiled()) {\n            throw new BadMethodCallException('Cannot load from an extension on a compiled container.');\n        }\n\n        $namespace = $this->getExtension($extension)->getAlias();\n\n        $this->extensionConfigs[$namespace][] = $values ?? [];\n\n        return $this;\n    }\n\n    /**\n     * Adds a compiler pass.\n     *\n     * @param string $type     The type of compiler pass\n     * @param int    $priority Used to sort the passes\n     *\n     * @return $this\n     */\n    public function addCompilerPass(CompilerPassInterface $pass, string $type = PassConfig::TYPE_BEFORE_OPTIMIZATION, int $priority = 0): static\n    {\n        $this->getCompiler()->addPass($pass, $type, $priority);\n\n        $this->addObjectResource($pass);\n\n        return $this;\n    }\n\n    /**\n     * Returns the compiler pass config which can then be modified.\n     */\n    public function getCompilerPassConfig(): PassConfig\n    {\n        return $this->getCompiler()->getPassConfig();\n    }\n\n    /**\n     * Returns the compiler.\n     */\n    public function getCompiler(): Compiler\n    {\n        return $this->compiler ??= new Compiler();\n    }\n\n    /**\n     * Sets a service.\n     *\n     * @throws BadMethodCallException When this ContainerBuilder is compiled\n     */\n    public function set(string $id, ?object $service): void\n    {\n        if ($this->isCompiled() && (isset($this->definitions[$id]) && !$this->definitions[$id]->isSynthetic())) {\n            // setting a synthetic service on a compiled container is alright\n            throw new BadMethodCallException(\\sprintf('Setting service \"%s\" for an unknown or non-synthetic service definition on a compiled container is not allowed.', $id));\n        }\n\n        unset($this->definitions[$id], $this->aliasDefinitions[$id], $this->removedIds[$id]);\n\n        parent::set($id, $service);\n    }\n\n    /**\n     * Removes a service definition.\n     */\n    public function removeDefinition(string $id): void\n    {\n        if (isset($this->definitions[$id])) {\n            unset($this->definitions[$id]);\n            if ('.' !== ($id[0] ?? '-')) {\n                $this->removedIds[$id] = true;\n            }\n        }\n    }\n\n    public function has(string $id): bool\n    {\n        return isset($this->definitions[$id]) || isset($this->aliasDefinitions[$id]) || parent::has($id);\n    }\n\n    /**\n     * @throws InvalidArgumentException          when no definitions are available\n     * @throws ServiceCircularReferenceException When a circular reference is detected\n     * @throws ServiceNotFoundException          When the service is not defined\n     * @throws \\Exception\n     *\n     * @see Reference\n     */\n    public function get(string $id, int $invalidBehavior = ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE): ?object\n    {\n        if ($this->isCompiled() && isset($this->removedIds[$id])) {\n            return ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE >= $invalidBehavior ? parent::get($id) : null;\n        }\n\n        return $this->doGet($id, $invalidBehavior);\n    }\n\n    private function doGet(string $id, int $invalidBehavior = ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE, ?array &$inlineServices = null, bool $isConstructorArgument = false): mixed\n    {\n        if (isset($inlineServices[$id])) {\n            return $inlineServices[$id];\n        }\n        if (null === $inlineServices) {\n            $isConstructorArgument = true;\n            $inlineServices = [];\n        }\n        try {\n            if (ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE === $invalidBehavior) {\n                return $this->privates[$id] ?? parent::get($id, $invalidBehavior);\n            }\n            if (null !== $service = $this->privates[$id] ?? parent::get($id, ContainerInterface::NULL_ON_INVALID_REFERENCE)) {\n                return $service;\n            }\n        } catch (ServiceCircularReferenceException $e) {\n            if ($isConstructorArgument) {\n                throw $e;\n            }\n        }\n\n        if (!isset($this->definitions[$id]) && isset($this->aliasDefinitions[$id])) {\n            $alias = $this->aliasDefinitions[$id];\n\n            if ($alias->isDeprecated()) {\n                $deprecation = $alias->getDeprecation($id);\n                trigger_deprecation($deprecation['package'], $deprecation['version'], $deprecation['message']);\n            }\n\n            return $this->doGet((string) $alias, $invalidBehavior, $inlineServices, $isConstructorArgument);\n        }\n\n        try {\n            $definition = $this->getDefinition($id);\n        } catch (ServiceNotFoundException $e) {\n            if (ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE < $invalidBehavior) {\n                return null;\n            }\n\n            throw $e;\n        }\n\n        if ($definition->hasErrors() && $e = $definition->getErrors()) {\n            throw new RuntimeException(reset($e));\n        }\n\n        if ($isConstructorArgument) {\n            $this->loading[$id] = true;\n        }\n\n        try {\n            return $this->createService($definition, $inlineServices, $isConstructorArgument, $id);\n        } finally {\n            if ($isConstructorArgument) {\n                unset($this->loading[$id]);\n            }\n        }\n    }\n\n    /**\n     * Merges a ContainerBuilder with the current ContainerBuilder configuration.\n     *\n     * Service definitions overrides the current defined ones.\n     *\n     * But for parameters, they are overridden by the current ones. It allows\n     * the parameters passed to the container constructor to have precedence\n     * over the loaded ones.\n     *\n     *     $container = new ContainerBuilder(new ParameterBag(['foo' => 'bar']));\n     *     $loader = new LoaderXXX($container);\n     *     $loader->load('resource_name');\n     *     $container->register('foo', 'stdClass');\n     *\n     * In the above example, even if the loaded resource defines a foo\n     * parameter, the value will still be 'bar' as defined in the ContainerBuilder\n     * constructor.\n     *\n     * @throws BadMethodCallException When this ContainerBuilder is compiled\n     */\n    public function merge(self $container): void\n    {\n        if ($this->isCompiled()) {\n            throw new BadMethodCallException('Cannot merge on a compiled container.');\n        }\n\n        foreach ($container->getDefinitions() as $id => $definition) {\n            if (!$definition->hasTag('container.excluded') || !$this->has($id)) {\n                $this->setDefinition($id, $definition);\n            }\n        }\n        $this->addAliases($container->getAliases());\n        $parameterBag = $this->getParameterBag();\n        $otherBag = $container->getParameterBag();\n        $parameterBag->add($otherBag->all());\n\n        if ($parameterBag instanceof ParameterBag && $otherBag instanceof ParameterBag) {\n            foreach ($otherBag->allDeprecated() as $name => $deprecated) {\n                $parameterBag->deprecate($name, ...$deprecated);\n            }\n\n            foreach ($otherBag->allNonEmpty() as $name => $message) {\n                $parameterBag->cannotBeEmpty($name, $message);\n            }\n        }\n\n        if ($this->trackResources) {\n            foreach ($container->getResources() as $resource) {\n                $this->addResource($resource);\n            }\n        }\n\n        foreach ($this->extensions as $name => $extension) {\n            if (!isset($this->extensionConfigs[$name])) {\n                $this->extensionConfigs[$name] = [];\n            }\n\n            $this->extensionConfigs[$name] = array_merge($this->extensionConfigs[$name], $container->getExtensionConfig($name));\n        }\n\n        if ($parameterBag instanceof EnvPlaceholderParameterBag && $otherBag instanceof EnvPlaceholderParameterBag) {\n            $envPlaceholders = $otherBag->getEnvPlaceholders();\n            $parameterBag->mergeEnvPlaceholders($otherBag);\n        } else {\n            $envPlaceholders = [];\n        }\n\n        foreach ($container->envCounters as $env => $count) {\n            if (!$count && !isset($envPlaceholders[$env])) {\n                continue;\n            }\n            if (!isset($this->envCounters[$env])) {\n                $this->envCounters[$env] = $count;\n            } else {\n                $this->envCounters[$env] += $count;\n            }\n        }\n\n        foreach ($container->getAutoconfiguredInstanceof() as $interface => $childDefinition) {\n            if (isset($this->autoconfiguredInstanceof[$interface])) {\n                throw new InvalidArgumentException(\\sprintf('\"%s\" has already been autoconfigured and merge() does not support merging autoconfiguration for the same class/interface.', $interface));\n            }\n\n            $this->autoconfiguredInstanceof[$interface] = $childDefinition;\n        }\n\n        foreach ($container->getAutoconfiguredAttributes() as $attribute => $configurator) {\n            if (isset($this->autoconfiguredAttributes[$attribute])) {\n                throw new InvalidArgumentException(\\sprintf('\"%s\" has already been autoconfigured and merge() does not support merging autoconfiguration for the same attribute.', $attribute));\n            }\n\n            $this->autoconfiguredAttributes[$attribute] = $configurator;\n        }\n    }\n\n    /**\n     * Returns the configuration array for the given extension.\n     *\n     * @return array<array<string, mixed>>\n     */\n    public function getExtensionConfig(string $name): array\n    {\n        if (!isset($this->extensionConfigs[$name])) {\n            $this->extensionConfigs[$name] = [];\n        }\n\n        return $this->extensionConfigs[$name];\n    }\n\n    /**\n     * Prepends a config array to the configs of the given extension.\n     *\n     * @param array<string, mixed> $config\n     */\n    public function prependExtensionConfig(string $name, array $config): void\n    {\n        if (!isset($this->extensionConfigs[$name])) {\n            $this->extensionConfigs[$name] = [];\n        }\n\n        array_unshift($this->extensionConfigs[$name], $config);\n    }\n\n    /**\n     * Deprecates a service container parameter.\n     *\n     * @throws ParameterNotFoundException if the parameter is not defined\n     */\n    public function deprecateParameter(string $name, string $package, string $version, string $message = 'The parameter \"%s\" is deprecated.'): void\n    {\n        if (!$this->parameterBag instanceof ParameterBag) {\n            throw new BadMethodCallException(\\sprintf('The parameter bag must be an instance of \"%s\" to call \"%s\".', ParameterBag::class, __METHOD__));\n        }\n\n        $this->parameterBag->deprecate($name, $package, $version, $message);\n    }\n\n    public function parameterCannotBeEmpty(string $name, string $message): void\n    {\n        if (!$this->parameterBag instanceof ParameterBag) {\n            throw new BadMethodCallException(\\sprintf('The parameter bag must be an instance of \"%s\" to call \"%s()\".', ParameterBag::class, __METHOD__));\n        }\n\n        $this->parameterBag->cannotBeEmpty($name, $message);\n    }\n\n    /**\n     * Compiles the container.\n     *\n     * This method passes the container to compiler\n     * passes whose job is to manipulate and optimize\n     * the container.\n     *\n     * The main compiler passes roughly do four things:\n     *\n     *  * The extension configurations are merged;\n     *  * Parameter values are resolved;\n     *  * The parameter bag is frozen;\n     *  * Extension loading is disabled.\n     *\n     * @param bool $resolveEnvPlaceholders Whether %env()% parameters should be resolved using the current\n     *                                     env vars or be replaced by uniquely identifiable placeholders.\n     *                                     Set to \"true\" when you want to use the current ContainerBuilder\n     *                                     directly, keep to \"false\" when the container is dumped instead.\n     */\n    public function compile(bool $resolveEnvPlaceholders = false): void\n    {\n        $compiler = $this->getCompiler();\n\n        if ($this->trackResources) {\n            foreach ($compiler->getPassConfig()->getPasses() as $pass) {\n                $this->addObjectResource($pass);\n            }\n        }\n        $bag = $this->getParameterBag();\n\n        if ($resolveEnvPlaceholders && $bag instanceof EnvPlaceholderParameterBag) {\n            $compiler->addPass(new ResolveEnvPlaceholdersPass(), PassConfig::TYPE_AFTER_REMOVING, -1000);\n        }\n\n        $compiler->compile($this);\n\n        foreach ($this->definitions as $id => $definition) {\n            if ($this->trackResources && $definition->isLazy()) {\n                $this->getReflectionClass($definition->getClass());\n            }\n        }\n\n        $this->extensionConfigs = [];\n\n        if ($bag instanceof EnvPlaceholderParameterBag) {\n            if ($resolveEnvPlaceholders) {\n                $this->parameterBag = new ParameterBag($this->resolveEnvPlaceholders($bag->all(), true));\n            }\n\n            $this->envPlaceholders = $bag->getEnvPlaceholders();\n        }\n\n        parent::compile();\n\n        foreach ($this->definitions + $this->aliasDefinitions as $id => $definition) {\n            if ('.' === ($id[0] ?? '-')) {\n                continue;\n            }\n            if (!$definition->isPublic() || $definition->isPrivate()) {\n                $this->removedIds[$id] = true;\n            }\n        }\n    }\n\n    public function getServiceIds(): array\n    {\n        return array_map('strval', array_unique(array_merge(array_keys($this->getDefinitions()), array_keys($this->aliasDefinitions), parent::getServiceIds())));\n    }\n\n    /**\n     * Gets removed service or alias ids.\n     *\n     * @return array<string, bool>\n     */\n    public function getRemovedIds(): array\n    {\n        return $this->removedIds;\n    }\n\n    /**\n     * Adds the service aliases.\n     *\n     * @param array<string, string|Alias> $aliases\n     */\n    public function addAliases(array $aliases): void\n    {\n        foreach ($aliases as $alias => $id) {\n            $this->setAlias($alias, $id);\n        }\n    }\n\n    /**\n     * Sets the service aliases.\n     *\n     * @param array<string, string|Alias> $aliases\n     */\n    public function setAliases(array $aliases): void\n    {\n        $this->aliasDefinitions = [];\n        $this->addAliases($aliases);\n    }\n\n    /**\n     * Sets an alias for an existing service.\n     *\n     * @throws InvalidArgumentException if the id is not a string or an Alias\n     * @throws InvalidArgumentException if the alias is for itself\n     */\n    public function setAlias(string $alias, string|Alias $id): Alias\n    {\n        if ('' === $alias || '\\\\' === $alias[-1] || \\strlen($alias) !== strcspn($alias, \"\\0\\r\\n'\")) {\n            throw new InvalidArgumentException(\\sprintf('Invalid alias id: \"%s\".', $alias));\n        }\n\n        if (\\is_string($id)) {\n            $id = new Alias($id);\n        }\n\n        if ($alias === (string) $id) {\n            throw new InvalidArgumentException(\\sprintf('An alias cannot reference itself, got a circular reference on \"%s\".', $alias));\n        }\n\n        unset($this->definitions[$alias], $this->removedIds[$alias]);\n\n        return $this->aliasDefinitions[$alias] = $id;\n    }\n\n    public function removeAlias(string $alias): void\n    {\n        if (isset($this->aliasDefinitions[$alias])) {\n            unset($this->aliasDefinitions[$alias]);\n            if ('.' !== ($alias[0] ?? '-')) {\n                $this->removedIds[$alias] = true;\n            }\n        }\n    }\n\n    public function hasAlias(string $id): bool\n    {\n        return isset($this->aliasDefinitions[$id]);\n    }\n\n    /**\n     * @return array<string, Alias>\n     */\n    public function getAliases(): array\n    {\n        return $this->aliasDefinitions;\n    }\n\n    /**\n     * @throws InvalidArgumentException if the alias does not exist\n     */\n    public function getAlias(string $id): Alias\n    {\n        if (!isset($this->aliasDefinitions[$id])) {\n            throw new InvalidArgumentException(\\sprintf('The service alias \"%s\" does not exist.', $id));\n        }\n\n        return $this->aliasDefinitions[$id];\n    }\n\n    /**\n     * Registers a service definition.\n     *\n     * This method allows for simple registration of service definition\n     * with a fluid interface.\n     */\n    public function register(string $id, ?string $class = null): Definition\n    {\n        return $this->setDefinition($id, new Definition($class));\n    }\n\n    /**\n     * This method provides a fluid interface for easily registering a child\n     * service definition of the given parent service.\n     */\n    public function registerChild(string $id, string $parent): ChildDefinition\n    {\n        return $this->setDefinition($id, new ChildDefinition($parent));\n    }\n\n    /**\n     * Registers an autowired service definition.\n     *\n     * This method implements a shortcut for using setDefinition() with\n     * an autowired definition.\n     */\n    public function autowire(string $id, ?string $class = null): Definition\n    {\n        return $this->setDefinition($id, (new Definition($class))->setAutowired(true));\n    }\n\n    /**\n     * Adds the service definitions.\n     *\n     * @param array<string, Definition> $definitions\n     */\n    public function addDefinitions(array $definitions): void\n    {\n        foreach ($definitions as $id => $definition) {\n            $this->setDefinition($id, $definition);\n        }\n    }\n\n    /**\n     * Sets the service definitions.\n     *\n     * @param array<string, Definition> $definitions\n     */\n    public function setDefinitions(array $definitions): void\n    {\n        $this->definitions = [];\n        $this->addDefinitions($definitions);\n    }\n\n    /**\n     * Gets all service definitions.\n     *\n     * @return array<string, Definition>\n     */\n    public function getDefinitions(): array\n    {\n        return $this->definitions;\n    }\n\n    /**\n     * Sets a service definition.\n     *\n     * @throws BadMethodCallException When this ContainerBuilder is compiled\n     */\n    public function setDefinition(string $id, Definition $definition): Definition\n    {\n        if ($this->isCompiled()) {\n            throw new BadMethodCallException('Adding definition to a compiled container is not allowed.');\n        }\n\n        if ('' === $id || '\\\\' === $id[-1] || \\strlen($id) !== strcspn($id, \"\\0\\r\\n'\")) {\n            throw new InvalidArgumentException(\\sprintf('Invalid service id: \"%s\".', $id));\n        }\n\n        unset($this->aliasDefinitions[$id], $this->removedIds[$id]);\n\n        return $this->definitions[$id] = $definition;\n    }\n\n    /**\n     * Returns true if a service definition exists under the given identifier.\n     */\n    public function hasDefinition(string $id): bool\n    {\n        return isset($this->definitions[$id]);\n    }\n\n    /**\n     * Gets a service definition.\n     *\n     * @throws ServiceNotFoundException if the service definition does not exist\n     */\n    public function getDefinition(string $id): Definition\n    {\n        if (!isset($this->definitions[$id])) {\n            throw new ServiceNotFoundException($id);\n        }\n\n        return $this->definitions[$id];\n    }\n\n    /**\n     * Gets a service definition by id or alias.\n     *\n     * The method \"unaliases\" recursively to return a Definition instance.\n     *\n     * @throws ServiceNotFoundException if the service definition does not exist\n     */\n    public function findDefinition(string $id): Definition\n    {\n        $seen = [];\n        while (isset($this->aliasDefinitions[$id])) {\n            $id = (string) $this->aliasDefinitions[$id];\n\n            if (isset($seen[$id])) {\n                $seen = array_values($seen);\n                $seen = \\array_slice($seen, array_search($id, $seen));\n                $seen[] = $id;\n\n                throw new ServiceCircularReferenceException($id, $seen);\n            }\n\n            $seen[$id] = $id;\n        }\n\n        return $this->getDefinition($id);\n    }\n\n    /**\n     * Creates a service for a service definition.\n     *\n     * @throws RuntimeException         When the factory definition is incomplete\n     * @throws RuntimeException         When the service is a synthetic service\n     * @throws InvalidArgumentException When configure callable is not callable\n     */\n    private function createService(Definition $definition, array &$inlineServices, bool $isConstructorArgument = false, ?string $id = null, bool|object $tryProxy = true): mixed\n    {\n        if (null === $id && isset($inlineServices[$h = spl_object_hash($definition)])) {\n            return $inlineServices[$h];\n        }\n\n        if ($definition instanceof ChildDefinition) {\n            throw new RuntimeException(\\sprintf('Constructing service \"%s\" from a parent definition is not supported at build time.', $id));\n        }\n\n        if ($definition->isSynthetic()) {\n            throw new RuntimeException(\\sprintf('You have requested a synthetic service (\"%s\"). The DIC does not know how to construct this service.', $id));\n        }\n\n        if ($definition->isDeprecated()) {\n            $deprecation = $definition->getDeprecation($id);\n            trigger_deprecation($deprecation['package'], $deprecation['version'], $deprecation['message']);\n        }\n\n        $parameterBag = $this->getParameterBag();\n        $class = $parameterBag->resolveValue($definition->getClass()) ?: (['Closure', 'fromCallable'] === $definition->getFactory() ? 'Closure' : null);\n\n        if (['Closure', 'fromCallable'] === $definition->getFactory() && ('Closure' !== $class || $definition->isLazy())) {\n            $callable = $parameterBag->unescapeValue($parameterBag->resolveValue($definition->getArgument(0)));\n\n            if ($callable instanceof Reference || $callable instanceof Definition) {\n                $callable = [$callable, '__invoke'];\n            }\n\n            if (\\is_array($callable) && (\n                $callable[0] instanceof Reference\n                || $callable[0] instanceof Definition && !isset($inlineServices[spl_object_hash($callable[0])])\n            )) {\n                $initializer = function () use ($callable, &$inlineServices) {\n                    return $this->doResolveServices($callable[0], $inlineServices);\n                };\n\n                $proxy = eval('return '.LazyClosure::getCode('$initializer', $callable, $definition, $this, $id).';');\n                $this->shareService($definition, $proxy, $id, $inlineServices);\n\n                return $proxy;\n            }\n        }\n\n        if (true === $tryProxy && $definition->isLazy() && ['Closure', 'fromCallable'] !== $definition->getFactory()\n            && !$tryProxy = !($proxy = $this->proxyInstantiator ??= new LazyServiceInstantiator()) || $proxy instanceof RealServiceInstantiator\n        ) {\n            $proxy = $proxy->instantiateProxy(\n                $this,\n                (clone $definition)\n                    ->setClass($class)\n                    ->setTags(($definition->hasTag('proxy') ? ['proxy' => $parameterBag->resolveValue($definition->getTag('proxy'))] : []) + $definition->getTags()),\n                $id, function ($proxy = false) use ($definition, &$inlineServices, $id) {\n                    return $this->createService($definition, $inlineServices, true, $id, $proxy);\n                }\n            );\n            $this->shareService($definition, $proxy, $id, $inlineServices);\n\n            return $proxy;\n        }\n\n        if (null !== $definition->getFile()) {\n            require_once $parameterBag->resolveValue($definition->getFile());\n        }\n\n        $arguments = $definition->getArguments();\n\n        if (null !== $factory = $definition->getFactory()) {\n            if (\\is_array($factory)) {\n                $factory = [$this->doResolveServices($parameterBag->resolveValue($factory[0]), $inlineServices, $isConstructorArgument), $factory[1]];\n            } elseif (!\\is_string($factory)) {\n                throw new RuntimeException(\\sprintf('Cannot create service \"%s\" because of invalid factory.', $id));\n            } elseif (str_starts_with($factory, '@=')) {\n                $factory = fn (ServiceLocator $arguments) => $this->getExpressionLanguage()->evaluate(substr($factory, 2), ['container' => $this, 'args' => $arguments]);\n                $arguments = [new ServiceLocatorArgument($arguments)];\n            }\n        }\n\n        $arguments = $this->doResolveServices($parameterBag->unescapeValue($parameterBag->resolveValue($arguments)), $inlineServices, $isConstructorArgument);\n\n        if (null !== $id && $definition->isShared() && (isset($this->services[$id]) || isset($this->privates[$id])) && (true === $tryProxy || !$definition->isLazy())) {\n            return $this->services[$id] ?? $this->privates[$id];\n        }\n\n        if (!array_is_list($arguments)) {\n            $arguments = array_combine(array_map(fn ($k) => preg_replace('/^.*\\\\$/', '', $k), array_keys($arguments)), $arguments);\n        }\n\n        if (null !== $factory) {\n            $service = $factory(...$arguments);\n\n            if (!$definition->isDeprecated() && \\is_array($factory) && \\is_string($factory[0])) {\n                $r = new \\ReflectionClass($factory[0]);\n\n                if (0 < strpos($r->getDocComment(), \"\\n * @deprecated \")) {\n                    trigger_deprecation('', '', 'The \"%s\" service relies on the deprecated \"%s\" factory class. It should either be deprecated or its factory upgraded.', $id, $r->name);\n                }\n            }\n        } else {\n            $r = new \\ReflectionClass($class);\n\n            if (\\is_object($tryProxy)) {\n                if ($r->getConstructor()) {\n                    $tryProxy->__construct(...$arguments);\n                }\n\n                $service = $tryProxy;\n            } else {\n                $service = $r->getConstructor() ? $r->newInstanceArgs($arguments) : $r->newInstance();\n            }\n\n            if (!$definition->isDeprecated() && 0 < strpos($r->getDocComment(), \"\\n * @deprecated \")) {\n                trigger_deprecation('', '', 'The \"%s\" service relies on the deprecated \"%s\" class. It should either be deprecated or its implementation upgraded.', $id, $r->name);\n            }\n        }\n\n        $lastWitherIndex = null;\n        foreach ($definition->getMethodCalls() as $k => $call) {\n            if ($call[2] ?? false) {\n                $lastWitherIndex = $k;\n            }\n        }\n\n        if (null === $lastWitherIndex && (true === $tryProxy || !$definition->isLazy())) {\n            // share only if proxying failed, or if not a proxy, and if no withers are found\n            $this->shareService($definition, $service, $id, $inlineServices);\n        }\n\n        $properties = $this->doResolveServices($parameterBag->unescapeValue($parameterBag->resolveValue($definition->getProperties())), $inlineServices);\n        foreach ($properties as $name => $value) {\n            $service->$name = $value;\n        }\n\n        foreach ($definition->getMethodCalls() as $k => $call) {\n            $service = $this->callMethod($service, $call, $inlineServices);\n\n            if ($lastWitherIndex === $k && (true === $tryProxy || !$definition->isLazy())) {\n                // share only if proxying failed, or if not a proxy, and this is the last wither\n                $this->shareService($definition, $service, $id, $inlineServices);\n            }\n        }\n\n        if ($callable = $definition->getConfigurator()) {\n            if (\\is_array($callable)) {\n                $callable[0] = $parameterBag->resolveValue($callable[0]);\n\n                if ($callable[0] instanceof Reference) {\n                    $callable[0] = $this->doGet((string) $callable[0], $callable[0]->getInvalidBehavior(), $inlineServices);\n                } elseif ($callable[0] instanceof Definition) {\n                    $callable[0] = $this->createService($callable[0], $inlineServices);\n                }\n            }\n\n            if (!\\is_callable($callable)) {\n                throw new InvalidArgumentException(\\sprintf('The configure callable for class \"%s\" is not a callable.', get_debug_type($service)));\n            }\n\n            $callable($service);\n        }\n\n        return $service;\n    }\n\n    /**\n     * Replaces service references by the real service instance and evaluates expressions.\n     *\n     * @return mixed The same value with all service references replaced by\n     *               the real service instances and all expressions evaluated\n     */\n    public function resolveServices(mixed $value): mixed\n    {\n        return $this->doResolveServices($value);\n    }\n\n    private function doResolveServices(mixed $value, array &$inlineServices = [], bool $isConstructorArgument = false): mixed\n    {\n        if (\\is_array($value)) {\n            foreach ($value as $k => $v) {\n                $value[$k] = $this->doResolveServices($v, $inlineServices, $isConstructorArgument);\n            }\n        } elseif ($value instanceof ServiceClosureArgument) {\n            $reference = $value->getValues()[0];\n            $value = fn () => $this->resolveServices($reference);\n        } elseif ($value instanceof IteratorArgument) {\n            $value = new RewindableGenerator(function () use ($value, &$inlineServices) {\n                foreach ($value->getValues() as $k => $v) {\n                    foreach (self::getServiceConditionals($v) as $s) {\n                        if (!$this->has($s)) {\n                            continue 2;\n                        }\n                    }\n                    foreach (self::getInitializedConditionals($v) as $s) {\n                        if (!$this->doGet($s, ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE, $inlineServices)) {\n                            continue 2;\n                        }\n                    }\n\n                    yield $k => $this->doResolveServices($v, $inlineServices);\n                }\n            }, function () use ($value): int {\n                $count = 0;\n                foreach ($value->getValues() as $v) {\n                    foreach (self::getServiceConditionals($v) as $s) {\n                        if (!$this->has($s)) {\n                            continue 2;\n                        }\n                    }\n                    foreach (self::getInitializedConditionals($v) as $s) {\n                        if (!$this->doGet($s, ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE)) {\n                            continue 2;\n                        }\n                    }\n\n                    ++$count;\n                }\n\n                return $count;\n            });\n        } elseif ($value instanceof ServiceLocatorArgument) {\n            $refs = $types = [];\n            foreach ($value->getValues() as $k => $v) {\n                $refs[$k] = [$v, null];\n                $types[$k] = $v instanceof TypedReference ? $v->getType() : '?';\n            }\n            $value = new ServiceLocator($this->resolveServices(...), $refs, $types);\n        } elseif ($value instanceof Reference) {\n            $value = $this->doGet((string) $value, $value->getInvalidBehavior(), $inlineServices, $isConstructorArgument);\n        } elseif ($value instanceof Definition) {\n            $value = $this->createService($value, $inlineServices, $isConstructorArgument);\n        } elseif ($value instanceof Parameter) {\n            $value = $this->getParameter((string) $value);\n        } elseif ($value instanceof Expression) {\n            $value = $this->getExpressionLanguage()->evaluate($value, ['container' => $this]);\n        } elseif ($value instanceof AbstractArgument) {\n            throw new RuntimeException($value->getTextWithContext());\n        }\n\n        return $value;\n    }\n\n    /**\n     * Returns service ids for a given tag.\n     *\n     * Example:\n     *\n     *     $container->register('foo')->addTag('my.tag', ['hello' => 'world']);\n     *\n     *     $serviceIds = $container->findTaggedServiceIds('my.tag');\n     *     foreach ($serviceIds as $serviceId => $tags) {\n     *         foreach ($tags as $tag) {\n     *             echo $tag['hello'];\n     *         }\n     *     }\n     *\n     * @return array<string, array> An array of tags with the tagged service as key, holding a list of attribute arrays\n     */\n    public function findTaggedServiceIds(string $name, bool $throwOnAbstract = false): array\n    {\n        $this->usedTags[] = $name;\n        $tags = [];\n        foreach ($this->getDefinitions() as $id => $definition) {\n            if ($definition->hasTag($name) && !$definition->hasTag('container.excluded')) {\n                if ($throwOnAbstract && $definition->isAbstract()) {\n                    throw new InvalidArgumentException(\\sprintf('The service \"%s\" tagged \"%s\" must not be abstract.', $id, $name));\n                }\n                $tags[$id] = $definition->getTag($name);\n            }\n        }\n\n        return $tags;\n    }\n\n    /**\n     * Returns all tags the defined services use.\n     *\n     * @return string[]\n     */\n    public function findTags(): array\n    {\n        $tags = [];\n        foreach ($this->getDefinitions() as $id => $definition) {\n            $tags[] = array_keys($definition->getTags());\n        }\n\n        return array_unique(array_merge([], ...$tags));\n    }\n\n    /**\n     * Returns all tags not queried by findTaggedServiceIds.\n     *\n     * @return string[]\n     */\n    public function findUnusedTags(): array\n    {\n        return array_values(array_diff($this->findTags(), $this->usedTags));\n    }\n\n    public function addExpressionLanguageProvider(ExpressionFunctionProviderInterface $provider): void\n    {\n        $this->expressionLanguageProviders[] = $provider;\n    }\n\n    /**\n     * @return ExpressionFunctionProviderInterface[]\n     */\n    public function getExpressionLanguageProviders(): array\n    {\n        return $this->expressionLanguageProviders;\n    }\n\n    /**\n     * Returns a ChildDefinition that will be used for autoconfiguring the interface/class.\n     */\n    public function registerForAutoconfiguration(string $interface): ChildDefinition\n    {\n        if (!isset($this->autoconfiguredInstanceof[$interface])) {\n            $this->autoconfiguredInstanceof[$interface] = new ChildDefinition('');\n        }\n\n        return $this->autoconfiguredInstanceof[$interface];\n    }\n\n    /**\n     * Registers an attribute that will be used for autoconfiguring annotated classes.\n     *\n     * The third argument passed to the callable is the reflector of the\n     * class/method/property/parameter that the attribute targets. Using one or many of\n     * \\ReflectionClass|\\ReflectionMethod|\\ReflectionProperty|\\ReflectionParameter as a type-hint\n     * for this argument allows filtering which attributes should be passed to the callable.\n     *\n     * @template T\n     *\n     * @param class-string<T>                                $attributeClass\n     * @param callable(ChildDefinition, T, \\Reflector): void $configurator\n     */\n    public function registerAttributeForAutoconfiguration(string $attributeClass, callable $configurator): void\n    {\n        $this->autoconfiguredAttributes[$attributeClass] = $configurator;\n    }\n\n    /**\n     * Registers an autowiring alias that only binds to a specific argument name.\n     *\n     * The argument name is derived from $name if provided (from $id otherwise)\n     * using camel case: \"foo.bar\" or \"foo_bar\" creates an alias bound to\n     * \"$fooBar\"-named arguments with $type as type-hint. Such arguments will\n     * receive the service $id when autowiring is used.\n     */\n    public function registerAliasForArgument(string $id, string $type, ?string $name = null): Alias\n    {\n        $parsedName = (new Target($name ??= $id))->getParsedName();\n\n        if (!preg_match('/^[a-zA-Z_\\x7f-\\xff]/', $parsedName)) {\n            if ($id !== $name) {\n                $id = \\sprintf(' for service \"%s\"', $id);\n            }\n\n            throw new InvalidArgumentException(\\sprintf('Invalid argument name \"%s\"'.$id.': the first character must be a letter.', $name));\n        }\n\n        if ($parsedName !== $name) {\n            $this->setAlias('.'.$type.' $'.$name, $type.' $'.$parsedName);\n        }\n\n        return $this->setAlias($type.' $'.$parsedName, $id);\n    }\n\n    /**\n     * Returns an array of ChildDefinition[] keyed by interface.\n     *\n     * @return array<string, ChildDefinition>\n     */\n    public function getAutoconfiguredInstanceof(): array\n    {\n        return $this->autoconfiguredInstanceof;\n    }\n\n    /**\n     * @return array<string, callable>\n     */\n    public function getAutoconfiguredAttributes(): array\n    {\n        return $this->autoconfiguredAttributes;\n    }\n\n    /**\n     * Resolves env parameter placeholders in a string or an array.\n     *\n     * @param string|true|null $format    A sprintf() format returning the replacement for each env var name or\n     *                                    null to resolve back to the original \"%env(VAR)%\" format or\n     *                                    true to resolve to the actual values of the referenced env vars\n     * @param array            &$usedEnvs Env vars found while resolving are added to this array\n     *\n     * @return mixed The value with env parameters resolved if a string or an array is passed\n     */\n    public function resolveEnvPlaceholders(mixed $value, string|bool|null $format = null, ?array &$usedEnvs = null): mixed\n    {\n        $bag = $this->getParameterBag();\n        if (true === $format ??= '%%env(%s)%%') {\n            $value = $bag->resolveValue($value);\n        }\n\n        if ($value instanceof Definition) {\n            $value = (array) $value;\n        }\n\n        if (\\is_array($value)) {\n            $result = [];\n            foreach ($value as $k => $v) {\n                $result[\\is_string($k) ? $this->resolveEnvPlaceholders($k, $format, $usedEnvs) : $k] = $this->resolveEnvPlaceholders($v, $format, $usedEnvs);\n            }\n\n            return $result;\n        }\n\n        if (!\\is_string($value) || 38 > \\strlen($value) || false === stripos($value, 'env_')) {\n            return $value;\n        }\n        $envPlaceholders = $bag instanceof EnvPlaceholderParameterBag ? $bag->getEnvPlaceholders() : $this->envPlaceholders;\n\n        $completed = false;\n        preg_match_all('/env_[a-f0-9]{16}_\\w+_[a-f0-9]{32}/Ui', $value, $matches);\n        $usedPlaceholders = array_flip($matches[0]);\n        foreach ($envPlaceholders as $env => $placeholders) {\n            foreach ($placeholders as $placeholder) {\n                if (isset($usedPlaceholders[$placeholder])) {\n                    if (true === $format) {\n                        $resolved = $bag->escapeValue($this->getEnv($env));\n                    } else {\n                        $resolved = \\sprintf($format, $env);\n                    }\n                    if ($placeholder === $value) {\n                        $value = $resolved;\n                        $completed = true;\n                    } else {\n                        if (!\\is_string($resolved) && !is_numeric($resolved)) {\n                            throw new RuntimeException(\\sprintf('A string value must be composed of strings and/or numbers, but found parameter \"env(%s)\" of type \"%s\" inside string value \"%s\".', $env, get_debug_type($resolved), $this->resolveEnvPlaceholders($value)));\n                        }\n                        $value = str_ireplace($placeholder, $resolved, $value);\n                    }\n                    $usedEnvs[$env] = $env;\n                    $this->envCounters[$env] = isset($this->envCounters[$env]) ? 1 + $this->envCounters[$env] : 1;\n\n                    if ($completed) {\n                        break 2;\n                    }\n                }\n            }\n        }\n\n        return $value;\n    }\n\n    /**\n     * Get statistics about env usage.\n     *\n     * @return int[] The number of time each env vars has been resolved\n     */\n    public function getEnvCounters(): array\n    {\n        $bag = $this->getParameterBag();\n        $envPlaceholders = $bag instanceof EnvPlaceholderParameterBag ? $bag->getEnvPlaceholders() : $this->envPlaceholders;\n\n        foreach ($envPlaceholders as $env => $placeholders) {\n            if (!isset($this->envCounters[$env])) {\n                $this->envCounters[$env] = 0;\n            }\n        }\n\n        return $this->envCounters;\n    }\n\n    /**\n     * @final\n     */\n    public function log(CompilerPassInterface $pass, string $message): void\n    {\n        $this->getCompiler()->log($pass, $this->resolveEnvPlaceholders($message));\n    }\n\n    /**\n     * Checks whether a class is available and will remain available in the \"no-dev\" mode of Composer.\n     *\n     * When parent packages are provided and if any of them is in dev-only mode,\n     * the class will be considered available even if it is also in dev-only mode.\n     *\n     * @throws \\LogicException If dependencies have been installed with Composer 1\n     */\n    final public static function willBeAvailable(string $package, string $class, array $parentPackages): bool\n    {\n        if (!class_exists(InstalledVersions::class)) {\n            throw new \\LogicException(\\sprintf('Calling \"%s\" when dependencies have been installed with Composer 1 is not supported. Consider upgrading to Composer 2.', __METHOD__));\n        }\n\n        if (!class_exists($class) && !interface_exists($class, false) && !trait_exists($class, false)) {\n            return false;\n        }\n\n        if (!InstalledVersions::isInstalled($package) || InstalledVersions::isInstalled($package, false)) {\n            return true;\n        }\n\n        // the package is installed but in dev-mode only, check if this applies to one of the parent packages too\n\n        $rootPackage = InstalledVersions::getRootPackage()['name'] ?? '';\n\n        if ('symfony/symfony' === $rootPackage) {\n            return true;\n        }\n\n        foreach ($parentPackages as $parentPackage) {\n            if ($rootPackage === $parentPackage || (InstalledVersions::isInstalled($parentPackage) && !InstalledVersions::isInstalled($parentPackage, false))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Gets removed binding ids.\n     *\n     * @return array<int, bool>\n     *\n     * @internal\n     */\n    public function getRemovedBindingIds(): array\n    {\n        return $this->removedBindingIds;\n    }\n\n    /**\n     * Removes bindings for a service.\n     *\n     * @internal\n     */\n    public function removeBindings(string $id): void\n    {\n        if ($this->hasDefinition($id)) {\n            foreach ($this->getDefinition($id)->getBindings() as $key => $binding) {\n                [, $bindingId] = $binding->getValues();\n                $this->removedBindingIds[(int) $bindingId] = true;\n            }\n        }\n    }\n\n    /**\n     * @return string[]\n     *\n     * @internal\n     */\n    public static function getServiceConditionals(mixed $value): array\n    {\n        $services = [];\n\n        if (\\is_array($value)) {\n            foreach ($value as $v) {\n                $services = array_unique(array_merge($services, self::getServiceConditionals($v)));\n            }\n        } elseif ($value instanceof Reference && ContainerInterface::IGNORE_ON_INVALID_REFERENCE === $value->getInvalidBehavior()) {\n            $services[] = (string) $value;\n        }\n\n        return $services;\n    }\n\n    /**\n     * @return string[]\n     *\n     * @internal\n     */\n    public static function getInitializedConditionals(mixed $value): array\n    {\n        $services = [];\n\n        if (\\is_array($value)) {\n            foreach ($value as $v) {\n                $services = array_unique(array_merge($services, self::getInitializedConditionals($v)));\n            }\n        } elseif ($value instanceof Reference && ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE === $value->getInvalidBehavior()) {\n            $services[] = (string) $value;\n        }\n\n        return $services;\n    }\n\n    /**\n     * Computes a reasonably unique hash of a serializable value.\n     */\n    public static function hash(mixed $value): string\n    {\n        $hash = substr(base64_encode(hash('xxh128', serialize($value), true)), 0, 7);\n\n        return str_replace(['/', '+'], ['.', '_'], $hash);\n    }\n\n    protected function getEnv(string $name): mixed\n    {\n        $value = parent::getEnv($name);\n        $bag = $this->getParameterBag();\n\n        if (!\\is_string($value) || !$bag instanceof EnvPlaceholderParameterBag) {\n            return $value;\n        }\n\n        $envPlaceholders = $bag->getEnvPlaceholders();\n        if (isset($envPlaceholders[$name][$value])) {\n            $bag = new ParameterBag($bag->all());\n\n            return $bag->unescapeValue($bag->get(\"env($name)\"));\n        }\n        foreach ($envPlaceholders as $env => $placeholders) {\n            if (isset($placeholders[$value])) {\n                return $this->getEnv($env);\n            }\n        }\n\n        $this->resolving[\"env($name)\"] = true;\n        try {\n            return $bag->unescapeValue($this->resolveEnvPlaceholders($bag->escapeValue($value), true));\n        } finally {\n            unset($this->resolving[\"env($name)\"]);\n        }\n    }\n\n    private function callMethod(object $service, array $call, array &$inlineServices): mixed\n    {\n        foreach (self::getServiceConditionals($call[1]) as $s) {\n            if (!$this->has($s)) {\n                return $service;\n            }\n        }\n        foreach (self::getInitializedConditionals($call[1]) as $s) {\n            if (!$this->doGet($s, ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE, $inlineServices)) {\n                return $service;\n            }\n        }\n\n        $result = $service->{$call[0]}(...$this->doResolveServices($this->getParameterBag()->unescapeValue($this->getParameterBag()->resolveValue($call[1])), $inlineServices));\n\n        return empty($call[2]) ? $service : $result;\n    }\n\n    private function shareService(Definition $definition, mixed $service, ?string $id, array &$inlineServices): void\n    {\n        $inlineServices[$id ?? spl_object_hash($definition)] = $service;\n\n        if (null !== $id && $definition->isShared()) {\n            if ($definition->isPrivate() && $this->isCompiled()) {\n                $this->privates[$id] = $service;\n            } else {\n                $this->services[$id] = $service;\n            }\n            unset($this->loading[$id]);\n        }\n    }\n\n    private function getExpressionLanguage(): ExpressionLanguage\n    {\n        if (!isset($this->expressionLanguage)) {\n            if (!class_exists(Expression::class)) {\n                throw new LogicException('Expressions cannot be used without the ExpressionLanguage component. Try running \"composer require symfony/expression-language\".');\n            }\n            $this->expressionLanguage = new ExpressionLanguage(null, $this->expressionLanguageProviders, null, $this->getEnv(...));\n        }\n\n        return $this->expressionLanguage;\n    }\n\n    private function inVendors(string $path): bool\n    {\n        $path = is_file($path) ? \\dirname($path) : $path;\n\n        if (isset($this->pathsInVendor[$path])) {\n            return $this->pathsInVendor[$path];\n        }\n\n        $this->vendors ??= (new ComposerResource())->getVendors();\n        $path = realpath($path) ?: $path;\n\n        if (isset($this->pathsInVendor[$path])) {\n            return $this->pathsInVendor[$path];\n        }\n\n        foreach ($this->vendors as $vendor) {\n            if (\\in_array($path[\\strlen($vendor)] ?? '', ['/', \\DIRECTORY_SEPARATOR], true) && str_starts_with($path, $vendor)) {\n                $this->pathsInVendor[$vendor.\\DIRECTORY_SEPARATOR.'composer'] = false;\n                $this->addResource(new FileResource($vendor.\\DIRECTORY_SEPARATOR.'composer'.\\DIRECTORY_SEPARATOR.'installed.json'));\n                $this->pathsInVendor[$vendor.\\DIRECTORY_SEPARATOR.'composer'] = true;\n\n                return $this->pathsInVendor[$path] = true;\n            }\n        }\n\n        return $this->pathsInVendor[$path] = false;\n    }\n}\n"
        },
        {
          "name": "ContainerInterface.php",
          "type": "blob",
          "size": 2.2001953125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Psr\\Container\\ContainerInterface as PsrContainerInterface;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ParameterNotFoundException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ServiceCircularReferenceException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ServiceNotFoundException;\n\n/**\n * ContainerInterface is the interface implemented by service container classes.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n */\ninterface ContainerInterface extends PsrContainerInterface\n{\n    public const RUNTIME_EXCEPTION_ON_INVALID_REFERENCE = 0;\n    public const EXCEPTION_ON_INVALID_REFERENCE = 1;\n    public const NULL_ON_INVALID_REFERENCE = 2;\n    public const IGNORE_ON_INVALID_REFERENCE = 3;\n    public const IGNORE_ON_UNINITIALIZED_REFERENCE = 4;\n\n    public function set(string $id, ?object $service): void;\n\n    /**\n     * @template B of self::*_REFERENCE\n     *\n     * @param B $invalidBehavior\n     *\n     * @psalm-return (B is self::EXCEPTION_ON_INVALID_REFERENCE|self::RUNTIME_EXCEPTION_ON_INVALID_REFERENCE ? object : object|null)\n     *\n     * @throws ServiceCircularReferenceException When a circular reference is detected\n     * @throws ServiceNotFoundException          When the service is not defined\n     *\n     * @see Reference\n     */\n    public function get(string $id, int $invalidBehavior = self::EXCEPTION_ON_INVALID_REFERENCE): ?object;\n\n    public function has(string $id): bool;\n\n    /**\n     * Check for whether or not a service has been initialized.\n     */\n    public function initialized(string $id): bool;\n\n    /**\n     * @throws ParameterNotFoundException if the parameter is not defined\n     */\n    public function getParameter(string $name): array|bool|string|int|float|\\UnitEnum|null;\n\n    public function hasParameter(string $name): bool;\n\n    public function setParameter(string $name, array|bool|string|int|float|\\UnitEnum|null $value): void;\n}\n"
        },
        {
          "name": "Definition.php",
          "type": "blob",
          "size": 19.8544921875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Symfony\\Component\\DependencyInjection\\Argument\\BoundArgument;\nuse Symfony\\Component\\DependencyInjection\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\OutOfBoundsException;\n\n/**\n * Definition represents a service definition.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Definition\n{\n    private const DEFAULT_DEPRECATION_TEMPLATE = 'The \"%service_id%\" service is deprecated. You should stop using it, as it will be removed in the future.';\n\n    private ?string $class = null;\n    private ?string $file = null;\n    private string|array|null $factory = null;\n    private bool $shared = true;\n    private array $deprecation = [];\n    private array $properties = [];\n    private array $calls = [];\n    private array $instanceof = [];\n    private bool $autoconfigured = false;\n    private string|array|null $configurator = null;\n    private array $tags = [];\n    private bool $public = false;\n    private bool $synthetic = false;\n    private bool $abstract = false;\n    private bool $lazy = false;\n    private ?array $decoratedService = null;\n    private bool $autowired = false;\n    private array $changes = [];\n    private array $bindings = [];\n    private array $errors = [];\n\n    protected array $arguments = [];\n\n    /**\n     * @internal\n     *\n     * Used to store the name of the inner id when using service decoration together with autowiring\n     */\n    public ?string $innerServiceId = null;\n\n    /**\n     * @internal\n     *\n     * Used to store the behavior to follow when using service decoration and the decorated service is invalid\n     */\n    public ?int $decorationOnInvalid = null;\n\n    public function __construct(?string $class = null, array $arguments = [])\n    {\n        if (null !== $class) {\n            $this->setClass($class);\n        }\n        $this->arguments = $arguments;\n    }\n\n    /**\n     * Returns all changes tracked for the Definition object.\n     */\n    public function getChanges(): array\n    {\n        return $this->changes;\n    }\n\n    /**\n     * Sets the tracked changes for the Definition object.\n     *\n     * @param array $changes An array of changes for this Definition\n     *\n     * @return $this\n     */\n    public function setChanges(array $changes): static\n    {\n        $this->changes = $changes;\n\n        return $this;\n    }\n\n    /**\n     * Sets a factory.\n     *\n     * @param string|array|Reference|null $factory A PHP function, reference or an array containing a class/Reference and a method to call\n     *\n     * @return $this\n     */\n    public function setFactory(string|array|Reference|null $factory): static\n    {\n        $this->changes['factory'] = true;\n\n        if (\\is_string($factory) && str_contains($factory, '::')) {\n            $factory = explode('::', $factory, 2);\n        } elseif ($factory instanceof Reference) {\n            $factory = [$factory, '__invoke'];\n        }\n\n        $this->factory = $factory;\n\n        return $this;\n    }\n\n    /**\n     * Gets the factory.\n     *\n     * @return string|array|null The PHP function or an array containing a class/Reference and a method to call\n     */\n    public function getFactory(): string|array|null\n    {\n        return $this->factory;\n    }\n\n    /**\n     * Sets the service that this service is decorating.\n     *\n     * @param string|null $id        The decorated service id, use null to remove decoration\n     * @param string|null $renamedId The new decorated service id\n     *\n     * @return $this\n     *\n     * @throws InvalidArgumentException in case the decorated service id and the new decorated service id are equals\n     */\n    public function setDecoratedService(?string $id, ?string $renamedId = null, int $priority = 0, int $invalidBehavior = ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE): static\n    {\n        if ($renamedId && $id === $renamedId) {\n            throw new InvalidArgumentException(\\sprintf('The decorated service inner name for \"%s\" must be different than the service name itself.', $id));\n        }\n\n        $this->changes['decorated_service'] = true;\n\n        if (null === $id) {\n            $this->decoratedService = null;\n        } else {\n            $this->decoratedService = [$id, $renamedId, $priority];\n\n            if (ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE !== $invalidBehavior) {\n                $this->decoratedService[] = $invalidBehavior;\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * Gets the service that this service is decorating.\n     *\n     * @return array|null An array composed of the decorated service id, the new id for it and the priority of decoration, null if no service is decorated\n     */\n    public function getDecoratedService(): ?array\n    {\n        return $this->decoratedService;\n    }\n\n    /**\n     * Sets the service class.\n     *\n     * @return $this\n     */\n    public function setClass(?string $class): static\n    {\n        $this->changes['class'] = true;\n\n        $this->class = $class;\n\n        return $this;\n    }\n\n    /**\n     * Gets the service class.\n     */\n    public function getClass(): ?string\n    {\n        return $this->class;\n    }\n\n    /**\n     * Sets the arguments to pass to the service constructor/factory method.\n     *\n     * @return $this\n     */\n    public function setArguments(array $arguments): static\n    {\n        $this->arguments = $arguments;\n\n        return $this;\n    }\n\n    /**\n     * Sets the properties to define when creating the service.\n     *\n     * @return $this\n     */\n    public function setProperties(array $properties): static\n    {\n        $this->properties = $properties;\n\n        return $this;\n    }\n\n    /**\n     * Gets the properties to define when creating the service.\n     */\n    public function getProperties(): array\n    {\n        return $this->properties;\n    }\n\n    /**\n     * Sets a specific property.\n     *\n     * @return $this\n     */\n    public function setProperty(string $name, mixed $value): static\n    {\n        $this->properties[$name] = $value;\n\n        return $this;\n    }\n\n    /**\n     * Adds an argument to pass to the service constructor/factory method.\n     *\n     * @return $this\n     */\n    public function addArgument(mixed $argument): static\n    {\n        $this->arguments[] = $argument;\n\n        return $this;\n    }\n\n    /**\n     * Replaces a specific argument.\n     *\n     * @return $this\n     *\n     * @throws OutOfBoundsException When the replaced argument does not exist\n     */\n    public function replaceArgument(int|string $index, mixed $argument): static\n    {\n        if (0 === \\count($this->arguments)) {\n            throw new OutOfBoundsException(\\sprintf('Cannot replace arguments for class \"%s\" if none have been configured yet.', $this->class));\n        }\n\n        if (!\\array_key_exists($index, $this->arguments)) {\n            throw new OutOfBoundsException(\\sprintf('The argument \"%s\" doesn\\'t exist in class \"%s\".', $index, $this->class));\n        }\n\n        $this->arguments[$index] = $argument;\n\n        return $this;\n    }\n\n    /**\n     * Sets a specific argument.\n     *\n     * @return $this\n     */\n    public function setArgument(int|string $key, mixed $value): static\n    {\n        $this->arguments[$key] = $value;\n\n        return $this;\n    }\n\n    /**\n     * Gets the arguments to pass to the service constructor/factory method.\n     */\n    public function getArguments(): array\n    {\n        return $this->arguments;\n    }\n\n    /**\n     * Gets an argument to pass to the service constructor/factory method.\n     *\n     * @throws OutOfBoundsException When the argument does not exist\n     */\n    public function getArgument(int|string $index): mixed\n    {\n        if (!\\array_key_exists($index, $this->arguments)) {\n            throw new OutOfBoundsException(\\sprintf('The argument \"%s\" doesn\\'t exist in class \"%s\".', $index, $this->class));\n        }\n\n        return $this->arguments[$index];\n    }\n\n    /**\n     * Sets the methods to call after service initialization.\n     *\n     * @return $this\n     */\n    public function setMethodCalls(array $calls = []): static\n    {\n        $this->calls = [];\n        foreach ($calls as $call) {\n            $this->addMethodCall($call[0], $call[1], $call[2] ?? false);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Adds a method to call after service initialization.\n     *\n     * @param string $method       The method name to call\n     * @param array  $arguments    An array of arguments to pass to the method call\n     * @param bool   $returnsClone Whether the call returns the service instance or not\n     *\n     * @return $this\n     *\n     * @throws InvalidArgumentException on empty $method param\n     */\n    public function addMethodCall(string $method, array $arguments = [], bool $returnsClone = false): static\n    {\n        if (!$method) {\n            throw new InvalidArgumentException('Method name cannot be empty.');\n        }\n        $this->calls[] = $returnsClone ? [$method, $arguments, true] : [$method, $arguments];\n\n        return $this;\n    }\n\n    /**\n     * Removes a method to call after service initialization.\n     *\n     * @return $this\n     */\n    public function removeMethodCall(string $method): static\n    {\n        foreach ($this->calls as $i => $call) {\n            if ($call[0] === $method) {\n                unset($this->calls[$i]);\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * Check if the current definition has a given method to call after service initialization.\n     */\n    public function hasMethodCall(string $method): bool\n    {\n        foreach ($this->calls as $call) {\n            if ($call[0] === $method) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Gets the methods to call after service initialization.\n     */\n    public function getMethodCalls(): array\n    {\n        return $this->calls;\n    }\n\n    /**\n     * Sets the definition templates to conditionally apply on the current definition, keyed by parent interface/class.\n     *\n     * @param ChildDefinition[] $instanceof\n     *\n     * @return $this\n     */\n    public function setInstanceofConditionals(array $instanceof): static\n    {\n        $this->instanceof = $instanceof;\n\n        return $this;\n    }\n\n    /**\n     * Gets the definition templates to conditionally apply on the current definition, keyed by parent interface/class.\n     *\n     * @return ChildDefinition[]\n     */\n    public function getInstanceofConditionals(): array\n    {\n        return $this->instanceof;\n    }\n\n    /**\n     * Sets whether or not instanceof conditionals should be prepended with a global set.\n     *\n     * @return $this\n     */\n    public function setAutoconfigured(bool $autoconfigured): static\n    {\n        $this->changes['autoconfigured'] = true;\n\n        $this->autoconfigured = $autoconfigured;\n\n        return $this;\n    }\n\n    public function isAutoconfigured(): bool\n    {\n        return $this->autoconfigured;\n    }\n\n    /**\n     * Sets tags for this definition.\n     *\n     * @return $this\n     */\n    public function setTags(array $tags): static\n    {\n        $this->tags = $tags;\n\n        return $this;\n    }\n\n    /**\n     * Returns all tags.\n     */\n    public function getTags(): array\n    {\n        return $this->tags;\n    }\n\n    /**\n     * Gets a tag by name.\n     */\n    public function getTag(string $name): array\n    {\n        return $this->tags[$name] ?? [];\n    }\n\n    /**\n     * Adds a tag for this definition.\n     *\n     * @return $this\n     */\n    public function addTag(string $name, array $attributes = []): static\n    {\n        $this->tags[$name][] = $attributes;\n\n        return $this;\n    }\n\n    /**\n     * Whether this definition has a tag with the given name.\n     */\n    public function hasTag(string $name): bool\n    {\n        return isset($this->tags[$name]);\n    }\n\n    /**\n     * Clears all tags for a given name.\n     *\n     * @return $this\n     */\n    public function clearTag(string $name): static\n    {\n        unset($this->tags[$name]);\n\n        return $this;\n    }\n\n    /**\n     * Clears the tags for this definition.\n     *\n     * @return $this\n     */\n    public function clearTags(): static\n    {\n        $this->tags = [];\n\n        return $this;\n    }\n\n    /**\n     * Sets a file to require before creating the service.\n     *\n     * @return $this\n     */\n    public function setFile(?string $file): static\n    {\n        $this->changes['file'] = true;\n\n        $this->file = $file;\n\n        return $this;\n    }\n\n    /**\n     * Gets the file to require before creating the service.\n     */\n    public function getFile(): ?string\n    {\n        return $this->file;\n    }\n\n    /**\n     * Sets if the service must be shared or not.\n     *\n     * @return $this\n     */\n    public function setShared(bool $shared): static\n    {\n        $this->changes['shared'] = true;\n\n        $this->shared = $shared;\n\n        return $this;\n    }\n\n    /**\n     * Whether this service is shared.\n     */\n    public function isShared(): bool\n    {\n        return $this->shared;\n    }\n\n    /**\n     * Sets the visibility of this service.\n     *\n     * @return $this\n     */\n    public function setPublic(bool $boolean): static\n    {\n        $this->changes['public'] = true;\n\n        $this->public = $boolean;\n\n        return $this;\n    }\n\n    /**\n     * Whether this service is public facing.\n     */\n    public function isPublic(): bool\n    {\n        return $this->public;\n    }\n\n    /**\n     * Whether this service is private.\n     */\n    public function isPrivate(): bool\n    {\n        return !$this->public;\n    }\n\n    /**\n     * Sets the lazy flag of this service.\n     *\n     * @return $this\n     */\n    public function setLazy(bool $lazy): static\n    {\n        $this->changes['lazy'] = true;\n\n        $this->lazy = $lazy;\n\n        return $this;\n    }\n\n    /**\n     * Whether this service is lazy.\n     */\n    public function isLazy(): bool\n    {\n        return $this->lazy;\n    }\n\n    /**\n     * Sets whether this definition is synthetic, that is not constructed by the\n     * container, but dynamically injected.\n     *\n     * @return $this\n     */\n    public function setSynthetic(bool $boolean): static\n    {\n        $this->synthetic = $boolean;\n\n        if (!isset($this->changes['public'])) {\n            $this->setPublic(true);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Whether this definition is synthetic, that is not constructed by the\n     * container, but dynamically injected.\n     */\n    public function isSynthetic(): bool\n    {\n        return $this->synthetic;\n    }\n\n    /**\n     * Whether this definition is abstract, that means it merely serves as a\n     * template for other definitions.\n     *\n     * @return $this\n     */\n    public function setAbstract(bool $boolean): static\n    {\n        $this->abstract = $boolean;\n\n        return $this;\n    }\n\n    /**\n     * Whether this definition is abstract, that means it merely serves as a\n     * template for other definitions.\n     */\n    public function isAbstract(): bool\n    {\n        return $this->abstract;\n    }\n\n    /**\n     * Whether this definition is deprecated, that means it should not be called\n     * anymore.\n     *\n     * @param string $package The name of the composer package that is triggering the deprecation\n     * @param string $version The version of the package that introduced the deprecation\n     * @param string $message The deprecation message to use\n     *\n     * @return $this\n     *\n     * @throws InvalidArgumentException when the message template is invalid\n     */\n    public function setDeprecated(string $package, string $version, string $message): static\n    {\n        if ('' !== $message) {\n            if (preg_match('#[\\r\\n]|\\*/#', $message)) {\n                throw new InvalidArgumentException('Invalid characters found in deprecation template.');\n            }\n\n            if (!str_contains($message, '%service_id%')) {\n                throw new InvalidArgumentException('The deprecation template must contain the \"%service_id%\" placeholder.');\n            }\n        }\n\n        $this->changes['deprecated'] = true;\n        $this->deprecation = ['package' => $package, 'version' => $version, 'message' => $message ?: self::DEFAULT_DEPRECATION_TEMPLATE];\n\n        return $this;\n    }\n\n    /**\n     * Whether this definition is deprecated, that means it should not be called\n     * anymore.\n     */\n    public function isDeprecated(): bool\n    {\n        return (bool) $this->deprecation;\n    }\n\n    /**\n     * @param string $id Service id relying on this definition\n     */\n    public function getDeprecation(string $id): array\n    {\n        return [\n            'package' => $this->deprecation['package'],\n            'version' => $this->deprecation['version'],\n            'message' => str_replace('%service_id%', $id, $this->deprecation['message']),\n        ];\n    }\n\n    /**\n     * Sets a configurator to call after the service is fully initialized.\n     *\n     * @param string|array|Reference|null $configurator A PHP function, reference or an array containing a class/Reference and a method to call\n     *\n     * @return $this\n     */\n    public function setConfigurator(string|array|Reference|null $configurator): static\n    {\n        $this->changes['configurator'] = true;\n\n        if (\\is_string($configurator) && str_contains($configurator, '::')) {\n            $configurator = explode('::', $configurator, 2);\n        } elseif ($configurator instanceof Reference) {\n            $configurator = [$configurator, '__invoke'];\n        }\n\n        $this->configurator = $configurator;\n\n        return $this;\n    }\n\n    /**\n     * Gets the configurator to call after the service is fully initialized.\n     */\n    public function getConfigurator(): string|array|null\n    {\n        return $this->configurator;\n    }\n\n    /**\n     * Is the definition autowired?\n     */\n    public function isAutowired(): bool\n    {\n        return $this->autowired;\n    }\n\n    /**\n     * Enables/disables autowiring.\n     *\n     * @return $this\n     */\n    public function setAutowired(bool $autowired): static\n    {\n        $this->changes['autowired'] = true;\n\n        $this->autowired = $autowired;\n\n        return $this;\n    }\n\n    /**\n     * Gets bindings.\n     *\n     * @return BoundArgument[]\n     */\n    public function getBindings(): array\n    {\n        return $this->bindings;\n    }\n\n    /**\n     * Sets bindings.\n     *\n     * Bindings map $named or FQCN arguments to values that should be\n     * injected in the matching parameters (of the constructor, of methods\n     * called and of controller actions).\n     *\n     * @return $this\n     */\n    public function setBindings(array $bindings): static\n    {\n        foreach ($bindings as $key => $binding) {\n            if (0 < strpos($key, '$') && $key !== $k = preg_replace('/[ \\t]*\\$/', ' $', $key)) {\n                unset($bindings[$key]);\n                $bindings[$key = $k] = $binding;\n            }\n            if (!$binding instanceof BoundArgument) {\n                $bindings[$key] = new BoundArgument($binding);\n            }\n        }\n\n        $this->bindings = $bindings;\n\n        return $this;\n    }\n\n    /**\n     * Add an error that occurred when building this Definition.\n     *\n     * @return $this\n     */\n    public function addError(string|\\Closure|self $error): static\n    {\n        if ($error instanceof self) {\n            $this->errors = array_merge($this->errors, $error->errors);\n        } else {\n            $this->errors[] = $error;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns any errors that occurred while building this Definition.\n     */\n    public function getErrors(): array\n    {\n        foreach ($this->errors as $i => $error) {\n            if ($error instanceof \\Closure) {\n                $this->errors[$i] = (string) $error();\n            } elseif (!\\is_string($error)) {\n                $this->errors[$i] = (string) $error;\n            }\n        }\n\n        return $this->errors;\n    }\n\n    public function hasErrors(): bool\n    {\n        return (bool) $this->errors;\n    }\n}\n"
        },
        {
          "name": "Dumper",
          "type": "tree",
          "content": null
        },
        {
          "name": "EnvVarLoaderInterface.php",
          "type": "blob",
          "size": 0.638671875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\n/**\n * EnvVarLoaderInterface objects return key/value pairs that are added to the list of available env vars.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\ninterface EnvVarLoaderInterface\n{\n    /**\n     * @return array<string|\\Stringable> Key/value pairs that can be accessed using the regular \"%env()%\" syntax\n     */\n    public function loadEnvVars(): array;\n}\n"
        },
        {
          "name": "EnvVarProcessor.php",
          "type": "blob",
          "size": 13.9296875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Symfony\\Component\\DependencyInjection\\Exception\\EnvNotFoundException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ParameterCircularReferenceException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\RuntimeException;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass EnvVarProcessor implements EnvVarProcessorInterface, ResetInterface\n{\n    /** @var \\Traversable<EnvVarLoaderInterface> */\n    private \\Traversable $loaders;\n    /** @var \\Traversable<EnvVarLoaderInterface> */\n    private \\Traversable $originalLoaders;\n    private array $loadedVars = [];\n\n    /**\n     * @param \\Traversable<EnvVarLoaderInterface>|null $loaders\n     */\n    public function __construct(\n        private ContainerInterface $container,\n        ?\\Traversable $loaders = null,\n    ) {\n        $this->originalLoaders = $this->loaders = $loaders ?? new \\ArrayIterator();\n    }\n\n    public static function getProvidedTypes(): array\n    {\n        return [\n            'base64' => 'string',\n            'bool' => 'bool',\n            'not' => 'bool',\n            'const' => 'bool|int|float|string|array',\n            'csv' => 'array',\n            'file' => 'string',\n            'float' => 'float',\n            'int' => 'int',\n            'json' => 'array',\n            'key' => 'bool|int|float|string|array',\n            'url' => 'array',\n            'query_string' => 'array',\n            'resolve' => 'string',\n            'default' => 'bool|int|float|string|array',\n            'string' => 'string',\n            'trim' => 'string',\n            'require' => 'bool|int|float|string|array',\n            'enum' => \\BackedEnum::class,\n            'shuffle' => 'array',\n            'defined' => 'bool',\n            'urlencode' => 'string',\n        ];\n    }\n\n    public function getEnv(string $prefix, string $name, \\Closure $getEnv): mixed\n    {\n        $i = strpos($name, ':');\n\n        if ('key' === $prefix) {\n            if (false === $i) {\n                throw new RuntimeException(\\sprintf('Invalid env \"key:%s\": a key specifier should be provided.', $name));\n            }\n\n            $next = substr($name, $i + 1);\n            $key = substr($name, 0, $i);\n            $array = $getEnv($next);\n\n            if (!\\is_array($array)) {\n                throw new RuntimeException(\\sprintf('Resolved value of \"%s\" did not result in an array value.', $next));\n            }\n\n            if (!isset($array[$key]) && !\\array_key_exists($key, $array)) {\n                throw new EnvNotFoundException(\\sprintf('Key \"%s\" not found in %s (resolved from \"%s\").', $key, json_encode($array), $next));\n            }\n\n            return $array[$key];\n        }\n\n        if ('enum' === $prefix) {\n            if (false === $i) {\n                throw new RuntimeException(\\sprintf('Invalid env \"enum:%s\": a \"%s\" class-string should be provided.', $name, \\BackedEnum::class));\n            }\n\n            $next = substr($name, $i + 1);\n            $backedEnumClassName = substr($name, 0, $i);\n            $backedEnumValue = $getEnv($next);\n\n            if (!\\is_string($backedEnumValue) && !\\is_int($backedEnumValue)) {\n                throw new RuntimeException(\\sprintf('Resolved value of \"%s\" did not result in a string or int value.', $next));\n            }\n\n            if (!is_subclass_of($backedEnumClassName, \\BackedEnum::class)) {\n                throw new RuntimeException(\\sprintf('\"%s\" is not a \"%s\".', $backedEnumClassName, \\BackedEnum::class));\n            }\n\n            return $backedEnumClassName::tryFrom($backedEnumValue) ?? throw new RuntimeException(\\sprintf('Enum value \"%s\" is not backed by \"%s\".', $backedEnumValue, $backedEnumClassName));\n        }\n\n        if ('defined' === $prefix) {\n            try {\n                return '' !== ($getEnv($name) ?? '');\n            } catch (EnvNotFoundException) {\n                return false;\n            }\n        }\n\n        if ('default' === $prefix) {\n            if (false === $i) {\n                throw new RuntimeException(\\sprintf('Invalid env \"default:%s\": a fallback parameter should be provided.', $name));\n            }\n\n            $next = substr($name, $i + 1);\n            $default = substr($name, 0, $i);\n\n            if ('' !== $default && !$this->container->hasParameter($default)) {\n                throw new RuntimeException(\\sprintf('Invalid env fallback in \"default:%s\": parameter \"%s\" not found.', $name, $default));\n            }\n\n            try {\n                $env = $getEnv($next);\n\n                if ('' !== $env && null !== $env) {\n                    return $env;\n                }\n            } catch (EnvNotFoundException) {\n                // no-op\n            }\n\n            return '' === $default ? null : $this->container->getParameter($default);\n        }\n\n        if ('file' === $prefix || 'require' === $prefix) {\n            if (!\\is_scalar($file = $getEnv($name))) {\n                throw new RuntimeException(\\sprintf('Invalid file name: env var \"%s\" is non-scalar.', $name));\n            }\n            if (!is_file($file)) {\n                throw new EnvNotFoundException(\\sprintf('File \"%s\" not found (resolved from \"%s\").', $file, $name));\n            }\n\n            if ('file' === $prefix) {\n                return file_get_contents($file);\n            }\n\n            return require $file;\n        }\n\n        $returnNull = false;\n        if ('' === $prefix) {\n            if ('' === $name) {\n                return null;\n            }\n            $returnNull = true;\n            $prefix = 'string';\n        }\n\n        if (false !== $i || 'string' !== $prefix) {\n            $env = $getEnv($name);\n        } elseif ('' === ($env = $_ENV[$name] ?? (str_starts_with($name, 'HTTP_') ? null : ($_SERVER[$name] ?? null)))\n            || (false !== $env && false === $env ??= getenv($name) ?? false) // null is a possible value because of thread safety issues\n        ) {\n            foreach ($this->loadedVars as $i => $vars) {\n                if (false === $env = $vars[$name] ?? $env) {\n                    continue;\n                }\n                if ($env instanceof \\Stringable) {\n                    $this->loadedVars[$i][$name] = $env = (string) $env;\n                }\n                if ('' !== ($env ?? '')) {\n                    break;\n                }\n            }\n\n            if (false === $env || '' === $env) {\n                $loaders = $this->loaders;\n                $this->loaders = new \\ArrayIterator();\n\n                try {\n                    $i = 0;\n                    $ended = true;\n                    $count = $loaders instanceof \\Countable ? $loaders->count() : 0;\n                    foreach ($loaders as $loader) {\n                        if (\\count($this->loadedVars) > $i++) {\n                            continue;\n                        }\n                        $this->loadedVars[] = $vars = $loader->loadEnvVars();\n                        if (false === $env = $vars[$name] ?? $env) {\n                            continue;\n                        }\n                        if ($env instanceof \\Stringable) {\n                            $this->loadedVars[array_key_last($this->loadedVars)][$name] = $env = (string) $env;\n                        }\n                        if ('' !== ($env ?? '')) {\n                            $ended = false;\n                            break;\n                        }\n                    }\n                    if ($ended || $count === $i) {\n                        $loaders = $this->loaders;\n                    }\n                } catch (ParameterCircularReferenceException) {\n                    // skip loaders that need an env var that is not defined\n                } finally {\n                    $this->loaders = $loaders;\n                }\n            }\n\n            if (false === $env) {\n                if (!$this->container->hasParameter(\"env($name)\")) {\n                    throw new EnvNotFoundException(\\sprintf('Environment variable not found: \"%s\".', $name));\n                }\n\n                $env = $this->container->getParameter(\"env($name)\");\n            }\n        }\n\n        if (null === $env) {\n            if ($returnNull) {\n                return null;\n            }\n\n            if (!isset(static::getProvidedTypes()[$prefix])) {\n                throw new RuntimeException(\\sprintf('Unsupported env var prefix \"%s\".', $prefix));\n            }\n\n            if (!\\in_array($prefix, ['string', 'bool', 'not', 'int', 'float'], true)) {\n                return null;\n            }\n        }\n\n        if ('shuffle' === $prefix) {\n            \\is_array($env) ? shuffle($env) : throw new RuntimeException(\\sprintf('Env var \"%s\" cannot be shuffled, expected array, got \"%s\".', $name, get_debug_type($env)));\n\n            return $env;\n        }\n\n        if (null !== $env && !\\is_scalar($env)) {\n            throw new RuntimeException(\\sprintf('Non-scalar env var \"%s\" cannot be cast to \"%s\".', $name, $prefix));\n        }\n\n        if ('string' === $prefix) {\n            return (string) $env;\n        }\n\n        if (\\in_array($prefix, ['bool', 'not'], true)) {\n            $env = (bool) (filter_var($env, \\FILTER_VALIDATE_BOOL) ?: filter_var($env, \\FILTER_VALIDATE_INT) ?: filter_var($env, \\FILTER_VALIDATE_FLOAT));\n\n            return 'not' === $prefix xor $env;\n        }\n\n        if ('int' === $prefix) {\n            if (null !== $env && false === $env = filter_var($env, \\FILTER_VALIDATE_INT) ?: filter_var($env, \\FILTER_VALIDATE_FLOAT)) {\n                throw new RuntimeException(\\sprintf('Non-numeric env var \"%s\" cannot be cast to int.', $name));\n            }\n\n            return (int) $env;\n        }\n\n        if ('float' === $prefix) {\n            if (null !== $env && false === $env = filter_var($env, \\FILTER_VALIDATE_FLOAT)) {\n                throw new RuntimeException(\\sprintf('Non-numeric env var \"%s\" cannot be cast to float.', $name));\n            }\n\n            return (float) $env;\n        }\n\n        if ('const' === $prefix) {\n            if (!\\defined($env)) {\n                throw new RuntimeException(\\sprintf('Env var \"%s\" maps to undefined constant \"%s\".', $name, $env));\n            }\n\n            return \\constant($env);\n        }\n\n        if ('base64' === $prefix) {\n            return base64_decode(strtr($env, '-_', '+/'));\n        }\n\n        if ('json' === $prefix) {\n            $env = json_decode($env, true);\n\n            if (\\JSON_ERROR_NONE !== json_last_error()) {\n                throw new RuntimeException(\\sprintf('Invalid JSON in env var \"%s\": ', $name).json_last_error_msg());\n            }\n\n            if (null !== $env && !\\is_array($env)) {\n                throw new RuntimeException(\\sprintf('Invalid JSON env var \"%s\": array or null expected, \"%s\" given.', $name, get_debug_type($env)));\n            }\n\n            return $env;\n        }\n\n        if ('url' === $prefix) {\n            $params = parse_url($env);\n\n            if (false === $params) {\n                throw new RuntimeException(\\sprintf('Invalid URL in env var \"%s\".', $name));\n            }\n            if (!isset($params['scheme'], $params['host'])) {\n                throw new RuntimeException(\\sprintf('Invalid URL in env var \"%s\": scheme and host expected.', $name));\n            }\n            if (('\\\\' !== \\DIRECTORY_SEPARATOR || 'file' !== $params['scheme']) && false !== ($i = strpos($env, '\\\\')) && $i < strcspn($env, '?#')) {\n                throw new RuntimeException(\\sprintf('Invalid URL in env var \"%s\": backslashes are not allowed.', $name));\n            }\n            if (\\ord($env[0]) <= 32 || \\ord($env[-1]) <= 32 || \\strlen($env) !== strcspn($env, \"\\r\\n\\t\")) {\n                throw new RuntimeException(\\sprintf('Invalid URL in env var \"%s\": leading/trailing ASCII control characters or whitespaces are not allowed.', $name));\n            }\n            $params += [\n                'port' => null,\n                'user' => null,\n                'pass' => null,\n                'path' => null,\n                'query' => null,\n                'fragment' => null,\n            ];\n\n            $params['user'] = null !== $params['user'] ? rawurldecode($params['user']) : null;\n            $params['pass'] = null !== $params['pass'] ? rawurldecode($params['pass']) : null;\n\n            // remove the '/' separator\n            $params['path'] = '/' === ($params['path'] ?? '/') ? '' : substr($params['path'], 1);\n\n            return $params;\n        }\n\n        if ('query_string' === $prefix) {\n            $queryString = parse_url($env, \\PHP_URL_QUERY) ?: $env;\n            parse_str($queryString, $result);\n\n            return $result;\n        }\n\n        if ('resolve' === $prefix) {\n            return preg_replace_callback('/%%|%([^%\\s]+)%/', function ($match) use ($name, $getEnv) {\n                if (!isset($match[1])) {\n                    return '%';\n                }\n\n                if (str_starts_with($match[1], 'env(') && str_ends_with($match[1], ')') && 'env()' !== $match[1]) {\n                    $value = $getEnv(substr($match[1], 4, -1));\n                } else {\n                    $value = $this->container->getParameter($match[1]);\n                }\n\n                if (!\\is_scalar($value)) {\n                    throw new RuntimeException(\\sprintf('Parameter \"%s\" found when resolving env var \"%s\" must be scalar, \"%s\" given.', $match[1], $name, get_debug_type($value)));\n                }\n\n                return $value;\n            }, $env);\n        }\n\n        if ('csv' === $prefix) {\n            return '' === $env ? [] : str_getcsv($env, ',', '\"', '');\n        }\n\n        if ('trim' === $prefix) {\n            return trim($env);\n        }\n\n        if ('urlencode' === $prefix) {\n            return rawurlencode($env);\n        }\n\n        throw new RuntimeException(\\sprintf('Unsupported env var prefix \"%s\" for env name \"%s\".', $prefix, $name));\n    }\n\n    public function reset(): void\n    {\n        $this->loadedVars = [];\n        $this->loaders = $this->originalLoaders;\n    }\n}\n"
        },
        {
          "name": "EnvVarProcessorInterface.php",
          "type": "blob",
          "size": 1.2431640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Symfony\\Component\\DependencyInjection\\Exception\\RuntimeException;\n\n/**\n * The EnvVarProcessorInterface is implemented by objects that manage environment-like variables.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\ninterface EnvVarProcessorInterface\n{\n    /**\n     * Returns the value of the given variable as managed by the current instance.\n     *\n     * @param string                  $prefix The namespace of the variable; when the empty string is passed, null values should be kept as is\n     * @param string                  $name   The name of the variable within the namespace\n     * @param \\Closure(string): mixed $getEnv A closure that allows fetching more env vars\n     *\n     * @throws RuntimeException on error\n     */\n    public function getEnv(string $prefix, string $name, \\Closure $getEnv): mixed;\n\n    /**\n     * @return array<string, string> The PHP-types managed by getEnv(), keyed by prefixes\n     */\n    public static function getProvidedTypes(): array;\n}\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "ExpressionLanguage.php",
          "type": "blob",
          "size": 1.0537109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Psr\\Cache\\CacheItemPoolInterface;\nuse Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage as BaseExpressionLanguage;\n\nif (!class_exists(BaseExpressionLanguage::class)) {\n    return;\n}\n\n/**\n * Adds some function to the default ExpressionLanguage.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @see ExpressionLanguageProvider\n */\nclass ExpressionLanguage extends BaseExpressionLanguage\n{\n    public function __construct(?CacheItemPoolInterface $cache = null, array $providers = [], ?callable $serviceCompiler = null, ?\\Closure $getEnv = null)\n    {\n        // prepend the default provider to let users override it easily\n        array_unshift($providers, new ExpressionLanguageProvider($serviceCompiler, $getEnv));\n\n        parent::__construct($cache, $providers);\n    }\n}\n"
        },
        {
          "name": "ExpressionLanguageProvider.php",
          "type": "blob",
          "size": 2.0859375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Symfony\\Component\\DependencyInjection\\Exception\\LogicException;\nuse Symfony\\Component\\ExpressionLanguage\\ExpressionFunction;\nuse Symfony\\Component\\ExpressionLanguage\\ExpressionFunctionProviderInterface;\n\n/**\n * Define some ExpressionLanguage functions.\n *\n * To get a service, use service('request').\n * To get a parameter, use parameter('kernel.debug').\n * To get an env variable, use env('SOME_VARIABLE').\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass ExpressionLanguageProvider implements ExpressionFunctionProviderInterface\n{\n    private ?\\Closure $serviceCompiler;\n\n    public function __construct(\n        ?callable $serviceCompiler = null,\n        private ?\\Closure $getEnv = null,\n    ) {\n        $this->serviceCompiler = null === $serviceCompiler ? null : $serviceCompiler(...);\n    }\n\n    public function getFunctions(): array\n    {\n        return [\n            new ExpressionFunction('service', $this->serviceCompiler ?? fn ($arg) => \\sprintf('$container->get(%s)', $arg), fn (array $variables, $value) => $variables['container']->get($value)),\n\n            new ExpressionFunction('parameter', fn ($arg) => \\sprintf('$container->getParameter(%s)', $arg), fn (array $variables, $value) => $variables['container']->getParameter($value)),\n\n            new ExpressionFunction('env', fn ($arg) => \\sprintf('$container->getEnv(%s)', $arg), function (array $variables, $value) {\n                if (!$this->getEnv) {\n                    throw new LogicException('You need to pass a getEnv closure to the expression language provider to use the \"env\" function.');\n                }\n\n                return ($this->getEnv)($value);\n            }),\n\n            new ExpressionFunction('arg', fn ($arg) => \\sprintf('$args?->get(%s)', $arg), fn (array $variables, $value) => $variables['args']?->get($value)),\n        ];\n    }\n}\n"
        },
        {
          "name": "Extension",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "LazyProxy",
          "type": "tree",
          "content": null
        },
        {
          "name": "Loader",
          "type": "tree",
          "content": null
        },
        {
          "name": "Parameter.php",
          "type": "blob",
          "size": 0.556640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\n/**\n * Parameter represents a parameter reference.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Parameter\n{\n    public function __construct(\n        private string $id,\n    ) {\n    }\n\n    public function __toString(): string\n    {\n        return $this->id;\n    }\n}\n"
        },
        {
          "name": "ParameterBag",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.5654296875,
          "content": "DependencyInjection Component\n=============================\n\nThe DependencyInjection component allows you to standardize and centralize the\nway objects are constructed in your application.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/dependency_injection.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Reference.php",
          "type": "blob",
          "size": 0.8251953125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\n/**\n * Reference represents a service reference.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Reference\n{\n    public function __construct(\n        private string $id,\n        private int $invalidBehavior = ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE,\n    ) {\n    }\n\n    public function __toString(): string\n    {\n        return $this->id;\n    }\n\n    /**\n     * Returns the behavior to be used when the service does not exist.\n     */\n    public function getInvalidBehavior(): int\n    {\n        return $this->invalidBehavior;\n    }\n}\n"
        },
        {
          "name": "ReverseContainer.php",
          "type": "blob",
          "size": 2.197265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Psr\\Container\\ContainerInterface;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ServiceNotFoundException;\n\n/**\n * Turns public and \"container.reversible\" services back to their ids.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class ReverseContainer\n{\n    private \\Closure $getServiceId;\n\n    public function __construct(\n        private Container $serviceContainer,\n        private ContainerInterface $reversibleLocator,\n        private string $tagName = 'container.reversible',\n    ) {\n        $this->getServiceId = \\Closure::bind(fn (object $service): ?string => array_search($service, $this->services, true) ?: array_search($service, $this->privates, true) ?: null, $serviceContainer, Container::class);\n    }\n\n    /**\n     * Returns the id of the passed object when it exists as a service.\n     *\n     * To be reversible, services need to be either public or be tagged with \"container.reversible\".\n     */\n    public function getId(object $service): ?string\n    {\n        if ($this->serviceContainer === $service) {\n            return 'service_container';\n        }\n\n        if (null === $id = ($this->getServiceId)($service)) {\n            return null;\n        }\n\n        if ($this->serviceContainer->has($id) || $this->reversibleLocator->has($id)) {\n            return $id;\n        }\n\n        return null;\n    }\n\n    /**\n     * @throws ServiceNotFoundException When the service is not reversible\n     */\n    public function getService(string $id): object\n    {\n        if ($this->reversibleLocator->has($id)) {\n            return $this->reversibleLocator->get($id);\n        }\n\n        if (isset($this->serviceContainer->getRemovedIds()[$id])) {\n            throw new ServiceNotFoundException($id, null, null, [], \\sprintf('The \"%s\" service is private and cannot be accessed by reference. You should either make it public, or tag it as \"%s\".', $id, $this->tagName));\n        }\n\n        return $this->serviceContainer->get($id);\n    }\n}\n"
        },
        {
          "name": "ServiceLocator.php",
          "type": "blob",
          "size": 5.4541015625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nuse Psr\\Container\\ContainerExceptionInterface;\nuse Psr\\Container\\NotFoundExceptionInterface;\nuse Symfony\\Component\\DependencyInjection\\Exception\\RuntimeException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ServiceCircularReferenceException;\nuse Symfony\\Component\\DependencyInjection\\Exception\\ServiceNotFoundException;\nuse Symfony\\Contracts\\Service\\ServiceCollectionInterface;\nuse Symfony\\Contracts\\Service\\ServiceLocatorTrait;\nuse Symfony\\Contracts\\Service\\ServiceSubscriberInterface;\n\n/**\n * @author Robin Chalas <robin.chalas@gmail.com>\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @template-covariant T of mixed\n *\n * @implements ServiceCollectionInterface<T>\n */\nclass ServiceLocator implements ServiceCollectionInterface\n{\n    use ServiceLocatorTrait {\n        get as private doGet;\n    }\n\n    private ?string $externalId = null;\n    private ?Container $container = null;\n\n    public function get(string $id): mixed\n    {\n        if (!$this->externalId) {\n            return $this->doGet($id);\n        }\n\n        try {\n            return $this->doGet($id);\n        } catch (RuntimeException $e) {\n            $what = \\sprintf('service \"%s\" required by \"%s\"', $id, $this->externalId);\n            $message = preg_replace('/service \"\\.service_locator\\.[^\"]++\"/', $what, $e->getMessage());\n\n            if ($e->getMessage() === $message) {\n                $message = \\sprintf('Cannot resolve %s: %s', $what, $message);\n            }\n\n            $r = new \\ReflectionProperty($e, 'message');\n            $r->setValue($e, $message);\n\n            throw $e;\n        }\n    }\n\n    public function __invoke(string $id): mixed\n    {\n        return isset($this->factories[$id]) ? $this->get($id) : null;\n    }\n\n    /**\n     * @internal\n     */\n    public function withContext(string $externalId, Container $container): static\n    {\n        $locator = clone $this;\n        $locator->externalId = $externalId;\n        $locator->container = $container;\n\n        return $locator;\n    }\n\n    public function count(): int\n    {\n        return \\count($this->getProvidedServices());\n    }\n\n    public function getIterator(): \\Traversable\n    {\n        foreach ($this->getProvidedServices() as $id => $config) {\n            yield $id => $this->get($id);\n        }\n    }\n\n    private function createNotFoundException(string $id): NotFoundExceptionInterface\n    {\n        if ($this->loading) {\n            $msg = \\sprintf('The service \"%s\" has a dependency on a non-existent service \"%s\". This locator %s', end($this->loading), $id, $this->formatAlternatives());\n\n            return new ServiceNotFoundException($id, end($this->loading) ?: null, null, [], $msg);\n        }\n\n        $class = debug_backtrace(\\DEBUG_BACKTRACE_PROVIDE_OBJECT | \\DEBUG_BACKTRACE_IGNORE_ARGS, 4);\n        $class = isset($class[3]['object']) ? $class[3]['object']::class : null;\n        $externalId = $this->externalId ?: $class;\n\n        $msg = [];\n        $msg[] = \\sprintf('Service \"%s\" not found:', $id);\n\n        if (!$this->container) {\n            $class = null;\n        } elseif ($this->container->has($id) || isset($this->container->getRemovedIds()[$id])) {\n            $msg[] = 'even though it exists in the app\\'s container,';\n        } else {\n            try {\n                $this->container->get($id);\n                $class = null;\n            } catch (ServiceNotFoundException $e) {\n                if ($e->getAlternatives()) {\n                    $msg[] = \\sprintf('did you mean %s? Anyway,', $this->formatAlternatives($e->getAlternatives(), 'or'));\n                } else {\n                    $class = null;\n                }\n            }\n        }\n        if ($externalId) {\n            $msg[] = \\sprintf('the container inside \"%s\" is a smaller service locator that %s', $externalId, $this->formatAlternatives());\n        } else {\n            $msg[] = \\sprintf('the current service locator %s', $this->formatAlternatives());\n        }\n\n        if (!$class) {\n            // no-op\n        } elseif (is_subclass_of($class, ServiceSubscriberInterface::class)) {\n            $msg[] = \\sprintf('Unless you need extra laziness, try using dependency injection instead. Otherwise, you need to declare it using \"%s::getSubscribedServices()\".', preg_replace('/([^\\\\\\\\]++\\\\\\\\)++/', '', $class));\n        } else {\n            $msg[] = 'Try using dependency injection instead.';\n        }\n\n        return new ServiceNotFoundException($id, end($this->loading) ?: null, null, [], implode(' ', $msg));\n    }\n\n    private function createCircularReferenceException(string $id, array $path): ContainerExceptionInterface\n    {\n        return new ServiceCircularReferenceException($id, $path);\n    }\n\n    private function formatAlternatives(?array $alternatives = null, string $separator = 'and'): string\n    {\n        $format = '\"%s\"%s';\n        if (null === $alternatives) {\n            if (!$alternatives = array_keys($this->factories)) {\n                return 'is empty...';\n            }\n            $format = \\sprintf('only knows about the %s service%s.', $format, 1 < \\count($alternatives) ? 's' : '');\n        }\n        $last = array_pop($alternatives);\n\n        return \\sprintf($format, $alternatives ? implode('\", \"', $alternatives) : $last, $alternatives ? \\sprintf(' %s \"%s\"', $separator, $last) : '');\n    }\n}\n"
        },
        {
          "name": "StaticEnvVarLoader.php",
          "type": "blob",
          "size": 0.578125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\nclass StaticEnvVarLoader implements EnvVarLoaderInterface\n{\n    private array $envVars;\n\n    public function __construct(private EnvVarLoaderInterface $envVarLoader)\n    {\n    }\n\n    public function loadEnvVars(): array\n    {\n        return $this->envVars ??= $this->envVarLoader->loadEnvVars();\n    }\n}\n"
        },
        {
          "name": "TaggedContainerInterface.php",
          "type": "blob",
          "size": 0.671875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\n/**\n * TaggedContainerInterface is the interface implemented when a container knows how to deals with tags.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\ninterface TaggedContainerInterface extends ContainerInterface\n{\n    /**\n     * Returns service ids for a given tag.\n     *\n     * @param string $name The tag name\n     */\n    public function findTaggedServiceIds(string $name): array;\n}\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "TypedReference.php",
          "type": "blob",
          "size": 1.4423828125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\n/**\n * Represents a PHP type-hinted service reference.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass TypedReference extends Reference\n{\n    private ?string $name;\n\n    /**\n     * @param string      $id              The service identifier\n     * @param string      $type            The PHP type of the identified service\n     * @param int         $invalidBehavior The behavior when the service does not exist\n     * @param string|null $name            The name of the argument targeting the service\n     * @param array       $attributes      The attributes to be used\n     */\n    public function __construct(\n        string $id,\n        private string $type,\n        int $invalidBehavior = ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE,\n        ?string $name = null,\n        private array $attributes = [],\n    ) {\n        $this->name = $type === $id ? $name : null;\n        parent::__construct($id, $invalidBehavior);\n    }\n\n    public function getType(): string\n    {\n        return $this->type;\n    }\n\n    public function getName(): ?string\n    {\n        return $this->name;\n    }\n\n    public function getAttributes(): array\n    {\n        return $this->attributes;\n    }\n}\n"
        },
        {
          "name": "Variable.php",
          "type": "blob",
          "size": 0.6396484375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection;\n\n/**\n * Represents a variable.\n *\n *     $var = new Variable('a');\n *\n * will be dumped as\n *\n *     $a\n *\n * by the PHP dumper.\n *\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n */\nclass Variable\n{\n    public function __construct(\n        private string $name,\n    ) {\n    }\n\n    public function __toString(): string\n    {\n        return $this->name;\n    }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.3427734375,
          "content": "{\n    \"name\": \"symfony/dependency-injection\",\n    \"type\": \"library\",\n    \"description\": \"Allows you to standardize and centralize the way objects are constructed in your application\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"psr/container\": \"^1.1|^2.0\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3\",\n        \"symfony/service-contracts\": \"^3.5\",\n        \"symfony/var-exporter\": \"^6.4|^7.0\"\n    },\n    \"require-dev\": {\n        \"symfony/yaml\": \"^6.4|^7.0\",\n        \"symfony/config\": \"^6.4|^7.0\",\n        \"symfony/expression-language\": \"^6.4|^7.0\"\n    },\n    \"conflict\": {\n        \"ext-psr\": \"<1.1|>=2\",\n        \"symfony/config\": \"<6.4\",\n        \"symfony/finder\": \"<6.4\",\n        \"symfony/yaml\": \"<6.4\"\n    },\n    \"provide\": {\n        \"psr/container-implementation\": \"1.1|2.0\",\n        \"symfony/service-implementation\": \"1.1|2.0|3.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\DependencyInjection\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.8564453125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony DependencyInjection Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Resources</directory>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}