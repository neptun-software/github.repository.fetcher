{
  "metadata": {
    "timestamp": 1736711904567,
    "page": 286,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "silexphp/Pimple",
      "stars": 2646,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0556640625,
          "content": "phpunit.xml\n.phpunit.result.cache\ncomposer.lock\n/vendor/\n"
        },
        {
          "name": ".php_cs.dist",
          "type": "blob",
          "size": 0.7724609375,
          "content": "<?php\n\nreturn PhpCsFixer\\Config::create()\n    ->setRules([\n        '@Symfony' => true,\n        '@Symfony:risky' => true,\n        '@PHPUnit75Migration:risky' => true,\n        'php_unit_dedicate_assert' => true,\n        'array_syntax' => ['syntax' => 'short'],\n        'php_unit_fqcn_annotation' => true,\n        'no_unreachable_default_argument_value' => false,\n        'braces' => ['allow_single_line_closure' => true],\n        'heredoc_to_nowdoc' => false,\n        'ordered_imports' => true,\n        'phpdoc_types_order' => ['null_adjustment' => 'always_last', 'sort_algorithm' => 'none'],\n        'native_function_invocation' => ['include' => ['@compiler_optimized'], 'scope' => 'all'],\n    ])\n    ->setRiskyAllowed(true)\n    ->setFinder(PhpCsFixer\\Finder::create()->in(__DIR__.'/src'))\n;\n"
        },
        {
          "name": "CHANGELOG",
          "type": "blob",
          "size": 1.646484375,
          "content": "* 3.5.0 (2021-10-28)\n\n * Add support for PHP 8.1\n * Add support for version 2.0 of PSR-11\n\n* 3.4.0 (2021-03-06)\n\n * Implement version 1.1 of PSR-11\n\n* 3.3.1 (2020-11-24)\n\n * Add support for PHP 8\n\n* 3.3.0 (2020-03-03)\n\n * Drop PHP extension\n * Bump min PHP version to 7.2.5\n\n* 3.2.3 (2018-01-21)\n\n * prefixed all function calls with \\ for extra speed\n\n* 3.2.2 (2017-07-23)\n\n * reverted extending a protected closure throws an exception (deprecated it instead)\n\n* 3.2.1 (2017-07-17)\n\n * fixed PHP error\n\n* 3.2.0 (2017-07-17)\n\n * added a PSR-11 service locator\n * added a PSR-11 wrapper\n * added ServiceIterator\n * fixed extending a protected closure (now throws InvalidServiceIdentifierException)\n\n* 3.1.0 (2017-07-03)\n\n * deprecated the C extension\n * added support for PSR-11 exceptions\n\n* 3.0.2 (2015-09-11)\n\n * refactored the C extension\n * minor non-significant changes\n\n* 3.0.1 (2015-07-30)\n\n * simplified some code\n * fixed a segfault in the C extension\n\n* 3.0.0 (2014-07-24)\n\n * removed the Pimple class alias (use Pimple\\Container instead)\n\n* 2.1.1 (2014-07-24)\n\n * fixed compiler warnings for the C extension\n * fixed code when dealing with circular references\n\n* 2.1.0 (2014-06-24)\n\n * moved the Pimple to Pimple\\Container (with a BC layer -- Pimple is now a\n   deprecated alias which will be removed in Pimple 3.0)\n * added Pimple\\ServiceProviderInterface (and Pimple::register())\n\n* 2.0.0 (2014-02-10)\n\n * changed extend to automatically re-assign the extended service and keep it as shared or factory\n   (to keep BC, extend still returns the extended service)\n * changed services to be shared by default (use factory() for factory\n   services)\n\n* 1.0.0\n\n * initial version\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0400390625,
          "content": "Copyright (c) 2009-2020 Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 9.2900390625,
          "content": "Pimple\n======\n\n.. caution::\n\n    Pimple is now closed for changes. No new features will be added and no\n    cosmetic changes will be accepted either. The only accepted changes are\n    compatibility with newer PHP versions and security issue fixes.\n\n.. caution::\n\n    This is the documentation for Pimple 3.x. If you are using Pimple 1.x, read\n    the `Pimple 1.x documentation`_. Reading the Pimple 1.x code is also a good\n    way to learn more about how to create a simple Dependency Injection\n    Container (recent versions of Pimple are more focused on performance).\n\nPimple is a small Dependency Injection Container for PHP.\n\nInstallation\n------------\n\nBefore using Pimple in your project, add it to your ``composer.json`` file:\n\n.. code-block:: bash\n\n    $ ./composer.phar require pimple/pimple \"^3.0\"\n\nUsage\n-----\n\nCreating a container is a matter of creating a ``Container`` instance:\n\n.. code-block:: php\n\n    use Pimple\\Container;\n\n    $container = new Container();\n\nAs many other dependency injection containers, Pimple manages two different\nkind of data: **services** and **parameters**.\n\nDefining Services\n~~~~~~~~~~~~~~~~~\n\nA service is an object that does something as part of a larger system. Examples\nof services: a database connection, a templating engine, or a mailer. Almost\nany **global** object can be a service.\n\nServices are defined by **anonymous functions** that return an instance of an\nobject:\n\n.. code-block:: php\n\n    // define some services\n    $container['session_storage'] = fn($c) => new SessionStorage('SESSION_ID');\n\n    $container['session'] = fn($c) => new Session($c['session_storage']);\n\nNotice that the anonymous function has access to the current container\ninstance, allowing references to other services or parameters.\n\nAs objects are only created when you get them, the order of the definitions\ndoes not matter.\n\nUsing the defined services is also very easy:\n\n.. code-block:: php\n\n    // get the session object\n    $session = $container['session'];\n\n    // the above call is roughly equivalent to the following code:\n    // $storage = new SessionStorage('SESSION_ID');\n    // $session = new Session($storage);\n\nDefining Factory Services\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBy default, each time you get a service, Pimple returns the **same instance**\nof it. If you want a different instance to be returned for all calls, wrap your\nanonymous function with the ``factory()`` method\n\n.. code-block:: php\n\n    $container['session'] = $container->factory(fn($c) => new Session($c['session_storage']));\n\nNow, each call to ``$container['session']`` returns a new instance of the\nsession.\n\nDefining Parameters\n~~~~~~~~~~~~~~~~~~~\n\nDefining a parameter allows to ease the configuration of your container from\nthe outside and to store global values:\n\n.. code-block:: php\n\n    // define some parameters\n    $container['cookie_name'] = 'SESSION_ID';\n    $container['session_storage_class'] = 'SessionStorage';\n\nIf you change the ``session_storage`` service definition like below:\n\n.. code-block:: php\n\n    $container['session_storage'] = fn($c) => new $c['session_storage_class']($c['cookie_name']);\n\nYou can now easily change the cookie name by overriding the\n``cookie_name`` parameter instead of redefining the service\ndefinition.\n\nProtecting Parameters\n~~~~~~~~~~~~~~~~~~~~~\n\nBecause Pimple sees anonymous functions as service definitions, you need to\nwrap anonymous functions with the ``protect()`` method to store them as\nparameters:\n\n.. code-block:: php\n\n    $container['random_func'] = $container->protect(fn() => rand());\n\nModifying Services after Definition\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn some cases you may want to modify a service definition after it has been\ndefined. You can use the ``extend()`` method to define additional code to be\nrun on your service just after it is created:\n\n.. code-block:: php\n\n    $container['session_storage'] = fn($c) => new $c['session_storage_class']($c['cookie_name']);\n\n    $container->extend('session_storage', function ($storage, $c) {\n        $storage->...();\n\n        return $storage;\n    });\n\nThe first argument is the name of the service to extend, the second a function\nthat gets access to the object instance and the container.\n\nExtending a Container\n~~~~~~~~~~~~~~~~~~~~~\n\nIf you use the same libraries over and over, you might want to reuse some\nservices from one project to the next one; package your services into a\n**provider** by implementing ``Pimple\\ServiceProviderInterface``:\n\n.. code-block:: php\n\n    use Pimple\\Container;\n\n    class FooProvider implements Pimple\\ServiceProviderInterface\n    {\n        public function register(Container $pimple)\n        {\n            // register some services and parameters\n            // on $pimple\n        }\n    }\n\nThen, register the provider on a Container:\n\n.. code-block:: php\n\n    $pimple->register(new FooProvider());\n\nFetching the Service Creation Function\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen you access an object, Pimple automatically calls the anonymous function\nthat you defined, which creates the service object for you. If you want to get\nraw access to this function, you can use the ``raw()`` method:\n\n.. code-block:: php\n\n    $container['session'] = fn($c) => new Session($c['session_storage']);\n\n    $sessionFunction = $container->raw('session');\n\nPSR-11 compatibility\n--------------------\n\nFor historical reasons, the ``Container`` class does not implement the PSR-11\n``ContainerInterface``. However, Pimple provides a helper class that will let\nyou decouple your code from the Pimple container class.\n\nThe PSR-11 container class\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``Pimple\\Psr11\\Container`` class lets you access the content of an\nunderlying Pimple container using ``Psr\\Container\\ContainerInterface``\nmethods:\n\n.. code-block:: php\n\n    use Pimple\\Container;\n    use Pimple\\Psr11\\Container as PsrContainer;\n\n    $container = new Container();\n    $container['service'] = fn($c) => new Service();\n    $psr11 = new PsrContainer($container);\n\n    $controller = function (PsrContainer $container) {\n        $service = $container->get('service');\n    };\n    $controller($psr11);\n\nUsing the PSR-11 ServiceLocator\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSometimes, a service needs access to several other services without being sure\nthat all of them will actually be used. In those cases, you may want the\ninstantiation of the services to be lazy.\n\nThe traditional solution is to inject the entire service container to get only\nthe services really needed. However, this is not recommended because it gives\nservices a too broad access to the rest of the application and it hides their\nactual dependencies.\n\nThe ``ServiceLocator`` is intended to solve this problem by giving access to a\nset of predefined services while instantiating them only when actually needed.\n\nIt also allows you to make your services available under a different name than\nthe one used to register them. For instance, you may want to use an object\nthat expects an instance of ``EventDispatcherInterface`` to be available under\nthe name ``event_dispatcher`` while your event dispatcher has been\nregistered under the name ``dispatcher``:\n\n.. code-block:: php\n\n    use Monolog\\Logger;\n    use Pimple\\Psr11\\ServiceLocator;\n    use Psr\\Container\\ContainerInterface;\n    use Symfony\\Component\\EventDispatcher\\EventDispatcher;\n\n    class MyService\n    {\n        /**\n         * \"logger\" must be an instance of Psr\\Log\\LoggerInterface\n         * \"event_dispatcher\" must be an instance of Symfony\\Component\\EventDispatcher\\EventDispatcherInterface\n         */\n        private $services;\n\n        public function __construct(ContainerInterface $services)\n        {\n            $this->services = $services;\n        }\n    }\n\n    $container['logger'] = fn($c) => new Monolog\\Logger();\n    $container['dispatcher'] = fn($c) => new EventDispatcher();\n    \n    $container['service'] = function ($c) {\n        $locator = new ServiceLocator($c, array('logger', 'event_dispatcher' => 'dispatcher'));\n\n        return new MyService($locator);\n    };\n\nReferencing a Collection of Services Lazily\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPassing a collection of services instances in an array may prove inefficient\nif the class that consumes the collection only needs to iterate over it at a\nlater stage, when one of its method is called. It can also lead to problems\nif there is a circular dependency between one of the services stored in the\ncollection and the class that consumes it.\n\nThe ``ServiceIterator`` class helps you solve these issues. It receives a\nlist of service names during instantiation and will retrieve the services\nwhen iterated over:\n\n.. code-block:: php\n\n    use Pimple\\Container;\n    use Pimple\\ServiceIterator;\n\n    class AuthorizationService\n    {\n        private $voters;\n\n        public function __construct($voters)\n        {\n            $this->voters = $voters;\n        }\n\n        public function canAccess($resource)\n        {\n            foreach ($this->voters as $voter) {\n                if (true === $voter->canAccess($resource)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    $container = new Container();\n\n    $container['voter1'] = fn($c) => new SomeVoter();\n    $container['voter2'] = fn($c) => new SomeOtherVoter($c['auth']);\n    $container['auth'] = fn ($c) => new AuthorizationService(new ServiceIterator($c, array('voter1', 'voter2'));\n\n.. _Pimple 1.x documentation: https://github.com/silexphp/Pimple/tree/1.1\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.6796875,
          "content": "{\n    \"name\": \"pimple/pimple\",\n    \"type\": \"library\",\n    \"description\": \"Pimple, a simple Dependency Injection Container\",\n    \"keywords\": [\"dependency injection\", \"container\"],\n    \"homepage\": \"https://pimple.symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=7.2.5\",\n        \"psr/container\": \"^1.1 || ^2.0\"\n    },\n    \"require-dev\": {\n        \"symfony/phpunit-bridge\": \"^5.4@dev\"\n    },\n    \"autoload\": {\n        \"psr-0\": { \"Pimple\": \"src/\" }\n    },\n    \"extra\": {\n        \"branch-alias\": {\n            \"dev-master\": \"3.4.x-dev\"\n        }\n    }\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.5419921875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/4.1/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n>\n    <testsuites>\n        <testsuite name=\"Pimple Test Suite\">\n            <directory>./src/Pimple/Tests</directory>\n        </testsuite>\n    </testsuites>\n\n    <listeners>\n        <listener class=\"Symfony\\Bridge\\PhpUnit\\SymfonyTestsListener\" />\n    </listeners>\n</phpunit>\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}