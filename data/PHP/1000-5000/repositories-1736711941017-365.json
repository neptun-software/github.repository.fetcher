{
  "metadata": {
    "timestamp": 1736711941017,
    "page": 365,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "markrogoyski/math-php",
      "stars": 2351,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0634765625,
          "content": "/vendor\ncomposer.lock\ncomposer.phar\n/.idea\n.phpunit.result.cache\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 24.26953125,
          "content": "# MathPHP Change Log\n\n## v2.10.0 - 2024-04-16\n\n### New Features\n* NumberTheory\\Integer `isPrime`\n\n## v2.9.0 - 2024-03-02\n\n### New Features\n* Distance `chebyshev`\n\n### Improvements\n* Internal build CI/CD improvements\n\n## v2.8.1 - 2023-05-18\n\n### Improvements\n* Internal improvements to improve conformance with static analysis tools\n\n## v2.8.0 - 2023-05-07\n\n### New Features\n* Matrix `rowAddVector`\n* Matrix `columnAddVector`\n\n### Improvements\n* Better error handling and exception message in `Sequence\\NonIntenger::hyperharmonic`\n* Internal code improvements to conform to static analysis checks\n\n### Backwards Incompatible Changes\n* Helper method names changed (public abstract methods but not part of published interface)\n  * `NumericalDifferentiation::isTargetInPoints` changed to `assertTargetInPoints`\n  * `NumericalDifferentiation::isSpacingConstant` changed to `assertSpacingConstant`\n\n## v2.7.0 - 2022-12-31\n\n### Improvements\n* Improved algorithm for `regularizedIncompleteBeta`: Addresses issue 458\n* Issue 456: Improved PHPDoc blocks: Changed \"number\" to \"int|float\"\n* Added PHP 8.2 for CI test target\n\n## v2.6.0 - 2022-04-10\n\n### Improvements\n* `Average::truncatedMean` behavior at 50% trim made consistent\n* PHP 8.1 compatibility improvements\n\n### Backwards Incompatible Changes\n# `Average::truncatedMean` throws exception if trim percent greater than 50% rather than error or unpredictable results.\n\n## v2.5.0 - 2021-11-21\n\n### New Features\n* Special function `logbeta`\n* Special function `logGamma`\n* Special function `logGammaCorr`\n* Special function `stirlingError`\n\n### Improvements\n* Improvements in StudentT continuous distribution\n* Improvements in special function `gamma`\n* Improvements in special function `beta`\n\n### Bug Fixes\n* Issue 393 (regularizedIncompleteBeta NAN)\n* Issue 429 (Linear regression CI division by zero)\n\n## v2.4.0 - 2021-07-27\n\n### New Features\n* Complex Exponential (`exp`)\n* Complex Exponentiation (`pow`)\n* Zipf's Law Discrete Distribution\n* Generalized harmonic non-integer sequence\n\n### Improvements\n* Fixed Complex `polarForm` to compute the right values\n* Fixed `hyperharnomic` non-integer sequence. Previously was computing the wrong thing\n* Fixed how `ArbitraryInterger` handles `pow` of negative exponents\n\n### Backwards Incompatible Changes\n* Complex `polarForm` now returns an array rather than a Complex number, as the Complex return was incorrect\n* Interface to `hyperharmonic` non-integer sequence changed due to previous implementation being incorrect\n\n## v2.3.0 - 2021-07-14\n\n### New Features\n* Matrix SVD (Singular Value Decomposition)\n* Polynomial companion matrix\n\n## v2.2.0 - 2021-07-11\n\n### New Features\n* PLS (Partial Least Squares Regression)\n\n### Improvements\n* Add custom `__debugInfo` to `NumericMatrix`\n\n## v2.1.0 - 2021-07-07\n\n### New Features\n* Quaternion numbers\n\n## v2.0.0 - 2021-05-09\n\n### New Features\n* Matrix Improvements\n  * `walk` method to map a function to all values without mutation or returning a value\n  * `MatrixFactory` creates more matrix types\n  * `MatrixFactory::createNumeric` to create `NumericMatrix` types\n  * `MatrixFactory::createFromRowVector`\n  * `MatrixFactory::createFromColumnVector`\n  * Internal `ObjectMatrix` improvements\n    * Add `trace`\n    * Add `scalarMultiply`\n  * Add initial `ComplexMatrix`\n* Sample data People\n\n### Improvements\n* Bug fixes\n  * Issue 414 fixed - PCA/Eigenvalue convergence\n  * Issue 413 fixed - matrix solve with singular matrix using RREF\n\n## Migration - Upgrading to v2.0 from v1.0\n* PHP minimum version now 7.2 (was 7.0)\n* Deprecated code removed (backwards-incompatible change)\n  * `MathPHP\\Statistics\\Distance::kullbackLeiblerDivergence` removed (Use `MathPHP\\Statistics\\Divergence::kullbackLeibler` instead)\n  * `MathPHP\\Statistics\\Distance::jensenShannonDivergence` removed (Use `MathPHP\\Statistics\\Divergence::jensenShannon` instead)\n  * Matrix Decompositions no longer implement `\\ArrayAccess` interface to access decomposition matrixes. Use properties instead.\n    * `MathPHP\\LinearAlgebra\\Decomposition\\Cholesky`\n      * `$cholesky['L']`, `$cholesky['Láµ€']`, `$cholesky['LT']` removed, use `$cholesky->L`, `$cholesky->Láµ€`, `$cholesky->LT` instead.\n    * `MathPHP\\LinearAlgebra\\Decomposition\\Crout`\n      * `$crout['L']`, `$crout['U']` removed, use `$crout->L`, `$crout->U` instead.\n    * `MathPHP\\LinearAlgebra\\Decomposition\\LU`\n      * `$LU['L']`, `LU['U']`, `LU['P']` removed, use `$LU->L`, `$LU->U`, `$LU->P` instead.\n    * `MathPHP\\LinearAlgebra\\Decomposition\\QR`\n      * `$QR['Q']`, `$QR['R']` removed, use `$QR->Q`, `$QR->R` instead.\n* Methods renamed (backwards-incompatible change)\n  * `MathPHP\\Statistics\\Distance::bhattacharyyaDistance` renamed to `MathPHP\\Statistics\\Distance::bhattacharyya`\n  * `MathPHP\\Statistics\\Distance::hellingerDistance` renamed to `MathPHP\\Statistics\\Distance::hellinger`\n* Moved Functionality (backwards-incompatible change)\n  * `MathPHP\\Functions\\Polynomial` moved to `MathPHP\\Expression\\Polynomial`\n  * `MathPHP\\Functions\\Piecewise` moved to `MathPHP\\Expression\\Piecewise`\n* Matrix internal refactoring\n  * Note: These changes will not affect any client code as long as matrices were created using `MatrixFactory`.\n  * `Matrix` is not a base abstract class for all matrix classes to extend\n  * `Matrix` renamed `NumericMatrix`\n  * `Matrix` base method `createZeroValue`\n    * Use case is various `ObjectMatrix` classes that implement `ObjectArithmetic`\n  * `RowVector` removed. Use `MatrixFactory::createFromRowVector` instead\n  * `ColumnVector` removed. Use `MatrixFactory::createFromColumnVector` instead\n\n## v1.11.0 - 2021-05-09\n\n### Improvements\n* Bugfix (Issue 413): Matrix solve with singular matrix using RREF\n* Bugfix (Issue 414): PCA/Eigenvalue convergence\n\n## v1.10.0 - 2020-12-19\n\n### Improvements\n* Bugfix (Issue 356): Fix Finance IRR NANs\n\n## v1.9.0 - 2020-12-13\n\n### New Features\n* Vector min and max\n* Arithmetic isqrt (integer square root)\n\n### Improvements\n* Remove Travis CI (Moved CI to Github Actions in v1.8.0 release)\n* Rearrange non-code files\n\n## v1.8.0 - 2020-12-11\n\n### Improvements\n* Improve permutations algorithm to be more efficient and more numerically stable\n* Qualify PHP function names with root namespace\n* Move CI to Github Actions\n\n## v1.7.0 - 2020-11-15\n\n### New Features\n* Algebra linear equation of one variable\n* Rational number inverse\n* Rational number pow\n\n### Improvements\n* Improve combinations algorithm to be more efficient and more numerically stable\n* Internal Matrix class reorganization\n\n## v1.6.0 - 2020-10-22\n\n### New Features\n* Special function regularized lower incomplete gamma\n* Cereal sample data set\n\n### Improvements\n* Define boundary condition for lower incomplete gamma function\n\n## v1.5.0 - 2020-10-12\n\n### New Features\n* Matrix LU solve\n* Matrix QR solve\n\n### Improvements\n* Bugfix (Issue 386) Matrix solve improvements\n* Matrix solve has optional method parameter to force a solve method\n* Bugfix ArbitraryInteger multiplication sign not taken into account\n\n## v1.4.0 - 2020-10-02\n\n### New Features\n* Multivariate Regular Grid Interpolation\n* Jensen-Shannon Distance\n* Canberra Distance\n* Search Sorted\n* Search ArgMax\n* Search NanArgMax\n* Search ArgMin\n* Search NanArgMin\n* Search NonZero\n\n### Improvements\n * Divergence factored out of Distance into new Divergence class\n\n### Backwards Incompatible Changes\n * Legacy Distance divergences marked as deprecated (To be removed in v2.0.0)\n\n## v1.3.0 - 2020-08-24\n\n### New Features\n* LinearAlgebra\\Vector\n  * Angle between two vectors\n  * LÂ¹ distance of two vectors\n  * LÂ² distance of two vectors\n  * Minkowski distance of two vectors\n* Statistics\\Distance\n  * Minkowski distance\n  * Euclidean distance (LÂ² distance)\n  * Manhattan distance (Taxicab geometry, LÂ¹ distance, etc.)\n  * Cosine distance\n  * Cosine similarity\n\n## v1.2.0 - 2020-07-24\n\n### New Features\n* Ranking\n  * Ordinal ranking\n  * Standard competition ranking\n  * Modified competition ranking\n  * Fractional ranking\n\n### Improvements\n* (Issue 380) Fixed Spearman's Rho calculation when there are rank ties\n\n## v1.1.0 - 2020-04-19\n\n### New Features\n- Arithmetic modulo\n\n### Improvements\n- Improved matrix multiplication performance using cache-oblivious algorithm optimization\n\n## v1.0.0 - 2020-04-14\n\nInitial version 1.0.0 release!\n\n## v0.62.0 - 2020-04-08\n\n### Improvements\n- Internal improvements\n\n## v0.61.0 - 2020-03-22\n\n### New Features\n* Multivariate Hypergeometric distribution\n\n## v0.60.0 - 2020-02-27\n\n### New Features\n- Sample Data\n  - MtCars\n  - Iris\n  - ToothGrowth\n  - PlantGrowth\n  - UsArrests\n\n## v0.59.0 - 2020-02-19\n\n### New Features\n- Add population and sample kurtosis\n- Changed default kurtosis algorithm to the more common population kurtosis\n- kurtosis now takes an optional parameter to set the kurtosis type algorithm\n\n## v0.58.0 - 2020-02-06\n\n### Improvements\n* Changed default skewness algorithm to the more common sample skewness\n* skewness now takes an optional parameter to set the skewness type algorithm\n* Improvements to skewness algorithms\n\n## v0.57.0 - 2020-01-07\n\n### New Features\n* Number\\Rational basic getters\n  * getWholePart\n  * getNumerator\n  * getDenominator\n* Set Theory n-ary Cartesian product\n\n### Improvements\n* Data direction control for Matrix meanDeviation and covarianceMatrix\n* Algebra factors performance improvement\n\n## v0.56.0 - 2019-12-03\n\n### New Features\n* Number Theory\n  * isDeficientNumber\n  * isAbundantNumber\n  * aliquotSum\n  * radical\n  * totient\n  * cototient\n  * reducedTotient\n  * mobius\n  * isSquarefree\n  * isRefactorableNumber\n  * isSphenicNumber\n  * numberOfDivisors\n  * sumOfDivisors\n\n### Improvements\n* Optimization of prime factorization algorithm\n\n## v0.55.0 - 2019-11-19\n\n### New Features\n- Arbitrary length integers\n\n### Improvements\n- Factorial optimization\n\n## v0.54.0 - 2019-10-12\n\n### New Features\n- Matrix isNilpotent\n- Matrix isRectangularDiagonal\n- Matrix mapRows\n- MathPHP logo\n\n### Improvements\n* MatrixFactory random matrix custom lower and upper bounds for random number\n* PSR-12 style compliance\n* Bugfix: powerIteration random failure - [Issue 346](https://github.com/markrogoyski/math-php/issues/346)\n\n## v0.53.0 - 2019-09-09\n\n### New Features\n* Matrix QR decomposition using Householder reflections\n* Matrix Householder transformation\n* MatrixFactory random matrix\n* MatrixFactory givens rotation matrix\n* Matrix isIdempotent\n* Matrix Eigenvalue power iteration\n* Matrix Eigenvalue jacobi method\n* Arithmetic root (náµ—Ê° root)\n* Vector arithmetic multiply and divide\n* Vector Iterator interface\n\n### Improvements\n* Internal improvements to Matrix\n* Matrix decompositions returned as objects\n* Matrix Cholesky decomposition provides L transpose\n\n## v0.52.0 - 2019-07-11\n\n### New Features\n* Grubb's test for statistical outliers\n\n## v0.51.0 - 2019-06-05\n\n### New Features\n* Matrix rowSums\n* Matrix columnSums\n* Matrix rowMeans\n* Matrix columnMeans\n* Matrix isNormal\n* MatrixFactory diagonal matrix creation method\n* MatrixFactory vandermonde matrix creation method\n\n### Improvements\n* Set custom Matrix tolerances\n* Various internal improvements\n\n### Backwards Incompatible Changes\n* Remove Matrix sampleMeans (use rowMeans or columnMeans instead)\n* MatrixFactory create method only works with 2d arrays. 1d arrays no longer work. (use diagonal and vandermonde factory methods instead)\n* Statistics methods throw exceptions instead of returning null on bad input\n* Change return type of LagrangePolynomial to Polynomial\n\n## v0.50.0 - 2019-04-22\n\n### New Features\n* Matrix isOrthogonal\n* Matrix isEqual\n* Harmonic sequence\n* Hyperharmonic sequence\n* Map\\Single reciprocal\n\n### Improvements\n* Support methods for almost equal\n* Matrix getDiagonalElements works for non-square matrices\n* Use more efficient algorithm in Matrix isSymmetric\n* Use more efficient algorithm in Matrix isSkewSymmetric\n\n### Backwards Incompatible Changes\n* Statistics methods throw exceptions instead of returning null on bad input\n\n## v0.49.0 - 2019-02-23\n\n### New Features\n- Matrix augmentAbove\n- Matrix augmentLeft\n\n### Improvements\n- Object matrix multiplication\n\n## v0.48.0 - 2018-12-15\n\n### New Features\n- Matrix submatrix\n- Mahalanobis distance\n- Bernoulli distribution mean, median, mode and variance\n- Binomial distribution mean and variance\n- Geometric distribution mean, median, mode and variance\n- Hypergeometric distribution mode and variance\n- NegativeBinomial (Pascal) distribution CDF, mean, mode and variance\n- Poisson distribution mean, median, mode and variance\n- Discrete Uniform distribution variance\n\n### Improvements\n- Binomial distribution PMF uses more numerically stable multiplication method\n- Fix potential divide by zero in TheilSen regression\n\n### Backwards Incompatible Changes\n- Multinomial distribution moved from Discrete to Multivariate namespace\n\n## v0.47.0 - 2018-11-21\n\n### New Features\n* Beta distribution median, mode, variance\n* Cauchy distribution variance\n* ChiSquared distribution mode, variance\n* Exponential distribution median, mode, variance\n* F distribution mode, variance\n* Gamma distribution median, mode, variance\n* Laplace distribution mode, variance\n* Logistic distribution mode, vaiance\n* LogLogistic distribution median, mode, variance\n* LogNormal distribution mode, variance\n* Normal distribution mode, variance\n* StandardNormal distribution mode, variance\n* StudentT distribution mode, variance\n* Uniform distribution median, mode, variance\n* Weibull distribution median, mode\n\n### Improvements\n* Normal distribution rand algorithm changed to Boxâ€“Muller transform\n\n## v0.46.0 - 2018-10-28\n\n### New Features\n* NumberTheory isPerfectNumber\n* Sequence perfectNumber\n\n### Improvements\n* Improve README documentation for continuous distributions\n* Updates to build tools\n* General improvements\n\n## v0.45.0 - 2018-09-24\n\n### Improvements\n- Add Beta distribution inverse quantile function\n- Improvements to Weibull distribution\n- Improvements to Cauchy distribution\n- Improvements to Laplace distribution\n- Improvements to Logistic distribution\n- Improvements to LogNormal distribution\n- Improvements to Normal distribution\n- Improvements to Pareto distribution\n- Improvements to Algebra cubic/quartic complex root handling\n\n## v0.44.0 - 2018-08-29\n\n### Improvements\n- [[Issue 271]](https://github.com/markrogoyski/math-php/issues/271) Improvements to documentation\n- [[Issue 269]](https://github.com/markrogoyski/math-php/issues/269) Add closed-form inverse function for Exponential distribution\n\n## v0.43.0 - 2018-05-21\n\n### New Features\n* Arithmetic copySign\n* Matrix negate\n* Matrix isSkewSymmetric\n\n## v0.42.0 - 2018-05-09\n\n### New Features\n* Weighted mean\n* Weighted sample variance\n* Weighted covariance\n* Weighted correlation coefficient\n\n### Improvements\n* Minor code improvements\n\n## v0.41.0 - 2018-04-23\n\n### New Features\n* Arithmetic almostEqual\n\n### Improvements\n* Statistics\\Average::mode improved to work with non-integer values\n* Various minor code improvements\n\n## v0.40.0 - 2018-03-22\n\n### New Features\n* Simpler interface for Significance ```tTest``` for one and two samples\n\n### Improvements\n* T test for two samples uses more robust Welch test\n* Improvements to Normal and Standard Normal continuous distributions\n* General improvements to continuous distributions\n\n## v0.39.0 - 2018-02-27\n\n### Improvements\n* Upgrade unit testing framework to PHPUnit 6\n* Update unit tests for PHPUnit 6 compatibility\n* Add PHP 7.2 to continuous integration tests\n\n## v0.38.0 - 2017-12-10\n\n### Improvements\n* Percentile reimplemented to use linear interpolation between closest ranks method - Second variant, C = 1\n* General code improvements\n* Better error and exception handling\n\n## v0.37.0 - 2017-10-23\n\n### Improvements\n- Change probability distributions to be objects instead of static methods\n\n### Backwards Incompatible Changes\n- Change probability distributions to be objects instead of static methods\n\n## v0.36.0 - 2017-09-26\n\n### New Features\n* Rational number\n* Gamma distribution mean\n\n### Improvements\n* Add .gitignore file\n\n## v0.35.0 - 2017-08-20\n\n### New Features\n* Matrix isTridiagonal\n* Matrix isUpperHessenberg\n* Matrix isLowerHessenberg\n* Matrix getSuperdiagonalElements\n* Matrix getSubdiagonalElements\n\n### Improvements\n* [Issue 242 - documentation improvement](https://github.com/markrogoyski/math-php/issues/242)\n\n## v0.34.0 - 2017-08-12\n\n### New Features\n- Multivariate normal distribution\n\n## v0.33.0 - 2017-08-04\n\n### New Features\n- Kernel density estimation\n\n## v0.32.0 - 2017-07-24\n\n### New Features\n* Matrix Crout decomposition\n* Categorical discrete distribution\n\n## v0.31.0 - 2017-07-02\n\n### New Features\n* Hypergeometric distribution\n* Discrete uniform distribution\n\n## v0.30.0 - 2017-06-11\n\n### New Features\n* Dirichlet multivariate distribution\n* Gamma distribution\n* Initial eigenvalue matrix method\n* Initial eigenvector matrix method\n* Confidence ellipse\n\n### Improvements\n* Internal Bitwise addition\n\n## v0.29.0 - 2017-05-21\n\n### New Features\n- Matrix rank\n- ObjectArithmetic interface\n- Polynomial implements ObjectArithmetic\n- ObjectSquareMatrix\n- Polynomial negate\n\n### Improvements\n- Refactor Matrix REF algorithm\n- Refactor Matrix RREF algorithm\n- Support functions for better handling of infinitesimal floating-point zero-like quantities\n- Fix bug in Polynomial degree calculation\n- Refactored Polynomial::add() to be simpler and faster\n\n## v0.28.0 - 2017-05-02\n\n### New Features\n* Matrix adjugate\n* Polynomial subtract\n\n### Improvements\n* Internal refactoring/improvements\n  * Tests namespace for unit tests\n  * Standardize method naming convention\n  * Update PHPUnit exception assertion\n  * Replace class strings in tests with class constants\n\n## v0.27.0 - 2017-04-23\n\n### New Features\n* Matrix\n  * Cholesky decomposition\n  * isRref\n  * Exchange matrix\n  * isInvolutory\n  * isSignature\n  * Hilbert matrix\n  * isUpperBidiagonal\n  * isLowerBidiagonal\n  * isBidiagonal\n* Quartic function roots\n* Trigonometry unit circle\n* Integer\n  * isOdd\n  * isEven\n\n## v0.26.0 - 2017-04-15\n\n### New Features\n* Initial Complex number class\n* Complex number support to quadratic and cubic equations\n* Initial Eigenvalue strategy class (2x2 and 3x3 matrices using root equations)\n* Matrix\n  * isLowerTriangular\n  * isUpperTriangular\n  * isTriangular\n  * isDiagonal\n* Beta function convenience method\n\n### Improvements\n* Add BadDataException to LeastSquares regression method trait if degrees of freedom is 0\n* Complex Root of Quadratic Function\n\n## v0.25.0 - 2017-04-01\n\n### New Features\n* Matrix\n  * isSingular\n  * isNonsingular\n  * isInvertible\n  * leadingPrincipalMinor\n  * isPositiveDefinite\n  * isPositiveSemidefinite\n  * isNegativeDefinite\n  * isNegativeSemidefinite\n* Number Theory\n  * Integer coprime\n* Arithmetic\n  * digitSum\n  * digitalRoot\n* Basic sequences\n  * digitSum\n  * digitalRoot\n\n## v0.24.0 - 2017-03-26\n\n### New Features\n* Arithmetic cube root\n* Algebra cubic equation\n* Matrix Kronecker sum\n* Vector Kronecker product\n* Number theory prime factorization\n\n### Improvements\n* Improved quadratic equation edge case handling\n\n## v0.23.0 - 2017-03-12\n\n### New Features\n* Number Theory - Integers\n * Perfect powers\n* Advanced Sequences\n * Perfect powers\n * Not perfect powers\n * Primes up to n\n* Algebra\n * Quadratic equation\n\n## v0.22.0 - 2017-01-31\n\n### New Features\n* Circular statistics (directional statistics)\n * Circular mean\n * Resultant length\n * Mean resultant length\n * Circular variance\n * Circular standard deviation\n * Describe\n* Finance profitability index\n\n### Improvements\n* Update Finance payback to be both simple and discounted payback\n\n## v0.21.0 - 2017-01-23\n\n### New Features\n* Finance interest payment\n* Finance principle payment on an annuity\n* Finance payback\n* Make files for unit tests, linting, and code coverage\n\n## v0.20.0 - 2017-01-12\n\n### New Features\n* Finance net present value\n* Finance rate function\n* Finance internal rate of return\n* Finance modified internal rate of return\n* Finance payment periods of an annuity\n\n### Improvements\n* Update Newton's Method to handle non-convergence and infinite slopes.\n\n## v0.19.0 - 2016-12-31\n\n### New Features\n* Matrix sample mean\n* Matrix mean deviation form\n* Covariance matrix\n* Matrix representation as array of column vectors\n* Finance future value\n* Finance present value\n\n## v0.18.0 - 2016-12-28\n\n### New Features\n* Joint entropy\n* RÃ©nyi entropy\n* Perplexity\n* Matrix scalar division\n* Finance: Annual Equivalent Rate (AER)\n\n### Improvements\n* Fix vector pnorm to take absolute value of each element\n\n### Backwards Incompatible Changes\n* Refactor distances and divergences from InformationTheory\\Entropy to Statistics\\Distance\n\n## v0.17.0 - 2016-12-21\n\n### New Features\n* Two-sample z significance test\n\n## v.0.16.0 - 2016-12-18\n\n### New Features\n* Information Theory\n * Shannon entropy (bits, nats, hartleys)\n * Cross entropy\n * Bhattacharyya distance\n * Kullback-Leibler divergence\n * Hellinger distance\n * Jensen-Shannon divergence\n* Linear Algebra\n * vectorMultiply method on Matrix to return Vector when multiply with a Vector\n\n## v0.15.0 - 2016-11-10\n\n### New Features\n* Lazy caterer's sequence\n* Magic squares sequence\n\n## v0.14.0 - 2016-10-28\n\n### New Features\n* Look-and-say sequence\n\n## v0.13.0 - 2016-10-17\n\n### New Features\n* Custom exception classes\n\n### Improvements\n* Refactor exceptions to use custom exception classes\n\n## v0.12.0 - 2016-10-06\n\n### New Features\n* Softmax function\n* Effect size Î·Â² (Eta-squared)\n* Effect size Î·Â²p (Partial eta-squared)\n* Effect size Ï‰Â² (omega-squared)\n* Effect size Cohen's Æ’Â²\n* Effect size Cohen's q\n* Effect size Cohen's d\n* Effect size Hedges' g\n* Effect size Glass' Î” (glass' delta)\n\n### Improvements\n* Replace mt_rand with random_int\n\n## v0.11.0 - 2016-10-01\n\n### Backwards Incompatible Changes\n* Change root namespace from Math to MathPHP\n  * (Run composer update to update autoloader)\n\n## v0.10.0 - 2016-09-28\n\n### New Features\n* Clamped Cubic Spline Interpolation\n* Custom variable in Polynomial class\n\n## v0.9.0 - 2016-09-27\n\n### New Features\n* Natural cubic spline interpolation\n* Vector direct product\n\n## v0.8.0 - 2016-09-22\n\n### New Features\n* Set Theory\n* Matrix kronecker product\n* Matrix augment below\n\n### Backwards Incompatible Changes\n* Some null return values changed to NAN when computation is invalid\n\n\n## v0.7.0 - 2016-09-19\n\n### New Features\n* Matrix solve linear system of equations\n* Noncentral T distribution\n* Piecewise function class\n* Initial Finance class (pmt function)\n* Vector scalar multiplication\n* Vector normalization\n* Vector scalar division\n* Vector perpendicular operator\n* Vector projections\n* Vector perp and perp dot product\n\n### Improvements\n* Add getters to Polynomial for degree and coefficients\n* Improvements to gamma function\n\n## v0.6.1 - 2016-09-11\n\n### Improvements\n* Fix matrix determinant calculation\n\n## v0.6.0 - 2016-09-10\n\n### New Features\n* Polynomial class\n* Vector cross product\n\n## v0.5.0 - 2016-09-07\n\n### New Features\n* Numerical Differentiation (\\Math\\NumericalAnalysis\\NumericalDifferentiation)\n  * Three Point Formula (\\Math\\NumericalAnalysis\\NumericalDifferentiation\\ThreePointFormula)\n  * Five Point Formula (\\Math\\NumericalAnalysis\\NumericalDifferentiation\\FivePointFormula)\n  * SecondDerivativeMidpointFormula (\\Math\\NumericalAnalysis\\NumericalDifferentiation\\SecondDerivativeMidpointFormula)\n* Two-way ANOVA (\\Math\\Statistics\\ANOVA)\n\n## v0.4.0 - 2016-09-07\n\n### New Features\n\n* Nevilles Method (\\Math\\NumericalAnalysis\\Interpolation)\n* Newton Polynomial (\\Math\\NumericalAnalysis\\Interpolation)\n\n## v0.3.0 - 2016-09-06\n\n### New Features\n\n* Lagrange polynomials (\\Math\\NumericalAnalysis\\Interpolation)\n* Function arithmetic (\\Math\\Functions\\Arithmetic)\n\n## v0.2.0 - 2016-09-05\n\n### New Features\n\n* One-way ANOVA (```Math\\Statistics\\ANOVA```)\n* Ï‡Â² Table (```Math\\Probability\\Distribution\\Table```)\n* Five number summary (```Math\\Statistics\\Descriptive```)\n* Simple sum of squares (```Math\\Statistics\\RandomVariable```)\n\n### Improvements\n\n* Refactor probability distribution tables (```Math\\Probability\\Distribution\\Table```)\n* Minor refactors\n\n### Backwards Incompatible Changes\n\n* Move probability distribution tables to new namespace\n  * From ```Math\\Probability``` to ```Math\\Probability\\Distribution\\Table```\n\n## v0.1.0 - 2016-09-02\n\n### New Features\n\n * Algebra\n * Functions\n   - Map\n   - Special Functions\n * Linear Algebra\n   - Matrix\n   - Vector\n * Numerical Analysis\n   - Numerical Integration\n   - Root Finding\n * Probability\n     - Combinatorics\n     - Distributions\n         * Continuous\n         * Discrete\n     - Standard Normal Table (Z Table)\n     - t Distribution Table\n * Sequences\n     - Basic\n     - Advanced\n * Statistics\n     - Averages\n     - Correlation\n     - Descriptive\n     - Distributions\n     - Experiments\n     - Random Variables\n     - Regressions\n     - Significance Testing"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2016 Mark Rogoyski\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.5634765625,
          "content": ".PHONY : lint tests style phpstan phpmd report coverage\n\nall : lint tests style phpstan phpmd report\n\ntests :\n\tvendor/bin/phpunit tests/ --configuration=tests/phpunit.xml\n\nlint :\n\tvendor/bin/parallel-lint src tests\n\nstyle :\n\tvendor/bin/phpcs --standard=tests/coding_standard.xml --ignore=vendor -s .\n\nphpstan :\n\tvendor/bin/phpstan analyze -c tests/phpstan.neon\n\nphpmd :\n\tvendor/bin/phpmd src/ ansi cleancode,codesize,design,unusedcode,naming\n\ncoverage :\n\tvendor/bin/phpunit tests/ --configuration=tests/phpunit.xml --coverage-text=php://stdout\n\nreport :\n\tvendor/bin/phploc src/"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 99.5302734375,
          "content": "![MathPHP Logo](https://github.com/markrogoyski/math-php/blob/master/docs/image/MathPHPLogo.png?raw=true)\n\n### MathPHP - Powerful Modern Math Library for PHP\n\nThe only library you need to integrate mathematical functions into your applications. It is a self-contained library in pure PHP with no external dependencies.\n\n[![Coverage Status](https://coveralls.io/repos/github/markrogoyski/math-php/badge.svg?branch=master)](https://coveralls.io/github/markrogoyski/math-php?branch=master)\n[![License](https://poser.pugx.org/markrogoyski/math-php/license)](https://packagist.org/packages/markrogoyski/math-php)\n\nFeatures\n--------\n * [Algebra](#algebra)\n * [Arithmetic](#arithmetic)\n * Expression\n   - [Polynomial](#expression---polynomial)\n * [Finance](#finance)\n * Functions\n   - [Map](#functions---map---single-array)\n   - [Special Functions](#functions---special-functions)\n * Information Theory\n   - [Entropy](#information-theory---entropy)\n * Linear Algebra\n   - [Matrix](#linear-algebra---matrix)\n   - [Vector](#linear-algebra---vector)\n * Numbers\n   - [Arbitrary Integer](#number---arbitrary-length-integers)\n   - [Complex](#number---complex-numbers)\n   - [Quaternion](#number---quaternion)\n   - [Rational](#number---rational-numbers)\n * Number Theory\n   - [Integers](#number-theory---integers)\n * Numerical Analysis\n   - [Interpolation](#numerical-analysis---interpolation)\n   - [Numerical Differentiation](#numerical-analysis---numerical-differentiation)\n   - [Numerical Integration](#numerical-analysis---numerical-integration)\n   - [Root Finding](#numerical-analysis---root-finding)\n * Probability\n     - [Combinatorics](#probability---combinatorics)\n     - Distributions\n         * [Continuous](#probability---continuous-distributions)\n         * [Discrete](#probability---discrete-distributions)\n         * [Multivariate](#probability---multivariate-distributions)\n         * [Tables](#probability---distribution-tables)\n * [Sample Data](#sample-data)\n * [Search](#search)\n * Sequences\n     - [Basic](#sequences---basic)\n     - [Advanced](#sequences---advanced)\n     - [NonInteger](#sequences---non-integer)\n * [Set Theory](#set-theory)\n * Statistics\n     - [ANOVA](#statistics---anova)\n     - [Averages](#statistics---averages)\n     - [Circular](#statistics---circular)\n     - [Correlation](#statistics---correlation)\n     - [Descriptive](#statistics---descriptive)\n     - [Distance](#statistics---distance)\n     - [Distributions](#statistics---distributions)\n     - [Divergence](#statistics---divergence)\n     - [Effect Size](#statistics---effect-size)\n     - [Experiments](#statistics---experiments)\n     - [Kernel Density Estimation](#statistics---kernel-density-estimation)\n     - Multivariate\n        * [PCA (Principal Component Analysis)](#statistics---multivariate---principal-component-analysis)\n        * [PLS (Partial Least Squares Regression)](#statistics---multivariate---partial-least-squares-regression)\n     - [Outlier](#statistics---outlier)\n     - [Random Variables](#statistics---random-variables)\n     - [Regressions](#statistics---regressions)\n     - [Significance Testing](#statistics---significance-testing)\n * [Trigonometry](#trigonometry)\n\nSetup\n-----\n\n Add the library to your `composer.json` file in your project:\n\n```javascript\n{\n  \"require\": {\n      \"markrogoyski/math-php\": \"2.*\"\n  }\n}\n```\n\nUse [composer](http://getcomposer.org) to install the library:\n\n```bash\n$ php composer.phar install\n```\n\nComposer will install MathPHP inside your vendor folder. Then you can add the following to your\n.php files to use the library with Autoloading.\n\n```php\nrequire_once __DIR__ . '/vendor/autoload.php';\n```\n\nAlternatively, use composer on the command line to require and install MathPHP:\n\n```\n$ php composer.phar require markrogoyski/math-php:2.*\n```\n\n### Minimum Requirements\n * PHP 7.2\n\n Note: For PHP 7.0 and 7.1, use v1.0 (`markrogoyski/math-php:1.*`)\n\nUsage\n-----\n\n### Algebra\n```php\nuse MathPHP\\Algebra;\n\n// Greatest common divisor (GCD)\n$gcd = Algebra::gcd(8, 12);\n\n// Extended greatest common divisor - gcd(a, b) = a*a' + b*b'\n$gcd = Algebra::extendedGcd(12, 8); // returns array [gcd, a', b']\n\n// Least common multiple (LCM)\n$lcm = Algebra::lcm(5, 2);\n\n// Factors of an integer\n$factors = Algebra::factors(12); // returns [1, 2, 3, 4, 6, 12]\n\n// Linear equation of one variable: ax + b = 0\n[$a, $b] = [2, 4]; // 2x + 4 = 0\n$x       = Algebra::linear($a, $b);\n\n// Quadratic equation: axÂ² + bx + c = 0\n[$a, $b, $c] = [1, 2, -8]; // xÂ² + 2x - 8\n[$xâ‚, $xâ‚‚]   = Algebra::quadratic($a, $b, $c);\n\n// Discriminant: Î” = bÂ² - 4ac\n[$a, $b, $c] = [2, 3, 4]; // 3Â² - 4(2)(4)\n$Î”           = Algebra::discriminant($a, $b, $c);\n\n// Cubic equation: zÂ³ + aâ‚‚zÂ² + aâ‚z + aâ‚€ = 0\n[$aâ‚ƒ, $aâ‚‚, $aâ‚, $aâ‚€] = [2, 9, 3, -4]; // 2xÂ³ + 9xÂ² + 3x -4\n[$xâ‚, $xâ‚‚, $xâ‚ƒ]      = Algebra::cubic($aâ‚ƒ, $aâ‚‚, $aâ‚, $aâ‚€);\n\n// Quartic equation: aâ‚„zâ´ + aâ‚ƒzÂ³ + aâ‚‚zÂ² + aâ‚z + aâ‚€ = 0\n[$aâ‚„, $aâ‚ƒ, $aâ‚‚, $aâ‚, $aâ‚€] = [1, -10, 35, -50, 24]; // zâ´ - 10zÂ³ + 35zÂ² - 50z + 24 = 0\n[$zâ‚, $zâ‚‚, $zâ‚ƒ, $zâ‚„]      = Algebra::quartic($aâ‚„, $aâ‚ƒ, $aâ‚‚, $aâ‚, $aâ‚€);\n```\n\n### Arithmetic\n```php\nuse MathPHP\\Arithmetic;\n\n$âˆšx  = Arithmetic::isqrt(8);     // 2 Integer square root\n$Â³âˆšx = Arithmetic::cubeRoot(-8); // -2\n$â¿âˆšx = Arithmetic::root(81, 4);  // náµ—Ê° root (4áµ—Ê°): 3\n\n// Sum of digits\n$digit_sum    = Arithmetic::digitSum(99);    // 18\n$digital_root = Arithmetic::digitalRoot(99); // 9\n\n// Equality of numbers within a tolerance\n$x = 0.00000003458;\n$y = 0.00000003455;\n$Îµ = 0.0000000001;\n$almostEqual = Arithmetic::almostEqual($x, $y, $Îµ); // true\n\n// Copy sign\n$magnitude = 5;\n$sign      = -3;\n$signed_magnitude = Arithmetic::copySign($magnitude, $sign); // -5\n\n// Modulo (Differs from PHP remainder (%) operator for negative numbers)\n$dividend = 12;\n$divisor  = 5;\n$modulo   = Arithmetic::modulo($dividend, $divisor);  // 2\n$modulo   = Arithmetic::modulo(-$dividend, $divisor); // 3\n```\n\n### Expression - Polynomial\n```php\nuse MathPHP\\Expression\\Polynomial;\n\n// Polynomial xÂ² + 2x + 3\n$coefficients = [1, 2, 3]\n$polynomial   = new Polynomial($coefficients);\n\n// Evaluate for x = 3\n$x = 3;\n$y = $polynomial($x);  // 18: 3Â² + 2*3 + 3\n\n// Calculus\n$derivative = $polynomial->differentiate();  // Polynomial 2x + 2\n$integral   = $polynomial->integrate();      // Polynomial â…“xÂ³ + xÂ² + 3x\n\n// Arithmetic\n$sum        = $polynomial->add($polynomial);       // Polynomial 2xÂ² + 4x + 6\n$sum        = $polynomial->add(2);                 // Polynomial xÂ² + 2x + 5\n$difference = $polynomial->subtract($polynomial);  // Polynomial 0\n$difference = $polynomial->subtract(2);            // Polynomial xÂ² + 2x + 1\n$product    = $polynomial->multiply($polynomial);  // Polynomial xâ´ + 4xÂ³ + 10xÂ² + 12x + 9\n$product    = $polynomial->multiply(2);            // Polynomial 2xÂ² + 4x + 6\n$negated    = $polynomial->negate();               // Polynomial -xÂ² - 2x - 3\n\n// Data\n$degree       = $polynomial->getDegree();        // 2\n$coefficients = $polynomial->getCoefficients();  // [1, 2, 3]\n\n// String representation\nprint($polynomial);  // xÂ² + 2x + 3\n\n// Roots\n$polynomial = new Polynomial([1, -3, -4]);\n$roots      = $polynomial->roots();         // [-1, 4]\n\n// Companion matrix\n$companion = $polynomial->companionMatrix();\n```\n\n### Finance\n```php\nuse MathPHP\\Finance;\n\n// Financial payment for a loan or annuity with compound interest\n$rate          = 0.035 / 12; // 3.5% interest paid at the end of every month\n$periods       = 30 * 12;    // 30-year mortgage\n$present_value = 265000;     // Mortgage note of $265,000.00\n$future_value  = 0;\n$beginning     = false;      // Adjust the payment to the beginning or end of the period\n$pmt           = Finance::pmt($rate, $periods, $present_value, $future_value, $beginning);\n\n// Interest on a financial payment for a loan or annuity with compound interest.\n$period = 1; // First payment period\n$ipmt   = Finance::ipmt($rate, $period, $periods, $present_value, $future_value, $beginning);\n\n// Principle on a financial payment for a loan or annuity with compound interest\n$ppmt = Finance::ppmt($rate, $period, $periods, $present_value, $future_value = 0, $beginning);\n\n// Number of payment periods of an annuity.\n$periods = Finance::periods($rate, $payment, $present_value, $future_value, $beginning);\n\n// Annual Equivalent Rate (AER) of an annual percentage rate (APR)\n$nominal = 0.035; // APR 3.5% interest\n$periods = 12;    // Compounded monthly\n$aer     = Finance::aer($nominal, $periods);\n\n// Annual nominal rate of an annual effective rate (AER)\n$nomial = Finance::nominal($aer, $periods);\n\n// Future value for a loan or annuity with compound interest\n$payment = 1189.97;\n$fv      = Finance::fv($rate, $periods, $payment, $present_value, $beginning)\n\n// Present value for a loan or annuity with compound interest\n$pv = Finance::pv($rate, $periods, $payment, $future_value, $beginning)\n\n// Net present value of cash flows\n$values = [-1000, 100, 200, 300, 400];\n$npv    = Finance::npv($rate, $values);\n\n// Interest rate per period of an annuity\n$beginning = false; // Adjust the payment to the beginning or end of the period\n$rate      = Finance::rate($periods, $payment, $present_value, $future_value, $beginning);\n\n// Internal rate of return\n$values = [-100, 50, 40, 30];\n$irr    = Finance::irr($values); // Rate of return of an initial investment of $100 with returns of $50, $40, and $30\n\n// Modified internal rate of return\n$finance_rate      = 0.05; // 5% financing\n$reinvestment_rate = 0.10; // reinvested at 10%\n$mirr              = Finance::mirr($values, $finance_rate); // rate of return of an initial investment of $100 at 5% financing with returns of $50, $40, and $30 reinvested at 10%\n\n// Discounted payback of an investment\n$values  = [-1000, 100, 200, 300, 400, 500];\n$rate    = 0.1;\n$payback = Finance::payback($values, $rate); // The payback period of an investment with a $1,000 investment and future returns of $100, $200, $300, $400, $500 and a discount rate of 0.10\n\n// Profitability index\n$values              = [-100, 50, 50, 50];\n$profitability_index = Finance::profitabilityIndex($values, $rate); // The profitability index of an initial $100 investment with future returns of $50, $50, $50 with a 10% discount rate\n```\n\n### Functions - Map - Single Array\n```php\nuse MathPHP\\Functions\\Map;\n\n$x = [1, 2, 3, 4];\n\n$sums        = Map\\Single::add($x, 2);      // [3, 4, 5, 6]\n$differences = Map\\Single::subtract($x, 1); // [0, 1, 2, 3]\n$products    = Map\\Single::multiply($x, 5); // [5, 10, 15, 20]\n$quotients   = Map\\Single::divide($x, 2);   // [0.5, 1, 1.5, 2]\n$xÂ²          = Map\\Single::square($x);      // [1, 4, 9, 16]\n$xÂ³          = Map\\Single::cube($x);        // [1, 8, 27, 64]\n$xâ´          = Map\\Single::pow($x, 4);      // [1, 16, 81, 256]\n$âˆšx          = Map\\Single::sqrt($x);        // [1, 1.414, 1.732, 2]\n$âˆ£xâˆ£         = Map\\Single::abs($x);         // [1, 2, 3, 4]\n$maxes       = Map\\Single::max($x, 3);      // [3, 3, 3, 4]\n$mins        = Map\\Single::min($x, 3);      // [1, 2, 3, 3]\n$reciprocals = Map\\Single::reciprocal($x);  // [1, 1/2, 1/3, 1/4]\n```\n\n### Functions - Map - Multiple Arrays\n```php\nuse MathPHP\\Functions\\Map;\n\n$x = [10, 10, 10, 10];\n$y = [1,   2,  5, 10];\n\n// Map function against elements of two or more arrays, item by item (by item ...)\n$sums        = Map\\Multi::add($x, $y);      // [11, 12, 15, 20]\n$differences = Map\\Multi::subtract($x, $y); // [9, 8, 5, 0]\n$products    = Map\\Multi::multiply($x, $y); // [10, 20, 50, 100]\n$quotients   = Map\\Multi::divide($x, $y);   // [10, 5, 2, 1]\n$maxes       = Map\\Multi::max($x, $y);      // [10, 10, 10, 10]\n$mins        = Map\\Multi::mins($x, $y);     // [1, 2, 5, 10]\n\n// All functions work on multiple arrays; not limited to just two\n$x    = [10, 10, 10, 10];\n$y    = [1,   2,  5, 10];\n$z    = [4,   5,  6,  7];\n$sums = Map\\Multi::add($x, $y, $z); // [15, 17, 21, 27]\n```\n\n### Functions - Special Functions\n```php\nuse MathPHP\\Functions\\Special;\n\n// Gamma function Î“(z)\n$z = 4;\n$Î“ = Special::gamma($z);\n$Î“ = Special::gammaLanczos($z);   // Lanczos approximation\n$Î“ = Special::gammaStirling($z);  // Stirling approximation\n$l = Special::logGamma($z);\n$c = Special::logGammaCorr($z);   // Log gamma correction\n\n// Incomplete gamma functions - Î³(s,t), Î“(s,x), P(s,x)\n[$x, $s] = [1, 2];\n$Î³ = Special::lowerIncompleteGamma($x, $s);\n$Î“ = Special::upperIncompleteGamma($x, $s);\n$P = Special::regularizedLowerIncompleteGamma($x, $s);\n\n// Beta function\n[$x, $y] = [1, 2];\n$Î²  = Special::beta($x, $y);\n$lÎ² = Special::logBeta($x, $y);\n\n// Incomplete beta functions\n[$x, $a, $b] = [0.4, 2, 3];\n$B  = Special::incompleteBeta($x, $a, $b);\n$Iâ‚“ = Special::regularizedIncompleteBeta($x, $a, $b);\n\n// Multivariate beta function\n$Î±s = [1, 2, 3];\n$Î²  = Special::multivariateBeta($Î±s);\n\n// Error function (Gauss error function)\n$error = Special::errorFunction(2);              // same as erf\n$error = Special::erf(2);                        // same as errorFunction\n$error = Special::complementaryErrorFunction(2); // same as erfc\n$error = Special::erfc(2);                       // same as complementaryErrorFunction\n\n// Hypergeometric functions\n$pFq = Special::generalizedHypergeometric($p, $q, $a, $b, $c, $z);\n$â‚Fâ‚ = Special::confluentHypergeometric($a, $b, $z);\n$â‚‚Fâ‚ = Special::hypergeometric($a, $b, $c, $z);\n\n// Sign function (also known as signum or sgn)\n$x    = 4;\n$sign = Special::signum($x); // same as sgn\n$sign = Special::sgn($x);    // same as signum\n\n// Logistic function (logistic sigmoid function)\n$xâ‚€ = 2; // x-value of the sigmoid's midpoint\n$L  = 3; // the curve's maximum value\n$k  = 4; // the steepness of the curve\n$x  = 5;\n$logistic = Special::logistic($xâ‚€, $L, $k, $x);\n\n// Sigmoid function\n$t = 2;\n$sigmoid = Special::sigmoid($t);\n\n// Softmax function\n$ð³    = [1, 2, 3, 4, 1, 2, 3];\n$ÏƒâŸ®ð³âŸ¯â±¼ = Special::softmax($ð³);\n\n// Log of the error term in the Stirling-De Moivre factorial series\n$err = Special::stirlingError($n);\n```\n\n### Information Theory - Entropy\n```php\nuse MathPHP\\InformationTheory\\Entropy;\n\n// Probability distributions\n$p = [0.2, 0.5, 0.3];\n$q = [0.1, 0.4, 0.5];\n\n// Shannon entropy\n$bits  = Entropy::shannonEntropy($p);         // logâ‚‚\n$nats  = Entropy::shannonNatEntropy($p);      // ln\n$harts = Entropy::shannonHartleyEntropy($p);  // logâ‚â‚€\n\n// Cross entropy\n$HâŸ®pã€qâŸ¯ = Entropy::crossEntropy($p, $q);       // logâ‚‚\n\n// Joint entropy\n$PâŸ®xã€yâŸ¯ = [1/2, 1/4, 1/4, 0];\nHâŸ®xã€yâŸ¯ = Entropy::jointEntropy($PâŸ®xã€yâŸ¯);        // logâ‚‚\n\n// RÃ©nyi entropy\n$Î±    = 0.5;\n$Hâ‚âŸ®XâŸ¯ = Entropy::renyiEntropy($p, $Î±);         // logâ‚‚\n\n// Perplexity\n$perplexity = Entropy::perplexity($p);         // logâ‚‚\n```\n\n### Linear Algebra - Matrix\n```php\nuse MathPHP\\LinearAlgebra\\Matrix;\nuse MathPHP\\LinearAlgebra\\MatrixFactory;\n\n// Create an m Ã— n matrix from an array of arrays\n$matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n];\n$A = MatrixFactory::create($matrix);\n\n// Basic matrix data\n$array = $A->getMatrix();  // Original array of arrays\n$rows  = $A->getM();       // number of rows\n$cols  = $A->getN();       // number of columns\n\n// Basic matrix element getters (zero-based indexing)\n$row = $A->getRow(2);\n$col = $A->getColumn(2);\n$Aáµ¢â±¼ = $A->get(2, 2);\n$Aáµ¢â±¼ = $A[2][2];\n\n// Row operations\n[$máµ¢, $mâ±¼, $k] = [1, 2, 5];\n$R = $A->rowInterchange($máµ¢, $mâ±¼);\n$R = $A->rowExclude($máµ¢);             // Exclude row $máµ¢\n$R = $A->rowMultiply($máµ¢, $k);        // Multiply row máµ¢ by k\n$R = $A->rowDivide($máµ¢, $k);          // Divide row máµ¢ by k\n$R = $A->rowAdd($máµ¢, $mâ±¼, $k);        // Add k * row máµ¢ to row mâ±¼\n$R = $A->rowAddScalar($máµ¢, $k);       // Add k to each item of row máµ¢\n$R = $A->rowAddVector($máµ¢, $V);       // Add Vector V to row máµ¢\n$R = $A->rowSubtract($máµ¢, $mâ±¼, $k);   // Subtract k * row máµ¢ from row mâ±¼\n$R = $A->rowSubtractScalar($máµ¢, $k);  // Subtract k from each item of row máµ¢\n\n// Column operations\n[$náµ¢, $nâ±¼, $k] = [1, 2, 5];\n$R = $A->columnInterchange($náµ¢, $nâ±¼);\n$R = $A->columnExclude($náµ¢);          // Exclude column $náµ¢\n$R = $A->columnMultiply($náµ¢, $k);     // Multiply column náµ¢ by k\n$R = $A->columnAdd($náµ¢, $nâ±¼, $k);     // Add k * column náµ¢ to column nâ±¼\n$R = $A->columnAddVector($náµ¢, $V);    // Add Vector V to column náµ¢\n\n// Matrix augmentations - return a new Matrix\n$âŸ®Aâˆ£BâŸ¯ = $A->augment($B);        // Augment on the right - standard augmentation\n$âŸ®Aâˆ£IâŸ¯ = $A->augmentIdentity();  // Augment with the identity matrix\n$âŸ®Aâˆ£BâŸ¯ = $A->augmentBelow($B);\n$âŸ®Aâˆ£BâŸ¯ = $A->augmentAbove($B);\n$âŸ®Bâˆ£AâŸ¯ = $A->augmentLeft($B);\n\n// Matrix arithmetic operations - return a new Matrix\n$Aï¼‹B = $A->add($B);\n$AâŠ•B  = $A->directSum($B);\n$AâŠ•B  = $A->kroneckerSum($B);\n$Aâˆ’B  = $A->subtract($B);\n$AB   = $A->multiply($B);\n$ï¼’A  = $A->scalarMultiply(2);\n$Aï¼2 = $A->scalarDivide(2);\n$âˆ’A   = $A->negate();\n$Aâˆ˜B  = $A->hadamardProduct($B);\n$AâŠ—B  = $A->kroneckerProduct($B);\n\n// Matrix operations - return a new Matrix\n$Aáµ€ ã€€ = $A->transpose();\n$D  ã€€ = $A->diagonal();\n$Aâ»Â¹   = $A->inverse();\n$Máµ¢â±¼   = $A->minorMatrix($máµ¢, $nâ±¼);        // Square matrix with row máµ¢ and column nâ±¼ removed\n$Mk    = $A->leadingPrincipalMinor($k);    // káµ—Ê°-order leading principal minor\n$CM    = $A->cofactorMatrix();\n$B     = $A->meanDeviation();              // optional parameter to specify data direction (variables in 'rows' or 'columns')\n$S     = $A->covarianceMatrix();           // optional parameter to specify data direction (variables in 'rows' or 'columns')\n$adjâŸ®AâŸ¯ = $A->adjugate();\n$Máµ¢â±¼   = $A->submatrix($máµ¢, $náµ¢, $mâ±¼, $nâ±¼) // Submatrix of A from row máµ¢, column náµ¢ to row mâ±¼, column nâ±¼\n$H     = $A->householder();\n\n// Matrix value operations - return a value\n$trâŸ®AâŸ¯   = $A->trace();\n$|A|    = $a->det();              // Determinant\n$Máµ¢â±¼    = $A->minor($máµ¢, $nâ±¼);    // First minor\n$Cáµ¢â±¼    = $A->cofactor($máµ¢, $nâ±¼);\n$rankâŸ®AâŸ¯ = $A->rank();\n\n// Matrix vector operations - return a new Vector\n$AB = $A->vectorMultiply($Xâ‚);\n$M  = $A->rowSums();\n$M  = $A->columnSums();\n$M  = $A->rowMeans();\n$M  = $A->columnMeans();\n\n// Matrix norms - return a value\n$â€–Aâ€–â‚ = $A->oneNorm();\n$â€–Aâ€–F = $A->frobeniusNorm(); // Hilbertâ€“Schmidt norm\n$â€–Aâ€–âˆž = $A->infinityNorm();\n$max   = $A->maxNorm();\n\n// Matrix reductions\n$ref  = $A->ref();   // Matrix in row echelon form\n$rref = $A->rref();  // Matrix in reduced row echelon form\n\n// Matrix decompositions\n// LU decomposition\n$LU = $A->luDecomposition();\n$L  = $LU->L;  // lower triangular matrix\n$U  = $LU->U;  // upper triangular matrix\n$P  = $LU-P;   // permutation matrix\n\n// QR decomposition\n$QR = $A->qrDecomposition();\n$Q  = $QR->Q;  // orthogonal matrix\n$R  = $QR->R;  // upper triangular matrix\n\n// SVD (Singular Value Decomposition)\n$SVD = $A->svd();\n$U   = $A->U;  // m x m orthogonal matrix\n$V   = $A->V;  // n x n orthogonal matrix\n$S   = $A->S;  // m x n diagonal matrix of singular values\n$D   = $A->D;  // Vector of diagonal elements from S\n\n// Crout decomposition\n$LU = $A->croutDecomposition();\n$L  = $LU->L;  // lower triangular matrix\n$U  = $LU->U;  // normalized upper triangular matrix\n\n// Cholesky decomposition\n$LLáµ€ = $A->choleskyDecomposition();\n$L   = $LLáµ€->L;   // lower triangular matrix\n$LT  = $LLáµ€->LT;  // transpose of lower triangular matrix\n\n// Eigenvalues and eigenvectors\n$eigenvalues   = $A->eigenvalues();   // array of eigenvalues\n$eigenvecetors = $A->eigenvectors();  // Matrix of eigenvectors\n\n// Solve a linear system of equations: Ax = b\n$b = new Vector(1, 2, 3);\n$x = $A->solve($b);\n\n// Map a function over each element\n$func = function($x) {\n    return $x * 2;\n};\n$R = $A->map($func);  // using closure\n$R = $A->map('abs');  // using callable\n\n// Map a function over each row\n$array = $A->mapRows('array_reverse');  // using callable returns matrix-like array of arrays\n$array = $A->mapRows('array_sum');     // using callable returns array of aggregate calculations\n\n// Walk maps a function to all values without mutation or returning a value\n$A->walk($func);\n\n// Matrix comparisons\n$bool = $A->isEqual($B);\n\n// Matrix properties - return a bool\n$bool = $A->isSquare();\n$bool = $A->isSymmetric();\n$bool = $A->isSkewSymmetric();\n$bool = $A->isSingular();\n$bool = $A->isNonsingular();           // Same as isInvertible\n$bool = $A->isInvertible();            // Same as isNonsingular\n$bool = $A->isPositiveDefinite();\n$bool = $A->isPositiveSemidefinite();\n$bool = $A->isNegativeDefinite();\n$bool = $A->isNegativeSemidefinite();\n$bool = $A->isLowerTriangular();\n$bool = $A->isUpperTriangular();\n$bool = $A->isTriangular();\n$bool = $A->isDiagonal();\n$bool = $A->isRectangularDiagonal();\n$bool = $A->isUpperBidiagonal();\n$bool = $A->isLowerBidiagonal();\n$bool = $A->isBidiagonal();\n$bool = $A->isTridiagonal();\n$bool = $A->isUpperHessenberg();\n$bool = $A->isLowerHessenberg();\n$bool = $A->isOrthogonal();\n$bool = $A->isNormal();\n$bool = $A->isIdempotent();\n$bool = $A->isNilpotent();\n$bool = $A->isInvolutory();\n$bool = $A->isSignature();\n$bool = $A->isRef();\n$bool = $A->isRref();\n\n// Other representations of matrix data\n$vectors = $A->asVectors();                 // array of column vectors\n$D       = $A->getDiagonalElements();       // array of the diagonal elements\n$d       = $A->getSuperdiagonalElements();  // array of the superdiagonal elements\n$d       = $A->getSubdiagonalElements();    // array of the subdiagonal elements\n\n// String representation - Print a matrix\nprint($A);\n/*\n [1, 2, 3]\n [2, 3, 4]\n [3, 4, 5]\n */\n\n// PHP Predefined Interfaces\n$json = json_encode($A); // JsonSerializable\n$Aáµ¢â±¼  = $A[$máµ¢][$nâ±¼];    // ArrayAccess\n```\n\n#### Linear Algebra - Matrix Construction (Factory)\n```php\n$matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n];\n\n// Matrix factory creates most appropriate matrix\n$A = MatrixFactory::create($matrix);\n\n// Matrix factory can create a matrix from an array of column vectors\nuse MathPHP\\LinearAlgebra\\Vector;\n$Xâ‚ = new Vector([1, 4, 7]);\n$Xâ‚‚ = new Vector([2, 5, 8]);\n$Xâ‚ƒ = new Vector([3, 6, 9]);\n$A  = MatrixFactory::createFromVectors([$Xâ‚, $Xâ‚‚, $Xâ‚ƒ]);\n\n// Create from row or column vector\n$A = MatrixFactory::createFromRowVector([1, 2, 3]);    // 1 Ã— n matrix consisting of a single row of n elements\n$A = MatrixFactory::createFromColumnVector([1, 2, 3]); // m Ã— 1 matrix consisting of a single column of m elements\n\n// Specialized matrices\n[$m, $n, $k, $angle, $size]   = [4, 4, 2, 3.14159, 2];\n$identity_matrix              = MatrixFactory::identity($n);                   // Ones on the main diagonal\n$zero_matrix                  = MatrixFactory::zero($m, $n);                   // All zeros\n$ones_matrix                  = MatrixFactory::one($m, $n);                    // All ones\n$eye_matrix                   = MatrixFactory::eye($m, $n, $k);                // Ones (or other value) on the k-th diagonal\n$exchange_matrix              = MatrixFactory::exchange($n);                   // Ones on the reverse diagonal\n$downshift_permutation_matrix = MatrixFactory::downshiftPermutation($n);       // Permutation matrix that pushes the components of a vector down one notch with wraparound\n$upshift_permutation_matrix   = MatrixFactory::upshiftPermutation($n);         // Permutation matrix that pushes the components of a vector up one notch with wraparound\n$diagonal_matrix              = MatrixFactory::diagonal([1, 2, 3]);            // 3 x 3 diagonal matrix with zeros above and below the diagonal\n$hilbert_matrix               = MatrixFactory::hilbert($n);                    // Square matrix with entries being the unit fractions\n$vandermonde_matrix           = MatrixFactory::vandermonde([1, 2, 3], 4);      // 4 x 3 Vandermonde matrix\n$random_matrix                = MatrixFactory::random($m, $n);                 // m x n matrix of random integers\n$givens_matrix                = MatrixFactory::givens($m, $n, $angle, $size);  // givens rotation matrix\n```\n\n### Linear Algebra - Vector\n```php\nuse MathPHP\\LinearAlgebra\\Vector;\n\n// Vector\n$A = new Vector([1, 2]);\n$B = new Vector([2, 4]);\n\n// Basic vector data\n$array = $A->getVector();\n$n     = $A->getN();           // number of elements\n$M     = $A->asColumnMatrix(); // Vector as an nx1 matrix\n$M     = $A->asRowMatrix();    // Vector as a 1xn matrix\n\n// Basic vector elements (zero-based indexing)\n$item = $A->get(1);\n\n// Vector numeric operations - return a value\n$sum               = $A->sum();\n$â”‚Aâ”‚               = $A->length();                            // same as l2Norm\n$max               = $A->max();\n$min               = $A->min();\n$Aâ‹…B               = $A->dotProduct($B);                      // same as innerProduct\n$Aâ‹…B               = $A->innerProduct($B);                    // same as dotProduct\n$AâŠ¥â‹…B              = $A->perpDotProduct($B);\n$radAngle          = $A->angleBetween($B);                    // angle in radians\n$degAngle          = $A->angleBetween($B, $inDegrees = true); // angle in degrees\n$taxicabDistance   = $A->l1Distance($B);                      // same as minkowskiDistance($B, 1)\n$euclidDistance    = $A->l2Distance($B);                      // same as minkowskiDistance($B, 2)\n$minkowskiDistance = $A->minkowskiDistance($B, $p = 2);\n\n// Vector arithmetic operations - return a Vector\n$Aï¼‹B  = $A->add($B);\n$Aâˆ’B   = $A->subtract($B);\n$AÃ—B   = $A->multiply($B);\n$Aï¼B  = $A->divide($B);\n$kA    = $A->scalarMultiply($k);\n$Aï¼k  = $A->scalarDivide($k);\n\n// Vector operations - return a Vector or Matrix\n$Aâ¨‚B  = $A->outerProduct($B);  // Same as direct product\n$AB    = $A->directProduct($B); // Same as outer product\n$AxB   = $A->crossProduct($B);\n$Aâ¨‚B   = $A->kroneckerProduct($B);\n$Ã‚     = $A->normalize();\n$AâŠ¥    = $A->perpendicular();\n$projáµ‡A = $A->projection($B);   // projection of A onto B\n$perpáµ‡A = $A->perp($B);         // perpendicular of A on B\n\n// Vector norms - return a value\n$lâ‚norm = $A->l1Norm();\n$lÂ²norm = $A->l2Norm();\n$pnorm  = $A->pNorm();\n$max    = $A->maxNorm();\n\n// String representation\nprint($A);  // [1, 2]\n\n// PHP standard interfaces\n$n    = count($A);                // Countable\n$json = json_encode($A);          // JsonSerializable\n$Aáµ¢   = $A[$i];                   // ArrayAccess\nforeach ($A as $element) { ... }  // Iterator\n```\n\n### Number - Arbitrary Length Integers\n```php\nuse MathPHP\\Number;\nuse MathPHP\\Functions;\n\n// Create arbitrary-length big integers from int or string\n$bigInt = new Number\\ArbitraryInteger('876937869482938749389832');\n\n// Unary functions\n$âˆ’bigInt  = $bigInt->negate();\n$âˆšbigInt  = $bigInt->isqrt();       // Integer square root\n$â”‚bitIntâ”‚ = $bigInt->abs();         // Absolute value\n$bigIntï¼  = $bigInt->fact();\n$bool     = $bigInt->isPositive();\n\n// Binary functions\n$sum              = $bigInt->add($bigInt);\n$difference       = $bigInt->subtract($bigInt);\n$product          = $bigInt->multiply($bigInt);\n$quotient         = $bigInt->intdiv($divisor);\n$mod              = $bigInt->mod($divisor);\n[$quotient, $mod] = $bigInt->fullIntdiv($divisor);\n$pow              = $bigInt->pow($exponent);\n$shifted          = $bigInt->leftShift(2);\n\n// Comparison functions\n$bool = $bigInt->equals($bigInt);\n$bool = $bigInt->greaterThan($bigInt);\n$bool = $bigInt->lessThan($bigInt);\n\n// Conversions\n$int    = $bigInt->toInt();\n$float  = $bigInt->toFloat();\n$binary = $bigInt->toBinary();\n$string = (string) $bigInt;\n\n// Functions\n$ackermann    = Functions\\ArbitraryInteger::ackermann($bigInt);\n$randomBigInt = Functions\\ArbitaryInteger::rand($intNumberOfBytes);\n```\n\n### Number - Complex Numbers\n```php\nuse MathPHP\\Number\\Complex;\n\n[$r, $i] = [2, 4];\n$complex = new Complex($r, $i);\n\n// Accessors\n$r = $complex->r;\n$i = $complex->i;\n\n// Unary functions\n$conjugate = $complex->complexConjugate();\n$â”‚câ”‚       = $complex->abs();     // absolute value (modulus)\n$argâŸ®câŸ¯     = $complex->arg();     // argument (phase)\n$âˆšc        = $complex->sqrt();    // positive square root\n[$zâ‚, $zâ‚‚] = $complex->roots();\n$câ»Â¹       = $complex->inverse();\n$âˆ’c        = $complex->negate();\n[$r, $Î¸]   = $complex->polarForm();\n\n// Binary functions\n$cï¼‹c = $complex->add($complex);\n$câˆ’c  = $complex->subtract($complex);\n$cÃ—c  = $complex->multiply($complex);\n$cï¼c = $complex->divide($complex);\n\n// Other functions\n$bool   = $complex->equals($complex);\n$string = (string) $complex;\n```\n\n### Number - Quaternion\n```php\nUse MathPHP\\Number\\Quaternion;\n\n$r = 4;\n$i = 1;\n$j = 2;\n$k = 3;\n\n$quaternion = new Quaternion($r, $i, $j, $k);\n\n// Get individual parts\n[$r, $i, $j, $k] = [$quaternion->r, $quaternion->i, $quaternion->j, $quaternion->k];\n\n// Unary functions\n$conjugate    = $quaternion->complexConjugate();\n$â”‚qâ”‚          = $quaternion->abs();  // absolute value (magnitude)\n$quaternionâ»Â¹ = $quaternion->inverse();\n$âˆ’q           = $quaternion->negate();\n\n// Binary functions\n$qï¼‹q = $quaternion->add($quaternion);\n$qâˆ’q  = $quaternion->subtract($quaternion);\n$qÃ—q  = $quaternion->multiply($quaternion);\n$qï¼q = $quaternion->divide($quaternion);\n\n// Other functions\n$bool = $quaternion->equals($quaternion);\n```\n\n### Number - Rational Numbers\n```php\nuse MathPHP\\Number\\Rational;\n\n$whole       = 0;\n$numerator   = 2;\n$denominator = 3;\n\n$rational = new Rational($whole, $numerator, $denominator);  // Â²/â‚ƒ\n\n// Get individual parts\n$whole       = $rational->getWholePart();\n$numerator   = $rational->getNumerator();\n$denominator = $rational->getDenominator();\n\n// Unary functions\n$â”‚rationalâ”‚ = $rational->abs();\n$inverse    = $rational->inverse();\n\n// Binary functions\n$sum            = $rational->add($rational);\n$diff           = $rational->subtract($rational);\n$product        = $rational->multiply($rational);\n$quotient       = $rational->divide($rational);\n$exponentiation = $rational->pow(2);\n\n// Other functions\n$bool   = $rational->equals($rational);\n$float  = $rational->toFloat();\n$string = (string) $rational;\n```\n\n### Number Theory - Integers\n```php\nuse MathPHP\\NumberTheory\\Integer;\n\n$n = 225;\n\n// Prime numbers\n$bool    = Integer::isPrime($n);\n$factors = Integer::primeFactorization($n);\n\n// Divisor function\n$int  = Integer::numberOfDivisors($n);\n$int  = Integer::sumOfDivisors($n);\n\n// Aliquot sums\n$int  = Integer::aliquotSum($n);        // sum-of-divisors - n\n$bool = Integer::isPerfectNumber($n);   // n = aliquot sum\n$bool = Integer::isDeficientNumber($n); // n > aliquot sum\n$bool = Integer::isAbundantNumber($n);  // n < aliquot sum\n\n// Totients\n$int  = Integer::totient($n);        // Jordan's totient k=1 (Euler's totient)\n$int  = Integer::totient($n, 2);     // Jordan's totient k=2\n$int  = Integer::cototient($n);      // Cototient\n$int  = Integer::reducedTotient($n); // Carmichael's function\n\n// MÃ¶bius function\n$int  = Integer::mobius($n);\n\n// Radical/squarefree kernel\n$int  = Integer::radical($n);\n\n// Squarefree\n$bool = Integer::isSquarefree($n);\n\n// Refactorable number\n$bool = Integer::isRefactorableNumber($n);\n\n// Sphenic number\n$bool = Integer::isSphenicNumber($n);\n\n// Perfect powers\n$bool    = Integer::isPerfectPower($n);\n[$m, $k] = Integer::perfectPower($n);\n\n// Coprime\n$bool = Integer::coprime(4, 35);\n\n// Even and odd\n$bool = Integer::isEven($n);\n$bool = Integer::isOdd($n);\n```\n\n### Numerical Analysis - Interpolation\n```php\nuse MathPHP\\NumericalAnalysis\\Interpolation;\n\n// Interpolation is a method of constructing new data points with the range\n// of a discrete set of known data points.\n// Each integration method can take input in two ways:\n//  1) As a set of points (inputs and outputs of a function)\n//  2) As a callback function, and the number of function evaluations to\n//     perform on an interval between a start and end point.\n\n// Input as a set of points\n$points = [[0, 1], [1, 4], [2, 9], [3, 16]];\n\n// Input as a callback function\n$fâŸ®xâŸ¯ = function ($x) {\n    return $x**2 + 2 * $x + 1;\n};\n[$start, $end, $n] = [0, 3, 4];\n\n// Lagrange Polynomial\n// Returns a function p(x) of x\n$p = Interpolation\\LagrangePolynomial::interpolate($points);                // input as a set of points\n$p = Interpolation\\LagrangePolynomial::interpolate($fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n$p(0) // 1\n$p(3) // 16\n\n// Nevilles Method\n// More accurate than Lagrange Polynomial Interpolation given the same input\n// Returns the evaluation of the interpolating polynomial at the $target point\n$target = 2;\n$result = Interpolation\\NevillesMethod::interpolate($target, $points);                // input as a set of points\n$result = Interpolation\\NevillesMethod::interpolate($target, $fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n// Newton Polynomial (Forward)\n// Returns a function p(x) of x\n$p = Interpolation\\NewtonPolynomialForward::interpolate($points);                // input as a set of points\n$p = Interpolation\\NewtonPolynomialForward::interpolate($fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n$p(0) // 1\n$p(3) // 16\n\n// Natural Cubic Spline\n// Returns a piecewise polynomial p(x)\n$p = Interpolation\\NaturalCubicSpline::interpolate($points);                // input as a set of points\n$p = Interpolation\\NaturalCubicSpline::interpolate($fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n$p(0) // 1\n$p(3) // 16\n\n// Clamped Cubic Spline\n// Returns a piecewise polynomial p(x)\n\n// Input as a set of points\n$points = [[0, 1, 0], [1, 4, -1], [2, 9, 4], [3, 16, 0]];\n\n// Input as a callback function\n$fâŸ®xâŸ¯ = function ($x) {\n    return $x**2 + 2 * $x + 1;\n};\n$fâ€™âŸ®xâŸ¯ = function ($x) {\n    return 2*$x + 2;\n};\n[$start, $end, $n] = [0, 3, 4];\n\n$p = Interpolation\\ClampedCubicSpline::interpolate($points);                       // input as a set of points\n$p = Interpolation\\ClampedCubicSpline::interpolate($fâŸ®xâŸ¯, $fâ€™âŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n$p(0); // 1\n$p(3); // 16\n\n// Regular Grid Interpolation\n// Returns a scalar\n\n// Points defining the regular grid\n$xs = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n$ys = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];\n$zs = [110, 111, 112, 113, 114, 115, 116, 117, 118, 119];\n\n// Data on the regular grid in n dimensions\n$data = [];\n$func = function ($x, $y, $z) {\n    return 2 * $x + 3 * $y - $z;\n};\nforeach ($xs as $i => $x) {\n    foreach ($ys as $j => $y) {\n        foreach ($zs as $k => $z) {\n            $data[$i][$j][$k] = $func($x, $y, $z);\n        }\n    }\n}\n\n// Constructing a RegularGridInterpolator\n$rgi = new Interpolation\\RegularGridInterpolator([$xs, $ys, $zs], $data, 'linear');  // 'nearest' method also available\n\n// Interpolating coordinates on the regular grid\n$coordinates   = [2.21, 12.1, 115.9];\n$interpolation = $rgi($coordinates);  // -75.18\n```\n\n### Numerical Analysis - Numerical Differentiation\n```php\nuse MathPHP\\NumericalAnalysis\\NumericalDifferentiation;\n\n// Numerical Differentiation approximates the derivative of a function.\n// Each Differentiation method can take input in two ways:\n//  1) As a set of points (inputs and outputs of a function)\n//  2) As a callback function, and the number of function evaluations to\n//     perform on an interval between a start and end point.\n\n// Input as a callback function\n$fâŸ®xâŸ¯ = function ($x) {\n    return $x**2 + 2 * $x + 1;\n};\n\n// Three Point Formula\n// Returns an approximation for the derivative of our input at our target\n\n// Input as a set of points\n$points = [[0, 1], [1, 4], [2, 9]];\n\n$target = 0;\n[$start, $end, $n] = [0, 2, 3];\n$derivative = NumericalDifferentiation\\ThreePointFormula::differentiate($target, $points);                // input as a set of points\n$derivative = NumericalDifferentiation\\ThreePointFormula::differentiate($target, $fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n// Five Point Formula\n// Returns an approximation for the derivative of our input at our target\n\n// Input as a set of points\n$points = [[0, 1], [1, 4], [2, 9], [3, 16], [4, 25]];\n\n$target = 0;\n[$start, $end, $n] = [0, 4, 5];\n$derivative = NumericalDifferentiation\\FivePointFormula::differentiate($target, $points);                // input as a set of points\n$derivative = NumericalDifferentiation\\FivePointFormula::differentiate($target, $fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n// Second Derivative Midpoint Formula\n// Returns an approximation for the second derivative of our input at our target\n\n// Input as a set of points\n$points = [[0, 1], [1, 4], [2, 9];\n\n$target = 1;\n[$start, $end, $n] = [0, 2, 3];\n$derivative = NumericalDifferentiation\\SecondDerivativeMidpointFormula::differentiate($target, $points);                // input as a set of points\n$derivative = NumericalDifferentiation\\SecondDerivativeMidpointFormula::differentiate($target, $fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n```\n\n### Numerical Analysis - Numerical Integration\n```php\nuse MathPHP\\NumericalAnalysis\\NumericalIntegration;\n\n// Numerical integration approximates the definite integral of a function.\n// Each integration method can take input in two ways:\n//  1) As a set of points (inputs and outputs of a function)\n//  2) As a callback function, and the number of function evaluations to\n//     perform on an interval between a start and end point.\n\n// Trapezoidal Rule (closed Newton-Cotes formula)\n$points = [[0, 1], [1, 4], [2, 9], [3, 16]];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\TrapezoidalRule::approximate($points); // input as a set of points\n\n$fâŸ®xâŸ¯ = function ($x) {\n    return $x**2 + 2 * $x + 1;\n};\n[$start, $end, $n] = [0, 3, 4];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\TrapezoidalRule::approximate($fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n// Simpsons Rule (closed Newton-Cotes formula)\n$points = [[0, 1], [1, 4], [2, 9], [3, 16], [4,3]];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\SimpsonsRule::approximate($points); // input as a set of points\n\n$fâŸ®xâŸ¯ = function ($x) {\n    return $x**2 + 2 * $x + 1;\n};\n[$start, $end, $n] = [0, 3, 5];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\SimpsonsRule::approximate($fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n// Simpsons 3/8 Rule (closed Newton-Cotes formula)\n$points = [[0, 1], [1, 4], [2, 9], [3, 16]];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\SimpsonsThreeEighthsRule::approximate($points); // input as a set of points\n\n$fâŸ®xâŸ¯ = function ($x) {\n    return $x**2 + 2 * $x + 1;\n};\n[$start, $end, $n] = [0, 3, 5];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\SimpsonsThreeEighthsRule::approximate($fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n// Booles Rule (closed Newton-Cotes formula)\n$points = [[0, 1], [1, 4], [2, 9], [3, 16], [4, 25]];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\BoolesRule::approximate($points); // input as a set of points\n\n$fâŸ®xâŸ¯ = function ($x) {\n    return $x**3 + 2 * $x + 1;\n};\n[$start, $end, $n] = [0, 4, 5];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\BoolesRuleRule::approximate($fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n// Rectangle Method (open Newton-Cotes formula)\n$points = [[0, 1], [1, 4], [2, 9], [3, 16]];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\RectangleMethod::approximate($points); // input as a set of points\n\n$fâŸ®xâŸ¯ = function ($x) {\n    return $x**2 + 2 * $x + 1;\n};\n[$start, $end, $n] = [0, 3, 4];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\RectangleMethod::approximate($fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n\n// Midpoint Rule (open Newton-Cotes formula)\n$points = [[0, 1], [1, 4], [2, 9], [3, 16]];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\MidpointRule::approximate($points); // input as a set of points\n\n$fâŸ®xâŸ¯ = function ($x) {\n    return $x**2 + 2 * $x + 1;\n};\n[$start, $end, $n] = [0, 3, 4];\n$âˆ«fâŸ®xâŸ¯dx = NumericalIntegration\\MidpointRule::approximate($fâŸ®xâŸ¯, $start, $end, $n); // input as a callback function\n```\n\n### Numerical Analysis - Root Finding\n```php\nuse MathPHP\\NumericalAnalysis\\RootFinding;\n\n// Root-finding methods solve for a root of a polynomial.\n\n// f(x) = xâ´ + 8xÂ³ -13xÂ² -92x + 96\n$fâŸ®xâŸ¯ = function($x) {\n    return $x**4 + 8 * $x**3 - 13 * $x**2 - 92 * $x + 96;\n};\n\n// Newton's Method\n$args     = [-4.1];  // Parameters to pass to callback function (initial guess, other parameters)\n$target   = 0;       // Value of f(x) we a trying to solve for\n$tol      = 0.00001; // Tolerance; how close to the actual solution we would like\n$position = 0;       // Which element in the $args array will be changed; also serves as initial guess. Defaults to 0.\n$x        = RootFinding\\NewtonsMethod::solve($fâŸ®xâŸ¯, $args, $target, $tol, $position); // Solve for x where f(x) = $target\n\n// Secant Method\n$pâ‚€  = -1;      // First initial approximation\n$pâ‚  = 2;       // Second initial approximation\n$tol = 0.00001; // Tolerance; how close to the actual solution we would like\n$x   = RootFinding\\SecantMethod::solve($fâŸ®xâŸ¯, $pâ‚€, $pâ‚, $tol); // Solve for x where f(x) = 0\n\n// Bisection Method\n$a   = 2;       // The start of the interval which contains a root\n$b   = 5;       // The end of the interval which contains a root\n$tol = 0.00001; // Tolerance; how close to the actual solution we would like\n$x   = RootFinding\\BisectionMethod::solve($fâŸ®xâŸ¯, $a, $b, $tol); // Solve for x where f(x) = 0\n\n// Fixed-Point Iteration\n// f(x) = xâ´ + 8xÂ³ -13xÂ² -92x + 96\n// Rewrite f(x) = 0 as (xâ´ + 8xÂ³ -13xÂ² + 96)/92 = x\n// Thus, g(x) = (xâ´ + 8xÂ³ -13xÂ² + 96)/92\n$gâŸ®xâŸ¯ = function($x) {\n    return ($x**4 + 8 * $x**3 - 13 * $x**2 + 96)/92;\n};\n$a   = 0;       // The start of the interval which contains a root\n$b   = 2;       // The end of the interval which contains a root\n$p   = 0;       // The initial guess for our root\n$tol = 0.00001; // Tolerance; how close to the actual solution we would like\n$x   = RootFinding\\FixedPointIteration::solve($gâŸ®xâŸ¯, $a, $b, $p, $tol); // Solve for x where f(x) = 0\n```\n\n### Probability - Combinatorics\n```php\nuse MathPHP\\Probability\\Combinatorics;\n\n[$n, $x, $k] = [10, 3, 4];\n\n// Factorials\n$nï¼  = Combinatorics::factorial($n);\n$nâ€¼ï¸Ž   = Combinatorics::doubleFactorial($n);\n$xâ½â¿â¾ = Combinatorics::risingFactorial($x, $n);\n$xâ‚áµ¢â‚Ž = Combinatorics::fallingFactorial($x, $n);\n$ï¼n  = Combinatorics::subfactorial($n);\n\n// Permutations\n$nPn = Combinatorics::permutations($n);     // Permutations of n things, taken n at a time (same as factorial)\n$nPk = Combinatorics::permutations($n, $k); // Permutations of n things, taking only k of them\n\n// Combinations\n$nCk  = Combinatorics::combinations($n, $k);                            // n choose k without repetition\n$nCâ€²k = Combinatorics::combinations($n, $k, Combinatorics::REPETITION); // n choose k with repetition (REPETITION const = true)\n\n// Central binomial coefficient\n$cbc = Combinatorics::centralBinomialCoefficient($n);\n\n// Catalan number\n$Cn = Combinatorics::catalanNumber($n);\n\n// Lah number\n$LâŸ®nã€kâŸ¯ = Combinatorics::lahNumber($n, $k)\n\n// Multinomial coefficient\n$groups    = [5, 2, 3];\n$divisions = Combinatorics::multinomial($groups);\n```\n\n### Probability - Continuous Distributions\n```php\nuse MathPHP\\Probability\\Distribution\\Continuous;\n\n$p = 0.1;\n\n// Beta distribution\n$Î±      = 1; // shape parameter\n$Î²      = 1; // shape parameter\n$x      = 2;\n$beta   = new Continuous\\Beta($Î±, $Î²);\n$pdf    = $beta->pdf($x);\n$cdf    = $beta->cdf($x);\n$icdf   = $beta->inverse($p);\n$Î¼      = $beta->mean();\n$median = $beta->median();\n$mode   = $beta->mode();\n$ÏƒÂ²     = $beta->variance();\n\n// Cauchy distribution\n$xâ‚€     = 2; // location parameter\n$Î³      = 3; // scale parameter\n$x      = 1;\n$cauchy = new Continuous\\Cauchy(xâ‚€, Î³);\n$pdf    = $cauchy->pdf(x);\n$cdf    = $cauchy->cdf(x);\n$icdf   = $cauchy->inverse($p);\n$Î¼      = $cauchy->mean();\n$median = $cauchy->median();\n$mode   = $cauchy->mode();\n\n// Ï‡Â²-distribution (Chi-Squared)\n$k      = 2; // degrees of freedom\n$x      = 1;\n$Ï‡Â²     = new Continuous\\ChiSquared($k);\n$pdf    = $Ï‡Â²->pdf($x);\n$cdf    = $Ï‡Â²->cdf($x);\n$Î¼      = $Ï‡Â²->mean($x);\n$median = $Ï‡Â²->median();\n$mode   = $Ï‡Â²->mode();\n$ÏƒÂ²     = $Ï‡Â²->variance();\n\n// Dirac delta distribution\n$x     = 1;\n$dirac = new Continuous\\DiracDelta();\n$pdf   = $dirac->pdf($x);\n$cdf   = $dirac->cdf($x);\n$icdf  = $dirac->inverse($p);\n$Î¼     = $dirac->mean();\n\n// Exponential distribution\n$Î»           = 1; // rate parameter\n$x           = 2;\n$exponential = new Continuous\\Exponential($Î»);\n$pdf         = $exponential->pdf($x);\n$cdf         = $exponential->cdf($x);\n$icdf        = $exponential->inverse($p);\n$Î¼           = $exponential->mean();\n$median      = $exponential->median();\n$ÏƒÂ²          = $exponential->variance();\n\n// F-distribution\n$dâ‚   = 3; // degree of freedom v1\n$dâ‚‚   = 4; // degree of freedom v2\n$x    = 2;\n$f    = new Continuous\\F($dâ‚, $dâ‚‚);\n$pdf  = $f->pdf($x);\n$cdf  = $f->cdf($x);\n$Î¼    = $f->mean();\n$mode = $f->mode();\n$ÏƒÂ²   = $f->variance();\n\n// Gamma distribution\n$k      = 2; // shape parameter\n$Î¸      = 3; // scale parameter\n$x      = 4;\n$gamma  = new Continuous\\Gamma($k, $Î¸);\n$pdf    = $gamma->pdf($x);\n$cdf    = $gamma->cdf($x);\n$Î¼      = $gamma->mean();\n$median = $gamma->median();\n$mode   = $gamma->mode();\n$ÏƒÂ²     = $gamma->variance();\n\n// Laplace distribution\n$Î¼       = 1;   // location parameter\n$b       = 1.5; // scale parameter (diversity)\n$x       = 1;\n$laplace = new Continuous\\Laplace($Î¼, $b);\n$pdf     = $laplace->pdf($x);\n$cdf     = $laplace->cdf($x);\n$icdf    = $laplace->inverse($p);\n$Î¼       = $laplace->mean();\n$median  = $laplace->median();\n$mode    = $laplace->mode();\n$ÏƒÂ²      = $laplace->variance();\n\n// Logistic distribution\n$Î¼        = 2;   // location parameter\n$s        = 1.5; // scale parameter\n$x        = 3;\n$logistic = new Continuous\\Logistic($Î¼, $s);\n$pdf      = $logistic->pdf($x);\n$cdf      = $logistic->cdf($x);\n$icdf     = $logistic->inverse($p);\n$Î¼        = $logistic->mean();\n$median   = $logistic->median();\n$mode     = $logistic->mode();\n$ÏƒÂ²       = $logisitic->variance();\n\n// Log-logistic distribution (Fisk distribution)\n$Î±           = 1; // scale parameter\n$Î²           = 1; // shape parameter\n$x           = 2;\n$logLogistic = new Continuous\\LogLogistic($Î±, $Î²);\n$pdf         = $logLogistic->pdf($x);\n$cdf         = $logLogistic->cdf($x);\n$icdf        = $logLogistic->inverse($p);\n$Î¼           = $logLogistic->mean();\n$median      = $logLogistic->median();\n$mode        = $logLogistic->mode();\n$ÏƒÂ²          = $logLogistic->variance();\n\n// Log-normal distribution\n$Î¼         = 6;   // scale parameter\n$Ïƒ         = 2;   // location parameter\n$x         = 4.3;\n$logNormal = new Continuous\\LogNormal($Î¼, $Ïƒ);\n$pdf       = $logNormal->pdf($x);\n$cdf       = $logNormal->cdf($x);\n$icdf      = $logNormal->inverse($p);\n$Î¼         = $logNormal->mean();\n$median    = $logNormal->median();\n$mode      = $logNormal->mode();\n$ÏƒÂ²        = $logNormal->variance();\n\n// Noncentral T distribution\n$Î½            = 50; // degrees of freedom\n$Î¼            = 10; // noncentrality parameter\n$x            = 8;\n$noncenetralT = new Continuous\\NoncentralT($Î½, $Î¼);\n$pdf          = $noncenetralT->pdf($x);\n$cdf          = $noncenetralT->cdf($x);\n$Î¼            = $noncenetralT->mean();\n\n// Normal distribution\n$Ïƒ      = 1;\n$Î¼      = 0;\n$x      = 2;\n$normal = new Continuous\\Normal($Î¼, $Ïƒ);\n$pdf    = $normal->pdf($x);\n$cdf    = $normal->cdf($x);\n$icdf   = $normal->inverse($p);\n$Î¼      = $normal->mean();\n$median = $normal->median();\n$mode   = $normal->mode();\n$ÏƒÂ²     = $normal->variance();\n\n// Pareto distribution\n$a      = 1; // shape parameter\n$b      = 1; // scale parameter\n$x      = 2;\n$pareto = new Continuous\\Pareto($a, $b);\n$pdf    = $pareto->pdf($x);\n$cdf    = $pareto->cdf($x);\n$icdf   = $pareto->inverse($p);\n$Î¼      = $pareto->mean();\n$median = $pareto->median();\n$mode   = $pareto->mode();\n$ÏƒÂ²     = $pareto->variance();\n\n// Standard normal distribution\n$z              = 2;\n$standardNormal = new Continuous\\StandardNormal();\n$pdf            = $standardNormal->pdf($z);\n$cdf            = $standardNormal->cdf($z);\n$icdf           = $standardNormal->inverse($p);\n$Î¼              = $standardNormal->mean();\n$median         = $standardNormal->median();\n$mode           = $standardNormal->mode();\n$ÏƒÂ²             = $standardNormal->variance();\n\n// Student's t-distribution\n$Î½        = 3;   // degrees of freedom\n$p        = 0.4; // proportion of area\n$x        = 2;\n$studentT = new Continuous\\StudentT::pdf($Î½);\n$pdf      = $studentT->pdf($x);\n$cdf      = $studentT->cdf($x);\n$t        = $studentT->inverse2Tails($p);  // t such that the area greater than t and the area beneath -t is p\n$Î¼        = $studentT->mean();\n$median   = $studentT->median();\n$mode     = $studentT->mode();\n$ÏƒÂ²       = $studentT->variance();\n\n// Uniform distribution\n$a       = 1; // lower boundary of the distribution\n$b       = 4; // upper boundary of the distribution\n$x       = 2;\n$uniform = new Continuous\\Uniform($a, $b);\n$pdf     = $uniform->pdf($x);\n$cdf     = $uniform->cdf($x);\n$Î¼       = $uniform->mean();\n$median  = $uniform->median();\n$mode    = $uniform->mode();\n$ÏƒÂ²      = $uniform->variance();\n\n// Weibull distribution\n$k       = 1; // shape parameter\n$Î»       = 2; // scale parameter\n$x       = 2;\n$weibull = new Continuous\\Weibull($k, $Î»);\n$pdf     = $weibull->pdf($x);\n$cdf     = $weibull->cdf($x);\n$icdf    = $weibull->inverse($p);\n$Î¼       = $weibull->mean();\n$median  = $weibull->median();\n$mode    = $weibull->mode();\n\n// Other CDFs - All continuous distributions - Replace {$distribution} with desired distribution.\n$between = $distribution->between($xâ‚, $xâ‚‚);  // Probability of being between two points, xâ‚ and xâ‚‚\n$outside = $distribution->outside($xâ‚, $x);   // Probability of being between below xâ‚ and above xâ‚‚\n$above   = $distribution->above($x);          // Probability of being above x to âˆž\n\n// Random Number Generator\n$random  = $distribution->rand();  // A random number with a given distribution\n```\n\n### Probability - Discrete Distributions\n```php\nuse MathPHP\\Probability\\Distribution\\Discrete;\n\n// Bernoulli distribution (special case of binomial where n = 1)\n$p         = 0.3;\n$k         = 0;\n$bernoulli = new Discrete\\Bernoulli($p);\n$pmf       = $bernoulli->pmf($k);\n$cdf       = $bernoulli->cdf($k);\n$Î¼         = $bernoulli->mean();\n$median    = $bernoulli->median();\n$mode      = $bernoulli->mode();\n$ÏƒÂ²        = $bernoulli->variance();\n\n// Binomial distribution\n$n        = 2;   // number of events\n$p        = 0.5; // probability of success\n$r        = 1;   // number of successful events\n$binomial = new Discrete\\Binomial($n, $p);\n$pmf      = $binomial->pmf($r);\n$cdf      = $binomial->cdf($r);\n$Î¼        = $binomial->mean();\n$ÏƒÂ²       = $binomial->variance();\n\n// Categorical distribution\n$k             = 3;                                    // number of categories\n$probabilities = ['a' => 0.3, 'b' => 0.2, 'c' => 0.5]; // probabilities for categorices a, b, and c\n$categorical   = new Discrete\\Categorical($k, $probabilities);\n$pmf_a         = $categorical->pmf('a');\n$mode          = $categorical->mode();\n\n// Geometric distribution (failures before the first success)\n$p         = 0.5; // success probability\n$k         = 2;   // number of trials\n$geometric = new Discrete\\Geometric($p);\n$pmf       = $geometric->pmf($k);\n$cdf       = $geometric->cdf($k);\n$Î¼         = $geometric->mean();\n$median    = $geometric->median();\n$mode      = $geometric->mode();\n$ÏƒÂ²        = $geometric->variance();\n\n// Hypergeometric distribution\n$N        = 50; // population size\n$K        = 5;  // number of success states in the population\n$n        = 10; // number of draws\n$k        = 4;  // number of observed successes\n$hypergeo = new Discrete\\Hypergeometric($N, $K, $n);\n$pmf      = $hypergeo->pmf($k);\n$cdf      = $hypergeo->cdf($k);\n$Î¼        = $hypergeo->mean();\n$mode     = $hypergeo->mode();\n$ÏƒÂ²       = $hypergeo->variance();\n\n// Negative binomial distribution (Pascal)\n$r                = 1;   // number of failures until the experiment is stopped\n$P                = 0.5; // probability of success on an individual trial\n$x                = 2;   // number of successes\n$negativeBinomial = new Discrete\\NegativeBinomial($r, $p);\n$pmf              = $negativeBinomial->pmf($x);\n$cdf              = $negativeBinomial->cdf($x);\n$Î¼                = $negativeBinomial->mean();\n$mode             = $negativeBinomial->mode();\n$ÏƒÂ²               = $negativeBinomial->variance();\n\n// Pascal distribution (Negative binomial)\n$r      = 1;   // number of failures until the experiment is stopped\n$P      = 0.5; // probability of success on an individual trial\n$x      = 2;   // number of successes\n$pascal = new Discrete\\Pascal($r, $p);\n$pmf    = $pascal->pmf($x);\n$cdf    = $pascal->cdf($x);\n$Î¼      = $pascal->mean();\n$mode   = $pascal->mode();\n$ÏƒÂ²     = $pascal->variance();\n\n// Poisson distribution\n$Î»       = 2; // average number of successful events per interval\n$k       = 3; // events in the interval\n$poisson = new Discrete\\Poisson($Î»);\n$pmf     = $poisson->pmf($k);\n$cdf     = $poisson->cdf($k);\n$Î¼       = $poisson->mean();\n$median  = $poisson->median();\n$mode    = $poisson->mode();\n$ÏƒÂ²      = $poisson->variance();\n\n// Shifted geometric distribution (probability to get one success)\n$p                = 0.5; // success probability\n$k                = 2;   // number of trials\n$shiftedGeometric = new Discrete\\ShiftedGeometric($p);\n$pmf              = $shiftedGeometric->pmf($k);\n$cdf              = $shiftedGeometric->cdf($k);\n$Î¼                = $shiftedGeometric->mean();\n$median           = $shiftedGeometric->median();\n$mode             = $shiftedGeometric->mode();\n$ÏƒÂ²               = $shiftedGeometric->variance();\n\n// Uniform distribution\n$a       = 1; // lower boundary of the distribution\n$b       = 4; // upper boundary of the distribution\n$k       = 2; // percentile\n$uniform = new Discrete\\Uniform($a, $b);\n$pmf     = $uniform->pmf();\n$cdf     = $uniform->cdf($k);\n$Î¼       = $uniform->mean();\n$median  = $uniform->median();\n$ÏƒÂ²      = $uniform->variance();\n\n// Zipf distribution\n$k    = 2;   // rank\n$s    = 3;   // exponent\n$N    = 10;  // number of elements\n$zipf = new Discrete\\Zipf($s, $N);\n$pmf  = $zipf->pmf($k);\n$cdf  = $zipf->cdf($k);\n$Î¼    = $zipf->mean();\n$mode = $zipf->mode();\n```\n\n### Probability - Multivariate Distributions\n```php\nuse MathPHP\\Probability\\Distribution\\Multivariate;\n\n// Dirichlet distribution\n$Î±s        = [1, 2, 3];\n$xs        = [0.07255081, 0.27811903, 0.64933016];\n$dirichlet = new Multivariate\\Dirichlet($Î±s);\n$pdf       = $dirichlet->pdf($xs);\n\n// Normal distribution\n$Î¼      = [1, 1.1];\n$âˆ‘      = MatrixFactory::create([\n    [1, 0],\n    [0, 1],\n]);\n$X      = [0.7, 1.4];\n$normal = new Multivariate\\Normal($Î¼, $âˆ‘);\n$pdf    = $normal->pdf($X);\n\n// Hypergeometric distribution\n$quantities   = [5, 10, 15];   // Suppose there are 5 black, 10 white, and 15 red marbles in an urn.\n$choices      = [2, 2, 2];     // If six marbles are chosen without replacement, the probability that exactly two of each color are chosen is:\n$distribution = new Multivariate\\Hypergeometric($quantities);\n$probability  = $distribution->pmf($choices);    // 0.0795756\n\n// Multinomial distribution\n$frequencies   = [7, 2, 3];\n$probabilities = [0.40, 0.35, 0.25];\n$multinomial   = new Multivariate\\Multinomial($probabilities);\n$pmf           = $multinomial->pmf($frequencies);\n```\n\n### Probability - Distribution Tables\n```php\nuse MathPHP\\Probability\\Distribution\\Table;\n\n// Provided solely for completeness' sake.\n// It is statistics tradition to provide these tables.\n// MathPHP has dynamic distribution CDF functions you can use instead.\n\n// Standard Normal Table (Z Table)\n$table       = Table\\StandardNormal::Z_SCORES;\n$probability = $table[1.5][0];                 // Value for Z of 1.50\n\n// t Distribution Tables\n$table   = Table\\TDistribution::ONE_SIDED_CONFIDENCE_LEVEL;\n$table   = Table\\TDistribution::TWO_SIDED_CONFIDENCE_LEVEL;\n$Î½       = 5;  // degrees of freedom\n$cl      = 99; // confidence level\n$t       = $table[$Î½][$cl];\n\n// t Distribution Tables\n$table = Table\\TDistribution::ONE_SIDED_ALPHA;\n$table = Table\\TDistribution::TWO_SIDED_ALPHA;\n$Î½     = 5;     // degrees of freedom\n$Î±     = 0.001; // alpha value\n$t     = $table[$Î½][$Î±];\n\n// Ï‡Â² Distribution Table\n$table = Table\\ChiSquared::CHI_SQUARED_SCORES;\n$df    = 2;    // degrees of freedom\n$p     = 0.05; // P value\n$Ï‡Â²    = $table[$df][$p];\n```\n\n### Sample Data\n```php\nuse MathPHP\\SampleData;\n\n// Famous sample data sets to experiment with\n\n// Motor Trend Car Road Tests (mtcars)\n$mtCars      = new SampleData\\MtCars();\n$rawData     = $mtCars->getData();                     // [[21, 6, 160, ... ], [30.4, 4, 71.1, ... ], ... ]\n$labeledData = $mtCars->getLabeledData();              // ['Mazda RX4' => ['mpg' => 21, 'cyl' => 6, 'disp' => 160, ... ], 'Honda Civic' => [ ... ], ...]\n$modelData   = $mtCars->getModelData('Ferrari Dino');  // ['mpg' => 19.7, 'cyl' => 6, 'disp' => 145, ... ]\n$mpgs        = $mtCars->getMpg();                      // ['Mazda RX4' => 21, 'Honda civic' => 30.4, ... ]\n// Getters for Mpg, Cyl, Disp, Hp, Drat, Wt, Qsec, Vs, Am, Gear, Carb\n\n// Edgar Anderson's Iris Data (iris)\n$iris         = new SampleData\\Iris();\n$rawData      = $iris->getData();         // [[5.1, 3.5, 1.4, 0.2, 'setosa'], [4.9, 3.0, 1.4, 0.2, 'setosa'], ... ]\n$labeledData  = $iris->getLabeledData();  // [['sepalLength' => 5.11, 'sepalWidth' => 3.5, 'petalLength' => 1.4, 'petalWidth' => 0.2, 'species' => 'setosa'], ... ]\n$petalLengths = $iris->getSepalLength();  // [5.1, 4.9, 4.7, ... ]\n// Getters for SepalLength, SepalWidth, PetalLength, PetalWidth, Species\n\n// The Effect of Vitamin C on Tooth Growth in Guinea Pigs (ToothGrowth)\n$toothGrowth = new SampleData\\ToothGrowth();\n$rawData     = $toothGrowth->getData();         // [[4.2, 'VC', 0.5], [11.5, 'VC', '0.5], ... ]\n$labeledData = $toothGrowth->getLabeledData();  // [['len' => 4.2, 'supp' => 'VC', 'dose' => 0.5], ... ]\n$lengths     = $toothGrowth->getLen();          // [4.2, 11.5, ... ]\n// Getters for Len, Supp, Dose\n\n// Results from an Experiment on Plant Growth (PlantGrowth)\n$plantGrowth = new SampleData\\PlantGrowth();\n$rawData     = $plantGrowth->getData();         // [[4.17, 'ctrl'], [5.58, 'ctrl'], ... ]\n$labeledData = $plantGrowth->getLabeledData();  // [['weight' => 4.17, 'group' => 'ctrl'], ['weight' => 5.58, 'group' => 'ctrl'], ... ]\n$weights     = $plantGrowth->getWeight();       // [4.17, 5.58, ... ]\n// Getters for Weight, Group\n\n// Violent Crime Rates by US State (USArrests)\n$usArrests   = new SampleData\\UsArrests();\n$rawData     = $usArrests->rawData();              // [[13.2, 236, 58, 21.2], [10.0, 263, 48, 44.5], ... ]\n$labeledData = $usArrests->getLabeledData();       // ['Alabama' => ['murder' => 13.2, 'assault' => 236, 'urbanPop' => 58, 'rape' => 21.2], ... ]\n$stateData   = $usArrests->getStateData('Texas');  // ['murder' => 12.7, 'assault' => 201, 'urbanPop' => 80, 'rape' => 25.5]\n$murders     = $usArrests->getMurders();           // ['Alabama' => 13.2, 'Alaska' => 10.1, ... ]\n// Getters for Murder, Assault, UrbanPop, Rape\n\n// Data from Cereals (cereal)\n$cereal  = new SampleData\\Cereal();\n$cereals = $cereal->getCereals();    // ['B1', 'B2', 'B3', 'M1', 'M2', ... ]\n$X       = $cereal->getXData();      // [[0.002682755, 0.003370673, 0.004085942, ... ], [0.002781597, 0.003474863, 0.004191472, ... ], ... ]\n$Y       = $cereal->getYData();      // [[18373, 41.61500, 6.565000, ... ], [18536, 41.40500, 6.545000, ... ], ... ]\n$Ysc     = $cereal->getYscData();    // [[-0.1005049, 0.6265746, -1.1716630, ... ], [0.9233889, 0.1882929, -1.3185289, ... ], ... ]\n// Labeled data: getLabeledXData(), getLabeledYData(), getLabeledYscData()\n\n// Data from People (people)\n$people      = new SampleData\\People();\n$rawData     = $people->getData();         // [198, 92, -1, ... ], [184, 84, -1, ... ], ... ]\n$labeledData = $people->getLabeledData();  // ['Lars' => ['height' => 198, 'weight' => 92, 'hairLength' => -1, ... ]]\n$names       = $people->getNames();\n// Getters for names, height, weight, hairLength, shoeSize, age, income, beer, wine, sex, swim, region, iq\n```\n\n### Search\n```php\nuse MathPHP\\Search;\n\n// Search lists of numbers to find specific indexes\n\n$list = [1, 2, 3, 4, 5];\n\n$index   = Search::sorted($list, 2);   // Find the array index where an item should be inserted to maintain sorted order\n$index   = Search::argMax($list);      // Find the array index of the maximum value\n$index   = Search::nanArgMax($list);   // Find the array index of the maximum value, ignoring NANs\n$index   = Search::argMin($list);      // Find the array index of the minimum value\n$index   = Search::nanArgMin($list);   // Find the array index of the minimum value, ignoring NANs\n$indices = Search::nonZero($list);     // Find the array indices of the scalar values that are non-zero\n```\n\n### Sequences - Basic\n```php\nuse MathPHP\\Sequence\\Basic;\n\n$n = 5; // Number of elements in the sequence\n\n// Arithmetic progression\n$d           = 2;  // Difference between the elements of the sequence\n$aâ‚          = 1;  // Starting number for the sequence\n$progression = Basic::arithmeticProgression($n, $d, $aâ‚);\n// [1, 3, 5, 7, 9] - Indexed from 1\n\n// Geometric progression (arâ¿â»Â¹)\n$a           = 2; // Scalar value\n$r           = 3; // Common ratio\n$progression = Basic::geometricProgression($n, $a, $r);\n// [2(3)â°, 2(3)Â¹, 2(3)Â², 2(3)Â³] = [2, 6, 18, 54] - Indexed from 1\n\n// Square numbers (nÂ²)\n$squares = Basic::squareNumber($n);\n// [0Â², 1Â², 2Â², 3Â², 4Â²] = [0, 1, 4, 9, 16] - Indexed from 0\n\n// Cubic numbers (nÂ³)\n$cubes = Basic::cubicNumber($n);\n// [0Â³, 1Â³, 2Â³, 3Â³, 4Â³] = [0, 1, 8, 27, 64] - Indexed from 0\n\n// Powers of 2 (2â¿)\n$po2 = Basic::powersOfTwo($n);\n// [2â°, 2Â¹, 2Â², 2Â³, 2â´] = [1,  2,  4,  8,  16] - Indexed from 0\n\n// Powers of 10 (10â¿)\n$po10 = Basic::powersOfTen($n);\n// [10â°, 10Â¹, 10Â², 10Â³,  10â´] = [1, 10, 100, 1000, 10000] - Indexed from 0\n\n// Factorial (n!)\n$fact = Basic::factorial($n);\n// [0!, 1!, 2!, 3!, 4!] = [1,  1,  2,  6,  24] - Indexed from 0\n\n// Digit sum\n$digit_sum = Basic::digitSum($n);\n// [0, 1, 2, 3, 4] - Indexed from 0\n\n// Digital root\n$digit_root = Basic::digitalRoot($n);\n// [0, 1, 2, 3, 4] - Indexed from 0\n```\n\n### Sequences - Advanced\n```php\nuse MathPHP\\Sequence\\Advanced;\n\n$n = 6; // Number of elements in the sequence\n\n// Fibonacci (Fáµ¢ = Fáµ¢â‚‹â‚ + Fáµ¢â‚‹â‚‚)\n$fib = Advanced::fibonacci($n);\n// [0, 1, 1, 2, 3, 5] - Indexed from 0\n\n// Lucas numbers\n$lucas = Advanced::lucasNumber($n);\n// [2, 1, 3, 4, 7, 11] - Indexed from 0\n\n// Pell numbers\n$pell = Advanced::pellNumber($n);\n// [0, 1, 2, 5, 12, 29] - Indexed from 0\n\n// Triangular numbers (figurate number)\n$triangles = Advanced::triangularNumber($n);\n// [1, 3, 6, 10, 15, 21] - Indexed from 1\n\n// Pentagonal numbers (figurate number)\n$pentagons = Advanced::pentagonalNumber($n);\n// [1, 5, 12, 22, 35, 51] - Indexed from 1\n\n// Hexagonal numbers (figurate number)\n$hexagons = Advanced::hexagonalNumber($n);\n// [1, 6, 15, 28, 45, 66] - Indexed from 1\n\n// Heptagonal numbers (figurate number)\n$heptagons = Advanced::heptagonalNumber($n);\n// [1, 4, 7, 13, 18, 27] - Indexed from 1\n\n// Look-and-say sequence (describe the previous term!)\n$look_and_say = Advanced::lookAndSay($n);\n// ['1', '11', '21', '1211', '111221', '312211'] - Indexed from 1\n\n// Lazy caterer's sequence (central polygonal numbers)\n$lazy_caterer = Advanced::lazyCaterers($n);\n// [1, 2, 4, 7, 11, 16] - Indexed from 0\n\n// Magic squares series (magic constants; magic sums)\n$magic_squares = Advanced::magicSquares($n);\n// [0, 1, 5, 15, 34, 65] - Indexed from 0\n\n// Perfect numbers\n$perfect_numbers = Advanced::perfectNumbers($n);\n// [6, 28, 496, 8128, 33550336, 8589869056] - Indexed from 0\n\n// Perfect powers sequence\n$perfect_powers = Advanced::perfectPowers($n);\n// [4, 8, 9, 16, 25, 27] - Indexed from 0\n\n// Not perfect powers sequence\n$not_perfect_powers = Advanced::notPerfectPowers($n);\n// [2, 3, 5, 6, 7, 10] - Indexed from 0\n\n// Prime numbers up to n (n is not the number of elements in the sequence)\n$primes = Advanced::primesUpTo(30);\n// [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] - Indexed from 0\n```\n\n### Sequences - Non-Integer\n```php\nuse MathPHP\\Sequence\\NonInteger;\n\n$n = 4; // Number of elements in the sequence\n\n// Harmonic sequence\n$harmonic = NonInteger::harmonic($n);\n// [1, 3/2, 11/6, 25/12] - Indexed from 1\n\n// Generalized harmonic sequence\n$m           = 2;  // exponent\n$generalized = NonInteger::generalizedHarmonic($n, $m);\n// [1, 5 / 4, 49 / 36, 205 / 144] - Indexed from 1\n\n// Hyperharmonic sequence\n$r             = 2;  // depth of recursion\n$hyperharmonic = NonInteger::hyperharmonic($n, $r);\n// [1, 5/2, 26/6, 77/12] - Indexed from 1\n```\n\n### Set Theory\n```php\nuse MathPHP\\SetTheory\\Set;\nuse MathPHP\\SetTheory\\ImmutableSet;\n\n// Sets and immutable sets\n$A = new Set([1, 2, 3]);          // Can add and remove members\n$B = new ImmutableSet([3, 4, 5]); // Cannot modify set once created\n\n// Basic set data\n$set         = $A->asArray();\n$cardinality = $A->length();\n$bool        = $A->isEmpty();\n\n// Set membership\n$true = $A->isMember(2);\n$true = $A->isNotMember(8);\n\n// Add and remove members\n$A->add(4);\n$A->add(new Set(['a', 'b']));\n$A->addMulti([5, 6, 7]);\n$A->remove(7);\n$A->removeMulti([5, 6]);\n$A->clear();\n\n// Set properties against other sets - return boolean\n$bool = $A->isDisjoint($B);\n$bool = $A->isSubset($B);         // A âŠ† B\n$bool = $A->isProperSubset($B);   // A âŠ† B & A â‰  B\n$bool = $A->isSuperset($B);       // A âŠ‡ B\n$bool = $A->isProperSuperset($B); // A âŠ‡ B & A â‰  B\n\n// Set operations with other sets - return a new Set\n$AâˆªB  = $A->union($B);\n$Aâˆ©B  = $A->intersect($B);\n$Aï¼¼B = $A->difference($B);          // relative complement\n$AÎ”B  = $A->symmetricDifference($B);\n$AÃ—B  = $A->cartesianProduct($B);\n\n// Other set operations\n$PâŸ®AâŸ¯ = $A->powerSet();\n$C   = $A->copy();\n\n// Print a set\nprint($A); // Set{1, 2, 3, 4, Set{a, b}}\n\n// PHP Interfaces\n$n = count($A);                 // Countable\nforeach ($A as $member) { ... } // Iterator\n\n// Fluent interface\n$A->add(5)->add(6)->remove(4)->addMulti([7, 8, 9]);\n```\n\n### Statistics - ANOVA\n```php\nuse MathPHP\\Statistics\\ANOVA;\n\n// One-way ANOVA\n$sample1 = [1, 2, 3];\n$sample2 = [3, 4, 5];\n$sample3 = [5, 6, 7];\n   â‹®            â‹®\n\n$anova = ANOVA::oneWay($sample1, $sample2, $sample3);\nprint_r($anova);\n/* Array (\n    [ANOVA] => Array (             // ANOVA hypothesis test summary data\n            [treatment] => Array (\n                    [SS] => 24     // Sum of squares (between)\n                    [df] => 2      // Degrees of freedom\n                    [MS] => 12     // Mean squares\n                    [F]  => 12     // Test statistic\n                    [P]  => 0.008  // P value\n                )\n            [error] => Array (\n                    [SS] => 6      // Sum of squares (within)\n                    [df] => 6      // Degrees of freedom\n                    [MS] => 1      // Mean squares\n                )\n            [total] => Array (\n                    [SS] => 30     // Sum of squares (total)\n                    [df] => 8      // Degrees of freedom\n                )\n        )\n    [total_summary] => Array (     // Total summary data\n            [n]        => 9\n            [sum]      => 36\n            [mean]     => 4\n            [SS]       => 174\n            [variance] => 3.75\n            [sd]       => 1.9364916731037\n            [sem]      => 0.6454972243679\n        )\n    [data_summary] => Array (      // Data summary (each input sample)\n            [0] => Array ([n] => 3 [sum] => 6  [mean] => 2 [SS] => 14  [variance] => 1 [sd] => 1 [sem] => 0.57735026918963)\n            [1] => Array ([n] => 3 [sum] => 12 [mean] => 4 [SS] => 50  [variance] => 1 [sd] => 1 [sem] => 0.57735026918963)\n            [2] => Array ([n] => 3 [sum] => 18 [mean] => 6 [SS] => 110 [variance] => 1 [sd] => 1 [sem] => 0.57735026918963)\n        )\n) */\n\n// Two-way ANOVA\n/*        | Factor Bâ‚ | Factor Bâ‚‚ | Factor Bâ‚ƒ | â‹¯\nFactor Aâ‚ |  4, 6, 8  |  6, 6, 9  |  8, 9, 13 | â‹¯\nFactor Aâ‚‚ |  4, 8, 9  | 7, 10, 13 | 12, 14, 16| â‹¯\n    â‹®           â‹®           â‹®           â‹®         */\n$factorAâ‚ = [\n  [4, 6, 8],    // Factor Bâ‚\n  [6, 6, 9],    // Factor Bâ‚‚\n  [8, 9, 13],   // Factor Bâ‚ƒ\n];\n$factorAâ‚‚ = [\n  [4, 8, 9],    // Factor Bâ‚\n  [7, 10, 13],  // Factor Bâ‚‚\n  [12, 14, 16], // Factor Bâ‚ƒ\n];\n       â‹®\n\n$anova = ANOVA::twoWay($factorAâ‚, $factorAâ‚‚);\nprint_r($anova);\n/* Array (\n    [ANOVA] => Array (          // ANOVA hypothesis test summary data\n            [factorA] => Array (\n                    [SS] => 32                 // Sum of squares\n                    [df] => 1                  // Degrees of freedom\n                    [MS] => 32                 // Mean squares\n                    [F]  => 5.6470588235294    // Test statistic\n                    [P]  => 0.034994350619895  // P value\n                )\n            [factorB] => Array (\n                    [SS] => 93                 // Sum of squares\n                    [df] => 2                  // Degrees of freedom\n                    [MS] => 46.5               // Mean squares\n                    [F]  => 8.2058823529412    // Test statistic\n                    [P]  => 0.0056767297582031 // P value\n                )\n            [interaction] => Array (\n                    [SS] => 7                  // Sum of squares\n                    [df] => 2                  // Degrees of freedom\n                    [MS] => 3.5                // Mean squares\n                    [F]  => 0.61764705882353   // Test statistic\n                    [P]  => 0.5555023440712    // P value\n                )\n            [error] => Array (\n                    [SS] => 68                 // Sum of squares (within)\n                    [df] => 12                 // Degrees of freedom\n                    [MS] => 5.6666666666667    // Mean squares\n                )\n            [total] => Array (\n                    [SS] => 200                // Sum of squares (total)\n                    [df] => 17                 // Degrees of freedom\n                )\n        )\n    [total_summary] => Array (    // Total summary data\n            [n]        => 18\n            [sum]      => 162\n            [mean]     => 9\n            [SS]       => 1658\n            [variance] => 11.764705882353\n            [sd]       => 3.4299717028502\n            [sem]      => 0.80845208345444\n        )\n    [summary_factorA]     => Array ( ... )   // Summary data of factor A\n    [summary_factorB]     => Array ( ... )   // Summary data of factor B\n    [summary_interaction] => Array ( ... )   // Summary data of interactions of factors A and B\n) */\n```\n\n### Statistics - Averages\n```php\nuse MathPHP\\Statistics\\Average;\n\n$numbers = [13, 18, 13, 14, 13, 16, 14, 21, 13];\n\n// Mean, median, mode\n$mean   = Average::mean($numbers);\n$median = Average::median($numbers);\n$mode   = Average::mode($numbers); // Returns an array â€” may be multimodal\n\n// Weighted mean\n$weights       = [12, 1, 23, 6, 12, 26, 21, 12, 1];\n$weighted_mean = Average::weightedMean($numbers, $weights)\n\n// Other means of a list of numbers\n$geometric_mean      = Average::geometricMean($numbers);\n$harmonic_mean       = Average::harmonicMean($numbers);\n$contraharmonic_mean = Average::contraharmonicMean($numbers);\n$quadratic_mean      = Average::quadraticMean($numbers);  // same as rootMeanSquare\n$root_mean_square    = Average::rootMeanSquare($numbers); // same as quadraticMean\n$trimean             = Average::trimean($numbers);\n$interquartile_mean  = Average::interquartileMean($numbers); // same as iqm\n$interquartile_mean  = Average::iqm($numbers);               // same as interquartileMean\n$cubic_mean          = Average::cubicMean($numbers);\n\n// Truncated mean (trimmed mean)\n$trim_percent   = 25;  // 25 percent of observations trimmed from each end of distribution\n$truncated_mean = Average::truncatedMean($numbers, $trim_percent);\n\n// Generalized mean (power mean)\n$p                = 2;\n$generalized_mean = Average::generalizedMean($numbers, $p); // same as powerMean\n$power_mean       = Average::powerMean($numbers, $p);       // same as generalizedMean\n\n// Lehmer mean\n$p           = 3;\n$lehmer_mean = Average::lehmerMean($numbers, $p);\n\n// Moving averages\n$n       = 3;\n$weights = [3, 2, 1];\n$SMA     = Average::simpleMovingAverage($numbers, $n);             // 3 n-point moving average\n$CMA     = Average::cumulativeMovingAverage($numbers);\n$WMA     = Average::weightedMovingAverage($numbers, $n, $weights);\n$EPA     = Average::exponentialMovingAverage($numbers, $n);\n\n// Means of two numbers\n[$x, $y]       = [24, 6];\n$agm           = Average::arithmeticGeometricMean($x, $y); // same as agm\n$agm           = Average::agm($x, $y);                     // same as arithmeticGeometricMean\n$log_mean      = Average::logarithmicMean($x, $y);\n$heronian_mean = Average::heronianMean($x, $y);\n$identric_mean = Average::identricMean($x, $y);\n\n// Averages report\n$averages = Average::describe($numbers);\nprint_r($averages);\n/* Array (\n    [mean]                => 15\n    [median]              => 14\n    [mode]                => Array ( [0] => 13 )\n    [geometric_mean]      => 14.789726414533\n    [harmonic_mean]       => 14.605077399381\n    [contraharmonic_mean] => 15.474074074074\n    [quadratic_mean]      => 15.235193176035\n    [trimean]             => 14.5\n    [iqm]                 => 14\n    [cubic_mean]          => 15.492307432707\n) */\n```\n\n### Statistics - Circular\n```php\nuse MathPHP\\Statistics\\Circular;\n\n$angles = [1.51269877, 1.07723915, 0.81992282];\n\n$Î¸ = Circular::mean($angles);\n$R = Circular::resultantLength($angles);\n$Ï = Circular::meanResultantLength($angles);\n$V = Circular::variance($angles);\n$Î½ = Circular::standardDeviation($angles);\n\n// Descriptive circular statistics report\n$stats = Circular::describe($angles);\nprint_r($stats);\n/* Array (\n    [n]                     => 3\n    [mean]                  => 1.1354043006436\n    [resultant_length]      => 2.8786207547493\n    [mean_resultant_length] => 0.9595402515831\n    [variance]              => 0.040459748416901\n    [sd]                    => 0.28740568481722\n); */\n```\n\n### Statistics - Correlation\n```php\nuse MathPHP\\Statistics\\Correlation;\n\n$X = [1, 2, 3, 4, 5];\n$Y = [2, 3, 4, 4, 6];\n\n// Covariance\n$Ïƒxy = Correlation::covariance($X, $Y);  // Has optional parameter to set population (defaults to sample covariance)\n\n// Weighted covariance\n$w    = [2, 3, 1, 1, 5];\n$Ïƒxyw = Correlation::weightedCovariance($X, $Y, $w);\n\n// r - Pearson product-moment correlation coefficient (Pearson's r)\n$r = Correlation::r($X, $Y);  // Has optional parameter to set population (defaults to sample correlation coefficient)\n\n// Weighted correlation coefficient\n$rw = Correlation::weightedCorrelationCoefficient($X, $Y, $w);\n\n// RÂ² - Coefficient of determination\n$RÂ² = Correlation::r2($X, $Y);  // Has optional parameter to set population (defaults to sample coefficient of determination)\n\n// Ï„ - Kendall rank correlation coefficient (Kendall's tau)\n$Ï„ = Correlation::kendallsTau($X, $Y);\n\n// Ï - Spearman's rank correlation coefficient (Spearman's rho)\n$Ï = Correlation::spearmansRho($X, $Y);\n\n// Descriptive correlation report\n$stats = Correlation::describe($X, $Y);\nprint_r($stats);\n/* Array (\n    [cov] => 2.25\n    [r]   => 0.95940322360025\n    [r2]  => 0.92045454545455\n    [tau] => 0.94868329805051\n    [rho] => 0.975\n) */\n\n// Confidence ellipse - create an ellipse surrounding the data at a specified standard deviation\n$sd           = 1;\n$num_points   = 11; // Optional argument specifying number of points of the ellipse\n$ellipse_data = Correlation::confidenceEllipse($X, $Y, $sd, $num_points);\n\n```\n\n### Statistics - Descriptive\n```php\nuse MathPHP\\Statistics\\Descriptive;\n\n$numbers = [13, 18, 13, 14, 13, 16, 14, 21, 13];\n\n// Range and midrange\n$range    = Descriptive::range($numbers);\n$midrange = Descriptive::midrange($numbers);\n\n// Variance (population and sample)\n$ÏƒÂ² = Descriptive::populationVariance($numbers); // n degrees of freedom\n$SÂ² = Descriptive::sampleVariance($numbers);     // n - 1 degrees of freedom\n\n// Variance (Custom degrees of freedom)\n$df = 5;                                    // degrees of freedom\n$SÂ² = Descriptive::variance($numbers, $df); // can specify custom degrees of freedom\n\n// Weighted sample variance\n$weights = [0.1, 0.2, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1];\n$ÏƒÂ²w     = Descriptive::weightedSampleVariance($numbers, $weights, $biased = false);\n\n// Standard deviation (For a sample; uses sample variance)\n$Ïƒ = Descriptive::sd($numbers);                // same as standardDeviation;\n$Ïƒ = Descriptive::standardDeviation($numbers); // same as sd;\n\n// SD+ (Standard deviation for a population; uses population variance)\n$SDï¼‹ = Descriptive::sd($numbers, Descriptive::POPULATION); // POPULATION constant = true\n$SDï¼‹ = Descriptive::standardDeviation($numbers, true);     // same as sd with POPULATION constant\n\n// Coefficient of variation (cáµ¥)\n$cáµ¥ = Descriptive::coefficientOfVariation($numbers);\n\n// MAD - mean/median absolute deviations\n$mean_mad   = Descriptive::meanAbsoluteDeviation($numbers);\n$median_mad = Descriptive::medianAbsoluteDeviation($numbers);\n\n// Quartiles (inclusive and exclusive methods)\n// [0% => 13, Q1 => 13, Q2 => 14, Q3 => 17, 100% => 21, IQR => 4]\n$quartiles = Descriptive::quartiles($numbers);          // Has optional parameter to specify method. Default is Exclusive\n$quartiles = Descriptive::quartilesExclusive($numbers);\n$quartiles = Descriptive::quartilesInclusive($numbers);\n\n// IQR - Interquartile range\n$IQR = Descriptive::interquartileRange($numbers); // Same as IQR; has optional parameter to specify quartile method.\n$IQR = Descriptive::iqr($numbers);                // Same as interquartileRange; has optional parameter to specify quartile method.\n\n// Percentiles\n$twentieth_percentile    = Descriptive::percentile($numbers, 20);\n$ninety_fifth_percentile = Descriptive::percentile($numbers, 95);\n\n// Midhinge\n$midhinge = Descriptive::midhinge($numbers);\n\n// Describe a list of numbers - descriptive stats report\n$stats = Descriptive::describe($numbers); // Has optional parameter to set population or sample calculations\nprint_r($stats);\n/* Array (\n    [n]          => 9\n    [min]        => 13\n    [max]        => 21\n    [mean]       => 15\n    [median]     => 14\n    [mode]       => Array ( [0] => 13 )\n    [range]      => 8\n    [midrange]   => 17\n    [variance]   => 8\n    [sd]         => 2.8284271247462\n    [cv]         => 0.18856180831641\n    [mean_mad]   => 2.2222222222222\n    [median_mad] => 1\n    [quartiles]  => Array (\n            [0%]   => 13\n            [Q1]   => 13\n            [Q2]   => 14\n            [Q3]   => 17\n            [100%] => 21\n            [IQR]  => 4\n        )\n    [midhinge]   => 15\n    [skewness]   => 1.4915533665654\n    [ses]        => 0.71713716560064\n    [kurtosis]   => 0.1728515625\n    [sek]        => 1.3997084244475\n    [sem]        => 0.94280904158206\n    [ci_95]      => Array (\n            [ci]          => 1.8478680091392\n            [lower_bound] => 13.152131990861\n            [upper_bound] => 16.847868009139\n        )\n    [ci_99]      => Array (\n            [ci]          => 2.4285158135783\n            [lower_bound] => 12.571484186422\n            [upper_bound] => 17.428515813578\n        )\n) */\n\n// Five number summary - five most important sample percentiles\n$summary = Descriptive::fiveNumberSummary($numbers);\n// [min, Q1, median, Q3, max]\n```\n\n### Statistics - Distance\n```php\nuse MathPHP\\Statistics\\Distance;\n\n// Probability distributions\n$X = [0.2, 0.5, 0.3];\n$Y = [0.1, 0.4, 0.5];\n\n// Distances\n$DBâŸ®Xã€YâŸ¯   = Distance::bhattacharyya($X, $Y);\n$HâŸ®Xã€YâŸ¯    = Distance::hellinger($X, $Y);\n$DâŸ®Xã€YâŸ¯    = Distance::minkowski($X, $Y, $p = 2);\n$dâŸ®Xã€YâŸ¯    = Distance::euclidean($X, $Y);          // LÂ² distance\n$dâ‚âŸ®Xã€YâŸ¯   = Distance::manhattan($X, $Y);          // LÂ¹ distance, taxicab geometry, city block distance\n$JSDâŸ®Xâ€–YâŸ¯   = Distance::jensenShannon($X, $Y);\n$dâŸ®Xã€YâŸ¯    = Distance::canberra($X, Y);\nbrayCurtis = Distance::brayCurtis($X, $Y);\n$cosine    = Distance::cosine($X, $Y);\n$cosâŸ®Î±âŸ¯     = Distance::cosineSimilarity($X, $Y);\n$DâŸ®Xã€YâŸ¯    = Distance::chebyshev($X, $Y);\n\n// Mahalanobis distance\n$x    = new Matrix([[6], [5]]);\n$data = new Matrix([\n    [4, 4, 5, 2, 3, 6, 9, 7, 4, 5],\n    [3, 7, 5, 7, 9, 5, 6, 2, 2, 7],\n]);\n$otherData = new Matrix([\n    [4, 4, 5, 2, 3, 6, 9, 7, 4, 5],\n    [3, 7, 5, 7, 9, 5, 6, 2, 2, 7],\n]);\n$y = new Matrix([[2], [2]]);\n$D = Distance::mahalanobis($x, $data);          // Mahalanobis distance from x to the centroid of the data.\n$D = Distance::mahalanobis($x, $data, $y);      // Mahalanobis distance between $x and $y using the data.\n$D = Distance::mahalanobis($data, $otherData);  // Mahalanobis distance between the centroids of two sets of data.\n```\n\n### Statistics - Distributions\n```php\nuse MathPHP\\Statistics\\Distribution;\n\n$grades = ['A', 'A', 'B', 'B', 'B', 'B', 'C', 'C', 'D', 'F'];\n\n// Frequency distributions (frequency and relative frequency)\n$frequencies          = Distribution::frequency($grades);         // [ A => 2,   B => 4,   C => 2,   D => 1,   F => 1   ]\n$relative_frequencies = Distribution::relativeFrequency($grades); // [ A => 0.2, B => 0.4, C => 0.2, D => 0.1, F => 0.1 ]\n\n// Cumulative frequency distributions (cumulative and cumulative relative)\n$cumulative_frequencies          = Distribution::cumulativeFrequency($grades);         // [ A => 2,   B => 6,   C => 8,   D => 9,   F => 10  ]\n$cumulative_relative_frequencies = Distribution::cumulativeRelativeFrequency($grades); // [ A => 0.2, B => 0.6, C => 0.8, D => 0.9, F => 1   ]\n\n// Ranking of data\n$values                       = [1, 2, 2, 3];\n$ordinal_ranking              = Distribution::ordinalRanking($values);              // 1, 2, 3, 4\n$standard_competition_ranking = Distribution::standardCompetitionRanking($values);  // 1, 2, 2, 4\n$modified_competition_ranking = Distribution::modifiedCompetitionRanking($values);  // 1, 3, 3, 4\n$fractional_ranking           = Distribution::fractionalRanking($values);           // 1, 2.5, 2.5, 4\n\n// Stem and leaf plot\n// Return value is array where keys are the stems, values are the leaves\n$values             = [44, 46, 47, 49, 63, 64, 66, 68, 68, 72, 72, 75, 76, 81, 84, 88, 106];\n$stem_and_leaf_plot = Distribution::stemAndLeafPlot($values);\n// [4 => [4, 6, 7, 9], 5 => [], 6 => [3, 4, 6, 8, 8], 7 => [2, 2, 5, 6], 8 => [1, 4, 8], 9 => [], 10 => [6]]\n\n// Optional second parameter will print stem and leaf plot to STDOUT\nDistribution::stemAndLeafPlot($values, Distribution::PRINT);\n/*\n 4 | 4 6 7 9\n 5 |\n 6 | 3 4 6 8 8\n 7 | 2 2 5 6\n 8 | 1 4 8\n 9 |\n10 | 6\n*/\n```\n\n### Statistics - Divergence\n```php\nuse MathPHP\\Statistics\\Divergence;\n\n// Probability distributions\n$X = [0.2, 0.5, 0.3];\n$Y = [0.1, 0.4, 0.5];\n\n// Divergences\n$DklâŸ®Xâ€–YâŸ¯ = Divergence::kullbackLeibler($X, $Y);\n$JSDâŸ®Xâ€–YâŸ¯ = Divergence::jensenShannon($X, $Y);\n```\n\n### Statistics - Effect Size\n```php\nuse MathPHP\\Statistics\\EffectSize;\n\n$SSt = 24;  // Sum of squares treatment\n$SSE = 300; // Sum of squares error\n$SST = 600; // Sum of squares total\n$dft = 1;   // Degrees of freedom treatment\n$MSE = 18;  // Mean squares error\n\n// Î·Â² - Eta-squared\n$Î·Â²  = EffectSize::etaSquared($SSt, $SST);\n$Î·Â²p = EffectSize::partialEtaSquared($SSt, $SSE);\n\n// Ï‰Â² - Omega-squared\n$Ï‰Â² = EffectSize::omegaSquared($SSt, $dft, $SST, $MSE);\n\n// Cohen's Æ’Â²\n$Æ’Â² = EffectSize::cohensF($Î·Â²);\n$Æ’Â² = EffectSize::cohensF($Ï‰Â²);\n$Æ’Â² = EffectSize::cohensF($RÂ²);\n\n// Cohen's q\n[$râ‚, $râ‚‚] = [0.1, 0.2];\n$q = EffectSize::cohensQ($râ‚, $râ‚‚);\n\n// Cohen's d\n[$Î¼â‚, $Ïƒâ‚] = [6.7, 1.2];\n[$Î¼â‚‚, $Ïƒâ‚‚] = [6, 1];\n$d = EffectSize::cohensD($Î¼â‚, $Î¼â‚‚, $Ïƒâ‚, $Ïƒâ‚‚);\n\n// Hedges' g\n[$Î¼â‚, $Ïƒâ‚, $nâ‚] = [6.7, 1.2, 15];\n[$Î¼â‚‚, $Ïƒâ‚‚, $nâ‚‚] = [6, 1, 15];\n$g = EffectSize::hedgesG($Î¼â‚, $Î¼â‚‚, $Ïƒâ‚, $Ïƒâ‚‚, $nâ‚, $nâ‚‚);\n\n// Glass' Î”\n$Î” = EffectSize::glassDelta($Î¼â‚, $Î¼â‚‚, $Ïƒâ‚‚);\n```\n\n### Statistics - Experiments\n```php\nuse MathPHP\\Statistics\\Experiment;\n\n$a = 28;   // Exposed and event present\n$b = 129;  // Exposed and event absent\n$c = 4;    // Non-exposed and event present\n$d = 133;  // Non-exposed and event absent\n\n// Risk ratio (relative risk) - RR\n$RR = Experiment::riskRatio($a, $b, $c, $d);\n// ['RR' => 6.1083, 'ci_lower_bound' => 2.1976, 'ci_upper_bound' => 16.9784, 'p' => 0.0005]\n\n// Odds ratio (OR)\n$OR = Experiment::oddsRatio($a, $b, $c, $d);\n// ['OR' => 7.2171, 'ci_lower_bound' => 2.4624, 'ci_upper_bound' => 21.1522, 'p' => 0.0003]\n\n// Likelihood ratios (positive and negative)\n$LL = Experiment::likelihoodRatio($a, $b, $c, $d);\n// ['LL+' => 7.4444, 'LL-' => 0.3626]\n\n$sensitivity = 0.67;\n$specificity = 0.91;\n$LL          = Experiment::likelihoodRatioSS($sensitivity, $specificity);\n```\n\n### Statistics - Kernel Density Estimation\n```php\nuse MathPHP\\Statistics\\KernelDensityEstimation\n\n$data = [-2.76, -1.09, -0.5, -0.15, 0.22, 0.69, 1.34, 1.75];\n$x    = 0.5;\n\n// Density estimator with default bandwidth (normal distribution approximation) and kernel function (standard normal)\n$kde     = new KernelDensityEstimation($data);\n$density = $kde->evaluate($x)\n\n// Custom bandwidth\n$h = 0.1;\n$kde->setBandwidth($h);\n\n// Library of built-in kernel functions\n$kde->setKernelFunction(KernelDensityEstimation::STANDARD_NORMAL);\n$kde->setKernelFunction(KernelDensityEstimation::NORMAL);\n$kde->setKernelFunction(KernelDensityEstimation::UNIFORM);\n$kde->setKernelFunction(KernelDensityEstimation::TRIANGULAR);\n$kde->setKernelFunction(KernelDensityEstimation::EPANECHNIKOV);\n$kde->setKernelFunction(KernelDensityEstimation::TRICUBE);\n\n// Set custom kernel function (user-provided callable)\n$kernel = function ($x) {\n  if (abs($x) > 1) {\n      return 0;\n  } else {\n      return 70 / 81 * ((1 - abs($x) ** 3) ** 3);\n  }\n};\n$kde->setKernelFunction($kernel);\n\n// All customization optionally can be done in the constructor\n$kde = new KernelDesnsityEstimation($data, $h, $kernel);\n```\n\n### Statistics - Multivariate - Principal Component Analysis\n```php\nuse MathPHP\\Statistics\\Multivariate\\PCA;\nuse MathPHP\\LinearAlgebra\\MatrixFactory;\n\n// Given\n$matrix = MatrixFactory::create($data);  // observations of possibly correlated variables\n$center = true;                          // do mean centering of data\n$scale  = true;                          // do standardization of data\n\n// Build a principal component analysis model to explore\n$model = new PCA($matrix, $center, $scale);\n\n// Scores and loadings of the PCA model\n$scores      = $model->getScores();       // Matrix of transformed standardized data with the loadings matrix\n$loadings    = $model->getLoadings();     // Matrix of unit eigenvectors of the correlation matrix\n$eigenvalues = $model->getEigenvalues();  // Vector of eigenvalues of components\n\n// Residuals, limits, critical values and more\n$RÂ²         = $model->getR2();           // array of RÂ² values\n$cumRÂ²      = $model->getCumR2();        // array of cummulative RÂ² values\n$Q          = $model->getQResiduals();   // Matrix of Q residuals\n$TÂ²         = $model->getT2Distances();  // Matrix of TÂ² distances\n$TÂ²Critical = $model->getCriticalT2();   // array of critical limits of TÂ²\n$QCritical  = $model->getCriticalQ();    // array of critical limits of Q\n```\n\n### Statistics - Multivariate - Partial Least Squares Regression\n```php\nuse MathPHP\\Statistics\\Multivariate\\PLS;\nuse MathPHP\\LinearAlgebra\\MatrixFactory;\nuse MathPHP\\SampleData;\n\n// Given\n$cereal = new SampleData\\Cereal();\n$X      = MatrixFactory::createNumeric($cereal->getXData());\n$Y      = MatrixFactory::createNumeric($cereal->getYData());\n\n// Build a partial least squares regression to explore\n$numberOfComponents = 5;\n$scale              = true;\n$pls                = new PLS($X, $Y, $numberOfComponents, $scale);\n\n// PLS model data\n$C = $pls->getYLoadings();     // Loadings for Y values (each loading column transforms F to U)\n$W = $pls->getXLoadings();     // Loadings for X values (each loading column transforms E into T)\n$T = $pls->getXScores();       // Scores for the X values (latent variables of X)\n$U = $pls->getYScores();       // Scores for the Y values (latent variables of Y)\n$B = $pls->getCoefficients();  // Regression coefficients (matrix that best transforms E into F)\n$P = $pls->getProjections();   // Projection matrix (each projection column transforms T into ÃŠ)\n\n// Predict values (use regression model to predict new values of Y given values for X)\n$yPredictions = $pls->predict($xMatrix);\n```\n\n### Statistics - Outlier\n```php\nuse MathPHP\\Statistics\\Outlier;\n\n$data = [199.31, 199.53, 200.19, 200.82, 201.92, 201.95, 202.18, 245.57];\n$n    = 8;    // size of data\n$ð›¼    = 0.05; // significance level\n\n// Grubb's test - two sided test\n$grubbsStatistic = Outlier::grubbsStatistic($data, Outlier::TWO_SIDED);\n$criticalValue   = Outlier::grubbsCriticalValue($ð›¼, $n, Outlier::TWO_SIDED);\n\n// Grubbs' test - one sided test of minimum value\n$grubbsStatistic = Outlier::grubbsStatistic($data, Outlier::ONE_SIDED_LOWER);\n$criticalValue   = Outlier::grubbsCriticalValue($ð›¼, $n, Outlier::ONE_SIDED);\n\n// Grubbs' test - one sided test of maximum value\n$grubbsStatistic = Outlier::grubbsStatistic($data, Outlier::ONE_SIDED_UPPER);\n$criticalValue   = Outlier::grubbsCriticalValue($ð›¼, $n, Outlier::ONE_SIDED);\n```\n\n### Statistics - Random Variables\n```php\nuse MathPHP\\Statistics\\RandomVariable;\n\n$X = [1, 2, 3, 4];\n$Y = [2, 3, 4, 5];\n\n// Central moment (nth moment)\n$second_central_moment = RandomVariable::centralMoment($X, 2);\n$third_central_moment  = RandomVariable::centralMoment($X, 3);\n\n// Skewness (population, sample, and alternative general method)\n$skewness = RandomVariable::skewness($X);            // Optional type parameter to choose skewness type calculation. Defaults to sample skewness (similar to Excel's SKEW).\n$skewness = RandomVariable::sampleSkewness($X);      // Same as RandomVariable::skewness($X, RandomVariable::SAMPLE_SKEWNESS) - Similar to Excel's SKEW, SAS and SPSS, R (e1071) skewness type 2\n$skewness = RandomVariable::populationSkewness($X);  // Same as RandomVariable::skewness($X, RandomVariable::POPULATION_SKEWNESS) - Similar to Excel's SKEW.P, classic textbook definition, R (e1071) skewness type 1\n$skewness = RandomVariable::alternativeSkewness($X); // Same as RandomVariable::skewness($X, RandomVariable::ALTERNATIVE_SKEWNESS) - Alternative, classic definition of skewness\n$SES      = RandomVariable::ses(count($X));          // standard error of skewness\n\n// Kurtosis (excess)\n$kurtosis    = RandomVariable::kurtosis($X);           // Optional type parameter to choose kurtosis type calculation. Defaults to population kurtosis (similar to Excel's KURT).\n$kurtosis    = RandomVariable::sampleKurtosis($X);     // Same as RandomVariable::kurtosis($X, RandomVariable::SAMPLE_KURTOSIS) -  Similar to R (e1071) kurtosis type 1\n$kurtosis    = RandomVariable::populationKurtosis($X); // Same as RandomVariable::kurtosis($X, RandomVariable::POPULATION_KURTOSIS) - Similar to Excel's KURT, SAS and SPSS, R (e1071) kurtosis type 2\n$platykurtic = RandomVariable::isPlatykurtic($X);      // true if kurtosis is less than zero\n$leptokurtic = RandomVariable::isLeptokurtic($X);      // true if kurtosis is greater than zero\n$mesokurtic  = RandomVariable::isMesokurtic($X);       // true if kurtosis is zero\n$SEK         = RandomVariable::sek(count($X));         // standard error of kurtosis\n\n// Standard error of the mean (SEM)\n$sem = RandomVariable::standardErrorOfTheMean($X); // same as sem\n$sem = RandomVariable::sem($X);                    // same as standardErrorOfTheMean\n\n// Confidence interval\n$Î¼  = 90; // sample mean\n$n  = 9;  // sample size\n$Ïƒ  = 36; // standard deviation\n$cl = 99; // confidence level\n$ci = RandomVariable::confidenceInterval($Î¼, $n, $Ïƒ, $cl); // Array( [ci] => 30.91, [lower_bound] => 59.09, [upper_bound] => 120.91 )\n```\n\n### Statistics - Regressions\n```php\nuse MathPHP\\Statistics\\Regression;\n\n$points = [[1,2], [2,3], [4,5], [5,7], [6,8]];\n\n// Simple linear regression (least squares method)\n$regression = new Regression\\Linear($points);\n$parameters = $regression->getParameters();          // [m => 1.2209302325581, b => 0.6046511627907]\n$equation   = $regression->getEquation();            // y = 1.2209302325581x + 0.6046511627907\n$y          = $regression->evaluate(5);              // Evaluate for y at x = 5 using regression equation\n$ci         = $regression->ci(5, 0.5);               // Confidence interval for x = 5 with p-value of 0.5\n$pi         = $regression->pi(5, 0.5);               // Prediction interval for x = 5 with p-value of 0.5; Optional number of trials parameter.\n$Å¶          = $regression->yHat();\n$r          = $regression->r();                      // same as correlationCoefficient\n$rÂ²         = $regression->r2();                     // same as coefficientOfDetermination\n$se         = $regression->standardErrors();         // [m => se(m), b => se(b)]\n$t          = $regression->tValues();                // [m => t, b => t]\n$p          = $regression->tProbability();           // [m => p, b => p]\n$F          = $regression->fStatistic();\n$p          = $regression->fProbability();\n$h          = $regression->leverages();\n$e          = $regression->residuals();\n$D          = $regression->cooksD();\n$DFFITS     = $regression->dffits();\n$SStot      = $regression->sumOfSquaresTotal();\n$SSreg      = $regression->sumOfSquaresRegression();\n$SSres      = $regression->sumOfSquaresResidual();\n$MSR        = $regression->meanSquareRegression();\n$MSE        = $regression->meanSquareResidual();\n$MSTO       = $regression->meanSquareTotal();\n$error      = $regression->errorSd();                // Standard error of the residuals\n$V          = $regression->regressionVariance();\n$n          = $regression->getSampleSize();          // 5\n$points     = $regression->getPoints();              // [[1,2], [2,3], [4,5], [5,7], [6,8]]\n$xs         = $regression->getXs();                  // [1, 2, 4, 5, 6]\n$ys         = $regression->getYs();                  // [2, 3, 5, 7, 8]\n$Î½          = $regression->degreesOfFreedom();\n\n// Linear regression through a fixed point (least squares method)\n$force_point = [0,0];\n$regression  = new Regression\\LinearThroughPoint($points, $force_point);\n$parameters  = $regression->getParameters();\n$equation    = $regression->getEquation();\n$y           = $regression->evaluate(5);\n$Å¶           = $regression->yHat();\n$r           = $regression->r();\n$rÂ²          = $regression->r2();\n â‹®                     â‹®\n\n// Theilâ€“Sen estimator (Sen's slope estimator, Kendallâ€“Theil robust line)\n$regression  = new Regression\\TheilSen($points);\n$parameters  = $regression->getParameters();\n$equation    = $regression->getEquation();\n$y           = $regression->evaluate(5);\n â‹®                     â‹®\n\n// Use Lineweaver-Burk linearization to fit data to the Michaelisâ€“Menten model: y = (V * x) / (K + x)\n$regression  = new Regression\\LineweaverBurk($points);\n$parameters  = $regression->getParameters();  // [V, K]\n$equation    = $regression->getEquation();    // y = Vx / (K + x)\n$y           = $regression->evaluate(5);\n â‹®                     â‹®\n\n// Use Hanes-Woolf linearization to fit data to the Michaelisâ€“Menten model: y = (V * x) / (K + x)\n$regression  = new Regression\\HanesWoolf($points);\n$parameters  = $regression->getParameters();  // [V, K]\n$equation    = $regression->getEquation();    // y = Vx / (K + x)\n$y           = $regression->evaluate(5);\n â‹®                     â‹®\n\n// Power law regression - power curve (least squares fitting)\n$regression = new Regression\\PowerLaw($points);\n$parameters = $regression->getParameters();   // [a => 56.483375436574, b => 0.26415375648621]\n$equation   = $regression->getEquation();     // y = 56.483375436574x^0.26415375648621\n$y          = $regression->evaluate(5);\n â‹®                     â‹®\n\n// LOESS - Locally Weighted Scatterplot Smoothing (Local regression)\n$Î±          = 1/3;                         // Smoothness parameter\n$Î»          = 1;                           // Order of the polynomial fit\n$regression = new Regression\\LOESS($points, $Î±, $Î»);\n$y          = $regression->evaluate(5);\n$Å¶          = $regression->yHat();\n â‹®                     â‹®\n```\n\n### Statistics - Significance Testing\n```php\nuse MathPHP\\Statistics\\Significance;\n\n// Z test - One sample (z and p values)\n$Hâ‚ = 20;   // Alternate hypothesis (M Sample mean)\n$n  = 200;  // Sample size\n$Hâ‚€ = 19.2; // Null hypothesis (Î¼ Population mean)\n$Ïƒ  = 6;    // SD of population (Standard error of the mean)\n$z  = Significance:zTest($Hâ‚, $n, $Hâ‚€, $Ïƒ);           // Same as zTestOneSample\n$z  = Significance:zTestOneSample($Hâ‚, $n, $Hâ‚€, $Ïƒ);  // Same as zTest\n/* [\n  'z'  => 1.88562, // Z score\n  'p1' => 0.02938, // one-tailed p value\n  'p2' => 0.0593,  // two-tailed p value\n] */\n\n// Z test - Two samples (z and p values)\n$Î¼â‚ = 27;   // Sample mean of population 1\n$Î¼â‚‚ = 33;   // Sample mean of population 2\n$nâ‚ = 75;   // Sample size of population 1\n$nâ‚‚ = 50;   // Sample size of population 2\n$Ïƒâ‚ = 14.1; // Standard deviation of sample mean 1\n$Ïƒâ‚‚ = 9.5;  // Standard deviation of sample mean 2\n$z  = Significance::zTestTwoSample($Î¼â‚, $Î¼â‚‚, $nâ‚, $nâ‚‚, $Ïƒâ‚, $Ïƒâ‚‚);\n/* [\n  'z'  => -2.36868418147285,  // z score\n  'p1' => 0.00893,            // one-tailed p value\n  'p2' => 0.0179,             // two-tailed p value\n] */\n\n// Z score\n$M = 8; // Sample mean\n$Î¼ = 7; // Population mean\n$Ïƒ = 1; // Population SD\n$z = Significance::zScore($M, $Î¼, $Ïƒ);\n\n// T test - One sample (from sample data)\n$a     = [3, 4, 4, 5, 5, 5, 6, 6, 7, 8]; // Data set\n$Hâ‚€    = 300;                            // Null hypothesis (Î¼â‚€ Population mean)\n$tTest = Significance::tTest($a, $Hâ‚€)\nprint_r($tTest);\n/* Array (\n    [t]    => 0.42320736951516  // t score\n    [df]   => 9                 // degrees of freedom\n    [p1]   => 0.34103867713806  // one-tailed p value\n    [p2]   => 0.68207735427613  // two-tailed p value\n    [mean] => 5.3               // sample mean\n    [sd]   => 1.4944341180973   // standard deviation\n) */\n\n// T test - One sample (from summary data)\n$Hâ‚    = 280; // Alternate hypothesis (M Sample mean)\n$s     = 50;  // Standard deviation of sample\n$n     = 15;  // Sample size\n$Hâ‚€    = 300; // Null hypothesis (Î¼â‚€ Population mean)\n$tTest = Significance::tTestOneSampleFromSummaryData($Hâ‚, $s, $n, $Hâ‚€);\nprint_r($tTest);\n/* Array (\n    [t]    => -1.549193338483    // t score\n    [df]   => 14                 // degreees of freedom\n    [p1]   => 0.071820000122611  // one-tailed p value\n    [p2]   => 0.14364000024522   // two-tailed p value\n    [mean] => 280                // sample mean\n    [sd]   => 50                 // standard deviation\n) */\n\n// T test - Two samples (from sample data)\n$xâ‚    = [27.5, 21.0, 19.0, 23.6, 17.0, 17.9, 16.9, 20.1, 21.9, 22.6, 23.1, 19.6, 19.0, 21.7, 21.4];\n$xâ‚‚    = [27.1, 22.0, 20.8, 23.4, 23.4, 23.5, 25.8, 22.0, 24.8, 20.2, 21.9, 22.1, 22.9, 20.5, 24.4];\n$tTest = Significance::tTest($xâ‚, $xâ‚‚);\nprint_r($tTest);\n/* Array (\n    [t]     => -2.4553600286929   // t score\n    [df]    => 24.988527070145    // degrees of freedom\n    [p1]    => 0.010688914613979  // one-tailed p value\n    [p2]    => 0.021377829227958  // two-tailed p value\n    [mean1] => 20.82              // mean of sample xâ‚\n    [mean2] => 22.98667           // mean of sample xâ‚‚\n    [sd1]   => 2.804894           // standard deviation of xâ‚\n    [sd2]   => 1.952605           // standard deviation of xâ‚‚\n) */\n\n// T test - Two samples (from summary data)\n$Î¼â‚    = 42.14; // Sample mean of population 1\n$Î¼â‚‚    = 43.23; // Sample mean of population 2\n$nâ‚    = 10;    // Sample size of population 1\n$nâ‚‚    = 10;    // Sample size of population 2\n$Ïƒâ‚    = 0.683; // Standard deviation of sample mean 1\n$Ïƒâ‚‚    = 0.750; // Standard deviation of sample mean 2\n$tTest = Significance::tTestTwoSampleFromSummaryData($Î¼â‚, $Î¼â‚‚, $nâ‚, $nâ‚‚, $Ïƒâ‚, $Ïƒâ‚‚);\nprint_r($tTest);\n/* Array (\n   [t] => -3.3972305988708     // t score\n   [df] => 17.847298548027     // degrees of freedom\n   [p1] => 0.0016211251126198  // one-tailed p value\n   [p2] => 0.0032422502252396  // two-tailed p value\n   [mean1] => 42.14\n   [mean2] => 43.23\n   [sd1] => 0.6834553\n   [sd2] => 0.7498889\n] */\n\n// T score\n$Hâ‚ = 280; // Alternate hypothesis (M Sample mean)\n$s  = 50;  // SD of sample\n$n  = 15;  // Sample size\n$Hâ‚€ = 300; // Null hypothesis (Î¼â‚€ Population mean)\n$t  = Significance::tScore($Hâ‚, $s, $n, $H);\n\n// Ï‡Â² test (chi-squared goodness of fit test)\n$observed = [4, 6, 17, 16, 8, 9];\n$expected = [10, 10, 10, 10, 10, 10];\n$Ï‡Â²       = Significance::chiSquaredTest($observed, $expected);\n// ['chi-square' => 14.2, 'p' => 0.014388]\n```\n\n### Trigonometry\n```php\nuse MathPHP\\Trigonometry;\n\n$n      = 9;\n$points = Trigonometry::unitCircle($n); // Produce n number of points along the unit circle\n```\n\nUnit Tests\n----------\n\nBeyond 100% code coverage!\n\nMathPHP has thousands of unit tests testing individual functions directly with numerous data inputs to achieve 100% test coverage.\nMathPHP unit tests also test mathematical axioms which indirectly test the same functions in multiple different ways ensuring that those math properties all work out according to the axioms.\n\n```bash\n$ cd tests\n$ phpunit\n```\n\n[![Coverage Status](https://coveralls.io/repos/github/markrogoyski/math-php/badge.svg?branch=master)](https://coveralls.io/github/markrogoyski/math-php?branch=master)\n\nStandards\n---------\n\nMathPHP conforms to the following standards:\n\n * PSR-1  - Basic coding standard (http://www.php-fig.org/psr/psr-1/)\n * PSR-4  - Autoloader (http://www.php-fig.org/psr/psr-4/)\n * PSR-12 - Extended coding style guide (http://www.php-fig.org/psr/psr-12/)\n\nLicense\n-------\n\nMathPHP is licensed under the MIT License.\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.4521484375,
          "content": "{\n  \"name\": \"markrogoyski/math-php\",\n  \"type\": \"library\",\n  \"description\": \"Math Library for PHP. Features descriptive statistics and regressions; Continuous and discrete probability distributions; Linear algebra with matrices and vectors, Numerical analysis; special mathematical functions; Algebra\",\n  \"keywords\": [\"math\", \"mathematics\", \"probability\", \"combinatorics\", \"statistics\", \"distributions\", \"regressions\", \"linear algebra\", \"matrix\", \"algebra\", \"numerical analysis\"],\n  \"homepage\": \"https://github.com/markrogoyski/math-php/\",\n  \"require\": {\n    \"php\": \">=7.2.0\",\n    \"ext-json\": \"*\"\n  },\n  \"autoload\": {\n    \"psr-4\": { \"MathPHP\\\\\": \"src/\" }\n  },\n  \"require-dev\": {\n      \"phpunit/phpunit\": \"^8.5\",\n      \"php-coveralls/php-coveralls\": \"^2.0\",\n      \"squizlabs/php_codesniffer\": \"3.*\",\n      \"phpstan/phpstan\": \"^1.10\",\n      \"phpmd/phpmd\": \"^2.6\",\n      \"phploc/phploc\": \"*\",\n      \"php-parallel-lint/php-parallel-lint\": \"^1.2\"\n  },\n  \"autoload-dev\": {\n    \"psr-4\": { \"MathPHP\\\\Tests\\\\\": \"tests/\" }\n  },\n  \"authors\": [\n    {\n      \"name\": \"Mark Rogoyski\",\n      \"role\": \"Lead developer\",\n      \"email\": \"mark@rogoyski.com\",\n      \"homepage\": \"https://github.com/markrogoyski\"\n    },\n    {\n      \"name\": \"Kevin Nowaczyk\",\n      \"role\": \"Developer\",\n      \"homepage\": \"https://github.com/Beakerboy\"\n    },\n    {\n      \"name\": \"MathPHP Community of Contributors\",\n      \"homepage\": \"https://github.com/markrogoyski/math-php/graphs/contributors\"\n    }\n  ],\n  \"license\": \"MIT\"\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}