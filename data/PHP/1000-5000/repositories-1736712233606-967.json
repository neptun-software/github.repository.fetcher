{
  "metadata": {
    "timestamp": 1736712233606,
    "page": 967,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dedemao/weixinPay",
      "stars": 1189,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.4716796875,
          "content": "# weixinPay\n一个PHP文件搞定微信支付系列\n\n网上的很多PHP微信支付接入教程都颇为复杂，且需要配置和引入较多的文件，本人通过整理后给出一个单文件版的（代码只有200行左右），每个文件独立运行，不依赖和引入其他文件，希望可以给各位想接入微信支付的带来些许帮助和借鉴意义。\n\n一个PHP文件搞定支付宝系列请移步：https://github.com/dedemao/alipay\n\n# 在线演示\nhttps://www.dedemao.com/wx/demo.html\n\n# 环境依赖\n\nPHP5.0以上，且需要开启CURL服务、SSL服务。\n\n# 文件对应说明\n\nnative.php\t  原生支付（扫码支付）\n\nbarcode.php\t  刷卡支付（商户扫描用户收款码）\n\njsapi.php\t   公众号支付\n\nH5.php\t   H5支付\n\nredpack.php   现金红包\n\ntransfers.php 企业付款到零钱\n\nnotify.php    异步回调通知\n\nrefund.php 退款\n\n# 注意事项\n\n1.需要用到微信支付的哪一种支付方式，就只下载对应的单个文件即可。\n\n2.文件开头的配置信息必须完善\n\n3.文件需放到支付授权目录下，可以在微信支付商户平台->产品中心->开发配置中设置。\n\n4.如提示签名错误可以通过微信支付签名验证工具进行验证：https://pay.weixin.qq.com/wiki/tools/signverify/\n\n\n# 若对您有帮助，可以赞助并支持下作者哦，谢谢！\n\n<p align=\"center\">\n    <img src=\"https://www.dedemao.com/uploads/zan.jpg\" width=\"500px\">\n    <p align=\"center\">联系邮箱：884358@qq.com</p>\n</p>\n"
        },
        {
          "name": "authorize.php",
          "type": "blob",
          "size": 7.384765625,
          "content": "<?php\r\nerror_reporting(1);\r\nheader('Content-type:text/html; Charset=utf-8');\r\n/* 配置开始 */\r\n$appid = '';  //微信公众平台->开发->基本配置->AppID\r\n$appKey = '';   //微信公众平台->开发->基本配置->AppSecret\r\n/* 配置结束 */\r\n\r\n//①、获取用户openid\r\n$wxPay = new WxService($appid,$appKey);\r\n$data = $wxPay->GetOpenid();      //获取openid\r\nif(!$data['openid']) exit('获取openid失败');\r\n//②、获取用户信息\r\n$user = $wxPay->getUserInfo($data['openid'],$data['access_token']);\r\n?>\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"renderer\" content=\"webkit\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,Chrome=1\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0\" />\r\n    <title>微信获取用户信息demo</title>\r\n    <link href=\"https://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css\" rel=\"stylesheet\">\r\n    <script src=\"https://cdn.bootcss.com/jquery/2.1.0/jquery.min.js\"></script>\r\n</head>\r\n<body>\r\n<div class=\"container\">\r\n    <div class=\"row\">\r\n        <h1>你的基本信息如下：</h1>\r\n        <table class=\"table table-bordered\">\r\n            <tr>\r\n                <td>openid</td>\r\n                <td><?=$user['openid']?></td>\r\n            </tr>\r\n            <tr>\r\n                <td>unionid</td>\r\n                <td><?=$user['unionid']?></td>\r\n            </tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>昵称</td>\r\n\t\t\t\t<td><?=$user['nickname']?></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>头像</td>\r\n\t\t\t\t<td><img src=\"<?=$user['headimgurl']?>\" style=\"width: 100px;\" alt=\"\"></td>\r\n\t\t\t</tr>               \r\n\t\t\t<tr>\r\n\t\t\t\t<td>性别</td>\r\n\t\t\t\t<td><?php\r\n\t\t\t\t\tswitch (strtoupper($user['sex'])){\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\techo '男性';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\techo '女性';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\techo '未知';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t?></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>省份 / 城市</td>\r\n\t\t\t\t<td><?=$user['province'].' / '.$user['city']?></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>language</td>\r\n\t\t\t\t<td><?=$user['language']?></td>\r\n\t\t\t</tr>\r\n        </table>\r\n    </div>\r\n</div>\r\n</body>\r\n</html>\r\n<?php\r\nclass WxService\r\n{\r\n    protected $appid;\r\n    protected $appKey;\r\n\r\n    public $data = null;\r\n\r\n    public function __construct($appid, $appKey)\r\n    {\r\n        $this->appid = $appid; //微信支付申请对应的公众号的APPID\r\n        $this->appKey = $appKey; //微信支付申请对应的公众号的APP Key\r\n    }\r\n\r\n    /**\r\n     * 通过跳转获取用户的openid，跳转流程如下：\r\n     * 1、设置自己需要调回的url及其其他参数，跳转到微信服务器https://open.weixin.qq.com/connect/oauth2/authorize\r\n     * 2、微信服务处理完成之后会跳转回用户redirect_uri地址，此时会带上一些参数，如：code\r\n     *\r\n     * @return 用户的openid\r\n     */\r\n    public function GetOpenid()\r\n    {\r\n        //通过code获得openid\r\n        if (!isset($_GET['code'])){\r\n            //触发微信返回code码\r\n            $baseUrl = $this->getCurrentUrl();\r\n            $url = $this->__CreateOauthUrlForCode($baseUrl);\r\n            Header(\"Location: $url\");\r\n            exit();\r\n        } else {\r\n            //获取code码，以获取openid\r\n            $code = $_GET['code'];\r\n            $openid = $this->getOpenidFromMp($code);\r\n            return $openid;\r\n        }\r\n    }\r\n\r\n    public function getCurrentUrl()\r\n    {\r\n        $scheme = $_SERVER['HTTPS']=='on' ? 'https://' : 'http://';\r\n        $uri = $_SERVER['PHP_SELF'].$_SERVER['QUERY_STRING'];\r\n        if($_SERVER['REQUEST_URI']) $uri = $_SERVER['REQUEST_URI'];\r\n        $baseUrl = urlencode($scheme.$_SERVER['HTTP_HOST'].$uri);\r\n        return $baseUrl;\r\n    }\r\n\r\n    /**\r\n     * 通过code从工作平台获取openid机器access_token\r\n     * @param string $code 微信跳转回来带上的code\r\n     * @return openid\r\n     */\r\n    public function GetOpenidFromMp($code)\r\n    {\r\n        $url = $this->__CreateOauthUrlForOpenid($code);        \r\n        $res = self::curlGet($url);\r\n        $data = json_decode($res,true);\r\n        $this->data = $data;\r\n        return $data;\r\n    }\r\n\r\n    /**\r\n     * 构造获取open和access_toke的url地址\r\n     * @param string $code，微信跳转带回的code\r\n     * @return 请求的url\r\n     */\r\n    private function __CreateOauthUrlForOpenid($code)\r\n    {\r\n        $urlObj[\"appid\"] = $this->appid;\r\n        $urlObj[\"secret\"] = $this->appKey;\r\n        $urlObj[\"code\"] = $code;\r\n        $urlObj[\"grant_type\"] = \"authorization_code\";\r\n        $bizString = $this->ToUrlParams($urlObj);\r\n        return \"https://api.weixin.qq.com/sns/oauth2/access_token?\".$bizString;\r\n    }\r\n\r\n    /**\r\n     * 构造获取code的url连接\r\n     * @param string $redirectUrl 微信服务器回跳的url，需要url编码\r\n     * @return 返回构造好的url\r\n     */\r\n    private function __CreateOauthUrlForCode($redirectUrl)\r\n    {\r\n        $urlObj[\"appid\"] = $this->appid;\r\n        $urlObj[\"redirect_uri\"] = \"$redirectUrl\";\r\n        $urlObj[\"response_type\"] = \"code\";\r\n        $urlObj[\"scope\"] = \"snsapi_userinfo\";\r\n        $urlObj[\"state\"] = \"STATE\";\r\n        $bizString = $this->ToUrlParams($urlObj);\r\n        return \"https://open.weixin.qq.com/connect/oauth2/authorize?\".$bizString;\r\n    }\r\n\r\n    /**\r\n     * 拼接签名字符串\r\n     * @param array $urlObj\r\n     * @return 返回已经拼接好的字符串\r\n     */\r\n    private function ToUrlParams($urlObj)\r\n    {\r\n        $buff = \"\";\r\n        foreach ($urlObj as $k => $v)\r\n        {\r\n            if($k != \"sign\") $buff .= $k . \"=\" . $v . \"&\";\r\n        }\r\n        $buff = trim($buff, \"&\");\r\n        return $buff;\r\n    }\r\n\r\n    /**\r\n     * 获取用户信息\r\n     * @param string $openid 调用【网页授权获取用户信息】接口获取到用户在该公众号下的Openid\r\n     * @return string\r\n     */\r\n    public function getUserInfo($openid,$access_token)\r\n    {\r\n\r\n        $response = self::curlGet('https://api.weixin.qq.com/sns/userinfo?access_token='.$access_token.'&openid='.$openid.'&lang=zh_CN');\r\n        return json_decode($response,true);\r\n        \r\n    }\r\n\r\n    public static function curlGet($url = '', $options = array())\r\n    {\r\n        $ch = curl_init($url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n\r\n    public static function curlPost($url = '', $postData = '', $options = array())\r\n    {\r\n        if (is_array($postData)) {\r\n            $postData = http_build_query($postData);\r\n        }\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_URL, $url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_POST, 1);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n\r\n}\r\n"
        },
        {
          "name": "barcode.php",
          "type": "blob",
          "size": 8.390625,
          "content": "<?php\r\n/**\r\n * 刷卡支付\r\n * 提醒：提交支付请求后微信会同步返回支付结果（没有异步回调通知）。当返回结果为“系统错误”时，商户系统等待5秒后调用【查询订单API】，查询支付实际交易结果；当返回结果为“USERPAYING”时，商户系统可设置间隔时间(建议10秒)重新查询支付结果，直到支付成功或超时(建议30秒)；\r\n */\r\nheader('Content-type:text/html; Charset=utf-8');\r\n$mchid = 'xxxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\r\n$appid = 'xxxxx';  //公众号APPID 通过微信支付商户资料审核后邮件发送\r\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n$outTradeNo = uniqid();     //你自己的商品订单号，不能重复\r\n$payAmount = 0.01;          //付款金额，单位:元\r\n$orderName = '支付测试';    //订单标题\r\n$authCode = 'xxxxx';         //用户付款码（商户使用设备扫码用户的付款条码读取到的条码数字，或 打开微信-》我-》钱包-》收付款 点击可查看付款码数字）\r\n\r\n$wxPay = new WxpayService($mchid,$appid,$apiKey);\r\n$wxPay->setTotalFee($payAmount);\r\n$wxPay->setOutTradeNo($outTradeNo);\r\n$wxPay->setOrderName($orderName);\r\n$wxPay->setAuthCode($authCode);\r\n$arr = $wxPay->createJsBizPackage();\r\nif($arr['return_code']=='SUCCESS'){\r\n    echo '付款成功！返回信息如下：<br><hr>';\r\n    echo '<pre>'.print_r($arr).'</pre>';\r\n    exit();\r\n}\r\nexit('error');\r\nclass WxpayService\r\n{\r\n    protected $mchid;\r\n    protected $appid;\r\n    protected $apiKey;\r\n    protected $totalFee;\r\n    protected $outTradeNo;\r\n    protected $orderName;\r\n    protected $authCode;\r\n    public function __construct($mchid='', $appid='', $key='')\r\n    {\r\n        $this->mchid = $mchid;\r\n        $this->appid = $appid;\r\n        $this->apiKey = $key;\r\n    }\r\n\r\n    public function setTotalFee($totalFee)\r\n    {\r\n        $this->totalFee = $totalFee;\r\n    }\r\n\r\n    public function setOutTradeNo($outTradeNo)\r\n    {\r\n        $this->outTradeNo = $outTradeNo;\r\n    }\r\n\r\n    public function setOrderName($orderName)\r\n    {\r\n        $this->orderName = $orderName;\r\n    }\r\n\r\n    public function setAuthCode($authCode)\r\n    {\r\n        $this->authCode = $authCode;\r\n    }\r\n\r\n    /**\r\n     * 发起订单\r\n     * @return array\r\n     */\r\n    public function createJsBizPackage()\r\n    {\r\n        $config = array(\r\n            'mch_id' => $this->mchid,\r\n            'appid' => $this->appid,\r\n            'key' => $this->apiKey,\r\n            'total_fee' => $this->totalFee,\r\n            'out_trade_no' => $this->outTradeNo,\r\n            'order_name' => $this->orderName,\r\n            'auth_code' => $this->authCode,\r\n        );\r\n        //$orderName = iconv('GBK','UTF-8',$orderName);\r\n        $unified = array(\r\n            'appid' => $config['appid'],\r\n            'attach' => 'pay',             //商家数据包，原样返回，如果填写中文，请注意转换为utf-8\r\n            'body' => $config['order_name'],\r\n            'mch_id' => $config['mch_id'],\r\n            'nonce_str' => self::createNonceStr(),\r\n            'out_trade_no' => $config['out_trade_no'],\r\n            'spbill_create_ip' => '127.0.0.1',\r\n            'total_fee' => floatval($config['total_fee']) * 100,       //单位 转为分\r\n            'auth_code'=>$config['auth_code'],     //收款码,\r\n            'device_info'=>'dedemao001',        //终端设备号(商户自定义，如门店编号)\r\n//            'limit_pay'=>'no_credit'            //指定支付方式  no_credit--指定不能使用信用卡支付\r\n        );\r\n        $unified['sign'] = self::getSign($unified, $config['key']);\r\n        $responseXml = self::curlPost('https://api.mch.weixin.qq.com/pay/micropay', self::arrayToXml($unified));\r\n        $unifiedOrder = simplexml_load_string($responseXml, 'SimpleXMLElement', LIBXML_NOCDATA);\r\n        if ($unifiedOrder === false) {\r\n            die('parse xml error');\r\n        }\r\n        if ($unifiedOrder->return_code != 'SUCCESS') {\r\n            die('支付失败：错误码：'.$unifiedOrder->err_code.'。错误码说明：https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=9_10&index=1#7');\r\n        }\r\n        if ($unifiedOrder->result_code != 'SUCCESS') {\r\n            die('支付失败：错误码：'.$unifiedOrder->err_code.'。错误码说明：https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=9_10&index=1#7');\r\n        }\r\n        return (array)$unifiedOrder;\r\n    }\r\n    public function notify()\r\n    {\r\n        $config = array(\r\n            'mch_id' => $this->mchid,\r\n            'appid' => $this->appid,\r\n            'key' => $this->apiKey,\r\n        );\r\n        $postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"];\r\n        $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);\r\n        if ($postObj === false) {\r\n            die('parse xml error');\r\n        }\r\n        if ($postObj->return_code != 'SUCCESS') {\r\n            die($postObj->return_msg);\r\n        }\r\n        if ($postObj->result_code != 'SUCCESS') {\r\n            die($postObj->err_code);\r\n        }\r\n        $arr = (array)$postObj;\r\n        unset($arr['sign']);\r\n        if (self::getSign($arr, $config['key']) == $postObj->sign) {\r\n            echo '<xml><return_code><![CDATA[SUCCESS]]></return_code><return_msg><![CDATA[OK]]></return_msg></xml>';\r\n            return $postObj;\r\n        }\r\n    }\r\n    /**\r\n     * curl get\r\n     *\r\n     * @param string $url\r\n     * @param array $options\r\n     * @return mixed\r\n     */\r\n    public static function curlGet($url = '', $options = array())\r\n    {\r\n        $ch = curl_init($url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n    public static function curlPost($url = '', $postData = '', $options = array())\r\n    {\r\n        if (is_array($postData)) {\r\n            $postData = http_build_query($postData);\r\n        }\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_URL, $url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_POST, 1);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n    public static function createNonceStr($length = 16)\r\n    {\r\n        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        $str = '';\r\n        for ($i = 0; $i < $length; $i++) {\r\n            $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\r\n        }\r\n        return $str;\r\n    }\r\n    public static function arrayToXml($arr)\r\n    {\r\n        $xml = \"<xml>\";\r\n        foreach ($arr as $key => $val) {\r\n            if (is_numeric($val)) {\r\n                $xml .= \"<\" . $key . \">\" . $val . \"</\" . $key . \">\";\r\n            } else\r\n                $xml .= \"<\" . $key . \"><![CDATA[\" . $val . \"]]></\" . $key . \">\";\r\n        }\r\n        $xml .= \"</xml>\";\r\n        return $xml;\r\n    }\r\n    /**\r\n     * 获取签名\r\n     */\r\n    public static function getSign($params, $key)\r\n    {\r\n        ksort($params, SORT_STRING);\r\n        $unSignParaString = self::formatQueryParaMap($params, false);\r\n        $signStr = strtoupper(md5($unSignParaString . \"&key=\" . $key));\r\n        return $signStr;\r\n    }\r\n    protected static function formatQueryParaMap($paraMap, $urlEncode = false)\r\n    {\r\n        $buff = \"\";\r\n        ksort($paraMap);\r\n        foreach ($paraMap as $k => $v) {\r\n            if (null != $v && \"null\" != $v) {\r\n                if ($urlEncode) {\r\n                    $v = urlencode($v);\r\n                }\r\n                $buff .= $k . \"=\" . $v . \"&\";\r\n            }\r\n        }\r\n        $reqPar = '';\r\n        if (strlen($buff) > 0) {\r\n            $reqPar = substr($buff, 0, strlen($buff) - 1);\r\n        }\r\n        return $reqPar;\r\n    }\r\n}\r\n"
        },
        {
          "name": "h5.php",
          "type": "blob",
          "size": 7.1923828125,
          "content": "<?php\r\n/**\r\n * H5支付\r\n *\r\n * 常见错误：\r\n * 1.网络环境未能通过安全验证，请稍后再试（原因：终端IP(spbill_create_ip)与用户实际调起支付时微信侧检测到的终端IP不一致）\r\n * 2.商家参数格式有误，请联系商家解决（原因：当前调起H5支付的referer为空）\r\n * 3.商家存在未配置的参数，请联系商家解决（原因：当前调起H5支付的域名与申请H5支付时提交的授权域名不一致）\r\n * 4.支付请求已失效，请重新发起支付（原因：有效期为5分钟，如超时请重新发起支付）\r\n * 5.请在微信外打开订单，进行支付（原因：H5支付不能直接在微信客户端内调起）\r\n */\r\nheader('Content-type:text/html; Charset=utf-8');\r\n/** 请填写以下配置信息 */\r\n$mchid = 'xxxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\r\n$appid = 'xxxxx';  //微信支付申请对应的公众号的APPID\r\n$appKey = 'xxxxx';   //微信支付申请对应的公众号的APP Key\r\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n$outTradeNo = uniqid();     //你自己的商品订单号\r\n$payAmount = 0.01;          //付款金额，单位:元\r\n$orderName = '支付测试';    //订单标题\r\n$notifyUrl = 'http://www.xxx.com/wx/notify.php';     //付款成功后的回调地址(不要有问号)\r\n$returnUrl = 'http://www.baidu.com';     //付款成功后，页面跳转的地址\r\n$wapUrl = 'www.xxx.com';   //WAP网站URL地址\r\n$wapName = 'H5支付';       //WAP 网站名\r\n/** 配置结束 */\r\n\r\n$wxPay = new WxpayService($mchid,$appid,$apiKey);\r\n$wxPay->setTotalFee($payAmount);\r\n$wxPay->setOutTradeNo($outTradeNo);\r\n$wxPay->setOrderName($orderName);\r\n$wxPay->setNotifyUrl($notifyUrl);\r\n$wxPay->setReturnUrl($returnUrl);\r\n$wxPay->setWapUrl($wapUrl);\r\n$wxPay->setWapName($wapName);\r\n\r\n$mwebUrl= $wxPay->createJsBizPackage($payAmount,$outTradeNo,$orderName,$notifyUrl);\r\necho \"<h1><a href='{$mwebUrl}'>点击跳转至支付页面</a></h1>\";\r\nexit();\r\nclass WxpayService\r\n{\r\n    protected $mchid;\r\n    protected $appid;\r\n    protected $apiKey;\r\n    protected $totalFee;\r\n    protected $outTradeNo;\r\n    protected $orderName;\r\n    protected $notifyUrl;\r\n    protected $returnUrl;\r\n    protected $wapUrl;\r\n    protected $wapName;\r\n\r\n    public function __construct($mchid, $appid, $key)\r\n    {\r\n        $this->mchid = $mchid;\r\n        $this->appid = $appid;\r\n        $this->apiKey = $key;\r\n    }\r\n\r\n    public function setTotalFee($totalFee)\r\n    {\r\n        $this->totalFee = $totalFee;\r\n    }\r\n    public function setOutTradeNo($outTradeNo)\r\n    {\r\n        $this->outTradeNo = $outTradeNo;\r\n    }\r\n    public function setOrderName($orderName)\r\n    {\r\n        $this->orderName = $orderName;\r\n    }\r\n    public function setWapUrl($wapUrl)\r\n    {\r\n        $this->wapUrl = $wapUrl;\r\n    }\r\n    public function setWapName($wapName)\r\n    {\r\n        $this->wapName = $wapName;\r\n    }\r\n    public function setNotifyUrl($notifyUrl)\r\n    {\r\n        $this->notifyUrl = $notifyUrl;\r\n    }\r\n    public function setReturnUrl($returnUrl)\r\n    {\r\n        $this->returnUrl = $returnUrl;\r\n    }\r\n\r\n    /**\r\n     * 发起订单\r\n     * @return array\r\n     */\r\n    public function createJsBizPackage()\r\n    {\r\n        $config = array(\r\n            'mch_id' => $this->mchid,\r\n            'appid' => $this->appid,\r\n            'key' => $this->apiKey,\r\n        );\r\n        $scene_info = array(\r\n            'h5_info' =>array(\r\n                'type'=>'Wap',\r\n                'wap_url'=>$this->wapUrl,\r\n                'wap_name'=>$this->wapName,\r\n            )\r\n        );\r\n        $unified = array(\r\n            'appid' => $config['appid'],\r\n            'attach' => 'pay',             //商家数据包，原样返回，如果填写中文，请注意转换为utf-8\r\n            'body' => $this->orderName,\r\n            'mch_id' => $config['mch_id'],\r\n            'nonce_str' => self::createNonceStr(),\r\n            'notify_url' => $this->notifyUrl,\r\n            'out_trade_no' => $this->outTradeNo,\r\n            'spbill_create_ip' => $_SERVER['REMOTE_ADDR'],\r\n            'total_fee' => floatval($this->totalFee) * 100,       //单位 转为分\r\n            'trade_type' => 'MWEB',\r\n            'scene_info'=>json_encode($scene_info)\r\n        );\r\n        $unified['sign'] = self::getSign($unified, $config['key']);\r\n        $responseXml = self::curlPost('https://api.mch.weixin.qq.com/pay/unifiedorder', self::arrayToXml($unified));\r\n        $unifiedOrder = simplexml_load_string($responseXml, 'SimpleXMLElement', LIBXML_NOCDATA);\r\n        if ($unifiedOrder->return_code != 'SUCCESS') {\r\n            die($unifiedOrder->return_msg);\r\n        }\r\n        if($unifiedOrder->mweb_url){\r\n            return $unifiedOrder->mweb_url.'&redirect_url='.urlencode($this->returnUrl);\r\n        }\r\n        exit('error');\r\n    }\r\n    public static function curlPost($url = '', $postData = '', $options = array())\r\n    {\r\n        if (is_array($postData)) {\r\n            $postData = http_build_query($postData);\r\n        }\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_URL, $url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_POST, 1);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n    public static function createNonceStr($length = 16)\r\n    {\r\n        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        $str = '';\r\n        for ($i = 0; $i < $length; $i++) {\r\n            $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\r\n        }\r\n        return $str;\r\n    }\r\n    public static function arrayToXml($arr)\r\n    {\r\n        $xml = \"<xml>\";\r\n        foreach ($arr as $key => $val) {\r\n            if (is_numeric($val)) {\r\n                $xml .= \"<\" . $key . \">\" . $val . \"</\" . $key . \">\";\r\n            } else\r\n                $xml .= \"<\" . $key . \"><![CDATA[\" . $val . \"]]></\" . $key . \">\";\r\n        }\r\n        $xml .= \"</xml>\";\r\n        return $xml;\r\n    }\r\n    /**\r\n     * 获取签名\r\n     */\r\n    public static function getSign($params, $key)\r\n    {\r\n        ksort($params, SORT_STRING);\r\n        $unSignParaString = self::formatQueryParaMap($params, false);\r\n        $signStr = strtoupper(md5($unSignParaString . \"&key=\" . $key));\r\n        return $signStr;\r\n    }\r\n    protected static function formatQueryParaMap($paraMap, $urlEncode = false)\r\n    {\r\n        $buff = \"\";\r\n        ksort($paraMap);\r\n        foreach ($paraMap as $k => $v) {\r\n            if (null != $v && \"null\" != $v) {\r\n                if ($urlEncode) {\r\n                    $v = urlencode($v);\r\n                }\r\n                $buff .= $k . \"=\" . $v . \"&\";\r\n            }\r\n        }\r\n        $reqPar = '';\r\n        if (strlen($buff) > 0) {\r\n            $reqPar = substr($buff, 0, strlen($buff) - 1);\r\n        }\r\n        return $reqPar;\r\n    }\r\n}\r\n"
        },
        {
          "name": "jsapi.php",
          "type": "blob",
          "size": 11.931640625,
          "content": "<?php\r\nheader('Content-type:text/html; Charset=utf-8');\r\n$mchid = 'xxxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\r\n$appid = 'xxxxx';  //微信支付申请对应的公众号的APPID\r\n$appKey = 'xxxxx';   //微信支付申请对应的公众号的APP Key\r\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n//①、获取用户openid\r\n$wxPay = new WxpayService($mchid,$appid,$appKey,$apiKey);\r\n$openId = $wxPay->GetOpenid();      //获取openid\r\nif(!$openId) exit('获取openid失败');\r\n//②、统一下单\r\n$outTradeNo = uniqid();     //你自己的商品订单号\r\n$payAmount = 0.01;          //付款金额，单位:元\r\n$orderName = '支付测试';    //订单标题\r\n$notifyUrl = 'https://www.xxx.com/wx/notify.php';     //付款成功后的回调地址(不要有问号)\r\n$payTime = time();      //付款时间\r\n$jsApiParameters = $wxPay->createJsBizPackage($openId,$payAmount,$outTradeNo,$orderName,$notifyUrl,$payTime);\r\n$jsApiParameters = json_encode($jsApiParameters);\r\n?>\r\n    <html>\r\n    <head>\r\n        <meta charset=\"utf-8\" />\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\r\n        <title>微信支付样例-支付</title>\r\n        <script type=\"text/javascript\">\r\n            //调用微信JS api 支付\r\n            function jsApiCall()\r\n            {\r\n                WeixinJSBridge.invoke(\r\n                    'getBrandWCPayRequest',\r\n                    <?php echo $jsApiParameters; ?>,\r\n                    function(res){\r\n                        WeixinJSBridge.log(res.err_msg);\r\n\t\t\t\t\t\tif(res.err_msg=='get_brand_wcpay_request:ok'){\r\n\t\t\t\t\t\t\talert('支付成功！');\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\talert('支付失败：'+res.err_code+res.err_desc+res.err_msg);\r\n\t\t\t\t\t\t}\r\n                    }\r\n                );\r\n            }\r\n            function callpay()\r\n            {\r\n                if (typeof WeixinJSBridge == \"undefined\"){\r\n                    if( document.addEventListener ){\r\n                        document.addEventListener('WeixinJSBridgeReady', jsApiCall, false);\r\n                    }else if (document.attachEvent){\r\n                        document.attachEvent('WeixinJSBridgeReady', jsApiCall);\r\n                        document.attachEvent('onWeixinJSBridgeReady', jsApiCall);\r\n                    }\r\n                }else{\r\n                    jsApiCall();\r\n                }\r\n            }\r\n        </script>\r\n    </head>\r\n    <body>\r\n    <br/>\r\n    <font color=\"#9ACD32\"><b>该笔订单支付金额为<span style=\"color:#f00;font-size:50px\"><?php echo $payAmount?>元</span>钱</b></font><br/><br/>\r\n    <div align=\"center\">\r\n        <button style=\"width:210px; height:50px; border-radius: 15px;background-color:#FE6714; border:0px #FE6714 solid; cursor: pointer;  color:white;  font-size:16px;\" type=\"button\" onclick=\"callpay()\" >立即支付</button>\r\n    </div>\r\n    </body>\r\n    </html>\r\n<?php\r\nclass WxpayService\r\n{\r\n    protected $mchid;\r\n    protected $appid;\r\n    protected $appKey;\r\n    protected $apiKey;\r\n    public $data = null;\r\n    public function __construct($mchid, $appid, $appKey,$key)\r\n    {\r\n        $this->mchid = $mchid; //https://pay.weixin.qq.com 产品中心-开发配置-商户号\r\n        $this->appid = $appid; //微信支付申请对应的公众号的APPID\r\n        $this->appKey = $appKey; //微信支付申请对应的公众号的APP Key\r\n        $this->apiKey = $key;   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n    }\r\n    /**\r\n     * 通过跳转获取用户的openid，跳转流程如下：\r\n     * 1、设置自己需要调回的url及其其他参数，跳转到微信服务器https://open.weixin.qq.com/connect/oauth2/authorize\r\n     * 2、微信服务处理完成之后会跳转回用户redirect_uri地址，此时会带上一些参数，如：code\r\n     * @return 用户的openid\r\n     */\r\n    public function GetOpenid()\r\n    {\r\n        //通过code获得openid\r\n        if (!isset($_GET['code'])){\r\n            //触发微信返回code码\r\n            $scheme = $_SERVER['HTTPS']=='on' ? 'https://' : 'http://';\r\n\t\t\t$uri = $_SERVER['PHP_SELF'].$_SERVER['QUERY_STRING'];\r\n\t\t\tif($_SERVER['REQUEST_URI']) $uri = $_SERVER['REQUEST_URI'];\r\n            $baseUrl = urlencode($scheme.$_SERVER['HTTP_HOST'].$uri);\r\n            $url = $this->__CreateOauthUrlForCode($baseUrl);\r\n            Header(\"Location: $url\");\r\n            exit();\r\n        } else {\r\n            //获取code码，以获取openid\r\n            $code = $_GET['code'];\r\n            $openid = $this->getOpenidFromMp($code);\r\n            return $openid;\r\n        }\r\n    }\r\n    /**\r\n     * 通过code从工作平台获取openid机器access_token\r\n     * @param string $code 微信跳转回来带上的code\r\n     * @return openid\r\n     */\r\n    public function GetOpenidFromMp($code)\r\n    {\r\n        $url = $this->__CreateOauthUrlForOpenid($code);\r\n        $res = self::curlGet($url);\r\n        //取出openid\r\n        $data = json_decode($res,true);\r\n        $this->data = $data;\r\n        $openid = $data['openid'];\r\n        return $openid;\r\n    }\r\n    /**\r\n     * 构造获取open和access_toke的url地址\r\n     * @param string $code，微信跳转带回的code\r\n     * @return 请求的url\r\n     */\r\n    private function __CreateOauthUrlForOpenid($code)\r\n    {\r\n        $urlObj[\"appid\"] = $this->appid;\r\n        $urlObj[\"secret\"] = $this->appKey;\r\n        $urlObj[\"code\"] = $code;\r\n        $urlObj[\"grant_type\"] = \"authorization_code\";\r\n        $bizString = $this->ToUrlParams($urlObj);\r\n        return \"https://api.weixin.qq.com/sns/oauth2/access_token?\".$bizString;\r\n    }\r\n    /**\r\n     * 构造获取code的url连接\r\n     * @param string $redirectUrl 微信服务器回跳的url，需要url编码\r\n     * @return 返回构造好的url\r\n     */\r\n    private function __CreateOauthUrlForCode($redirectUrl)\r\n    {\r\n        $urlObj[\"appid\"] = $this->appid;\r\n        $urlObj[\"redirect_uri\"] = \"$redirectUrl\";\r\n        $urlObj[\"response_type\"] = \"code\";\r\n        $urlObj[\"scope\"] = \"snsapi_base\";\r\n        $urlObj[\"state\"] = \"STATE\".\"#wechat_redirect\";\r\n        $bizString = $this->ToUrlParams($urlObj);\r\n        return \"https://open.weixin.qq.com/connect/oauth2/authorize?\".$bizString;\r\n    }\r\n    /**\r\n     * 拼接签名字符串\r\n     * @param array $urlObj\r\n     * @return 返回已经拼接好的字符串\r\n     */\r\n    private function ToUrlParams($urlObj)\r\n    {\r\n        $buff = \"\";\r\n        foreach ($urlObj as $k => $v)\r\n        {\r\n            if($k != \"sign\") $buff .= $k . \"=\" . $v . \"&\";\r\n        }\r\n        $buff = trim($buff, \"&\");\r\n        return $buff;\r\n    }\r\n    /**\r\n     * 统一下单\r\n     * @param string $openid 调用【网页授权获取用户信息】接口获取到用户在该公众号下的Openid\r\n     * @param float $totalFee 收款总费用 单位元\r\n     * @param string $outTradeNo 唯一的订单号\r\n     * @param string $orderName 订单名称\r\n     * @param string $notifyUrl 支付结果通知url 不要有问号\r\n     * @param string $timestamp 支付时间\r\n     * @return string\r\n     */\r\n    public function createJsBizPackage($openid, $totalFee, $outTradeNo, $orderName, $notifyUrl, $timestamp)\r\n    {\r\n        $config = array(\r\n            'mch_id' => $this->mchid,\r\n            'appid' => $this->appid,\r\n            'key' => $this->apiKey,\r\n        );\r\n        //$orderName = iconv('GBK','UTF-8',$orderName);\r\n        $unified = array(\r\n            'appid' => $config['appid'],\r\n            'attach' => 'pay',             //商家数据包，原样返回，如果填写中文，请注意转换为utf-8\r\n            'body' => $orderName,\r\n            'mch_id' => $config['mch_id'],\r\n            'nonce_str' => self::createNonceStr(),\r\n            'notify_url' => $notifyUrl,\r\n            'openid' => $openid,            //rade_type=JSAPI，此参数必传\r\n            'out_trade_no' => $outTradeNo,\r\n            'spbill_create_ip' => '127.0.0.1',\r\n            'total_fee' => floatval($totalFee) * 100,       //单位 转为分\r\n            'trade_type' => 'JSAPI',\r\n        );\r\n        $unified['sign'] = self::getSign($unified, $config['key']);\r\n        $responseXml = self::curlPost('https://api.mch.weixin.qq.com/pay/unifiedorder', self::arrayToXml($unified));\r\n\t\t//禁止引用外部xml实体\r\n\t\tlibxml_disable_entity_loader(true);\t    \r\n        $unifiedOrder = simplexml_load_string($responseXml, 'SimpleXMLElement', LIBXML_NOCDATA);\r\n        if ($unifiedOrder === false) {\r\n            die('parse xml error');\r\n        }\r\n        if ($unifiedOrder->return_code != 'SUCCESS') {\r\n            die($unifiedOrder->return_msg);\r\n        }\r\n        if ($unifiedOrder->result_code != 'SUCCESS') {\r\n            die($unifiedOrder->err_code);\r\n        }\r\n        $arr = array(\r\n            \"appId\" => $config['appid'],\r\n            \"timeStamp\" => \"$timestamp\",        //这里是字符串的时间戳，不是int，所以需加引号\r\n            \"nonceStr\" => self::createNonceStr(),\r\n            \"package\" => \"prepay_id=\" . $unifiedOrder->prepay_id,\r\n            \"signType\" => 'MD5',\r\n        );\r\n        $arr['paySign'] = self::getSign($arr, $config['key']);\r\n        return $arr;\r\n    }\r\n    public static function curlGet($url = '', $options = array())\r\n    {\r\n        $ch = curl_init($url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n    public static function curlPost($url = '', $postData = '', $options = array())\r\n    {\r\n        if (is_array($postData)) {\r\n            $postData = http_build_query($postData);\r\n        }\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_URL, $url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_POST, 1);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n    public static function createNonceStr($length = 16)\r\n    {\r\n        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        $str = '';\r\n        for ($i = 0; $i < $length; $i++) {\r\n            $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\r\n        }\r\n        return $str;\r\n    }\r\n    public static function arrayToXml($arr)\r\n    {\r\n        $xml = \"<xml>\";\r\n        foreach ($arr as $key => $val) {\r\n            if (is_numeric($val)) {\r\n                $xml .= \"<\" . $key . \">\" . $val . \"</\" . $key . \">\";\r\n            } else\r\n                $xml .= \"<\" . $key . \"><![CDATA[\" . $val . \"]]></\" . $key . \">\";\r\n        }\r\n        $xml .= \"</xml>\";\r\n        return $xml;\r\n    }\r\n    public static function getSign($params, $key)\r\n    {\r\n        ksort($params, SORT_STRING);\r\n        $unSignParaString = self::formatQueryParaMap($params, false);\r\n        $signStr = strtoupper(md5($unSignParaString . \"&key=\" . $key));\r\n        return $signStr;\r\n    }\r\n    protected static function formatQueryParaMap($paraMap, $urlEncode = false)\r\n    {\r\n        $buff = \"\";\r\n        ksort($paraMap);\r\n        foreach ($paraMap as $k => $v) {\r\n            if (null != $v && \"null\" != $v) {\r\n                if ($urlEncode) {\r\n                    $v = urlencode($v);\r\n                }\r\n                $buff .= $k . \"=\" . $v . \"&\";\r\n            }\r\n        }\r\n        $reqPar = '';\r\n        if (strlen($buff) > 0) {\r\n            $reqPar = substr($buff, 0, strlen($buff) - 1);\r\n        }\r\n        return $reqPar;\r\n    }\r\n}\r\n"
        },
        {
          "name": "jsapi_v3.php",
          "type": "blob",
          "size": 13.9052734375,
          "content": "<?php\r\nheader('Content-type:text/html; Charset=utf-8');\r\n/** 请填写以下配置信息 */\r\n$mchid = 'xxxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\r\n$appid = 'xxxxx';  //公众号APPID 通过微信支付商户资料审核后邮件发送\r\n$appKey = 'xxxxx';  //微信支付申请对应的公众号的APP Key\r\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户中心-安全中心-API安全-APIv3密钥-设置密钥\r\n$privateKeyPath = getcwd() . '/cert/apiclient_key.pem';       //apiclient_key.pem的路径，通过”微信支付商户平台证书工具“生成。https://kf.qq.com/faq/161222NneAJf161222U7fARv.html\r\n$serialNumber = 'xxxxx'; //证书序列号 https://pay.weixin.qq.com 帐户中心-安全中心-API安全-API证书-查看证书\r\n$outTradeNo = uniqid();     //你自己的商品订单号，最小字符长度为6\r\n$payAmount = 0.01;          //付款金额，单位:元\r\n$orderName = '支付测试';    //订单标题\r\n$notifyUrl = 'https://www.xxx.com/notify_v3.php';     //付款成功后的回调地址(不要有问号)\r\n/** 配置结束 */\r\n\r\n//①、获取用户openid\r\n$wxPay = new WxpayService($mchid, $appid, $appKey,$apiKey,$privateKeyPath,$serialNumber);\r\n$openId = $wxPay->GetOpenid();      //获取openid\r\nif(!$openId) exit('获取openid失败');\r\n//②、统一下单\r\n$wxPay->setOrderName($orderName);\r\n$wxPay->setOutTradeNo($outTradeNo);\r\n$wxPay->setTotalFee($payAmount);\r\n$wxPay->setNotifyUrl($notifyUrl);\r\n$wxPay->setOpenid($openId);\r\n$result = $wxPay->doPay();\r\n$jsApiParameters = json_encode($result);\r\n?>\r\n    <html>\r\n    <head>\r\n        <meta charset=\"utf-8\" />\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\r\n        <title>微信支付样例-支付</title>\r\n        <script type=\"text/javascript\">\r\n            //调用微信JS api 支付\r\n            function jsApiCall()\r\n            {\r\n                WeixinJSBridge.invoke(\r\n                    'getBrandWCPayRequest',\r\n                    <?php echo $jsApiParameters; ?>,\r\n                    function(res){\r\n                        WeixinJSBridge.log(res.err_msg);\r\n\t\t\t\t\t\tif(res.err_msg=='get_brand_wcpay_request:ok'){\r\n\t\t\t\t\t\t\talert('支付成功！');\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\talert('支付失败：'+res.err_code+res.err_desc+res.err_msg);\r\n\t\t\t\t\t\t}\r\n                    }\r\n                );\r\n            }\r\n            function callpay()\r\n            {\r\n                if (typeof WeixinJSBridge == \"undefined\"){\r\n                    if( document.addEventListener ){\r\n                        document.addEventListener('WeixinJSBridgeReady', jsApiCall, false);\r\n                    }else if (document.attachEvent){\r\n                        document.attachEvent('WeixinJSBridgeReady', jsApiCall);\r\n                        document.attachEvent('onWeixinJSBridgeReady', jsApiCall);\r\n                    }\r\n                }else{\r\n                    jsApiCall();\r\n                }\r\n            }\r\n        </script>\r\n    </head>\r\n    <body>\r\n    <br/>\r\n    <font color=\"#9ACD32\"><b>该笔订单支付金额为<span style=\"color:#f00;font-size:50px\"><?php echo $payAmount?>元</span>钱</b></font><br/><br/>\r\n    <div align=\"center\">\r\n        <button style=\"width:210px; height:50px; border-radius: 15px;background-color:#FE6714; border:0px #FE6714 solid; cursor: pointer;  color:white;  font-size:16px;\" type=\"button\" onclick=\"callpay()\" >立即支付</button>\r\n    </div>\r\n    </body>\r\n    </html>\r\n<?php\r\n\r\nclass WxpayService\r\n{\r\n    protected $mchid;\r\n    protected $appid;\r\n    protected $apiKey;\r\n    protected $appKey;\r\n    protected $privateKeyPath;\r\n    protected $serialNumber;\r\n    protected $totalFee;\r\n    protected $outTradeNo;\r\n    protected $orderName;\r\n    protected $notifyUrl;\r\n    protected $auth;\r\n    protected $openid;\r\n    protected $gateWay='https://api.mch.weixin.qq.com/v3';\r\n\r\n    public function __construct($mchid, $appid, $appkey,$apikey, $privateKeyPath, $serialNumber)\r\n    {\r\n        $this->mchid = $mchid;\r\n        $this->appid = $appid;\r\n        $this->apiKey = $apikey;\r\n        $this->appKey = $appkey;\r\n        $this->privateKeyPath = $privateKeyPath;\r\n        $this->serialNumber = $serialNumber;\r\n    }\r\n\r\n    public function setTotalFee($totalFee)\r\n    {\r\n        $this->totalFee = floatval($totalFee);\r\n    }\r\n\r\n    public function setOutTradeNo($outTradeNo)\r\n    {\r\n        $this->outTradeNo = $outTradeNo;\r\n    }\r\n\r\n    public function setOrderName($orderName)\r\n    {\r\n        $this->orderName = $orderName;\r\n    }\r\n\r\n    public function setNotifyUrl($notifyUrl)\r\n    {\r\n        $this->notifyUrl = $notifyUrl;\r\n    }\r\n\r\n    public function setOpenid($openid)\r\n    {\r\n        $this->openid = $openid;\r\n    }\r\n\r\n    /**\r\n     * 发起支付\r\n     */\r\n    public function doPay()\r\n    {\r\n        $reqParams = array(\r\n            'appid' => $this->appid,        //公众号或移动应用appid\r\n            'mchid' => $this->mchid,        //商户号\r\n            'description' => $this->orderName,     //商品描述\r\n            'attach' => 'pay',              //附加数据，在查询API和支付通知中原样返回，可作为自定义参数使用\r\n            'notify_url' => $this->notifyUrl,       //通知URL必须为直接可访问的URL，不允许携带查询串。\r\n            'out_trade_no' => $this->outTradeNo,      //商户系统内部订单号，只能是数字、大小写字母_-*且在同一个商户号下唯一，详见【商户订单号】。特殊规则：最小字符长度为6\r\n            'amount'=>array(\r\n                'total'=>intval($this->totalFee * 100), //订单总金额，单位为分\r\n                'currency'=>'CNY', //CNY：人民币，境内商户号仅支持人民币\r\n            ),\r\n            'scene_info'=>array(        //支付场景描述\r\n                'payer_client_ip'=>'127.0.0.1'   //调用微信支付API的机器IP\r\n            ),\r\n            'payer'=>array(        //支付场景描述\r\n                'openid'=>$this->openid   //调用微信支付API的机器IP\r\n            )\r\n        );\r\n        $reqUrl = $this->gateWay.'/pay/transactions/jsapi';\r\n        $this->getAuthStr($reqUrl,$reqParams);\r\n        $response = $this->curlPost($reqUrl,$reqParams);\r\n        $response = json_decode($response,true);\r\n\r\n        if(isset($response['code'])){\r\n            echo $response['code'].':'.$response['message'];exit();\r\n        }\r\n        $timestamp = time();\r\n        $arr = array(\r\n            \"appId\" => $this->appid,\r\n            \"timeStamp\" => \"$timestamp\",        //这里是字符串的时间戳，不是int，所以需加引号\r\n            \"nonceStr\" => $this->getNonce(),\r\n            \"package\" => \"prepay_id=\" . $response['prepay_id'],\r\n            \"signType\" => 'RSA',\r\n        );\r\n        $message = $this->appid . \"\\n\" .\r\n            $timestamp . \"\\n\" .\r\n            $arr['nonceStr'] . \"\\n\" .\r\n            \"prepay_id=\" . $response['prepay_id'] . \"\\n\";\r\n        $arr['paySign'] = $this->sign($message, 'RSA');\r\n        return $arr;\r\n    }\r\n\r\n    private function sign($message,$signType='sha256WithRSAEncryption')\r\n    {\r\n        $res = file_get_contents($this->privateKeyPath);\r\n        if($signType=='RSA'){\r\n            $result = openssl_sign($message, $sign, $res,version_compare(PHP_VERSION,'5.4.0', '<') ? SHA256 : OPENSSL_ALGO_SHA256);\r\n        }else{\r\n            if (!in_array('sha256WithRSAEncryption', openssl_get_md_methods(true))) {\r\n                throw new \\RuntimeException(\"当前PHP环境不支持SHA256withRSA\");\r\n            }\r\n            $result = openssl_sign($message, $sign, $res, 'sha256WithRSAEncryption');\r\n        }\r\n        if (!$result) {\r\n            throw new \\UnexpectedValueException(\"签名验证过程发生了错误\");\r\n        }\r\n        return base64_encode($sign);\r\n    }\r\n\r\n    public function curlPost($url = '', $postData = array(), $options = array())\r\n    {\r\n        if (is_array($postData)) {\r\n            $postData = json_encode($postData);\r\n        }\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_URL, $url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_POST, 1);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\r\n        curl_setopt($ch, CURLOPT_HTTPHEADER, array(\r\n            'Authorization:'.$this->auth,\r\n            'Content-Type:application/json',\r\n            'Accept:application/json',\r\n            'User-Agent:'.$_SERVER['HTTP_USER_AGENT']\r\n        ));\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n\r\n    private function getSchema()\r\n    {\r\n        return 'WECHATPAY2-SHA256-RSA2048';\r\n    }\r\n\r\n    public function getAuthStr($requestUrl,$reqParams=array())\r\n    {\r\n        $schema = $this->getSchema();\r\n        $token = $this->getToken($requestUrl,$reqParams);\r\n        $this->auth = $schema.' '.$token;\r\n        return $this->auth;\r\n    }\r\n\r\n    private function getNonce()\r\n    {\r\n        static $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n        $charactersLength = strlen($characters);\r\n        $randomString = '';\r\n        for ($i = 0; $i < 32; $i++) {\r\n            $randomString .= $characters[rand(0, $charactersLength - 1)];\r\n        }\r\n        return $randomString;\r\n    }\r\n\r\n    public function getToken($requestUrl,$reqParams=array())\r\n    {\r\n        $body = $reqParams ?  json_encode($reqParams) : '';\r\n        $nonce = $this->getNonce();\r\n        $timestamp = time();\r\n        $message = $this->buildMessage($nonce, $timestamp, $requestUrl,$body);\r\n        $sign = $this->sign($message);\r\n        $serialNo = $this->serialNumber;\r\n        return sprintf('mchid=\"%s\",nonce_str=\"%s\",timestamp=\"%d\",serial_no=\"%s\",signature=\"%s\"',\r\n            $this->mchid, $nonce, $timestamp, $serialNo, $sign\r\n        );\r\n    }\r\n\r\n    private function buildMessage($nonce, $timestamp, $requestUrl, $body = '')\r\n    {\r\n        $method = 'POST';\r\n        $urlParts = parse_url($requestUrl);\r\n        $canonicalUrl = ($urlParts['path'] . (!empty($urlParts['query']) ? \"?{$urlParts['query']}\" : \"\"));\r\n        return strtoupper($method) . \"\\n\" .\r\n            $canonicalUrl . \"\\n\" .\r\n            $timestamp . \"\\n\" .\r\n            $nonce . \"\\n\" .\r\n            $body . \"\\n\";\r\n    }\r\n\r\n    /**\r\n     * 通过跳转获取用户的openid，跳转流程如下：\r\n     * 1、设置自己需要调回的url及其其他参数，跳转到微信服务器https://open.weixin.qq.com/connect/oauth2/authorize\r\n     * 2、微信服务处理完成之后会跳转回用户redirect_uri地址，此时会带上一些参数，如：code\r\n     * @return 用户的openid\r\n     */\r\n    public function GetOpenid()\r\n    {\r\n        //通过code获得openid\r\n        if (!isset($_GET['code'])){\r\n            //触发微信返回code码\r\n            $scheme = $_SERVER['HTTPS']=='on' ? 'https://' : 'http://';\r\n            $baseUrl = urlencode($scheme.$_SERVER['HTTP_HOST'].$_SERVER['PHP_SELF'].$_SERVER['QUERY_STRING']);\r\n            $url = $this->__CreateOauthUrlForCode($baseUrl);\r\n            Header(\"Location: $url\");\r\n            exit();\r\n        } else {\r\n            //获取code码，以获取openid\r\n            $code = $_GET['code'];\r\n            $openid = $this->getOpenidFromMp($code);\r\n            return $openid;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 构造获取code的url连接\r\n     * @param string $redirectUrl 微信服务器回跳的url，需要url编码\r\n     * @return 返回构造好的url\r\n     */\r\n    private function __CreateOauthUrlForCode($redirectUrl)\r\n    {\r\n        $urlObj[\"appid\"] = $this->appid;\r\n        $urlObj[\"redirect_uri\"] = \"$redirectUrl\";\r\n        $urlObj[\"response_type\"] = \"code\";\r\n        $urlObj[\"scope\"] = \"snsapi_base\";\r\n        $urlObj[\"state\"] = \"STATE\".\"#wechat_redirect\";\r\n        $bizString = $this->ToUrlParams($urlObj);\r\n        return \"https://open.weixin.qq.com/connect/oauth2/authorize?\".$bizString;\r\n    }\r\n\r\n    /**\r\n     * 通过code从工作平台获取openid机器access_token\r\n     * @param string $code 微信跳转回来带上的code\r\n     * @return openid\r\n     */\r\n    public function GetOpenidFromMp($code)\r\n    {\r\n        $url = $this->__CreateOauthUrlForOpenid($code);\r\n        $res = self::curlGet($url);\r\n        //取出openid\r\n        $data = json_decode($res,true);\r\n//        $this->data = $data;\r\n        $openid = $data['openid'];\r\n        return $openid;\r\n    }\r\n\r\n    public static function curlGet($url = '', $options = array())\r\n    {\r\n        $ch = curl_init($url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n\r\n    /**\r\n     * 构造获取open和access_toke的url地址\r\n     * @param string $code，微信跳转带回的code\r\n     * @return 请求的url\r\n     */\r\n    private function __CreateOauthUrlForOpenid($code)\r\n    {\r\n        $urlObj[\"appid\"] = $this->appid;\r\n        $urlObj[\"secret\"] = $this->appKey;\r\n        $urlObj[\"code\"] = $code;\r\n        $urlObj[\"grant_type\"] = \"authorization_code\";\r\n        $bizString = $this->ToUrlParams($urlObj);\r\n        return \"https://api.weixin.qq.com/sns/oauth2/access_token?\".$bizString;\r\n    }\r\n\r\n    /**\r\n     * 拼接签名字符串\r\n     * @param array $urlObj\r\n     * @return 返回已经拼接好的字符串\r\n     */\r\n    private function ToUrlParams($urlObj)\r\n    {\r\n        $buff = \"\";\r\n        foreach ($urlObj as $k => $v)\r\n        {\r\n            if($k != \"sign\") $buff .= $k . \"=\" . $v . \"&\";\r\n        }\r\n        $buff = trim($buff, \"&\");\r\n        return $buff;\r\n    }\r\n}"
        },
        {
          "name": "native.php",
          "type": "blob",
          "size": 7.5439453125,
          "content": "<?php\r\nheader('Content-type:text/html; Charset=utf-8');\r\n$mchid = 'xxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\r\n$appid = 'xxxx';  //公众号APPID 通过微信支付商户资料审核后邮件发送\r\n$apiKey = 'xxxx';   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n$wxPay = new WxpayService($mchid,$appid,$apiKey);\r\n$outTradeNo = uniqid();     //你自己的商品订单号\r\n$payAmount = 0.01;          //付款金额，单位:元\r\n$orderName = '支付测试';    //订单标题\r\n$notifyUrl = 'https://www.xxx.com/wx/notify.php';     //付款成功后的回调地址(不要有问号)\r\n$payTime = time();      //付款时间\r\n$arr = $wxPay->createJsBizPackage($payAmount,$outTradeNo,$orderName,$notifyUrl,$payTime);\r\n//生成二维码\r\n$url = 'https://wenhairu.com/static/api/qr/?size=300&text='.$arr['code_url'];\r\necho \"<img src='{$url}' style='width:300px;'><br>\";\r\necho '二维码内容：'.$arr['code_url'];\r\nclass WxpayService\r\n{\r\n    protected $mchid;\r\n    protected $appid;\r\n    protected $apiKey;\r\n    public function __construct($mchid, $appid, $key)\r\n    {\r\n        $this->mchid = $mchid;\r\n        $this->appid = $appid;\r\n        $this->apiKey = $key;\r\n    }\r\n    /**\r\n     * 发起订单\r\n     * @param float $totalFee 收款总费用 单位元\r\n     * @param string $outTradeNo 唯一的订单号\r\n     * @param string $orderName 订单名称\r\n     * @param string $notifyUrl 支付结果通知url 不要有问号\r\n     * @param string $timestamp 订单发起时间\r\n     * @return array\r\n     */\r\n    public function createJsBizPackage($totalFee, $outTradeNo, $orderName, $notifyUrl, $timestamp)\r\n    {\r\n        $config = array(\r\n            'mch_id' => $this->mchid,\r\n            'appid' => $this->appid,\r\n            'key' => $this->apiKey,\r\n        );\r\n        //$orderName = iconv('GBK','UTF-8',$orderName);\r\n        $unified = array(\r\n            'appid' => $config['appid'],\r\n            'attach' => 'pay',             //商家数据包，原样返回，如果填写中文，请注意转换为utf-8\r\n            'body' => $orderName,\r\n            'mch_id' => $config['mch_id'],\r\n            'nonce_str' => self::createNonceStr(),\r\n            'notify_url' => $notifyUrl,\r\n            'out_trade_no' => $outTradeNo,\r\n            'spbill_create_ip' => '127.0.0.1',\r\n            'total_fee' => floatval($totalFee) * 100,       //单位 转为分\r\n            'trade_type' => 'NATIVE',\r\n        );\r\n        $unified['sign'] = self::getSign($unified, $config['key']);\r\n        $responseXml = self::curlPost('https://api.mch.weixin.qq.com/pay/unifiedorder', self::arrayToXml($unified));\r\n\t\t//禁止引用外部xml实体\r\n\t\tlibxml_disable_entity_loader(true);        \r\n        $unifiedOrder = simplexml_load_string($responseXml, 'SimpleXMLElement', LIBXML_NOCDATA);\r\n        if ($unifiedOrder === false) {\r\n            die('parse xml error');\r\n        }\r\n        if ($unifiedOrder->return_code != 'SUCCESS') {\r\n            die($unifiedOrder->return_msg);\r\n        }\r\n        if ($unifiedOrder->result_code != 'SUCCESS') {\r\n            die($unifiedOrder->err_code);\r\n        }\r\n        $codeUrl = (array)($unifiedOrder->code_url);\r\n        if(!$codeUrl[0]) exit('get code_url error');\r\n        $arr = array(\r\n            \"appId\" => $config['appid'],\r\n            \"timeStamp\" => $timestamp,\r\n            \"nonceStr\" => self::createNonceStr(),\r\n            \"package\" => \"prepay_id=\" . $unifiedOrder->prepay_id,\r\n            \"signType\" => 'MD5',\r\n            \"code_url\" => $codeUrl[0],\r\n        );\r\n        $arr['paySign'] = self::getSign($arr, $config['key']);\r\n        return $arr;\r\n    }\r\n    public function notify()\r\n    {\r\n        $config = array(\r\n            'mch_id' => $this->mchid,\r\n            'appid' => $this->appid,\r\n            'key' => $this->apiKey,\r\n        );\r\n        $postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"];\r\n        $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);\r\n        if ($postObj === false) {\r\n            die('parse xml error');\r\n        }\r\n        if ($postObj->return_code != 'SUCCESS') {\r\n            die($postObj->return_msg);\r\n        }\r\n        if ($postObj->result_code != 'SUCCESS') {\r\n            die($postObj->err_code);\r\n        }\r\n        $arr = (array)$postObj;\r\n        unset($arr['sign']);\r\n        if (self::getSign($arr, $config['key']) == $postObj->sign) {\r\n            echo '<xml><return_code><![CDATA[SUCCESS]]></return_code><return_msg><![CDATA[OK]]></return_msg></xml>';\r\n            return $postObj;\r\n        }\r\n    }\r\n    /**\r\n     * curl get\r\n     *\r\n     * @param string $url\r\n     * @param array $options\r\n     * @return mixed\r\n     */\r\n    public static function curlGet($url = '', $options = array())\r\n    {\r\n        $ch = curl_init($url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n    public static function curlPost($url = '', $postData = '', $options = array())\r\n    {\r\n        if (is_array($postData)) {\r\n            $postData = http_build_query($postData);\r\n        }\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_URL, $url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_POST, 1);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n    public static function createNonceStr($length = 16)\r\n    {\r\n        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        $str = '';\r\n        for ($i = 0; $i < $length; $i++) {\r\n            $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\r\n        }\r\n        return $str;\r\n    }\r\n    public static function arrayToXml($arr)\r\n    {\r\n        $xml = \"<xml>\";\r\n        foreach ($arr as $key => $val) {\r\n            if (is_numeric($val)) {\r\n                $xml .= \"<\" . $key . \">\" . $val . \"</\" . $key . \">\";\r\n            } else\r\n                $xml .= \"<\" . $key . \"><![CDATA[\" . $val . \"]]></\" . $key . \">\";\r\n        }\r\n        $xml .= \"</xml>\";\r\n        return $xml;\r\n    }\r\n    /**\r\n     * 获取签名\r\n     */\r\n    public static function getSign($params, $key)\r\n    {\r\n        ksort($params, SORT_STRING);\r\n        $unSignParaString = self::formatQueryParaMap($params, false);\r\n        $signStr = strtoupper(md5($unSignParaString . \"&key=\" . $key));\r\n        return $signStr;\r\n    }\r\n    protected static function formatQueryParaMap($paraMap, $urlEncode = false)\r\n    {\r\n        $buff = \"\";\r\n        ksort($paraMap);\r\n        foreach ($paraMap as $k => $v) {\r\n            if (null != $v && \"null\" != $v) {\r\n                if ($urlEncode) {\r\n                    $v = urlencode($v);\r\n                }\r\n                $buff .= $k . \"=\" . $v . \"&\";\r\n            }\r\n        }\r\n        $reqPar = '';\r\n        if (strlen($buff) > 0) {\r\n            $reqPar = substr($buff, 0, strlen($buff) - 1);\r\n        }\r\n        return $reqPar;\r\n    }\r\n}\r\n"
        },
        {
          "name": "native_v3.php",
          "type": "blob",
          "size": 7.234375,
          "content": "<?php\r\nheader('Content-type:text/html; Charset=utf-8');\r\n/** 请填写以下配置信息 */\r\n$mchid = 'xxxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\r\n$appid = 'xxxxx';  //公众号APPID 通过微信支付商户资料审核后邮件发送\r\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户中心-安全中心-API安全-APIv3密钥-设置密钥\r\n$privateKeyPath = getcwd() . '/cert/apiclient_key.pem';       //apiclient_key.pem的路径，通过”微信支付商户平台证书工具“生成。https://kf.qq.com/faq/161222NneAJf161222U7fARv.html\r\n$serialNumber = 'xxxxx'; //证书序列号 https://pay.weixin.qq.com 帐户中心-安全中心-API安全-API证书-查看证书\r\n$outTradeNo = uniqid();     //你自己的商品订单号，最小字符长度为6\r\n$payAmount = 0.01;          //付款金额，单位:元\r\n$orderName = '支付测试';    //订单标题\r\n$notifyUrl = 'https://www.xxx.com/wx/notify.php';     //付款成功后的回调地址(不要有问号)\r\n/** 配置结束 */\r\n\r\n$wxPay = new WxpayService($mchid, $appid, $apiKey,$privateKeyPath,$serialNumber);\r\n$wxPay->setTotalFee($payAmount);\r\n$wxPay->setOutTradeNo($outTradeNo);\r\n$wxPay->setOrderName($orderName);\r\n$wxPay->setNotifyUrl($notifyUrl);\r\n$result = $wxPay->doPay();\r\nif(isset($result['code'])){\r\n    echo $result['code'].':'.$result['message'];exit();\r\n}\r\n//生成二维码\r\n$url = 'https://wenhairu.com/static/api/qr/?size=300&text=' . $result['code_url'];\r\necho \"<img src='{$url}' style='width:300px;'><br>\";\r\necho '二维码内容：' . $result['code_url'];\r\n\r\nclass WxpayService\r\n{\r\n    protected $mchid;\r\n    protected $appid;\r\n    protected $apiKey;\r\n    protected $privateKeyPath;\r\n    protected $serialNumber;\r\n    protected $totalFee;\r\n    protected $outTradeNo;\r\n    protected $orderName;\r\n    protected $notifyUrl;\r\n    protected $auth;\r\n    protected $gateWay='https://api.mch.weixin.qq.com/v3';\r\n\r\n    public function __construct($mchid, $appid, $apikey, $privateKeyPath, $serialNumber)\r\n    {\r\n        $this->mchid = $mchid;\r\n        $this->appid = $appid;\r\n        $this->apiKey = $apikey;\r\n        $this->privateKeyPath = $privateKeyPath;\r\n        $this->serialNumber = $serialNumber;\r\n    }\r\n\r\n    public function setTotalFee($totalFee)\r\n    {\r\n        $this->totalFee = floatval($totalFee);\r\n    }\r\n\r\n    public function setOutTradeNo($outTradeNo)\r\n    {\r\n        $this->outTradeNo = $outTradeNo;\r\n    }\r\n\r\n    public function setOrderName($orderName)\r\n    {\r\n        $this->orderName = $orderName;\r\n    }\r\n\r\n    public function setNotifyUrl($notifyUrl)\r\n    {\r\n        $this->notifyUrl = $notifyUrl;\r\n    }\r\n\r\n    /**\r\n     * 发起支付\r\n     */\r\n    public function doPay()\r\n    {\r\n        $reqParams = array(\r\n            'appid' => $this->appid,        //公众号或移动应用appid\r\n            'mchid' => $this->mchid,        //商户号\r\n            'description' => $this->orderName,     //商品描述\r\n            'attach' => 'pay',              //附加数据，在查询API和支付通知中原样返回，可作为自定义参数使用\r\n            'notify_url' => $this->notifyUrl,       //通知URL必须为直接可访问的URL，不允许携带查询串。\r\n            'out_trade_no' => $this->outTradeNo,      //商户系统内部订单号，只能是数字、大小写字母_-*且在同一个商户号下唯一，详见【商户订单号】。特殊规则：最小字符长度为6\r\n            'amount'=>array(\r\n                'total'=> floatval($this->totalFee) * 100, //订单总金额，单位为分\r\n                'currency'=> 'CNY', //CNY：人民币，境内商户号仅支持人民币\r\n            ),\r\n            'scene_info'=>array(        //支付场景描述\r\n                'payer_client_ip'=>'127.0.0.1'   //调用微信支付API的机器IP\r\n            )\r\n        );\r\n        $reqUrl = $this->gateWay.'/pay/transactions/native';\r\n        $this->getAuthStr($reqUrl,$reqParams);\r\n        $response = $this->curlPost($reqUrl,$reqParams);\r\n        return json_decode($response,true);\r\n\r\n    }\r\n\r\n    public function curlPost($url = '', $postData = array(), $options = array())\r\n    {\r\n        if (is_array($postData)) {\r\n            $postData = json_encode($postData);\r\n        }\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_URL, $url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_POST, 1);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\r\n        curl_setopt($ch, CURLOPT_HTTPHEADER, array(\r\n            'Authorization:'.$this->auth,\r\n            'Content-Type:application/json',\r\n            'Accept:application/json',\r\n            'User-Agent:'.$_SERVER['HTTP_USER_AGENT']\r\n        ));\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n\r\n    private function getSchema()\r\n    {\r\n        return 'WECHATPAY2-SHA256-RSA2048';\r\n    }\r\n\r\n    public function getAuthStr($requestUrl,$reqParams=array())\r\n    {\r\n        $schema = $this->getSchema();\r\n        $token = $this->getToken($requestUrl,$reqParams);\r\n        $this->auth = $schema.' '.$token;\r\n        return $this->auth;\r\n    }\r\n\r\n    private function getNonce()\r\n    {\r\n        static $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n        $charactersLength = strlen($characters);\r\n        $randomString = '';\r\n        for ($i = 0; $i < 32; $i++) {\r\n            $randomString .= $characters[rand(0, $charactersLength - 1)];\r\n        }\r\n        return $randomString;\r\n    }\r\n\r\n    public function getToken($requestUrl,$reqParams=array())\r\n    {\r\n        $body = $reqParams ?  json_encode($reqParams) : '';\r\n        $nonce = $this->getNonce();\r\n        $timestamp = time();\r\n        $message = $this->buildMessage($nonce, $timestamp, $requestUrl,$body);\r\n        $sign = $this->sign($message);\r\n        $serialNo = $this->serialNumber;\r\n        return sprintf('mchid=\"%s\",nonce_str=\"%s\",timestamp=\"%d\",serial_no=\"%s\",signature=\"%s\"',\r\n            $this->mchid, $nonce, $timestamp, $serialNo, $sign\r\n        );\r\n    }\r\n\r\n    private function buildMessage($nonce, $timestamp, $requestUrl, $body = '')\r\n    {\r\n        $method = 'POST';\r\n        $urlParts = parse_url($requestUrl);\r\n        $canonicalUrl = ($urlParts['path'] . (!empty($urlParts['query']) ? \"?{$urlParts['query']}\" : \"\"));\r\n        return strtoupper($method) . \"\\n\" .\r\n            $canonicalUrl . \"\\n\" .\r\n            $timestamp . \"\\n\" .\r\n            $nonce . \"\\n\" .\r\n            $body . \"\\n\";\r\n    }\r\n\r\n    private function sign($message)\r\n    {\r\n        if (!in_array('sha256WithRSAEncryption', openssl_get_md_methods(true))) {\r\n            throw new \\RuntimeException(\"当前PHP环境不支持SHA256withRSA\");\r\n        }\r\n        $res = file_get_contents($this->privateKeyPath);\r\n        if (!openssl_sign($message, $sign, $res, 'sha256WithRSAEncryption')) {\r\n            throw new \\UnexpectedValueException(\"签名验证过程发生了错误\");\r\n        }\r\n        return base64_encode($sign);\r\n    }\r\n}\r\n"
        },
        {
          "name": "notify.php",
          "type": "blob",
          "size": 3.4912109375,
          "content": "<?php\r\n/**\r\n * 异步回调通知\r\n * 说明：需要在支付文件中（如native.php或者jsapi.php）的填写回调地址。例如：http://www.xxx.com/wx/notify.php\r\n * 付款成功后，微信服务器会将付款结果通知到该页面\r\n */\r\n\r\nheader('Content-type:text/html; Charset=utf-8');\r\n$mchid = 'xxxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\r\n$appid = 'xxxxx';  //公众号APPID 通过微信支付商户资料审核后邮件发送\r\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n$wxPay = new WxpayService($mchid,$appid,$apiKey);\r\n$result = $wxPay->notify();\r\nif($result){\r\n    //完成你的逻辑\r\n    //例如连接数据库，获取付款金额$result['cash_fee']，获取订单号$result['out_trade_no']，修改数据库中的订单状态等;\r\n\t//现金支付金额：$result['cash_fee']\r\n\t//订单金额：$result['total_fee']\r\n\t//商户订单号：$result['out_trade_no']\r\n\t//付款银行：$result['bank_type']\r\n\t//货币种类：$result['fee_type']\r\n\t//是否关注公众账号：$result['is_subscribe']\r\n\t//用户标识：$result['openid']\r\n\t//业务结果：$result['result_code']  SUCCESS/FAIL\r\n\t//支付完成时间：$result['time_end']  格式为yyyyMMddHHmmss\r\n\t//具体详细请看微信文档：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_7&index=8\r\n}else{\r\n    echo 'pay error';\r\n}\r\nclass WxpayService\r\n{\r\n    protected $mchid;\r\n    protected $appid;\r\n    protected $apiKey;\r\n    public function __construct($mchid, $appid, $key)\r\n    {\r\n        $this->mchid = $mchid;\r\n        $this->appid = $appid;\r\n        $this->apiKey = $key;\r\n    }\r\n\r\n    public function notify()\r\n    {\r\n        $config = array(\r\n            'mch_id' => $this->mchid,\r\n            'appid' => $this->appid,\r\n            'key' => $this->apiKey,\r\n        );\r\n        $postStr = file_get_contents('php://input');\r\n\t\t//禁止引用外部xml实体\r\n\t\tlibxml_disable_entity_loader(true);        \r\n        $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);\r\n        if ($postObj === false) {\r\n            die('parse xml error');\r\n        }\r\n        if ($postObj->return_code != 'SUCCESS') {\r\n            die($postObj->return_msg);\r\n        }\r\n        if ($postObj->result_code != 'SUCCESS') {\r\n            die($postObj->err_code);\r\n        }\r\n        $arr = (array)$postObj;\r\n        unset($arr['sign']);\r\n        if (self::getSign($arr, $config['key']) == $postObj->sign) {\r\n            echo '<xml><return_code><![CDATA[SUCCESS]]></return_code><return_msg><![CDATA[OK]]></return_msg></xml>';\r\n            return $arr;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取签名\r\n     */\r\n    public static function getSign($params, $key)\r\n    {\r\n        ksort($params, SORT_STRING);\r\n        $unSignParaString = self::formatQueryParaMap($params, false);\r\n        $signStr = strtoupper(md5($unSignParaString . \"&key=\" . $key));\r\n        return $signStr;\r\n    }\r\n    protected static function formatQueryParaMap($paraMap, $urlEncode = false)\r\n    {\r\n        $buff = \"\";\r\n        ksort($paraMap);\r\n        foreach ($paraMap as $k => $v) {\r\n            if (null != $v && \"null\" != $v) {\r\n                if ($urlEncode) {\r\n                    $v = urlencode($v);\r\n                }\r\n                $buff .= $k . \"=\" . $v . \"&\";\r\n            }\r\n        }\r\n        $reqPar = '';\r\n        if (strlen($buff) > 0) {\r\n            $reqPar = substr($buff, 0, strlen($buff) - 1);\r\n        }\r\n        return $reqPar;\r\n    }\r\n}\r\n"
        },
        {
          "name": "notify_v3.php",
          "type": "blob",
          "size": 6.1376953125,
          "content": "<?php\r\nheader('Content-type:text/html; Charset=utf-8');\r\n/** 请填写以下配置信息 **/\r\n$publicKeyPath = getcwd() . '/cert/public_key.pem';    //微信支付公钥证书文件路径，可以到 https://www.dedemao.com/wx/wx_publickey_download.php 生成\r\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户中心-安全中心-API安全-APIv3密钥-设置密钥\r\n/** 配置结束 **/\r\n\r\n$wxPay = new WxpayService($apiKey, $publicKeyPath);\r\n$result = $wxPay->validate();\r\nif($result===false){\r\n    //验证签名失败\r\n    exit('sign error');\r\n}\r\n$result = $wxPay->notify();\r\nif ($result === false) {\r\n    exit('pay error');\r\n}\r\nif ($result['trade_state'] == 'SUCCESS') {\r\n    //支付成功，完成你的逻辑\r\n    //例如连接数据库，获取付款金额$result['amount']['total']，获取订单号$result['out_trade_no']修改数据库中的订单状态等;\r\n    //订单总金额，单位为分：$result['amount']['total']\r\n    //用户支付金额，单位为分：$result['amount']['payer_total']\r\n    //商户订单号：$result['out_trade_no']\r\n    //微信支付订单号：$result['transaction_id']\r\n    //银行类型：$result['bank_type']\r\n    //支付完成时间：$result['success_time'] 格式为YYYY-MM-DDTHH:mm:ss+TIMEZONE\r\n    //用户标识：$result['payer']['openid']\r\n    //交易状态：$result['trade_state']\r\n    //具体详细请看微信文档：https://pay.weixin.qq.com/wiki/doc/apiv3/wxpay/pay/transactions/chapter3_11.shtml\r\n    echo 'success';\r\n}\r\n\r\n\r\nclass WxpayService\r\n{\r\n    protected $apiKey;\r\n    protected $publicKeyPath;\r\n    protected $publicKey;\r\n\r\n    public function __construct($apikey, $publicKeyPath)\r\n    {\r\n        $this->apiKey = $apikey;\r\n        $this->publicKeyPath = $publicKeyPath;\r\n    }\r\n\r\n    public function getHeader($key = '')\r\n    {\r\n        $headers = getallheaders();\r\n        if ($key) {\r\n            return $headers[$key];\r\n        }\r\n        return $headers;\r\n    }\r\n\r\n    public function validate()\r\n    {\r\n        $serialNo = $this->getHeader('Wechatpay-Serial');\r\n        $sign = $this->getHeader('Wechatpay-Signature');\r\n        $timestamp = $this->getHeader('Wechatpay-Timestamp');\r\n        $nonce = $this->getHeader('Wechatpay-Nonce');\r\n        if (!isset($serialNo, $sign, $timestamp, $nonce)) {\r\n            return false;\r\n        }\r\n//        if (!$this->checkTimestamp($timestamp)) {\r\n//            return false;\r\n//        }\r\n        $body = file_get_contents('php://input');\r\n        $message = \"$timestamp\\n$nonce\\n$body\\n\";\r\n\r\n        $certificate = openssl_x509_read(file_get_contents($this->publicKeyPath));\r\n        $_serialNo = $this->parseSerialNo($certificate);\r\n        if ($serialNo !== $_serialNo) return false;\r\n        $this->publicKey = openssl_get_publickey($certificate);\r\n        return $this->verify($message, $sign);\r\n    }\r\n\r\n    private function verify($message, $signature)\r\n    {\r\n        if (!$this->publicKey) {\r\n            return false;\r\n        }\r\n        if (!in_array('sha256WithRSAEncryption', openssl_get_md_methods(true))) {\r\n            exit(\"当前PHP环境不支持SHA256withRSA\");\r\n        }\r\n        $signature = base64_decode($signature);\r\n        return (bool)openssl_verify($message, $signature, $this->publicKey, 'sha256WithRSAEncryption');\r\n    }\r\n\r\n    private function parseSerialNo($certificate)\r\n    {\r\n        $info = openssl_x509_parse($certificate);\r\n        if (!isset($info['serialNumber']) && !isset($info['serialNumberHex'])) {\r\n            exit('证书格式错误');\r\n        }\r\n\r\n        $serialNo = '';\r\n        if (isset($info['serialNumberHex'])) {\r\n            $serialNo = $info['serialNumberHex'];\r\n        } else {\r\n            if (strtolower(substr($info['serialNumber'], 0, 2)) == '0x') { // HEX format\r\n                $serialNo = substr($info['serialNumber'], 2);\r\n            } else { // DEC format\r\n                $value = $info['serialNumber'];\r\n                $hexvalues = ['0', '1', '2', '3', '4', '5', '6', '7',\r\n                    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\r\n                while ($value != '0') {\r\n                    $serialNo = $hexvalues[bcmod($value, '16')] . $serialNo;\r\n                    $value = bcdiv($value, '16', 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        return strtoupper($serialNo);\r\n    }\r\n\r\n    protected function checkTimestamp($timestamp)\r\n    {\r\n        return abs((int)$timestamp - time()) <= 120;\r\n    }\r\n\r\n    public function notify()\r\n    {\r\n        $postStr = file_get_contents('php://input');\r\n        $postData = json_decode($postStr, true);\r\n        if ($postData['resource']) {\r\n            $data = $this->decryptToString($postData['resource']['associated_data'], $postData['resource']['nonce'], $postData['resource']['ciphertext']);\r\n            $data = json_decode($data, true);\r\n            return is_array($data) ? $data : false;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public function decryptToString($associatedData, $nonceStr, $ciphertext)\r\n    {\r\n        $ciphertext = base64_decode($ciphertext);\r\n        if (strlen($ciphertext) <= 16) {\r\n            return false;\r\n        }\r\n\r\n        // ext-sodium (default installed on >= PHP 7.2)\r\n        if (function_exists('sodium_crypto_aead_aes256gcm_is_available') &&\r\n            sodium_crypto_aead_aes256gcm_is_available()) {\r\n            return sodium_crypto_aead_aes256gcm_decrypt($ciphertext, $associatedData, $nonceStr, $this->apiKey);\r\n        }\r\n\r\n        // ext-libsodium (need install libsodium-php 1.x via pecl)\r\n        if (function_exists('\\Sodium\\crypto_aead_aes256gcm_is_available') &&\r\n            \\Sodium\\crypto_aead_aes256gcm_is_available()) {\r\n            return \\Sodium\\crypto_aead_aes256gcm_decrypt($ciphertext, $associatedData, $nonceStr, $this->apiKey);\r\n        }\r\n\r\n        // openssl (PHP >= 7.1 support AEAD)\r\n        if (PHP_VERSION_ID >= 70100 && in_array('aes-256-gcm', openssl_get_cipher_methods())) {\r\n            $ctext = substr($ciphertext, 0, -16);\r\n            $authTag = substr($ciphertext, -16);\r\n\r\n            return openssl_decrypt($ctext, 'aes-256-gcm', $this->apiKey, OPENSSL_RAW_DATA, $nonceStr,\r\n                $authTag, $associatedData);\r\n        }\r\n\r\n        exit('AEAD_AES_256_GCM需要PHP 7.1以上或者安装libsodium-php');\r\n    }\r\n}\r\n"
        },
        {
          "name": "orderquery.php",
          "type": "blob",
          "size": 5.806640625,
          "content": "<?php\r\nheader('Content-type:text/html; Charset=utf-8');\r\n\r\n/** 请填写以下配置信息 */\r\n$mchid = 'xxxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\r\n$appid = 'xxxxx';  //公众号APPID 通过微信支付商户资料审核后邮件发送\r\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n$outTradeNo = '';     //要查询的订单号\r\n/** 配置结束 */\r\n\r\n$wxPay = new WxpayService($mchid,$appid,$apiKey);\r\n$result = $wxPay->orderquery($outTradeNo);\r\necho json_encode($result);die;\r\n\r\nclass WxpayService\r\n{\r\n    protected $mchid;\r\n    protected $appid;\r\n    protected $apiKey;\r\n    protected $returnUrl;\r\n    public function __construct($mchid, $appid, $key)\r\n    {\r\n        $this->mchid = $mchid;\r\n        $this->appid = $appid;\r\n        $this->apiKey = $key;\r\n    }\r\n\r\n    public function setReturnUrl($returnUrl)\r\n    {\r\n        $this->returnUrl = $returnUrl;\r\n    }\r\n\r\n    public function orderquery($outTradeNo)\r\n    {\r\n        $config = array(\r\n            'mch_id' => $this->mchid,\r\n            'appid' => $this->appid,\r\n            'key' => $this->apiKey,\r\n        );\r\n        //$orderName = iconv('GBK','UTF-8',$orderName);\r\n        $unified = array(\r\n            'appid' => $config['appid'],\r\n            'mch_id' => $config['mch_id'],\r\n            'out_trade_no' => $outTradeNo,\r\n            'nonce_str' => self::createNonceStr(),\r\n        );\r\n        $unified['sign'] = self::getSign($unified, $config['key']);\r\n        $responseXml = self::curlPost('https://api.mch.weixin.qq.com/pay/orderquery', self::arrayToXml($unified));\r\n        $queryResult = simplexml_load_string($responseXml, 'SimpleXMLElement', LIBXML_NOCDATA);\r\n        if ($queryResult === false) {\r\n            die('parse xml error');\r\n        }\r\n        if ($queryResult->return_code != 'SUCCESS') {\r\n            die($queryResult->return_msg);\r\n        }\r\n        $trade_state = $queryResult->trade_state;\r\n        $data['code'] = $trade_state=='SUCCESS' ? 0 : 1;\r\n        $data['data'] = $trade_state;\r\n        $data['msg'] = $this->getTradeSTate($trade_state);\r\n        $data['time'] = date('Y-m-d H:i:s');\r\n        return $data;exit();\r\n    }\r\n\r\n    public function getTradeSTate($str)\r\n    {\r\n        switch ($str){\r\n            case 'SUCCESS';\r\n                return '支付成功';\r\n            case 'REFUND';\r\n                return '转入退款';\r\n            case 'NOTPAY';\r\n                return '未支付';\r\n            case 'CLOSED';\r\n                return '已关闭';\r\n            case 'REVOKED';\r\n                return '已撤销（刷卡支付）';\r\n            case 'USERPAYING';\r\n                return '用户支付中';\r\n            case 'PAYERROR';\r\n                return '支付失败';\r\n        }\r\n    }\r\n    /**\r\n     * curl get\r\n     *\r\n     * @param string $url\r\n     * @param array $options\r\n     * @return mixed\r\n     */\r\n    public static function curlGet($url = '', $options = array())\r\n    {\r\n        $ch = curl_init($url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n    public static function curlPost($url = '', $postData = '', $options = array())\r\n    {\r\n        if (is_array($postData)) {\r\n            $postData = http_build_query($postData);\r\n        }\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_URL, $url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_POST, 1);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n    public static function createNonceStr($length = 16)\r\n    {\r\n        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        $str = '';\r\n        for ($i = 0; $i < $length; $i++) {\r\n            $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\r\n        }\r\n        return $str;\r\n    }\r\n    public static function arrayToXml($arr)\r\n    {\r\n        $xml = \"<xml>\";\r\n        foreach ($arr as $key => $val) {\r\n            if (is_numeric($val)) {\r\n                $xml .= \"<\" . $key . \">\" . $val . \"</\" . $key . \">\";\r\n            } else\r\n                $xml .= \"<\" . $key . \"><![CDATA[\" . $val . \"]]></\" . $key . \">\";\r\n        }\r\n        $xml .= \"</xml>\";\r\n        return $xml;\r\n    }\r\n    /**\r\n     * 获取签名\r\n     */\r\n    public static function getSign($params, $key)\r\n    {\r\n        ksort($params, SORT_STRING);\r\n        $unSignParaString = self::formatQueryParaMap($params, false);\r\n        $signStr = strtoupper(md5($unSignParaString . \"&key=\" . $key));\r\n        return $signStr;\r\n    }\r\n    protected static function formatQueryParaMap($paraMap, $urlEncode = false)\r\n    {\r\n        $buff = \"\";\r\n        ksort($paraMap);\r\n        foreach ($paraMap as $k => $v) {\r\n            if (null != $v && \"null\" != $v) {\r\n                if ($urlEncode) {\r\n                    $v = urlencode($v);\r\n                }\r\n                $buff .= $k . \"=\" . $v . \"&\";\r\n            }\r\n        }\r\n        $reqPar = '';\r\n        if (strlen($buff) > 0) {\r\n            $reqPar = substr($buff, 0, strlen($buff) - 1);\r\n        }\r\n        return $reqPar;\r\n    }\r\n}\r\n"
        },
        {
          "name": "redpack.php",
          "type": "blob",
          "size": 11.0029296875,
          "content": "<?php\n/**\n * 关于微信现金红包的说明\n * 1.微信现金红包要求必传证书，需要到https://pay.weixin.qq.com 账户中心->账户设置->API安全->下载证书\n * 2.默认的使用场景是抽奖（即scene_id参数为PRODUCT_2），额度是1-200元，所以测试时的最低金额是1元。如需修改在产品中心->产品大全->现金红包->产品设置中修改\n * 3.错误码参照 ：https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_4&index=3\n */\nheader('Content-type:text/html; Charset=utf-8');\n$mchid = 'xxxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\n$appid = 'xxxxx';  //微信支付申请对应的公众号的APPID\n$appKey = 'xxxxx';   //微信支付申请对应的公众号的APP Key\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\n//填写证书所在位置，证书在https://pay.weixin.qq.com 账户中心->账户设置->API安全->下载证书，下载后将apiclient_cert.pem和apiclient_key.pem上传到服务器。\n$apiclient_cert = getcwd().'/cert/apiclient_cert.pem';\n$apiclient_key = getcwd().'/cert/apiclient_key.pem';\n\n//①、获取当前访问页面的用户openid（如果给指定用户发送红包，则填写指定用户的openid)\n$wxPay = new WxpayService($mchid,$appid,$appKey,$apiKey,$apiclient_cert,$apiclient_key);\n$openId = $wxPay->GetOpenid();      //获取openid\nif(!$openId) exit('获取openid失败');\n//②、发送红包\n$outTradeNo = uniqid();     //你自己的商品订单号\n$payAmount = 1;          //红包金额，单位:元\n$sendName = '元旦';    //红包发送者名称\n$wishing = '祝您元旦快乐！';      //红包祝福语\n$act_name='元旦快乐';           //活动名称\n$result = $wxPay->createJsBizPackage($openId,$payAmount,$outTradeNo,$sendName,$wishing,$act_name);\necho 'success';\nclass WxpayService\n{\n    protected $mchid;\n    protected $appid;\n    protected $appKey;\n    protected $apiKey;\n    protected $apiclient_cert;\n    protected $apiclient_key;\n    public $data = null;\n\n    public function __construct($mchid, $appid, $appKey,$key,$apiclient_cert,$apiclient_key)\n    {\n        $this->mchid = $mchid;\n        $this->appid = $appid;\n        $this->appKey = $appKey;\n        $this->apiKey = $key;\n        $this->apiclient_cert = $apiclient_cert;\n        $this->apiclient_key = $apiclient_key;\n    }\n\n    /**\n     * 通过跳转获取用户的openid，跳转流程如下：\n     * 1、设置自己需要调回的url及其其他参数，跳转到微信服务器https://open.weixin.qq.com/connect/oauth2/authorize\n     * 2、微信服务处理完成之后会跳转回用户redirect_uri地址，此时会带上一些参数，如：code\n     * @return 用户的openid\n     */\n    public function GetOpenid()\n    {\n        //通过code获得openid\n        if (!isset($_GET['code'])){\n            //触发微信返回code码\n            $scheme = $_SERVER['HTTPS']=='on' ? 'https://' : 'http://';\n\t\t\t$uri = $_SERVER['PHP_SELF'].$_SERVER['QUERY_STRING'];\n\t\t\tif($_SERVER['REQUEST_URI']){\n\t\t\t\t$uri = $_SERVER['REQUEST_URI'];\n\t\t\t}\n            $baseUrl = urlencode($scheme.$_SERVER['HTTP_HOST'].$uri);\n            $url = $this->__CreateOauthUrlForCode($baseUrl);\n            Header(\"Location: $url\");\n            exit();\n        } else {\n            //获取code码，以获取openid\n            $code = $_GET['code'];\n            $openid = $this->getOpenidFromMp($code);\n            return $openid;\n        }\n    }\n\n    /**\n     * 通过code从工作平台获取openid机器access_token\n     * @param string $code 微信跳转回来带上的code\n     * @return openid\n     */\n    public function GetOpenidFromMp($code)\n    {\n        $url = $this->__CreateOauthUrlForOpenid($code);\n        $res = self::curlGet($url);\n        //取出openid\n        $data = json_decode($res,true);\n        $this->data = $data;\n        $openid = $data['openid'];\n        return $openid;\n    }\n\n    /**\n     * 构造获取open和access_toke的url地址\n     * @param string $code，微信跳转带回的code\n     * @return 请求的url\n     */\n    private function __CreateOauthUrlForOpenid($code)\n    {\n        $urlObj[\"appid\"] = $this->appid;\n        $urlObj[\"secret\"] = $this->appKey;\n        $urlObj[\"code\"] = $code;\n        $urlObj[\"grant_type\"] = \"authorization_code\";\n        $bizString = $this->ToUrlParams($urlObj);\n        return \"https://api.weixin.qq.com/sns/oauth2/access_token?\".$bizString;\n    }\n\n    /**\n     * 构造获取code的url连接\n     * @param string $redirectUrl 微信服务器回跳的url，需要url编码\n     * @return 返回构造好的url\n     */\n    private function __CreateOauthUrlForCode($redirectUrl)\n    {\n        $urlObj[\"appid\"] = $this->appid;\n        $urlObj[\"redirect_uri\"] = \"$redirectUrl\";\n        $urlObj[\"response_type\"] = \"code\";\n        $urlObj[\"scope\"] = \"snsapi_base\";\n        $urlObj[\"state\"] = \"STATE\".\"#wechat_redirect\";\n        $bizString = $this->ToUrlParams($urlObj);\n        return \"https://open.weixin.qq.com/connect/oauth2/authorize?\".$bizString;\n    }\n\n    /**\n     * 拼接签名字符串\n     * @param array $urlObj\n     * @return 返回已经拼接好的字符串\n     */\n    private function ToUrlParams($urlObj)\n    {\n        $buff = \"\";\n        foreach ($urlObj as $k => $v)\n        {\n            if($k != \"sign\") $buff .= $k . \"=\" . $v . \"&\";\n        }\n        $buff = trim($buff, \"&\");\n        return $buff;\n    }\n\n    /**\n     * 统一下单\n     * @param string $openid 调用【网页授权获取用户信息】接口获取到用户在该公众号下的Openid\n     * @param float $totalFee 收款总费用 单位元\n     * @param string $outTradeNo 唯一的订单号\n     * @param string $orderName 订单名称\n     * @param string $notifyUrl 支付结果通知url 不要有问号\n     * @param string $timestamp 支付时间\n     * @return string\n     */\n    public function createJsBizPackage($openid, $totalFee, $outTradeNo, $sendName,$wishing,$actName)\n    {\n        $config = array(\n            'mch_id' => $this->mchid,\n            'appid' => $this->appid,\n            'key' => $this->apiKey,\n        );\n        $unified = array(\n            'wxappid' => $config['appid'],\n            'send_name' => $sendName,\n            'mch_id' => $config['mch_id'],\n            'nonce_str' => self::createNonceStr(),\n            're_openid' => $openid,\n            'mch_billno' => $outTradeNo,\n            'client_ip' => '127.0.0.1',\n            'total_amount' => floatval($totalFee) * 100,       //单位 转为分\n            'total_num'=>1,     //红包发放总人数\n            'wishing'=>$wishing,      //红包祝福语\n            'act_name'=>$actName,           //活动名称\n            'remark'=>'remark',               //备注信息，如为中文注意转为UTF8编码\n            'scene_id'=>'PRODUCT_2',      //发放红包使用场景，红包金额大于200时必传。https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_4&index=3\n        );\n        $unified['sign'] = self::getSign($unified, $config['key']);\n        $responseXml = $this->curlPost('https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack', self::arrayToXml($unified));\n        file_put_contents('1.txt',print_r($responseXml,true));\n//        print_r($responseXml,true);die;\n        $unifiedOrder = simplexml_load_string($responseXml, 'SimpleXMLElement', LIBXML_NOCDATA);\n        if ($unifiedOrder === false) {\n            die('parse xml error');\n        }\n        if ($unifiedOrder->return_code != 'SUCCESS') {\n            die($unifiedOrder->return_msg);\n        }\n        if ($unifiedOrder->result_code != 'SUCCESS') {\n            die($unifiedOrder->err_code);\n        }\n        return true;\n    }\n\n    public static function curlGet($url = '', $options = array())\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https请求 不验证证书和host\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array())\n    {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https请求 不验证证书和host\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        //第一种方法，cert 与 key 分别属于两个.pem文件\n        //默认格式为PEM，可以注释\n        curl_setopt($ch,CURLOPT_SSLCERTTYPE,'PEM');\n        curl_setopt($ch,CURLOPT_SSLCERT,getcwd().'/cert/apiclient_cert.pem');\n        //默认格式为PEM，可以注释\n        curl_setopt($ch,CURLOPT_SSLKEYTYPE,'PEM');\n        curl_setopt($ch,CURLOPT_SSLKEY,getcwd().'/cert/apiclient_key.pem');\n        //第二种方式，两个文件合成一个.pem文件\n//        curl_setopt($ch,CURLOPT_SSLCERT,getcwd().'/all.pem');\n\n        $data = curl_exec($ch);\n        var_dump($data);die;\n        curl_close($ch);\n        return $data;\n    }\n\n    public static function createNonceStr($length = 16)\n    {\n        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n        $str = '';\n        for ($i = 0; $i < $length; $i++) {\n            $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\n        }\n        return $str;\n    }\n    public static function arrayToXml($arr)\n    {\n        $xml = \"<xml>\";\n        foreach ($arr as $key => $val) {\n            if (is_numeric($val)) {\n                $xml .= \"<\" . $key . \">\" . $val . \"</\" . $key . \">\";\n            } else\n                $xml .= \"<\" . $key . \"><![CDATA[\" . $val . \"]]></\" . $key . \">\";\n        }\n        $xml .= \"</xml>\";\n        file_put_contents('1.txt',$xml);\n        return $xml;\n    }\n\n    public static function getSign($params, $key)\n    {\n        ksort($params, SORT_STRING);\n        $unSignParaString = self::formatQueryParaMap($params, false);\n        $signStr = strtoupper(md5($unSignParaString . \"&key=\" . $key));\n        return $signStr;\n    }\n    protected static function formatQueryParaMap($paraMap, $urlEncode = false)\n    {\n        $buff = \"\";\n        ksort($paraMap);\n        foreach ($paraMap as $k => $v) {\n            if (null != $v && \"null\" != $v) {\n                if ($urlEncode) {\n                    $v = urlencode($v);\n                }\n                $buff .= $k . \"=\" . $v . \"&\";\n            }\n        }\n        $reqPar = '';\n        if (strlen($buff) > 0) {\n            $reqPar = substr($buff, 0, strlen($buff) - 1);\n        }\n        return $reqPar;\n    }\n}\n?>\n"
        },
        {
          "name": "refund.php",
          "type": "blob",
          "size": 7.0703125,
          "content": "<?php\r\n/**\r\n * 关于微信退款的说明\r\n * 1.微信退款要求必传证书，需要到https://pay.weixin.qq.com 账户中心->账户设置->API安全->下载证书，证书路径在第119行和122行修改\r\n * 2.错误码参照 ：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_4\r\n */\r\nheader('Content-type:text/html; Charset=utf-8');\r\n$mchid = 'xxxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\r\n$appid = 'xxxxx';  //微信支付申请对应的公众号的APPID\r\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n$orderNo = '';                      //商户订单号（商户订单号与微信订单号二选一，至少填一个）\r\n$wxOrderNo = '';                     //微信订单号（商户订单号与微信订单号二选一，至少填一个）\r\n$totalFee = 0.01;                   //订单金额，单位:元\r\n$refundFee = 0.01;                  //退款金额，单位:元\r\n$refundNo = 'refund_'.uniqid();        //退款订单号(可随机生成)\r\n$wxPay = new WxpayService($mchid,$appid,$apiKey);\r\n$result = $wxPay->doRefund($totalFee, $refundFee, $refundNo, $wxOrderNo,$orderNo);\r\nif($result===true){\r\n    echo 'refund success';exit();\r\n}\r\necho 'refund fail';\r\n\r\nclass WxpayService\r\n{\r\n    protected $mchid;\r\n    protected $appid;\r\n    protected $apiKey;\r\n    public $data = null;\r\n\r\n    public function __construct($mchid, $appid, $key)\r\n    {\r\n        $this->mchid = $mchid; //https://pay.weixin.qq.com 产品中心-开发配置-商户号\r\n        $this->appid = $appid; //微信支付申请对应的公众号的APPID\r\n        $this->apiKey = $key;   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n    }\r\n\r\n    /**\r\n     * 退款\r\n     * @param float $totalFee 订单金额 单位元\r\n     * @param float $refundFee 退款金额 单位元\r\n     * @param string $refundNo 退款单号\r\n     * @param string $wxOrderNo 微信订单号\r\n     * @param string $orderNo 商户订单号\r\n     * @return string\r\n     */\r\n    public function doRefund($totalFee, $refundFee, $refundNo, $wxOrderNo='',$orderNo='')\r\n    {\r\n        $config = array(\r\n            'mch_id' => $this->mchid,\r\n            'appid' => $this->appid,\r\n            'key' => $this->apiKey,\r\n        );\r\n        $unified = array(\r\n            'appid' => $config['appid'],\r\n            'mch_id' => $config['mch_id'],\r\n            'nonce_str' => self::createNonceStr(),\r\n            'total_fee' => floatval($totalFee) * 100,       //订单金额\t 单位 转为分\r\n            'refund_fee' => floatval($refundFee) * 100,       //退款金额 单位 转为分\r\n            'sign_type' => 'MD5',           //签名类型 支持HMAC-SHA256和MD5，默认为MD5\r\n            'transaction_id'=>$wxOrderNo,               //微信订单号\r\n            'out_trade_no'=>$orderNo,        //商户订单号\r\n            'out_refund_no'=>$refundNo,        //商户退款单号\r\n            'refund_desc'=>'商品已售完',     //退款原因（选填）\r\n        );\r\n        $unified['sign'] = self::getSign($unified, $config['key']);\r\n        $responseXml = $this->curlPost('https://api.mch.weixin.qq.com/secapi/pay/refund', self::arrayToXml($unified));\r\n        $unifiedOrder = simplexml_load_string($responseXml, 'SimpleXMLElement', LIBXML_NOCDATA);\r\n        if ($unifiedOrder === false) {\r\n            die('parse xml error');\r\n        }\r\n        if ($unifiedOrder->return_code != 'SUCCESS') {\r\n            die($unifiedOrder->return_msg);\r\n        }\r\n        if ($unifiedOrder->result_code != 'SUCCESS') {\r\n            die($unifiedOrder->err_code);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static function curlGet($url = '', $options = array())\r\n    {\r\n        $ch = curl_init($url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n\r\n    public function curlPost($url = '', $postData = '', $options = array())\r\n    {\r\n        if (is_array($postData)) {\r\n            $postData = http_build_query($postData);\r\n        }\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_URL, $url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_POST, 1);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n\r\n        //第一种方法，cert 与 key 分别属于两个.pem文件\r\n        //默认格式为PEM，可以注释\r\n        curl_setopt($ch,CURLOPT_SSLCERTTYPE,'PEM');\r\n        curl_setopt($ch,CURLOPT_SSLCERT,getcwd().'/cert/apiclient_cert.pem');\r\n        //默认格式为PEM，可以注释\r\n        curl_setopt($ch,CURLOPT_SSLKEYTYPE,'PEM');\r\n        curl_setopt($ch,CURLOPT_SSLKEY,getcwd().'/cert/apiclient_key.pem');\r\n        //第二种方式，两个文件合成一个.pem文件\r\n//        curl_setopt($ch,CURLOPT_SSLCERT,getcwd().'/all.pem');\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n\r\n    public static function createNonceStr($length = 16)\r\n    {\r\n        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        $str = '';\r\n        for ($i = 0; $i < $length; $i++) {\r\n            $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\r\n        }\r\n        return $str;\r\n    }\r\n    public static function arrayToXml($arr)\r\n    {\r\n        $xml = \"<xml>\";\r\n        foreach ($arr as $key => $val) {\r\n            if (is_numeric($val)) {\r\n                $xml .= \"<\" . $key . \">\" . $val . \"</\" . $key . \">\";\r\n            } else\r\n                $xml .= \"<\" . $key . \"><![CDATA[\" . $val . \"]]></\" . $key . \">\";\r\n        }\r\n        $xml .= \"</xml>\";\r\n        return $xml;\r\n    }\r\n\r\n    public static function getSign($params, $key)\r\n    {\r\n        ksort($params, SORT_STRING);\r\n        $unSignParaString = self::formatQueryParaMap($params, false);\r\n        $signStr = strtoupper(md5($unSignParaString . \"&key=\" . $key));\r\n        return $signStr;\r\n    }\r\n    protected static function formatQueryParaMap($paraMap, $urlEncode = false)\r\n    {\r\n        $buff = \"\";\r\n        ksort($paraMap);\r\n        foreach ($paraMap as $k => $v) {\r\n            if (null != $v && \"null\" != $v) {\r\n                if ($urlEncode) {\r\n                    $v = urlencode($v);\r\n                }\r\n                $buff .= $k . \"=\" . $v . \"&\";\r\n            }\r\n        }\r\n        $reqPar = '';\r\n        if (strlen($buff) > 0) {\r\n            $reqPar = substr($buff, 0, strlen($buff) - 1);\r\n        }\r\n        return $reqPar;\r\n    }\r\n}\r\n?>\r\n"
        },
        {
          "name": "refund_query.php",
          "type": "blob",
          "size": 6.0205078125,
          "content": "<?php\r\nheader('Content-type:text/html; Charset=utf-8');\r\n$mchid = 'xxxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\r\n$appid = 'xxxxx';  //微信支付申请对应的公众号的APPID\r\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n\r\n//以下四个单号四选一。查询的优先级是： 微信退款单号 > 商户退款订单号 > 微信订单号 > 商户订单号\r\n$orderNo = '';                      //商户订单号\r\n$wxOrderNo = '';                     //微信订单号\r\n$refundNo='';                       //商户退款订单号\r\n$refundId = '';                     //微信退款单号（微信生成的退款单号，在申请退款接口有返回）\r\n\r\n$wxPay = new WxpayService($mchid,$appid,$apiKey);\r\n$result = $wxPay->doRefundQuery($refundNo, $wxOrderNo,$orderNo,$refundId);\r\nif($result===true){\r\n    echo 'refund success';exit();\r\n}\r\necho 'refund fail';\r\n\r\nclass WxpayService\r\n{\r\n    protected $mchid;\r\n    protected $appid;\r\n    protected $apiKey;\r\n    public $data = null;\r\n\r\n    public function __construct($mchid, $appid, $key)\r\n    {\r\n        $this->mchid = $mchid; //https://pay.weixin.qq.com 产品中心-开发配置-商户号\r\n        $this->appid = $appid; //微信支付申请对应的公众号的APPID\r\n        $this->apiKey = $key;   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n    }\r\n\r\n    /**\r\n     * 退款查询\r\n     * @param string $refundNo 商户退款单号\r\n     * @param string $wxOrderNo 微信订单号\r\n     * @param string $orderNo 商户订单号\r\n     * @param string $refundId 微信退款单号\r\n     * @return string\r\n     */\r\n    public function doRefundQuery($refundNo='', $wxOrderNo='',$orderNo='',$refundId='')\r\n    {\r\n        $config = array(\r\n            'mch_id' => $this->mchid,\r\n            'appid' => $this->appid,\r\n            'key' => $this->apiKey,\r\n        );\r\n        $unified = array(\r\n            'appid' => $config['appid'],\r\n            'mch_id' => $config['mch_id'],\r\n            'nonce_str' => self::createNonceStr(),\r\n            'sign_type' => 'MD5',           //签名类型 支持HMAC-SHA256和MD5，默认为MD5\r\n            'transaction_id'=>$wxOrderNo,               //微信订单号\r\n            'out_trade_no'=>$orderNo,        //商户订单号\r\n            'out_refund_no'=>$refundNo,        //商户退款单号\r\n            'refund_id'=>$refundId,     //微信退款单号\r\n        );\r\n        $unified['sign'] = self::getSign($unified, $config['key']);\r\n        $responseXml = $this->curlPost('https://api.mch.weixin.qq.com/pay/refundquery', self::arrayToXml($unified));\r\n        file_put_contents('2.txt',$responseXml);\r\n        $unifiedOrder = simplexml_load_string($responseXml, 'SimpleXMLElement', LIBXML_NOCDATA);\r\n        if ($unifiedOrder === false) {\r\n            die('parse xml error');\r\n        }\r\n        if ($unifiedOrder->return_code != 'SUCCESS') {\r\n            die($unifiedOrder->return_msg);\r\n        }\r\n        if ($unifiedOrder->result_code != 'SUCCESS') {\r\n            die($unifiedOrder->err_code);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static function curlGet($url = '', $options = array())\r\n    {\r\n        $ch = curl_init($url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n\r\n    public function curlPost($url = '', $postData = '', $options = array())\r\n    {\r\n        if (is_array($postData)) {\r\n            $postData = http_build_query($postData);\r\n        }\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_URL, $url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_POST, 1);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n\r\n    public static function createNonceStr($length = 16)\r\n    {\r\n        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        $str = '';\r\n        for ($i = 0; $i < $length; $i++) {\r\n            $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\r\n        }\r\n        return $str;\r\n    }\r\n    public static function arrayToXml($arr)\r\n    {\r\n        $xml = \"<xml>\";\r\n        foreach ($arr as $key => $val) {\r\n            if (is_numeric($val)) {\r\n                $xml .= \"<\" . $key . \">\" . $val . \"</\" . $key . \">\";\r\n            } else\r\n                $xml .= \"<\" . $key . \"><![CDATA[\" . $val . \"]]></\" . $key . \">\";\r\n        }\r\n        $xml .= \"</xml>\";\r\n        return $xml;\r\n    }\r\n\r\n    public static function getSign($params, $key)\r\n    {\r\n        ksort($params, SORT_STRING);\r\n        $unSignParaString = self::formatQueryParaMap($params, false);\r\n        $signStr = strtoupper(md5($unSignParaString . \"&key=\" . $key));\r\n        return $signStr;\r\n    }\r\n    protected static function formatQueryParaMap($paraMap, $urlEncode = false)\r\n    {\r\n        $buff = \"\";\r\n        ksort($paraMap);\r\n        foreach ($paraMap as $k => $v) {\r\n            if (null != $v && \"null\" != $v) {\r\n                if ($urlEncode) {\r\n                    $v = urlencode($v);\r\n                }\r\n                $buff .= $k . \"=\" . $v . \"&\";\r\n            }\r\n        }\r\n        $reqPar = '';\r\n        if (strlen($buff) > 0) {\r\n            $reqPar = substr($buff, 0, strlen($buff) - 1);\r\n        }\r\n        return $reqPar;\r\n    }\r\n}\r\n?>"
        },
        {
          "name": "reverse.php",
          "type": "blob",
          "size": 7.1337890625,
          "content": "<?php\r\n/**\r\n * 撤销订单\r\n * 支付交易返回失败或支付系统超时，调用该接口撤销交易。如果此订单用户支付失败，微信支付系统会将此订单关闭；如果用户支付成功，微信支付系统会将此订单资金退还给用户。\r\n * 注意：7天以内的交易单可调用撤销，其他正常支付的单如需实现相同功能请调用申请退款API。\r\n * 1.撤销订单要求必传证书，需要到https://pay.weixin.qq.com 账户中心->账户设置->API安全->下载证书\r\n * 2.错误码参照 ：https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=9_11&index=3\r\n */\r\nheader('Content-type:text/html; Charset=utf-8');\r\n/* 配置开始  */\r\n$mchid = '';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\r\n$appid = '';  //微信支付申请对应的公众号的APPID\r\n$appKey = '';   //微信支付申请对应的公众号的APP Key\r\n$apiKey = '';   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\r\n//填写证书所在位置，证书在https://pay.weixin.qq.com 账户中心->账户设置->API安全->下载证书，下载后将apiclient_cert.pem和apiclient_key.pem上传到服务器。\r\n$apiclient_cert = getcwd().'/cert/apiclient_cert.pem';\r\n$apiclient_key = getcwd().'/cert/apiclient_key.pem';\r\n$transaction_id = '';   //微信的订单号，优先使用。微信订单号与商户订单号不能同时为空\r\n$out_trade_no = '';\t\t//商户订单号。微信订单号与商户订单号不能同时为空\r\n/* 配置结束 */\r\n$wxPay = new WxpayService($mchid,$appid,$appKey,$apiKey);\r\n$wxPay->setApiclientCert($apiclient_cert);\r\n$wxPay->setApiclientKey($apiclient_key);\r\n$wxPay->setTransactionId($transaction_id);\r\n$wxPay->setOutTradeNo($out_trade_no);\r\n$result = $wxPay->doReverse();\r\necho 'success';\r\nclass WxpayService\r\n{\r\n    protected $mchid;\r\n    protected $appid;\r\n    protected $appKey;\r\n    protected $apiKey;\r\n    protected $apiclient_cert;\r\n    protected $apiclient_key;\r\n    protected $transactionId;\r\n    protected $outTradeNo;\r\n    public $data = null;\r\n\r\n    public function __construct($mchid, $appid, $appKey,$key)\r\n    {\r\n        $this->mchid = $mchid;\r\n        $this->appid = $appid;\r\n        $this->appKey = $appKey;\r\n        $this->apiKey = $key;\r\n    }\r\n\r\n\tpublic function setApiclientCert($apiclient_cert)\r\n\t{\r\n\t\t$this->apiclient_cert = $apiclient_cert;\r\n\t}\r\n\r\n\tpublic function setApiclientKey($apiclient_key)\r\n\t{\r\n\t\t$this->apiclient_key = $apiclient_key;\r\n\t}\r\n\r\n\tpublic function setTransactionId($transaction_id)\r\n\t{\r\n\t\t$this->transactionId = $transaction_id;\r\n\t}\r\n\r\n\tpublic function setOutTradeNo($out_trade_no)\r\n\t{\r\n\t\t$this->outTradeNo = $out_trade_no;\r\n\t}\r\n\r\n    /**\r\n     * 撤销订单\r\n     */\r\n    public function doReverse()\r\n    {\r\n        $unified = array(\r\n            'mch_id' => $this->mchid,\r\n            'appid' => $this->appid,\r\n            'transaction_id' => $this->transactionId,\r\n            'out_trade_no' => $this->outTradeNo,\r\n            'nonce_str' => self::createNonceStr(),\r\n        );\r\n        $unified['sign'] = self::getSign($unified, $this->apiKey);\r\n        $responseXml = $this->curlPost('https://api.mch.weixin.qq.com/secapi/pay/reverse', self::arrayToXml($unified));\t\t\r\n        $unifiedOrder = simplexml_load_string($responseXml, 'SimpleXMLElement', LIBXML_NOCDATA);\r\n        if ($unifiedOrder === false) {\r\n            die('parse xml error');\r\n        }\r\n        if ($unifiedOrder->return_code != 'SUCCESS') {\r\n            die($unifiedOrder->return_msg);\r\n        }\r\n        if ($unifiedOrder->result_code != 'SUCCESS') {\r\n            die($unifiedOrder->err_code.':'.$unifiedOrder->err_code_des);\r\n        }\r\n\t\t\r\n        return true;\r\n    }\r\n\r\n    public static function curlGet($url = '', $options = array())\r\n    {\r\n        $ch = curl_init($url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        $data = curl_exec($ch);\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n\r\n    public function curlPost($url = '', $postData = '', $options = array())\r\n    {\r\n        if (is_array($postData)) {\r\n            $postData = http_build_query($postData);\r\n        }\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_URL, $url);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($ch, CURLOPT_POST, 1);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\r\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\r\n        if (!empty($options)) {\r\n            curl_setopt_array($ch, $options);\r\n        }\r\n        //https请求 不验证证书和host\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n\r\n        //第一种方法，cert 与 key 分别属于两个.pem文件\r\n        //默认格式为PEM，可以注释\r\n        curl_setopt($ch,CURLOPT_SSLCERTTYPE,'PEM');\r\n        curl_setopt($ch,CURLOPT_SSLCERT,$this->apiclient_cert);\r\n        //默认格式为PEM，可以注释\r\n        curl_setopt($ch,CURLOPT_SSLKEYTYPE,'PEM');\r\n        curl_setopt($ch,CURLOPT_SSLKEY,$this->apiclient_key);\r\n        //第二种方式，两个文件合成一个.pem文件\r\n//        curl_setopt($ch,CURLOPT_SSLCERT,getcwd().'/all.pem');\r\n\r\n        $data = curl_exec($ch);\r\n        //var_dump($data);die;\r\n        curl_close($ch);\r\n        return $data;\r\n    }\r\n\r\n    public static function createNonceStr($length = 16)\r\n    {\r\n        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        $str = '';\r\n        for ($i = 0; $i < $length; $i++) {\r\n            $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\r\n        }\r\n        return $str;\r\n    }\r\n    public static function arrayToXml($arr)\r\n    {\r\n        $xml = \"<xml>\";\r\n        foreach ($arr as $key => $val) {\r\n            if (is_numeric($val)) {\r\n                $xml .= \"<\" . $key . \">\" . $val . \"</\" . $key . \">\";\r\n            } else\r\n                $xml .= \"<\" . $key . \"><![CDATA[\" . $val . \"]]></\" . $key . \">\";\r\n        }\r\n        $xml .= \"</xml>\";\r\n        file_put_contents('1.txt',$xml);\r\n        return $xml;\r\n    }\r\n\r\n    public static function getSign($params, $key)\r\n    {\r\n        ksort($params, SORT_STRING);\r\n        $unSignParaString = self::formatQueryParaMap($params, false);\r\n        $signStr = strtoupper(md5($unSignParaString . \"&key=\" . $key));\r\n        return $signStr;\r\n    }\r\n    protected static function formatQueryParaMap($paraMap, $urlEncode = false)\r\n    {\r\n        $buff = \"\";\r\n        ksort($paraMap);\r\n        foreach ($paraMap as $k => $v) {\r\n            if (null != $v && \"null\" != $v) {\r\n                if ($urlEncode) {\r\n                    $v = urlencode($v);\r\n                }\r\n                $buff .= $k . \"=\" . $v . \"&\";\r\n            }\r\n        }\r\n        $reqPar = '';\r\n        if (strlen($buff) > 0) {\r\n            $reqPar = substr($buff, 0, strlen($buff) - 1);\r\n        }\r\n        return $reqPar;\r\n    }\r\n}\r\n?>"
        },
        {
          "name": "transfers.php",
          "type": "blob",
          "size": 9.9931640625,
          "content": "<?php\n/**\n * 关于微信企业付款的说明\n * 1.微信企业付款要求必传证书，需要到https://pay.weixin.qq.com 账户中心->账户设置->API安全->下载证书，证书路径在第207行和210行修改\n * 2.错误码参照 ：https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2\n */\nheader('Content-type:text/html; Charset=utf-8');\n$mchid = 'xxxxx';          //微信支付商户号 PartnerID 通过微信支付商户资料审核后邮件发送\n$appid = 'xxxxx';  //微信支付申请对应的公众号的APPID\n$appKey = 'xxxxx';   //微信支付申请对应的公众号的APP Key\n$apiKey = 'xxxxx';   //https://pay.weixin.qq.com 帐户设置-安全设置-API安全-API密钥-设置API密钥\n\n//①、获取当前访问页面的用户openid（如果给指定用户转账，则直接填写指定用户的openid)\n$wxPay = new WxpayService($mchid,$appid,$appKey,$apiKey);\n$openId = $wxPay->GetOpenid();      //获取openid\nif(!$openId) exit('获取openid失败');\n//②、付款\n$outTradeNo = uniqid();     //订单号\n$payAmount = 1;             //转账金额，单位:元。转账最小金额为1元\n$trueName = '张三';         //收款人真实姓名\n$result = $wxPay->createJsBizPackage($openId,$payAmount,$outTradeNo,$trueName);\necho 'success';\nclass WxpayService\n{\n    protected $mchid;\n    protected $appid;\n    protected $appKey;\n    protected $apiKey;\n    public $data = null;\n\n    public function __construct($mchid, $appid, $appKey,$key)\n    {\n        $this->mchid = $mchid;\n        $this->appid = $appid;\n        $this->appKey = $appKey;\n        $this->apiKey = $key;\n    }\n\n    /**\n     * 通过跳转获取用户的openid，跳转流程如下：\n     * 1、设置自己需要调回的url及其其他参数，跳转到微信服务器https://open.weixin.qq.com/connect/oauth2/authorize\n     * 2、微信服务处理完成之后会跳转回用户redirect_uri地址，此时会带上一些参数，如：code\n     * @return 用户的openid\n     */\n    public function GetOpenid()\n    {\n        //通过code获得openid\n        if (!isset($_GET['code'])){\n            //触发微信返回code码\n            $scheme = $_SERVER['HTTPS']=='on' ? 'https://' : 'http://';\n\t\t\t$uri = $_SERVER['PHP_SELF'].$_SERVER['QUERY_STRING'];\n\t\t\tif($_SERVER['REQUEST_URI']){\n\t\t\t\t$uri = $_SERVER['REQUEST_URI'];\n\t\t\t}\n            $baseUrl = urlencode($scheme.$_SERVER['HTTP_HOST'].$uri);\n            $url = $this->__CreateOauthUrlForCode($baseUrl);\n            Header(\"Location: $url\");\n            exit();\n        } else {\n            //获取code码，以获取openid\n            $code = $_GET['code'];\n            $openid = $this->getOpenidFromMp($code);\n            return $openid;\n        }\n    }\n\n    /**\n     * 通过code从工作平台获取openid机器access_token\n     * @param string $code 微信跳转回来带上的code\n     * @return openid\n     */\n    public function GetOpenidFromMp($code)\n    {\n        $url = $this->__CreateOauthUrlForOpenid($code);\n        $res = self::curlGet($url);\n        //取出openid\n        $data = json_decode($res,true);\n        $this->data = $data;\n        $openid = $data['openid'];\n        return $openid;\n    }\n\n    /**\n     * 构造获取open和access_toke的url地址\n     * @param string $code，微信跳转带回的code\n     * @return 请求的url\n     */\n    private function __CreateOauthUrlForOpenid($code)\n    {\n        $urlObj[\"appid\"] = $this->appid;\n        $urlObj[\"secret\"] = $this->appKey;\n        $urlObj[\"code\"] = $code;\n        $urlObj[\"grant_type\"] = \"authorization_code\";\n        $bizString = $this->ToUrlParams($urlObj);\n        return \"https://api.weixin.qq.com/sns/oauth2/access_token?\".$bizString;\n    }\n\n    /**\n     * 构造获取code的url连接\n     * @param string $redirectUrl 微信服务器回跳的url，需要url编码\n     * @return 返回构造好的url\n     */\n    private function __CreateOauthUrlForCode($redirectUrl)\n    {\n        $urlObj[\"appid\"] = $this->appid;\n        $urlObj[\"redirect_uri\"] = \"$redirectUrl\";\n        $urlObj[\"response_type\"] = \"code\";\n        $urlObj[\"scope\"] = \"snsapi_base\";\n        $urlObj[\"state\"] = \"STATE\".\"#wechat_redirect\";\n        $bizString = $this->ToUrlParams($urlObj);\n        return \"https://open.weixin.qq.com/connect/oauth2/authorize?\".$bizString;\n    }\n\n    /**\n     * 拼接签名字符串\n     * @param array $urlObj\n     * @return 返回已经拼接好的字符串\n     */\n    private function ToUrlParams($urlObj)\n    {\n        $buff = \"\";\n        foreach ($urlObj as $k => $v)\n        {\n            if($k != \"sign\") $buff .= $k . \"=\" . $v . \"&\";\n        }\n        $buff = trim($buff, \"&\");\n        return $buff;\n    }\n\n    /**\n     * 企业付款\n     * @param string $openid 调用【网页授权获取用户信息】接口获取到用户在该公众号下的Openid\n     * @param float $totalFee 收款总费用 单位元\n     * @param string $outTradeNo 唯一的订单号\n     * @param string $orderName 订单名称\n     * @param string $notifyUrl 支付结果通知url 不要有问号\n     * @param string $timestamp 支付时间\n     * @return string\n     */\n    public function createJsBizPackage($openid, $totalFee, $outTradeNo,$trueName)\n    {\n        $config = array(\n            'mch_id' => $this->mchid,\n            'appid' => $this->appid,\n            'key' => $this->apiKey,\n        );\n        $unified = array(\n            'mch_appid' => $config['appid'],\n            'mchid' => $config['mch_id'],\n            'nonce_str' => self::createNonceStr(),\n            'openid' => $openid,\n            'check_name'=>'FORCE_CHECK',        //校验用户姓名选项。NO_CHECK：不校验真实姓名，FORCE_CHECK：强校验真实姓名\n            're_user_name'=>$trueName,                 //收款用户真实姓名（不支持给非实名用户打款）\n            'partner_trade_no' => $outTradeNo,\n            'spbill_create_ip' => '127.0.0.1',\n            'amount' => floatval($totalFee) * 100,       //单位 转为分\n            'desc'=>'付款',            //企业付款操作说明信息\n        );\n        $unified['sign'] = self::getSign($unified, $config['key']);\n        $responseXml = $this->curlPost('https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers', self::arrayToXml($unified));\n        $unifiedOrder = simplexml_load_string($responseXml, 'SimpleXMLElement', LIBXML_NOCDATA);\n        if ($unifiedOrder === false) {\n            die('parse xml error');\n        }\n        if ($unifiedOrder->return_code != 'SUCCESS') {\n            die($unifiedOrder->return_msg);\n        }\n        if ($unifiedOrder->result_code != 'SUCCESS') {\n            die($unifiedOrder->err_code);\n        }\n        return true;\n    }\n\n    public static function curlGet($url = '', $options = array())\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https请求 不验证证书和host\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array())\n    {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https请求 不验证证书和host\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        //第一种方法，cert 与 key 分别属于两个.pem文件\n        //默认格式为PEM，可以注释\n        curl_setopt($ch,CURLOPT_SSLCERTTYPE,'PEM');\n        curl_setopt($ch,CURLOPT_SSLCERT,getcwd().'/cert/apiclient_cert.pem');\n        //默认格式为PEM，可以注释\n        curl_setopt($ch,CURLOPT_SSLKEYTYPE,'PEM');\n        curl_setopt($ch,CURLOPT_SSLKEY,getcwd().'/cert/apiclient_key.pem');\n        //第二种方式，两个文件合成一个.pem文件\n//        curl_setopt($ch,CURLOPT_SSLCERT,getcwd().'/all.pem');\n        $data = curl_exec($ch);\n        if($data === false)\n        {\n            echo 'Curl error: ' . curl_error($ch);exit();\n        }        \n        curl_close($ch);\n        return $data;\n    }\n\n    public static function createNonceStr($length = 16)\n    {\n        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n        $str = '';\n        for ($i = 0; $i < $length; $i++) {\n            $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\n        }\n        return $str;\n    }\n    public static function arrayToXml($arr)\n    {\n        $xml = \"<xml>\";\n        foreach ($arr as $key => $val) {\n            if (is_numeric($val)) {\n                $xml .= \"<\" . $key . \">\" . $val . \"</\" . $key . \">\";\n            } else\n                $xml .= \"<\" . $key . \"><![CDATA[\" . $val . \"]]></\" . $key . \">\";\n        }\n        $xml .= \"</xml>\";\n        return $xml;\n    }\n\n    public static function getSign($params, $key)\n    {\n        ksort($params, SORT_STRING);\n        $unSignParaString = self::formatQueryParaMap($params, false);\n        $signStr = strtoupper(md5($unSignParaString . \"&key=\" . $key));\n        return $signStr;\n    }\n    protected static function formatQueryParaMap($paraMap, $urlEncode = false)\n    {\n        $buff = \"\";\n        ksort($paraMap);\n        foreach ($paraMap as $k => $v) {\n            if (null != $v && \"null\" != $v) {\n                if ($urlEncode) {\n                    $v = urlencode($v);\n                }\n                $buff .= $k . \"=\" . $v . \"&\";\n            }\n        }\n        $reqPar = '';\n        if (strlen($buff) > 0) {\n            $reqPar = substr($buff, 0, strlen($buff) - 1);\n        }\n        return $reqPar;\n    }\n}\n?>\n"
        }
      ]
    }
  ]
}