{
  "metadata": {
    "timestamp": 1736711927899,
    "page": 338,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/phpunit-bridge",
      "stars": 2455,
      "defaultBranch": "7.0",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1064453125,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.gitattributes export-ignore\n/.gitignore export-ignore\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.6982421875,
          "content": "CHANGELOG\n=========\n\n6.4\n---\n\n * Allow setting the locale using `SYMFONY_PHPUNIT_LOCALE` env var\n\n6.3\n---\n\n * Add support for mocking the `enum_exists` function\n * Enable reporting of deprecations triggered by Doctrine by default\n\n6.2\n---\n\n * Add support for mocking the `hrtime()` function\n\n6.1\n---\n\n * Add option `ignoreFile` to configure a file that lists deprecation messages to ignore\n\n6.0\n---\n\n * Remove `SetUpTearDownTrait`\n\n5.3\n---\n\n * bumped the minimum PHP version to 7.1.3\n * bumped the minimum PHPUnit version to 7.5\n * deprecated the `SetUpTearDownTrait` trait, use original methods with \"void\" return typehint.\n * added `logFile` option to write deprecations to a file instead of echoing them\n\n5.1.0\n-----\n\n * ignore verbosity settings when the build fails because of deprecations\n * added per-group verbosity\n * added `ExpectDeprecationTrait` to be able to define an expected deprecation from inside a test\n * deprecated the `@expectedDeprecation` annotation, use the `ExpectDeprecationTrait::expectDeprecation()` method instead\n\n5.0.0\n-----\n\n * removed `weak_vendor` mode, use `max[self]=0` instead\n\n4.4.0\n-----\n\n * made the bridge act as a polyfill for newest PHPUnit features\n * added `SetUpTearDownTrait` to allow working around the `void` return-type added by PHPUnit 8\n * added namespace aliases for PHPUnit < 6\n\n4.3.0\n-----\n\n * added `ClassExistsMock`\n * bumped PHP version from 5.3.3 to 5.5.9\n * split simple-phpunit bin into php file with code and a shell script\n\n4.1.0\n-----\n\n * Search for `SYMFONY_PHPUNIT_VERSION`, `SYMFONY_PHPUNIT_REMOVE`,\n   `SYMFONY_PHPUNIT_DIR` env var in `phpunit.xml` then in `phpunit.xml.dist`\n\n4.0.0\n-----\n\n * support for the `testLegacy` prefix in method names to mark a test as legacy\n   has been dropped, use the `@group legacy` notation instead\n * support for the `Legacy` prefix in class names to mark tests as legacy has\n   been dropped, use the `@group legacy` notation instead\n * support for passing an array of mocked namespaces not indexed by the mock\n   feature to the constructor of the `SymfonyTestsListenerTrait` class was\n   dropped\n\n3.4.0\n-----\n\n * added a `CoverageListener` to enhance the code coverage report\n * all deprecations but those from tests marked with `@group legacy` are always\n   displayed when not in `weak` mode\n\n3.3.0\n-----\n\n * using the `testLegacy` prefix in method names to mark a test as legacy is\n   deprecated, use the `@group legacy` notation instead\n * using the `Legacy` prefix in class names to mark a test as legacy is deprecated,\n   use the `@group legacy` notation instead\n\n3.1.0\n-----\n\n * passing a numerically indexed array to the constructor of the `SymfonyTestsListenerTrait`\n   is deprecated, pass an array of namespaces indexed by the mocked feature instead\n"
        },
        {
          "name": "ClassExistsMock.php",
          "type": "blob",
          "size": 2.86328125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bridge\\PhpUnit;\n\n/**\n * @author Roland Franssen <franssen.roland@gmail.com>\n */\nclass ClassExistsMock\n{\n    private static $classes = [];\n\n    private static $enums = [];\n\n    /**\n     * Configures the classes to be checked upon existence.\n     *\n     * @param array $classes Mocked class names as keys (case-sensitive, without leading root namespace slash) and booleans as values\n     */\n    public static function withMockedClasses(array $classes): void\n    {\n        self::$classes = $classes;\n    }\n\n    /**\n     * Configures the enums to be checked upon existence.\n     *\n     * @param array $enums Mocked enums names as keys (case-sensitive, without leading root namespace slash) and booleans as values\n     */\n    public static function withMockedEnums(array $enums): void\n    {\n        self::$enums = $enums;\n        self::$classes += $enums;\n    }\n\n    public static function class_exists($name, $autoload = true): bool\n    {\n        $name = ltrim($name, '\\\\');\n\n        return isset(self::$classes[$name]) ? (bool) self::$classes[$name] : \\class_exists($name, $autoload);\n    }\n\n    public static function interface_exists($name, $autoload = true): bool\n    {\n        $name = ltrim($name, '\\\\');\n\n        return isset(self::$classes[$name]) ? (bool) self::$classes[$name] : \\interface_exists($name, $autoload);\n    }\n\n    public static function trait_exists($name, $autoload = true): bool\n    {\n        $name = ltrim($name, '\\\\');\n\n        return isset(self::$classes[$name]) ? (bool) self::$classes[$name] : \\trait_exists($name, $autoload);\n    }\n\n    public static function enum_exists($name, $autoload = true):bool\n    {\n        $name = ltrim($name, '\\\\');\n\n        return isset(self::$enums[$name]) ? (bool) self::$enums[$name] : \\enum_exists($name, $autoload);\n    }\n\n    public static function register($class): void\n    {\n        $self = static::class;\n\n        $mockedNs = [substr($class, 0, strrpos($class, '\\\\'))];\n        if (0 < strpos($class, '\\\\Tests\\\\')) {\n            $ns = str_replace('\\\\Tests\\\\', '\\\\', $class);\n            $mockedNs[] = substr($ns, 0, strrpos($ns, '\\\\'));\n        } elseif (0 === strpos($class, 'Tests\\\\')) {\n            $mockedNs[] = substr($class, 6, strrpos($class, '\\\\') - 6);\n        }\n        foreach ($mockedNs as $ns) {\n            foreach (['class', 'interface', 'trait', 'enum'] as $type) {\n                if (\\function_exists($ns.'\\\\'.$type.'_exists')) {\n                    continue;\n                }\n                eval(<<<EOPHP\nnamespace $ns;\n\nfunction {$type}_exists(\\$name, \\$autoload = true)\n{\n    return \\\\$self::{$type}_exists(\\$name, \\$autoload);\n}\n\nEOPHP\n                );\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "ClockMock.php",
          "type": "blob",
          "size": 3.494140625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bridge\\PhpUnit;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n * @author Dominic Tubach <dominic.tubach@to.com>\n */\nclass ClockMock\n{\n    private static $now;\n\n    public static function withClockMock($enable = null): ?bool\n    {\n        if (null === $enable) {\n            return null !== self::$now;\n        }\n\n        self::$now = is_numeric($enable) ? (float) $enable : ($enable ? microtime(true) : null);\n\n        return null;\n    }\n\n    public static function time(): int\n    {\n        if (null === self::$now) {\n            return \\time();\n        }\n\n        return (int) self::$now;\n    }\n\n    public static function sleep($s): int\n    {\n        if (null === self::$now) {\n            return \\sleep($s);\n        }\n\n        self::$now += (int) $s;\n\n        return 0;\n    }\n\n    public static function usleep($us): void\n    {\n        if (null === self::$now) {\n            \\usleep($us);\n        } else {\n            self::$now += $us / 1000000;\n        }\n    }\n\n    /**\n     * @return string|float\n     */\n    public static function microtime($asFloat = false)\n    {\n        if (null === self::$now) {\n            return \\microtime($asFloat);\n        }\n\n        if ($asFloat) {\n            return self::$now;\n        }\n\n        return sprintf('%0.6f00 %d', self::$now - (int) self::$now, (int) self::$now);\n    }\n\n    public static function date($format, $timestamp = null): string\n    {\n        if (null === $timestamp) {\n            $timestamp = self::time();\n        }\n\n        return \\date($format, $timestamp);\n    }\n\n    public static function gmdate($format, $timestamp = null): string\n    {\n        if (null === $timestamp) {\n            $timestamp = self::time();\n        }\n\n        return \\gmdate($format, $timestamp);\n    }\n\n    /**\n     * @return array|int|float\n     */\n    public static function hrtime($asNumber = false)\n    {\n        $ns = (self::$now - (int) self::$now) * 1000000000;\n\n        if ($asNumber) {\n            $number = sprintf('%d%d', (int) self::$now, $ns);\n\n            return \\PHP_INT_SIZE === 8 ? (int) $number : (float) $number;\n        }\n\n        return [(int) self::$now, (int) $ns];\n    }\n\n    public static function register($class): void\n    {\n        $self = static::class;\n\n        $mockedNs = [substr($class, 0, strrpos($class, '\\\\'))];\n        if (0 < strpos($class, '\\\\Tests\\\\')) {\n            $ns = str_replace('\\\\Tests\\\\', '\\\\', $class);\n            $mockedNs[] = substr($ns, 0, strrpos($ns, '\\\\'));\n        } elseif (0 === strpos($class, 'Tests\\\\')) {\n            $mockedNs[] = substr($class, 6, strrpos($class, '\\\\') - 6);\n        }\n        foreach ($mockedNs as $ns) {\n            if (\\function_exists($ns.'\\time')) {\n                continue;\n            }\n            eval(<<<EOPHP\nnamespace $ns;\n\nfunction time()\n{\n    return \\\\$self::time();\n}\n\nfunction microtime(\\$asFloat = false)\n{\n    return \\\\$self::microtime(\\$asFloat);\n}\n\nfunction sleep(\\$s)\n{\n    return \\\\$self::sleep(\\$s);\n}\n\nfunction usleep(\\$us)\n{\n    \\\\$self::usleep(\\$us);\n}\n\nfunction date(\\$format, \\$timestamp = null)\n{\n    return \\\\$self::date(\\$format, \\$timestamp);\n}\n\nfunction gmdate(\\$format, \\$timestamp = null)\n{\n    return \\\\$self::gmdate(\\$format, \\$timestamp);\n}\n\nfunction hrtime(\\$asNumber = false)\n{\n    return \\\\$self::hrtime(\\$asNumber);\n}\nEOPHP\n            );\n        }\n    }\n}\n"
        },
        {
          "name": "ConstraintTrait.php",
          "type": "blob",
          "size": 0.703125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bridge\\PhpUnit;\n\nuse PHPUnit\\Framework\\Constraint\\Constraint;\n\n$r = new \\ReflectionClass(Constraint::class);\nif ($r->getProperty('exporter')->isProtected()) {\n    trait ConstraintTrait\n    {\n        use Legacy\\ConstraintTraitForV7;\n    }\n} elseif (!$r->getMethod('evaluate')->hasReturnType()) {\n    trait ConstraintTrait\n    {\n        use Legacy\\ConstraintTraitForV8;\n    }\n} else {\n    trait ConstraintTrait\n    {\n        use Legacy\\ConstraintTraitForV9;\n    }\n}\n"
        },
        {
          "name": "CoverageListener.php",
          "type": "blob",
          "size": 3.5927734375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bridge\\PhpUnit;\n\nuse PHPUnit\\Framework\\Test;\nuse PHPUnit\\Framework\\TestCase;\nuse PHPUnit\\Framework\\TestListener;\nuse PHPUnit\\Framework\\TestListenerDefaultImplementation;\nuse PHPUnit\\Framework\\Warning;\nuse PHPUnit\\Util\\Annotation\\Registry;\nuse PHPUnit\\Util\\Test as TestUtil;\n\nclass CoverageListener implements TestListener\n{\n    use TestListenerDefaultImplementation;\n\n    private $sutFqcnResolver;\n    private $warningOnSutNotFound;\n\n    public function __construct(?callable $sutFqcnResolver = null, bool $warningOnSutNotFound = false)\n    {\n        $this->sutFqcnResolver = $sutFqcnResolver ?? static function (Test $test): ?string {\n            $class = \\get_class($test);\n\n            $sutFqcn = str_replace('\\\\Tests\\\\', '\\\\', $class);\n            $sutFqcn = preg_replace('{Test$}', '', $sutFqcn);\n\n            return class_exists($sutFqcn) ? $sutFqcn : null;\n        };\n\n        $this->warningOnSutNotFound = $warningOnSutNotFound;\n    }\n\n    public function startTest(Test $test): void\n    {\n        if (!$test instanceof TestCase) {\n            return;\n        }\n\n        $annotations = TestUtil::parseTestMethodAnnotations(\\get_class($test), $test->getName(false));\n\n        $ignoredAnnotations = ['covers', 'coversDefaultClass', 'coversNothing'];\n\n        foreach ($ignoredAnnotations as $annotation) {\n            if (isset($annotations['class'][$annotation]) || isset($annotations['method'][$annotation])) {\n                return;\n            }\n        }\n\n        $sutFqcn = ($this->sutFqcnResolver)($test);\n        if (!$sutFqcn) {\n            if ($this->warningOnSutNotFound) {\n                $test->getTestResultObject()->addWarning($test, new Warning('Could not find the tested class.'), 0);\n            }\n\n            return;\n        }\n\n        $covers = $sutFqcn;\n        if (!\\is_array($sutFqcn)) {\n            $covers = [$sutFqcn];\n            while ($parent = get_parent_class($sutFqcn)) {\n                $covers[] = $parent;\n                $sutFqcn = $parent;\n            }\n        }\n\n        if (class_exists(Registry::class)) {\n            $this->addCoversForDocBlockInsideRegistry($test, $covers);\n\n            return;\n        }\n\n        $this->addCoversForClassToAnnotationCache($test, $covers);\n    }\n\n    private function addCoversForClassToAnnotationCache(Test $test, array $covers): void\n    {\n        $r = new \\ReflectionProperty(TestUtil::class, 'annotationCache');\n        $r->setAccessible(true);\n\n        $cache = $r->getValue();\n        $cache = array_replace_recursive($cache, [\n            \\get_class($test) => [\n                'covers' => $covers,\n            ],\n        ]);\n\n        $r->setValue(TestUtil::class, $cache);\n    }\n\n    private function addCoversForDocBlockInsideRegistry(Test $test, array $covers): void\n    {\n        $docBlock = Registry::getInstance()->forClassName(\\get_class($test));\n\n        $symbolAnnotations = new \\ReflectionProperty($docBlock, 'symbolAnnotations');\n        $symbolAnnotations->setAccessible(true);\n\n        // Exclude internal classes; PHPUnit 9.1+ is picky about tests covering, say, a \\RuntimeException\n        $covers = array_filter($covers, function (string $class) {\n            $reflector = new \\ReflectionClass($class);\n\n            return $reflector->isUserDefined();\n        });\n\n        $symbolAnnotations->setValue($docBlock, array_replace($docBlock->symbolAnnotations(), [\n            'covers' => $covers,\n        ]));\n    }\n}\n"
        },
        {
          "name": "DeprecationErrorHandler.php",
          "type": "blob",
          "size": 15.5703125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bridge\\PhpUnit;\n\nuse PHPUnit\\Framework\\TestCase;\nuse PHPUnit\\Framework\\TestResult;\nuse PHPUnit\\Runner\\ErrorHandler;\nuse PHPUnit\\Util\\Error\\Handler;\nuse PHPUnit\\Util\\ErrorHandler as UtilErrorHandler;\nuse Symfony\\Bridge\\PhpUnit\\DeprecationErrorHandler\\Configuration;\nuse Symfony\\Bridge\\PhpUnit\\DeprecationErrorHandler\\Deprecation;\nuse Symfony\\Bridge\\PhpUnit\\DeprecationErrorHandler\\DeprecationGroup;\nuse Symfony\\Component\\ErrorHandler\\DebugClassLoader;\n\n/**\n * Catch deprecation notices and print a summary report at the end of the test suite.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass DeprecationErrorHandler\n{\n    public const MODE_DISABLED = 'disabled';\n    public const MODE_WEAK = 'max[total]=999999&verbose=0';\n    public const MODE_STRICT = 'max[total]=0';\n\n    private $mode;\n    private $configuration;\n\n    /**\n     * @var DeprecationGroup[]\n     */\n    private $deprecationGroups = [];\n\n    private static $isRegistered = false;\n    private static $errorHandler;\n\n    public function __construct()\n    {\n        $this->resetDeprecationGroups();\n    }\n\n    /**\n     * Registers and configures the deprecation handler.\n     *\n     * The mode is a query string with options:\n     *  - \"disabled\" to enable/disable the deprecation handler\n     *  - \"verbose\" to enable/disable displaying the deprecation report\n     *  - \"quiet\" to disable displaying the deprecation report only for some groups (i.e. quiet[]=other)\n     *  - \"max\" to configure the number of deprecations to allow before exiting with a non-zero\n     *    status code; it's an array with keys \"total\", \"self\", \"direct\" and \"indirect\"\n     *\n     * The default mode is \"max[total]=0&verbose=1\".\n     *\n     * The mode can alternatively be \"/some-regexp/\" to stop the test suite whenever\n     * a deprecation message matches the given regular expression.\n     *\n     * @param int|string|false $mode The reporting mode, defaults to not allowing any deprecations\n     */\n    public static function register($mode = 0)\n    {\n        if (self::$isRegistered) {\n            return;\n        }\n\n        $handler = new self();\n        $oldErrorHandler = set_error_handler([$handler, 'handleError']);\n\n        if (null !== $oldErrorHandler) {\n            restore_error_handler();\n\n            if (\n                $oldErrorHandler instanceof UtilErrorHandler\n                || [UtilErrorHandler::class, 'handleError'] === $oldErrorHandler\n                || $oldErrorHandler instanceof ErrorHandler\n                || [ErrorHandler::class, 'handleError'] === $oldErrorHandler\n            ) {\n                restore_error_handler();\n                self::register($mode);\n            }\n        } else {\n            $handler->mode = $mode;\n            self::$isRegistered = true;\n            register_shutdown_function([$handler, 'shutdown']);\n        }\n    }\n\n    public static function collectDeprecations($outputFile)\n    {\n        $deprecations = [];\n        $previousErrorHandler = set_error_handler(function ($type, $msg, $file, $line, $context = []) use (&$deprecations, &$previousErrorHandler) {\n            if (\\E_USER_DEPRECATED !== $type && \\E_DEPRECATED !== $type && (\\E_WARNING !== $type || false === strpos($msg, '\" targeting switch is equivalent to \"break'))) {\n                if ($previousErrorHandler) {\n                    return $previousErrorHandler($type, $msg, $file, $line, $context);\n                }\n\n                return \\call_user_func(self::getPhpUnitErrorHandler(), $type, $msg, $file, $line, $context);\n            }\n\n            $filesStack = [];\n            foreach (debug_backtrace() as $frame) {\n                if (!isset($frame['file']) || \\in_array($frame['function'], ['require', 'require_once', 'include', 'include_once'], true)) {\n                    continue;\n                }\n\n                $filesStack[] = $frame['file'];\n            }\n\n            $deprecations[] = [error_reporting() & $type, $msg, $file, $filesStack];\n\n            return null;\n        });\n\n        register_shutdown_function(function () use ($outputFile, &$deprecations) {\n            file_put_contents($outputFile, serialize($deprecations));\n        });\n    }\n\n    /**\n     * @internal\n     */\n    public function handleError($type, $msg, $file, $line, $context = [])\n    {\n        if ((\\E_USER_DEPRECATED !== $type && \\E_DEPRECATED !== $type && (\\E_WARNING !== $type || false === strpos($msg, '\" targeting switch is equivalent to \"break'))) || !$this->getConfiguration()->isEnabled()) {\n            return \\call_user_func(self::getPhpUnitErrorHandler(), $type, $msg, $file, $line, $context);\n        }\n\n        $trace = debug_backtrace();\n\n        if (isset($trace[1]['function'], $trace[1]['args'][0]) && ('trigger_error' === $trace[1]['function'] || 'user_error' === $trace[1]['function'])) {\n            $msg = $trace[1]['args'][0];\n        }\n\n        $deprecation = new Deprecation($msg, $trace, $file, \\E_DEPRECATED === $type);\n        if ($deprecation->isMuted()) {\n            return null;\n        }\n        if ($this->getConfiguration()->isIgnoredDeprecation($deprecation)) {\n            return null;\n        }\n        if ($this->getConfiguration()->isBaselineDeprecation($deprecation)) {\n            return null;\n        }\n\n        $msg = $deprecation->getMessage();\n\n        if (\\E_DEPRECATED !== $type && (error_reporting() & $type)) {\n            $group = 'unsilenced';\n        } elseif ($deprecation->isLegacy()) {\n            $group = 'legacy';\n        } else {\n            $group = [\n                Deprecation::TYPE_SELF => 'self',\n                Deprecation::TYPE_DIRECT => 'direct',\n                Deprecation::TYPE_INDIRECT => 'indirect',\n                Deprecation::TYPE_UNDETERMINED => 'other',\n            ][$deprecation->getType()];\n        }\n\n        if ($this->getConfiguration()->shouldDisplayStackTrace($msg)) {\n            echo \"\\n\".ucfirst($group).' '.$deprecation->toString();\n\n            exit(1);\n        }\n\n        if ('legacy' === $group) {\n            $this->deprecationGroups[$group]->addNotice();\n        } elseif ($deprecation->originatesFromAnObject()) {\n            $class = $deprecation->originatingClass();\n            $method = $deprecation->originatingMethod();\n            $this->deprecationGroups[$group]->addNoticeFromObject($msg, $class, $method);\n        } else {\n            $this->deprecationGroups[$group]->addNoticeFromProceduralCode($msg);\n        }\n\n        return null;\n    }\n\n    /**\n     * @internal\n     */\n    public function shutdown()\n    {\n        $configuration = $this->getConfiguration();\n\n        if ($configuration->isInRegexMode()) {\n            return;\n        }\n\n        if (class_exists(DebugClassLoader::class, false)) {\n            DebugClassLoader::checkClasses();\n        }\n        $currErrorHandler = set_error_handler('is_int');\n        restore_error_handler();\n\n        if ($currErrorHandler !== [$this, 'handleError']) {\n            echo \"\\n\", self::colorize('THE ERROR HANDLER HAS CHANGED!', true), \"\\n\";\n        }\n\n        $groups = array_keys($this->deprecationGroups);\n\n        // store failing status\n        $isFailing = !$configuration->tolerates($this->deprecationGroups);\n\n        $this->displayDeprecations($groups, $configuration);\n\n        $this->resetDeprecationGroups();\n\n        register_shutdown_function(function () use ($isFailing, $groups, $configuration) {\n            foreach ($this->deprecationGroups as $group) {\n                if ($group->count() > 0) {\n                    echo \"Shutdown-time deprecations:\\n\";\n                    break;\n                }\n            }\n\n            $isFailingAtShutdown = !$configuration->tolerates($this->deprecationGroups);\n            $this->displayDeprecations($groups, $configuration);\n\n            if ($configuration->isGeneratingBaseline()) {\n                $configuration->writeBaseline();\n            }\n\n            if ($isFailing || $isFailingAtShutdown) {\n                exit(1);\n            }\n        });\n    }\n\n    private function resetDeprecationGroups()\n    {\n        $this->deprecationGroups = [\n            'unsilenced' => new DeprecationGroup(),\n            'self' => new DeprecationGroup(),\n            'direct' => new DeprecationGroup(),\n            'indirect' => new DeprecationGroup(),\n            'legacy' => new DeprecationGroup(),\n            'other' => new DeprecationGroup(),\n        ];\n    }\n\n    private function getConfiguration()\n    {\n        if (null !== $this->configuration) {\n            return $this->configuration;\n        }\n        if (false === $mode = $this->mode) {\n            $mode = $_SERVER['SYMFONY_DEPRECATIONS_HELPER'] ?? $_ENV['SYMFONY_DEPRECATIONS_HELPER'] ?? getenv('SYMFONY_DEPRECATIONS_HELPER');\n        }\n        if ('strict' === $mode) {\n            return $this->configuration = Configuration::inStrictMode();\n        }\n        if (self::MODE_DISABLED === $mode) {\n            return $this->configuration = Configuration::inDisabledMode();\n        }\n        if ('weak' === $mode) {\n            return $this->configuration = Configuration::inWeakMode();\n        }\n        if (isset($mode[0]) && '/' === $mode[0]) {\n            return $this->configuration = Configuration::fromRegex($mode);\n        }\n\n        if (preg_match('/^[1-9][0-9]*$/', (string) $mode)) {\n            return $this->configuration = Configuration::fromNumber($mode);\n        }\n\n        if (!$mode) {\n            return $this->configuration = Configuration::fromNumber(0);\n        }\n\n        return $this->configuration = Configuration::fromUrlEncodedString((string) $mode);\n    }\n\n    private static function colorize(string $str, bool $red): string\n    {\n        if (!self::hasColorSupport()) {\n            return $str;\n        }\n\n        $color = $red ? '41;37' : '43;30';\n\n        return \"\\x1B[{$color}m{$str}\\x1B[0m\";\n    }\n\n    /**\n     * @param string[] $groups\n     */\n    private function displayDeprecations(array $groups, Configuration $configuration): void\n    {\n        $cmp = function ($a, $b) {\n            return $b->count() - $a->count();\n        };\n\n        if ($configuration->shouldWriteToLogFile()) {\n            if (false === $handle = @fopen($file = $configuration->getLogFile(), 'a')) {\n                throw new \\InvalidArgumentException(sprintf('The configured log file \"%s\" is not writeable.', $file));\n            }\n        } else {\n            $handle = fopen('php://output', 'w');\n        }\n\n        foreach ($groups as $group) {\n            if ($this->deprecationGroups[$group]->count()) {\n                $deprecationGroupMessage = sprintf(\n                    '%s deprecation notices (%d)',\n                    \\in_array($group, ['direct', 'indirect', 'self'], true) ? \"Remaining $group\" : ucfirst($group),\n                    $this->deprecationGroups[$group]->count()\n                );\n                if ($configuration->shouldWriteToLogFile()) {\n                    fwrite($handle, \"\\n$deprecationGroupMessage\\n\");\n                } else {\n                    fwrite($handle, \"\\n\".self::colorize($deprecationGroupMessage, 'legacy' !== $group && 'indirect' !== $group).\"\\n\");\n                }\n\n                // Skip the verbose output if the group is quiet and not failing according to its threshold:\n                if ('legacy' !== $group && !$configuration->verboseOutput($group) && $configuration->toleratesForGroup($group, $this->deprecationGroups)) {\n                    continue;\n                }\n                $notices = $this->deprecationGroups[$group]->notices();\n                uasort($notices, $cmp);\n\n                foreach ($notices as $msg => $notice) {\n                    fwrite($handle, sprintf(\"\\n  %sx: %s\\n\", $notice->count(), $msg));\n\n                    $countsByCaller = $notice->getCountsByCaller();\n                    arsort($countsByCaller);\n                    $limit = 5;\n\n                    foreach ($countsByCaller as $method => $count) {\n                        if ('count' !== $method) {\n                            if (!$limit--) {\n                                fwrite($handle, \"    ...\\n\");\n                                break;\n                            }\n                            fwrite($handle, sprintf(\"    %dx in %s\\n\", $count, preg_replace('/(.*)\\\\\\\\(.*?::.*?)$/', '$2 from $1', $method)));\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!empty($notices)) {\n            fwrite($handle, \"\\n\");\n        }\n    }\n\n    private static function getPhpUnitErrorHandler(): callable\n    {\n        if (!$eh = self::$errorHandler) {\n            if (class_exists(Handler::class)) {\n                $eh = self::$errorHandler = Handler::class;\n            } elseif (method_exists(UtilErrorHandler::class, '__invoke')) {\n                $eh = self::$errorHandler = UtilErrorHandler::class;\n            } elseif (method_exists(ErrorHandler::class, '__invoke')) {\n                $eh = self::$errorHandler = ErrorHandler::class;\n            } else {\n                return self::$errorHandler = 'PHPUnit\\Util\\ErrorHandler::handleError';\n            }\n        }\n\n        if ('PHPUnit\\Util\\ErrorHandler::handleError' === $eh) {\n            return $eh;\n        }\n\n        foreach (debug_backtrace(\\DEBUG_BACKTRACE_PROVIDE_OBJECT | \\DEBUG_BACKTRACE_IGNORE_ARGS) as $frame) {\n            if (!isset($frame['object'])) {\n                continue;\n            }\n\n            if ($frame['object'] instanceof TestResult) {\n                return new $eh(\n                    $frame['object']->getConvertDeprecationsToExceptions(),\n                    $frame['object']->getConvertErrorsToExceptions(),\n                    $frame['object']->getConvertNoticesToExceptions(),\n                    $frame['object']->getConvertWarningsToExceptions()\n                );\n            } elseif (ErrorHandler::class === $eh && $frame['object'] instanceof TestCase) {\n                return function (int $errorNumber, string $errorString, string $errorFile, int $errorLine) {\n                    ErrorHandler::instance()($errorNumber, $errorString, $errorFile, $errorLine);\n\n                    return true;\n                };\n            }\n        }\n\n        return function () { return false; };\n    }\n\n    /**\n     * Returns true if STDOUT is defined and supports colorization.\n     *\n     * Reference: Composer\\XdebugHandler\\Process::supportsColor\n     * https://github.com/composer/xdebug-handler\n     */\n    private static function hasColorSupport(): bool\n    {\n        if (!\\defined('STDOUT')) {\n            return false;\n        }\n\n        // Follow https://no-color.org/\n        if ('' !== ($_SERVER['NO_COLOR'] ?? getenv('NO_COLOR') ?: '')) {\n            return false;\n        }\n\n        // Detect msysgit/mingw and assume this is a tty because detection\n        // does not work correctly, see https://github.com/composer/composer/issues/9690\n        if (!@stream_isatty(\\STDOUT) && !\\in_array(strtoupper((string) getenv('MSYSTEM')), ['MINGW32', 'MINGW64'], true)) {\n            return false;\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR && @sapi_windows_vt100_support(\\STDOUT)) {\n            return true;\n        }\n\n        if ('Hyper' === getenv('TERM_PROGRAM')\n            || false !== getenv('COLORTERM')\n            || false !== getenv('ANSICON')\n            || 'ON' === getenv('ConEmuANSI')\n        ) {\n            return true;\n        }\n\n        if ('dumb' === $term = (string) getenv('TERM')) {\n            return false;\n        }\n\n        // See https://github.com/chalk/supports-color/blob/d4f413efaf8da045c5ab440ed418ef02dbb28bf1/index.js#L157\n        return preg_match('/^((screen|xterm|vt100|vt220|putty|rxvt|ansi|cygwin|linux).*)|(.*-256(color)?(-bce)?)$/', $term);\n    }\n}\n"
        },
        {
          "name": "DeprecationErrorHandler",
          "type": "tree",
          "content": null
        },
        {
          "name": "DnsMock.php",
          "type": "blob",
          "size": 5.8671875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bridge\\PhpUnit;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass DnsMock\n{\n    private static $hosts = [];\n    private static $dnsTypes = [\n        'A' => \\DNS_A,\n        'MX' => \\DNS_MX,\n        'NS' => \\DNS_NS,\n        'SOA' => \\DNS_SOA,\n        'PTR' => \\DNS_PTR,\n        'CNAME' => \\DNS_CNAME,\n        'AAAA' => \\DNS_AAAA,\n        'A6' => \\DNS_A6,\n        'SRV' => \\DNS_SRV,\n        'NAPTR' => \\DNS_NAPTR,\n        'TXT' => \\DNS_TXT,\n        'HINFO' => \\DNS_HINFO,\n    ];\n\n    /**\n     * Configures the mock values for DNS queries.\n     *\n     * @param array $hosts Mocked hosts as keys, arrays of DNS records as returned by dns_get_record() as values\n     */\n    public static function withMockedHosts(array $hosts): void\n    {\n        self::$hosts = $hosts;\n    }\n\n    public static function checkdnsrr($hostname, $type = 'MX'): bool\n    {\n        if (!self::$hosts) {\n            return \\checkdnsrr($hostname, $type);\n        }\n        if (isset(self::$hosts[$hostname])) {\n            $type = strtoupper($type);\n\n            foreach (self::$hosts[$hostname] as $record) {\n                if ($record['type'] === $type) {\n                    return true;\n                }\n                if ('ANY' === $type && isset(self::$dnsTypes[$record['type']]) && 'HINFO' !== $record['type']) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static function getmxrr($hostname, &$mxhosts, &$weight = null): bool\n    {\n        if (!self::$hosts) {\n            return \\getmxrr($hostname, $mxhosts, $weight);\n        }\n        $mxhosts = $weight = [];\n\n        if (isset(self::$hosts[$hostname])) {\n            foreach (self::$hosts[$hostname] as $record) {\n                if ('MX' === $record['type']) {\n                    $mxhosts[] = $record['host'];\n                    $weight[] = $record['pri'];\n                }\n            }\n        }\n\n        return (bool) $mxhosts;\n    }\n\n    public static function gethostbyaddr($ipAddress)\n    {\n        if (!self::$hosts) {\n            return \\gethostbyaddr($ipAddress);\n        }\n        foreach (self::$hosts as $hostname => $records) {\n            foreach ($records as $record) {\n                if ('A' === $record['type'] && $ipAddress === $record['ip']) {\n                    return $hostname;\n                }\n                if ('AAAA' === $record['type'] && $ipAddress === $record['ipv6']) {\n                    return $hostname;\n                }\n            }\n        }\n\n        return $ipAddress;\n    }\n\n    public static function gethostbyname($hostname)\n    {\n        if (!self::$hosts) {\n            return \\gethostbyname($hostname);\n        }\n        if (isset(self::$hosts[$hostname])) {\n            foreach (self::$hosts[$hostname] as $record) {\n                if ('A' === $record['type']) {\n                    return $record['ip'];\n                }\n            }\n        }\n\n        return $hostname;\n    }\n\n    public static function gethostbynamel($hostname)\n    {\n        if (!self::$hosts) {\n            return \\gethostbynamel($hostname);\n        }\n        $ips = false;\n\n        if (isset(self::$hosts[$hostname])) {\n            $ips = [];\n\n            foreach (self::$hosts[$hostname] as $record) {\n                if ('A' === $record['type']) {\n                    $ips[] = $record['ip'];\n                }\n            }\n        }\n\n        return $ips;\n    }\n\n    public static function dns_get_record($hostname, $type = \\DNS_ANY, &$authns = null, &$addtl = null, $raw = false)\n    {\n        if (!self::$hosts) {\n            return \\dns_get_record($hostname, $type, $authns, $addtl, $raw);\n        }\n\n        $records = false;\n\n        if (isset(self::$hosts[$hostname])) {\n            if (\\DNS_ANY === $type) {\n                $type = \\DNS_ALL;\n            }\n            $records = [];\n\n            foreach (self::$hosts[$hostname] as $record) {\n                if ((self::$dnsTypes[$record['type']] ?? 0) & $type) {\n                    $records[] = array_merge(['host' => $hostname, 'class' => 'IN', 'ttl' => 1, 'type' => $record['type']], $record);\n                }\n            }\n        }\n\n        return $records;\n    }\n\n    public static function register($class): void\n    {\n        $self = static::class;\n\n        $mockedNs = [substr($class, 0, strrpos($class, '\\\\'))];\n        if (0 < strpos($class, '\\\\Tests\\\\')) {\n            $ns = str_replace('\\\\Tests\\\\', '\\\\', $class);\n            $mockedNs[] = substr($ns, 0, strrpos($ns, '\\\\'));\n        } elseif (0 === strpos($class, 'Tests\\\\')) {\n            $mockedNs[] = substr($class, 6, strrpos($class, '\\\\') - 6);\n        }\n        foreach ($mockedNs as $ns) {\n            if (\\function_exists($ns.'\\checkdnsrr')) {\n                continue;\n            }\n            eval(<<<EOPHP\nnamespace $ns;\n\nfunction checkdnsrr(\\$host, \\$type = 'MX')\n{\n    return \\\\$self::checkdnsrr(\\$host, \\$type);\n}\n\nfunction dns_check_record(\\$host, \\$type = 'MX')\n{\n    return \\\\$self::checkdnsrr(\\$host, \\$type);\n}\n\nfunction getmxrr(\\$hostname, &\\$mxhosts, &\\$weight = null)\n{\n    return \\\\$self::getmxrr(\\$hostname, \\$mxhosts, \\$weight);\n}\n\nfunction dns_get_mx(\\$hostname, &\\$mxhosts, &\\$weight = null)\n{\n    return \\\\$self::getmxrr(\\$hostname, \\$mxhosts, \\$weight);\n}\n\nfunction gethostbyaddr(\\$ipAddress)\n{\n    return \\\\$self::gethostbyaddr(\\$ipAddress);\n}\n\nfunction gethostbyname(\\$hostname)\n{\n    return \\\\$self::gethostbyname(\\$hostname);\n}\n\nfunction gethostbynamel(\\$hostname)\n{\n    return \\\\$self::gethostbynamel(\\$hostname);\n}\n\nfunction dns_get_record(\\$hostname, \\$type = DNS_ANY, &\\$authns = null, &\\$addtl = null, \\$raw = false)\n{\n    return \\\\$self::dns_get_record(\\$hostname, \\$type, \\$authns, \\$addtl, \\$raw);\n}\n\nEOPHP\n            );\n        }\n    }\n}\n"
        },
        {
          "name": "ExpectDeprecationTrait.php",
          "type": "blob",
          "size": 0.71875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bridge\\PhpUnit;\n\nuse Symfony\\Bridge\\PhpUnit\\Legacy\\ExpectDeprecationTraitBeforeV8_4;\nuse Symfony\\Bridge\\PhpUnit\\Legacy\\ExpectDeprecationTraitForV8_4;\n\nif (version_compare(\\PHPUnit\\Runner\\Version::id(), '8.4.0', '<')) {\n    trait ExpectDeprecationTrait\n    {\n        use ExpectDeprecationTraitBeforeV8_4;\n    }\n} else {\n    /**\n     * @method void expectDeprecation(string $message)\n     */\n    trait ExpectDeprecationTrait\n    {\n        use ExpectDeprecationTraitForV8_4;\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2014-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Legacy",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.5244140625,
          "content": "PHPUnit Bridge\n==============\n\nThe PHPUnit bridge provides utilities for [PHPUnit](https://phpunit.de/),\nespecially user deprecation notices management.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/phpunit_bridge.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "SymfonyTestsListener.php",
          "type": "blob",
          "size": 0.4404296875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bridge\\PhpUnit;\n\nclass_alias('Symfony\\Bridge\\PhpUnit\\Legacy\\SymfonyTestsListenerForV7', 'Symfony\\Bridge\\PhpUnit\\SymfonyTestsListener');\n\nif (false) {\n    class SymfonyTestsListener\n    {\n    }\n}\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "TextUI",
          "type": "tree",
          "content": null
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "bootstrap.php",
          "type": "blob",
          "size": 1.7109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Doctrine\\Common\\Annotations\\AnnotationRegistry;\nuse Doctrine\\Deprecations\\Deprecation;\nuse Symfony\\Bridge\\PhpUnit\\DeprecationErrorHandler;\n\n// Detect if we need to serialize deprecations to a file.\nif (in_array(\\PHP_SAPI, ['cli', 'phpdbg'], true) && $file = getenv('SYMFONY_DEPRECATIONS_SERIALIZE')) {\n    DeprecationErrorHandler::collectDeprecations($file);\n\n    return;\n}\n\n// Detect if we're loaded by an actual run of phpunit\nif (!defined('PHPUNIT_COMPOSER_INSTALL') && !class_exists(\\PHPUnit\\TextUI\\Command::class, false)) {\n    return;\n}\n\nif (isset($fileIdentifier)) {\n    unset($GLOBALS['__composer_autoload_files'][$fileIdentifier]);\n}\n\nif (class_exists(Deprecation::class)) {\n    Deprecation::withoutDeduplication();\n\n    if (\\PHP_VERSION_ID < 80000) {\n        // Ignore deprecations about the annotation mapping driver when it's not possible to move to the attribute driver yet\n        Deprecation::ignoreDeprecations('https://github.com/doctrine/orm/issues/10098');\n    }\n}\n\nif (!class_exists(AnnotationRegistry::class, false) && class_exists(AnnotationRegistry::class)) {\n    if (method_exists(AnnotationRegistry::class, 'registerUniqueLoader')) {\n        AnnotationRegistry::registerUniqueLoader('class_exists');\n    } elseif (method_exists(AnnotationRegistry::class, 'registerLoader')) {\n        AnnotationRegistry::registerLoader('class_exists');\n    }\n}\n\nif ('disabled' !== getenv('SYMFONY_DEPRECATIONS_HELPER')) {\n    DeprecationErrorHandler::register(getenv('SYMFONY_DEPRECATIONS_HELPER'));\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.3349609375,
          "content": "{\n    \"name\": \"symfony/phpunit-bridge\",\n    \"type\": \"symfony-bridge\",\n    \"description\": \"Provides utilities for PHPUnit, especially user deprecation notices management\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Nicolas Grekas\",\n            \"email\": \"p@tchwork.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=7.2.5 EVEN ON LATEST SYMFONY VERSIONS TO ALLOW USING\",\n        \"php\": \"THIS BRIDGE WHEN TESTING LOWEST SYMFONY VERSIONS.\",\n        \"php\": \">=7.2.5\"\n    },\n    \"require-dev\": {\n        \"symfony/deprecation-contracts\": \"^2.5|^3.0\",\n        \"symfony/error-handler\": \"^5.4|^6.4|^7.0\",\n        \"symfony/polyfill-php81\": \"^1.27\"\n    },\n    \"conflict\": {\n        \"phpunit/phpunit\": \"<7.5|9.1.2\"\n    },\n    \"autoload\": {\n        \"files\": [ \"bootstrap.php\" ],\n        \"psr-4\": { \"Symfony\\\\Bridge\\\\PhpUnit\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\",\n            \"/bin/\"\n        ]\n    },\n    \"bin\": [\n        \"bin/simple-phpunit\"\n    ],\n    \"minimum-stability\": \"dev\",\n    \"extra\": {\n        \"thanks\": {\n            \"name\": \"phpunit/phpunit\",\n            \"url\": \"https://github.com/sebastianbergmann/phpunit\"\n        }\n    }\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.876953125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony PHPUnit Bridge Test Suite\">\n            <directory>./Tests/</directory>\n            <directory suffix=\".phpt\">./Tests/DeprecationErrorHandler/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}