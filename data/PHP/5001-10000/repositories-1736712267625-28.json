{
  "metadata": {
    "timestamp": 1736712267625,
    "page": 28,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/event-dispatcher",
      "stars": 8523,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "Attribute",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.8408203125,
          "content": "CHANGELOG\n=========\n\n6.0\n---\n\n * Remove `LegacyEventDispatcherProxy`\n\n5.4\n---\n\n * Allow `#[AsEventListener]` attribute on methods\n\n5.3\n---\n\n * Add `#[AsEventListener]` attribute for declaring listeners on PHP 8\n\n5.1.0\n-----\n\n * The `LegacyEventDispatcherProxy` class has been deprecated.\n * Added an optional `dispatcher` attribute to the listener and subscriber tags in `RegisterListenerPass`.\n\n5.0.0\n-----\n\n * The signature of the `EventDispatcherInterface::dispatch()` method has been changed to `dispatch($event, string $eventName = null): object`.\n * The `Event` class has been removed in favor of `Symfony\\Contracts\\EventDispatcher\\Event`.\n * The `TraceableEventDispatcherInterface` has been removed.\n * The `WrappedListener` class is now final.\n\n4.4.0\n-----\n\n * `AddEventAliasesPass` has been added, allowing applications and bundles to extend the event alias mapping used by `RegisterListenersPass`.\n * Made the `event` attribute of the `kernel.event_listener` tag optional for FQCN events.\n\n4.3.0\n-----\n\n * The signature of the `EventDispatcherInterface::dispatch()` method should be updated to `dispatch($event, string $eventName = null)`, not doing so is deprecated\n * deprecated the `Event` class, use `Symfony\\Contracts\\EventDispatcher\\Event` instead\n\n4.1.0\n-----\n\n * added support for invokable event listeners tagged with `kernel.event_listener` by default\n * The `TraceableEventDispatcher::getOrphanedEvents()` method has been added.\n * The `TraceableEventDispatcherInterface` has been deprecated.\n\n4.0.0\n-----\n\n * removed the `ContainerAwareEventDispatcher` class\n * added the `reset()` method to the `TraceableEventDispatcherInterface`\n\n3.4.0\n-----\n\n * Implementing `TraceableEventDispatcherInterface` without the `reset()` method has been deprecated.\n\n3.3.0\n-----\n\n * The ContainerAwareEventDispatcher class has been deprecated. Use EventDispatcher with closure factories instead.\n\n3.0.0\n-----\n\n * The method `getListenerPriority($eventName, $listener)` has been added to the\n   `EventDispatcherInterface`.\n * The methods `Event::setDispatcher()`, `Event::getDispatcher()`, `Event::setName()`\n   and `Event::getName()` have been removed.\n   The event dispatcher and the event name are passed to the listener call.\n\n2.5.0\n-----\n\n * added Debug\\TraceableEventDispatcher (originally in HttpKernel)\n * changed Debug\\TraceableEventDispatcherInterface to extend EventDispatcherInterface\n * added RegisterListenersPass (originally in HttpKernel)\n\n2.1.0\n-----\n\n * added TraceableEventDispatcherInterface\n * added ContainerAwareEventDispatcher\n * added a reference to the EventDispatcher on the Event\n * added a reference to the Event name on the event\n * added fluid interface to the dispatch() method which now returns the Event\n   object\n * added GenericEvent event class\n * added the possibility for subscribers to subscribe several times for the\n   same event\n * added ImmutableEventDispatcher\n"
        },
        {
          "name": "Debug",
          "type": "tree",
          "content": null
        },
        {
          "name": "DependencyInjection",
          "type": "tree",
          "content": null
        },
        {
          "name": "EventDispatcher.php",
          "type": "blob",
          "size": 8.650390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\EventDispatcher;\n\nuse Psr\\EventDispatcher\\StoppableEventInterface;\nuse Symfony\\Component\\EventDispatcher\\Debug\\WrappedListener;\n\n/**\n * The EventDispatcherInterface is the central point of Symfony's event listener system.\n *\n * Listeners are registered on the manager and events are dispatched through the\n * manager.\n *\n * @author Guilherme Blanco <guilhermeblanco@hotmail.com>\n * @author Jonathan Wage <jonwage@gmail.com>\n * @author Roman Borschel <roman@code-factory.org>\n * @author Bernhard Schussek <bschussek@gmail.com>\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Jordi Boggiano <j.boggiano@seld.be>\n * @author Jordan Alliot <jordan.alliot@gmail.com>\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass EventDispatcher implements EventDispatcherInterface\n{\n    private array $listeners = [];\n    private array $sorted = [];\n    private array $optimized;\n\n    public function __construct()\n    {\n        if (__CLASS__ === static::class) {\n            $this->optimized = [];\n        }\n    }\n\n    public function dispatch(object $event, ?string $eventName = null): object\n    {\n        $eventName ??= $event::class;\n\n        if (isset($this->optimized)) {\n            $listeners = $this->optimized[$eventName] ?? (empty($this->listeners[$eventName]) ? [] : $this->optimizeListeners($eventName));\n        } else {\n            $listeners = $this->getListeners($eventName);\n        }\n\n        if ($listeners) {\n            $this->callListeners($listeners, $eventName, $event);\n        }\n\n        return $event;\n    }\n\n    public function getListeners(?string $eventName = null): array\n    {\n        if (null !== $eventName) {\n            if (empty($this->listeners[$eventName])) {\n                return [];\n            }\n\n            if (!isset($this->sorted[$eventName])) {\n                $this->sortListeners($eventName);\n            }\n\n            return $this->sorted[$eventName];\n        }\n\n        foreach ($this->listeners as $eventName => $eventListeners) {\n            if (!isset($this->sorted[$eventName])) {\n                $this->sortListeners($eventName);\n            }\n        }\n\n        return array_filter($this->sorted);\n    }\n\n    public function getListenerPriority(string $eventName, callable|array $listener): ?int\n    {\n        if (empty($this->listeners[$eventName])) {\n            return null;\n        }\n\n        if (\\is_array($listener) && isset($listener[0]) && $listener[0] instanceof \\Closure && 2 >= \\count($listener)) {\n            $listener[0] = $listener[0]();\n            $listener[1] ??= '__invoke';\n        }\n\n        foreach ($this->listeners[$eventName] as $priority => &$listeners) {\n            foreach ($listeners as &$v) {\n                if ($v !== $listener && \\is_array($v) && isset($v[0]) && $v[0] instanceof \\Closure && 2 >= \\count($v)) {\n                    $v[0] = $v[0]();\n                    $v[1] ??= '__invoke';\n                }\n                if ($v === $listener || ($listener instanceof \\Closure && $v == $listener)) {\n                    return $priority;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    public function hasListeners(?string $eventName = null): bool\n    {\n        if (null !== $eventName) {\n            return !empty($this->listeners[$eventName]);\n        }\n\n        foreach ($this->listeners as $eventListeners) {\n            if ($eventListeners) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public function addListener(string $eventName, callable|array $listener, int $priority = 0): void\n    {\n        $this->listeners[$eventName][$priority][] = $listener;\n        unset($this->sorted[$eventName], $this->optimized[$eventName]);\n    }\n\n    public function removeListener(string $eventName, callable|array $listener): void\n    {\n        if (empty($this->listeners[$eventName])) {\n            return;\n        }\n\n        if (\\is_array($listener) && isset($listener[0]) && $listener[0] instanceof \\Closure && 2 >= \\count($listener)) {\n            $listener[0] = $listener[0]();\n            $listener[1] ??= '__invoke';\n        }\n\n        foreach ($this->listeners[$eventName] as $priority => &$listeners) {\n            foreach ($listeners as $k => &$v) {\n                if ($v !== $listener && \\is_array($v) && isset($v[0]) && $v[0] instanceof \\Closure && 2 >= \\count($v)) {\n                    $v[0] = $v[0]();\n                    $v[1] ??= '__invoke';\n                }\n                if ($v === $listener || ($listener instanceof \\Closure && $v == $listener)) {\n                    unset($listeners[$k], $this->sorted[$eventName], $this->optimized[$eventName]);\n                }\n            }\n\n            if (!$listeners) {\n                unset($this->listeners[$eventName][$priority]);\n            }\n        }\n    }\n\n    public function addSubscriber(EventSubscriberInterface $subscriber): void\n    {\n        foreach ($subscriber->getSubscribedEvents() as $eventName => $params) {\n            if (\\is_string($params)) {\n                $this->addListener($eventName, [$subscriber, $params]);\n            } elseif (\\is_string($params[0])) {\n                $this->addListener($eventName, [$subscriber, $params[0]], $params[1] ?? 0);\n            } else {\n                foreach ($params as $listener) {\n                    $this->addListener($eventName, [$subscriber, $listener[0]], $listener[1] ?? 0);\n                }\n            }\n        }\n    }\n\n    public function removeSubscriber(EventSubscriberInterface $subscriber): void\n    {\n        foreach ($subscriber->getSubscribedEvents() as $eventName => $params) {\n            if (\\is_array($params) && \\is_array($params[0])) {\n                foreach ($params as $listener) {\n                    $this->removeListener($eventName, [$subscriber, $listener[0]]);\n                }\n            } else {\n                $this->removeListener($eventName, [$subscriber, \\is_string($params) ? $params : $params[0]]);\n            }\n        }\n    }\n\n    /**\n     * Triggers the listeners of an event.\n     *\n     * This method can be overridden to add functionality that is executed\n     * for each listener.\n     *\n     * @param callable[] $listeners The event listeners\n     * @param string     $eventName The name of the event to dispatch\n     * @param object     $event     The event object to pass to the event handlers/listeners\n     */\n    protected function callListeners(iterable $listeners, string $eventName, object $event): void\n    {\n        $stoppable = $event instanceof StoppableEventInterface;\n\n        foreach ($listeners as $listener) {\n            if ($stoppable && $event->isPropagationStopped()) {\n                break;\n            }\n            $listener($event, $eventName, $this);\n        }\n    }\n\n    /**\n     * Sorts the internal list of listeners for the given event by priority.\n     */\n    private function sortListeners(string $eventName): void\n    {\n        krsort($this->listeners[$eventName]);\n        $this->sorted[$eventName] = [];\n\n        foreach ($this->listeners[$eventName] as &$listeners) {\n            foreach ($listeners as &$listener) {\n                if (\\is_array($listener) && isset($listener[0]) && $listener[0] instanceof \\Closure && 2 >= \\count($listener)) {\n                    $listener[0] = $listener[0]();\n                    $listener[1] ??= '__invoke';\n                }\n                $this->sorted[$eventName][] = $listener;\n            }\n        }\n    }\n\n    /**\n     * Optimizes the internal list of listeners for the given event by priority.\n     */\n    private function optimizeListeners(string $eventName): array\n    {\n        krsort($this->listeners[$eventName]);\n        $this->optimized[$eventName] = [];\n\n        foreach ($this->listeners[$eventName] as &$listeners) {\n            foreach ($listeners as &$listener) {\n                $closure = &$this->optimized[$eventName][];\n                if (\\is_array($listener) && isset($listener[0]) && $listener[0] instanceof \\Closure && 2 >= \\count($listener)) {\n                    $closure = static function (...$args) use (&$listener, &$closure) {\n                        if ($listener[0] instanceof \\Closure) {\n                            $listener[0] = $listener[0]();\n                            $listener[1] ??= '__invoke';\n                        }\n                        ($closure = $listener(...))(...$args);\n                    };\n                } else {\n                    $closure = $listener instanceof WrappedListener ? $listener : $listener(...);\n                }\n            }\n        }\n\n        return $this->optimized[$eventName];\n    }\n}\n"
        },
        {
          "name": "EventDispatcherInterface.php",
          "type": "blob",
          "size": 2.1044921875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\EventDispatcher;\n\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface as ContractsEventDispatcherInterface;\n\n/**\n * The EventDispatcherInterface is the central point of Symfony's event listener system.\n * Listeners are registered on the manager and events are dispatched through the\n * manager.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface EventDispatcherInterface extends ContractsEventDispatcherInterface\n{\n    /**\n     * Adds an event listener that listens on the specified events.\n     *\n     * @param int $priority The higher this value, the earlier an event\n     *                      listener will be triggered in the chain (defaults to 0)\n     */\n    public function addListener(string $eventName, callable $listener, int $priority = 0): void;\n\n    /**\n     * Adds an event subscriber.\n     *\n     * The subscriber is asked for all the events it is\n     * interested in and added as a listener for these events.\n     */\n    public function addSubscriber(EventSubscriberInterface $subscriber): void;\n\n    /**\n     * Removes an event listener from the specified events.\n     */\n    public function removeListener(string $eventName, callable $listener): void;\n\n    public function removeSubscriber(EventSubscriberInterface $subscriber): void;\n\n    /**\n     * Gets the listeners of a specific event or all listeners sorted by descending priority.\n     *\n     * @return array<callable[]|callable>\n     */\n    public function getListeners(?string $eventName = null): array;\n\n    /**\n     * Gets the listener priority for a specific event.\n     *\n     * Returns null if the event or the listener does not exist.\n     */\n    public function getListenerPriority(string $eventName, callable $listener): ?int;\n\n    /**\n     * Checks whether an event has any registered listeners.\n     */\n    public function hasListeners(?string $eventName = null): bool;\n}\n"
        },
        {
          "name": "EventSubscriberInterface.php",
          "type": "blob",
          "size": 1.72265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\EventDispatcher;\n\n/**\n * An EventSubscriber knows itself what events it is interested in.\n * If an EventSubscriber is added to an EventDispatcherInterface, the manager invokes\n * {@link getSubscribedEvents} and registers the subscriber as a listener for all\n * returned events.\n *\n * @author Guilherme Blanco <guilhermeblanco@hotmail.com>\n * @author Jonathan Wage <jonwage@gmail.com>\n * @author Roman Borschel <roman@code-factory.org>\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface EventSubscriberInterface\n{\n    /**\n     * Returns an array of event names this subscriber wants to listen to.\n     *\n     * The array keys are event names and the value can be:\n     *\n     *  * The method name to call (priority defaults to 0)\n     *  * An array composed of the method name to call and the priority\n     *  * An array of arrays composed of the method names to call and respective\n     *    priorities, or 0 if unset\n     *\n     * For instance:\n     *\n     *  * ['eventName' => 'methodName']\n     *  * ['eventName' => ['methodName', $priority]]\n     *  * ['eventName' => [['methodName1', $priority], ['methodName2']]]\n     *\n     * The code must not depend on runtime state as it will only be called at compile time.\n     * All logic depending on runtime state must be put into the individual methods handling the events.\n     *\n     * @return array<string, string|array{0: string, 1: int}|list<array{0: string, 1?: int}>>\n     */\n    public static function getSubscribedEvents();\n}\n"
        },
        {
          "name": "GenericEvent.php",
          "type": "blob",
          "size": 3.3759765625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\EventDispatcher;\n\nuse Symfony\\Contracts\\EventDispatcher\\Event;\n\n/**\n * Event encapsulation class.\n *\n * Encapsulates events thus decoupling the observer from the subject they encapsulate.\n *\n * @author Drak <drak@zikula.org>\n *\n * @implements \\ArrayAccess<string, mixed>\n * @implements \\IteratorAggregate<string, mixed>\n */\nclass GenericEvent extends Event implements \\ArrayAccess, \\IteratorAggregate\n{\n    /**\n     * Encapsulate an event with $subject and $arguments.\n     *\n     * @param mixed $subject   The subject of the event, usually an object or a callable\n     * @param array $arguments Arguments to store in the event\n     */\n    public function __construct(\n        protected mixed $subject = null,\n        protected array $arguments = [],\n    ) {\n    }\n\n    /**\n     * Getter for subject property.\n     */\n    public function getSubject(): mixed\n    {\n        return $this->subject;\n    }\n\n    /**\n     * Get argument by key.\n     *\n     * @throws \\InvalidArgumentException if key is not found\n     */\n    public function getArgument(string $key): mixed\n    {\n        if ($this->hasArgument($key)) {\n            return $this->arguments[$key];\n        }\n\n        throw new \\InvalidArgumentException(\\sprintf('Argument \"%s\" not found.', $key));\n    }\n\n    /**\n     * Add argument to event.\n     *\n     * @return $this\n     */\n    public function setArgument(string $key, mixed $value): static\n    {\n        $this->arguments[$key] = $value;\n\n        return $this;\n    }\n\n    /**\n     * Getter for all arguments.\n     */\n    public function getArguments(): array\n    {\n        return $this->arguments;\n    }\n\n    /**\n     * Set args property.\n     *\n     * @return $this\n     */\n    public function setArguments(array $args = []): static\n    {\n        $this->arguments = $args;\n\n        return $this;\n    }\n\n    /**\n     * Has argument.\n     */\n    public function hasArgument(string $key): bool\n    {\n        return \\array_key_exists($key, $this->arguments);\n    }\n\n    /**\n     * ArrayAccess for argument getter.\n     *\n     * @param string $key Array key\n     *\n     * @throws \\InvalidArgumentException if key does not exist in $this->args\n     */\n    public function offsetGet(mixed $key): mixed\n    {\n        return $this->getArgument($key);\n    }\n\n    /**\n     * ArrayAccess for argument setter.\n     *\n     * @param string $key Array key to set\n     */\n    public function offsetSet(mixed $key, mixed $value): void\n    {\n        $this->setArgument($key, $value);\n    }\n\n    /**\n     * ArrayAccess for unset argument.\n     *\n     * @param string $key Array key\n     */\n    public function offsetUnset(mixed $key): void\n    {\n        if ($this->hasArgument($key)) {\n            unset($this->arguments[$key]);\n        }\n    }\n\n    /**\n     * ArrayAccess has argument.\n     *\n     * @param string $key Array key\n     */\n    public function offsetExists(mixed $key): bool\n    {\n        return $this->hasArgument($key);\n    }\n\n    /**\n     * IteratorAggregate for iterating over the object like an array.\n     *\n     * @return \\ArrayIterator<string, mixed>\n     */\n    public function getIterator(): \\ArrayIterator\n    {\n        return new \\ArrayIterator($this->arguments);\n    }\n}\n"
        },
        {
          "name": "ImmutableEventDispatcher.php",
          "type": "blob",
          "size": 1.93359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\EventDispatcher;\n\n/**\n * A read-only proxy for an event dispatcher.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass ImmutableEventDispatcher implements EventDispatcherInterface\n{\n    public function __construct(\n        private EventDispatcherInterface $dispatcher,\n    ) {\n    }\n\n    public function dispatch(object $event, ?string $eventName = null): object\n    {\n        return $this->dispatcher->dispatch($event, $eventName);\n    }\n\n    public function addListener(string $eventName, callable|array $listener, int $priority = 0): never\n    {\n        throw new \\BadMethodCallException('Unmodifiable event dispatchers must not be modified.');\n    }\n\n    public function addSubscriber(EventSubscriberInterface $subscriber): never\n    {\n        throw new \\BadMethodCallException('Unmodifiable event dispatchers must not be modified.');\n    }\n\n    public function removeListener(string $eventName, callable|array $listener): never\n    {\n        throw new \\BadMethodCallException('Unmodifiable event dispatchers must not be modified.');\n    }\n\n    public function removeSubscriber(EventSubscriberInterface $subscriber): never\n    {\n        throw new \\BadMethodCallException('Unmodifiable event dispatchers must not be modified.');\n    }\n\n    public function getListeners(?string $eventName = null): array\n    {\n        return $this->dispatcher->getListeners($eventName);\n    }\n\n    public function getListenerPriority(string $eventName, callable|array $listener): ?int\n    {\n        return $this->dispatcher->getListenerPriority($eventName, $listener);\n    }\n\n    public function hasListeners(?string $eventName = null): bool\n    {\n        return $this->dispatcher->hasListeners($eventName);\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.5849609375,
          "content": "EventDispatcher Component\n=========================\n\nThe EventDispatcher component provides tools that allow your application\ncomponents to communicate with each other by dispatching events and listening to\nthem.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/event_dispatcher.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.4462890625,
          "content": "{\n    \"name\": \"symfony/event-dispatcher\",\n    \"type\": \"library\",\n    \"description\": \"Provides tools that allow your application components to communicate with each other by dispatching events and listening to them\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/event-dispatcher-contracts\": \"^2.5|^3\"\n    },\n    \"require-dev\": {\n        \"symfony/dependency-injection\": \"^6.4|^7.0\",\n        \"symfony/expression-language\": \"^6.4|^7.0\",\n        \"symfony/config\": \"^6.4|^7.0\",\n        \"symfony/error-handler\": \"^6.4|^7.0\",\n        \"symfony/http-foundation\": \"^6.4|^7.0\",\n        \"symfony/service-contracts\": \"^2.5|^3\",\n        \"symfony/stopwatch\": \"^6.4|^7.0\",\n        \"psr/log\": \"^1|^2|^3\"\n    },\n    \"conflict\": {\n        \"symfony/dependency-injection\": \"<6.4\",\n        \"symfony/service-contracts\": \"<2.5\"\n    },\n    \"provide\": {\n        \"psr/event-dispatcher-implementation\": \"1.0\",\n        \"symfony/event-dispatcher-implementation\": \"2.0|3.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\EventDispatcher\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.8525390625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony EventDispatcher Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Resources</directory>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}