{
  "metadata": {
    "timestamp": 1736712270131,
    "page": 31,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/finder",
      "stars": 8422,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.505859375,
          "content": "CHANGELOG\n=========\n\n6.4\n---\n\n * Add early directory pruning to `Finder::filter()`\n\n6.2\n---\n\n * Add `Finder::sortByExtension()` and `Finder::sortBySize()`\n * Add `Finder::sortByCaseInsensitiveName()` to sort by name with case insensitive sorting methods\n\n6.0\n---\n\n * Remove `Comparator::setTarget()` and `Comparator::setOperator()`\n\n5.4.0\n-----\n\n * Deprecate `Comparator::setTarget()` and `Comparator::setOperator()`\n * Add a constructor to `Comparator` that allows setting target and operator\n * Finder's iterator has now `Symfony\\Component\\Finder\\SplFileInfo` inner type specified\n * Add recursive .gitignore files support\n\n5.0.0\n-----\n\n * added `$useNaturalSort` argument to `Finder::sortByName()`\n\n4.3.0\n-----\n\n * added Finder::ignoreVCSIgnored() to ignore files based on rules listed in .gitignore\n\n4.2.0\n-----\n\n * added $useNaturalSort option to Finder::sortByName() method\n * the `Finder::sortByName()` method will have a new `$useNaturalSort`\n   argument in version 5.0, not defining it is deprecated\n * added `Finder::reverseSorting()` to reverse the sorting\n\n4.0.0\n-----\n\n * removed `ExceptionInterface`\n * removed `Symfony\\Component\\Finder\\Iterator\\FilterIterator`\n\n3.4.0\n-----\n\n * deprecated `Symfony\\Component\\Finder\\Iterator\\FilterIterator`\n * added Finder::hasResults() method to check if any results were found\n\n3.3.0\n-----\n\n * added double-star matching to Glob::toRegex()\n\n3.0.0\n-----\n\n * removed deprecated classes\n\n2.8.0\n-----\n\n * deprecated adapters and related classes\n\n2.5.0\n-----\n * added support for GLOB_BRACE in the paths passed to Finder::in()\n\n2.3.0\n-----\n\n * added a way to ignore unreadable directories (via Finder::ignoreUnreadableDirs())\n * unified the way subfolders that are not executable are handled by always throwing an AccessDeniedException exception\n\n2.2.0\n-----\n\n * added Finder::path() and Finder::notPath() methods\n * added finder adapters to improve performance on specific platforms\n * added support for wildcard characters (glob patterns) in the paths passed\n   to Finder::in()\n\n2.1.0\n-----\n\n * added Finder::sortByAccessedTime(), Finder::sortByChangedTime(), and\n   Finder::sortByModifiedTime()\n * added Countable to Finder\n * added support for an array of directories as an argument to\n   Finder::exclude()\n * added searching based on the file content via Finder::contains() and\n   Finder::notContains()\n * added support for the != operator in the Comparator\n * [BC BREAK] filter expressions (used for file name and content) are no more\n   considered as regexps but glob patterns when they are enclosed in '*' or '?'\n"
        },
        {
          "name": "Comparator",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Finder.php",
          "type": "blob",
          "size": 23.5908203125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Finder;\n\nuse Symfony\\Component\\Finder\\Comparator\\DateComparator;\nuse Symfony\\Component\\Finder\\Comparator\\NumberComparator;\nuse Symfony\\Component\\Finder\\Exception\\DirectoryNotFoundException;\nuse Symfony\\Component\\Finder\\Iterator\\CustomFilterIterator;\nuse Symfony\\Component\\Finder\\Iterator\\DateRangeFilterIterator;\nuse Symfony\\Component\\Finder\\Iterator\\DepthRangeFilterIterator;\nuse Symfony\\Component\\Finder\\Iterator\\ExcludeDirectoryFilterIterator;\nuse Symfony\\Component\\Finder\\Iterator\\FilecontentFilterIterator;\nuse Symfony\\Component\\Finder\\Iterator\\FilenameFilterIterator;\nuse Symfony\\Component\\Finder\\Iterator\\LazyIterator;\nuse Symfony\\Component\\Finder\\Iterator\\SizeRangeFilterIterator;\nuse Symfony\\Component\\Finder\\Iterator\\SortableIterator;\n\n/**\n * Finder allows to build rules to find files and directories.\n *\n * It is a thin wrapper around several specialized iterator classes.\n *\n * All rules may be invoked several times.\n *\n * All methods return the current Finder object to allow chaining:\n *\n *     $finder = Finder::create()->files()->name('*.php')->in(__DIR__);\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @implements \\IteratorAggregate<string, SplFileInfo>\n */\nclass Finder implements \\IteratorAggregate, \\Countable\n{\n    public const IGNORE_VCS_FILES = 1;\n    public const IGNORE_DOT_FILES = 2;\n    public const IGNORE_VCS_IGNORED_FILES = 4;\n\n    private int $mode = 0;\n    private array $names = [];\n    private array $notNames = [];\n    private array $exclude = [];\n    private array $filters = [];\n    private array $pruneFilters = [];\n    private array $depths = [];\n    private array $sizes = [];\n    private bool $followLinks = false;\n    private bool $reverseSorting = false;\n    private \\Closure|int|false $sort = false;\n    private int $ignore = 0;\n    private array $dirs = [];\n    private array $dates = [];\n    private array $iterators = [];\n    private array $contains = [];\n    private array $notContains = [];\n    private array $paths = [];\n    private array $notPaths = [];\n    private bool $ignoreUnreadableDirs = false;\n\n    private static array $vcsPatterns = ['.svn', '_svn', 'CVS', '_darcs', '.arch-params', '.monotone', '.bzr', '.git', '.hg'];\n\n    public function __construct()\n    {\n        $this->ignore = static::IGNORE_VCS_FILES | static::IGNORE_DOT_FILES;\n    }\n\n    /**\n     * Creates a new Finder.\n     */\n    public static function create(): static\n    {\n        return new static();\n    }\n\n    /**\n     * Restricts the matching to directories only.\n     *\n     * @return $this\n     */\n    public function directories(): static\n    {\n        $this->mode = Iterator\\FileTypeFilterIterator::ONLY_DIRECTORIES;\n\n        return $this;\n    }\n\n    /**\n     * Restricts the matching to files only.\n     *\n     * @return $this\n     */\n    public function files(): static\n    {\n        $this->mode = Iterator\\FileTypeFilterIterator::ONLY_FILES;\n\n        return $this;\n    }\n\n    /**\n     * Adds tests for the directory depth.\n     *\n     * Usage:\n     *\n     *     $finder->depth('> 1') // the Finder will start matching at level 1.\n     *     $finder->depth('< 3') // the Finder will descend at most 3 levels of directories below the starting point.\n     *     $finder->depth(['>= 1', '< 3'])\n     *\n     * @param string|int|string[]|int[] $levels The depth level expression or an array of depth levels\n     *\n     * @return $this\n     *\n     * @see DepthRangeFilterIterator\n     * @see NumberComparator\n     */\n    public function depth(string|int|array $levels): static\n    {\n        foreach ((array) $levels as $level) {\n            $this->depths[] = new NumberComparator($level);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Adds tests for file dates (last modified).\n     *\n     * The date must be something that strtotime() is able to parse:\n     *\n     *     $finder->date('since yesterday');\n     *     $finder->date('until 2 days ago');\n     *     $finder->date('> now - 2 hours');\n     *     $finder->date('>= 2005-10-15');\n     *     $finder->date(['>= 2005-10-15', '<= 2006-05-27']);\n     *\n     * @param string|string[] $dates A date range string or an array of date ranges\n     *\n     * @return $this\n     *\n     * @see strtotime\n     * @see DateRangeFilterIterator\n     * @see DateComparator\n     */\n    public function date(string|array $dates): static\n    {\n        foreach ((array) $dates as $date) {\n            $this->dates[] = new DateComparator($date);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Adds rules that files must match.\n     *\n     * You can use patterns (delimited with / sign), globs or simple strings.\n     *\n     *     $finder->name('/\\.php$/')\n     *     $finder->name('*.php') // same as above, without dot files\n     *     $finder->name('test.php')\n     *     $finder->name(['test.py', 'test.php'])\n     *\n     * @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns\n     *\n     * @return $this\n     *\n     * @see FilenameFilterIterator\n     */\n    public function name(string|array $patterns): static\n    {\n        $this->names = array_merge($this->names, (array) $patterns);\n\n        return $this;\n    }\n\n    /**\n     * Adds rules that files must not match.\n     *\n     * @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns\n     *\n     * @return $this\n     *\n     * @see FilenameFilterIterator\n     */\n    public function notName(string|array $patterns): static\n    {\n        $this->notNames = array_merge($this->notNames, (array) $patterns);\n\n        return $this;\n    }\n\n    /**\n     * Adds tests that file contents must match.\n     *\n     * Strings or PCRE patterns can be used:\n     *\n     *     $finder->contains('Lorem ipsum')\n     *     $finder->contains('/Lorem ipsum/i')\n     *     $finder->contains(['dolor', '/ipsum/i'])\n     *\n     * @param string|string[] $patterns A pattern (string or regexp) or an array of patterns\n     *\n     * @return $this\n     *\n     * @see FilecontentFilterIterator\n     */\n    public function contains(string|array $patterns): static\n    {\n        $this->contains = array_merge($this->contains, (array) $patterns);\n\n        return $this;\n    }\n\n    /**\n     * Adds tests that file contents must not match.\n     *\n     * Strings or PCRE patterns can be used:\n     *\n     *     $finder->notContains('Lorem ipsum')\n     *     $finder->notContains('/Lorem ipsum/i')\n     *     $finder->notContains(['lorem', '/dolor/i'])\n     *\n     * @param string|string[] $patterns A pattern (string or regexp) or an array of patterns\n     *\n     * @return $this\n     *\n     * @see FilecontentFilterIterator\n     */\n    public function notContains(string|array $patterns): static\n    {\n        $this->notContains = array_merge($this->notContains, (array) $patterns);\n\n        return $this;\n    }\n\n    /**\n     * Adds rules that filenames must match.\n     *\n     * You can use patterns (delimited with / sign) or simple strings.\n     *\n     *     $finder->path('some/special/dir')\n     *     $finder->path('/some\\/special\\/dir/') // same as above\n     *     $finder->path(['some dir', 'another/dir'])\n     *\n     * Use only / as dirname separator.\n     *\n     * @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns\n     *\n     * @return $this\n     *\n     * @see FilenameFilterIterator\n     */\n    public function path(string|array $patterns): static\n    {\n        $this->paths = array_merge($this->paths, (array) $patterns);\n\n        return $this;\n    }\n\n    /**\n     * Adds rules that filenames must not match.\n     *\n     * You can use patterns (delimited with / sign) or simple strings.\n     *\n     *     $finder->notPath('some/special/dir')\n     *     $finder->notPath('/some\\/special\\/dir/') // same as above\n     *     $finder->notPath(['some/file.txt', 'another/file.log'])\n     *\n     * Use only / as dirname separator.\n     *\n     * @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns\n     *\n     * @return $this\n     *\n     * @see FilenameFilterIterator\n     */\n    public function notPath(string|array $patterns): static\n    {\n        $this->notPaths = array_merge($this->notPaths, (array) $patterns);\n\n        return $this;\n    }\n\n    /**\n     * Adds tests for file sizes.\n     *\n     *     $finder->size('> 10K');\n     *     $finder->size('<= 1Ki');\n     *     $finder->size(4);\n     *     $finder->size(['> 10K', '< 20K'])\n     *\n     * @param string|int|string[]|int[] $sizes A size range string or an integer or an array of size ranges\n     *\n     * @return $this\n     *\n     * @see SizeRangeFilterIterator\n     * @see NumberComparator\n     */\n    public function size(string|int|array $sizes): static\n    {\n        foreach ((array) $sizes as $size) {\n            $this->sizes[] = new NumberComparator($size);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Excludes directories.\n     *\n     * Directories passed as argument must be relative to the ones defined with the `in()` method. For example:\n     *\n     *     $finder->in(__DIR__)->exclude('ruby');\n     *\n     * @param string|array $dirs A directory path or an array of directories\n     *\n     * @return $this\n     *\n     * @see ExcludeDirectoryFilterIterator\n     */\n    public function exclude(string|array $dirs): static\n    {\n        $this->exclude = array_merge($this->exclude, (array) $dirs);\n\n        return $this;\n    }\n\n    /**\n     * Excludes \"hidden\" directories and files (starting with a dot).\n     *\n     * This option is enabled by default.\n     *\n     * @return $this\n     *\n     * @see ExcludeDirectoryFilterIterator\n     */\n    public function ignoreDotFiles(bool $ignoreDotFiles): static\n    {\n        if ($ignoreDotFiles) {\n            $this->ignore |= static::IGNORE_DOT_FILES;\n        } else {\n            $this->ignore &= ~static::IGNORE_DOT_FILES;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Forces the finder to ignore version control directories.\n     *\n     * This option is enabled by default.\n     *\n     * @return $this\n     *\n     * @see ExcludeDirectoryFilterIterator\n     */\n    public function ignoreVCS(bool $ignoreVCS): static\n    {\n        if ($ignoreVCS) {\n            $this->ignore |= static::IGNORE_VCS_FILES;\n        } else {\n            $this->ignore &= ~static::IGNORE_VCS_FILES;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Forces Finder to obey .gitignore and ignore files based on rules listed there.\n     *\n     * This option is disabled by default.\n     *\n     * @return $this\n     */\n    public function ignoreVCSIgnored(bool $ignoreVCSIgnored): static\n    {\n        if ($ignoreVCSIgnored) {\n            $this->ignore |= static::IGNORE_VCS_IGNORED_FILES;\n        } else {\n            $this->ignore &= ~static::IGNORE_VCS_IGNORED_FILES;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Adds VCS patterns.\n     *\n     * @see ignoreVCS()\n     *\n     * @param string|string[] $pattern VCS patterns to ignore\n     */\n    public static function addVCSPattern(string|array $pattern): void\n    {\n        foreach ((array) $pattern as $p) {\n            self::$vcsPatterns[] = $p;\n        }\n\n        self::$vcsPatterns = array_unique(self::$vcsPatterns);\n    }\n\n    /**\n     * Sorts files and directories by an anonymous function.\n     *\n     * The anonymous function receives two \\SplFileInfo instances to compare.\n     *\n     * This can be slow as all the matching files and directories must be retrieved for comparison.\n     *\n     * @return $this\n     *\n     * @see SortableIterator\n     */\n    public function sort(\\Closure $closure): static\n    {\n        $this->sort = $closure;\n\n        return $this;\n    }\n\n    /**\n     * Sorts files and directories by extension.\n     *\n     * This can be slow as all the matching files and directories must be retrieved for comparison.\n     *\n     * @return $this\n     *\n     * @see SortableIterator\n     */\n    public function sortByExtension(): static\n    {\n        $this->sort = SortableIterator::SORT_BY_EXTENSION;\n\n        return $this;\n    }\n\n    /**\n     * Sorts files and directories by name.\n     *\n     * This can be slow as all the matching files and directories must be retrieved for comparison.\n     *\n     * @return $this\n     *\n     * @see SortableIterator\n     */\n    public function sortByName(bool $useNaturalSort = false): static\n    {\n        $this->sort = $useNaturalSort ? SortableIterator::SORT_BY_NAME_NATURAL : SortableIterator::SORT_BY_NAME;\n\n        return $this;\n    }\n\n    /**\n     * Sorts files and directories by name case insensitive.\n     *\n     * This can be slow as all the matching files and directories must be retrieved for comparison.\n     *\n     * @return $this\n     *\n     * @see SortableIterator\n     */\n    public function sortByCaseInsensitiveName(bool $useNaturalSort = false): static\n    {\n        $this->sort = $useNaturalSort ? SortableIterator::SORT_BY_NAME_NATURAL_CASE_INSENSITIVE : SortableIterator::SORT_BY_NAME_CASE_INSENSITIVE;\n\n        return $this;\n    }\n\n    /**\n     * Sorts files and directories by size.\n     *\n     * This can be slow as all the matching files and directories must be retrieved for comparison.\n     *\n     * @return $this\n     *\n     * @see SortableIterator\n     */\n    public function sortBySize(): static\n    {\n        $this->sort = SortableIterator::SORT_BY_SIZE;\n\n        return $this;\n    }\n\n    /**\n     * Sorts files and directories by type (directories before files), then by name.\n     *\n     * This can be slow as all the matching files and directories must be retrieved for comparison.\n     *\n     * @return $this\n     *\n     * @see SortableIterator\n     */\n    public function sortByType(): static\n    {\n        $this->sort = SortableIterator::SORT_BY_TYPE;\n\n        return $this;\n    }\n\n    /**\n     * Sorts files and directories by the last accessed time.\n     *\n     * This is the time that the file was last accessed, read or written to.\n     *\n     * This can be slow as all the matching files and directories must be retrieved for comparison.\n     *\n     * @return $this\n     *\n     * @see SortableIterator\n     */\n    public function sortByAccessedTime(): static\n    {\n        $this->sort = SortableIterator::SORT_BY_ACCESSED_TIME;\n\n        return $this;\n    }\n\n    /**\n     * Reverses the sorting.\n     *\n     * @return $this\n     */\n    public function reverseSorting(): static\n    {\n        $this->reverseSorting = true;\n\n        return $this;\n    }\n\n    /**\n     * Sorts files and directories by the last inode changed time.\n     *\n     * This is the time that the inode information was last modified (permissions, owner, group or other metadata).\n     *\n     * On Windows, since inode is not available, changed time is actually the file creation time.\n     *\n     * This can be slow as all the matching files and directories must be retrieved for comparison.\n     *\n     * @return $this\n     *\n     * @see SortableIterator\n     */\n    public function sortByChangedTime(): static\n    {\n        $this->sort = SortableIterator::SORT_BY_CHANGED_TIME;\n\n        return $this;\n    }\n\n    /**\n     * Sorts files and directories by the last modified time.\n     *\n     * This is the last time the actual contents of the file were last modified.\n     *\n     * This can be slow as all the matching files and directories must be retrieved for comparison.\n     *\n     * @return $this\n     *\n     * @see SortableIterator\n     */\n    public function sortByModifiedTime(): static\n    {\n        $this->sort = SortableIterator::SORT_BY_MODIFIED_TIME;\n\n        return $this;\n    }\n\n    /**\n     * Filters the iterator with an anonymous function.\n     *\n     * The anonymous function receives a \\SplFileInfo and must return false\n     * to remove files.\n     *\n     * @param \\Closure(SplFileInfo): bool $closure\n     * @param bool                        $prune   Whether to skip traversing directories further\n     *\n     * @return $this\n     *\n     * @see CustomFilterIterator\n     */\n    public function filter(\\Closure $closure, bool $prune = false): static\n    {\n        $this->filters[] = $closure;\n\n        if ($prune) {\n            $this->pruneFilters[] = $closure;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Forces the following of symlinks.\n     *\n     * @return $this\n     */\n    public function followLinks(): static\n    {\n        $this->followLinks = true;\n\n        return $this;\n    }\n\n    /**\n     * Tells finder to ignore unreadable directories.\n     *\n     * By default, scanning unreadable directories content throws an AccessDeniedException.\n     *\n     * @return $this\n     */\n    public function ignoreUnreadableDirs(bool $ignore = true): static\n    {\n        $this->ignoreUnreadableDirs = $ignore;\n\n        return $this;\n    }\n\n    /**\n     * Searches files and directories which match defined rules.\n     *\n     * @param string|string[] $dirs A directory path or an array of directories\n     *\n     * @return $this\n     *\n     * @throws DirectoryNotFoundException if one of the directories does not exist\n     */\n    public function in(string|array $dirs): static\n    {\n        $resolvedDirs = [];\n\n        foreach ((array) $dirs as $dir) {\n            if (is_dir($dir)) {\n                $resolvedDirs[] = [$this->normalizeDir($dir)];\n            } elseif ($glob = glob($dir, (\\defined('GLOB_BRACE') ? \\GLOB_BRACE : 0) | \\GLOB_ONLYDIR | \\GLOB_NOSORT)) {\n                sort($glob);\n                $resolvedDirs[] = array_map($this->normalizeDir(...), $glob);\n            } else {\n                throw new DirectoryNotFoundException(\\sprintf('The \"%s\" directory does not exist.', $dir));\n            }\n        }\n\n        $this->dirs = array_merge($this->dirs, ...$resolvedDirs);\n\n        return $this;\n    }\n\n    /**\n     * Returns an Iterator for the current Finder configuration.\n     *\n     * This method implements the IteratorAggregate interface.\n     *\n     * @return \\Iterator<string, SplFileInfo>\n     *\n     * @throws \\LogicException if the in() method has not been called\n     */\n    public function getIterator(): \\Iterator\n    {\n        if (0 === \\count($this->dirs) && 0 === \\count($this->iterators)) {\n            throw new \\LogicException('You must call one of in() or append() methods before iterating over a Finder.');\n        }\n\n        if (1 === \\count($this->dirs) && 0 === \\count($this->iterators)) {\n            $iterator = $this->searchInDirectory($this->dirs[0]);\n\n            if ($this->sort || $this->reverseSorting) {\n                $iterator = (new SortableIterator($iterator, $this->sort, $this->reverseSorting))->getIterator();\n            }\n\n            return $iterator;\n        }\n\n        $iterator = new \\AppendIterator();\n        foreach ($this->dirs as $dir) {\n            $iterator->append(new \\IteratorIterator(new LazyIterator(fn () => $this->searchInDirectory($dir))));\n        }\n\n        foreach ($this->iterators as $it) {\n            $iterator->append($it);\n        }\n\n        if ($this->sort || $this->reverseSorting) {\n            $iterator = (new SortableIterator($iterator, $this->sort, $this->reverseSorting))->getIterator();\n        }\n\n        return $iterator;\n    }\n\n    /**\n     * Appends an existing set of files/directories to the finder.\n     *\n     * The set can be another Finder, an Iterator, an IteratorAggregate, or even a plain array.\n     *\n     * @return $this\n     */\n    public function append(iterable $iterator): static\n    {\n        if ($iterator instanceof \\IteratorAggregate) {\n            $this->iterators[] = $iterator->getIterator();\n        } elseif ($iterator instanceof \\Iterator) {\n            $this->iterators[] = $iterator;\n        } else {\n            $it = new \\ArrayIterator();\n            foreach ($iterator as $file) {\n                $file = $file instanceof \\SplFileInfo ? $file : new \\SplFileInfo($file);\n                $it[$file->getPathname()] = $file;\n            }\n            $this->iterators[] = $it;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Check if any results were found.\n     */\n    public function hasResults(): bool\n    {\n        foreach ($this->getIterator() as $_) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Counts all the results collected by the iterators.\n     */\n    public function count(): int\n    {\n        return iterator_count($this->getIterator());\n    }\n\n    private function searchInDirectory(string $dir): \\Iterator\n    {\n        $exclude = $this->exclude;\n        $notPaths = $this->notPaths;\n\n        if ($this->pruneFilters) {\n            $exclude = array_merge($exclude, $this->pruneFilters);\n        }\n\n        if (static::IGNORE_VCS_FILES === (static::IGNORE_VCS_FILES & $this->ignore)) {\n            $exclude = array_merge($exclude, self::$vcsPatterns);\n        }\n\n        if (static::IGNORE_DOT_FILES === (static::IGNORE_DOT_FILES & $this->ignore)) {\n            $notPaths[] = '#(^|/)\\..+(/|$)#';\n        }\n\n        $minDepth = 0;\n        $maxDepth = \\PHP_INT_MAX;\n\n        foreach ($this->depths as $comparator) {\n            switch ($comparator->getOperator()) {\n                case '>':\n                    $minDepth = $comparator->getTarget() + 1;\n                    break;\n                case '>=':\n                    $minDepth = $comparator->getTarget();\n                    break;\n                case '<':\n                    $maxDepth = $comparator->getTarget() - 1;\n                    break;\n                case '<=':\n                    $maxDepth = $comparator->getTarget();\n                    break;\n                default:\n                    $minDepth = $maxDepth = $comparator->getTarget();\n            }\n        }\n\n        $flags = \\RecursiveDirectoryIterator::SKIP_DOTS;\n\n        if ($this->followLinks) {\n            $flags |= \\RecursiveDirectoryIterator::FOLLOW_SYMLINKS;\n        }\n\n        $iterator = new Iterator\\RecursiveDirectoryIterator($dir, $flags, $this->ignoreUnreadableDirs);\n\n        if ($exclude) {\n            $iterator = new ExcludeDirectoryFilterIterator($iterator, $exclude);\n        }\n\n        $iterator = new \\RecursiveIteratorIterator($iterator, \\RecursiveIteratorIterator::SELF_FIRST);\n\n        if ($minDepth > 0 || $maxDepth < \\PHP_INT_MAX) {\n            $iterator = new DepthRangeFilterIterator($iterator, $minDepth, $maxDepth);\n        }\n\n        if ($this->mode) {\n            $iterator = new Iterator\\FileTypeFilterIterator($iterator, $this->mode);\n        }\n\n        if ($this->names || $this->notNames) {\n            $iterator = new FilenameFilterIterator($iterator, $this->names, $this->notNames);\n        }\n\n        if ($this->contains || $this->notContains) {\n            $iterator = new FilecontentFilterIterator($iterator, $this->contains, $this->notContains);\n        }\n\n        if ($this->sizes) {\n            $iterator = new SizeRangeFilterIterator($iterator, $this->sizes);\n        }\n\n        if ($this->dates) {\n            $iterator = new DateRangeFilterIterator($iterator, $this->dates);\n        }\n\n        if ($this->filters) {\n            $iterator = new CustomFilterIterator($iterator, $this->filters);\n        }\n\n        if ($this->paths || $notPaths) {\n            $iterator = new Iterator\\PathFilterIterator($iterator, $this->paths, $notPaths);\n        }\n\n        if (static::IGNORE_VCS_IGNORED_FILES === (static::IGNORE_VCS_IGNORED_FILES & $this->ignore)) {\n            $iterator = new Iterator\\VcsIgnoredFilterIterator($iterator, $dir);\n        }\n\n        return $iterator;\n    }\n\n    /**\n     * Normalizes given directory names by removing trailing slashes.\n     *\n     * Excluding: (s)ftp:// or ssh2.(s)ftp:// wrapper\n     */\n    private function normalizeDir(string $dir): string\n    {\n        if ('/' === $dir) {\n            return $dir;\n        }\n\n        $dir = rtrim($dir, '/'.\\DIRECTORY_SEPARATOR);\n\n        if (preg_match('#^(ssh2\\.)?s?ftp://#', $dir)) {\n            $dir .= '/';\n        }\n\n        return $dir;\n    }\n}\n"
        },
        {
          "name": "Gitignore.php",
          "type": "blob",
          "size": 2.94140625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Finder;\n\n/**\n * Gitignore matches against text.\n *\n * @author Michael Voříšek <vorismi3@fel.cvut.cz>\n * @author Ahmed Abdou <mail@ahmd.io>\n */\nclass Gitignore\n{\n    /**\n     * Returns a regexp which is the equivalent of the gitignore pattern.\n     *\n     * Format specification: https://git-scm.com/docs/gitignore#_pattern_format\n     */\n    public static function toRegex(string $gitignoreFileContent): string\n    {\n        return self::buildRegex($gitignoreFileContent, false);\n    }\n\n    public static function toRegexMatchingNegatedPatterns(string $gitignoreFileContent): string\n    {\n        return self::buildRegex($gitignoreFileContent, true);\n    }\n\n    private static function buildRegex(string $gitignoreFileContent, bool $inverted): string\n    {\n        $gitignoreFileContent = preg_replace('~(?<!\\\\\\\\)#[^\\n\\r]*~', '', $gitignoreFileContent);\n        $gitignoreLines = preg_split('~\\r\\n?|\\n~', $gitignoreFileContent);\n\n        $res = self::lineToRegex('');\n        foreach ($gitignoreLines as $line) {\n            $line = preg_replace('~(?<!\\\\\\\\)[ \\t]+$~', '', $line);\n\n            if (str_starts_with($line, '!')) {\n                $line = substr($line, 1);\n                $isNegative = true;\n            } else {\n                $isNegative = false;\n            }\n\n            if ('' !== $line) {\n                if ($isNegative xor $inverted) {\n                    $res = '(?!'.self::lineToRegex($line).'$)'.$res;\n                } else {\n                    $res = '(?:'.$res.'|'.self::lineToRegex($line).')';\n                }\n            }\n        }\n\n        return '~^(?:'.$res.')~s';\n    }\n\n    private static function lineToRegex(string $gitignoreLine): string\n    {\n        if ('' === $gitignoreLine) {\n            return '$f'; // always false\n        }\n\n        $slashPos = strpos($gitignoreLine, '/');\n        if (false !== $slashPos && \\strlen($gitignoreLine) - 1 !== $slashPos) {\n            if (0 === $slashPos) {\n                $gitignoreLine = substr($gitignoreLine, 1);\n            }\n            $isAbsolute = true;\n        } else {\n            $isAbsolute = false;\n        }\n\n        $regex = preg_quote(str_replace('\\\\', '', $gitignoreLine), '~');\n        $regex = preg_replace_callback('~\\\\\\\\\\[((?:\\\\\\\\!)?)([^\\[\\]]*)\\\\\\\\\\]~', fn (array $matches): string => '['.('' !== $matches[1] ? '^' : '').str_replace('\\\\-', '-', $matches[2]).']', $regex);\n        $regex = preg_replace('~(?:(?:\\\\\\\\\\*){2,}(/?))+~', '(?:(?:(?!//).(?<!//))+$1)?', $regex);\n        $regex = preg_replace('~\\\\\\\\\\*~', '[^/]*', $regex);\n        $regex = preg_replace('~\\\\\\\\\\?~', '[^/]', $regex);\n\n        return ($isAbsolute ? '' : '(?:[^/]+/)*')\n            .$regex\n            .(!str_ends_with($gitignoreLine, '/') ? '(?:$|/)' : '');\n    }\n}\n"
        },
        {
          "name": "Glob.php",
          "type": "blob",
          "size": 3.5146484375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Finder;\n\n/**\n * Glob matches globbing patterns against text.\n *\n *     if match_glob(\"foo.*\", \"foo.bar\") echo \"matched\\n\";\n *\n *     // prints foo.bar and foo.baz\n *     $regex = glob_to_regex(\"foo.*\");\n *     for (['foo.bar', 'foo.baz', 'foo', 'bar'] as $t)\n *     {\n *         if (/$regex/) echo \"matched: $car\\n\";\n *     }\n *\n * Glob implements glob(3) style matching that can be used to match\n * against text, rather than fetching names from a filesystem.\n *\n * Based on the Perl Text::Glob module.\n *\n * @author Fabien Potencier <fabien@symfony.com> PHP port\n * @author     Richard Clamp <richardc@unixbeard.net> Perl version\n * @copyright  2004-2005 Fabien Potencier <fabien@symfony.com>\n * @copyright  2002 Richard Clamp <richardc@unixbeard.net>\n */\nclass Glob\n{\n    /**\n     * Returns a regexp which is the equivalent of the glob pattern.\n     */\n    public static function toRegex(string $glob, bool $strictLeadingDot = true, bool $strictWildcardSlash = true, string $delimiter = '#'): string\n    {\n        $firstByte = true;\n        $escaping = false;\n        $inCurlies = 0;\n        $regex = '';\n        $sizeGlob = \\strlen($glob);\n        for ($i = 0; $i < $sizeGlob; ++$i) {\n            $car = $glob[$i];\n            if ($firstByte && $strictLeadingDot && '.' !== $car) {\n                $regex .= '(?=[^\\.])';\n            }\n\n            $firstByte = '/' === $car;\n\n            if ($firstByte && $strictWildcardSlash && isset($glob[$i + 2]) && '**' === $glob[$i + 1].$glob[$i + 2] && (!isset($glob[$i + 3]) || '/' === $glob[$i + 3])) {\n                $car = '[^/]++/';\n                if (!isset($glob[$i + 3])) {\n                    $car .= '?';\n                }\n\n                if ($strictLeadingDot) {\n                    $car = '(?=[^\\.])'.$car;\n                }\n\n                $car = '/(?:'.$car.')*';\n                $i += 2 + isset($glob[$i + 3]);\n\n                if ('/' === $delimiter) {\n                    $car = str_replace('/', '\\\\/', $car);\n                }\n            }\n\n            if ($delimiter === $car || '.' === $car || '(' === $car || ')' === $car || '|' === $car || '+' === $car || '^' === $car || '$' === $car) {\n                $regex .= \"\\\\$car\";\n            } elseif ('*' === $car) {\n                $regex .= $escaping ? '\\\\*' : ($strictWildcardSlash ? '[^/]*' : '.*');\n            } elseif ('?' === $car) {\n                $regex .= $escaping ? '\\\\?' : ($strictWildcardSlash ? '[^/]' : '.');\n            } elseif ('{' === $car) {\n                $regex .= $escaping ? '\\\\{' : '(';\n                if (!$escaping) {\n                    ++$inCurlies;\n                }\n            } elseif ('}' === $car && $inCurlies) {\n                $regex .= $escaping ? '}' : ')';\n                if (!$escaping) {\n                    --$inCurlies;\n                }\n            } elseif (',' === $car && $inCurlies) {\n                $regex .= $escaping ? ',' : '|';\n            } elseif ('\\\\' === $car) {\n                if ($escaping) {\n                    $regex .= '\\\\\\\\';\n                    $escaping = false;\n                } else {\n                    $escaping = true;\n                }\n\n                continue;\n            } else {\n                $regex .= $car;\n            }\n            $escaping = false;\n        }\n\n        return $delimiter.'^'.$regex.'$'.$delimiter;\n    }\n}\n"
        },
        {
          "name": "Iterator",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.4833984375,
          "content": "Finder Component\n================\n\nThe Finder component finds files and directories via an intuitive fluent\ninterface.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/finder.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "SplFileInfo.php",
          "type": "blob",
          "size": 1.8349609375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Finder;\n\n/**\n * Extends \\SplFileInfo to support relative paths.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass SplFileInfo extends \\SplFileInfo\n{\n    /**\n     * @param string $file             The file name\n     * @param string $relativePath     The relative path\n     * @param string $relativePathname The relative path name\n     */\n    public function __construct(\n        string $file,\n        private string $relativePath,\n        private string $relativePathname,\n    ) {\n        parent::__construct($file);\n    }\n\n    /**\n     * Returns the relative path.\n     *\n     * This path does not contain the file name.\n     */\n    public function getRelativePath(): string\n    {\n        return $this->relativePath;\n    }\n\n    /**\n     * Returns the relative path name.\n     *\n     * This path contains the file name.\n     */\n    public function getRelativePathname(): string\n    {\n        return $this->relativePathname;\n    }\n\n    public function getFilenameWithoutExtension(): string\n    {\n        $filename = $this->getFilename();\n\n        return pathinfo($filename, \\PATHINFO_FILENAME);\n    }\n\n    /**\n     * Returns the contents of the file.\n     *\n     * @throws \\RuntimeException\n     */\n    public function getContents(): string\n    {\n        set_error_handler(function ($type, $msg) use (&$error) { $error = $msg; });\n        try {\n            $content = file_get_contents($this->getPathname());\n        } finally {\n            restore_error_handler();\n        }\n        if (false === $content) {\n            throw new \\RuntimeException($error);\n        }\n\n        return $content;\n    }\n}\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.748046875,
          "content": "{\n    \"name\": \"symfony/finder\",\n    \"type\": \"library\",\n    \"description\": \"Finds files and directories via an intuitive fluent interface\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\"\n    },\n    \"require-dev\": {\n        \"symfony/filesystem\": \"^6.4|^7.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Finder\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.7978515625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Finder Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}