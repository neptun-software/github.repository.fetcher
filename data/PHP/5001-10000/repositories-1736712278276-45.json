{
  "metadata": {
    "timestamp": 1736712278276,
    "page": 45,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/polyfill-mbstring",
      "stars": 7844,
      "defaultBranch": "1.x",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2015-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Mbstring.php",
          "type": "blob",
          "size": 35.3232421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Mbstring;\n\n/**\n * Partial mbstring implementation in PHP, iconv based, UTF-8 centric.\n *\n * Implemented:\n * - mb_chr                  - Returns a specific character from its Unicode code point\n * - mb_convert_encoding     - Convert character encoding\n * - mb_convert_variables    - Convert character code in variable(s)\n * - mb_decode_mimeheader    - Decode string in MIME header field\n * - mb_encode_mimeheader    - Encode string for MIME header XXX NATIVE IMPLEMENTATION IS REALLY BUGGED\n * - mb_decode_numericentity - Decode HTML numeric string reference to character\n * - mb_encode_numericentity - Encode character to HTML numeric string reference\n * - mb_convert_case         - Perform case folding on a string\n * - mb_detect_encoding      - Detect character encoding\n * - mb_get_info             - Get internal settings of mbstring\n * - mb_http_input           - Detect HTTP input character encoding\n * - mb_http_output          - Set/Get HTTP output character encoding\n * - mb_internal_encoding    - Set/Get internal character encoding\n * - mb_list_encodings       - Returns an array of all supported encodings\n * - mb_ord                  - Returns the Unicode code point of a character\n * - mb_output_handler       - Callback function converts character encoding in output buffer\n * - mb_scrub                - Replaces ill-formed byte sequences with substitute characters\n * - mb_strlen               - Get string length\n * - mb_strpos               - Find position of first occurrence of string in a string\n * - mb_strrpos              - Find position of last occurrence of a string in a string\n * - mb_str_split            - Convert a string to an array\n * - mb_strtolower           - Make a string lowercase\n * - mb_strtoupper           - Make a string uppercase\n * - mb_substitute_character - Set/Get substitution character\n * - mb_substr               - Get part of string\n * - mb_stripos              - Finds position of first occurrence of a string within another, case insensitive\n * - mb_stristr              - Finds first occurrence of a string within another, case insensitive\n * - mb_strrchr              - Finds the last occurrence of a character in a string within another\n * - mb_strrichr             - Finds the last occurrence of a character in a string within another, case insensitive\n * - mb_strripos             - Finds position of last occurrence of a string within another, case insensitive\n * - mb_strstr               - Finds first occurrence of a string within another\n * - mb_strwidth             - Return width of string\n * - mb_substr_count         - Count the number of substring occurrences\n * - mb_ucfirst              - Make a string's first character uppercase\n * - mb_lcfirst              - Make a string's first character lowercase\n * - mb_trim                 - Strip whitespace (or other characters) from the beginning and end of a string\n * - mb_ltrim                - Strip whitespace (or other characters) from the beginning of a string\n * - mb_rtrim                - Strip whitespace (or other characters) from the end of a string\n *\n * Not implemented:\n * - mb_convert_kana         - Convert \"kana\" one from another (\"zen-kaku\", \"han-kaku\" and more)\n * - mb_ereg_*               - Regular expression with multibyte support\n * - mb_parse_str            - Parse GET/POST/COOKIE data and set global variable\n * - mb_preferred_mime_name  - Get MIME charset string\n * - mb_regex_encoding       - Returns current encoding for multibyte regex as string\n * - mb_regex_set_options    - Set/Get the default options for mbregex functions\n * - mb_send_mail            - Send encoded mail\n * - mb_split                - Split multibyte string using regular expression\n * - mb_strcut               - Get part of string\n * - mb_strimwidth           - Get truncated string with specified width\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @internal\n */\nfinal class Mbstring\n{\n    public const MB_CASE_FOLD = \\PHP_INT_MAX;\n\n    private const SIMPLE_CASE_FOLD = [\n        ['µ', 'ſ', \"\\xCD\\x85\", 'ς', \"\\xCF\\x90\", \"\\xCF\\x91\", \"\\xCF\\x95\", \"\\xCF\\x96\", \"\\xCF\\xB0\", \"\\xCF\\xB1\", \"\\xCF\\xB5\", \"\\xE1\\xBA\\x9B\", \"\\xE1\\xBE\\xBE\"],\n        ['μ', 's', 'ι',        'σ', 'β',        'θ',        'φ',        'π',        'κ',        'ρ',        'ε',        \"\\xE1\\xB9\\xA1\", 'ι'],\n    ];\n\n    private static $encodingList = ['ASCII', 'UTF-8'];\n    private static $language = 'neutral';\n    private static $internalEncoding = 'UTF-8';\n\n    public static function mb_convert_encoding($s, $toEncoding, $fromEncoding = null)\n    {\n        if (\\is_array($s)) {\n            $r = [];\n            foreach ($s as $str) {\n                $r[] = self::mb_convert_encoding($str, $toEncoding, $fromEncoding);\n            }\n\n            return $r;\n        }\n\n        if (\\is_array($fromEncoding) || (null !== $fromEncoding && false !== strpos($fromEncoding, ','))) {\n            $fromEncoding = self::mb_detect_encoding($s, $fromEncoding);\n        } else {\n            $fromEncoding = self::getEncoding($fromEncoding);\n        }\n\n        $toEncoding = self::getEncoding($toEncoding);\n\n        if ('BASE64' === $fromEncoding) {\n            $s = base64_decode($s);\n            $fromEncoding = $toEncoding;\n        }\n\n        if ('BASE64' === $toEncoding) {\n            return base64_encode($s);\n        }\n\n        if ('HTML-ENTITIES' === $toEncoding || 'HTML' === $toEncoding) {\n            if ('HTML-ENTITIES' === $fromEncoding || 'HTML' === $fromEncoding) {\n                $fromEncoding = 'Windows-1252';\n            }\n            if ('UTF-8' !== $fromEncoding) {\n                $s = iconv($fromEncoding, 'UTF-8//IGNORE', $s);\n            }\n\n            return preg_replace_callback('/[\\x80-\\xFF]+/', [__CLASS__, 'html_encoding_callback'], $s);\n        }\n\n        if ('HTML-ENTITIES' === $fromEncoding) {\n            $s = html_entity_decode($s, \\ENT_COMPAT, 'UTF-8');\n            $fromEncoding = 'UTF-8';\n        }\n\n        return iconv($fromEncoding, $toEncoding.'//IGNORE', $s);\n    }\n\n    public static function mb_convert_variables($toEncoding, $fromEncoding, &...$vars)\n    {\n        $ok = true;\n        array_walk_recursive($vars, function (&$v) use (&$ok, $toEncoding, $fromEncoding) {\n            if (false === $v = self::mb_convert_encoding($v, $toEncoding, $fromEncoding)) {\n                $ok = false;\n            }\n        });\n\n        return $ok ? $fromEncoding : false;\n    }\n\n    public static function mb_decode_mimeheader($s)\n    {\n        return iconv_mime_decode($s, 2, self::$internalEncoding);\n    }\n\n    public static function mb_encode_mimeheader($s, $charset = null, $transferEncoding = null, $linefeed = null, $indent = null)\n    {\n        trigger_error('mb_encode_mimeheader() is bugged. Please use iconv_mime_encode() instead', \\E_USER_WARNING);\n    }\n\n    public static function mb_decode_numericentity($s, $convmap, $encoding = null)\n    {\n        if (null !== $s && !\\is_scalar($s) && !(\\is_object($s) && method_exists($s, '__toString'))) {\n            trigger_error('mb_decode_numericentity() expects parameter 1 to be string, '.\\gettype($s).' given', \\E_USER_WARNING);\n\n            return null;\n        }\n\n        if (!\\is_array($convmap) || (80000 > \\PHP_VERSION_ID && !$convmap)) {\n            return false;\n        }\n\n        if (null !== $encoding && !\\is_scalar($encoding)) {\n            trigger_error('mb_decode_numericentity() expects parameter 3 to be string, '.\\gettype($s).' given', \\E_USER_WARNING);\n\n            return '';  // Instead of null (cf. mb_encode_numericentity).\n        }\n\n        $s = (string) $s;\n        if ('' === $s) {\n            return '';\n        }\n\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $encoding) {\n            $encoding = null;\n            if (!preg_match('//u', $s)) {\n                $s = @iconv('UTF-8', 'UTF-8//IGNORE', $s);\n            }\n        } else {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        $cnt = floor(\\count($convmap) / 4) * 4;\n\n        for ($i = 0; $i < $cnt; $i += 4) {\n            // collector_decode_htmlnumericentity ignores $convmap[$i + 3]\n            $convmap[$i] += $convmap[$i + 2];\n            $convmap[$i + 1] += $convmap[$i + 2];\n        }\n\n        $s = preg_replace_callback('/&#(?:0*([0-9]+)|x0*([0-9a-fA-F]+))(?!&);?/', function (array $m) use ($cnt, $convmap) {\n            $c = isset($m[2]) ? (int) hexdec($m[2]) : $m[1];\n            for ($i = 0; $i < $cnt; $i += 4) {\n                if ($c >= $convmap[$i] && $c <= $convmap[$i + 1]) {\n                    return self::mb_chr($c - $convmap[$i + 2]);\n                }\n            }\n\n            return $m[0];\n        }, $s);\n\n        if (null === $encoding) {\n            return $s;\n        }\n\n        return iconv('UTF-8', $encoding.'//IGNORE', $s);\n    }\n\n    public static function mb_encode_numericentity($s, $convmap, $encoding = null, $is_hex = false)\n    {\n        if (null !== $s && !\\is_scalar($s) && !(\\is_object($s) && method_exists($s, '__toString'))) {\n            trigger_error('mb_encode_numericentity() expects parameter 1 to be string, '.\\gettype($s).' given', \\E_USER_WARNING);\n\n            return null;\n        }\n\n        if (!\\is_array($convmap) || (80000 > \\PHP_VERSION_ID && !$convmap)) {\n            return false;\n        }\n\n        if (null !== $encoding && !\\is_scalar($encoding)) {\n            trigger_error('mb_encode_numericentity() expects parameter 3 to be string, '.\\gettype($s).' given', \\E_USER_WARNING);\n\n            return null;  // Instead of '' (cf. mb_decode_numericentity).\n        }\n\n        if (null !== $is_hex && !\\is_scalar($is_hex)) {\n            trigger_error('mb_encode_numericentity() expects parameter 4 to be boolean, '.\\gettype($s).' given', \\E_USER_WARNING);\n\n            return null;\n        }\n\n        $s = (string) $s;\n        if ('' === $s) {\n            return '';\n        }\n\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $encoding) {\n            $encoding = null;\n            if (!preg_match('//u', $s)) {\n                $s = @iconv('UTF-8', 'UTF-8//IGNORE', $s);\n            }\n        } else {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        static $ulenMask = [\"\\xC0\" => 2, \"\\xD0\" => 2, \"\\xE0\" => 3, \"\\xF0\" => 4];\n\n        $cnt = floor(\\count($convmap) / 4) * 4;\n        $i = 0;\n        $len = \\strlen($s);\n        $result = '';\n\n        while ($i < $len) {\n            $ulen = $s[$i] < \"\\x80\" ? 1 : $ulenMask[$s[$i] & \"\\xF0\"];\n            $uchr = substr($s, $i, $ulen);\n            $i += $ulen;\n            $c = self::mb_ord($uchr);\n\n            for ($j = 0; $j < $cnt; $j += 4) {\n                if ($c >= $convmap[$j] && $c <= $convmap[$j + 1]) {\n                    $cOffset = ($c + $convmap[$j + 2]) & $convmap[$j + 3];\n                    $result .= $is_hex ? sprintf('&#x%X;', $cOffset) : '&#'.$cOffset.';';\n                    continue 2;\n                }\n            }\n            $result .= $uchr;\n        }\n\n        if (null === $encoding) {\n            return $result;\n        }\n\n        return iconv('UTF-8', $encoding.'//IGNORE', $result);\n    }\n\n    public static function mb_convert_case($s, $mode, $encoding = null)\n    {\n        $s = (string) $s;\n        if ('' === $s) {\n            return '';\n        }\n\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $encoding) {\n            $encoding = null;\n            if (!preg_match('//u', $s)) {\n                $s = @iconv('UTF-8', 'UTF-8//IGNORE', $s);\n            }\n        } else {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        if (\\MB_CASE_TITLE == $mode) {\n            static $titleRegexp = null;\n            if (null === $titleRegexp) {\n                $titleRegexp = self::getData('titleCaseRegexp');\n            }\n            $s = preg_replace_callback($titleRegexp, [__CLASS__, 'title_case'], $s);\n        } else {\n            if (\\MB_CASE_UPPER == $mode) {\n                static $upper = null;\n                if (null === $upper) {\n                    $upper = self::getData('upperCase');\n                }\n                $map = $upper;\n            } else {\n                if (self::MB_CASE_FOLD === $mode) {\n                    static $caseFolding = null;\n                    if (null === $caseFolding) {\n                        $caseFolding = self::getData('caseFolding');\n                    }\n                    $s = strtr($s, $caseFolding);\n                }\n\n                static $lower = null;\n                if (null === $lower) {\n                    $lower = self::getData('lowerCase');\n                }\n                $map = $lower;\n            }\n\n            static $ulenMask = [\"\\xC0\" => 2, \"\\xD0\" => 2, \"\\xE0\" => 3, \"\\xF0\" => 4];\n\n            $i = 0;\n            $len = \\strlen($s);\n\n            while ($i < $len) {\n                $ulen = $s[$i] < \"\\x80\" ? 1 : $ulenMask[$s[$i] & \"\\xF0\"];\n                $uchr = substr($s, $i, $ulen);\n                $i += $ulen;\n\n                if (isset($map[$uchr])) {\n                    $uchr = $map[$uchr];\n                    $nlen = \\strlen($uchr);\n\n                    if ($nlen == $ulen) {\n                        $nlen = $i;\n                        do {\n                            $s[--$nlen] = $uchr[--$ulen];\n                        } while ($ulen);\n                    } else {\n                        $s = substr_replace($s, $uchr, $i - $ulen, $ulen);\n                        $len += $nlen - $ulen;\n                        $i += $nlen - $ulen;\n                    }\n                }\n            }\n        }\n\n        if (null === $encoding) {\n            return $s;\n        }\n\n        return iconv('UTF-8', $encoding.'//IGNORE', $s);\n    }\n\n    public static function mb_internal_encoding($encoding = null)\n    {\n        if (null === $encoding) {\n            return self::$internalEncoding;\n        }\n\n        $normalizedEncoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $normalizedEncoding || false !== @iconv($normalizedEncoding, $normalizedEncoding, ' ')) {\n            self::$internalEncoding = $normalizedEncoding;\n\n            return true;\n        }\n\n        if (80000 > \\PHP_VERSION_ID) {\n            return false;\n        }\n\n        throw new \\ValueError(sprintf('Argument #1 ($encoding) must be a valid encoding, \"%s\" given', $encoding));\n    }\n\n    public static function mb_language($lang = null)\n    {\n        if (null === $lang) {\n            return self::$language;\n        }\n\n        switch ($normalizedLang = strtolower($lang)) {\n            case 'uni':\n            case 'neutral':\n                self::$language = $normalizedLang;\n\n                return true;\n        }\n\n        if (80000 > \\PHP_VERSION_ID) {\n            return false;\n        }\n\n        throw new \\ValueError(sprintf('Argument #1 ($language) must be a valid language, \"%s\" given', $lang));\n    }\n\n    public static function mb_list_encodings()\n    {\n        return ['UTF-8'];\n    }\n\n    public static function mb_encoding_aliases($encoding)\n    {\n        switch (strtoupper($encoding)) {\n            case 'UTF8':\n            case 'UTF-8':\n                return ['utf8'];\n        }\n\n        return false;\n    }\n\n    public static function mb_check_encoding($var = null, $encoding = null)\n    {\n        if (null === $encoding) {\n            if (null === $var) {\n                return false;\n            }\n            $encoding = self::$internalEncoding;\n        }\n\n        if (!\\is_array($var)) {\n            return self::mb_detect_encoding($var, [$encoding]) || false !== @iconv($encoding, $encoding, $var);\n        }\n\n        foreach ($var as $key => $value) {\n            if (!self::mb_check_encoding($key, $encoding)) {\n                return false;\n            }\n            if (!self::mb_check_encoding($value, $encoding)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static function mb_detect_encoding($str, $encodingList = null, $strict = false)\n    {\n        if (null === $encodingList) {\n            $encodingList = self::$encodingList;\n        } else {\n            if (!\\is_array($encodingList)) {\n                $encodingList = array_map('trim', explode(',', $encodingList));\n            }\n            $encodingList = array_map('strtoupper', $encodingList);\n        }\n\n        foreach ($encodingList as $enc) {\n            switch ($enc) {\n                case 'ASCII':\n                    if (!preg_match('/[\\x80-\\xFF]/', $str)) {\n                        return $enc;\n                    }\n                    break;\n\n                case 'UTF8':\n                case 'UTF-8':\n                    if (preg_match('//u', $str)) {\n                        return 'UTF-8';\n                    }\n                    break;\n\n                default:\n                    if (0 === strncmp($enc, 'ISO-8859-', 9)) {\n                        return $enc;\n                    }\n            }\n        }\n\n        return false;\n    }\n\n    public static function mb_detect_order($encodingList = null)\n    {\n        if (null === $encodingList) {\n            return self::$encodingList;\n        }\n\n        if (!\\is_array($encodingList)) {\n            $encodingList = array_map('trim', explode(',', $encodingList));\n        }\n        $encodingList = array_map('strtoupper', $encodingList);\n\n        foreach ($encodingList as $enc) {\n            switch ($enc) {\n                default:\n                    if (strncmp($enc, 'ISO-8859-', 9)) {\n                        return false;\n                    }\n                    // no break\n                case 'ASCII':\n                case 'UTF8':\n                case 'UTF-8':\n            }\n        }\n\n        self::$encodingList = $encodingList;\n\n        return true;\n    }\n\n    public static function mb_strlen($s, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return \\strlen($s);\n        }\n\n        return @iconv_strlen($s, $encoding);\n    }\n\n    public static function mb_strpos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return strpos($haystack, $needle, $offset);\n        }\n\n        $needle = (string) $needle;\n        if ('' === $needle) {\n            if (80000 > \\PHP_VERSION_ID) {\n                trigger_error(__METHOD__.': Empty delimiter', \\E_USER_WARNING);\n\n                return false;\n            }\n\n            return 0;\n        }\n\n        return iconv_strpos($haystack, $needle, $offset, $encoding);\n    }\n\n    public static function mb_strrpos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return strrpos($haystack, $needle, $offset);\n        }\n\n        if ($offset != (int) $offset) {\n            $offset = 0;\n        } elseif ($offset = (int) $offset) {\n            if ($offset < 0) {\n                if (0 > $offset += self::mb_strlen($needle)) {\n                    $haystack = self::mb_substr($haystack, 0, $offset, $encoding);\n                }\n                $offset = 0;\n            } else {\n                $haystack = self::mb_substr($haystack, $offset, 2147483647, $encoding);\n            }\n        }\n\n        $pos = '' !== $needle || 80000 > \\PHP_VERSION_ID\n            ? iconv_strrpos($haystack, $needle, $encoding)\n            : self::mb_strlen($haystack, $encoding);\n\n        return false !== $pos ? $offset + $pos : false;\n    }\n\n    public static function mb_str_split($string, $split_length = 1, $encoding = null)\n    {\n        if (null !== $string && !\\is_scalar($string) && !(\\is_object($string) && method_exists($string, '__toString'))) {\n            trigger_error('mb_str_split() expects parameter 1 to be string, '.\\gettype($string).' given', \\E_USER_WARNING);\n\n            return null;\n        }\n\n        if (1 > $split_length = (int) $split_length) {\n            if (80000 > \\PHP_VERSION_ID) {\n                trigger_error('The length of each segment must be greater than zero', \\E_USER_WARNING);\n\n                return false;\n            }\n\n            throw new \\ValueError('Argument #2 ($length) must be greater than 0');\n        }\n\n        if (null === $encoding) {\n            $encoding = mb_internal_encoding();\n        }\n\n        if ('UTF-8' === $encoding = self::getEncoding($encoding)) {\n            $rx = '/(';\n            while (65535 < $split_length) {\n                $rx .= '.{65535}';\n                $split_length -= 65535;\n            }\n            $rx .= '.{'.$split_length.'})/us';\n\n            return preg_split($rx, $string, -1, \\PREG_SPLIT_DELIM_CAPTURE | \\PREG_SPLIT_NO_EMPTY);\n        }\n\n        $result = [];\n        $length = mb_strlen($string, $encoding);\n\n        for ($i = 0; $i < $length; $i += $split_length) {\n            $result[] = mb_substr($string, $i, $split_length, $encoding);\n        }\n\n        return $result;\n    }\n\n    public static function mb_strtolower($s, $encoding = null)\n    {\n        return self::mb_convert_case($s, \\MB_CASE_LOWER, $encoding);\n    }\n\n    public static function mb_strtoupper($s, $encoding = null)\n    {\n        return self::mb_convert_case($s, \\MB_CASE_UPPER, $encoding);\n    }\n\n    public static function mb_substitute_character($c = null)\n    {\n        if (null === $c) {\n            return 'none';\n        }\n        if (0 === strcasecmp($c, 'none')) {\n            return true;\n        }\n        if (80000 > \\PHP_VERSION_ID) {\n            return false;\n        }\n        if (\\is_int($c) || 'long' === $c || 'entity' === $c) {\n            return false;\n        }\n\n        throw new \\ValueError('Argument #1 ($substitute_character) must be \"none\", \"long\", \"entity\" or a valid codepoint');\n    }\n\n    public static function mb_substr($s, $start, $length = null, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return (string) substr($s, $start, null === $length ? 2147483647 : $length);\n        }\n\n        if ($start < 0) {\n            $start = iconv_strlen($s, $encoding) + $start;\n            if ($start < 0) {\n                $start = 0;\n            }\n        }\n\n        if (null === $length) {\n            $length = 2147483647;\n        } elseif ($length < 0) {\n            $length = iconv_strlen($s, $encoding) + $length - $start;\n            if ($length < 0) {\n                return '';\n            }\n        }\n\n        return (string) iconv_substr($s, $start, $length, $encoding);\n    }\n\n    public static function mb_stripos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        [$haystack, $needle] = str_replace(self::SIMPLE_CASE_FOLD[0], self::SIMPLE_CASE_FOLD[1], [\n            self::mb_convert_case($haystack, \\MB_CASE_LOWER, $encoding),\n            self::mb_convert_case($needle, \\MB_CASE_LOWER, $encoding),\n        ]);\n\n        return self::mb_strpos($haystack, $needle, $offset, $encoding);\n    }\n\n    public static function mb_stristr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $pos = self::mb_stripos($haystack, $needle, 0, $encoding);\n\n        return self::getSubpart($pos, $part, $haystack, $encoding);\n    }\n\n    public static function mb_strrchr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            $pos = strrpos($haystack, $needle);\n        } else {\n            $needle = self::mb_substr($needle, 0, 1, $encoding);\n            $pos = iconv_strrpos($haystack, $needle, $encoding);\n        }\n\n        return self::getSubpart($pos, $part, $haystack, $encoding);\n    }\n\n    public static function mb_strrichr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $needle = self::mb_substr($needle, 0, 1, $encoding);\n        $pos = self::mb_strripos($haystack, $needle, $encoding);\n\n        return self::getSubpart($pos, $part, $haystack, $encoding);\n    }\n\n    public static function mb_strripos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        $haystack = self::mb_convert_case($haystack, \\MB_CASE_LOWER, $encoding);\n        $needle = self::mb_convert_case($needle, \\MB_CASE_LOWER, $encoding);\n\n        $haystack = str_replace(self::SIMPLE_CASE_FOLD[0], self::SIMPLE_CASE_FOLD[1], $haystack);\n        $needle = str_replace(self::SIMPLE_CASE_FOLD[0], self::SIMPLE_CASE_FOLD[1], $needle);\n\n        return self::mb_strrpos($haystack, $needle, $offset, $encoding);\n    }\n\n    public static function mb_strstr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $pos = strpos($haystack, $needle);\n        if (false === $pos) {\n            return false;\n        }\n        if ($part) {\n            return substr($haystack, 0, $pos);\n        }\n\n        return substr($haystack, $pos);\n    }\n\n    public static function mb_get_info($type = 'all')\n    {\n        $info = [\n            'internal_encoding' => self::$internalEncoding,\n            'http_output' => 'pass',\n            'http_output_conv_mimetypes' => '^(text/|application/xhtml\\+xml)',\n            'func_overload' => 0,\n            'func_overload_list' => 'no overload',\n            'mail_charset' => 'UTF-8',\n            'mail_header_encoding' => 'BASE64',\n            'mail_body_encoding' => 'BASE64',\n            'illegal_chars' => 0,\n            'encoding_translation' => 'Off',\n            'language' => self::$language,\n            'detect_order' => self::$encodingList,\n            'substitute_character' => 'none',\n            'strict_detection' => 'Off',\n        ];\n\n        if ('all' === $type) {\n            return $info;\n        }\n        if (isset($info[$type])) {\n            return $info[$type];\n        }\n\n        return false;\n    }\n\n    public static function mb_http_input($type = '')\n    {\n        return false;\n    }\n\n    public static function mb_http_output($encoding = null)\n    {\n        return null !== $encoding ? 'pass' === $encoding : 'pass';\n    }\n\n    public static function mb_strwidth($s, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' !== $encoding) {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        $s = preg_replace('/[\\x{1100}-\\x{115F}\\x{2329}\\x{232A}\\x{2E80}-\\x{303E}\\x{3040}-\\x{A4CF}\\x{AC00}-\\x{D7A3}\\x{F900}-\\x{FAFF}\\x{FE10}-\\x{FE19}\\x{FE30}-\\x{FE6F}\\x{FF00}-\\x{FF60}\\x{FFE0}-\\x{FFE6}\\x{20000}-\\x{2FFFD}\\x{30000}-\\x{3FFFD}]/u', '', $s, -1, $wide);\n\n        return ($wide << 1) + iconv_strlen($s, 'UTF-8');\n    }\n\n    public static function mb_substr_count($haystack, $needle, $encoding = null)\n    {\n        return substr_count($haystack, $needle);\n    }\n\n    public static function mb_output_handler($contents, $status)\n    {\n        return $contents;\n    }\n\n    public static function mb_chr($code, $encoding = null)\n    {\n        if (0x80 > $code %= 0x200000) {\n            $s = \\chr($code);\n        } elseif (0x800 > $code) {\n            $s = \\chr(0xC0 | $code >> 6).\\chr(0x80 | $code & 0x3F);\n        } elseif (0x10000 > $code) {\n            $s = \\chr(0xE0 | $code >> 12).\\chr(0x80 | $code >> 6 & 0x3F).\\chr(0x80 | $code & 0x3F);\n        } else {\n            $s = \\chr(0xF0 | $code >> 18).\\chr(0x80 | $code >> 12 & 0x3F).\\chr(0x80 | $code >> 6 & 0x3F).\\chr(0x80 | $code & 0x3F);\n        }\n\n        if ('UTF-8' !== $encoding = self::getEncoding($encoding)) {\n            $s = mb_convert_encoding($s, $encoding, 'UTF-8');\n        }\n\n        return $s;\n    }\n\n    public static function mb_ord($s, $encoding = null)\n    {\n        if ('UTF-8' !== $encoding = self::getEncoding($encoding)) {\n            $s = mb_convert_encoding($s, 'UTF-8', $encoding);\n        }\n\n        if (1 === \\strlen($s)) {\n            return \\ord($s);\n        }\n\n        $code = ($s = unpack('C*', substr($s, 0, 4))) ? $s[1] : 0;\n        if (0xF0 <= $code) {\n            return (($code - 0xF0) << 18) + (($s[2] - 0x80) << 12) + (($s[3] - 0x80) << 6) + $s[4] - 0x80;\n        }\n        if (0xE0 <= $code) {\n            return (($code - 0xE0) << 12) + (($s[2] - 0x80) << 6) + $s[3] - 0x80;\n        }\n        if (0xC0 <= $code) {\n            return (($code - 0xC0) << 6) + $s[2] - 0x80;\n        }\n\n        return $code;\n    }\n\n    public static function mb_str_pad(string $string, int $length, string $pad_string = ' ', int $pad_type = \\STR_PAD_RIGHT, ?string $encoding = null): string\n    {\n        if (!\\in_array($pad_type, [\\STR_PAD_RIGHT, \\STR_PAD_LEFT, \\STR_PAD_BOTH], true)) {\n            throw new \\ValueError('mb_str_pad(): Argument #4 ($pad_type) must be STR_PAD_LEFT, STR_PAD_RIGHT, or STR_PAD_BOTH');\n        }\n\n        if (null === $encoding) {\n            $encoding = self::mb_internal_encoding();\n        } else {\n            self::assertEncoding($encoding, 'mb_str_pad(): Argument #5 ($encoding) must be a valid encoding, \"%s\" given');\n        }\n\n        if (self::mb_strlen($pad_string, $encoding) <= 0) {\n            throw new \\ValueError('mb_str_pad(): Argument #3 ($pad_string) must be a non-empty string');\n        }\n\n        $paddingRequired = $length - self::mb_strlen($string, $encoding);\n\n        if ($paddingRequired < 1) {\n            return $string;\n        }\n\n        switch ($pad_type) {\n            case \\STR_PAD_LEFT:\n                return self::mb_substr(str_repeat($pad_string, $paddingRequired), 0, $paddingRequired, $encoding).$string;\n            case \\STR_PAD_RIGHT:\n                return $string.self::mb_substr(str_repeat($pad_string, $paddingRequired), 0, $paddingRequired, $encoding);\n            default:\n                $leftPaddingLength = floor($paddingRequired / 2);\n                $rightPaddingLength = $paddingRequired - $leftPaddingLength;\n\n                return self::mb_substr(str_repeat($pad_string, $leftPaddingLength), 0, $leftPaddingLength, $encoding).$string.self::mb_substr(str_repeat($pad_string, $rightPaddingLength), 0, $rightPaddingLength, $encoding);\n        }\n    }\n\n    public static function mb_ucfirst(string $string, ?string $encoding = null): string\n    {\n        if (null === $encoding) {\n            $encoding = self::mb_internal_encoding();\n        } else {\n            self::assertEncoding($encoding, 'mb_ucfirst(): Argument #2 ($encoding) must be a valid encoding, \"%s\" given');\n        }\n\n        $firstChar = mb_substr($string, 0, 1, $encoding);\n        $firstChar = mb_convert_case($firstChar, \\MB_CASE_TITLE, $encoding);\n\n        return $firstChar.mb_substr($string, 1, null, $encoding);\n    }\n\n    public static function mb_lcfirst(string $string, ?string $encoding = null): string\n    {\n        if (null === $encoding) {\n            $encoding = self::mb_internal_encoding();\n        } else {\n            self::assertEncoding($encoding, 'mb_lcfirst(): Argument #2 ($encoding) must be a valid encoding, \"%s\" given');\n        }\n\n        $firstChar = mb_substr($string, 0, 1, $encoding);\n        $firstChar = mb_convert_case($firstChar, \\MB_CASE_LOWER, $encoding);\n\n        return $firstChar.mb_substr($string, 1, null, $encoding);\n    }\n\n    private static function getSubpart($pos, $part, $haystack, $encoding)\n    {\n        if (false === $pos) {\n            return false;\n        }\n        if ($part) {\n            return self::mb_substr($haystack, 0, $pos, $encoding);\n        }\n\n        return self::mb_substr($haystack, $pos, null, $encoding);\n    }\n\n    private static function html_encoding_callback(array $m)\n    {\n        $i = 1;\n        $entities = '';\n        $m = unpack('C*', htmlentities($m[0], \\ENT_COMPAT, 'UTF-8'));\n\n        while (isset($m[$i])) {\n            if (0x80 > $m[$i]) {\n                $entities .= \\chr($m[$i++]);\n                continue;\n            }\n            if (0xF0 <= $m[$i]) {\n                $c = (($m[$i++] - 0xF0) << 18) + (($m[$i++] - 0x80) << 12) + (($m[$i++] - 0x80) << 6) + $m[$i++] - 0x80;\n            } elseif (0xE0 <= $m[$i]) {\n                $c = (($m[$i++] - 0xE0) << 12) + (($m[$i++] - 0x80) << 6) + $m[$i++] - 0x80;\n            } else {\n                $c = (($m[$i++] - 0xC0) << 6) + $m[$i++] - 0x80;\n            }\n\n            $entities .= '&#'.$c.';';\n        }\n\n        return $entities;\n    }\n\n    private static function title_case(array $s)\n    {\n        return self::mb_convert_case($s[1], \\MB_CASE_UPPER, 'UTF-8').self::mb_convert_case($s[2], \\MB_CASE_LOWER, 'UTF-8');\n    }\n\n    private static function getData($file)\n    {\n        if (file_exists($file = __DIR__.'/Resources/unidata/'.$file.'.php')) {\n            return require $file;\n        }\n\n        return false;\n    }\n\n    private static function getEncoding($encoding)\n    {\n        if (null === $encoding) {\n            return self::$internalEncoding;\n        }\n\n        if ('UTF-8' === $encoding) {\n            return 'UTF-8';\n        }\n\n        $encoding = strtoupper($encoding);\n\n        if ('8BIT' === $encoding || 'BINARY' === $encoding) {\n            return 'CP850';\n        }\n\n        if ('UTF8' === $encoding) {\n            return 'UTF-8';\n        }\n\n        return $encoding;\n    }\n\n    public static function mb_trim(string $string, ?string $characters = null, ?string $encoding = null): string\n    {\n        return self::mb_internal_trim('{^[%s]+|[%1$s]+$}Du', $string, $characters, $encoding, __FUNCTION__);\n    }\n\n    public static function mb_ltrim(string $string, ?string $characters = null, ?string $encoding = null): string\n    {\n        return self::mb_internal_trim('{^[%s]+}Du', $string, $characters, $encoding, __FUNCTION__);\n    }\n\n    public static function mb_rtrim(string $string, ?string $characters = null, ?string $encoding = null): string\n    {\n        return self::mb_internal_trim('{[%s]+$}Du', $string, $characters, $encoding, __FUNCTION__);\n    }\n\n    private static function mb_internal_trim(string $regex, string $string, ?string $characters, ?string $encoding, string $function): string\n    {\n        if (null === $encoding) {\n            $encoding = self::mb_internal_encoding();\n        } else {\n            self::assertEncoding($encoding, $function.'(): Argument #3 ($encoding) must be a valid encoding, \"%s\" given');\n        }\n\n        if ('' === $characters) {\n            return null === $encoding ? $string : self::mb_convert_encoding($string, $encoding);\n        }\n\n        if ('UTF-8' === $encoding) {\n            $encoding = null;\n            if (!preg_match('//u', $string)) {\n                $string = @iconv('UTF-8', 'UTF-8//IGNORE', $string);\n            }\n            if (null !== $characters && !preg_match('//u', $characters)) {\n                $characters = @iconv('UTF-8', 'UTF-8//IGNORE', $characters);\n            }\n        } else {\n            $string = iconv($encoding, 'UTF-8//IGNORE', $string);\n\n            if (null !== $characters) {\n                $characters = iconv($encoding, 'UTF-8//IGNORE', $characters);\n            }\n        }\n\n        if (null === $characters) {\n            $characters = \"\\\\0 \\f\\n\\r\\t\\v\\u{00A0}\\u{1680}\\u{2000}\\u{2001}\\u{2002}\\u{2003}\\u{2004}\\u{2005}\\u{2006}\\u{2007}\\u{2008}\\u{2009}\\u{200A}\\u{2028}\\u{2029}\\u{202F}\\u{205F}\\u{3000}\\u{0085}\\u{180E}\";\n        } else {\n            $characters = preg_quote($characters);\n        }\n\n        $string = preg_replace(sprintf($regex, $characters), '', $string);\n\n        if (null === $encoding) {\n            return $string;\n        }\n\n        return iconv('UTF-8', $encoding.'//IGNORE', $string);\n    }\n\n    private static function assertEncoding(string $encoding, string $errorFormat): void\n    {\n        try {\n            $validEncoding = @self::mb_check_encoding('', $encoding);\n        } catch (\\ValueError $e) {\n            throw new \\ValueError(sprintf($errorFormat, $encoding));\n        }\n\n        // BC for PHP 7.3 and lower\n        if (!$validEncoding) {\n            throw new \\ValueError(sprintf($errorFormat, $encoding));\n        }\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.361328125,
          "content": "Symfony Polyfill / Mbstring\n===========================\n\nThis component provides a partial, native PHP implementation for the\n[Mbstring](https://php.net/mbstring) extension.\n\nMore information can be found in the\n[main Polyfill README](https://github.com/symfony/polyfill/blob/main/README.md).\n\nLicense\n=======\n\nThis library is released under the [MIT license](LICENSE).\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "bootstrap.php",
          "type": "blob",
          "size": 8.2646484375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Mbstring as p;\n\nif (\\PHP_VERSION_ID >= 80000) {\n    return require __DIR__.'/bootstrap80.php';\n}\n\nif (!function_exists('mb_convert_encoding')) {\n    function mb_convert_encoding($string, $to_encoding, $from_encoding = null) { return p\\Mbstring::mb_convert_encoding($string, $to_encoding, $from_encoding); }\n}\nif (!function_exists('mb_decode_mimeheader')) {\n    function mb_decode_mimeheader($string) { return p\\Mbstring::mb_decode_mimeheader($string); }\n}\nif (!function_exists('mb_encode_mimeheader')) {\n    function mb_encode_mimeheader($string, $charset = null, $transfer_encoding = null, $newline = \"\\r\\n\", $indent = 0) { return p\\Mbstring::mb_encode_mimeheader($string, $charset, $transfer_encoding, $newline, $indent); }\n}\nif (!function_exists('mb_decode_numericentity')) {\n    function mb_decode_numericentity($string, $map, $encoding = null) { return p\\Mbstring::mb_decode_numericentity($string, $map, $encoding); }\n}\nif (!function_exists('mb_encode_numericentity')) {\n    function mb_encode_numericentity($string, $map, $encoding = null, $hex = false) { return p\\Mbstring::mb_encode_numericentity($string, $map, $encoding, $hex); }\n}\nif (!function_exists('mb_convert_case')) {\n    function mb_convert_case($string, $mode, $encoding = null) { return p\\Mbstring::mb_convert_case($string, $mode, $encoding); }\n}\nif (!function_exists('mb_internal_encoding')) {\n    function mb_internal_encoding($encoding = null) { return p\\Mbstring::mb_internal_encoding($encoding); }\n}\nif (!function_exists('mb_language')) {\n    function mb_language($language = null) { return p\\Mbstring::mb_language($language); }\n}\nif (!function_exists('mb_list_encodings')) {\n    function mb_list_encodings() { return p\\Mbstring::mb_list_encodings(); }\n}\nif (!function_exists('mb_encoding_aliases')) {\n    function mb_encoding_aliases($encoding) { return p\\Mbstring::mb_encoding_aliases($encoding); }\n}\nif (!function_exists('mb_check_encoding')) {\n    function mb_check_encoding($value = null, $encoding = null) { return p\\Mbstring::mb_check_encoding($value, $encoding); }\n}\nif (!function_exists('mb_detect_encoding')) {\n    function mb_detect_encoding($string, $encodings = null, $strict = false) { return p\\Mbstring::mb_detect_encoding($string, $encodings, $strict); }\n}\nif (!function_exists('mb_detect_order')) {\n    function mb_detect_order($encoding = null) { return p\\Mbstring::mb_detect_order($encoding); }\n}\nif (!function_exists('mb_parse_str')) {\n    function mb_parse_str($string, &$result = []) { parse_str($string, $result); return (bool) $result; }\n}\nif (!function_exists('mb_strlen')) {\n    function mb_strlen($string, $encoding = null) { return p\\Mbstring::mb_strlen($string, $encoding); }\n}\nif (!function_exists('mb_strpos')) {\n    function mb_strpos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_strpos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_strtolower')) {\n    function mb_strtolower($string, $encoding = null) { return p\\Mbstring::mb_strtolower($string, $encoding); }\n}\nif (!function_exists('mb_strtoupper')) {\n    function mb_strtoupper($string, $encoding = null) { return p\\Mbstring::mb_strtoupper($string, $encoding); }\n}\nif (!function_exists('mb_substitute_character')) {\n    function mb_substitute_character($substitute_character = null) { return p\\Mbstring::mb_substitute_character($substitute_character); }\n}\nif (!function_exists('mb_substr')) {\n    function mb_substr($string, $start, $length = 2147483647, $encoding = null) { return p\\Mbstring::mb_substr($string, $start, $length, $encoding); }\n}\nif (!function_exists('mb_stripos')) {\n    function mb_stripos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_stripos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_stristr')) {\n    function mb_stristr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_stristr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_strrchr')) {\n    function mb_strrchr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_strrchr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_strrichr')) {\n    function mb_strrichr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_strrichr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_strripos')) {\n    function mb_strripos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_strripos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_strrpos')) {\n    function mb_strrpos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_strrpos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_strstr')) {\n    function mb_strstr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_strstr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_get_info')) {\n    function mb_get_info($type = 'all') { return p\\Mbstring::mb_get_info($type); }\n}\nif (!function_exists('mb_http_output')) {\n    function mb_http_output($encoding = null) { return p\\Mbstring::mb_http_output($encoding); }\n}\nif (!function_exists('mb_strwidth')) {\n    function mb_strwidth($string, $encoding = null) { return p\\Mbstring::mb_strwidth($string, $encoding); }\n}\nif (!function_exists('mb_substr_count')) {\n    function mb_substr_count($haystack, $needle, $encoding = null) { return p\\Mbstring::mb_substr_count($haystack, $needle, $encoding); }\n}\nif (!function_exists('mb_output_handler')) {\n    function mb_output_handler($string, $status) { return p\\Mbstring::mb_output_handler($string, $status); }\n}\nif (!function_exists('mb_http_input')) {\n    function mb_http_input($type = null) { return p\\Mbstring::mb_http_input($type); }\n}\n\nif (!function_exists('mb_convert_variables')) {\n    function mb_convert_variables($to_encoding, $from_encoding, &...$vars) { return p\\Mbstring::mb_convert_variables($to_encoding, $from_encoding, ...$vars); }\n}\n\nif (!function_exists('mb_ord')) {\n    function mb_ord($string, $encoding = null) { return p\\Mbstring::mb_ord($string, $encoding); }\n}\nif (!function_exists('mb_chr')) {\n    function mb_chr($codepoint, $encoding = null) { return p\\Mbstring::mb_chr($codepoint, $encoding); }\n}\nif (!function_exists('mb_scrub')) {\n    function mb_scrub($string, $encoding = null) { $encoding = null === $encoding ? mb_internal_encoding() : $encoding; return mb_convert_encoding($string, $encoding, $encoding); }\n}\nif (!function_exists('mb_str_split')) {\n    function mb_str_split($string, $length = 1, $encoding = null) { return p\\Mbstring::mb_str_split($string, $length, $encoding); }\n}\n\nif (!function_exists('mb_str_pad')) {\n    function mb_str_pad(string $string, int $length, string $pad_string = ' ', int $pad_type = STR_PAD_RIGHT, ?string $encoding = null): string { return p\\Mbstring::mb_str_pad($string, $length, $pad_string, $pad_type, $encoding); }\n}\n\nif (!function_exists('mb_ucfirst')) {\n    function mb_ucfirst(string $string, ?string $encoding = null): string { return p\\Mbstring::mb_ucfirst($string, $encoding); }\n}\n\nif (!function_exists('mb_lcfirst')) {\n    function mb_lcfirst(string $string, ?string $encoding = null): string { return p\\Mbstring::mb_lcfirst($string, $encoding); }\n}\n\nif (!function_exists('mb_trim')) {\n    function mb_trim(string $string, ?string $characters = null, ?string $encoding = null): string { return p\\Mbstring::mb_trim($string, $characters, $encoding); }\n}\n\nif (!function_exists('mb_ltrim')) {\n    function mb_ltrim(string $string, ?string $characters = null, ?string $encoding = null): string { return p\\Mbstring::mb_ltrim($string, $characters, $encoding); }\n}\n\nif (!function_exists('mb_rtrim')) {\n    function mb_rtrim(string $string, ?string $characters = null, ?string $encoding = null): string { return p\\Mbstring::mb_rtrim($string, $characters, $encoding); }\n}\n\n\nif (extension_loaded('mbstring')) {\n    return;\n}\n\nif (!defined('MB_CASE_UPPER')) {\n    define('MB_CASE_UPPER', 0);\n}\nif (!defined('MB_CASE_LOWER')) {\n    define('MB_CASE_LOWER', 1);\n}\nif (!defined('MB_CASE_TITLE')) {\n    define('MB_CASE_TITLE', 2);\n}\n"
        },
        {
          "name": "bootstrap80.php",
          "type": "blob",
          "size": 9.779296875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Mbstring as p;\n\nif (!function_exists('mb_convert_encoding')) {\n    function mb_convert_encoding(array|string|null $string, ?string $to_encoding, array|string|null $from_encoding = null): array|string|false { return p\\Mbstring::mb_convert_encoding($string ?? '', (string) $to_encoding, $from_encoding); }\n}\nif (!function_exists('mb_decode_mimeheader')) {\n    function mb_decode_mimeheader(?string $string): string { return p\\Mbstring::mb_decode_mimeheader((string) $string); }\n}\nif (!function_exists('mb_encode_mimeheader')) {\n    function mb_encode_mimeheader(?string $string, ?string $charset = null, ?string $transfer_encoding = null, ?string $newline = \"\\r\\n\", ?int $indent = 0): string { return p\\Mbstring::mb_encode_mimeheader((string) $string, $charset, $transfer_encoding, (string) $newline, (int) $indent); }\n}\nif (!function_exists('mb_decode_numericentity')) {\n    function mb_decode_numericentity(?string $string, array $map, ?string $encoding = null): string { return p\\Mbstring::mb_decode_numericentity((string) $string, $map, $encoding); }\n}\nif (!function_exists('mb_encode_numericentity')) {\n    function mb_encode_numericentity(?string $string, array $map, ?string $encoding = null, ?bool $hex = false): string { return p\\Mbstring::mb_encode_numericentity((string) $string, $map, $encoding, (bool) $hex); }\n}\nif (!function_exists('mb_convert_case')) {\n    function mb_convert_case(?string $string, ?int $mode, ?string $encoding = null): string { return p\\Mbstring::mb_convert_case((string) $string, (int) $mode, $encoding); }\n}\nif (!function_exists('mb_internal_encoding')) {\n    function mb_internal_encoding(?string $encoding = null): string|bool { return p\\Mbstring::mb_internal_encoding($encoding); }\n}\nif (!function_exists('mb_language')) {\n    function mb_language(?string $language = null): string|bool { return p\\Mbstring::mb_language($language); }\n}\nif (!function_exists('mb_list_encodings')) {\n    function mb_list_encodings(): array { return p\\Mbstring::mb_list_encodings(); }\n}\nif (!function_exists('mb_encoding_aliases')) {\n    function mb_encoding_aliases(?string $encoding): array { return p\\Mbstring::mb_encoding_aliases((string) $encoding); }\n}\nif (!function_exists('mb_check_encoding')) {\n    function mb_check_encoding(array|string|null $value = null, ?string $encoding = null): bool { return p\\Mbstring::mb_check_encoding($value, $encoding); }\n}\nif (!function_exists('mb_detect_encoding')) {\n    function mb_detect_encoding(?string $string, array|string|null $encodings = null, ?bool $strict = false): string|false { return p\\Mbstring::mb_detect_encoding((string) $string, $encodings, (bool) $strict); }\n}\nif (!function_exists('mb_detect_order')) {\n    function mb_detect_order(array|string|null $encoding = null): array|bool { return p\\Mbstring::mb_detect_order($encoding); }\n}\nif (!function_exists('mb_parse_str')) {\n    function mb_parse_str(?string $string, &$result = []): bool { parse_str((string) $string, $result); return (bool) $result; }\n}\nif (!function_exists('mb_strlen')) {\n    function mb_strlen(?string $string, ?string $encoding = null): int { return p\\Mbstring::mb_strlen((string) $string, $encoding); }\n}\nif (!function_exists('mb_strpos')) {\n    function mb_strpos(?string $haystack, ?string $needle, ?int $offset = 0, ?string $encoding = null): int|false { return p\\Mbstring::mb_strpos((string) $haystack, (string) $needle, (int) $offset, $encoding); }\n}\nif (!function_exists('mb_strtolower')) {\n    function mb_strtolower(?string $string, ?string $encoding = null): string { return p\\Mbstring::mb_strtolower((string) $string, $encoding); }\n}\nif (!function_exists('mb_strtoupper')) {\n    function mb_strtoupper(?string $string, ?string $encoding = null): string { return p\\Mbstring::mb_strtoupper((string) $string, $encoding); }\n}\nif (!function_exists('mb_substitute_character')) {\n    function mb_substitute_character(string|int|null $substitute_character = null): string|int|bool { return p\\Mbstring::mb_substitute_character($substitute_character); }\n}\nif (!function_exists('mb_substr')) {\n    function mb_substr(?string $string, ?int $start, ?int $length = null, ?string $encoding = null): string { return p\\Mbstring::mb_substr((string) $string, (int) $start, $length, $encoding); }\n}\nif (!function_exists('mb_stripos')) {\n    function mb_stripos(?string $haystack, ?string $needle, ?int $offset = 0, ?string $encoding = null): int|false { return p\\Mbstring::mb_stripos((string) $haystack, (string) $needle, (int) $offset, $encoding); }\n}\nif (!function_exists('mb_stristr')) {\n    function mb_stristr(?string $haystack, ?string $needle, ?bool $before_needle = false, ?string $encoding = null): string|false { return p\\Mbstring::mb_stristr((string) $haystack, (string) $needle, (bool) $before_needle, $encoding); }\n}\nif (!function_exists('mb_strrchr')) {\n    function mb_strrchr(?string $haystack, ?string $needle, ?bool $before_needle = false, ?string $encoding = null): string|false { return p\\Mbstring::mb_strrchr((string) $haystack, (string) $needle, (bool) $before_needle, $encoding); }\n}\nif (!function_exists('mb_strrichr')) {\n    function mb_strrichr(?string $haystack, ?string $needle, ?bool $before_needle = false, ?string $encoding = null): string|false { return p\\Mbstring::mb_strrichr((string) $haystack, (string) $needle, (bool) $before_needle, $encoding); }\n}\nif (!function_exists('mb_strripos')) {\n    function mb_strripos(?string $haystack, ?string $needle, ?int $offset = 0, ?string $encoding = null): int|false { return p\\Mbstring::mb_strripos((string) $haystack, (string) $needle, (int) $offset, $encoding); }\n}\nif (!function_exists('mb_strrpos')) {\n    function mb_strrpos(?string $haystack, ?string $needle, ?int $offset = 0, ?string $encoding = null): int|false { return p\\Mbstring::mb_strrpos((string) $haystack, (string) $needle, (int) $offset, $encoding); }\n}\nif (!function_exists('mb_strstr')) {\n    function mb_strstr(?string $haystack, ?string $needle, ?bool $before_needle = false, ?string $encoding = null): string|false { return p\\Mbstring::mb_strstr((string) $haystack, (string) $needle, (bool) $before_needle, $encoding); }\n}\nif (!function_exists('mb_get_info')) {\n    function mb_get_info(?string $type = 'all'): array|string|int|false|null { return p\\Mbstring::mb_get_info((string) $type); }\n}\nif (!function_exists('mb_http_output')) {\n    function mb_http_output(?string $encoding = null): string|bool { return p\\Mbstring::mb_http_output($encoding); }\n}\nif (!function_exists('mb_strwidth')) {\n    function mb_strwidth(?string $string, ?string $encoding = null): int { return p\\Mbstring::mb_strwidth((string) $string, $encoding); }\n}\nif (!function_exists('mb_substr_count')) {\n    function mb_substr_count(?string $haystack, ?string $needle, ?string $encoding = null): int { return p\\Mbstring::mb_substr_count((string) $haystack, (string) $needle, $encoding); }\n}\nif (!function_exists('mb_output_handler')) {\n    function mb_output_handler(?string $string, ?int $status): string { return p\\Mbstring::mb_output_handler((string) $string, (int) $status); }\n}\nif (!function_exists('mb_http_input')) {\n    function mb_http_input(?string $type = null): array|string|false { return p\\Mbstring::mb_http_input($type); }\n}\n\nif (!function_exists('mb_convert_variables')) {\n    function mb_convert_variables(?string $to_encoding, array|string|null $from_encoding, mixed &$var, mixed &...$vars): string|false { return p\\Mbstring::mb_convert_variables((string) $to_encoding, $from_encoding ?? '', $var, ...$vars); }\n}\n\nif (!function_exists('mb_ord')) {\n    function mb_ord(?string $string, ?string $encoding = null): int|false { return p\\Mbstring::mb_ord((string) $string, $encoding); }\n}\nif (!function_exists('mb_chr')) {\n    function mb_chr(?int $codepoint, ?string $encoding = null): string|false { return p\\Mbstring::mb_chr((int) $codepoint, $encoding); }\n}\nif (!function_exists('mb_scrub')) {\n    function mb_scrub(?string $string, ?string $encoding = null): string { $encoding ??= mb_internal_encoding(); return mb_convert_encoding((string) $string, $encoding, $encoding); }\n}\nif (!function_exists('mb_str_split')) {\n    function mb_str_split(?string $string, ?int $length = 1, ?string $encoding = null): array { return p\\Mbstring::mb_str_split((string) $string, (int) $length, $encoding); }\n}\n\nif (!function_exists('mb_str_pad')) {\n    function mb_str_pad(string $string, int $length, string $pad_string = ' ', int $pad_type = STR_PAD_RIGHT, ?string $encoding = null): string { return p\\Mbstring::mb_str_pad($string, $length, $pad_string, $pad_type, $encoding); }\n}\n\nif (!function_exists('mb_ucfirst')) {\n    function mb_ucfirst(string $string, ?string $encoding = null): string { return p\\Mbstring::mb_ucfirst($string, $encoding); }\n}\n\nif (!function_exists('mb_lcfirst')) {\n    function mb_lcfirst(string $string, ?string $encoding = null): string { return p\\Mbstring::mb_lcfirst($string, $encoding); }\n}\n\nif (!function_exists('mb_trim')) {\n    function mb_trim(string $string, ?string $characters = null, ?string $encoding = null): string { return p\\Mbstring::mb_trim($string, $characters, $encoding); }\n}\n\nif (!function_exists('mb_ltrim')) {\n    function mb_ltrim(string $string, ?string $characters = null, ?string $encoding = null): string { return p\\Mbstring::mb_ltrim($string, $characters, $encoding); }\n}\n\nif (!function_exists('mb_rtrim')) {\n    function mb_rtrim(string $string, ?string $characters = null, ?string $encoding = null): string { return p\\Mbstring::mb_rtrim($string, $characters, $encoding); }\n}\n\nif (extension_loaded('mbstring')) {\n    return;\n}\n\nif (!defined('MB_CASE_UPPER')) {\n    define('MB_CASE_UPPER', 0);\n}\nif (!defined('MB_CASE_LOWER')) {\n    define('MB_CASE_LOWER', 1);\n}\nif (!defined('MB_CASE_TITLE')) {\n    define('MB_CASE_TITLE', 2);\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.986328125,
          "content": "{\n    \"name\": \"symfony/polyfill-mbstring\",\n    \"type\": \"library\",\n    \"description\": \"Symfony polyfill for the Mbstring extension\",\n    \"keywords\": [\"polyfill\", \"shim\", \"compatibility\", \"portable\", \"mbstring\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Nicolas Grekas\",\n            \"email\": \"p@tchwork.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=7.2\",\n        \"ext-iconv\": \"*\"\n    },\n    \"provide\": {\n        \"ext-mbstring\": \"*\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Polyfill\\\\Mbstring\\\\\": \"\" },\n        \"files\": [ \"bootstrap.php\" ]\n    },\n    \"suggest\": {\n        \"ext-mbstring\": \"For best performance\"\n    },\n    \"minimum-stability\": \"dev\",\n    \"extra\": {\n        \"thanks\": {\n            \"name\": \"symfony/polyfill\",\n            \"url\": \"https://github.com/symfony/polyfill\"\n        }\n    }\n}\n"
        }
      ]
    }
  ]
}