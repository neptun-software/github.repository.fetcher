{
  "metadata": {
    "timestamp": 1736712273782,
    "page": 37,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/http-kernel",
      "stars": 8113,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0751953125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\nTests/Fixtures/cache/\nTests/Fixtures/logs/\n"
        },
        {
          "name": "Attribute",
          "type": "tree",
          "content": null
        },
        {
          "name": "Bundle",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 22.4755859375,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Remove `@internal` flag and add `@final` to `ServicesResetter`\n * Add support for `SYMFONY_DISABLE_RESOURCE_TRACKING` env var\n * Add support for configuring trusted proxies/headers/hosts via env vars\n\n7.1\n---\n\n * Add method `isKernelTerminating()` to `ExceptionEvent` that allows to check if an exception was thrown while the kernel is being terminated\n * Add `HttpException::fromStatusCode()`\n * Add `$validationFailedStatusCode` argument to `#[MapQueryParameter]` that allows setting a custom HTTP status code when validation fails\n * Add `NearMissValueResolverException` to let value resolvers report when an argument could be under their watch but failed to be resolved\n * Add `$type` argument to `#[MapRequestPayload]` that allows mapping a list of items\n * The `Extension` class is marked as internal, extend the `Extension` class from the DependencyInjection component instead\n * Deprecate `Extension::addAnnotatedClassesToCompile()`\n * Deprecate `AddAnnotatedClassesToCachePass`\n * Deprecate the `setAnnotatedClassCache()` and `getAnnotatedClassesToCompile()` methods of the `Kernel` class\n * Add `#[MapUploadedFile]` attribute to fetch, validate, and inject uploaded files into controller arguments\n\n7.0\n---\n\n * Add argument `$reflector` to `ArgumentResolverInterface::getArguments()` and `ArgumentMetadataFactoryInterface::createArgumentMetadata()`\n * Remove `ArgumentValueResolverInterface`, use `ValueResolverInterface` instead\n * Remove `StreamedResponseListener`\n * Remove `AbstractSurrogate::$phpEscapeMap`\n * Remove `HttpKernelInterface::MASTER_REQUEST`\n * Remove `terminate_on_cache_hit` option from `HttpCache`\n * Require explicit argument when calling `ConfigDataCollector::setKernel()`, `RouterListener::setCurrentRequest()`\n * Remove `Kernel::stripComments()`\n * Remove `FileLinkFormatter`, use `FileLinkFormatter` from the ErrorHandler component instead\n * Remove `UriSigner`, use `UriSigner` from the HttpFoundation component instead\n * Add argument `$buildDir` to `WarmableInterface`\n * Add argument `$filter` to `Profiler::find()` and `FileProfilerStorage::find()`\n\n6.4\n---\n\n * Support backed enums in #[MapQueryParameter]\n * `BundleInterface` no longer extends `ContainerAwareInterface`\n * Add optional `$className` parameter to `ControllerEvent::getAttributes()`\n * Add native return types to `TraceableEventDispatcher` and to `MergeExtensionConfigurationPass`\n * Add argument `$validationFailedStatusCode` to `#[MapQueryString]` and `#[MapRequestPayload]`\n * Add argument `$debug` to `Logger`\n * Add class `DebugLoggerConfigurator`\n * Add parameters `kernel.runtime_mode` and `kernel.runtime_mode.*`, all set from env var `APP_RUNTIME_MODE`\n * Deprecate `Kernel::stripComments()`\n * Support the `!` character at the beginning of a string as a negation operator in the url filter of the profiler\n * Deprecate `UriSigner`, use `UriSigner` from the HttpFoundation component instead\n * Deprecate `FileLinkFormatter`, use `FileLinkFormatter` from the ErrorHandler component instead\n * Add argument `$buildDir` to `WarmableInterface`\n * Add argument `$filter` to `Profiler::find()` and `FileProfilerStorage::find()`\n * Add `ControllerResolver::allowControllers()` to define which callables are legit controllers when the `_check_controller_is_allowed` request attribute is set\n\n6.3\n---\n\n * Deprecate parameters `container.dumper.inline_factories` and `container.dumper.inline_class_loader`, use `.container.dumper.inline_factories` and `.container.dumper.inline_class_loader` instead\n * `FileProfilerStorage` removes profiles automatically after two days\n * Add `#[WithHttpStatus]` for defining status codes for exceptions\n * Use an instance of `Psr\\Clock\\ClockInterface` to generate the current date time in `DateTimeValueResolver`\n * Add `#[WithLogLevel]` for defining log levels for exceptions\n * Add `skip_response_headers` to the `HttpCache` options\n * Introduce targeted value resolvers with `#[ValueResolver]` and `#[AsTargetedValueResolver]`\n * Add `#[MapRequestPayload]` to map and validate request payload from `Request::getContent()` or `Request::$request->all()` to typed objects\n * Add `#[MapQueryString]` to map and validate request query string from `Request::$query->all()` to typed objects\n * Add `#[MapQueryParameter]` to map and validate individual query parameters to controller arguments\n * Collect data from every event dispatcher\n\n6.2\n---\n\n * Add constructor argument `bool $handleAllThrowable` to `HttpKernel`\n * Add `ControllerEvent::getAttributes()` to handle attributes on controllers\n * Add `#[Cache]` to describe the default HTTP cache headers on controllers\n * Add `absolute_uri` option to surrogate fragment renderers\n * Add `ValueResolverInterface` and deprecate `ArgumentValueResolverInterface`\n * Add argument `$reflector` to `ArgumentResolverInterface` and `ArgumentMetadataFactoryInterface`\n * Deprecate calling `ConfigDataCollector::setKernel()`, `RouterListener::setCurrentRequest()` without arguments\n\n6.1\n---\n\n * Add `BackedEnumValueResolver` to resolve backed enum cases from request attributes in controller arguments\n * Add `DateTimeValueResolver` to resolve request attributes into DateTime objects in controller arguments\n * Deprecate StreamedResponseListener, it's not needed anymore\n * Add `Profiler::isEnabled()` so collaborating collector services may elect to omit themselves\n * Add the `UidValueResolver` argument value resolver\n * Add `AbstractBundle` class for DI configuration/definition on a single file\n * Update the path of a bundle placed in the `src/` directory to the parent directory when `AbstractBundle` is used\n\n6.0\n---\n\n * Remove `ArgumentInterface`\n * Remove `ArgumentMetadata::getAttribute()`, use `getAttributes()` instead\n * Remove support for returning a `ContainerBuilder` from `KernelInterface::registerContainerConfiguration()`\n * Remove `KernelEvent::isMasterRequest()`, use `isMainRequest()` instead\n * Remove support for `service:action` syntax to reference controllers, use `serviceOrFqcn::method` instead\n\n5.4\n---\n\n * Add the ability to enable the profiler using a request query parameter, body parameter or attribute\n * Deprecate `AbstractTestSessionListener` and `TestSessionListener`, use `AbstractSessionListener` and `SessionListener` instead\n * Deprecate the `fileLinkFormat` parameter of `DebugHandlersListener`\n * Add support for configuring log level, and status code by exception class\n * Allow ignoring \"kernel.reset\" methods that don't exist with \"on_invalid\" attribute\n\n5.3\n---\n\n * Deprecate `ArgumentInterface`\n * Add `ArgumentMetadata::getAttributes()`\n * Deprecate `ArgumentMetadata::getAttribute()`, use `getAttributes()` instead\n * Mark the class `Symfony\\Component\\HttpKernel\\EventListener\\DebugHandlersListener` as internal\n * Deprecate returning a `ContainerBuilder` from `KernelInterface::registerContainerConfiguration()`\n * Deprecate `HttpKernelInterface::MASTER_REQUEST` and add `HttpKernelInterface::MAIN_REQUEST` as replacement\n * Deprecate `KernelEvent::isMasterRequest()` and add `isMainRequest()` as replacement\n * Add `#[AsController]` attribute for declaring standalone controllers on PHP 8\n * Add `FragmentUriGeneratorInterface` and `FragmentUriGenerator` to generate the URI of a fragment\n\n5.2.0\n-----\n\n * added session usage\n * made the public `http_cache` service handle requests when available\n * allowed enabling trusted hosts and proxies using new `kernel.trusted_hosts`,\n   `kernel.trusted_proxies` and `kernel.trusted_headers` parameters\n * content of request parameter `_password` is now also hidden\n   in the request profiler raw content section\n * Allowed adding attributes on controller arguments that will be passed to argument resolvers.\n * kernels implementing the `ExtensionInterface` will now be auto-registered to the container\n * added parameter `kernel.runtime_environment`, defined as `%env(default:kernel.environment:APP_RUNTIME_ENV)%`\n * do not set a default `Accept` HTTP header when using `HttpKernelBrowser`\n\n5.1.0\n-----\n\n * allowed to use a specific logger channel for deprecations\n * made `WarmableInterface::warmUp()` return a list of classes or files to preload on PHP 7.4+;\n   not returning an array is deprecated\n * made kernels implementing `WarmableInterface` be part of the cache warmup stage\n * deprecated support for `service:action` syntax to reference controllers, use `serviceOrFqcn::method` instead\n * allowed using public aliases to reference controllers\n * added session usage reporting when the `_stateless` attribute of the request is set to `true`\n * added `AbstractSessionListener::onSessionUsage()` to report when the session is used while a request is stateless\n\n5.0.0\n-----\n\n * removed support for getting the container from a non-booted kernel\n * removed the first and second constructor argument of `ConfigDataCollector`\n * removed `ConfigDataCollector::getApplicationName()`\n * removed `ConfigDataCollector::getApplicationVersion()`\n * removed support for `Symfony\\Component\\Templating\\EngineInterface` in `HIncludeFragmentRenderer`, use a `Twig\\Environment` only\n * removed `TranslatorListener` in favor of `LocaleAwareListener`\n * removed `getRootDir()` and `getName()` from `Kernel` and `KernelInterface`\n * removed `FilterControllerArgumentsEvent`, use `ControllerArgumentsEvent` instead\n * removed `FilterControllerEvent`, use `ControllerEvent` instead\n * removed `FilterResponseEvent`, use `ResponseEvent` instead\n * removed `GetResponseEvent`, use `RequestEvent` instead\n * removed `GetResponseForControllerResultEvent`, use `ViewEvent` instead\n * removed `GetResponseForExceptionEvent`, use `ExceptionEvent` instead\n * removed `PostResponseEvent`, use `TerminateEvent` instead\n * removed `SaveSessionListener` in favor of `AbstractSessionListener`\n * removed `Client`, use `HttpKernelBrowser` instead\n * added method `getProjectDir()` to `KernelInterface`\n * removed methods `serialize` and `unserialize` from `DataCollector`, store the serialized state in the data property instead\n * made `ProfilerStorageInterface` internal\n * removed the second and third argument of `KernelInterface::locateResource`\n * removed the second and third argument of `FileLocator::__construct`\n * removed loading resources from `%kernel.root_dir%/Resources` and `%kernel.root_dir%` as\n   fallback directories.\n * removed class `ExceptionListener`, use `ErrorListener` instead\n\n4.4.0\n-----\n\n * The `DebugHandlersListener` class has been marked as `final`\n * Added new Bundle directory convention consistent with standard skeletons\n * Deprecated the second and third argument of `KernelInterface::locateResource`\n * Deprecated the second and third argument of `FileLocator::__construct`\n * Deprecated loading resources from `%kernel.root_dir%/Resources` and `%kernel.root_dir%` as\n   fallback directories. Resources like service definitions are usually loaded relative to the\n   current directory or with a glob pattern. The fallback directories have never been advocated\n   so you likely do not use those in any app based on the SF Standard or Flex edition.\n * Marked all dispatched event classes as `@final`\n * Added `ErrorController` to enable the preview and error rendering mechanism\n * Getting the container from a non-booted kernel is deprecated.\n * Marked the `AjaxDataCollector`, `ConfigDataCollector`, `EventDataCollector`,\n   `ExceptionDataCollector`, `LoggerDataCollector`, `MemoryDataCollector`,\n   `RequestDataCollector` and `TimeDataCollector` classes as `@final`.\n * Marked the `RouterDataCollector::collect()` method as `@final`.\n * The `DataCollectorInterface::collect()` and `Profiler::collect()` methods third parameter signature\n   will be `\\Throwable $exception = null` instead of `\\Exception $exception = null` in Symfony 5.0.\n * Deprecated methods `ExceptionEvent::get/setException()`, use `get/setThrowable()` instead\n * Deprecated class `ExceptionListener`, use `ErrorListener` instead\n\n4.3.0\n-----\n\n * renamed `Client` to `HttpKernelBrowser`\n * `KernelInterface` doesn't extend `Serializable` anymore\n * deprecated the `Kernel::serialize()` and `unserialize()` methods\n * increased the priority of `Symfony\\Component\\HttpKernel\\EventListener\\AddRequestFormatsListener`\n * made `Symfony\\Component\\HttpKernel\\EventListener\\LocaleListener` set the default locale early\n * deprecated `TranslatorListener` in favor of `LocaleAwareListener`\n * added the registration of all `LocaleAwareInterface` implementations into the `LocaleAwareListener`\n * made `FileLinkFormatter` final and not implement `Serializable` anymore\n * the base `DataCollector` doesn't implement `Serializable` anymore, you should\n   store all the serialized state in the data property instead\n * `DumpDataCollector` has been marked as `final`\n * added an event listener to prevent search engines from indexing applications in debug mode.\n * renamed `FilterControllerArgumentsEvent` to `ControllerArgumentsEvent`\n * renamed `FilterControllerEvent` to `ControllerEvent`\n * renamed `FilterResponseEvent` to `ResponseEvent`\n * renamed `GetResponseEvent` to `RequestEvent`\n * renamed `GetResponseForControllerResultEvent` to `ViewEvent`\n * renamed `GetResponseForExceptionEvent` to `ExceptionEvent`\n * renamed `PostResponseEvent` to `TerminateEvent`\n * added `HttpClientKernel` for handling requests with an `HttpClientInterface` instance\n * added `trace_header` and `trace_level` configuration options to `HttpCache`\n\n4.2.0\n-----\n\n * deprecated `KernelInterface::getRootDir()` and the `kernel.root_dir` parameter\n * deprecated `KernelInterface::getName()` and the `kernel.name` parameter\n * deprecated the first and second constructor argument of `ConfigDataCollector`\n * deprecated `ConfigDataCollector::getApplicationName()`\n * deprecated `ConfigDataCollector::getApplicationVersion()`\n\n4.1.0\n-----\n\n * added orphaned events support to `EventDataCollector`\n * `ExceptionListener` now logs exceptions at priority `0` (previously logged at `-128`)\n * Added support for using `service::method` to reference controllers, making it consistent with other cases. It is recommended over the `service:action` syntax with a single colon, which will be deprecated in the future.\n * Added the ability to profile individual argument value resolvers via the\n   `Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver\\TraceableValueResolver`\n\n4.0.0\n-----\n\n * removed the `DataCollector::varToString()` method, use `DataCollector::cloneVar()`\n   instead\n * using the `DataCollector::cloneVar()` method requires the VarDumper component\n * removed the `ValueExporter` class\n * removed `ControllerResolverInterface::getArguments()`\n * removed `TraceableControllerResolver::getArguments()`\n * removed `ControllerResolver::getArguments()` and the ability to resolve arguments\n * removed the `argument_resolver` service dependency from the `debug.controller_resolver`\n * removed `LazyLoadingFragmentHandler::addRendererService()`\n * removed `Psr6CacheClearer::addPool()`\n * removed `Extension::addClassesToCompile()` and `Extension::getClassesToCompile()`\n * removed `Kernel::loadClassCache()`, `Kernel::doLoadClassCache()`, `Kernel::setClassCache()`,\n   and `Kernel::getEnvParameters()`\n * support for the `X-Status-Code` when handling exceptions in the `HttpKernel`\n   has been dropped, use the `HttpKernel::allowCustomResponseCode()` method\n   instead\n * removed convention-based commands registration\n * removed the `ChainCacheClearer::add()` method\n * removed the `CacheaWarmerAggregate::add()` and `setWarmers()` methods\n * made `CacheWarmerAggregate` and `ChainCacheClearer` classes final\n\n3.4.0\n-----\n\n * added a minimalist PSR-3 `Logger` class that writes in `stderr`\n * made kernels implementing `CompilerPassInterface` able to process the container\n * deprecated bundle inheritance\n * added `RebootableInterface` and implemented it in `Kernel`\n * deprecated commands auto registration\n * deprecated `EnvParametersResource`\n * added `Symfony\\Component\\HttpKernel\\Client::catchExceptions()`\n * deprecated the `ChainCacheClearer::add()` method\n * deprecated the `CacheaWarmerAggregate::add()` and `setWarmers()` methods\n * made `CacheWarmerAggregate` and `ChainCacheClearer` classes final\n * added the possibility to reset the profiler to its initial state\n * deprecated data collectors without a `reset()` method\n * deprecated implementing `DebugLoggerInterface` without a `clear()` method\n\n3.3.0\n-----\n\n * added `kernel.project_dir` and `Kernel::getProjectDir()`\n * deprecated `kernel.root_dir` and `Kernel::getRootDir()`\n * deprecated `Kernel::getEnvParameters()`\n * deprecated the special `SYMFONY__` environment variables\n * added the possibility to change the query string parameter used by `UriSigner`\n * deprecated `LazyLoadingFragmentHandler::addRendererService()`\n * deprecated `Extension::addClassesToCompile()` and `Extension::getClassesToCompile()`\n * deprecated `Psr6CacheClearer::addPool()`\n\n3.2.0\n-----\n\n * deprecated `DataCollector::varToString()`, use `cloneVar()` instead\n * changed surrogate capability name in `AbstractSurrogate::addSurrogateCapability` to 'symfony'\n * Added `ControllerArgumentValueResolverPass`\n\n3.1.0\n-----\n * deprecated passing objects as URI attributes to the ESI and SSI renderers\n * deprecated `ControllerResolver::getArguments()`\n * added `Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolverInterface`\n * added `Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolverInterface` as argument to `HttpKernel`\n * added `Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver`\n * added `Symfony\\Component\\HttpKernel\\DataCollector\\RequestDataCollector::getMethod()`\n * added `Symfony\\Component\\HttpKernel\\DataCollector\\RequestDataCollector::getRedirect()`\n * added the `kernel.controller_arguments` event, triggered after controller arguments have been resolved\n\n3.0.0\n-----\n\n * removed `Symfony\\Component\\HttpKernel\\Kernel::init()`\n * removed `Symfony\\Component\\HttpKernel\\Kernel::isClassInActiveBundle()` and `Symfony\\Component\\HttpKernel\\KernelInterface::isClassInActiveBundle()`\n * removed `Symfony\\Component\\HttpKernel\\Debug\\TraceableEventDispatcher::setProfiler()`\n * removed `Symfony\\Component\\HttpKernel\\EventListener\\FragmentListener::getLocalIpAddresses()`\n * removed `Symfony\\Component\\HttpKernel\\EventListener\\LocaleListener::setRequest()`\n * removed `Symfony\\Component\\HttpKernel\\EventListener\\RouterListener::setRequest()`\n * removed `Symfony\\Component\\HttpKernel\\EventListener\\ProfilerListener::onKernelRequest()`\n * removed `Symfony\\Component\\HttpKernel\\Fragment\\FragmentHandler::setRequest()`\n * removed `Symfony\\Component\\HttpKernel\\HttpCache\\Esi::hasSurrogateEsiCapability()`\n * removed `Symfony\\Component\\HttpKernel\\HttpCache\\Esi::addSurrogateEsiCapability()`\n * removed `Symfony\\Component\\HttpKernel\\HttpCache\\Esi::needsEsiParsing()`\n * removed `Symfony\\Component\\HttpKernel\\HttpCache\\HttpCache::getEsi()`\n * removed `Symfony\\Component\\HttpKernel\\DependencyInjection\\ContainerAwareHttpKernel`\n * removed `Symfony\\Component\\HttpKernel\\DependencyInjection\\RegisterListenersPass`\n * removed `Symfony\\Component\\HttpKernel\\EventListener\\ErrorsLoggerListener`\n * removed `Symfony\\Component\\HttpKernel\\EventListener\\EsiListener`\n * removed `Symfony\\Component\\HttpKernel\\HttpCache\\EsiResponseCacheStrategy`\n * removed `Symfony\\Component\\HttpKernel\\HttpCache\\EsiResponseCacheStrategyInterface`\n * removed `Symfony\\Component\\HttpKernel\\Log\\LoggerInterface`\n * removed `Symfony\\Component\\HttpKernel\\Log\\NullLogger`\n * removed `Symfony\\Component\\HttpKernel\\Profiler::import()`\n * removed `Symfony\\Component\\HttpKernel\\Profiler::export()`\n\n2.8.0\n-----\n\n * deprecated `Profiler::import` and `Profiler::export`\n\n2.7.0\n-----\n\n * added the HTTP status code to profiles\n\n2.6.0\n-----\n\n * deprecated `Symfony\\Component\\HttpKernel\\EventListener\\ErrorsLoggerListener`, use `Symfony\\Component\\HttpKernel\\EventListener\\DebugHandlersListener` instead\n * deprecated unused method `Symfony\\Component\\HttpKernel\\Kernel::isClassInActiveBundle` and `Symfony\\Component\\HttpKernel\\KernelInterface::isClassInActiveBundle`\n\n2.5.0\n-----\n\n * deprecated `Symfony\\Component\\HttpKernel\\DependencyInjection\\RegisterListenersPass`, use `Symfony\\Component\\EventDispatcher\\DependencyInjection\\RegisterListenersPass` instead\n\n2.4.0\n-----\n\n * added event listeners for the session\n * added the KernelEvents::FINISH_REQUEST event\n\n2.3.0\n-----\n\n * [BC BREAK] renamed `Symfony\\Component\\HttpKernel\\EventListener\\DeprecationLoggerListener` to `Symfony\\Component\\HttpKernel\\EventListener\\ErrorsLoggerListener` and changed its constructor\n * deprecated `Symfony\\Component\\HttpKernel\\Debug\\ErrorHandler`, `Symfony\\Component\\HttpKernel\\Debug\\ExceptionHandler`,\n   `Symfony\\Component\\HttpKernel\\Exception\\FatalErrorException` and `Symfony\\Component\\HttpKernel\\Exception\\FlattenException`\n * deprecated `Symfony\\Component\\HttpKernel\\Kernel::init()`\n * added the possibility to specify an id an extra attributes to hinclude tags\n * added the collect of data if a controller is a Closure in the Request collector\n * pass exceptions from the ExceptionListener to the logger using the logging context to allow for more\n   detailed messages\n\n2.2.0\n-----\n\n * [BC BREAK] the path info for sub-request is now always _fragment (or whatever you configured instead of the default)\n * added Symfony\\Component\\HttpKernel\\EventListener\\FragmentListener\n * added Symfony\\Component\\HttpKernel\\UriSigner\n * added Symfony\\Component\\HttpKernel\\FragmentRenderer and rendering strategies (in Symfony\\Component\\HttpKernel\\Fragment\\FragmentRendererInterface)\n * added Symfony\\Component\\HttpKernel\\DependencyInjection\\ContainerAwareHttpKernel\n * added ControllerReference to create reference of Controllers (used in the FragmentRenderer class)\n * [BC BREAK] renamed TimeDataCollector::getTotalTime() to\n   TimeDataCollector::getDuration()\n * updated the MemoryDataCollector to include the memory used in the\n   kernel.terminate event listeners\n * moved the Stopwatch classes to a new component\n * added TraceableControllerResolver\n * added TraceableEventDispatcher (removed ContainerAwareTraceableEventDispatcher)\n * added support for WinCache opcode cache in ConfigDataCollector\n\n2.1.0\n-----\n\n * [BC BREAK] the charset is now configured via the Kernel::getCharset() method\n * [BC BREAK] the current locale for the user is not stored anymore in the session\n * added the HTTP method to the profiler storage\n * updated all listeners to implement EventSubscriberInterface\n * added TimeDataCollector\n * added ContainerAwareTraceableEventDispatcher\n * moved TraceableEventDispatcherInterface to the EventDispatcher component\n * added RouterListener, LocaleListener, and StreamedResponseListener\n * added CacheClearerInterface (and ChainCacheClearer)\n * added a kernel.terminate event (via TerminableInterface and PostResponseEvent)\n * added a Stopwatch class\n * added WarmableInterface\n * improved extensibility between bundles\n * added profiler storages for Memcache(d), File-based, MongoDB, Redis\n * moved Filesystem class to its own component\n"
        },
        {
          "name": "CacheClearer",
          "type": "tree",
          "content": null
        },
        {
          "name": "CacheWarmer",
          "type": "tree",
          "content": null
        },
        {
          "name": "Config",
          "type": "tree",
          "content": null
        },
        {
          "name": "Controller",
          "type": "tree",
          "content": null
        },
        {
          "name": "ControllerMetadata",
          "type": "tree",
          "content": null
        },
        {
          "name": "DataCollector",
          "type": "tree",
          "content": null
        },
        {
          "name": "Debug",
          "type": "tree",
          "content": null
        },
        {
          "name": "DependencyInjection",
          "type": "tree",
          "content": null
        },
        {
          "name": "Event",
          "type": "tree",
          "content": null
        },
        {
          "name": "EventListener",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Fragment",
          "type": "tree",
          "content": null
        },
        {
          "name": "HttpCache",
          "type": "tree",
          "content": null
        },
        {
          "name": "HttpClientKernel.php",
          "type": "blob",
          "size": 3.84375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel;\n\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(ResponseHeaderBag::class);\n\n/**\n * An implementation of a Symfony HTTP kernel using a \"real\" HTTP client.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nfinal class HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (null === $client && !class_exists(HttpClient::class)) {\n            throw new \\LogicException(\\sprintf('You cannot use \"%s\" as the HttpClient component is not installed. Try running \"composer require symfony/http-client\".', __CLASS__));\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = HttpKernelInterface::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $headers = $this->getHeaders($request);\n        $body = '';\n        if (null !== $part = $this->getBody($request)) {\n            $headers = array_merge($headers, $part->getPreparedHeaders()->toArray());\n            $body = $part->bodyToIterable();\n        }\n        $response = $this->client->request($request->getMethod(), $request->getUri(), [\n            'headers' => $headers,\n            'body' => $body,\n        ] + $request->attributes->get('http_client_options', []));\n\n        $response = new Response($response->getContent(!$catch), $response->getStatusCode(), $response->getHeaders(!$catch));\n\n        $response->headers->remove('X-Body-File');\n        $response->headers->remove('X-Body-Eval');\n        $response->headers->remove('X-Content-Digest');\n\n        $response->headers = new class($response->headers->all()) extends ResponseHeaderBag {\n            protected function computeCacheControlValue(): string\n            {\n                return $this->getCacheControlHeader(); // preserve the original value\n            }\n        };\n\n        return $response;\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (\\in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        if (!class_exists(AbstractPart::class)) {\n            throw new \\LogicException('You cannot pass non-empty bodies as the Mime component is not installed. Try running \"composer require symfony/mime\".');\n        }\n\n        if ($content = $request->getContent()) {\n            return new TextPart($content, 'utf-8', 'plain', '8bit');\n        }\n\n        $fields = $request->request->all();\n        foreach ($request->files->all() as $name => $file) {\n            $fields[$name] = DataPart::fromPath($file->getPathname(), $file->getClientOriginalName(), $file->getClientMimeType());\n        }\n\n        return new FormDataPart($fields);\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers as $key => $value) {\n            $headers[$key] = $value;\n        }\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name.'='.$value;\n        }\n        if ($cookies) {\n            $headers['cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n}\n"
        },
        {
          "name": "HttpKernel.php",
          "type": "blob",
          "size": 11.1103515625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\RequestExceptionInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\StreamedResponse;\nuse Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver;\nuse Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolverInterface;\nuse Symfony\\Component\\HttpKernel\\Controller\\ControllerResolverInterface;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerArgumentsEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\FinishRequestEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ResponseEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\TerminateEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ViewEvent;\nuse Symfony\\Component\\HttpKernel\\Exception\\BadRequestHttpException;\nuse Symfony\\Component\\HttpKernel\\Exception\\ControllerDoesNotReturnResponseException;\nuse Symfony\\Component\\HttpKernel\\Exception\\HttpExceptionInterface;\nuse Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(ControllerArgumentsEvent::class);\nclass_exists(ControllerEvent::class);\nclass_exists(ExceptionEvent::class);\nclass_exists(FinishRequestEvent::class);\nclass_exists(RequestEvent::class);\nclass_exists(ResponseEvent::class);\nclass_exists(TerminateEvent::class);\nclass_exists(ViewEvent::class);\nclass_exists(KernelEvents::class);\n\n/**\n * HttpKernel notifies events to convert a Request object to a Response one.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass HttpKernel implements HttpKernelInterface, TerminableInterface\n{\n    protected RequestStack $requestStack;\n    private ArgumentResolverInterface $argumentResolver;\n    private bool $terminating = false;\n\n    public function __construct(\n        protected EventDispatcherInterface $dispatcher,\n        protected ControllerResolverInterface $resolver,\n        ?RequestStack $requestStack = null,\n        ?ArgumentResolverInterface $argumentResolver = null,\n        private bool $handleAllThrowables = false,\n    ) {\n        $this->requestStack = $requestStack ?? new RequestStack();\n        $this->argumentResolver = $argumentResolver ?? new ArgumentResolver();\n    }\n\n    public function handle(Request $request, int $type = HttpKernelInterface::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $request->headers->set('X-Php-Ob-Level', (string) ob_get_level());\n\n        $this->requestStack->push($request);\n        $response = null;\n        try {\n            return $response = $this->handleRaw($request, $type);\n        } catch (\\Throwable $e) {\n            if ($e instanceof \\Error && !$this->handleAllThrowables) {\n                throw $e;\n            }\n\n            if ($e instanceof RequestExceptionInterface) {\n                $e = new BadRequestHttpException($e->getMessage(), $e);\n            }\n            if (false === $catch) {\n                $this->finishRequest($request, $type);\n\n                throw $e;\n            }\n\n            return $response = $this->handleThrowable($e, $request, $type);\n        } finally {\n            $this->requestStack->pop();\n\n            if ($response instanceof StreamedResponse && $callback = $response->getCallback()) {\n                $requestStack = $this->requestStack;\n\n                $response->setCallback(static function () use ($request, $callback, $requestStack) {\n                    $requestStack->push($request);\n                    try {\n                        $callback();\n                    } finally {\n                        $requestStack->pop();\n                    }\n                });\n            }\n        }\n    }\n\n    public function terminate(Request $request, Response $response): void\n    {\n        try {\n            $this->terminating = true;\n            $this->dispatcher->dispatch(new TerminateEvent($this, $request, $response), KernelEvents::TERMINATE);\n        } finally {\n            $this->terminating = false;\n        }\n    }\n\n    /**\n     * @internal\n     */\n    public function terminateWithException(\\Throwable $exception, ?Request $request = null): void\n    {\n        if (!$request ??= $this->requestStack->getMainRequest()) {\n            throw $exception;\n        }\n\n        if ($pop = $request !== $this->requestStack->getMainRequest()) {\n            $this->requestStack->push($request);\n        }\n\n        try {\n            $response = $this->handleThrowable($exception, $request, self::MAIN_REQUEST);\n        } finally {\n            if ($pop) {\n                $this->requestStack->pop();\n            }\n        }\n\n        $response->sendHeaders();\n        $response->sendContent();\n\n        $this->terminate($request, $response);\n    }\n\n    /**\n     * Handles a request to convert it to a response.\n     *\n     * Exceptions are not caught.\n     *\n     * @throws \\LogicException       If one of the listener does not behave as expected\n     * @throws NotFoundHttpException When controller cannot be found\n     */\n    private function handleRaw(Request $request, int $type = self::MAIN_REQUEST): Response\n    {\n        // request\n        $event = new RequestEvent($this, $request, $type);\n        $this->dispatcher->dispatch($event, KernelEvents::REQUEST);\n\n        if ($event->hasResponse()) {\n            return $this->filterResponse($event->getResponse(), $request, $type);\n        }\n\n        // load controller\n        if (false === $controller = $this->resolver->getController($request)) {\n            throw new NotFoundHttpException(\\sprintf('Unable to find the controller for path \"%s\". The route is wrongly configured.', $request->getPathInfo()));\n        }\n\n        $event = new ControllerEvent($this, $controller, $request, $type);\n        $this->dispatcher->dispatch($event, KernelEvents::CONTROLLER);\n        $controller = $event->getController();\n\n        // controller arguments\n        $arguments = $this->argumentResolver->getArguments($request, $controller, $event->getControllerReflector());\n\n        $event = new ControllerArgumentsEvent($this, $event, $arguments, $request, $type);\n        $this->dispatcher->dispatch($event, KernelEvents::CONTROLLER_ARGUMENTS);\n        $controller = $event->getController();\n        $arguments = $event->getArguments();\n\n        // call controller\n        $response = $controller(...$arguments);\n\n        // view\n        if (!$response instanceof Response) {\n            $event = new ViewEvent($this, $request, $type, $response, $event);\n            $this->dispatcher->dispatch($event, KernelEvents::VIEW);\n\n            if ($event->hasResponse()) {\n                $response = $event->getResponse();\n            } else {\n                $msg = \\sprintf('The controller must return a \"Symfony\\Component\\HttpFoundation\\Response\" object but it returned %s.', $this->varToString($response));\n\n                // the user may have forgotten to return something\n                if (null === $response) {\n                    $msg .= ' Did you forget to add a return statement somewhere in your controller?';\n                }\n\n                throw new ControllerDoesNotReturnResponseException($msg, $controller, __FILE__, __LINE__ - 17);\n            }\n        }\n\n        return $this->filterResponse($response, $request, $type);\n    }\n\n    /**\n     * Filters a response object.\n     *\n     * @throws \\RuntimeException if the passed object is not a Response instance\n     */\n    private function filterResponse(Response $response, Request $request, int $type): Response\n    {\n        $event = new ResponseEvent($this, $request, $type, $response);\n\n        $this->dispatcher->dispatch($event, KernelEvents::RESPONSE);\n\n        $this->finishRequest($request, $type);\n\n        return $event->getResponse();\n    }\n\n    /**\n     * Publishes the finish request event, then pop the request from the stack.\n     *\n     * Note that the order of the operations is important here, otherwise\n     * operations such as {@link RequestStack::getParentRequest()} can lead to\n     * weird results.\n     */\n    private function finishRequest(Request $request, int $type): void\n    {\n        $this->dispatcher->dispatch(new FinishRequestEvent($this, $request, $type), KernelEvents::FINISH_REQUEST);\n    }\n\n    /**\n     * Handles a throwable by trying to convert it to a Response.\n     */\n    private function handleThrowable(\\Throwable $e, Request $request, int $type): Response\n    {\n        $event = new ExceptionEvent($this, $request, $type, $e, isKernelTerminating: $this->terminating);\n        $this->dispatcher->dispatch($event, KernelEvents::EXCEPTION);\n\n        // a listener might have replaced the exception\n        $e = $event->getThrowable();\n\n        if (!$event->hasResponse()) {\n            $this->finishRequest($request, $type);\n\n            throw $e;\n        }\n\n        $response = $event->getResponse();\n\n        // the developer asked for a specific status code\n        if (!$event->isAllowingCustomResponseCode() && !$response->isClientError() && !$response->isServerError() && !$response->isRedirect()) {\n            // ensure that we actually have an error response\n            if ($e instanceof HttpExceptionInterface) {\n                // keep the HTTP status code and headers\n                $response->setStatusCode($e->getStatusCode());\n                $response->headers->add($e->getHeaders());\n            } else {\n                $response->setStatusCode(500);\n            }\n        }\n\n        try {\n            return $this->filterResponse($response, $request, $type);\n        } catch (\\Throwable $e) {\n            if ($e instanceof \\Error && !$this->handleAllThrowables) {\n                throw $e;\n            }\n\n            return $response;\n        }\n    }\n\n    /**\n     * Returns a human-readable string for the specified variable.\n     */\n    private function varToString(mixed $var): string\n    {\n        if (\\is_object($var)) {\n            return \\sprintf('an object of type %s', $var::class);\n        }\n\n        if (\\is_array($var)) {\n            $a = [];\n            foreach ($var as $k => $v) {\n                $a[] = \\sprintf('%s => ...', $k);\n            }\n\n            return \\sprintf('an array ([%s])', mb_substr(implode(', ', $a), 0, 255));\n        }\n\n        if (\\is_resource($var)) {\n            return \\sprintf('a resource (%s)', get_resource_type($var));\n        }\n\n        if (null === $var) {\n            return 'null';\n        }\n\n        if (false === $var) {\n            return 'a boolean value (false)';\n        }\n\n        if (true === $var) {\n            return 'a boolean value (true)';\n        }\n\n        if (\\is_string($var)) {\n            return \\sprintf('a string (\"%s%s\")', mb_substr($var, 0, 255), mb_strlen($var) > 255 ? '...' : '');\n        }\n\n        if (is_numeric($var)) {\n            return \\sprintf('a number (%s)', (string) $var);\n        }\n\n        return (string) $var;\n    }\n}\n"
        },
        {
          "name": "HttpKernelBrowser.php",
          "type": "blob",
          "size": 5.666015625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel;\n\nuse Symfony\\Component\\BrowserKit\\AbstractBrowser;\nuse Symfony\\Component\\BrowserKit\\CookieJar;\nuse Symfony\\Component\\BrowserKit\\History;\nuse Symfony\\Component\\BrowserKit\\Request as DomRequest;\nuse Symfony\\Component\\BrowserKit\\Response as DomResponse;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n/**\n * Simulates a browser and makes requests to an HttpKernel instance.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @template-extends AbstractBrowser<Request, Response>\n */\nclass HttpKernelBrowser extends AbstractBrowser\n{\n    private bool $catchExceptions = true;\n\n    /**\n     * @param array $server The server parameters (equivalent of $_SERVER)\n     */\n    public function __construct(\n        protected HttpKernelInterface $kernel,\n        array $server = [],\n        ?History $history = null,\n        ?CookieJar $cookieJar = null,\n    ) {\n        // These class properties must be set before calling the parent constructor, as it may depend on it.\n        $this->followRedirects = false;\n\n        parent::__construct($server, $history, $cookieJar);\n    }\n\n    /**\n     * Sets whether to catch exceptions when the kernel is handling a request.\n     */\n    public function catchExceptions(bool $catchExceptions): void\n    {\n        $this->catchExceptions = $catchExceptions;\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function doRequest(object $request): Response\n    {\n        $response = $this->kernel->handle($request, HttpKernelInterface::MAIN_REQUEST, $this->catchExceptions);\n\n        if ($this->kernel instanceof TerminableInterface) {\n            $this->kernel->terminate($request, $response);\n        }\n\n        return $response;\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function getScript(object $request): string\n    {\n        $kernel = var_export(serialize($this->kernel), true);\n        $request = var_export(serialize($request), true);\n\n        $errorReporting = error_reporting();\n\n        $requires = '';\n        foreach (get_declared_classes() as $class) {\n            if (str_starts_with($class, 'ComposerAutoloaderInit')) {\n                $r = new \\ReflectionClass($class);\n                $file = \\dirname($r->getFileName(), 2).'/autoload.php';\n                if (file_exists($file)) {\n                    $requires .= 'require_once '.var_export($file, true).\";\\n\";\n                }\n            }\n        }\n\n        if (!$requires) {\n            throw new \\RuntimeException('Composer autoloader not found.');\n        }\n\n        $code = <<<EOF\n<?php\n\nerror_reporting($errorReporting);\n\n$requires\n\n\\$kernel = unserialize($kernel);\n\\$request = unserialize($request);\nEOF;\n\n        return $code.$this->getHandleScript();\n    }\n\n    protected function getHandleScript(): string\n    {\n        return <<<'EOF'\n$response = $kernel->handle($request);\n\nif ($kernel instanceof Symfony\\Component\\HttpKernel\\TerminableInterface) {\n    $kernel->terminate($request, $response);\n}\n\necho serialize($response);\nEOF;\n    }\n\n    protected function filterRequest(DomRequest $request): Request\n    {\n        $httpRequest = Request::create($request->getUri(), $request->getMethod(), $request->getParameters(), $request->getCookies(), $request->getFiles(), $server = $request->getServer(), $request->getContent());\n        if (!isset($server['HTTP_ACCEPT'])) {\n            $httpRequest->headers->remove('Accept');\n        }\n\n        foreach ($this->filterFiles($httpRequest->files->all()) as $key => $value) {\n            $httpRequest->files->set($key, $value);\n        }\n\n        return $httpRequest;\n    }\n\n    /**\n     * Filters an array of files.\n     *\n     * This method created test instances of UploadedFile so that the move()\n     * method can be called on those instances.\n     *\n     * If the size of a file is greater than the allowed size (from php.ini) then\n     * an invalid UploadedFile is returned with an error set to UPLOAD_ERR_INI_SIZE.\n     *\n     * @see UploadedFile\n     */\n    protected function filterFiles(array $files): array\n    {\n        $filtered = [];\n        foreach ($files as $key => $value) {\n            if (\\is_array($value)) {\n                $filtered[$key] = $this->filterFiles($value);\n            } elseif ($value instanceof UploadedFile) {\n                if ($value->isValid() && $value->getSize() > UploadedFile::getMaxFilesize()) {\n                    $filtered[$key] = new UploadedFile(\n                        '',\n                        $value->getClientOriginalName(),\n                        $value->getClientMimeType(),\n                        \\UPLOAD_ERR_INI_SIZE,\n                        true\n                    );\n                } else {\n                    $filtered[$key] = new UploadedFile(\n                        $value->getPathname(),\n                        $value->getClientOriginalName(),\n                        $value->getClientMimeType(),\n                        $value->getError(),\n                        true\n                    );\n                }\n            }\n        }\n\n        return $filtered;\n    }\n\n    /**\n     * @param Response $response\n     */\n    protected function filterResponse(object $response): DomResponse\n    {\n        // this is needed to support StreamedResponse\n        ob_start();\n        $response->sendContent();\n        $content = ob_get_clean();\n\n        return new DomResponse($content, $response->getStatusCode(), $response->headers->all());\n    }\n}\n"
        },
        {
          "name": "HttpKernelInterface.php",
          "type": "blob",
          "size": 1.1982421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n/**\n * HttpKernelInterface handles a Request to convert it to a Response.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\ninterface HttpKernelInterface\n{\n    public const MAIN_REQUEST = 1;\n    public const SUB_REQUEST = 2;\n\n    /**\n     * Handles a Request to convert it to a Response.\n     *\n     * When $catch is true, the implementation must catch all exceptions\n     * and do its best to convert them to a Response instance.\n     *\n     * @param int  $type  The type of the request\n     *                    (one of HttpKernelInterface::MAIN_REQUEST or HttpKernelInterface::SUB_REQUEST)\n     * @param bool $catch Whether to catch exceptions or not\n     *\n     * @throws \\Exception When an Exception occurs during processing\n     */\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response;\n}\n"
        },
        {
          "name": "Kernel.php",
          "type": "blob",
          "size": 28.0947265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel;\n\nuse Symfony\\Component\\Config\\Builder\\ConfigBuilderGenerator;\nuse Symfony\\Component\\Config\\ConfigCache;\nuse Symfony\\Component\\Config\\Loader\\DelegatingLoader;\nuse Symfony\\Component\\Config\\Loader\\LoaderResolver;\nuse Symfony\\Component\\DependencyInjection\\Compiler\\CompilerPassInterface;\nuse Symfony\\Component\\DependencyInjection\\Compiler\\PassConfig;\nuse Symfony\\Component\\DependencyInjection\\Compiler\\RemoveBuildParametersPass;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\nuse Symfony\\Component\\DependencyInjection\\Dumper\\PhpDumper;\nuse Symfony\\Component\\DependencyInjection\\Dumper\\Preloader;\nuse Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface;\nuse Symfony\\Component\\DependencyInjection\\Loader\\ClosureLoader;\nuse Symfony\\Component\\DependencyInjection\\Loader\\DirectoryLoader;\nuse Symfony\\Component\\DependencyInjection\\Loader\\GlobFileLoader;\nuse Symfony\\Component\\DependencyInjection\\Loader\\IniFileLoader;\nuse Symfony\\Component\\DependencyInjection\\Loader\\PhpFileLoader;\nuse Symfony\\Component\\DependencyInjection\\Loader\\XmlFileLoader;\nuse Symfony\\Component\\DependencyInjection\\Loader\\YamlFileLoader;\nuse Symfony\\Component\\ErrorHandler\\DebugClassLoader;\nuse Symfony\\Component\\Filesystem\\Filesystem;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Bundle\\BundleInterface;\nuse Symfony\\Component\\HttpKernel\\CacheWarmer\\WarmableInterface;\nuse Symfony\\Component\\HttpKernel\\Config\\FileLocator;\nuse Symfony\\Component\\HttpKernel\\DependencyInjection\\MergeExtensionConfigurationPass;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(ConfigCache::class);\n\n/**\n * The Kernel is the heart of the Symfony system.\n *\n * It manages an environment made of bundles.\n *\n * Environment names must always start with a letter and\n * they must only contain letters and numbers.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nabstract class Kernel implements KernelInterface, RebootableInterface, TerminableInterface\n{\n    /**\n     * @var array<string, BundleInterface>\n     */\n    protected array $bundles = [];\n\n    protected ?ContainerInterface $container = null;\n    protected bool $booted = false;\n    protected ?float $startTime = null;\n\n    private string $projectDir;\n    private ?string $warmupDir = null;\n    private int $requestStackSize = 0;\n    private bool $resetServices = false;\n\n    /**\n     * @var array<string, bool>\n     */\n    private static array $freshCache = [];\n\n    public const VERSION = '7.2.3-DEV';\n    public const VERSION_ID = 70203;\n    public const MAJOR_VERSION = 7;\n    public const MINOR_VERSION = 2;\n    public const RELEASE_VERSION = 3;\n    public const EXTRA_VERSION = 'DEV';\n\n    public const END_OF_MAINTENANCE = '07/2025';\n    public const END_OF_LIFE = '07/2025';\n\n    public function __construct(\n        protected string $environment,\n        protected bool $debug,\n    ) {\n        if (!$environment) {\n            throw new \\InvalidArgumentException(\\sprintf('Invalid environment provided to \"%s\": the environment cannot be empty.', get_debug_type($this)));\n        }\n    }\n\n    public function __clone()\n    {\n        $this->booted = false;\n        $this->container = null;\n        $this->requestStackSize = 0;\n        $this->resetServices = false;\n    }\n\n    public function boot(): void\n    {\n        if (true === $this->booted) {\n            if (!$this->requestStackSize && $this->resetServices) {\n                if ($this->container->has('services_resetter')) {\n                    $this->container->get('services_resetter')->reset();\n                }\n                $this->resetServices = false;\n                if ($this->debug) {\n                    $this->startTime = microtime(true);\n                }\n            }\n\n            return;\n        }\n\n        if (null === $this->container) {\n            $this->preBoot();\n        }\n\n        foreach ($this->getBundles() as $bundle) {\n            $bundle->setContainer($this->container);\n            $bundle->boot();\n        }\n\n        $this->booted = true;\n    }\n\n    public function reboot(?string $warmupDir): void\n    {\n        $this->shutdown();\n        $this->warmupDir = $warmupDir;\n        $this->boot();\n    }\n\n    public function terminate(Request $request, Response $response): void\n    {\n        if (false === $this->booted) {\n            return;\n        }\n\n        if ($this->getHttpKernel() instanceof TerminableInterface) {\n            $this->getHttpKernel()->terminate($request, $response);\n        }\n    }\n\n    public function shutdown(): void\n    {\n        if (false === $this->booted) {\n            return;\n        }\n\n        $this->booted = false;\n\n        foreach ($this->getBundles() as $bundle) {\n            $bundle->shutdown();\n            $bundle->setContainer(null);\n        }\n\n        $this->container = null;\n        $this->requestStackSize = 0;\n        $this->resetServices = false;\n    }\n\n    public function handle(Request $request, int $type = HttpKernelInterface::MAIN_REQUEST, bool $catch = true): Response\n    {\n        if (!$this->booted) {\n            $container = $this->container ?? $this->preBoot();\n\n            if ($container->has('http_cache')) {\n                return $container->get('http_cache')->handle($request, $type, $catch);\n            }\n        }\n\n        $this->boot();\n        ++$this->requestStackSize;\n        $this->resetServices = true;\n\n        try {\n            return $this->getHttpKernel()->handle($request, $type, $catch);\n        } finally {\n            --$this->requestStackSize;\n        }\n    }\n\n    /**\n     * Gets an HTTP kernel from the container.\n     */\n    protected function getHttpKernel(): HttpKernelInterface\n    {\n        return $this->container->get('http_kernel');\n    }\n\n    public function getBundles(): array\n    {\n        return $this->bundles;\n    }\n\n    public function getBundle(string $name): BundleInterface\n    {\n        if (!isset($this->bundles[$name])) {\n            throw new \\InvalidArgumentException(\\sprintf('Bundle \"%s\" does not exist or it is not enabled. Maybe you forgot to add it in the \"registerBundles()\" method of your \"%s.php\" file?', $name, get_debug_type($this)));\n        }\n\n        return $this->bundles[$name];\n    }\n\n    public function locateResource(string $name): string\n    {\n        if ('@' !== $name[0]) {\n            throw new \\InvalidArgumentException(\\sprintf('A resource name must start with @ (\"%s\" given).', $name));\n        }\n\n        if (str_contains($name, '..')) {\n            throw new \\RuntimeException(\\sprintf('File name \"%s\" contains invalid characters (..).', $name));\n        }\n\n        $bundleName = substr($name, 1);\n        $path = '';\n        if (str_contains($bundleName, '/')) {\n            [$bundleName, $path] = explode('/', $bundleName, 2);\n        }\n\n        $bundle = $this->getBundle($bundleName);\n        if (file_exists($file = $bundle->getPath().'/'.$path)) {\n            return $file;\n        }\n\n        throw new \\InvalidArgumentException(\\sprintf('Unable to find file \"%s\".', $name));\n    }\n\n    public function getEnvironment(): string\n    {\n        return $this->environment;\n    }\n\n    public function isDebug(): bool\n    {\n        return $this->debug;\n    }\n\n    /**\n     * Gets the application root dir (path of the project's composer file).\n     */\n    public function getProjectDir(): string\n    {\n        if (!isset($this->projectDir)) {\n            $r = new \\ReflectionObject($this);\n\n            if (!is_file($dir = $r->getFileName())) {\n                throw new \\LogicException(\\sprintf('Cannot auto-detect project dir for kernel of class \"%s\".', $r->name));\n            }\n\n            $dir = $rootDir = \\dirname($dir);\n            while (!is_file($dir.'/composer.json')) {\n                if ($dir === \\dirname($dir)) {\n                    return $this->projectDir = $rootDir;\n                }\n                $dir = \\dirname($dir);\n            }\n            $this->projectDir = $dir;\n        }\n\n        return $this->projectDir;\n    }\n\n    public function getContainer(): ContainerInterface\n    {\n        if (!$this->container) {\n            throw new \\LogicException('Cannot retrieve the container from a non-booted kernel.');\n        }\n\n        return $this->container;\n    }\n\n    /**\n     * @internal\n     *\n     * @deprecated since Symfony 7.1, to be removed in 8.0\n     */\n    public function setAnnotatedClassCache(array $annotatedClasses): void\n    {\n        trigger_deprecation('symfony/http-kernel', '7.1', 'The \"%s()\" method is deprecated since Symfony 7.1 and will be removed in 8.0.', __METHOD__);\n\n        file_put_contents(($this->warmupDir ?: $this->getBuildDir()).'/annotations.map', \\sprintf('<?php return %s;', var_export($annotatedClasses, true)));\n    }\n\n    public function getStartTime(): float\n    {\n        return $this->debug && null !== $this->startTime ? $this->startTime : -\\INF;\n    }\n\n    public function getCacheDir(): string\n    {\n        return $this->getProjectDir().'/var/cache/'.$this->environment;\n    }\n\n    public function getBuildDir(): string\n    {\n        // Returns $this->getCacheDir() for backward compatibility\n        return $this->getCacheDir();\n    }\n\n    public function getLogDir(): string\n    {\n        return $this->getProjectDir().'/var/log';\n    }\n\n    public function getCharset(): string\n    {\n        return 'UTF-8';\n    }\n\n    /**\n     * Gets the patterns defining the classes to parse and cache for annotations.\n     *\n     * @return string[]\n     *\n     * @deprecated since Symfony 7.1, to be removed in 8.0\n     */\n    public function getAnnotatedClassesToCompile(): array\n    {\n        trigger_deprecation('symfony/http-kernel', '7.1', 'The \"%s()\" method is deprecated since Symfony 7.1 and will be removed in 8.0.', __METHOD__);\n\n        return [];\n    }\n\n    /**\n     * Initializes bundles.\n     *\n     * @throws \\LogicException if two bundles share a common name\n     */\n    protected function initializeBundles(): void\n    {\n        // init bundles\n        $this->bundles = [];\n        foreach ($this->registerBundles() as $bundle) {\n            $name = $bundle->getName();\n            if (isset($this->bundles[$name])) {\n                throw new \\LogicException(\\sprintf('Trying to register two bundles with the same name \"%s\".', $name));\n            }\n            $this->bundles[$name] = $bundle;\n        }\n    }\n\n    /**\n     * The extension point similar to the Bundle::build() method.\n     *\n     * Use this method to register compiler passes and manipulate the container during the building process.\n     */\n    protected function build(ContainerBuilder $container): void\n    {\n    }\n\n    /**\n     * Gets the container class.\n     *\n     * @throws \\InvalidArgumentException If the generated classname is invalid\n     */\n    protected function getContainerClass(): string\n    {\n        $class = static::class;\n        $class = str_contains($class, \"@anonymous\\0\") ? get_parent_class($class).str_replace('.', '_', ContainerBuilder::hash($class)) : $class;\n        $class = str_replace('\\\\', '_', $class).ucfirst($this->environment).($this->debug ? 'Debug' : '').'Container';\n\n        if (!preg_match('/^[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*$/', $class)) {\n            throw new \\InvalidArgumentException(\\sprintf('The environment \"%s\" contains invalid characters, it can only contain characters allowed in PHP class names.', $this->environment));\n        }\n\n        return $class;\n    }\n\n    /**\n     * Gets the container's base class.\n     *\n     * All names except Container must be fully qualified.\n     */\n    protected function getContainerBaseClass(): string\n    {\n        return 'Container';\n    }\n\n    /**\n     * Initializes the service container.\n     *\n     * The built version of the service container is used when fresh, otherwise the\n     * container is built.\n     */\n    protected function initializeContainer(): void\n    {\n        $class = $this->getContainerClass();\n        $buildDir = $this->warmupDir ?: $this->getBuildDir();\n        $skip = $_SERVER['SYMFONY_DISABLE_RESOURCE_TRACKING'] ?? '';\n        $skip = filter_var($skip, \\FILTER_VALIDATE_BOOLEAN, \\FILTER_NULL_ON_FAILURE) ?? explode(',', $skip);\n        $cache = new ConfigCache($buildDir.'/'.$class.'.php', $this->debug, null, \\is_array($skip) && ['*'] !== $skip ? $skip : ($skip ? [] : null));\n\n        $cachePath = $cache->getPath();\n\n        // Silence E_WARNING to ignore \"include\" failures - don't use \"@\" to prevent silencing fatal errors\n        $errorLevel = error_reporting(\\E_ALL ^ \\E_WARNING);\n\n        try {\n            if (is_file($cachePath) && \\is_object($this->container = include $cachePath)\n                && (!$this->debug || (self::$freshCache[$cachePath] ?? $cache->isFresh()))\n            ) {\n                self::$freshCache[$cachePath] = true;\n                $this->container->set('kernel', $this);\n                error_reporting($errorLevel);\n\n                return;\n            }\n        } catch (\\Throwable $e) {\n        }\n\n        $oldContainer = \\is_object($this->container) ? new \\ReflectionClass($this->container) : $this->container = null;\n\n        try {\n            is_dir($buildDir) ?: mkdir($buildDir, 0777, true);\n\n            if ($lock = fopen($cachePath.'.lock', 'w+')) {\n                if (!flock($lock, \\LOCK_EX | \\LOCK_NB, $wouldBlock) && !flock($lock, $wouldBlock ? \\LOCK_SH : \\LOCK_EX)) {\n                    fclose($lock);\n                    $lock = null;\n                } elseif (!is_file($cachePath) || !\\is_object($this->container = include $cachePath)) {\n                    $this->container = null;\n                } elseif (!$oldContainer || $this->container::class !== $oldContainer->name) {\n                    flock($lock, \\LOCK_UN);\n                    fclose($lock);\n                    $this->container->set('kernel', $this);\n\n                    return;\n                }\n            }\n        } catch (\\Throwable $e) {\n        } finally {\n            error_reporting($errorLevel);\n        }\n\n        if ($collectDeprecations = $this->debug && !\\defined('PHPUNIT_COMPOSER_INSTALL')) {\n            $collectedLogs = [];\n            $previousHandler = set_error_handler(function ($type, $message, $file, $line) use (&$collectedLogs, &$previousHandler) {\n                if (\\E_USER_DEPRECATED !== $type && \\E_DEPRECATED !== $type) {\n                    return $previousHandler ? $previousHandler($type, $message, $file, $line) : false;\n                }\n\n                if (isset($collectedLogs[$message])) {\n                    ++$collectedLogs[$message]['count'];\n\n                    return null;\n                }\n\n                $backtrace = debug_backtrace(\\DEBUG_BACKTRACE_IGNORE_ARGS, 5);\n                // Clean the trace by removing first frames added by the error handler itself.\n                for ($i = 0; isset($backtrace[$i]); ++$i) {\n                    if (isset($backtrace[$i]['file'], $backtrace[$i]['line']) && $backtrace[$i]['line'] === $line && $backtrace[$i]['file'] === $file) {\n                        $backtrace = \\array_slice($backtrace, 1 + $i);\n                        break;\n                    }\n                }\n                for ($i = 0; isset($backtrace[$i]); ++$i) {\n                    if (!isset($backtrace[$i]['file'], $backtrace[$i]['line'], $backtrace[$i]['function'])) {\n                        continue;\n                    }\n                    if (!isset($backtrace[$i]['class']) && 'trigger_deprecation' === $backtrace[$i]['function']) {\n                        $file = $backtrace[$i]['file'];\n                        $line = $backtrace[$i]['line'];\n                        $backtrace = \\array_slice($backtrace, 1 + $i);\n                        break;\n                    }\n                }\n\n                // Remove frames added by DebugClassLoader.\n                for ($i = \\count($backtrace) - 2; 0 < $i; --$i) {\n                    if (DebugClassLoader::class === ($backtrace[$i]['class'] ?? null)) {\n                        $backtrace = [$backtrace[$i + 1]];\n                        break;\n                    }\n                }\n\n                $collectedLogs[$message] = [\n                    'type' => $type,\n                    'message' => $message,\n                    'file' => $file,\n                    'line' => $line,\n                    'trace' => [$backtrace[0]],\n                    'count' => 1,\n                ];\n\n                return null;\n            });\n        }\n\n        try {\n            $container = null;\n            $container = $this->buildContainer();\n            $container->compile();\n        } finally {\n            if ($collectDeprecations) {\n                restore_error_handler();\n\n                @file_put_contents($buildDir.'/'.$class.'Deprecations.log', serialize(array_values($collectedLogs)));\n                @file_put_contents($buildDir.'/'.$class.'Compiler.log', null !== $container ? implode(\"\\n\", $container->getCompiler()->getLog()) : '');\n            }\n        }\n\n        $this->dumpContainer($cache, $container, $class, $this->getContainerBaseClass());\n\n        if ($lock) {\n            flock($lock, \\LOCK_UN);\n            fclose($lock);\n        }\n\n        $this->container = require $cachePath;\n        $this->container->set('kernel', $this);\n\n        if ($oldContainer && $this->container::class !== $oldContainer->name) {\n            // Because concurrent requests might still be using them,\n            // old container files are not removed immediately,\n            // but on a next dump of the container.\n            static $legacyContainers = [];\n            $oldContainerDir = \\dirname($oldContainer->getFileName());\n            $legacyContainers[$oldContainerDir.'.legacy'] = true;\n            foreach (glob(\\dirname($oldContainerDir).\\DIRECTORY_SEPARATOR.'*.legacy', \\GLOB_NOSORT) as $legacyContainer) {\n                if (!isset($legacyContainers[$legacyContainer]) && @unlink($legacyContainer)) {\n                    (new Filesystem())->remove(substr($legacyContainer, 0, -7));\n                }\n            }\n\n            touch($oldContainerDir.'.legacy');\n        }\n\n        $buildDir = $this->container->getParameter('kernel.build_dir');\n        $cacheDir = $this->container->getParameter('kernel.cache_dir');\n        $preload = $this instanceof WarmableInterface ? $this->warmUp($cacheDir, $buildDir) : [];\n\n        if ($this->container->has('cache_warmer')) {\n            $cacheWarmer = $this->container->get('cache_warmer');\n\n            if ($cacheDir !== $buildDir) {\n                $cacheWarmer->enableOptionalWarmers();\n            }\n\n            $preload = array_merge($preload, $cacheWarmer->warmUp($cacheDir, $buildDir));\n        }\n\n        if ($preload && file_exists($preloadFile = $buildDir.'/'.$class.'.preload.php')) {\n            Preloader::append($preloadFile, $preload);\n        }\n    }\n\n    /**\n     * Returns the kernel parameters.\n     *\n     * @return array<string, array|bool|string|int|float|\\UnitEnum|null>\n     */\n    protected function getKernelParameters(): array\n    {\n        $bundles = [];\n        $bundlesMetadata = [];\n\n        foreach ($this->bundles as $name => $bundle) {\n            $bundles[$name] = $bundle::class;\n            $bundlesMetadata[$name] = [\n                'path' => $bundle->getPath(),\n                'namespace' => $bundle->getNamespace(),\n            ];\n        }\n\n        return [\n            'kernel.project_dir' => realpath($this->getProjectDir()) ?: $this->getProjectDir(),\n            'kernel.environment' => $this->environment,\n            'kernel.runtime_environment' => '%env(default:kernel.environment:APP_RUNTIME_ENV)%',\n            'kernel.runtime_mode' => '%env(query_string:default:container.runtime_mode:APP_RUNTIME_MODE)%',\n            'kernel.runtime_mode.web' => '%env(bool:default::key:web:default:kernel.runtime_mode:)%',\n            'kernel.runtime_mode.cli' => '%env(not:default:kernel.runtime_mode.web:)%',\n            'kernel.runtime_mode.worker' => '%env(bool:default::key:worker:default:kernel.runtime_mode:)%',\n            'kernel.debug' => $this->debug,\n            'kernel.build_dir' => realpath($buildDir = $this->warmupDir ?: $this->getBuildDir()) ?: $buildDir,\n            'kernel.cache_dir' => realpath($cacheDir = ($this->getCacheDir() === $this->getBuildDir() ? ($this->warmupDir ?: $this->getCacheDir()) : $this->getCacheDir())) ?: $cacheDir,\n            'kernel.logs_dir' => realpath($this->getLogDir()) ?: $this->getLogDir(),\n            'kernel.bundles' => $bundles,\n            'kernel.bundles_metadata' => $bundlesMetadata,\n            'kernel.charset' => $this->getCharset(),\n            'kernel.container_class' => $this->getContainerClass(),\n        ];\n    }\n\n    /**\n     * Builds the service container.\n     *\n     * @throws \\RuntimeException\n     */\n    protected function buildContainer(): ContainerBuilder\n    {\n        foreach (['cache' => $this->getCacheDir(), 'build' => $this->warmupDir ?: $this->getBuildDir(), 'logs' => $this->getLogDir()] as $name => $dir) {\n            if (!is_dir($dir)) {\n                if (false === @mkdir($dir, 0777, true) && !is_dir($dir)) {\n                    throw new \\RuntimeException(\\sprintf('Unable to create the \"%s\" directory (%s).', $name, $dir));\n                }\n            } elseif (!is_writable($dir)) {\n                throw new \\RuntimeException(\\sprintf('Unable to write in the \"%s\" directory (%s).', $name, $dir));\n            }\n        }\n\n        $container = $this->getContainerBuilder();\n        $container->addObjectResource($this);\n        $this->prepareContainer($container);\n        $this->registerContainerConfiguration($this->getContainerLoader($container));\n\n        return $container;\n    }\n\n    /**\n     * Prepares the ContainerBuilder before it is compiled.\n     */\n    protected function prepareContainer(ContainerBuilder $container): void\n    {\n        $extensions = [];\n        foreach ($this->bundles as $bundle) {\n            if ($extension = $bundle->getContainerExtension()) {\n                $container->registerExtension($extension);\n            }\n\n            if ($this->debug) {\n                $container->addObjectResource($bundle);\n            }\n        }\n\n        foreach ($this->bundles as $bundle) {\n            $bundle->build($container);\n        }\n\n        $this->build($container);\n\n        foreach ($container->getExtensions() as $extension) {\n            $extensions[] = $extension->getAlias();\n        }\n\n        // ensure these extensions are implicitly loaded\n        $container->getCompilerPassConfig()->setMergePass(new MergeExtensionConfigurationPass($extensions));\n    }\n\n    /**\n     * Gets a new ContainerBuilder instance used to build the service container.\n     */\n    protected function getContainerBuilder(): ContainerBuilder\n    {\n        $container = new ContainerBuilder();\n        $container->getParameterBag()->add($this->getKernelParameters());\n\n        if ($this instanceof ExtensionInterface) {\n            $container->registerExtension($this);\n        }\n        if ($this instanceof CompilerPassInterface) {\n            $container->addCompilerPass($this, PassConfig::TYPE_BEFORE_OPTIMIZATION, -10000);\n        }\n\n        return $container;\n    }\n\n    /**\n     * Dumps the service container to PHP code in the cache.\n     *\n     * @param string $class     The name of the class to generate\n     * @param string $baseClass The name of the container's base class\n     */\n    protected function dumpContainer(ConfigCache $cache, ContainerBuilder $container, string $class, string $baseClass): void\n    {\n        // cache the container\n        $dumper = new PhpDumper($container);\n\n        $buildParameters = [];\n        foreach ($container->getCompilerPassConfig()->getPasses() as $pass) {\n            if ($pass instanceof RemoveBuildParametersPass) {\n                $buildParameters = array_merge($buildParameters, $pass->getRemovedParameters());\n            }\n        }\n\n        $content = $dumper->dump([\n            'class' => $class,\n            'base_class' => $baseClass,\n            'file' => $cache->getPath(),\n            'as_files' => true,\n            'debug' => $this->debug,\n            'inline_factories' => $buildParameters['.container.dumper.inline_factories'] ?? false,\n            'inline_class_loader' => $buildParameters['.container.dumper.inline_class_loader'] ?? $this->debug,\n            'build_time' => $container->hasParameter('kernel.container_build_time') ? $container->getParameter('kernel.container_build_time') : time(),\n            'preload_classes' => array_map('get_class', $this->bundles),\n        ]);\n\n        $rootCode = array_pop($content);\n        $dir = \\dirname($cache->getPath()).'/';\n        $fs = new Filesystem();\n\n        foreach ($content as $file => $code) {\n            $fs->dumpFile($dir.$file, $code);\n            @chmod($dir.$file, 0666 & ~umask());\n        }\n        $legacyFile = \\dirname($dir.key($content)).'.legacy';\n        if (is_file($legacyFile)) {\n            @unlink($legacyFile);\n        }\n\n        $cache->write($rootCode, $container->getResources());\n    }\n\n    /**\n     * Returns a loader for the container.\n     */\n    protected function getContainerLoader(ContainerInterface $container): DelegatingLoader\n    {\n        $env = $this->getEnvironment();\n        $locator = new FileLocator($this);\n        $resolver = new LoaderResolver([\n            new XmlFileLoader($container, $locator, $env),\n            new YamlFileLoader($container, $locator, $env),\n            new IniFileLoader($container, $locator, $env),\n            new PhpFileLoader($container, $locator, $env, class_exists(ConfigBuilderGenerator::class) ? new ConfigBuilderGenerator($this->getBuildDir()) : null),\n            new GlobFileLoader($container, $locator, $env),\n            new DirectoryLoader($container, $locator, $env),\n            new ClosureLoader($container, $env),\n        ]);\n\n        return new DelegatingLoader($resolver);\n    }\n\n    private function preBoot(): ContainerInterface\n    {\n        if ($this->debug) {\n            $this->startTime = microtime(true);\n        }\n        if ($this->debug && !isset($_ENV['SHELL_VERBOSITY']) && !isset($_SERVER['SHELL_VERBOSITY'])) {\n            if (\\function_exists('putenv')) {\n                putenv('SHELL_VERBOSITY=3');\n            }\n            $_ENV['SHELL_VERBOSITY'] = 3;\n            $_SERVER['SHELL_VERBOSITY'] = 3;\n        }\n\n        $this->initializeBundles();\n        $this->initializeContainer();\n\n        $container = $this->container;\n\n        if ($container->hasParameter('kernel.trusted_hosts') && $trustedHosts = $container->getParameter('kernel.trusted_hosts')) {\n            Request::setTrustedHosts(\\is_array($trustedHosts) ? $trustedHosts : preg_split('/\\s*+,\\s*+(?![^{]*})/', $trustedHosts));\n        }\n\n        if ($container->hasParameter('kernel.trusted_proxies') && $container->hasParameter('kernel.trusted_headers') && $trustedProxies = $container->getParameter('kernel.trusted_proxies')) {\n            $trustedHeaders = $container->getParameter('kernel.trusted_headers');\n\n            if (\\is_string($trustedHeaders)) {\n                $trustedHeaders = array_map('trim', explode(',', $trustedHeaders));\n            }\n\n            if (\\is_array($trustedHeaders)) {\n                $trustedHeaderSet = 0;\n\n                foreach ($trustedHeaders as $header) {\n                    if (!\\defined($const = Request::class.'::HEADER_'.strtr(strtoupper($header), '-', '_'))) {\n                        throw new \\InvalidArgumentException(\\sprintf('The trusted header \"%s\" is not supported.', $header));\n                    }\n                    $trustedHeaderSet |= \\constant($const);\n                }\n            } else {\n                $trustedHeaderSet = $trustedHeaders ?? (Request::HEADER_X_FORWARDED_FOR | Request::HEADER_X_FORWARDED_PORT | Request::HEADER_X_FORWARDED_PROTO);\n            }\n\n            Request::setTrustedProxies(\\is_array($trustedProxies) ? $trustedProxies : array_map('trim', explode(',', $trustedProxies)), $trustedHeaderSet);\n        }\n\n        return $container;\n    }\n\n    public function __sleep(): array\n    {\n        return ['environment', 'debug'];\n    }\n\n    public function __wakeup(): void\n    {\n        if (\\is_object($this->environment) || \\is_object($this->debug)) {\n            throw new \\BadMethodCallException('Cannot unserialize '.__CLASS__);\n        }\n\n        $this->__construct($this->environment, $this->debug);\n    }\n}\n"
        },
        {
          "name": "KernelEvents.php",
          "type": "blob",
          "size": 4.044921875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel;\n\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerArgumentsEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\FinishRequestEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ResponseEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\TerminateEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ViewEvent;\n\n/**\n * Contains all events thrown in the HttpKernel component.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nfinal class KernelEvents\n{\n    /**\n     * The REQUEST event occurs at the very beginning of request\n     * dispatching.\n     *\n     * This event allows you to create a response for a request before any\n     * other code in the framework is executed.\n     *\n     * @Event(\"Symfony\\Component\\HttpKernel\\Event\\RequestEvent\")\n     */\n    public const REQUEST = 'kernel.request';\n\n    /**\n     * The EXCEPTION event occurs when an uncaught exception appears.\n     *\n     * This event allows you to create a response for a thrown exception or\n     * to modify the thrown exception.\n     *\n     * @Event(\"Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent\")\n     */\n    public const EXCEPTION = 'kernel.exception';\n\n    /**\n     * The CONTROLLER event occurs once a controller was found for\n     * handling a request.\n     *\n     * This event allows you to change the controller that will handle the\n     * request.\n     *\n     * @Event(\"Symfony\\Component\\HttpKernel\\Event\\ControllerEvent\")\n     */\n    public const CONTROLLER = 'kernel.controller';\n\n    /**\n     * The CONTROLLER_ARGUMENTS event occurs once controller arguments have been resolved.\n     *\n     * This event allows you to change the arguments that will be passed to\n     * the controller.\n     *\n     * @Event(\"Symfony\\Component\\HttpKernel\\Event\\ControllerArgumentsEvent\")\n     */\n    public const CONTROLLER_ARGUMENTS = 'kernel.controller_arguments';\n\n    /**\n     * The VIEW event occurs when the return value of a controller\n     * is not a Response instance.\n     *\n     * This event allows you to create a response for the return value of the\n     * controller.\n     *\n     * @Event(\"Symfony\\Component\\HttpKernel\\Event\\ViewEvent\")\n     */\n    public const VIEW = 'kernel.view';\n\n    /**\n     * The RESPONSE event occurs once a response was created for\n     * replying to a request.\n     *\n     * This event allows you to modify or replace the response that will be\n     * replied.\n     *\n     * @Event(\"Symfony\\Component\\HttpKernel\\Event\\ResponseEvent\")\n     */\n    public const RESPONSE = 'kernel.response';\n\n    /**\n     * The FINISH_REQUEST event occurs when a response was generated for a request.\n     *\n     * This event allows you to reset the global and environmental state of\n     * the application, when it was changed during the request.\n     *\n     * @Event(\"Symfony\\Component\\HttpKernel\\Event\\FinishRequestEvent\")\n     */\n    public const FINISH_REQUEST = 'kernel.finish_request';\n\n    /**\n     * The TERMINATE event occurs once a response was sent.\n     *\n     * This event allows you to run expensive post-response jobs.\n     *\n     * @Event(\"Symfony\\Component\\HttpKernel\\Event\\TerminateEvent\")\n     */\n    public const TERMINATE = 'kernel.terminate';\n\n    /**\n     * Event aliases.\n     *\n     * These aliases can be consumed by RegisterListenersPass.\n     */\n    public const ALIASES = [\n        ControllerArgumentsEvent::class => self::CONTROLLER_ARGUMENTS,\n        ControllerEvent::class => self::CONTROLLER,\n        ResponseEvent::class => self::RESPONSE,\n        FinishRequestEvent::class => self::FINISH_REQUEST,\n        RequestEvent::class => self::REQUEST,\n        ViewEvent::class => self::VIEW,\n        ExceptionEvent::class => self::EXCEPTION,\n        TerminateEvent::class => self::TERMINATE,\n    ];\n}\n"
        },
        {
          "name": "KernelInterface.php",
          "type": "blob",
          "size": 3.623046875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel;\n\nuse Symfony\\Component\\Config\\Loader\\LoaderInterface;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\nuse Symfony\\Component\\HttpKernel\\Bundle\\BundleInterface;\n\n/**\n * The Kernel is the heart of the Symfony system.\n *\n * It manages an environment made of application kernel and bundles.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\ninterface KernelInterface extends HttpKernelInterface\n{\n    /**\n     * Returns an array of bundles to register.\n     *\n     * @return iterable<mixed, BundleInterface>\n     */\n    public function registerBundles(): iterable;\n\n    /**\n     * Loads the container configuration.\n     *\n     * @return void\n     */\n    public function registerContainerConfiguration(LoaderInterface $loader);\n\n    /**\n     * Boots the current kernel.\n     *\n     * @return void\n     */\n    public function boot();\n\n    /**\n     * Shutdowns the kernel.\n     *\n     * This method is mainly useful when doing functional testing.\n     *\n     * @return void\n     */\n    public function shutdown();\n\n    /**\n     * Gets the registered bundle instances.\n     *\n     * @return array<string, BundleInterface>\n     */\n    public function getBundles(): array;\n\n    /**\n     * Returns a bundle.\n     *\n     * @throws \\InvalidArgumentException when the bundle is not enabled\n     */\n    public function getBundle(string $name): BundleInterface;\n\n    /**\n     * Returns the file path for a given bundle resource.\n     *\n     * A Resource can be a file or a directory.\n     *\n     * The resource name must follow the following pattern:\n     *\n     *     \"@BundleName/path/to/a/file.something\"\n     *\n     * where BundleName is the name of the bundle\n     * and the remaining part is the relative path in the bundle.\n     *\n     * @throws \\InvalidArgumentException if the file cannot be found or the name is not valid\n     * @throws \\RuntimeException         if the name contains invalid/unsafe characters\n     */\n    public function locateResource(string $name): string;\n\n    /**\n     * Gets the environment.\n     */\n    public function getEnvironment(): string;\n\n    /**\n     * Checks if debug mode is enabled.\n     */\n    public function isDebug(): bool;\n\n    /**\n     * Gets the project dir (path of the project's composer file).\n     */\n    public function getProjectDir(): string;\n\n    /**\n     * Gets the current container.\n     */\n    public function getContainer(): ContainerInterface;\n\n    /**\n     * Gets the request start time (not available if debug is disabled).\n     */\n    public function getStartTime(): float;\n\n    /**\n     * Gets the cache directory.\n     *\n     * Since Symfony 5.2, the cache directory should be used for caches that are written at runtime.\n     * For caches and artifacts that can be warmed at compile-time and deployed as read-only,\n     * use the new \"build directory\" returned by the {@see getBuildDir()} method.\n     */\n    public function getCacheDir(): string;\n\n    /**\n     * Returns the build directory.\n     *\n     * This directory should be used to store build artifacts, and can be read-only at runtime.\n     * Caches written at runtime should be stored in the \"cache directory\" ({@see KernelInterface::getCacheDir()}).\n     */\n    public function getBuildDir(): string;\n\n    /**\n     * Gets the log directory.\n     */\n    public function getLogDir(): string;\n\n    /**\n     * Gets the charset of the application.\n     */\n    public function getCharset(): string;\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Log",
          "type": "tree",
          "content": null
        },
        {
          "name": "Profiler",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.66015625,
          "content": "HttpKernel Component\n====================\n\nThe HttpKernel component provides a structured process for converting a Request\ninto a Response by making use of the EventDispatcher component. It's flexible\nenough to create full-stack frameworks, micro-frameworks or advanced CMS systems like Drupal.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/http_kernel.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "RebootableInterface.php",
          "type": "blob",
          "size": 0.7744140625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel;\n\n/**\n * Allows the Kernel to be rebooted using a temporary cache directory.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\ninterface RebootableInterface\n{\n    /**\n     * Reboots a kernel.\n     *\n     * The getBuildDir() method of a rebootable kernel should not be called\n     * while building the container. Use the %kernel.build_dir% parameter instead.\n     *\n     * @param string|null $warmupDir pass null to reboot in the regular build directory\n     */\n    public function reboot(?string $warmupDir): void;\n}\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "TerminableInterface.php",
          "type": "blob",
          "size": 0.89453125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n/**\n * Terminable extends the Kernel request/response cycle with dispatching a post\n * response event after sending the response and before shutting down the kernel.\n *\n * @author Jordi Boggiano <j.boggiano@seld.be>\n * @author Pierre Minnieur <pierre.minnieur@sensiolabs.de>\n */\ninterface TerminableInterface\n{\n    /**\n     * Terminates a request/response cycle.\n     *\n     * Should be called after sending the response and before shutting down the kernel.\n     */\n    public function terminate(Request $request, Response $response): void;\n}\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 2.67578125,
          "content": "{\n    \"name\": \"symfony/http-kernel\",\n    \"type\": \"library\",\n    \"description\": \"Provides a structured process for converting a Request into a Response\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3\",\n        \"symfony/error-handler\": \"^6.4|^7.0\",\n        \"symfony/event-dispatcher\": \"^6.4|^7.0\",\n        \"symfony/http-foundation\": \"^6.4|^7.0\",\n        \"symfony/polyfill-ctype\": \"^1.8\",\n        \"psr/log\": \"^1|^2|^3\"\n    },\n    \"require-dev\": {\n        \"symfony/browser-kit\": \"^6.4|^7.0\",\n        \"symfony/clock\": \"^6.4|^7.0\",\n        \"symfony/config\": \"^6.4|^7.0\",\n        \"symfony/console\": \"^6.4|^7.0\",\n        \"symfony/css-selector\": \"^6.4|^7.0\",\n        \"symfony/dependency-injection\": \"^6.4|^7.0\",\n        \"symfony/dom-crawler\": \"^6.4|^7.0\",\n        \"symfony/expression-language\": \"^6.4|^7.0\",\n        \"symfony/finder\": \"^6.4|^7.0\",\n        \"symfony/http-client-contracts\": \"^2.5|^3\",\n        \"symfony/process\": \"^6.4|^7.0\",\n        \"symfony/property-access\": \"^7.1\",\n        \"symfony/routing\": \"^6.4|^7.0\",\n        \"symfony/serializer\": \"^7.1\",\n        \"symfony/stopwatch\": \"^6.4|^7.0\",\n        \"symfony/translation\": \"^6.4|^7.0\",\n        \"symfony/translation-contracts\": \"^2.5|^3\",\n        \"symfony/uid\": \"^6.4|^7.0\",\n        \"symfony/validator\": \"^6.4|^7.0\",\n        \"symfony/var-dumper\": \"^6.4|^7.0\",\n        \"symfony/var-exporter\": \"^6.4|^7.0\",\n        \"psr/cache\": \"^1.0|^2.0|^3.0\",\n        \"twig/twig\": \"^3.12\"\n    },\n    \"provide\": {\n        \"psr/log-implementation\": \"1.0|2.0|3.0\"\n    },\n    \"conflict\": {\n        \"symfony/browser-kit\": \"<6.4\",\n        \"symfony/cache\": \"<6.4\",\n        \"symfony/config\": \"<6.4\",\n        \"symfony/console\": \"<6.4\",\n        \"symfony/form\": \"<6.4\",\n        \"symfony/dependency-injection\": \"<6.4\",\n        \"symfony/doctrine-bridge\": \"<6.4\",\n        \"symfony/http-client\": \"<6.4\",\n        \"symfony/http-client-contracts\": \"<2.5\",\n        \"symfony/mailer\": \"<6.4\",\n        \"symfony/messenger\": \"<6.4\",\n        \"symfony/translation\": \"<6.4\",\n        \"symfony/translation-contracts\": \"<2.5\",\n        \"symfony/twig-bridge\": \"<6.4\",\n        \"symfony/validator\": \"<6.4\",\n        \"symfony/var-dumper\": \"<6.4\",\n        \"twig/twig\": \"<3.12\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\HttpKernel\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 1.126953125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony HttpKernel Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n\n    <listeners>\n        <listener class=\"Symfony\\Bridge\\PhpUnit\\SymfonyTestsListener\">\n            <arguments>\n                <array>\n                    <element key=\"time-sensitive\"><string>Symfony\\Component\\HttpFoundation</string></element>\n                </array>\n            </arguments>\n        </listener>\n    </listeners>\n</phpunit>\n"
        }
      ]
    }
  ]
}