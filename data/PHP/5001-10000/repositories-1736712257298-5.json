{
  "metadata": {
    "timestamp": 1736712257298,
    "page": 5,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/console",
      "stars": 9773,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "Application.php",
          "type": "blob",
          "size": 46.708984375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Console;\n\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Command\\CompleteCommand;\nuse Symfony\\Component\\Console\\Command\\DumpCompletionCommand;\nuse Symfony\\Component\\Console\\Command\\HelpCommand;\nuse Symfony\\Component\\Console\\Command\\LazyCommand;\nuse Symfony\\Component\\Console\\Command\\ListCommand;\nuse Symfony\\Component\\Console\\Command\\SignalableCommandInterface;\nuse Symfony\\Component\\Console\\CommandLoader\\CommandLoaderInterface;\nuse Symfony\\Component\\Console\\Completion\\CompletionInput;\nuse Symfony\\Component\\Console\\Completion\\CompletionSuggestions;\nuse Symfony\\Component\\Console\\Completion\\Suggestion;\nuse Symfony\\Component\\Console\\Event\\ConsoleAlarmEvent;\nuse Symfony\\Component\\Console\\Event\\ConsoleCommandEvent;\nuse Symfony\\Component\\Console\\Event\\ConsoleErrorEvent;\nuse Symfony\\Component\\Console\\Event\\ConsoleSignalEvent;\nuse Symfony\\Component\\Console\\Event\\ConsoleTerminateEvent;\nuse Symfony\\Component\\Console\\Exception\\CommandNotFoundException;\nuse Symfony\\Component\\Console\\Exception\\ExceptionInterface;\nuse Symfony\\Component\\Console\\Exception\\LogicException;\nuse Symfony\\Component\\Console\\Exception\\NamespaceNotFoundException;\nuse Symfony\\Component\\Console\\Exception\\RuntimeException;\nuse Symfony\\Component\\Console\\Formatter\\OutputFormatter;\nuse Symfony\\Component\\Console\\Helper\\DebugFormatterHelper;\nuse Symfony\\Component\\Console\\Helper\\DescriptorHelper;\nuse Symfony\\Component\\Console\\Helper\\FormatterHelper;\nuse Symfony\\Component\\Console\\Helper\\Helper;\nuse Symfony\\Component\\Console\\Helper\\HelperSet;\nuse Symfony\\Component\\Console\\Helper\\ProcessHelper;\nuse Symfony\\Component\\Console\\Helper\\QuestionHelper;\nuse Symfony\\Component\\Console\\Input\\ArgvInput;\nuse Symfony\\Component\\Console\\Input\\ArrayInput;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputAwareInterface;\nuse Symfony\\Component\\Console\\Input\\InputDefinition;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\ConsoleOutput;\nuse Symfony\\Component\\Console\\Output\\ConsoleOutputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\SignalRegistry\\SignalRegistry;\nuse Symfony\\Component\\Console\\Style\\SymfonyStyle;\nuse Symfony\\Component\\ErrorHandler\\ErrorHandler;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n/**\n * An Application is the container for a collection of commands.\n *\n * It is the main entry point of a Console application.\n *\n * This class is optimized for a standard CLI environment.\n *\n * Usage:\n *\n *     $app = new Application('myapp', '1.0 (stable)');\n *     $app->add(new SimpleCommand());\n *     $app->run();\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Application implements ResetInterface\n{\n    private array $commands = [];\n    private bool $wantHelps = false;\n    private ?Command $runningCommand = null;\n    private ?CommandLoaderInterface $commandLoader = null;\n    private bool $catchExceptions = true;\n    private bool $catchErrors = false;\n    private bool $autoExit = true;\n    private InputDefinition $definition;\n    private HelperSet $helperSet;\n    private ?EventDispatcherInterface $dispatcher = null;\n    private Terminal $terminal;\n    private string $defaultCommand;\n    private bool $singleCommand = false;\n    private bool $initialized = false;\n    private ?SignalRegistry $signalRegistry = null;\n    private array $signalsToDispatchEvent = [];\n    private ?int $alarmInterval = null;\n\n    public function __construct(\n        private string $name = 'UNKNOWN',\n        private string $version = 'UNKNOWN',\n    ) {\n        $this->terminal = new Terminal();\n        $this->defaultCommand = 'list';\n        if (\\defined('SIGINT') && SignalRegistry::isSupported()) {\n            $this->signalRegistry = new SignalRegistry();\n            $this->signalsToDispatchEvent = [\\SIGINT, \\SIGQUIT, \\SIGTERM, \\SIGUSR1, \\SIGUSR2, \\SIGALRM];\n        }\n    }\n\n    /**\n     * @final\n     */\n    public function setDispatcher(EventDispatcherInterface $dispatcher): void\n    {\n        $this->dispatcher = $dispatcher;\n    }\n\n    public function setCommandLoader(CommandLoaderInterface $commandLoader): void\n    {\n        $this->commandLoader = $commandLoader;\n    }\n\n    public function getSignalRegistry(): SignalRegistry\n    {\n        if (!$this->signalRegistry) {\n            throw new RuntimeException('Signals are not supported. Make sure that the \"pcntl\" extension is installed and that \"pcntl_*\" functions are not disabled by your php.ini\\'s \"disable_functions\" directive.');\n        }\n\n        return $this->signalRegistry;\n    }\n\n    public function setSignalsToDispatchEvent(int ...$signalsToDispatchEvent): void\n    {\n        $this->signalsToDispatchEvent = $signalsToDispatchEvent;\n    }\n\n    /**\n     * Sets the interval to schedule a SIGALRM signal in seconds.\n     */\n    public function setAlarmInterval(?int $seconds): void\n    {\n        $this->alarmInterval = $seconds;\n        $this->scheduleAlarm();\n    }\n\n    /**\n     * Gets the interval in seconds on which a SIGALRM signal is dispatched.\n     */\n    public function getAlarmInterval(): ?int\n    {\n        return $this->alarmInterval;\n    }\n\n    private function scheduleAlarm(): void\n    {\n        if (null !== $this->alarmInterval) {\n            $this->getSignalRegistry()->scheduleAlarm($this->alarmInterval);\n        }\n    }\n\n    /**\n     * Runs the current application.\n     *\n     * @return int 0 if everything went fine, or an error code\n     *\n     * @throws \\Exception When running fails. Bypass this when {@link setCatchExceptions()}.\n     */\n    public function run(?InputInterface $input = null, ?OutputInterface $output = null): int\n    {\n        if (\\function_exists('putenv')) {\n            @putenv('LINES='.$this->terminal->getHeight());\n            @putenv('COLUMNS='.$this->terminal->getWidth());\n        }\n\n        $input ??= new ArgvInput();\n        $output ??= new ConsoleOutput();\n\n        $renderException = function (\\Throwable $e) use ($output) {\n            if ($output instanceof ConsoleOutputInterface) {\n                $this->renderThrowable($e, $output->getErrorOutput());\n            } else {\n                $this->renderThrowable($e, $output);\n            }\n        };\n        if ($phpHandler = set_exception_handler($renderException)) {\n            restore_exception_handler();\n            if (!\\is_array($phpHandler) || !$phpHandler[0] instanceof ErrorHandler) {\n                $errorHandler = true;\n            } elseif ($errorHandler = $phpHandler[0]->setExceptionHandler($renderException)) {\n                $phpHandler[0]->setExceptionHandler($errorHandler);\n            }\n        }\n\n        try {\n            $this->configureIO($input, $output);\n\n            $exitCode = $this->doRun($input, $output);\n        } catch (\\Throwable $e) {\n            if ($e instanceof \\Exception && !$this->catchExceptions) {\n                throw $e;\n            }\n            if (!$e instanceof \\Exception && !$this->catchErrors) {\n                throw $e;\n            }\n\n            $renderException($e);\n\n            $exitCode = $e->getCode();\n            if (is_numeric($exitCode)) {\n                $exitCode = (int) $exitCode;\n                if ($exitCode <= 0) {\n                    $exitCode = 1;\n                }\n            } else {\n                $exitCode = 1;\n            }\n        } finally {\n            // if the exception handler changed, keep it\n            // otherwise, unregister $renderException\n            if (!$phpHandler) {\n                if (set_exception_handler($renderException) === $renderException) {\n                    restore_exception_handler();\n                }\n                restore_exception_handler();\n            } elseif (!$errorHandler) {\n                $finalHandler = $phpHandler[0]->setExceptionHandler(null);\n                if ($finalHandler !== $renderException) {\n                    $phpHandler[0]->setExceptionHandler($finalHandler);\n                }\n            }\n        }\n\n        if ($this->autoExit) {\n            if ($exitCode > 255) {\n                $exitCode = 255;\n            }\n\n            exit($exitCode);\n        }\n\n        return $exitCode;\n    }\n\n    /**\n     * Runs the current application.\n     *\n     * @return int 0 if everything went fine, or an error code\n     */\n    public function doRun(InputInterface $input, OutputInterface $output): int\n    {\n        if (true === $input->hasParameterOption(['--version', '-V'], true)) {\n            $output->writeln($this->getLongVersion());\n\n            return 0;\n        }\n\n        try {\n            // Makes ArgvInput::getFirstArgument() able to distinguish an option from an argument.\n            $input->bind($this->getDefinition());\n        } catch (ExceptionInterface) {\n            // Errors must be ignored, full binding/validation happens later when the command is known.\n        }\n\n        $name = $this->getCommandName($input);\n        if (true === $input->hasParameterOption(['--help', '-h'], true)) {\n            if (!$name) {\n                $name = 'help';\n                $input = new ArrayInput(['command_name' => $this->defaultCommand]);\n            } else {\n                $this->wantHelps = true;\n            }\n        }\n\n        if (!$name) {\n            $name = $this->defaultCommand;\n            $definition = $this->getDefinition();\n            $definition->setArguments(array_merge(\n                $definition->getArguments(),\n                [\n                    'command' => new InputArgument('command', InputArgument::OPTIONAL, $definition->getArgument('command')->getDescription(), $name),\n                ]\n            ));\n        }\n\n        try {\n            $this->runningCommand = null;\n            // the command name MUST be the first element of the input\n            $command = $this->find($name);\n        } catch (\\Throwable $e) {\n            if (($e instanceof CommandNotFoundException && !$e instanceof NamespaceNotFoundException) && 1 === \\count($alternatives = $e->getAlternatives()) && $input->isInteractive()) {\n                $alternative = $alternatives[0];\n\n                $style = new SymfonyStyle($input, $output);\n                $output->writeln('');\n                $formattedBlock = (new FormatterHelper())->formatBlock(\\sprintf('Command \"%s\" is not defined.', $name), 'error', true);\n                $output->writeln($formattedBlock);\n                if (!$style->confirm(\\sprintf('Do you want to run \"%s\" instead? ', $alternative), false)) {\n                    if (null !== $this->dispatcher) {\n                        $event = new ConsoleErrorEvent($input, $output, $e);\n                        $this->dispatcher->dispatch($event, ConsoleEvents::ERROR);\n\n                        return $event->getExitCode();\n                    }\n\n                    return 1;\n                }\n\n                $command = $this->find($alternative);\n            } else {\n                if (null !== $this->dispatcher) {\n                    $event = new ConsoleErrorEvent($input, $output, $e);\n                    $this->dispatcher->dispatch($event, ConsoleEvents::ERROR);\n\n                    if (0 === $event->getExitCode()) {\n                        return 0;\n                    }\n\n                    $e = $event->getError();\n                }\n\n                try {\n                    if ($e instanceof CommandNotFoundException && $namespace = $this->findNamespace($name)) {\n                        $helper = new DescriptorHelper();\n                        $helper->describe($output instanceof ConsoleOutputInterface ? $output->getErrorOutput() : $output, $this, [\n                            'format' => 'txt',\n                            'raw_text' => false,\n                            'namespace' => $namespace,\n                            'short' => false,\n                        ]);\n\n                        return isset($event) ? $event->getExitCode() : 1;\n                    }\n\n                    throw $e;\n                } catch (NamespaceNotFoundException) {\n                    throw $e;\n                }\n            }\n        }\n\n        if ($command instanceof LazyCommand) {\n            $command = $command->getCommand();\n        }\n\n        $this->runningCommand = $command;\n        $exitCode = $this->doRunCommand($command, $input, $output);\n        $this->runningCommand = null;\n\n        return $exitCode;\n    }\n\n    public function reset(): void\n    {\n    }\n\n    public function setHelperSet(HelperSet $helperSet): void\n    {\n        $this->helperSet = $helperSet;\n    }\n\n    /**\n     * Get the helper set associated with the command.\n     */\n    public function getHelperSet(): HelperSet\n    {\n        return $this->helperSet ??= $this->getDefaultHelperSet();\n    }\n\n    public function setDefinition(InputDefinition $definition): void\n    {\n        $this->definition = $definition;\n    }\n\n    /**\n     * Gets the InputDefinition related to this Application.\n     */\n    public function getDefinition(): InputDefinition\n    {\n        $this->definition ??= $this->getDefaultInputDefinition();\n\n        if ($this->singleCommand) {\n            $inputDefinition = $this->definition;\n            $inputDefinition->setArguments();\n\n            return $inputDefinition;\n        }\n\n        return $this->definition;\n    }\n\n    /**\n     * Adds suggestions to $suggestions for the current completion input (e.g. option or argument).\n     */\n    public function complete(CompletionInput $input, CompletionSuggestions $suggestions): void\n    {\n        if (\n            CompletionInput::TYPE_ARGUMENT_VALUE === $input->getCompletionType()\n            && 'command' === $input->getCompletionName()\n        ) {\n            foreach ($this->all() as $name => $command) {\n                // skip hidden commands and aliased commands as they already get added below\n                if ($command->isHidden() || $command->getName() !== $name) {\n                    continue;\n                }\n                $suggestions->suggestValue(new Suggestion($command->getName(), $command->getDescription()));\n                foreach ($command->getAliases() as $name) {\n                    $suggestions->suggestValue(new Suggestion($name, $command->getDescription()));\n                }\n            }\n\n            return;\n        }\n\n        if (CompletionInput::TYPE_OPTION_NAME === $input->getCompletionType()) {\n            $suggestions->suggestOptions($this->getDefinition()->getOptions());\n        }\n    }\n\n    /**\n     * Gets the help message.\n     */\n    public function getHelp(): string\n    {\n        return $this->getLongVersion();\n    }\n\n    /**\n     * Gets whether to catch exceptions or not during commands execution.\n     */\n    public function areExceptionsCaught(): bool\n    {\n        return $this->catchExceptions;\n    }\n\n    /**\n     * Sets whether to catch exceptions or not during commands execution.\n     */\n    public function setCatchExceptions(bool $boolean): void\n    {\n        $this->catchExceptions = $boolean;\n    }\n\n    /**\n     * Sets whether to catch errors or not during commands execution.\n     */\n    public function setCatchErrors(bool $catchErrors = true): void\n    {\n        $this->catchErrors = $catchErrors;\n    }\n\n    /**\n     * Gets whether to automatically exit after a command execution or not.\n     */\n    public function isAutoExitEnabled(): bool\n    {\n        return $this->autoExit;\n    }\n\n    /**\n     * Sets whether to automatically exit after a command execution or not.\n     */\n    public function setAutoExit(bool $boolean): void\n    {\n        $this->autoExit = $boolean;\n    }\n\n    /**\n     * Gets the name of the application.\n     */\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    /**\n     * Sets the application name.\n     */\n    public function setName(string $name): void\n    {\n        $this->name = $name;\n    }\n\n    /**\n     * Gets the application version.\n     */\n    public function getVersion(): string\n    {\n        return $this->version;\n    }\n\n    /**\n     * Sets the application version.\n     */\n    public function setVersion(string $version): void\n    {\n        $this->version = $version;\n    }\n\n    /**\n     * Returns the long version of the application.\n     */\n    public function getLongVersion(): string\n    {\n        if ('UNKNOWN' !== $this->getName()) {\n            if ('UNKNOWN' !== $this->getVersion()) {\n                return \\sprintf('%s <info>%s</info>', $this->getName(), $this->getVersion());\n            }\n\n            return $this->getName();\n        }\n\n        return 'Console Tool';\n    }\n\n    /**\n     * Registers a new command.\n     */\n    public function register(string $name): Command\n    {\n        return $this->add(new Command($name));\n    }\n\n    /**\n     * Adds an array of command objects.\n     *\n     * If a Command is not enabled it will not be added.\n     *\n     * @param Command[] $commands An array of commands\n     */\n    public function addCommands(array $commands): void\n    {\n        foreach ($commands as $command) {\n            $this->add($command);\n        }\n    }\n\n    /**\n     * Adds a command object.\n     *\n     * If a command with the same name already exists, it will be overridden.\n     * If the command is not enabled it will not be added.\n     */\n    public function add(Command $command): ?Command\n    {\n        $this->init();\n\n        $command->setApplication($this);\n\n        if (!$command->isEnabled()) {\n            $command->setApplication(null);\n\n            return null;\n        }\n\n        if (!$command instanceof LazyCommand) {\n            // Will throw if the command is not correctly initialized.\n            $command->getDefinition();\n        }\n\n        if (!$command->getName()) {\n            throw new LogicException(\\sprintf('The command defined in \"%s\" cannot have an empty name.', get_debug_type($command)));\n        }\n\n        $this->commands[$command->getName()] = $command;\n\n        foreach ($command->getAliases() as $alias) {\n            $this->commands[$alias] = $command;\n        }\n\n        return $command;\n    }\n\n    /**\n     * Returns a registered command by name or alias.\n     *\n     * @throws CommandNotFoundException When given command name does not exist\n     */\n    public function get(string $name): Command\n    {\n        $this->init();\n\n        if (!$this->has($name)) {\n            throw new CommandNotFoundException(\\sprintf('The command \"%s\" does not exist.', $name));\n        }\n\n        // When the command has a different name than the one used at the command loader level\n        if (!isset($this->commands[$name])) {\n            throw new CommandNotFoundException(\\sprintf('The \"%s\" command cannot be found because it is registered under multiple names. Make sure you don\\'t set a different name via constructor or \"setName()\".', $name));\n        }\n\n        $command = $this->commands[$name];\n\n        if ($this->wantHelps) {\n            $this->wantHelps = false;\n\n            $helpCommand = $this->get('help');\n            $helpCommand->setCommand($command);\n\n            return $helpCommand;\n        }\n\n        return $command;\n    }\n\n    /**\n     * Returns true if the command exists, false otherwise.\n     */\n    public function has(string $name): bool\n    {\n        $this->init();\n\n        return isset($this->commands[$name]) || ($this->commandLoader?->has($name) && $this->add($this->commandLoader->get($name)));\n    }\n\n    /**\n     * Returns an array of all unique namespaces used by currently registered commands.\n     *\n     * It does not return the global namespace which always exists.\n     *\n     * @return string[]\n     */\n    public function getNamespaces(): array\n    {\n        $namespaces = [];\n        foreach ($this->all() as $command) {\n            if ($command->isHidden()) {\n                continue;\n            }\n\n            $namespaces[] = $this->extractAllNamespaces($command->getName());\n\n            foreach ($command->getAliases() as $alias) {\n                $namespaces[] = $this->extractAllNamespaces($alias);\n            }\n        }\n\n        return array_values(array_unique(array_filter(array_merge([], ...$namespaces))));\n    }\n\n    /**\n     * Finds a registered namespace by a name or an abbreviation.\n     *\n     * @throws NamespaceNotFoundException When namespace is incorrect or ambiguous\n     */\n    public function findNamespace(string $namespace): string\n    {\n        $allNamespaces = $this->getNamespaces();\n        $expr = implode('[^:]*:', array_map('preg_quote', explode(':', $namespace))).'[^:]*';\n        $namespaces = preg_grep('{^'.$expr.'}', $allNamespaces);\n\n        if (!$namespaces) {\n            $message = \\sprintf('There are no commands defined in the \"%s\" namespace.', $namespace);\n\n            if ($alternatives = $this->findAlternatives($namespace, $allNamespaces)) {\n                if (1 == \\count($alternatives)) {\n                    $message .= \"\\n\\nDid you mean this?\\n    \";\n                } else {\n                    $message .= \"\\n\\nDid you mean one of these?\\n    \";\n                }\n\n                $message .= implode(\"\\n    \", $alternatives);\n            }\n\n            throw new NamespaceNotFoundException($message, $alternatives);\n        }\n\n        $exact = \\in_array($namespace, $namespaces, true);\n        if (\\count($namespaces) > 1 && !$exact) {\n            throw new NamespaceNotFoundException(\\sprintf(\"The namespace \\\"%s\\\" is ambiguous.\\nDid you mean one of these?\\n%s.\", $namespace, $this->getAbbreviationSuggestions(array_values($namespaces))), array_values($namespaces));\n        }\n\n        return $exact ? $namespace : reset($namespaces);\n    }\n\n    /**\n     * Finds a command by name or alias.\n     *\n     * Contrary to get, this command tries to find the best\n     * match if you give it an abbreviation of a name or alias.\n     *\n     * @throws CommandNotFoundException When command name is incorrect or ambiguous\n     */\n    public function find(string $name): Command\n    {\n        $this->init();\n\n        $aliases = [];\n\n        foreach ($this->commands as $command) {\n            foreach ($command->getAliases() as $alias) {\n                if (!$this->has($alias)) {\n                    $this->commands[$alias] = $command;\n                }\n            }\n        }\n\n        if ($this->has($name)) {\n            return $this->get($name);\n        }\n\n        $allCommands = $this->commandLoader ? array_merge($this->commandLoader->getNames(), array_keys($this->commands)) : array_keys($this->commands);\n        $expr = implode('[^:]*:', array_map('preg_quote', explode(':', $name))).'[^:]*';\n        $commands = preg_grep('{^'.$expr.'}', $allCommands);\n\n        if (!$commands) {\n            $commands = preg_grep('{^'.$expr.'}i', $allCommands);\n        }\n\n        // if no commands matched or we just matched namespaces\n        if (!$commands || \\count(preg_grep('{^'.$expr.'$}i', $commands)) < 1) {\n            if (false !== $pos = strrpos($name, ':')) {\n                // check if a namespace exists and contains commands\n                $this->findNamespace(substr($name, 0, $pos));\n            }\n\n            $message = \\sprintf('Command \"%s\" is not defined.', $name);\n\n            if ($alternatives = $this->findAlternatives($name, $allCommands)) {\n                // remove hidden commands\n                $alternatives = array_filter($alternatives, fn ($name) => !$this->get($name)->isHidden());\n\n                if (1 == \\count($alternatives)) {\n                    $message .= \"\\n\\nDid you mean this?\\n    \";\n                } else {\n                    $message .= \"\\n\\nDid you mean one of these?\\n    \";\n                }\n                $message .= implode(\"\\n    \", $alternatives);\n            }\n\n            throw new CommandNotFoundException($message, array_values($alternatives));\n        }\n\n        // filter out aliases for commands which are already on the list\n        if (\\count($commands) > 1) {\n            $commandList = $this->commandLoader ? array_merge(array_flip($this->commandLoader->getNames()), $this->commands) : $this->commands;\n            $commands = array_unique(array_filter($commands, function ($nameOrAlias) use (&$commandList, $commands, &$aliases) {\n                if (!$commandList[$nameOrAlias] instanceof Command) {\n                    $commandList[$nameOrAlias] = $this->commandLoader->get($nameOrAlias);\n                }\n\n                $commandName = $commandList[$nameOrAlias]->getName();\n\n                $aliases[$nameOrAlias] = $commandName;\n\n                return $commandName === $nameOrAlias || !\\in_array($commandName, $commands, true);\n            }));\n        }\n\n        if (\\count($commands) > 1) {\n            $usableWidth = $this->terminal->getWidth() - 10;\n            $abbrevs = array_values($commands);\n            $maxLen = 0;\n            foreach ($abbrevs as $abbrev) {\n                $maxLen = max(Helper::width($abbrev), $maxLen);\n            }\n            $abbrevs = array_map(function ($cmd) use ($commandList, $usableWidth, $maxLen, &$commands) {\n                if ($commandList[$cmd]->isHidden()) {\n                    unset($commands[array_search($cmd, $commands)]);\n\n                    return false;\n                }\n\n                $abbrev = str_pad($cmd, $maxLen, ' ').' '.$commandList[$cmd]->getDescription();\n\n                return Helper::width($abbrev) > $usableWidth ? Helper::substr($abbrev, 0, $usableWidth - 3).'...' : $abbrev;\n            }, array_values($commands));\n\n            if (\\count($commands) > 1) {\n                $suggestions = $this->getAbbreviationSuggestions(array_filter($abbrevs));\n\n                throw new CommandNotFoundException(\\sprintf(\"Command \\\"%s\\\" is ambiguous.\\nDid you mean one of these?\\n%s.\", $name, $suggestions), array_values($commands));\n            }\n        }\n\n        $command = $this->get(reset($commands));\n\n        if ($command->isHidden()) {\n            throw new CommandNotFoundException(\\sprintf('The command \"%s\" does not exist.', $name));\n        }\n\n        return $command;\n    }\n\n    /**\n     * Gets the commands (registered in the given namespace if provided).\n     *\n     * The array keys are the full names and the values the command instances.\n     *\n     * @return Command[]\n     */\n    public function all(?string $namespace = null): array\n    {\n        $this->init();\n\n        if (null === $namespace) {\n            if (!$this->commandLoader) {\n                return $this->commands;\n            }\n\n            $commands = $this->commands;\n            foreach ($this->commandLoader->getNames() as $name) {\n                if (!isset($commands[$name]) && $this->has($name)) {\n                    $commands[$name] = $this->get($name);\n                }\n            }\n\n            return $commands;\n        }\n\n        $commands = [];\n        foreach ($this->commands as $name => $command) {\n            if ($namespace === $this->extractNamespace($name, substr_count($namespace, ':') + 1)) {\n                $commands[$name] = $command;\n            }\n        }\n\n        if ($this->commandLoader) {\n            foreach ($this->commandLoader->getNames() as $name) {\n                if (!isset($commands[$name]) && $namespace === $this->extractNamespace($name, substr_count($namespace, ':') + 1) && $this->has($name)) {\n                    $commands[$name] = $this->get($name);\n                }\n            }\n        }\n\n        return $commands;\n    }\n\n    /**\n     * Returns an array of possible abbreviations given a set of names.\n     *\n     * @return string[][]\n     */\n    public static function getAbbreviations(array $names): array\n    {\n        $abbrevs = [];\n        foreach ($names as $name) {\n            for ($len = \\strlen($name); $len > 0; --$len) {\n                $abbrev = substr($name, 0, $len);\n                $abbrevs[$abbrev][] = $name;\n            }\n        }\n\n        return $abbrevs;\n    }\n\n    public function renderThrowable(\\Throwable $e, OutputInterface $output): void\n    {\n        $output->writeln('', OutputInterface::VERBOSITY_QUIET);\n\n        $this->doRenderThrowable($e, $output);\n\n        if (null !== $this->runningCommand) {\n            $output->writeln(\\sprintf('<info>%s</info>', OutputFormatter::escape(\\sprintf($this->runningCommand->getSynopsis(), $this->getName()))), OutputInterface::VERBOSITY_QUIET);\n            $output->writeln('', OutputInterface::VERBOSITY_QUIET);\n        }\n    }\n\n    protected function doRenderThrowable(\\Throwable $e, OutputInterface $output): void\n    {\n        do {\n            $message = trim($e->getMessage());\n            if ('' === $message || OutputInterface::VERBOSITY_VERBOSE <= $output->getVerbosity()) {\n                $class = get_debug_type($e);\n                $title = \\sprintf('  [%s%s]  ', $class, 0 !== ($code = $e->getCode()) ? ' ('.$code.')' : '');\n                $len = Helper::width($title);\n            } else {\n                $len = 0;\n            }\n\n            if (str_contains($message, \"@anonymous\\0\")) {\n                $message = preg_replace_callback('/[a-zA-Z_\\x7f-\\xff][\\\\\\\\a-zA-Z0-9_\\x7f-\\xff]*+@anonymous\\x00.*?\\.php(?:0x?|:[0-9]++\\$)?[0-9a-fA-F]++/', fn ($m) => class_exists($m[0], false) ? (get_parent_class($m[0]) ?: key(class_implements($m[0])) ?: 'class').'@anonymous' : $m[0], $message);\n            }\n\n            $width = $this->terminal->getWidth() ? $this->terminal->getWidth() - 1 : \\PHP_INT_MAX;\n            $lines = [];\n            foreach ('' !== $message ? preg_split('/\\r?\\n/', $message) : [] as $line) {\n                foreach ($this->splitStringByWidth($line, $width - 4) as $line) {\n                    // pre-format lines to get the right string length\n                    $lineLength = Helper::width($line) + 4;\n                    $lines[] = [$line, $lineLength];\n\n                    $len = max($lineLength, $len);\n                }\n            }\n\n            $messages = [];\n            if (!$e instanceof ExceptionInterface || OutputInterface::VERBOSITY_VERBOSE <= $output->getVerbosity()) {\n                $messages[] = \\sprintf('<comment>%s</comment>', OutputFormatter::escape(\\sprintf('In %s line %s:', basename($e->getFile()) ?: 'n/a', $e->getLine() ?: 'n/a')));\n            }\n            $messages[] = $emptyLine = \\sprintf('<error>%s</error>', str_repeat(' ', $len));\n            if ('' === $message || OutputInterface::VERBOSITY_VERBOSE <= $output->getVerbosity()) {\n                $messages[] = \\sprintf('<error>%s%s</error>', $title, str_repeat(' ', max(0, $len - Helper::width($title))));\n            }\n            foreach ($lines as $line) {\n                $messages[] = \\sprintf('<error>  %s  %s</error>', OutputFormatter::escape($line[0]), str_repeat(' ', $len - $line[1]));\n            }\n            $messages[] = $emptyLine;\n            $messages[] = '';\n\n            $output->writeln($messages, OutputInterface::VERBOSITY_QUIET);\n\n            if (OutputInterface::VERBOSITY_VERBOSE <= $output->getVerbosity()) {\n                $output->writeln('<comment>Exception trace:</comment>', OutputInterface::VERBOSITY_QUIET);\n\n                // exception related properties\n                $trace = $e->getTrace();\n\n                array_unshift($trace, [\n                    'function' => '',\n                    'file' => $e->getFile() ?: 'n/a',\n                    'line' => $e->getLine() ?: 'n/a',\n                    'args' => [],\n                ]);\n\n                for ($i = 0, $count = \\count($trace); $i < $count; ++$i) {\n                    $class = $trace[$i]['class'] ?? '';\n                    $type = $trace[$i]['type'] ?? '';\n                    $function = $trace[$i]['function'] ?? '';\n                    $file = $trace[$i]['file'] ?? 'n/a';\n                    $line = $trace[$i]['line'] ?? 'n/a';\n\n                    $output->writeln(\\sprintf(' %s%s at <info>%s:%s</info>', $class, $function ? $type.$function.'()' : '', $file, $line), OutputInterface::VERBOSITY_QUIET);\n                }\n\n                $output->writeln('', OutputInterface::VERBOSITY_QUIET);\n            }\n        } while ($e = $e->getPrevious());\n    }\n\n    /**\n     * Configures the input and output instances based on the user arguments and options.\n     */\n    protected function configureIO(InputInterface $input, OutputInterface $output): void\n    {\n        if (true === $input->hasParameterOption(['--ansi'], true)) {\n            $output->setDecorated(true);\n        } elseif (true === $input->hasParameterOption(['--no-ansi'], true)) {\n            $output->setDecorated(false);\n        }\n\n        if (true === $input->hasParameterOption(['--no-interaction', '-n'], true)) {\n            $input->setInteractive(false);\n        }\n\n        switch ($shellVerbosity = (int) getenv('SHELL_VERBOSITY')) {\n            case -2:\n                $output->setVerbosity(OutputInterface::VERBOSITY_SILENT);\n                break;\n            case -1:\n                $output->setVerbosity(OutputInterface::VERBOSITY_QUIET);\n                break;\n            case 1:\n                $output->setVerbosity(OutputInterface::VERBOSITY_VERBOSE);\n                break;\n            case 2:\n                $output->setVerbosity(OutputInterface::VERBOSITY_VERY_VERBOSE);\n                break;\n            case 3:\n                $output->setVerbosity(OutputInterface::VERBOSITY_DEBUG);\n                break;\n            default:\n                $shellVerbosity = 0;\n                break;\n        }\n\n        if (true === $input->hasParameterOption(['--silent'], true)) {\n            $output->setVerbosity(OutputInterface::VERBOSITY_SILENT);\n            $shellVerbosity = -2;\n        } elseif (true === $input->hasParameterOption(['--quiet', '-q'], true)) {\n            $output->setVerbosity(OutputInterface::VERBOSITY_QUIET);\n            $shellVerbosity = -1;\n        } else {\n            if ($input->hasParameterOption('-vvv', true) || $input->hasParameterOption('--verbose=3', true) || 3 === $input->getParameterOption('--verbose', false, true)) {\n                $output->setVerbosity(OutputInterface::VERBOSITY_DEBUG);\n                $shellVerbosity = 3;\n            } elseif ($input->hasParameterOption('-vv', true) || $input->hasParameterOption('--verbose=2', true) || 2 === $input->getParameterOption('--verbose', false, true)) {\n                $output->setVerbosity(OutputInterface::VERBOSITY_VERY_VERBOSE);\n                $shellVerbosity = 2;\n            } elseif ($input->hasParameterOption('-v', true) || $input->hasParameterOption('--verbose=1', true) || $input->hasParameterOption('--verbose', true) || $input->getParameterOption('--verbose', false, true)) {\n                $output->setVerbosity(OutputInterface::VERBOSITY_VERBOSE);\n                $shellVerbosity = 1;\n            }\n        }\n\n        if (0 > $shellVerbosity) {\n            $input->setInteractive(false);\n        }\n\n        if (\\function_exists('putenv')) {\n            @putenv('SHELL_VERBOSITY='.$shellVerbosity);\n        }\n        $_ENV['SHELL_VERBOSITY'] = $shellVerbosity;\n        $_SERVER['SHELL_VERBOSITY'] = $shellVerbosity;\n    }\n\n    /**\n     * Runs the current command.\n     *\n     * If an event dispatcher has been attached to the application,\n     * events are also dispatched during the life-cycle of the command.\n     *\n     * @return int 0 if everything went fine, or an error code\n     */\n    protected function doRunCommand(Command $command, InputInterface $input, OutputInterface $output): int\n    {\n        foreach ($command->getHelperSet() as $helper) {\n            if ($helper instanceof InputAwareInterface) {\n                $helper->setInput($input);\n            }\n        }\n\n        $commandSignals = $command instanceof SignalableCommandInterface ? $command->getSubscribedSignals() : [];\n        if ($commandSignals || $this->dispatcher && $this->signalsToDispatchEvent) {\n            $signalRegistry = $this->getSignalRegistry();\n\n            if (Terminal::hasSttyAvailable()) {\n                $sttyMode = shell_exec('stty -g');\n\n                foreach ([\\SIGINT, \\SIGQUIT, \\SIGTERM] as $signal) {\n                    $signalRegistry->register($signal, static fn () => shell_exec('stty '.$sttyMode));\n                }\n            }\n\n            if ($this->dispatcher) {\n                // We register application signals, so that we can dispatch the event\n                foreach ($this->signalsToDispatchEvent as $signal) {\n                    $signalEvent = new ConsoleSignalEvent($command, $input, $output, $signal);\n                    $alarmEvent = \\SIGALRM === $signal ? new ConsoleAlarmEvent($command, $input, $output) : null;\n\n                    $signalRegistry->register($signal, function ($signal) use ($signalEvent, $alarmEvent, $command, $commandSignals, $input, $output) {\n                        $this->dispatcher->dispatch($signalEvent, ConsoleEvents::SIGNAL);\n                        $exitCode = $signalEvent->getExitCode();\n\n                        if (null !== $alarmEvent) {\n                            if (false !== $exitCode) {\n                                $alarmEvent->setExitCode($exitCode);\n                            } else {\n                                $alarmEvent->abortExit();\n                            }\n                            $this->dispatcher->dispatch($alarmEvent);\n                            $exitCode = $alarmEvent->getExitCode();\n                        }\n\n                        // If the command is signalable, we call the handleSignal() method\n                        if (\\in_array($signal, $commandSignals, true)) {\n                            $exitCode = $command->handleSignal($signal, $exitCode);\n                        }\n\n                        if (\\SIGALRM === $signal) {\n                            $this->scheduleAlarm();\n                        }\n\n                        if (false !== $exitCode) {\n                            $event = new ConsoleTerminateEvent($command, $input, $output, $exitCode, $signal);\n                            $this->dispatcher->dispatch($event, ConsoleEvents::TERMINATE);\n\n                            exit($event->getExitCode());\n                        }\n                    });\n                }\n\n                // then we register command signals, but not if already handled after the dispatcher\n                $commandSignals = array_diff($commandSignals, $this->signalsToDispatchEvent);\n            }\n\n            foreach ($commandSignals as $signal) {\n                $signalRegistry->register($signal, function (int $signal) use ($command): void {\n                    if (\\SIGALRM === $signal) {\n                        $this->scheduleAlarm();\n                    }\n\n                    if (false !== $exitCode = $command->handleSignal($signal)) {\n                        exit($exitCode);\n                    }\n                });\n            }\n        }\n\n        if (null === $this->dispatcher) {\n            return $command->run($input, $output);\n        }\n\n        // bind before the console.command event, so the listeners have access to input options/arguments\n        try {\n            $command->mergeApplicationDefinition();\n            $input->bind($command->getDefinition());\n        } catch (ExceptionInterface) {\n            // ignore invalid options/arguments for now, to allow the event listeners to customize the InputDefinition\n        }\n\n        $event = new ConsoleCommandEvent($command, $input, $output);\n        $e = null;\n\n        try {\n            $this->dispatcher->dispatch($event, ConsoleEvents::COMMAND);\n\n            if ($event->commandShouldRun()) {\n                $exitCode = $command->run($input, $output);\n            } else {\n                $exitCode = ConsoleCommandEvent::RETURN_CODE_DISABLED;\n            }\n        } catch (\\Throwable $e) {\n            $event = new ConsoleErrorEvent($input, $output, $e, $command);\n            $this->dispatcher->dispatch($event, ConsoleEvents::ERROR);\n            $e = $event->getError();\n\n            if (0 === $exitCode = $event->getExitCode()) {\n                $e = null;\n            }\n        }\n\n        $event = new ConsoleTerminateEvent($command, $input, $output, $exitCode);\n        $this->dispatcher->dispatch($event, ConsoleEvents::TERMINATE);\n\n        if (null !== $e) {\n            throw $e;\n        }\n\n        return $event->getExitCode();\n    }\n\n    /**\n     * Gets the name of the command based on input.\n     */\n    protected function getCommandName(InputInterface $input): ?string\n    {\n        return $this->singleCommand ? $this->defaultCommand : $input->getFirstArgument();\n    }\n\n    /**\n     * Gets the default input definition.\n     */\n    protected function getDefaultInputDefinition(): InputDefinition\n    {\n        return new InputDefinition([\n            new InputArgument('command', InputArgument::REQUIRED, 'The command to execute'),\n            new InputOption('--help', '-h', InputOption::VALUE_NONE, 'Display help for the given command. When no command is given display help for the <info>'.$this->defaultCommand.'</info> command'),\n            new InputOption('--silent', null, InputOption::VALUE_NONE, 'Do not output any message'),\n            new InputOption('--quiet', '-q', InputOption::VALUE_NONE, 'Only errors are displayed. All other output is suppressed'),\n            new InputOption('--verbose', '-v|vv|vvv', InputOption::VALUE_NONE, 'Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug'),\n            new InputOption('--version', '-V', InputOption::VALUE_NONE, 'Display this application version'),\n            new InputOption('--ansi', '', InputOption::VALUE_NEGATABLE, 'Force (or disable --no-ansi) ANSI output', null),\n            new InputOption('--no-interaction', '-n', InputOption::VALUE_NONE, 'Do not ask any interactive question'),\n        ]);\n    }\n\n    /**\n     * Gets the default commands that should always be available.\n     *\n     * @return Command[]\n     */\n    protected function getDefaultCommands(): array\n    {\n        return [new HelpCommand(), new ListCommand(), new CompleteCommand(), new DumpCompletionCommand()];\n    }\n\n    /**\n     * Gets the default helper set with the helpers that should always be available.\n     */\n    protected function getDefaultHelperSet(): HelperSet\n    {\n        return new HelperSet([\n            new FormatterHelper(),\n            new DebugFormatterHelper(),\n            new ProcessHelper(),\n            new QuestionHelper(),\n        ]);\n    }\n\n    /**\n     * Returns abbreviated suggestions in string format.\n     */\n    private function getAbbreviationSuggestions(array $abbrevs): string\n    {\n        return '    '.implode(\"\\n    \", $abbrevs);\n    }\n\n    /**\n     * Returns the namespace part of the command name.\n     *\n     * This method is not part of public API and should not be used directly.\n     */\n    public function extractNamespace(string $name, ?int $limit = null): string\n    {\n        $parts = explode(':', $name, -1);\n\n        return implode(':', null === $limit ? $parts : \\array_slice($parts, 0, $limit));\n    }\n\n    /**\n     * Finds alternative of $name among $collection,\n     * if nothing is found in $collection, try in $abbrevs.\n     *\n     * @return string[]\n     */\n    private function findAlternatives(string $name, iterable $collection): array\n    {\n        $threshold = 1e3;\n        $alternatives = [];\n\n        $collectionParts = [];\n        foreach ($collection as $item) {\n            $collectionParts[$item] = explode(':', $item);\n        }\n\n        foreach (explode(':', $name) as $i => $subname) {\n            foreach ($collectionParts as $collectionName => $parts) {\n                $exists = isset($alternatives[$collectionName]);\n                if (!isset($parts[$i]) && $exists) {\n                    $alternatives[$collectionName] += $threshold;\n                    continue;\n                } elseif (!isset($parts[$i])) {\n                    continue;\n                }\n\n                $lev = levenshtein($subname, $parts[$i]);\n                if ($lev <= \\strlen($subname) / 3 || '' !== $subname && str_contains($parts[$i], $subname)) {\n                    $alternatives[$collectionName] = $exists ? $alternatives[$collectionName] + $lev : $lev;\n                } elseif ($exists) {\n                    $alternatives[$collectionName] += $threshold;\n                }\n            }\n        }\n\n        foreach ($collection as $item) {\n            $lev = levenshtein($name, $item);\n            if ($lev <= \\strlen($name) / 3 || str_contains($item, $name)) {\n                $alternatives[$item] = isset($alternatives[$item]) ? $alternatives[$item] - $lev : $lev;\n            }\n        }\n\n        $alternatives = array_filter($alternatives, fn ($lev) => $lev < 2 * $threshold);\n        ksort($alternatives, \\SORT_NATURAL | \\SORT_FLAG_CASE);\n\n        return array_keys($alternatives);\n    }\n\n    /**\n     * Sets the default Command name.\n     *\n     * @return $this\n     */\n    public function setDefaultCommand(string $commandName, bool $isSingleCommand = false): static\n    {\n        $this->defaultCommand = explode('|', ltrim($commandName, '|'))[0];\n\n        if ($isSingleCommand) {\n            // Ensure the command exist\n            $this->find($commandName);\n\n            $this->singleCommand = true;\n        }\n\n        return $this;\n    }\n\n    /**\n     * @internal\n     */\n    public function isSingleCommand(): bool\n    {\n        return $this->singleCommand;\n    }\n\n    private function splitStringByWidth(string $string, int $width): array\n    {\n        // str_split is not suitable for multi-byte characters, we should use preg_split to get char array properly.\n        // additionally, array_slice() is not enough as some character has doubled width.\n        // we need a function to split string not by character count but by string width\n        if (false === $encoding = mb_detect_encoding($string, null, true)) {\n            return str_split($string, $width);\n        }\n\n        $utf8String = mb_convert_encoding($string, 'utf8', $encoding);\n        $lines = [];\n        $line = '';\n\n        $offset = 0;\n        while (preg_match('/.{1,10000}/u', $utf8String, $m, 0, $offset)) {\n            $offset += \\strlen($m[0]);\n\n            foreach (preg_split('//u', $m[0]) as $char) {\n                // test if $char could be appended to current line\n                if (mb_strwidth($line.$char, 'utf8') <= $width) {\n                    $line .= $char;\n                    continue;\n                }\n                // if not, push current line to array and make new line\n                $lines[] = str_pad($line, $width);\n                $line = $char;\n            }\n        }\n\n        $lines[] = \\count($lines) ? str_pad($line, $width) : $line;\n\n        mb_convert_variables($encoding, 'utf8', $lines);\n\n        return $lines;\n    }\n\n    /**\n     * Returns all namespaces of the command name.\n     *\n     * @return string[]\n     */\n    private function extractAllNamespaces(string $name): array\n    {\n        // -1 as third argument is needed to skip the command short name when exploding\n        $parts = explode(':', $name, -1);\n        $namespaces = [];\n\n        foreach ($parts as $part) {\n            if (\\count($namespaces)) {\n                $namespaces[] = end($namespaces).':'.$part;\n            } else {\n                $namespaces[] = $part;\n            }\n        }\n\n        return $namespaces;\n    }\n\n    private function init(): void\n    {\n        if ($this->initialized) {\n            return;\n        }\n        $this->initialized = true;\n\n        foreach ($this->getDefaultCommands() as $command) {\n            $this->add($command);\n        }\n    }\n}\n"
        },
        {
          "name": "Attribute",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 11.3671875,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Add support for `FORCE_COLOR` environment variable\n * Add `verbosity` argument to `mustRun` process helper method\n * [BC BREAK] Add silent verbosity (`--silent`/`SHELL_VERBOSITY=-2`) to suppress all output, including errors\n * Add `OutputInterface::isSilent()`, `Output::isSilent()`, `OutputStyle::isSilent()` methods\n * Add a configurable finished indicator to the progress indicator to show that the progress is finished\n * Add ability to schedule alarm signals and a `ConsoleAlarmEvent`\n\n7.1\n---\n\n * Add `ArgvInput::getRawTokens()`\n\n7.0\n---\n\n * Add method `__toString()` to `InputInterface`\n * Remove `Command::$defaultName` and `Command::$defaultDescription`, use the `AsCommand` attribute instead\n * Require explicit argument when calling `*Command::setApplication()`, `*FormatterStyle::setForeground/setBackground()`, `Helper::setHelpSet()`, `Input*::setDefault()` and `Question::setAutocompleterCallback/setValidator()`\n * Remove `StringInput::REGEX_STRING`\n\n6.4\n---\n\n * Add `SignalMap` to map signal value to its name\n * Multi-line text in vertical tables is aligned properly\n * The application can also catch errors with `Application::setCatchErrors(true)`\n * Add `RunCommandMessage` and `RunCommandMessageHandler`\n * Dispatch `ConsoleTerminateEvent` after an exit on signal handling and add `ConsoleTerminateEvent::getInterruptingSignal()`\n\n6.3\n---\n\n * Add support for choosing exit code while handling signal, or to not exit at all\n * Add `ProgressBar::setPlaceholderFormatter` to set a placeholder attached to a instance, instead of being global.\n * Add `ReStructuredTextDescriptor`\n\n6.2\n---\n\n * Improve truecolor terminal detection in some cases\n * Add support for 256 color terminals (conversion from Ansi24 to Ansi8 if terminal is capable of it)\n * Deprecate calling `*Command::setApplication()`, `*FormatterStyle::setForeground/setBackground()`, `Helper::setHelpSet()`, `Input*::setDefault()`, `Question::setAutocompleterCallback/setValidator()`without any arguments\n * Change the signature of `OutputFormatterStyleInterface::setForeground/setBackground()` to `setForeground/setBackground(?string)`\n * Change the signature of `HelperInterface::setHelperSet()` to `setHelperSet(?HelperSet)`\n\n6.1\n---\n\n * Add support to display table vertically when calling setVertical()\n * Add method `__toString()` to `InputInterface`\n * Added `OutputWrapper` to prevent truncated URL in `SymfonyStyle::createBlock`.\n * Deprecate `Command::$defaultName` and `Command::$defaultDescription`, use the `AsCommand` attribute instead\n * Add suggested values for arguments and options in input definition, for input completion\n * Add `$resumeAt` parameter to `ProgressBar#start()`, so that one can easily 'resume' progress on longer tasks, and still get accurate `getEstimate()` and `getRemaining()` results.\n\n6.0\n---\n\n * `Command::setHidden()` has a default value (`true`) for `$hidden` parameter and is final\n * Remove `Helper::strlen()`, use `Helper::width()` instead\n * Remove `Helper::strlenWithoutDecoration()`, use `Helper::removeDecoration()` instead\n * `AddConsoleCommandPass` can not be configured anymore\n * Remove `HelperSet::setCommand()` and `getCommand()` without replacement\n\n5.4\n---\n\n * Add `TesterTrait::assertCommandIsSuccessful()` to test command\n * Deprecate `HelperSet::setCommand()` and `getCommand()` without replacement\n\n5.3\n---\n\n * Add `GithubActionReporter` to render annotations in a Github Action\n * Add `InputOption::VALUE_NEGATABLE` flag to handle `--foo`/`--no-foo` options\n * Add the `Command::$defaultDescription` static property and the `description` attribute\n   on the `console.command` tag to allow the `list` command to instantiate commands lazily\n * Add option `--short` to the `list` command\n * Add support for bright colors\n * Add `#[AsCommand]` attribute for declaring commands on PHP 8\n * Add `Helper::width()` and `Helper::length()`\n * The `--ansi` and `--no-ansi` options now default to `null`.\n\n5.2.0\n-----\n\n * Added `SingleCommandApplication::setAutoExit()` to allow testing via `CommandTester`\n * added support for multiline responses to questions through `Question::setMultiline()`\n   and `Question::isMultiline()`\n * Added `SignalRegistry` class to stack signals handlers\n * Added support for signals:\n    * Added `Application::getSignalRegistry()` and `Application::setSignalsToDispatchEvent()` methods\n    * Added `SignalableCommandInterface` interface\n * Added `TableCellStyle` class to customize table cell\n * Removed `php ` prefix invocation from help messages.\n\n5.1.0\n-----\n\n * `Command::setHidden()` is final since Symfony 5.1\n * Add `SingleCommandApplication`\n * Add `Cursor` class\n\n5.0.0\n-----\n\n * removed support for finding hidden commands using an abbreviation, use the full name instead\n * removed `TableStyle::setCrossingChar()` method in favor of `TableStyle::setDefaultCrossingChar()`\n * removed `TableStyle::setHorizontalBorderChar()` method in favor of `TableStyle::setDefaultCrossingChars()`\n * removed `TableStyle::getHorizontalBorderChar()` method in favor of `TableStyle::getBorderChars()`\n * removed `TableStyle::setVerticalBorderChar()` method in favor of `TableStyle::setVerticalBorderChars()`\n * removed `TableStyle::getVerticalBorderChar()` method in favor of `TableStyle::getBorderChars()`\n * removed support for returning `null` from `Command::execute()`, return `0` instead\n * `ProcessHelper::run()` accepts only `array|Symfony\\Component\\Process\\Process` for its `command` argument\n * `Application::setDispatcher` accepts only `Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface`\n   for its `dispatcher` argument\n * renamed `Application::renderException()` and `Application::doRenderException()`\n   to `renderThrowable()` and `doRenderThrowable()` respectively.\n\n4.4.0\n-----\n\n * deprecated finding hidden commands using an abbreviation, use the full name instead\n * added `Question::setTrimmable` default to true to allow the answer to be trimmed\n * added method `minSecondsBetweenRedraws()` and `maxSecondsBetweenRedraws()` on `ProgressBar`\n * `Application` implements `ResetInterface`\n * marked all dispatched event classes as `@final`\n * added support for displaying table horizontally\n * deprecated returning `null` from `Command::execute()`, return `0` instead\n * Deprecated the `Application::renderException()` and `Application::doRenderException()` methods,\n   use `renderThrowable()` and `doRenderThrowable()` instead.\n * added support for the `NO_COLOR` env var (https://no-color.org/)\n\n4.3.0\n-----\n\n * added support for hyperlinks\n * added `ProgressBar::iterate()` method that simplify updating the progress bar when iterating\n * added `Question::setAutocompleterCallback()` to provide a callback function\n   that dynamically generates suggestions as the user types\n\n4.2.0\n-----\n\n * allowed passing commands as `[$process, 'ENV_VAR' => 'value']` to\n   `ProcessHelper::run()` to pass environment variables\n * deprecated passing a command as a string to `ProcessHelper::run()`,\n   pass it the command as an array of its arguments instead\n * made the `ProcessHelper` class final\n * added `WrappableOutputFormatterInterface::formatAndWrap()` (implemented in `OutputFormatter`)\n * added `capture_stderr_separately` option to `CommandTester::execute()`\n\n4.1.0\n-----\n\n * added option to run suggested command if command is not found and only 1 alternative is available\n * added option to modify console output and print multiple modifiable sections\n * added support for iterable messages in output `write` and `writeln` methods\n\n4.0.0\n-----\n\n * `OutputFormatter` throws an exception when unknown options are used\n * removed `QuestionHelper::setInputStream()/getInputStream()`\n * removed `Application::getTerminalWidth()/getTerminalHeight()` and\n   `Application::setTerminalDimensions()/getTerminalDimensions()`\n * removed `ConsoleExceptionEvent`\n * removed `ConsoleEvents::EXCEPTION`\n\n3.4.0\n-----\n\n * added `SHELL_VERBOSITY` env var to control verbosity\n * added `CommandLoaderInterface`, `FactoryCommandLoader` and PSR-11\n   `ContainerCommandLoader` for commands lazy-loading\n * added a case-insensitive command name matching fallback\n * added static `Command::$defaultName/getDefaultName()`, allowing for\n   commands to be registered at compile time in the application command loader.\n   Setting the `$defaultName` property avoids the need for filling the `command`\n   attribute on the `console.command` tag when using `AddConsoleCommandPass`.\n\n3.3.0\n-----\n\n * added `ExceptionListener`\n * added `AddConsoleCommandPass` (originally in FrameworkBundle)\n * [BC BREAK] `Input::getOption()` no longer returns the default value for options\n   with value optional explicitly passed empty\n * added console.error event to catch exceptions thrown by other listeners\n * deprecated console.exception event in favor of console.error\n * added ability to handle `CommandNotFoundException` through the\n   `console.error` event\n * deprecated default validation in `SymfonyQuestionHelper::ask`\n\n3.2.0\n------\n\n * added `setInputs()` method to CommandTester for ease testing of commands expecting inputs\n * added `setStream()` and `getStream()` methods to Input (implement StreamableInputInterface)\n * added StreamableInputInterface\n * added LockableTrait\n\n3.1.0\n-----\n\n * added truncate method to FormatterHelper\n * added setColumnWidth(s) method to Table\n\n2.8.3\n-----\n\n * remove readline support from the question helper as it caused issues\n\n2.8.0\n-----\n\n * use readline for user input in the question helper when available to allow\n   the use of arrow keys\n\n2.6.0\n-----\n\n * added a Process helper\n * added a DebugFormatter helper\n\n2.5.0\n-----\n\n * deprecated the dialog helper (use the question helper instead)\n * deprecated TableHelper in favor of Table\n * deprecated ProgressHelper in favor of ProgressBar\n * added ConsoleLogger\n * added a question helper\n * added a way to set the process name of a command\n * added a way to set a default command instead of `ListCommand`\n\n2.4.0\n-----\n\n * added a way to force terminal dimensions\n * added a convenient method to detect verbosity level\n * [BC BREAK] made descriptors use output instead of returning a string\n\n2.3.0\n-----\n\n * added multiselect support to the select dialog helper\n * added Table Helper for tabular data rendering\n * added support for events in `Application`\n * added a way to normalize EOLs in `ApplicationTester::getDisplay()` and `CommandTester::getDisplay()`\n * added a way to set the progress bar progress via the `setCurrent` method\n * added support for multiple InputOption shortcuts, written as `'-a|-b|-c'`\n * added two additional verbosity levels, VERBOSITY_VERY_VERBOSE and VERBOSITY_DEBUG\n\n2.2.0\n-----\n\n * added support for colorization on Windows via ConEmu\n * add a method to Dialog Helper to ask for a question and hide the response\n * added support for interactive selections in console (DialogHelper::select())\n * added support for autocompletion as you type in Dialog Helper\n\n2.1.0\n-----\n\n * added ConsoleOutputInterface\n * added the possibility to disable a command (Command::isEnabled())\n * added suggestions when a command does not exist\n * added a --raw option to the list command\n * added support for STDERR in the console output class (errors are now sent\n   to STDERR)\n * made the defaults (helper set, commands, input definition) in Application\n   more easily customizable\n * added support for the shell even if readline is not available\n * added support for process isolation in Symfony shell via\n   `--process-isolation` switch\n * added support for `--`, which disables options parsing after that point\n   (tokens will be parsed as arguments)\n"
        },
        {
          "name": "CI",
          "type": "tree",
          "content": null
        },
        {
          "name": "Color.php",
          "type": "blob",
          "size": 3.6962890625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Console;\n\nuse Symfony\\Component\\Console\\Exception\\InvalidArgumentException;\n\n/**\n * @author Fabien Potencier <fabien@symfony.com>\n */\nfinal class Color\n{\n    private const COLORS = [\n        'black' => 0,\n        'red' => 1,\n        'green' => 2,\n        'yellow' => 3,\n        'blue' => 4,\n        'magenta' => 5,\n        'cyan' => 6,\n        'white' => 7,\n        'default' => 9,\n    ];\n\n    private const BRIGHT_COLORS = [\n        'gray' => 0,\n        'bright-red' => 1,\n        'bright-green' => 2,\n        'bright-yellow' => 3,\n        'bright-blue' => 4,\n        'bright-magenta' => 5,\n        'bright-cyan' => 6,\n        'bright-white' => 7,\n    ];\n\n    private const AVAILABLE_OPTIONS = [\n        'bold' => ['set' => 1, 'unset' => 22],\n        'underscore' => ['set' => 4, 'unset' => 24],\n        'blink' => ['set' => 5, 'unset' => 25],\n        'reverse' => ['set' => 7, 'unset' => 27],\n        'conceal' => ['set' => 8, 'unset' => 28],\n    ];\n\n    private string $foreground;\n    private string $background;\n    private array $options = [];\n\n    public function __construct(string $foreground = '', string $background = '', array $options = [])\n    {\n        $this->foreground = $this->parseColor($foreground);\n        $this->background = $this->parseColor($background, true);\n\n        foreach ($options as $option) {\n            if (!isset(self::AVAILABLE_OPTIONS[$option])) {\n                throw new InvalidArgumentException(\\sprintf('Invalid option specified: \"%s\". Expected one of (%s).', $option, implode(', ', array_keys(self::AVAILABLE_OPTIONS))));\n            }\n\n            $this->options[$option] = self::AVAILABLE_OPTIONS[$option];\n        }\n    }\n\n    public function apply(string $text): string\n    {\n        return $this->set().$text.$this->unset();\n    }\n\n    public function set(): string\n    {\n        $setCodes = [];\n        if ('' !== $this->foreground) {\n            $setCodes[] = $this->foreground;\n        }\n        if ('' !== $this->background) {\n            $setCodes[] = $this->background;\n        }\n        foreach ($this->options as $option) {\n            $setCodes[] = $option['set'];\n        }\n        if (0 === \\count($setCodes)) {\n            return '';\n        }\n\n        return \\sprintf(\"\\033[%sm\", implode(';', $setCodes));\n    }\n\n    public function unset(): string\n    {\n        $unsetCodes = [];\n        if ('' !== $this->foreground) {\n            $unsetCodes[] = 39;\n        }\n        if ('' !== $this->background) {\n            $unsetCodes[] = 49;\n        }\n        foreach ($this->options as $option) {\n            $unsetCodes[] = $option['unset'];\n        }\n        if (0 === \\count($unsetCodes)) {\n            return '';\n        }\n\n        return \\sprintf(\"\\033[%sm\", implode(';', $unsetCodes));\n    }\n\n    private function parseColor(string $color, bool $background = false): string\n    {\n        if ('' === $color) {\n            return '';\n        }\n\n        if ('#' === $color[0]) {\n            return ($background ? '4' : '3').Terminal::getColorMode()->convertFromHexToAnsiColorCode($color);\n        }\n\n        if (isset(self::COLORS[$color])) {\n            return ($background ? '4' : '3').self::COLORS[$color];\n        }\n\n        if (isset(self::BRIGHT_COLORS[$color])) {\n            return ($background ? '10' : '9').self::BRIGHT_COLORS[$color];\n        }\n\n        throw new InvalidArgumentException(\\sprintf('Invalid \"%s\" color; expected one of (%s).', $color, implode(', ', array_merge(array_keys(self::COLORS), array_keys(self::BRIGHT_COLORS)))));\n    }\n}\n"
        },
        {
          "name": "Command",
          "type": "tree",
          "content": null
        },
        {
          "name": "CommandLoader",
          "type": "tree",
          "content": null
        },
        {
          "name": "Completion",
          "type": "tree",
          "content": null
        },
        {
          "name": "ConsoleEvents.php",
          "type": "blob",
          "size": 2.123046875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Console;\n\nuse Symfony\\Component\\Console\\Event\\ConsoleCommandEvent;\nuse Symfony\\Component\\Console\\Event\\ConsoleErrorEvent;\nuse Symfony\\Component\\Console\\Event\\ConsoleSignalEvent;\nuse Symfony\\Component\\Console\\Event\\ConsoleTerminateEvent;\n\n/**\n * Contains all events dispatched by an Application.\n *\n * @author Francesco Levorato <git@flevour.net>\n */\nfinal class ConsoleEvents\n{\n    /**\n     * The COMMAND event allows you to attach listeners before any command is\n     * executed by the console. It also allows you to modify the command, input and output\n     * before they are handed to the command.\n     *\n     * @Event(\"Symfony\\Component\\Console\\Event\\ConsoleCommandEvent\")\n     */\n    public const COMMAND = 'console.command';\n\n    /**\n     * The SIGNAL event allows you to perform some actions\n     * after the command execution was interrupted.\n     *\n     * @Event(\"Symfony\\Component\\Console\\Event\\ConsoleSignalEvent\")\n     */\n    public const SIGNAL = 'console.signal';\n\n    /**\n     * The TERMINATE event allows you to attach listeners after a command is\n     * executed by the console.\n     *\n     * @Event(\"Symfony\\Component\\Console\\Event\\ConsoleTerminateEvent\")\n     */\n    public const TERMINATE = 'console.terminate';\n\n    /**\n     * The ERROR event occurs when an uncaught exception or error appears.\n     *\n     * This event allows you to deal with the exception/error or\n     * to modify the thrown exception.\n     *\n     * @Event(\"Symfony\\Component\\Console\\Event\\ConsoleErrorEvent\")\n     */\n    public const ERROR = 'console.error';\n\n    /**\n     * Event aliases.\n     *\n     * These aliases can be consumed by RegisterListenersPass.\n     */\n    public const ALIASES = [\n        ConsoleCommandEvent::class => self::COMMAND,\n        ConsoleErrorEvent::class => self::ERROR,\n        ConsoleSignalEvent::class => self::SIGNAL,\n        ConsoleTerminateEvent::class => self::TERMINATE,\n    ];\n}\n"
        },
        {
          "name": "Cursor.php",
          "type": "blob",
          "size": 3.8818359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Console;\n\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n/**\n * @author Pierre du Plessis <pdples@gmail.com>\n */\nfinal class Cursor\n{\n    /** @var resource */\n    private $input;\n\n    /**\n     * @param resource|null $input\n     */\n    public function __construct(\n        private OutputInterface $output,\n        $input = null,\n    ) {\n        $this->input = $input ?? (\\defined('STDIN') ? \\STDIN : fopen('php://input', 'r+'));\n    }\n\n    /**\n     * @return $this\n     */\n    public function moveUp(int $lines = 1): static\n    {\n        $this->output->write(\\sprintf(\"\\x1b[%dA\", $lines));\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function moveDown(int $lines = 1): static\n    {\n        $this->output->write(\\sprintf(\"\\x1b[%dB\", $lines));\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function moveRight(int $columns = 1): static\n    {\n        $this->output->write(\\sprintf(\"\\x1b[%dC\", $columns));\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function moveLeft(int $columns = 1): static\n    {\n        $this->output->write(\\sprintf(\"\\x1b[%dD\", $columns));\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function moveToColumn(int $column): static\n    {\n        $this->output->write(\\sprintf(\"\\x1b[%dG\", $column));\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function moveToPosition(int $column, int $row): static\n    {\n        $this->output->write(\\sprintf(\"\\x1b[%d;%dH\", $row + 1, $column));\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function savePosition(): static\n    {\n        $this->output->write(\"\\x1b7\");\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function restorePosition(): static\n    {\n        $this->output->write(\"\\x1b8\");\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function hide(): static\n    {\n        $this->output->write(\"\\x1b[?25l\");\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     */\n    public function show(): static\n    {\n        $this->output->write(\"\\x1b[?25h\\x1b[?0c\");\n\n        return $this;\n    }\n\n    /**\n     * Clears all the output from the current line.\n     *\n     * @return $this\n     */\n    public function clearLine(): static\n    {\n        $this->output->write(\"\\x1b[2K\");\n\n        return $this;\n    }\n\n    /**\n     * Clears all the output from the current line after the current position.\n     */\n    public function clearLineAfter(): self\n    {\n        $this->output->write(\"\\x1b[K\");\n\n        return $this;\n    }\n\n    /**\n     * Clears all the output from the cursors' current position to the end of the screen.\n     *\n     * @return $this\n     */\n    public function clearOutput(): static\n    {\n        $this->output->write(\"\\x1b[0J\");\n\n        return $this;\n    }\n\n    /**\n     * Clears the entire screen.\n     *\n     * @return $this\n     */\n    public function clearScreen(): static\n    {\n        $this->output->write(\"\\x1b[2J\");\n\n        return $this;\n    }\n\n    /**\n     * Returns the current cursor position as x,y coordinates.\n     */\n    public function getCurrentPosition(): array\n    {\n        static $isTtySupported;\n\n        if (!$isTtySupported ??= '/' === \\DIRECTORY_SEPARATOR && stream_isatty(\\STDOUT)) {\n            return [1, 1];\n        }\n\n        $sttyMode = shell_exec('stty -g');\n        shell_exec('stty -icanon -echo');\n\n        @fwrite($this->input, \"\\033[6n\");\n\n        $code = trim(fread($this->input, 1024));\n\n        shell_exec(\\sprintf('stty %s', $sttyMode));\n\n        sscanf($code, \"\\033[%d;%dR\", $row, $col);\n\n        return [$col, $row];\n    }\n}\n"
        },
        {
          "name": "DataCollector",
          "type": "tree",
          "content": null
        },
        {
          "name": "Debug",
          "type": "tree",
          "content": null
        },
        {
          "name": "DependencyInjection",
          "type": "tree",
          "content": null
        },
        {
          "name": "Descriptor",
          "type": "tree",
          "content": null
        },
        {
          "name": "Event",
          "type": "tree",
          "content": null
        },
        {
          "name": "EventListener",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Formatter",
          "type": "tree",
          "content": null
        },
        {
          "name": "Helper",
          "type": "tree",
          "content": null
        },
        {
          "name": "Input",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Logger",
          "type": "tree",
          "content": null
        },
        {
          "name": "Messenger",
          "type": "tree",
          "content": null
        },
        {
          "name": "Output",
          "type": "tree",
          "content": null
        },
        {
          "name": "Question",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.763671875,
          "content": "Console Component\n=================\n\nThe Console component eases the creation of beautiful and testable command line\ninterfaces.\n\nSponsor\n-------\n\nHelp Symfony by [sponsoring][1] its development!\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/console.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n\nCredits\n-------\n\n`Resources/bin/hiddeninput.exe` is a third party binary provided within this\ncomponent. Find sources and license at https://github.com/Seldaek/hidden-input.\n\n[1]: https://symfony.com/sponsor\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "SignalRegistry",
          "type": "tree",
          "content": null
        },
        {
          "name": "SingleCommandApplication.php",
          "type": "blob",
          "size": 1.7490234375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Console;\n\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n/**\n * @author Grégoire Pineau <lyrixx@lyrixx.info>\n */\nclass SingleCommandApplication extends Command\n{\n    private string $version = 'UNKNOWN';\n    private bool $autoExit = true;\n    private bool $running = false;\n\n    /**\n     * @return $this\n     */\n    public function setVersion(string $version): static\n    {\n        $this->version = $version;\n\n        return $this;\n    }\n\n    /**\n     * @final\n     *\n     * @return $this\n     */\n    public function setAutoExit(bool $autoExit): static\n    {\n        $this->autoExit = $autoExit;\n\n        return $this;\n    }\n\n    public function run(?InputInterface $input = null, ?OutputInterface $output = null): int\n    {\n        if ($this->running) {\n            return parent::run($input, $output);\n        }\n\n        // We use the command name as the application name\n        $application = new Application($this->getName() ?: 'UNKNOWN', $this->version);\n        $application->setAutoExit($this->autoExit);\n        // Fix the usage of the command displayed with \"--help\"\n        $this->setName($_SERVER['argv'][0]);\n        $application->add($this);\n        $application->setDefaultCommand($this->getName(), true);\n\n        $this->running = true;\n        try {\n            $ret = $application->run($input, $output);\n        } finally {\n            $this->running = false;\n        }\n\n        return $ret;\n    }\n}\n"
        },
        {
          "name": "Style",
          "type": "tree",
          "content": null
        },
        {
          "name": "Terminal.php",
          "type": "blob",
          "size": 6.611328125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Console;\n\nuse Symfony\\Component\\Console\\Output\\AnsiColorMode;\n\nclass Terminal\n{\n    public const DEFAULT_COLOR_MODE = AnsiColorMode::Ansi4;\n\n    private static ?AnsiColorMode $colorMode = null;\n    private static ?int $width = null;\n    private static ?int $height = null;\n    private static ?bool $stty = null;\n\n    /**\n     * About Ansi color types: https://en.wikipedia.org/wiki/ANSI_escape_code#Colors\n     * For more information about true color support with terminals https://github.com/termstandard/colors/.\n     */\n    public static function getColorMode(): AnsiColorMode\n    {\n        // Use Cache from previous run (or user forced mode)\n        if (null !== self::$colorMode) {\n            return self::$colorMode;\n        }\n\n        // Try with $COLORTERM first\n        if (\\is_string($colorterm = getenv('COLORTERM'))) {\n            $colorterm = strtolower($colorterm);\n\n            if (str_contains($colorterm, 'truecolor')) {\n                self::setColorMode(AnsiColorMode::Ansi24);\n\n                return self::$colorMode;\n            }\n\n            if (str_contains($colorterm, '256color')) {\n                self::setColorMode(AnsiColorMode::Ansi8);\n\n                return self::$colorMode;\n            }\n        }\n\n        // Try with $TERM\n        if (\\is_string($term = getenv('TERM'))) {\n            $term = strtolower($term);\n\n            if (str_contains($term, 'truecolor')) {\n                self::setColorMode(AnsiColorMode::Ansi24);\n\n                return self::$colorMode;\n            }\n\n            if (str_contains($term, '256color')) {\n                self::setColorMode(AnsiColorMode::Ansi8);\n\n                return self::$colorMode;\n            }\n        }\n\n        self::setColorMode(self::DEFAULT_COLOR_MODE);\n\n        return self::$colorMode;\n    }\n\n    /**\n     * Force a terminal color mode rendering.\n     */\n    public static function setColorMode(?AnsiColorMode $colorMode): void\n    {\n        self::$colorMode = $colorMode;\n    }\n\n    /**\n     * Gets the terminal width.\n     */\n    public function getWidth(): int\n    {\n        $width = getenv('COLUMNS');\n        if (false !== $width) {\n            return (int) trim($width);\n        }\n\n        if (null === self::$width) {\n            self::initDimensions();\n        }\n\n        return self::$width ?: 80;\n    }\n\n    /**\n     * Gets the terminal height.\n     */\n    public function getHeight(): int\n    {\n        $height = getenv('LINES');\n        if (false !== $height) {\n            return (int) trim($height);\n        }\n\n        if (null === self::$height) {\n            self::initDimensions();\n        }\n\n        return self::$height ?: 50;\n    }\n\n    /**\n     * @internal\n     */\n    public static function hasSttyAvailable(): bool\n    {\n        if (null !== self::$stty) {\n            return self::$stty;\n        }\n\n        // skip check if shell_exec function is disabled\n        if (!\\function_exists('shell_exec')) {\n            return false;\n        }\n\n        return self::$stty = (bool) shell_exec('stty 2> '.('\\\\' === \\DIRECTORY_SEPARATOR ? 'NUL' : '/dev/null'));\n    }\n\n    private static function initDimensions(): void\n    {\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $ansicon = getenv('ANSICON');\n            if (false !== $ansicon && preg_match('/^(\\d+)x(\\d+)(?: \\((\\d+)x(\\d+)\\))?$/', trim($ansicon), $matches)) {\n                // extract [w, H] from \"wxh (WxH)\"\n                // or [w, h] from \"wxh\"\n                self::$width = (int) $matches[1];\n                self::$height = isset($matches[4]) ? (int) $matches[4] : (int) $matches[2];\n            } elseif (!sapi_windows_vt100_support(fopen('php://stdout', 'w')) && self::hasSttyAvailable()) {\n                // only use stty on Windows if the terminal does not support vt100 (e.g. Windows 7 + git-bash)\n                // testing for stty in a Windows 10 vt100-enabled console will implicitly disable vt100 support on STDOUT\n                self::initDimensionsUsingStty();\n            } elseif (null !== $dimensions = self::getConsoleMode()) {\n                // extract [w, h] from \"wxh\"\n                self::$width = (int) $dimensions[0];\n                self::$height = (int) $dimensions[1];\n            }\n        } else {\n            self::initDimensionsUsingStty();\n        }\n    }\n\n    /**\n     * Initializes dimensions using the output of an stty columns line.\n     */\n    private static function initDimensionsUsingStty(): void\n    {\n        if ($sttyString = self::getSttyColumns()) {\n            if (preg_match('/rows.(\\d+);.columns.(\\d+);/is', $sttyString, $matches)) {\n                // extract [w, h] from \"rows h; columns w;\"\n                self::$width = (int) $matches[2];\n                self::$height = (int) $matches[1];\n            } elseif (preg_match('/;.(\\d+).rows;.(\\d+).columns/is', $sttyString, $matches)) {\n                // extract [w, h] from \"; h rows; w columns\"\n                self::$width = (int) $matches[2];\n                self::$height = (int) $matches[1];\n            }\n        }\n    }\n\n    /**\n     * Runs and parses mode CON if it's available, suppressing any error output.\n     *\n     * @return int[]|null An array composed of the width and the height or null if it could not be parsed\n     */\n    private static function getConsoleMode(): ?array\n    {\n        $info = self::readFromProcess('mode CON');\n\n        if (null === $info || !preg_match('/--------+\\r?\\n.+?(\\d+)\\r?\\n.+?(\\d+)\\r?\\n/', $info, $matches)) {\n            return null;\n        }\n\n        return [(int) $matches[2], (int) $matches[1]];\n    }\n\n    /**\n     * Runs and parses stty -a if it's available, suppressing any error output.\n     */\n    private static function getSttyColumns(): ?string\n    {\n        return self::readFromProcess(['stty', '-a']);\n    }\n\n    private static function readFromProcess(string|array $command): ?string\n    {\n        if (!\\function_exists('proc_open')) {\n            return null;\n        }\n\n        $descriptorspec = [\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $cp = \\function_exists('sapi_windows_cp_set') ? sapi_windows_cp_get() : 0;\n\n        if (!$process = @proc_open($command, $descriptorspec, $pipes, null, null, ['suppress_errors' => true])) {\n            return null;\n        }\n\n        $info = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        fclose($pipes[2]);\n        proc_close($process);\n\n        if ($cp) {\n            sapi_windows_cp_set($cp);\n        }\n\n        return $info;\n    }\n}\n"
        },
        {
          "name": "Tester",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.6259765625,
          "content": "{\n    \"name\": \"symfony/console\",\n    \"type\": \"library\",\n    \"description\": \"Eases the creation of beautiful and testable command line interfaces\",\n    \"keywords\": [\"console\", \"cli\", \"command-line\", \"terminal\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/polyfill-mbstring\": \"~1.0\",\n        \"symfony/service-contracts\": \"^2.5|^3\",\n        \"symfony/string\": \"^6.4|^7.0\"\n    },\n    \"require-dev\": {\n        \"symfony/config\": \"^6.4|^7.0\",\n        \"symfony/event-dispatcher\": \"^6.4|^7.0\",\n        \"symfony/http-foundation\": \"^6.4|^7.0\",\n        \"symfony/http-kernel\": \"^6.4|^7.0\",\n        \"symfony/dependency-injection\": \"^6.4|^7.0\",\n        \"symfony/lock\": \"^6.4|^7.0\",\n        \"symfony/messenger\": \"^6.4|^7.0\",\n        \"symfony/process\": \"^6.4|^7.0\",\n        \"symfony/stopwatch\": \"^6.4|^7.0\",\n        \"symfony/var-dumper\": \"^6.4|^7.0\",\n        \"psr/log\": \"^1|^2|^3\"\n    },\n    \"provide\": {\n        \"psr/log-implementation\": \"1.0|2.0|3.0\"\n    },\n    \"conflict\": {\n        \"symfony/dependency-injection\": \"<6.4\",\n        \"symfony/dotenv\": \"<6.4\",\n        \"symfony/event-dispatcher\": \"<6.4\",\n        \"symfony/lock\": \"<6.4\",\n        \"symfony/process\": \"<6.4\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Console\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 1.1630859375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Console Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Resources</directory>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n\n    <listeners>\n        <listener class=\"Symfony\\Bridge\\PhpUnit\\SymfonyTestsListener\">\n            <arguments>\n                <array>\n                    <element key=\"time-sensitive\"><string>Symfony\\Component\\Console</string></element>\n                </array>\n            </arguments>\n        </listener>\n    </listeners>\n</phpunit>\n"
        }
      ]
    }
  ]
}