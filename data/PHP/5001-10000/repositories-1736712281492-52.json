{
  "metadata": {
    "timestamp": 1736712281492,
    "page": 52,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/routing",
      "stars": 7611,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "Alias.php",
          "type": "blob",
          "size": 2.47265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Routing;\n\nuse Symfony\\Component\\Routing\\Exception\\InvalidArgumentException;\n\nclass Alias\n{\n    private array $deprecation = [];\n\n    public function __construct(\n        private string $id,\n    ) {\n    }\n\n    public function withId(string $id): static\n    {\n        $new = clone $this;\n\n        $new->id = $id;\n\n        return $new;\n    }\n\n    /**\n     * Returns the target name of this alias.\n     *\n     * @return string The target name\n     */\n    public function getId(): string\n    {\n        return $this->id;\n    }\n\n    /**\n     * Whether this alias is deprecated, that means it should not be referenced anymore.\n     *\n     * @param string $package The name of the composer package that is triggering the deprecation\n     * @param string $version The version of the package that introduced the deprecation\n     * @param string $message The deprecation message to use\n     *\n     * @return $this\n     *\n     * @throws InvalidArgumentException when the message template is invalid\n     */\n    public function setDeprecated(string $package, string $version, string $message): static\n    {\n        if ('' !== $message) {\n            if (preg_match('#[\\r\\n]|\\*/#', $message)) {\n                throw new InvalidArgumentException('Invalid characters found in deprecation template.');\n            }\n\n            if (!str_contains($message, '%alias_id%')) {\n                throw new InvalidArgumentException('The deprecation template must contain the \"%alias_id%\" placeholder.');\n            }\n        }\n\n        $this->deprecation = [\n            'package' => $package,\n            'version' => $version,\n            'message' => $message ?: 'The \"%alias_id%\" route alias is deprecated. You should stop using it, as it will be removed in the future.',\n        ];\n\n        return $this;\n    }\n\n    public function isDeprecated(): bool\n    {\n        return (bool) $this->deprecation;\n    }\n\n    /**\n     * @param string $name Route name relying on this alias\n     */\n    public function getDeprecation(string $name): array\n    {\n        return [\n            'package' => $this->deprecation['package'],\n            'version' => $this->deprecation['version'],\n            'message' => str_replace('%alias_id%', $name, $this->deprecation['message']),\n        ];\n    }\n}\n"
        },
        {
          "name": "Annotation",
          "type": "tree",
          "content": null
        },
        {
          "name": "Attribute",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 14.154296875,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Add the `Requirement::UID_RFC9562` constant to validate UUIDs in the RFC 9562 format\n * Deprecate the `AttributeClassLoader::$routeAnnotationClass` property\n\n7.1\n---\n\n * Add `{foo:bar}` syntax to define a mapping between a route parameter and its corresponding request attribute\n\n7.0\n---\n\n * Add argument `$routeParameters` to `UrlMatcher::handleRouteRequirements()`\n * Remove Doctrine annotations support in favor of native attributes\n * Remove `AnnotationClassLoader`, use `AttributeClassLoader` instead\n * Remove `AnnotationDirectoryLoader`, use `AttributeDirectoryLoader` instead\n * Remove `AnnotationFileLoader`, use `AttributeFileLoader` instead\n\n6.4\n---\n\n * Add FQCN and FQCN::method aliases for routes loaded from attributes/annotations when applicable\n * Add native return type to `AnnotationClassLoader::setResolver()`\n * Deprecate Doctrine annotations support in favor of native attributes\n * Change the constructor signature of `AnnotationClassLoader` to `__construct(?string $env = null)`, passing an annotation reader as first argument is deprecated\n * Deprecate `AnnotationClassLoader`, use `AttributeClassLoader` instead\n * Deprecate `AnnotationDirectoryLoader`, use `AttributeDirectoryLoader` instead\n * Deprecate `AnnotationFileLoader`, use `AttributeFileLoader` instead\n * Add `AddExpressionLanguageProvidersPass` (moved from `FrameworkBundle`)\n * Add aliases for all classes in the `Annotation` namespace to `Attribute`\n\n6.2\n---\n\n * Add `Requirement::POSITIVE_INT` for common ids and pagination\n\n6.1\n---\n\n * Add `getMissingParameters` and `getRouteName` methods on `MissingMandatoryParametersException`\n * Allow using UTF-8 parameter names\n * Support the `attribute` type (alias of `annotation`) in annotation loaders\n * Already encoded slashes are not decoded nor double-encoded anymore when generating URLs (query parameters)\n * Add `EnumRequirement` to help generate route requirements from a `\\BackedEnum`\n * Add `Requirement`, a collection of universal regular-expression constants to use as route parameter requirements\n * Add `params` variable to condition expression\n * Deprecate not passing route parameters as the fourth argument to `UrlMatcher::handleRouteRequirements()`\n\n5.3\n---\n\n * Already encoded slashes are not decoded nor double-encoded anymore when generating URLs\n * Add support for per-env configuration in XML and Yaml loaders\n * Deprecate creating instances of the `Route` annotation class by passing an array of parameters\n * Add `RoutingConfigurator::env()` to get the current environment\n\n5.2.0\n-----\n\n * Added support for inline definition of requirements and defaults for host\n * Added support for `\\A` and `\\z` as regex start and end for route requirement\n * Added support for `#[Route]` attributes\n\n5.1.0\n-----\n\n * added the protected method `PhpFileLoader::callConfigurator()` as extension point to ease custom routing configuration\n * deprecated `RouteCollectionBuilder` in favor of `RoutingConfigurator`.\n * added \"priority\" option to annotated routes\n * added argument `$priority` to `RouteCollection::add()`\n * deprecated the `RouteCompiler::REGEX_DELIMITER` constant\n * added `ExpressionLanguageProvider` to expose extra functions to route conditions\n * added support for a `stateless` keyword for configuring route stateless in PHP, YAML and XML configurations.\n * added the \"hosts\" option to be able to configure the host per locale.\n * added `RequestContext::fromUri()` to ease building the default context\n\n5.0.0\n-----\n\n * removed `PhpGeneratorDumper` and `PhpMatcherDumper`\n * removed `generator_base_class`, `generator_cache_class`, `matcher_base_class` and `matcher_cache_class` router options\n * `Serializable` implementing methods for `Route` and `CompiledRoute` are final\n * removed referencing service route loaders with a single colon\n * Removed `ServiceRouterLoader` and `ObjectRouteLoader`.\n\n4.4.0\n-----\n\n * Deprecated `ServiceRouterLoader` in favor of `ContainerLoader`.\n * Deprecated `ObjectRouteLoader` in favor of `ObjectLoader`.\n * Added a way to exclude patterns of resources from being imported by the `import()` method\n\n4.3.0\n-----\n\n * added `CompiledUrlMatcher` and `CompiledUrlMatcherDumper`\n * added `CompiledUrlGenerator` and `CompiledUrlGeneratorDumper`\n * deprecated `PhpGeneratorDumper` and `PhpMatcherDumper`\n * deprecated `generator_base_class`, `generator_cache_class`, `matcher_base_class` and `matcher_cache_class` router options\n * `Serializable` implementing methods for `Route` and `CompiledRoute` are marked as `@internal` and `@final`.\n   Instead of overwriting them, use `__serialize` and `__unserialize` as extension points which are forward compatible\n   with the new serialization methods in PHP 7.4.\n * exposed `utf8` Route option, defaults \"locale\" and \"format\" in configuration loaders and configurators\n * added support for invokable service route loaders\n\n4.2.0\n-----\n\n * added fallback to cultureless locale for internationalized routes\n\n4.0.0\n-----\n\n * dropped support for using UTF-8 route patterns without using the `utf8` option\n * dropped support for using UTF-8 route requirements without using the `utf8` option\n\n3.4.0\n-----\n\n * Added `NoConfigurationException`.\n * Added the possibility to define a prefix for all routes of a controller via @Route(name=\"prefix_\")\n * Added support for prioritized routing loaders.\n * Add matched and default parameters to redirect responses\n * Added support for a `controller` keyword for configuring route controllers in YAML and XML configurations.\n\n3.3.0\n-----\n\n * [DEPRECATION] Class parameters have been deprecated and will be removed in 4.0.\n   * router.options.generator_class\n   * router.options.generator_base_class\n   * router.options.generator_dumper_class\n   * router.options.matcher_class\n   * router.options.matcher_base_class\n   * router.options.matcher_dumper_class\n   * router.options.matcher.cache_class\n   * router.options.generator.cache_class\n\n3.2.0\n-----\n\n * Added support for `bool`, `int`, `float`, `string`, `list` and `map` defaults in XML configurations.\n * Added support for UTF-8 requirements\n\n2.8.0\n-----\n\n * allowed specifying a directory to recursively load all routing configuration files it contains\n * Added ObjectRouteLoader and ServiceRouteLoader that allow routes to be loaded\n   by calling a method on an object/service.\n * [DEPRECATION] Deprecated the hardcoded value for the `$referenceType` argument of the `UrlGeneratorInterface::generate` method.\n   Use the constants defined in the `UrlGeneratorInterface` instead.\n\n   Before:\n\n   ```php\n   $router->generate('blog_show', ['slug' => 'my-blog-post'], true);\n   ```\n\n   After:\n\n   ```php\n   use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;\n\n   $router->generate('blog_show', ['slug' => 'my-blog-post'], UrlGeneratorInterface::ABSOLUTE_URL);\n   ```\n\n2.5.0\n-----\n\n * [DEPRECATION] The `ApacheMatcherDumper` and `ApacheUrlMatcher` were deprecated and\n   will be removed in Symfony 3.0, since the performance gains were minimal and\n   it's hard to replicate the behavior of PHP implementation.\n\n2.3.0\n-----\n\n * added RequestContext::getQueryString()\n\n2.2.0\n-----\n\n * [DEPRECATION] Several route settings have been renamed (the old ones will be removed in 3.0):\n\n    * The `pattern` setting for a route has been deprecated in favor of `path`\n    * The `_scheme` and `_method` requirements have been moved to the `schemes` and `methods` settings\n\n   Before:\n\n   ```yaml\n   article_edit:\n       pattern: /article/{id}\n       requirements: { '_method': 'POST|PUT', '_scheme': 'https', 'id': '\\d+' }\n   ```\n\n   ```xml\n   <route id=\"article_edit\" pattern=\"/article/{id}\">\n       <requirement key=\"_method\">POST|PUT</requirement>\n       <requirement key=\"_scheme\">https</requirement>\n       <requirement key=\"id\">\\d+</requirement>\n   </route>\n   ```\n\n   ```php\n   $route = new Route();\n   $route->setPattern('/article/{id}');\n   $route->setRequirement('_method', 'POST|PUT');\n   $route->setRequirement('_scheme', 'https');\n   ```\n\n   After:\n\n   ```yaml\n   article_edit:\n       path: /article/{id}\n       methods: [POST, PUT]\n       schemes: https\n       requirements: { 'id': '\\d+' }\n   ```\n\n   ```xml\n   <route id=\"article_edit\" pattern=\"/article/{id}\" methods=\"POST PUT\" schemes=\"https\">\n       <requirement key=\"id\">\\d+</requirement>\n   </route>\n   ```\n\n   ```php\n   $route = new Route();\n   $route->setPath('/article/{id}');\n   $route->setMethods(['POST', 'PUT']);\n   $route->setSchemes('https');\n   ```\n\n * [BC BREAK] RouteCollection does not behave like a tree structure anymore but as\n   a flat array of Routes. So when using PHP to build the RouteCollection, you must\n   make sure to add routes to the sub-collection before adding it to the parent\n   collection (this is not relevant when using YAML or XML for Route definitions).\n\n   Before:\n\n   ```php\n   $rootCollection = new RouteCollection();\n   $subCollection = new RouteCollection();\n   $rootCollection->addCollection($subCollection);\n   $subCollection->add('foo', new Route('/foo'));\n   ```\n\n   After:\n\n   ```php\n   $rootCollection = new RouteCollection();\n   $subCollection = new RouteCollection();\n   $subCollection->add('foo', new Route('/foo'));\n   $rootCollection->addCollection($subCollection);\n   ```\n\n   Also one must call `addCollection` from the bottom to the top hierarchy.\n   So the correct sequence is the following (and not the reverse):\n\n   ```php\n   $childCollection->addCollection($grandchildCollection);\n   $rootCollection->addCollection($childCollection);\n   ```\n\n * [DEPRECATION] The methods `RouteCollection::getParent()` and `RouteCollection::getRoot()`\n   have been deprecated and will be removed in Symfony 2.3.\n * [BC BREAK] Misusing the `RouteCollection::addPrefix` method to add defaults, requirements\n   or options without adding a prefix is not supported anymore. So if you called `addPrefix`\n   with an empty prefix or `/` only (both have no relevance), like\n   `addPrefix('', $defaultsArray, $requirementsArray, $optionsArray)`\n   you need to use the new dedicated methods `addDefaults($defaultsArray)`,\n   `addRequirements($requirementsArray)` or `addOptions($optionsArray)` instead.\n * [DEPRECATION] The `$options` parameter to `RouteCollection::addPrefix()` has been deprecated\n   because adding options has nothing to do with adding a path prefix. If you want to add options\n   to all child routes of a RouteCollection, you can use `addOptions()`.\n * [DEPRECATION] The method `RouteCollection::getPrefix()` has been deprecated\n   because it suggested that all routes in the collection would have this prefix, which is\n   not necessarily true. On top of that, since there is no tree structure anymore, this method\n   is also useless. Don't worry about performance, prefix optimization for matching is still done\n   in the dumper, which was also improved in 2.2.0 to find even more grouping possibilities.\n * [DEPRECATION] `RouteCollection::addCollection(RouteCollection $collection)` should now only be\n   used with a single parameter. The other params `$prefix`, `$default`, `$requirements` and `$options`\n   will still work, but have been deprecated. The `addPrefix` method should be used for this\n   use-case instead.\n   Before: `$parentCollection->addCollection($collection, '/prefix', [...], [...])`\n   After:\n   ```php\n   $collection->addPrefix('/prefix', [...], [...]);\n   $parentCollection->addCollection($collection);\n   ```\n * added support for the method default argument values when defining a @Route\n * Adjacent placeholders without separator work now, e.g. `/{x}{y}{z}.{_format}`.\n * Characters that function as separator between placeholders are now whitelisted\n   to fix routes with normal text around a variable, e.g. `/prefix{var}suffix`.\n * [BC BREAK] The default requirement of a variable has been changed slightly.\n   Previously it disallowed the previous and the next char around a variable. Now\n   it disallows the slash (`/`) and the next char. Using the previous char added\n   no value and was problematic because the route `/index.{_format}` would be\n   matched by `/index.ht/ml`.\n * The default requirement now uses possessive quantifiers when possible which\n   improves matching performance by up to 20% because it prevents backtracking\n   when it's not needed.\n * The ConfigurableRequirementsInterface can now also be used to disable the requirements\n   check on URL generation completely by calling `setStrictRequirements(null)`. It\n   improves performance in production environment as you should know that params always\n   pass the requirements (otherwise it would break your link anyway).\n * There is no restriction on the route name anymore. So non-alphanumeric characters\n   are now also allowed.\n * [BC BREAK] `RouteCompilerInterface::compile(Route $route)` was made static\n   (only relevant if you implemented your own RouteCompiler).\n * Added possibility to generate relative paths and network paths in the UrlGenerator, e.g.\n   \"../parent-file\" and \"//example.com/dir/file\". The third parameter in\n   `UrlGeneratorInterface::generate($name, $parameters = [], $referenceType = self::ABSOLUTE_PATH)`\n   now accepts more values and you should use the constants defined in `UrlGeneratorInterface` for\n   claritiy. The old method calls with a Boolean parameter will continue to work because they\n   equal the signature using the constants.\n\n2.1.0\n-----\n\n * added RequestMatcherInterface\n * added RequestContext::fromRequest()\n * the UrlMatcher does not throw a \\LogicException anymore when the required\n   scheme is not the current one\n * added TraceableUrlMatcher\n * added the possibility to define options, default values and requirements\n   for placeholders in prefix, including imported routes\n * added RouterInterface::getRouteCollection\n * [BC BREAK] the UrlMatcher urldecodes the route parameters only once, they\n   were decoded twice before. Note that the `urldecode()` calls have been\n   changed for a single `rawurldecode()` in order to support `+` for input\n   paths.\n * added RouteCollection::getRoot method to retrieve the root of a\n   RouteCollection tree\n * [BC BREAK] made RouteCollection::setParent private which could not have\n   been used anyway without creating inconsistencies\n * [BC BREAK] RouteCollection::remove also removes a route from parent\n   collections (not only from its children)\n * added ConfigurableRequirementsInterface that allows to disable exceptions\n   (and generate empty URLs instead) when generating a route with an invalid\n   parameter value\n"
        },
        {
          "name": "CompiledRoute.php",
          "type": "blob",
          "size": 3.7099609375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Routing;\n\n/**\n * CompiledRoutes are returned by the RouteCompiler class.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass CompiledRoute implements \\Serializable\n{\n    /**\n     * @param string      $staticPrefix  The static prefix of the compiled route\n     * @param string      $regex         The regular expression to use to match this route\n     * @param array       $tokens        An array of tokens to use to generate URL for this route\n     * @param array       $pathVariables An array of path variables\n     * @param string|null $hostRegex     Host regex\n     * @param array       $hostTokens    Host tokens\n     * @param array       $hostVariables An array of host variables\n     * @param array       $variables     An array of variables (variables defined in the path and in the host patterns)\n     */\n    public function __construct(\n        private string $staticPrefix,\n        private string $regex,\n        private array $tokens,\n        private array $pathVariables,\n        private ?string $hostRegex = null,\n        private array $hostTokens = [],\n        private array $hostVariables = [],\n        private array $variables = [],\n    ) {\n    }\n\n    public function __serialize(): array\n    {\n        return [\n            'vars' => $this->variables,\n            'path_prefix' => $this->staticPrefix,\n            'path_regex' => $this->regex,\n            'path_tokens' => $this->tokens,\n            'path_vars' => $this->pathVariables,\n            'host_regex' => $this->hostRegex,\n            'host_tokens' => $this->hostTokens,\n            'host_vars' => $this->hostVariables,\n        ];\n    }\n\n    /**\n     * @internal\n     */\n    final public function serialize(): string\n    {\n        throw new \\BadMethodCallException('Cannot serialize '.__CLASS__);\n    }\n\n    public function __unserialize(array $data): void\n    {\n        $this->variables = $data['vars'];\n        $this->staticPrefix = $data['path_prefix'];\n        $this->regex = $data['path_regex'];\n        $this->tokens = $data['path_tokens'];\n        $this->pathVariables = $data['path_vars'];\n        $this->hostRegex = $data['host_regex'];\n        $this->hostTokens = $data['host_tokens'];\n        $this->hostVariables = $data['host_vars'];\n    }\n\n    /**\n     * @internal\n     */\n    final public function unserialize(string $serialized): void\n    {\n        $this->__unserialize(unserialize($serialized, ['allowed_classes' => false]));\n    }\n\n    /**\n     * Returns the static prefix.\n     */\n    public function getStaticPrefix(): string\n    {\n        return $this->staticPrefix;\n    }\n\n    /**\n     * Returns the regex.\n     */\n    public function getRegex(): string\n    {\n        return $this->regex;\n    }\n\n    /**\n     * Returns the host regex.\n     */\n    public function getHostRegex(): ?string\n    {\n        return $this->hostRegex;\n    }\n\n    /**\n     * Returns the tokens.\n     */\n    public function getTokens(): array\n    {\n        return $this->tokens;\n    }\n\n    /**\n     * Returns the host tokens.\n     */\n    public function getHostTokens(): array\n    {\n        return $this->hostTokens;\n    }\n\n    /**\n     * Returns the variables.\n     */\n    public function getVariables(): array\n    {\n        return $this->variables;\n    }\n\n    /**\n     * Returns the path variables.\n     */\n    public function getPathVariables(): array\n    {\n        return $this->pathVariables;\n    }\n\n    /**\n     * Returns the host variables.\n     */\n    public function getHostVariables(): array\n    {\n        return $this->hostVariables;\n    }\n}\n"
        },
        {
          "name": "DependencyInjection",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Generator",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Loader",
          "type": "tree",
          "content": null
        },
        {
          "name": "Matcher",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.931640625,
          "content": "Routing Component\n=================\n\nThe Routing component maps an HTTP request to a set of configuration variables.\n\nGetting Started\n---------------\n\n```bash\ncomposer require symfony/routing\n```\n\n```php\nuse App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Generator\\UrlGenerator;\nuse Symfony\\Component\\Routing\\Matcher\\UrlMatcher;\nuse Symfony\\Component\\Routing\\RequestContext;\nuse Symfony\\Component\\Routing\\Route;\nuse Symfony\\Component\\Routing\\RouteCollection;\n\n$route = new Route('/blog/{slug}', ['_controller' => BlogController::class]);\n$routes = new RouteCollection();\n$routes->add('blog_show', $route);\n\n$context = new RequestContext();\n\n// Routing can match routes with incoming requests\n$matcher = new UrlMatcher($routes, $context);\n$parameters = $matcher->match('/blog/lorem-ipsum');\n// $parameters = [\n//     '_controller' => 'App\\Controller\\BlogController',\n//     'slug' => 'lorem-ipsum',\n//     '_route' => 'blog_show'\n// ]\n\n// Routing can also generate URLs for a given route\n$generator = new UrlGenerator($routes, $context);\n$url = $generator->generate('blog_show', [\n    'slug' => 'my-blog-post',\n]);\n// $url = '/blog/my-blog-post'\n```\n\nSponsor\n-------\n\nThe Routing component for Symfony 7.1 is [backed][1] by [redirection.io][2].\n\nredirection.io logs all your website’s HTTP traffic, and lets you fix errors\nwith redirect rules in seconds. Give your marketing, SEO and IT teams the\nright tool to manage your website traffic efficiently!\n\nHelp Symfony by [sponsoring][3] its development!\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/routing.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n\n[1]: https://symfony.com/backers\n[2]: https://redirection.io\n[3]: https://symfony.com/sponsor\n"
        },
        {
          "name": "RequestContext.php",
          "type": "blob",
          "size": 6.8359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Routing;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Holds information about the current request.\n *\n * This class implements a fluent interface.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Tobias Schultze <http://tobion.de>\n */\nclass RequestContext\n{\n    private string $baseUrl;\n    private string $pathInfo;\n    private string $method;\n    private string $host;\n    private string $scheme;\n    private int $httpPort;\n    private int $httpsPort;\n    private string $queryString;\n    private array $parameters = [];\n\n    public function __construct(string $baseUrl = '', string $method = 'GET', string $host = 'localhost', string $scheme = 'http', int $httpPort = 80, int $httpsPort = 443, string $path = '/', string $queryString = '')\n    {\n        $this->setBaseUrl($baseUrl);\n        $this->setMethod($method);\n        $this->setHost($host);\n        $this->setScheme($scheme);\n        $this->setHttpPort($httpPort);\n        $this->setHttpsPort($httpsPort);\n        $this->setPathInfo($path);\n        $this->setQueryString($queryString);\n    }\n\n    public static function fromUri(string $uri, string $host = 'localhost', string $scheme = 'http', int $httpPort = 80, int $httpsPort = 443): self\n    {\n        if (false !== ($i = strpos($uri, '\\\\')) && $i < strcspn($uri, '?#')) {\n            $uri = '';\n        }\n        if ('' !== $uri && (\\ord($uri[0]) <= 32 || \\ord($uri[-1]) <= 32 || \\strlen($uri) !== strcspn($uri, \"\\r\\n\\t\"))) {\n            $uri = '';\n        }\n\n        $uri = parse_url($uri);\n        $scheme = $uri['scheme'] ?? $scheme;\n        $host = $uri['host'] ?? $host;\n\n        if (isset($uri['port'])) {\n            if ('http' === $scheme) {\n                $httpPort = $uri['port'];\n            } elseif ('https' === $scheme) {\n                $httpsPort = $uri['port'];\n            }\n        }\n\n        return new self($uri['path'] ?? '', 'GET', $host, $scheme, $httpPort, $httpsPort);\n    }\n\n    /**\n     * Updates the RequestContext information based on a HttpFoundation Request.\n     *\n     * @return $this\n     */\n    public function fromRequest(Request $request): static\n    {\n        $this->setBaseUrl($request->getBaseUrl());\n        $this->setPathInfo($request->getPathInfo());\n        $this->setMethod($request->getMethod());\n        $this->setHost($request->getHost());\n        $this->setScheme($request->getScheme());\n        $this->setHttpPort($request->isSecure() || null === $request->getPort() ? $this->httpPort : $request->getPort());\n        $this->setHttpsPort($request->isSecure() && null !== $request->getPort() ? $request->getPort() : $this->httpsPort);\n        $this->setQueryString($request->server->get('QUERY_STRING', ''));\n\n        return $this;\n    }\n\n    /**\n     * Gets the base URL.\n     */\n    public function getBaseUrl(): string\n    {\n        return $this->baseUrl;\n    }\n\n    /**\n     * Sets the base URL.\n     *\n     * @return $this\n     */\n    public function setBaseUrl(string $baseUrl): static\n    {\n        $this->baseUrl = rtrim($baseUrl, '/');\n\n        return $this;\n    }\n\n    /**\n     * Gets the path info.\n     */\n    public function getPathInfo(): string\n    {\n        return $this->pathInfo;\n    }\n\n    /**\n     * Sets the path info.\n     *\n     * @return $this\n     */\n    public function setPathInfo(string $pathInfo): static\n    {\n        $this->pathInfo = $pathInfo;\n\n        return $this;\n    }\n\n    /**\n     * Gets the HTTP method.\n     *\n     * The method is always an uppercased string.\n     */\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    /**\n     * Sets the HTTP method.\n     *\n     * @return $this\n     */\n    public function setMethod(string $method): static\n    {\n        $this->method = strtoupper($method);\n\n        return $this;\n    }\n\n    /**\n     * Gets the HTTP host.\n     *\n     * The host is always lowercased because it must be treated case-insensitive.\n     */\n    public function getHost(): string\n    {\n        return $this->host;\n    }\n\n    /**\n     * Sets the HTTP host.\n     *\n     * @return $this\n     */\n    public function setHost(string $host): static\n    {\n        $this->host = strtolower($host);\n\n        return $this;\n    }\n\n    /**\n     * Gets the HTTP scheme.\n     */\n    public function getScheme(): string\n    {\n        return $this->scheme;\n    }\n\n    /**\n     * Sets the HTTP scheme.\n     *\n     * @return $this\n     */\n    public function setScheme(string $scheme): static\n    {\n        $this->scheme = strtolower($scheme);\n\n        return $this;\n    }\n\n    /**\n     * Gets the HTTP port.\n     */\n    public function getHttpPort(): int\n    {\n        return $this->httpPort;\n    }\n\n    /**\n     * Sets the HTTP port.\n     *\n     * @return $this\n     */\n    public function setHttpPort(int $httpPort): static\n    {\n        $this->httpPort = $httpPort;\n\n        return $this;\n    }\n\n    /**\n     * Gets the HTTPS port.\n     */\n    public function getHttpsPort(): int\n    {\n        return $this->httpsPort;\n    }\n\n    /**\n     * Sets the HTTPS port.\n     *\n     * @return $this\n     */\n    public function setHttpsPort(int $httpsPort): static\n    {\n        $this->httpsPort = $httpsPort;\n\n        return $this;\n    }\n\n    /**\n     * Gets the query string without the \"?\".\n     */\n    public function getQueryString(): string\n    {\n        return $this->queryString;\n    }\n\n    /**\n     * Sets the query string.\n     *\n     * @return $this\n     */\n    public function setQueryString(?string $queryString): static\n    {\n        // string cast to be fault-tolerant, accepting null\n        $this->queryString = (string) $queryString;\n\n        return $this;\n    }\n\n    /**\n     * Returns the parameters.\n     */\n    public function getParameters(): array\n    {\n        return $this->parameters;\n    }\n\n    /**\n     * Sets the parameters.\n     *\n     * @param array $parameters The parameters\n     *\n     * @return $this\n     */\n    public function setParameters(array $parameters): static\n    {\n        $this->parameters = $parameters;\n\n        return $this;\n    }\n\n    /**\n     * Gets a parameter value.\n     */\n    public function getParameter(string $name): mixed\n    {\n        return $this->parameters[$name] ?? null;\n    }\n\n    /**\n     * Checks if a parameter value is set for the given parameter.\n     */\n    public function hasParameter(string $name): bool\n    {\n        return \\array_key_exists($name, $this->parameters);\n    }\n\n    /**\n     * Sets a parameter value.\n     *\n     * @return $this\n     */\n    public function setParameter(string $name, mixed $parameter): static\n    {\n        $this->parameters[$name] = $parameter;\n\n        return $this;\n    }\n\n    public function isSecure(): bool\n    {\n        return 'https' === $this->scheme;\n    }\n}\n"
        },
        {
          "name": "RequestContextAwareInterface.php",
          "type": "blob",
          "size": 0.5185546875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Routing;\n\ninterface RequestContextAwareInterface\n{\n    /**\n     * Sets the request context.\n     */\n    public function setContext(RequestContext $context): void;\n\n    /**\n     * Gets the request context.\n     */\n    public function getContext(): RequestContext;\n}\n"
        },
        {
          "name": "Requirement",
          "type": "tree",
          "content": null
        },
        {
          "name": "Route.php",
          "type": "blob",
          "size": 12.3095703125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Routing;\n\n/**\n * A Route describes a route and its parameters.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Tobias Schultze <http://tobion.de>\n */\nclass Route implements \\Serializable\n{\n    private string $path = '/';\n    private string $host = '';\n    private array $schemes = [];\n    private array $methods = [];\n    private array $defaults = [];\n    private array $requirements = [];\n    private array $options = [];\n    private string $condition = '';\n    private ?CompiledRoute $compiled = null;\n\n    /**\n     * Constructor.\n     *\n     * Available options:\n     *\n     *  * compiler_class: A class name able to compile this route instance (RouteCompiler by default)\n     *  * utf8:           Whether UTF-8 matching is enforced ot not\n     *\n     * @param string                    $path         The path pattern to match\n     * @param array                     $defaults     An array of default parameter values\n     * @param array<string|\\Stringable> $requirements An array of requirements for parameters (regexes)\n     * @param array                     $options      An array of options\n     * @param string|null               $host         The host pattern to match\n     * @param string|string[]           $schemes      A required URI scheme or an array of restricted schemes\n     * @param string|string[]           $methods      A required HTTP method or an array of restricted methods\n     * @param string|null               $condition    A condition that should evaluate to true for the route to match\n     */\n    public function __construct(string $path, array $defaults = [], array $requirements = [], array $options = [], ?string $host = '', string|array $schemes = [], string|array $methods = [], ?string $condition = '')\n    {\n        $this->setPath($path);\n        $this->addDefaults($defaults);\n        $this->addRequirements($requirements);\n        $this->setOptions($options);\n        $this->setHost($host);\n        $this->setSchemes($schemes);\n        $this->setMethods($methods);\n        $this->setCondition($condition);\n    }\n\n    public function __serialize(): array\n    {\n        return [\n            'path' => $this->path,\n            'host' => $this->host,\n            'defaults' => $this->defaults,\n            'requirements' => $this->requirements,\n            'options' => $this->options,\n            'schemes' => $this->schemes,\n            'methods' => $this->methods,\n            'condition' => $this->condition,\n            'compiled' => $this->compiled,\n        ];\n    }\n\n    /**\n     * @internal\n     */\n    final public function serialize(): string\n    {\n        throw new \\BadMethodCallException('Cannot serialize '.__CLASS__);\n    }\n\n    public function __unserialize(array $data): void\n    {\n        $this->path = $data['path'];\n        $this->host = $data['host'];\n        $this->defaults = $data['defaults'];\n        $this->requirements = $data['requirements'];\n        $this->options = $data['options'];\n        $this->schemes = $data['schemes'];\n        $this->methods = $data['methods'];\n\n        if (isset($data['condition'])) {\n            $this->condition = $data['condition'];\n        }\n        if (isset($data['compiled'])) {\n            $this->compiled = $data['compiled'];\n        }\n    }\n\n    /**\n     * @internal\n     */\n    final public function unserialize(string $serialized): void\n    {\n        $this->__unserialize(unserialize($serialized));\n    }\n\n    public function getPath(): string\n    {\n        return $this->path;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setPath(string $pattern): static\n    {\n        $pattern = $this->extractInlineDefaultsAndRequirements($pattern);\n\n        // A pattern must start with a slash and must not have multiple slashes at the beginning because the\n        // generated path for this route would be confused with a network path, e.g. '//domain.com/path'.\n        $this->path = '/'.ltrim(trim($pattern), '/');\n        $this->compiled = null;\n\n        return $this;\n    }\n\n    public function getHost(): string\n    {\n        return $this->host;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setHost(?string $pattern): static\n    {\n        $this->host = $this->extractInlineDefaultsAndRequirements((string) $pattern);\n        $this->compiled = null;\n\n        return $this;\n    }\n\n    /**\n     * Returns the lowercased schemes this route is restricted to.\n     * So an empty array means that any scheme is allowed.\n     *\n     * @return string[]\n     */\n    public function getSchemes(): array\n    {\n        return $this->schemes;\n    }\n\n    /**\n     * Sets the schemes (e.g. 'https') this route is restricted to.\n     * So an empty array means that any scheme is allowed.\n     *\n     * @param string|string[] $schemes The scheme or an array of schemes\n     *\n     * @return $this\n     */\n    public function setSchemes(string|array $schemes): static\n    {\n        $this->schemes = array_map('strtolower', (array) $schemes);\n        $this->compiled = null;\n\n        return $this;\n    }\n\n    /**\n     * Checks if a scheme requirement has been set.\n     */\n    public function hasScheme(string $scheme): bool\n    {\n        return \\in_array(strtolower($scheme), $this->schemes, true);\n    }\n\n    /**\n     * Returns the uppercased HTTP methods this route is restricted to.\n     * So an empty array means that any method is allowed.\n     *\n     * @return string[]\n     */\n    public function getMethods(): array\n    {\n        return $this->methods;\n    }\n\n    /**\n     * Sets the HTTP methods (e.g. 'POST') this route is restricted to.\n     * So an empty array means that any method is allowed.\n     *\n     * @param string|string[] $methods The method or an array of methods\n     *\n     * @return $this\n     */\n    public function setMethods(string|array $methods): static\n    {\n        $this->methods = array_map('strtoupper', (array) $methods);\n        $this->compiled = null;\n\n        return $this;\n    }\n\n    public function getOptions(): array\n    {\n        return $this->options;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setOptions(array $options): static\n    {\n        $this->options = [\n            'compiler_class' => RouteCompiler::class,\n        ];\n\n        return $this->addOptions($options);\n    }\n\n    /**\n     * @return $this\n     */\n    public function addOptions(array $options): static\n    {\n        foreach ($options as $name => $option) {\n            $this->options[$name] = $option;\n        }\n        $this->compiled = null;\n\n        return $this;\n    }\n\n    /**\n     * Sets an option value.\n     *\n     * @return $this\n     */\n    public function setOption(string $name, mixed $value): static\n    {\n        $this->options[$name] = $value;\n        $this->compiled = null;\n\n        return $this;\n    }\n\n    /**\n     * Returns the option value or null when not found.\n     */\n    public function getOption(string $name): mixed\n    {\n        return $this->options[$name] ?? null;\n    }\n\n    public function hasOption(string $name): bool\n    {\n        return \\array_key_exists($name, $this->options);\n    }\n\n    public function getDefaults(): array\n    {\n        return $this->defaults;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setDefaults(array $defaults): static\n    {\n        $this->defaults = [];\n\n        return $this->addDefaults($defaults);\n    }\n\n    /**\n     * @return $this\n     */\n    public function addDefaults(array $defaults): static\n    {\n        if (isset($defaults['_locale']) && $this->isLocalized()) {\n            unset($defaults['_locale']);\n        }\n\n        foreach ($defaults as $name => $default) {\n            $this->defaults[$name] = $default;\n        }\n        $this->compiled = null;\n\n        return $this;\n    }\n\n    public function getDefault(string $name): mixed\n    {\n        return $this->defaults[$name] ?? null;\n    }\n\n    public function hasDefault(string $name): bool\n    {\n        return \\array_key_exists($name, $this->defaults);\n    }\n\n    /**\n     * @return $this\n     */\n    public function setDefault(string $name, mixed $default): static\n    {\n        if ('_locale' === $name && $this->isLocalized()) {\n            return $this;\n        }\n\n        $this->defaults[$name] = $default;\n        $this->compiled = null;\n\n        return $this;\n    }\n\n    public function getRequirements(): array\n    {\n        return $this->requirements;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setRequirements(array $requirements): static\n    {\n        $this->requirements = [];\n\n        return $this->addRequirements($requirements);\n    }\n\n    /**\n     * @return $this\n     */\n    public function addRequirements(array $requirements): static\n    {\n        if (isset($requirements['_locale']) && $this->isLocalized()) {\n            unset($requirements['_locale']);\n        }\n\n        foreach ($requirements as $key => $regex) {\n            $this->requirements[$key] = $this->sanitizeRequirement($key, $regex);\n        }\n        $this->compiled = null;\n\n        return $this;\n    }\n\n    public function getRequirement(string $key): ?string\n    {\n        return $this->requirements[$key] ?? null;\n    }\n\n    public function hasRequirement(string $key): bool\n    {\n        return \\array_key_exists($key, $this->requirements);\n    }\n\n    /**\n     * @return $this\n     */\n    public function setRequirement(string $key, string $regex): static\n    {\n        if ('_locale' === $key && $this->isLocalized()) {\n            return $this;\n        }\n\n        $this->requirements[$key] = $this->sanitizeRequirement($key, $regex);\n        $this->compiled = null;\n\n        return $this;\n    }\n\n    public function getCondition(): string\n    {\n        return $this->condition;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setCondition(?string $condition): static\n    {\n        $this->condition = (string) $condition;\n        $this->compiled = null;\n\n        return $this;\n    }\n\n    /**\n     * Compiles the route.\n     *\n     * @throws \\LogicException If the Route cannot be compiled because the\n     *                         path or host pattern is invalid\n     *\n     * @see RouteCompiler which is responsible for the compilation process\n     */\n    public function compile(): CompiledRoute\n    {\n        if (null !== $this->compiled) {\n            return $this->compiled;\n        }\n\n        $class = $this->getOption('compiler_class');\n\n        return $this->compiled = $class::compile($this);\n    }\n\n    private function extractInlineDefaultsAndRequirements(string $pattern): string\n    {\n        if (false === strpbrk($pattern, '?<:')) {\n            return $pattern;\n        }\n\n        $mapping = $this->getDefault('_route_mapping') ?? [];\n\n        $pattern = preg_replace_callback('#\\{(!?)([\\w\\x80-\\xFF]++)(:[\\w\\x80-\\xFF]++)?(<.*?>)?(\\?[^\\}]*+)?\\}#', function ($m) use (&$mapping) {\n            if (isset($m[5][0])) {\n                $this->setDefault($m[2], '?' !== $m[5] ? substr($m[5], 1) : null);\n            }\n            if (isset($m[4][0])) {\n                $this->setRequirement($m[2], substr($m[4], 1, -1));\n            }\n            if (isset($m[3][0])) {\n                $mapping[$m[2]] = substr($m[3], 1);\n            }\n\n            return '{'.$m[1].$m[2].'}';\n        }, $pattern);\n\n        if ($mapping) {\n            $this->setDefault('_route_mapping', $mapping);\n        }\n\n        return $pattern;\n    }\n\n    private function sanitizeRequirement(string $key, string $regex): string\n    {\n        if ('' !== $regex) {\n            if ('^' === $regex[0]) {\n                $regex = substr($regex, 1);\n            } elseif (str_starts_with($regex, '\\\\A')) {\n                $regex = substr($regex, 2);\n            }\n        }\n\n        if (str_ends_with($regex, '$')) {\n            $regex = substr($regex, 0, -1);\n        } elseif (\\strlen($regex) - 2 === strpos($regex, '\\\\z')) {\n            $regex = substr($regex, 0, -2);\n        }\n\n        if ('' === $regex) {\n            throw new \\InvalidArgumentException(\\sprintf('Routing requirement for \"%s\" cannot be empty.', $key));\n        }\n\n        return $regex;\n    }\n\n    private function isLocalized(): bool\n    {\n        return isset($this->defaults['_locale']) && isset($this->defaults['_canonical_route']) && ($this->requirements['_locale'] ?? null) === preg_quote($this->defaults['_locale']);\n    }\n}\n"
        },
        {
          "name": "RouteCollection.php",
          "type": "blob",
          "size": 10.5107421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Routing;\n\nuse Symfony\\Component\\Config\\Resource\\ResourceInterface;\nuse Symfony\\Component\\Routing\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Routing\\Exception\\RouteCircularReferenceException;\n\n/**\n * A RouteCollection represents a set of Route instances.\n *\n * When adding a route at the end of the collection, an existing route\n * with the same name is removed first. So there can only be one route\n * with a given name.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Tobias Schultze <http://tobion.de>\n *\n * @implements \\IteratorAggregate<string, Route>\n */\nclass RouteCollection implements \\IteratorAggregate, \\Countable\n{\n    /**\n     * @var array<string, Route>\n     */\n    private array $routes = [];\n\n    /**\n     * @var array<string, Alias>\n     */\n    private array $aliases = [];\n\n    /**\n     * @var array<string, ResourceInterface>\n     */\n    private array $resources = [];\n\n    /**\n     * @var array<string, int>\n     */\n    private array $priorities = [];\n\n    public function __clone()\n    {\n        foreach ($this->routes as $name => $route) {\n            $this->routes[$name] = clone $route;\n        }\n\n        foreach ($this->aliases as $name => $alias) {\n            $this->aliases[$name] = clone $alias;\n        }\n    }\n\n    /**\n     * Gets the current RouteCollection as an Iterator that includes all routes.\n     *\n     * It implements \\IteratorAggregate.\n     *\n     * @see all()\n     *\n     * @return \\ArrayIterator<string, Route>\n     */\n    public function getIterator(): \\ArrayIterator\n    {\n        return new \\ArrayIterator($this->all());\n    }\n\n    /**\n     * Gets the number of Routes in this collection.\n     */\n    public function count(): int\n    {\n        return \\count($this->routes);\n    }\n\n    public function add(string $name, Route $route, int $priority = 0): void\n    {\n        unset($this->routes[$name], $this->priorities[$name], $this->aliases[$name]);\n\n        $this->routes[$name] = $route;\n\n        if ($priority) {\n            $this->priorities[$name] = $priority;\n        }\n    }\n\n    /**\n     * Returns all routes in this collection.\n     *\n     * @return array<string, Route>\n     */\n    public function all(): array\n    {\n        if ($this->priorities) {\n            $priorities = $this->priorities;\n            $keysOrder = array_flip(array_keys($this->routes));\n            uksort($this->routes, static fn ($n1, $n2) => (($priorities[$n2] ?? 0) <=> ($priorities[$n1] ?? 0)) ?: ($keysOrder[$n1] <=> $keysOrder[$n2]));\n        }\n\n        return $this->routes;\n    }\n\n    /**\n     * Gets a route by name.\n     */\n    public function get(string $name): ?Route\n    {\n        $visited = [];\n        while (null !== $alias = $this->aliases[$name] ?? null) {\n            if (false !== $searchKey = array_search($name, $visited)) {\n                $visited[] = $name;\n\n                throw new RouteCircularReferenceException($name, \\array_slice($visited, $searchKey));\n            }\n\n            if ($alias->isDeprecated()) {\n                $deprecation = $alias->getDeprecation($name);\n\n                trigger_deprecation($deprecation['package'], $deprecation['version'], $deprecation['message']);\n            }\n\n            $visited[] = $name;\n            $name = $alias->getId();\n        }\n\n        return $this->routes[$name] ?? null;\n    }\n\n    /**\n     * Removes a route or an array of routes by name from the collection.\n     *\n     * @param string|string[] $name The route name or an array of route names\n     */\n    public function remove(string|array $name): void\n    {\n        $routes = [];\n        foreach ((array) $name as $n) {\n            if (isset($this->routes[$n])) {\n                $routes[] = $n;\n            }\n\n            unset($this->routes[$n], $this->priorities[$n], $this->aliases[$n]);\n        }\n\n        if (!$routes) {\n            return;\n        }\n\n        foreach ($this->aliases as $k => $alias) {\n            if (\\in_array($alias->getId(), $routes, true)) {\n                unset($this->aliases[$k]);\n            }\n        }\n    }\n\n    /**\n     * Adds a route collection at the end of the current set by appending all\n     * routes of the added collection.\n     */\n    public function addCollection(self $collection): void\n    {\n        // we need to remove all routes with the same names first because just replacing them\n        // would not place the new route at the end of the merged array\n        foreach ($collection->all() as $name => $route) {\n            unset($this->routes[$name], $this->priorities[$name], $this->aliases[$name]);\n            $this->routes[$name] = $route;\n\n            if (isset($collection->priorities[$name])) {\n                $this->priorities[$name] = $collection->priorities[$name];\n            }\n        }\n\n        foreach ($collection->getAliases() as $name => $alias) {\n            unset($this->routes[$name], $this->priorities[$name], $this->aliases[$name]);\n\n            $this->aliases[$name] = $alias;\n        }\n\n        foreach ($collection->getResources() as $resource) {\n            $this->addResource($resource);\n        }\n    }\n\n    /**\n     * Adds a prefix to the path of all child routes.\n     */\n    public function addPrefix(string $prefix, array $defaults = [], array $requirements = []): void\n    {\n        $prefix = trim(trim($prefix), '/');\n\n        if ('' === $prefix) {\n            return;\n        }\n\n        foreach ($this->routes as $route) {\n            $route->setPath('/'.$prefix.$route->getPath());\n            $route->addDefaults($defaults);\n            $route->addRequirements($requirements);\n        }\n    }\n\n    /**\n     * Adds a prefix to the name of all the routes within in the collection.\n     */\n    public function addNamePrefix(string $prefix): void\n    {\n        $prefixedRoutes = [];\n        $prefixedPriorities = [];\n        $prefixedAliases = [];\n\n        foreach ($this->routes as $name => $route) {\n            $prefixedRoutes[$prefix.$name] = $route;\n            if (null !== $canonicalName = $route->getDefault('_canonical_route')) {\n                $route->setDefault('_canonical_route', $prefix.$canonicalName);\n            }\n            if (isset($this->priorities[$name])) {\n                $prefixedPriorities[$prefix.$name] = $this->priorities[$name];\n            }\n        }\n\n        foreach ($this->aliases as $name => $alias) {\n            $prefixedAliases[$prefix.$name] = $alias->withId($prefix.$alias->getId());\n        }\n\n        $this->routes = $prefixedRoutes;\n        $this->priorities = $prefixedPriorities;\n        $this->aliases = $prefixedAliases;\n    }\n\n    /**\n     * Sets the host pattern on all routes.\n     */\n    public function setHost(?string $pattern, array $defaults = [], array $requirements = []): void\n    {\n        foreach ($this->routes as $route) {\n            $route->setHost($pattern);\n            $route->addDefaults($defaults);\n            $route->addRequirements($requirements);\n        }\n    }\n\n    /**\n     * Sets a condition on all routes.\n     *\n     * Existing conditions will be overridden.\n     */\n    public function setCondition(?string $condition): void\n    {\n        foreach ($this->routes as $route) {\n            $route->setCondition($condition);\n        }\n    }\n\n    /**\n     * Adds defaults to all routes.\n     *\n     * An existing default value under the same name in a route will be overridden.\n     */\n    public function addDefaults(array $defaults): void\n    {\n        if ($defaults) {\n            foreach ($this->routes as $route) {\n                $route->addDefaults($defaults);\n            }\n        }\n    }\n\n    /**\n     * Adds requirements to all routes.\n     *\n     * An existing requirement under the same name in a route will be overridden.\n     */\n    public function addRequirements(array $requirements): void\n    {\n        if ($requirements) {\n            foreach ($this->routes as $route) {\n                $route->addRequirements($requirements);\n            }\n        }\n    }\n\n    /**\n     * Adds options to all routes.\n     *\n     * An existing option value under the same name in a route will be overridden.\n     */\n    public function addOptions(array $options): void\n    {\n        if ($options) {\n            foreach ($this->routes as $route) {\n                $route->addOptions($options);\n            }\n        }\n    }\n\n    /**\n     * Sets the schemes (e.g. 'https') all child routes are restricted to.\n     *\n     * @param string|string[] $schemes The scheme or an array of schemes\n     */\n    public function setSchemes(string|array $schemes): void\n    {\n        foreach ($this->routes as $route) {\n            $route->setSchemes($schemes);\n        }\n    }\n\n    /**\n     * Sets the HTTP methods (e.g. 'POST') all child routes are restricted to.\n     *\n     * @param string|string[] $methods The method or an array of methods\n     */\n    public function setMethods(string|array $methods): void\n    {\n        foreach ($this->routes as $route) {\n            $route->setMethods($methods);\n        }\n    }\n\n    /**\n     * Returns an array of resources loaded to build this collection.\n     *\n     * @return ResourceInterface[]\n     */\n    public function getResources(): array\n    {\n        return array_values($this->resources);\n    }\n\n    /**\n     * Adds a resource for this collection. If the resource already exists\n     * it is not added.\n     */\n    public function addResource(ResourceInterface $resource): void\n    {\n        $key = (string) $resource;\n\n        if (!isset($this->resources[$key])) {\n            $this->resources[$key] = $resource;\n        }\n    }\n\n    /**\n     * Sets an alias for an existing route.\n     *\n     * @param string $name  The alias to create\n     * @param string $alias The route to alias\n     *\n     * @throws InvalidArgumentException if the alias is for itself\n     */\n    public function addAlias(string $name, string $alias): Alias\n    {\n        if ($name === $alias) {\n            throw new InvalidArgumentException(\\sprintf('Route alias \"%s\" can not reference itself.', $name));\n        }\n\n        unset($this->routes[$name], $this->priorities[$name]);\n\n        return $this->aliases[$name] = new Alias($alias);\n    }\n\n    /**\n     * @return array<string, Alias>\n     */\n    public function getAliases(): array\n    {\n        return $this->aliases;\n    }\n\n    public function getAlias(string $name): ?Alias\n    {\n        return $this->aliases[$name] ?? null;\n    }\n\n    public function getPriority(string $name): ?int\n    {\n        return $this->priorities[$name] ?? null;\n    }\n}\n"
        },
        {
          "name": "RouteCompiler.php",
          "type": "blob",
          "size": 14.25390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Routing;\n\n/**\n * RouteCompiler compiles Route instances to CompiledRoute instances.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Tobias Schultze <http://tobion.de>\n */\nclass RouteCompiler implements RouteCompilerInterface\n{\n    /**\n     * This string defines the characters that are automatically considered separators in front of\n     * optional placeholders (with default and no static text following). Such a single separator\n     * can be left out together with the optional placeholder from matching and generating URLs.\n     */\n    public const SEPARATORS = '/,;.:-_~+*=@|';\n\n    /**\n     * The maximum supported length of a PCRE subpattern name\n     * http://pcre.org/current/doc/html/pcre2pattern.html#SEC16.\n     *\n     * @internal\n     */\n    public const VARIABLE_MAXIMUM_LENGTH = 32;\n\n    /**\n     * @throws \\InvalidArgumentException if a path variable is named _fragment\n     * @throws \\LogicException           if a variable is referenced more than once\n     * @throws \\DomainException          if a variable name starts with a digit or if it is too long to be successfully used as\n     *                                   a PCRE subpattern\n     */\n    public static function compile(Route $route): CompiledRoute\n    {\n        $hostVariables = [];\n        $variables = [];\n        $hostRegex = null;\n        $hostTokens = [];\n\n        if ('' !== $host = $route->getHost()) {\n            $result = self::compilePattern($route, $host, true);\n\n            $hostVariables = $result['variables'];\n            $variables = $hostVariables;\n\n            $hostTokens = $result['tokens'];\n            $hostRegex = $result['regex'];\n        }\n\n        $locale = $route->getDefault('_locale');\n        if (null !== $locale && null !== $route->getDefault('_canonical_route') && preg_quote($locale) === $route->getRequirement('_locale')) {\n            $requirements = $route->getRequirements();\n            unset($requirements['_locale']);\n            $route->setRequirements($requirements);\n            $route->setPath(str_replace('{_locale}', $locale, $route->getPath()));\n        }\n\n        $path = $route->getPath();\n\n        $result = self::compilePattern($route, $path, false);\n\n        $staticPrefix = $result['staticPrefix'];\n\n        $pathVariables = $result['variables'];\n\n        foreach ($pathVariables as $pathParam) {\n            if ('_fragment' === $pathParam) {\n                throw new \\InvalidArgumentException(\\sprintf('Route pattern \"%s\" cannot contain \"_fragment\" as a path parameter.', $route->getPath()));\n            }\n        }\n\n        $variables = array_merge($variables, $pathVariables);\n\n        $tokens = $result['tokens'];\n        $regex = $result['regex'];\n\n        return new CompiledRoute(\n            $staticPrefix,\n            $regex,\n            $tokens,\n            $pathVariables,\n            $hostRegex,\n            $hostTokens,\n            $hostVariables,\n            array_unique($variables)\n        );\n    }\n\n    private static function compilePattern(Route $route, string $pattern, bool $isHost): array\n    {\n        $tokens = [];\n        $variables = [];\n        $matches = [];\n        $pos = 0;\n        $defaultSeparator = $isHost ? '.' : '/';\n        $useUtf8 = preg_match('//u', $pattern);\n        $needsUtf8 = $route->getOption('utf8');\n\n        if (!$needsUtf8 && $useUtf8 && preg_match('/[\\x80-\\xFF]/', $pattern)) {\n            throw new \\LogicException(\\sprintf('Cannot use UTF-8 route patterns without setting the \"utf8\" option for route \"%s\".', $route->getPath()));\n        }\n        if (!$useUtf8 && $needsUtf8) {\n            throw new \\LogicException(\\sprintf('Cannot mix UTF-8 requirements with non-UTF-8 pattern \"%s\".', $pattern));\n        }\n\n        // Match all variables enclosed in \"{}\" and iterate over them. But we only want to match the innermost variable\n        // in case of nested \"{}\", e.g. {foo{bar}}. This in ensured because \\w does not match \"{\" or \"}\" itself.\n        preg_match_all('#\\{(!)?([\\w\\x80-\\xFF]+)\\}#', $pattern, $matches, \\PREG_OFFSET_CAPTURE | \\PREG_SET_ORDER);\n        foreach ($matches as $match) {\n            $important = $match[1][1] >= 0;\n            $varName = $match[2][0];\n            // get all static text preceding the current variable\n            $precedingText = substr($pattern, $pos, $match[0][1] - $pos);\n            $pos = $match[0][1] + \\strlen($match[0][0]);\n\n            if (!\\strlen($precedingText)) {\n                $precedingChar = '';\n            } elseif ($useUtf8) {\n                preg_match('/.$/u', $precedingText, $precedingChar);\n                $precedingChar = $precedingChar[0];\n            } else {\n                $precedingChar = substr($precedingText, -1);\n            }\n            $isSeparator = '' !== $precedingChar && str_contains(static::SEPARATORS, $precedingChar);\n\n            // A PCRE subpattern name must start with a non-digit. Also a PHP variable cannot start with a digit so the\n            // variable would not be usable as a Controller action argument.\n            if (preg_match('/^\\d/', $varName)) {\n                throw new \\DomainException(\\sprintf('Variable name \"%s\" cannot start with a digit in route pattern \"%s\". Please use a different name.', $varName, $pattern));\n            }\n            if (\\in_array($varName, $variables)) {\n                throw new \\LogicException(\\sprintf('Route pattern \"%s\" cannot reference variable name \"%s\" more than once.', $pattern, $varName));\n            }\n\n            if (\\strlen($varName) > self::VARIABLE_MAXIMUM_LENGTH) {\n                throw new \\DomainException(\\sprintf('Variable name \"%s\" cannot be longer than %d characters in route pattern \"%s\". Please use a shorter name.', $varName, self::VARIABLE_MAXIMUM_LENGTH, $pattern));\n            }\n\n            if ($isSeparator && $precedingText !== $precedingChar) {\n                $tokens[] = ['text', substr($precedingText, 0, -\\strlen($precedingChar))];\n            } elseif (!$isSeparator && '' !== $precedingText) {\n                $tokens[] = ['text', $precedingText];\n            }\n\n            $regexp = $route->getRequirement($varName);\n            if (null === $regexp) {\n                $followingPattern = substr($pattern, $pos);\n                // Find the next static character after the variable that functions as a separator. By default, this separator and '/'\n                // are disallowed for the variable. This default requirement makes sure that optional variables can be matched at all\n                // and that the generating-matching-combination of URLs unambiguous, i.e. the params used for generating the URL are\n                // the same that will be matched. Example: new Route('/{page}.{_format}', ['_format' => 'html'])\n                // If {page} would also match the separating dot, {_format} would never match as {page} will eagerly consume everything.\n                // Also even if {_format} was not optional the requirement prevents that {page} matches something that was originally\n                // part of {_format} when generating the URL, e.g. _format = 'mobile.html'.\n                $nextSeparator = self::findNextSeparator($followingPattern, $useUtf8);\n                $regexp = \\sprintf(\n                    '[^%s%s]+',\n                    preg_quote($defaultSeparator),\n                    $defaultSeparator !== $nextSeparator && '' !== $nextSeparator ? preg_quote($nextSeparator) : ''\n                );\n                if (('' !== $nextSeparator && !preg_match('#^\\{[\\w\\x80-\\xFF]+\\}#', $followingPattern)) || '' === $followingPattern) {\n                    // When we have a separator, which is disallowed for the variable, we can optimize the regex with a possessive\n                    // quantifier. This prevents useless backtracking of PCRE and improves performance by 20% for matching those patterns.\n                    // Given the above example, there is no point in backtracking into {page} (that forbids the dot) when a dot must follow\n                    // after it. This optimization cannot be applied when the next char is no real separator or when the next variable is\n                    // directly adjacent, e.g. '/{x}{y}'.\n                    $regexp .= '+';\n                }\n            } else {\n                if (!preg_match('//u', $regexp)) {\n                    $useUtf8 = false;\n                } elseif (!$needsUtf8 && preg_match('/[\\x80-\\xFF]|(?<!\\\\\\\\)\\\\\\\\(?:\\\\\\\\\\\\\\\\)*+(?-i:X|[pP][\\{CLMNPSZ]|x\\{[A-Fa-f0-9]{3})/', $regexp)) {\n                    throw new \\LogicException(\\sprintf('Cannot use UTF-8 route requirements without setting the \"utf8\" option for variable \"%s\" in pattern \"%s\".', $varName, $pattern));\n                }\n                if (!$useUtf8 && $needsUtf8) {\n                    throw new \\LogicException(\\sprintf('Cannot mix UTF-8 requirement with non-UTF-8 charset for variable \"%s\" in pattern \"%s\".', $varName, $pattern));\n                }\n                $regexp = self::transformCapturingGroupsToNonCapturings($regexp);\n            }\n\n            if ($important) {\n                $token = ['variable', $isSeparator ? $precedingChar : '', $regexp, $varName, false, true];\n            } else {\n                $token = ['variable', $isSeparator ? $precedingChar : '', $regexp, $varName];\n            }\n\n            $tokens[] = $token;\n            $variables[] = $varName;\n        }\n\n        if ($pos < \\strlen($pattern)) {\n            $tokens[] = ['text', substr($pattern, $pos)];\n        }\n\n        // find the first optional token\n        $firstOptional = \\PHP_INT_MAX;\n        if (!$isHost) {\n            for ($i = \\count($tokens) - 1; $i >= 0; --$i) {\n                $token = $tokens[$i];\n                // variable is optional when it is not important and has a default value\n                if ('variable' === $token[0] && !($token[5] ?? false) && $route->hasDefault($token[3])) {\n                    $firstOptional = $i;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // compute the matching regexp\n        $regexp = '';\n        for ($i = 0, $nbToken = \\count($tokens); $i < $nbToken; ++$i) {\n            $regexp .= self::computeRegexp($tokens, $i, $firstOptional);\n        }\n        $regexp = '{^'.$regexp.'$}sD'.($isHost ? 'i' : '');\n\n        // enable Utf8 matching if really required\n        if ($needsUtf8) {\n            $regexp .= 'u';\n            for ($i = 0, $nbToken = \\count($tokens); $i < $nbToken; ++$i) {\n                if ('variable' === $tokens[$i][0]) {\n                    $tokens[$i][4] = true;\n                }\n            }\n        }\n\n        return [\n            'staticPrefix' => self::determineStaticPrefix($route, $tokens),\n            'regex' => $regexp,\n            'tokens' => array_reverse($tokens),\n            'variables' => $variables,\n        ];\n    }\n\n    /**\n     * Determines the longest static prefix possible for a route.\n     */\n    private static function determineStaticPrefix(Route $route, array $tokens): string\n    {\n        if ('text' !== $tokens[0][0]) {\n            return ($route->hasDefault($tokens[0][3]) || '/' === $tokens[0][1]) ? '' : $tokens[0][1];\n        }\n\n        $prefix = $tokens[0][1];\n\n        if (isset($tokens[1][1]) && '/' !== $tokens[1][1] && false === $route->hasDefault($tokens[1][3])) {\n            $prefix .= $tokens[1][1];\n        }\n\n        return $prefix;\n    }\n\n    /**\n     * Returns the next static character in the Route pattern that will serve as a separator (or the empty string when none available).\n     */\n    private static function findNextSeparator(string $pattern, bool $useUtf8): string\n    {\n        if ('' == $pattern) {\n            // return empty string if pattern is empty or false (false which can be returned by substr)\n            return '';\n        }\n        // first remove all placeholders from the pattern so we can find the next real static character\n        if ('' === $pattern = preg_replace('#\\{[\\w\\x80-\\xFF]+\\}#', '', $pattern)) {\n            return '';\n        }\n        if ($useUtf8) {\n            preg_match('/^./u', $pattern, $pattern);\n        }\n\n        return str_contains(static::SEPARATORS, $pattern[0]) ? $pattern[0] : '';\n    }\n\n    /**\n     * Computes the regexp used to match a specific token. It can be static text or a subpattern.\n     *\n     * @param array $tokens        The route tokens\n     * @param int   $index         The index of the current token\n     * @param int   $firstOptional The index of the first optional token\n     */\n    private static function computeRegexp(array $tokens, int $index, int $firstOptional): string\n    {\n        $token = $tokens[$index];\n        if ('text' === $token[0]) {\n            // Text tokens\n            return preg_quote($token[1]);\n        }\n\n        // Variable tokens\n        if (0 === $index && 0 === $firstOptional) {\n            // When the only token is an optional variable token, the separator is required\n            return \\sprintf('%s(?P<%s>%s)?', preg_quote($token[1]), $token[3], $token[2]);\n        }\n\n        $regexp = \\sprintf('%s(?P<%s>%s)', preg_quote($token[1]), $token[3], $token[2]);\n        if ($index >= $firstOptional) {\n            // Enclose each optional token in a subpattern to make it optional.\n            // \"?:\" means it is non-capturing, i.e. the portion of the subject string that\n            // matched the optional subpattern is not passed back.\n            $regexp = \"(?:$regexp\";\n            $nbTokens = \\count($tokens);\n            if ($nbTokens - 1 == $index) {\n                // Close the optional subpatterns\n                $regexp .= str_repeat(')?', $nbTokens - $firstOptional - (0 === $firstOptional ? 1 : 0));\n            }\n        }\n\n        return $regexp;\n    }\n\n    private static function transformCapturingGroupsToNonCapturings(string $regexp): string\n    {\n        for ($i = 0; $i < \\strlen($regexp); ++$i) {\n            if ('\\\\' === $regexp[$i]) {\n                ++$i;\n                continue;\n            }\n            if ('(' !== $regexp[$i] || !isset($regexp[$i + 2])) {\n                continue;\n            }\n            if ('*' === $regexp[++$i] || '?' === $regexp[$i]) {\n                ++$i;\n                continue;\n            }\n            $regexp = substr_replace($regexp, '?:', $i, 0);\n            ++$i;\n        }\n\n        return $regexp;\n    }\n}\n"
        },
        {
          "name": "RouteCompilerInterface.php",
          "type": "blob",
          "size": 0.7158203125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Routing;\n\n/**\n * RouteCompilerInterface is the interface that all RouteCompiler classes must implement.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\ninterface RouteCompilerInterface\n{\n    /**\n     * Compiles the current route instance.\n     *\n     * @throws \\LogicException If the Route cannot be compiled because the\n     *                         path or host pattern is invalid\n     */\n    public static function compile(Route $route): CompiledRoute;\n}\n"
        },
        {
          "name": "Router.php",
          "type": "blob",
          "size": 11.2177734375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Routing;\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\Config\\ConfigCacheFactory;\nuse Symfony\\Component\\Config\\ConfigCacheFactoryInterface;\nuse Symfony\\Component\\Config\\ConfigCacheInterface;\nuse Symfony\\Component\\Config\\Loader\\LoaderInterface;\nuse Symfony\\Component\\ExpressionLanguage\\ExpressionFunctionProviderInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Generator\\CompiledUrlGenerator;\nuse Symfony\\Component\\Routing\\Generator\\ConfigurableRequirementsInterface;\nuse Symfony\\Component\\Routing\\Generator\\Dumper\\CompiledUrlGeneratorDumper;\nuse Symfony\\Component\\Routing\\Generator\\Dumper\\GeneratorDumperInterface;\nuse Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;\nuse Symfony\\Component\\Routing\\Matcher\\CompiledUrlMatcher;\nuse Symfony\\Component\\Routing\\Matcher\\Dumper\\CompiledUrlMatcherDumper;\nuse Symfony\\Component\\Routing\\Matcher\\Dumper\\MatcherDumperInterface;\nuse Symfony\\Component\\Routing\\Matcher\\RequestMatcherInterface;\nuse Symfony\\Component\\Routing\\Matcher\\UrlMatcherInterface;\n\n/**\n * The Router class is an example of the integration of all pieces of the\n * routing system for easier use.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Router implements RouterInterface, RequestMatcherInterface\n{\n    protected UrlMatcherInterface|RequestMatcherInterface $matcher;\n    protected UrlGeneratorInterface $generator;\n    protected RequestContext $context;\n    protected RouteCollection $collection;\n    protected array $options = [];\n\n    private ConfigCacheFactoryInterface $configCacheFactory;\n\n    /**\n     * @var ExpressionFunctionProviderInterface[]\n     */\n    private array $expressionLanguageProviders = [];\n\n    private static ?array $cache = [];\n\n    public function __construct(\n        protected LoaderInterface $loader,\n        protected mixed $resource,\n        array $options = [],\n        ?RequestContext $context = null,\n        protected ?LoggerInterface $logger = null,\n        protected ?string $defaultLocale = null,\n    ) {\n        $this->context = $context ?? new RequestContext();\n        $this->setOptions($options);\n    }\n\n    /**\n     * Sets options.\n     *\n     * Available options:\n     *\n     *   * cache_dir:              The cache directory (or null to disable caching)\n     *   * debug:                  Whether to enable debugging or not (false by default)\n     *   * generator_class:        The name of a UrlGeneratorInterface implementation\n     *   * generator_dumper_class: The name of a GeneratorDumperInterface implementation\n     *   * matcher_class:          The name of a UrlMatcherInterface implementation\n     *   * matcher_dumper_class:   The name of a MatcherDumperInterface implementation\n     *   * resource_type:          Type hint for the main resource (optional)\n     *   * strict_requirements:    Configure strict requirement checking for generators\n     *                             implementing ConfigurableRequirementsInterface (default is true)\n     *\n     * @throws \\InvalidArgumentException When unsupported option is provided\n     */\n    public function setOptions(array $options): void\n    {\n        $this->options = [\n            'cache_dir' => null,\n            'debug' => false,\n            'generator_class' => CompiledUrlGenerator::class,\n            'generator_dumper_class' => CompiledUrlGeneratorDumper::class,\n            'matcher_class' => CompiledUrlMatcher::class,\n            'matcher_dumper_class' => CompiledUrlMatcherDumper::class,\n            'resource_type' => null,\n            'strict_requirements' => true,\n        ];\n\n        // check option names and live merge, if errors are encountered Exception will be thrown\n        $invalid = [];\n        foreach ($options as $key => $value) {\n            if (\\array_key_exists($key, $this->options)) {\n                $this->options[$key] = $value;\n            } else {\n                $invalid[] = $key;\n            }\n        }\n\n        if ($invalid) {\n            throw new \\InvalidArgumentException(\\sprintf('The Router does not support the following options: \"%s\".', implode('\", \"', $invalid)));\n        }\n    }\n\n    /**\n     * Sets an option.\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function setOption(string $key, mixed $value): void\n    {\n        if (!\\array_key_exists($key, $this->options)) {\n            throw new \\InvalidArgumentException(\\sprintf('The Router does not support the \"%s\" option.', $key));\n        }\n\n        $this->options[$key] = $value;\n    }\n\n    /**\n     * Gets an option value.\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function getOption(string $key): mixed\n    {\n        if (!\\array_key_exists($key, $this->options)) {\n            throw new \\InvalidArgumentException(\\sprintf('The Router does not support the \"%s\" option.', $key));\n        }\n\n        return $this->options[$key];\n    }\n\n    public function getRouteCollection(): RouteCollection\n    {\n        return $this->collection ??= $this->loader->load($this->resource, $this->options['resource_type']);\n    }\n\n    public function setContext(RequestContext $context): void\n    {\n        $this->context = $context;\n\n        if (isset($this->matcher)) {\n            $this->getMatcher()->setContext($context);\n        }\n        if (isset($this->generator)) {\n            $this->getGenerator()->setContext($context);\n        }\n    }\n\n    public function getContext(): RequestContext\n    {\n        return $this->context;\n    }\n\n    /**\n     * Sets the ConfigCache factory to use.\n     */\n    public function setConfigCacheFactory(ConfigCacheFactoryInterface $configCacheFactory): void\n    {\n        $this->configCacheFactory = $configCacheFactory;\n    }\n\n    public function generate(string $name, array $parameters = [], int $referenceType = self::ABSOLUTE_PATH): string\n    {\n        return $this->getGenerator()->generate($name, $parameters, $referenceType);\n    }\n\n    public function match(string $pathinfo): array\n    {\n        return $this->getMatcher()->match($pathinfo);\n    }\n\n    public function matchRequest(Request $request): array\n    {\n        $matcher = $this->getMatcher();\n        if (!$matcher instanceof RequestMatcherInterface) {\n            // fallback to the default UrlMatcherInterface\n            return $matcher->match($request->getPathInfo());\n        }\n\n        return $matcher->matchRequest($request);\n    }\n\n    /**\n     * Gets the UrlMatcher or RequestMatcher instance associated with this Router.\n     */\n    public function getMatcher(): UrlMatcherInterface|RequestMatcherInterface\n    {\n        if (isset($this->matcher)) {\n            return $this->matcher;\n        }\n\n        if (null === $this->options['cache_dir']) {\n            $routes = $this->getRouteCollection();\n            $compiled = is_a($this->options['matcher_class'], CompiledUrlMatcher::class, true);\n            if ($compiled) {\n                $routes = (new CompiledUrlMatcherDumper($routes))->getCompiledRoutes();\n            }\n            $this->matcher = new $this->options['matcher_class']($routes, $this->context);\n            if (method_exists($this->matcher, 'addExpressionLanguageProvider')) {\n                foreach ($this->expressionLanguageProviders as $provider) {\n                    $this->matcher->addExpressionLanguageProvider($provider);\n                }\n            }\n\n            return $this->matcher;\n        }\n\n        $cache = $this->getConfigCacheFactory()->cache($this->options['cache_dir'].'/url_matching_routes.php',\n            function (ConfigCacheInterface $cache) {\n                $dumper = $this->getMatcherDumperInstance();\n                if (method_exists($dumper, 'addExpressionLanguageProvider')) {\n                    foreach ($this->expressionLanguageProviders as $provider) {\n                        $dumper->addExpressionLanguageProvider($provider);\n                    }\n                }\n\n                $cache->write($dumper->dump(), $this->getRouteCollection()->getResources());\n                unset(self::$cache[$cache->getPath()]);\n            }\n        );\n\n        return $this->matcher = new $this->options['matcher_class'](self::getCompiledRoutes($cache->getPath()), $this->context);\n    }\n\n    /**\n     * Gets the UrlGenerator instance associated with this Router.\n     */\n    public function getGenerator(): UrlGeneratorInterface\n    {\n        if (isset($this->generator)) {\n            return $this->generator;\n        }\n\n        if (null === $this->options['cache_dir']) {\n            $routes = $this->getRouteCollection();\n            $compiled = is_a($this->options['generator_class'], CompiledUrlGenerator::class, true);\n            if ($compiled) {\n                $generatorDumper = new CompiledUrlGeneratorDumper($routes);\n                $routes = array_merge($generatorDumper->getCompiledRoutes(), $generatorDumper->getCompiledAliases());\n            }\n            $this->generator = new $this->options['generator_class']($routes, $this->context, $this->logger, $this->defaultLocale);\n        } else {\n            $cache = $this->getConfigCacheFactory()->cache($this->options['cache_dir'].'/url_generating_routes.php',\n                function (ConfigCacheInterface $cache) {\n                    $dumper = $this->getGeneratorDumperInstance();\n\n                    $cache->write($dumper->dump(), $this->getRouteCollection()->getResources());\n                    unset(self::$cache[$cache->getPath()]);\n                }\n            );\n\n            $this->generator = new $this->options['generator_class'](self::getCompiledRoutes($cache->getPath()), $this->context, $this->logger, $this->defaultLocale);\n        }\n\n        if ($this->generator instanceof ConfigurableRequirementsInterface) {\n            $this->generator->setStrictRequirements($this->options['strict_requirements']);\n        }\n\n        return $this->generator;\n    }\n\n    public function addExpressionLanguageProvider(ExpressionFunctionProviderInterface $provider): void\n    {\n        $this->expressionLanguageProviders[] = $provider;\n    }\n\n    protected function getGeneratorDumperInstance(): GeneratorDumperInterface\n    {\n        return new $this->options['generator_dumper_class']($this->getRouteCollection());\n    }\n\n    protected function getMatcherDumperInstance(): MatcherDumperInterface\n    {\n        return new $this->options['matcher_dumper_class']($this->getRouteCollection());\n    }\n\n    /**\n     * Provides the ConfigCache factory implementation, falling back to a\n     * default implementation if necessary.\n     */\n    private function getConfigCacheFactory(): ConfigCacheFactoryInterface\n    {\n        return $this->configCacheFactory ??= new ConfigCacheFactory($this->options['debug']);\n    }\n\n    private static function getCompiledRoutes(string $path): array\n    {\n        if ([] === self::$cache && \\function_exists('opcache_invalidate') && filter_var(\\ini_get('opcache.enable'), \\FILTER_VALIDATE_BOOL) && (!\\in_array(\\PHP_SAPI, ['cli', 'phpdbg', 'embed'], true) || filter_var(\\ini_get('opcache.enable_cli'), \\FILTER_VALIDATE_BOOL))) {\n            self::$cache = null;\n        }\n\n        if (null === self::$cache) {\n            return require $path;\n        }\n\n        return self::$cache[$path] ??= require $path;\n    }\n}\n"
        },
        {
          "name": "RouterInterface.php",
          "type": "blob",
          "size": 0.970703125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Routing;\n\nuse Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;\nuse Symfony\\Component\\Routing\\Matcher\\UrlMatcherInterface;\n\n/**\n * RouterInterface is the interface that all Router classes must implement.\n *\n * This interface is the concatenation of UrlMatcherInterface and UrlGeneratorInterface.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\ninterface RouterInterface extends UrlMatcherInterface, UrlGeneratorInterface\n{\n    /**\n     * Gets the RouteCollection instance associated with this Router.\n     *\n     * WARNING: This method should never be used at runtime as it is SLOW.\n     *          You might use it in a cache warmer though.\n     */\n    public function getRouteCollection(): RouteCollection;\n}\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.1748046875,
          "content": "{\n    \"name\": \"symfony/routing\",\n    \"type\": \"library\",\n    \"description\": \"Maps an HTTP request to a set of configuration variables\",\n    \"keywords\": [\"routing\", \"router\", \"url\", \"uri\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3\"\n    },\n    \"require-dev\": {\n        \"symfony/config\": \"^6.4|^7.0\",\n        \"symfony/http-foundation\": \"^6.4|^7.0\",\n        \"symfony/yaml\": \"^6.4|^7.0\",\n        \"symfony/expression-language\": \"^6.4|^7.0\",\n        \"symfony/dependency-injection\": \"^6.4|^7.0\",\n        \"psr/log\": \"^1|^2|^3\"\n    },\n    \"conflict\": {\n        \"symfony/config\": \"<6.4\",\n        \"symfony/dependency-injection\": \"<6.4\",\n        \"symfony/yaml\": \"<6.4\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Routing\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.798828125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Routing Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}