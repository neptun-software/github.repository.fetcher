{
  "metadata": {
    "timestamp": 1736712300312,
    "page": 87,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/translation",
      "stars": 6618,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 8.091796875,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Deprecate `ProviderFactoryTestCase`, extend `AbstractProviderFactoryTestCase` instead\n\n   The `testIncompleteDsnException()` test is no longer provided by default. If you make use of it by implementing the `incompleteDsnProvider()` data providers,\n   you now need to use the `IncompleteDsnTestTrait`.\n\n * Make `ProviderFactoryTestCase` and `ProviderTestCase` compatible with PHPUnit 10+\n * Add `lint:translations` command\n * Deprecate passing an escape character to `CsvFileLoader::setCsvControl()`\n * Make Xliff 2.0 attributes in segment element available as `segment-attributes`\n   metadata returned by `XliffFileLoader` and make `XliffFileDumper` write them to the file\n\n7.1\n---\n\n * Mark class `DataCollectorTranslator` as `final`\n\n7.0\n---\n\n * Remove `PhpStringTokenParser`\n * Remove `PhpExtractor` in favor of `PhpAstExtractor`\n\n6.4\n---\n\n * Give current locale to `LocaleSwitcher::runWithLocale()`'s callback\n * Add `--as-tree` option to `translation:pull` command to write YAML messages as a tree-like structure\n * [BC BREAK] Add argument `$buildDir` to `DataCollectorTranslator::warmUp()`\n * Add `DataCollectorTranslatorPass` and `LoggingTranslatorPass`  (moved from `FrameworkBundle`)\n * Add `PhraseTranslationProvider`\n\n6.2.7\n-----\n\n * [BC BREAK] The following data providers for `ProviderFactoryTestCase` are now static:\n   `supportsProvider()`, `createProvider()`, `unsupportedSchemeProvider()`and `incompleteDsnProvider()`\n * [BC BREAK] `ProviderTestCase::toStringProvider()` is now static\n\n6.2\n---\n\n * Deprecate `PhpStringTokenParser`\n * Deprecate `PhpExtractor` in favor of `PhpAstExtractor`\n * Add `PhpAstExtractor` (requires [nikic/php-parser](https://github.com/nikic/php-parser) to be installed)\n\n6.1\n---\n\n * Parameters implementing `TranslatableInterface` are processed\n * Add the file extension to the `XliffFileDumper` constructor\n\n5.4\n---\n\n * Add `github` format & autodetection to render errors as annotations when\n   running the XLIFF linter command in a Github Actions environment.\n * Translation providers are not experimental anymore\n\n5.3\n---\n\n * Add `translation:pull` and `translation:push` commands to manage translations with third-party providers\n * Add `TranslatorBagInterface::getCatalogues` method\n * Add support to load XLIFF string in `XliffFileLoader`\n\n5.2.0\n-----\n\n * added support for calling `trans` with ICU formatted messages\n * added `PseudoLocalizationTranslator`\n * added `TranslatableMessage` objects that represent a message that can be translated\n * added the `t()` function to easily create `TranslatableMessage` objects\n * Added support for extracting messages from `TranslatableMessage` objects\n\n5.1.0\n-----\n\n * added support for `name` attribute on `unit` element from xliff2 to be used as a translation key instead of always the `source` element\n\n5.0.0\n-----\n\n * removed support for using `null` as the locale in `Translator`\n * removed `TranslatorInterface`\n * removed `MessageSelector`\n * removed `ChoiceMessageFormatterInterface`\n * removed `PluralizationRule`\n * removed `Interval`\n * removed `transChoice()` methods, use the trans() method instead with a %count% parameter\n * removed `FileDumper::setBackup()` and `TranslationWriter::disableBackup()`\n * removed `MessageFormatter::choiceFormat()`\n * added argument `$filename` to `PhpExtractor::parseTokens()`\n * removed support for implicit STDIN usage in the `lint:xliff` command, use `lint:xliff -` (append a dash) instead to make it explicit.\n\n4.4.0\n-----\n\n * deprecated support for using `null` as the locale in `Translator`\n * deprecated accepting STDIN implicitly when using the `lint:xliff` command, use `lint:xliff -` (append a dash) instead to make it explicit.\n * Marked the `TranslationDataCollector` class as `@final`.\n\n4.3.0\n-----\n\n * Improved Xliff 1.2 loader to load the original file's metadata\n * Added `TranslatorPathsPass`\n\n4.2.0\n-----\n\n * Started using ICU parent locales as fallback locales.\n * allow using the ICU message format using domains with the \"+intl-icu\" suffix\n * deprecated `Translator::transChoice()` in favor of using `Translator::trans()` with a `%count%` parameter\n * deprecated `TranslatorInterface` in favor of `Symfony\\Contracts\\Translation\\TranslatorInterface`\n * deprecated `MessageSelector`, `Interval` and `PluralizationRules`; use `IdentityTranslator` instead\n * Added `IntlFormatter` and `IntlFormatterInterface`\n * added support for multiple files and directories in `XliffLintCommand`\n * Marked `Translator::getFallbackLocales()` and `TranslationDataCollector::getFallbackLocales()` as internal\n\n4.1.0\n-----\n\n * The `FileDumper::setBackup()` method is deprecated.\n * The `TranslationWriter::disableBackup()` method is deprecated.\n * The `XliffFileDumper` will write \"name\" on the \"unit\" node when dumping XLIFF 2.0.\n\n4.0.0\n-----\n\n * removed the backup feature of the `FileDumper` class\n * removed `TranslationWriter::writeTranslations()` method\n * removed support for passing `MessageSelector` instances to the constructor of the `Translator` class\n\n3.4.0\n-----\n\n * Added `TranslationDumperPass`\n * Added `TranslationExtractorPass`\n * Added `TranslatorPass`\n * Added `TranslationReader` and `TranslationReaderInterface`\n * Added `<notes>` section to the Xliff 2.0 dumper.\n * Improved Xliff 2.0 loader to load `<notes>` section.\n * Added `TranslationWriterInterface`\n * Deprecated `TranslationWriter::writeTranslations` in favor of `TranslationWriter::write`\n * added support for adding custom message formatter and decoupling the default one.\n * Added `PhpExtractor`\n * Added `PhpStringTokenParser`\n\n3.2.0\n-----\n\n * Added support for escaping `|` in plural translations with double pipe.\n\n3.1.0\n-----\n\n * Deprecated the backup feature of the file dumper classes.\n\n3.0.0\n-----\n\n * removed `FileDumper::format()` method.\n * Changed the visibility of the locale property in `Translator` from protected to private.\n\n2.8.0\n-----\n\n * deprecated FileDumper::format(), overwrite FileDumper::formatCatalogue() instead.\n * deprecated Translator::getMessages(), rely on TranslatorBagInterface::getCatalogue() instead.\n * added `FileDumper::formatCatalogue` which allows format the catalogue without dumping it into file.\n * added option `json_encoding` to JsonFileDumper\n * added options `as_tree`, `inline` to YamlFileDumper\n * added support for XLIFF 2.0.\n * added support for XLIFF target and tool attributes.\n * added message parameters to DataCollectorTranslator.\n * [DEPRECATION] The `DiffOperation` class has been deprecated and\n   will be removed in Symfony 3.0, since its operation has nothing to do with 'diff',\n   so the class name is misleading. The `TargetOperation` class should be used for\n   this use-case instead.\n\n2.7.0\n-----\n\n * added DataCollectorTranslator for collecting the translated messages.\n\n2.6.0\n-----\n\n * added possibility to cache catalogues\n * added TranslatorBagInterface\n * added LoggingTranslator\n * added Translator::getMessages() for retrieving the message catalogue as an array\n\n2.5.0\n-----\n\n * added relative file path template to the file dumpers\n * added optional backup to the file dumpers\n * changed IcuResFileDumper to extend FileDumper\n\n2.3.0\n-----\n\n * added classes to make operations on catalogues (like making a diff or a merge on 2 catalogues)\n * added Translator::getFallbackLocales()\n * deprecated Translator::setFallbackLocale() in favor of the new Translator::setFallbackLocales() method\n\n2.2.0\n-----\n\n * QtTranslationsLoader class renamed to QtFileLoader. QtTranslationsLoader is deprecated and will be removed in 2.3.\n * [BC BREAK] uniformized the exception thrown by the load() method when an error occurs. The load() method now\n   throws Symfony\\Component\\Translation\\Exception\\NotFoundResourceException when a resource cannot be found\n   and Symfony\\Component\\Translation\\Exception\\InvalidResourceException when a resource is invalid.\n * changed the exception class thrown by some load() methods from \\RuntimeException to \\InvalidArgumentException\n   (IcuDatFileLoader, IcuResFileLoader and QtFileLoader)\n\n2.1.0\n-----\n\n * added support for more than one fallback locale\n * added support for extracting translation messages from templates (Twig and PHP)\n * added dumpers for translation catalogs\n * added support for QT, gettext, and ResourceBundles\n"
        },
        {
          "name": "Catalogue",
          "type": "tree",
          "content": null
        },
        {
          "name": "CatalogueMetadataAwareInterface.php",
          "type": "blob",
          "size": 1.419921875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\n/**\n * This interface is used to get, set, and delete metadata about the Catalogue.\n *\n * @author Hugo Alliaume <hugo@alliau.me>\n */\ninterface CatalogueMetadataAwareInterface\n{\n    /**\n     * Gets catalogue metadata for the given domain and key.\n     *\n     * Passing an empty domain will return an array with all catalogue metadata indexed by\n     * domain and then by key. Passing an empty key will return an array with all\n     * catalogue metadata for the given domain.\n     *\n     * @return mixed The value that was set or an array with the domains/keys or null\n     */\n    public function getCatalogueMetadata(string $key = '', string $domain = 'messages'): mixed;\n\n    /**\n     * Adds catalogue metadata to a message domain.\n     */\n    public function setCatalogueMetadata(string $key, mixed $value, string $domain = 'messages'): void;\n\n    /**\n     * Deletes catalogue metadata for the given key and domain.\n     *\n     * Passing an empty domain will delete all catalogue metadata. Passing an empty key will\n     * delete all metadata for the given domain.\n     */\n    public function deleteCatalogueMetadata(string $key = '', string $domain = 'messages'): void;\n}\n"
        },
        {
          "name": "Command",
          "type": "tree",
          "content": null
        },
        {
          "name": "DataCollector",
          "type": "tree",
          "content": null
        },
        {
          "name": "DataCollectorTranslator.php",
          "type": "blob",
          "size": 3.880859375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\nuse Symfony\\Component\\HttpKernel\\CacheWarmer\\WarmableInterface;\nuse Symfony\\Contracts\\Translation\\LocaleAwareInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * @author Abdellatif Ait boudad <a.aitboudad@gmail.com>\n *\n * @final since Symfony 7.1\n */\nclass DataCollectorTranslator implements TranslatorInterface, TranslatorBagInterface, LocaleAwareInterface, WarmableInterface\n{\n    public const MESSAGE_DEFINED = 0;\n    public const MESSAGE_MISSING = 1;\n    public const MESSAGE_EQUALS_FALLBACK = 2;\n\n    private array $messages = [];\n\n    public function __construct(\n        private TranslatorInterface&TranslatorBagInterface&LocaleAwareInterface $translator,\n    ) {\n    }\n\n    public function trans(?string $id, array $parameters = [], ?string $domain = null, ?string $locale = null): string\n    {\n        $trans = $this->translator->trans($id = (string) $id, $parameters, $domain, $locale);\n        $this->collectMessage($locale, $domain, $id, $trans, $parameters);\n\n        return $trans;\n    }\n\n    public function setLocale(string $locale): void\n    {\n        $this->translator->setLocale($locale);\n    }\n\n    public function getLocale(): string\n    {\n        return $this->translator->getLocale();\n    }\n\n    public function getCatalogue(?string $locale = null): MessageCatalogueInterface\n    {\n        return $this->translator->getCatalogue($locale);\n    }\n\n    public function getCatalogues(): array\n    {\n        return $this->translator->getCatalogues();\n    }\n\n    public function warmUp(string $cacheDir, ?string $buildDir = null): array\n    {\n        if ($this->translator instanceof WarmableInterface) {\n            return $this->translator->warmUp($cacheDir, $buildDir);\n        }\n\n        return [];\n    }\n\n    /**\n     * Gets the fallback locales.\n     */\n    public function getFallbackLocales(): array\n    {\n        if ($this->translator instanceof Translator || method_exists($this->translator, 'getFallbackLocales')) {\n            return $this->translator->getFallbackLocales();\n        }\n\n        return [];\n    }\n\n    public function __call(string $method, array $args): mixed\n    {\n        return $this->translator->{$method}(...$args);\n    }\n\n    public function getCollectedMessages(): array\n    {\n        return $this->messages;\n    }\n\n    private function collectMessage(?string $locale, ?string $domain, string $id, string $translation, ?array $parameters = []): void\n    {\n        $domain ??= 'messages';\n\n        $catalogue = $this->translator->getCatalogue($locale);\n        $locale = $catalogue->getLocale();\n        $fallbackLocale = null;\n        if ($catalogue->defines($id, $domain)) {\n            $state = self::MESSAGE_DEFINED;\n        } elseif ($catalogue->has($id, $domain)) {\n            $state = self::MESSAGE_EQUALS_FALLBACK;\n\n            $fallbackCatalogue = $catalogue->getFallbackCatalogue();\n            while ($fallbackCatalogue) {\n                if ($fallbackCatalogue->defines($id, $domain)) {\n                    $fallbackLocale = $fallbackCatalogue->getLocale();\n                    break;\n                }\n                $fallbackCatalogue = $fallbackCatalogue->getFallbackCatalogue();\n            }\n        } else {\n            $state = self::MESSAGE_MISSING;\n        }\n\n        $this->messages[] = [\n            'locale' => $locale,\n            'fallbackLocale' => $fallbackLocale,\n            'domain' => $domain,\n            'id' => $id,\n            'translation' => $translation,\n            'parameters' => $parameters,\n            'state' => $state,\n            'transChoiceNumber' => isset($parameters['%count%']) && is_numeric($parameters['%count%']) ? $parameters['%count%'] : null,\n        ];\n    }\n}\n"
        },
        {
          "name": "DependencyInjection",
          "type": "tree",
          "content": null
        },
        {
          "name": "Dumper",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Extractor",
          "type": "tree",
          "content": null
        },
        {
          "name": "Formatter",
          "type": "tree",
          "content": null
        },
        {
          "name": "IdentityTranslator.php",
          "type": "blob",
          "size": 0.6455078125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\nuse Symfony\\Contracts\\Translation\\LocaleAwareInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorTrait;\n\n/**\n * IdentityTranslator does not translate anything.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass IdentityTranslator implements TranslatorInterface, LocaleAwareInterface\n{\n    use TranslatorTrait;\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Loader",
          "type": "tree",
          "content": null
        },
        {
          "name": "LocaleSwitcher.php",
          "type": "blob",
          "size": 1.9638671875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\nuse Symfony\\Component\\Routing\\RequestContext;\nuse Symfony\\Contracts\\Translation\\LocaleAwareInterface;\n\n/**\n * @author Kevin Bond <kevinbond@gmail.com>\n */\nclass LocaleSwitcher implements LocaleAwareInterface\n{\n    private string $defaultLocale;\n\n    /**\n     * @param LocaleAwareInterface[] $localeAwareServices\n     */\n    public function __construct(\n        private string $locale,\n        private iterable $localeAwareServices,\n        private ?RequestContext $requestContext = null,\n    ) {\n        $this->defaultLocale = $locale;\n    }\n\n    public function setLocale(string $locale): void\n    {\n        // Silently ignore if the intl extension is not loaded\n        try {\n            if (class_exists(\\Locale::class, false)) {\n                \\Locale::setDefault($locale);\n            }\n        } catch (\\Exception) {\n        }\n\n        $this->locale = $locale;\n        $this->requestContext?->setParameter('_locale', $locale);\n\n        foreach ($this->localeAwareServices as $service) {\n            $service->setLocale($locale);\n        }\n    }\n\n    public function getLocale(): string\n    {\n        return $this->locale;\n    }\n\n    /**\n     * Switch to a new locale, execute a callback, then switch back to the original.\n     *\n     * @template T\n     *\n     * @param callable(string $locale):T $callback\n     *\n     * @return T\n     */\n    public function runWithLocale(string $locale, callable $callback): mixed\n    {\n        $original = $this->getLocale();\n        $this->setLocale($locale);\n\n        try {\n            return $callback($locale);\n        } finally {\n            $this->setLocale($original);\n        }\n    }\n\n    public function reset(): void\n    {\n        $this->setLocale($this->defaultLocale);\n    }\n}\n"
        },
        {
          "name": "LoggingTranslator.php",
          "type": "blob",
          "size": 2.8193359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Contracts\\Translation\\LocaleAwareInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * @author Abdellatif Ait boudad <a.aitboudad@gmail.com>\n */\nclass LoggingTranslator implements TranslatorInterface, TranslatorBagInterface, LocaleAwareInterface\n{\n    public function __construct(\n        private TranslatorInterface&TranslatorBagInterface&LocaleAwareInterface $translator,\n        private LoggerInterface $logger,\n    ) {\n    }\n\n    public function trans(?string $id, array $parameters = [], ?string $domain = null, ?string $locale = null): string\n    {\n        $trans = $this->translator->trans($id = (string) $id, $parameters, $domain, $locale);\n        $this->log($id, $domain, $locale);\n\n        return $trans;\n    }\n\n    public function setLocale(string $locale): void\n    {\n        $prev = $this->translator->getLocale();\n        $this->translator->setLocale($locale);\n        if ($prev === $locale) {\n            return;\n        }\n\n        $this->logger->debug(\\sprintf('The locale of the translator has changed from \"%s\" to \"%s\".', $prev, $locale));\n    }\n\n    public function getLocale(): string\n    {\n        return $this->translator->getLocale();\n    }\n\n    public function getCatalogue(?string $locale = null): MessageCatalogueInterface\n    {\n        return $this->translator->getCatalogue($locale);\n    }\n\n    public function getCatalogues(): array\n    {\n        return $this->translator->getCatalogues();\n    }\n\n    /**\n     * Gets the fallback locales.\n     */\n    public function getFallbackLocales(): array\n    {\n        if ($this->translator instanceof Translator || method_exists($this->translator, 'getFallbackLocales')) {\n            return $this->translator->getFallbackLocales();\n        }\n\n        return [];\n    }\n\n    public function __call(string $method, array $args): mixed\n    {\n        return $this->translator->{$method}(...$args);\n    }\n\n    /**\n     * Logs for missing translations.\n     */\n    private function log(string $id, ?string $domain, ?string $locale): void\n    {\n        $domain ??= 'messages';\n\n        $catalogue = $this->translator->getCatalogue($locale);\n        if ($catalogue->defines($id, $domain)) {\n            return;\n        }\n\n        if ($catalogue->has($id, $domain)) {\n            $this->logger->debug('Translation use fallback catalogue.', ['id' => $id, 'domain' => $domain, 'locale' => $catalogue->getLocale()]);\n        } else {\n            $this->logger->warning('Translation not found.', ['id' => $id, 'domain' => $domain, 'locale' => $catalogue->getLocale()]);\n        }\n    }\n}\n"
        },
        {
          "name": "MessageCatalogue.php",
          "type": "blob",
          "size": 9.4228515625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\nuse Symfony\\Component\\Config\\Resource\\ResourceInterface;\nuse Symfony\\Component\\Translation\\Exception\\LogicException;\n\n/**\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass MessageCatalogue implements MessageCatalogueInterface, MetadataAwareInterface, CatalogueMetadataAwareInterface\n{\n    private array $metadata = [];\n    private array $catalogueMetadata = [];\n    private array $resources = [];\n    private ?MessageCatalogueInterface $fallbackCatalogue = null;\n    private ?self $parent = null;\n\n    /**\n     * @param array $messages An array of messages classified by domain\n     */\n    public function __construct(\n        private string $locale,\n        private array $messages = [],\n    ) {\n    }\n\n    public function getLocale(): string\n    {\n        return $this->locale;\n    }\n\n    public function getDomains(): array\n    {\n        $domains = [];\n\n        foreach ($this->messages as $domain => $messages) {\n            if (str_ends_with($domain, self::INTL_DOMAIN_SUFFIX)) {\n                $domain = substr($domain, 0, -\\strlen(self::INTL_DOMAIN_SUFFIX));\n            }\n            $domains[$domain] = $domain;\n        }\n\n        return array_values($domains);\n    }\n\n    public function all(?string $domain = null): array\n    {\n        if (null !== $domain) {\n            // skip messages merge if intl-icu requested explicitly\n            if (str_ends_with($domain, self::INTL_DOMAIN_SUFFIX)) {\n                return $this->messages[$domain] ?? [];\n            }\n\n            return ($this->messages[$domain.self::INTL_DOMAIN_SUFFIX] ?? []) + ($this->messages[$domain] ?? []);\n        }\n\n        $allMessages = [];\n\n        foreach ($this->messages as $domain => $messages) {\n            if (str_ends_with($domain, self::INTL_DOMAIN_SUFFIX)) {\n                $domain = substr($domain, 0, -\\strlen(self::INTL_DOMAIN_SUFFIX));\n                $allMessages[$domain] = $messages + ($allMessages[$domain] ?? []);\n            } else {\n                $allMessages[$domain] = ($allMessages[$domain] ?? []) + $messages;\n            }\n        }\n\n        return $allMessages;\n    }\n\n    public function set(string $id, string $translation, string $domain = 'messages'): void\n    {\n        $this->add([$id => $translation], $domain);\n    }\n\n    public function has(string $id, string $domain = 'messages'): bool\n    {\n        if (isset($this->messages[$domain][$id]) || isset($this->messages[$domain.self::INTL_DOMAIN_SUFFIX][$id])) {\n            return true;\n        }\n\n        if (null !== $this->fallbackCatalogue) {\n            return $this->fallbackCatalogue->has($id, $domain);\n        }\n\n        return false;\n    }\n\n    public function defines(string $id, string $domain = 'messages'): bool\n    {\n        return isset($this->messages[$domain][$id]) || isset($this->messages[$domain.self::INTL_DOMAIN_SUFFIX][$id]);\n    }\n\n    public function get(string $id, string $domain = 'messages'): string\n    {\n        if (isset($this->messages[$domain.self::INTL_DOMAIN_SUFFIX][$id])) {\n            return $this->messages[$domain.self::INTL_DOMAIN_SUFFIX][$id];\n        }\n\n        if (isset($this->messages[$domain][$id])) {\n            return $this->messages[$domain][$id];\n        }\n\n        if (null !== $this->fallbackCatalogue) {\n            return $this->fallbackCatalogue->get($id, $domain);\n        }\n\n        return $id;\n    }\n\n    public function replace(array $messages, string $domain = 'messages'): void\n    {\n        unset($this->messages[$domain], $this->messages[$domain.self::INTL_DOMAIN_SUFFIX]);\n\n        $this->add($messages, $domain);\n    }\n\n    public function add(array $messages, string $domain = 'messages'): void\n    {\n        $altDomain = str_ends_with($domain, self::INTL_DOMAIN_SUFFIX) ? substr($domain, 0, -\\strlen(self::INTL_DOMAIN_SUFFIX)) : $domain.self::INTL_DOMAIN_SUFFIX;\n        foreach ($messages as $id => $message) {\n            unset($this->messages[$altDomain][$id]);\n            $this->messages[$domain][$id] = $message;\n        }\n\n        if ([] === ($this->messages[$altDomain] ?? null)) {\n            unset($this->messages[$altDomain]);\n        }\n    }\n\n    public function addCatalogue(MessageCatalogueInterface $catalogue): void\n    {\n        if ($catalogue->getLocale() !== $this->locale) {\n            throw new LogicException(\\sprintf('Cannot add a catalogue for locale \"%s\" as the current locale for this catalogue is \"%s\".', $catalogue->getLocale(), $this->locale));\n        }\n\n        foreach ($catalogue->all() as $domain => $messages) {\n            if ($intlMessages = $catalogue->all($domain.self::INTL_DOMAIN_SUFFIX)) {\n                $this->add($intlMessages, $domain.self::INTL_DOMAIN_SUFFIX);\n                $messages = array_diff_key($messages, $intlMessages);\n            }\n            $this->add($messages, $domain);\n        }\n\n        foreach ($catalogue->getResources() as $resource) {\n            $this->addResource($resource);\n        }\n\n        if ($catalogue instanceof MetadataAwareInterface) {\n            $metadata = $catalogue->getMetadata('', '');\n            $this->addMetadata($metadata);\n        }\n\n        if ($catalogue instanceof CatalogueMetadataAwareInterface) {\n            $catalogueMetadata = $catalogue->getCatalogueMetadata('', '');\n            $this->addCatalogueMetadata($catalogueMetadata);\n        }\n    }\n\n    public function addFallbackCatalogue(MessageCatalogueInterface $catalogue): void\n    {\n        // detect circular references\n        $c = $catalogue;\n        while ($c = $c->getFallbackCatalogue()) {\n            if ($c->getLocale() === $this->getLocale()) {\n                throw new LogicException(\\sprintf('Circular reference detected when adding a fallback catalogue for locale \"%s\".', $catalogue->getLocale()));\n            }\n        }\n\n        $c = $this;\n        do {\n            if ($c->getLocale() === $catalogue->getLocale()) {\n                throw new LogicException(\\sprintf('Circular reference detected when adding a fallback catalogue for locale \"%s\".', $catalogue->getLocale()));\n            }\n\n            foreach ($catalogue->getResources() as $resource) {\n                $c->addResource($resource);\n            }\n        } while ($c = $c->parent);\n\n        $catalogue->parent = $this;\n        $this->fallbackCatalogue = $catalogue;\n\n        foreach ($catalogue->getResources() as $resource) {\n            $this->addResource($resource);\n        }\n    }\n\n    public function getFallbackCatalogue(): ?MessageCatalogueInterface\n    {\n        return $this->fallbackCatalogue;\n    }\n\n    public function getResources(): array\n    {\n        return array_values($this->resources);\n    }\n\n    public function addResource(ResourceInterface $resource): void\n    {\n        $this->resources[$resource->__toString()] = $resource;\n    }\n\n    public function getMetadata(string $key = '', string $domain = 'messages'): mixed\n    {\n        if ('' == $domain) {\n            return $this->metadata;\n        }\n\n        if (isset($this->metadata[$domain])) {\n            if ('' == $key) {\n                return $this->metadata[$domain];\n            }\n\n            if (isset($this->metadata[$domain][$key])) {\n                return $this->metadata[$domain][$key];\n            }\n        }\n\n        return null;\n    }\n\n    public function setMetadata(string $key, mixed $value, string $domain = 'messages'): void\n    {\n        $this->metadata[$domain][$key] = $value;\n    }\n\n    public function deleteMetadata(string $key = '', string $domain = 'messages'): void\n    {\n        if ('' == $domain) {\n            $this->metadata = [];\n        } elseif ('' == $key) {\n            unset($this->metadata[$domain]);\n        } else {\n            unset($this->metadata[$domain][$key]);\n        }\n    }\n\n    public function getCatalogueMetadata(string $key = '', string $domain = 'messages'): mixed\n    {\n        if (!$domain) {\n            return $this->catalogueMetadata;\n        }\n\n        if (isset($this->catalogueMetadata[$domain])) {\n            if (!$key) {\n                return $this->catalogueMetadata[$domain];\n            }\n\n            if (isset($this->catalogueMetadata[$domain][$key])) {\n                return $this->catalogueMetadata[$domain][$key];\n            }\n        }\n\n        return null;\n    }\n\n    public function setCatalogueMetadata(string $key, mixed $value, string $domain = 'messages'): void\n    {\n        $this->catalogueMetadata[$domain][$key] = $value;\n    }\n\n    public function deleteCatalogueMetadata(string $key = '', string $domain = 'messages'): void\n    {\n        if (!$domain) {\n            $this->catalogueMetadata = [];\n        } elseif (!$key) {\n            unset($this->catalogueMetadata[$domain]);\n        } else {\n            unset($this->catalogueMetadata[$domain][$key]);\n        }\n    }\n\n    /**\n     * Adds current values with the new values.\n     *\n     * @param array $values Values to add\n     */\n    private function addMetadata(array $values): void\n    {\n        foreach ($values as $domain => $keys) {\n            foreach ($keys as $key => $value) {\n                $this->setMetadata($key, $value, $domain);\n            }\n        }\n    }\n\n    private function addCatalogueMetadata(array $values): void\n    {\n        foreach ($values as $domain => $keys) {\n            foreach ($keys as $key => $value) {\n                $this->setCatalogueMetadata($key, $value, $domain);\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "MessageCatalogueInterface.php",
          "type": "blob",
          "size": 3.2734375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\nuse Symfony\\Component\\Config\\Resource\\ResourceInterface;\n\n/**\n * MessageCatalogueInterface.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\ninterface MessageCatalogueInterface\n{\n    public const INTL_DOMAIN_SUFFIX = '+intl-icu';\n\n    /**\n     * Gets the catalogue locale.\n     */\n    public function getLocale(): string;\n\n    /**\n     * Gets the domains.\n     */\n    public function getDomains(): array;\n\n    /**\n     * Gets the messages within a given domain.\n     *\n     * If $domain is null, it returns all messages.\n     */\n    public function all(?string $domain = null): array;\n\n    /**\n     * Sets a message translation.\n     *\n     * @param string $id          The message id\n     * @param string $translation The messages translation\n     * @param string $domain      The domain name\n     */\n    public function set(string $id, string $translation, string $domain = 'messages'): void;\n\n    /**\n     * Checks if a message has a translation.\n     *\n     * @param string $id     The message id\n     * @param string $domain The domain name\n     */\n    public function has(string $id, string $domain = 'messages'): bool;\n\n    /**\n     * Checks if a message has a translation (it does not take into account the fallback mechanism).\n     *\n     * @param string $id     The message id\n     * @param string $domain The domain name\n     */\n    public function defines(string $id, string $domain = 'messages'): bool;\n\n    /**\n     * Gets a message translation.\n     *\n     * @param string $id     The message id\n     * @param string $domain The domain name\n     */\n    public function get(string $id, string $domain = 'messages'): string;\n\n    /**\n     * Sets translations for a given domain.\n     *\n     * @param array  $messages An array of translations\n     * @param string $domain   The domain name\n     */\n    public function replace(array $messages, string $domain = 'messages'): void;\n\n    /**\n     * Adds translations for a given domain.\n     *\n     * @param array  $messages An array of translations\n     * @param string $domain   The domain name\n     */\n    public function add(array $messages, string $domain = 'messages'): void;\n\n    /**\n     * Merges translations from the given Catalogue into the current one.\n     *\n     * The two catalogues must have the same locale.\n     */\n    public function addCatalogue(self $catalogue): void;\n\n    /**\n     * Merges translations from the given Catalogue into the current one\n     * only when the translation does not exist.\n     *\n     * This is used to provide default translations when they do not exist for the current locale.\n     */\n    public function addFallbackCatalogue(self $catalogue): void;\n\n    /**\n     * Gets the fallback catalogue.\n     */\n    public function getFallbackCatalogue(): ?self;\n\n    /**\n     * Returns an array of resources loaded to build this collection.\n     *\n     * @return ResourceInterface[]\n     */\n    public function getResources(): array;\n\n    /**\n     * Adds a resource for this collection.\n     */\n    public function addResource(ResourceInterface $resource): void;\n}\n"
        },
        {
          "name": "MetadataAwareInterface.php",
          "type": "blob",
          "size": 1.34375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\n/**\n * This interface is used to get, set, and delete metadata about the translation messages.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\ninterface MetadataAwareInterface\n{\n    /**\n     * Gets metadata for the given domain and key.\n     *\n     * Passing an empty domain will return an array with all metadata indexed by\n     * domain and then by key. Passing an empty key will return an array with all\n     * metadata for the given domain.\n     *\n     * @return mixed The value that was set or an array with the domains/keys or null\n     */\n    public function getMetadata(string $key = '', string $domain = 'messages'): mixed;\n\n    /**\n     * Adds metadata to a message domain.\n     */\n    public function setMetadata(string $key, mixed $value, string $domain = 'messages'): void;\n\n    /**\n     * Deletes metadata for the given key and domain.\n     *\n     * Passing an empty domain will delete all metadata. Passing an empty key will\n     * delete all metadata for the given domain.\n     */\n    public function deleteMetadata(string $key = '', string $domain = 'messages'): void;\n}\n"
        },
        {
          "name": "Provider",
          "type": "tree",
          "content": null
        },
        {
          "name": "PseudoLocalizationTranslator.php",
          "type": "blob",
          "size": 11.7607421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\nuse Symfony\\Component\\Translation\\Exception\\LogicException;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * This translator should only be used in a development environment.\n */\nfinal class PseudoLocalizationTranslator implements TranslatorInterface, TranslatorBagInterface\n{\n    private const EXPANSION_CHARACTER = '~';\n\n    private bool $accents;\n    private float $expansionFactor;\n    private bool $brackets;\n    private bool $parseHTML;\n\n    /**\n     * @var string[]\n     */\n    private array $localizableHTMLAttributes;\n\n    /**\n     * Available options:\n     *  * accents:\n     *      type: boolean\n     *      default: true\n     *      description: replace ASCII characters of the translated string with accented versions or similar characters\n     *      example: if true, \"foo\" => \"ƒöö\".\n     *\n     *  * expansion_factor:\n     *      type: float\n     *      default: 1\n     *      validation: it must be greater than or equal to 1\n     *      description: expand the translated string by the given factor with spaces and tildes\n     *      example: if 2, \"foo\" => \"~foo ~\"\n     *\n     *  * brackets:\n     *      type: boolean\n     *      default: true\n     *      description: wrap the translated string with brackets\n     *      example: if true, \"foo\" => \"[foo]\"\n     *\n     *  * parse_html:\n     *      type: boolean\n     *      default: false\n     *      description: parse the translated string as HTML - looking for HTML tags has a performance impact but allows to preserve them from alterations - it also allows to compute the visible translated string length which is useful to correctly expand ot when it contains HTML\n     *      warning: unclosed tags are unsupported, they will be fixed (closed) by the parser - eg, \"foo <div>bar\" => \"foo <div>bar</div>\"\n     *\n     *  * localizable_html_attributes:\n     *      type: string[]\n     *      default: []\n     *      description: the list of HTML attributes whose values can be altered - it is only useful when the \"parse_html\" option is set to true\n     *      example: if [\"title\"], and with the \"accents\" option set to true, \"<a href=\"#\" title=\"Go to your profile\">Profile</a>\" => \"<a href=\"#\" title=\"Ĝö ţö ýöûŕ þŕöƒîļé\">Þŕöƒîļé</a>\" - if \"title\" was not in the \"localizable_html_attributes\" list, the title attribute data would be left unchanged.\n     */\n    public function __construct(\n        private TranslatorInterface $translator,\n        array $options = [],\n    ) {\n        $this->translator = $translator;\n        $this->accents = $options['accents'] ?? true;\n\n        if (1.0 > ($this->expansionFactor = $options['expansion_factor'] ?? 1.0)) {\n            throw new \\InvalidArgumentException('The expansion factor must be greater than or equal to 1.');\n        }\n\n        $this->brackets = $options['brackets'] ?? true;\n\n        $this->parseHTML = $options['parse_html'] ?? false;\n        if ($this->parseHTML && !$this->accents && 1.0 === $this->expansionFactor) {\n            $this->parseHTML = false;\n        }\n\n        $this->localizableHTMLAttributes = $options['localizable_html_attributes'] ?? [];\n    }\n\n    public function trans(string $id, array $parameters = [], ?string $domain = null, ?string $locale = null): string\n    {\n        $trans = '';\n        $visibleText = '';\n\n        foreach ($this->getParts($this->translator->trans($id, $parameters, $domain, $locale)) as [$visible, $localizable, $text]) {\n            if ($visible) {\n                $visibleText .= $text;\n            }\n\n            if (!$localizable) {\n                $trans .= $text;\n\n                continue;\n            }\n\n            $this->addAccents($trans, $text);\n        }\n\n        $this->expand($trans, $visibleText);\n\n        $this->addBrackets($trans);\n\n        return $trans;\n    }\n\n    public function getLocale(): string\n    {\n        return $this->translator->getLocale();\n    }\n\n    public function getCatalogue(?string $locale = null): MessageCatalogueInterface\n    {\n        if (!$this->translator instanceof TranslatorBagInterface) {\n            throw new LogicException(\\sprintf('The \"%s()\" method cannot be called as the wrapped translator class \"%s\" does not implement the \"%s\".', __METHOD__, $this->translator::class, TranslatorBagInterface::class));\n        }\n\n        return $this->translator->getCatalogue($locale);\n    }\n\n    public function getCatalogues(): array\n    {\n        if (!$this->translator instanceof TranslatorBagInterface) {\n            throw new LogicException(\\sprintf('The \"%s()\" method cannot be called as the wrapped translator class \"%s\" does not implement the \"%s\".', __METHOD__, $this->translator::class, TranslatorBagInterface::class));\n        }\n\n        return $this->translator->getCatalogues();\n    }\n\n    private function getParts(string $originalTrans): array\n    {\n        if (!$this->parseHTML) {\n            return [[true, true, $originalTrans]];\n        }\n\n        $html = mb_encode_numericentity($originalTrans, [0x80, 0x10FFFF, 0, 0x1FFFFF], mb_detect_encoding($originalTrans, null, true) ?: 'UTF-8');\n\n        $useInternalErrors = libxml_use_internal_errors(true);\n\n        $dom = new \\DOMDocument();\n        $dom->loadHTML('<trans>'.$html.'</trans>');\n\n        libxml_clear_errors();\n        libxml_use_internal_errors($useInternalErrors);\n\n        return $this->parseNode($dom->childNodes->item(1)->childNodes->item(0)->childNodes->item(0));\n    }\n\n    private function parseNode(\\DOMNode $node): array\n    {\n        $parts = [];\n\n        foreach ($node->childNodes as $childNode) {\n            if (!$childNode instanceof \\DOMElement) {\n                $parts[] = [true, true, $childNode->nodeValue];\n\n                continue;\n            }\n\n            $parts[] = [false, false, '<'.$childNode->tagName];\n\n            /** @var \\DOMAttr $attribute */\n            foreach ($childNode->attributes as $attribute) {\n                $parts[] = [false, false, ' '.$attribute->nodeName.'=\"'];\n\n                $localizableAttribute = \\in_array($attribute->nodeName, $this->localizableHTMLAttributes, true);\n                foreach (preg_split('/(&(?:amp|quot|#039|lt|gt);+)/', htmlspecialchars($attribute->nodeValue, \\ENT_QUOTES, 'UTF-8'), -1, \\PREG_SPLIT_DELIM_CAPTURE) as $i => $match) {\n                    if ('' === $match) {\n                        continue;\n                    }\n\n                    $parts[] = [false, $localizableAttribute && 0 === $i % 2, $match];\n                }\n\n                $parts[] = [false, false, '\"'];\n            }\n\n            $parts[] = [false, false, '>'];\n\n            $parts = array_merge($parts, $this->parseNode($childNode, $parts));\n\n            $parts[] = [false, false, '</'.$childNode->tagName.'>'];\n        }\n\n        return $parts;\n    }\n\n    private function addAccents(string &$trans, string $text): void\n    {\n        $trans .= $this->accents ? strtr($text, [\n            ' ' => ' ',\n            '!' => '¡',\n            '\"' => '″',\n            '#' => '♯',\n            '$' => '€',\n            '%' => '‰',\n            '&' => '⅋',\n            '\\'' => '´',\n            '(' => '{',\n            ')' => '}',\n            '*' => '⁎',\n            '+' => '⁺',\n            ',' => '،',\n            '-' => '‐',\n            '.' => '·',\n            '/' => '⁄',\n            '0' => '⓪',\n            '1' => '①',\n            '2' => '②',\n            '3' => '③',\n            '4' => '④',\n            '5' => '⑤',\n            '6' => '⑥',\n            '7' => '⑦',\n            '8' => '⑧',\n            '9' => '⑨',\n            ':' => '∶',\n            ';' => '⁏',\n            '<' => '≤',\n            '=' => '≂',\n            '>' => '≥',\n            '?' => '¿',\n            '@' => '՞',\n            'A' => 'Å',\n            'B' => 'Ɓ',\n            'C' => 'Ç',\n            'D' => 'Ð',\n            'E' => 'É',\n            'F' => 'Ƒ',\n            'G' => 'Ĝ',\n            'H' => 'Ĥ',\n            'I' => 'Î',\n            'J' => 'Ĵ',\n            'K' => 'Ķ',\n            'L' => 'Ļ',\n            'M' => 'Ṁ',\n            'N' => 'Ñ',\n            'O' => 'Ö',\n            'P' => 'Þ',\n            'Q' => 'Ǫ',\n            'R' => 'Ŕ',\n            'S' => 'Š',\n            'T' => 'Ţ',\n            'U' => 'Û',\n            'V' => 'Ṽ',\n            'W' => 'Ŵ',\n            'X' => 'Ẋ',\n            'Y' => 'Ý',\n            'Z' => 'Ž',\n            '[' => '⁅',\n            '\\\\' => '∖',\n            ']' => '⁆',\n            '^' => '˄',\n            '_' => '‿',\n            '`' => '‵',\n            'a' => 'å',\n            'b' => 'ƀ',\n            'c' => 'ç',\n            'd' => 'ð',\n            'e' => 'é',\n            'f' => 'ƒ',\n            'g' => 'ĝ',\n            'h' => 'ĥ',\n            'i' => 'î',\n            'j' => 'ĵ',\n            'k' => 'ķ',\n            'l' => 'ļ',\n            'm' => 'ɱ',\n            'n' => 'ñ',\n            'o' => 'ö',\n            'p' => 'þ',\n            'q' => 'ǫ',\n            'r' => 'ŕ',\n            's' => 'š',\n            't' => 'ţ',\n            'u' => 'û',\n            'v' => 'ṽ',\n            'w' => 'ŵ',\n            'x' => 'ẋ',\n            'y' => 'ý',\n            'z' => 'ž',\n            '{' => '(',\n            '|' => '¦',\n            '}' => ')',\n            '~' => '˞',\n        ]) : $text;\n    }\n\n    private function expand(string &$trans, string $visibleText): void\n    {\n        if (1.0 >= $this->expansionFactor) {\n            return;\n        }\n\n        $visibleLength = $this->strlen($visibleText);\n        $missingLength = (int) ceil($visibleLength * $this->expansionFactor) - $visibleLength;\n        if ($this->brackets) {\n            $missingLength -= 2;\n        }\n\n        if (0 >= $missingLength) {\n            return;\n        }\n\n        $words = [];\n        $wordsCount = 0;\n        foreach (preg_split('/ +/', $visibleText, -1, \\PREG_SPLIT_NO_EMPTY) as $word) {\n            $wordLength = $this->strlen($word);\n\n            if ($wordLength >= $missingLength) {\n                continue;\n            }\n\n            if (!isset($words[$wordLength])) {\n                $words[$wordLength] = 0;\n            }\n\n            ++$words[$wordLength];\n            ++$wordsCount;\n        }\n\n        if (!$words) {\n            $trans .= 1 === $missingLength ? self::EXPANSION_CHARACTER : ' '.str_repeat(self::EXPANSION_CHARACTER, $missingLength - 1);\n\n            return;\n        }\n\n        arsort($words, \\SORT_NUMERIC);\n\n        $longestWordLength = max(array_keys($words));\n\n        while (true) {\n            $r = mt_rand(1, $wordsCount);\n\n            foreach ($words as $length => $count) {\n                $r -= $count;\n                if ($r <= 0) {\n                    break;\n                }\n            }\n\n            $trans .= ' '.str_repeat(self::EXPANSION_CHARACTER, $length);\n\n            $missingLength -= $length + 1;\n\n            if (0 === $missingLength) {\n                return;\n            }\n\n            while ($longestWordLength >= $missingLength) {\n                $wordsCount -= $words[$longestWordLength];\n                unset($words[$longestWordLength]);\n\n                if (!$words) {\n                    $trans .= 1 === $missingLength ? self::EXPANSION_CHARACTER : ' '.str_repeat(self::EXPANSION_CHARACTER, $missingLength - 1);\n\n                    return;\n                }\n\n                $longestWordLength = max(array_keys($words));\n            }\n        }\n    }\n\n    private function addBrackets(string &$trans): void\n    {\n        if (!$this->brackets) {\n            return;\n        }\n\n        $trans = '['.$trans.']';\n    }\n\n    private function strlen(string $s): int\n    {\n        return false === ($encoding = mb_detect_encoding($s, null, true)) ? \\strlen($s) : mb_strlen($s, $encoding);\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.2353515625,
          "content": "Translation Component\n=====================\n\nThe Translation component provides tools to internationalize your application.\n\nGetting Started\n---------------\n\n```bash\ncomposer require symfony/translation\n```\n\n```php\nuse Symfony\\Component\\Translation\\Translator;\nuse Symfony\\Component\\Translation\\Loader\\ArrayLoader;\n\n$translator = new Translator('fr_FR');\n$translator->addLoader('array', new ArrayLoader());\n$translator->addResource('array', [\n    'Hello World!' => 'Bonjour !',\n], 'fr_FR');\n\necho $translator->trans('Hello World!'); // outputs « Bonjour ! »\n```\n\nSponsor\n-------\n\nThe Translation component for Symfony 7.1 is [backed][1] by:\n\n * [Crowdin][2], a cloud-based localization management software helping teams to go global and stay agile.\n\nHelp Symfony by [sponsoring][3] its development!\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/translation.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n\n[1]: https://symfony.com/backers\n[2]: https://crowdin.com\n[3]: https://symfony.com/sponsor\n"
        },
        {
          "name": "Reader",
          "type": "tree",
          "content": null
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "Test",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "TranslatableMessage.php",
          "type": "blob",
          "size": 1.365234375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\nuse Symfony\\Contracts\\Translation\\TranslatableInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * @author Nate Wiebe <nate@northern.co>\n */\nclass TranslatableMessage implements TranslatableInterface\n{\n    public function __construct(\n        private string $message,\n        private array $parameters = [],\n        private ?string $domain = null,\n    ) {\n    }\n\n    public function __toString(): string\n    {\n        return $this->getMessage();\n    }\n\n    public function getMessage(): string\n    {\n        return $this->message;\n    }\n\n    public function getParameters(): array\n    {\n        return $this->parameters;\n    }\n\n    public function getDomain(): ?string\n    {\n        return $this->domain;\n    }\n\n    public function trans(TranslatorInterface $translator, ?string $locale = null): string\n    {\n        return $translator->trans($this->getMessage(), array_map(\n            static fn ($parameter) => $parameter instanceof TranslatableInterface ? $parameter->trans($translator, $locale) : $parameter,\n            $this->getParameters()\n        ), $this->getDomain(), $locale);\n    }\n}\n"
        },
        {
          "name": "Translator.php",
          "type": "blob",
          "size": 13.771484375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\nuse Symfony\\Component\\Config\\ConfigCacheFactory;\nuse Symfony\\Component\\Config\\ConfigCacheFactoryInterface;\nuse Symfony\\Component\\Config\\ConfigCacheInterface;\nuse Symfony\\Component\\Translation\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Translation\\Exception\\NotFoundResourceException;\nuse Symfony\\Component\\Translation\\Exception\\RuntimeException;\nuse Symfony\\Component\\Translation\\Formatter\\IntlFormatterInterface;\nuse Symfony\\Component\\Translation\\Formatter\\MessageFormatter;\nuse Symfony\\Component\\Translation\\Formatter\\MessageFormatterInterface;\nuse Symfony\\Component\\Translation\\Loader\\LoaderInterface;\nuse Symfony\\Contracts\\Translation\\LocaleAwareInterface;\nuse Symfony\\Contracts\\Translation\\TranslatableInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(MessageCatalogue::class);\n\n/**\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Translator implements TranslatorInterface, TranslatorBagInterface, LocaleAwareInterface\n{\n    /**\n     * @var MessageCatalogueInterface[]\n     */\n    protected array $catalogues = [];\n\n    private string $locale;\n\n    /**\n     * @var string[]\n     */\n    private array $fallbackLocales = [];\n\n    /**\n     * @var LoaderInterface[]\n     */\n    private array $loaders = [];\n\n    private array $resources = [];\n\n    private MessageFormatterInterface $formatter;\n\n    private ?ConfigCacheFactoryInterface $configCacheFactory;\n\n    private array $parentLocales;\n\n    private bool $hasIntlFormatter;\n\n    /**\n     * @throws InvalidArgumentException If a locale contains invalid characters\n     */\n    public function __construct(\n        string $locale,\n        ?MessageFormatterInterface $formatter = null,\n        private ?string $cacheDir = null,\n        private bool $debug = false,\n        private array $cacheVary = [],\n    ) {\n        $this->setLocale($locale);\n\n        $this->formatter = $formatter ??= new MessageFormatter();\n        $this->hasIntlFormatter = $formatter instanceof IntlFormatterInterface;\n    }\n\n    public function setConfigCacheFactory(ConfigCacheFactoryInterface $configCacheFactory): void\n    {\n        $this->configCacheFactory = $configCacheFactory;\n    }\n\n    /**\n     * Adds a Loader.\n     *\n     * @param string $format The name of the loader (@see addResource())\n     */\n    public function addLoader(string $format, LoaderInterface $loader): void\n    {\n        $this->loaders[$format] = $loader;\n    }\n\n    /**\n     * Adds a Resource.\n     *\n     * @param string $format   The name of the loader (@see addLoader())\n     * @param mixed  $resource The resource name\n     *\n     * @throws InvalidArgumentException If the locale contains invalid characters\n     */\n    public function addResource(string $format, mixed $resource, string $locale, ?string $domain = null): void\n    {\n        $domain ??= 'messages';\n\n        $this->assertValidLocale($locale);\n        $locale ?: $locale = class_exists(\\Locale::class) ? \\Locale::getDefault() : 'en';\n\n        $this->resources[$locale][] = [$format, $resource, $domain];\n\n        if (\\in_array($locale, $this->fallbackLocales, true)) {\n            $this->catalogues = [];\n        } else {\n            unset($this->catalogues[$locale]);\n        }\n    }\n\n    public function setLocale(string $locale): void\n    {\n        $this->assertValidLocale($locale);\n        $this->locale = $locale;\n    }\n\n    public function getLocale(): string\n    {\n        return $this->locale ?: (class_exists(\\Locale::class) ? \\Locale::getDefault() : 'en');\n    }\n\n    /**\n     * Sets the fallback locales.\n     *\n     * @param string[] $locales\n     *\n     * @throws InvalidArgumentException If a locale contains invalid characters\n     */\n    public function setFallbackLocales(array $locales): void\n    {\n        // needed as the fallback locales are linked to the already loaded catalogues\n        $this->catalogues = [];\n\n        foreach ($locales as $locale) {\n            $this->assertValidLocale($locale);\n        }\n\n        $this->fallbackLocales = $this->cacheVary['fallback_locales'] = $locales;\n    }\n\n    /**\n     * Gets the fallback locales.\n     *\n     * @internal\n     */\n    public function getFallbackLocales(): array\n    {\n        return $this->fallbackLocales;\n    }\n\n    public function trans(?string $id, array $parameters = [], ?string $domain = null, ?string $locale = null): string\n    {\n        if (null === $id || '' === $id) {\n            return '';\n        }\n\n        $domain ??= 'messages';\n\n        $catalogue = $this->getCatalogue($locale);\n        $locale = $catalogue->getLocale();\n        while (!$catalogue->defines($id, $domain)) {\n            if ($cat = $catalogue->getFallbackCatalogue()) {\n                $catalogue = $cat;\n                $locale = $catalogue->getLocale();\n            } else {\n                break;\n            }\n        }\n\n        $parameters = array_map(fn ($parameter) => $parameter instanceof TranslatableInterface ? $parameter->trans($this, $locale) : $parameter, $parameters);\n\n        $len = \\strlen(MessageCatalogue::INTL_DOMAIN_SUFFIX);\n        if ($this->hasIntlFormatter\n            && ($catalogue->defines($id, $domain.MessageCatalogue::INTL_DOMAIN_SUFFIX)\n            || (\\strlen($domain) > $len && 0 === substr_compare($domain, MessageCatalogue::INTL_DOMAIN_SUFFIX, -$len, $len)))\n        ) {\n            return $this->formatter->formatIntl($catalogue->get($id, $domain), $locale, $parameters);\n        }\n\n        return $this->formatter->format($catalogue->get($id, $domain), $locale, $parameters);\n    }\n\n    public function getCatalogue(?string $locale = null): MessageCatalogueInterface\n    {\n        if (!$locale) {\n            $locale = $this->getLocale();\n        } else {\n            $this->assertValidLocale($locale);\n        }\n\n        if (!isset($this->catalogues[$locale])) {\n            $this->loadCatalogue($locale);\n        }\n\n        return $this->catalogues[$locale];\n    }\n\n    public function getCatalogues(): array\n    {\n        return array_values($this->catalogues);\n    }\n\n    /**\n     * Gets the loaders.\n     *\n     * @return LoaderInterface[]\n     */\n    protected function getLoaders(): array\n    {\n        return $this->loaders;\n    }\n\n    protected function loadCatalogue(string $locale): void\n    {\n        if (null === $this->cacheDir) {\n            $this->initializeCatalogue($locale);\n        } else {\n            $this->initializeCacheCatalogue($locale);\n        }\n    }\n\n    protected function initializeCatalogue(string $locale): void\n    {\n        $this->assertValidLocale($locale);\n\n        try {\n            $this->doLoadCatalogue($locale);\n        } catch (NotFoundResourceException $e) {\n            if (!$this->computeFallbackLocales($locale)) {\n                throw $e;\n            }\n        }\n        $this->loadFallbackCatalogues($locale);\n    }\n\n    private function initializeCacheCatalogue(string $locale): void\n    {\n        if (isset($this->catalogues[$locale])) {\n            /* Catalogue already initialized. */\n            return;\n        }\n\n        $this->assertValidLocale($locale);\n        $cache = $this->getConfigCacheFactory()->cache($this->getCatalogueCachePath($locale),\n            function (ConfigCacheInterface $cache) use ($locale) {\n                $this->dumpCatalogue($locale, $cache);\n            }\n        );\n\n        if (isset($this->catalogues[$locale])) {\n            /* Catalogue has been initialized as it was written out to cache. */\n            return;\n        }\n\n        /* Read catalogue from cache. */\n        $this->catalogues[$locale] = include $cache->getPath();\n    }\n\n    private function dumpCatalogue(string $locale, ConfigCacheInterface $cache): void\n    {\n        $this->initializeCatalogue($locale);\n        $fallbackContent = $this->getFallbackContent($this->catalogues[$locale]);\n\n        $content = \\sprintf(<<<EOF\n<?php\n\nuse Symfony\\Component\\Translation\\MessageCatalogue;\n\n\\$catalogue = new MessageCatalogue('%s', %s);\n\n%s\nreturn \\$catalogue;\n\nEOF\n            ,\n            $locale,\n            var_export($this->getAllMessages($this->catalogues[$locale]), true),\n            $fallbackContent\n        );\n\n        $cache->write($content, $this->catalogues[$locale]->getResources());\n    }\n\n    private function getFallbackContent(MessageCatalogue $catalogue): string\n    {\n        $fallbackContent = '';\n        $current = '';\n        $replacementPattern = '/[^a-z0-9_]/i';\n        $fallbackCatalogue = $catalogue->getFallbackCatalogue();\n        while ($fallbackCatalogue) {\n            $fallback = $fallbackCatalogue->getLocale();\n            $fallbackSuffix = ucfirst(preg_replace($replacementPattern, '_', $fallback));\n            $currentSuffix = ucfirst(preg_replace($replacementPattern, '_', $current));\n\n            $fallbackContent .= \\sprintf(<<<'EOF'\n$catalogue%s = new MessageCatalogue('%s', %s);\n$catalogue%s->addFallbackCatalogue($catalogue%s);\n\nEOF\n                ,\n                $fallbackSuffix,\n                $fallback,\n                var_export($this->getAllMessages($fallbackCatalogue), true),\n                $currentSuffix,\n                $fallbackSuffix\n            );\n            $current = $fallbackCatalogue->getLocale();\n            $fallbackCatalogue = $fallbackCatalogue->getFallbackCatalogue();\n        }\n\n        return $fallbackContent;\n    }\n\n    private function getCatalogueCachePath(string $locale): string\n    {\n        return $this->cacheDir.'/catalogue.'.$locale.'.'.strtr(substr(base64_encode(hash('xxh128', serialize($this->cacheVary), true)), 0, 7), '/', '_').'.php';\n    }\n\n    /**\n     * @internal\n     */\n    protected function doLoadCatalogue(string $locale): void\n    {\n        $this->catalogues[$locale] = new MessageCatalogue($locale);\n\n        if (isset($this->resources[$locale])) {\n            foreach ($this->resources[$locale] as $resource) {\n                if (!isset($this->loaders[$resource[0]])) {\n                    if (\\is_string($resource[1])) {\n                        throw new RuntimeException(\\sprintf('No loader is registered for the \"%s\" format when loading the \"%s\" resource.', $resource[0], $resource[1]));\n                    }\n\n                    throw new RuntimeException(\\sprintf('No loader is registered for the \"%s\" format.', $resource[0]));\n                }\n                $this->catalogues[$locale]->addCatalogue($this->loaders[$resource[0]]->load($resource[1], $locale, $resource[2]));\n            }\n        }\n    }\n\n    private function loadFallbackCatalogues(string $locale): void\n    {\n        $current = $this->catalogues[$locale];\n\n        foreach ($this->computeFallbackLocales($locale) as $fallback) {\n            if (!isset($this->catalogues[$fallback])) {\n                $this->initializeCatalogue($fallback);\n            }\n\n            $fallbackCatalogue = new MessageCatalogue($fallback, $this->getAllMessages($this->catalogues[$fallback]));\n            foreach ($this->catalogues[$fallback]->getResources() as $resource) {\n                $fallbackCatalogue->addResource($resource);\n            }\n            $current->addFallbackCatalogue($fallbackCatalogue);\n            $current = $fallbackCatalogue;\n        }\n    }\n\n    protected function computeFallbackLocales(string $locale): array\n    {\n        $this->parentLocales ??= json_decode(file_get_contents(__DIR__.'/Resources/data/parents.json'), true);\n\n        $originLocale = $locale;\n        $locales = [];\n\n        while ($locale) {\n            $parent = $this->parentLocales[$locale] ?? null;\n\n            if ($parent) {\n                $locale = 'root' !== $parent ? $parent : null;\n            } elseif (\\function_exists('locale_parse')) {\n                $localeSubTags = locale_parse($locale);\n                $locale = null;\n                if (1 < \\count($localeSubTags)) {\n                    array_pop($localeSubTags);\n                    $locale = locale_compose($localeSubTags) ?: null;\n                }\n            } elseif ($i = strrpos($locale, '_') ?: strrpos($locale, '-')) {\n                $locale = substr($locale, 0, $i);\n            } else {\n                $locale = null;\n            }\n\n            if (null !== $locale) {\n                $locales[] = $locale;\n            }\n        }\n\n        foreach ($this->fallbackLocales as $fallback) {\n            if ($fallback === $originLocale) {\n                continue;\n            }\n\n            $locales[] = $fallback;\n        }\n\n        return array_unique($locales);\n    }\n\n    /**\n     * Asserts that the locale is valid, throws an Exception if not.\n     *\n     * @throws InvalidArgumentException If the locale contains invalid characters\n     */\n    protected function assertValidLocale(string $locale): void\n    {\n        if (!preg_match('/^[a-z0-9@_\\\\.\\\\-]*$/i', $locale)) {\n            throw new InvalidArgumentException(\\sprintf('Invalid \"%s\" locale.', $locale));\n        }\n    }\n\n    /**\n     * Provides the ConfigCache factory implementation, falling back to a\n     * default implementation if necessary.\n     */\n    private function getConfigCacheFactory(): ConfigCacheFactoryInterface\n    {\n        $this->configCacheFactory ??= new ConfigCacheFactory($this->debug);\n\n        return $this->configCacheFactory;\n    }\n\n    private function getAllMessages(MessageCatalogueInterface $catalogue): array\n    {\n        $allMessages = [];\n\n        foreach ($catalogue->all() as $domain => $messages) {\n            if ($intlMessages = $catalogue->all($domain.MessageCatalogue::INTL_DOMAIN_SUFFIX)) {\n                $allMessages[$domain.MessageCatalogue::INTL_DOMAIN_SUFFIX] = $intlMessages;\n                $messages = array_diff_key($messages, $intlMessages);\n            }\n            if ($messages) {\n                $allMessages[$domain] = $messages;\n            }\n        }\n\n        return $allMessages;\n    }\n}\n"
        },
        {
          "name": "TranslatorBag.php",
          "type": "blob",
          "size": 3.0537109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\nuse Symfony\\Component\\Translation\\Catalogue\\AbstractOperation;\nuse Symfony\\Component\\Translation\\Catalogue\\TargetOperation;\n\nfinal class TranslatorBag implements TranslatorBagInterface\n{\n    /** @var MessageCatalogue[] */\n    private array $catalogues = [];\n\n    public function addCatalogue(MessageCatalogue $catalogue): void\n    {\n        if (null !== $existingCatalogue = $this->getCatalogue($catalogue->getLocale())) {\n            $catalogue->addCatalogue($existingCatalogue);\n        }\n\n        $this->catalogues[$catalogue->getLocale()] = $catalogue;\n    }\n\n    public function addBag(TranslatorBagInterface $bag): void\n    {\n        foreach ($bag->getCatalogues() as $catalogue) {\n            $this->addCatalogue($catalogue);\n        }\n    }\n\n    public function getCatalogue(?string $locale = null): MessageCatalogueInterface\n    {\n        if (null === $locale || !isset($this->catalogues[$locale])) {\n            $this->catalogues[$locale] = new MessageCatalogue($locale);\n        }\n\n        return $this->catalogues[$locale];\n    }\n\n    public function getCatalogues(): array\n    {\n        return array_values($this->catalogues);\n    }\n\n    public function diff(TranslatorBagInterface $diffBag): self\n    {\n        $diff = new self();\n\n        foreach ($this->catalogues as $locale => $catalogue) {\n            if (null === $diffCatalogue = $diffBag->getCatalogue($locale)) {\n                $diff->addCatalogue($catalogue);\n\n                continue;\n            }\n\n            $operation = new TargetOperation($diffCatalogue, $catalogue);\n            $operation->moveMessagesToIntlDomainsIfPossible(AbstractOperation::NEW_BATCH);\n            $newCatalogue = new MessageCatalogue($locale);\n\n            foreach ($catalogue->getDomains() as $domain) {\n                $newCatalogue->add($operation->getNewMessages($domain), $domain);\n            }\n\n            $diff->addCatalogue($newCatalogue);\n        }\n\n        return $diff;\n    }\n\n    public function intersect(TranslatorBagInterface $intersectBag): self\n    {\n        $diff = new self();\n\n        foreach ($this->catalogues as $locale => $catalogue) {\n            if (null === $intersectCatalogue = $intersectBag->getCatalogue($locale)) {\n                continue;\n            }\n\n            $operation = new TargetOperation($catalogue, $intersectCatalogue);\n            $operation->moveMessagesToIntlDomainsIfPossible(AbstractOperation::OBSOLETE_BATCH);\n            $obsoleteCatalogue = new MessageCatalogue($locale);\n\n            foreach ($operation->getDomains() as $domain) {\n                $obsoleteCatalogue->add(\n                    array_diff($operation->getMessages($domain), $operation->getNewMessages($domain)),\n                    $domain\n                );\n            }\n\n            $diff->addCatalogue($obsoleteCatalogue);\n        }\n\n        return $diff;\n    }\n}\n"
        },
        {
          "name": "TranslatorBagInterface.php",
          "type": "blob",
          "size": 0.8955078125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Translation;\n\nuse Symfony\\Component\\Translation\\Exception\\InvalidArgumentException;\n\n/**\n * @author Abdellatif Ait boudad <a.aitboudad@gmail.com>\n */\ninterface TranslatorBagInterface\n{\n    /**\n     * Gets the catalogue by locale.\n     *\n     * @param string|null $locale The locale or null to use the default\n     *\n     * @throws InvalidArgumentException If the locale contains invalid characters\n     */\n    public function getCatalogue(?string $locale = null): MessageCatalogueInterface;\n\n    /**\n     * Returns all catalogues of the instance.\n     *\n     * @return MessageCatalogueInterface[]\n     */\n    public function getCatalogues(): array;\n}\n"
        },
        {
          "name": "Util",
          "type": "tree",
          "content": null
        },
        {
          "name": "Writer",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.8525390625,
          "content": "{\n    \"name\": \"symfony/translation\",\n    \"type\": \"library\",\n    \"description\": \"Provides tools to internationalize your application\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/polyfill-mbstring\": \"~1.0\",\n        \"symfony/translation-contracts\": \"^2.5|^3.0\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3\"\n    },\n    \"require-dev\": {\n        \"nikic/php-parser\": \"^4.18|^5.0\",\n        \"symfony/config\": \"^6.4|^7.0\",\n        \"symfony/console\": \"^6.4|^7.0\",\n        \"symfony/dependency-injection\": \"^6.4|^7.0\",\n        \"symfony/http-client-contracts\": \"^2.5|^3.0\",\n        \"symfony/http-kernel\": \"^6.4|^7.0\",\n        \"symfony/intl\": \"^6.4|^7.0\",\n        \"symfony/polyfill-intl-icu\": \"^1.21\",\n        \"symfony/routing\": \"^6.4|^7.0\",\n        \"symfony/service-contracts\": \"^2.5|^3\",\n        \"symfony/yaml\": \"^6.4|^7.0\",\n        \"symfony/finder\": \"^6.4|^7.0\",\n        \"psr/log\": \"^1|^2|^3\"\n    },\n    \"conflict\": {\n        \"symfony/config\": \"<6.4\",\n        \"symfony/dependency-injection\": \"<6.4\",\n        \"symfony/http-client-contracts\": \"<2.5\",\n        \"symfony/http-kernel\": \"<6.4\",\n        \"symfony/service-contracts\": \"<2.5\",\n        \"symfony/twig-bundle\": \"<6.4\",\n        \"symfony/yaml\": \"<6.4\",\n        \"symfony/console\": \"<6.4\"\n    },\n    \"provide\": {\n        \"symfony/translation-implementation\": \"2.3|3.0\"\n    },\n    \"autoload\": {\n        \"files\": [ \"Resources/functions.php\" ],\n        \"psr-4\": { \"Symfony\\\\Component\\\\Translation\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.802734375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Translation Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}