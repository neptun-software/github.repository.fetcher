{
  "metadata": {
    "timestamp": 1736712267172,
    "page": 27,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "phpspec/prophecy",
      "stars": 8529,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.19921875,
          "content": "root = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\nindent_size = 4\nindent_style = space\ninsert_final_newline = true\ntab_width = 4\ntrim_trailing_whitespace = true\n\n[.github/workflows/*.yml]\nindent_size = 2\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.3125,
          "content": "/.editorconfig    export-ignore\n/.gitattributes   export-ignore\n/.gitignore       export-ignore\n/CONTRIBUTING.md  export-ignore\n/.github/         export-ignore\n/fixtures/        export-ignore\n/phpunit.xml.dist export-ignore\n/phpstan*.neon    export-ignore\n/spec/            export-ignore\n/tests/           export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.123046875,
          "content": "*.tgz\n*.phar\n/.php-cs-fixer.cache\n/composer.lock\n/dev-tools/vendor/\n/vendor\n/phpstan.neon\n/phpunit.xml\n/.phpunit.result.cache\n"
        },
        {
          "name": ".php-cs-fixer.dist.php",
          "type": "blob",
          "size": 0.8310546875,
          "content": "<?php\n\ndeclare(strict_types=1);\n\nreturn (new PhpCsFixer\\Config())\n    ->setRiskyAllowed(false)\n    ->setRules([\n        '@PER-CS' => true,\n        'array_syntax' => false,\n        'braces_position' => [\n            'control_structures_opening_brace' => 'same_line',\n        ],\n        'concat_space' => ['spacing' => 'none'],\n        'method_argument_space' => ['on_multiline' => 'ignore'],\n        // Since PHP 7.2 is supported we can't add trailing commas in arguments, parameters and match\n        'trailing_comma_in_multiline' => ['elements' => ['arrays']],\n        'visibility_required' => false,\n    ])\n    ->setFinder(\n        (new PhpCsFixer\\Finder())\n            ->ignoreDotFiles(false)\n            ->ignoreVCSIgnored(true)\n            ->exclude(['fixtures'])\n            ->notPath(['phpstan-baseline.php'])\n            ->in(__DIR__)\n    )\n;\n"
        },
        {
          "name": "CHANGES.md",
          "type": "blob",
          "size": 13.2177734375,
          "content": "Unreleased\n==========\n\n1.20.0\n======\n\n**Added:**\n\n* Add support for PHP 8.4 (@andypost)\n\n**Fixed:**\n\n* Fix support for doubling methods using an enum case as default value of a parameter (@jdreesen)\n* Fix deprecation when doubling a class with constructor parameters (@singinwhale, @W0rma)\n* Fix deprecation warning when using phpdocumentor/reflection-docblock 5.4+ (@jrfnl)\n\n1.19.0\n======\n\n**Added:**\n\n* Allow sebastian/comparator and sebastian/recursion-context 6\n\n1.18.0 / 2023-12-07\n===================\n\n* [added] Add support for PHP 8.3 [@rajeshreeputra]\n* [changed] Improve the error when using return types that Prophecy does not support for mocking [@stof]\n* [changed] Add more precise type for static analysis [@stof]\n* [fixed] Error when comparing object arguments with integers [@lucassabreu]\n* [changed] Add PHP 8.2 to test matrix [@Jean85]\n* [Added] Allow sebastian/comparator and sebastian/recursion-context 5, and phpunit/phpunit 10 [@Jean85]\n* [docs] Switch travis status badge to GHA one [@michalbundyra]\n\n1.17.0 / 2023-02-02\n===================\n\n* [added] Add generic types for ProphecyInterface and ObjectProphecy [@stof]\n* [added] Add the conditional return type for `ObjectProphecy::getMethodProphecies` [@stof]\n* [added] Add support for doctrine/instantiator 2.0 [@stof]\n* [added] Add the ability to customize the __toString representation of a CallbackToken [@ian-zunderdorp]\n* [changed] Remove support for instantiating a MethodProphecy without its arguments [@stof]\n* [deprecated] Deprecate `\\Prophecy\\Comparator\\Factory` as `sebastian/comparator` v5 makes it parent class final [@stof]\n\n1.16.0 / 2022/11/29\n===================\n\n* [added] Allow installing with PHP 8.2 [@gquemener]\n* [added] Use shorter object IDs for object comparison [@TysonAndre]\n* [added] Support standalone false,true and null types [@kschatzle]\n* [added] Support doubling readonly classes [@gquemener]\n* [fixed] Remove workarounds for unsupported HHVM [@TysonAndre]\n* [fixed] Clear error message when doubling DNF types [@kschatzle]\n\n\n1.15.0 / 2021/12/08\n===================\n\n* [added] Support for the `static` return type [@denis-rolling-scopes]\n* [fixed] Add return types for Comparator implementations to avoid deprecation warnings from Symfony's DebugClassLoader [@stof]\n\n1.14.0 / 2021/09/16\n===================\n\n* [added] Support for static closures in will and should [@ntzm]\n* [added] Allow install on PHP 8.1 (with test suite fixes) [@javer]\n* [added] Support for the 'never' return type [@ciaranmcnulty]\n* [fixed] Better error message when doubling intersection return types [@ciaranmcnulty]\n\n1.13.0 / 2021/03/17\n===================\n\n* [added] willYield can now specify a return value [@camilledejoye]\n* [added] Prophecy exception interfaces are explicitly Throwable [@ciaranmcnulty]\n* [fixed] Argument::in() and notIn() now marked as static [@tyteen4a03]\n* [fixed] Can now double unions containing false [@ciaranmcnulty]\n* [fixed] Virtual magic methods with arguments are now doublable in PHP 8 [@ciaranmcnulty]\n\n1.12.2 / 2020/12/19\n===================\n\n* [fixed] MethodNotFoundException sometimes thrown with wrong class attached [@ciaranmcnulty]\n\n1.12.1 / 2020/10/29\n===================\n\n* [fixed] Incorrect handling of inherited 'self' return types [@ciaranmcnulty]\n\n1.12.0 / 2020/10/28\n===================\n\n* [added] PHP 8 support [@ciaranmcnulty]\n* [added] Argument::in() and Argument::notIn() [@viniciusalonso]\n* [added] Support for union and mixed types [@ciaranmcnulty]\n* [fixed] Issues caused by introduction of named parameters [@ciaranmcnulty]\n* [fixed] Issues caused by stricter rounding [@ciaranmcnulty]\n\n1.11.1 / 2020/07/08\n===================\n\n* [fixed] can't double objects with `self` type hints (@greg0ire)\n* [fixed] cloned doubes were not loosely comparable (@tkulka)\n\n1.11.0 / 2020/07/07\n===================\n\n* [changed] dropped support for PHP versions earlier than 7.2 (@ciaranmcnulty)\n* [fixed] removed use of Reflection APIs deprecated in PHP 8.0 (@Ayesh)\n\n1.10.3 / 2020/03/05\n===================\n\n* [fixed] removed fatal error when phpdocumentor/reflection-docblock 5 parses an invalid `@method` tag (@stof)\n\n1.10.2 / 2020/01/20\n===================\n\n* [added] support for new versions of `sebastian/comparator` and `sebastian/recursion-context` (@sebastianbergmann)\n\n1.10.1 / 2019/12/22\n===================\n\n* [fixed] identical callables no longer match as arguments (@ciaranmcnulty)\n\n1.10.0 / 2019/12/17\n===================\n\n* [added] shouldHaveBeenCalled evaluation happens later so un-stubbed calls don't throw (@elvetemedve)\n* [added] methods can now be doubled case-insensitively to match PHP semantics (@michalbundyra)\n* [fixed] reduced memory usage by optimising CachedDoubler (@DonCallisto)\n* [fixed] removed fatal error nesting level when comparing large objects (@scroach)\n\n1.9.0 / 2019/10/03\n==================\n\n* [added] Add willYield feature to Method Prophecy(@tkotosz)\n* [fixed] Allow `MethodProphecy::willThrow()` to accept Throwable as string (@timoschinkel )\n* [fixed] Allow new version of phpdocumentor/reflection-docblock (@ricpelo)\n\n1.8.1 / 2019/06/13\n==================\n\n* [fixed] Don't try to patch final constructors (@NiR)\n\n1.8.0 / 2018/08/05\n==================\n\n* Support for void return types without explicit will (@crellbar)\n* Clearer error message for unexpected method calls (@meridius)\n* Clearer error message for aggregate exceptions (@meridius)\n* More verbose `shouldBeCalledOnce` expectation (@olvlvl)\n* Ability to double Throwable, or methods that extend it (@ciaranmcnulty)\n* [fixed] Doubling methods where class has additional arguments to interface (@webimpress)\n* [fixed] Doubling methods where arguments are nullable but default is not null (@webimpress)\n* [fixed] Doubling magic methods on parent class (@dsnopek)\n* [fixed] Check method predictions only once (@dontub)\n* [fixed] Argument::containingString throwing error when called with non-string (@dcabrejas)\n\n1.7.6 / 2018/04/18\n==================\n\n* Allow sebastian/comparator ^3.0 (@sebastianbergmann)\n\n1.7.5 / 2018/02/11\n==================\n\n* Support for object return type hints (thanks @greg0ire)\n\n1.7.4 / 2018/02/11\n==================\n\n* Fix issues with PHP 7.2 (thanks @greg0ire)\n* Support object type hints in PHP 7.2 (thanks @@jansvoboda11)\n\n1.7.3 / 2017/11/24\n==================\n\n* Fix SplInfo ClassPatch to work with Symfony 4 (Thanks @gnugat)\n\n1.7.2 / 2017-10-04\n==================\n\n* Reverted \"check method predictions only once\" due to it breaking Spies\n\n1.7.1 / 2017-10-03\n==================\n\n* Allow PHP5 keywords methods generation on PHP7 (thanks @bycosta)\n* Allow reflection-docblock v4 (thanks @GrahamCampbell)\n* Check method predictions only once (thanks @dontub)\n* Escape file path sent to \\SplFileObjectConstructor when running on Windows (thanks @danmartin-epiphany)\n\n1.7.0 / 2017-03-02\n==================\n\n* Add full PHP 7.1 Support (thanks @prolic)\n* Allow `sebastian/comparator ^2.0` (thanks @sebastianbergmann)\n* Allow `sebastian/recursion-context ^3.0` (thanks @sebastianbergmann)\n* Allow `\\Error` instances in `ThrowPromise` (thanks @jameshalsall)\n* Support `phpspec/phpspect ^3.2` (thanks @Sam-Burns)\n* Fix failing builds (thanks @Sam-Burns)\n\n1.6.2 / 2016-11-21\n==================\n\n* Added support for detecting @method on interfaces that the class itself implements, or when the stubbed class is an interface itself (thanks @Seldaek)\n* Added support for sebastian/recursion-context 2 (thanks @sebastianbergmann)\n* Added testing on PHP 7.1 on Travis (thanks @danizord)\n* Fixed the usage of the phpunit comparator (thanks @Anyqax)\n\n1.6.1 / 2016-06-07\n==================\n\n  * Ignored empty method names in invalid `@method` phpdoc\n  * Fixed the mocking of SplFileObject\n  * Added compatibility with phpdocumentor/reflection-docblock 3\n\n1.6.0 / 2016-02-15\n==================\n\n  * Add Variadics support (thanks @pamil)\n  * Add ProphecyComparator for comparing objects that need revealing (thanks @jon-acker)\n  * Add ApproximateValueToken (thanks @dantleech)\n  * Add support for 'self' and 'parent' return type (thanks @bendavies)\n  * Add __invoke to allowed reflectable methods list (thanks @ftrrtf)\n  * Updated ExportUtil to reflect the latest changes by Sebastian (thanks @jakari)\n  * Specify the required php version for composer (thanks @jakzal)\n  * Exclude 'args' in the generated backtrace (thanks @oradwell)\n  * Fix code generation for scalar parameters (thanks @trowski)\n  * Fix missing sprintf in InvalidArgumentException __construct call (thanks @emmanuelballery)\n  * Fix phpdoc for magic methods (thanks @Tobion)\n  * Fix PhpDoc for interfaces usage (thanks @ImmRanneft)\n  * Prevent final methods from being manually extended (thanks @kamioftea)\n  * Enhance exception for invalid argument to ThrowPromise (thanks @Tobion)\n\n1.5.0 / 2015-04-27\n==================\n\n  * Add support for PHP7 scalar type hints (thanks @trowski)\n  * Add support for PHP7 return types (thanks @trowski)\n  * Update internal test suite to support PHP7\n\n1.4.1 / 2015-04-27\n==================\n\n  * Fixed bug in closure-based argument tokens (#181)\n\n1.4.0 / 2015-03-27\n==================\n\n  * Fixed errors in return type phpdocs (thanks @sobit)\n  * Fixed stringifying of hash containing one value (thanks @avant1)\n  * Improved clarity of method call expectation exception (thanks @dantleech)\n  * Add ability to specify which argument is returned in willReturnArgument (thanks @coderbyheart)\n  * Add more information to MethodNotFound exceptions (thanks @ciaranmcnulty)\n  * Support for mocking classes with methods that return references (thanks @edsonmedina)\n  * Improved object comparison (thanks @whatthejeff)\n  * Adopted '^' in composer dependencies (thanks @GrahamCampbell)\n  * Fixed non-typehinted arguments being treated as optional (thanks @whatthejeff)\n  * Magic methods are now filtered for keywords (thanks @seagoj)\n  * More readable errors for failure when expecting single calls (thanks @dantleech)\n\n1.3.1 / 2014-11-17\n==================\n\n  * Fix the edge case when failed predictions weren't recorded for `getCheckedPredictions()`\n\n1.3.0 / 2014-11-14\n==================\n\n  * Add a way to get checked predictions with `MethodProphecy::getCheckedPredictions()`\n  * Fix HHVM compatibility\n  * Remove dead code (thanks @stof)\n  * Add support for DirectoryIterators (thanks @shanethehat)\n\n1.2.0 / 2014-07-18\n==================\n\n  * Added support for doubling magic methods documented in the class phpdoc (thanks @armetiz)\n  * Fixed a segfault appearing in some cases (thanks @dmoreaulf)\n  * Fixed the doubling of methods with typehints on non-existent classes (thanks @gquemener)\n  * Added support for internal classes using keywords as method names (thanks @milan)\n  * Added IdenticalValueToken and Argument::is (thanks @florianv)\n  * Removed the usage of scalar typehints in HHVM as HHVM 3 does not support them anymore in PHP code (thanks @whatthejeff)\n\n1.1.2 / 2014-01-24\n==================\n\n  * Spy automatically promotes spied method call to an expected one\n\n1.1.1 / 2014-01-15\n==================\n\n  * Added support for HHVM\n\n1.1.0 / 2014-01-01\n==================\n\n  * Changed the generated class names to use a static counter instead of a random number\n  * Added a clss patch for ReflectionClass::newInstance to make its argument optional consistently (thanks @docteurklein)\n  * Fixed mirroring of classes with typehints on non-existent classes (thanks @docteurklein)\n  * Fixed the support of array callables in CallbackPromise and CallbackPrediction (thanks @ciaranmcnulty)\n  * Added support for properties in ObjectStateToken (thanks @adrienbrault)\n  * Added support for mocking classes with a final constructor (thanks @ciaranmcnulty)\n  * Added ArrayEveryEntryToken and Argument::withEveryEntry() (thanks @adrienbrault)\n  * Added an exception when trying to prophesize on a final method instead of ignoring silently (thanks @docteurklein)\n  * Added StringContainToken and Argument::containingString() (thanks @peterjmit)\n  * Added ``shouldNotHaveBeenCalled`` on the MethodProphecy (thanks @ciaranmcnulty)\n  * Fixed the comparison of objects in ExactValuetoken (thanks @sstok)\n  * Deprecated ``shouldNotBeenCalled`` in favor of ``shouldNotHaveBeenCalled``\n\n1.0.4 / 2013-08-10\n==================\n\n  * Better randomness for generated class names (thanks @sstok)\n  * Add support for interfaces into TypeToken and Argument::type() (thanks @sstok)\n  * Add support for old-style (method name === class name) constructors (thanks @l310 for report)\n\n1.0.3 / 2013-07-04\n==================\n\n  * Support callable typehints (thanks @stof)\n  * Do not attempt to autoload arrays when generating code (thanks @MarcoDeBortoli)\n  * New ArrayEntryToken (thanks @kagux)\n\n1.0.2 / 2013-05-19\n==================\n\n  * Logical `AND` token added (thanks @kagux)\n  * Logical `NOT` token added (thanks @kagux)\n  * Add support for setting custom constructor arguments\n  * Properly stringify hashes\n  * Record calls that throw exceptions\n  * Migrate spec suite to PhpSpec 2.0\n\n1.0.1 / 2013-04-30\n==================\n\n  * Fix broken UnexpectedCallException message\n  * Trim AggregateException message\n\n1.0.0 / 2013-04-29\n==================\n\n  * Improve exception messages\n\n1.0.0-BETA2 / 2013-04-03\n========================\n\n  * Add more debug information to CallTimes and Call prediction exception messages\n  * Fix MethodNotFoundException wrong namespace (thanks @gunnarlium)\n  * Fix some typos in the exception messages (thanks @pborreli)\n\n1.0.0-BETA1 / 2013-03-25\n========================\n\n  * Initial release\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.6728515625,
          "content": "Contributing\n------------\n\nProphecy is an open source, community-driven project. If you'd like to contribute,\nfeel free to do this, but remember to follow these few simple rules:\n\n- Make your feature addition or bug fix,\n- Add either specs or examples for any changes you're making (bugfixes or additions)\n  (please look into `spec/` folder for some examples). This is important so we don't break\n  it in a future version unintentionally,\n- Commit your code, but do not mess with `CHANGES.md`,\n\nRunning tests\n-------------\n\nMake sure that you don't break anything with your changes by running:\n\n```bash\n$> composer install --prefer-dist\n$> vendor/bin/phpspec run\n$> vendor/bin/phpunit\n```\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1220703125,
          "content": "Copyright (c) 2013 Konstantin Kudryashov <ever.zet@gmail.com>\nCopyright (c) 2013 Marcello Duarte <marcello.duarte@gmail.com>\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.2314453125,
          "content": "# Prophecy\n\n[![Stable release](https://poser.pugx.org/phpspec/prophecy/version.svg)](https://packagist.org/packages/phpspec/prophecy)\n[![Build](https://github.com/phpspec/prophecy/actions/workflows/build.yml/badge.svg)](https://github.com/phpspec/prophecy/actions/workflows/build.yml)\n\nProphecy is a highly opinionated yet very powerful and flexible PHP object mocking\nframework. Though initially it was created to fulfil phpspec2 needs, it is flexible\nenough to be used inside any testing framework out there with minimal effort.\n\n## A simple example\n\n```php\n<?php\n\nclass UserTest extends PHPUnit\\Framework\\TestCase\n{\n    private $prophet;\n\n    public function testPasswordHashing()\n    {\n        $hasher = $this->prophet->prophesize('App\\Security\\Hasher');\n        $user   = new App\\Entity\\User($hasher->reveal());\n\n        $hasher->generateHash($user, 'qwerty')->willReturn('hashed_pass');\n\n        $user->setPassword('qwerty');\n\n        $this->assertEquals('hashed_pass', $user->getPassword());\n    }\n\n    protected function setUp()\n    {\n        $this->prophet = new \\Prophecy\\Prophet;\n    }\n\n    protected function tearDown()\n    {\n        $this->prophet->checkPredictions();\n    }\n}\n```\n\n## Installation\n\n### Prerequisites\n\nProphecy requires PHP 7.2.0 or greater.\n\n### Setup through composer\n\nFirst, add Prophecy to the list of dependencies inside your `composer.json`:\n\n```json\n{\n    \"require-dev\": {\n        \"phpspec/prophecy\": \"~1.0\"\n    }\n}\n```\n\nThen simply install it with composer:\n\n```bash\n$> composer install --prefer-dist\n```\n\nYou can read more about Composer on its [official webpage](http://getcomposer.org).\n\n## How to use it\n\nFirst of all, in Prophecy every word has a logical meaning, even the name of the library\nitself (Prophecy). When you start feeling that, you'll become very fluid with this\ntool.\n\nFor example, Prophecy has been named that way because it concentrates on describing the future\nbehavior of objects with very limited knowledge about them. But as with any other prophecy,\nthose object prophecies can't create themselves - there should be a Prophet:\n\n```php\n$prophet = new Prophecy\\Prophet;\n```\n\nThe Prophet creates prophecies by *prophesizing* them:\n\n```php\n$prophecy = $prophet->prophesize();\n```\n\nThe result of the `prophesize()` method call is a new object of class `ObjectProphecy`. Yes,\nthat's your specific object prophecy, which describes how your object would behave\nin the near future. But first, you need to specify which object you're talking about,\nright?\n\n```php\n$prophecy->willExtend('stdClass');\n$prophecy->willImplement('SessionHandlerInterface');\n```\n\nThere are 2 interesting calls - `willExtend` and `willImplement`. The first one tells\nobject prophecy that our object should extend a specific class. The second one says that\nit should implement some interface. Obviously, objects in PHP can implement multiple\ninterfaces, but extend only one parent class.\n\n### Dummies\n\nOk, now we have our object prophecy. What can we do with it? First of all, we can get\nour object *dummy* by revealing its prophecy:\n\n```php\n$dummy = $prophecy->reveal();\n```\n\nThe `$dummy` variable now holds a special dummy object. Dummy objects are objects that extend\nand/or implement preset classes/interfaces by overriding all their public methods. The key\npoint about dummies is that they do not hold any logic - they just do nothing. Any method\nof the dummy will always return `null` and the dummy will never throw any exceptions.\nDummy is your friend if you don't care about the actual behavior of this double and just need\na token object to satisfy a method typehint.\n\nYou need to understand one thing - a dummy is not a prophecy. Your object prophecy is still\nassigned to `$prophecy` variable and in order to manipulate with your expectations, you\nshould work with it. `$dummy` is a dummy - a simple php object that tries to fulfil your\nprophecy.\n\n### Stubs\n\nOk, now we know how to create basic prophecies and reveal dummies from them. That's\nawesome if we don't care about our _doubles_ (objects that reflect originals)\ninteractions. If we do, we need to use *stubs* or *mocks*.\n\nA stub is an object double, which doesn't have any expectations about the object behavior,\nbut when put in specific environment, behaves in specific way. Ok, I know, it's cryptic,\nbut bear with me for a minute. Simply put, a stub is a dummy, which depending on the called\nmethod signature does different things (has logic). To create stubs in Prophecy:\n\n```php\n$prophecy->read('123')->willReturn('value');\n```\n\nOh wow. We've just made an arbitrary call on the object prophecy? Yes, we did. And this\ncall returned us a new object instance of class `MethodProphecy`. Yep, that's a specific\nmethod with arguments prophecy. Method prophecies give you the ability to create method\npromises or predictions. We'll talk about method predictions later in the _Mocks_ section.\n\n#### Promises\n\nPromises are logical blocks, that represent your fictional methods in prophecy terms\nand they are handled by the `MethodProphecy::will(PromiseInterface $promise)` method.\nAs a matter of fact, the call that we made earlier (`willReturn('value')`) is a simple\nshortcut to:\n\n```php\n$prophecy->read('123')->will(new Prophecy\\Promise\\ReturnPromise(array('value')));\n```\n\nThis promise will cause any call to our double's `read()` method with exactly one\nargument - `'123'` to always return `'value'`. But that's only for this\npromise, there's plenty others you can use:\n\n- `ReturnPromise` or `->willReturn(1)` - returns a value from a method call\n- `ReturnArgumentPromise` or `->willReturnArgument($index)` - returns the nth method argument from call\n- `ThrowPromise` or `->willThrow($exception)` - causes the method to throw specific exception\n- `CallbackPromise` or `->will($callback)` - gives you a quick way to define your own custom logic\n\nKeep in mind, that you can always add even more promises by implementing\n`Prophecy\\Promise\\PromiseInterface`.\n\n#### Method prophecies idempotency\n\nProphecy enforces same method prophecies and, as a consequence, same promises and\npredictions for the same method calls with the same arguments. This means:\n\n```php\n$methodProphecy1 = $prophecy->read('123');\n$methodProphecy2 = $prophecy->read('123');\n$methodProphecy3 = $prophecy->read('321');\n\n$methodProphecy1 === $methodProphecy2;\n$methodProphecy1 !== $methodProphecy3;\n```\n\nThat's interesting, right? Now you might ask me how would you define more complex\nbehaviors where some method call changes behavior of others. In PHPUnit or Mockery\nyou do that by predicting how many times your method will be called. In Prophecy,\nyou'll use promises for that:\n\n```php\n$user->getName()->willReturn(null);\n\n// For PHP 5.4\n$user->setName('everzet')->will(function () {\n    $this->getName()->willReturn('everzet');\n});\n\n// For PHP 5.3\n$user->setName('everzet')->will(function ($args, $user) {\n    $user->getName()->willReturn('everzet');\n});\n\n// Or\n$user->setName('everzet')->will(function ($args) use ($user) {\n    $user->getName()->willReturn('everzet');\n});\n```\n\nAnd now it doesn't matter how many times or in which order your methods are called.\nWhat matters is their behaviors and how well you faked it.\n\nNote: If the method is called several times, you can use the following syntax to return different\nvalues for each call:\n\n```php\n$prophecy->read('123')->willReturn(1, 2, 3);\n```\n\nThis feature is actually not recommended for most cases. Relying on the order of\ncalls for the same arguments tends to make test fragile, as adding one more call\ncan break everything.\n\n#### Arguments wildcarding\n\nThe previous example is awesome (at least I hope it is for you), but that's not\noptimal enough. We hardcoded `'everzet'` in our expectation. Isn't there a better\nway? In fact there is, but it involves understanding what this `'everzet'`\nactually is.\n\nYou see, even if method arguments used during method prophecy creation look\nlike simple method arguments, in reality they are not. They are argument token\nwildcards.  As a matter of fact, `->setName('everzet')` looks like a simple call just\nbecause Prophecy automatically transforms it under the hood into:\n\n```php\n$user->setName(new Prophecy\\Argument\\Token\\ExactValueToken('everzet'));\n```\n\nThose argument tokens are simple PHP classes, that implement\n`Prophecy\\Argument\\Token\\TokenInterface` and tell Prophecy how to compare real arguments\nwith your expectations. And yes, those classnames are damn big. That's why there's a\nshortcut class `Prophecy\\Argument`, which you can use to create tokens like that:\n\n```php\nuse Prophecy\\Argument;\n\n$user->setName(Argument::exact('everzet'));\n```\n\n`ExactValueToken` is not very useful in our case as it forced us to hardcode the username.\nThat's why Prophecy comes bundled with a bunch of other tokens:\n\n- `IdenticalValueToken` or `Argument::is($value)` - checks that the argument is identical to a specific value\n- `ExactValueToken` or `Argument::exact($value)` - checks that the argument matches a specific value\n- `TypeToken` or `Argument::type($typeOrClass)` - checks that the argument matches a specific type or\n  classname\n- `ObjectStateToken` or `Argument::which($method, $value)` - checks that the argument method returns\n  a specific value\n- `CallbackToken` or `Argument::that(callback)` - checks that the argument matches a custom callback\n- `AnyValueToken` or `Argument::any()` - matches any argument\n- `AnyValuesToken` or `Argument::cetera()` - matches any arguments to the rest of the signature\n- `StringContainsToken` or `Argument::containingString($value)` - checks that the argument contains a specific string value\n- `InArrayToken` or `Argument::in($array)` - checks if value is in array\n- `NotInArrayToken` or `Argument::notIn($array)` - checks if value is not in array\n\nAnd you can add even more by implementing `TokenInterface` with your own custom classes.\n\nSo, let's refactor our initial `{set,get}Name()` logic with argument tokens:\n\n```php\nuse Prophecy\\Argument;\n\n$user->getName()->willReturn(null);\n\n// For PHP 5.4\n$user->setName(Argument::type('string'))->will(function ($args) {\n    $this->getName()->willReturn($args[0]);\n});\n\n// For PHP 5.3\n$user->setName(Argument::type('string'))->will(function ($args, $user) {\n    $user->getName()->willReturn($args[0]);\n});\n\n// Or\n$user->setName(Argument::type('string'))->will(function ($args) use ($user) {\n    $user->getName()->willReturn($args[0]);\n});\n```\n\nThat's it. Now our `{set,get}Name()` prophecy will work with any string argument provided to it.\nWe've just described how our stub object should behave, even though the original object could have\nno behavior whatsoever.\n\nOne last bit about arguments now. You might ask, what happens in case of:\n\n```php\nuse Prophecy\\Argument;\n\n$user->getName()->willReturn(null);\n\n// For PHP 5.4\n$user->setName(Argument::type('string'))->will(function ($args) {\n    $this->getName()->willReturn($args[0]);\n});\n\n// For PHP 5.3\n$user->setName(Argument::type('string'))->will(function ($args, $user) {\n    $user->getName()->willReturn($args[0]);\n});\n\n// Or\n$user->setName(Argument::type('string'))->will(function ($args) use ($user) {\n    $user->getName()->willReturn($args[0]);\n});\n\n$user->setName(Argument::any())->will(function () {\n});\n```\n\nNothing. Your stub will continue behaving the way it did before. That's because of how\narguments wildcarding works. Every argument token type has a different score level, which\nwildcard then uses to calculate the final arguments match score and use the method prophecy\npromise that has the highest score. In this case, `Argument::type()` in case of success\nscores `5` and `Argument::any()` scores `3`. So the type token wins, as does the first\n`setName()` method prophecy and its promise. The simple rule of thumb - more precise token\nalways wins.\n\n#### Getting stub objects\n\nOk, now we know how to define our prophecy method promises, let's get our stub from\nit:\n\n```php\n$stub = $prophecy->reveal();\n```\n\nAs you might see, the only difference between how we get dummies and stubs is that with\nstubs we describe every object conversation instead of just agreeing with `null` returns\n(object being *dummy*). As a matter of fact, after you define your first promise\n(method call), Prophecy will force you to define all the communications - it throws\nthe `UnexpectedCallException` for any call you didn't describe with object prophecy before\ncalling it on a stub.\n\n### Mocks\n\nNow we know how to define doubles without behavior (dummies) and doubles with behavior, but\nno expectations (stubs). What's left is doubles for which we have some expectations. These\nare called mocks and in Prophecy they look almost exactly the same as stubs, except that\nthey define *predictions* instead of *promises* on method prophecies:\n\n```php\n$entityManager->flush()->shouldBeCalled();\n```\n\n#### Predictions\n\nThe `shouldBeCalled()` method here assigns `CallPrediction` to our method prophecy.\nPredictions are a delayed behavior check for your prophecies. You see, during the entire lifetime\nof your doubles, Prophecy records every single call you're making against it inside your\ncode. After that, Prophecy can use this collected information to check if it matches defined\npredictions. You can assign predictions to method prophecies using the\n`MethodProphecy::should(PredictionInterface $prediction)` method. As a matter of fact,\nthe `shouldBeCalled()` method we used earlier is just a shortcut to:\n\n```php\n$entityManager->flush()->should(new Prophecy\\Prediction\\CallPrediction());\n```\n\nIt checks if your method of interest (that matches both the method name and the arguments wildcard)\nwas called 1 or more times. If the prediction failed then it throws an exception. When does this\ncheck happen? Whenever you call `checkPredictions()` on the main Prophet object:\n\n```php\n$prophet->checkPredictions();\n```\n\nIn PHPUnit, you would want to put this call into the `tearDown()` method. If no predictions\nare defined, it would do nothing. So it won't harm to call it after every test.\n\nThere are plenty more predictions you can play with:\n\n- `CallPrediction` or `shouldBeCalled()` - checks that the method has been called 1 or more times\n- `NoCallsPrediction` or `shouldNotBeCalled()` - checks that the method has not been called\n- `CallTimesPrediction` or `shouldBeCalledTimes($count)` - checks that the method has been called\n  `$count` times\n- `CallbackPrediction` or `should($callback)` - checks the method against your own custom callback\n\nOf course, you can always create your own custom prediction any time by implementing\n`PredictionInterface`.\n\n### Spies\n\nThe last bit of awesomeness in Prophecy is out-of-the-box spies support. As I said in the previous\nsection, Prophecy records every call made during the double's entire lifetime. This means\nyou don't need to record predictions in order to check them. You can also do it\nmanually by using the `MethodProphecy::shouldHave(PredictionInterface $prediction)` method:\n\n```php\n$em = $prophet->prophesize('Doctrine\\ORM\\EntityManager');\n\n$controller->createUser($em->reveal());\n\n$em->flush()->shouldHaveBeenCalled();\n```\n\nSuch manipulation with doubles is called spying. And with Prophecy it just works.\n\n\n## FAQ\n\n### Can I call the original methods on a prophesized class?\n\nProphecy does not support calling the original methods on a phrophesized class. If you find yourself needing to mock some methods of a class while calling the original version of other methods, it's likely a sign that your class violates the [single-responsibility principle](https://en.wikipedia.org/wiki/Single-responsibility_principle) and should be refactored.\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 2.029296875,
          "content": "{\n    \"name\":         \"phpspec/prophecy\",\n    \"description\":  \"Highly opinionated mocking framework for PHP 5.3+\",\n    \"keywords\":     [\"Mock\", \"Stub\", \"Dummy\", \"Double\", \"Fake\", \"Spy\", \"dev\"],\n    \"homepage\":     \"https://github.com/phpspec/prophecy\",\n    \"type\":         \"library\",\n    \"license\":      \"MIT\",\n    \"authors\":      [\n        {\n            \"name\":      \"Konstantin Kudryashov\",\n            \"email\":     \"ever.zet@gmail.com\",\n            \"homepage\":  \"http://everzet.com\"\n        },\n        {\n            \"name\":      \"Marcello Duarte\",\n            \"email\":     \"marcello.duarte@gmail.com\"\n        }\n    ],\n\n    \"require\": {\n        \"php\":                               \"^7.2 || 8.0.* || 8.1.* || 8.2.* || 8.3.* || 8.4.*\",\n        \"phpdocumentor/reflection-docblock\": \"^5.2\",\n        \"sebastian/comparator\":              \"^3.0 || ^4.0 || ^5.0 || ^6.0\",\n        \"doctrine/instantiator\":             \"^1.2 || ^2.0\",\n        \"sebastian/recursion-context\":       \"^3.0 || ^4.0 || ^5.0 || ^6.0\"\n    },\n\n    \"require-dev\": {\n        \"friendsofphp/php-cs-fixer\": \"^3.40\",\n        \"phpspec/phpspec\": \"^6.0 || ^7.0\",\n        \"phpstan/phpstan\": \"^1.9\",\n        \"phpunit/phpunit\": \"^8.0 || ^9.0 || ^10.0\"\n    },\n\n    \"autoload\": {\n        \"psr-4\": {\n            \"Prophecy\\\\\": \"src/Prophecy\"\n        }\n    },\n\n    \"autoload-dev\": {\n        \"psr-4\": {\n            \"Fixtures\\\\Prophecy\\\\\": \"fixtures\",\n            \"Tests\\\\Prophecy\\\\\": \"tests\"\n        }\n    },\n\n    \"scripts\": {\n        \"cs:check\": \"@php php-cs-fixer check --verbose --diff\",\n        \"cs:fix\": \"@php php-cs-fixer fix\",\n        \"phpstan\": \"phpstan analyse\",\n        \"phpstan:baseline\": \"phpstan analyse --generate-baseline\"\n    },\n\n    \"scripts-descriptions\": {\n        \"cs:check\": \"Check coding standards\",\n        \"cs:fix\": \"Fix coding standards\",\n        \"phpstan\": \"Run PHPStan analysis\",\n        \"phpstan:baseline\": \"Dump PHPStan baseline file - use only for updating, do not add new errors when possible\"\n    },\n\n    \"extra\": {\n        \"branch-alias\": {\n            \"dev-master\": \"1.x-dev\"\n        }\n    }\n}\n"
        },
        {
          "name": "fixtures",
          "type": "tree",
          "content": null
        },
        {
          "name": "phpstan-baseline.neon",
          "type": "blob",
          "size": 1.4052734375,
          "content": "parameters:\n\tignoreErrors:\n\t\t-\n\t\t\tmessage: \"#^Parameter \\\\#1 \\\\$value of function strval expects bool\\\\|float\\\\|int\\\\|resource\\\\|string\\\\|null, mixed given\\\\.$#\"\n\t\t\tcount: 2\n\t\t\tpath: src/Prophecy/Argument/Token/ExactValueToken.php\n\n\t\t-\n\t\t\tmessage: \"#^Method Prophecy\\\\\\\\Doubler\\\\\\\\CachedDoubler\\\\:\\\\:createDoubleClass\\\\(\\\\) should return class\\\\-string\\\\<Prophecy\\\\\\\\Doubler\\\\\\\\DoubleInterface&T of object\\\\> but returns class\\\\-string\\\\.$#\"\n\t\t\tcount: 1\n\t\t\tpath: src/Prophecy/Doubler/CachedDoubler.php\n\n\t\t-\n\t\t\tmessage: \"#^Method Prophecy\\\\\\\\Doubler\\\\\\\\Doubler\\\\:\\\\:createDoubleClass\\\\(\\\\) should return class\\\\-string\\\\<Prophecy\\\\\\\\Doubler\\\\\\\\DoubleInterface&T of object\\\\> but returns class\\\\-string\\\\.$#\"\n\t\t\tcount: 1\n\t\t\tpath: src/Prophecy/Doubler/Doubler.php\n\n\t\t-\n\t\t\tmessage: \"#^Parameter \\\\#1 \\\\$callback of function array_map expects \\\\(callable\\\\(ReflectionIntersectionType\\\\|ReflectionNamedType\\\\|string\\\\)\\\\: mixed\\\\)\\\\|null, Closure\\\\(string\\\\)\\\\: string given\\\\.$#\"\n\t\t\tcount: 1\n\t\t\tpath: src/Prophecy/Doubler/Generator/ClassMirror.php\n\n\t\t-\n\t\t\tmessage: \"#^Parameter \\\\#1 \\\\$callback of function array_map expects \\\\(callable\\\\(ReflectionIntersectionType\\\\|ReflectionNamedType\\\\)\\\\: mixed\\\\)\\\\|null, Closure\\\\(ReflectionNamedType\\\\)\\\\: string given\\\\.$#\"\n\t\t\tcount: 1\n\t\t\tpath: src/Prophecy/Prophecy/MethodProphecy.php\n\n\t\t-\n\t\t\tmessage: \"#^Cannot access offset mixed on mixed\\\\.$#\"\n\t\t\tcount: 1\n\t\t\tpath: src/Prophecy/Util/ExportUtil.php\n"
        },
        {
          "name": "phpstan.dist.neon",
          "type": "blob",
          "size": 0.236328125,
          "content": "parameters:\n    level: 9\n    inferPrivatePropertyTypeFromConstructor: true\n    treatPhpDocTypesAsCertain: false\n    paths:\n        - ./src/\n    excludePaths:\n        - src/Prophecy/Comparator/Factory.php\nincludes:\n    - phpstan-baseline.neon\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.6044921875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/4.8/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"PhpSpec Test Suite\">\n            <directory>tests</directory>\n        </testsuite>\n    </testsuites>\n\n    <filter>\n        <whitelist>\n            <directory>./src/</directory>\n        </whitelist>\n    </filter>\n</phpunit>\n"
        },
        {
          "name": "spec",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}