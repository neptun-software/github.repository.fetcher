{
  "metadata": {
    "timestamp": 1736712285182,
    "page": 59,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/process",
      "stars": 7449,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 4.2216796875,
          "content": "CHANGELOG\n=========\n\n7.1\n---\n\n * Add `Process::setIgnoredSignals()` to disable signal propagation to the child process\n\n6.4\n---\n\n * Add `PhpSubprocess` to handle PHP subprocesses that take over the\n   configuration from their parent\n * Add `RunProcessMessage` and `RunProcessMessageHandler`\n\n5.2.0\n-----\n\n * added `Process::setOptions()` to set `Process` specific options\n * added option `create_new_console` to allow a subprocess to continue\n   to run after the main script exited, both on Linux and on Windows\n\n5.1.0\n-----\n\n * added `Process::getStartTime()` to retrieve the start time of the process as float\n\n5.0.0\n-----\n\n * removed `Process::inheritEnvironmentVariables()`\n * removed `PhpProcess::setPhpBinary()`\n * `Process` must be instantiated with a command array, use `Process::fromShellCommandline()` when the command should be parsed by the shell\n * removed `Process::setCommandLine()`\n\n4.4.0\n-----\n\n * deprecated `Process::inheritEnvironmentVariables()`: env variables are always inherited.\n * added `Process::getLastOutputTime()` method\n\n4.2.0\n-----\n\n * added the `Process::fromShellCommandline()` to run commands in a shell wrapper\n * deprecated passing a command as string when creating a `Process` instance\n * deprecated the `Process::setCommandline()` and the `PhpProcess::setPhpBinary()` methods\n * added the `Process::waitUntil()` method to wait for the process only for a\n   specific output, then continue the normal execution of your application\n\n4.1.0\n-----\n\n * added the `Process::isTtySupported()` method that allows to check for TTY support\n * made `PhpExecutableFinder` look for the `PHP_BINARY` env var when searching the php binary\n * added the `ProcessSignaledException` class to properly catch signaled process errors\n\n4.0.0\n-----\n\n * environment variables will always be inherited\n * added a second `array $env = []` argument to the `start()`, `run()`,\n   `mustRun()`, and `restart()` methods of the `Process` class\n * added a second `array $env = []` argument to the `start()` method of the\n   `PhpProcess` class\n * the `ProcessUtils::escapeArgument()` method has been removed\n * the `areEnvironmentVariablesInherited()`, `getOptions()`, and `setOptions()`\n   methods of the `Process` class have been removed\n * support for passing `proc_open()` options has been removed\n * removed the `ProcessBuilder` class, use the `Process` class instead\n * removed the `getEnhanceWindowsCompatibility()` and `setEnhanceWindowsCompatibility()` methods of the `Process` class\n * passing a not existing working directory to the constructor of the `Symfony\\Component\\Process\\Process` class is not\n   supported anymore\n\n3.4.0\n-----\n\n * deprecated the ProcessBuilder class\n * deprecated calling `Process::start()` without setting a valid working directory beforehand (via `setWorkingDirectory()` or constructor)\n\n3.3.0\n-----\n\n * added command line arrays in the `Process` class\n * added `$env` argument to `Process::start()`, `run()`, `mustRun()` and `restart()` methods\n * deprecated the `ProcessUtils::escapeArgument()` method\n * deprecated not inheriting environment variables\n * deprecated configuring `proc_open()` options\n * deprecated configuring enhanced Windows compatibility\n * deprecated configuring enhanced sigchild compatibility\n\n2.5.0\n-----\n\n * added support for PTY mode\n * added the convenience method \"mustRun\"\n * deprecation: Process::setStdin() is deprecated in favor of Process::setInput()\n * deprecation: Process::getStdin() is deprecated in favor of Process::getInput()\n * deprecation: Process::setInput() and ProcessBuilder::setInput() do not accept non-scalar types\n\n2.4.0\n-----\n\n * added the ability to define an idle timeout\n\n2.3.0\n-----\n\n * added ProcessUtils::escapeArgument() to fix the bug in escapeshellarg() function on Windows\n * added Process::signal()\n * added Process::getPid()\n * added support for a TTY mode\n\n2.2.0\n-----\n\n * added ProcessBuilder::setArguments() to reset the arguments on a builder\n * added a way to retrieve the standard and error output incrementally\n * added Process:restart()\n\n2.1.0\n-----\n\n * added support for non-blocking processes (start(), wait(), isRunning(), stop())\n * enhanced Windows compatibility\n * added Process::getExitCodeText() that returns a string representation for\n   the exit code returned by the process\n * added ProcessBuilder\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "ExecutableFinder.php",
          "type": "blob",
          "size": 3.478515625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Process;\n\n/**\n * Generic executable finder.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n */\nclass ExecutableFinder\n{\n    private const CMD_BUILTINS = [\n        'assoc', 'break', 'call', 'cd', 'chdir', 'cls', 'color', 'copy', 'date',\n        'del', 'dir', 'echo', 'endlocal', 'erase', 'exit', 'for', 'ftype', 'goto',\n        'help', 'if', 'label', 'md', 'mkdir', 'mklink', 'move', 'path', 'pause',\n        'popd', 'prompt', 'pushd', 'rd', 'rem', 'ren', 'rename', 'rmdir', 'set',\n        'setlocal', 'shift', 'start', 'time', 'title', 'type', 'ver', 'vol',\n    ];\n\n    private array $suffixes = [];\n\n    /**\n     * Replaces default suffixes of executable.\n     */\n    public function setSuffixes(array $suffixes): void\n    {\n        $this->suffixes = $suffixes;\n    }\n\n    /**\n     * Adds new possible suffix to check for executable, including the dot (.).\n     *\n     *     $finder = new ExecutableFinder();\n     *     $finder->addSuffix('.foo');\n     */\n    public function addSuffix(string $suffix): void\n    {\n        $this->suffixes[] = $suffix;\n    }\n\n    /**\n     * Finds an executable by name.\n     *\n     * @param string      $name      The executable name (without the extension)\n     * @param string|null $default   The default to return if no executable is found\n     * @param array       $extraDirs Additional dirs to check into\n     */\n    public function find(string $name, ?string $default = null, array $extraDirs = []): ?string\n    {\n        // windows built-in commands that are present in cmd.exe should not be resolved using PATH as they do not exist as exes\n        if ('\\\\' === \\DIRECTORY_SEPARATOR && \\in_array(strtolower($name), self::CMD_BUILTINS, true)) {\n            return $name;\n        }\n\n        $dirs = array_merge(\n            explode(\\PATH_SEPARATOR, getenv('PATH') ?: getenv('Path')),\n            $extraDirs\n        );\n\n        $suffixes = $this->suffixes;\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $pathExt = getenv('PATHEXT');\n            $suffixes = array_merge($suffixes, $pathExt ? explode(\\PATH_SEPARATOR, $pathExt) : ['.exe', '.bat', '.cmd', '.com']);\n        }\n        $suffixes = '' !== pathinfo($name, PATHINFO_EXTENSION) ? array_merge([''], $suffixes) : array_merge($suffixes, ['']);\n        foreach ($suffixes as $suffix) {\n            foreach ($dirs as $dir) {\n                if ('' === $dir) {\n                    $dir = '.';\n                }\n                if (@is_file($file = $dir.\\DIRECTORY_SEPARATOR.$name.$suffix) && ('\\\\' === \\DIRECTORY_SEPARATOR || @is_executable($file))) {\n                    return $file;\n                }\n\n                if (!@is_dir($dir) && basename($dir) === $name.$suffix && @is_executable($dir)) {\n                    return $dir;\n                }\n            }\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR || !\\function_exists('exec') || \\strlen($name) !== strcspn($name, '/'.\\DIRECTORY_SEPARATOR)) {\n            return $default;\n        }\n\n        $execResult = exec('command -v -- '.escapeshellarg($name));\n\n        if (($executablePath = substr($execResult, 0, strpos($execResult, \\PHP_EOL) ?: null)) && @is_executable($executablePath)) {\n            return $executablePath;\n        }\n\n        return $default;\n    }\n}\n"
        },
        {
          "name": "InputStream.php",
          "type": "blob",
          "size": 2.3291015625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Process;\n\nuse Symfony\\Component\\Process\\Exception\\RuntimeException;\n\n/**\n * Provides a way to continuously write to the input of a Process until the InputStream is closed.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @implements \\IteratorAggregate<int, string>\n */\nclass InputStream implements \\IteratorAggregate\n{\n    private ?\\Closure $onEmpty = null;\n    private array $input = [];\n    private bool $open = true;\n\n    /**\n     * Sets a callback that is called when the write buffer becomes empty.\n     */\n    public function onEmpty(?callable $onEmpty = null): void\n    {\n        $this->onEmpty = null !== $onEmpty ? $onEmpty(...) : null;\n    }\n\n    /**\n     * Appends an input to the write buffer.\n     *\n     * @param resource|string|int|float|bool|\\Traversable|null $input The input to append as scalar,\n     *                                                                stream resource or \\Traversable\n     */\n    public function write(mixed $input): void\n    {\n        if (null === $input) {\n            return;\n        }\n        if ($this->isClosed()) {\n            throw new RuntimeException(\\sprintf('\"%s\" is closed.', static::class));\n        }\n        $this->input[] = ProcessUtils::validateInput(__METHOD__, $input);\n    }\n\n    /**\n     * Closes the write buffer.\n     */\n    public function close(): void\n    {\n        $this->open = false;\n    }\n\n    /**\n     * Tells whether the write buffer is closed or not.\n     */\n    public function isClosed(): bool\n    {\n        return !$this->open;\n    }\n\n    public function getIterator(): \\Traversable\n    {\n        $this->open = true;\n\n        while ($this->open || $this->input) {\n            if (!$this->input) {\n                yield '';\n                continue;\n            }\n            $current = array_shift($this->input);\n\n            if ($current instanceof \\Iterator) {\n                yield from $current;\n            } else {\n                yield $current;\n            }\n            if (!$this->input && $this->open && null !== $onEmpty = $this->onEmpty) {\n                $this->write($onEmpty($this));\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Messenger",
          "type": "tree",
          "content": null
        },
        {
          "name": "PhpExecutableFinder.php",
          "type": "blob",
          "size": 2.3720703125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Process;\n\n/**\n * An executable finder specifically designed for the PHP executable.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n */\nclass PhpExecutableFinder\n{\n    private ExecutableFinder $executableFinder;\n\n    public function __construct()\n    {\n        $this->executableFinder = new ExecutableFinder();\n    }\n\n    /**\n     * Finds The PHP executable.\n     */\n    public function find(bool $includeArgs = true): string|false\n    {\n        if ($php = getenv('PHP_BINARY')) {\n            if (!is_executable($php) && !$php = $this->executableFinder->find($php)) {\n                return false;\n            }\n\n            if (@is_dir($php)) {\n                return false;\n            }\n\n            return $php;\n        }\n\n        $args = $this->findArguments();\n        $args = $includeArgs && $args ? ' '.implode(' ', $args) : '';\n\n        // PHP_BINARY return the current sapi executable\n        if (\\PHP_BINARY && \\in_array(\\PHP_SAPI, ['cli', 'cli-server', 'phpdbg'], true)) {\n            return \\PHP_BINARY.$args;\n        }\n\n        if ($php = getenv('PHP_PATH')) {\n            if (!@is_executable($php) || @is_dir($php)) {\n                return false;\n            }\n\n            return $php;\n        }\n\n        if ($php = getenv('PHP_PEAR_PHP_BIN')) {\n            if (@is_executable($php) && !@is_dir($php)) {\n                return $php;\n            }\n        }\n\n        if (@is_executable($php = \\PHP_BINDIR.('\\\\' === \\DIRECTORY_SEPARATOR ? '\\\\php.exe' : '/php')) && !@is_dir($php)) {\n            return $php;\n        }\n\n        $dirs = [\\PHP_BINDIR];\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $dirs[] = 'C:\\xampp\\php\\\\';\n        }\n\n        if ($herdPath = getenv('HERD_HOME')) {\n            $dirs[] = $herdPath.\\DIRECTORY_SEPARATOR.'bin';\n        }\n\n        return $this->executableFinder->find('php', false, $dirs);\n    }\n\n    /**\n     * Finds the PHP executable arguments.\n     */\n    public function findArguments(): array\n    {\n        $arguments = [];\n        if ('phpdbg' === \\PHP_SAPI) {\n            $arguments[] = '-qrr';\n        }\n\n        return $arguments;\n    }\n}\n"
        },
        {
          "name": "PhpProcess.php",
          "type": "blob",
          "size": 2.3583984375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Process;\n\nuse Symfony\\Component\\Process\\Exception\\LogicException;\nuse Symfony\\Component\\Process\\Exception\\RuntimeException;\n\n/**\n * PhpProcess runs a PHP script in an independent process.\n *\n *     $p = new PhpProcess('<?php echo \"foo\"; ?>');\n *     $p->run();\n *     print $p->getOutput().\"\\n\";\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass PhpProcess extends Process\n{\n    /**\n     * @param string      $script  The PHP script to run (as a string)\n     * @param string|null $cwd     The working directory or null to use the working dir of the current PHP process\n     * @param array|null  $env     The environment variables or null to use the same environment as the current PHP process\n     * @param int         $timeout The timeout in seconds\n     * @param array|null  $php     Path to the PHP binary to use with any additional arguments\n     */\n    public function __construct(string $script, ?string $cwd = null, ?array $env = null, int $timeout = 60, ?array $php = null)\n    {\n        if (null === $php) {\n            $executableFinder = new PhpExecutableFinder();\n            $php = $executableFinder->find(false);\n            $php = false === $php ? null : array_merge([$php], $executableFinder->findArguments());\n        }\n        if ('phpdbg' === \\PHP_SAPI) {\n            $file = tempnam(sys_get_temp_dir(), 'dbg');\n            file_put_contents($file, $script);\n            register_shutdown_function('unlink', $file);\n            $php[] = $file;\n            $script = null;\n        }\n\n        parent::__construct($php, $cwd, $env, $script, $timeout);\n    }\n\n    public static function fromShellCommandline(string $command, ?string $cwd = null, ?array $env = null, mixed $input = null, ?float $timeout = 60): static\n    {\n        throw new LogicException(\\sprintf('The \"%s()\" method cannot be called when using \"%s\".', __METHOD__, self::class));\n    }\n\n    public function start(?callable $callback = null, array $env = []): void\n    {\n        if (null === $this->getCommandLine()) {\n            throw new RuntimeException('Unable to find the PHP executable.');\n        }\n\n        parent::start($callback, $env);\n    }\n}\n"
        },
        {
          "name": "PhpSubprocess.php",
          "type": "blob",
          "size": 5.921875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Process;\n\nuse Symfony\\Component\\Process\\Exception\\LogicException;\nuse Symfony\\Component\\Process\\Exception\\RuntimeException;\n\n/**\n * PhpSubprocess runs a PHP command as a subprocess while keeping the original php.ini settings.\n *\n * For this, it generates a temporary php.ini file taking over all the current settings and disables\n * loading additional .ini files. Basically, your command gets prefixed using \"php -n -c /tmp/temp.ini\".\n *\n * Given your php.ini contains \"memory_limit=-1\" and you have a \"MemoryTest.php\" with the following content:\n *\n *     <?php var_dump(ini_get('memory_limit'));\n *\n * These are the differences between the regular Process and PhpSubprocess classes:\n *\n *     $p = new Process(['php', '-d', 'memory_limit=256M', 'MemoryTest.php']);\n *     $p->run();\n *     print $p->getOutput().\"\\n\";\n *\n * This will output \"string(2) \"-1\", because the process is started with the default php.ini settings.\n *\n *     $p = new PhpSubprocess(['MemoryTest.php'], null, null, 60, ['php', '-d', 'memory_limit=256M']);\n *     $p->run();\n *     print $p->getOutput().\"\\n\";\n *\n * This will output \"string(4) \"256M\"\", because the process is started with the temporarily created php.ini settings.\n *\n * @author Yanick Witschi <yanick.witschi@terminal42.ch>\n * @author Partially copied and heavily inspired from composer/xdebug-handler by John Stevenson <john-stevenson@blueyonder.co.uk>\n */\nclass PhpSubprocess extends Process\n{\n    /**\n     * @param array       $command The command to run and its arguments listed as separate entries. They will automatically\n     *                             get prefixed with the PHP binary\n     * @param string|null $cwd     The working directory or null to use the working dir of the current PHP process\n     * @param array|null  $env     The environment variables or null to use the same environment as the current PHP process\n     * @param int         $timeout The timeout in seconds\n     * @param array|null  $php     Path to the PHP binary to use with any additional arguments\n     */\n    public function __construct(array $command, ?string $cwd = null, ?array $env = null, int $timeout = 60, ?array $php = null)\n    {\n        if (null === $php) {\n            $executableFinder = new PhpExecutableFinder();\n            $php = $executableFinder->find(false);\n            $php = false === $php ? null : array_merge([$php], $executableFinder->findArguments());\n        }\n\n        if (null === $php) {\n            throw new RuntimeException('Unable to find PHP binary.');\n        }\n\n        $tmpIni = $this->writeTmpIni($this->getAllIniFiles(), sys_get_temp_dir());\n\n        $php = array_merge($php, ['-n', '-c', $tmpIni]);\n        register_shutdown_function('unlink', $tmpIni);\n\n        $command = array_merge($php, $command);\n\n        parent::__construct($command, $cwd, $env, null, $timeout);\n    }\n\n    public static function fromShellCommandline(string $command, ?string $cwd = null, ?array $env = null, mixed $input = null, ?float $timeout = 60): static\n    {\n        throw new LogicException(\\sprintf('The \"%s()\" method cannot be called when using \"%s\".', __METHOD__, self::class));\n    }\n\n    public function start(?callable $callback = null, array $env = []): void\n    {\n        if (null === $this->getCommandLine()) {\n            throw new RuntimeException('Unable to find the PHP executable.');\n        }\n\n        parent::start($callback, $env);\n    }\n\n    private function writeTmpIni(array $iniFiles, string $tmpDir): string\n    {\n        if (false === $tmpfile = @tempnam($tmpDir, '')) {\n            throw new RuntimeException('Unable to create temporary ini file.');\n        }\n\n        // $iniFiles has at least one item and it may be empty\n        if ('' === $iniFiles[0]) {\n            array_shift($iniFiles);\n        }\n\n        $content = '';\n\n        foreach ($iniFiles as $file) {\n            // Check for inaccessible ini files\n            if (($data = @file_get_contents($file)) === false) {\n                throw new RuntimeException('Unable to read ini: '.$file);\n            }\n            // Check and remove directives after HOST and PATH sections\n            if (preg_match('/^\\s*\\[(?:PATH|HOST)\\s*=/mi', $data, $matches, \\PREG_OFFSET_CAPTURE)) {\n                $data = substr($data, 0, $matches[0][1]);\n            }\n\n            $content .= $data.\"\\n\";\n        }\n\n        // Merge loaded settings into our ini content, if it is valid\n        $config = parse_ini_string($content);\n        $loaded = ini_get_all(null, false);\n\n        if (false === $config || false === $loaded) {\n            throw new RuntimeException('Unable to parse ini data.');\n        }\n\n        $content .= $this->mergeLoadedConfig($loaded, $config);\n\n        // Work-around for https://bugs.php.net/bug.php?id=75932\n        $content .= \"opcache.enable_cli=0\\n\";\n\n        if (false === @file_put_contents($tmpfile, $content)) {\n            throw new RuntimeException('Unable to write temporary ini file.');\n        }\n\n        return $tmpfile;\n    }\n\n    private function mergeLoadedConfig(array $loadedConfig, array $iniConfig): string\n    {\n        $content = '';\n\n        foreach ($loadedConfig as $name => $value) {\n            if (!\\is_string($value)) {\n                continue;\n            }\n\n            if (!isset($iniConfig[$name]) || $iniConfig[$name] !== $value) {\n                // Double-quote escape each value\n                $content .= $name.'=\"'.addcslashes($value, '\\\\\"').\"\\\"\\n\";\n            }\n        }\n\n        return $content;\n    }\n\n    private function getAllIniFiles(): array\n    {\n        $paths = [(string) php_ini_loaded_file()];\n\n        if (false !== $scanned = php_ini_scanned_files()) {\n            $paths = array_merge($paths, array_map('trim', explode(',', $scanned)));\n        }\n\n        return $paths;\n    }\n}\n"
        },
        {
          "name": "Pipes",
          "type": "tree",
          "content": null
        },
        {
          "name": "Process.php",
          "type": "blob",
          "size": 54.234375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Process;\n\nuse Symfony\\Component\\Process\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Process\\Exception\\LogicException;\nuse Symfony\\Component\\Process\\Exception\\ProcessFailedException;\nuse Symfony\\Component\\Process\\Exception\\ProcessSignaledException;\nuse Symfony\\Component\\Process\\Exception\\ProcessStartFailedException;\nuse Symfony\\Component\\Process\\Exception\\ProcessTimedOutException;\nuse Symfony\\Component\\Process\\Exception\\RuntimeException;\nuse Symfony\\Component\\Process\\Pipes\\UnixPipes;\nuse Symfony\\Component\\Process\\Pipes\\WindowsPipes;\n\n/**\n * Process is a thin wrapper around proc_* functions to easily\n * start independent PHP processes.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Romain Neutron <imprec@gmail.com>\n *\n * @implements \\IteratorAggregate<string, string>\n */\nclass Process implements \\IteratorAggregate\n{\n    public const ERR = 'err';\n    public const OUT = 'out';\n\n    public const STATUS_READY = 'ready';\n    public const STATUS_STARTED = 'started';\n    public const STATUS_TERMINATED = 'terminated';\n\n    public const STDIN = 0;\n    public const STDOUT = 1;\n    public const STDERR = 2;\n\n    // Timeout Precision in seconds.\n    public const TIMEOUT_PRECISION = 0.2;\n\n    public const ITER_NON_BLOCKING = 1; // By default, iterating over outputs is a blocking call, use this flag to make it non-blocking\n    public const ITER_KEEP_OUTPUT = 2;  // By default, outputs are cleared while iterating, use this flag to keep them in memory\n    public const ITER_SKIP_OUT = 4;     // Use this flag to skip STDOUT while iterating\n    public const ITER_SKIP_ERR = 8;     // Use this flag to skip STDERR while iterating\n\n    private ?\\Closure $callback = null;\n    private array|string $commandline;\n    private ?string $cwd;\n    private array $env = [];\n    /** @var resource|string|\\Iterator|null */\n    private $input;\n    private ?float $starttime = null;\n    private ?float $lastOutputTime = null;\n    private ?float $timeout = null;\n    private ?float $idleTimeout = null;\n    private ?int $exitcode = null;\n    private array $fallbackStatus = [];\n    private array $processInformation;\n    private bool $outputDisabled = false;\n    /** @var resource */\n    private $stdout;\n    /** @var resource */\n    private $stderr;\n    /** @var resource|null */\n    private $process;\n    private string $status = self::STATUS_READY;\n    private int $incrementalOutputOffset = 0;\n    private int $incrementalErrorOutputOffset = 0;\n    private bool $tty = false;\n    private bool $pty;\n    private array $options = ['suppress_errors' => true, 'bypass_shell' => true];\n    private array $ignoredSignals = [];\n\n    private WindowsPipes|UnixPipes $processPipes;\n\n    private ?int $latestSignal = null;\n    private ?int $cachedExitCode = null;\n\n    private static ?bool $sigchild = null;\n    private static array $executables = [];\n\n    /**\n     * Exit codes translation table.\n     *\n     * User-defined errors must use exit codes in the 64-113 range.\n     */\n    public static array $exitCodes = [\n        0 => 'OK',\n        1 => 'General error',\n        2 => 'Misuse of shell builtins',\n\n        126 => 'Invoked command cannot execute',\n        127 => 'Command not found',\n        128 => 'Invalid exit argument',\n\n        // signals\n        129 => 'Hangup',\n        130 => 'Interrupt',\n        131 => 'Quit and dump core',\n        132 => 'Illegal instruction',\n        133 => 'Trace/breakpoint trap',\n        134 => 'Process aborted',\n        135 => 'Bus error: \"access to undefined portion of memory object\"',\n        136 => 'Floating point exception: \"erroneous arithmetic operation\"',\n        137 => 'Kill (terminate immediately)',\n        138 => 'User-defined 1',\n        139 => 'Segmentation violation',\n        140 => 'User-defined 2',\n        141 => 'Write to pipe with no one reading',\n        142 => 'Signal raised by alarm',\n        143 => 'Termination (request to terminate)',\n        // 144 - not defined\n        145 => 'Child process terminated, stopped (or continued*)',\n        146 => 'Continue if stopped',\n        147 => 'Stop executing temporarily',\n        148 => 'Terminal stop signal',\n        149 => 'Background process attempting to read from tty (\"in\")',\n        150 => 'Background process attempting to write to tty (\"out\")',\n        151 => 'Urgent data available on socket',\n        152 => 'CPU time limit exceeded',\n        153 => 'File size limit exceeded',\n        154 => 'Signal raised by timer counting virtual time: \"virtual timer expired\"',\n        155 => 'Profiling timer expired',\n        // 156 - not defined\n        157 => 'Pollable event',\n        // 158 - not defined\n        159 => 'Bad syscall',\n    ];\n\n    /**\n     * @param array          $command The command to run and its arguments listed as separate entries\n     * @param string|null    $cwd     The working directory or null to use the working dir of the current PHP process\n     * @param array|null     $env     The environment variables or null to use the same environment as the current PHP process\n     * @param mixed          $input   The input as stream resource, scalar or \\Traversable, or null for no input\n     * @param int|float|null $timeout The timeout in seconds or null to disable\n     *\n     * @throws LogicException When proc_open is not installed\n     */\n    public function __construct(array $command, ?string $cwd = null, ?array $env = null, mixed $input = null, ?float $timeout = 60)\n    {\n        if (!\\function_exists('proc_open')) {\n            throw new LogicException('The Process class relies on proc_open, which is not available on your PHP installation.');\n        }\n\n        $this->commandline = $command;\n        $this->cwd = $cwd;\n\n        // on Windows, if the cwd changed via chdir(), proc_open defaults to the dir where PHP was started\n        // on Gnu/Linux, PHP builds with --enable-maintainer-zts are also affected\n        // @see : https://bugs.php.net/51800\n        // @see : https://bugs.php.net/50524\n        if (null === $this->cwd && (\\defined('ZEND_THREAD_SAFE') || '\\\\' === \\DIRECTORY_SEPARATOR)) {\n            $this->cwd = getcwd();\n        }\n        if (null !== $env) {\n            $this->setEnv($env);\n        }\n\n        $this->setInput($input);\n        $this->setTimeout($timeout);\n        $this->pty = false;\n    }\n\n    /**\n     * Creates a Process instance as a command-line to be run in a shell wrapper.\n     *\n     * Command-lines are parsed by the shell of your OS (/bin/sh on Unix-like, cmd.exe on Windows.)\n     * This allows using e.g. pipes or conditional execution. In this mode, signals are sent to the\n     * shell wrapper and not to your commands.\n     *\n     * In order to inject dynamic values into command-lines, we strongly recommend using placeholders.\n     * This will save escaping values, which is not portable nor secure anyway:\n     *\n     *   $process = Process::fromShellCommandline('my_command \"${:MY_VAR}\"');\n     *   $process->run(null, ['MY_VAR' => $theValue]);\n     *\n     * @param string         $command The command line to pass to the shell of the OS\n     * @param string|null    $cwd     The working directory or null to use the working dir of the current PHP process\n     * @param array|null     $env     The environment variables or null to use the same environment as the current PHP process\n     * @param mixed          $input   The input as stream resource, scalar or \\Traversable, or null for no input\n     * @param int|float|null $timeout The timeout in seconds or null to disable\n     *\n     * @throws LogicException When proc_open is not installed\n     */\n    public static function fromShellCommandline(string $command, ?string $cwd = null, ?array $env = null, mixed $input = null, ?float $timeout = 60): static\n    {\n        $process = new static([], $cwd, $env, $input, $timeout);\n        $process->commandline = $command;\n\n        return $process;\n    }\n\n    public function __sleep(): array\n    {\n        throw new \\BadMethodCallException('Cannot serialize '.__CLASS__);\n    }\n\n    public function __wakeup(): void\n    {\n        throw new \\BadMethodCallException('Cannot unserialize '.__CLASS__);\n    }\n\n    public function __destruct()\n    {\n        if ($this->options['create_new_console'] ?? false) {\n            $this->processPipes->close();\n        } else {\n            $this->stop(0);\n        }\n    }\n\n    public function __clone()\n    {\n        $this->resetProcessData();\n    }\n\n    /**\n     * Runs the process.\n     *\n     * The callback receives the type of output (out or err) and\n     * some bytes from the output in real-time. It allows to have feedback\n     * from the independent process during execution.\n     *\n     * The STDOUT and STDERR are also available after the process is finished\n     * via the getOutput() and getErrorOutput() methods.\n     *\n     * @param callable|null $callback A PHP callback to run whenever there is some\n     *                                output available on STDOUT or STDERR\n     *\n     * @return int The exit status code\n     *\n     * @throws ProcessStartFailedException When process can't be launched\n     * @throws RuntimeException            When process is already running\n     * @throws ProcessTimedOutException    When process timed out\n     * @throws ProcessSignaledException    When process stopped after receiving signal\n     * @throws LogicException              In case a callback is provided and output has been disabled\n     *\n     * @final\n     */\n    public function run(?callable $callback = null, array $env = []): int\n    {\n        $this->start($callback, $env);\n\n        return $this->wait();\n    }\n\n    /**\n     * Runs the process.\n     *\n     * This is identical to run() except that an exception is thrown if the process\n     * exits with a non-zero exit code.\n     *\n     * @return $this\n     *\n     * @throws ProcessFailedException if the process didn't terminate successfully\n     *\n     * @final\n     */\n    public function mustRun(?callable $callback = null, array $env = []): static\n    {\n        if (0 !== $this->run($callback, $env)) {\n            throw new ProcessFailedException($this);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Starts the process and returns after writing the input to STDIN.\n     *\n     * This method blocks until all STDIN data is sent to the process then it\n     * returns while the process runs in the background.\n     *\n     * The termination of the process can be awaited with wait().\n     *\n     * The callback receives the type of output (out or err) and some bytes from\n     * the output in real-time while writing the standard input to the process.\n     * It allows to have feedback from the independent process during execution.\n     *\n     * @param callable|null $callback A PHP callback to run whenever there is some\n     *                                output available on STDOUT or STDERR\n     *\n     * @throws ProcessStartFailedException When process can't be launched\n     * @throws RuntimeException            When process is already running\n     * @throws LogicException              In case a callback is provided and output has been disabled\n     */\n    public function start(?callable $callback = null, array $env = []): void\n    {\n        if ($this->isRunning()) {\n            throw new RuntimeException('Process is already running.');\n        }\n\n        $this->resetProcessData();\n        $this->starttime = $this->lastOutputTime = microtime(true);\n        $this->callback = $this->buildCallback($callback);\n        $descriptors = $this->getDescriptors(null !== $callback);\n\n        if ($this->env) {\n            $env += '\\\\' === \\DIRECTORY_SEPARATOR ? array_diff_ukey($this->env, $env, 'strcasecmp') : $this->env;\n        }\n\n        $env += '\\\\' === \\DIRECTORY_SEPARATOR ? array_diff_ukey($this->getDefaultEnv(), $env, 'strcasecmp') : $this->getDefaultEnv();\n\n        if (\\is_array($commandline = $this->commandline)) {\n            $commandline = array_values(array_map(strval(...), $commandline));\n        } else {\n            $commandline = $this->replacePlaceholders($commandline, $env);\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $commandline = $this->prepareWindowsCommandLine($commandline, $env);\n        } elseif ($this->isSigchildEnabled()) {\n            // last exit code is output on the fourth pipe and caught to work around --enable-sigchild\n            $descriptors[3] = ['pipe', 'w'];\n\n            if (\\is_array($commandline)) {\n                // exec is mandatory to deal with sending a signal to the process\n                $commandline = 'exec '.$this->buildShellCommandline($commandline);\n            }\n\n            // See https://unix.stackexchange.com/questions/71205/background-process-pipe-input\n            $commandline = '{ ('.$commandline.') <&3 3<&- 3>/dev/null & } 3<&0;';\n            $commandline .= 'pid=$!; echo $pid >&3; wait $pid 2>/dev/null; code=$?; echo $code >&3; exit $code';\n        }\n\n        $envPairs = [];\n        foreach ($env as $k => $v) {\n            if (false !== $v && false === \\in_array($k, ['argc', 'argv', 'ARGC', 'ARGV'], true)) {\n                $envPairs[] = $k.'='.$v;\n            }\n        }\n\n        if (!is_dir($this->cwd)) {\n            throw new RuntimeException(\\sprintf('The provided cwd \"%s\" does not exist.', $this->cwd));\n        }\n\n        $lastError = null;\n        set_error_handler(function ($type, $msg) use (&$lastError) {\n            $lastError = $msg;\n\n            return true;\n        });\n\n        $oldMask = [];\n\n        if ($this->ignoredSignals && \\function_exists('pcntl_sigprocmask')) {\n            // we block signals we want to ignore, as proc_open will use fork / posix_spawn which will copy the signal mask this allow to block\n            // signals in the child process\n            pcntl_sigprocmask(\\SIG_BLOCK, $this->ignoredSignals, $oldMask);\n        }\n\n        try {\n            $process = @proc_open($commandline, $descriptors, $this->processPipes->pipes, $this->cwd, $envPairs, $this->options);\n\n            // Ensure array vs string commands behave the same\n            if (!$process && \\is_array($commandline)) {\n                $process = @proc_open('exec '.$this->buildShellCommandline($commandline), $descriptors, $this->processPipes->pipes, $this->cwd, $envPairs, $this->options);\n            }\n        } finally {\n            if ($this->ignoredSignals && \\function_exists('pcntl_sigprocmask')) {\n                // we restore the signal mask here to avoid any side effects\n                pcntl_sigprocmask(\\SIG_SETMASK, $oldMask);\n            }\n\n            restore_error_handler();\n        }\n\n        if (!$process) {\n            throw new ProcessStartFailedException($this, $lastError);\n        }\n        $this->process = $process;\n        $this->status = self::STATUS_STARTED;\n\n        if (isset($descriptors[3])) {\n            $this->fallbackStatus['pid'] = (int) fgets($this->processPipes->pipes[3]);\n        }\n\n        if ($this->tty) {\n            return;\n        }\n\n        $this->updateStatus(false);\n        $this->checkTimeout();\n    }\n\n    /**\n     * Restarts the process.\n     *\n     * Be warned that the process is cloned before being started.\n     *\n     * @param callable|null $callback A PHP callback to run whenever there is some\n     *                                output available on STDOUT or STDERR\n     *\n     * @throws ProcessStartFailedException When process can't be launched\n     * @throws RuntimeException            When process is already running\n     *\n     * @see start()\n     *\n     * @final\n     */\n    public function restart(?callable $callback = null, array $env = []): static\n    {\n        if ($this->isRunning()) {\n            throw new RuntimeException('Process is already running.');\n        }\n\n        $process = clone $this;\n        $process->start($callback, $env);\n\n        return $process;\n    }\n\n    /**\n     * Waits for the process to terminate.\n     *\n     * The callback receives the type of output (out or err) and some bytes\n     * from the output in real-time while writing the standard input to the process.\n     * It allows to have feedback from the independent process during execution.\n     *\n     * @param callable|null $callback A valid PHP callback\n     *\n     * @return int The exitcode of the process\n     *\n     * @throws ProcessTimedOutException When process timed out\n     * @throws ProcessSignaledException When process stopped after receiving signal\n     * @throws LogicException           When process is not yet started\n     */\n    public function wait(?callable $callback = null): int\n    {\n        $this->requireProcessIsStarted(__FUNCTION__);\n\n        $this->updateStatus(false);\n\n        if (null !== $callback) {\n            if (!$this->processPipes->haveReadSupport()) {\n                $this->stop(0);\n                throw new LogicException('Pass the callback to the \"Process::start\" method or call enableOutput to use a callback with \"Process::wait\".');\n            }\n            $this->callback = $this->buildCallback($callback);\n        }\n\n        do {\n            $this->checkTimeout();\n            $running = $this->isRunning() && ('\\\\' === \\DIRECTORY_SEPARATOR || $this->processPipes->areOpen());\n            $this->readPipes($running, '\\\\' !== \\DIRECTORY_SEPARATOR || !$running);\n        } while ($running);\n\n        while ($this->isRunning()) {\n            $this->checkTimeout();\n            usleep(1000);\n        }\n\n        if ($this->processInformation['signaled'] && $this->processInformation['termsig'] !== $this->latestSignal) {\n            throw new ProcessSignaledException($this);\n        }\n\n        return $this->exitcode;\n    }\n\n    /**\n     * Waits until the callback returns true.\n     *\n     * The callback receives the type of output (out or err) and some bytes\n     * from the output in real-time while writing the standard input to the process.\n     * It allows to have feedback from the independent process during execution.\n     *\n     * @throws RuntimeException         When process timed out\n     * @throws LogicException           When process is not yet started\n     * @throws ProcessTimedOutException In case the timeout was reached\n     */\n    public function waitUntil(callable $callback): bool\n    {\n        $this->requireProcessIsStarted(__FUNCTION__);\n        $this->updateStatus(false);\n\n        if (!$this->processPipes->haveReadSupport()) {\n            $this->stop(0);\n            throw new LogicException('Pass the callback to the \"Process::start\" method or call enableOutput to use a callback with \"Process::waitUntil\".');\n        }\n        $callback = $this->buildCallback($callback);\n\n        $ready = false;\n        while (true) {\n            $this->checkTimeout();\n            $running = '\\\\' === \\DIRECTORY_SEPARATOR ? $this->isRunning() : $this->processPipes->areOpen();\n            $output = $this->processPipes->readAndWrite($running, '\\\\' !== \\DIRECTORY_SEPARATOR || !$running);\n\n            foreach ($output as $type => $data) {\n                if (3 !== $type) {\n                    $ready = $callback(self::STDOUT === $type ? self::OUT : self::ERR, $data) || $ready;\n                } elseif (!isset($this->fallbackStatus['signaled'])) {\n                    $this->fallbackStatus['exitcode'] = (int) $data;\n                }\n            }\n            if ($ready) {\n                return true;\n            }\n            if (!$running) {\n                return false;\n            }\n\n            usleep(1000);\n        }\n    }\n\n    /**\n     * Returns the Pid (process identifier), if applicable.\n     *\n     * @return int|null The process id if running, null otherwise\n     */\n    public function getPid(): ?int\n    {\n        return $this->isRunning() ? $this->processInformation['pid'] : null;\n    }\n\n    /**\n     * Sends a POSIX signal to the process.\n     *\n     * @param int $signal A valid POSIX signal (see https://php.net/pcntl.constants)\n     *\n     * @return $this\n     *\n     * @throws LogicException   In case the process is not running\n     * @throws RuntimeException In case --enable-sigchild is activated and the process can't be killed\n     * @throws RuntimeException In case of failure\n     */\n    public function signal(int $signal): static\n    {\n        $this->doSignal($signal, true);\n\n        return $this;\n    }\n\n    /**\n     * Disables fetching output and error output from the underlying process.\n     *\n     * @return $this\n     *\n     * @throws RuntimeException In case the process is already running\n     * @throws LogicException   if an idle timeout is set\n     */\n    public function disableOutput(): static\n    {\n        if ($this->isRunning()) {\n            throw new RuntimeException('Disabling output while the process is running is not possible.');\n        }\n        if (null !== $this->idleTimeout) {\n            throw new LogicException('Output cannot be disabled while an idle timeout is set.');\n        }\n\n        $this->outputDisabled = true;\n\n        return $this;\n    }\n\n    /**\n     * Enables fetching output and error output from the underlying process.\n     *\n     * @return $this\n     *\n     * @throws RuntimeException In case the process is already running\n     */\n    public function enableOutput(): static\n    {\n        if ($this->isRunning()) {\n            throw new RuntimeException('Enabling output while the process is running is not possible.');\n        }\n\n        $this->outputDisabled = false;\n\n        return $this;\n    }\n\n    /**\n     * Returns true in case the output is disabled, false otherwise.\n     */\n    public function isOutputDisabled(): bool\n    {\n        return $this->outputDisabled;\n    }\n\n    /**\n     * Returns the current output of the process (STDOUT).\n     *\n     * @throws LogicException in case the output has been disabled\n     * @throws LogicException In case the process is not started\n     */\n    public function getOutput(): string\n    {\n        $this->readPipesForOutput(__FUNCTION__);\n\n        if (false === $ret = stream_get_contents($this->stdout, -1, 0)) {\n            return '';\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Returns the output incrementally.\n     *\n     * In comparison with the getOutput method which always return the whole\n     * output, this one returns the new output since the last call.\n     *\n     * @throws LogicException in case the output has been disabled\n     * @throws LogicException In case the process is not started\n     */\n    public function getIncrementalOutput(): string\n    {\n        $this->readPipesForOutput(__FUNCTION__);\n\n        $latest = stream_get_contents($this->stdout, -1, $this->incrementalOutputOffset);\n        $this->incrementalOutputOffset = ftell($this->stdout);\n\n        if (false === $latest) {\n            return '';\n        }\n\n        return $latest;\n    }\n\n    /**\n     * Returns an iterator to the output of the process, with the output type as keys (Process::OUT/ERR).\n     *\n     * @param int $flags A bit field of Process::ITER_* flags\n     *\n     * @return \\Generator<string, string>\n     *\n     * @throws LogicException in case the output has been disabled\n     * @throws LogicException In case the process is not started\n     */\n    public function getIterator(int $flags = 0): \\Generator\n    {\n        $this->readPipesForOutput(__FUNCTION__, false);\n\n        $clearOutput = !(self::ITER_KEEP_OUTPUT & $flags);\n        $blocking = !(self::ITER_NON_BLOCKING & $flags);\n        $yieldOut = !(self::ITER_SKIP_OUT & $flags);\n        $yieldErr = !(self::ITER_SKIP_ERR & $flags);\n\n        while (null !== $this->callback || ($yieldOut && !feof($this->stdout)) || ($yieldErr && !feof($this->stderr))) {\n            if ($yieldOut) {\n                $out = stream_get_contents($this->stdout, -1, $this->incrementalOutputOffset);\n\n                if (isset($out[0])) {\n                    if ($clearOutput) {\n                        $this->clearOutput();\n                    } else {\n                        $this->incrementalOutputOffset = ftell($this->stdout);\n                    }\n\n                    yield self::OUT => $out;\n                }\n            }\n\n            if ($yieldErr) {\n                $err = stream_get_contents($this->stderr, -1, $this->incrementalErrorOutputOffset);\n\n                if (isset($err[0])) {\n                    if ($clearOutput) {\n                        $this->clearErrorOutput();\n                    } else {\n                        $this->incrementalErrorOutputOffset = ftell($this->stderr);\n                    }\n\n                    yield self::ERR => $err;\n                }\n            }\n\n            if (!$blocking && !isset($out[0]) && !isset($err[0])) {\n                yield self::OUT => '';\n            }\n\n            $this->checkTimeout();\n            $this->readPipesForOutput(__FUNCTION__, $blocking);\n        }\n    }\n\n    /**\n     * Clears the process output.\n     *\n     * @return $this\n     */\n    public function clearOutput(): static\n    {\n        ftruncate($this->stdout, 0);\n        fseek($this->stdout, 0);\n        $this->incrementalOutputOffset = 0;\n\n        return $this;\n    }\n\n    /**\n     * Returns the current error output of the process (STDERR).\n     *\n     * @throws LogicException in case the output has been disabled\n     * @throws LogicException In case the process is not started\n     */\n    public function getErrorOutput(): string\n    {\n        $this->readPipesForOutput(__FUNCTION__);\n\n        if (false === $ret = stream_get_contents($this->stderr, -1, 0)) {\n            return '';\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Returns the errorOutput incrementally.\n     *\n     * In comparison with the getErrorOutput method which always return the\n     * whole error output, this one returns the new error output since the last\n     * call.\n     *\n     * @throws LogicException in case the output has been disabled\n     * @throws LogicException In case the process is not started\n     */\n    public function getIncrementalErrorOutput(): string\n    {\n        $this->readPipesForOutput(__FUNCTION__);\n\n        $latest = stream_get_contents($this->stderr, -1, $this->incrementalErrorOutputOffset);\n        $this->incrementalErrorOutputOffset = ftell($this->stderr);\n\n        if (false === $latest) {\n            return '';\n        }\n\n        return $latest;\n    }\n\n    /**\n     * Clears the process output.\n     *\n     * @return $this\n     */\n    public function clearErrorOutput(): static\n    {\n        ftruncate($this->stderr, 0);\n        fseek($this->stderr, 0);\n        $this->incrementalErrorOutputOffset = 0;\n\n        return $this;\n    }\n\n    /**\n     * Returns the exit code returned by the process.\n     *\n     * @return int|null The exit status code, null if the Process is not terminated\n     */\n    public function getExitCode(): ?int\n    {\n        $this->updateStatus(false);\n\n        return $this->exitcode;\n    }\n\n    /**\n     * Returns a string representation for the exit code returned by the process.\n     *\n     * This method relies on the Unix exit code status standardization\n     * and might not be relevant for other operating systems.\n     *\n     * @return string|null A string representation for the exit status code, null if the Process is not terminated\n     *\n     * @see http://tldp.org/LDP/abs/html/exitcodes.html\n     * @see http://en.wikipedia.org/wiki/Unix_signal\n     */\n    public function getExitCodeText(): ?string\n    {\n        if (null === $exitcode = $this->getExitCode()) {\n            return null;\n        }\n\n        return self::$exitCodes[$exitcode] ?? 'Unknown error';\n    }\n\n    /**\n     * Checks if the process ended successfully.\n     */\n    public function isSuccessful(): bool\n    {\n        return 0 === $this->getExitCode();\n    }\n\n    /**\n     * Returns true if the child process has been terminated by an uncaught signal.\n     *\n     * It always returns false on Windows.\n     *\n     * @throws LogicException In case the process is not terminated\n     */\n    public function hasBeenSignaled(): bool\n    {\n        $this->requireProcessIsTerminated(__FUNCTION__);\n\n        return $this->processInformation['signaled'];\n    }\n\n    /**\n     * Returns the number of the signal that caused the child process to terminate its execution.\n     *\n     * It is only meaningful if hasBeenSignaled() returns true.\n     *\n     * @throws RuntimeException In case --enable-sigchild is activated\n     * @throws LogicException   In case the process is not terminated\n     */\n    public function getTermSignal(): int\n    {\n        $this->requireProcessIsTerminated(__FUNCTION__);\n\n        if ($this->isSigchildEnabled() && -1 === $this->processInformation['termsig']) {\n            throw new RuntimeException('This PHP has been compiled with --enable-sigchild. Term signal cannot be retrieved.');\n        }\n\n        return $this->processInformation['termsig'];\n    }\n\n    /**\n     * Returns true if the child process has been stopped by a signal.\n     *\n     * It always returns false on Windows.\n     *\n     * @throws LogicException In case the process is not terminated\n     */\n    public function hasBeenStopped(): bool\n    {\n        $this->requireProcessIsTerminated(__FUNCTION__);\n\n        return $this->processInformation['stopped'];\n    }\n\n    /**\n     * Returns the number of the signal that caused the child process to stop its execution.\n     *\n     * It is only meaningful if hasBeenStopped() returns true.\n     *\n     * @throws LogicException In case the process is not terminated\n     */\n    public function getStopSignal(): int\n    {\n        $this->requireProcessIsTerminated(__FUNCTION__);\n\n        return $this->processInformation['stopsig'];\n    }\n\n    /**\n     * Checks if the process is currently running.\n     */\n    public function isRunning(): bool\n    {\n        if (self::STATUS_STARTED !== $this->status) {\n            return false;\n        }\n\n        $this->updateStatus(false);\n\n        return $this->processInformation['running'];\n    }\n\n    /**\n     * Checks if the process has been started with no regard to the current state.\n     */\n    public function isStarted(): bool\n    {\n        return self::STATUS_READY != $this->status;\n    }\n\n    /**\n     * Checks if the process is terminated.\n     */\n    public function isTerminated(): bool\n    {\n        $this->updateStatus(false);\n\n        return self::STATUS_TERMINATED == $this->status;\n    }\n\n    /**\n     * Gets the process status.\n     *\n     * The status is one of: ready, started, terminated.\n     */\n    public function getStatus(): string\n    {\n        $this->updateStatus(false);\n\n        return $this->status;\n    }\n\n    /**\n     * Stops the process.\n     *\n     * @param int|float $timeout The timeout in seconds\n     * @param int|null  $signal  A POSIX signal to send in case the process has not stop at timeout, default is SIGKILL (9)\n     *\n     * @return int|null The exit-code of the process or null if it's not running\n     */\n    public function stop(float $timeout = 10, ?int $signal = null): ?int\n    {\n        $timeoutMicro = microtime(true) + $timeout;\n        if ($this->isRunning()) {\n            // given SIGTERM may not be defined and that \"proc_terminate\" uses the constant value and not the constant itself, we use the same here\n            $this->doSignal(15, false);\n            do {\n                usleep(1000);\n            } while ($this->isRunning() && microtime(true) < $timeoutMicro);\n\n            if ($this->isRunning()) {\n                // Avoid exception here: process is supposed to be running, but it might have stopped just\n                // after this line. In any case, let's silently discard the error, we cannot do anything.\n                $this->doSignal($signal ?: 9, false);\n            }\n        }\n\n        if ($this->isRunning()) {\n            if (isset($this->fallbackStatus['pid'])) {\n                unset($this->fallbackStatus['pid']);\n\n                return $this->stop(0, $signal);\n            }\n            $this->close();\n        }\n\n        return $this->exitcode;\n    }\n\n    /**\n     * Adds a line to the STDOUT stream.\n     *\n     * @internal\n     */\n    public function addOutput(string $line): void\n    {\n        $this->lastOutputTime = microtime(true);\n\n        fseek($this->stdout, 0, \\SEEK_END);\n        fwrite($this->stdout, $line);\n        fseek($this->stdout, $this->incrementalOutputOffset);\n    }\n\n    /**\n     * Adds a line to the STDERR stream.\n     *\n     * @internal\n     */\n    public function addErrorOutput(string $line): void\n    {\n        $this->lastOutputTime = microtime(true);\n\n        fseek($this->stderr, 0, \\SEEK_END);\n        fwrite($this->stderr, $line);\n        fseek($this->stderr, $this->incrementalErrorOutputOffset);\n    }\n\n    /**\n     * Gets the last output time in seconds.\n     */\n    public function getLastOutputTime(): ?float\n    {\n        return $this->lastOutputTime;\n    }\n\n    /**\n     * Gets the command line to be executed.\n     */\n    public function getCommandLine(): string\n    {\n        return $this->buildShellCommandline($this->commandline);\n    }\n\n    /**\n     * Gets the process timeout in seconds (max. runtime).\n     */\n    public function getTimeout(): ?float\n    {\n        return $this->timeout;\n    }\n\n    /**\n     * Gets the process idle timeout in seconds (max. time since last output).\n     */\n    public function getIdleTimeout(): ?float\n    {\n        return $this->idleTimeout;\n    }\n\n    /**\n     * Sets the process timeout (max. runtime) in seconds.\n     *\n     * To disable the timeout, set this value to null.\n     *\n     * @return $this\n     *\n     * @throws InvalidArgumentException if the timeout is negative\n     */\n    public function setTimeout(?float $timeout): static\n    {\n        $this->timeout = $this->validateTimeout($timeout);\n\n        return $this;\n    }\n\n    /**\n     * Sets the process idle timeout (max. time since last output) in seconds.\n     *\n     * To disable the timeout, set this value to null.\n     *\n     * @return $this\n     *\n     * @throws LogicException           if the output is disabled\n     * @throws InvalidArgumentException if the timeout is negative\n     */\n    public function setIdleTimeout(?float $timeout): static\n    {\n        if (null !== $timeout && $this->outputDisabled) {\n            throw new LogicException('Idle timeout cannot be set while the output is disabled.');\n        }\n\n        $this->idleTimeout = $this->validateTimeout($timeout);\n\n        return $this;\n    }\n\n    /**\n     * Enables or disables the TTY mode.\n     *\n     * @return $this\n     *\n     * @throws RuntimeException In case the TTY mode is not supported\n     */\n    public function setTty(bool $tty): static\n    {\n        if ('\\\\' === \\DIRECTORY_SEPARATOR && $tty) {\n            throw new RuntimeException('TTY mode is not supported on Windows platform.');\n        }\n\n        if ($tty && !self::isTtySupported()) {\n            throw new RuntimeException('TTY mode requires /dev/tty to be read/writable.');\n        }\n\n        $this->tty = $tty;\n\n        return $this;\n    }\n\n    /**\n     * Checks if the TTY mode is enabled.\n     */\n    public function isTty(): bool\n    {\n        return $this->tty;\n    }\n\n    /**\n     * Sets PTY mode.\n     *\n     * @return $this\n     */\n    public function setPty(bool $bool): static\n    {\n        $this->pty = $bool;\n\n        return $this;\n    }\n\n    /**\n     * Returns PTY state.\n     */\n    public function isPty(): bool\n    {\n        return $this->pty;\n    }\n\n    /**\n     * Gets the working directory.\n     */\n    public function getWorkingDirectory(): ?string\n    {\n        if (null === $this->cwd) {\n            // getcwd() will return false if any one of the parent directories does not have\n            // the readable or search mode set, even if the current directory does\n            return getcwd() ?: null;\n        }\n\n        return $this->cwd;\n    }\n\n    /**\n     * Sets the current working directory.\n     *\n     * @return $this\n     */\n    public function setWorkingDirectory(string $cwd): static\n    {\n        $this->cwd = $cwd;\n\n        return $this;\n    }\n\n    /**\n     * Gets the environment variables.\n     */\n    public function getEnv(): array\n    {\n        return $this->env;\n    }\n\n    /**\n     * Sets the environment variables.\n     *\n     * @param array<string|\\Stringable> $env The new environment variables\n     *\n     * @return $this\n     */\n    public function setEnv(array $env): static\n    {\n        $this->env = $env;\n\n        return $this;\n    }\n\n    /**\n     * Gets the Process input.\n     *\n     * @return resource|string|\\Iterator|null\n     */\n    public function getInput()\n    {\n        return $this->input;\n    }\n\n    /**\n     * Sets the input.\n     *\n     * This content will be passed to the underlying process standard input.\n     *\n     * @param string|resource|\\Traversable|self|null $input The content\n     *\n     * @return $this\n     *\n     * @throws LogicException In case the process is running\n     */\n    public function setInput(mixed $input): static\n    {\n        if ($this->isRunning()) {\n            throw new LogicException('Input cannot be set while the process is running.');\n        }\n\n        $this->input = ProcessUtils::validateInput(__METHOD__, $input);\n\n        return $this;\n    }\n\n    /**\n     * Performs a check between the timeout definition and the time the process started.\n     *\n     * In case you run a background process (with the start method), you should\n     * trigger this method regularly to ensure the process timeout\n     *\n     * @throws ProcessTimedOutException In case the timeout was reached\n     */\n    public function checkTimeout(): void\n    {\n        if (self::STATUS_STARTED !== $this->status) {\n            return;\n        }\n\n        if (null !== $this->timeout && $this->timeout < microtime(true) - $this->starttime) {\n            $this->stop(0);\n\n            throw new ProcessTimedOutException($this, ProcessTimedOutException::TYPE_GENERAL);\n        }\n\n        if (null !== $this->idleTimeout && $this->idleTimeout < microtime(true) - $this->lastOutputTime) {\n            $this->stop(0);\n\n            throw new ProcessTimedOutException($this, ProcessTimedOutException::TYPE_IDLE);\n        }\n    }\n\n    /**\n     * @throws LogicException in case process is not started\n     */\n    public function getStartTime(): float\n    {\n        if (!$this->isStarted()) {\n            throw new LogicException('Start time is only available after process start.');\n        }\n\n        return $this->starttime;\n    }\n\n    /**\n     * Defines options to pass to the underlying proc_open().\n     *\n     * @see https://php.net/proc_open for the options supported by PHP.\n     *\n     * Enabling the \"create_new_console\" option allows a subprocess to continue\n     * to run after the main process exited, on both Windows and *nix\n     */\n    public function setOptions(array $options): void\n    {\n        if ($this->isRunning()) {\n            throw new RuntimeException('Setting options while the process is running is not possible.');\n        }\n\n        $defaultOptions = $this->options;\n        $existingOptions = ['blocking_pipes', 'create_process_group', 'create_new_console'];\n\n        foreach ($options as $key => $value) {\n            if (!\\in_array($key, $existingOptions)) {\n                $this->options = $defaultOptions;\n                throw new LogicException(\\sprintf('Invalid option \"%s\" passed to \"%s()\". Supported options are \"%s\".', $key, __METHOD__, implode('\", \"', $existingOptions)));\n            }\n            $this->options[$key] = $value;\n        }\n    }\n\n    /**\n     * Defines a list of posix signals that will not be propagated to the process.\n     *\n     * @param list<\\SIG*> $signals\n     */\n    public function setIgnoredSignals(array $signals): void\n    {\n        if ($this->isRunning()) {\n            throw new RuntimeException('Setting ignored signals while the process is running is not possible.');\n        }\n\n        $this->ignoredSignals = $signals;\n    }\n\n    /**\n     * Returns whether TTY is supported on the current operating system.\n     */\n    public static function isTtySupported(): bool\n    {\n        static $isTtySupported;\n\n        return $isTtySupported ??= ('/' === \\DIRECTORY_SEPARATOR && stream_isatty(\\STDOUT) && @is_writable('/dev/tty'));\n    }\n\n    /**\n     * Returns whether PTY is supported on the current operating system.\n     */\n    public static function isPtySupported(): bool\n    {\n        static $result;\n\n        if (null !== $result) {\n            return $result;\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            return $result = false;\n        }\n\n        return $result = (bool) @proc_open('echo 1 >/dev/null', [['pty'], ['pty'], ['pty']], $pipes);\n    }\n\n    /**\n     * Creates the descriptors needed by the proc_open.\n     */\n    private function getDescriptors(bool $hasCallback): array\n    {\n        if ($this->input instanceof \\Iterator) {\n            $this->input->rewind();\n        }\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $this->processPipes = new WindowsPipes($this->input, !$this->outputDisabled || $hasCallback);\n        } else {\n            $this->processPipes = new UnixPipes($this->isTty(), $this->isPty(), $this->input, !$this->outputDisabled || $hasCallback);\n        }\n\n        return $this->processPipes->getDescriptors();\n    }\n\n    /**\n     * Builds up the callback used by wait().\n     *\n     * The callbacks adds all occurred output to the specific buffer and calls\n     * the user callback (if present) with the received output.\n     *\n     * @param callable|null $callback The user defined PHP callback\n     */\n    protected function buildCallback(?callable $callback = null): \\Closure\n    {\n        if ($this->outputDisabled) {\n            return fn ($type, $data): bool => null !== $callback && $callback($type, $data);\n        }\n\n        $out = self::OUT;\n\n        return function ($type, $data) use ($callback, $out): bool {\n            if ($out == $type) {\n                $this->addOutput($data);\n            } else {\n                $this->addErrorOutput($data);\n            }\n\n            return null !== $callback && $callback($type, $data);\n        };\n    }\n\n    /**\n     * Updates the status of the process, reads pipes.\n     *\n     * @param bool $blocking Whether to use a blocking read call\n     */\n    protected function updateStatus(bool $blocking): void\n    {\n        if (self::STATUS_STARTED !== $this->status) {\n            return;\n        }\n\n        $this->processInformation = proc_get_status($this->process);\n        $running = $this->processInformation['running'];\n\n        // In PHP < 8.3, \"proc_get_status\" only returns the correct exit status on the first call.\n        // Subsequent calls return -1 as the process is discarded. This workaround caches the first\n        // retrieved exit status for consistent results in later calls, mimicking PHP 8.3 behavior.\n        if (\\PHP_VERSION_ID < 80300) {\n            if (!isset($this->cachedExitCode) && !$running && -1 !== $this->processInformation['exitcode']) {\n                $this->cachedExitCode = $this->processInformation['exitcode'];\n            }\n\n            if (isset($this->cachedExitCode) && !$running && -1 === $this->processInformation['exitcode']) {\n                $this->processInformation['exitcode'] = $this->cachedExitCode;\n            }\n        }\n\n        $this->readPipes($running && $blocking, '\\\\' !== \\DIRECTORY_SEPARATOR || !$running);\n\n        if ($this->fallbackStatus && $this->isSigchildEnabled()) {\n            $this->processInformation = $this->fallbackStatus + $this->processInformation;\n        }\n\n        if (!$running) {\n            $this->close();\n        }\n    }\n\n    /**\n     * Returns whether PHP has been compiled with the '--enable-sigchild' option or not.\n     */\n    protected function isSigchildEnabled(): bool\n    {\n        if (null !== self::$sigchild) {\n            return self::$sigchild;\n        }\n\n        if (!\\function_exists('phpinfo')) {\n            return self::$sigchild = false;\n        }\n\n        ob_start();\n        phpinfo(\\INFO_GENERAL);\n\n        return self::$sigchild = str_contains(ob_get_clean(), '--enable-sigchild');\n    }\n\n    /**\n     * Reads pipes for the freshest output.\n     *\n     * @param string $caller   The name of the method that needs fresh outputs\n     * @param bool   $blocking Whether to use blocking calls or not\n     *\n     * @throws LogicException in case output has been disabled or process is not started\n     */\n    private function readPipesForOutput(string $caller, bool $blocking = false): void\n    {\n        if ($this->outputDisabled) {\n            throw new LogicException('Output has been disabled.');\n        }\n\n        $this->requireProcessIsStarted($caller);\n\n        $this->updateStatus($blocking);\n    }\n\n    /**\n     * Validates and returns the filtered timeout.\n     *\n     * @throws InvalidArgumentException if the given timeout is a negative number\n     */\n    private function validateTimeout(?float $timeout): ?float\n    {\n        $timeout = (float) $timeout;\n\n        if (0.0 === $timeout) {\n            $timeout = null;\n        } elseif ($timeout < 0) {\n            throw new InvalidArgumentException('The timeout value must be a valid positive integer or float number.');\n        }\n\n        return $timeout;\n    }\n\n    /**\n     * Reads pipes, executes callback.\n     *\n     * @param bool $blocking Whether to use blocking calls or not\n     * @param bool $close    Whether to close file handles or not\n     */\n    private function readPipes(bool $blocking, bool $close): void\n    {\n        $result = $this->processPipes->readAndWrite($blocking, $close);\n\n        $callback = $this->callback;\n        foreach ($result as $type => $data) {\n            if (3 !== $type) {\n                $callback(self::STDOUT === $type ? self::OUT : self::ERR, $data);\n            } elseif (!isset($this->fallbackStatus['signaled'])) {\n                $this->fallbackStatus['exitcode'] = (int) $data;\n            }\n        }\n    }\n\n    /**\n     * Closes process resource, closes file handles, sets the exitcode.\n     *\n     * @return int The exitcode\n     */\n    private function close(): int\n    {\n        $this->processPipes->close();\n        if ($this->process) {\n            proc_close($this->process);\n            $this->process = null;\n        }\n        $this->exitcode = $this->processInformation['exitcode'];\n        $this->status = self::STATUS_TERMINATED;\n\n        if (-1 === $this->exitcode) {\n            if ($this->processInformation['signaled'] && 0 < $this->processInformation['termsig']) {\n                // if process has been signaled, no exitcode but a valid termsig, apply Unix convention\n                $this->exitcode = 128 + $this->processInformation['termsig'];\n            } elseif ($this->isSigchildEnabled()) {\n                $this->processInformation['signaled'] = true;\n                $this->processInformation['termsig'] = -1;\n            }\n        }\n\n        // Free memory from self-reference callback created by buildCallback\n        // Doing so in other contexts like __destruct or by garbage collector is ineffective\n        // Now pipes are closed, so the callback is no longer necessary\n        $this->callback = null;\n\n        return $this->exitcode;\n    }\n\n    /**\n     * Resets data related to the latest run of the process.\n     */\n    private function resetProcessData(): void\n    {\n        $this->starttime = null;\n        $this->callback = null;\n        $this->exitcode = null;\n        $this->fallbackStatus = [];\n        $this->processInformation = [];\n        $this->stdout = fopen('php://temp/maxmemory:'.(1024 * 1024), 'w+');\n        $this->stderr = fopen('php://temp/maxmemory:'.(1024 * 1024), 'w+');\n        $this->process = null;\n        $this->latestSignal = null;\n        $this->status = self::STATUS_READY;\n        $this->incrementalOutputOffset = 0;\n        $this->incrementalErrorOutputOffset = 0;\n    }\n\n    /**\n     * Sends a POSIX signal to the process.\n     *\n     * @param int  $signal         A valid POSIX signal (see https://php.net/pcntl.constants)\n     * @param bool $throwException Whether to throw exception in case signal failed\n     *\n     * @throws LogicException   In case the process is not running\n     * @throws RuntimeException In case --enable-sigchild is activated and the process can't be killed\n     * @throws RuntimeException In case of failure\n     */\n    private function doSignal(int $signal, bool $throwException): bool\n    {\n        // Signal seems to be send when sigchild is enable, this allow blocking the signal correctly in this case\n        if ($this->isSigchildEnabled() && \\in_array($signal, $this->ignoredSignals)) {\n            return false;\n        }\n\n        if (null === $pid = $this->getPid()) {\n            if ($throwException) {\n                throw new LogicException('Cannot send signal on a non running process.');\n            }\n\n            return false;\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            exec(\\sprintf('taskkill /F /T /PID %d 2>&1', $pid), $output, $exitCode);\n            if ($exitCode && $this->isRunning()) {\n                if ($throwException) {\n                    throw new RuntimeException(\\sprintf('Unable to kill the process (%s).', implode(' ', $output)));\n                }\n\n                return false;\n            }\n        } else {\n            if (!$this->isSigchildEnabled()) {\n                $ok = @proc_terminate($this->process, $signal);\n            } elseif (\\function_exists('posix_kill')) {\n                $ok = @posix_kill($pid, $signal);\n            } elseif ($ok = proc_open(\\sprintf('kill -%d %d', $signal, $pid), [2 => ['pipe', 'w']], $pipes)) {\n                $ok = false === fgets($pipes[2]);\n            }\n            if (!$ok) {\n                if ($throwException) {\n                    throw new RuntimeException(\\sprintf('Error while sending signal \"%s\".', $signal));\n                }\n\n                return false;\n            }\n        }\n\n        $this->latestSignal = $signal;\n        $this->fallbackStatus['signaled'] = true;\n        $this->fallbackStatus['exitcode'] = -1;\n        $this->fallbackStatus['termsig'] = $this->latestSignal;\n\n        return true;\n    }\n\n    private function buildShellCommandline(string|array $commandline): string\n    {\n        if (\\is_string($commandline)) {\n            return $commandline;\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR && isset($commandline[0][0]) && \\strlen($commandline[0]) === strcspn($commandline[0], ':/\\\\')) {\n            // On Windows, we don't rely on the OS to find the executable if possible to avoid lookups\n            // in the current directory which could be untrusted. Instead we use the ExecutableFinder.\n            $commandline[0] = (self::$executables[$commandline[0]] ??= (new ExecutableFinder())->find($commandline[0])) ?? $commandline[0];\n        }\n\n        return implode(' ', array_map($this->escapeArgument(...), $commandline));\n    }\n\n    private function prepareWindowsCommandLine(string|array $cmd, array &$env): string\n    {\n        $cmd = $this->buildShellCommandline($cmd);\n        $uid = bin2hex(random_bytes(4));\n        $cmd = preg_replace_callback(\n            '/\"(?:(\n                [^\"%!^]*+\n                (?:\n                    (?: !LF! | \"(?:\\^[%!^])?+\" )\n                    [^\"%!^]*+\n                )++\n            ) | [^\"]*+ )\"/x',\n            function ($m) use (&$env, $uid) {\n                static $varCount = 0;\n                static $varCache = [];\n                if (!isset($m[1])) {\n                    return $m[0];\n                }\n                if (isset($varCache[$m[0]])) {\n                    return $varCache[$m[0]];\n                }\n                if (str_contains($value = $m[1], \"\\0\")) {\n                    $value = str_replace(\"\\0\", '?', $value);\n                }\n                if (false === strpbrk($value, \"\\\"%!\\n\")) {\n                    return '\"'.$value.'\"';\n                }\n\n                $value = str_replace(['!LF!', '\"^!\"', '\"^%\"', '\"^^\"', '\"\"'], [\"\\n\", '!', '%', '^', '\"'], $value);\n                $value = '\"'.preg_replace('/(\\\\\\\\*)\"/', '$1$1\\\\\"', $value).'\"';\n                $var = $uid.++$varCount;\n\n                $env[$var] = $value;\n\n                return $varCache[$m[0]] = '!'.$var.'!';\n            },\n            $cmd\n        );\n\n        static $comSpec;\n\n        if (!$comSpec && $comSpec = (new ExecutableFinder())->find('cmd.exe')) {\n            // Escape according to CommandLineToArgvW rules\n            $comSpec = '\"'.preg_replace('{(\\\\\\\\*+)\"}', '$1$1\\\"', $comSpec) .'\"';\n        }\n\n        $cmd = ($comSpec ?? 'cmd').' /V:ON /E:ON /D /C ('.str_replace(\"\\n\", ' ', $cmd).')';\n        foreach ($this->processPipes->getFiles() as $offset => $filename) {\n            $cmd .= ' '.$offset.'>\"'.$filename.'\"';\n        }\n\n        return $cmd;\n    }\n\n    /**\n     * Ensures the process is running or terminated, throws a LogicException if the process has a not started.\n     *\n     * @throws LogicException if the process has not run\n     */\n    private function requireProcessIsStarted(string $functionName): void\n    {\n        if (!$this->isStarted()) {\n            throw new LogicException(\\sprintf('Process must be started before calling \"%s()\".', $functionName));\n        }\n    }\n\n    /**\n     * Ensures the process is terminated, throws a LogicException if the process has a status different than \"terminated\".\n     *\n     * @throws LogicException if the process is not yet terminated\n     */\n    private function requireProcessIsTerminated(string $functionName): void\n    {\n        if (!$this->isTerminated()) {\n            throw new LogicException(\\sprintf('Process must be terminated before calling \"%s()\".', $functionName));\n        }\n    }\n\n    /**\n     * Escapes a string to be used as a shell argument.\n     */\n    private function escapeArgument(?string $argument): string\n    {\n        if ('' === $argument || null === $argument) {\n            return '\"\"';\n        }\n        if ('\\\\' !== \\DIRECTORY_SEPARATOR) {\n            return \"'\".str_replace(\"'\", \"'\\\\''\", $argument).\"'\";\n        }\n        if (str_contains($argument, \"\\0\")) {\n            $argument = str_replace(\"\\0\", '?', $argument);\n        }\n        if (!preg_match('/[()%!^\"<>&|\\s]/', $argument)) {\n            return $argument;\n        }\n        $argument = preg_replace('/(\\\\\\\\+)$/', '$1$1', $argument);\n\n        return '\"'.str_replace(['\"', '^', '%', '!', \"\\n\"], ['\"\"', '\"^^\"', '\"^%\"', '\"^!\"', '!LF!'], $argument).'\"';\n    }\n\n    private function replacePlaceholders(string $commandline, array $env): string\n    {\n        return preg_replace_callback('/\"\\$\\{:([_a-zA-Z]++[_a-zA-Z0-9]*+)\\}\"/', function ($matches) use ($commandline, $env) {\n            if (!isset($env[$matches[1]]) || false === $env[$matches[1]]) {\n                throw new InvalidArgumentException(\\sprintf('Command line is missing a value for parameter \"%s\": ', $matches[1]).$commandline);\n            }\n\n            return $this->escapeArgument($env[$matches[1]]);\n        }, $commandline);\n    }\n\n    private function getDefaultEnv(): array\n    {\n        $env = getenv();\n        $env = ('\\\\' === \\DIRECTORY_SEPARATOR ? array_intersect_ukey($env, $_SERVER, 'strcasecmp') : array_intersect_key($env, $_SERVER)) ?: $env;\n\n        return $_ENV + ('\\\\' === \\DIRECTORY_SEPARATOR ? array_diff_ukey($env, $_ENV, 'strcasecmp') : $env);\n    }\n}\n"
        },
        {
          "name": "ProcessUtils.php",
          "type": "blob",
          "size": 1.7119140625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Process;\n\nuse Symfony\\Component\\Process\\Exception\\InvalidArgumentException;\n\n/**\n * ProcessUtils is a bunch of utility methods.\n *\n * This class contains static methods only and is not meant to be instantiated.\n *\n * @author Martin Haso <martin.hason@gmail.com>\n */\nclass ProcessUtils\n{\n    /**\n     * This class should not be instantiated.\n     */\n    private function __construct()\n    {\n    }\n\n    /**\n     * Validates and normalizes a Process input.\n     *\n     * @param string $caller The name of method call that validates the input\n     * @param mixed  $input  The input to validate\n     *\n     * @throws InvalidArgumentException In case the input is not valid\n     */\n    public static function validateInput(string $caller, mixed $input): mixed\n    {\n        if (null !== $input) {\n            if (\\is_resource($input)) {\n                return $input;\n            }\n            if (\\is_scalar($input)) {\n                return (string) $input;\n            }\n            if ($input instanceof Process) {\n                return $input->getIterator($input::ITER_SKIP_ERR);\n            }\n            if ($input instanceof \\Iterator) {\n                return $input;\n            }\n            if ($input instanceof \\Traversable) {\n                return new \\IteratorIterator($input);\n            }\n\n            throw new InvalidArgumentException(\\sprintf('\"%s\" only accepts strings, Traversable objects or stream resources.', $caller));\n        }\n\n        return $input;\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.4609375,
          "content": "Process Component\n=================\n\nThe Process component executes commands in sub-processes.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/process.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.6552734375,
          "content": "{\n    \"name\": \"symfony/process\",\n    \"type\": \"library\",\n    \"description\": \"Executes commands in sub-processes\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Process\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.798828125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Process Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}