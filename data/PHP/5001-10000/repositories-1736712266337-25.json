{
  "metadata": {
    "timestamp": 1736712266337,
    "page": 25,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/http-foundation",
      "stars": 8646,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "AcceptHeader.php",
          "type": "blob",
          "size": 3.35546875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(AcceptHeaderItem::class);\n\n/**\n * Represents an Accept-* header.\n *\n * An accept header is compound with a list of items,\n * sorted by descending quality.\n *\n * @author Jean-François Simon <contact@jfsimon.fr>\n */\nclass AcceptHeader\n{\n    /**\n     * @var AcceptHeaderItem[]\n     */\n    private array $items = [];\n\n    private bool $sorted = true;\n\n    /**\n     * @param AcceptHeaderItem[] $items\n     */\n    public function __construct(array $items)\n    {\n        foreach ($items as $item) {\n            $this->add($item);\n        }\n    }\n\n    /**\n     * Builds an AcceptHeader instance from a string.\n     */\n    public static function fromString(?string $headerValue): self\n    {\n        $parts = HeaderUtils::split($headerValue ?? '', ',;=');\n\n        return new self(array_map(function ($subParts) {\n            static $index = 0;\n            $part = array_shift($subParts);\n            $attributes = HeaderUtils::combine($subParts);\n\n            $item = new AcceptHeaderItem($part[0], $attributes);\n            $item->setIndex($index++);\n\n            return $item;\n        }, $parts));\n    }\n\n    /**\n     * Returns header value's string representation.\n     */\n    public function __toString(): string\n    {\n        return implode(',', $this->items);\n    }\n\n    /**\n     * Tests if header has given value.\n     */\n    public function has(string $value): bool\n    {\n        return isset($this->items[$value]);\n    }\n\n    /**\n     * Returns given value's item, if exists.\n     */\n    public function get(string $value): ?AcceptHeaderItem\n    {\n        return $this->items[$value] ?? $this->items[explode('/', $value)[0].'/*'] ?? $this->items['*/*'] ?? $this->items['*'] ?? null;\n    }\n\n    /**\n     * Adds an item.\n     *\n     * @return $this\n     */\n    public function add(AcceptHeaderItem $item): static\n    {\n        $this->items[$item->getValue()] = $item;\n        $this->sorted = false;\n\n        return $this;\n    }\n\n    /**\n     * Returns all items.\n     *\n     * @return AcceptHeaderItem[]\n     */\n    public function all(): array\n    {\n        $this->sort();\n\n        return $this->items;\n    }\n\n    /**\n     * Filters items on their value using given regex.\n     */\n    public function filter(string $pattern): self\n    {\n        return new self(array_filter($this->items, fn (AcceptHeaderItem $item) => preg_match($pattern, $item->getValue())));\n    }\n\n    /**\n     * Returns first item.\n     */\n    public function first(): ?AcceptHeaderItem\n    {\n        $this->sort();\n\n        return $this->items ? reset($this->items) : null;\n    }\n\n    /**\n     * Sorts items by descending quality.\n     */\n    private function sort(): void\n    {\n        if (!$this->sorted) {\n            uasort($this->items, function (AcceptHeaderItem $a, AcceptHeaderItem $b) {\n                $qA = $a->getQuality();\n                $qB = $b->getQuality();\n\n                if ($qA === $qB) {\n                    return $a->getIndex() > $b->getIndex() ? 1 : -1;\n                }\n\n                return $qA > $qB ? -1 : 1;\n            });\n\n            $this->sorted = true;\n        }\n    }\n}\n"
        },
        {
          "name": "AcceptHeaderItem.php",
          "type": "blob",
          "size": 3.158203125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * Represents an Accept-* header item.\n *\n * @author Jean-François Simon <contact@jfsimon.fr>\n */\nclass AcceptHeaderItem\n{\n    private float $quality = 1.0;\n    private int $index = 0;\n    private array $attributes = [];\n\n    public function __construct(\n        private string $value,\n        array $attributes = [],\n    ) {\n        foreach ($attributes as $name => $value) {\n            $this->setAttribute($name, $value);\n        }\n    }\n\n    /**\n     * Builds an AcceptHeaderInstance instance from a string.\n     */\n    public static function fromString(?string $itemValue): self\n    {\n        $parts = HeaderUtils::split($itemValue ?? '', ';=');\n\n        $part = array_shift($parts);\n        $attributes = HeaderUtils::combine($parts);\n\n        return new self($part[0], $attributes);\n    }\n\n    /**\n     * Returns header value's string representation.\n     */\n    public function __toString(): string\n    {\n        $string = $this->value.($this->quality < 1 ? ';q='.$this->quality : '');\n        if (\\count($this->attributes) > 0) {\n            $string .= '; '.HeaderUtils::toString($this->attributes, ';');\n        }\n\n        return $string;\n    }\n\n    /**\n     * Set the item value.\n     *\n     * @return $this\n     */\n    public function setValue(string $value): static\n    {\n        $this->value = $value;\n\n        return $this;\n    }\n\n    /**\n     * Returns the item value.\n     */\n    public function getValue(): string\n    {\n        return $this->value;\n    }\n\n    /**\n     * Set the item quality.\n     *\n     * @return $this\n     */\n    public function setQuality(float $quality): static\n    {\n        $this->quality = $quality;\n\n        return $this;\n    }\n\n    /**\n     * Returns the item quality.\n     */\n    public function getQuality(): float\n    {\n        return $this->quality;\n    }\n\n    /**\n     * Set the item index.\n     *\n     * @return $this\n     */\n    public function setIndex(int $index): static\n    {\n        $this->index = $index;\n\n        return $this;\n    }\n\n    /**\n     * Returns the item index.\n     */\n    public function getIndex(): int\n    {\n        return $this->index;\n    }\n\n    /**\n     * Tests if an attribute exists.\n     */\n    public function hasAttribute(string $name): bool\n    {\n        return isset($this->attributes[$name]);\n    }\n\n    /**\n     * Returns an attribute by its name.\n     */\n    public function getAttribute(string $name, mixed $default = null): mixed\n    {\n        return $this->attributes[$name] ?? $default;\n    }\n\n    /**\n     * Returns all attributes.\n     */\n    public function getAttributes(): array\n    {\n        return $this->attributes;\n    }\n\n    /**\n     * Set an attribute.\n     *\n     * @return $this\n     */\n    public function setAttribute(string $name, string $value): static\n    {\n        if ('q' === $name) {\n            $this->quality = (float) $value;\n        } else {\n            $this->attributes[$name] = $value;\n        }\n\n        return $this;\n    }\n}\n"
        },
        {
          "name": "BinaryFileResponse.php",
          "type": "blob",
          "size": 13.2060546875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\File\\Exception\\FileException;\nuse Symfony\\Component\\HttpFoundation\\File\\File;\n\n/**\n * BinaryFileResponse represents an HTTP response delivering a file.\n *\n * @author Niklas Fiekas <niklas.fiekas@tu-clausthal.de>\n * @author stealth35 <stealth35-php@live.fr>\n * @author Igor Wiedler <igor@wiedler.ch>\n * @author Jordan Alliot <jordan.alliot@gmail.com>\n * @author Sergey Linnik <linniksa@gmail.com>\n */\nclass BinaryFileResponse extends Response\n{\n    protected static bool $trustXSendfileTypeHeader = false;\n\n    protected File $file;\n    protected ?\\SplTempFileObject $tempFileObject = null;\n    protected int $offset = 0;\n    protected int $maxlen = -1;\n    protected bool $deleteFileAfterSend = false;\n    protected int $chunkSize = 16 * 1024;\n\n    /**\n     * @param \\SplFileInfo|string $file               The file to stream\n     * @param int                 $status             The response status code (200 \"OK\" by default)\n     * @param array               $headers            An array of response headers\n     * @param bool                $public             Files are public by default\n     * @param string|null         $contentDisposition The type of Content-Disposition to set automatically with the filename\n     * @param bool                $autoEtag           Whether the ETag header should be automatically set\n     * @param bool                $autoLastModified   Whether the Last-Modified header should be automatically set\n     */\n    public function __construct(\\SplFileInfo|string $file, int $status = 200, array $headers = [], bool $public = true, ?string $contentDisposition = null, bool $autoEtag = false, bool $autoLastModified = true)\n    {\n        parent::__construct(null, $status, $headers);\n\n        $this->setFile($file, $contentDisposition, $autoEtag, $autoLastModified);\n\n        if ($public) {\n            $this->setPublic();\n        }\n    }\n\n    /**\n     * Sets the file to stream.\n     *\n     * @return $this\n     *\n     * @throws FileException\n     */\n    public function setFile(\\SplFileInfo|string $file, ?string $contentDisposition = null, bool $autoEtag = false, bool $autoLastModified = true): static\n    {\n        $isTemporaryFile = $file instanceof \\SplTempFileObject;\n        $this->tempFileObject = $isTemporaryFile ? $file : null;\n\n        if (!$file instanceof File) {\n            if ($file instanceof \\SplFileInfo) {\n                $file = new File($file->getPathname(), !$isTemporaryFile);\n            } else {\n                $file = new File($file);\n            }\n        }\n\n        if (!$file->isReadable() && !$isTemporaryFile) {\n            throw new FileException('File must be readable.');\n        }\n\n        $this->file = $file;\n\n        if ($autoEtag) {\n            $this->setAutoEtag();\n        }\n\n        if ($autoLastModified && !$isTemporaryFile) {\n            $this->setAutoLastModified();\n        }\n\n        if ($contentDisposition) {\n            $this->setContentDisposition($contentDisposition);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Gets the file.\n     */\n    public function getFile(): File\n    {\n        return $this->file;\n    }\n\n    /**\n     * Sets the response stream chunk size.\n     *\n     * @return $this\n     */\n    public function setChunkSize(int $chunkSize): static\n    {\n        if ($chunkSize < 1) {\n            throw new \\InvalidArgumentException('The chunk size of a BinaryFileResponse cannot be less than 1.');\n        }\n\n        $this->chunkSize = $chunkSize;\n\n        return $this;\n    }\n\n    /**\n     * Automatically sets the Last-Modified header according the file modification date.\n     *\n     * @return $this\n     */\n    public function setAutoLastModified(): static\n    {\n        $this->setLastModified(\\DateTimeImmutable::createFromFormat('U', $this->tempFileObject ? time() : $this->file->getMTime()));\n\n        return $this;\n    }\n\n    /**\n     * Automatically sets the ETag header according to the checksum of the file.\n     *\n     * @return $this\n     */\n    public function setAutoEtag(): static\n    {\n        $this->setEtag(base64_encode(hash_file('xxh128', $this->file->getPathname(), true)));\n\n        return $this;\n    }\n\n    /**\n     * Sets the Content-Disposition header with the given filename.\n     *\n     * @param string $disposition      ResponseHeaderBag::DISPOSITION_INLINE or ResponseHeaderBag::DISPOSITION_ATTACHMENT\n     * @param string $filename         Optionally use this UTF-8 encoded filename instead of the real name of the file\n     * @param string $filenameFallback A fallback filename, containing only ASCII characters. Defaults to an automatically encoded filename\n     *\n     * @return $this\n     */\n    public function setContentDisposition(string $disposition, string $filename = '', string $filenameFallback = ''): static\n    {\n        if ('' === $filename) {\n            $filename = $this->file->getFilename();\n        }\n\n        if ('' === $filenameFallback && (!preg_match('/^[\\x20-\\x7e]*$/', $filename) || str_contains($filename, '%'))) {\n            $encoding = mb_detect_encoding($filename, null, true) ?: '8bit';\n\n            for ($i = 0, $filenameLength = mb_strlen($filename, $encoding); $i < $filenameLength; ++$i) {\n                $char = mb_substr($filename, $i, 1, $encoding);\n\n                if ('%' === $char || \\ord($char) < 32 || \\ord($char) > 126) {\n                    $filenameFallback .= '_';\n                } else {\n                    $filenameFallback .= $char;\n                }\n            }\n        }\n\n        $dispositionHeader = $this->headers->makeDisposition($disposition, $filename, $filenameFallback);\n        $this->headers->set('Content-Disposition', $dispositionHeader);\n\n        return $this;\n    }\n\n    public function prepare(Request $request): static\n    {\n        if ($this->isInformational() || $this->isEmpty()) {\n            parent::prepare($request);\n\n            $this->maxlen = 0;\n\n            return $this;\n        }\n\n        if (!$this->headers->has('Content-Type')) {\n            $mimeType = null;\n            if (!$this->tempFileObject) {\n                $mimeType = $this->file->getMimeType();\n            }\n\n            $this->headers->set('Content-Type', $mimeType ?: 'application/octet-stream');\n        }\n\n        parent::prepare($request);\n\n        $this->offset = 0;\n        $this->maxlen = -1;\n\n        if ($this->tempFileObject) {\n            $fileSize = $this->tempFileObject->fstat()['size'];\n        } elseif (false === $fileSize = $this->file->getSize()) {\n            return $this;\n        }\n        $this->headers->remove('Transfer-Encoding');\n        $this->headers->set('Content-Length', $fileSize);\n\n        if (!$this->headers->has('Accept-Ranges')) {\n            // Only accept ranges on safe HTTP methods\n            $this->headers->set('Accept-Ranges', $request->isMethodSafe() ? 'bytes' : 'none');\n        }\n\n        if (self::$trustXSendfileTypeHeader && $request->headers->has('X-Sendfile-Type')) {\n            // Use X-Sendfile, do not send any content.\n            $type = $request->headers->get('X-Sendfile-Type');\n            $path = $this->file->getRealPath();\n            // Fall back to scheme://path for stream wrapped locations.\n            if (false === $path) {\n                $path = $this->file->getPathname();\n            }\n            if ('x-accel-redirect' === strtolower($type)) {\n                // Do X-Accel-Mapping substitutions.\n                // @link https://github.com/rack/rack/blob/main/lib/rack/sendfile.rb\n                // @link https://mattbrictson.com/blog/accelerated-rails-downloads\n                if (!$request->headers->has('X-Accel-Mapping')) {\n                    throw new \\LogicException('The \"X-Accel-Mapping\" header must be set when \"X-Sendfile-Type\" is set to \"X-Accel-Redirect\".');\n                }\n                $parts = HeaderUtils::split($request->headers->get('X-Accel-Mapping'), ',=');\n                foreach ($parts as $part) {\n                    [$pathPrefix, $location] = $part;\n                    if (str_starts_with($path, $pathPrefix)) {\n                        $path = $location.substr($path, \\strlen($pathPrefix));\n                        // Only set X-Accel-Redirect header if a valid URI can be produced\n                        // as nginx does not serve arbitrary file paths.\n                        $this->headers->set($type, $path);\n                        $this->maxlen = 0;\n                        break;\n                    }\n                }\n            } else {\n                $this->headers->set($type, $path);\n                $this->maxlen = 0;\n            }\n        } elseif ($request->headers->has('Range') && $request->isMethod('GET')) {\n            // Process the range headers.\n            if (!$request->headers->has('If-Range') || $this->hasValidIfRangeHeader($request->headers->get('If-Range'))) {\n                $range = $request->headers->get('Range');\n\n                if (str_starts_with($range, 'bytes=')) {\n                    [$start, $end] = explode('-', substr($range, 6), 2) + [1 => 0];\n\n                    $end = ('' === $end) ? $fileSize - 1 : (int) $end;\n\n                    if ('' === $start) {\n                        $start = $fileSize - $end;\n                        $end = $fileSize - 1;\n                    } else {\n                        $start = (int) $start;\n                    }\n\n                    if ($start <= $end) {\n                        $end = min($end, $fileSize - 1);\n                        if ($start < 0 || $start > $end) {\n                            $this->setStatusCode(416);\n                            $this->headers->set('Content-Range', \\sprintf('bytes */%s', $fileSize));\n                        } elseif ($end - $start < $fileSize - 1) {\n                            $this->maxlen = $end < $fileSize ? $end - $start + 1 : -1;\n                            $this->offset = $start;\n\n                            $this->setStatusCode(206);\n                            $this->headers->set('Content-Range', \\sprintf('bytes %s-%s/%s', $start, $end, $fileSize));\n                            $this->headers->set('Content-Length', $end - $start + 1);\n                        }\n                    }\n                }\n            }\n        }\n\n        if ($request->isMethod('HEAD')) {\n            $this->maxlen = 0;\n        }\n\n        return $this;\n    }\n\n    private function hasValidIfRangeHeader(?string $header): bool\n    {\n        if ($this->getEtag() === $header) {\n            return true;\n        }\n\n        if (null === $lastModified = $this->getLastModified()) {\n            return false;\n        }\n\n        return $lastModified->format('D, d M Y H:i:s').' GMT' === $header;\n    }\n\n    public function sendContent(): static\n    {\n        try {\n            if (!$this->isSuccessful()) {\n                return $this;\n            }\n\n            if (0 === $this->maxlen) {\n                return $this;\n            }\n\n            $out = fopen('php://output', 'w');\n\n            if ($this->tempFileObject) {\n                $file = $this->tempFileObject;\n                $file->rewind();\n            } else {\n                $file = new \\SplFileObject($this->file->getPathname(), 'r');\n            }\n\n            ignore_user_abort(true);\n\n            if (0 !== $this->offset) {\n                $file->fseek($this->offset);\n            }\n\n            $length = $this->maxlen;\n            while ($length && !$file->eof()) {\n                $read = $length > $this->chunkSize || 0 > $length ? $this->chunkSize : $length;\n\n                if (false === $data = $file->fread($read)) {\n                    break;\n                }\n                while ('' !== $data) {\n                    $read = fwrite($out, $data);\n                    if (false === $read || connection_aborted()) {\n                        break 2;\n                    }\n                    if (0 < $length) {\n                        $length -= $read;\n                    }\n                    $data = substr($data, $read);\n                }\n            }\n\n            fclose($out);\n        } finally {\n            if (null === $this->tempFileObject && $this->deleteFileAfterSend && is_file($this->file->getPathname())) {\n                unlink($this->file->getPathname());\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * @throws \\LogicException when the content is not null\n     */\n    public function setContent(?string $content): static\n    {\n        if (null !== $content) {\n            throw new \\LogicException('The content cannot be set on a BinaryFileResponse instance.');\n        }\n\n        return $this;\n    }\n\n    public function getContent(): string|false\n    {\n        return false;\n    }\n\n    /**\n     * Trust X-Sendfile-Type header.\n     */\n    public static function trustXSendfileTypeHeader(): void\n    {\n        self::$trustXSendfileTypeHeader = true;\n    }\n\n    /**\n     * If this is set to true, the file will be unlinked after the request is sent\n     * Note: If the X-Sendfile header is used, the deleteFileAfterSend setting will not be used.\n     *\n     * @return $this\n     */\n    public function deleteFileAfterSend(bool $shouldDelete = true): static\n    {\n        $this->deleteFileAfterSend = $shouldDelete;\n\n        return $this;\n    }\n}\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 20.826171875,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Add optional `$requests` parameter to `RequestStack::__construct()`\n * Add optional `$v4Bytes` and `$v6Bytes` parameters to `IpUtils::anonymize()`\n * Add `PRIVATE_SUBNETS` as a shortcut for private IP address ranges to `Request::setTrustedProxies()`\n * Deprecate passing `referer_check`, `use_only_cookies`, `use_trans_sid`, `trans_sid_hosts`, `trans_sid_tags`, `sid_bits_per_character` and `sid_length` options to `NativeSessionStorage`\n\n7.1\n---\n\n * Add optional `$expirationParameter` argument to `UriSigner::__construct()`\n * Add optional `$expiration` argument to `UriSigner::sign()`\n * Rename `$parameter` argument of `UriSigner::__construct()` to `$hashParameter`\n * Add `UploadedFile::getClientOriginalPath()`\n * Add `QueryParameterRequestMatcher`\n * Add `HeaderRequestMatcher`\n * Add support for `\\SplTempFileObject` in `BinaryFileResponse`\n * Add `verbose` argument to response test constraints\n\n7.0\n---\n\n * Calling `ParameterBag::filter()` throws an `UnexpectedValueException` on invalid value, unless flag `FILTER_NULL_ON_FAILURE` is set\n * Calling `ParameterBag::getInt()` and `ParameterBag::getBool()` throws an `UnexpectedValueException` on invalid value\n * Remove classes `RequestMatcher` and `ExpressionRequestMatcher`\n * Remove `Request::getContentType()`, use `Request::getContentTypeFormat()` instead\n * Throw an `InvalidArgumentException` when calling `Request::create()` with a malformed URI\n * Require explicit argument when calling `JsonResponse::setCallback()`, `Response::setExpires/setLastModified/setEtag()`, `MockArraySessionStorage/NativeSessionStorage::setMetadataBag()`, `NativeSessionStorage::setSaveHandler()`\n * Add argument `$statusCode` to `Response::sendHeaders()` and `StreamedResponse::sendHeaders()`\n\n6.4\n---\n\n * Make `HeaderBag::getDate()`, `Response::getDate()`, `getExpires()` and `getLastModified()` return a `DateTimeImmutable`\n * Support root-level `Generator` in `StreamedJsonResponse`\n * Add `UriSigner` from the HttpKernel component\n * Add `partitioned` flag to `Cookie` (CHIPS Cookie)\n * Add argument `bool $flush = true` to `Response::send()`\n* Make `MongoDbSessionHandler` instantiable with the mongodb extension directly\n\n6.3\n---\n\n * Calling `ParameterBag::getDigit()`, `getAlnum()`, `getAlpha()` on an `array` throws a `UnexpectedValueException` instead of a `TypeError`\n * Add `ParameterBag::getString()` to convert a parameter into string and throw an exception if the value is invalid\n * Add `ParameterBag::getEnum()`\n * Create migration for session table when pdo handler is used\n * Add support for Relay PHP extension for Redis\n * The `Response::sendHeaders()` method now takes an optional HTTP status code as parameter, allowing to send informational responses such as Early Hints responses (103 status code)\n * Add `IpUtils::isPrivateIp()`\n * Add `Request::getPayload(): InputBag`\n * Deprecate conversion of invalid values in `ParameterBag::getInt()` and `ParameterBag::getBoolean()`,\n * Deprecate ignoring invalid values when using `ParameterBag::filter()`, unless flag `FILTER_NULL_ON_FAILURE` is set\n\n6.2\n---\n\n * Add `StreamedJsonResponse` class for efficient JSON streaming\n * The HTTP cache store uses the `xxh128` algorithm\n * Deprecate calling `JsonResponse::setCallback()`, `Response::setExpires/setLastModified/setEtag()`, `MockArraySessionStorage/NativeSessionStorage::setMetadataBag()`, `NativeSessionStorage::setSaveHandler()` without arguments\n * Add request matchers under the `Symfony\\Component\\HttpFoundation\\RequestMatcher` namespace\n * Deprecate `RequestMatcher` in favor of `ChainRequestMatcher`\n * Deprecate `Symfony\\Component\\HttpFoundation\\ExpressionRequestMatcher` in favor of `Symfony\\Component\\HttpFoundation\\RequestMatcher\\ExpressionRequestMatcher`\n\n6.1\n---\n\n * Add stale while revalidate and stale if error cache header\n * Allow dynamic session \"ttl\" when using a remote storage\n * Deprecate `Request::getContentType()`, use `Request::getContentTypeFormat()` instead\n\n6.0\n---\n\n * Remove the `NamespacedAttributeBag` class\n * Removed `Response::create()`, `JsonResponse::create()`,\n   `RedirectResponse::create()`, `StreamedResponse::create()` and\n   `BinaryFileResponse::create()` methods (use `__construct()` instead)\n * Not passing a `Closure` together with `FILTER_CALLBACK` to `ParameterBag::filter()` throws an `\\InvalidArgumentException`; wrap your filter in a closure instead\n * Not passing a `Closure` together with `FILTER_CALLBACK` to `InputBag::filter()` throws an `\\InvalidArgumentException`; wrap your filter in a closure instead\n * Removed the `Request::HEADER_X_FORWARDED_ALL` constant, use either `Request::HEADER_X_FORWARDED_FOR | Request::HEADER_X_FORWARDED_HOST | Request::HEADER_X_FORWARDED_PORT | Request::HEADER_X_FORWARDED_PROTO` or `Request::HEADER_X_FORWARDED_AWS_ELB` or `Request::HEADER_X_FORWARDED_TRAEFIK`constants instead\n * Rename `RequestStack::getMasterRequest()` to `getMainRequest()`\n * Not passing `FILTER_REQUIRE_ARRAY` or `FILTER_FORCE_ARRAY` flags to `InputBag::filter()` when filtering an array will throw `BadRequestException`\n * Removed the `Request::HEADER_X_FORWARDED_ALL` constant\n * Retrieving non-scalar values using `InputBag::get()` will throw `BadRequestException` (use `InputBad::all()` instead to retrieve an array)\n * Passing non-scalar default value as the second argument `InputBag::get()` will throw `\\InvalidArgumentException`\n * Passing non-scalar, non-array value as the second argument `InputBag::set()` will throw `\\InvalidArgumentException`\n * Passing `null` as `$requestIp` to `IpUtils::__checkIp()`, `IpUtils::__checkIp4()` or `IpUtils::__checkIp6()` is not supported anymore.\n\n5.4\n---\n\n * Deprecate passing `null` as `$requestIp` to `IpUtils::__checkIp()`, `IpUtils::__checkIp4()` or `IpUtils::__checkIp6()`, pass an empty string instead.\n * Add the `litespeed_finish_request` method to work with Litespeed\n * Deprecate `upload_progress.*` and `url_rewriter.tags` session options\n * Allow setting session options via DSN\n\n5.3\n---\n\n * Add the `SessionFactory`, `NativeSessionStorageFactory`, `PhpBridgeSessionStorageFactory` and `MockFileSessionStorageFactory` classes\n * Calling `Request::getSession()` when there is no available session throws a `SessionNotFoundException`\n * Add the `RequestStack::getSession` method\n * Deprecate the `NamespacedAttributeBag` class\n * Add `ResponseFormatSame` PHPUnit constraint\n * Deprecate the `RequestStack::getMasterRequest()` method and add `getMainRequest()` as replacement\n\n5.2.0\n-----\n\n * added support for `X-Forwarded-Prefix` header\n * added `HeaderUtils::parseQuery()`: it does the same as `parse_str()` but preserves dots in variable names\n * added `File::getContent()`\n * added ability to use comma separated ip addresses for `RequestMatcher::matchIps()`\n * added `Request::toArray()` to parse a JSON request body to an array\n * added `RateLimiter\\RequestRateLimiterInterface` and `RateLimiter\\AbstractRequestRateLimiter`\n * deprecated not passing a `Closure` together with `FILTER_CALLBACK` to `ParameterBag::filter()`; wrap your filter in a closure instead.\n * Deprecated the `Request::HEADER_X_FORWARDED_ALL` constant, use either `HEADER_X_FORWARDED_FOR | HEADER_X_FORWARDED_HOST | HEADER_X_FORWARDED_PORT | HEADER_X_FORWARDED_PROTO` or `HEADER_X_FORWARDED_AWS_ELB` or `HEADER_X_FORWARDED_TRAEFIK` constants instead.\n * Deprecated `BinaryFileResponse::create()`, use `__construct()` instead\n\n5.1.0\n-----\n\n * added `Cookie::withValue`, `Cookie::withDomain`, `Cookie::withExpires`,\n   `Cookie::withPath`, `Cookie::withSecure`, `Cookie::withHttpOnly`,\n   `Cookie::withRaw`, `Cookie::withSameSite`\n * Deprecate `Response::create()`, `JsonResponse::create()`,\n   `RedirectResponse::create()`, and `StreamedResponse::create()` methods (use\n   `__construct()` instead)\n * added `Request::preferSafeContent()` and `Response::setContentSafe()` to handle \"safe\" HTTP preference\n   according to [RFC 8674](https://tools.ietf.org/html/rfc8674)\n * made the Mime component an optional dependency\n * added `MarshallingSessionHandler`, `IdentityMarshaller`\n * made `Session` accept a callback to report when the session is being used\n * Add support for all core cache control directives\n * Added `Symfony\\Component\\HttpFoundation\\InputBag`\n * Deprecated retrieving non-string values using `InputBag::get()`, use `InputBag::all()` if you need access to the collection of values\n\n5.0.0\n-----\n\n * made `Cookie` auto-secure and lax by default\n * removed classes in the `MimeType` namespace, use the Symfony Mime component instead\n * removed method `UploadedFile::getClientSize()` and the related constructor argument\n * made `Request::getSession()` throw if the session has not been set before\n * removed `Response::HTTP_RESERVED_FOR_WEBDAV_ADVANCED_COLLECTIONS_EXPIRED_PROPOSAL`\n * passing a null url when instantiating a `RedirectResponse` is not allowed\n\n4.4.0\n-----\n\n * passing arguments to `Request::isMethodSafe()` is deprecated.\n * `ApacheRequest` is deprecated, use the `Request` class instead.\n * passing a third argument to `HeaderBag::get()` is deprecated, use method `all()` instead\n * [BC BREAK] `PdoSessionHandler` with MySQL changed the type of the lifetime column,\n   make sure to run `ALTER TABLE sessions MODIFY sess_lifetime INTEGER UNSIGNED NOT NULL` to\n   update your database.\n * `PdoSessionHandler` now precalculates the expiry timestamp in the lifetime column,\n    make sure to run `CREATE INDEX expiry ON sessions (sess_lifetime)` to update your database\n    to speed up garbage collection of expired sessions.\n * added `SessionHandlerFactory` to create session handlers with a DSN\n * added `IpUtils::anonymize()` to help with GDPR compliance.\n\n4.3.0\n-----\n\n * added PHPUnit constraints: `RequestAttributeValueSame`, `ResponseCookieValueSame`, `ResponseHasCookie`,\n   `ResponseHasHeader`, `ResponseHeaderSame`, `ResponseIsRedirected`, `ResponseIsSuccessful`, and `ResponseStatusCodeSame`\n * deprecated `MimeTypeGuesserInterface` and `ExtensionGuesserInterface` in favor of `Symfony\\Component\\Mime\\MimeTypesInterface`.\n * deprecated `MimeType` and `MimeTypeExtensionGuesser` in favor of `Symfony\\Component\\Mime\\MimeTypes`.\n * deprecated `FileBinaryMimeTypeGuesser` in favor of `Symfony\\Component\\Mime\\FileBinaryMimeTypeGuesser`.\n * deprecated `FileinfoMimeTypeGuesser` in favor of `Symfony\\Component\\Mime\\FileinfoMimeTypeGuesser`.\n * added `UrlHelper` that allows to get an absolute URL and a relative path for a given path\n\n4.2.0\n-----\n\n * the default value of the \"$secure\" and \"$samesite\" arguments of Cookie's constructor\n   will respectively change from \"false\" to \"null\" and from \"null\" to \"lax\" in Symfony\n   5.0, you should define their values explicitly or use \"Cookie::create()\" instead.\n * added `matchPort()` in RequestMatcher\n\n4.1.3\n-----\n\n * [BC BREAK] Support for the IIS-only `X_ORIGINAL_URL` and `X_REWRITE_URL`\n   HTTP headers has been dropped for security reasons.\n\n4.1.0\n-----\n\n * Query string normalization uses `parse_str()` instead of custom parsing logic.\n * Passing the file size to the constructor of the `UploadedFile` class is deprecated.\n * The `getClientSize()` method of the `UploadedFile` class is deprecated. Use `getSize()` instead.\n * added `RedisSessionHandler` to use Redis as a session storage\n * The `get()` method of the `AcceptHeader` class now takes into account the\n   `*` and `*/*` default values (if they are present in the Accept HTTP header)\n   when looking for items.\n * deprecated `Request::getSession()` when no session has been set. Use `Request::hasSession()` instead.\n * added `CannotWriteFileException`, `ExtensionFileException`, `FormSizeFileException`,\n   `IniSizeFileException`, `NoFileException`, `NoTmpDirFileException`, `PartialFileException` to\n   handle failed `UploadedFile`.\n * added `MigratingSessionHandler` for migrating between two session handlers without losing sessions\n * added `HeaderUtils`.\n\n4.0.0\n-----\n\n * the `Request::setTrustedHeaderName()` and `Request::getTrustedHeaderName()`\n   methods have been removed\n * the `Request::HEADER_CLIENT_IP` constant has been removed, use\n   `Request::HEADER_X_FORWARDED_FOR` instead\n * the `Request::HEADER_CLIENT_HOST` constant has been removed, use\n   `Request::HEADER_X_FORWARDED_HOST` instead\n * the `Request::HEADER_CLIENT_PROTO` constant has been removed, use\n   `Request::HEADER_X_FORWARDED_PROTO` instead\n * the `Request::HEADER_CLIENT_PORT` constant has been removed, use\n   `Request::HEADER_X_FORWARDED_PORT` instead\n * checking for cacheable HTTP methods using the `Request::isMethodSafe()`\n   method (by not passing `false` as its argument) is not supported anymore and\n   throws a `\\BadMethodCallException`\n * the `WriteCheckSessionHandler`, `NativeSessionHandler` and `NativeProxy` classes have been removed\n * setting session save handlers that do not implement `\\SessionHandlerInterface` in\n   `NativeSessionStorage::setSaveHandler()` is not supported anymore and throws a\n   `\\TypeError`\n\n3.4.0\n-----\n\n * implemented PHP 7.0's `SessionUpdateTimestampHandlerInterface` with a new\n   `AbstractSessionHandler` base class and a new `StrictSessionHandler` wrapper\n * deprecated the `WriteCheckSessionHandler`, `NativeSessionHandler` and `NativeProxy` classes\n * deprecated setting session save handlers that do not implement `\\SessionHandlerInterface` in `NativeSessionStorage::setSaveHandler()`\n * deprecated using `MongoDbSessionHandler` with the legacy mongo extension; use it with the mongodb/mongodb package and ext-mongodb instead\n * deprecated `MemcacheSessionHandler`; use `MemcachedSessionHandler` instead\n\n3.3.0\n-----\n\n * the `Request::setTrustedProxies()` method takes a new `$trustedHeaderSet` argument,\n   see https://symfony.com/doc/current/deployment/proxies.html for more info,\n * deprecated the `Request::setTrustedHeaderName()` and `Request::getTrustedHeaderName()` methods,\n * added `File\\Stream`, to be passed to `BinaryFileResponse` when the size of the served file is unknown,\n   disabling `Range` and `Content-Length` handling, switching to chunked encoding instead\n * added the `Cookie::fromString()` method that allows to create a cookie from a\n   raw header string\n\n3.1.0\n-----\n\n * Added support for creating `JsonResponse` with a string of JSON data\n\n3.0.0\n-----\n\n * The precedence of parameters returned from `Request::get()` changed from \"GET, PATH, BODY\" to \"PATH, GET, BODY\"\n\n2.8.0\n-----\n\n * Finding deep items in `ParameterBag::get()` is deprecated since version 2.8 and\n   will be removed in 3.0.\n\n2.6.0\n-----\n\n * PdoSessionHandler changes\n   - implemented different session locking strategies to prevent loss of data by concurrent access to the same session\n   - [BC BREAK] save session data in a binary column without base64_encode\n   - [BC BREAK] added lifetime column to the session table which allows to have different lifetimes for each session\n   - implemented lazy connections that are only opened when a session is used by either passing a dsn string\n     explicitly or falling back to session.save_path ini setting\n   - added a createTable method that initializes a correctly defined table depending on the database vendor\n\n2.5.0\n-----\n\n * added `JsonResponse::setEncodingOptions()` & `JsonResponse::getEncodingOptions()` for easier manipulation\n   of the options used while encoding data to JSON format.\n\n2.4.0\n-----\n\n * added RequestStack\n * added Request::getEncodings()\n * added accessors methods to session handlers\n\n2.3.0\n-----\n\n * added support for ranges of IPs in trusted proxies\n * `UploadedFile::isValid` now returns false if the file was not uploaded via HTTP (in a non-test mode)\n * Improved error-handling of `\\Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler`\n   to ensure the supplied PDO handler throws Exceptions on error (as the class expects). Added related test cases\n   to verify that Exceptions are properly thrown when the PDO queries fail.\n\n2.2.0\n-----\n\n * fixed the Request::create() precedence (URI information always take precedence now)\n * added Request::getTrustedProxies()\n * deprecated Request::isProxyTrusted()\n * [BC BREAK] JsonResponse does not turn a top level empty array to an object anymore, use an ArrayObject to enforce objects\n * added a IpUtils class to check if an IP belongs to a CIDR\n * added Request::getRealMethod() to get the \"real\" HTTP method (getMethod() returns the \"intended\" HTTP method)\n * disabled _method request parameter support by default (call Request::enableHttpMethodParameterOverride() to\n   enable it, and Request::getHttpMethodParameterOverride() to check if it is supported)\n * Request::splitHttpAcceptHeader() method is deprecated and will be removed in 2.3\n * Deprecated Flashbag::count() and \\Countable interface, will be removed in 2.3\n\n2.1.0\n-----\n\n * added Request::getSchemeAndHttpHost() and Request::getUserInfo()\n * added a fluent interface to the Response class\n * added Request::isProxyTrusted()\n * added JsonResponse\n * added a getTargetUrl method to RedirectResponse\n * added support for streamed responses\n * made Response::prepare() method the place to enforce HTTP specification\n * [BC BREAK] moved management of the locale from the Session class to the Request class\n * added a generic access to the PHP built-in filter mechanism: ParameterBag::filter()\n * made FileBinaryMimeTypeGuesser command configurable\n * added Request::getUser() and Request::getPassword()\n * added support for the PATCH method in Request\n * removed the ContentTypeMimeTypeGuesser class as it is deprecated and never used on PHP 5.3\n * added ResponseHeaderBag::makeDisposition() (implements RFC 6266)\n * made mimetype to extension conversion configurable\n * [BC BREAK] Moved all session related classes and interfaces into own namespace, as\n   `Symfony\\Component\\HttpFoundation\\Session` and renamed classes accordingly.\n   Session handlers are located in the subnamespace `Symfony\\Component\\HttpFoundation\\Session\\Handler`.\n * SessionHandlers must implement `\\SessionHandlerInterface` or extend from the\n   `Symfony\\Component\\HttpFoundation\\Storage\\Handler\\NativeSessionHandler` base class.\n * Added internal storage driver proxy mechanism for forward compatibility with\n   PHP 5.4 `\\SessionHandler` class.\n * Added session handlers for custom Memcache, Memcached and Null session save handlers.\n * [BC BREAK] Removed `NativeSessionStorage` and replaced with `NativeFileSessionHandler`.\n * [BC BREAK] `SessionStorageInterface` methods removed: `write()`, `read()` and\n   `remove()`.  Added `getBag()`, `registerBag()`.  The `NativeSessionStorage` class\n   is a mediator for the session storage internals including the session handlers\n   which do the real work of participating in the internal PHP session workflow.\n * [BC BREAK] Introduced mock implementations of `SessionStorage` to enable unit\n   and functional testing without starting real PHP sessions.  Removed\n   `ArraySessionStorage`, and replaced with `MockArraySessionStorage` for unit\n   tests; removed `FilesystemSessionStorage`, and replaced with`MockFileSessionStorage`\n   for functional tests.  These do not interact with global session ini\n   configuration values, session functions or `$_SESSION` superglobal. This means\n   they can be configured directly allowing multiple instances to work without\n   conflicting in the same PHP process.\n * [BC BREAK] Removed the `close()` method from the `Session` class, as this is\n   now redundant.\n * Deprecated the following methods from the Session class: `setFlash()`, `setFlashes()`\n   `getFlash()`, `hasFlash()`, and `removeFlash()`. Use `getFlashBag()` instead\n   which returns a `FlashBagInterface`.\n * `Session->clear()` now only clears session attributes as before it cleared\n   flash messages and attributes. `Session->getFlashBag()->all()` clears flashes now.\n * Session data is now managed by `SessionBagInterface` to better encapsulate\n   session data.\n * Refactored session attribute and flash messages system to their own\n  `SessionBagInterface` implementations.\n * Added `FlashBag`. Flashes expire when retrieved by `get()` or `all()`. This\n   implementation is ESI compatible.\n * Added `AutoExpireFlashBag` (default) to replicate Symfony 2.0.x auto expire\n   behavior of messages auto expiring after one page page load.  Messages must\n   be retrieved by `get()` or `all()`.\n * Added `Symfony\\Component\\HttpFoundation\\Attribute\\AttributeBag` to replicate\n   attributes storage behavior from 2.0.x (default).\n * Added `Symfony\\Component\\HttpFoundation\\Attribute\\NamespacedAttributeBag` for\n   namespace session attributes.\n * Flash API can stores messages in an array so there may be multiple messages\n   per flash type.  The old `Session` class API remains without BC break as it\n   will allow single messages as before.\n * Added basic session meta-data to the session to record session create time,\n   last updated time, and the lifetime of the session cookie that was provided\n   to the client.\n * Request::getClientIp() method doesn't take a parameter anymore but bases\n   itself on the trustProxy parameter.\n * Added isMethod() to Request object.\n * [BC BREAK] The methods `getPathInfo()`, `getBaseUrl()` and `getBasePath()` of\n   a `Request` now all return a raw value (vs a urldecoded value before). Any call\n   to one of these methods must be checked and wrapped in a `rawurldecode()` if\n   needed.\n"
        },
        {
          "name": "ChainRequestMatcher.php",
          "type": "blob",
          "size": 0.8525390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * ChainRequestMatcher verifies that all checks match against a Request instance.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass ChainRequestMatcher implements RequestMatcherInterface\n{\n    /**\n     * @param iterable<RequestMatcherInterface> $matchers\n     */\n    public function __construct(private iterable $matchers)\n    {\n    }\n\n    public function matches(Request $request): bool\n    {\n        foreach ($this->matchers as $matcher) {\n            if (!$matcher->matches($request)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"
        },
        {
          "name": "Cookie.php",
          "type": "blob",
          "size": 11.5302734375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * Represents a cookie.\n *\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n */\nclass Cookie\n{\n    public const SAMESITE_NONE = 'none';\n    public const SAMESITE_LAX = 'lax';\n    public const SAMESITE_STRICT = 'strict';\n\n    protected int $expire;\n    protected string $path;\n\n    private ?string $sameSite = null;\n    private bool $secureDefault = false;\n\n    private const RESERVED_CHARS_LIST = \"=,; \\t\\r\\n\\v\\f\";\n    private const RESERVED_CHARS_FROM = ['=', ',', ';', ' ', \"\\t\", \"\\r\", \"\\n\", \"\\v\", \"\\f\"];\n    private const RESERVED_CHARS_TO = ['%3D', '%2C', '%3B', '%20', '%09', '%0D', '%0A', '%0B', '%0C'];\n\n    /**\n     * Creates cookie from raw header string.\n     */\n    public static function fromString(string $cookie, bool $decode = false): static\n    {\n        $data = [\n            'expires' => 0,\n            'path' => '/',\n            'domain' => null,\n            'secure' => false,\n            'httponly' => false,\n            'raw' => !$decode,\n            'samesite' => null,\n            'partitioned' => false,\n        ];\n\n        $parts = HeaderUtils::split($cookie, ';=');\n        $part = array_shift($parts);\n\n        $name = $decode ? urldecode($part[0]) : $part[0];\n        $value = isset($part[1]) ? ($decode ? urldecode($part[1]) : $part[1]) : null;\n\n        $data = HeaderUtils::combine($parts) + $data;\n        $data['expires'] = self::expiresTimestamp($data['expires']);\n\n        if (isset($data['max-age']) && ($data['max-age'] > 0 || $data['expires'] > time())) {\n            $data['expires'] = time() + (int) $data['max-age'];\n        }\n\n        return new static($name, $value, $data['expires'], $data['path'], $data['domain'], $data['secure'], $data['httponly'], $data['raw'], $data['samesite'], $data['partitioned']);\n    }\n\n    /**\n     * @see self::__construct\n     *\n     * @param self::SAMESITE_*|''|null $sameSite\n     */\n    public static function create(string $name, ?string $value = null, int|string|\\DateTimeInterface $expire = 0, ?string $path = '/', ?string $domain = null, ?bool $secure = null, bool $httpOnly = true, bool $raw = false, ?string $sameSite = self::SAMESITE_LAX, bool $partitioned = false): self\n    {\n        return new self($name, $value, $expire, $path, $domain, $secure, $httpOnly, $raw, $sameSite, $partitioned);\n    }\n\n    /**\n     * @param string                        $name     The name of the cookie\n     * @param string|null                   $value    The value of the cookie\n     * @param int|string|\\DateTimeInterface $expire   The time the cookie expires\n     * @param string|null                   $path     The path on the server in which the cookie will be available on\n     * @param string|null                   $domain   The domain that the cookie is available to\n     * @param bool|null                     $secure   Whether the client should send back the cookie only over HTTPS or null to auto-enable this when the request is already using HTTPS\n     * @param bool                          $httpOnly Whether the cookie will be made accessible only through the HTTP protocol\n     * @param bool                          $raw      Whether the cookie value should be sent with no url encoding\n     * @param self::SAMESITE_*|''|null      $sameSite Whether the cookie will be available for cross-site requests\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function __construct(\n        protected string $name,\n        protected ?string $value = null,\n        int|string|\\DateTimeInterface $expire = 0,\n        ?string $path = '/',\n        protected ?string $domain = null,\n        protected ?bool $secure = null,\n        protected bool $httpOnly = true,\n        private bool $raw = false,\n        ?string $sameSite = self::SAMESITE_LAX,\n        private bool $partitioned = false,\n    ) {\n        // from PHP source code\n        if ($raw && false !== strpbrk($name, self::RESERVED_CHARS_LIST)) {\n            throw new \\InvalidArgumentException(\\sprintf('The cookie name \"%s\" contains invalid characters.', $name));\n        }\n\n        if (!$name) {\n            throw new \\InvalidArgumentException('The cookie name cannot be empty.');\n        }\n\n        $this->expire = self::expiresTimestamp($expire);\n        $this->path = $path ?: '/';\n        $this->sameSite = $this->withSameSite($sameSite)->sameSite;\n    }\n\n    /**\n     * Creates a cookie copy with a new value.\n     */\n    public function withValue(?string $value): static\n    {\n        $cookie = clone $this;\n        $cookie->value = $value;\n\n        return $cookie;\n    }\n\n    /**\n     * Creates a cookie copy with a new domain that the cookie is available to.\n     */\n    public function withDomain(?string $domain): static\n    {\n        $cookie = clone $this;\n        $cookie->domain = $domain;\n\n        return $cookie;\n    }\n\n    /**\n     * Creates a cookie copy with a new time the cookie expires.\n     */\n    public function withExpires(int|string|\\DateTimeInterface $expire = 0): static\n    {\n        $cookie = clone $this;\n        $cookie->expire = self::expiresTimestamp($expire);\n\n        return $cookie;\n    }\n\n    /**\n     * Converts expires formats to a unix timestamp.\n     */\n    private static function expiresTimestamp(int|string|\\DateTimeInterface $expire = 0): int\n    {\n        // convert expiration time to a Unix timestamp\n        if ($expire instanceof \\DateTimeInterface) {\n            $expire = $expire->format('U');\n        } elseif (!is_numeric($expire)) {\n            $expire = strtotime($expire);\n\n            if (false === $expire) {\n                throw new \\InvalidArgumentException('The cookie expiration time is not valid.');\n            }\n        }\n\n        return 0 < $expire ? (int) $expire : 0;\n    }\n\n    /**\n     * Creates a cookie copy with a new path on the server in which the cookie will be available on.\n     */\n    public function withPath(string $path): static\n    {\n        $cookie = clone $this;\n        $cookie->path = '' === $path ? '/' : $path;\n\n        return $cookie;\n    }\n\n    /**\n     * Creates a cookie copy that only be transmitted over a secure HTTPS connection from the client.\n     */\n    public function withSecure(bool $secure = true): static\n    {\n        $cookie = clone $this;\n        $cookie->secure = $secure;\n\n        return $cookie;\n    }\n\n    /**\n     * Creates a cookie copy that be accessible only through the HTTP protocol.\n     */\n    public function withHttpOnly(bool $httpOnly = true): static\n    {\n        $cookie = clone $this;\n        $cookie->httpOnly = $httpOnly;\n\n        return $cookie;\n    }\n\n    /**\n     * Creates a cookie copy that uses no url encoding.\n     */\n    public function withRaw(bool $raw = true): static\n    {\n        if ($raw && false !== strpbrk($this->name, self::RESERVED_CHARS_LIST)) {\n            throw new \\InvalidArgumentException(\\sprintf('The cookie name \"%s\" contains invalid characters.', $this->name));\n        }\n\n        $cookie = clone $this;\n        $cookie->raw = $raw;\n\n        return $cookie;\n    }\n\n    /**\n     * Creates a cookie copy with SameSite attribute.\n     *\n     * @param self::SAMESITE_*|''|null $sameSite\n     */\n    public function withSameSite(?string $sameSite): static\n    {\n        if ('' === $sameSite) {\n            $sameSite = null;\n        } elseif (null !== $sameSite) {\n            $sameSite = strtolower($sameSite);\n        }\n\n        if (!\\in_array($sameSite, [self::SAMESITE_LAX, self::SAMESITE_STRICT, self::SAMESITE_NONE, null], true)) {\n            throw new \\InvalidArgumentException('The \"sameSite\" parameter value is not valid.');\n        }\n\n        $cookie = clone $this;\n        $cookie->sameSite = $sameSite;\n\n        return $cookie;\n    }\n\n    /**\n     * Creates a cookie copy that is tied to the top-level site in cross-site context.\n     */\n    public function withPartitioned(bool $partitioned = true): static\n    {\n        $cookie = clone $this;\n        $cookie->partitioned = $partitioned;\n\n        return $cookie;\n    }\n\n    /**\n     * Returns the cookie as a string.\n     */\n    public function __toString(): string\n    {\n        if ($this->isRaw()) {\n            $str = $this->getName();\n        } else {\n            $str = str_replace(self::RESERVED_CHARS_FROM, self::RESERVED_CHARS_TO, $this->getName());\n        }\n\n        $str .= '=';\n\n        if ('' === (string) $this->getValue()) {\n            $str .= 'deleted; expires='.gmdate('D, d M Y H:i:s T', time() - 31536001).'; Max-Age=0';\n        } else {\n            $str .= $this->isRaw() ? $this->getValue() : rawurlencode($this->getValue());\n\n            if (0 !== $this->getExpiresTime()) {\n                $str .= '; expires='.gmdate('D, d M Y H:i:s T', $this->getExpiresTime()).'; Max-Age='.$this->getMaxAge();\n            }\n        }\n\n        if ($this->getPath()) {\n            $str .= '; path='.$this->getPath();\n        }\n\n        if ($this->getDomain()) {\n            $str .= '; domain='.$this->getDomain();\n        }\n\n        if ($this->isSecure()) {\n            $str .= '; secure';\n        }\n\n        if ($this->isHttpOnly()) {\n            $str .= '; httponly';\n        }\n\n        if (null !== $this->getSameSite()) {\n            $str .= '; samesite='.$this->getSameSite();\n        }\n\n        if ($this->isPartitioned()) {\n            $str .= '; partitioned';\n        }\n\n        return $str;\n    }\n\n    /**\n     * Gets the name of the cookie.\n     */\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    /**\n     * Gets the value of the cookie.\n     */\n    public function getValue(): ?string\n    {\n        return $this->value;\n    }\n\n    /**\n     * Gets the domain that the cookie is available to.\n     */\n    public function getDomain(): ?string\n    {\n        return $this->domain;\n    }\n\n    /**\n     * Gets the time the cookie expires.\n     */\n    public function getExpiresTime(): int\n    {\n        return $this->expire;\n    }\n\n    /**\n     * Gets the max-age attribute.\n     */\n    public function getMaxAge(): int\n    {\n        $maxAge = $this->expire - time();\n\n        return max(0, $maxAge);\n    }\n\n    /**\n     * Gets the path on the server in which the cookie will be available on.\n     */\n    public function getPath(): string\n    {\n        return $this->path;\n    }\n\n    /**\n     * Checks whether the cookie should only be transmitted over a secure HTTPS connection from the client.\n     */\n    public function isSecure(): bool\n    {\n        return $this->secure ?? $this->secureDefault;\n    }\n\n    /**\n     * Checks whether the cookie will be made accessible only through the HTTP protocol.\n     */\n    public function isHttpOnly(): bool\n    {\n        return $this->httpOnly;\n    }\n\n    /**\n     * Whether this cookie is about to be cleared.\n     */\n    public function isCleared(): bool\n    {\n        return 0 !== $this->expire && $this->expire < time();\n    }\n\n    /**\n     * Checks if the cookie value should be sent with no url encoding.\n     */\n    public function isRaw(): bool\n    {\n        return $this->raw;\n    }\n\n    /**\n     * Checks whether the cookie should be tied to the top-level site in cross-site context.\n     */\n    public function isPartitioned(): bool\n    {\n        return $this->partitioned;\n    }\n\n    /**\n     * @return self::SAMESITE_*|null\n     */\n    public function getSameSite(): ?string\n    {\n        return $this->sameSite;\n    }\n\n    /**\n     * @param bool $default The default value of the \"secure\" flag when it is set to null\n     */\n    public function setSecureDefault(bool $default): void\n    {\n        $this->secureDefault = $default;\n    }\n}\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "File",
          "type": "tree",
          "content": null
        },
        {
          "name": "FileBag.php",
          "type": "blob",
          "size": 3.7666015625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\n/**\n * FileBag is a container for uploaded files.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Bulat Shakirzyanov <mallluhuct@gmail.com>\n */\nclass FileBag extends ParameterBag\n{\n    private const FILE_KEYS = ['error', 'full_path', 'name', 'size', 'tmp_name', 'type'];\n\n    /**\n     * @param array|UploadedFile[] $parameters An array of HTTP files\n     */\n    public function __construct(array $parameters = [])\n    {\n        $this->replace($parameters);\n    }\n\n    public function replace(array $files = []): void\n    {\n        $this->parameters = [];\n        $this->add($files);\n    }\n\n    public function set(string $key, mixed $value): void\n    {\n        if (!\\is_array($value) && !$value instanceof UploadedFile) {\n            throw new \\InvalidArgumentException('An uploaded file must be an array or an instance of UploadedFile.');\n        }\n\n        parent::set($key, $this->convertFileInformation($value));\n    }\n\n    public function add(array $files = []): void\n    {\n        foreach ($files as $key => $file) {\n            $this->set($key, $file);\n        }\n    }\n\n    /**\n     * Converts uploaded files to UploadedFile instances.\n     *\n     * @return UploadedFile[]|UploadedFile|null\n     */\n    protected function convertFileInformation(array|UploadedFile $file): array|UploadedFile|null\n    {\n        if ($file instanceof UploadedFile) {\n            return $file;\n        }\n\n        $file = $this->fixPhpFilesArray($file);\n        $keys = array_keys($file + ['full_path' => null]);\n        sort($keys);\n\n        if (self::FILE_KEYS === $keys) {\n            if (\\UPLOAD_ERR_NO_FILE === $file['error']) {\n                $file = null;\n            } else {\n                $file = new UploadedFile($file['tmp_name'], $file['full_path'] ?? $file['name'], $file['type'], $file['error'], false);\n            }\n        } else {\n            $file = array_map(fn ($v) => $v instanceof UploadedFile || \\is_array($v) ? $this->convertFileInformation($v) : $v, $file);\n            if (array_is_list($file)) {\n                $file = array_filter($file);\n            }\n        }\n\n        return $file;\n    }\n\n    /**\n     * Fixes a malformed PHP $_FILES array.\n     *\n     * PHP has a bug that the format of the $_FILES array differs, depending on\n     * whether the uploaded file fields had normal field names or array-like\n     * field names (\"normal\" vs. \"parent[child]\").\n     *\n     * This method fixes the array to look like the \"normal\" $_FILES array.\n     *\n     * It's safe to pass an already converted array, in which case this method\n     * just returns the original array unmodified.\n     */\n    protected function fixPhpFilesArray(array $data): array\n    {\n        $keys = array_keys($data + ['full_path' => null]);\n        sort($keys);\n\n        if (self::FILE_KEYS !== $keys || !isset($data['name']) || !\\is_array($data['name'])) {\n            return $data;\n        }\n\n        $files = $data;\n        foreach (self::FILE_KEYS as $k) {\n            unset($files[$k]);\n        }\n\n        foreach ($data['name'] as $key => $name) {\n            $files[$key] = $this->fixPhpFilesArray([\n                'error' => $data['error'][$key],\n                'name' => $name,\n                'type' => $data['type'][$key],\n                'tmp_name' => $data['tmp_name'][$key],\n                'size' => $data['size'][$key],\n            ] + (isset($data['full_path'][$key]) ? [\n                'full_path' => $data['full_path'][$key],\n            ] : []));\n        }\n\n        return $files;\n    }\n}\n"
        },
        {
          "name": "HeaderBag.php",
          "type": "blob",
          "size": 6.9365234375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * HeaderBag is a container for HTTP headers.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @implements \\IteratorAggregate<string, list<string|null>>\n */\nclass HeaderBag implements \\IteratorAggregate, \\Countable, \\Stringable\n{\n    protected const UPPER = '_ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    protected const LOWER = '-abcdefghijklmnopqrstuvwxyz';\n\n    /**\n     * @var array<string, list<string|null>>\n     */\n    protected array $headers = [];\n    protected array $cacheControl = [];\n\n    public function __construct(array $headers = [])\n    {\n        foreach ($headers as $key => $values) {\n            $this->set($key, $values);\n        }\n    }\n\n    /**\n     * Returns the headers as a string.\n     */\n    public function __toString(): string\n    {\n        if (!$headers = $this->all()) {\n            return '';\n        }\n\n        ksort($headers);\n        $max = max(array_map('strlen', array_keys($headers))) + 1;\n        $content = '';\n        foreach ($headers as $name => $values) {\n            $name = ucwords($name, '-');\n            foreach ($values as $value) {\n                $content .= \\sprintf(\"%-{$max}s %s\\r\\n\", $name.':', $value);\n            }\n        }\n\n        return $content;\n    }\n\n    /**\n     * Returns the headers.\n     *\n     * @param string|null $key The name of the headers to return or null to get them all\n     *\n     * @return ($key is null ? array<string, list<string|null>> : list<string|null>)\n     */\n    public function all(?string $key = null): array\n    {\n        if (null !== $key) {\n            return $this->headers[strtr($key, self::UPPER, self::LOWER)] ?? [];\n        }\n\n        return $this->headers;\n    }\n\n    /**\n     * Returns the parameter keys.\n     *\n     * @return string[]\n     */\n    public function keys(): array\n    {\n        return array_keys($this->all());\n    }\n\n    /**\n     * Replaces the current HTTP headers by a new set.\n     */\n    public function replace(array $headers = []): void\n    {\n        $this->headers = [];\n        $this->add($headers);\n    }\n\n    /**\n     * Adds new headers the current HTTP headers set.\n     */\n    public function add(array $headers): void\n    {\n        foreach ($headers as $key => $values) {\n            $this->set($key, $values);\n        }\n    }\n\n    /**\n     * Returns the first header by name or the default one.\n     */\n    public function get(string $key, ?string $default = null): ?string\n    {\n        $headers = $this->all($key);\n\n        if (!$headers) {\n            return $default;\n        }\n\n        if (null === $headers[0]) {\n            return null;\n        }\n\n        return $headers[0];\n    }\n\n    /**\n     * Sets a header by name.\n     *\n     * @param string|string[]|null $values  The value or an array of values\n     * @param bool                 $replace Whether to replace the actual value or not (true by default)\n     */\n    public function set(string $key, string|array|null $values, bool $replace = true): void\n    {\n        $key = strtr($key, self::UPPER, self::LOWER);\n\n        if (\\is_array($values)) {\n            $values = array_values($values);\n\n            if (true === $replace || !isset($this->headers[$key])) {\n                $this->headers[$key] = $values;\n            } else {\n                $this->headers[$key] = array_merge($this->headers[$key], $values);\n            }\n        } else {\n            if (true === $replace || !isset($this->headers[$key])) {\n                $this->headers[$key] = [$values];\n            } else {\n                $this->headers[$key][] = $values;\n            }\n        }\n\n        if ('cache-control' === $key) {\n            $this->cacheControl = $this->parseCacheControl(implode(', ', $this->headers[$key]));\n        }\n    }\n\n    /**\n     * Returns true if the HTTP header is defined.\n     */\n    public function has(string $key): bool\n    {\n        return \\array_key_exists(strtr($key, self::UPPER, self::LOWER), $this->all());\n    }\n\n    /**\n     * Returns true if the given HTTP header contains the given value.\n     */\n    public function contains(string $key, string $value): bool\n    {\n        return \\in_array($value, $this->all($key), true);\n    }\n\n    /**\n     * Removes a header.\n     */\n    public function remove(string $key): void\n    {\n        $key = strtr($key, self::UPPER, self::LOWER);\n\n        unset($this->headers[$key]);\n\n        if ('cache-control' === $key) {\n            $this->cacheControl = [];\n        }\n    }\n\n    /**\n     * Returns the HTTP header value converted to a date.\n     *\n     * @throws \\RuntimeException When the HTTP header is not parseable\n     */\n    public function getDate(string $key, ?\\DateTimeInterface $default = null): ?\\DateTimeImmutable\n    {\n        if (null === $value = $this->get($key)) {\n            return null !== $default ? \\DateTimeImmutable::createFromInterface($default) : null;\n        }\n\n        if (false === $date = \\DateTimeImmutable::createFromFormat(\\DATE_RFC2822, $value)) {\n            throw new \\RuntimeException(\\sprintf('The \"%s\" HTTP header is not parseable (%s).', $key, $value));\n        }\n\n        return $date;\n    }\n\n    /**\n     * Adds a custom Cache-Control directive.\n     */\n    public function addCacheControlDirective(string $key, bool|string $value = true): void\n    {\n        $this->cacheControl[$key] = $value;\n\n        $this->set('Cache-Control', $this->getCacheControlHeader());\n    }\n\n    /**\n     * Returns true if the Cache-Control directive is defined.\n     */\n    public function hasCacheControlDirective(string $key): bool\n    {\n        return \\array_key_exists($key, $this->cacheControl);\n    }\n\n    /**\n     * Returns a Cache-Control directive value by name.\n     */\n    public function getCacheControlDirective(string $key): bool|string|null\n    {\n        return $this->cacheControl[$key] ?? null;\n    }\n\n    /**\n     * Removes a Cache-Control directive.\n     */\n    public function removeCacheControlDirective(string $key): void\n    {\n        unset($this->cacheControl[$key]);\n\n        $this->set('Cache-Control', $this->getCacheControlHeader());\n    }\n\n    /**\n     * Returns an iterator for headers.\n     *\n     * @return \\ArrayIterator<string, list<string|null>>\n     */\n    public function getIterator(): \\ArrayIterator\n    {\n        return new \\ArrayIterator($this->headers);\n    }\n\n    /**\n     * Returns the number of headers.\n     */\n    public function count(): int\n    {\n        return \\count($this->headers);\n    }\n\n    protected function getCacheControlHeader(): string\n    {\n        ksort($this->cacheControl);\n\n        return HeaderUtils::toString($this->cacheControl, ',');\n    }\n\n    /**\n     * Parses a Cache-Control HTTP header.\n     */\n    protected function parseCacheControl(string $header): array\n    {\n        $parts = HeaderUtils::split($header, ',=');\n\n        return HeaderUtils::combine($parts);\n    }\n}\n"
        },
        {
          "name": "HeaderUtils.php",
          "type": "blob",
          "size": 9.0673828125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * HTTP header utility functions.\n *\n * @author Christian Schmidt <github@chsc.dk>\n */\nclass HeaderUtils\n{\n    public const DISPOSITION_ATTACHMENT = 'attachment';\n    public const DISPOSITION_INLINE = 'inline';\n\n    /**\n     * This class should not be instantiated.\n     */\n    private function __construct()\n    {\n    }\n\n    /**\n     * Splits an HTTP header by one or more separators.\n     *\n     * Example:\n     *\n     *     HeaderUtils::split('da, en-gb;q=0.8', ',;')\n     *     # returns [['da'], ['en-gb', 'q=0.8']]\n     *\n     * @param string $separators List of characters to split on, ordered by\n     *                           precedence, e.g. ',', ';=', or ',;='\n     *\n     * @return array Nested array with as many levels as there are characters in\n     *               $separators\n     */\n    public static function split(string $header, string $separators): array\n    {\n        if ('' === $separators) {\n            throw new \\InvalidArgumentException('At least one separator must be specified.');\n        }\n\n        $quotedSeparators = preg_quote($separators, '/');\n\n        preg_match_all('\n            /\n                (?!\\s)\n                    (?:\n                        # quoted-string\n                        \"(?:[^\"\\\\\\\\]|\\\\\\\\.)*(?:\"|\\\\\\\\|$)\n                    |\n                        # token\n                        [^\"'.$quotedSeparators.']+\n                    )+\n                (?<!\\s)\n            |\n                # separator\n                \\s*\n                (?<separator>['.$quotedSeparators.'])\n                \\s*\n            /x', trim($header), $matches, \\PREG_SET_ORDER);\n\n        return self::groupParts($matches, $separators);\n    }\n\n    /**\n     * Combines an array of arrays into one associative array.\n     *\n     * Each of the nested arrays should have one or two elements. The first\n     * value will be used as the keys in the associative array, and the second\n     * will be used as the values, or true if the nested array only contains one\n     * element. Array keys are lowercased.\n     *\n     * Example:\n     *\n     *     HeaderUtils::combine([['foo', 'abc'], ['bar']])\n     *     // => ['foo' => 'abc', 'bar' => true]\n     */\n    public static function combine(array $parts): array\n    {\n        $assoc = [];\n        foreach ($parts as $part) {\n            $name = strtolower($part[0]);\n            $value = $part[1] ?? true;\n            $assoc[$name] = $value;\n        }\n\n        return $assoc;\n    }\n\n    /**\n     * Joins an associative array into a string for use in an HTTP header.\n     *\n     * The key and value of each entry are joined with '=', and all entries\n     * are joined with the specified separator and an additional space (for\n     * readability). Values are quoted if necessary.\n     *\n     * Example:\n     *\n     *     HeaderUtils::toString(['foo' => 'abc', 'bar' => true, 'baz' => 'a b c'], ',')\n     *     // => 'foo=abc, bar, baz=\"a b c\"'\n     */\n    public static function toString(array $assoc, string $separator): string\n    {\n        $parts = [];\n        foreach ($assoc as $name => $value) {\n            if (true === $value) {\n                $parts[] = $name;\n            } else {\n                $parts[] = $name.'='.self::quote($value);\n            }\n        }\n\n        return implode($separator.' ', $parts);\n    }\n\n    /**\n     * Encodes a string as a quoted string, if necessary.\n     *\n     * If a string contains characters not allowed by the \"token\" construct in\n     * the HTTP specification, it is backslash-escaped and enclosed in quotes\n     * to match the \"quoted-string\" construct.\n     */\n    public static function quote(string $s): string\n    {\n        if (preg_match('/^[a-z0-9!#$%&\\'*.^_`|~-]+$/i', $s)) {\n            return $s;\n        }\n\n        return '\"'.addcslashes($s, '\"\\\\\"').'\"';\n    }\n\n    /**\n     * Decodes a quoted string.\n     *\n     * If passed an unquoted string that matches the \"token\" construct (as\n     * defined in the HTTP specification), it is passed through verbatim.\n     */\n    public static function unquote(string $s): string\n    {\n        return preg_replace('/\\\\\\\\(.)|\"/', '$1', $s);\n    }\n\n    /**\n     * Generates an HTTP Content-Disposition field-value.\n     *\n     * @param string $disposition      One of \"inline\" or \"attachment\"\n     * @param string $filename         A unicode string\n     * @param string $filenameFallback A string containing only ASCII characters that\n     *                                 is semantically equivalent to $filename. If the filename is already ASCII,\n     *                                 it can be omitted, or just copied from $filename\n     *\n     * @throws \\InvalidArgumentException\n     *\n     * @see RFC 6266\n     */\n    public static function makeDisposition(string $disposition, string $filename, string $filenameFallback = ''): string\n    {\n        if (!\\in_array($disposition, [self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE])) {\n            throw new \\InvalidArgumentException(\\sprintf('The disposition must be either \"%s\" or \"%s\".', self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE));\n        }\n\n        if ('' === $filenameFallback) {\n            $filenameFallback = $filename;\n        }\n\n        // filenameFallback is not ASCII.\n        if (!preg_match('/^[\\x20-\\x7e]*$/', $filenameFallback)) {\n            throw new \\InvalidArgumentException('The filename fallback must only contain ASCII characters.');\n        }\n\n        // percent characters aren't safe in fallback.\n        if (str_contains($filenameFallback, '%')) {\n            throw new \\InvalidArgumentException('The filename fallback cannot contain the \"%\" character.');\n        }\n\n        // path separators aren't allowed in either.\n        if (str_contains($filename, '/') || str_contains($filename, '\\\\') || str_contains($filenameFallback, '/') || str_contains($filenameFallback, '\\\\')) {\n            throw new \\InvalidArgumentException('The filename and the fallback cannot contain the \"/\" and \"\\\\\" characters.');\n        }\n\n        $params = ['filename' => $filenameFallback];\n        if ($filename !== $filenameFallback) {\n            $params['filename*'] = \"utf-8''\".rawurlencode($filename);\n        }\n\n        return $disposition.'; '.self::toString($params, ';');\n    }\n\n    /**\n     * Like parse_str(), but preserves dots in variable names.\n     */\n    public static function parseQuery(string $query, bool $ignoreBrackets = false, string $separator = '&'): array\n    {\n        $q = [];\n\n        foreach (explode($separator, $query) as $v) {\n            if (false !== $i = strpos($v, \"\\0\")) {\n                $v = substr($v, 0, $i);\n            }\n\n            if (false === $i = strpos($v, '=')) {\n                $k = urldecode($v);\n                $v = '';\n            } else {\n                $k = urldecode(substr($v, 0, $i));\n                $v = substr($v, $i);\n            }\n\n            if (false !== $i = strpos($k, \"\\0\")) {\n                $k = substr($k, 0, $i);\n            }\n\n            $k = ltrim($k, ' ');\n\n            if ($ignoreBrackets) {\n                $q[$k][] = urldecode(substr($v, 1));\n\n                continue;\n            }\n\n            if (false === $i = strpos($k, '[')) {\n                $q[] = bin2hex($k).$v;\n            } else {\n                $q[] = bin2hex(substr($k, 0, $i)).rawurlencode(substr($k, $i)).$v;\n            }\n        }\n\n        if ($ignoreBrackets) {\n            return $q;\n        }\n\n        parse_str(implode('&', $q), $q);\n\n        $query = [];\n\n        foreach ($q as $k => $v) {\n            if (false !== $i = strpos($k, '_')) {\n                $query[substr_replace($k, hex2bin(substr($k, 0, $i)).'[', 0, 1 + $i)] = $v;\n            } else {\n                $query[hex2bin($k)] = $v;\n            }\n        }\n\n        return $query;\n    }\n\n    private static function groupParts(array $matches, string $separators, bool $first = true): array\n    {\n        $separator = $separators[0];\n        $separators = substr($separators, 1) ?: '';\n        $i = 0;\n\n        if ('' === $separators && !$first) {\n            $parts = [''];\n\n            foreach ($matches as $match) {\n                if (!$i && isset($match['separator'])) {\n                    $i = 1;\n                    $parts[1] = '';\n                } else {\n                    $parts[$i] .= self::unquote($match[0]);\n                }\n            }\n\n            return $parts;\n        }\n\n        $parts = [];\n        $partMatches = [];\n\n        foreach ($matches as $match) {\n            if (($match['separator'] ?? null) === $separator) {\n                ++$i;\n            } else {\n                $partMatches[$i][] = $match;\n            }\n        }\n\n        foreach ($partMatches as $matches) {\n            if ('' === $separators && '' !== $unquoted = self::unquote($matches[0][0])) {\n                $parts[] = $unquoted;\n            } elseif ($groupedParts = self::groupParts($matches, $separators, false)) {\n                $parts[] = $groupedParts;\n            }\n        }\n\n        return $parts;\n    }\n}\n"
        },
        {
          "name": "InputBag.php",
          "type": "blob",
          "size": 4.6396484375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\BadRequestException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\UnexpectedValueException;\n\n/**\n * InputBag is a container for user input values such as $_GET, $_POST, $_REQUEST, and $_COOKIE.\n *\n * @author Saif Eddin Gmati <azjezz@protonmail.com>\n */\nfinal class InputBag extends ParameterBag\n{\n    /**\n     * Returns a scalar input value by name.\n     *\n     * @param string|int|float|bool|null $default The default value if the input key does not exist\n     */\n    public function get(string $key, mixed $default = null): string|int|float|bool|null\n    {\n        if (null !== $default && !\\is_scalar($default) && !$default instanceof \\Stringable) {\n            throw new \\InvalidArgumentException(\\sprintf('Expected a scalar value as a 2nd argument to \"%s()\", \"%s\" given.', __METHOD__, get_debug_type($default)));\n        }\n\n        $value = parent::get($key, $this);\n\n        if (null !== $value && $this !== $value && !\\is_scalar($value) && !$value instanceof \\Stringable) {\n            throw new BadRequestException(\\sprintf('Input value \"%s\" contains a non-scalar value.', $key));\n        }\n\n        return $this === $value ? $default : $value;\n    }\n\n    /**\n     * Replaces the current input values by a new set.\n     */\n    public function replace(array $inputs = []): void\n    {\n        $this->parameters = [];\n        $this->add($inputs);\n    }\n\n    /**\n     * Adds input values.\n     */\n    public function add(array $inputs = []): void\n    {\n        foreach ($inputs as $input => $value) {\n            $this->set($input, $value);\n        }\n    }\n\n    /**\n     * Sets an input by name.\n     *\n     * @param string|int|float|bool|array|null $value\n     */\n    public function set(string $key, mixed $value): void\n    {\n        if (null !== $value && !\\is_scalar($value) && !\\is_array($value) && !$value instanceof \\Stringable) {\n            throw new \\InvalidArgumentException(\\sprintf('Expected a scalar, or an array as a 2nd argument to \"%s()\", \"%s\" given.', __METHOD__, get_debug_type($value)));\n        }\n\n        $this->parameters[$key] = $value;\n    }\n\n    /**\n     * Returns the parameter value converted to an enum.\n     *\n     * @template T of \\BackedEnum\n     *\n     * @param class-string<T> $class\n     * @param ?T              $default\n     *\n     * @return ?T\n     *\n     * @psalm-return ($default is null ? T|null : T)\n     */\n    public function getEnum(string $key, string $class, ?\\BackedEnum $default = null): ?\\BackedEnum\n    {\n        try {\n            return parent::getEnum($key, $class, $default);\n        } catch (UnexpectedValueException $e) {\n            throw new BadRequestException($e->getMessage(), $e->getCode(), $e);\n        }\n    }\n\n    /**\n     * Returns the parameter value converted to string.\n     */\n    public function getString(string $key, string $default = ''): string\n    {\n        // Shortcuts the parent method because the validation on scalar is already done in get().\n        return (string) $this->get($key, $default);\n    }\n\n    public function filter(string $key, mixed $default = null, int $filter = \\FILTER_DEFAULT, mixed $options = []): mixed\n    {\n        $value = $this->has($key) ? $this->all()[$key] : $default;\n\n        // Always turn $options into an array - this allows filter_var option shortcuts.\n        if (!\\is_array($options) && $options) {\n            $options = ['flags' => $options];\n        }\n\n        if (\\is_array($value) && !(($options['flags'] ?? 0) & (\\FILTER_REQUIRE_ARRAY | \\FILTER_FORCE_ARRAY))) {\n            throw new BadRequestException(\\sprintf('Input value \"%s\" contains an array, but \"FILTER_REQUIRE_ARRAY\" or \"FILTER_FORCE_ARRAY\" flags were not set.', $key));\n        }\n\n        if ((\\FILTER_CALLBACK & $filter) && !(($options['options'] ?? null) instanceof \\Closure)) {\n            throw new \\InvalidArgumentException(\\sprintf('A Closure must be passed to \"%s()\" when FILTER_CALLBACK is used, \"%s\" given.', __METHOD__, get_debug_type($options['options'] ?? null)));\n        }\n\n        $options['flags'] ??= 0;\n        $nullOnFailure = $options['flags'] & \\FILTER_NULL_ON_FAILURE;\n        $options['flags'] |= \\FILTER_NULL_ON_FAILURE;\n\n        $value = filter_var($value, $filter, $options);\n\n        if (null !== $value || $nullOnFailure) {\n            return $value;\n        }\n\n        throw new BadRequestException(\\sprintf('Input value \"%s\" is invalid and flag \"FILTER_NULL_ON_FAILURE\" was not set.', $key));\n    }\n}\n"
        },
        {
          "name": "IpUtils.php",
          "type": "blob",
          "size": 8.4794921875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * Http utility functions.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass IpUtils\n{\n    public const PRIVATE_SUBNETS = [\n        '127.0.0.0/8',    // RFC1700 (Loopback)\n        '10.0.0.0/8',     // RFC1918\n        '192.168.0.0/16', // RFC1918\n        '172.16.0.0/12',  // RFC1918\n        '169.254.0.0/16', // RFC3927\n        '0.0.0.0/8',      // RFC5735\n        '240.0.0.0/4',    // RFC1112\n        '::1/128',        // Loopback\n        'fc00::/7',       // Unique Local Address\n        'fe80::/10',      // Link Local Address\n        '::ffff:0:0/96',  // IPv4 translations\n        '::/128',         // Unspecified address\n    ];\n\n    private static array $checkedIps = [];\n\n    /**\n     * This class should not be instantiated.\n     */\n    private function __construct()\n    {\n    }\n\n    /**\n     * Checks if an IPv4 or IPv6 address is contained in the list of given IPs or subnets.\n     *\n     * @param string|array $ips List of IPs or subnets (can be a string if only a single one)\n     */\n    public static function checkIp(string $requestIp, string|array $ips): bool\n    {\n        if (!\\is_array($ips)) {\n            $ips = [$ips];\n        }\n\n        $method = substr_count($requestIp, ':') > 1 ? 'checkIp6' : 'checkIp4';\n\n        foreach ($ips as $ip) {\n            if (self::$method($requestIp, $ip)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Compares two IPv4 addresses.\n     * In case a subnet is given, it checks if it contains the request IP.\n     *\n     * @param string $ip IPv4 address or subnet in CIDR notation\n     *\n     * @return bool Whether the request IP matches the IP, or whether the request IP is within the CIDR subnet\n     */\n    public static function checkIp4(string $requestIp, string $ip): bool\n    {\n        $cacheKey = $requestIp.'-'.$ip.'-v4';\n        if (null !== $cacheValue = self::getCacheResult($cacheKey)) {\n            return $cacheValue;\n        }\n\n        if (!filter_var($requestIp, \\FILTER_VALIDATE_IP, \\FILTER_FLAG_IPV4)) {\n            return self::setCacheResult($cacheKey, false);\n        }\n\n        if (str_contains($ip, '/')) {\n            [$address, $netmask] = explode('/', $ip, 2);\n\n            if ('0' === $netmask) {\n                return self::setCacheResult($cacheKey, false !== filter_var($address, \\FILTER_VALIDATE_IP, \\FILTER_FLAG_IPV4));\n            }\n\n            if ($netmask < 0 || $netmask > 32) {\n                return self::setCacheResult($cacheKey, false);\n            }\n        } else {\n            $address = $ip;\n            $netmask = 32;\n        }\n\n        if (false === ip2long($address)) {\n            return self::setCacheResult($cacheKey, false);\n        }\n\n        return self::setCacheResult($cacheKey, 0 === substr_compare(\\sprintf('%032b', ip2long($requestIp)), \\sprintf('%032b', ip2long($address)), 0, $netmask));\n    }\n\n    /**\n     * Compares two IPv6 addresses.\n     * In case a subnet is given, it checks if it contains the request IP.\n     *\n     * @author David Soria Parra <dsp at php dot net>\n     *\n     * @see https://github.com/dsp/v6tools\n     *\n     * @param string $ip IPv6 address or subnet in CIDR notation\n     *\n     * @throws \\RuntimeException When IPV6 support is not enabled\n     */\n    public static function checkIp6(string $requestIp, string $ip): bool\n    {\n        $cacheKey = $requestIp.'-'.$ip.'-v6';\n        if (null !== $cacheValue = self::getCacheResult($cacheKey)) {\n            return $cacheValue;\n        }\n\n        if (!((\\extension_loaded('sockets') && \\defined('AF_INET6')) || @inet_pton('::1'))) {\n            throw new \\RuntimeException('Unable to check Ipv6. Check that PHP was not compiled with option \"disable-ipv6\".');\n        }\n\n        // Check to see if we were given a IP4 $requestIp or $ip by mistake\n        if (!filter_var($requestIp, \\FILTER_VALIDATE_IP, \\FILTER_FLAG_IPV6)) {\n            return self::setCacheResult($cacheKey, false);\n        }\n\n        if (str_contains($ip, '/')) {\n            [$address, $netmask] = explode('/', $ip, 2);\n\n            if (!filter_var($address, \\FILTER_VALIDATE_IP, \\FILTER_FLAG_IPV6)) {\n                return self::setCacheResult($cacheKey, false);\n            }\n\n            if ('0' === $netmask) {\n                return (bool) unpack('n*', @inet_pton($address));\n            }\n\n            if ($netmask < 1 || $netmask > 128) {\n                return self::setCacheResult($cacheKey, false);\n            }\n        } else {\n            if (!filter_var($ip, \\FILTER_VALIDATE_IP, \\FILTER_FLAG_IPV6)) {\n                return self::setCacheResult($cacheKey, false);\n            }\n\n            $address = $ip;\n            $netmask = 128;\n        }\n\n        $bytesAddr = unpack('n*', @inet_pton($address));\n        $bytesTest = unpack('n*', @inet_pton($requestIp));\n\n        if (!$bytesAddr || !$bytesTest) {\n            return self::setCacheResult($cacheKey, false);\n        }\n\n        for ($i = 1, $ceil = ceil($netmask / 16); $i <= $ceil; ++$i) {\n            $left = $netmask - 16 * ($i - 1);\n            $left = ($left <= 16) ? $left : 16;\n            $mask = ~(0xFFFF >> $left) & 0xFFFF;\n            if (($bytesAddr[$i] & $mask) != ($bytesTest[$i] & $mask)) {\n                return self::setCacheResult($cacheKey, false);\n            }\n        }\n\n        return self::setCacheResult($cacheKey, true);\n    }\n\n    /**\n     * Anonymizes an IP/IPv6.\n     *\n     * Removes the last bytes of IPv4 and IPv6 addresses (1 byte for IPv4 and 8 bytes for IPv6 by default).\n     *\n     * @param int<0, 4>  $v4Bytes\n     * @param int<0, 16> $v6Bytes\n     */\n    public static function anonymize(string $ip/* , int $v4Bytes = 1, int $v6Bytes = 8 */): string\n    {\n        $v4Bytes = 1 < \\func_num_args() ? func_get_arg(1) : 1;\n        $v6Bytes = 2 < \\func_num_args() ? func_get_arg(2) : 8;\n\n        if ($v4Bytes < 0 || $v6Bytes < 0) {\n            throw new \\InvalidArgumentException('Cannot anonymize less than 0 bytes.');\n        }\n\n        if ($v4Bytes > 4 || $v6Bytes > 16) {\n            throw new \\InvalidArgumentException('Cannot anonymize more than 4 bytes for IPv4 and 16 bytes for IPv6.');\n        }\n\n        $wrappedIPv6 = false;\n        if (str_starts_with($ip, '[') && str_ends_with($ip, ']')) {\n            $wrappedIPv6 = true;\n            $ip = substr($ip, 1, -1);\n        }\n\n        $mappedIpV4MaskGenerator = function (string $mask, int $bytesToAnonymize) {\n            $mask .= str_repeat('ff', 4 - $bytesToAnonymize);\n            $mask .= str_repeat('00', $bytesToAnonymize);\n\n            return '::'.implode(':', str_split($mask, 4));\n        };\n\n        $packedAddress = inet_pton($ip);\n        if (4 === \\strlen($packedAddress)) {\n            $mask = rtrim(str_repeat('255.', 4 - $v4Bytes).str_repeat('0.', $v4Bytes), '.');\n        } elseif ($ip === inet_ntop($packedAddress & inet_pton('::ffff:ffff:ffff'))) {\n            $mask = $mappedIpV4MaskGenerator('ffff', $v4Bytes);\n        } elseif ($ip === inet_ntop($packedAddress & inet_pton('::ffff:ffff'))) {\n            $mask = $mappedIpV4MaskGenerator('', $v4Bytes);\n        } else {\n            $mask = str_repeat('ff', 16 - $v6Bytes).str_repeat('00', $v6Bytes);\n            $mask = implode(':', str_split($mask, 4));\n        }\n        $ip = inet_ntop($packedAddress & inet_pton($mask));\n\n        if ($wrappedIPv6) {\n            $ip = '['.$ip.']';\n        }\n\n        return $ip;\n    }\n\n    /**\n     * Checks if an IPv4 or IPv6 address is contained in the list of private IP subnets.\n     */\n    public static function isPrivateIp(string $requestIp): bool\n    {\n        return self::checkIp($requestIp, self::PRIVATE_SUBNETS);\n    }\n\n    private static function getCacheResult(string $cacheKey): ?bool\n    {\n        if (isset(self::$checkedIps[$cacheKey])) {\n            // Move the item last in cache (LRU)\n            $value = self::$checkedIps[$cacheKey];\n            unset(self::$checkedIps[$cacheKey]);\n            self::$checkedIps[$cacheKey] = $value;\n\n            return self::$checkedIps[$cacheKey];\n        }\n\n        return null;\n    }\n\n    private static function setCacheResult(string $cacheKey, bool $result): bool\n    {\n        if (1000 < \\count(self::$checkedIps)) {\n            // stop memory leak if there are many keys\n            self::$checkedIps = \\array_slice(self::$checkedIps, 500, null, true);\n        }\n\n        return self::$checkedIps[$cacheKey] = $result;\n    }\n}\n"
        },
        {
          "name": "JsonResponse.php",
          "type": "blob",
          "size": 6.4462890625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * Response represents an HTTP response in JSON format.\n *\n * Note that this class does not force the returned JSON content to be an\n * object. It is however recommended that you do return an object as it\n * protects yourself against XSSI and JSON-JavaScript Hijacking.\n *\n * @see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside\n *\n * @author Igor Wiedler <igor@wiedler.ch>\n */\nclass JsonResponse extends Response\n{\n    protected mixed $data;\n    protected ?string $callback = null;\n\n    // Encode <, >, ', &, and \" characters in the JSON, making it also safe to be embedded into HTML.\n    // 15 === JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT\n    public const DEFAULT_ENCODING_OPTIONS = 15;\n\n    protected int $encodingOptions = self::DEFAULT_ENCODING_OPTIONS;\n\n    /**\n     * @param bool $json If the data is already a JSON string\n     */\n    public function __construct(mixed $data = null, int $status = 200, array $headers = [], bool $json = false)\n    {\n        parent::__construct('', $status, $headers);\n\n        if ($json && !\\is_string($data) && !is_numeric($data) && !$data instanceof \\Stringable) {\n            throw new \\TypeError(\\sprintf('\"%s\": If $json is set to true, argument $data must be a string or object implementing __toString(), \"%s\" given.', __METHOD__, get_debug_type($data)));\n        }\n\n        $data ??= new \\ArrayObject();\n\n        $json ? $this->setJson($data) : $this->setData($data);\n    }\n\n    /**\n     * Factory method for chainability.\n     *\n     * Example:\n     *\n     *     return JsonResponse::fromJsonString('{\"key\": \"value\"}')\n     *         ->setSharedMaxAge(300);\n     *\n     * @param string $data    The JSON response string\n     * @param int    $status  The response status code (200 \"OK\" by default)\n     * @param array  $headers An array of response headers\n     */\n    public static function fromJsonString(string $data, int $status = 200, array $headers = []): static\n    {\n        return new static($data, $status, $headers, true);\n    }\n\n    /**\n     * Sets the JSONP callback.\n     *\n     * @param string|null $callback The JSONP callback or null to use none\n     *\n     * @return $this\n     *\n     * @throws \\InvalidArgumentException When the callback name is not valid\n     */\n    public function setCallback(?string $callback): static\n    {\n        if (null !== $callback) {\n            // partially taken from https://geekality.net/2011/08/03/valid-javascript-identifier/\n            // partially taken from https://github.com/willdurand/JsonpCallbackValidator\n            //      JsonpCallbackValidator is released under the MIT License. See https://github.com/willdurand/JsonpCallbackValidator/blob/v1.1.0/LICENSE for details.\n            //      (c) William Durand <william.durand1@gmail.com>\n            $pattern = '/^[$_\\p{L}][$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*(?:\\[(?:\"(?:\\\\\\.|[^\"\\\\\\])*\"|\\'(?:\\\\\\.|[^\\'\\\\\\])*\\'|\\d+)\\])*?$/u';\n            $reserved = [\n                'break', 'do', 'instanceof', 'typeof', 'case', 'else', 'new', 'var', 'catch', 'finally', 'return', 'void', 'continue', 'for', 'switch', 'while',\n                'debugger', 'function', 'this', 'with', 'default', 'if', 'throw', 'delete', 'in', 'try', 'class', 'enum', 'extends', 'super',  'const', 'export',\n                'import', 'implements', 'let', 'private', 'public', 'yield', 'interface', 'package', 'protected', 'static', 'null', 'true', 'false',\n            ];\n            $parts = explode('.', $callback);\n            foreach ($parts as $part) {\n                if (!preg_match($pattern, $part) || \\in_array($part, $reserved, true)) {\n                    throw new \\InvalidArgumentException('The callback name is not valid.');\n                }\n            }\n        }\n\n        $this->callback = $callback;\n\n        return $this->update();\n    }\n\n    /**\n     * Sets a raw string containing a JSON document to be sent.\n     *\n     * @return $this\n     */\n    public function setJson(string $json): static\n    {\n        $this->data = $json;\n\n        return $this->update();\n    }\n\n    /**\n     * Sets the data to be sent as JSON.\n     *\n     * @return $this\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function setData(mixed $data = []): static\n    {\n        try {\n            $data = json_encode($data, $this->encodingOptions);\n        } catch (\\Exception $e) {\n            if ('Exception' === $e::class && str_starts_with($e->getMessage(), 'Failed calling ')) {\n                throw $e->getPrevious() ?: $e;\n            }\n            throw $e;\n        }\n\n        if (\\JSON_THROW_ON_ERROR & $this->encodingOptions) {\n            return $this->setJson($data);\n        }\n\n        if (\\JSON_ERROR_NONE !== json_last_error()) {\n            throw new \\InvalidArgumentException(json_last_error_msg());\n        }\n\n        return $this->setJson($data);\n    }\n\n    /**\n     * Returns options used while encoding data to JSON.\n     */\n    public function getEncodingOptions(): int\n    {\n        return $this->encodingOptions;\n    }\n\n    /**\n     * Sets options used while encoding data to JSON.\n     *\n     * @return $this\n     */\n    public function setEncodingOptions(int $encodingOptions): static\n    {\n        $this->encodingOptions = $encodingOptions;\n\n        return $this->setData(json_decode($this->data));\n    }\n\n    /**\n     * Updates the content and headers according to the JSON data and callback.\n     *\n     * @return $this\n     */\n    protected function update(): static\n    {\n        if (null !== $this->callback) {\n            // Not using application/javascript for compatibility reasons with older browsers.\n            $this->headers->set('Content-Type', 'text/javascript');\n\n            return $this->setContent(\\sprintf('/**/%s(%s);', $this->callback, $this->data));\n        }\n\n        // Only set the header when there is none or when it equals 'text/javascript' (from a previous update with callback)\n        // in order to not overwrite a custom definition.\n        if (!$this->headers->has('Content-Type') || 'text/javascript' === $this->headers->get('Content-Type')) {\n            $this->headers->set('Content-Type', 'application/json');\n        }\n\n        return $this->setContent($this->data);\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "ParameterBag.php",
          "type": "blob",
          "size": 6.8154296875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\BadRequestException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\UnexpectedValueException;\n\n/**\n * ParameterBag is a container for key/value pairs.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @implements \\IteratorAggregate<string, mixed>\n */\nclass ParameterBag implements \\IteratorAggregate, \\Countable\n{\n    public function __construct(\n        protected array $parameters = [],\n    ) {\n    }\n\n    /**\n     * Returns the parameters.\n     *\n     * @param string|null $key The name of the parameter to return or null to get them all\n     */\n    public function all(?string $key = null): array\n    {\n        if (null === $key) {\n            return $this->parameters;\n        }\n\n        if (!\\is_array($value = $this->parameters[$key] ?? [])) {\n            throw new BadRequestException(\\sprintf('Unexpected value for parameter \"%s\": expecting \"array\", got \"%s\".', $key, get_debug_type($value)));\n        }\n\n        return $value;\n    }\n\n    /**\n     * Returns the parameter keys.\n     */\n    public function keys(): array\n    {\n        return array_keys($this->parameters);\n    }\n\n    /**\n     * Replaces the current parameters by a new set.\n     */\n    public function replace(array $parameters = []): void\n    {\n        $this->parameters = $parameters;\n    }\n\n    /**\n     * Adds parameters.\n     */\n    public function add(array $parameters = []): void\n    {\n        $this->parameters = array_replace($this->parameters, $parameters);\n    }\n\n    public function get(string $key, mixed $default = null): mixed\n    {\n        return \\array_key_exists($key, $this->parameters) ? $this->parameters[$key] : $default;\n    }\n\n    public function set(string $key, mixed $value): void\n    {\n        $this->parameters[$key] = $value;\n    }\n\n    /**\n     * Returns true if the parameter is defined.\n     */\n    public function has(string $key): bool\n    {\n        return \\array_key_exists($key, $this->parameters);\n    }\n\n    /**\n     * Removes a parameter.\n     */\n    public function remove(string $key): void\n    {\n        unset($this->parameters[$key]);\n    }\n\n    /**\n     * Returns the alphabetic characters of the parameter value.\n     */\n    public function getAlpha(string $key, string $default = ''): string\n    {\n        return preg_replace('/[^[:alpha:]]/', '', $this->getString($key, $default));\n    }\n\n    /**\n     * Returns the alphabetic characters and digits of the parameter value.\n     */\n    public function getAlnum(string $key, string $default = ''): string\n    {\n        return preg_replace('/[^[:alnum:]]/', '', $this->getString($key, $default));\n    }\n\n    /**\n     * Returns the digits of the parameter value.\n     */\n    public function getDigits(string $key, string $default = ''): string\n    {\n        return preg_replace('/[^[:digit:]]/', '', $this->getString($key, $default));\n    }\n\n    /**\n     * Returns the parameter as string.\n     */\n    public function getString(string $key, string $default = ''): string\n    {\n        $value = $this->get($key, $default);\n        if (!\\is_scalar($value) && !$value instanceof \\Stringable) {\n            throw new UnexpectedValueException(\\sprintf('Parameter value \"%s\" cannot be converted to \"string\".', $key));\n        }\n\n        return (string) $value;\n    }\n\n    /**\n     * Returns the parameter value converted to integer.\n     */\n    public function getInt(string $key, int $default = 0): int\n    {\n        return $this->filter($key, $default, \\FILTER_VALIDATE_INT, ['flags' => \\FILTER_REQUIRE_SCALAR]);\n    }\n\n    /**\n     * Returns the parameter value converted to boolean.\n     */\n    public function getBoolean(string $key, bool $default = false): bool\n    {\n        return $this->filter($key, $default, \\FILTER_VALIDATE_BOOL, ['flags' => \\FILTER_REQUIRE_SCALAR]);\n    }\n\n    /**\n     * Returns the parameter value converted to an enum.\n     *\n     * @template T of \\BackedEnum\n     *\n     * @param class-string<T> $class\n     * @param ?T              $default\n     *\n     * @return ?T\n     *\n     * @psalm-return ($default is null ? T|null : T)\n     */\n    public function getEnum(string $key, string $class, ?\\BackedEnum $default = null): ?\\BackedEnum\n    {\n        $value = $this->get($key);\n\n        if (null === $value) {\n            return $default;\n        }\n\n        try {\n            return $class::from($value);\n        } catch (\\ValueError|\\TypeError $e) {\n            throw new UnexpectedValueException(\\sprintf('Parameter \"%s\" cannot be converted to enum: %s.', $key, $e->getMessage()), $e->getCode(), $e);\n        }\n    }\n\n    /**\n     * Filter key.\n     *\n     * @param int                                     $filter  FILTER_* constant\n     * @param int|array{flags?: int, options?: array} $options Flags from FILTER_* constants\n     *\n     * @see https://php.net/filter-var\n     */\n    public function filter(string $key, mixed $default = null, int $filter = \\FILTER_DEFAULT, mixed $options = []): mixed\n    {\n        $value = $this->get($key, $default);\n\n        // Always turn $options into an array - this allows filter_var option shortcuts.\n        if (!\\is_array($options) && $options) {\n            $options = ['flags' => $options];\n        }\n\n        // Add a convenience check for arrays.\n        if (\\is_array($value) && !isset($options['flags'])) {\n            $options['flags'] = \\FILTER_REQUIRE_ARRAY;\n        }\n\n        if (\\is_object($value) && !$value instanceof \\Stringable) {\n            throw new UnexpectedValueException(\\sprintf('Parameter value \"%s\" cannot be filtered.', $key));\n        }\n\n        if ((\\FILTER_CALLBACK & $filter) && !(($options['options'] ?? null) instanceof \\Closure)) {\n            throw new \\InvalidArgumentException(\\sprintf('A Closure must be passed to \"%s()\" when FILTER_CALLBACK is used, \"%s\" given.', __METHOD__, get_debug_type($options['options'] ?? null)));\n        }\n\n        $options['flags'] ??= 0;\n        $nullOnFailure = $options['flags'] & \\FILTER_NULL_ON_FAILURE;\n        $options['flags'] |= \\FILTER_NULL_ON_FAILURE;\n\n        $value = filter_var($value, $filter, $options);\n\n        if (null !== $value || $nullOnFailure) {\n            return $value;\n        }\n\n        throw new \\UnexpectedValueException(\\sprintf('Parameter value \"%s\" is invalid and flag \"FILTER_NULL_ON_FAILURE\" was not set.', $key));\n    }\n\n    /**\n     * Returns an iterator for parameters.\n     *\n     * @return \\ArrayIterator<string, mixed>\n     */\n    public function getIterator(): \\ArrayIterator\n    {\n        return new \\ArrayIterator($this->parameters);\n    }\n\n    /**\n     * Returns the number of parameters.\n     */\n    public function count(): int\n    {\n        return \\count($this->parameters);\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.513671875,
          "content": "HttpFoundation Component\n========================\n\nThe HttpFoundation component defines an object-oriented layer for the HTTP\nspecification.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/http_foundation.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "RateLimiter",
          "type": "tree",
          "content": null
        },
        {
          "name": "RedirectResponse.php",
          "type": "blob",
          "size": 2.5673828125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * RedirectResponse represents an HTTP response doing a redirect.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass RedirectResponse extends Response\n{\n    protected string $targetUrl;\n\n    /**\n     * Creates a redirect response so that it conforms to the rules defined for a redirect status code.\n     *\n     * @param string $url     The URL to redirect to. The URL should be a full URL, with schema etc.,\n     *                        but practically every browser redirects on paths only as well\n     * @param int    $status  The HTTP status code (302 \"Found\" by default)\n     * @param array  $headers The headers (Location is always set to the given URL)\n     *\n     * @throws \\InvalidArgumentException\n     *\n     * @see https://tools.ietf.org/html/rfc2616#section-10.3\n     */\n    public function __construct(string $url, int $status = 302, array $headers = [])\n    {\n        parent::__construct('', $status, $headers);\n\n        $this->setTargetUrl($url);\n\n        if (!$this->isRedirect()) {\n            throw new \\InvalidArgumentException(\\sprintf('The HTTP status code is not a redirect (\"%s\" given).', $status));\n        }\n\n        if (301 == $status && !\\array_key_exists('cache-control', array_change_key_case($headers, \\CASE_LOWER))) {\n            $this->headers->remove('cache-control');\n        }\n    }\n\n    /**\n     * Returns the target URL.\n     */\n    public function getTargetUrl(): string\n    {\n        return $this->targetUrl;\n    }\n\n    /**\n     * Sets the redirect target of this response.\n     *\n     * @return $this\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function setTargetUrl(string $url): static\n    {\n        if ('' === $url) {\n            throw new \\InvalidArgumentException('Cannot redirect to an empty URL.');\n        }\n\n        $this->targetUrl = $url;\n\n        $this->setContent(\n            \\sprintf('<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta http-equiv=\"refresh\" content=\"0;url=\\'%1$s\\'\" />\n\n        <title>Redirecting to %1$s</title>\n    </head>\n    <body>\n        Redirecting to <a href=\"%1$s\">%1$s</a>.\n    </body>\n</html>', htmlspecialchars($url, \\ENT_QUOTES, 'UTF-8')));\n\n        $this->headers->set('Location', $url);\n        $this->headers->set('Content-Type', 'text/html; charset=utf-8');\n\n        return $this;\n    }\n}\n"
        },
        {
          "name": "Request.php",
          "type": "blob",
          "size": 69.443359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\BadRequestException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\ConflictingHeadersException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\JsonException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\SessionNotFoundException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\SuspiciousOperationException;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(AcceptHeader::class);\nclass_exists(FileBag::class);\nclass_exists(HeaderBag::class);\nclass_exists(HeaderUtils::class);\nclass_exists(InputBag::class);\nclass_exists(ParameterBag::class);\nclass_exists(ServerBag::class);\n\n/**\n * Request represents an HTTP request.\n *\n * The methods dealing with URL accept / return a raw path (% encoded):\n *   * getBasePath\n *   * getBaseUrl\n *   * getPathInfo\n *   * getRequestUri\n *   * getUri\n *   * getUriForPath\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Request\n{\n    public const HEADER_FORWARDED = 0b000001; // When using RFC 7239\n    public const HEADER_X_FORWARDED_FOR = 0b000010;\n    public const HEADER_X_FORWARDED_HOST = 0b000100;\n    public const HEADER_X_FORWARDED_PROTO = 0b001000;\n    public const HEADER_X_FORWARDED_PORT = 0b010000;\n    public const HEADER_X_FORWARDED_PREFIX = 0b100000;\n\n    public const HEADER_X_FORWARDED_AWS_ELB = 0b0011010; // AWS ELB doesn't send X-Forwarded-Host\n    public const HEADER_X_FORWARDED_TRAEFIK = 0b0111110; // All \"X-Forwarded-*\" headers sent by Traefik reverse proxy\n\n    public const METHOD_HEAD = 'HEAD';\n    public const METHOD_GET = 'GET';\n    public const METHOD_POST = 'POST';\n    public const METHOD_PUT = 'PUT';\n    public const METHOD_PATCH = 'PATCH';\n    public const METHOD_DELETE = 'DELETE';\n    public const METHOD_PURGE = 'PURGE';\n    public const METHOD_OPTIONS = 'OPTIONS';\n    public const METHOD_TRACE = 'TRACE';\n    public const METHOD_CONNECT = 'CONNECT';\n\n    /**\n     * @var string[]\n     */\n    protected static array $trustedProxies = [];\n\n    /**\n     * @var string[]\n     */\n    protected static array $trustedHostPatterns = [];\n\n    /**\n     * @var string[]\n     */\n    protected static array $trustedHosts = [];\n\n    protected static bool $httpMethodParameterOverride = false;\n\n    /**\n     * Custom parameters.\n     */\n    public ParameterBag $attributes;\n\n    /**\n     * Request body parameters ($_POST).\n     *\n     * @see getPayload() for portability between content types\n     */\n    public InputBag $request;\n\n    /**\n     * Query string parameters ($_GET).\n     */\n    public InputBag $query;\n\n    /**\n     * Server and execution environment parameters ($_SERVER).\n     */\n    public ServerBag $server;\n\n    /**\n     * Uploaded files ($_FILES).\n     */\n    public FileBag $files;\n\n    /**\n     * Cookies ($_COOKIE).\n     */\n    public InputBag $cookies;\n\n    /**\n     * Headers (taken from the $_SERVER).\n     */\n    public HeaderBag $headers;\n\n    /**\n     * @var string|resource|false|null\n     */\n    protected $content;\n\n    /**\n     * @var string[]|null\n     */\n    protected ?array $languages = null;\n\n    /**\n     * @var string[]|null\n     */\n    protected ?array $charsets = null;\n\n    /**\n     * @var string[]|null\n     */\n    protected ?array $encodings = null;\n\n    /**\n     * @var string[]|null\n     */\n    protected ?array $acceptableContentTypes = null;\n\n    protected ?string $pathInfo = null;\n    protected ?string $requestUri = null;\n    protected ?string $baseUrl = null;\n    protected ?string $basePath = null;\n    protected ?string $method = null;\n    protected ?string $format = null;\n    protected SessionInterface|\\Closure|null $session = null;\n    protected ?string $locale = null;\n    protected string $defaultLocale = 'en';\n\n    /**\n     * @var array<string, string[]>|null\n     */\n    protected static ?array $formats = null;\n\n    protected static ?\\Closure $requestFactory = null;\n\n    private ?string $preferredFormat = null;\n\n    private bool $isHostValid = true;\n    private bool $isForwardedValid = true;\n    private bool $isSafeContentPreferred;\n\n    private array $trustedValuesCache = [];\n\n    private static int $trustedHeaderSet = -1;\n\n    private const FORWARDED_PARAMS = [\n        self::HEADER_X_FORWARDED_FOR => 'for',\n        self::HEADER_X_FORWARDED_HOST => 'host',\n        self::HEADER_X_FORWARDED_PROTO => 'proto',\n        self::HEADER_X_FORWARDED_PORT => 'host',\n    ];\n\n    /**\n     * Names for headers that can be trusted when\n     * using trusted proxies.\n     *\n     * The FORWARDED header is the standard as of rfc7239.\n     *\n     * The other headers are non-standard, but widely used\n     * by popular reverse proxies (like Apache mod_proxy or Amazon EC2).\n     */\n    private const TRUSTED_HEADERS = [\n        self::HEADER_FORWARDED => 'FORWARDED',\n        self::HEADER_X_FORWARDED_FOR => 'X_FORWARDED_FOR',\n        self::HEADER_X_FORWARDED_HOST => 'X_FORWARDED_HOST',\n        self::HEADER_X_FORWARDED_PROTO => 'X_FORWARDED_PROTO',\n        self::HEADER_X_FORWARDED_PORT => 'X_FORWARDED_PORT',\n        self::HEADER_X_FORWARDED_PREFIX => 'X_FORWARDED_PREFIX',\n    ];\n\n    private bool $isIisRewrite = false;\n\n    /**\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function __construct(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets the parameters for this request.\n     *\n     * This method also re-initializes all properties.\n     *\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function initialize(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null): void\n    {\n        $this->request = new InputBag($request);\n        $this->query = new InputBag($query);\n        $this->attributes = new ParameterBag($attributes);\n        $this->cookies = new InputBag($cookies);\n        $this->files = new FileBag($files);\n        $this->server = new ServerBag($server);\n        $this->headers = new HeaderBag($this->server->getHeaders());\n\n        $this->content = $content;\n        $this->languages = null;\n        $this->charsets = null;\n        $this->encodings = null;\n        $this->acceptableContentTypes = null;\n        $this->pathInfo = null;\n        $this->requestUri = null;\n        $this->baseUrl = null;\n        $this->basePath = null;\n        $this->method = null;\n        $this->format = null;\n    }\n\n    /**\n     * Creates a new request with values from PHP's super globals.\n     */\n    public static function createFromGlobals(): static\n    {\n        $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER);\n\n        if (str_starts_with($request->headers->get('CONTENT_TYPE', ''), 'application/x-www-form-urlencoded')\n            && \\in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'], true)\n        ) {\n            parse_str($request->getContent(), $data);\n            $request->request = new InputBag($data);\n        }\n\n        return $request;\n    }\n\n    /**\n     * Creates a Request based on a given URI and configuration.\n     *\n     * The information contained in the URI always take precedence\n     * over the other information (server and parameters).\n     *\n     * @param string               $uri        The URI\n     * @param string               $method     The HTTP method\n     * @param array                $parameters The query (GET) or request (POST) parameters\n     * @param array                $cookies    The request cookies ($_COOKIE)\n     * @param array                $files      The request files ($_FILES)\n     * @param array                $server     The server parameters ($_SERVER)\n     * @param string|resource|null $content    The raw body data\n     *\n     * @throws BadRequestException When the URI is invalid\n     */\n    public static function create(string $uri, string $method = 'GET', array $parameters = [], array $cookies = [], array $files = [], array $server = [], $content = null): static\n    {\n        $server = array_replace([\n            'SERVER_NAME' => 'localhost',\n            'SERVER_PORT' => 80,\n            'HTTP_HOST' => 'localhost',\n            'HTTP_USER_AGENT' => 'Symfony',\n            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',\n            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n            'REMOTE_ADDR' => '127.0.0.1',\n            'SCRIPT_NAME' => '',\n            'SCRIPT_FILENAME' => '',\n            'SERVER_PROTOCOL' => 'HTTP/1.1',\n            'REQUEST_TIME' => time(),\n            'REQUEST_TIME_FLOAT' => microtime(true),\n        ], $server);\n\n        $server['PATH_INFO'] = '';\n        $server['REQUEST_METHOD'] = strtoupper($method);\n\n        if (false === $components = parse_url(\\strlen($uri) !== strcspn($uri, '?#') ? $uri : $uri.'#')) {\n            throw new BadRequestException('Invalid URI.');\n        }\n\n        if (false !== ($i = strpos($uri, '\\\\')) && $i < strcspn($uri, '?#')) {\n            throw new BadRequestException('Invalid URI: A URI cannot contain a backslash.');\n        }\n        if (\\strlen($uri) !== strcspn($uri, \"\\r\\n\\t\")) {\n            throw new BadRequestException('Invalid URI: A URI cannot contain CR/LF/TAB characters.');\n        }\n        if ('' !== $uri && (\\ord($uri[0]) <= 32 || \\ord($uri[-1]) <= 32)) {\n            throw new BadRequestException('Invalid URI: A URI must not start nor end with ASCII control characters or spaces.');\n        }\n\n        if (isset($components['host'])) {\n            $server['SERVER_NAME'] = $components['host'];\n            $server['HTTP_HOST'] = $components['host'];\n        }\n\n        if (isset($components['scheme'])) {\n            if ('https' === $components['scheme']) {\n                $server['HTTPS'] = 'on';\n                $server['SERVER_PORT'] = 443;\n            } else {\n                unset($server['HTTPS']);\n                $server['SERVER_PORT'] = 80;\n            }\n        }\n\n        if (isset($components['port'])) {\n            $server['SERVER_PORT'] = $components['port'];\n            $server['HTTP_HOST'] .= ':'.$components['port'];\n        }\n\n        if (isset($components['user'])) {\n            $server['PHP_AUTH_USER'] = $components['user'];\n        }\n\n        if (isset($components['pass'])) {\n            $server['PHP_AUTH_PW'] = $components['pass'];\n        }\n\n        if (!isset($components['path'])) {\n            $components['path'] = '/';\n        }\n\n        switch (strtoupper($method)) {\n            case 'POST':\n            case 'PUT':\n            case 'DELETE':\n                if (!isset($server['CONTENT_TYPE'])) {\n                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';\n                }\n                // no break\n            case 'PATCH':\n                $request = $parameters;\n                $query = [];\n                break;\n            default:\n                $request = [];\n                $query = $parameters;\n                break;\n        }\n\n        $queryString = '';\n        if (isset($components['query'])) {\n            parse_str(html_entity_decode($components['query']), $qs);\n\n            if ($query) {\n                $query = array_replace($qs, $query);\n                $queryString = http_build_query($query, '', '&');\n            } else {\n                $query = $qs;\n                $queryString = $components['query'];\n            }\n        } elseif ($query) {\n            $queryString = http_build_query($query, '', '&');\n        }\n\n        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');\n        $server['QUERY_STRING'] = $queryString;\n\n        return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets a callable able to create a Request instance.\n     *\n     * This is mainly useful when you need to override the Request class\n     * to keep BC with an existing system. It should not be used for any\n     * other purpose.\n     */\n    public static function setFactory(?callable $callable): void\n    {\n        self::$requestFactory = null === $callable ? null : $callable(...);\n    }\n\n    /**\n     * Clones a request and overrides some of its parameters.\n     *\n     * @param array|null $query      The GET parameters\n     * @param array|null $request    The POST parameters\n     * @param array|null $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array|null $cookies    The COOKIE parameters\n     * @param array|null $files      The FILES parameters\n     * @param array|null $server     The SERVER parameters\n     */\n    public function duplicate(?array $query = null, ?array $request = null, ?array $attributes = null, ?array $cookies = null, ?array $files = null, ?array $server = null): static\n    {\n        $dup = clone $this;\n        if (null !== $query) {\n            $dup->query = new InputBag($query);\n        }\n        if (null !== $request) {\n            $dup->request = new InputBag($request);\n        }\n        if (null !== $attributes) {\n            $dup->attributes = new ParameterBag($attributes);\n        }\n        if (null !== $cookies) {\n            $dup->cookies = new InputBag($cookies);\n        }\n        if (null !== $files) {\n            $dup->files = new FileBag($files);\n        }\n        if (null !== $server) {\n            $dup->server = new ServerBag($server);\n            $dup->headers = new HeaderBag($dup->server->getHeaders());\n        }\n        $dup->languages = null;\n        $dup->charsets = null;\n        $dup->encodings = null;\n        $dup->acceptableContentTypes = null;\n        $dup->pathInfo = null;\n        $dup->requestUri = null;\n        $dup->baseUrl = null;\n        $dup->basePath = null;\n        $dup->method = null;\n        $dup->format = null;\n\n        if (!$dup->get('_format') && $this->get('_format')) {\n            $dup->attributes->set('_format', $this->get('_format'));\n        }\n\n        if (!$dup->getRequestFormat(null)) {\n            $dup->setRequestFormat($this->getRequestFormat(null));\n        }\n\n        return $dup;\n    }\n\n    /**\n     * Clones the current request.\n     *\n     * Note that the session is not cloned as duplicated requests\n     * are most of the time sub-requests of the main one.\n     */\n    public function __clone()\n    {\n        $this->query = clone $this->query;\n        $this->request = clone $this->request;\n        $this->attributes = clone $this->attributes;\n        $this->cookies = clone $this->cookies;\n        $this->files = clone $this->files;\n        $this->server = clone $this->server;\n        $this->headers = clone $this->headers;\n    }\n\n    public function __toString(): string\n    {\n        $content = $this->getContent();\n\n        $cookieHeader = '';\n        $cookies = [];\n\n        foreach ($this->cookies as $k => $v) {\n            $cookies[] = \\is_array($v) ? http_build_query([$k => $v], '', '; ', \\PHP_QUERY_RFC3986) : \"$k=$v\";\n        }\n\n        if ($cookies) {\n            $cookieHeader = 'Cookie: '.implode('; ', $cookies).\"\\r\\n\";\n        }\n\n        return\n            \\sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).\"\\r\\n\".\n            $this->headers.\n            $cookieHeader.\"\\r\\n\".\n            $content;\n    }\n\n    /**\n     * Overrides the PHP global variables according to this request instance.\n     *\n     * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.\n     * $_FILES is never overridden, see rfc1867\n     */\n    public function overrideGlobals(): void\n    {\n        $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));\n\n        $_GET = $this->query->all();\n        $_POST = $this->request->all();\n        $_SERVER = $this->server->all();\n        $_COOKIE = $this->cookies->all();\n\n        foreach ($this->headers->all() as $key => $value) {\n            $key = strtoupper(str_replace('-', '_', $key));\n            if (\\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {\n                $_SERVER[$key] = implode(', ', $value);\n            } else {\n                $_SERVER['HTTP_'.$key] = implode(', ', $value);\n            }\n        }\n\n        $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];\n\n        $requestOrder = \\ini_get('request_order') ?: \\ini_get('variables_order');\n        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';\n\n        $_REQUEST = [[]];\n\n        foreach (str_split($requestOrder) as $order) {\n            $_REQUEST[] = $request[$order];\n        }\n\n        $_REQUEST = array_merge(...$_REQUEST);\n    }\n\n    /**\n     * Sets a list of trusted proxies.\n     *\n     * You should only list the reverse proxies that you manage directly.\n     *\n     * @param array                          $proxies          A list of trusted proxies, the string 'REMOTE_ADDR' will be replaced with $_SERVER['REMOTE_ADDR'] and 'PRIVATE_SUBNETS' by IpUtils::PRIVATE_SUBNETS\n     * @param int-mask-of<Request::HEADER_*> $trustedHeaderSet A bit field to set which headers to trust from your proxies\n     */\n    public static function setTrustedProxies(array $proxies, int $trustedHeaderSet): void\n    {\n        if (false !== $i = array_search('REMOTE_ADDR', $proxies, true)) {\n            if (isset($_SERVER['REMOTE_ADDR'])) {\n                $proxies[$i] = $_SERVER['REMOTE_ADDR'];\n            } else {\n                unset($proxies[$i]);\n                $proxies = array_values($proxies);\n            }\n        }\n\n        if (false !== ($i = array_search('PRIVATE_SUBNETS', $proxies, true)) || false !== ($i = array_search('private_ranges', $proxies, true))) {\n            unset($proxies[$i]);\n            $proxies = array_merge($proxies, IpUtils::PRIVATE_SUBNETS);\n        }\n\n        self::$trustedProxies = $proxies;\n        self::$trustedHeaderSet = $trustedHeaderSet;\n    }\n\n    /**\n     * Gets the list of trusted proxies.\n     *\n     * @return string[]\n     */\n    public static function getTrustedProxies(): array\n    {\n        return self::$trustedProxies;\n    }\n\n    /**\n     * Gets the set of trusted headers from trusted proxies.\n     *\n     * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies\n     */\n    public static function getTrustedHeaderSet(): int\n    {\n        return self::$trustedHeaderSet;\n    }\n\n    /**\n     * Sets a list of trusted host patterns.\n     *\n     * You should only list the hosts you manage using regexs.\n     *\n     * @param array $hostPatterns A list of trusted host patterns\n     */\n    public static function setTrustedHosts(array $hostPatterns): void\n    {\n        self::$trustedHostPatterns = array_map(fn ($hostPattern) => \\sprintf('{%s}i', $hostPattern), $hostPatterns);\n        // we need to reset trusted hosts on trusted host patterns change\n        self::$trustedHosts = [];\n    }\n\n    /**\n     * Gets the list of trusted host patterns.\n     *\n     * @return string[]\n     */\n    public static function getTrustedHosts(): array\n    {\n        return self::$trustedHostPatterns;\n    }\n\n    /**\n     * Normalizes a query string.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized,\n     * have consistent escaping and unneeded delimiters are removed.\n     */\n    public static function normalizeQueryString(?string $qs): string\n    {\n        if ('' === ($qs ?? '')) {\n            return '';\n        }\n\n        $qs = HeaderUtils::parseQuery($qs);\n        ksort($qs);\n\n        return http_build_query($qs, '', '&', \\PHP_QUERY_RFC3986);\n    }\n\n    /**\n     * Enables support for the _method request parameter to determine the intended HTTP method.\n     *\n     * Be warned that enabling this feature might lead to CSRF issues in your code.\n     * Check that you are using CSRF tokens when required.\n     * If the HTTP method parameter override is enabled, an html-form with method \"POST\" can be altered\n     * and used to send a \"PUT\" or \"DELETE\" request via the _method request parameter.\n     * If these methods are not protected against CSRF, this presents a possible vulnerability.\n     *\n     * The HTTP method can only be overridden when the real HTTP method is POST.\n     */\n    public static function enableHttpMethodParameterOverride(): void\n    {\n        self::$httpMethodParameterOverride = true;\n    }\n\n    /**\n     * Checks whether support for the _method request parameter is enabled.\n     */\n    public static function getHttpMethodParameterOverride(): bool\n    {\n        return self::$httpMethodParameterOverride;\n    }\n\n    /**\n     * Gets a \"parameter\" value from any bag.\n     *\n     * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the\n     * flexibility in controllers, it is better to explicitly get request parameters from the appropriate\n     * public property instead (attributes, query, request).\n     *\n     * Order of precedence: PATH (routing placeholders or custom attributes), GET, POST\n     *\n     * @internal use explicit input sources instead\n     */\n    public function get(string $key, mixed $default = null): mixed\n    {\n        if ($this !== $result = $this->attributes->get($key, $this)) {\n            return $result;\n        }\n\n        if ($this->query->has($key)) {\n            return $this->query->all()[$key];\n        }\n\n        if ($this->request->has($key)) {\n            return $this->request->all()[$key];\n        }\n\n        return $default;\n    }\n\n    /**\n     * Gets the Session.\n     *\n     * @throws SessionNotFoundException When session is not set properly\n     */\n    public function getSession(): SessionInterface\n    {\n        $session = $this->session;\n        if (!$session instanceof SessionInterface && null !== $session) {\n            $this->setSession($session = $session());\n        }\n\n        if (null === $session) {\n            throw new SessionNotFoundException('Session has not been set.');\n        }\n\n        return $session;\n    }\n\n    /**\n     * Whether the request contains a Session which was started in one of the\n     * previous requests.\n     */\n    public function hasPreviousSession(): bool\n    {\n        // the check for $this->session avoids malicious users trying to fake a session cookie with proper name\n        return $this->hasSession() && $this->cookies->has($this->getSession()->getName());\n    }\n\n    /**\n     * Whether the request contains a Session object.\n     *\n     * This method does not give any information about the state of the session object,\n     * like whether the session is started or not. It is just a way to check if this Request\n     * is associated with a Session instance.\n     *\n     * @param bool $skipIfUninitialized When true, ignores factories injected by `setSessionFactory`\n     */\n    public function hasSession(bool $skipIfUninitialized = false): bool\n    {\n        return null !== $this->session && (!$skipIfUninitialized || $this->session instanceof SessionInterface);\n    }\n\n    public function setSession(SessionInterface $session): void\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * @internal\n     *\n     * @param callable(): SessionInterface $factory\n     */\n    public function setSessionFactory(callable $factory): void\n    {\n        $this->session = $factory(...);\n    }\n\n    /**\n     * Returns the client IP addresses.\n     *\n     * In the returned array the most trusted IP address is first, and the\n     * least trusted one last. The \"real\" client IP address is the last one,\n     * but this is also the least trusted one. Trusted proxies are stripped.\n     *\n     * Use this method carefully; you should use getClientIp() instead.\n     *\n     * @see getClientIp()\n     */\n    public function getClientIps(): array\n    {\n        $ip = $this->server->get('REMOTE_ADDR');\n\n        if (!$this->isFromTrustedProxy()) {\n            return [$ip];\n        }\n\n        return $this->getTrustedValues(self::HEADER_X_FORWARDED_FOR, $ip) ?: [$ip];\n    }\n\n    /**\n     * Returns the client IP address.\n     *\n     * This method can read the client IP address from the \"X-Forwarded-For\" header\n     * when trusted proxies were set via \"setTrustedProxies()\". The \"X-Forwarded-For\"\n     * header value is a comma+space separated list of IP addresses, the left-most\n     * being the original client, and each successive proxy that passed the request\n     * adding the IP address where it received the request from.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-For\",\n     * (\"Client-Ip\" for instance), configure it via the $trustedHeaderSet\n     * argument of the Request::setTrustedProxies() method instead.\n     *\n     * @see getClientIps()\n     * @see https://wikipedia.org/wiki/X-Forwarded-For\n     */\n    public function getClientIp(): ?string\n    {\n        return $this->getClientIps()[0];\n    }\n\n    /**\n     * Returns current script name.\n     */\n    public function getScriptName(): string\n    {\n        return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));\n    }\n\n    /**\n     * Returns the path being requested relative to the executed script.\n     *\n     * The path info always starts with a /.\n     *\n     * Suppose this request is instantiated from /mysite on localhost:\n     *\n     *  * http://localhost/mysite              returns an empty string\n     *  * http://localhost/mysite/about        returns '/about'\n     *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'\n     *  * http://localhost/mysite/about?var=1  returns '/about'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getPathInfo(): string\n    {\n        return $this->pathInfo ??= $this->preparePathInfo();\n    }\n\n    /**\n     * Returns the root path from which this request is executed.\n     *\n     * Suppose that an index.php file instantiates this request object:\n     *\n     *  * http://localhost/index.php         returns an empty string\n     *  * http://localhost/index.php/page    returns an empty string\n     *  * http://localhost/web/index.php     returns '/web'\n     *  * http://localhost/we%20b/index.php  returns '/we%20b'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getBasePath(): string\n    {\n        return $this->basePath ??= $this->prepareBasePath();\n    }\n\n    /**\n     * Returns the root URL from which this request is executed.\n     *\n     * The base URL never ends with a /.\n     *\n     * This is similar to getBasePath(), except that it also includes the\n     * script filename (e.g. index.php) if one exists.\n     *\n     * @return string The raw URL (i.e. not urldecoded)\n     */\n    public function getBaseUrl(): string\n    {\n        $trustedPrefix = '';\n\n        // the proxy prefix must be prepended to any prefix being needed at the webserver level\n        if ($this->isFromTrustedProxy() && $trustedPrefixValues = $this->getTrustedValues(self::HEADER_X_FORWARDED_PREFIX)) {\n            $trustedPrefix = rtrim($trustedPrefixValues[0], '/');\n        }\n\n        return $trustedPrefix.$this->getBaseUrlReal();\n    }\n\n    /**\n     * Returns the real base URL received by the webserver from which this request is executed.\n     * The URL does not include trusted reverse proxy prefix.\n     *\n     * @return string The raw URL (i.e. not urldecoded)\n     */\n    private function getBaseUrlReal(): string\n    {\n        return $this->baseUrl ??= $this->prepareBaseUrl();\n    }\n\n    /**\n     * Gets the request's scheme.\n     */\n    public function getScheme(): string\n    {\n        return $this->isSecure() ? 'https' : 'http';\n    }\n\n    /**\n     * Returns the port on which the request is made.\n     *\n     * This method can read the client port from the \"X-Forwarded-Port\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Port\" header must contain the client port.\n     *\n     * @return int|string|null Can be a string if fetched from the server bag\n     */\n    public function getPort(): int|string|null\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_PORT)) {\n            $host = $host[0];\n        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            return $this->server->get('SERVER_PORT');\n        }\n\n        if ('[' === $host[0]) {\n            $pos = strpos($host, ':', strrpos($host, ']'));\n        } else {\n            $pos = strrpos($host, ':');\n        }\n\n        if (false !== $pos && $port = substr($host, $pos + 1)) {\n            return (int) $port;\n        }\n\n        return 'https' === $this->getScheme() ? 443 : 80;\n    }\n\n    /**\n     * Returns the user.\n     */\n    public function getUser(): ?string\n    {\n        return $this->headers->get('PHP_AUTH_USER');\n    }\n\n    /**\n     * Returns the password.\n     */\n    public function getPassword(): ?string\n    {\n        return $this->headers->get('PHP_AUTH_PW');\n    }\n\n    /**\n     * Gets the user info.\n     *\n     * @return string|null A user name if any and, optionally, scheme-specific information about how to gain authorization to access the server\n     */\n    public function getUserInfo(): ?string\n    {\n        $userinfo = $this->getUser();\n\n        $pass = $this->getPassword();\n        if ('' != $pass) {\n            $userinfo .= \":$pass\";\n        }\n\n        return $userinfo;\n    }\n\n    /**\n     * Returns the HTTP host being requested.\n     *\n     * The port name will be appended to the host if it's non-standard.\n     */\n    public function getHttpHost(): string\n    {\n        $scheme = $this->getScheme();\n        $port = $this->getPort();\n\n        if (('http' === $scheme && 80 == $port) || ('https' === $scheme && 443 == $port)) {\n            return $this->getHost();\n        }\n\n        return $this->getHost().':'.$port;\n    }\n\n    /**\n     * Returns the requested URI (path and query string).\n     *\n     * @return string The raw URI (i.e. not URI decoded)\n     */\n    public function getRequestUri(): string\n    {\n        return $this->requestUri ??= $this->prepareRequestUri();\n    }\n\n    /**\n     * Gets the scheme and HTTP host.\n     *\n     * If the URL was called with basic authentication, the user\n     * and the password are not added to the generated string.\n     */\n    public function getSchemeAndHttpHost(): string\n    {\n        return $this->getScheme().'://'.$this->getHttpHost();\n    }\n\n    /**\n     * Generates a normalized URI (URL) for the Request.\n     *\n     * @see getQueryString()\n     */\n    public function getUri(): string\n    {\n        if (null !== $qs = $this->getQueryString()) {\n            $qs = '?'.$qs;\n        }\n\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;\n    }\n\n    /**\n     * Generates a normalized URI for the given path.\n     *\n     * @param string $path A path to use instead of the current one\n     */\n    public function getUriForPath(string $path): string\n    {\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;\n    }\n\n    /**\n     * Returns the path as relative reference from the current Request path.\n     *\n     * Only the URIs path component (no schema, host etc.) is relevant and must be given.\n     * Both paths must be absolute and not contain relative parts.\n     * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.\n     * Furthermore, they can be used to reduce the link size in documents.\n     *\n     * Example target paths, given a base path of \"/a/b/c/d\":\n     * - \"/a/b/c/d\"     -> \"\"\n     * - \"/a/b/c/\"      -> \"./\"\n     * - \"/a/b/\"        -> \"../\"\n     * - \"/a/b/c/other\" -> \"other\"\n     * - \"/a/x/y\"       -> \"../../x/y\"\n     */\n    public function getRelativeUriForPath(string $path): string\n    {\n        // be sure that we are dealing with an absolute path\n        if (!isset($path[0]) || '/' !== $path[0]) {\n            return $path;\n        }\n\n        if ($path === $basePath = $this->getPathInfo()) {\n            return '';\n        }\n\n        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);\n        $targetDirs = explode('/', substr($path, 1));\n        array_pop($sourceDirs);\n        $targetFile = array_pop($targetDirs);\n\n        foreach ($sourceDirs as $i => $dir) {\n            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {\n                unset($sourceDirs[$i], $targetDirs[$i]);\n            } else {\n                break;\n            }\n        }\n\n        $targetDirs[] = $targetFile;\n        $path = str_repeat('../', \\count($sourceDirs)).implode('/', $targetDirs);\n\n        // A reference to the same base directory or an empty subdirectory must be prefixed with \"./\".\n        // This also applies to a segment with a colon character (e.g., \"file:colon\") that cannot be used\n        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name\n        // (see https://tools.ietf.org/html/rfc3986#section-4.2).\n        return !isset($path[0]) || '/' === $path[0]\n            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)\n            ? \"./$path\" : $path;\n    }\n\n    /**\n     * Generates the normalized query string for the Request.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized\n     * and have consistent escaping.\n     */\n    public function getQueryString(): ?string\n    {\n        $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));\n\n        return '' === $qs ? null : $qs;\n    }\n\n    /**\n     * Checks whether the request is secure or not.\n     *\n     * This method can read the client protocol from the \"X-Forwarded-Proto\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Proto\" header must contain the protocol: \"https\" or \"http\".\n     */\n    public function isSecure(): bool\n    {\n        if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_X_FORWARDED_PROTO)) {\n            return \\in_array(strtolower($proto[0]), ['https', 'on', 'ssl', '1'], true);\n        }\n\n        $https = $this->server->get('HTTPS');\n\n        return $https && 'off' !== strtolower($https);\n    }\n\n    /**\n     * Returns the host name.\n     *\n     * This method can read the client host name from the \"X-Forwarded-Host\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Host\" header must contain the client host name.\n     *\n     * @throws SuspiciousOperationException when the host name is invalid or not trusted\n     */\n    public function getHost(): string\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            if (!$host = $this->server->get('SERVER_NAME')) {\n                $host = $this->server->get('SERVER_ADDR', '');\n            }\n        }\n\n        // trim and remove port number from host\n        // host is lowercase as per RFC 952/2181\n        $host = strtolower(preg_replace('/:\\d+$/', '', trim($host)));\n\n        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)\n        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)\n        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names\n        if ($host && '' !== preg_replace('/(?:^\\[)?[a-zA-Z0-9-:\\]_]+\\.?/', '', $host)) {\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(\\sprintf('Invalid Host \"%s\".', $host));\n        }\n\n        if (\\count(self::$trustedHostPatterns) > 0) {\n            // to avoid host header injection attacks, you should provide a list of trusted host patterns\n\n            if (\\in_array($host, self::$trustedHosts, true)) {\n                return $host;\n            }\n\n            foreach (self::$trustedHostPatterns as $pattern) {\n                if (preg_match($pattern, $host)) {\n                    self::$trustedHosts[] = $host;\n\n                    return $host;\n                }\n            }\n\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(\\sprintf('Untrusted Host \"%s\".', $host));\n        }\n\n        return $host;\n    }\n\n    /**\n     * Sets the request method.\n     */\n    public function setMethod(string $method): void\n    {\n        $this->method = null;\n        $this->server->set('REQUEST_METHOD', $method);\n    }\n\n    /**\n     * Gets the request \"intended\" method.\n     *\n     * If the X-HTTP-Method-Override header is set, and if the method is a POST,\n     * then it is used to determine the \"real\" intended HTTP method.\n     *\n     * The _method request parameter can also be used to determine the HTTP method,\n     * but only if enableHttpMethodParameterOverride() has been called.\n     *\n     * The method is always an uppercased string.\n     *\n     * @see getRealMethod()\n     */\n    public function getMethod(): string\n    {\n        if (null !== $this->method) {\n            return $this->method;\n        }\n\n        $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n\n        if ('POST' !== $this->method) {\n            return $this->method;\n        }\n\n        $method = $this->headers->get('X-HTTP-METHOD-OVERRIDE');\n\n        if (!$method && self::$httpMethodParameterOverride) {\n            $method = $this->request->get('_method', $this->query->get('_method', 'POST'));\n        }\n\n        if (!\\is_string($method)) {\n            return $this->method;\n        }\n\n        $method = strtoupper($method);\n\n        if (\\in_array($method, ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'PATCH', 'PURGE', 'TRACE'], true)) {\n            return $this->method = $method;\n        }\n\n        if (!preg_match('/^[A-Z]++$/D', $method)) {\n            throw new SuspiciousOperationException('Invalid HTTP method override.');\n        }\n\n        return $this->method = $method;\n    }\n\n    /**\n     * Gets the \"real\" request method.\n     *\n     * @see getMethod()\n     */\n    public function getRealMethod(): string\n    {\n        return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n    }\n\n    /**\n     * Gets the mime type associated with the format.\n     */\n    public function getMimeType(string $format): ?string\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;\n    }\n\n    /**\n     * Gets the mime types associated with the format.\n     *\n     * @return string[]\n     */\n    public static function getMimeTypes(string $format): array\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return static::$formats[$format] ?? [];\n    }\n\n    /**\n     * Gets the format associated with the mime type.\n     */\n    public function getFormat(?string $mimeType): ?string\n    {\n        $canonicalMimeType = null;\n        if ($mimeType && false !== $pos = strpos($mimeType, ';')) {\n            $canonicalMimeType = trim(substr($mimeType, 0, $pos));\n        }\n\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        foreach (static::$formats as $format => $mimeTypes) {\n            if (\\in_array($mimeType, (array) $mimeTypes, true)) {\n                return $format;\n            }\n            if (null !== $canonicalMimeType && \\in_array($canonicalMimeType, (array) $mimeTypes, true)) {\n                return $format;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Associates a format with mime types.\n     *\n     * @param string|string[] $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)\n     */\n    public function setFormat(?string $format, string|array $mimeTypes): void\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        static::$formats[$format] = \\is_array($mimeTypes) ? $mimeTypes : [$mimeTypes];\n    }\n\n    /**\n     * Gets the request format.\n     *\n     * Here is the process to determine the format:\n     *\n     *  * format defined by the user (with setRequestFormat())\n     *  * _format request attribute\n     *  * $default\n     *\n     * @see getPreferredFormat\n     */\n    public function getRequestFormat(?string $default = 'html'): ?string\n    {\n        $this->format ??= $this->attributes->get('_format');\n\n        return $this->format ?? $default;\n    }\n\n    /**\n     * Sets the request format.\n     */\n    public function setRequestFormat(?string $format): void\n    {\n        $this->format = $format;\n    }\n\n    /**\n     * Gets the usual name of the format associated with the request's media type (provided in the Content-Type header).\n     *\n     * @see Request::$formats\n     */\n    public function getContentTypeFormat(): ?string\n    {\n        return $this->getFormat($this->headers->get('CONTENT_TYPE', ''));\n    }\n\n    /**\n     * Sets the default locale.\n     */\n    public function setDefaultLocale(string $locale): void\n    {\n        $this->defaultLocale = $locale;\n\n        if (null === $this->locale) {\n            $this->setPhpDefaultLocale($locale);\n        }\n    }\n\n    /**\n     * Get the default locale.\n     */\n    public function getDefaultLocale(): string\n    {\n        return $this->defaultLocale;\n    }\n\n    /**\n     * Sets the locale.\n     */\n    public function setLocale(string $locale): void\n    {\n        $this->setPhpDefaultLocale($this->locale = $locale);\n    }\n\n    /**\n     * Get the locale.\n     */\n    public function getLocale(): string\n    {\n        return $this->locale ?? $this->defaultLocale;\n    }\n\n    /**\n     * Checks if the request method is of specified type.\n     *\n     * @param string $method Uppercase request method (GET, POST etc)\n     */\n    public function isMethod(string $method): bool\n    {\n        return $this->getMethod() === strtoupper($method);\n    }\n\n    /**\n     * Checks whether or not the method is safe.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.1\n     */\n    public function isMethodSafe(): bool\n    {\n        return \\in_array($this->getMethod(), ['GET', 'HEAD', 'OPTIONS', 'TRACE']);\n    }\n\n    /**\n     * Checks whether or not the method is idempotent.\n     */\n    public function isMethodIdempotent(): bool\n    {\n        return \\in_array($this->getMethod(), ['HEAD', 'GET', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'PURGE']);\n    }\n\n    /**\n     * Checks whether the method is cacheable or not.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.3\n     */\n    public function isMethodCacheable(): bool\n    {\n        return \\in_array($this->getMethod(), ['GET', 'HEAD']);\n    }\n\n    /**\n     * Returns the protocol version.\n     *\n     * If the application is behind a proxy, the protocol version used in the\n     * requests between the client and the proxy and between the proxy and the\n     * server might be different. This returns the former (from the \"Via\" header)\n     * if the proxy is trusted (see \"setTrustedProxies()\"), otherwise it returns\n     * the latter (from the \"SERVER_PROTOCOL\" server parameter).\n     */\n    public function getProtocolVersion(): ?string\n    {\n        if ($this->isFromTrustedProxy()) {\n            preg_match('~^(HTTP/)?([1-9]\\.[0-9]) ~', $this->headers->get('Via') ?? '', $matches);\n\n            if ($matches) {\n                return 'HTTP/'.$matches[2];\n            }\n        }\n\n        return $this->server->get('SERVER_PROTOCOL');\n    }\n\n    /**\n     * Returns the request body content.\n     *\n     * @param bool $asResource If true, a resource will be returned\n     *\n     * @return string|resource\n     *\n     * @psalm-return ($asResource is true ? resource : string)\n     */\n    public function getContent(bool $asResource = false)\n    {\n        $currentContentIsResource = \\is_resource($this->content);\n\n        if (true === $asResource) {\n            if ($currentContentIsResource) {\n                rewind($this->content);\n\n                return $this->content;\n            }\n\n            // Content passed in parameter (test)\n            if (\\is_string($this->content)) {\n                $resource = fopen('php://temp', 'r+');\n                fwrite($resource, $this->content);\n                rewind($resource);\n\n                return $resource;\n            }\n\n            $this->content = false;\n\n            return fopen('php://input', 'r');\n        }\n\n        if ($currentContentIsResource) {\n            rewind($this->content);\n\n            return stream_get_contents($this->content);\n        }\n\n        if (null === $this->content || false === $this->content) {\n            $this->content = file_get_contents('php://input');\n        }\n\n        return $this->content;\n    }\n\n    /**\n     * Gets the decoded form or json request body.\n     *\n     * @throws JsonException When the body cannot be decoded to an array\n     */\n    public function getPayload(): InputBag\n    {\n        if ($this->request->count()) {\n            return clone $this->request;\n        }\n\n        if ('' === $content = $this->getContent()) {\n            return new InputBag([]);\n        }\n\n        try {\n            $content = json_decode($content, true, 512, \\JSON_BIGINT_AS_STRING | \\JSON_THROW_ON_ERROR);\n        } catch (\\JsonException $e) {\n            throw new JsonException('Could not decode request body.', $e->getCode(), $e);\n        }\n\n        if (!\\is_array($content)) {\n            throw new JsonException(\\sprintf('JSON content was expected to decode to an array, \"%s\" returned.', get_debug_type($content)));\n        }\n\n        return new InputBag($content);\n    }\n\n    /**\n     * Gets the request body decoded as array, typically from a JSON payload.\n     *\n     * @see getPayload() for portability between content types\n     *\n     * @throws JsonException When the body cannot be decoded to an array\n     */\n    public function toArray(): array\n    {\n        if ('' === $content = $this->getContent()) {\n            throw new JsonException('Request body is empty.');\n        }\n\n        try {\n            $content = json_decode($content, true, 512, \\JSON_BIGINT_AS_STRING | \\JSON_THROW_ON_ERROR);\n        } catch (\\JsonException $e) {\n            throw new JsonException('Could not decode request body.', $e->getCode(), $e);\n        }\n\n        if (!\\is_array($content)) {\n            throw new JsonException(\\sprintf('JSON content was expected to decode to an array, \"%s\" returned.', get_debug_type($content)));\n        }\n\n        return $content;\n    }\n\n    /**\n     * Gets the Etags.\n     */\n    public function getETags(): array\n    {\n        return preg_split('/\\s*,\\s*/', $this->headers->get('If-None-Match', ''), -1, \\PREG_SPLIT_NO_EMPTY);\n    }\n\n    public function isNoCache(): bool\n    {\n        return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');\n    }\n\n    /**\n     * Gets the preferred format for the response by inspecting, in the following order:\n     *   * the request format set using setRequestFormat;\n     *   * the values of the Accept HTTP header.\n     *\n     * Note that if you use this method, you should send the \"Vary: Accept\" header\n     * in the response to prevent any issues with intermediary HTTP caches.\n     */\n    public function getPreferredFormat(?string $default = 'html'): ?string\n    {\n        if (!isset($this->preferredFormat) && null !== $preferredFormat = $this->getRequestFormat(null)) {\n            $this->preferredFormat = $preferredFormat;\n        }\n\n        if ($this->preferredFormat ?? null) {\n            return $this->preferredFormat;\n        }\n\n        foreach ($this->getAcceptableContentTypes() as $mimeType) {\n            if ($this->preferredFormat = $this->getFormat($mimeType)) {\n                return $this->preferredFormat;\n            }\n        }\n\n        return $default;\n    }\n\n    /**\n     * Returns the preferred language.\n     *\n     * @param string[] $locales An array of ordered available locales\n     */\n    public function getPreferredLanguage(?array $locales = null): ?string\n    {\n        $preferredLanguages = $this->getLanguages();\n\n        if (!$locales) {\n            return $preferredLanguages[0] ?? null;\n        }\n\n        $locales = array_map($this->formatLocale(...), $locales);\n        if (!$preferredLanguages) {\n            return $locales[0];\n        }\n\n        if ($matches = array_intersect($preferredLanguages, $locales)) {\n            return current($matches);\n        }\n\n        $combinations = array_merge(...array_map($this->getLanguageCombinations(...), $preferredLanguages));\n        foreach ($combinations as $combination) {\n            foreach ($locales as $locale) {\n                if (str_starts_with($locale, $combination)) {\n                    return $locale;\n                }\n            }\n        }\n\n        return $locales[0];\n    }\n\n    /**\n     * Gets a list of languages acceptable by the client browser ordered in the user browser preferences.\n     *\n     * @return string[]\n     */\n    public function getLanguages(): array\n    {\n        if (null !== $this->languages) {\n            return $this->languages;\n        }\n\n        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();\n        $this->languages = [];\n        foreach ($languages as $acceptHeaderItem) {\n            $lang = $acceptHeaderItem->getValue();\n            $this->languages[] = self::formatLocale($lang);\n        }\n        $this->languages = array_unique($this->languages);\n\n        return $this->languages;\n    }\n\n    /**\n     * Strips the locale to only keep the canonicalized language value.\n     *\n     * Depending on the $locale value, this method can return values like :\n     * - language_Script_REGION: \"fr_Latn_FR\", \"zh_Hans_TW\"\n     * - language_Script: \"fr_Latn\", \"zh_Hans\"\n     * - language_REGION: \"fr_FR\", \"zh_TW\"\n     * - language: \"fr\", \"zh\"\n     *\n     * Invalid locale values are returned as is.\n     *\n     * @see https://wikipedia.org/wiki/IETF_language_tag\n     * @see https://datatracker.ietf.org/doc/html/rfc5646\n     */\n    private static function formatLocale(string $locale): string\n    {\n        [$language, $script, $region] = self::getLanguageComponents($locale);\n\n        return implode('_', array_filter([$language, $script, $region]));\n    }\n\n    /**\n     * Returns an array of all possible combinations of the language components.\n     *\n     * For instance, if the locale is \"fr_Latn_FR\", this method will return:\n     * - \"fr_Latn_FR\"\n     * - \"fr_Latn\"\n     * - \"fr_FR\"\n     * - \"fr\"\n     *\n     * @return string[]\n     */\n    private static function getLanguageCombinations(string $locale): array\n    {\n        [$language, $script, $region] = self::getLanguageComponents($locale);\n\n        return array_unique([\n            implode('_', array_filter([$language, $script, $region])),\n            implode('_', array_filter([$language, $script])),\n            implode('_', array_filter([$language, $region])),\n            $language,\n        ]);\n    }\n\n    /**\n     * Returns an array with the language components of the locale.\n     *\n     * For example:\n     * - If the locale is \"fr_Latn_FR\", this method will return \"fr\", \"Latn\", \"FR\"\n     * - If the locale is \"fr_FR\", this method will return \"fr\", null, \"FR\"\n     * - If the locale is \"zh_Hans\", this method will return \"zh\", \"Hans\", null\n     *\n     * @see https://wikipedia.org/wiki/IETF_language_tag\n     * @see https://datatracker.ietf.org/doc/html/rfc5646\n     *\n     * @return array{string, string|null, string|null}\n     */\n    private static function getLanguageComponents(string $locale): array\n    {\n        $locale = str_replace('_', '-', strtolower($locale));\n        $pattern = '/^([a-zA-Z]{2,3}|i-[a-zA-Z]{5,})(?:-([a-zA-Z]{4}))?(?:-([a-zA-Z]{2}))?(?:-(.+))?$/';\n        if (!preg_match($pattern, $locale, $matches)) {\n            return [$locale, null, null];\n        }\n        if (str_starts_with($matches[1], 'i-')) {\n            // Language not listed in ISO 639 that are not variants\n            // of any listed language, which can be registered with the\n            // i-prefix, such as i-cherokee\n            $matches[1] = substr($matches[1], 2);\n        }\n\n        return [\n            $matches[1],\n            isset($matches[2]) ? ucfirst(strtolower($matches[2])) : null,\n            isset($matches[3]) ? strtoupper($matches[3]) : null,\n        ];\n    }\n\n    /**\n     * Gets a list of charsets acceptable by the client browser in preferable order.\n     *\n     * @return string[]\n     */\n    public function getCharsets(): array\n    {\n        return $this->charsets ??= array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all()));\n    }\n\n    /**\n     * Gets a list of encodings acceptable by the client browser in preferable order.\n     *\n     * @return string[]\n     */\n    public function getEncodings(): array\n    {\n        return $this->encodings ??= array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all()));\n    }\n\n    /**\n     * Gets a list of content types acceptable by the client browser in preferable order.\n     *\n     * @return string[]\n     */\n    public function getAcceptableContentTypes(): array\n    {\n        return $this->acceptableContentTypes ??= array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all()));\n    }\n\n    /**\n     * Returns true if the request is an XMLHttpRequest.\n     *\n     * It works if your JavaScript library sets an X-Requested-With HTTP header.\n     * It is known to work with common JavaScript frameworks:\n     *\n     * @see https://wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript\n     */\n    public function isXmlHttpRequest(): bool\n    {\n        return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');\n    }\n\n    /**\n     * Checks whether the client browser prefers safe content or not according to RFC8674.\n     *\n     * @see https://tools.ietf.org/html/rfc8674\n     */\n    public function preferSafeContent(): bool\n    {\n        if (isset($this->isSafeContentPreferred)) {\n            return $this->isSafeContentPreferred;\n        }\n\n        if (!$this->isSecure()) {\n            // see https://tools.ietf.org/html/rfc8674#section-3\n            return $this->isSafeContentPreferred = false;\n        }\n\n        return $this->isSafeContentPreferred = AcceptHeader::fromString($this->headers->get('Prefer'))->has('safe');\n    }\n\n    /*\n     * The following methods are derived from code of the Zend Framework (1.10dev - 2010-01-24)\n     *\n     * Code subject to the new BSD license (https://framework.zend.com/license).\n     *\n     * Copyright (c) 2005-2010 Zend Technologies USA Inc. (https://www.zend.com/)\n     */\n\n    protected function prepareRequestUri(): string\n    {\n        $requestUri = '';\n\n        if ($this->isIisRewrite() && '' != $this->server->get('UNENCODED_URL')) {\n            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)\n            $requestUri = $this->server->get('UNENCODED_URL');\n            $this->server->remove('UNENCODED_URL');\n        } elseif ($this->server->has('REQUEST_URI')) {\n            $requestUri = $this->server->get('REQUEST_URI');\n\n            if ('' !== $requestUri && '/' === $requestUri[0]) {\n                // To only use path and query remove the fragment.\n                if (false !== $pos = strpos($requestUri, '#')) {\n                    $requestUri = substr($requestUri, 0, $pos);\n                }\n            } else {\n                // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path,\n                // only use URL path.\n                $uriComponents = parse_url($requestUri);\n\n                if (isset($uriComponents['path'])) {\n                    $requestUri = $uriComponents['path'];\n                }\n\n                if (isset($uriComponents['query'])) {\n                    $requestUri .= '?'.$uriComponents['query'];\n                }\n            }\n        } elseif ($this->server->has('ORIG_PATH_INFO')) {\n            // IIS 5.0, PHP as CGI\n            $requestUri = $this->server->get('ORIG_PATH_INFO');\n            if ('' != $this->server->get('QUERY_STRING')) {\n                $requestUri .= '?'.$this->server->get('QUERY_STRING');\n            }\n            $this->server->remove('ORIG_PATH_INFO');\n        }\n\n        // normalize the request URI to ease creating sub-requests from this request\n        $this->server->set('REQUEST_URI', $requestUri);\n\n        return $requestUri;\n    }\n\n    /**\n     * Prepares the base URL.\n     */\n    protected function prepareBaseUrl(): string\n    {\n        $filename = basename($this->server->get('SCRIPT_FILENAME', ''));\n\n        if (basename($this->server->get('SCRIPT_NAME', '')) === $filename) {\n            $baseUrl = $this->server->get('SCRIPT_NAME');\n        } elseif (basename($this->server->get('PHP_SELF', '')) === $filename) {\n            $baseUrl = $this->server->get('PHP_SELF');\n        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME', '')) === $filename) {\n            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility\n        } else {\n            // Backtrack up the script_filename to find the portion matching\n            // php_self\n            $path = $this->server->get('PHP_SELF', '');\n            $file = $this->server->get('SCRIPT_FILENAME', '');\n            $segs = explode('/', trim($file, '/'));\n            $segs = array_reverse($segs);\n            $index = 0;\n            $last = \\count($segs);\n            $baseUrl = '';\n            do {\n                $seg = $segs[$index];\n                $baseUrl = '/'.$seg.$baseUrl;\n                ++$index;\n            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);\n        }\n\n        // Does the baseUrl have anything in common with the request_uri?\n        $requestUri = $this->getRequestUri();\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {\n            // full $baseUrl matches\n            return $prefix;\n        }\n\n        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(\\dirname($baseUrl), '/'.\\DIRECTORY_SEPARATOR).'/')) {\n            // directory portion of $baseUrl matches\n            return rtrim($prefix, '/'.\\DIRECTORY_SEPARATOR);\n        }\n\n        $truncatedRequestUri = $requestUri;\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $truncatedRequestUri = substr($requestUri, 0, $pos);\n        }\n\n        $basename = basename($baseUrl ?? '');\n        if (!$basename || !strpos(rawurldecode($truncatedRequestUri), $basename)) {\n            // no match whatsoever; set it blank\n            return '';\n        }\n\n        // If using mod_rewrite or ISAPI_Rewrite strip the script filename\n        // out of baseUrl. $pos !== 0 makes sure it is not matching a value\n        // from PATH_INFO or QUERY_STRING\n        if (\\strlen($requestUri) >= \\strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {\n            $baseUrl = substr($requestUri, 0, $pos + \\strlen($baseUrl));\n        }\n\n        return rtrim($baseUrl, '/'.\\DIRECTORY_SEPARATOR);\n    }\n\n    /**\n     * Prepares the base path.\n     */\n    protected function prepareBasePath(): string\n    {\n        $baseUrl = $this->getBaseUrl();\n        if (!$baseUrl) {\n            return '';\n        }\n\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n        if (basename($baseUrl) === $filename) {\n            $basePath = \\dirname($baseUrl);\n        } else {\n            $basePath = $baseUrl;\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $basePath = str_replace('\\\\', '/', $basePath);\n        }\n\n        return rtrim($basePath, '/');\n    }\n\n    /**\n     * Prepares the path info.\n     */\n    protected function preparePathInfo(): string\n    {\n        if (null === ($requestUri = $this->getRequestUri())) {\n            return '/';\n        }\n\n        // Remove the query string from REQUEST_URI\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $requestUri = substr($requestUri, 0, $pos);\n        }\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if (null === ($baseUrl = $this->getBaseUrlReal())) {\n            return $requestUri;\n        }\n\n        $pathInfo = substr($requestUri, \\strlen($baseUrl));\n        if ('' === $pathInfo) {\n            // If substr() returns false then PATH_INFO is set to an empty string\n            return '/';\n        }\n\n        return $pathInfo;\n    }\n\n    /**\n     * Initializes HTTP request formats.\n     */\n    protected static function initializeFormats(): void\n    {\n        static::$formats = [\n            'html' => ['text/html', 'application/xhtml+xml'],\n            'txt' => ['text/plain'],\n            'js' => ['application/javascript', 'application/x-javascript', 'text/javascript'],\n            'css' => ['text/css'],\n            'json' => ['application/json', 'application/x-json'],\n            'jsonld' => ['application/ld+json'],\n            'xml' => ['text/xml', 'application/xml', 'application/x-xml'],\n            'rdf' => ['application/rdf+xml'],\n            'atom' => ['application/atom+xml'],\n            'rss' => ['application/rss+xml'],\n            'form' => ['application/x-www-form-urlencoded', 'multipart/form-data'],\n        ];\n    }\n\n    private function setPhpDefaultLocale(string $locale): void\n    {\n        // if either the class Locale doesn't exist, or an exception is thrown when\n        // setting the default locale, the intl module is not installed, and\n        // the call can be ignored:\n        try {\n            if (class_exists(\\Locale::class, false)) {\n                \\Locale::setDefault($locale);\n            }\n        } catch (\\Exception) {\n        }\n    }\n\n    /**\n     * Returns the prefix as encoded in the string when the string starts with\n     * the given prefix, null otherwise.\n     */\n    private function getUrlencodedPrefix(string $string, string $prefix): ?string\n    {\n        if ($this->isIisRewrite()) {\n            // ISS with UrlRewriteModule might report SCRIPT_NAME/PHP_SELF with wrong case\n            // see https://github.com/php/php-src/issues/11981\n            if (0 !== stripos(rawurldecode($string), $prefix)) {\n                return null;\n            }\n        } elseif (!str_starts_with(rawurldecode($string), $prefix)) {\n            return null;\n        }\n\n        $len = \\strlen($prefix);\n\n        if (preg_match(\\sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {\n            return $match[0];\n        }\n\n        return null;\n    }\n\n    private static function createRequestFromFactory(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null): static\n    {\n        if (self::$requestFactory) {\n            $request = (self::$requestFactory)($query, $request, $attributes, $cookies, $files, $server, $content);\n\n            if (!$request instanceof self) {\n                throw new \\LogicException('The Request factory must return an instance of Symfony\\Component\\HttpFoundation\\Request.');\n            }\n\n            return $request;\n        }\n\n        return new static($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Indicates whether this request originated from a trusted proxy.\n     *\n     * This can be useful to determine whether or not to trust the\n     * contents of a proxy-specific header.\n     */\n    public function isFromTrustedProxy(): bool\n    {\n        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR', ''), self::$trustedProxies);\n    }\n\n    /**\n     * This method is rather heavy because it splits and merges headers, and it's called by many other methods such as\n     * getPort(), isSecure(), getHost(), getClientIps(), getBaseUrl() etc. Thus, we try to cache the results for\n     * best performance.\n     */\n    private function getTrustedValues(int $type, ?string $ip = null): array\n    {\n        $cacheKey = $type.\"\\0\".((self::$trustedHeaderSet & $type) ? $this->headers->get(self::TRUSTED_HEADERS[$type]) : '');\n        $cacheKey .= \"\\0\".$ip.\"\\0\".$this->headers->get(self::TRUSTED_HEADERS[self::HEADER_FORWARDED]);\n\n        if (isset($this->trustedValuesCache[$cacheKey])) {\n            return $this->trustedValuesCache[$cacheKey];\n        }\n\n        $clientValues = [];\n        $forwardedValues = [];\n\n        if ((self::$trustedHeaderSet & $type) && $this->headers->has(self::TRUSTED_HEADERS[$type])) {\n            foreach (explode(',', $this->headers->get(self::TRUSTED_HEADERS[$type])) as $v) {\n                $clientValues[] = (self::HEADER_X_FORWARDED_PORT === $type ? '0.0.0.0:' : '').trim($v);\n            }\n        }\n\n        if ((self::$trustedHeaderSet & self::HEADER_FORWARDED) && (isset(self::FORWARDED_PARAMS[$type])) && $this->headers->has(self::TRUSTED_HEADERS[self::HEADER_FORWARDED])) {\n            $forwarded = $this->headers->get(self::TRUSTED_HEADERS[self::HEADER_FORWARDED]);\n            $parts = HeaderUtils::split($forwarded, ',;=');\n            $param = self::FORWARDED_PARAMS[$type];\n            foreach ($parts as $subParts) {\n                if (null === $v = HeaderUtils::combine($subParts)[$param] ?? null) {\n                    continue;\n                }\n                if (self::HEADER_X_FORWARDED_PORT === $type) {\n                    if (str_ends_with($v, ']') || false === $v = strrchr($v, ':')) {\n                        $v = $this->isSecure() ? ':443' : ':80';\n                    }\n                    $v = '0.0.0.0'.$v;\n                }\n                $forwardedValues[] = $v;\n            }\n        }\n\n        if (null !== $ip) {\n            $clientValues = $this->normalizeAndFilterClientIps($clientValues, $ip);\n            $forwardedValues = $this->normalizeAndFilterClientIps($forwardedValues, $ip);\n        }\n\n        if ($forwardedValues === $clientValues || !$clientValues) {\n            return $this->trustedValuesCache[$cacheKey] = $forwardedValues;\n        }\n\n        if (!$forwardedValues) {\n            return $this->trustedValuesCache[$cacheKey] = $clientValues;\n        }\n\n        if (!$this->isForwardedValid) {\n            return $this->trustedValuesCache[$cacheKey] = null !== $ip ? ['0.0.0.0', $ip] : [];\n        }\n        $this->isForwardedValid = false;\n\n        throw new ConflictingHeadersException(\\sprintf('The request has both a trusted \"%s\" header and a trusted \"%s\" header, conflicting with each other. You should either configure your proxy to remove one of them, or configure your project to distrust the offending one.', self::TRUSTED_HEADERS[self::HEADER_FORWARDED], self::TRUSTED_HEADERS[$type]));\n    }\n\n    private function normalizeAndFilterClientIps(array $clientIps, string $ip): array\n    {\n        if (!$clientIps) {\n            return [];\n        }\n        $clientIps[] = $ip; // Complete the IP chain with the IP the request actually came from\n        $firstTrustedIp = null;\n\n        foreach ($clientIps as $key => $clientIp) {\n            if (strpos($clientIp, '.')) {\n                // Strip :port from IPv4 addresses. This is allowed in Forwarded\n                // and may occur in X-Forwarded-For.\n                $i = strpos($clientIp, ':');\n                if ($i) {\n                    $clientIps[$key] = $clientIp = substr($clientIp, 0, $i);\n                }\n            } elseif (str_starts_with($clientIp, '[')) {\n                // Strip brackets and :port from IPv6 addresses.\n                $i = strpos($clientIp, ']', 1);\n                $clientIps[$key] = $clientIp = substr($clientIp, 1, $i - 1);\n            }\n\n            if (!filter_var($clientIp, \\FILTER_VALIDATE_IP)) {\n                unset($clientIps[$key]);\n\n                continue;\n            }\n\n            if (IpUtils::checkIp($clientIp, self::$trustedProxies)) {\n                unset($clientIps[$key]);\n\n                // Fallback to this when the client IP falls into the range of trusted proxies\n                $firstTrustedIp ??= $clientIp;\n            }\n        }\n\n        // Now the IP chain contains only untrusted proxies and the client IP\n        return $clientIps ? array_reverse($clientIps) : [$firstTrustedIp];\n    }\n\n    /**\n     * Is this IIS with UrlRewriteModule?\n     *\n     * This method consumes, caches and removed the IIS_WasUrlRewritten env var,\n     * so we don't inherit it to sub-requests.\n     */\n    private function isIisRewrite(): bool\n    {\n        if (1 === $this->server->getInt('IIS_WasUrlRewritten')) {\n            $this->isIisRewrite = true;\n            $this->server->remove('IIS_WasUrlRewritten');\n        }\n\n        return $this->isIisRewrite;\n    }\n}\n"
        },
        {
          "name": "RequestMatcher",
          "type": "tree",
          "content": null
        },
        {
          "name": "RequestMatcherInterface.php",
          "type": "blob",
          "size": 0.6064453125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * RequestMatcherInterface is an interface for strategies to match a Request.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\ninterface RequestMatcherInterface\n{\n    /**\n     * Decides whether the rule(s) implemented by the strategy matches the supplied request.\n     */\n    public function matches(Request $request): bool;\n}\n"
        },
        {
          "name": "RequestStack.php",
          "type": "blob",
          "size": 2.81640625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\SessionNotFoundException;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n/**\n * Request stack that controls the lifecycle of requests.\n *\n * @author Benjamin Eberlei <kontakt@beberlei.de>\n */\nclass RequestStack\n{\n    /**\n     * @var Request[]\n     */\n    private array $requests = [];\n\n    /**\n     * @param Request[] $requests\n     */\n    public function __construct(array $requests = [])\n    {\n        foreach ($requests as $request) {\n            $this->push($request);\n        }\n    }\n\n    /**\n     * Pushes a Request on the stack.\n     *\n     * This method should generally not be called directly as the stack\n     * management should be taken care of by the application itself.\n     */\n    public function push(Request $request): void\n    {\n        $this->requests[] = $request;\n    }\n\n    /**\n     * Pops the current request from the stack.\n     *\n     * This operation lets the current request go out of scope.\n     *\n     * This method should generally not be called directly as the stack\n     * management should be taken care of by the application itself.\n     */\n    public function pop(): ?Request\n    {\n        if (!$this->requests) {\n            return null;\n        }\n\n        return array_pop($this->requests);\n    }\n\n    public function getCurrentRequest(): ?Request\n    {\n        return end($this->requests) ?: null;\n    }\n\n    /**\n     * Gets the main request.\n     *\n     * Be warned that making your code aware of the main request\n     * might make it un-compatible with other features of your framework\n     * like ESI support.\n     */\n    public function getMainRequest(): ?Request\n    {\n        if (!$this->requests) {\n            return null;\n        }\n\n        return $this->requests[0];\n    }\n\n    /**\n     * Returns the parent request of the current.\n     *\n     * Be warned that making your code aware of the parent request\n     * might make it un-compatible with other features of your framework\n     * like ESI support.\n     *\n     * If current Request is the main request, it returns null.\n     */\n    public function getParentRequest(): ?Request\n    {\n        $pos = \\count($this->requests) - 2;\n\n        return $this->requests[$pos] ?? null;\n    }\n\n    /**\n     * Gets the current session.\n     *\n     * @throws SessionNotFoundException\n     */\n    public function getSession(): SessionInterface\n    {\n        if ((null !== $request = end($this->requests) ?: null) && $request->hasSession()) {\n            return $request->getSession();\n        }\n\n        throw new SessionNotFoundException();\n    }\n}\n"
        },
        {
          "name": "Response.php",
          "type": "blob",
          "size": 39.05078125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(ResponseHeaderBag::class);\n\n/**\n * Response represents an HTTP response.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Response\n{\n    public const HTTP_CONTINUE = 100;\n    public const HTTP_SWITCHING_PROTOCOLS = 101;\n    public const HTTP_PROCESSING = 102;            // RFC2518\n    public const HTTP_EARLY_HINTS = 103;           // RFC8297\n    public const HTTP_OK = 200;\n    public const HTTP_CREATED = 201;\n    public const HTTP_ACCEPTED = 202;\n    public const HTTP_NON_AUTHORITATIVE_INFORMATION = 203;\n    public const HTTP_NO_CONTENT = 204;\n    public const HTTP_RESET_CONTENT = 205;\n    public const HTTP_PARTIAL_CONTENT = 206;\n    public const HTTP_MULTI_STATUS = 207;          // RFC4918\n    public const HTTP_ALREADY_REPORTED = 208;      // RFC5842\n    public const HTTP_IM_USED = 226;               // RFC3229\n    public const HTTP_MULTIPLE_CHOICES = 300;\n    public const HTTP_MOVED_PERMANENTLY = 301;\n    public const HTTP_FOUND = 302;\n    public const HTTP_SEE_OTHER = 303;\n    public const HTTP_NOT_MODIFIED = 304;\n    public const HTTP_USE_PROXY = 305;\n    public const HTTP_RESERVED = 306;\n    public const HTTP_TEMPORARY_REDIRECT = 307;\n    public const HTTP_PERMANENTLY_REDIRECT = 308;  // RFC7238\n    public const HTTP_BAD_REQUEST = 400;\n    public const HTTP_UNAUTHORIZED = 401;\n    public const HTTP_PAYMENT_REQUIRED = 402;\n    public const HTTP_FORBIDDEN = 403;\n    public const HTTP_NOT_FOUND = 404;\n    public const HTTP_METHOD_NOT_ALLOWED = 405;\n    public const HTTP_NOT_ACCEPTABLE = 406;\n    public const HTTP_PROXY_AUTHENTICATION_REQUIRED = 407;\n    public const HTTP_REQUEST_TIMEOUT = 408;\n    public const HTTP_CONFLICT = 409;\n    public const HTTP_GONE = 410;\n    public const HTTP_LENGTH_REQUIRED = 411;\n    public const HTTP_PRECONDITION_FAILED = 412;\n    public const HTTP_REQUEST_ENTITY_TOO_LARGE = 413;\n    public const HTTP_REQUEST_URI_TOO_LONG = 414;\n    public const HTTP_UNSUPPORTED_MEDIA_TYPE = 415;\n    public const HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n    public const HTTP_EXPECTATION_FAILED = 417;\n    public const HTTP_I_AM_A_TEAPOT = 418;                                               // RFC2324\n    public const HTTP_MISDIRECTED_REQUEST = 421;                                         // RFC7540\n    public const HTTP_UNPROCESSABLE_ENTITY = 422;                                        // RFC4918\n    public const HTTP_LOCKED = 423;                                                      // RFC4918\n    public const HTTP_FAILED_DEPENDENCY = 424;                                           // RFC4918\n    public const HTTP_TOO_EARLY = 425;                                                   // RFC-ietf-httpbis-replay-04\n    public const HTTP_UPGRADE_REQUIRED = 426;                                            // RFC2817\n    public const HTTP_PRECONDITION_REQUIRED = 428;                                       // RFC6585\n    public const HTTP_TOO_MANY_REQUESTS = 429;                                           // RFC6585\n    public const HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;                             // RFC6585\n    public const HTTP_UNAVAILABLE_FOR_LEGAL_REASONS = 451;                               // RFC7725\n    public const HTTP_INTERNAL_SERVER_ERROR = 500;\n    public const HTTP_NOT_IMPLEMENTED = 501;\n    public const HTTP_BAD_GATEWAY = 502;\n    public const HTTP_SERVICE_UNAVAILABLE = 503;\n    public const HTTP_GATEWAY_TIMEOUT = 504;\n    public const HTTP_VERSION_NOT_SUPPORTED = 505;\n    public const HTTP_VARIANT_ALSO_NEGOTIATES_EXPERIMENTAL = 506;                        // RFC2295\n    public const HTTP_INSUFFICIENT_STORAGE = 507;                                        // RFC4918\n    public const HTTP_LOOP_DETECTED = 508;                                               // RFC5842\n    public const HTTP_NOT_EXTENDED = 510;                                                // RFC2774\n    public const HTTP_NETWORK_AUTHENTICATION_REQUIRED = 511;                             // RFC6585\n\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\n     */\n    private const HTTP_RESPONSE_CACHE_CONTROL_DIRECTIVES = [\n        'must_revalidate' => false,\n        'no_cache' => false,\n        'no_store' => false,\n        'no_transform' => false,\n        'public' => false,\n        'private' => false,\n        'proxy_revalidate' => false,\n        'max_age' => true,\n        's_maxage' => true,\n        'stale_if_error' => true,         // RFC5861\n        'stale_while_revalidate' => true, // RFC5861\n        'immutable' => false,\n        'last_modified' => true,\n        'etag' => true,\n    ];\n\n    public ResponseHeaderBag $headers;\n\n    protected string $content;\n    protected string $version;\n    protected int $statusCode;\n    protected string $statusText;\n    protected ?string $charset = null;\n\n    /**\n     * Status codes translation table.\n     *\n     * The list of codes is complete according to the\n     * {@link https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml Hypertext Transfer Protocol (HTTP) Status Code Registry}\n     * (last updated 2021-10-01).\n     *\n     * Unless otherwise noted, the status code is defined in RFC2616.\n     */\n    public static array $statusTexts = [\n        100 => 'Continue',\n        101 => 'Switching Protocols',\n        102 => 'Processing',            // RFC2518\n        103 => 'Early Hints',\n        200 => 'OK',\n        201 => 'Created',\n        202 => 'Accepted',\n        203 => 'Non-Authoritative Information',\n        204 => 'No Content',\n        205 => 'Reset Content',\n        206 => 'Partial Content',\n        207 => 'Multi-Status',          // RFC4918\n        208 => 'Already Reported',      // RFC5842\n        226 => 'IM Used',               // RFC3229\n        300 => 'Multiple Choices',\n        301 => 'Moved Permanently',\n        302 => 'Found',\n        303 => 'See Other',\n        304 => 'Not Modified',\n        305 => 'Use Proxy',\n        307 => 'Temporary Redirect',\n        308 => 'Permanent Redirect',    // RFC7238\n        400 => 'Bad Request',\n        401 => 'Unauthorized',\n        402 => 'Payment Required',\n        403 => 'Forbidden',\n        404 => 'Not Found',\n        405 => 'Method Not Allowed',\n        406 => 'Not Acceptable',\n        407 => 'Proxy Authentication Required',\n        408 => 'Request Timeout',\n        409 => 'Conflict',\n        410 => 'Gone',\n        411 => 'Length Required',\n        412 => 'Precondition Failed',\n        413 => 'Content Too Large',                                           // RFC-ietf-httpbis-semantics\n        414 => 'URI Too Long',\n        415 => 'Unsupported Media Type',\n        416 => 'Range Not Satisfiable',\n        417 => 'Expectation Failed',\n        418 => 'I\\'m a teapot',                                               // RFC2324\n        421 => 'Misdirected Request',                                         // RFC7540\n        422 => 'Unprocessable Content',                                       // RFC-ietf-httpbis-semantics\n        423 => 'Locked',                                                      // RFC4918\n        424 => 'Failed Dependency',                                           // RFC4918\n        425 => 'Too Early',                                                   // RFC-ietf-httpbis-replay-04\n        426 => 'Upgrade Required',                                            // RFC2817\n        428 => 'Precondition Required',                                       // RFC6585\n        429 => 'Too Many Requests',                                           // RFC6585\n        431 => 'Request Header Fields Too Large',                             // RFC6585\n        451 => 'Unavailable For Legal Reasons',                               // RFC7725\n        500 => 'Internal Server Error',\n        501 => 'Not Implemented',\n        502 => 'Bad Gateway',\n        503 => 'Service Unavailable',\n        504 => 'Gateway Timeout',\n        505 => 'HTTP Version Not Supported',\n        506 => 'Variant Also Negotiates',                                     // RFC2295\n        507 => 'Insufficient Storage',                                        // RFC4918\n        508 => 'Loop Detected',                                               // RFC5842\n        510 => 'Not Extended',                                                // RFC2774\n        511 => 'Network Authentication Required',                             // RFC6585\n    ];\n\n    /**\n     * Tracks headers already sent in informational responses.\n     */\n    private array $sentHeaders;\n\n    /**\n     * @param int $status The HTTP status code (200 \"OK\" by default)\n     *\n     * @throws \\InvalidArgumentException When the HTTP status code is not valid\n     */\n    public function __construct(?string $content = '', int $status = 200, array $headers = [])\n    {\n        $this->headers = new ResponseHeaderBag($headers);\n        $this->setContent($content);\n        $this->setStatusCode($status);\n        $this->setProtocolVersion('1.0');\n    }\n\n    /**\n     * Returns the Response as an HTTP string.\n     *\n     * The string representation of the Response is the same as the\n     * one that will be sent to the client only if the prepare() method\n     * has been called before.\n     *\n     * @see prepare()\n     */\n    public function __toString(): string\n    {\n        return\n            \\sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText).\"\\r\\n\".\n            $this->headers.\"\\r\\n\".\n            $this->getContent();\n    }\n\n    /**\n     * Clones the current Response instance.\n     */\n    public function __clone()\n    {\n        $this->headers = clone $this->headers;\n    }\n\n    /**\n     * Prepares the Response before it is sent to the client.\n     *\n     * This method tweaks the Response to ensure that it is\n     * compliant with RFC 2616. Most of the changes are based on\n     * the Request that is \"associated\" with this Response.\n     *\n     * @return $this\n     */\n    public function prepare(Request $request): static\n    {\n        $headers = $this->headers;\n\n        if ($this->isInformational() || $this->isEmpty()) {\n            $this->setContent(null);\n            $headers->remove('Content-Type');\n            $headers->remove('Content-Length');\n            // prevent PHP from sending the Content-Type header based on default_mimetype\n            ini_set('default_mimetype', '');\n        } else {\n            // Content-type based on the Request\n            if (!$headers->has('Content-Type')) {\n                $format = $request->getRequestFormat(null);\n                if (null !== $format && $mimeType = $request->getMimeType($format)) {\n                    $headers->set('Content-Type', $mimeType);\n                }\n            }\n\n            // Fix Content-Type\n            $charset = $this->charset ?: 'UTF-8';\n            if (!$headers->has('Content-Type')) {\n                $headers->set('Content-Type', 'text/html; charset='.$charset);\n            } elseif (0 === stripos($headers->get('Content-Type') ?? '', 'text/') && false === stripos($headers->get('Content-Type') ?? '', 'charset')) {\n                // add the charset\n                $headers->set('Content-Type', $headers->get('Content-Type').'; charset='.$charset);\n            }\n\n            // Fix Content-Length\n            if ($headers->has('Transfer-Encoding')) {\n                $headers->remove('Content-Length');\n            }\n\n            if ($request->isMethod('HEAD')) {\n                // cf. RFC2616 14.13\n                $length = $headers->get('Content-Length');\n                $this->setContent(null);\n                if ($length) {\n                    $headers->set('Content-Length', $length);\n                }\n            }\n        }\n\n        // Fix protocol\n        if ('HTTP/1.0' != $request->server->get('SERVER_PROTOCOL')) {\n            $this->setProtocolVersion('1.1');\n        }\n\n        // Check if we need to send extra expire info headers\n        if ('1.0' == $this->getProtocolVersion() && str_contains($headers->get('Cache-Control', ''), 'no-cache')) {\n            $headers->set('pragma', 'no-cache');\n            $headers->set('expires', -1);\n        }\n\n        $this->ensureIEOverSSLCompatibility($request);\n\n        if ($request->isSecure()) {\n            foreach ($headers->getCookies() as $cookie) {\n                $cookie->setSecureDefault(true);\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sends HTTP headers.\n     *\n     * @param positive-int|null $statusCode The status code to use, override the statusCode property if set and not null\n     *\n     * @return $this\n     */\n    public function sendHeaders(?int $statusCode = null): static\n    {\n        // headers have already been sent by the developer\n        if (headers_sent()) {\n            return $this;\n        }\n\n        $informationalResponse = $statusCode >= 100 && $statusCode < 200;\n        if ($informationalResponse && !\\function_exists('headers_send')) {\n            // skip informational responses if not supported by the SAPI\n            return $this;\n        }\n\n        // headers\n        foreach ($this->headers->allPreserveCaseWithoutCookies() as $name => $values) {\n            // As recommended by RFC 8297, PHP automatically copies headers from previous 103 responses, we need to deal with that if headers changed\n            $previousValues = $this->sentHeaders[$name] ?? null;\n            if ($previousValues === $values) {\n                // Header already sent in a previous response, it will be automatically copied in this response by PHP\n                continue;\n            }\n\n            $replace = 0 === strcasecmp($name, 'Content-Type');\n\n            if (null !== $previousValues && array_diff($previousValues, $values)) {\n                header_remove($name);\n                $previousValues = null;\n            }\n\n            $newValues = null === $previousValues ? $values : array_diff($values, $previousValues);\n\n            foreach ($newValues as $value) {\n                header($name.': '.$value, $replace, $this->statusCode);\n            }\n\n            if ($informationalResponse) {\n                $this->sentHeaders[$name] = $values;\n            }\n        }\n\n        // cookies\n        foreach ($this->headers->getCookies() as $cookie) {\n            header('Set-Cookie: '.$cookie, false, $this->statusCode);\n        }\n\n        if ($informationalResponse) {\n            headers_send($statusCode);\n\n            return $this;\n        }\n\n        $statusCode ??= $this->statusCode;\n\n        // status\n        header(\\sprintf('HTTP/%s %s %s', $this->version, $statusCode, $this->statusText), true, $statusCode);\n\n        return $this;\n    }\n\n    /**\n     * Sends content for the current web response.\n     *\n     * @return $this\n     */\n    public function sendContent(): static\n    {\n        echo $this->content;\n\n        return $this;\n    }\n\n    /**\n     * Sends HTTP headers and content.\n     *\n     * @param bool $flush Whether output buffers should be flushed\n     *\n     * @return $this\n     */\n    public function send(bool $flush = true): static\n    {\n        $this->sendHeaders();\n        $this->sendContent();\n\n        if (!$flush) {\n            return $this;\n        }\n\n        if (\\function_exists('fastcgi_finish_request')) {\n            fastcgi_finish_request();\n        } elseif (\\function_exists('litespeed_finish_request')) {\n            litespeed_finish_request();\n        } elseif (!\\in_array(\\PHP_SAPI, ['cli', 'phpdbg', 'embed'], true)) {\n            static::closeOutputBuffers(0, true);\n            flush();\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets the response content.\n     *\n     * @return $this\n     */\n    public function setContent(?string $content): static\n    {\n        $this->content = $content ?? '';\n\n        return $this;\n    }\n\n    /**\n     * Gets the current response content.\n     */\n    public function getContent(): string|false\n    {\n        return $this->content;\n    }\n\n    /**\n     * Sets the HTTP protocol version (1.0 or 1.1).\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setProtocolVersion(string $version): static\n    {\n        $this->version = $version;\n\n        return $this;\n    }\n\n    /**\n     * Gets the HTTP protocol version.\n     *\n     * @final\n     */\n    public function getProtocolVersion(): string\n    {\n        return $this->version;\n    }\n\n    /**\n     * Sets the response status code.\n     *\n     * If the status text is null it will be automatically populated for the known\n     * status codes and left empty otherwise.\n     *\n     * @return $this\n     *\n     * @throws \\InvalidArgumentException When the HTTP status code is not valid\n     *\n     * @final\n     */\n    public function setStatusCode(int $code, ?string $text = null): static\n    {\n        $this->statusCode = $code;\n        if ($this->isInvalid()) {\n            throw new \\InvalidArgumentException(\\sprintf('The HTTP status code \"%s\" is not valid.', $code));\n        }\n\n        if (null === $text) {\n            $this->statusText = self::$statusTexts[$code] ?? 'unknown status';\n\n            return $this;\n        }\n\n        $this->statusText = $text;\n\n        return $this;\n    }\n\n    /**\n     * Retrieves the status code for the current web response.\n     *\n     * @final\n     */\n    public function getStatusCode(): int\n    {\n        return $this->statusCode;\n    }\n\n    /**\n     * Sets the response charset.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setCharset(string $charset): static\n    {\n        $this->charset = $charset;\n\n        return $this;\n    }\n\n    /**\n     * Retrieves the response charset.\n     *\n     * @final\n     */\n    public function getCharset(): ?string\n    {\n        return $this->charset;\n    }\n\n    /**\n     * Returns true if the response may safely be kept in a shared (surrogate) cache.\n     *\n     * Responses marked \"private\" with an explicit Cache-Control directive are\n     * considered uncacheable.\n     *\n     * Responses with neither a freshness lifetime (Expires, max-age) nor cache\n     * validator (Last-Modified, ETag) are considered uncacheable because there is\n     * no way to tell when or how to remove them from the cache.\n     *\n     * Note that RFC 7231 and RFC 7234 possibly allow for a more permissive implementation,\n     * for example \"status codes that are defined as cacheable by default [...]\n     * can be reused by a cache with heuristic expiration unless otherwise indicated\"\n     * (https://tools.ietf.org/html/rfc7231#section-6.1)\n     *\n     * @final\n     */\n    public function isCacheable(): bool\n    {\n        if (!\\in_array($this->statusCode, [200, 203, 300, 301, 302, 404, 410])) {\n            return false;\n        }\n\n        if ($this->headers->hasCacheControlDirective('no-store') || $this->headers->getCacheControlDirective('private')) {\n            return false;\n        }\n\n        return $this->isValidateable() || $this->isFresh();\n    }\n\n    /**\n     * Returns true if the response is \"fresh\".\n     *\n     * Fresh responses may be served from cache without any interaction with the\n     * origin. A response is considered fresh when it includes a Cache-Control/max-age\n     * indicator or Expires header and the calculated age is less than the freshness lifetime.\n     *\n     * @final\n     */\n    public function isFresh(): bool\n    {\n        return $this->getTtl() > 0;\n    }\n\n    /**\n     * Returns true if the response includes headers that can be used to validate\n     * the response with the origin server using a conditional GET request.\n     *\n     * @final\n     */\n    public function isValidateable(): bool\n    {\n        return $this->headers->has('Last-Modified') || $this->headers->has('ETag');\n    }\n\n    /**\n     * Marks the response as \"private\".\n     *\n     * It makes the response ineligible for serving other clients.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setPrivate(): static\n    {\n        $this->headers->removeCacheControlDirective('public');\n        $this->headers->addCacheControlDirective('private');\n\n        return $this;\n    }\n\n    /**\n     * Marks the response as \"public\".\n     *\n     * It makes the response eligible for serving other clients.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setPublic(): static\n    {\n        $this->headers->addCacheControlDirective('public');\n        $this->headers->removeCacheControlDirective('private');\n\n        return $this;\n    }\n\n    /**\n     * Marks the response as \"immutable\".\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setImmutable(bool $immutable = true): static\n    {\n        if ($immutable) {\n            $this->headers->addCacheControlDirective('immutable');\n        } else {\n            $this->headers->removeCacheControlDirective('immutable');\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns true if the response is marked as \"immutable\".\n     *\n     * @final\n     */\n    public function isImmutable(): bool\n    {\n        return $this->headers->hasCacheControlDirective('immutable');\n    }\n\n    /**\n     * Returns true if the response must be revalidated by shared caches once it has become stale.\n     *\n     * This method indicates that the response must not be served stale by a\n     * cache in any circumstance without first revalidating with the origin.\n     * When present, the TTL of the response should not be overridden to be\n     * greater than the value provided by the origin.\n     *\n     * @final\n     */\n    public function mustRevalidate(): bool\n    {\n        return $this->headers->hasCacheControlDirective('must-revalidate') || $this->headers->hasCacheControlDirective('proxy-revalidate');\n    }\n\n    /**\n     * Returns the Date header as a DateTime instance.\n     *\n     * @throws \\RuntimeException When the header is not parseable\n     *\n     * @final\n     */\n    public function getDate(): ?\\DateTimeImmutable\n    {\n        return $this->headers->getDate('Date');\n    }\n\n    /**\n     * Sets the Date header.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setDate(\\DateTimeInterface $date): static\n    {\n        $date = \\DateTimeImmutable::createFromInterface($date);\n        $date = $date->setTimezone(new \\DateTimeZone('UTC'));\n        $this->headers->set('Date', $date->format('D, d M Y H:i:s').' GMT');\n\n        return $this;\n    }\n\n    /**\n     * Returns the age of the response in seconds.\n     *\n     * @final\n     */\n    public function getAge(): int\n    {\n        if (null !== $age = $this->headers->get('Age')) {\n            return (int) $age;\n        }\n\n        return max(time() - (int) $this->getDate()->format('U'), 0);\n    }\n\n    /**\n     * Marks the response stale by setting the Age header to be equal to the maximum age of the response.\n     *\n     * @return $this\n     */\n    public function expire(): static\n    {\n        if ($this->isFresh()) {\n            $this->headers->set('Age', $this->getMaxAge());\n            $this->headers->remove('Expires');\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns the value of the Expires header as a DateTime instance.\n     *\n     * @final\n     */\n    public function getExpires(): ?\\DateTimeImmutable\n    {\n        try {\n            return $this->headers->getDate('Expires');\n        } catch (\\RuntimeException) {\n            // according to RFC 2616 invalid date formats (e.g. \"0\" and \"-1\") must be treated as in the past\n            return \\DateTimeImmutable::createFromFormat('U', time() - 172800);\n        }\n    }\n\n    /**\n     * Sets the Expires HTTP header with a DateTime instance.\n     *\n     * Passing null as value will remove the header.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setExpires(?\\DateTimeInterface $date): static\n    {\n        if (null === $date) {\n            $this->headers->remove('Expires');\n\n            return $this;\n        }\n\n        $date = \\DateTimeImmutable::createFromInterface($date);\n        $date = $date->setTimezone(new \\DateTimeZone('UTC'));\n        $this->headers->set('Expires', $date->format('D, d M Y H:i:s').' GMT');\n\n        return $this;\n    }\n\n    /**\n     * Returns the number of seconds after the time specified in the response's Date\n     * header when the response should no longer be considered fresh.\n     *\n     * First, it checks for a s-maxage directive, then a max-age directive, and then it falls\n     * back on an expires header. It returns null when no maximum age can be established.\n     *\n     * @final\n     */\n    public function getMaxAge(): ?int\n    {\n        if ($this->headers->hasCacheControlDirective('s-maxage')) {\n            return (int) $this->headers->getCacheControlDirective('s-maxage');\n        }\n\n        if ($this->headers->hasCacheControlDirective('max-age')) {\n            return (int) $this->headers->getCacheControlDirective('max-age');\n        }\n\n        if (null !== $expires = $this->getExpires()) {\n            $maxAge = (int) $expires->format('U') - (int) $this->getDate()->format('U');\n\n            return max($maxAge, 0);\n        }\n\n        return null;\n    }\n\n    /**\n     * Sets the number of seconds after which the response should no longer be considered fresh.\n     *\n     * This method sets the Cache-Control max-age directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setMaxAge(int $value): static\n    {\n        $this->headers->addCacheControlDirective('max-age', $value);\n\n        return $this;\n    }\n\n    /**\n     * Sets the number of seconds after which the response should no longer be returned by shared caches when backend is down.\n     *\n     * This method sets the Cache-Control stale-if-error directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setStaleIfError(int $value): static\n    {\n        $this->headers->addCacheControlDirective('stale-if-error', $value);\n\n        return $this;\n    }\n\n    /**\n     * Sets the number of seconds after which the response should no longer return stale content by shared caches.\n     *\n     * This method sets the Cache-Control stale-while-revalidate directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setStaleWhileRevalidate(int $value): static\n    {\n        $this->headers->addCacheControlDirective('stale-while-revalidate', $value);\n\n        return $this;\n    }\n\n    /**\n     * Sets the number of seconds after which the response should no longer be considered fresh by shared caches.\n     *\n     * This method sets the Cache-Control s-maxage directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setSharedMaxAge(int $value): static\n    {\n        $this->setPublic();\n        $this->headers->addCacheControlDirective('s-maxage', $value);\n\n        return $this;\n    }\n\n    /**\n     * Returns the response's time-to-live in seconds.\n     *\n     * It returns null when no freshness information is present in the response.\n     *\n     * When the response's TTL is 0, the response may not be served from cache without first\n     * revalidating with the origin.\n     *\n     * @final\n     */\n    public function getTtl(): ?int\n    {\n        $maxAge = $this->getMaxAge();\n\n        return null !== $maxAge ? max($maxAge - $this->getAge(), 0) : null;\n    }\n\n    /**\n     * Sets the response's time-to-live for shared caches in seconds.\n     *\n     * This method adjusts the Cache-Control/s-maxage directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setTtl(int $seconds): static\n    {\n        $this->setSharedMaxAge($this->getAge() + $seconds);\n\n        return $this;\n    }\n\n    /**\n     * Sets the response's time-to-live for private/client caches in seconds.\n     *\n     * This method adjusts the Cache-Control/max-age directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setClientTtl(int $seconds): static\n    {\n        $this->setMaxAge($this->getAge() + $seconds);\n\n        return $this;\n    }\n\n    /**\n     * Returns the Last-Modified HTTP header as a DateTime instance.\n     *\n     * @throws \\RuntimeException When the HTTP header is not parseable\n     *\n     * @final\n     */\n    public function getLastModified(): ?\\DateTimeImmutable\n    {\n        return $this->headers->getDate('Last-Modified');\n    }\n\n    /**\n     * Sets the Last-Modified HTTP header with a DateTime instance.\n     *\n     * Passing null as value will remove the header.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setLastModified(?\\DateTimeInterface $date): static\n    {\n        if (null === $date) {\n            $this->headers->remove('Last-Modified');\n\n            return $this;\n        }\n\n        $date = \\DateTimeImmutable::createFromInterface($date);\n        $date = $date->setTimezone(new \\DateTimeZone('UTC'));\n        $this->headers->set('Last-Modified', $date->format('D, d M Y H:i:s').' GMT');\n\n        return $this;\n    }\n\n    /**\n     * Returns the literal value of the ETag HTTP header.\n     *\n     * @final\n     */\n    public function getEtag(): ?string\n    {\n        return $this->headers->get('ETag');\n    }\n\n    /**\n     * Sets the ETag value.\n     *\n     * @param string|null $etag The ETag unique identifier or null to remove the header\n     * @param bool        $weak Whether you want a weak ETag or not\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setEtag(?string $etag, bool $weak = false): static\n    {\n        if (null === $etag) {\n            $this->headers->remove('Etag');\n        } else {\n            if (!str_starts_with($etag, '\"')) {\n                $etag = '\"'.$etag.'\"';\n            }\n\n            $this->headers->set('ETag', (true === $weak ? 'W/' : '').$etag);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets the response's cache headers (validation and/or expiration).\n     *\n     * Available options are: must_revalidate, no_cache, no_store, no_transform, public, private, proxy_revalidate, max_age, s_maxage, immutable, last_modified and etag.\n     *\n     * @return $this\n     *\n     * @throws \\InvalidArgumentException\n     *\n     * @final\n     */\n    public function setCache(array $options): static\n    {\n        if ($diff = array_diff(array_keys($options), array_keys(self::HTTP_RESPONSE_CACHE_CONTROL_DIRECTIVES))) {\n            throw new \\InvalidArgumentException(\\sprintf('Response does not support the following options: \"%s\".', implode('\", \"', $diff)));\n        }\n\n        if (isset($options['etag'])) {\n            $this->setEtag($options['etag']);\n        }\n\n        if (isset($options['last_modified'])) {\n            $this->setLastModified($options['last_modified']);\n        }\n\n        if (isset($options['max_age'])) {\n            $this->setMaxAge($options['max_age']);\n        }\n\n        if (isset($options['s_maxage'])) {\n            $this->setSharedMaxAge($options['s_maxage']);\n        }\n\n        if (isset($options['stale_while_revalidate'])) {\n            $this->setStaleWhileRevalidate($options['stale_while_revalidate']);\n        }\n\n        if (isset($options['stale_if_error'])) {\n            $this->setStaleIfError($options['stale_if_error']);\n        }\n\n        foreach (self::HTTP_RESPONSE_CACHE_CONTROL_DIRECTIVES as $directive => $hasValue) {\n            if (!$hasValue && isset($options[$directive])) {\n                if ($options[$directive]) {\n                    $this->headers->addCacheControlDirective(str_replace('_', '-', $directive));\n                } else {\n                    $this->headers->removeCacheControlDirective(str_replace('_', '-', $directive));\n                }\n            }\n        }\n\n        if (isset($options['public'])) {\n            if ($options['public']) {\n                $this->setPublic();\n            } else {\n                $this->setPrivate();\n            }\n        }\n\n        if (isset($options['private'])) {\n            if ($options['private']) {\n                $this->setPrivate();\n            } else {\n                $this->setPublic();\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * Modifies the response so that it conforms to the rules defined for a 304 status code.\n     *\n     * This sets the status, removes the body, and discards any headers\n     * that MUST NOT be included in 304 responses.\n     *\n     * @return $this\n     *\n     * @see https://tools.ietf.org/html/rfc2616#section-10.3.5\n     *\n     * @final\n     */\n    public function setNotModified(): static\n    {\n        $this->setStatusCode(304);\n        $this->setContent(null);\n\n        // remove headers that MUST NOT be included with 304 Not Modified responses\n        foreach (['Allow', 'Content-Encoding', 'Content-Language', 'Content-Length', 'Content-MD5', 'Content-Type', 'Last-Modified'] as $header) {\n            $this->headers->remove($header);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns true if the response includes a Vary header.\n     *\n     * @final\n     */\n    public function hasVary(): bool\n    {\n        return null !== $this->headers->get('Vary');\n    }\n\n    /**\n     * Returns an array of header names given in the Vary header.\n     *\n     * @final\n     */\n    public function getVary(): array\n    {\n        if (!$vary = $this->headers->all('Vary')) {\n            return [];\n        }\n\n        $ret = [];\n        foreach ($vary as $item) {\n            $ret[] = preg_split('/[\\s,]+/', $item);\n        }\n\n        return array_merge([], ...$ret);\n    }\n\n    /**\n     * Sets the Vary header.\n     *\n     * @param bool $replace Whether to replace the actual value or not (true by default)\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setVary(string|array $headers, bool $replace = true): static\n    {\n        $this->headers->set('Vary', $headers, $replace);\n\n        return $this;\n    }\n\n    /**\n     * Determines if the Response validators (ETag, Last-Modified) match\n     * a conditional value specified in the Request.\n     *\n     * If the Response is not modified, it sets the status code to 304 and\n     * removes the actual content by calling the setNotModified() method.\n     *\n     * @final\n     */\n    public function isNotModified(Request $request): bool\n    {\n        if (!$request->isMethodCacheable()) {\n            return false;\n        }\n\n        $notModified = false;\n        $lastModified = $this->headers->get('Last-Modified');\n        $modifiedSince = $request->headers->get('If-Modified-Since');\n\n        if (($ifNoneMatchEtags = $request->getETags()) && (null !== $etag = $this->getEtag())) {\n            if (0 == strncmp($etag, 'W/', 2)) {\n                $etag = substr($etag, 2);\n            }\n\n            // Use weak comparison as per https://tools.ietf.org/html/rfc7232#section-3.2.\n            foreach ($ifNoneMatchEtags as $ifNoneMatchEtag) {\n                if (0 == strncmp($ifNoneMatchEtag, 'W/', 2)) {\n                    $ifNoneMatchEtag = substr($ifNoneMatchEtag, 2);\n                }\n\n                if ($ifNoneMatchEtag === $etag || '*' === $ifNoneMatchEtag) {\n                    $notModified = true;\n                    break;\n                }\n            }\n        }\n        // Only do If-Modified-Since date comparison when If-None-Match is not present as per https://tools.ietf.org/html/rfc7232#section-3.3.\n        elseif ($modifiedSince && $lastModified) {\n            $notModified = strtotime($modifiedSince) >= strtotime($lastModified);\n        }\n\n        if ($notModified) {\n            $this->setNotModified();\n        }\n\n        return $notModified;\n    }\n\n    /**\n     * Is response invalid?\n     *\n     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n     *\n     * @final\n     */\n    public function isInvalid(): bool\n    {\n        return $this->statusCode < 100 || $this->statusCode >= 600;\n    }\n\n    /**\n     * Is response informative?\n     *\n     * @final\n     */\n    public function isInformational(): bool\n    {\n        return $this->statusCode >= 100 && $this->statusCode < 200;\n    }\n\n    /**\n     * Is response successful?\n     *\n     * @final\n     */\n    public function isSuccessful(): bool\n    {\n        return $this->statusCode >= 200 && $this->statusCode < 300;\n    }\n\n    /**\n     * Is the response a redirect?\n     *\n     * @final\n     */\n    public function isRedirection(): bool\n    {\n        return $this->statusCode >= 300 && $this->statusCode < 400;\n    }\n\n    /**\n     * Is there a client error?\n     *\n     * @final\n     */\n    public function isClientError(): bool\n    {\n        return $this->statusCode >= 400 && $this->statusCode < 500;\n    }\n\n    /**\n     * Was there a server side error?\n     *\n     * @final\n     */\n    public function isServerError(): bool\n    {\n        return $this->statusCode >= 500 && $this->statusCode < 600;\n    }\n\n    /**\n     * Is the response OK?\n     *\n     * @final\n     */\n    public function isOk(): bool\n    {\n        return 200 === $this->statusCode;\n    }\n\n    /**\n     * Is the response forbidden?\n     *\n     * @final\n     */\n    public function isForbidden(): bool\n    {\n        return 403 === $this->statusCode;\n    }\n\n    /**\n     * Is the response a not found error?\n     *\n     * @final\n     */\n    public function isNotFound(): bool\n    {\n        return 404 === $this->statusCode;\n    }\n\n    /**\n     * Is the response a redirect of some form?\n     *\n     * @final\n     */\n    public function isRedirect(?string $location = null): bool\n    {\n        return \\in_array($this->statusCode, [201, 301, 302, 303, 307, 308]) && (null === $location ?: $location == $this->headers->get('Location'));\n    }\n\n    /**\n     * Is the response empty?\n     *\n     * @final\n     */\n    public function isEmpty(): bool\n    {\n        return \\in_array($this->statusCode, [204, 304]);\n    }\n\n    /**\n     * Cleans or flushes output buffers up to target level.\n     *\n     * Resulting level can be greater than target level if a non-removable buffer has been encountered.\n     *\n     * @final\n     */\n    public static function closeOutputBuffers(int $targetLevel, bool $flush): void\n    {\n        $status = ob_get_status(true);\n        $level = \\count($status);\n        $flags = \\PHP_OUTPUT_HANDLER_REMOVABLE | ($flush ? \\PHP_OUTPUT_HANDLER_FLUSHABLE : \\PHP_OUTPUT_HANDLER_CLEANABLE);\n\n        while ($level-- > $targetLevel && ($s = $status[$level]) && (!isset($s['del']) ? !isset($s['flags']) || ($s['flags'] & $flags) === $flags : $s['del'])) {\n            if ($flush) {\n                ob_end_flush();\n            } else {\n                ob_end_clean();\n            }\n        }\n    }\n\n    /**\n     * Marks a response as safe according to RFC8674.\n     *\n     * @see https://tools.ietf.org/html/rfc8674\n     */\n    public function setContentSafe(bool $safe = true): void\n    {\n        if ($safe) {\n            $this->headers->set('Preference-Applied', 'safe');\n        } elseif ('safe' === $this->headers->get('Preference-Applied')) {\n            $this->headers->remove('Preference-Applied');\n        }\n\n        $this->setVary('Prefer', false);\n    }\n\n    /**\n     * Checks if we need to remove Cache-Control for SSL encrypted downloads when using IE < 9.\n     *\n     * @see http://support.microsoft.com/kb/323308\n     *\n     * @final\n     */\n    protected function ensureIEOverSSLCompatibility(Request $request): void\n    {\n        if (false !== stripos($this->headers->get('Content-Disposition') ?? '', 'attachment') && 1 == preg_match('/MSIE (.*?);/i', $request->server->get('HTTP_USER_AGENT') ?? '', $match) && true === $request->isSecure()) {\n            if ((int) preg_replace('/(MSIE )(.*?);/', '$2', $match[0]) < 9) {\n                $this->headers->remove('Cache-Control');\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "ResponseHeaderBag.php",
          "type": "blob",
          "size": 7.7490234375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * ResponseHeaderBag is a container for Response HTTP headers.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass ResponseHeaderBag extends HeaderBag\n{\n    public const COOKIES_FLAT = 'flat';\n    public const COOKIES_ARRAY = 'array';\n\n    public const DISPOSITION_ATTACHMENT = 'attachment';\n    public const DISPOSITION_INLINE = 'inline';\n\n    protected array $computedCacheControl = [];\n    protected array $cookies = [];\n    protected array $headerNames = [];\n\n    public function __construct(array $headers = [])\n    {\n        parent::__construct($headers);\n\n        if (!isset($this->headers['cache-control'])) {\n            $this->set('Cache-Control', '');\n        }\n\n        /* RFC2616 - 14.18 says all Responses need to have a Date */\n        if (!isset($this->headers['date'])) {\n            $this->initDate();\n        }\n    }\n\n    /**\n     * Returns the headers, with original capitalizations.\n     */\n    public function allPreserveCase(): array\n    {\n        $headers = [];\n        foreach ($this->all() as $name => $value) {\n            $headers[$this->headerNames[$name] ?? $name] = $value;\n        }\n\n        return $headers;\n    }\n\n    public function allPreserveCaseWithoutCookies(): array\n    {\n        $headers = $this->allPreserveCase();\n        if (isset($this->headerNames['set-cookie'])) {\n            unset($headers[$this->headerNames['set-cookie']]);\n        }\n\n        return $headers;\n    }\n\n    public function replace(array $headers = []): void\n    {\n        $this->headerNames = [];\n\n        parent::replace($headers);\n\n        if (!isset($this->headers['cache-control'])) {\n            $this->set('Cache-Control', '');\n        }\n\n        if (!isset($this->headers['date'])) {\n            $this->initDate();\n        }\n    }\n\n    public function all(?string $key = null): array\n    {\n        $headers = parent::all();\n\n        if (null !== $key) {\n            $key = strtr($key, self::UPPER, self::LOWER);\n\n            return 'set-cookie' !== $key ? $headers[$key] ?? [] : array_map('strval', $this->getCookies());\n        }\n\n        foreach ($this->getCookies() as $cookie) {\n            $headers['set-cookie'][] = (string) $cookie;\n        }\n\n        return $headers;\n    }\n\n    public function set(string $key, string|array|null $values, bool $replace = true): void\n    {\n        $uniqueKey = strtr($key, self::UPPER, self::LOWER);\n\n        if ('set-cookie' === $uniqueKey) {\n            if ($replace) {\n                $this->cookies = [];\n            }\n            foreach ((array) $values as $cookie) {\n                $this->setCookie(Cookie::fromString($cookie));\n            }\n            $this->headerNames[$uniqueKey] = $key;\n\n            return;\n        }\n\n        $this->headerNames[$uniqueKey] = $key;\n\n        parent::set($key, $values, $replace);\n\n        // ensure the cache-control header has sensible defaults\n        if (\\in_array($uniqueKey, ['cache-control', 'etag', 'last-modified', 'expires'], true) && '' !== $computed = $this->computeCacheControlValue()) {\n            $this->headers['cache-control'] = [$computed];\n            $this->headerNames['cache-control'] = 'Cache-Control';\n            $this->computedCacheControl = $this->parseCacheControl($computed);\n        }\n    }\n\n    public function remove(string $key): void\n    {\n        $uniqueKey = strtr($key, self::UPPER, self::LOWER);\n        unset($this->headerNames[$uniqueKey]);\n\n        if ('set-cookie' === $uniqueKey) {\n            $this->cookies = [];\n\n            return;\n        }\n\n        parent::remove($key);\n\n        if ('cache-control' === $uniqueKey) {\n            $this->computedCacheControl = [];\n        }\n\n        if ('date' === $uniqueKey) {\n            $this->initDate();\n        }\n    }\n\n    public function hasCacheControlDirective(string $key): bool\n    {\n        return \\array_key_exists($key, $this->computedCacheControl);\n    }\n\n    public function getCacheControlDirective(string $key): bool|string|null\n    {\n        return $this->computedCacheControl[$key] ?? null;\n    }\n\n    public function setCookie(Cookie $cookie): void\n    {\n        $this->cookies[$cookie->getDomain()][$cookie->getPath()][$cookie->getName()] = $cookie;\n        $this->headerNames['set-cookie'] = 'Set-Cookie';\n    }\n\n    /**\n     * Removes a cookie from the array, but does not unset it in the browser.\n     */\n    public function removeCookie(string $name, ?string $path = '/', ?string $domain = null): void\n    {\n        $path ??= '/';\n\n        unset($this->cookies[$domain][$path][$name]);\n\n        if (empty($this->cookies[$domain][$path])) {\n            unset($this->cookies[$domain][$path]);\n\n            if (empty($this->cookies[$domain])) {\n                unset($this->cookies[$domain]);\n            }\n        }\n\n        if (!$this->cookies) {\n            unset($this->headerNames['set-cookie']);\n        }\n    }\n\n    /**\n     * Returns an array with all cookies.\n     *\n     * @return Cookie[]\n     *\n     * @throws \\InvalidArgumentException When the $format is invalid\n     */\n    public function getCookies(string $format = self::COOKIES_FLAT): array\n    {\n        if (!\\in_array($format, [self::COOKIES_FLAT, self::COOKIES_ARRAY])) {\n            throw new \\InvalidArgumentException(\\sprintf('Format \"%s\" invalid (%s).', $format, implode(', ', [self::COOKIES_FLAT, self::COOKIES_ARRAY])));\n        }\n\n        if (self::COOKIES_ARRAY === $format) {\n            return $this->cookies;\n        }\n\n        $flattenedCookies = [];\n        foreach ($this->cookies as $path) {\n            foreach ($path as $cookies) {\n                foreach ($cookies as $cookie) {\n                    $flattenedCookies[] = $cookie;\n                }\n            }\n        }\n\n        return $flattenedCookies;\n    }\n\n    /**\n     * Clears a cookie in the browser.\n     *\n     * @param bool $partitioned\n     */\n    public function clearCookie(string $name, ?string $path = '/', ?string $domain = null, bool $secure = false, bool $httpOnly = true, ?string $sameSite = null /* , bool $partitioned = false */): void\n    {\n        $partitioned = 6 < \\func_num_args() ? \\func_get_arg(6) : false;\n\n        $this->setCookie(new Cookie($name, null, 1, $path, $domain, $secure, $httpOnly, false, $sameSite, $partitioned));\n    }\n\n    /**\n     * @see HeaderUtils::makeDisposition()\n     */\n    public function makeDisposition(string $disposition, string $filename, string $filenameFallback = ''): string\n    {\n        return HeaderUtils::makeDisposition($disposition, $filename, $filenameFallback);\n    }\n\n    /**\n     * Returns the calculated value of the cache-control header.\n     *\n     * This considers several other headers and calculates or modifies the\n     * cache-control header to a sensible, conservative value.\n     */\n    protected function computeCacheControlValue(): string\n    {\n        if (!$this->cacheControl) {\n            if ($this->has('Last-Modified') || $this->has('Expires')) {\n                return 'private, must-revalidate'; // allows for heuristic expiration (RFC 7234 Section 4.2.2) in the case of \"Last-Modified\"\n            }\n\n            // conservative by default\n            return 'no-cache, private';\n        }\n\n        $header = $this->getCacheControlHeader();\n        if (isset($this->cacheControl['public']) || isset($this->cacheControl['private'])) {\n            return $header;\n        }\n\n        // public if s-maxage is defined, private otherwise\n        if (!isset($this->cacheControl['s-maxage'])) {\n            return $header.', private';\n        }\n\n        return $header;\n    }\n\n    private function initDate(): void\n    {\n        $this->set('Date', gmdate('D, d M Y H:i:s').' GMT');\n    }\n}\n"
        },
        {
          "name": "ServerBag.php",
          "type": "blob",
          "size": 3.916015625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * ServerBag is a container for HTTP headers from the $_SERVER variable.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Bulat Shakirzyanov <mallluhuct@gmail.com>\n * @author Robert Kiss <kepten@gmail.com>\n */\nclass ServerBag extends ParameterBag\n{\n    /**\n     * Gets the HTTP headers.\n     */\n    public function getHeaders(): array\n    {\n        $headers = [];\n        foreach ($this->parameters as $key => $value) {\n            if (str_starts_with($key, 'HTTP_')) {\n                $headers[substr($key, 5)] = $value;\n            } elseif (\\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true) && '' !== $value) {\n                $headers[$key] = $value;\n            }\n        }\n\n        if (isset($this->parameters['PHP_AUTH_USER'])) {\n            $headers['PHP_AUTH_USER'] = $this->parameters['PHP_AUTH_USER'];\n            $headers['PHP_AUTH_PW'] = $this->parameters['PHP_AUTH_PW'] ?? '';\n        } else {\n            /*\n             * php-cgi under Apache does not pass HTTP Basic user/pass to PHP by default\n             * For this workaround to work, add these lines to your .htaccess file:\n             * RewriteCond %{HTTP:Authorization} .+\n             * RewriteRule ^ - [E=HTTP_AUTHORIZATION:%0]\n             *\n             * A sample .htaccess file:\n             * RewriteEngine On\n             * RewriteCond %{HTTP:Authorization} .+\n             * RewriteRule ^ - [E=HTTP_AUTHORIZATION:%0]\n             * RewriteCond %{REQUEST_FILENAME} !-f\n             * RewriteRule ^(.*)$ index.php [QSA,L]\n             */\n\n            $authorizationHeader = null;\n            if (isset($this->parameters['HTTP_AUTHORIZATION'])) {\n                $authorizationHeader = $this->parameters['HTTP_AUTHORIZATION'];\n            } elseif (isset($this->parameters['REDIRECT_HTTP_AUTHORIZATION'])) {\n                $authorizationHeader = $this->parameters['REDIRECT_HTTP_AUTHORIZATION'];\n            }\n\n            if (null !== $authorizationHeader) {\n                if (0 === stripos($authorizationHeader, 'basic ')) {\n                    // Decode AUTHORIZATION header into PHP_AUTH_USER and PHP_AUTH_PW when authorization header is basic\n                    $exploded = explode(':', base64_decode(substr($authorizationHeader, 6)), 2);\n                    if (2 == \\count($exploded)) {\n                        [$headers['PHP_AUTH_USER'], $headers['PHP_AUTH_PW']] = $exploded;\n                    }\n                } elseif (empty($this->parameters['PHP_AUTH_DIGEST']) && (0 === stripos($authorizationHeader, 'digest '))) {\n                    // In some circumstances PHP_AUTH_DIGEST needs to be set\n                    $headers['PHP_AUTH_DIGEST'] = $authorizationHeader;\n                    $this->parameters['PHP_AUTH_DIGEST'] = $authorizationHeader;\n                } elseif (0 === stripos($authorizationHeader, 'bearer ')) {\n                    /*\n                     * XXX: Since there is no PHP_AUTH_BEARER in PHP predefined variables,\n                     *      I'll just set $headers['AUTHORIZATION'] here.\n                     *      https://php.net/reserved.variables.server\n                     */\n                    $headers['AUTHORIZATION'] = $authorizationHeader;\n                }\n            }\n        }\n\n        if (isset($headers['AUTHORIZATION'])) {\n            return $headers;\n        }\n\n        // PHP_AUTH_USER/PHP_AUTH_PW\n        if (isset($headers['PHP_AUTH_USER'])) {\n            $headers['AUTHORIZATION'] = 'Basic '.base64_encode($headers['PHP_AUTH_USER'].':'.($headers['PHP_AUTH_PW'] ?? ''));\n        } elseif (isset($headers['PHP_AUTH_DIGEST'])) {\n            $headers['AUTHORIZATION'] = $headers['PHP_AUTH_DIGEST'];\n        }\n\n        return $headers;\n    }\n}\n"
        },
        {
          "name": "Session",
          "type": "tree",
          "content": null
        },
        {
          "name": "StreamedJsonResponse.php",
          "type": "blob",
          "size": 5.6396484375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * StreamedJsonResponse represents a streamed HTTP response for JSON.\n *\n * A StreamedJsonResponse uses a structure and generics to create an\n * efficient resource-saving JSON response.\n *\n * It is recommended to use flush() function after a specific number of items to directly stream the data.\n *\n * @see flush()\n *\n * @author Alexander Schranz <alexander@sulu.io>\n *\n * Example usage:\n *\n *     function loadArticles(): \\Generator\n *         // some streamed loading\n *         yield ['title' => 'Article 1'];\n *         yield ['title' => 'Article 2'];\n *         yield ['title' => 'Article 3'];\n *         // recommended to use flush() after every specific number of items\n *     }),\n *\n *     $response = new StreamedJsonResponse(\n *         // json structure with generators in which will be streamed\n *         [\n *             '_embedded' => [\n *                 'articles' => loadArticles(), // any generator which you want to stream as list of data\n *             ],\n *         ],\n *     );\n */\nclass StreamedJsonResponse extends StreamedResponse\n{\n    private const PLACEHOLDER = '__symfony_json__';\n\n    /**\n     * @param mixed[]                        $data            JSON Data containing PHP generators which will be streamed as list of data or a Generator\n     * @param int                            $status          The HTTP status code (200 \"OK\" by default)\n     * @param array<string, string|string[]> $headers         An array of HTTP headers\n     * @param int                            $encodingOptions Flags for the json_encode() function\n     */\n    public function __construct(\n        private readonly iterable $data,\n        int $status = 200,\n        array $headers = [],\n        private int $encodingOptions = JsonResponse::DEFAULT_ENCODING_OPTIONS,\n    ) {\n        parent::__construct($this->stream(...), $status, $headers);\n\n        if (!$this->headers->get('Content-Type')) {\n            $this->headers->set('Content-Type', 'application/json');\n        }\n    }\n\n    private function stream(): void\n    {\n        $jsonEncodingOptions = \\JSON_THROW_ON_ERROR | $this->encodingOptions;\n        $keyEncodingOptions = $jsonEncodingOptions & ~\\JSON_NUMERIC_CHECK;\n\n        $this->streamData($this->data, $jsonEncodingOptions, $keyEncodingOptions);\n    }\n\n    private function streamData(mixed $data, int $jsonEncodingOptions, int $keyEncodingOptions): void\n    {\n        if (\\is_array($data)) {\n            $this->streamArray($data, $jsonEncodingOptions, $keyEncodingOptions);\n\n            return;\n        }\n\n        if (is_iterable($data) && !$data instanceof \\JsonSerializable) {\n            $this->streamIterable($data, $jsonEncodingOptions, $keyEncodingOptions);\n\n            return;\n        }\n\n        echo json_encode($data, $jsonEncodingOptions);\n    }\n\n    private function streamArray(array $data, int $jsonEncodingOptions, int $keyEncodingOptions): void\n    {\n        $generators = [];\n\n        array_walk_recursive($data, function (&$item, $key) use (&$generators) {\n            if (self::PLACEHOLDER === $key) {\n                // if the placeholder is already in the structure it should be replaced with a new one that explode\n                // works like expected for the structure\n                $generators[] = $key;\n            }\n\n            // generators should be used but for better DX all kind of Traversable and objects are supported\n            if (\\is_object($item)) {\n                $generators[] = $item;\n                $item = self::PLACEHOLDER;\n            } elseif (self::PLACEHOLDER === $item) {\n                // if the placeholder is already in the structure it should be replaced with a new one that explode\n                // works like expected for the structure\n                $generators[] = $item;\n            }\n        });\n\n        $jsonParts = explode('\"'.self::PLACEHOLDER.'\"', json_encode($data, $jsonEncodingOptions));\n\n        foreach ($generators as $index => $generator) {\n            // send first and between parts of the structure\n            echo $jsonParts[$index];\n\n            $this->streamData($generator, $jsonEncodingOptions, $keyEncodingOptions);\n        }\n\n        // send last part of the structure\n        echo $jsonParts[array_key_last($jsonParts)];\n    }\n\n    private function streamIterable(iterable $iterable, int $jsonEncodingOptions, int $keyEncodingOptions): void\n    {\n        $isFirstItem = true;\n        $startTag = '[';\n\n        foreach ($iterable as $key => $item) {\n            if ($isFirstItem) {\n                $isFirstItem = false;\n                // depending on the first elements key the generator is detected as a list or map\n                // we can not check for a whole list or map because that would hurt the performance\n                // of the streamed response which is the main goal of this response class\n                if (0 !== $key) {\n                    $startTag = '{';\n                }\n\n                echo $startTag;\n            } else {\n                // if not first element of the generic, a separator is required between the elements\n                echo ',';\n            }\n\n            if ('{' === $startTag) {\n                echo json_encode((string) $key, $keyEncodingOptions).':';\n            }\n\n            $this->streamData($item, $jsonEncodingOptions, $keyEncodingOptions);\n        }\n\n        if ($isFirstItem) { // indicates that the generator was empty\n            echo '[';\n        }\n\n        echo '[' === $startTag ? ']' : '}';\n    }\n}\n"
        },
        {
          "name": "StreamedResponse.php",
          "type": "blob",
          "size": 2.962890625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n/**\n * StreamedResponse represents a streamed HTTP response.\n *\n * A StreamedResponse uses a callback for its content.\n *\n * The callback should use the standard PHP functions like echo\n * to stream the response back to the client. The flush() function\n * can also be used if needed.\n *\n * @see flush()\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass StreamedResponse extends Response\n{\n    protected ?\\Closure $callback = null;\n    protected bool $streamed = false;\n\n    private bool $headersSent = false;\n\n    /**\n     * @param int $status The HTTP status code (200 \"OK\" by default)\n     */\n    public function __construct(?callable $callback = null, int $status = 200, array $headers = [])\n    {\n        parent::__construct(null, $status, $headers);\n\n        if (null !== $callback) {\n            $this->setCallback($callback);\n        }\n        $this->streamed = false;\n        $this->headersSent = false;\n    }\n\n    /**\n     * Sets the PHP callback associated with this Response.\n     *\n     * @return $this\n     */\n    public function setCallback(callable $callback): static\n    {\n        $this->callback = $callback(...);\n\n        return $this;\n    }\n\n    public function getCallback(): ?\\Closure\n    {\n        if (!isset($this->callback)) {\n            return null;\n        }\n\n        return ($this->callback)(...);\n    }\n\n    /**\n     * This method only sends the headers once.\n     *\n     * @param positive-int|null $statusCode The status code to use, override the statusCode property if set and not null\n     *\n     * @return $this\n     */\n    public function sendHeaders(?int $statusCode = null): static\n    {\n        if ($this->headersSent) {\n            return $this;\n        }\n\n        if ($statusCode < 100 || $statusCode >= 200) {\n            $this->headersSent = true;\n        }\n\n        return parent::sendHeaders($statusCode);\n    }\n\n    /**\n     * This method only sends the content once.\n     *\n     * @return $this\n     */\n    public function sendContent(): static\n    {\n        if ($this->streamed) {\n            return $this;\n        }\n\n        $this->streamed = true;\n\n        if (!isset($this->callback)) {\n            throw new \\LogicException('The Response callback must be set.');\n        }\n\n        ($this->callback)();\n\n        return $this;\n    }\n\n    /**\n     * @return $this\n     *\n     * @throws \\LogicException when the content is not null\n     */\n    public function setContent(?string $content): static\n    {\n        if (null !== $content) {\n            throw new \\LogicException('The content cannot be set on a StreamedResponse instance.');\n        }\n\n        $this->streamed = true;\n\n        return $this;\n    }\n\n    public function getContent(): string|false\n    {\n        return false;\n    }\n}\n"
        },
        {
          "name": "Test",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "UriSigner.php",
          "type": "blob",
          "size": 5.6982421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\LogicException;\n\n/**\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass UriSigner\n{\n    /**\n     * @param string $hashParameter       Query string parameter to use\n     * @param string $expirationParameter Query string parameter to use for expiration\n     */\n    public function __construct(\n        #[\\SensitiveParameter] private string $secret,\n        private string $hashParameter = '_hash',\n        private string $expirationParameter = '_expiration',\n    ) {\n        if (!$secret) {\n            throw new \\InvalidArgumentException('A non-empty secret is required.');\n        }\n    }\n\n    /**\n     * Signs a URI.\n     *\n     * The given URI is signed by adding the query string parameter\n     * which value depends on the URI and the secret.\n     *\n     * @param \\DateTimeInterface|\\DateInterval|int|null $expiration The expiration for the given URI.\n     *                                                              If $expiration is a \\DateTimeInterface, it's expected to be the exact date + time.\n     *                                                              If $expiration is a \\DateInterval, the interval is added to \"now\" to get the date + time.\n     *                                                              If $expiration is an int, it's expected to be a timestamp in seconds of the exact date + time.\n     *                                                              If $expiration is null, no expiration.\n     *\n     * The expiration is added as a query string parameter.\n     */\n    public function sign(string $uri/*, \\DateTimeInterface|\\DateInterval|int|null $expiration = null*/): string\n    {\n        $expiration = null;\n\n        if (1 < \\func_num_args()) {\n            $expiration = func_get_arg(1);\n        }\n\n        if (null !== $expiration && !$expiration instanceof \\DateTimeInterface && !$expiration instanceof \\DateInterval && !\\is_int($expiration)) {\n            throw new \\TypeError(\\sprintf('The second argument of %s() must be an instance of %s or %s, an integer or null (%s given).', __METHOD__, \\DateTimeInterface::class, \\DateInterval::class, get_debug_type($expiration)));\n        }\n\n        $url = parse_url($uri);\n        $params = [];\n\n        if (isset($url['query'])) {\n            parse_str($url['query'], $params);\n        }\n\n        if (isset($params[$this->hashParameter])) {\n            throw new LogicException(\\sprintf('URI query parameter conflict: parameter name \"%s\" is reserved.', $this->hashParameter));\n        }\n\n        if (isset($params[$this->expirationParameter])) {\n            throw new LogicException(\\sprintf('URI query parameter conflict: parameter name \"%s\" is reserved.', $this->expirationParameter));\n        }\n\n        if (null !== $expiration) {\n            $params[$this->expirationParameter] = $this->getExpirationTime($expiration);\n        }\n\n        $uri = $this->buildUrl($url, $params);\n        $params[$this->hashParameter] = $this->computeHash($uri);\n\n        return $this->buildUrl($url, $params);\n    }\n\n    /**\n     * Checks that a URI contains the correct hash.\n     * Also checks if the URI has not expired (If you used expiration during signing).\n     */\n    public function check(string $uri): bool\n    {\n        $url = parse_url($uri);\n        $params = [];\n\n        if (isset($url['query'])) {\n            parse_str($url['query'], $params);\n        }\n\n        if (empty($params[$this->hashParameter])) {\n            return false;\n        }\n\n        $hash = $params[$this->hashParameter];\n        unset($params[$this->hashParameter]);\n\n        if (!hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash)) {\n            return false;\n        }\n\n        if ($expiration = $params[$this->expirationParameter] ?? false) {\n            return time() < $expiration;\n        }\n\n        return true;\n    }\n\n    public function checkRequest(Request $request): bool\n    {\n        $qs = ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : '';\n\n        // we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)\n        return $this->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().$qs);\n    }\n\n    private function computeHash(string $uri): string\n    {\n        return base64_encode(hash_hmac('sha256', $uri, $this->secret, true));\n    }\n\n    private function buildUrl(array $url, array $params = []): string\n    {\n        ksort($params, \\SORT_STRING);\n        $url['query'] = http_build_query($params, '', '&');\n\n        $scheme = isset($url['scheme']) ? $url['scheme'].'://' : '';\n        $host = $url['host'] ?? '';\n        $port = isset($url['port']) ? ':'.$url['port'] : '';\n        $user = $url['user'] ?? '';\n        $pass = isset($url['pass']) ? ':'.$url['pass'] : '';\n        $pass = ($user || $pass) ? \"$pass@\" : '';\n        $path = $url['path'] ?? '';\n        $query = $url['query'] ? '?'.$url['query'] : '';\n        $fragment = isset($url['fragment']) ? '#'.$url['fragment'] : '';\n\n        return $scheme.$user.$pass.$host.$port.$path.$query.$fragment;\n    }\n\n    private function getExpirationTime(\\DateTimeInterface|\\DateInterval|int $expiration): string\n    {\n        if ($expiration instanceof \\DateTimeInterface) {\n            return $expiration->format('U');\n        }\n\n        if ($expiration instanceof \\DateInterval) {\n            return \\DateTimeImmutable::createFromFormat('U', time())->add($expiration)->format('U');\n        }\n\n        return (string) $expiration;\n    }\n}\n"
        },
        {
          "name": "UrlHelper.php",
          "type": "blob",
          "size": 3.05078125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\Routing\\RequestContext;\nuse Symfony\\Component\\Routing\\RequestContextAwareInterface;\n\n/**\n * A helper service for manipulating URLs within and outside the request scope.\n *\n * @author Valentin Udaltsov <udaltsov.valentin@gmail.com>\n */\nfinal class UrlHelper\n{\n    public function __construct(\n        private RequestStack $requestStack,\n        private RequestContextAwareInterface|RequestContext|null $requestContext = null,\n    ) {\n    }\n\n    public function getAbsoluteUrl(string $path): string\n    {\n        if (str_contains($path, '://') || str_starts_with($path, '//')) {\n            return $path;\n        }\n\n        if (null === $request = $this->requestStack->getMainRequest()) {\n            return $this->getAbsoluteUrlFromContext($path);\n        }\n\n        if ('#' === $path[0]) {\n            $path = $request->getRequestUri().$path;\n        } elseif ('?' === $path[0]) {\n            $path = $request->getPathInfo().$path;\n        }\n\n        if (!$path || '/' !== $path[0]) {\n            $prefix = $request->getPathInfo();\n            $last = \\strlen($prefix) - 1;\n            if ($last !== $pos = strrpos($prefix, '/')) {\n                $prefix = substr($prefix, 0, $pos).'/';\n            }\n\n            return $request->getUriForPath($prefix.$path);\n        }\n\n        return $request->getSchemeAndHttpHost().$path;\n    }\n\n    public function getRelativePath(string $path): string\n    {\n        if (str_contains($path, '://') || str_starts_with($path, '//')) {\n            return $path;\n        }\n\n        if (null === $request = $this->requestStack->getMainRequest()) {\n            return $path;\n        }\n\n        return $request->getRelativeUriForPath($path);\n    }\n\n    private function getAbsoluteUrlFromContext(string $path): string\n    {\n        if (null === $context = $this->requestContext) {\n            return $path;\n        }\n\n        if ($context instanceof RequestContextAwareInterface) {\n            $context = $context->getContext();\n        }\n\n        if ('' === $host = $context->getHost()) {\n            return $path;\n        }\n\n        $scheme = $context->getScheme();\n        $port = '';\n\n        if ('http' === $scheme && 80 !== $context->getHttpPort()) {\n            $port = ':'.$context->getHttpPort();\n        } elseif ('https' === $scheme && 443 !== $context->getHttpsPort()) {\n            $port = ':'.$context->getHttpsPort();\n        }\n\n        if ('#' === $path[0]) {\n            $queryString = $context->getQueryString();\n            $path = $context->getPathInfo().($queryString ? '?'.$queryString : '').$path;\n        } elseif ('?' === $path[0]) {\n            $path = $context->getPathInfo().$path;\n        }\n\n        if ('/' !== $path[0]) {\n            $path = rtrim($context->getBaseUrl(), '/').'/'.$path;\n        }\n\n        return $scheme.'://'.$host.$port.$path;\n    }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.302734375,
          "content": "{\n    \"name\": \"symfony/http-foundation\",\n    \"type\": \"library\",\n    \"description\": \"Defines an object-oriented layer for the HTTP specification\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/deprecation-contracts\": \"^2.5|^3.0\",\n        \"symfony/polyfill-mbstring\": \"~1.1\",\n        \"symfony/polyfill-php83\": \"^1.27\"\n    },\n    \"require-dev\": {\n        \"doctrine/dbal\": \"^3.6|^4\",\n        \"predis/predis\": \"^1.1|^2.0\",\n        \"symfony/cache\": \"^6.4.12|^7.1.5\",\n        \"symfony/dependency-injection\": \"^6.4|^7.0\",\n        \"symfony/http-kernel\": \"^6.4|^7.0\",\n        \"symfony/mime\": \"^6.4|^7.0\",\n        \"symfony/expression-language\": \"^6.4|^7.0\",\n        \"symfony/rate-limiter\": \"^6.4|^7.0\"\n    },\n    \"conflict\": {\n        \"doctrine/dbal\": \"<3.6\",\n        \"symfony/cache\": \"<6.4.12|>=7.0,<7.1.5\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\HttpFoundation\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.904296875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n        <env name=\"MONGODB_HOST\" value=\"localhost\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony HttpFoundation Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Resources</directory>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}