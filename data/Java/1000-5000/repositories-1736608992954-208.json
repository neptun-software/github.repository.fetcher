{
  "metadata": {
    "timestamp": 1736608992954,
    "page": 208,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "BoltsFramework/Bolts-Android",
      "stars": 4014,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1171875,
          "content": ".DS_Store\n*.swp\n\n# Gradle\nbuild\n.gradle/\n\n# Intellij project files\n*.iml\n*.ipr\n*.iws\n.idea/\n\n# Android\nlocal.properties\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.7783203125,
          "content": "branches:\n  only:\n    - master\n\nlanguage: android\nsudo: false\n\nandroid:\n  components:\n    - build-tools-28.0.3\n    - android-22\n    - android-28\n    - extra-android-support\n    - extra-google-m2repository\n    - extra-android-m2repository\n    - sys-img-armeabi-v7a-android-22\n\nbefore_script:\n  - android list target\n  - echo no | android create avd --force -n test -t android-22 --abi armeabi-v7a\n  - emulator -avd test -no-audio -no-window &\n  - android-wait-for-emulator\n  - adb shell input keyevent 82 &\n  - adb logcat -v time > logcat.txt &\n\nscript:\n  - ./gradlew build testDebug connectedCheck --continue --info\n\nafter_script:\n  - travis_fold:start:logcat\n  - cat logcat.txt\n  - travis_fold:end:logcat\n\nafter_success:\n  - ./gradlew jacocoTestReport coveralls\n  - ./scripts/publish_snapshot.sh\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.23828125,
          "content": "# Code of Conduct\n\nFacebook has adopted a Code of Conduct that we expect project participants to adhere to.\nPlease read the [full text](https://code.fb.com/codeofconduct/)\nso that you can understand what actions will and will not be tolerated.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.3388671875,
          "content": "# Contributing to MyProject\nWe want to make contributing to this project as easy and transparent as possible.\n\n## Pull Requests\nWe actively welcome your pull requests.\n\n1. Fork the repo and create your branch from `master`.\n2. If you've added code that should be tested, add tests\n3. If you've changed APIs, update the documentation.\n4. Ensure the test suite passes.\n5. Make sure your code lints.\n6. If you haven't already, complete the Contributor License Agreement (\"CLA\").\n\n## Contributor License Agreement (\"CLA\")\nIn order to accept your pull request, we need you to submit a CLA. You only need to do this once to work on any of Facebook's open source projects.\n\nComplete your CLA here: <https://developers.facebook.com/opensource/cla>\n\n## Issues  \nWe use GitHub issues to track public bugs. Please ensure your description is clear and has sufficient instructions to be able to reproduce the issue.\n\nFacebook has a [bounty program](https://www.facebook.com/whitehat/) for the safe disclosure of security bugs. In those cases, please go through the process outlined on that page and do not file a public issue.\n\n## Coding Style  \n* Most importantly, match the existing code style as much as possible.\n* Try to keep lines under 100 characters, if possible.\n\n## License\nBy contributing to Bolts, you agree that your contributions will be licensed under its MIT license.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.060546875,
          "content": "MIT License\n\nCopyright (c) Facebook, Inc. and its affiliates.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 27.37890625,
          "content": "Bolts\n============\n[![Build Status][build-status-svg]][build-status-link]\n[![Coverage Status][coverage-status-svg]][coverage-status-link]\n[![Maven Central][maven-tasks-svg]][maven-tasks-link]\n[![Maven Central][maven-applinks-svg]][maven-applinks-link]\n[![License][license-svg]][license-link]\n\nBolts is a collection of low-level libraries designed to make developing mobile\napps easier. Bolts was designed by Parse and Facebook for our own internal use,\nand we have decided to open source these libraries to make them available to\nothers. Using these libraries does not require using any Parse services. Nor\ndo they require having a Parse or Facebook developer account.\n\nBolts includes:\n\n* \"Tasks\", which make organization of complex asynchronous code more manageable. A task is kind of like a JavaScript Promise, but available for iOS and Android.\n* An implementation of the [App Links protocol](http://www.applinks.org), helping you link to content in other apps and handle incoming deep-links.\n\nFor more information, see the [Bolts Android API Reference](http://boltsframework.github.io/Bolts-Android/).\n\n## Download\nDownload [the latest JAR][latest] or define in Gradle:\n\n```groovy\ndependencies {\n  compile 'com.parse.bolts:bolts-tasks:1.4.0'\n  compile 'com.parse.bolts:bolts-applinks:1.4.0'\n}\n```\n\nSnapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n\n# Tasks\n\nTo build a truly responsive Android application, you must keep long-running operations off of the UI thread, and be careful to avoid blocking anything the UI thread might be waiting on. This means you will need to execute various operations in the background. To make this easier, we've added a class called `Task`. A `Task` represents an asynchronous operation. Typically, a `Task` is returned from an asynchronous function and gives the ability to continue processing the result of the task. When a `Task` is returned from a function, it's already begun doing its job. A `Task` is not tied to a particular threading model: it represents the work being done, not where it is executing. `Task`s have many advantages over other methods of asynchronous programming, such as callbacks and `AsyncTask`.\n* They consume fewer system resources, since they don't occupy a thread while waiting on other `Task`s.\n* Performing several `Task`s in a row will not create nested \"pyramid\" code as you would get when using only callbacks.\n* `Task`s are fully composable, allowing you to perform branching, parallelism, and complex error handling, without the spaghetti code of having many named callbacks.\n* You can arrange task-based code in the order that it executes, rather than having to split your logic across scattered callback functions.\n\nFor the examples in this doc, assume there are async versions of some common Parse methods, called `saveAsync` and `findAsync` which return a `Task`. In a later section, we'll show how to define these functions yourself.\n\n## The `continueWith` Method\n\nEvery `Task` has a method named `continueWith` which takes a `Continuation`. A continuation is an interface that you implement which has one method, named `then`. The `then` method is called when the `Task` is complete. You can then inspect the `Task` to check if it was successful and to get its result.\n\n```java\nsaveAsync(obj).continueWith(new Continuation<ParseObject, Void>() {\n  public Void then(Task<ParseObject> task) throws Exception {\n    if (task.isCancelled()) {\n      // the save was cancelled.\n    } else if (task.isFaulted()) {\n      // the save failed.\n      Exception error = task.getError();\n    } else {\n      // the object was saved successfully.\n      ParseObject object = task.getResult();\n    }\n    return null;\n  }\n});\n```\n\n`Task`s are strongly-typed using Java Generics, so getting the syntax right can be a little tricky at first. Let's look closer at the types involved with an example.\n\n```java\n/**\n Gets a String asynchronously.\n */\npublic Task<String> getStringAsync() {\n  // Let's suppose getIntAsync() returns a Task<Integer>.\n  return getIntAsync().continueWith(\n    // This Continuation is a function which takes an Integer as input,\n    // and provides a String as output. It must take an Integer because\n    // that's what was returned from the previous Task.\n    new Continuation<Integer, String>() {\n      // The Task getIntAsync() returned is passed to \"then\" for convenience.\n      public String then(Task<Integer> task) throws Exception {\n        Integer number = task.getResult();\n        return String.format(\"%d\", Locale.US, number);\n      }\n    }\n  );\n}\n```\n\nIn many cases, you only want to do more work if the previous `Task` was successful, and propagate any errors or cancellations to be dealt with later. To do this, use the `onSuccess` method instead of `continueWith`.\n\n```java\nsaveAsync(obj).onSuccess(new Continuation<ParseObject, Void>() {\n  public Void then(Task<ParseObject> task) throws Exception {\n    // the object was saved successfully.\n    return null;\n  }\n});\n```\n\n## Chaining Tasks Together\n\n`Task`s are a little bit magical, in that they let you chain them without nesting. If you use `continueWithTask` instead of `continueWith`, then you can return a new task. The `Task` returned by `continueWithTask` will not be considered complete until the new `Task` returned from within `continueWithTask` is. This lets you perform multiple actions without incurring the pyramid code you would get with callbacks. Likewise, `onSuccessTask` is a version of `onSuccess` that returns a new task. So, use `continueWith`/`onSuccess` to do more synchronous work, or `continueWithTask`/`onSuccessTask` to do more asynchronous work.\n\n```java\nfinal ParseQuery<ParseObject> query = ParseQuery.getQuery(\"Student\");\nquery.orderByDescending(\"gpa\");\nfindAsync(query).onSuccessTask(new Continuation<List<ParseObject>, Task<ParseObject>>() {\n  public Task<ParseObject> then(Task<List<ParseObject>> task) throws Exception {\n    List<ParseObject> students = task.getResult();\n    students.get(0).put(\"valedictorian\", true);\n    return saveAsync(students.get(0));\n  }\n}).onSuccessTask(new Continuation<ParseObject, Task<List<ParseObject>>>() {\n  public Task<List<ParseObject>> then(Task<ParseObject> task) throws Exception {\n    ParseObject valedictorian = task.getResult();\n    return findAsync(query);\n  }\n}).onSuccessTask(new Continuation<List<ParseObject>, Task<ParseObject>>() {\n  public Task<ParseObject> then(Task<List<ParseObject>> task) throws Exception {\n    List<ParseObject> students = task.getResult();\n    students.get(1).put(\"salutatorian\", true);\n    return saveAsync(students.get(1));\n  }\n}).onSuccess(new Continuation<ParseObject, Void>() {\n  public Void then(Task<ParseObject> task) throws Exception {\n    // Everything is done!\n    return null;\n  }\n});\n```\n\n## Error Handling\n\nBy carefully choosing whether to call `continueWith` or `onSuccess`, you can control how errors are propagated in your application. Using `continueWith` lets you handle errors by transforming them or dealing with them. You can think of failed `Task`s kind of like throwing an exception. In fact, if you throw an exception inside a continuation, the resulting `Task` will be faulted with that exception.\n\n```java\nfinal ParseQuery<ParseObject> query = ParseQuery.getQuery(\"Student\");\nquery.orderByDescending(\"gpa\");\nfindAsync(query).onSuccessTask(new Continuation<List<ParseObject>, Task<ParseObject>>() {\n  public Task<ParseObject> then(Task<List<ParseObject>> task) throws Exception {\n    List<ParseObject> students = task.getResult();\n    students.get(0).put(\"valedictorian\", true);\n    // Force this callback to fail.\n    throw new RuntimeException(\"There was an error.\");\n  }\n}).onSuccessTask(new Continuation<ParseObject, Task<List<ParseObject>>>() {\n  public Task<List<ParseObject>> then(Task<ParseObject> task) throws Exception {\n    // Now this continuation will be skipped.\n    ParseObject valedictorian = task.getResult();\n    return findAsync(query);\n  }\n}).continueWithTask(new Continuation<List<ParseObject>, Task<ParseObject>>() {\n  public Task<ParseObject> then(Task<List<ParseObject>> task) throws Exception {\n    if (task.isFaulted()) {\n      // This error handler WILL be called.\n      // The exception will be \"There was an error.\"\n      // Let's handle the error by returning a new value.\n      // The task will be completed with null as its value.\n      return null;\n    }\n\n    // This will also be skipped.\n    List<ParseObject> students = task.getResult();\n    students.get(1).put(\"salutatorian\", true);\n    return saveAsync(students.get(1));\n  }\n}).onSuccess(new Continuation<ParseObject, Void>() {\n  public Void then(Task<ParseObject> task) throws Exception {\n    // Everything is done! This gets called.\n    // The task's result is null.\n    return null;\n  }\n});\n```\n\nIt's often convenient to have a long chain of success callbacks with only one error handler at the end.\n\n## Creating Tasks\n\nWhen you're getting started, you can just use the `Task`s returned from methods like `findAsync` or `saveAsync`. However, for more advanced scenarios, you may want to make your own `Task`s. To do that, you create a `TaskCompletionSource`. This object will let you create a new `Task` and control whether it gets marked as completed or cancelled. After you create a `Task`, you'll need to call `setResult`, `setError`, or `setCancelled` to trigger its continuations.\n\n```java\npublic Task<String> succeedAsync() {\n  TaskCompletionSource<String> successful = new TaskCompletionSource<>();\n  successful.setResult(\"The good result.\");\n  return successful.getTask();\n}\n\npublic Task<String> failAsync() {\n  TaskCompletionSource<String> failed = new TaskCompletionSource<>();\n  failed.setError(new RuntimeException(\"An error message.\"));\n  return failed.getTask();\n}\n```\n\nIf you know the result of a `Task` at the time it is created, there are some convenience methods you can use.\n\n```java\nTask<String> successful = Task.forResult(\"The good result.\");\n\nTask<String> failed = Task.forError(new RuntimeException(\"An error message.\"));\n```\n\n## Creating Async Methods\n\nWith these tools, it's easy to make your own asynchronous functions that return `Task`s. For example, you can define `fetchAsync` easily.\n\n```java\npublic Task<ParseObject> fetchAsync(ParseObject obj) {\n  final TaskCompletionSource<ParseObject> tcs = new TaskCompletionSource<>();\n  obj.fetchInBackground(new GetCallback() {\n    public void done(ParseObject object, ParseException e) {\n     if (e == null) {\n       tcs.setResult(object);\n     } else {\n       tcs.setError(e);\n     }\n   }\n  });\n  return tcs.getTask();\n}\n```\n\nIt's similarly easy to create `saveAsync`, `findAsync` or `deleteAsync`. We've also provided some convenience functions to help you create `Task`s from straight blocks of code. `callInBackground` runs a `Task` on our background thread pool, while `call` tries to execute its block immediately.\n\n```java\nTask.callInBackground(new Callable<Void>() {\n  public Void call() {\n    // Do a bunch of stuff.\n  }\n}).continueWith(...);\n```\n\n## Tasks in Series\n\n`Task`s are convenient when you want to do a series of asynchronous operations in a row, each one waiting for the previous to finish. For example, imagine you want to delete all of the comments on your blog.\n\n```java\nParseQuery<ParseObject> query = ParseQuery.getQuery(\"Comments\");\nquery.whereEqualTo(\"post\", 123);\n\nfindAsync(query).continueWithTask(new Continuation<List<ParseObject>, Task<Void>>() {\n  public Task<Void> then(Task<List<ParseObject>> results) throws Exception {\n    // Create a trivial completed task as a base case.\n    Task<Void> task = Task.forResult(null);\n    for (final ParseObject result : results) {\n      // For each item, extend the task with a function to delete the item.\n      task = task.continueWithTask(new Continuation<Void, Task<Void>>() {\n        public Task<Void> then(Task<Void> ignored) throws Exception {\n          // Return a task that will be marked as completed when the delete is finished.\n          return deleteAsync(result);\n        }\n      });\n    }\n    return task;\n  }\n}).continueWith(new Continuation<Void, Void>() {\n  public Void then(Task<Void> ignored) throws Exception {\n    // Every comment was deleted.\n    return null;\n  }\n});\n```\n\n## Tasks in Parallel\n\nYou can also perform several `Task`s in parallel, using the `whenAll` method. You can start multiple operations at once and use `Task.whenAll` to create a new `Task` that will be marked as completed when all of its input `Task`s are finished. The new `Task` will be successful only if all of the passed-in `Task`s succeed. Performing operations in parallel will be faster than doing them serially, but may consume more system resources and bandwidth.\n\n```java\nParseQuery<ParseObject> query = ParseQuery.getQuery(\"Comments\");\nquery.whereEqualTo(\"post\", 123);\n\nfindAsync(query).continueWithTask(new Continuation<List<ParseObject>, Task<Void>>() {\n  public Task<Void> then(Task<List<ParseObject>> results) throws Exception {\n    // Collect one task for each delete into an array.\n    ArrayList<Task<Void>> tasks = new ArrayList<Task<Void>>();\n    for (ParseObject result : results) {\n      // Start this delete immediately and add its task to the list.\n      tasks.add(deleteAsync(result));\n    }\n    // Return a new task that will be marked as completed when all of the deletes are\n    // finished.\n    return Task.whenAll(tasks);\n  }\n}).onSuccess(new Continuation<Void, Void>() {\n  public Void then(Task<Void> ignored) throws Exception {\n    // Every comment was deleted.\n    return null;\n  }\n});\n```\n\n## Task Executors\n\nAll of the `continueWith` and `onSuccess` methods can take an instance of `java.util.concurrent.Executor` as an optional second argument. This allows you to control how the continuation is executed. `Task.call()` invokes `Callable`s on the current thread and `Task.callInBackground` will use its own thread pool, but you can provide your own executor to schedule work onto a different thread. For example, if you want to do work on a specific thread pool:\n\n```java\nstatic final Executor NETWORK_EXECUTOR = Executors.newCachedThreadPool();\nstatic final Executor DISK_EXECUTOR = Executors.newCachedThreadPool();\n```\n\n```java\nfinal Request request = ...\nTask.call(new Callable<HttpResponse>() {\n  @Override\n  public HttpResponse call() throws Exception {\n    // Work is specified to be done on NETWORK_EXECUTOR\n    return client.execute(request);\n  }\n}, NETWORK_EXECUTOR).continueWithTask(new Continuation<HttpResponse, Task<byte[]>>() {\n  @Override\n  public Task<byte[]> then(Task<HttpResponse> task) throws Exception {\n    // Since no executor is specified, it's continued on NETWORK_EXECUTOR\n    return processResponseAsync(response);\n  }\n}).continueWithTask(new Continuation<byte[], Task<Void>>() {\n  @Override\n  public Task<Void> then(Task<byte[]> task) throws Exception {\n    // We don't want to clog NETWORK_EXECUTOR with disk I/O, so we specify to use DISK_EXECUTOR\n    return writeToDiskAsync(task.getResult());\n  }\n}, DISK_EXECUTOR);\n```\n\nFor common cases, such as dispatching on the main thread, we have provided default implementations of Executor. These include `Task.UI_THREAD_EXECUTOR` and `Task.BACKGROUND_EXECUTOR`. For example:\n\n```java\nfetchAsync(object).continueWith(new Continuation<ParseObject, Void>() {\n  public Void then(Task<ParseObject> object) throws Exception {\n    TextView textView = (TextView)findViewById(R.id.name);\n    textView.setText(object.get(\"name\"));\n    return null;\n  }\n}, Task.UI_THREAD_EXECUTOR);\n```\n\n## Capturing Variables\n\nOne difficulty in breaking up code across multiple callbacks is that they have different variable scopes. Java allows functions to \"capture\" variables from outer scopes, but only if they are marked as `final`, making them immutable. This is inconvenient. That's why we've added another convenience class called `Capture`, which lets you share a mutable variable with your callbacks. Just call `get` and `set` on the variable to change its value.\n\n```java\n// Capture a variable to be modified in the Task callbacks.\nfinal Capture<Integer> successfulSaveCount = new Capture<Integer>(0);\n\nsaveAsync(obj1).onSuccessTask(new Continuation<ParseObject, Task<ParseObject>>() {\n  public Task<ParseObject> then(Task<ParseObject> obj1) throws Exception {\n    successfulSaveCount.set(successfulSaveCount.get() + 1);\n    return saveAsync(obj2);\n  }\n}).onSuccessTask(new Continuation<ParseObject, Task<ParseObject>>() {\n  public Task<ParseObject> then(Task<ParseObject> obj2) throws Exception {\n    successfulSaveCount.set(successfulSaveCount.get() + 1);\n    return saveAsync(obj3);\n  }\n}).onSuccessTask(new Continuation<ParseObject, Task<ParseObject>>() {\n  public Task<ParseObject> then(Task<ParseObject> obj3) throws Exception {\n    successfulSaveCount.set(successfulSaveCount.get() + 1);\n    return saveAsync(obj4);\n  }\n}).onSuccess(new Continuation<ParseObject, Void>() {\n  public Void then(Task<ParseObject> obj4) throws Exception {\n    successfulSaveCount.set(successfulSaveCount.get() + 1);\n    return null;\n  }\n}).continueWith(new Continuation<Void, Integer>() {\n  public Integer then(Task<Void> ignored) throws Exception {\n    // successfulSaveCount now contains the number of saves that succeeded.\n    return successfulSaveCount.get();\n  }\n});\n```\n\n## Cancelling Tasks\n\nTo cancel a `Task` create a `CancellationTokenSource` and pass the corresponding token to any methods that create a `Task` you want to cancel, then call `cancel()` on the source. This will cancel any ongoing `Task`s that the token was supplied to.\n\n\n```java\nCancellationTokenSource cts = new CancellationTokenSource();\n\nTask<Integer> stringTask = getIntAsync(cts.getToken());\n\ncts.cancel();\n```\n\nTo cancel an asynchronous call using a token you must first modify the method to accept a `CancellationToken` and use the  `isCancellationRequested()` method to determine when to halt the operation.\n\n```java\n/**\n Gets an Integer asynchronously.\n */\npublic Task<Integer> getIntAsync(final CancellationToken ct) {\n  // Create a new Task\n  final TaskCompletionSource<Integer> tcs = new TaskCompletionSource<>();\n\n  new Thread() {\n    @Override\n    public void run() {\n      // Check if cancelled at start\n      if (ct.isCancellationRequested()) {\n        tcs.setCancelled();\n        return;\n      }\n\n      int result = 0;\n      while (result < 100) {\n        // Poll isCancellationRequested in a loop\n        if (ct.isCancellationRequested()) {\n          tcs.setCancelled();\n          return;\n        }\n        result++;\n      }\n      tcs.setResult(result);\n    }\n  }.start();\n\n  return tcs.getTask();\n}\n```\n\n# App Links\n\n[App Links](http://www.applinks.org) provide a cross-platform mechanism that allows a developer to define and publish a deep-linking scheme for their content, allowing other apps to link directly to an experience optimized for the device they are running on. Whether you are building an app that receives incoming links or one that may link out to other apps' content, Bolts provides tools to simplify implementation of the [App Links protocol](http://www.applinks.org/documentation).\n\n## Handling an App Link\n\nThe most common case will be making your app receive App Links. In-linking will allow your users to quickly access the richest, most native-feeling presentation of linked content on their devices. Bolts makes it easy to handle an inbound App Link by providing utilities for processing an incoming `Intent`.\n\nFor example, you can use the `AppLinks` utility class to parse an incoming `Intent` in your `Activity`:\n\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n\n  // An intent filter in your AndroidManifest.xml has probably already filtered by path\n  // to some extent.\n\n  // Use the target URL from the App Link to locate content.\n  Uri targetUrl = AppLinks.getTargetUrlFromInboundIntent(getIntent());\n  if (targetUrl != null) {\n    // This is activity is started by app link intent.\n\n    // targetUrl is the URL shared externally. In most cases, you embed your content identifier\n    // in this data.\n\n    // If you need to access data that you are passing from the meta tag from your website or from opening app\n    // you can get them from AppLinkData.\n    Bundle applinkData = AppLinks.getAppLinkData(getIntent());\n    String id = applinkData.getString(\"id\");\n\n    // You can also get referrer data from AppLinkData\n    Bundle referrerAppData = applinkData.getBundle(\"referer_app_link\");\n\n    // Apps can easily check the Extras from the App Link as well.\n    Bundle extras = AppLinks.getAppLinkExtras(getIntent());\n    String fbAccessToken = extras.getString(\"fb_access_token\");\n  } else {\n    // Not an applink, your existing code goes here.\n  }\n}\n```\n\n## Navigating to a URL\n\nFollowing an App Link allows your app to provide the best user experience (as defined by the receiving app) when a user navigates to a link. Bolts makes this process simple, automating the steps required to follow a link:\n\n1. Resolve the App Link by getting the App Link metadata from the HTML at the URL specified\n2. Step through App Link targets relevant to the device being used, checking whether the app that can handle the target is present on the device\n3. If an app is present, build an `Intent` with the appropriate al_applink_data specified and navigate to that `Intent`\n4. Otherwise, open the browser with the original URL specified\n\nIn the simplest case, it takes just one line of code to navigate to a URL that may have an App Link:\n\n```java\nAppLinkNavigation.navigateInBackground(getContext(), url);\n```\n\n### Adding App and Navigation Data\n\nUnder most circumstances, the data that will need to be passed along to an app during a navigation will be contained in the URL itself, so that whether or not the app is actually installed on the device, users are taken to the correct content. Occasionally, however, apps will want to pass along data that is relevant for an app-to-app navigation, or will want to augment the App Link protocol with information that might be used by the app to adjust how the app should behave (e.g. showing a link back to the referring app).\n\nIf you want to take advantage of these features, you can break apart the navigation process. First, you must have an App Link to which you wish to navigate:\n\n```java\nnew WebViewAppLinkResolver(getContext()).getAppLinkFromUrlInBackground(url).continueWith(\n    new Continuation<AppLink, AppLinkNavigation.NavigationType>() {\n      @Override\n      public AppLinkNavigation.NavigationType then(Task<AppLink> task) {\n        AppLink link = task.getResult();\n        return null;\n      }\n    });\n```\n\nThen, you can build an App Link request with any additional data you would like and navigate:\n\n```java\nBundle extras = new Bundle();\nextras.putString(\"fb_access_token\", \"t0kEn\");\nBundle appLinkData = new Bundle();\nappLinkData.putString(\"id\", \"12345\");\nAppLinkNavigation navigation = new AppLinkNavigation(link, extras, appLinkData);\nreturn navigation.navigate();\n```\n\n### Resolving App Link Metadata\n\nBolts allows for custom App Link resolution, which may be used as a performance optimization (e.g. caching the metadata) or as a mechanism to allow developers to use a centralized index for obtaining App Link metadata. A custom App Link resolver just needs to be able to take a URL and return an `AppLink` containing the ordered list of `AppLink.Target`s that are applicable for this device. Bolts provides one of these out of the box that performs this resolution on the device using a hidden `WebView`.\n\nYou can use any resolver that implements the `AppLinkResolver` interface by using one of the overloads on `AppLinkNavigation`:\n\n```java\nAppLinkNavigation.navigateInBackground(url, resolver);\n```\n\nAlternatively, a you can swap out the default resolver to be used by the built-in APIs:\n\n```java\nAppLinkNavigation.setDefaultResolver(resolver);\nAppLinkNavigation.navigateInBackground(url);\n```\n\n## Analytics\n\nBolts introduces Measurement Event. App Links broadcast two Measurement Events to the application, which can be caught and integrated with existing analytics components in your application. ([Android Support Library v4](http://developer.android.com/tools/support-library/index.html) is required in your runtime to enable Analytics.)\n\n*  `al_nav_out` — Raised when your app sends out an App Links URL.\n*  `al_nav_in` — Raised when your app opens an incoming App Links URL or intent.\n\n### Listen for App Links Measurement Events\n\nThere are other analytics tools that are integrated with Bolts' App Links events, but you can also listen for these events yourself:\n\n```java\nLocalBroadcastManager manager = LocalBroadcastManager.getInstance(context);\nmanager.registerReceiver(\n    new BroadcastReceiver() {\n      @Override\n      public void onReceive(Context context, Intent intent) {\n        String eventName = intent.getStringExtra(MeasurementEvent.MEASUREMENT_EVENT_NAME_KEY);\n        if (eventName.equals(MeasurementEvent.APP_LINK_NAVIGATE_IN_EVENT_NAME)) {\n          Bundle eventArgs = intent.getBundleExtra(MeasurementEvent.MEASUREMENT_EVENT_ARGS_KEY);\n          String targetURL = eventArgs.getString(\"targetURL\");\n          String referrerName = eventArgs.getString(\"refererAppName\");\n          // Integrate to your logging/analytics component.\n        }\n      }\n    },\n    new IntentFilter(MeasurementEvent.MEASUREMENT_EVENT_NOTIFICATION_NAME)\n);\n```\n\n### App Links Event Fields\n\nApp Links Measurement Events sends additional information from App Links Intents in flattened string key value pairs. Here are some of the useful fields for the two events.\n\n* `al_nav_in`\n  * `inputURL`: the URL that opens the app.\n  * `inputURLScheme`: the scheme of `inputURL`.\n  * `refererURL`: the URL that the referrer app added into `al_applink_data`: `referer_app_link`.\n  * `refererAppName`: the app name that the referrer app added to `al_applink_data`: `referer_app_link`.\n  * `sourceApplication`: the bundle of referrer application.\n  * `targetURL`: the `target_url` field in `al_applink_data`.\n  * `version`: App Links API  version.\n\n* `al_nav_out`\n  * `outputURL`: the URL used to open the other app (or browser). If there is an eligible app to open, this will be the custom scheme url/intent in `al_applink_data`.\n  * `outputURLScheme`: the scheme of `outputURL`.\n  * `sourceURL`: the URL of the page hosting App Links meta tags.\n  * `sourceURLHost`: the hostname of `sourceURL`.\n  * `success`: `“1”` to indicate success in opening the App Link in another app or browser; `“0”` to indicate failure to open the App Link.\n  * `type`: `“app”` for open in app, `“web”` for open in browser; `“fail”` when the success field is `“0”`.\n  * `version`: App Links API version.\n\n## License\nBolts-Android is MIT licensed, as found in the LICENSE file.\n\n [build-status-svg]: http://img.shields.io/travis/BoltsFramework/Bolts-Android/master.svg?style=flat\n [build-status-link]: https://travis-ci.org/BoltsFramework/Bolts-Android\n [coverage-status-svg]: https://coveralls.io/repos/BoltsFramework/Bolts-Android/badge.svg?branch=master&service=github\n [coverage-status-link]: https://coveralls.io/github/BoltsFramework/Bolts-Android?branch=master\n [maven-tasks-svg]: https://img.shields.io/maven-central/v/com.parse.bolts/bolts-tasks.svg?label=bolts-tasks&style=flat\n [maven-tasks-link]: https://maven-badges.herokuapp.com/maven-central/com.parse.bolts/bolts-tasks\n [maven-applinks-svg]: https://img.shields.io/maven-central/v/com.parse.bolts/bolts-applinks.svg?label=bolts-applinks&style=flat\n [maven-applinks-link]: https://maven-badges.herokuapp.com/maven-central/com.parse.bolts/bolts-applinks\n [license-svg]: https://img.shields.io/badge/license-MIT-lightgrey.svg?style=flat\n [license-link]: https://github.com/BoltsFramework/Bolts-Android/blob/master/LICENSE\n\n [latest]: https://search.maven.org/remote_content?g=com.parse.bolts&a=bolts-tasks&v=LATEST\n [snap]: https://oss.sonatype.org/content/repositories/snapshots/\n"
        },
        {
          "name": "bolts-android",
          "type": "tree",
          "content": null
        },
        {
          "name": "bolts-applinks",
          "type": "tree",
          "content": null
        },
        {
          "name": "bolts-tasks",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.gradle",
          "type": "blob",
          "size": 1.4169921875,
          "content": "// Copyright (c) Facebook, Inc. and its affiliates.\n//\n// This source code is licensed under the MIT license found in the/\n// LICENSE file in the root directory of this source tree.\n\nimport com.android.build.gradle.LibraryPlugin\n\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\nbuildscript {\n    repositories {\n        google()\n        jcenter()\n        mavenCentral()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.3.1'\n        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.0.1x'\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n        mavenCentral()\n    }\n}\n\next {\n    compileSdkVersion = 28\n    buildToolsVersion = \"28.0.3\"\n\n    minSdkVersion = 14\n    targetSdkVersion = 28\n}\n\ntask aggregateJavadocs(type: Javadoc) {\n    destinationDir = file(\"$buildDir/docs/javadoc\")\n}\n\nsubprojects {\n    afterEvaluate {\n        if (plugins.hasPlugin(JavaPlugin)) {\n            rootProject.tasks.aggregateJavadocs {\n                source += javadoc.source\n                classpath += files(javadoc.classpath)\n            }\n        }\n        if (plugins.hasPlugin(LibraryPlugin)) {\n            rootProject.tasks.aggregateJavadocs {\n                source += files(android.sourceSets.main.java.srcDirs)\n                classpath += files(project.files(android.getBootClasspath().join(File.pathSeparator)))\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "gradle.properties",
          "type": "blob",
          "size": 0.2197265625,
          "content": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the/\n# LICENSE file in the root directory of this source tree.\n\nGROUP_NAME=com.parse.bolts\nVERSION_NAME=1.5.0\n"
        },
        {
          "name": "gradle",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradlew",
          "type": "blob",
          "size": 4.9609375,
          "content": "#!/usr/bin/env bash\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\"\"\n\nAPP_NAME=\"Gradle\"\nAPP_BASE_NAME=`basename \"$0\"`\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD=\"maximum\"\n\nwarn ( ) {\n    echo \"$*\"\n}\n\ndie ( ) {\n    echo\n    echo \"$*\"\n    echo\n    exit 1\n}\n\n# OS specific support (must be 'true' or 'false').\ncygwin=false\nmsys=false\ndarwin=false\ncase \"`uname`\" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\nesac\n\n# For Cygwin, ensure paths are in UNIX format before anything is touched.\nif $cygwin ; then\n    [ -n \"$JAVA_HOME\" ] && JAVA_HOME=`cygpath --unix \"$JAVA_HOME\"`\nfi\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG=\"$0\"\n# Need this for relative symlinks.\nwhile [ -h \"$PRG\" ] ; do\n    ls=`ls -ld \"$PRG\"`\n    link=`expr \"$ls\" : '.*-> \\(.*\\)$'`\n    if expr \"$link\" : '/.*' > /dev/null; then\n        PRG=\"$link\"\n    else\n        PRG=`dirname \"$PRG\"`\"/$link\"\n    fi\ndone\nSAVED=\"`pwd`\"\ncd \"`dirname \\\"$PRG\\\"`/\" >&-\nAPP_HOME=\"`pwd -P`\"\ncd \"$SAVED\" >&-\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n \"$JAVA_HOME\" ] ; then\n    if [ -x \"$JAVA_HOME/jre/sh/java\" ] ; then\n        # IBM's JDK on AIX uses strange locations for the executables\n        JAVACMD=\"$JAVA_HOME/jre/sh/java\"\n    else\n        JAVACMD=\"$JAVA_HOME/bin/java\"\n    fi\n    if [ ! -x \"$JAVACMD\" ] ; then\n        die \"ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\n    fi\nelse\n    JAVACMD=\"java\"\n    which java >/dev/null 2>&1 || die \"ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ \"$cygwin\" = \"false\" -a \"$darwin\" = \"false\" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ \"$MAX_FD\" = \"maximum\" -o \"$MAX_FD\" = \"max\" ] ; then\n            MAX_FD=\"$MAX_FD_LIMIT\"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn \"Could not set maximum file descriptor limit: $MAX_FD\"\n        fi\n    else\n        warn \"Could not query maximum file descriptor limit: $MAX_FD_LIMIT\"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS=\"$GRADLE_OPTS \\\"-Xdock:name=$APP_NAME\\\" \\\"-Xdock:icon=$APP_HOME/media/gradle.icns\\\"\"\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed \"$APP_HOME\"`\n    CLASSPATH=`cygpath --path --mixed \"$CLASSPATH\"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=\"\"\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS=\"$ROOTDIRS$SEP$dir\"\n        SEP=\"|\"\n    done\n    OURCYGPATTERN=\"(^($ROOTDIRS))\"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ \"$GRADLE_CYGPATTERN\" != \"\" ] ; then\n        OURCYGPATTERN=\"$OURCYGPATTERN|($GRADLE_CYGPATTERN)\"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in \"$@\" ; do\n        CHECK=`echo \"$arg\"|egrep -c \"$OURCYGPATTERN\" -`\n        CHECK2=`echo \"$arg\"|egrep -c \"^-\"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed \"$arg\"`\n        else\n            eval `echo args$i`=\"\\\"$arg\\\"\"\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- \"$args0\" ;;\n        (2) set -- \"$args0\" \"$args1\" ;;\n        (3) set -- \"$args0\" \"$args1\" \"$args2\" ;;\n        (4) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" ;;\n        (5) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" ;;\n        (6) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" ;;\n        (7) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" ;;\n        (8) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" ;;\n        (9) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" \"$args8\" ;;\n    esac\nfi\n\n# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules\nfunction splitJvmOpts() {\n    JVM_OPTS=(\"$@\")\n}\neval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS\nJVM_OPTS[${#JVM_OPTS[*]}]=\"-Dorg.gradle.appname=$APP_BASE_NAME\"\n\nexec \"$JAVACMD\" \"${JVM_OPTS[@]}\" -classpath \"$CLASSPATH\" org.gradle.wrapper.GradleWrapperMain \"$@\"\n"
        },
        {
          "name": "gradlew.bat",
          "type": "blob",
          "size": 2.259765625,
          "content": "@if \"%DEBUG%\" == \"\" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif \"%OS%\"==\"Windows_NT\" setlocal\n\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nset DEFAULT_JVM_OPTS=\n\nset DIRNAME=%~dp0\nif \"%DIRNAME%\" == \"\" set DIRNAME=.\nset APP_BASE_NAME=%~n0\nset APP_HOME=%DIRNAME%\n\n@rem Find java.exe\nif defined JAVA_HOME goto findJavaFromJavaHome\n\nset JAVA_EXE=java.exe\n%JAVA_EXE% -version >NUL 2>&1\nif \"%ERRORLEVEL%\" == \"0\" goto init\n\necho.\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:findJavaFromJavaHome\nset JAVA_HOME=%JAVA_HOME:\"=%\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\n\nif exist \"%JAVA_EXE%\" goto init\n\necho.\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:init\n@rem Get command-line arguments, handling Windowz variants\n\nif not \"%OS%\" == \"Windows_NT\" goto win9xME_args\nif \"%@eval[2+2]\" == \"4\" goto 4NT_args\n\n:win9xME_args\n@rem Slurp the command line arguments.\nset CMD_LINE_ARGS=\nset _SKIP=2\n\n:win9xME_args_slurp\nif \"x%~1\" == \"x\" goto execute\n\nset CMD_LINE_ARGS=%*\ngoto execute\n\n:4NT_args\n@rem Get arguments from the 4NT Shell from JP Software\nset CMD_LINE_ARGS=%$\n\n:execute\n@rem Setup the command line\n\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n\n@rem Execute Gradle\n\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\n\n:end\n@rem End local scope for the variables with windows NT shell\nif \"%ERRORLEVEL%\"==\"0\" goto mainEnd\n\n:fail\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\nrem the _cmd.exe /c_ return code!\nif  not \"\" == \"%GRADLE_EXIT_CONSOLE%\" exit 1\nexit /b 1\n\n:mainEnd\nif \"%OS%\"==\"Windows_NT\" endlocal\n\n:omega\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "settings.gradle",
          "type": "blob",
          "size": 0.2529296875,
          "content": "// Copyright (c) Facebook, Inc. and its affiliates.\n//\n// This source code is licensed under the MIT license found in the/\n// LICENSE file in the root directory of this source tree.\n\ninclude ':bolts-android',\n        ':bolts-tasks',\n        ':bolts-applinks'\n"
        }
      ]
    }
  ]
}