{
  "metadata": {
    "timestamp": 1736609166064,
    "page": 474,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zhou-you/RxEasyHttp",
      "stars": 3134,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.8984375,
          "content": "# Built application files\n*.apk\n*.ap_\n\n# Files for the ART/Dalvik VM\n*.dex\n\n# Java class files\n*.class\n\n# Generated files\nbin/\ngen/\nout/\n\n# Gradle files\n.gradle/\nbuild/\n\n# Local configuration file (sdk path, etc)\nlocal.properties\n\n# Proguard folder generated by Eclipse\nproguard/\n\n# Log Files\n*.log\n\n# Android Studio Navigation editor temp files\n.navigation/\n\n# Android Studio captures folder\ncaptures/\n\n# Intellij\n*.iml\n.idea/workspace.xml\n.idea/tasks.xml\n.idea/gradle.xml\n.idea/dictionaries\n.idea/libraries\n\n# Keystore files\n*.jks\n\n# External native build folder generated in Android Studio 2.2 and later\n.externalNativeBuild\n\n# Google Services (e.g. APIs or Firebase)\ngoogle-services.json\n\n# Freeline\nfreeline.py\nfreeline/\nfreeline_project_description.json\n\n.gradle\n/local.properties\n/.idea/workspace.xml\n/.idea/libraries\n.DS_Store\n/build\n/captures\n/app/src/main/java/com/zhouyou/http/demo/MyApplication.java\n/.idea/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 60.1259765625,
          "content": "## RxEasyHttp\n\n本库是一款基于RxJava2+Retrofit2实现简单易用的网络请求框架，结合android平台特性的网络封装库,采用api链式调用一点到底,集成cookie管理,多种缓存模式,极简https配置,上传下载进度显示,请求错误自动重试,请求携带token、时间戳、签名sign动态配置,自动登录成功后请求重发功能,3种层次的参数设置默认全局局部,默认标准ApiResult同时可以支持自定义的数据结构，已经能满足现在的大部分网络请求。\n*注：Retrofit和Rxjava是当下非常火爆的开源框架，均来自神一般的公司。本库就不介绍Retrofit和Rxjava2的用法。*\n\n## 为什么会封装此库？\n网上好的开源网络库像Volley、async-http、okhttp、retrofit等都非常强大，但是实际应用中我们不会直接去使用，一般都会根据自己的业务再封装一层，这样更方便快捷，又能统一处理业务共性的东西例如：统一的数据结构（code、msg、data）、token处理、网络异常等情况。在使用retrofit来请求网络的时候，项目的需求越来越多，api也随之越来越多，一个普通的应用api一般也在100+左右。如果把这些api放在一个ApiService内会很臃肿，不利于查看api.如果采用模块的方式对api进行分类，每个模块对应若干个api.以retrofit的使用方式又需要创建若干个ApiService，这种方式维护方便，但是模块增多了，类也增多了很多。对于懒人来说就想通过一个URL就能回调你所需要的数据，什么ApiService都不想理会，同时又可以很快的与自己的业务相关联，就类似于代替你在开源网络库基础上再封装一层的作用，于是本库就应运而生。\n\n## 特点\n- 比Retrofit使用更简单、更易用。\n- 采用链式调用一点到底\n- 加入基础ApiService，减少Api冗余\n- 支持动态配置和自定义底层框架Okhttpclient、Retrofit.\n- 支持多种方式访问网络GET、POST、PUT、DELETE等请求协议\n- 支持网络缓存,八种缓存策略可选,涵盖大多数业务场景\n- 支持固定添加header和动态添加header\n- 支持添加全局参数和动态添加局部参数\n- 支持文件下载、多文件上传和表单提交数据\n- 支持文件请求、上传、下载的进度回调、错误回调，也可以自定义回调\n- 支持默认、全局、局部三个层次的配置功能\n- 支持任意数据结构的自动解析\n- 支持添加动态参数例如timeStamp时间戳、token、签名sign\n- 支持自定义的扩展API\n- 支持多个请求合并\n- 支持Cookie管理\n- 支持异步、同步请求\n- 支持Https、自签名网站Https的访问、双向验证\n- 支持失败重试机制，可以指定重试次数、重试间隔时间\n- 支持根据ky删除网络缓存和清空网络缓存\n- 提供默认的标准ApiResult解析和回调，并且可自定义ApiResult\n- 支持取消数据请求，取消订阅，带有对话框的请求不需要手动取消请求，对话框消失会自动取消请求\n- 支持请求数据结果采用回调和订阅两种方式\n- api设计上结合http协议和android平台特点来实现,loading对话框,实时进度条显示\n- 返回结果和异常统一处理\n- 结合RxJava2，线程智能控制\n\n## 关于我\n[![github](https://img.shields.io/badge/GitHub-zhou--you-green.svg)](https://github.com/zhou-you)   [![csdn](https://img.shields.io/badge/CSDN-zhouy478319399-green.svg)](http://blog.csdn.net/zhouy478319399)\n## 联系方式\n本群旨在为使用我github项目的人提供方便，如果遇到问题欢迎在群里提问。\n\n#### 欢迎加入QQ交流群（Q1群已满，请加入Q2群）\n\n[![](https://img.shields.io/badge/%E7%82%B9%E6%88%91%E4%B8%80%E9%94%AE%E5%8A%A0%E5%85%A5Q1%E7%BE%A4-581235049%28%E5%B7%B2%E6%BB%A1%29-blue.svg)](http://shang.qq.com/wpa/qunwpa?idkey=1e1f4bcfd8775a55e6cf6411f6ff0e7058ff469ef87c4d1e67890c27f0c5a390)\n\n[![](https://img.shields.io/badge/%E7%82%B9%E6%88%91%E4%B8%80%E9%94%AE%E5%8A%A0%E5%85%A5Q2%E7%BE%A4-832887601-blue.svg)](http://shang.qq.com/wpa/qunwpa?idkey=f3c997d1c3cc6a8c9fa46d3fde0d663f50e4e6d0e6441b8cc276bef39befd24c)\n\n![](http://img.blog.csdn.net/20170601165330238)![](https://img-blog.csdnimg.cn/20190627164802234.jpg)\n## 演示（请star支持）\n![](https://github.com/zhou-you/RxEasyHttp/raw/master/screenshot/1.gif) ![](https://github.com/zhou-you/RxEasyHttp/raw/master/screenshot/2.gif)\n![](https://github.com/zhou-you/RxEasyHttp/raw/master/screenshot/3.gif) ![](https://github.com/zhou-you/RxEasyHttp/raw/master/screenshot/4.gif)\n\n### RxEasyHttp与Rxjava结合使用场景演示\n![](https://github.com/zhou-you/RxEasyHttp/raw/master/screenshot/5.gif)\n\n**[RxEasyHttp网络库与Rxjava2结合常见使用场景介绍    点我！！！>>](http://blog.csdn.net/zhouy478319399/article/details/78550248)**\n\n[![](https://badge.juejin.im/entry/5a0d4d0d6fb9a045080934f1/likes.svg?style=plastic)](https://juejin.im/post/5a0d4cd851882531ba108090)\n\n## 版本说明\n\n### 当前版本\n[![release](https://img.shields.io/badge/release-V2.1.2-orange.svg)](https://github.com/zhou-you/RxEasyHttp/blob/master/update.md)\n\n**[历史版本，点我、点我、点我>>](https://github.com/zhou-you/RxEasyHttp/blob/master/update.md)**\n\n## 用法介绍\n目前只支持主流开发工具AndtoidStudio的使用，没有提供Eclipse使用方式.\n本项目Demo的网络请求的服务器地址为了安全，把url去掉了，但是Demo程序中的示例都是ok的\n### 点击按钮下载Demo\n[![downloads](https://img.shields.io/badge/downloads-2.2M-blue.svg)](https://github.com/zhou-you/RxEasyHttp/blob/master/apk/rxeasyhttp-demo.apk?raw=true) \n#### 扫码下载Demo\n![](https://github.com/zhou-you/RxEasyHttp/blob/master/screenshot/down.png?raw=true)\n\n### build.gradle设置\n```\ndependencies {\n compile 'com.zhouyou:rxeasyhttp:2.1.5'\n}\n```\n想查看所有版本，请点击下面地址。\n\n[![jcenter](https://img.shields.io/badge/Jcenter-Latest%20Release-orange.svg)](https://jcenter.bintray.com/com/zhouyou/rxeasyhttp/)\n## 权限说明\n如果使用本库实现文件下载到SD卡、或者配置了缓存数据到SD卡，你必须要考虑到Android6.0及以上系统的运行时权限，给大家推荐两个权限库：\n\n[AndPermission](https://github.com/yanzhenjie/AndPermission)  \n[RxPermissions](https://github.com/tbruyelle/RxPermissions) \n\n因为要请求网络、从SD卡读写缓存、下载文件到SD卡等等，所以需要在manifest.xml中配置以下几个权限，如果你已经配置过了这些权限，请不要重复配置：\n```\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n<uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"/>\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n## 全局配置\n一般在 Aplication，或者基类中，只需要调用一次即可，可以配置调试开关，全局的超时时间，公共的请求头和请求参数等信息\n初始化需要一个Context，最好在Application#onCreate()中初始化，记得在manifest.xml中注册Application。\n#### Application:\n\n```\npublic class MyApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n    }\n}\n```\n#### manifest.xml：\n\n```\n...\n\n<application\n    android:name=\".MyApplication\"\n    ...\n />\n```\n\n## 默认初始化\n如果使用默认始化后，一切采用默认设置。如果你需要配置全局超时时间、缓存、Cookie、底层为OkHttp的话，请看[高级初始化](https://github.com/zhou-you/RxEasyHttp#高级初始化)。\n```\npublic class MyApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        EasyHttp.init(this);//默认初始化\n    }\n}\n```\n## 高级初始化\n可以进行超时配置、网络缓存配置、okhttp相关参数配置、retrofit相关参数配置、cookie配置等，这些参数可以选择性的根据业务需要配置。\n```\npublic class MyApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        EasyHttp.init(this);//默认初始化,必须调用\n\n        //全局设置请求头\n        HttpHeaders headers = new HttpHeaders();\n        headers.put(\"User-Agent\", SystemInfoUtils.getUserAgent(this, AppConstant.APPID));\n        //全局设置请求参数\n        HttpParams params = new HttpParams();\n        params.put(\"appId\", AppConstant.APPID);\n\n        //以下设置的所有参数是全局参数,同样的参数可以在请求的时候再设置一遍,那么对于该请求来讲,请求中的参数会覆盖全局参数\n        EasyHttp.getInstance()\n        \n                //可以全局统一设置全局URL\n                .setBaseUrl(Url)//设置全局URL  url只能是域名 或者域名+端口号 \n\n                // 打开该调试开关并设置TAG,不需要就不要加入该行\n                // 最后的true表示是否打印内部异常，一般打开方便调试错误\n                .debug(\"EasyHttp\", true)\n                \n                //如果使用默认的60秒,以下三行也不需要设置\n                .setReadTimeOut(60 * 1000)\n                .setWriteTimeOut(60 * 100)\n                .setConnectTimeout(60 * 100)\n                \n                //可以全局统一设置超时重连次数,默认为3次,那么最差的情况会请求4次(一次原始请求,三次重连请求),\n                //不需要可以设置为0\n                .setRetryCount(3)//网络不好自动重试3次\n                //可以全局统一设置超时重试间隔时间,默认为500ms,不需要可以设置为0\n                .setRetryDelay(500)//每次延时500ms重试\n                //可以全局统一设置超时重试间隔叠加时间,默认为0ms不叠加\n                .setRetryIncreaseDelay(500)//每次延时叠加500ms\n                \n                //可以全局统一设置缓存模式,默认是不使用缓存,可以不传,具体请看CacheMode\n                .setCacheMode(CacheMode.NO_CACHE)\n                //可以全局统一设置缓存时间,默认永不过期\n                .setCacheTime(-1)//-1表示永久缓存,单位:秒 ，Okhttp和自定义RxCache缓存都起作用\n                //全局设置自定义缓存保存转换器，主要针对自定义RxCache缓存\n                .setCacheDiskConverter(new SerializableDiskConverter())//默认缓存使用序列化转化\n                //全局设置自定义缓存大小，默认50M\n                .setCacheMaxSize(100 * 1024 * 1024)//设置缓存大小为100M\n                //设置缓存版本，如果缓存有变化，修改版本后，缓存就不会被加载。特别是用于版本重大升级时缓存不能使用的情况\n                .setCacheVersion(1)//缓存版本为1\n                //.setHttpCache(new Cache())//设置Okhttp缓存，在缓存模式为DEFAULT才起作用\n                \n                //可以设置https的证书,以下几种方案根据需要自己设置\n                .setCertificates()                                  //方法一：信任所有证书,不安全有风险\n                //.setCertificates(new SafeTrustManager())            //方法二：自定义信任规则，校验服务端证书\n                //配置https的域名匹配规则，不需要就不要加入，使用不当会导致https握手失败\n                //.setHostnameVerifier(new SafeHostnameVerifier())\n                //.addConverterFactory(GsonConverterFactory.create(gson))//本框架没有采用Retrofit的Gson转化，所以不用配置\n                .addCommonHeaders(headers)//设置全局公共头\n                .addCommonParams(params)//设置全局公共参数\n                //.addNetworkInterceptor(new NoCacheInterceptor())//设置网络拦截器\n                //.setCallFactory()//局设置Retrofit对象Factory\n                //.setCookieStore()//设置cookie\n                //.setOkproxy()//设置全局代理\n                //.setOkconnectionPool()//设置请求连接池\n                //.setCallbackExecutor()//全局设置Retrofit callbackExecutor\n                //可以添加全局拦截器，不需要就不要加入，错误写法直接导致任何回调不执行\n                //.addInterceptor(new GzipRequestInterceptor())//开启post数据进行gzip后发送给服务器\n                .addInterceptor(new CustomSignInterceptor());//添加参数签名拦截器\n    }\n}\n```\n## 请求数据\n网络请求，采用链式调用，支持一点到底。\n\n### 入口方法\n```\n  /**\n     * get请求\n     */\n    public static GetRequest get(String url);\n\n    /**\n     * post请求和文件上传\n     */\n    public static PostRequest post(String url);\n\n    /**\n     * delete请求\n     */\n    public static DeleteRequest delete(String url) ;\n\n    /**\n     * 自定义请求\n     */\n    public static CustomRequest custom();\n\n    /**\n     * 文件下载\n     */\n    public static DownloadRequest downLoad(String url) ;\n\n    /**\n     * put请求\n     */\n    public static PutRequest put(String url);\n```\n\n\n### 通用功能配置\n1.包含一次普通请求所有能配置的参数，真实使用时不需要配置这么多，按自己的需要选择性的使用即可<br/>\n2.以下配置全部是单次请求配置，不会影响全局配置，没有配置的仍然是使用全局参数。<br/>\n3.为单个请求设置超时，比如涉及到文件的需要设置读写等待时间多一点。<br/>\n完整参数GET示例：\n```\nEasyHttp.get(\"/v1/app/chairdressing/skinAnalyzePower/skinTestResult\")\n                .baseUrl(\"http://www.xxxx.com\")//设置url\n                .writeTimeOut(30*1000)//局部写超时30s,单位毫秒\n                .readTimeOut(30*1000)//局部读超时30s,单位毫秒\n                .connectTimeout(30*1000)//局部连接超时30s,单位毫秒\n                .headers(new HttpHeaders(\"header1\",\"header1Value\"))//添加请求头参数\n                .headers(\"header2\",\"header2Value\")//支持添加多个请求头同时添加\n                .headers(\"header3\",\"header3Value\")//支持添加多个请求头同时添加\n                .params(\"param1\",\"param1Value\")//支持添加多个参数同时添加\n                .params(\"param2\",\"param2Value\")//支持添加多个参数同时添加\n                //.addCookie(new CookieManger(this).addCookies())//支持添加Cookie\n                .cacheTime(300)//缓存300s 单位s\n                .cacheKey(\"cachekey\")//缓存key\n                .cacheMode(CacheMode.CACHEANDREMOTE)//设置请求缓存模式\n                //.okCache()//使用模式缓存模式时，走Okhttp缓存\n                .cacheDiskConverter(new GsonDiskConverter())//GSON-数据转换器\n                //.certificates()添加证书\n                .retryCount(5)//本次请求重试次数\n                .retryDelay(500)//本次请求重试延迟时间500ms\n                .addInterceptor(Interceptor)//添加拦截器\n                .okproxy()//设置代理\n                .removeHeader(\"header2\")//移除头部header2\n                .removeAllHeaders()//移除全部请求头\n                .removeParam(\"param1\")\n                .accessToken(true)//本次请求是否追加token\n                .timeStamp(false)//本次请求是否携带时间戳\n                .sign(false)//本次请求是否需要签名\n                .syncRequest(true)//是否是同步请求，默认异步请求。true:同步请求\n                .execute(new CallBack<SkinTestResult>() {\n                    @Override\n                    public void onStart() {\n                        //开始请求\n                    }\n\n                    @Override\n                    public void onCompleted() {\n                       //请求完成\n                    }\n\n                    @Override\n                    public void onError(ApiException e) {\n                      //请求错误\n                    }\n\n                    @Override\n                    public void onSuccess(SkinTestResult response) {\n                      //请求成功\n                    }\n                });\n```\n#### url\nUrl可以通过初始化配置的时候传入`EasyHttp.getInstance().setBaseUrl(\"http://www.xxx.com\");`  \n入口方法传入： `EasyHttp.get(\"/v1/app/chairdressing/skinAnalyzePower/skinTestResult\").baseUrl(\"http://www.xxxx.com\")`\n如果入口方法中传入的url含有http或者https,则不会拼接初始化设置的baseUrl.\n例如：`EasyHttp.get(\"http://www.xxx.com/v1/app/chairdressing/skinAnalyzePower/skinTestResult\")`则setBaseUrl()和baseUrl()传入的baseurl都不会被拼接。\n*注:EasyHttp.get/post/put/等采用拼接的用法时请注意，url要用/斜杠开头，例如：`EasyHttp.get(\"/v1/login\")` 正确  ` EasyHttp.get(\"v1/login\")` 错误*\n#### http请求参数\n两种设置方式\n.params(HttpParams params)\n.params(\"param1\",\"param1Value\")//添加参数键值对\n\n HttpParams params = new HttpParams();\n params.put(\"appId\", AppConstant.APPID);\n .addCommonParams(params)//设置全局公共参数\n#### http请求头\n.headers(HttpHeaders headers) \n.headers(\"header2\",\"header2Value\")//添加参数键值对\n\n.addCommonHeaders(headers)//设置全局公共头\n\n### 普通网络请求\n**支持get/post/delete/put等**\n链式调用的终点请求的执行方式有：execute(Class<T> clazz) 、execute(Type type)、execute(CallBack<T> callBack)三种方式，都是针对标准的ApiResult\n#### execute(CallBack<T> callBack)\n1.EasyHttp（**推荐**）\n示例：\n```\n方式一：\n //EasyHttp.post(\"/v1/app/chairdressing/skinAnalyzePower/skinTestResult\")\n EasyHttp.get(\"/v1/app/chairdressing/skinAnalyzePower/skinTestResult\")\n                .readTimeOut(30 * 1000)//局部定义读超时\n                .writeTimeOut(30 * 1000)\n                .connectTimeout(30 * 1000)\n                .params(\"name\",\"张三\")\n                .timeStamp(true)\n                .execute(new SimpleCallBack<SkinTestResult>() {\n                    @Override\n                    public void onError(ApiException e) {\n                        showToast(e.getMessage());\n                    }\n\n                    @Override\n                    public void onSuccess(SkinTestResult response) {\n                        if (response != null) showToast(response.toString());\n                    }\n                });\n```\n2.手动创建请求对象\n```\n //GetRequest 、PostRequest、DeleteRequest、PutRequest\n GetRequest request = new GetRequest(\"/v1/app/chairdressing/skinAnalyzePower/skinTestResult\");\n        request.readTimeOut(30 * 1000)//局部定义读超时\n                .params(\"param1\", \"param1Value1\")\n                .execute(new SimpleCallBack<SkinTestResult>() {\n                    @Override\n                    public void onError(ApiException e) {\n\n                    }\n\n                    @Override\n                    public void onSuccess(SkinTestResult response) {\n\n                    }\n                });\n```\n#### execute(Class<T> clazz)和execute(Type type)\nexecute(Class<T> clazz)和execute(Type type)功能基本一样，execute(Type type)主要是针对集合不能直接传递Class\n```\nEasyHttp.get(url)\n                .params(\"param1\", \"paramValue1\")\n                .execute(SkinTestResult.class)//非常简单直接传目标class\n                //.execute(new TypeToken<List<SectionItem>>() {}.getType())//Type类型\n                .subscribe(new BaseSubscriber<SkinTestResult>() {\n                    @Override\n                    public void onError(ApiException e) {\n                        showToast(e.getMessage());\n                    }\n\n                    @Override\n                    public void onNext(SkinTestResult skinTestResult) {\n                        showToast(skinTestResult.toString());\n                    }\n                });\n```\n### 请求返回Disposable\n网络请求会返回Disposable对象，方便取消网络请求\n```\nDisposable disposable = EasyHttp.get(\"/v1/app/chairdressing/skinAnalyzePower/skinTestResult\")\n                .params(\"param1\", \"paramValue1\")\n                .execute(new SimpleCallBack<SkinTestResult>() {\n                    @Override\n                    public void onError(ApiException e) {\n                        showToast(e.getMessage());\n                    }\n\n                    @Override\n                    public void onSuccess(SkinTestResult response) {\n                        showToast(response.toString());\n                    }\n                });\n\n        //在需要取消网络请求的地方调用,一般在onDestroy()中\n        //EasyHttp.cancelSubscription(disposable);\n```\n### 带有进度框的请求\n带有进度框的请求，可以设置对话框消失是否自动取消网络和自定义对话框功能，具体参数作用请看请求回调讲解\n#### 方式一：ProgressDialogCallBack\nProgressDialogCallBack带有进度框的请求，可以设置对话框消失是否自动取消网络和自定义对话框功能，具体参数作用请看自定义CallBack讲解\n```\n IProgressDialog mProgressDialog = new IProgressDialog() {\n            @Override\n            public Dialog getDialog() {\n                ProgressDialog dialog = new ProgressDialog(MainActivity.this);\n                dialog.setMessage(\"请稍候...\");\n                return dialog;\n            }\n        };\n        EasyHttp.get(\"/v1/app/chairdressing/\")\n                .params(\"param1\", \"paramValue1\")\n                .execute(new ProgressDialogCallBack<SkinTestResult>(mProgressDialog, true, true) {\n                    @Override\n                    public void onError(ApiException e) {\n                        super.onError(e);//super.onError(e)必须写不能删掉或者忘记了\n                        //请求失败\n                    }\n\n                    @Override\n                    public void onSuccess(SkinTestResult response) {\n                       //请求成功\n                    }\n                });\n```\n*注：错误回调 super.onError(e);必须写*\n#### 方式二：ProgressSubscriber\n\n```\nIProgressDialog mProgressDialog = new IProgressDialog() {\n            @Override\n            public Dialog getDialog() {\n                ProgressDialog dialog = new ProgressDialog(MainActivity.this);\n                dialog.setMessage(\"请稍候...\");\n                return dialog;\n            }\n        };\n EasyHttp.get(URL)\n                .timeStamp(true)\n                .execute(SkinTestResult.class)\n                .subscribe(new ProgressSubscriber<SkinTestResult>(this, mProgressDialog) {\n                    @Override\n                    public void onError(ApiException e) {\n                        super.onError(e);\n                        showToast(e.getMessage());\n                    }\n\n                    @Override\n                    public void onNext(SkinTestResult skinTestResult) {\n                        showToast(skinTestResult.toString());\n                    }\n                });\n\n```\n\n### 请求返回Observable\n通过网络请求可以返回Observable，这样就可以很好的通过Rxjava与其它场景业务结合处理，甚至可以通过Rxjava的connect()操作符处理多个网络请求。例如：在一个页面有多个网络请求，如何在多个请求都访问成功后再显示页面呢？这也是Rxjava强大之处。\n*注：目前通过execute(Class<T> clazz)方式只支持标注的ApiResult结构，不支持自定义的ApiResult*\n示例：\n```\nObservable<SkinTestResult> observable = EasyHttp.get(url)\n                .params(\"param1\", \"paramValue1\")\n                .execute(SkinTestResult.class);\n\n        observable.subscribe(new BaseSubscriber<SkinTestResult>() {\n            @Override\n            public void onError(ApiException e) {\n                showToast(e.getMessage());\n            }\n\n            @Override\n            public void onNext(SkinTestResult skinTestResult) {\n                showToast(skinTestResult.toString());\n            }\n        });\n```\n\n### 文件下载\n本库提供的文件下载非常简单，没有提供复杂的下载方式例如：下载管理器、断点续传、多线程下载等，因为不想把本库做重。如果复杂的下载方式，还请考虑其它下载方案。\n文件目录如果不指定,默认下载的目录为/storage/emulated/0/Android/data/包名/files\n文件名如果不指定,则按照以下规则命名:\n>1.首先检查用户是否传入了文件名,如果传入,将以用户传入的文件名命名\n>2.如果没有传入文件名，默认名字是时间戳生成的。\n>3.如果传入了文件名但是没有后缀，程序会自动解析类型追加后缀名\n\n示例：\n```\n String url = \"http://61.144.207.146:8081/b8154d3d-4166-4561-ad8d-7188a96eb195/2005/07/6c/076ce42f-3a78-4b5b-9aae-3c2959b7b1ba/kfid/2475751/qqlite_3.5.0.660_android_r108360_GuanWang_537047121_release_10000484.apk\";\n        EasyHttp.downLoad(url)\n                .savePath(\"/sdcard/test/QQ\")\n                .saveName(\"release_10000484.apk\")//不设置默认名字是时间戳生成的\n                .execute(new DownloadProgressCallBack<String>() {\n                    @Override\n                    public void update(long bytesRead, long contentLength, boolean done) {\n                        int progress = (int) (bytesRead * 100 / contentLength);\n                        HttpLog.e(progress + \"% \");\n                        dialog.setProgress(progress);\n                        if (done) {//下载完成\n                        }\n                        ...\n                    }\n\n                    @Override\n                    public void onStart() {\n                       //开始下载\n                    }\n\n                    @Override\n                    public void onComplete(String path) {\n                       //下载完成，path：下载文件保存的完整路径\n                    }\n\n                    @Override\n                    public void onError(ApiException e) {\n                        //下载失败\n                    }\n                });\n```\n\n### POST请求，上传String、json、object、body、byte[]\n一般此种用法用于与服务器约定的数据格式，当使用该方法时，params中的参数设置是无效的，所有参数均需要通过需要上传的文本中指定，此外，额外指定的header参数仍然保持有效。\n- `.upString(\"这是要上传的长文本数据！\")//默认类型是：MediaType.parse(\"text/plain\")`\n- 如果你对请求头有自己的要求，可以使用这个重载的形式，传入自定义的content-type文本\n `upString(\"这是要上传的长文本数据！\", \"application/xml\") // 比如上传xml数据，这里就可以自己指定请求头`\n- upJson该方法与upString没有本质区别，只是数据格式是json,通常需要自己创建一个实体bean或者一个map，把需要的参数设置进去，然后通过三方的Gson或者 fastjson转换成json字符串，最后直接使用该方法提交到服务器。\n`.upJson(jsonObject.toString())//上传json`\n- `.upBytes(new byte[]{})//上传byte[]`\n- `.requestBody(body)//上传自定义RequestBody`\n- `.upObject(object)//上传对象object`   必须要增加`.addConverterFactory(GsonConverterFactory.create())`设置\n\n\n> 1.upString、upJson、requestBody、upBytes、upObject五个方法不能同时使用，当前只能选用一个\n> 2.使用upJson、upObject时候params、sign(true/false)、accessToken（true/false）、拦截器都不会起作用\n\n\n示例：\n``` \nHashMap<String, String> params = new HashMap<>();\nparams.put(\"key1\", \"value1\");\nparams.put(\"key2\", \"这里是需要提交的json格式数据\");\nparams.put(\"key3\", \"也可以使用三方工具将对象转成json字符串\");\nJSONObject jsonObject = new JSONObject(params);\n\nRequestBody body=RequestBody.create(MediaType.parse(\"xxx/xx\"),\"内容\");\nEasyHttp.post(\"v1/app/chairdressing/news/favorite\")\n                //.params(\"param1\", \"paramValue1\")//不能使用params，upString 与 params 是互斥的，只有 upString 的数据会被上传\n                .upString(\"这里是要上传的文本！\")//默认类型是：MediaType.parse(\"text/plain\")\n                //.upString(\"这是要上传的长文本数据！\", \"application/xml\") // 比如上传xml数据，这里就可以自己指定请求头\n                \n                 //.upJson(jsonObject.toString())\n                 //.requestBody(body)\n                 //.upBytes(new byte[]{})\n                 //.upObject(object)\n                .execute(new SimpleCallBack<String>() {\n                    @Override\n                    public void onError(ApiException e) {\n                        showToast(e.getMessage());\n                    }\n\n                    @Override\n                    public void onSuccess(String response) {\n                        showToast(response);\n                    }\n                });\n\n```\n\n### 上传图片或者文件\n>支持单文件上传、多文件上传、混合上传，同时支持进度回调，\n>暂不实现多线程上传/分片上传/断点续传等高级功能\n\n上传文件支持文件与参数一起同时上传，也支持一个key上传多个文件，以下方式可以任选\n上传文件支持两种进度回调：ProgressResponseCallBack(线程中回调)和UIProgressResponseCallBack（可以刷新UI）\n```\nfinal UIProgressResponseCallBack listener = new UIProgressResponseCallBack() {\n            @Override\n            public void onUIResponseProgress(long bytesRead, long contentLength, boolean done) {\n                int progress = (int) (bytesRead * 100 / contentLength);\n                if (done) {//完成\n                }\n                ...\n            }\n        };\n        EasyHttp.post(\"/v1/user/uploadAvatar\")\n                //支持上传新增的参数\n                //.params(String key, File file, ProgressResponseCallBack responseCallBack)\n                //.params(String key, InputStream stream, String fileName, ProgressResponseCallBack responseCallBack)\n                //.params(String key, byte[] bytes, String fileName, ProgressResponseCallBack responseCallBack) \n                //.addFileParams(String key, List<File> files, ProgressResponseCallBack responseCallBack)\n                //.addFileWrapperParams(String key, List<HttpParams.FileWrapper> fileWrappers)\n                //.params(String key, File file, String fileName, ProgressResponseCallBack responseCallBack)\n                //.params(String key, T file, String fileName, MediaType contentType, ProgressResponseCallBack responseCallBack)\n                \n                //方式一：文件上传\n                File file = new File(\"/sdcard/1.jpg\");\n                //如果有文件名字可以不用再传Type,会自动解析到是image/*\n                .params(\"avatar\", file, file.getName(), listener)\n                //.params(\"avatar\", file, file.getName(),MediaType.parse(\"image/*\"), listener)\n\n                //方式二：InputStream上传\n               final InputStream inputStream = getResources().getAssets().open(\"1.jpg\");\n                .params(\"avatar\", inputStream, \"test.png\", listener)\n                \n                //方式三：byte[]上传\n                Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.test);\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                bitmap.compress(Bitmap.CompressFormat.PNG, 100, baos);\n                final byte[] bytes = baos.toByteArray();\n                //.params(\"avatar\",bytes,\"streamfile.png\",MediaType.parse(\"image/*\"),listener)\n                //如果有文件名字可以不用再传Type,会自动解析到是image/*\n                .params(\"avatar\", bytes, \"streamfile.png\", listener)\n        \n                .params(\"file1\", new File(\"filepath1\"))   // 可以添加文件上传\n\t            .params(\"file2\", new File(\"filepath2\")) \t// 支持多文件同时添加上传\n\t            .addFileParams(\"key\", List<File> files)\t// 这里支持一个key传多个文件\n                .params(\"param1\", \"paramValue1\") \t\t// 这里可以上传参数\n                .accessToken(true)\n                .timeStamp(true)\n                .execute(new ProgressDialogCallBack<String>(mProgressDialog, true, true) {\n                    @Override\n                    public void onError(ApiException e) {\n                        super.onError(e);\n                        showToast(e.getMessage());\n                    }\n\n                    @Override\n                    public void onSuccess(String response) {\n                        showToast(response);\n                    }\n                });\n```\n### 取消请求\n#### 通过Disposable取消\n每个请求前都会返回一个Disposable，取消订阅就可以取消网络请求，如果是带有进度框的网络请求，则不需要手动取消网络请求，会自动取消。\n```\n Disposable mSubscription = EasyHttp.get(url).execute(callback);\n  ...\n  @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        EasyHttp.cancelSubscription(mSubscription);\n    }\n```\n#### 通过dialog取消\n自动取消使用ProgressDialogCallBack回调或者使用ProgressSubscriber,就不用再手动调用cancelSubscription();\nProgressDialogCallBack:\n ```\nEasyHttp.get(url).execute(new ProgressDialogCallBack());\n```\nProgressSubscriber\n```\nEasyHttp.get(url).execute(SkinTestResult.class).subscribe(new ProgressSubscriber<SkinTestResult>(this, mProgressDialog) {\n            @Override\n            public void onError(ApiException e) {\n                super.onError(e);\n                showToast(e.getMessage());\n            }\n\n            @Override\n            public void onNext(SkinTestResult skinTestResult) {\n                showToast(skinTestResult.toString());\n            }\n        })\n```\n\n### 同步请求\n同步请求只需要设置syncRequest()方法\n```\n EasyHttp.get(\"/v1/app/chairdressing/skinAnalyzePower/skinTestResult\")\n                ...\n                .syncRequest(true)//设置同步请求\n                .execute(new CallBack<SkinTestResult>() {});\n```\n\n### 请求回调CallBack支持的类型\n```\n//支持回调的类型可以是Bean、String、CacheResult<Bean>、CacheResult<String>、List<Bean>\nnew SimpleCallBack<CacheResult<Bean>>()//支持缓存的回调，请看缓存讲解\nnew SimpleCallBack<CacheResult<String>>()//支持缓存的回调，请看缓存讲解\nnew SimpleCallBack<Bean>()//返回Bean\nnew SimpleCallBack<String>()//返回字符串\nnew SimpleCallBack<List<Bean>()//返回集合\n```\n*注：其它回调同理*\n\n### cookie使用\ncookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围,关于cookie的作用这里就不再科普，自己可以去了解\ncookie设置：\n```\nEasyHttp.getInstance()\n   \t\t\t\t ...\n                  //如果不想让本库管理cookie,以下不需要\n                .setCookieStore(new CookieManger(this)) //cookie持久化存储，如果cookie不过期，则一直有效\n                 ...\n```\n\n- 查看url所对应的cookie\n\n```\nHttpUrl httpUrl = HttpUrl.parse(\"http://www.xxx.com/test\");\nCookieManger cookieManger = getCookieJar();\nList<Cookie> cookies =  cookieManger.loadForRequest(httpUrl);\n```\n\n- 查看CookieManger所有cookie\n \n```\nPersistentCookieStore cookieStore= getCookieJar().getCookieStore();\nList<Cookie> cookies1= cookieStore.getCookies();\n```\n\n- 添加cookie\n\n```\nCookie.Builder builder = new Cookie.Builder();\nCookie cookie = builder.name(\"mCookieKey1\").value(\"mCookieValue1\").domain(httpUrl.host()).build();\nCookieManger cookieManger = getCookieJar();\ncookieManger.saveFromResponse(httpUrl, cookie);\n//cookieStore.saveFromResponse(httpUrl, cookieList);//添加cookie集合\n```\n\n- 移除cookie\n\n```\nHttpUrl httpUrl = HttpUrl.parse(\"http://www.xxx.com/test\");\nCookieManger cookieManger = EasyHttp.getCookieJar();\nCookie cookie = builder.name(\"mCookieKey1\").value(\"mCookieValue1\").domain(httpUrl.host()).build();\ncookieManger.remove(httpUrl,cookie);\n```\n\n- 清空cookie\n\n```\nCookieManger cookieManger = EasyHttp.getCookieJar();\ncookieManger.removeAll();\n```\n\n### 自定义call()请求\n提供了用户自定义ApiService的接口，您只需调用call方法即可.\n示例：\n```\npublic interface LoginService {\n    @POST(\"{path}\")\n    @FormUrlEncoded\n    Observable<ApiResult<AuthModel>> login(@Path(\"path\") String path, @FieldMap Map<String, String> map);\n}\n\nfinal CustomRequest request = EasyHttp.custom()\n                .addConverterFactory(GsonConverterFactory.create(new Gson()))//自定义的可以设置GsonConverterFactory\n                .params(\"param1\", \"paramValue1\")\n                .build();\n\n        LoginService mLoginService = request.create(LoginService.class);\n        LoginService mLoginService = request.create(LoginService.class);\n        Observable<ApiResult<AuthModel>> observable = request.call(mLoginService.login(\"v1/account/login\", request.getParams().urlParamsMap));\n        Disposable subscription = observable.subscribe(new Action1<ApiResult<AuthModel>>() {\n            @Override\n            public void call(ApiResult<AuthModel> result) {\n                //请求成功\n            }\n        }, new Action1<Throwable>() {\n            @Override\n            public void call(Throwable throwable) {\n                //请求失败\n            }\n        });\n```\n\n### 自定义apiCall()请求\n提供默认的支持ApiResult结构，数据返回不需要带ApiResult,直接返回目标.\n示例：\n```\nObservable<AuthModel> observable = request.apiCall(mLoginService.login(\"v1/account/login\", request.getParams().urlParamsMap));\n```\n## 请求回调和订阅\n请求回调本库提供两种方式Callback和Subscriber\n### 回调方式\n此种方式主要针对execute(CallBack<T> callBack)，目前内部提供的回调包含CallBack, SimpleCallBack ,ProgressDialogCallBack ,DownloadProgressCallBack 可以根据自己的需求去自定义Callback\n\n- CallBack所有回调的基类，抽象类\n- SimpleCallBack简单回调，只有成功和失败\n- ProgressDialogCallBack带有进度框的回调，可以自定义进度框、支持是否可以取消对话框、对话框消失自动取消网络请求等参数设置\n- DownloadProgressCallBack如果要做文件下载，则必须使用该回调，内部封装了关于文件下载进度回调的方法，如果使用其他回调也可以，但是没有进度通知\n\n该网络框架的核心使用方法即为Callback的继承使用，因为不同的项目需求，会有个性化的回调请自定义\n#### CallBack回调\n```\nnew CallBack<T>() {\n                    @Override\n                    public void onStart() {\n                       //请求开始\n                    }\n\n                    @Override\n                    public void onCompleted() {\n                       //请求完成\n                    }\n\n                    @Override\n                    public void onError(ApiException e) {\n                       //请求失败\n                    }\n\n                    @Override\n                    public void onSuccess(T t) {\n                       //请求成功\n                    }\n                }\n```\n\n#### SimpleCallBack回调\n\n```\nnew SimpleCallBack<T>() {\n                    @Override\n                    public void onError(ApiException e) {\n                         //请求失败\n                    }\n\n                    @Override\n                    public void onSuccess(T t) {\n                        //请求成功\n                    }\n                }\n```\n\n#### ProgressDialogCallBack回调\n可以自定义带有加载进度框的回调，取消对话框会自动取消掉网络请求\n\n提供两个构造\n> public ProgressDialogCallBack(IProgressDialog progressDialog);//默认不能取消对话框\n> public ProgressDialogCallBack(IProgressDialog progressDialog, boolean isShowProgress, boolean isCancel);//自定义加载进度框,可以设置是否显示弹出框，是否可以取消 progressDialog: dialog对象接口  isShowProgress：对话框消失是否取消网络请求 isCancel：是否可以取消对话框对应Dialog的setCancelable(isCancel)方法;\n\n自定义ProgressDialog对话框\n```\n private IProgressDialog mProgressDialog = new IProgressDialog() {\n        @Override\n        public Dialog getDialog() {\n            ProgressDialog dialog = new ProgressDialog(MainActivity.this);\n            dialog.setMessage(\"请稍候...\");\n            return dialog;\n        }\n    };\n```\n#### DownloadProgressCallBack回调\n此回调只用于文件下载，具体请看文件下载讲解\n#### 自定义CallBack回调\n如果对回调有特殊需求，支持可以继承CallBack自己扩展功能\n\n### 订阅方式\n此种方式主要是针对execute(Class<T> clazz)和execute(Type type)，目前内部提供的Subscriber包含BaseSubscriber、DownloadSubscriber、ProgressSubscriber，可以根据自己的需求去自定义Subscriber\n- BaseSubscriber所有订阅者的基类，抽象类\n- DownloadSubscriber下载的订阅者，上层不需要关注\n- ProgressSubscriber带有进度框的订阅，可以自定义进度框、支持是否可以取消对话框、对话框消失自动取消网络请求等参数设置\n\n```\nnew BaseSubscriber<T>() {\n            @Override\n            public void onError(ApiException e) {\n               //请求失败\n            }\n\n            @Override\n            public void onNext(T t) {\n                //请求成功\n            }\n        }\n```\n\n```\nnew ProgressSubscriber<T>(this, mProgressDialog) {\n                    @Override\n                    public void onError(ApiException e) {\n                        super.onError(e);\n                        //请求失败\n                    }\n\n                    @Override\n                    public void onNext(T t) {\n                         //请求成功\n                    }\n                }\n```\n\n### 自定义Subscriber\n如果对Subscriber有特殊需求，支持可以继承BaseSubscriber自己扩展订阅者\n## 缓存使用\n### 缓存介绍\n本库的缓存主要分okhttp的Cache缓存和自定义的RxCache缓存,大家有疑问okhttp有缓存，retrofit也是支持通过header来设置缓存，为什么还要自定义一个缓存机制呢？通过自定义RxCache缓存使用更简单，更符合我们常用的业务需求(常用的缓存策略也不会太复杂)， retrofit的缓存借助于okhttp通过拦截器interceptor实现或者通过[`@Headers(\"Cache-Control: public, max-age=3600)`](http://www.jianshu.com/p/9c3b4ea108a7)具体用法这里不做详细描述，有兴趣的可以自己去了解。动态修改缓存时间不方便，例如：同一个接口，不同时间段请求的内容缓存的时间不一样，需要动态修改。\n\n对于`DEFAULT`模式是okhttp的Cache缓存。因为该模式是完全遵循标准的http协议的,缓存时间是依靠服务端响应头来控制，也可以通过拦截器自己处理\n\n对于RxCache的缓存支持多种存储方式，提供`IDiskConverter`转换器接口目前支持`SerializableDiskConverter`和`GsonDiskConverter`两种方式，也可以自定义Parcelable、fastjson、xml、kryo等转换器\n**SerializableDiskConverter**\n使用缓存前，必须让缓存的数据所有javaBean对象实现Serializable接口，否则会报NotSerializableException。 因为缓存的原理是将对象序列化后保存，如果不实现Serializable接口，会导致对象无法序列化，进而无法保存，也就达不到缓存的效果。\n优点：存储和读取都不用再转化直接就是需要的对象速度快 \n缺点：如果javabean里面还有javabean且层级比较多，也必须每个都要实现Serializable接口，比较麻烦\n**GsonDiskConverter**\n此种方式就是以json字符串的方式存储\n优点：相对于SerializableDiskConverter转换器，存储的对象不需要进行序列化\n缺点：就是存储和读取都要使用Gson进行转换，object->String->Object的给一个过程，相对来说每次都要转换性能略低，但是性能基本忽略不计\n\n目前提供了八种CacheMode缓存模式,每种缓存模式都可以指定对应的CacheTime,将复杂常用的业务场景封装在里面，让你不用关心缓存的具体实现，而专注于数据的处理\n\n- NO_CACHE：不使用缓存,该模式下,cacheKey,cacheTime 等参数均无效\n- DEFAULT：按照HTTP协议的默认缓存规则，走OKhttp的Cache缓存\n- FIRSTREMOTE：先请求网络，请求网络失败后再加载缓存\n- FIRSTCACHE：先加载缓存，缓存没有再去请求网络\n- ONLYREMOTE：仅加载网络，但数据依然会被缓存\n- ONLYCACHE：只读取缓存，缓存没有会返回null\n- CACHEANDREMOTE:先使用缓存，不管是否存在，仍然请求网络，CallBack会回调两次.\n- CACHEANDREMOTEDISTINCT:先使用缓存，不管是否存在，仍然请求网络，CallBack回调不一定是两次，如果发现请求的网络数据和缓存数据是一样的，就不会再返回网络的回调,既回调一次。否则不相同仍然会回调两次。（目的是为了防止数据没有发生变化，也需要回调两次导致界面无用的重复刷新）,**此种模式缓存的对象bean一定要重写tostring()方法**\n\n*注：无论对于哪种缓存模式，都可以指定一个cacheKey，建议针对不同需要缓存的页面设置不同的cacheKey，如果相同，会导致数据覆盖。*\n\n### 缓存设置\n缓存设置有两种方式\n方式一：全局设置，所有请求都会默认使用此模式\n```\n EasyHttp.getInstance()\n \t\t\t\t...\n                .setCacheMode(CacheMode.CACHEANDREMOTE)//不设置默认是NO_CACHE模式\n                ...\n```\n方式二：单个请求设置缓存模式\n```\n EasyHttp.get(URL)\n \t\t\t\t...\n                .cacheMode(CacheMode.FIRSTREMOTE)\n                ...\n```\n### 设置转换器\n方式一：全局设置，所有请求都会默认使用此存储转换器\n```\nEasyHttp.getInstance().setCacheDiskConverter(new SerializableDiskConverter())//默认缓存使用序列化转化\n```\n方式二：单个请求设置存储转换器\n```\nEasyHttp.get(URL).cacheDiskConverter(new GsonDiskConverter());\n```\n*注：一个请求就选用一种转换器，切记不要使用SerializableDiskConverter来缓存，又用GsonDiskConverter来读会报错*\n\n### 自定义转换器\n如果你想拥有自己的转换器请实现`IDiskConverter`接口。\n示例：\n```\npublic class CustomDiskConverter implements IDiskConverter {\n    @Override\n    public <T> T load(InputStream source, Type type) {\n        //实现读功能\n        return null;\n    }\n\n    @Override\n    public boolean writer(OutputStream sink, Object data) {\n        //实现写功能\n        return false;\n    }\n}\n\n```\n### 缓存回调\n对具有缓存的回调CallBack，如果你想知道当前的缓存是来自本地还是网络，只需要回调中加入CacheResult，其它和普通的网络请求方式一模一样。CacheResult中的isFromCache可以知道是否来自缓存，true：来自缓存，false：来自网络。请使用`new SimpleCallBack<CacheResult<T>>()` 也就是在你原有的T上包含一层CacheResult就可以了。如果不想用到isFromCache就不需要用CacheResult，直接使用`new SimpleCallBack<T>()`\n带有CacheResult回调示例：\n```\n EasyHttp.get(url)\n                .readTimeOut(30 * 1000)//测试局部读超时30s\n                .cacheMode(cacheMode)\n                .cacheKey(this.getClass().getSimpleName())//缓存key\n                .retryCount(5)//重试次数\n                .cacheTime(5 * 60)//缓存时间300s，默认-1永久缓存  okhttp和自定义缓存都起作用\n                //.okCache(new Cache());//okhttp缓存，模式为默认模式（CacheMode.DEFAULT）才生效\n                //.cacheDiskConverter(new GsonDiskConverter())//默认使用的是 new SerializableDiskConverter();\n                .cacheDiskConverter(new SerializableDiskConverter())//默认使用的是 new SerializableDiskConverter();\n                .timeStamp(true)\n                .execute(new SimpleCallBack<CacheResult<SkinTestResult>>() {\n\n                    @Override\n                    public void onError(ApiException e) {\n                       //请求失败\n                    }\n\n                    @Override\n                    public void onSuccess(CacheResult<SkinTestResult> cacheResult) {\n                        HttpLog.i(cacheResult.toString());\n                        String from = \"\";\n                        if (cacheResult.isFromCache) {\n                            from = \"我来自缓存\";\n                        } else {\n                            from = \"我来自远程网络\";\n                        }\n                       ....\n                    }\n                });\n```\n### 移除缓存\n支持根据缓存key移除缓存，主要是针对RxCache才能起作用\n```\nEasyHttp.removeCache(\"cachekey\");\n```\n### 清空缓存\n```\nEasyHttp.clearCache();\n```\n\n### RxCache\nRxCache是自己封装的一个本地缓存功能库，采用Rxjava+DiskLruCache来实现，线程安全内部采用ReadWriteLock机制防止频繁读写缓存造成的异常，可以独立使用，单独用RxCache来存储数据。采用transformer与网络请求结合，可以实现网络缓存功能,本地硬缓存，具有缓存读写功能（异步）、缓存是否存在、根据key删除缓存、清空缓存（异步）、缓存Key会自动进行MD5加密、可以设置缓存磁盘大小、缓存key、缓存时间、缓存存储的转换器、缓存目录、缓存Version等功能本库不作为重点介绍。后期会将此代码独立开源一个库，作为一分钟让你自己的网络库也具有缓存功能，敬请期待！！！\n\n## 动态参数\n动态参数就是像我们的token、时间戳timeStamp、签名sign等，这些参数不能是全局参数因为是变化的，设置成局部参数又太麻烦，每次都要获取。token是有有效时间的或者异地登录等都会变化重新获取，时间戳一般是根据系统的时间，sign是根据请求的url和参数进行加密签名一般都有自己的签名规则。有的接口需要这些参数有的接口不需要，本库很好的解决这个问题。\n#### 1.在请求的时候可以设置下面三个参数\n```\n.accessToken(true)//本次请求是否追加token\n.timeStamp(false)//本次请求是否携带时间戳\n.sign(false)//本次请求是否需要签名\n```\n#### 2.需要继承库中提供的动态拦截器BaseDynamicInterceptor\n继承BaseDynamicInterceptor后就可以获取到参数的设置值，请详细看`CustomSignInterceptor`的注释讲解，也可以查看Demo示例\n示例:\n```\n/**\n * <p>描述：对参数进行签名、添加token、时间戳处理的拦截器</p>\n * 主要功能说明：<br>\n * 因为参数签名没办法统一，签名的规则不一样，签名加密的方式也不同有MD5、BASE64等等，只提供自己能够扩展的能力。<br>\n * 作者： zhouyou<br>\n * 日期： 2017/5/4 15:21 <br>\n * 版本： v1.0<br>\n */\npublic class CustomSignInterceptor extends BaseDynamicInterceptor<CustomSignInterceptor> {\n    @Override\n    public TreeMap<String, String> dynamic(TreeMap<String, String> dynamicMap) {\n        //dynamicMap:是原有的全局参数+局部参数\n        //你不必关心当前是get/post/上传文件/混合上传等，库中会自动帮你处理。\n        //根据需要自己处理，如果你只用到token则不必处理isTimeStamp()、isSign()\n        if (isTimeStamp()) {//是否添加时间戳，因为你的字段key可能不是timestamp,这种动态的自己处理\n            dynamicMap.put(ComParamContact.Common.TIMESTAMP, String.valueOf(System.currentTimeMillis()));\n        }\n        if (isSign()) {是否签名\n            //1.因为你的字段key可能不是sign，这种需要动态的自己处理\n            //2.因为你的签名的规则不一样，签名加密方式也不一样，只提供自己能够扩展的能力\n            dynamicMap.put(ComParamContact.Common.SIGN, sign(dynamicMap));\n        }\n        if (isAccessToken()) {//是否添加token\n            String acccess = TokenManager.getInstance().getAuthModel().getAccessToken();\n            dynamicMap.put(ComParamContact.Common.ACCESSTOKEN, acccess);\n        }\n        //Logc.i(\"dynamicMap:\" + dynamicMap.toString());\n        return dynamicMap;//dynamicMap:是原有的全局参数+局部参数+新增的动态参数\n    }\n\n    //示例->签名规则：POST+url+参数的拼装+secret\n    private String sign(TreeMap<String, String> dynamicMap) {\n        String url = getHttpUrl().url().toString();\n        url = url.replaceAll(\"%2F\", \"/\");\n        StringBuilder sb = new StringBuilder(\"POST\");\n        sb.append(url);\n        for (Map.Entry<String, String> entry : dynamicMap.entrySet()) {\n            sb.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\"&\");\n        }\n\n        sb.append(AppConstant.APP_SECRET);\n        HttpLog.i(sb.toString());\n        return MD5.encode(sb.toString());\n    }\n}\n```\n#### 3.设置自定义的动态拦截器\n最好通过全局的方式设置，因为一般很多接口都会使用到\n```\n EasyHttp.getInstance()\n                 ...\n                .addInterceptor(new CustomSignInterceptor())//添加动态参数（签名、token、时间戳）拦截器\n                 ...\n```\n## 自定义ApiResult\n本库中默认提供的是标准ApiResult.内部是靠ApiResult进行解析的，如果你的数据结构跟ApiResult不同，你可以在你的项目中继承ApiResult，然后重写getCode()、getData()、getMsg()和isOk()等方法来实现自己的需求。\n本库中ApiResult如下：\n```\npublic class ApiResult<T> {\n    private int code;\n    private String msg;\n    private T data;\n    public int getCode() {\n        return code;\n    }\n\n    public void setCode(int code) {\n        this.code = code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n\n    public T getData() {\n        return data;\n    }\n\n    public void setData(T data) {\n        this.data = data;\n    }\n\n    public boolean isOk() {//请求成功的判断方法\n        return code == 0 ? true : false;\n    }\n}\n```\njson格式类似:\n```\n{\n\"code\": 100010101,\n\"data\": 内容,\n\"msg\": \"请求成功\"\n}\n```\n假如你的数据结构是这样的：\n```\n{\n\"error_code\": 0,\n\"result\": 内容,\n\"reason\": \"请求成功\"\n}\n```\n那么你的basebean可以写成这样\n```\npublic class CustomApiResult<T> extends ApiResult<T> {\n    String reason;\n    int error_code;\n    //int resultcode;\n    T result;\n    @Override\n    public int getCode() {\n        return error_code;\n    }\n    @Override\n    public void setCode(int code) {\n        error_code = code;\n    }\n    @Override\n    public String getMsg() {\n        return reason;\n    }\n    @Override\n    public void setMsg(String msg) {\n        reason = msg;\n    }\n    @Override\n    public T getData() {\n        return result;\n    }\n    @Override\n    public void setData(T data) {\n        result = data;\n    }\n   /* @Override\n    public boolean isOk() {\n        return error_code==200;//如果不是0表示成功，请重写isOk()方法。\n    }*/\n}\n```\n那么你的网络请求可以这样写\n##### 自定义ApiResult回调方式（通过CallBackProxy代理）\n```\nEasyHttp.get(url)\n                .readTimeOut(30 * 1000)//局部定义读超时\n                .writeTimeOut(30 * 1000)\n                .connectTimeout(30 * 1000)\n                //.cacheKey(this.getClass().getSimpleName()+\"11\")\n                //.cacheMode(CacheMode.CACHEANDREMOTE)\n                //.cacheMode(CacheMode.ONLYREMOTE)\n                //.headers(\"\",\"\")//设置头参数\n                //.params(\"name\",\"张三\")//设置参数\n                //.addInterceptor()\n                //.addConverterFactory()\n                //.addCookie()\n                //.timeStamp(true)\n                .baseUrl(\"http://apis.juhe.cn\")\n                .params(\"phone\", \"手机号\")\n                .params(\"dtype\", \"json\")\n                .params(\"key\", \"5682c1f44a7f486e40f9720d6c97ffe4\")\n                .execute(new CallBackProxy<CustomApiResult<ResultBean>, ResultBean>(new SimpleCallBack<ResultBean>() {\n                    @Override\n                    public void onError(ApiException e) {\n                        //请求错误\n                    }\n\n                    @Override\n                    public void onSuccess(ResultBean response) {\n                        //请求成功\n                    }\n                }) {\n                });\n```\n\n这种写法会觉得有点长，CallBackProxy的泛型参数每次都需要填写，其中CustomApiResult是继承ApiResult的，CustomApiResult相当于项目的basebean,对于一个实际项目来讲，basebean是固定的，所以我们可以继续封装这个方法，根据需要一般只需要封装get和post请求就可以了。\n```\n public static <T> Disposable customExecute(CallBack<T> callBack) {\n        return execute(new CallBackProxy<CustomApiResult<T>, T>(callBack) {\n        });\n    }\n```\n\n通过以上改造，再次调用时直接使用CallBack，不用再关注CallBackProxy，是不是明显简单很多了，具体请看代码Demo!!!\n##### 自定义ApiResult订阅方式（通过CallClazzProxy代理）\n```\nObservable<ResultBean> observable = EasyHttp.get(\"/mobile/get\")\n                .readTimeOut(30 * 1000)//局部定义读超时\n                .writeTimeOut(30 * 1000)\n                .baseUrl(\"http://apis.juhe.cn\")\n                .params(\"phone\", \"18688994275\")\n                .params(\"dtype\", \"json\")\n                .params(\"key\", \"5682c1f44a7f486e40f9720d6c97ffe4\")\n                .execute(new CallClazzProxy<CustomApiResult<ResultBean>, ResultBean>(ResultBean.class) {\n                });\n        observable.subscribe(new ProgressSubscriber<ResultBean>(this, mProgressDialog) {\n            @Override\n            public void onError(ApiException e) {\n                super.onError(e);\n                showToast(e.getMessage());\n            }\n\n            @Override\n            public void onNext(ResultBean result) {\n                showToast(result.toString());\n            }\n        });\n```\n## 调试模式\n一个好的库，一定有比较人性化的调试模式，为了方便开发者查看请求过程和请求日志，本库提供详细的日志打印，最好在开发阶段，请打开调试模式输出优雅的Log.\n调试模式的控制在初始化配置时就可以直接设置。\n```\npublic class MyApplication extends Application {\n        @Override\n        public void onCreate() {\n            super.onCreate();\n            ...\n            EasyHttp.getInstance()\n            \t\t...\n                    // 打开该调试开关并设置TAG,不需要就不要加入该行\n                    // 最后的true表示是否打印内部异常，一般打开方便调试错误\n                    .debug(\"EasyHttp\", true);\n        }\n    }\n```\n#### Log预览说明\n这里一个成功请求的例子：\n![](http://img.blog.csdn.net/20170608191720172)\n上方的Log打印了一个Request完整的声明周期，一个请求的Log有以下特点：\n1.开头和结尾打了-->http is start和 -->http is Complete分割请求，完整的生命周期的内容都会打印在开头和结尾的里面。\n2.request请求和response响应分割，分别是\n> -------------------------------request-------------------------------\n\n> -------------------------------response-------------------------------\n\n3.在---request---之后会打印请求的url、当前请求的类型GET/POST... -->GET/POST开头  -->END GET/POST结尾。如果是GET、HEAD请求方式添加的参数将会在这里完整的以url?key=value&key=value的形式打印。\n4.在----response----之后会打印（在服务器响应后被打印），包含响应码、响应状态、响应头、cookie,body等以<--200(响应码)开头，<--END HTTP结尾\n5.loadCache  key=如果设置了缓存，会看到缓存的key，开启了网络缓存功能才会输出。\n6.loadCache result=从缓存里读取的结果，开启了网络缓存功能才会输出。\n7.save status => true保存缓存的状态\n## 混淆\n```\n#okhttp\n-dontwarn com.squareup.okhttp3.**\n-keep class com.squareup.okhttp3.** { *;}\n-dontwarn okio.**\n\n# Retrofit\n-dontwarn retrofit2.**\n-keep class retrofit2.** { *; }\n-keepattributes Exceptions\n\n# Retrolambda\n-dontwarn java.lang.invoke.*\n\n# RxJava RxAndroid\n-dontwarn sun.misc.**\n-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* {\n    long producerIndex;\n    long consumerIndex;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef {\n    rx.internal.util.atomic.LinkedQueueNode producerNode;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef {\n    rx.internal.util.atomic.LinkedQueueNode consumerNode;\n}\n###rxandroid-1.2.1\n-keepclassmembers class rx.android.**{*;}\n\n# Gson\n-keep class com.google.gson.stream.** { *; }\n-keepattributes EnclosingMethod\n-keep class org.xz_sale.entity.**{*;}\n-keep class com.google.gson.** {*;}\n-keep class com.google.**{*;}\n-keep class sun.misc.Unsafe { *; }\n-keep class com.google.gson.stream.** { *; }\n-keep class com.google.gson.examples.android.model.** { *; }\n\n#RxEasyHttp\n-keep class com.zhouyou.http.model.** {*;}\n-keep class com.zhouyou.http.cache.model.** {*;}\n-keep class com.zhouyou.http.cache.stategy.**{*;}\n```\n[请查看Demo中完整的混淆文件](https://github.com/zhou-you/RxEasyHttp/blob/master/app/proguard-rules.pro)\n\n"
        },
        {
          "name": "about.md",
          "type": "blob",
          "size": 1.7822265625,
          "content": "## 关于我\n专注Android领域的知识研究和分享，也是开源爱好者，Github地址 https://github.com/zhou-you ，会持续把工作中积累的知识和经验分享出去。\n\n## 技术交流\n### 一、QQ交流群\n\n[![](https://img.shields.io/badge/%E7%82%B9%E6%88%91%E4%B8%80%E9%94%AE%E5%8A%A0%E5%85%A5QQ%E7%BE%A4-581235049-blue.svg)](http://shang.qq.com/wpa/qunwpa?idkey=1e1f4bcfd8775a55e6cf6411f6ff0e7058ff469ef87c4d1e67890c27f0c5a390)\n\n![](http://img.blog.csdn.net/20170601165330238)\n\n### 二、知识星球 （推荐）\n#### 我在知识星球平台上创建了一个星球「Android技术交流圈」\n\n![](https://github.com/zhou-you/RxEasyHttp/blob/master/screenshot/1_1.jpg)\n\n#### 有QQ群为什么还要创建星球呢？\n1. 它是更干净纯粹的朋友圈，没有广告，没有微商，也没有QQ群随便进去都是99+的消息，有用的信息都被冲掉。\n1. 这里有QQ群没有的一些东西，QQ群旨在帮助使用我的库的同学解决问题和日常一些交流，而此星球是真正花费时间经营一起成长的技术交流圈子，其它关于知识星球更多优势可以自己去了解。\n\n#### 我的知识星球有什么？\n1. 专注分享与交流Android技术相关的常用知识、教程、经验、技术干货、技术前沿等 \n1. 推荐流行的框架及讲解，你关心的Kotlin、Rxjava、Retrofit、OkHttp、蓝牙、蓝牙Mesh等都会涉及 \n1. 向我提出问题的权力，一对一的提问解答\n1. 分享我的知识结构，成长过程中的迷茫，职业发展的经验和教训\n1. 圈友们可以在星球内自由发言、分享文章和资料，提出观点和问题，对于分享高质量的内容和帮助其他圈友解决问题的，我会定期送出红包予以鼓励\n1. ....\n\n**更多内容可以扫码看星球介绍！！！**\n\n\n\n"
        },
        {
          "name": "apk",
          "type": "tree",
          "content": null
        },
        {
          "name": "app",
          "type": "tree",
          "content": null
        },
        {
          "name": "bintray.gradle",
          "type": "blob",
          "size": 2.0458984375,
          "content": "apply plugin: 'com.github.dcendents.android-maven'\napply plugin: 'com.jfrog.bintray'\n\nversion = android.defaultConfig.versionName\ngroup = GROUP\n\ninstall{\n    repositories.mavenInstaller{\n        pom{\n            project{\n                packaging PACKAGING\n                name DESCRIBE\n                url SITE_URL\n                licenses{\n                    license{\n                        name LICENSE_NAME\n                        url LICENSE_URL\n                    }\n                }\n                developers{\n                    developer{\n                        id DEVELOPER_ID\n                        name DEVELOPER_NAME\n                        email DEVELOPER_EMAIL\n                    }\n                }\n                scm{\n                    connection GIT_URL\n                    developerConnection GIT_URL\n                    url SITE_URL\n                }\n            }\n        }\n    }\n}\n\ntask sourcesJar(type: Jar){\n    from android.sourceSets.main.java.srcDirs\n    classifier = 'sources'\n}\n\ntask javadoc(type: Javadoc){\n    options.encoding = \"UTF-8\"\n    source = android.sourceSets.main.java.srcDirs\n    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))\n}\n\ntask javadocJar(type: Jar, dependsOn: javadoc){\n    classifier = 'javadoc'\n    from javadoc.destinationDir\n}\n\ntasks.withType(JavaCompile) {\n    options.encoding = \"UTF-8\"\n}\n\ntasks.withType(Javadoc) {\n    options.addStringOption('Xdoclint:none', '-quiet')\n    options.addStringOption('encoding', 'UTF-8')\n    options.addStringOption('charSet', 'UTF-8')\n}\n\nartifacts{\n    archives javadocJar\n    archives sourcesJar\n}\n\nProperties properties = new Properties()\nproperties.load(project.rootProject.file('local.properties').newDataInputStream())\nbintray{\n    user = properties.getProperty(\"bintray.user\")\n    key = properties.getProperty(\"bintray.apikey\")\n    configurations = ['archives']\n    pkg{\n        repo = PROJECT_REPO\n        name = PROJECT_NAME\n        websiteUrl = SITE_URL\n        vcsUrl = GIT_URL\n        licenses = [\"Apache-2.0\"]\n        publish = PROJECT_PUBLISH\n    }\n}"
        },
        {
          "name": "build.gradle",
          "type": "blob",
          "size": 1.14453125,
          "content": "// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n    repositories {\n        maven { url 'https://maven.aliyun.com/nexus/content/groups/public' }\n        maven { url 'https://maven.aliyun.com/nexus/content/repositories/google' }\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.3.0'\n        //classpath 'me.tatarka:gradle-retrolambda:3.2.0'\n        // 添加上传到jcenter所需的插件\n        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7'\n        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        jcenter()\n    }\n    tasks.withType(Javadoc) {\n        options.addStringOption('Xdoclint:none', '-quiet')\n        options.addStringOption('encoding', 'UTF-8')\n    }\n    tasks.withType(JavaCompile) {\n        options.compilerArgs << \"-Xlint:unchecked\"  << \"-Xlint:deprecation\"\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n"
        },
        {
          "name": "git",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "gradle.properties",
          "type": "blob",
          "size": 1.23046875,
          "content": "#\n# Copyright (C) 2017 zhouyou(478319399@qq.com)\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n# gradle¼ÓËÙ\n#org.gradle.daemon=true\n#org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8\n#org.gradle.parallel=true\n#org.gradle.configureondemand=true\n\n\nGROUP=com.zhouyou\n\nSITE_URL=https://github.com/zhou-you/RxEasyHttp\nGIT_URL=https://github.com/zhou-you/RxEasyHttp.git\n\nPACKAGING=aar\nDESCRIBE=Custom Common Framework EasyHttp Code For Android\n\nLICENSE_NAME=The Apache Software License, Version 2.0\nLICENSE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt\n\nDEVELOPER_ID=zhouy478319399\nDEVELOPER_NAME=zhouyou\nDEVELOPER_EMAIL=478319399@qq.com\n\nPROJECT_REPO=maven\nPROJECT_NAME=rxeasyhttp\nPROJECT_PUBLISH=true"
        },
        {
          "name": "gradle",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradlew",
          "type": "blob",
          "size": 4.8544921875,
          "content": "#!/usr/bin/env bash\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\"\"\n\nAPP_NAME=\"Gradle\"\nAPP_BASE_NAME=`basename \"$0\"`\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD=\"maximum\"\n\nwarn ( ) {\n    echo \"$*\"\n}\n\ndie ( ) {\n    echo\n    echo \"$*\"\n    echo\n    exit 1\n}\n\n# OS specific support (must be 'true' or 'false').\ncygwin=false\nmsys=false\ndarwin=false\ncase \"`uname`\" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\nesac\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG=\"$0\"\n# Need this for relative symlinks.\nwhile [ -h \"$PRG\" ] ; do\n    ls=`ls -ld \"$PRG\"`\n    link=`expr \"$ls\" : '.*-> \\(.*\\)$'`\n    if expr \"$link\" : '/.*' > /dev/null; then\n        PRG=\"$link\"\n    else\n        PRG=`dirname \"$PRG\"`\"/$link\"\n    fi\ndone\nSAVED=\"`pwd`\"\ncd \"`dirname \\\"$PRG\\\"`/\" >/dev/null\nAPP_HOME=\"`pwd -P`\"\ncd \"$SAVED\" >/dev/null\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n \"$JAVA_HOME\" ] ; then\n    if [ -x \"$JAVA_HOME/jre/sh/java\" ] ; then\n        # IBM's JDK on AIX uses strange locations for the executables\n        JAVACMD=\"$JAVA_HOME/jre/sh/java\"\n    else\n        JAVACMD=\"$JAVA_HOME/bin/java\"\n    fi\n    if [ ! -x \"$JAVACMD\" ] ; then\n        die \"ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\n    fi\nelse\n    JAVACMD=\"java\"\n    which java >/dev/null 2>&1 || die \"ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ \"$cygwin\" = \"false\" -a \"$darwin\" = \"false\" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ \"$MAX_FD\" = \"maximum\" -o \"$MAX_FD\" = \"max\" ] ; then\n            MAX_FD=\"$MAX_FD_LIMIT\"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn \"Could not set maximum file descriptor limit: $MAX_FD\"\n        fi\n    else\n        warn \"Could not query maximum file descriptor limit: $MAX_FD_LIMIT\"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS=\"$GRADLE_OPTS \\\"-Xdock:name=$APP_NAME\\\" \\\"-Xdock:icon=$APP_HOME/media/gradle.icns\\\"\"\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed \"$APP_HOME\"`\n    CLASSPATH=`cygpath --path --mixed \"$CLASSPATH\"`\n    JAVACMD=`cygpath --unix \"$JAVACMD\"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=\"\"\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS=\"$ROOTDIRS$SEP$dir\"\n        SEP=\"|\"\n    done\n    OURCYGPATTERN=\"(^($ROOTDIRS))\"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ \"$GRADLE_CYGPATTERN\" != \"\" ] ; then\n        OURCYGPATTERN=\"$OURCYGPATTERN|($GRADLE_CYGPATTERN)\"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in \"$@\" ; do\n        CHECK=`echo \"$arg\"|egrep -c \"$OURCYGPATTERN\" -`\n        CHECK2=`echo \"$arg\"|egrep -c \"^-\"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed \"$arg\"`\n        else\n            eval `echo args$i`=\"\\\"$arg\\\"\"\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- \"$args0\" ;;\n        (2) set -- \"$args0\" \"$args1\" ;;\n        (3) set -- \"$args0\" \"$args1\" \"$args2\" ;;\n        (4) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" ;;\n        (5) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" ;;\n        (6) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" ;;\n        (7) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" ;;\n        (8) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" ;;\n        (9) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" \"$args8\" ;;\n    esac\nfi\n\n# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules\nfunction splitJvmOpts() {\n    JVM_OPTS=(\"$@\")\n}\neval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS\nJVM_OPTS[${#JVM_OPTS[*]}]=\"-Dorg.gradle.appname=$APP_BASE_NAME\"\n\nexec \"$JAVACMD\" \"${JVM_OPTS[@]}\" -classpath \"$CLASSPATH\" org.gradle.wrapper.GradleWrapperMain \"$@\"\n"
        },
        {
          "name": "gradlew.bat",
          "type": "blob",
          "size": 2.259765625,
          "content": "@if \"%DEBUG%\" == \"\" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif \"%OS%\"==\"Windows_NT\" setlocal\n\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nset DEFAULT_JVM_OPTS=\n\nset DIRNAME=%~dp0\nif \"%DIRNAME%\" == \"\" set DIRNAME=.\nset APP_BASE_NAME=%~n0\nset APP_HOME=%DIRNAME%\n\n@rem Find java.exe\nif defined JAVA_HOME goto findJavaFromJavaHome\n\nset JAVA_EXE=java.exe\n%JAVA_EXE% -version >NUL 2>&1\nif \"%ERRORLEVEL%\" == \"0\" goto init\n\necho.\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:findJavaFromJavaHome\nset JAVA_HOME=%JAVA_HOME:\"=%\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\n\nif exist \"%JAVA_EXE%\" goto init\n\necho.\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:init\n@rem Get command-line arguments, handling Windowz variants\n\nif not \"%OS%\" == \"Windows_NT\" goto win9xME_args\nif \"%@eval[2+2]\" == \"4\" goto 4NT_args\n\n:win9xME_args\n@rem Slurp the command line arguments.\nset CMD_LINE_ARGS=\nset _SKIP=2\n\n:win9xME_args_slurp\nif \"x%~1\" == \"x\" goto execute\n\nset CMD_LINE_ARGS=%*\ngoto execute\n\n:4NT_args\n@rem Get arguments from the 4NT Shell from JP Software\nset CMD_LINE_ARGS=%$\n\n:execute\n@rem Setup the command line\n\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n\n@rem Execute Gradle\n\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\n\n:end\n@rem End local scope for the variables with windows NT shell\nif \"%ERRORLEVEL%\"==\"0\" goto mainEnd\n\n:fail\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\nrem the _cmd.exe /c_ return code!\nif  not \"\" == \"%GRADLE_EXIT_CONSOLE%\" exit 1\nexit /b 1\n\n:mainEnd\nif \"%OS%\"==\"Windows_NT\" endlocal\n\n:omega\n"
        },
        {
          "name": "rxeasyhttp",
          "type": "tree",
          "content": null
        },
        {
          "name": "screenshot",
          "type": "tree",
          "content": null
        },
        {
          "name": "settings.gradle",
          "type": "blob",
          "size": 0.0361328125,
          "content": "include ':app'\ninclude ':rxeasyhttp'\n"
        },
        {
          "name": "update.md",
          "type": "blob",
          "size": 2.603515625,
          "content": "## 更新日志\r\n### 2019-03-07\r\n**v2.1.5**\r\n- 增加参数设置params(Map<String, String> keyValues)\r\n\r\n### 2018-09-03\r\n**v2.1.2**\r\n- 修改了请求参数编码问题 \r\n- 优化了baseurl可以为null\r\n- 优化了addCallAdapterFactory重复的问题\r\n- 修改添加cookie错误问题\r\n\r\n### 2018-07-02\r\n**v2.1.0**\r\n- 解决了多baseUrl时，先请求局部baseUrl，报： Base URL required.问题\r\n\r\n### 2018-06-26\r\n**v2.0.9**\r\n- 修改了delete body请求注解错误问题\r\n\r\n### 2018-06-14\r\n**v2.0.8**\r\n- 增加put请求支持json，object,body类型\r\n\r\n### 2018-05-23\r\n**v2.0.7**\r\n- 修改put注解错误 \r\n\r\n### 2018-05-16\r\n**v2.0.6**\r\n- 增加delete请求支持body\r\n- 修复put请求bug\r\n\r\n### 2017-12-26\r\n**v2.0.5**\r\n- 修复了cookie保存问题\r\n- 添加的header去重复\r\n- 修改将默认的头拦截器放在其它拦截器最前面\r\n\r\n### 2017-09-21\r\n**v2.0.2**\r\n- 修复了V2.0.1解决bug时导致重新引入进度框消失，网络请求没有自动取消的问题\r\n\r\n### 2017-09-13\r\n**v2.0.1**\r\n- 修改了网络请求返回String时，也判断code状态\r\n- 优化网络缓存功能\r\n- 修改网络请求缓存为同步存储，解决可能造成crash的风险\r\n- 修复下载错误时回调异常的问题\r\n- 修复同步下载问题\r\n- 库进行lint检查，更加稳定\r\n\r\n### 2017-08-09\r\n\r\n**V2.0.0**\r\n\r\n- 网络库从Rxjava升级到Rxjava2\r\n- 优化缓存策略实现\r\n- 修复同步请求回调问题\r\n- 修复put请求失败问题\r\n- 修改图片请求失败@url问题导致404错误\r\n- 修复多图片表单上传失败问题\r\n- Demo增加根据key获取缓存的演示\r\n- 修复post提交json到后台问题\r\n- 定位upObject失败原因，需要加转换器addConverterFactory(GsonConverterFactory.create())\r\n\r\n### 2017-07-21\r\n\r\n**V1.1.2**\r\n\r\n- put请求增加body支持\r\n\r\n\r\n\r\n### 2017-07-17\r\n\r\n**V1.1.1**\r\n\r\n- 修改了文件上传方式，增加设置uploadType\r\n\r\n\r\n\r\n### 2017-07-07\r\n\r\n**V1.1.0**\r\n\r\n- 修复了库中签名问题\r\n\r\n- 修复了数据解析为List<String>时类型转化错误\r\n\r\n\r\n\r\n### 2017-06-22\r\n\r\n**V1.0.8**\r\n\r\n- 优化了异常返回\r\n\r\n\r\n\r\n**V1.0.7**\r\n\r\n\r\n\r\n- 优化了代码\r\n- 修复了允许data返回为null\r\n\r\n\r\n\r\n### 2017-06-16\r\n\r\n**V1.0.6**\r\n\r\n- 修复重复初始化问题okhttpclient.Build()\r\n- 修复带有缓存的CacheResult返回list集合解析异常问题\r\n\r\n\r\n\r\n### 2017-06-13\r\n\r\n**V1.0.5**\r\n\r\n- 新增缓存模式CACHEANDREMOTEDISTINCT\r\n- 修复只配置默认初始化不配置高级初始化RxJavaCallAdapterFactory会导致网络访问失败问题\r\n\r\n\r\n\r\n### 2017-06-09\r\n\r\n**V1.0.4**\r\n\r\n- 修复回调单词拼写错误\r\n\r\n\r\n\r\n### 2017-06-08\r\n\r\n\r\n\r\n**V1.0.3 **\r\n\r\n- 初始版本上传"
        }
      ]
    }
  ]
}