{
  "metadata": {
    "timestamp": 1736609037738,
    "page": 277,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "yanzhenjie/NoHttp",
      "stars": 3709,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0859375,
          "content": "*.iml\n*.apk\n.gradle\nlocal.properties\n.DS_Store\ncaptures\n.externalNativeBuild\nbuild\n.idea"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.076171875,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2018 Yan Zhenjie\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 28.9208984375,
          "content": "# NoHttp\n\nQQ技术交流群：[46505645](https://jq.qq.com/?_wv=1027&k=5ImVHCl)\n\n**特别说明**：强烈建议开发者切换到另一个网络框架[Kalle](https://github.com/yanzhenjie/Kalle)，Kalle在架构设计上、Api设计上、功能实现上都更加健壮和完善，文档也比较全面。\n\nKalle开源地址：[https://github.com/yanzhenjie/Kalle](https://github.com/yanzhenjie/Kalle)  \nKalle文档地址：[http://yanzhenjie.github.io/Kalle](http://yanzhenjie.github.io/Kalle)\n\n**NoHttp依旧正常维护**，正在使用和即将要使用的同学可以放心使用。\n\n## 添加依赖\n如果使用HttpURLConnection作为网络层\n```groovy\nimplementation 'com.yanzhenjie.nohttp:nohttp:1.1.11'\n```\n\n如果要使用OkHttp作为网络层，请再依赖\n```groovy\nimplementation 'com.yanzhenjie.nohttp:okhttp:1.1.11'\n```\n\n### 一般初始化\n直接初始化后，一切采用默认设置。\n```java\nNoHttp.initialize(this);\n```\n\n### 高级初始化\n```java\nInitializationConfig config = InitializationConfig.newBuilder(context)\n    // 其它配置。\n    ...\n    .build();\n\nNoHttp.initialize(config);\n```\n\n关于超时，很多人都没有彻底理解或理解有误差，本人在知乎上写过一个答案，请参考：  \n[HTTP 在什么情况下会请求超时？](https://www.zhihu.com/question/21609463/answer/160100810)  \n\n下面介绍上方省略的**其它配置**的详情。\n\n```java\nInitializationConfig config = InitializationConfig.newBuilder(context)\n    // 全局连接服务器超时时间，单位毫秒，默认10s。\n    .connectionTimeout(30 * 1000)\n    // 全局等待服务器响应超时时间，单位毫秒，默认10s。\n    .readTimeout(30 * 1000)\n    // 配置缓存，默认保存数据库DBCacheStore，保存到SD卡使用DiskCacheStore。\n    .cacheStore(\n        // 如果不使用缓存，setEnable(false)禁用。\n        new DBCacheStore(context).setEnable(true)\n    )\n    // 配置Cookie，默认保存数据库DBCookieStore，开发者可以自己实现CookieStore接口。\n    .cookieStore(\n        // 如果不维护cookie，setEnable(false)禁用。\n        new DBCookieStore(context).setEnable(true)\n    )\n    // 配置网络层，默认URLConnectionNetworkExecutor，如果想用OkHttp：OkHttpNetworkExecutor。\n    .networkExecutor()\n    // 全局通用Header，add是添加，多次调用add不会覆盖上次add。\n    .addHeader()\n    // 全局通用Param，add是添加，多次调用add不会覆盖上次add。\n    .addParam()\n    .sslSocketFactory() // 全局SSLSocketFactory。\n    .hostnameVerifier() // 全局HostnameVerifier。\n    .retry(x) // 全局重试次数，配置后每个请求失败都会重试x次。\n    .build();\n```\n\n**说明**：\n1. 上方配置可以全部配置，也可以只配置其中一个或者几个。\n2. addHeader()、addParam()可以调用多次，且值不会被覆盖。\n3. 使用`DiskCacheStore()`时默认缓存到`context.getCacheDir()`目录，使用`DiskCacheStore(path)`指定缓存目录为`path`，不过要注意SD卡的读写权限和运行时权限：[AndPermission](https://github.com/yanzhenjie/AndPermission)。\n\n配置缓存位置为SD卡示例：\n```java\nInitializationConfig config = InitializationConfig.newBuilder(context)\n    .cacheStore(\n        new DiskCacheStore(context) // 保存在context.getCahceDir()文件夹中。\n        // new DiskCacheStore(path) // 保存在path文件夹中，path是开发者指定的绝对路径。\n    )\n    .build();\n```\n\n添加全局请求头、参数示例：   \n```java\nInitializationConfig config = InitializationConfig.newBuilder(context)\n    .addHeader(\"Token\", \"123\") // 全局请求头。\n    .addHeader(\"Token\", \"456\") // 全局请求头，不会覆盖上面的。\n    .addParam(\"AppVersion\", \"1.0.0\") // 全局请求参数。\n    .addParam(\"AppType\", \"Android\") // 全局请求参数。\n    .addParam(\"AppType\", \"iOS\") // 全局请求参数，不会覆盖上面的两个。\n    .build();\n```\n\n## 需要的权限\n```xml\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n```\n\n## 调试模式\n```java\nLogger.setDebug(true);// 开启NoHttp的调试模式, 配置后可看到请求过程、日志和错误信息。\nLogger.setTag(\"NoHttpSample\");// 打印Log的tag。\n```\n开启NoHttp的调试模式后可看到请求过程、日志和错误信息，基本不用抓包。可以看到请求头、请求数据、响应头、Cookie等，而且打印出的Log非常整齐。\n\n所以说，如果开发者使用过程中遇到什么问题了，开启调试模式，一切妖魔鬼怪都会现形的。\n\n## 第三方异步框架\n\n`NoHttp`的核心就是同步请求方法，`NoHttp`的异步方法（`AsyncRequestExecutor`、`RequestQueue`都是基于同步请求封装的），所以使用`RxJava`、`AsyncTask`等都可以很好的封装`NoHttp`，一个请求`String`的示例：\n```\nStringRequest request = new String(url, RequestMethod.GET);\nResponse<String> response = SyncRequestExecutor.INSTANCE.execute(request);\nif (response.isSucceed()) {\n    // 请求成功。\n} else {\n    // 请求失败，拿到错误：\n    Exception e = response.getException();\n}\n```\n\n下面是两个项目群里的基友基于RxJava + NoHttp封装的，开发者可以作为参考或者直接使用：\n1. [IRequest](https://github.com/yuanshenbin/IRequest)（袁慎彬）\n2. [NohttpRxUtils](https://github.com/LiqiNew/NohttpRxUtils)（李奇）\n\n# 同步请求和异步请求\n`NoHttp`的请求模块的核心其实就是同步请求：`SyncRequestExecutor`；`NoHttp`的异步请求分为两个类型，一个是异步请求执行器：`AsyncRequestExecutor`，另一个是请求队列：`RequestQueue`。\n\n## 同步请求\n一个请求`String`的示例：\n```java\nStringRequest req = new String(\"http://api.nohttp.net\"， RequestMethod.POST);\nResponse<String> response = SyncRequestExecutor.INSTANCE.execute(req);\nif (response.isSucceed()) {\n    // 请求成功。\n} else {\n    // 请求失败，拿到错误：\n    Exception e = response.getException();\n}\n```\n当然同步请求只适合在**子线程**中使用，因为Android主线程不允许发起网络请求。当然如果使用`RxJava`、`AsyncTask`等把同步请求封装一下也可以用在主线程，不过NoHttp提供了两种异步请求的方式，可以直接用在主线程中。\n\n## 异步请求-AsyncRequestExecutor\n```java\nStringRequest request = new StringRequest(\"http://api.nohttp.net\");\nCancelable cancel = AsyncRequestExecutor.INSTANCE.execute(0, request, new SimpleResponseListener<String>() {\n    @Override\n    public void onSucceed(int what, Response<String> response) {\n        // 请求成功。\n    }\n\n    @Override\n    public void onFailed(int what, Response<String> response) {\n        // 请求失败。\n    }\n});\n\n// 如果想取消请求：\ncancel.cancel();\n\n// 判断是否取消：\nboolean isCancelled = cancel.isCancelled();\n```\n这种方式是基于线程池的，它没有队列的优先级的特点了。\n\n## 异步请求-RequestQueue\n```java\nRequestQueue queue = NoHttp.newRequestQueue(); // 默认三个并发，此处可以传入并发数量。\n\n...\n// 发起请求：\nqueue.add(what, request, listener);\n\n...\n// 使用完后需要关闭队列释放CPU：\nqueue.stop();\n```\n\n也可以自己建立队列：\n```java\n// 也可以自己建立队列：\nRequestQueue queue = new RequestQueue(5);\nqueue.start(); // 开始队列。\n\n...\n// 发起请求：\nqueue.add(what, request, listener);\n\n...\n// 使用完后需要关闭队列：\nqueue.stop();\n```\n\n很多同学有一个习惯就是每发起一个请求就new一个队列，**这是绝对错误的用法**，例如某同学封装的一个方法：\n```java\npublic <T> void request(Request<T> request, SampleResponseListener<T> listener) {\n    RequestQueue queue = NoHttp.newRequestQueue(5);\n    queue.add(0, request, listener);\n}\n```\n再次声明一下，**上面的这段用法是错误的**。  \n\n对于想直接调用队列就能请求的开发者，`NoHttp`也提供了一个单例模式的用法：  \n```java\n// 比如请求队列单例模式：\nNoHttp.getRequestQueueInstance().add...\n\n...\n\n// 比如下载队列单例模式：\nNoHttp.getDownloadQueueInstance().add...\n```\n\n当然开发者可以直接使用上面讲到的异步请求执行器：`AsyncRequestExecutor`，这个是比较推荐的。\n\n### 队列的正确用法\n队列正确的用法有两种，一种是每一个页面使用一个队列，在页面退出时调用`queue.stop()`停止队列；另一种是全局使用同一个队列，在App退出时调用`queue.stop()`停止队列。本人比较推荐第二种方法，即全局使用同一个`RequestQueue`。\n\n用法一，开发者可以写一个`BaseActivity`，在`onCreate()`方法中建立`RequestQueue`，在`onDestory()`中销毁队列：  \n```java\npublic class BaseActivity extends Activity {\n\n    private RequestQueue queue;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        queue = NoHttp.newRequestQueue();\n    }\n    \n    // 提供给子类请求使用。\n    public <T> void request(int what, Request<T> request, SimpleResponseListener<T> listener) {\n        queue.add(what, request, listener);\n    }\n\n    @Override\n    public void onDestory() {\n        queue.stop();\n    }\n\n}\n```\n\n用法二，使用单例模式封装一个全局专门负责请求的类，使全局仅仅保持一个`RequestQueue`：\n```java\nStringRequest request = new StringRequest(\"http://api.nohttp.net\", RequestMethod.POST);\nCallServer.getInstance().request(0, request, listener);\n```\n\n上面的`CallServer`不是`NoHttp`提供的，而是需要开发者自己封装，因为这里可以写自己App的业务，所以这里开发者可以尽情发挥：\n```java\npublic class CallServer {\n\n    private static CallServer instance;\n\n    public static CallServer getInstance() {\n        if (instance == null)\n            synchronized (CallServer.class) {\n                if (instance == null)\n                    instance = new CallServer();\n            }\n        return instance;\n    }\n\n    private RequestQueue queue;\n\n    private CallServer() {\n        queue = NoHttp.newRequestQueue(5);\n    }\n\n    public <T> void request(int what, Request<T> request, SimpleResponseListener<T> listener) {\n        queue.add(what, request, listener);\n    }\n    \n    // 完全退出app时，调用这个方法释放CPU。\n    public void stop() {\n        queue.stop();\n    }\n}\n```\n\n**注意**：上面的出现的`listener`就是接受结果的回调`interface`，它实际上是`OnResponseListener`，它一种有四个方法需要实现，而有时候实现4个方法显得比较麻烦，所以`NoHttp`提供了一个默认实现类`SimpleResponseListener`，开发者可以仅仅实现自己需要实现的方法。\n\n> 上面在添加Request到队列中时，出现了一个`what`参数，它相当于使用`Handler`时的`Message`的`what`一样，仅仅是用于当一个`OnResponseListener`接受多个Request的请求结果时区分是哪个`Request`的响应结果的。\n\n# 其它特点和用法\n下面将会介绍`NoHttp`默认的几种请求，比如`String`、`Bitmap`、`JSONObject`等，一般清情况下，一部分开发者都是直接请求`String`，然后进行解析成`JSON`、`XML`、`JavaBean`等，无论使用任何网络框架，这都不是最好的办法，原因如下：\n\n1. 每一个请求都需要解析`String`成`XML`、`JSON`等，逻辑判断麻烦，代码冗余。\n2. 解析过程在主线程进行，数据量过大时解析过程必将耗时，会造成不好的用户体验（App假死）。\n\n所以本人写了一片如何结合业务直接请求`JavaBean`、`List`、`Map`、`Protobuf`的博文：  \n[http://blog.csdn.net/yanzhenjie1003/article/details/70158030](http://blog.csdn.net/yanzhenjie1003/article/details/70158030)\n\n## 请求不同数据的几种Request\n`NoHttp`请求什么样的数据是由`Request`决定的，`NoHttp`本身已经提供了请求`String`、`Bitmap`、`JSONObject`、`JSONArray`的`Request`：\n```java\n// 请求String：\nStringRequest request = new StringRequest(url, method);\n\n// 请求Bitmap：\nImageRequest request = new ImageRequest(url, method);\n\n// 请求JSONObject：\nJsonObjectRequest request = new JsonObjectRequest(url, method);\n\n// 请求JSONArray：\nJsonArrayRequest request = new JsonArrayRequest(url, method);\n```\n\n## 拼装URL\n这个能力是在1.1.3开始增加的，也是本次升级的一个亮点，增加拼装URL的方法，比如服务器是RESTFUL风格的API，请求用户信息时可能是这样一个URL：  \n```\nhttp://api.nohttp.net/rest/<userid>/userinfo\n```\n这里的`<userid>`就是用户名或者用户id，需要开发者动态替换，然后获取用户信息。以前是这样做的：\n```\nString userName = AppConfig.getUserName();\n\nString url = \"http://api.nohttp.net/rest/%1$s/userinfo\";\nurl = String.format(Locale.getDefault(), url, userName);\n\nStringRequest request = new StringRequest(url);\n...\n```\n现在可以这样做：\n```\nString url = \"http://api.nohttp.net/rest/\";\n\nStringRequest request = new StringRequest(url)\nrequest.path(AppConfig.getUserName())\nrequest.path(\"userinfo\")\n...\n```\n\n也就是说开发者可以动态拼装URL了。\n\n## 添加请求头\n请求头支持添加各种类型，比如`String`、`int`、`long`、`double`、`float`等等。\n```java\nStringRequest request = new StringRequest(url, RequestMethod.POST);\n   .addHeader(\"name\", \"yanzhenjie\") // String类型。\n   .addHeader(\"age\", \"18\") // int类型。\n   .setHeader(\"sex\", \"男\") // setHeader将会覆盖已经存在的key。\n   ...\n```\n\n## 添加参数\n请求头支持添加各种类型，比如`Binary`、`File`、`String`、`int`、`long`、`double`、`float`等等。\n```java\nStringRequest request = new StringRequest(url, RequestMethod.POST);\n   .add(\"name\", \"严振杰\") // String类型\n   .add(\"age\", 18) // int类型\n   .add(\"age\", \"20\") // add方法不会覆盖已经存在key，所以age将会有两个值：18, 20。\n   .set(\"sex\", \"女\") // set会覆盖已存在的key。\n   .set(\"sex\", \"男\") // 比如最终sex就只有一个值：男。\n\n    // 添加File\n   .add(\"head\", file)\n   .add(\"head\", new FileBinary(file))\n   // 添加Bitmap\n   .add(\"head\", new BitmapBinary(bitmap))\n   // 添加ByteArray\n   .add(\"head\", new ByteArrayBinary(byte[]))\n   // 添加InputStream\n   .add(\"head\", new InputStreamBinary(inputStream));\n```\n\n另外需要说明原来的`Request#add(Map<String, String>)`更新为`Request#add(Map<String, Object>)`，这样做的好处是喜欢使用`Map`封装参数的同学，可以在`Map`中添加以下几种类型的参数了：  \n```java\nString、File、Binary、List<String>、List<Binary>、List<File>、List<Object>\n```\n\n代码举例说明：\n```java\nMap<String, Object> params = new HashMap<>();\n\nparams.put(\"name\", \"yanzhenjie\");\nparams.put(\"head\", new File(path));\nparams.put(\"logo\", new FileBinary(file));\nparams.put(\"age\", 18);\nparams.put(\"height\", 180.5);\n\nList<String> hobbies = new ArrayList<>();\nhobbies.add(\"篮球\");\nhobbies.add(\"帅哥\");\nparams.put(\"hobbies\", hobbies);\n\nList<File> goods = new ArrayList<>();\ngoods.add(file1);\ngoods.add(file2);\nparams.put(\"goods\", goods);\n\nList<Object> otherParams = new ArrayList<>();\notherParams.add(\"yanzhenjie\");\notherParams.add(1);\notherParams.add(file);\notherParams.add(new FileBinary(file));\n\nparams.put(\"other\", otherParams);\n```\n\n当然，真实开发中第三种和文件一起使用同一个`key`请求，几乎不会存在，但是难免会`String`、`int`等使用同一个`key`请求。\n\n文件上传有两种形式，第一种：以表单的形式上传，第二种：以`request body`的形式上传，下面先介绍第一种表单的形式：\n\n* 单个文件\n```java\nStringRequest request = ...\nrequest.add(\"file\", new FileBinary(file));\n```\n\n* 多文件，以不同的`key`上传不同的多个文件  \n这里可以添加各种形式的文件，`File`、`Bitmap`、`InputStream`、`ByteArray`。\n\n```java\nStringRequest request = ...\nrequest.add(\"file1\", new FileBinary(File));\nrequest.add(\"file2\", new FileBinary(File));\nrequest.add(\"file3\", new InputStreamBinary(InputStream));\nrequest.add(\"file4\", new ByteArrayBinary(byte[]));\nrequest.add(\"file5\", new BitmapBinary(Bitmap));\n```\n\n* 多文件，以相同的`key`上传相同的多个文件\n```java\nStringRequest request = ...\nfileList.add(\"image\", new FileBinary(File));\nfileList.add(\"image\", new InputStreamBinary(InputStream));\nfileList.add(\"image\", new ByteArrayBinary(byte[]));\nfileList.add(\"image\", new BitmapBinary(Bitmap));\n```\n\n或者：  \n```java\nStringRequest request = ...;\n\nList<Binary> fileList = ...;\nfileList.add(new FileBinary(File));\nfileList.add(new InputStreamBinary(InputStream));\nfileList.add(new ByteArrayBinary(byte[]));\nfileList.add(new BitmapStreamBinary(Bitmap));\nrequest.add(\"file_list\", fileList);\n```\n\n第二种`request body`的形式是多种多样的，同时不仅可以提交文件，也可以提交任何流的数据，详情看下面**提交请求包体**的内容。  \n\n## 提交请求包体\n提交Body分为提交`Json`、提交`String`、提交`Xml`、提交流等，其实最终都是转成流提交的，所以开发者可以用这种方式提交文件。\n\n具体用法如下：  \n```java\n// 提交普通String\nrequest.setDefineRequestBody(String, ContentType);\n\n// 提交json字符串\nrequest.setDefineRequestBodyForJson(JsonString)\n\n// 提交jsonObject对象，其实还是json字符串\nrequest.setDefineRequestBodyForJson(JSONObject)\n\n// 提交xml字符串\nrequest.setDefineRequestBodyForXML(XmlString)\n\n// 提交字体Body，比如File（这跟表单上传不一样的），可以转为InputStream来提交\nrequest.setDefineRequestBody(InputStream, ContentType)\n```\n\n举一个提交文件的例子：\n```java\nFile file = ...;\nFileInputStream fileStream = new FileInputStream(file);\n\nStringRequest request = new StringRequest(url, RequestMethod.POST);\nrequest.setDefineRequestBody(fileStream, Headers.HEAD_VALUE_CONTENT_TYPE_OCTET_STREAM);\n```\n\n## 五大缓存模式\n`NoHttp`支持缓存到数据库、缓存到SD卡等，并且不论缓存在数据库或者SD，`NoHttp`都把数据进行了加密，需要在初始化的时候配置缓存的位置。\n\n需要注意的是，在6.0以上的手机中如果要缓存在SD卡，需要在请求之前，需要请求运行时权限，如果开发者不懂运行时权限，可以看这篇文章[Android 6.0 运行时权限管理最佳实践](http://blog.csdn.net/yanzhenjie1003/article/details/52503533)，本人推荐使用这个运行时权限管理框架：[AndPermission](https://github.com/yanzhenjie/AndPermission)。\n\n* 1、`Default`模式，也是没有设置缓存模式时的默认模式\n这个模式实现http协议中的内容，比如响应码是304时，当然还会结合E-Tag和LastModify等头。\n```java\nStringRequest request = new StringRequest(url, method);\nrequest.setCacheMode(CacheMode.DEFAULT);\n```\n\n* 2、 当请求服务器失败的时候，读取缓存\n请求服务器成功则返回服务器数据，如果请求服务器失败，读取缓存数据返回。\n```java\nStringRequest request = new StringRequest(url, method);\nrequest.setCacheMode(CacheMode.REQUEST_NETWORK_FAILED_READ_CACHE);\n```\n\n* 3、如果发现有缓存直接成功，没有缓存才请求服务器\nImageLoader的核心除了内存优化外，剩下一个就是发现把内地有图片则直接使用，没有则请求服务器。  \n\n请求`String`，缓存`String`：\n```java\nStringRequest request = new StringRequest(url, method);\n// 非标准Http协议，改变缓存模式为IF_NONE_CACHE_REQUEST_NETWORK\nrequest.setCacheMode(CacheMode.IF_NONE_CACHE_REQUEST_NETWORK);\n```\n\n请求图片，缓存图片：\n```java\nImageRequest request = new ImageRequest(url, method);\nrequest.setCacheMode(CacheMode.IF_NONE_CACHE_REQUEST_NETWORK);\n```\n\n* 4、仅仅请求网络\n无论如何也只会请求网络，也不支持http 304这种默认行为。\n```java\nImageRequest request = new ImageRequest(url, method);\nrequest.setCacheMode(CacheMode.ONLY_REQUEST_NETWORK);\n...\n```\n\n* 5、仅仅读取缓存\n无论如何仅仅读取缓存，不会请求网络和其它操作。\n```java\nRequest<Bitmap> request = NoHttp.createImageRequest(imageUrl);\nrequest.setCacheMode(CacheMode.ONLY_READ_CACHE);\n```\n\n**注意**：如果开发者想先得到缓存再请求网络，开发者可以先发起一个仅仅读取缓存的`Request`，然后发起一个仅仅请求网络的`Request`，**不过本人已经在准备NoHttp2.0了，到时候将会以一个全新的面貌和开发者们见面。**\n\n缓存模式支持缓存任何数据，因为`NoHttp`保存数据是转为`byte[]`，读取数据时是把`byte[]`转为开发者想要的数据，因此`NoHttp`的缓存可以支持任何自定义的`Request`。\n\n## 自定义请求\n`NoHttp`的所有自带请求都是继承`RestRequest`类，所以自定义请求也需要继承`RestRequest`，泛型写自己想要请求的数据类型，最后在`parseResponse()`方法中解析服务器数据成自己自己想要的数据类型即可。\n\n* FastJsonRequest\n```java\npublic class FastJsonRequest extends RestRequestor<JSONObject> {\n\n    public FastJsonRequest(String url) {\n\t    this(url, RequestMethod.GET);\n    }\n\n    public FastJsonRequest(String url, RequestMethod requestMethod) {\n\t    super(url, requestMethod);\n    }\n\n    @Override\n    public JSONObject parseResponse(Headers header, byte[] body) throws Throwable {\n\t    String result = StringRequest.parseResponseString(headers, body);\n\t    return JSON.parseObject(result);\n    }\n}\n```\n这只是一个自定义请求的演示，比如开发者还可以结合业务封装`Request`，可以直接请求到业务的`JavaBean`、`List`等复杂数据，具体请参考这篇博文：  \n[http://blog.csdn.net/yanzhenjie1003/article/details/70158030](http://blog.csdn.net/yanzhenjie1003/article/details/70158030)\n\n# 文件下载\n因为下载文件代码比较多，这里贴关键部分，具体的请参考demo。  \n\n`NoHttp`的下载模块的核心也是同步请求：`SyncDownloadExecutor`；`NoHttp`的异步异步下载只有下载队列一种方式：`DownloadQueue`，当然也可以使用`SyncDownloadExecutor`结合`RxJava`、`AsyncTask`封装其它形式的异步下载。\n\n## 同步下载-SyncDownloadExecutor\n```java\nDownloadRequest request = new DownloadRequest(url, RequestMethod.GET, fileFolder, true, true);\n    SyncDownloadExecutor.INSTANCE.execute(0, request, new SimpleDownloadListener() {\n        @Override\n        public void onStart(int what, boolean resume, long range, Headers headers, long size) {\n            // 开始下载，回调的时候说明文件开始下载了。\n            // 参数1：what。\n            // 参数2：是否是断点续传，从中间开始下载的。\n            // 参数3：如果是断点续传，这个参数非0，表示之前已经下载的文件大小。\n            // 参数4：服务器响应头。\n            // 参数5：文件总大小，可能为0，因为服务器可能不返回文件大小。\n        }\n\n        @Override\n        public void onProgress(int what, int progress, long fileCount, long speed) {\n            // 进度发生变化，服务器不返回文件总大小时不回调，因为没法计算进度。\n            // 参数1：what。\n            // 参数2：进度，[0-100]。\n            // 参数3：文件总大小，可能为0，因为服务器可能不返回文件大小。\n            // 参数4：下载的速度，含义为1S下载的byte大小，计算下载速度时：\n            //        int xKB = (int) speed / 1024; // 单位：xKB/S\n            //        int xM = (int) speed / 1024 / 1024; // 单位：xM/S\n        }\n\n        @Override\n        public void onFinish(int what, String filePath) {\n            // 下载完成，参数2为保存在本地的文件路径。\n        }\n});\n```\n\n必须要介绍一下`DownloadListener`，它是文件下载状态的监听器，`NoHttp`提供了一个默认实现，就是上面看到的`SimpleDownloadListener`，`DownloadListener`的完成实现如下：\n```java\nprivate DownloadListener downloadListener = new DownloadListener() {\n\t@Override\n\tpublic void onStart(int what, boolean resume, long preLenght, Headers header, long count) {\n\t    // 下载开始。\n\t}\n\n\t@Override\n\tpublic void onProgress(int what, int progress, long downCount, long speed) {\n\t\t// 更新下载进度和下载网速。\n\t}\n\n \t@Override\n\tpublic void onFinish(int what, String filePath) {\n\t    // 下载完成。\n \t}\n\n\t@Override\n\tpublic void onDownloadError(int what, StatusCode code, CharSequence message) {\n\t    // 下载发生错误。\n\t    // 参数2：错误类型，是枚举值，每一个枚举的具体请看javaDoc或者demo。\n\t    // 参数三：错误信息。\n\t}\n\n\t@Override\n\tpublic void onCancel(int what) {\n\t    // 下载被取消或者暂停。\n\t}\n};\n```\n\n## 异步下载-DownloadQueue\n```java\nDownloadQueue queue = NoHttp.newDownloadQueue(); // 默认三个并发，此处可以传入并发数量。\n\n...\n// 发起下载请求：\nqueue.add(what, request, listener);\n\n...\n// 使用完后需要关闭队列释放CPU：\nqueue.stop();\n```\n\n当然开发者可以自己建立队列：\n```java\n// 也可以自己建立队列：\nRequestQueue queue = new RequestQueue(5);\nqueue.start(); // 开始队列。\n\n...\n// 发起下载请求：\nqueue.add(what, request, listener);\n\n...\n// 使用完后需要关闭队列释放CPU：\nqueue.stop();\n```\n\n其它的使用方法和封装和上面的`RequestQueue`相同，请参考上面`RequestQueue`用法。\n\n## 创建请求\n`NoHttp`提供了两种构造下载请求的方法，第一种：手动指定下载文件名；第二种：由`NoHttp`根据服务器响应头、URL等自动确定文件名。\n\n### 方式一：指定文件名\n如果指定文件名，就会使用开发者指定的文件名去命名下载的文件（**推荐**）：\n```java\nDownloadRequest req = new DownloadRequest(url, method, folder, filename, range, deleteOld);\n// 参数1，文件的url。\n// 参数2，请求方法，一般为GET。\n// 参数3，要保存的文件名路径，须是绝对路径。\n// 参数4，文件最终的文件名，最终会用这个文件命名下载好的文件。\n// 参数5，是否断点续传，比如之前已经下载了50%，是否继续从50%处开始下载，否则从0开始下载。\n// 参数6，下载前检测到已存在你指定的相同文件名的文件时，是否删除重新下载，否则直接回调下载成功。\n```\n\n示例：\n```java\nString url = \"http://...\";\nString folder = ...;\nString filename = \"xx.apk\";\nDownloadRequest req = new DownloadRequest(url, RequestMethod.GET, folder, filename, true, true);\n```\n\n### 方式一：不指定文件名\n`NoHttp`会根据`url`或者服务器响应头的`Content-Disposition`自动命名文件：\n```java\nDownloadRequest req = new DownloadRequest(url, method, folder, range, deleteOld);\n// 参数含义同上。\n```\n\n**注意**：两种方式都是支持断点续传的。如果开发者设置了使用断点续传，但是文件服务器不支持，那么`NoHttp`会先尝试以断点的请求一次，如果请求失败，则再以普通下载的方式请求下载。\n\n## 暂停、继续、取消下载\n特别注意：`Http`下载其实没有暂停下载一说，其本质就是取消下载，继续下载其实利用的就是上面说的断点续传技术，断点续传需要服务器支持，一般`tomcat`、`apache`、`nginx`、`iis`都是支持的。\n\n### Nohttp暂停下载继续下载原理介绍\n`NoHttp`的demo中演示了暂停下载，继续下载等功能，其实就是下载到中途，暂停下载时调用取消下载，然后继续下载时重新建一个`DownloadRequest`并且使用断点续传下载，此时服务器就会从客户端上次取消下载时客户端已经接受的byte数处开始写出文件，客户端也从上次已经接受的byte数处开始接受并写入文件。\n\n示例：\n```java\nDownloadRequest request;\nString url = \"http://...\";\n\n// 开始或者继续一个下载。\npublic void startDownload() {\n    if(request != null)\n        request = new DownloadRequest(url, RequestMethod.GET, \"/sdcard/\", \"xx.apk\", true, true);\n    // 注意第5个参数，true表示断点续传。\n}\n\n// 暂停或者取消一个下载。\npublic void stopDownload() {\n    if(downloadRequest != null)\n        downloadRequest.cancel();\n}\n```\n\n更多的使用请参考sample。\n\n## 代码混淆\n如果你没有使用Https，NoHttp可以随意混淆，如果使用了Https，请添加如下混淆规则：\n```\n-keepclassmembers class ** {\n    private javax.net.ssl.SSLSocketFactory delegate;\n}\n```\n\n## 关于我\n:smile:关注一下我的微信公众号支持我一波  \n![微信二维码](http://img.blog.csdn.net/20161020083048694)  \n\n## License\n```text\nCopyright 2015 Yan Zhenjie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```"
        },
        {
          "name": "UPGRADE.md",
          "type": "blob",
          "size": 4.4208984375,
          "content": "﻿# NoHttp升级日志\n\n## 1.1.11\n普通请求和下载请求都添加了立刻取消的特性，无论是通过`Request#cancel()`、`ReuqestQueue#cancelBySign(Object)`或者`ReuqestQueue#cancelAll()`，取消后立即从队列移除，防止偶现的内存泄漏。\n\n## 1.1.3 \n**特别说明**：本次升级不影响API的使用，请大家放心升级，如果升级之后有问题，那你顺着网线来打我啊。嘿嘿，开个玩笑，如果升级后有问题，请立刻通过issue或者qq反馈给我，保证分分钟修复并发布新版。\n\n1. 兼容`Android4.0`以下使用`Https`不支持`TLSv1.1`，`TLSv1.2`的系统问题。\n2. 优化下载模块，根据url和相应头自动命名时也支持断点续传下载。\n3. 优化下载时多次重定向后不支持断点续传的问题。\n4. 初始化增加全局参数、全局请求头、全局`SSLSocketFactory`、全局`HostnameVerifier`、全局重试次数。\n5. 初始化由原来的`Config`类变为`InitializationConfig`类，并使用`Build`模式。\n6. 修复4.x手机上发生的内存泄漏问题。\n7. 去掉`HttpHeaders`类，把`Header`接口改为类并实现所有原接口方法。\n8. 去掉`DefaultDownloadRequest`类，把`RequestDownload`接口改为类并实现所有接口方法。\n9. 去掉`IProtocolRequest`接口，直接使用`ProtocolRequst`类。\n10. 把`Request`接口改为抽象类，提供结合队列使用的方法。\n11. 去掉`IBasicRequest`接口，直接向外提供`BasicRequest`类。\n12. `HeaderUtil`改为`HeaderUtils`，`NetUtil`改为`NetUtils`。\n13. 升级`OkHttp`为3.8.0，`OkHttp`原项目：[https://github.com/square/okhttp](https://github.com/square/okhttp)\n\n另外需要说明原来的`Request#add(Map<String, String>)`更新为`Request#add(Map<String, Object>)`，这样做的好处是喜欢使用`Map`封装参数的同学，可以在`Map`中添加以下几种类型的参数了：  \n```java\nString、File、Binary、List<String>、List<Binary>、List<File>、List<Object>\n```\n\n代码举例说明：\n```java\nMap<String, Object> params = new HashMap<>();\n\nparams.put(\"name\", \"yanzhenjie\");\nparams.put(\"head\", new File(path));\nparams.put(\"logo\", new FileBinary(file));\nparams.put(\"age\", 18);\nparams.put(\"height\", 180.5);\n\nList<String> hobbies = new ArrayList<>();\nhobbies.add(\"篮球\");\nhobbies.add(\"帅哥\");\nparams.put(\"hobbies\", hobbies);\n\nList<File> goods = new ArrayList<>();\ngoods.add(file1);\ngoods.add(file2);\nparams.put(\"goods\", goods);\n\nList<Object> otherParams = new ArrayList<>();\notherParams.add(\"yanzhenjie\");\notherParams.add(1);\notherParams.add(file);\notherParams.add(new FileBinary(file));\n\nparams.put(\"other\", otherParams);\n```\n\n当然，真实开发中第三种和文件一起使用同一个`key`请求，几乎不会存在，但是难免会`String`、`int`等使用同一个`key`请求。\n\n本次升级的一个亮点，增加拼装URL的方法，比如服务器是RESTFUL风格的API，请求用户信息时可能是这样一个URL：  \n```\nhttp://api.nohttp.net/rest/<userid>/userinfo\n```\n这里的`<userid>`就是用户名或者用户id，需要开发者动态替换，然后获取用户信息。以前是这样做的：\n```\nString userName = AppConfig.getUserName();\n\nString url = \"http://api.nohttp.net/rest/%1$s/userinfo\";\nurl = String.format(Locale.getDefault(), url, userName);\n\nStringRequest request = new StringRequest(url);\n...\n```\n\n现在可以这样做：\n```\nString url = \"http://api.nohttp.net/rest/\";\n\nStringRequest request = new StringRequest(url)\nrequest.path(AppConfig.getUserName())\nrequest.path(\"userinfo\")\n...\n```\n\n\n## 1.1.2\n 是对1.1.1的bug修复，无api的改动。  \n\n## 1.1.1\n 1. 修改包名为`com.yanzhenjie.com`，开发者从旧版升级后会发生编译错误，请使用全局替换，将`com.yolanda.nohttp`替换为`com.yanzhenjie.nohttp`即可。\n 因此依赖方式也由`com.yolanda.nohttp:nohttp:version`变为`com.yanzhenjie.nohttp:nohttp:version`\n 2. 新增一种非队列的异步请求方式，调用后会立即发起请求：`AsyncRequestExecutor`。\n 3. 修复StringRequest中按照服务器ContentType指定编码集解码（原来是由于解析contentType错误，默认utf-8解码）。\n 4. 优化缓存逻辑，在不使用缓存的时候可提升请求速度与性能。\n 5. 下载模块增加回调下载速度，具体可以参考[Sample](https://github.com/yanzhenjie/NoHttp)或者[使用文档](http://doc.nohttp.net)。\n 6. 兼容服务器要求重定向时Location中返回不完整url的问题。\n 7. 升级okhttp为3.6.0。"
        },
        {
          "name": "build.gradle",
          "type": "blob",
          "size": 0.4609375,
          "content": "apply from: \"config.gradle\"\n\nbuildscript {\n    repositories {\n        jcenter()\n        google()\n    }\n\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.1.3'\n        classpath 'com.github.dcendents:android-maven-gradle-plugin:2.1'\n        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'\n    }\n}\n\nallprojects {\n    repositories {\n        jcenter()\n        google()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}"
        },
        {
          "name": "config.gradle",
          "type": "blob",
          "size": 2.791015625,
          "content": "ext {\n    plugins = [library    : 'com.android.library',\n               application: 'com.android.application',\n               maven      : 'com.github.dcendents.android-maven',\n               bintray    : 'com.jfrog.bintray']\n\n    android = [applicationId          : \"com.yanzhenjie.nohttp.sample\",\n               compileSdkVersion      : 27,\n               buildToolsVersion      : \"27.0.3\",\n\n               librayMinSdkVersion    : 9,\n               libraryTargetSdkVersion: 27,\n\n               sampleMinSdkVersion    : 14,\n               sampleTargetSdkVersion : 27,\n\n               versionCode            : 121,\n               versionName            : \"1.1.11\",]\n\n    bintray = [version       : \"1.1.11\",\n\n               siteUrl       : 'https://github.com/yanzhenjie/NoHttp',\n               gitUrl        : 'git@github.com:yanzhenjie/NoHttp.git',\n\n               group         : \"com.yanzhenjie.nohttp\",\n\n               packaging     : 'aar',\n               name          : 'NoHttp',\n               description   : 'Synchronous and asynchronous network request framework for Android',\n\n               licenseName   : 'The Apache Software License, Version 2.0',\n               licenseUrl    : 'http://www.apache.org/licenses/LICENSE-2.0.txt',\n\n               developerId   : 'yanzhenjie',\n               developerName : 'yanzhenjie',\n               developerEmail: 'smallajax@foxmail.com',\n\n               binrayLibrary : \"\",\n               bintrayRepo   : \"maven\",\n               bintrayUser   : 'yolanda',\n               bintrayLicense: \"Apache-2.0\"]\n\n    dependencies = [okhttpUrl          : 'com.squareup.okhttp3:okhttp-urlconnection:3.11.0',\n\n                    nohttp             : 'com.yanzhenjie.nohttp:nohttp:1.1.11',\n                    okhttp             : 'com.yanzhenjie.nohttp:okhttp:1.1.11',\n\n                    junit              : 'junit:junit:4.12',\n                    expressoCore       : 'com.android.support.test.espresso:espresso-core:3.0.2',\n\n                    appCompat          : 'com.android.support:appcompat-v7:27.1.1',\n                    design             : 'com.android.support:design:27.1.1',\n                    cardView           : 'com.android.support:cardview-v7:27.1.1',\n                    recyclerView       : 'com.yanzhenjie:recyclerview-swipe:1.1.4',\n\n                    fastjson           : 'com.alibaba:fastjson:1.1.68.android',\n                    permission         : 'com.yanzhenjie:permission:2.0.0-rc11',\n                    loading            : 'com.yanzhenjie:loading:1.0.2',\n                    album              : 'com.yanzhenjie:album:2.1.1',\n                    glide              : 'com.github.bumptech.glide:glide:3.8.0',\n\n                    butterKnife        : 'com.jakewharton:butterknife:8.8.1',\n                    butterKnifeCompiler: 'com.jakewharton:butterknife-compiler:8.8.1']\n}"
        },
        {
          "name": "gradle",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradlew",
          "type": "blob",
          "size": 4.853515625,
          "content": "#!/usr/bin/env bash\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\"\"\n\nAPP_NAME=\"Gradle\"\nAPP_BASE_NAME=`basename \"$0\"`\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD=\"maximum\"\n\nwarn ( ) {\n    echo \"$*\"\n}\n\ndie ( ) {\n    echo\n    echo \"$*\"\n    echo\n    exit 1\n}\n\n# OS specific support (must be 'true' or 'false').\ncygwin=false\nmsys=false\ndarwin=false\ncase \"`uname`\" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\nesac\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG=\"$0\"\n# Need this for relative symlinks.\nwhile [ -h \"$PRG\" ] ; do\n    ls=`ls -ld \"$PRG\"`\n    link=`expr \"$ls\" : '.*-> \\(.*\\)$'`\n    if expr \"$link\" : '/.*' > /dev/null; then\n        PRG=\"$link\"\n    else\n        PRG=`dirname \"$PRG\"`\"/$link\"\n    fi\ndone\nSAVED=\"`pwd`\"\ncd \"`dirname \\\"$PRG\\\"`/\" >/dev/null\nAPP_HOME=\"`pwd -P`\"\ncd \"$SAVED\" >/dev/null\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n \"$JAVA_HOME\" ] ; then\n    if [ -x \"$JAVA_HOME/jre/sh/java\" ] ; then\n        # IBM's JDK on AIX uses strange locations for the executables\n        JAVACMD=\"$JAVA_HOME/jre/sh/java\"\n    else\n        JAVACMD=\"$JAVA_HOME/bin/java\"\n    fi\n    if [ ! -x \"$JAVACMD\" ] ; then\n        die \"ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\n    fi\nelse\n    JAVACMD=\"java\"\n    which java >/dev/null 2>&1 || die \"ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ \"$cygwin\" = \"false\" -a \"$darwin\" = \"false\" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ \"$MAX_FD\" = \"maximum\" -o \"$MAX_FD\" = \"max\" ] ; then\n            MAX_FD=\"$MAX_FD_LIMIT\"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn \"Could not set maximum file descriptor limit: $MAX_FD\"\n        fi\n    else\n        warn \"Could not query maximum file descriptor limit: $MAX_FD_LIMIT\"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS=\"$GRADLE_OPTS \\\"-Xdock:name=$APP_NAME\\\" \\\"-Xdock:icon=$APP_HOME/media/gradle.icns\\\"\"\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed \"$APP_HOME\"`\n    CLASSPATH=`cygpath --path --mixed \"$CLASSPATH\"`\n    JAVACMD=`cygpath --unix \"$JAVACMD\"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=\"\"\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS=\"$ROOTDIRS$SEP$dir\"\n        SEP=\"|\"\n    done\n    OURCYGPATTERN=\"(^($ROOTDIRS))\"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ \"$GRADLE_CYGPATTERN\" != \"\" ] ; then\n        OURCYGPATTERN=\"$OURCYGPATTERN|($GRADLE_CYGPATTERN)\"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in \"$@\" ; do\n        CHECK=`echo \"$arg\"|egrep -c \"$OURCYGPATTERN\" -`\n        CHECK2=`echo \"$arg\"|egrep -c \"^-\"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed \"$arg\"`\n        else\n            eval `echo args$i`=\"\\\"$arg\\\"\"\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- \"$args0\" ;;\n        (2) set -- \"$args0\" \"$args1\" ;;\n        (3) set -- \"$args0\" \"$args1\" \"$args2\" ;;\n        (4) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" ;;\n        (5) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" ;;\n        (6) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" ;;\n        (7) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" ;;\n        (8) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" ;;\n        (9) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" \"$args8\" ;;\n    esac\nfi\n\n# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules\nfunction splitJvmOpts() {\n    JVM_OPTS=(\"$@\")\n}\neval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS\nJVM_OPTS[${#JVM_OPTS[*]}]=\"-Dorg.gradle.appname=$APP_BASE_NAME\"\n\nexec \"$JAVACMD\" \"${JVM_OPTS[@]}\" -classpath \"$CLASSPATH\" org.gradle.wrapper.GradleWrapperMain \"$@\""
        },
        {
          "name": "gradlew.bat",
          "type": "blob",
          "size": 2.2587890625,
          "content": "@if \"%DEBUG%\" == \"\" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif \"%OS%\"==\"Windows_NT\" setlocal\n\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nset DEFAULT_JVM_OPTS=\n\nset DIRNAME=%~dp0\nif \"%DIRNAME%\" == \"\" set DIRNAME=.\nset APP_BASE_NAME=%~n0\nset APP_HOME=%DIRNAME%\n\n@rem Find java.exe\nif defined JAVA_HOME goto findJavaFromJavaHome\n\nset JAVA_EXE=java.exe\n%JAVA_EXE% -version >NUL 2>&1\nif \"%ERRORLEVEL%\" == \"0\" goto init\n\necho.\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:findJavaFromJavaHome\nset JAVA_HOME=%JAVA_HOME:\"=%\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\n\nif exist \"%JAVA_EXE%\" goto init\n\necho.\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:init\n@rem Get command-line arguments, handling Windowz variants\n\nif not \"%OS%\" == \"Windows_NT\" goto win9xME_args\nif \"%@eval[2+2]\" == \"4\" goto 4NT_args\n\n:win9xME_args\n@rem Slurp the command line arguments.\nset CMD_LINE_ARGS=\nset _SKIP=2\n\n:win9xME_args_slurp\nif \"x%~1\" == \"x\" goto execute\n\nset CMD_LINE_ARGS=%*\ngoto execute\n\n:4NT_args\n@rem Get arguments from the 4NT Shell from JP Software\nset CMD_LINE_ARGS=%$\n\n:execute\n@rem Setup the command line\n\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n\n@rem Execute Gradle\n\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\n\n:end\n@rem End local scope for the variables with windows NT shell\nif \"%ERRORLEVEL%\"==\"0\" goto mainEnd\n\n:fail\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\nrem the _cmd.exe /c_ return code!\nif  not \"\" == \"%GRADLE_EXIT_CONSOLE%\" exit 1\nexit /b 1\n\n:mainEnd\nif \"%OS%\"==\"Windows_NT\" endlocal\n\n:omega"
        },
        {
          "name": "nohttp",
          "type": "tree",
          "content": null
        },
        {
          "name": "okhttp",
          "type": "tree",
          "content": null
        },
        {
          "name": "sample",
          "type": "tree",
          "content": null
        },
        {
          "name": "settings.gradle",
          "type": "blob",
          "size": 0.0380859375,
          "content": "include ':nohttp', ':okhttp', ':sample'"
        }
      ]
    }
  ]
}