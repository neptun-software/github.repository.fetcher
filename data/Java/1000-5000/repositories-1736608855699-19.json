{
  "metadata": {
    "timestamp": 1736608855699,
    "page": 19,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "alibaba/QLExpress",
      "stars": 4930,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3232421875,
          "content": "# Created by .ignore support plugin (hsz.mobi)\n### Java template\n*.class\n!SelfDefineObject1.class\n\ntarget/*\n*.iml\n.idea/\ngen/\n\n\n# Mobile Tools for Java (J2ME)\n.mtj.tmp/\n\n# Package Files #\n*.jar\n*.war\n*.ear\n\n# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml\nhs_err_pid*\n\ntest.log\ntest-push.sh\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 31.76171875,
          "content": "QLExpress 最新的大版本 4.0 已经处于 Beta 阶段啦！ :confetti_ball:\n\n4.0 对 3 进行了大幅度重构，放下了部分历史包袱，拥抱更好的用户体验和表达能力。\n\n欢迎朋友们试用并给予反馈，[帮助文档](https://github.com/alibaba/QLExpress/blob/branch_version_4.0.0.dev/README.adoc)\n\n# QLExpress基本语法\n\n# 一、背景介绍\n\n由阿里的电商业务规则、表达式（布尔组合）、特殊数学公式计算（高精度）、语法分析、脚本二次定制等强需求而设计的一门动态脚本引擎解析工具。\n在阿里集团有很强的影响力，同时为了自身不断优化、发扬开源贡献精神，于2012年开源。\n\nQLExpress脚本引擎被广泛应用在阿里的电商业务场景，具有以下的一些特性:\n- 1、线程安全，引擎运算过程中的产生的临时变量都是threadlocal类型。\n- 2、高效执行，比较耗时的脚本编译过程可以缓存在本地机器，运行时的临时变量创建采用了缓冲池的技术，和groovy性能相当。\n- 3、弱类型脚本语言，和groovy，javascript语法类似，虽然比强类型脚本语言要慢一些，但是使业务的灵活度大大增强。\n- 4、安全控制,可以通过设置相关运行参数，预防死循环、高危系统api调用等情况。\n- 5、代码精简，依赖最小，250k的jar包适合所有java的运行环境，在android系统的低端pos机也得到广泛运用。\n\n# 二、依赖和调用说明\n\n```xml\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>QLExpress</artifactId>\n  <version>3.3.4</version>\n</dependency>\n```\n\n版本兼容性: [跳转查看](VERSIONS.md)\n\n```java\nExpressRunner runner = new ExpressRunner();\nDefaultContext<String, Object> context = new DefaultContext<String, Object>();\ncontext.put(\"a\", 1);\ncontext.put(\"b\", 2);\ncontext.put(\"c\", 3);\nString express = \"a + b * c\";\nObject r = runner.execute(express, context, null, true, false);\nSystem.out.println(r);\n```\n如果应用有让终端用户输入与执行 QLExpress 的功能，务必关注 [多级别安全控制](#4-多级别安全控制)，**将 QLExpress 的安全级别配置在白名单或以上。**\n\n# 三、语法介绍\n\n## 1、操作符和java对象操作\n### 普通java语法\n```java\n//支持 +,-,*,/,<,>,<=,>=,==,!=,<>【等同于!=】,%,mod【取模等同于%】,++,--,\n//in【类似sql】,like【sql语法】,&&,||,!,等操作符\n//支持for，break、continue、if then else 等标准的程序控制逻辑\nn = 10;\nsum = 0;\nfor(i = 0; i < n; i++) {\n   sum = sum + i;\n}\nreturn sum;\n\n//逻辑三元操作\na = 1;\nb = 2;\nmaxnum = a > b ? a : b;\n```\n\n### 和java语法相比，要避免的一些ql写法错误\n- 不支持try{}catch{}\n- 注释目前只支持 /** **/，不支持单行注释 //\n- 不支持java8的lambda表达式\n- 不支持for循环集合操作for (Item item : list)\n- 弱类型语言，请不要定义类型声明,更不要用Template（Map<String, List>之类的）\n- array的声明不一样\n- min,max,round,print,println,like,in 都是系统默认函数的关键字，请不要作为变量名\n\n```\n//java语法：使用泛型来提醒开发者检查类型\nkeys = new ArrayList<String>();\ndeviceName2Value = new HashMap<String, String>(7);\nString[] deviceNames = {\"ng\", \"si\", \"umid\", \"ut\", \"mac\", \"imsi\", \"imei\"};\nint[] mins = {5, 30};\n\n//ql写法：\nkeys = new ArrayList();\ndeviceName2Value = new HashMap();\ndeviceNames = [\"ng\", \"si\", \"umid\", \"ut\", \"mac\", \"imsi\", \"imei\"];\nmins = [5, 30];\n\n//java语法：对象类型声明\nFocFulfillDecisionReqDTO reqDTO = param.getReqDTO();\n//ql写法：\nreqDTO = param.getReqDTO();\n\n//java语法：数组遍历\nfor(Item item : list) {\n}\n//ql写法：\nfor(i = 0; i < list.size(); i++){\n    item = list.get(i);\n}\n\n//java语法：map遍历\nfor(String key : map.keySet()) {\n    System.out.println(map.get(key));\n}\n//ql写法：\nkeySet = map.keySet();\nobjArr = keySet.toArray();\nfor (i = 0; i < objArr.length; i++) {\n    key = objArr[i];\n    System.out.println(map.get(key));\n}\n```\n\n### java的对象操作\n```java\nimport com.ql.util.express.test.OrderQuery;\n//系统自动会import java.lang.*,import java.util.*;\n\nquery = new OrderQuery();           // 创建class实例，自动补全类路径\nquery.setCreateDate(new Date());    // 设置属性\nquery.buyer = \"张三\";                // 调用属性，默认会转化为setBuyer(\"张三\")\nresult = bizOrderDAO.query(query);  // 调用bean对象的方法\nSystem.out.println(result.getId()); // 调用静态方法\n```\n\n## 2、脚本中定义function\n```java\nfunction add(int a, int b){\n    return a + b;\n};\n\nfunction sub(int a, int b){\n    return a - b;\n};\n\na = 10;\nreturn add(a, 4) + sub(a, 9);\n```\n\n## 3、扩展操作符：Operator\n### 替换 if then else 等关键字\n\n```java\nrunner.addOperatorWithAlias(\"如果\", \"if\", null);\nrunner.addOperatorWithAlias(\"则\", \"then\", null);\nrunner.addOperatorWithAlias(\"否则\", \"else\", null);\n\nexpress = \"如果 (语文 + 数学 + 英语 > 270) 则 {return 1;} 否则 {return 0;}\";\nDefaultContext<String, Object> context = new DefaultContext<String, Object>();\nrunner.execute(express, context, null, false, false, null);\n```\n\n### 如何自定义Operator\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 定义一个继承自com.ql.util.express.Operator的操作符\n */\npublic class JoinOperator extends Operator {\n    public Object executeInner(Object[] list) throws Exception {\n        Object opdata1 = list[0];\n        Object opdata2 = list[1];\n        if (opdata1 instanceof List) {\n            ((List)opdata1).add(opdata2);\n            return opdata1;\n        } else {\n            List result = new ArrayList();\n            for (Object opdata : list) {\n                result.add(opdata);\n            }\n            return result;\n        }\n    }\n}\n```\n### 如何使用Operator\n\n```java\n//(1)addOperator\nExpressRunner runner = new ExpressRunner();\nDefaultContext<String, Object> context = new DefaultContext<String, Object>();\nrunner.addOperator(\"join\", new JoinOperator());\nObject r = runner.execute(\"1 join 2 join 3\", context, null, false, false);\nSystem.out.println(r); // 返回结果 [1, 2, 3]\n\n//(2)replaceOperator\nExpressRunner runner = new ExpressRunner();\nDefaultContext<String, Object> context = new DefaultContext<String, Object>();\nrunner.replaceOperator(\"+\", new JoinOperator());\nObject r = runner.execute(\"1 + 2 + 3\", context, null, false, false);\nSystem.out.println(r); // 返回结果 [1, 2, 3]\n\n//(3)addFunction\nExpressRunner runner = new ExpressRunner();\nDefaultContext<String, Object> context = new DefaultContext<String, Object>();\nrunner.addFunction(\"join\", new JoinOperator());\nObject r = runner.execute(\"join(1, 2, 3)\", context, null, false, false);\nSystem.out.println(r); // 返回结果 [1, 2, 3]\n```\n## 4、绑定java类或者对象的method\naddFunctionOfClassMethod + addFunctionOfServiceMethod\n```java\npublic class BeanExample {\n    public static String upper(String abc) {\n        return abc.toUpperCase();\n    }\n    public boolean anyContains(String str, String searchStr) {\n        char[] s = str.toCharArray();\n        for (char c : s) {\n            if (searchStr.contains(c+\"\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nrunner.addFunctionOfClassMethod(\"取绝对值\", Math.class.getName(), \"abs\", new String[] {\"double\"}, null);\nrunner.addFunctionOfClassMethod(\"转换为大写\", BeanExample.class.getName(), \"upper\", new String[] {\"String\"}, null);\n\nrunner.addFunctionOfServiceMethod(\"打印\", System.out, \"println\", new String[] { \"String\" }, null);\nrunner.addFunctionOfServiceMethod(\"contains\", new BeanExample(), \"anyContains\", new Class[] {String.class, String.class}, null);\n\nString express = \"取绝对值(-100); 转换为大写(\\\"hello world\\\"); 打印(\\\"你好吗？\\\"); contains(\"helloworld\",\\\"aeiou\\\")\";\nrunner.execute(express, context, null, false, false);\n```\n\n ## 5、macro 宏定义\n\n```java\nrunner.addMacro(\"计算平均成绩\", \"(语文+数学+英语)/3.0\");\nrunner.addMacro(\"是否优秀\", \"计算平均成绩>90\");\nIExpressContext<String, Object> context = new DefaultContext<String, Object>();\ncontext.put(\"语文\", 88);\ncontext.put(\"数学\", 99);\ncontext.put(\"英语\", 95);\nObject result = runner.execute(\"是否优秀\", context, null, false, false);\nSystem.out.println(r);\n//返回结果true\n```\n\n ## 6、编译脚本，查询外部需要定义的变量和函数。\n **注意以下脚本int和没有int的区别**\n\n```java\nString express = \"int 平均分 = (语文 + 数学 + 英语 + 综合考试.科目2) / 4.0; return 平均分\";\nExpressRunner runner = new ExpressRunner(true, true);\nString[] names = runner.getOutVarNames(express);\nfor(String s:names){\n    System.out.println(\"var : \" + s);\n}\n\n//输出结果：\nvar : 数学\nvar : 综合考试\nvar : 英语\nvar : 语文\n```\n\n## 7、关于不定参数的使用\n\n```java\n@Test\npublic void testMethodReplace() throws Exception {\n    ExpressRunner runner = new ExpressRunner();\n    IExpressContext<String, Object> expressContext = new DefaultContext<String, Object>();\n    runner.addFunctionOfServiceMethod(\"getTemplate\", this, \"getTemplate\", new Class[]{Object[].class}, null);\n\n    //(1)默认的不定参数可以使用数组来代替\n    Object r = runner.execute(\"getTemplate([11,'22', 33L, true])\", expressContext, null, false, false);\n    System.out.println(r);\n    //(2)像java一样,支持函数动态参数调用,需要打开以下全局开关,否则以下调用会失败\n    DynamicParamsUtil.supportDynamicParams = true;\n    r = runner.execute(\"getTemplate(11, '22', 33L, true)\", expressContext, null, false, false);\n    System.out.println(r);\n}\n\n//等价于getTemplate(Object[] params)\npublic Object getTemplate(Object... params) throws Exception{\n    String result = \"\";\n    for(Object obj:params){\n        result = result + obj + \",\";\n    }\n    return result;\n}\n```\n\n## 8、关于集合的快捷写法\n```java\n@Test\npublic void testSet() throws Exception {\n    ExpressRunner runner = new ExpressRunner(false, false);\n    DefaultContext<String, Object> context = new DefaultContext<String, Object>();\n    String express = \"abc = NewMap(1:1, 2:2); return abc.get(1) + abc.get(2);\";\n    Object r = runner.execute(express, context, null, false, false);\n    System.out.println(r);\n    express = \"abc = NewList(1, 2, 3); return abc.get(1) + abc.get(2)\";\n    r = runner.execute(express, context, null, false, false);\n    System.out.println(r);\n    express = \"abc = [1, 2, 3]; return abc[1] + abc[2];\";\n    r = runner.execute(express, context, null, false, false);\n    System.out.println(r);\n}\n```\n\n## 9、集合的遍历\n其实类似java的语法，只是ql不支持for(obj:list){}的语法，只能通过下标访问。\n```java\n//遍历map\nmap = new HashMap();\nmap.put(\"a\", \"a_value\");\nmap.put(\"b\", \"b_value\");\nkeySet = map.keySet();\nobjArr = keySet.toArray();\nfor (i = 0; i < objArr.length; i++) {\n    key = objArr[i];\n    System.out.println(map.get(key));\n}\n```\n\n# 四、运行参数和API列表介绍\n\nQLExpressRunner如下图所示，从语法树分析、上下文、执行过程三个方面提供二次定制的功能扩展。\n\n![QlExpress-detail.jpg](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/dec904b003aba15cbf1af2726914ddee.jpg)\n\n## 1、属性开关\n### isPrecise\n```java\n/**\n * 是否需要高精度计算\n */\nprivate boolean isPrecise = false;\n```\n\n> 高精度计算在会计财务中非常重要，java的float、double、int、long存在很多隐式转换，做四则运算和比较的时候其实存在非常多的安全隐患。\n> 所以类似汇金的系统中，会有很多BigDecimal转换代码。而使用QLExpress，你只要关注数学公式本身 _订单总价 = 单价 * 数量 + 首重价格 + （ 总重量 - 首重） * 续重单价_ ，然后设置这个属性即可，所有的中间运算过程都会保证不丢失精度。\n\n### isShortCircuit\n\n```java\n/**\n * 是否使用逻辑短路特性\n */\nprivate boolean isShortCircuit = true;\n```\n在很多业务决策系统中，往往需要对布尔条件表达式进行分析输出，普通的java运算一般会通过逻辑短路来减少性能的消耗。例如规则公式：\n_star > 10000 and shopType in ('tmall', 'juhuasuan') and price between (100, 900)_\n假设第一个条件 _star>10000_ 不满足就停止运算。但业务系统却还是希望把后面的逻辑都能够运算一遍，并且输出中间过程，保证更快更好的做出决策。\n\n参照单元测试:[ShortCircuitLogicTest.java](https://github.com/alibaba/QLExpress/blob/master/src/test/java/com/ql/util/express/test/logic/ShortCircuitLogicTest.java)\n\n### isTrace\n\n```java\n/**\n * 是否输出所有的跟踪信息，同时还需要log级别是DEBUG级别\n */\nprivate boolean isTrace = false;\n```\n这个主要是是否输出脚本的编译解析过程，一般对于业务系统来说关闭之后会提高性能。\n\n## 2、调用入参\n\n```java\n/**\n * 执行一段文本\n * @param expressString 程序文本\n * @param context 执行上下文，可以扩展为包含ApplicationContext\n * @param errorList 输出的错误信息List\n * @param isCache 是否使用Cache中的指令集,建议为true\n * @param isTrace 是否输出详细的执行指令信息，建议为false\n * @param aLog 输出的log\n * @return\n * @throws Exception\n */\nObject execute(String expressString, IExpressContext<String, Object> context, List<String> errorList, boolean isCache, boolean isTrace);\n```\n\n## 3、功能扩展API列表\nQLExpress主要通过子类实现Operator.java提供的以下方法来最简单的操作符定义，然后可以被通过addFunction或者addOperator的方式注入到ExpressRunner中。\n\n```java\npublic abstract Object executeInner(Object[] list) throws Exception;\n```\n\n比如我们几行代码就可以实现一个功能超级强大、非常好用的join操作符:\n```\n_list = 1 join 2 join 3;_         -> [1,2,3]\n_list = join(list, 4, 5, 6);_     -> [1,2,3,4,5,6]\n```\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JoinOperator extends Operator {\n    public Object executeInner(Object[] list) throws Exception {\n        List result = new ArrayList();\n        Object opdata1 = list[0];\n        if (opdata1 instanceof List) {\n            result.addAll((List)opdata1);\n        } else {\n            result.add(opdata1);\n        }\n        for (int i = 1; i < list.length; i++) {\n            result.add(list[i]);\n        }\n        return result;\n    }\n}\n```\n\n如果你使用Operator的基类OperatorBase.java将获得更强大的能力，基本能够满足所有的要求。\n\n### （1）function相关API\n\n```java\n//通过name获取function的定义\nOperatorBase getFunciton(String name);\n\n//通过自定义的Operator来实现类似：fun(a, b, c)\nvoid addFunction(String name, OperatorBase op);\n\n//fun(a, b, c) 绑定 object.function(a, b, c)对象方法\nvoid addFunctionOfServiceMethod(String name, Object aServiceObject, String aFunctionName, Class<?>[] aParameterClassTypes, String errorInfo);\n\n//fun(a, b, c) 绑定 Class.function(a, b, c)类方法\nvoid addFunctionOfClassMethod(String name, String aClassName, String aFunctionName, Class<?>[] aParameterClassTypes, String errorInfo);\n\n//给Class增加或者替换method，同时支持 a.fun(b), fun(a, b) 两种方法调用\n//比如扩展String.class的isBlank方法:\"abc\".isBlank()和isBlank(\"abc\")都可以调用\nvoid addFunctionAndClassMethod(String name, Class<?> bindingClass, OperatorBase op);\n```\n\n### （2）Operator相关API\n\n提到脚本语言的操作符，优先级、运算的目数、覆盖原始的操作符(+,-,*,/等等)都是需要考虑的问题，QLExpress统统帮你搞定了。\n\n```java\n//添加操作符号,可以设置优先级\nvoid addOperator(String name, Operator op);\nvoid addOperator(String name, String aRefOpername, Operator op);\n\n//替换操作符处理\nOperatorBase replaceOperator(String name, OperatorBase op);\n\n//添加操作符和关键字的别名，比如 if..then..else -> 如果。。那么。。否则。。\nvoid addOperatorWithAlias(String keyWordName, String realKeyWordName, String errorInfo);\n```\n\n### （3）宏定义相关API\nQLExpress的宏定义比较简单，就是简单的用一个变量替换一段文本，和传统的函数替换有所区别。\n\n```java\n//比如addMacro(\"天猫卖家\", \"userDO.userTag &1024 == 1024\")\nvoid addMacro(String macroName, String express);\n```\n\n### （4）java class的相关api\nQLExpress可以通过给java类增加或者改写一些method和field，比如 链式调用：\"list.join(\"1\").join(\"2\")\"，比如中文属性：\"list.长度\"。\n\n```java\n//添加类的属性字段\nvoid addClassField(String field, Class<?>bindingClass, Class<?>returnType, Operator op);\n\n//添加类的方法\nvoid addClassMethod(String name, Class<?>bindingClass, OperatorBase op);\n```\n\n> 注意，这些类的字段和方法是执行器通过解析语法执行的，而不是通过字节码增强等技术，所以只在脚本运行期间生效，不会对jvm整体的运行产生任何影响，所以是绝对安全的。\n\n### （4）语法树解析变量、函数的API\n\n> 这些接口主要是对一个脚本内容的静态分析，可以作为上下文创建的依据，也可以用于系统的业务处理。\n> 比如：计算 \"a + fun1(a) + fun2(a + b) + c.getName()\"\n> 包含的变量:a,b,c\n> 包含的函数:fun1,fun2\n\n```java\n//获取一个表达式需要的外部变量名称列表\nString[] getOutVarNames(String express);\nString[] getOutFunctionNames(String express);\n```\n\n### （5）语法解析校验api\n脚本语法是否正确，可以通过ExpressRunner编译指令集的接口来完成。\n```java\nString expressString = \"for(i = 0; i < 10; i++) {sum = i + 1;} return sum;\";\nInstructionSet instructionSet = expressRunner.parseInstructionSet(expressString);\n//如果调用过程不出现异常，指令集instructionSet就是可以被加载运行（execute）了！\n```\n\n### （6）指令集缓存相关的api\n因为QLExpress对文本到指令集做了一个本地HashMap缓存，通常情况下一个设计合理的应用脚本数量应该是有限的，缓存是安全稳定的，但是也提供了一些接口进行管理。\n```java\n//优先从本地指令集缓存获取指令集，没有的话生成并且缓存在本地\nInstructionSet getInstructionSetFromLocalCache(String expressString);\n//清除缓存\nvoid clearExpressCache();\n```\n\n### （7）安全风险控制\n#### 7.1 防止死循环\n```java\ntry {\n    express = \"sum = 0; for(i = 0; i < 1000000000; i++) {sum = sum + i;} return sum;\";\n    //可通过timeoutMillis参数设置脚本的运行超时时间:1000ms\n    Object r = runner.execute(express, context, null, true, false, 1000);\n    System.out.println(r);\n    throw new Exception(\"没有捕获到超时异常\");\n} catch (QLTimeOutException e) {\n    System.out.println(e);\n}\n```\n#### 7.1 防止调用不安全的系统api\n\n更加详细多级安全控制见 [多级别安全控制](#4-多级别安全控制)\n\n```java\nExpressRunner runner = new ExpressRunner();\nQLExpressRunStrategy.setForbiddenInvokeSecurityRiskMethods(true);\n\nDefaultContext<String, Object> context = new DefaultContext<String, Object>();\ntry {\n    express = \"System.exit(1);\";\n    Object r = runner.execute(express, context, null, true, false);\n    System.out.println(r);\n    throw new Exception(\"没有捕获到不安全的方法\");\n} catch (QLException e) {\n    System.out.println(e);\n}\n```\n\n### （8）增强上下文参数Context相关的api\n\n#### 8.1 与spring框架的无缝集成\n上下文参数 IExpressContext context 非常有用，它允许put任何变量，然后在脚本中识别出来。\n\n在实际中我们很希望能够无缝的集成到spring框架中，可以仿照下面的例子使用一个子类。\n\n```java\npublic class QLExpressContext extends HashMap<String, Object> implements IExpressContext<String, Object> {\n    private final ApplicationContext context;\n\n    // 构造函数，传入context 和 ApplicationContext\n    public QLExpressContext(Map<String, Object> map, ApplicationContext aContext) {\n        super(map);\n        this.context = aContext;\n    }\n\n    /**\n     * 抽象方法：根据名称从属性列表中提取属性值\n     */\n    public Object get(Object name) {\n        Object result;\n        result = super.get(name);\n        try {\n            if (result == null && this.context != null && this.context.containsBean((String)name)) {\n                // 如果在Spring容器中包含bean，则返回String的Bean\n                result = this.context.getBean((String)name);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return result;\n    }\n\n    public Object put(String name, Object object) {\n        return super.put(name, object);\n    }\n}\n```\n\n完整的demo参照 [SpringDemoTest.java](https://github.com/alibaba/QLExpress/blob/master/src/test/java/com/ql/util/express/test/spring/SpringDemoTest.java)\n\n#### 8.2 自定义函数操作符获取原始的context控制上下文\n\n自定义的Operator需要直接继承OperatorBase，获取到parent即可，可以用于在运行一组脚本的时候，直接编辑上下文信息，业务逻辑处理上也非常有用。\n\n```java\npublic class ContextMessagePutTest {\n    class OperatorContextPut extends OperatorBase {\n        public OperatorContextPut(String aName) {\n            this.name = aName;\n        }\n\n        @Override\n        public OperateData executeInner(InstructionSetContext parent, ArraySwap list) throws Exception {\n            String key = list.get(0).toString();\n            Object value = list.get(1);\n            parent.put(key, value);\n            return null;\n        }\n    }\n\n    @Test\n    public void test() throws Exception {\n        ExpressRunner runner = new ExpressRunner();\n        OperatorBase op = new OperatorContextPut(\"contextPut\");\n        runner.addFunction(\"contextPut\", op);\n        String express = \"contextPut('success', 'false'); contextPut('error', '错误信息'); contextPut('warning', '提醒信息')\";\n        IExpressContext<String, Object> context = new DefaultContext<String, Object>();\n        context.put(\"success\", \"true\");\n        Object result = runner.execute(express, context, null, false, true);\n        System.out.println(result);\n        System.out.println(context);\n    }\n}\n```\n## 4. 多级别安全控制\n\nQLExpress 与本地 JVM 交互的方式有：\n\n - 应用中的自定义函数/操作符/宏: 该部分不在 QLExpress 运行时的管控范围，属于应用开放给脚本的业务功能，不受安全控制，应用需要自行确保这部分是安全的\n - 在 QLExpress 运行时中发生的交互: 安全控制可以对这一部分进行管理, QLExpress 会开放相关的配置给应用\n   - 通过 `.` 操作符获取 Java 对象的属性或者调用 Java 对象中的方法\n   - 通过 `import` 可以导入 JVM 中存在的任何类并且使用, 默认情况下会导入 `java.lang`, `java.util` 以及 `java.util.stream`\n\n在不同的场景下，应用可以配置不同的安全级别，安全级别由低到高：\n\n1. 黑名单控制：QLExpress 默认会阻断一些高危的系统 API, 用户也可以自行添加, 但是开放对 JVM 中其他所有类与方法的访问, 最灵活, 但是很容易被反射工具类绕过，只适用于脚本安全性有其他严格控制的场景，禁止直接运行终端用户输入\n2. 白名单控制：QLExpress 支持编译时白名单和运行时白名单机制, 编译时白名单设置到类级别, 能够在语法检查阶段就暴露出不安全类的使用, 但是无法阻断运行时动态生成的类(比如通过反射), 运行时白名单能够确保运行时只可以直接调用有限的 Java 方法, 必须设置了运行时白名单, 才算是达到了这个级别\n\n3. 沙箱模式：QLExpress 作为一个语言沙箱, 只允许通过自定义函数/操作符/宏与应用交互, 不允许与 JVM 中的类产生交互\n\n### （1） 黑名单控制\n\n\n\nQLExpess 目前默认添加的黑名单有：\n\n- `java.lang.System.exit`\n- `java.lang.Runtime.exec`\n- `java.lang.ProcessBuilder.start`\n- `java.lang.reflect.Method.invoke`\n- `java.lang.reflect.Class.forName`\n- `java.lang.reflect.ClassLoader.loadClass`\n- `java.lang.reflect.ClassLoader.findClass`\n\n同时支持通过 `QLExpressRunStrategy.addSecurityRiskMethod` 额外添加\n\n`com.ql.util.express.example.MultiLevelSecurityTest#blockWhiteListControlTest`\n\n```java\n// 必须将该选项设置为 true\nQLExpressRunStrategy.setForbidInvokeSecurityRiskMethods(true);\n// 这里不区分静态方法与成员方法, 写法一致\n// 不支持重载, riskMethod 的所有重载方法都会被禁止\nQLExpressRunStrategy.addSecurityRiskMethod(RiskBean.class, \"riskMethod\");\nExpressRunner expressRunner = new ExpressRunner();\nDefaultContext<String, Object> context = new DefaultContext<>();\ntry {\n    expressRunner.execute(\"import com.ql.util.express.example.RiskBean;\" +\n                          \"RiskBean.riskMethod()\", context, null, true, false);\n    fail(\"没有捕获到不安全的方法\");\n} catch (Exception e) {\n    assertTrue(e.getCause() instanceof QLSecurityRiskException);\n}\n```\n\n\n\n### （2）白名单控制\n\n**编译期白名单：**\n\n编译期白名单是类维度的，脚本中只允许显式引用符合白名单条件的类，支持两种设置方式，精确设置某个类，以及设置某个类的全部子类。\n\n`com.ql.util.express.example.MultiLevelSecurityTest#compileWhiteListTest`\n\n```java\n// 设置编译期白名单\nQLExpressRunStrategy.setCompileWhiteCheckerList(Arrays.asList(\n    // 精确设置\n    CheckerFactory.must(Date.class),\n    // 子类设置\n    CheckerFactory.assignable(List.class)\n));\nExpressRunner expressRunner = new ExpressRunner();\n// Date 在编译期白名单中, 可以显示引用\nexpressRunner.execute(\"new Date()\", new DefaultContext<>(), null,\n                      false, true);\n// LinkedList 是 List 的子类, 符合白名单要求\nexpressRunner.execute(\"LinkedList ll = new LinkedList; ll.add(1); ll.add(2); ll\",\n                      new DefaultContext<>(), null, false, true);\ntry {\n    // String 不在白名单中, 不可以显示引用\n    // 但是隐式引用, a = 'mmm', 或者定义字符串常量 'mmm' 都是可以的\n    expressRunner.execute(\"String a = 'mmm'\", new DefaultContext<>(), null,\n                          false, true);\n} catch (Exception e) {\n    assertTrue(e.getCause() instanceof QLSecurityRiskException);\n}\n\n// Math 不在白名单中\n// 对于不满足编译期类型白名单的脚本无需运行, 即可通过 checkSyntax 检测出\nassertFalse(expressRunner.checkSyntax(\"Math.abs(-1)\"));\n```\n\n编译期白名单只能检测出脚本编译时能够确认的类型，任何运行时出现的类型都是无法检测的，诸如各种反射`Class.forName`, `ClassLoader.loadClass`，或者没有声明类型的变量等等，因为编译期白名单只能增加黑客的作案成本，是容易被绕过。因此建议编译期白名单只用来帮助脚本校验，如果需要接收终端用户输入，运行期白名单是务必要配置的。\n\n**运行期白名单：**\n\n如果有白名单设置，所有的黑名单设置就都会无效，以白名单为准。默认没有白名单设置。\n\n`com.ql.util.express.example.MultiLevelSecurityTest#blockWhiteListControlTest`\n\n```java\n// 必须将该选项设置为 true\nQLExpressRunStrategy.setForbidInvokeSecurityRiskMethods(true);\n// 有白名单设置时, 则黑名单失效\nQLExpressRunStrategy.addSecureMethod(RiskBean.class, \"secureMethod\");\n// 白名单中的方法, 允许正常调用\nexpressRunner.execute(\"import com.ql.util.express.example.RiskBean;\" +\n                      \"RiskBean.secureMethod()\", context, null, true, false);\ntry {\n    // java.lang.String.length 不在白名单中, 不允许调用\n    expressRunner.execute(\"'abcd'.length()\", context,\n                          null, true, false);\n    fail(\"没有捕获到不安全的方法\");\n} catch (Exception e) {\n    assertTrue(e.getCause() instanceof QLSecurityRiskException);\n}\n\n// setSecureMethods 设置方式\nSet<String> secureMethods = new HashSet<>();\nsecureMethods.add(\"java.lang.String.length\");\nsecureMethods.add(\"java.lang.Integer.valueOf\");\nQLExpressRunStrategy.setSecureMethods(secureMethods);\n// 白名单中的方法, 允许正常调用\nObject res = expressRunner.execute(\"Integer.valueOf('abcd'.length())\", context,\n                                   null, true, false);\nassertEquals(4, res);\ntry {\n    // java.lang.Long.valueOf 不在白名单中, 不允许调用\n    expressRunner.execute(\"Long.valueOf('abcd'.length())\", context,\n                          null, true, false);\n    fail(\"没有捕获到不安全的方法\");\n} catch (Exception e) {\n    assertTrue(e.getCause() instanceof QLSecurityRiskException);\n}\n```\n\n从上图中可以看出白名单有两种设置方式：\n\n- 添加：`QLExpressRunStrategy.addSecureMethod`\n- 置换：`QLExpressRunStrategy.setSecureMethods`\n\n在应用中使用的时，推荐将白名单配置在诸如 `etcd`,`configServer` 等配置服务中，根据需求随时调整。\n\n### （3）沙箱模式\n\n如果你厌烦上述复杂的配置，只是想完全关闭 QLExpress 和 Java 应用的自由交互，那么推荐使用沙箱模式。\n\n在沙箱模式中，脚本**不可以**：\n\n- import Java 类\n- 显式引用 Java 类，比如 `String a = 'mmm'`\n- 取 Java 类中的字段：`a = new Integer(11); a.value`\n- 调用 Java 类中的方法：`Math.abs(12)`\n\n脚本**可以**：\n\n- 使用 QLExpress 的自定义操作符/宏/函数，以此实现与应用的受控交互\n- 使用 `.` 操作符获取 `Map` 的 `key` 对应的 `value`，比如 `a` 在应用传入的表达式中是一个 `Map`，那么可以通过 `a.b` 获取\n- 所有不涉及应用 Java 类的操作\n\n`com.ql.util.express.example.MultiLevelSecurityTest#sandboxModeTest`\n\n```java\n// 开启沙箱模式\nQLExpressRunStrategy.setSandBoxMode(true);\nExpressRunner expressRunner = new ExpressRunner();\n// 沙箱模式下不支持 import 语句\nassertFalse(expressRunner.checkSyntax(\"import com.ql.util.express.example.RiskBean;\"));\n// 沙箱模式下不支持显式的类型引用\nassertFalse(expressRunner.checkSyntax(\"String a = 'abc'\"));\nassertTrue(expressRunner.checkSyntax(\"a = 'abc'\"));\n// 无法用 . 获取 Java 类属性或者 Java 类方法\ntry {\n    expressRunner.execute(\"'abc'.length()\", new DefaultContext<>(),\n                          null, false, true);\n    fail();\n} catch (QLException e) {\n    // 没有找到方法:length\n}\ntry {\n    DefaultContext<String, Object> context = new DefaultContext<>();\n    context.put(\"test\", new CustBean(12));\n    expressRunner.execute(\"test.id\", context,\n                          null, false, true);\n    fail();\n} catch (RuntimeException e) {\n    // 无法获取属性:id\n}\n\n// 沙箱模式下可以使用 自定义操作符/宏/函数 和应用进行交互\nexpressRunner.addFunction(\"add\", new Operator() {\n    @Override\n    public Object executeInner(Object[] list) throws Exception {\n        return (Integer) list[0] + (Integer) list[1];\n    }\n});\nassertEquals(3, expressRunner.execute(\"add(1,2)\", new DefaultContext<>(),\n                                      null, false, true));\n// 可以用 . 获取 map 的属性\nDefaultContext<String, Object> context = new DefaultContext<>();\nHashMap<Object, Object> testMap = new HashMap<>();\ntestMap.put(\"a\", \"t\");\ncontext.put(\"test\", testMap);\nassertEquals(\"t\", expressRunner.execute(\"test.a\", context,\n                                        null, false, true));\n```\n\n在沙箱模式下，为了进一步保障内存的安全，建议同时限制脚本能够申请的最大数组长度以及超时时间，设置方法如下：\n\n`com.ql.util.express.test.ArrayLenCheckTest`\n\n```java\n// 限制最大申请数组长度为10, 默认没有限制\nQLExpressRunStrategy.setMaxArrLength(10);\nExpressRunner runner = new ExpressRunner();\nString code = \"byte[] a = new byte[11];\";\ntry {\n    // 20ms 超时时间\n    runner.execute(code, new DefaultContext<>(), null, false, false, 20);\n    Assert.fail();\n} catch (QLException e) {\n}\n\nQLExpressRunStrategy.setMaxArrLength(-1);\n// 20ms 超时时间\nrunner.execute(code, new DefaultContext<>(), null, false, false, 20);\n```\n\n附录：\n[版本更新列表](VERSIONS.md)\n\n## links for us\n-  Gitter channel - Online chat room with QLExpress developers. [Gitter channel ](https://gitter.im/QLExpress/Lobby)\n-  email:tianqiao@alibaba-inc.com,baoxingjie@126.com\n-  wechat:371754252\n"
        },
        {
          "name": "VERSIONS.md",
          "type": "blob",
          "size": 7.9287109375,
          "content": "# QLExpress基本语法\n\n# 一、背景介绍\n\n由阿里的电商业务规则、表达式（布尔组合）、特殊数学公式计算（高精度）、语法分析、脚本二次定制等强需求而设计的一门动态脚本引擎解析工具。\n在阿里集团有很强的影响力，同时为了自身不断优化、发扬开源贡献精神，于2012年开源。\n先后出现了1.0版本和2.0版本，到3.0版本之后，引入了比较系统的语法树推导，使语法的功能大大增强和稳定。\n之前svn的开源地址： http://code.taobao.org/p/QLExpress/src/branches/\n\n# 二、版本升级可能会有的不兼容问题\n## 1、 版本3.2.3\n 引入了不兼容的修改, 将比较（==, >, >=, <. <=）由弱类型改成了强类型，比如在 3.2.2 中 1==\"1\" 为 true, 但是 3.2.3 及以后版本都是 false，升级时需要注意\n## 2、 版本3.3.1\n 去除 log4j 和 apache common log 的依赖， 原先部分 execute 参数中含有 common log ，所以部分 execute 签名有不兼容变更\n\n# 三、有记录的版本迭代\n\n## 1、3.0.7-SNAPSHOT 版本[2014-06-06 fixed]\nBigDecimal.divide()函数增加默认的策略BigDecimal.ROUND_HALF_UP，防止在高精度要求的除法计算时，某些情况下出现以下异常。\nava.lang.ArithmeticException: Non-terminating decimal expansion\n\n## 2、3.0.7版本[2015-01-08 fixed]\n增加ExpressRunner.getInstructionSetFromLocalCache()方法。支持阿里的某个业务系统，支持直接获取本地指令集缓存，作为业务的判断场景需求。\n\n## 3、3.0.8版本[2015-04-23 fixed]\n（1）增加指令集错误日志打印输出的控制。支付宝解析外部脚本文件，文件信息有可能出现错误，处理的时候打印log日志导致应用压力太大。\n（2）修复线上bug，该业务方不恰当的使用addFunctionMethod(class.name,methodName....)导致脚本运行期间每次去new Object（），效率变慢，影响了qps，换用了addServiceMethod（bean,methodName）之后得到解决。\n对classname-object做了一层缓存保护，保证即使误用也能够获取到较好地性能。\n\n## 4、3.0.9版本[2015-09-21 fixed] \n（1）修复多线程下的重大bug，token使用的分隔符号数组在多线程解析脚本的情况下，有可能出现数组排序异常，导致数组中的元素混乱。\n重新问题的单元用例：\n\nhttp://gitlab.alibaba-inc.com/alibaba-rule-platform/qlExpress2\n\ncom.ql.util.express.bugfix.CrashTest\n\n根本解决方案：在ExpressRunner创建的时候，就排序完毕，之后不再排序，保证多线程安全，同时也提升了编译器的性能和效率。\n临时解决方案：在脚本中，需要分割的地方加一些不可见字符，比如空格等。\n\n比如：\"单价*数量+运费\"   修改成 \"单价 * 数量 + 运费\" 就会不受这个bug影响\n\n目前要求所有核心系统版本升级到3.0.9及以上版本。\n```xml\n<dependency>\n  <groupId>com.taobao.util</groupId>\n  <artifactId>taobao-express</artifactId>\n  <version>3.0.9</version>\n</dependency>\n```\n \n\n\n\n## 5、3.0.11版本[2016-1]\n(1)解决了指令中引用ExpressRunner的问题，使用分离的ExpressRunner来解决指令集运行期间相互的影响。\n\n## 6、3.0.12版本[2016-08-03]\n（1）分支迁移到git上，字符集修改为utf-8\n\n## 7、3.0.13版本[2016-08-15]\n(1)玄难通过jprofile进行性能分析，对数组的创建、数据获取采用了swapArray方式，大量的较少了Array的创建。\n(2)补上遗漏的反射缓存。\n(3)对部分对象做缓存，进一步提升性能。\n(4)解决null关键字导出变量列表的时候的bug\n(5)注意：取消了ExpressRunner.java的以下接口，主要用在自己管理指令缓存，这个可以通过clearExpressCache()实现，所以不推荐使用，万一还是想使用这个接口，请升级到3.0.17版本。\npublic Object execute(InstructionSet[] instructionSets,IExpressContext<String,Object> context, List<String> errorList,\n                 boolean isTrace,boolean isCatchException, Log aLog)\n \n\n\n\n## 8、3.0.14版本[2016-09-13]\n(1)支持java不定参数的调用\n(2)提高数组定义的灵活性和准确性。\n\n## 9、3.0.15版本[2016-10-26]\n(1)支持Method导出，用于给菜鸟业务动态绑定函数使用\n\n## 10、3.0.16版本[2016-10-28]\n(1)支持在脚本中给任意的Object增加字段field或者方法method，比如增加string的方法，\"helloworld\".isNotBlank()或者\"helloworld\".长度  非常安全，只在脚本中生效，没有采用任何aop或者增强字节码的技术，不会影响外部的调用。\n\n## 11、3.0.17版本[2016-11-30]\n(1)考虑到老系统二方包的兼容，恢复了兼容接口ExpressRunner.execute(InstructionSet[] instructionSets....)但是不推荐使用。\n(2)bugfix 3.0.16版本特性的表达式，最后不return情况下的bug。\n\n## 12、3.0.18版本[2017-1-16]\n(1)来自开源用户的反馈，bugfix 使用addFunctionOfServiceMethod指令集无法序列化的问题。\n\n## 12、3.1.0版本[2017-3-27]\n(1)增加 | & ~ << >>位操作符\n(2)增加executeRule函数，打印出规则逻辑结构\n\n## 13、3.1.1版本[2017-4-5]\n(1)增加指令集的行数，出错的时候增加出错行数信息\n\n## 14、3.1.3版本[2017-6-4]\n(1)内部版本调整，避免其他的分支干扰，覆盖版本3.1.2版本\n\n## 15、3.1.4版本[2017-9-19]\n(1)增加instanceof 的操作符\n\n## 16、3.1.5版本[2017-11-17]\n(1)负号某些特殊情况下的解析bug：三元操作符，return\n\n## 17、3.1.6版本[2017-11-17]\n(1)bugfix 嵌套runner调用的时候，数据池的还原\n\n## 18、3.1.7版本[2017-11-17]\n(1)bugfix 在自定义操作符的情况下，调用 runner.getOutVarNames Api 可能引发的空指针问题\n\n## 18、3.1.8版本[2018-1-30]\n(1)增加扩展功能:ExpressRunner#setIgnoreConstChar(Boolean),设置可以忽略单字符操作，即 'a'自动变成\"a\"。\n\n## 3.2.1版本[2018-2-23]\n(1)增加扩展功能:ExpressRunner#setIgnoreConstChar(Boolean),设置可以忽略单字符操作，即 'a'自动变成\"a\"。\n\n(2)增加接口来支持绑定自定义classloader的class的method:ExpressRunner#addFunctionOfClassMethod(String name, Class<?> aClass,...)。\n\n## 3.2.2版本[2019-1-22]\n(1)android环境的重大优化：减少编译的内存消耗，堆栈溢出问题\n\n(2)空指针的保护策略：com.ql.util.express.config.QLExpressRunStrategy.setAvoidNullPointer(true)\n\n## 3.2.3版本[2019-6-18]\n(1)增加超时方法:TimeOutExceptionTest\n\n(2)安全审核方法:InvokeSecurityRiskMethodsTest\n\n(3)区分异常类型：ThrowExceptionTest\n\n(4)**引入了不兼容的修改**, 将比较（==, >, >=, <. <=）由弱类型改成了强类型，比如在 3.2.2 中 `1==\"1\"` 为 true, 但是 3.3.3 及以后版本都是 false，升级时需要注意\n## 3.2.4版本[2019-12-6]\n(1)增加null的数字比较方案\"1>null\"\":NullCompareTest\n\n## 3.2.5版本[2021-8-23]\n(1)支持强大的数组符号访问属性功能（List,Map,Array）：ArrayPropertyMixTest\n(2)支持lambda表达式，stream方式操作集合书写更高效（List,Map）：LambdaTest\n(3)解决数组类型的方法匹配bug：ArrayMisType\n\n## 3.2.6版本[2021-11-24]\n(1)彻底解决ExpressRunner重入问题，可以嵌套使用：RecursivelyRunnerTest\n(2)重磅特性：通过@QLAlias对字段和方法上添加注解，实现中文字段和中文方法调用：QLAliasTest\n\n## 3.2.7版本[2021-12-10]\n(1)QLAliasTest 添加set方法\n\n## 3.3.0版本[2022-04-09]\n\n(1)高精度计算下的溢出问题修复 com.ql.util.express.test.NumberOperatorCalculatorTest\n\n(2)多级别安全控制与沙箱模式 com.ql.util.express.example.MultiLevelSecurityTest\n\n## 3.3.1版本[2023-02-03]\n\n(1) #188 break/continue 问题修复\n(2)内置脚本 cache 改成 concurrentHashMap\n(3)去除 log4j 和 apache common log 的依赖， 原先部分 `execute` 参数中含有 common log ，所以部分 `execute` 签名有不兼容变更。可能会导致升级后编译不通过\n(4)#233 相关安全增强\n    a. 扩充默认黑名单\n    b. 支持通过 com.ql.util.express.config.QLExpressRunStrategy#setMaxArrLength 限制脚本一次最多申请数组的大小"
        },
        {
          "name": "pom.xml",
          "type": "blob",
          "size": 7.671875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.alibaba</groupId>\n    <artifactId>QLExpress</artifactId>\n    <packaging>jar</packaging>\n    <version>3.3.4</version>\n    <name>QLExpress</name>\n    <description>QLExpress is a powerful, lightweight, dynamic language for the Java platform aimed at improving developers’ productivity in different business scenes.\n    </description>\n    <url>https://github.com/alibaba/QLExpress</url>\n    <inceptionYear>2012</inceptionYear>\n\n    <licenses>\n        <license>\n            <name>Apache 2</name>\n            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>\n            <distribution>repo</distribution>\n            <comments>A business-friendly OSS license</comments>\n        </license>\n    </licenses>\n\n    <scm>\n        <connection>scm:git:git@github.com:alibaba/QLExpress.git</connection>\n        <developerConnection>scm:git:git@github.com:alibaba/QLExpress.git</developerConnection>\n        <url>git@github.com:alibaba/QLExpress.git</url>\n    </scm>\n\n    <issueManagement>\n        <url>https://github.com/alibaba/QLExpress/issues</url>\n        <system>GitHub Issues</system>\n    </issueManagement>\n\n    <organization>\n        <name>Alibaba Group</name>\n        <url>https://github.com/alibaba</url>\n    </organization>\n\n    <developers>\n        <developer>\n            <id>tianqiao</id>\n            <name>tianqiao</name>\n            <email>tianqiao@alibaba-inc.com</email>\n        </developer>\n        <developer>\n            <id>baoxingjie</id>\n            <name>baoxingjie</name>\n            <email>baoxingjie@126.com</email>\n        </developer>\n        <developer>\n            <id>qianghui</id>\n            <name>qianghui</name>\n            <email>qhlhl2010@gmail.com</email>\n        </developer>\n    </developers>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>commons-beanutils</groupId>\n            <artifactId>commons-beanutils</artifactId>\n            <version>1.9.4</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-lang</groupId>\n            <artifactId>commons-lang</artifactId>\n            <version>2.4</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.4</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.unitils</groupId>\n            <artifactId>unitils</artifactId>\n            <version>2.3</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring</artifactId>\n            <version>2.5.6</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <distributionManagement>\n        <snapshotRepository>\n            <id>ossrh</id>\n            <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n        </snapshotRepository>\n        <repository>\n            <id>oss</id>\n            <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>\n        </repository>\n    </distributionManagement>\n\n    <profiles>\n        <profile>\n            <id>deploy</id>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>org.apache.maven.plugins</groupId>\n                        <artifactId>maven-source-plugin</artifactId>\n                    </plugin>\n                    <plugin>\n                        <groupId>org.apache.maven.plugins</groupId>\n                        <artifactId>maven-javadoc-plugin</artifactId>\n                    </plugin>\n                    <!-- GPG plugin -->\n                    <plugin>\n                        <groupId>org.apache.maven.plugins</groupId>\n                        <artifactId>maven-gpg-plugin</artifactId>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n    </profiles>\n\n    <build>\n        <pluginManagement>\n            <plugins>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-compiler-plugin</artifactId>\n                    <configuration>\n                        <source>1.8</source>\n                        <target>1.8</target>\n                    </configuration>\n                </plugin>\n                <plugin>\n                    <artifactId>maven-source-plugin</artifactId>\n                    <version>2.1</version>\n                    <configuration>\n                        <attach>true</attach>\n                    </configuration>\n                    <executions>\n                        <execution>\n                            <phase>compile</phase>\n                            <goals>\n                                <goal>jar</goal>\n                            </goals>\n                        </execution>\n                    </executions>\n                </plugin>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-javadoc-plugin</artifactId>\n                    <version>2.1</version>\n                    <configuration>\n                        <aggregate>true</aggregate>\n                    </configuration>\n                    <executions>\n                        <execution>\n                            <id>attach-javadocs</id>\n                            <goals>\n                                <goal>jar</goal>\n                            </goals>\n                        </execution>\n                    </executions>\n                </plugin>\n                <plugin>\n                    <groupId>org.sonatype.plugins</groupId>\n                    <artifactId>nexus-staging-maven-plugin</artifactId>\n                    <version>1.6.7</version>\n                    <extensions>true</extensions>\n                    <configuration>\n                        <serverId>ossrh</serverId>\n                        <nexusUrl>https://oss.sonatype.org/</nexusUrl>\n                        <autoReleaseAfterClose>true</autoReleaseAfterClose>\n                    </configuration>\n                </plugin>\n                <!-- GPG -->\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-gpg-plugin</artifactId>\n                    <version>1.6</version>\n                    <executions>\n                        <execution>\n                            <phase>verify</phase>\n                            <goals>\n                                <goal>sign</goal>\n                            </goals>\n                            <configuration>\n                                <gpgArguments>\n                                    <arg>--pinentry-mode</arg>\n                                    <arg>loopback</arg>\n                                </gpgArguments>\n                            </configuration>\n                        </execution>\n                    </executions>\n                </plugin>\n            </plugins>\n        </pluginManagement>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n            </plugin>\n            <plugin>\n                <groupId>org.sonatype.plugins</groupId>\n                <artifactId>nexus-staging-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}