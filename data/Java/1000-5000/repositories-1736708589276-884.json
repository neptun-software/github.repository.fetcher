{
  "metadata": {
    "timestamp": 1736708589276,
    "page": 884,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hellokaton/30-seconds-of-java8",
      "stars": 2380,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.0244140625,
          "content": "# Created by .ignore support plugin (hsz.mobi)\n### Maven template\ntarget/\n.idea/\npom.xml.tag\npom.xml.releaseBackup\npom.xml.versionsBackup\npom.xml.next\nrelease.properties\ndependency-reduced-pom.xml\nbuildNumber.properties\n.mvn/timing.properties\n\n# Avoid ignoring Maven wrapper jar file (.jar files are usually ignored)\n!/.mvn/wrapper/maven-wrapper.jar\n### JetBrains template\n# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and Webstorm\n# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839\n\n# User-specific stuff:\n.idea/**/workspace.xml\n.idea/**/tasks.xml\n.idea/dictionaries\n\n# Sensitive or high-churn files:\n.idea/**/dataSources/\n.idea/**/dataSources.ids\n.idea/**/dataSources.xml\n.idea/**/dataSources.local.xml\n.idea/**/sqlDataSources.xml\n.idea/**/dynamic.xml\n.idea/**/uiDesigner.xml\n\n# Gradle:\n.idea/**/gradle.xml\n.idea/**/libraries\n\n# CMake\ncmake-build-debug/\n\n# Mongo Explorer plugin:\n.idea/**/mongoSettings.xml\n\n## File-based project format:\n*.iws\n\n## Plugin-specific files:\n\n# IntelliJ\nout/\n\n# mpeltonen/sbt-idea plugin\n.idea_modules/\n\n# JIRA plugin\natlassian-ide-plugin.xml\n\n# Cursive Clojure plugin\n.idea/replstate.xml\n\n# Crashlytics plugin (for Android Studio and IntelliJ)\ncom_crashlytics_export_strings.xml\ncrashlytics.properties\ncrashlytics-build.properties\nfabric.properties\n### Eclipse template\n\n.metadata\nbin/\ntmp/\n*.tmp\n*.bak\n*.swp\n*~.nib\nlocal.properties\n.settings/\n.loadpath\n.recommenders\n\n# External tool builders\n.externalToolBuilders/\n\n# Locally stored \"Eclipse launch configurations\"\n*.launch\n\n# PyDev specific (Python IDE for Eclipse)\n*.pydevproject\n\n# CDT-specific (C/C++ Development Tooling)\n.cproject\n\n# Java annotation processor (APT)\n.factorypath\n\n# PDT-specific (PHP Development Tools)\n.buildpath\n\n# sbteclipse plugin\n.target\n\n# Tern plugin\n.tern-project\n\n# TeXlipse plugin\n.texlipse\n\n# STS (Spring Tool Suite)\n.springBeans\n\n# Code Recommenders\n.recommenders/\n\n# Scala IDE specific (Scala & Java development for Eclipse)\n.cache-main\n.scala_dependencies\n.worksheet\n.vscode\n\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.125,
          "content": "language: java\n\njdk:\n  - oraclejdk8\n\nnotifications:\n  email: false\n\nsudo: false\n\nbefore_install:\n    - export TZ='Asia/Shanghai'"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 6.400390625,
          "content": "CC0 1.0 Universal\n\nStatement of Purpose\n\nThe laws of most jurisdictions throughout the world automatically confer\nexclusive Copyright and Related Rights (defined below) upon the creator and\nsubsequent owner(s) (each and all, an \"owner\") of an original work of\nauthorship and/or a database (each, a \"Work\").\n\nCertain owners wish to permanently relinquish those rights to a Work for the\npurpose of contributing to a commons of creative, cultural and scientific\nworks (\"Commons\") that the public can reliably and without fear of later\nclaims of infringement build upon, modify, incorporate in other works, reuse\nand redistribute as freely as possible in any form whatsoever and for any\npurposes, including without limitation commercial purposes. These owners may\ncontribute to the Commons to promote the ideal of a free culture and the\nfurther production of creative, cultural and scientific works, or to gain\nreputation or greater distribution for their Work in part through the use and\nefforts of others.\n\nFor these and/or other purposes and motivations, and without any expectation\nof additional consideration or compensation, the person associating CC0 with a\nWork (the \"Affirmer\"), to the extent that he or she is an owner of Copyright\nand Related Rights in the Work, voluntarily elects to apply CC0 to the Work\nand publicly distribute the Work under its terms, with knowledge of his or her\nCopyright and Related Rights in the Work and the meaning and intended legal\neffect of CC0 on those rights.\n\n1. Copyright and Related Rights. A Work made available under CC0 may be\nprotected by copyright and related or neighboring rights (\"Copyright and\nRelated Rights\"). Copyright and Related Rights include, but are not limited\nto, the following:\n\n  i. the right to reproduce, adapt, distribute, perform, display, communicate,\n  and translate a Work;\n\n  ii. moral rights retained by the original author(s) and/or performer(s);\n\n  iii. publicity and privacy rights pertaining to a person's image or likeness\n  depicted in a Work;\n\n  iv. rights protecting against unfair competition in regards to a Work,\n  subject to the limitations in paragraph 4(a), below;\n\n  v. rights protecting the extraction, dissemination, use and reuse of data in\n  a Work;\n\n  vi. database rights (such as those arising under Directive 96/9/EC of the\n  European Parliament and of the Council of 11 March 1996 on the legal\n  protection of databases, and under any national implementation thereof,\n  including any amended or successor version of such directive); and\n\n  vii. other similar, equivalent or corresponding rights throughout the world\n  based on applicable law or treaty, and any national implementations thereof.\n\n2. Waiver. To the greatest extent permitted by, but not in contravention of,\napplicable law, Affirmer hereby overtly, fully, permanently, irrevocably and\nunconditionally waives, abandons, and surrenders all of Affirmer's Copyright\nand Related Rights and associated claims and causes of action, whether now\nknown or unknown (including existing as well as future claims and causes of\naction), in the Work (i) in all territories worldwide, (ii) for the maximum\nduration provided by applicable law or treaty (including future time\nextensions), (iii) in any current or future medium and for any number of\ncopies, and (iv) for any purpose whatsoever, including without limitation\ncommercial, advertising or promotional purposes (the \"Waiver\"). Affirmer makes\nthe Waiver for the benefit of each member of the public at large and to the\ndetriment of Affirmer's heirs and successors, fully intending that such Waiver\nshall not be subject to revocation, rescission, cancellation, termination, or\nany other legal or equitable action to disrupt the quiet enjoyment of the Work\nby the public as contemplated by Affirmer's express Statement of Purpose.\n\n3. Public License Fallback. Should any part of the Waiver for any reason be\njudged legally invalid or ineffective under applicable law, then the Waiver\nshall be preserved to the maximum extent permitted taking into account\nAffirmer's express Statement of Purpose. In addition, to the extent the Waiver\nis so judged Affirmer hereby grants to each affected person a royalty-free,\nnon transferable, non sublicensable, non exclusive, irrevocable and\nunconditional license to exercise Affirmer's Copyright and Related Rights in\nthe Work (i) in all territories worldwide, (ii) for the maximum duration\nprovided by applicable law or treaty (including future time extensions), (iii)\nin any current or future medium and for any number of copies, and (iv) for any\npurpose whatsoever, including without limitation commercial, advertising or\npromotional purposes (the \"License\"). The License shall be deemed effective as\nof the date CC0 was applied by Affirmer to the Work. Should any part of the\nLicense for any reason be judged legally invalid or ineffective under\napplicable law, such partial invalidity or ineffectiveness shall not\ninvalidate the remainder of the License, and in such case Affirmer hereby\naffirms that he or she will not (i) exercise any of his or her remaining\nCopyright and Related Rights in the Work or (ii) assert any associated claims\nand causes of action with respect to the Work, in either case contrary to\nAffirmer's express Statement of Purpose.\n\n4. Limitations and Disclaimers.\n\n  a. No trademark or patent rights held by Affirmer are waived, abandoned,\n  surrendered, licensed or otherwise affected by this document.\n\n  b. Affirmer offers the Work as-is and makes no representations or warranties\n  of any kind concerning the Work, express, implied, statutory or otherwise,\n  including without limitation warranties of title, merchantability, fitness\n  for a particular purpose, non infringement, or the absence of latent or\n  other defects, accuracy, or the present or absence of errors, whether or not\n  discoverable, all to the greatest extent permissible under applicable law.\n\n  c. Affirmer disclaims responsibility for clearing rights of other persons\n  that may apply to the Work or any use thereof, including without limitation\n  any person's Copyright and Related Rights in the Work. Further, Affirmer\n  disclaims responsibility for obtaining any necessary consents, permissions\n  or other rights required for any use of the Work.\n\n  d. Affirmer understands and acknowledges that Creative Commons is not a\n  party to this document and has no duty or obligation with respect to this\n  CC0 or use of the Work.\n\nFor more information, please see\n<http://creativecommons.org/publicdomain/zero/1.0/>"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 35.498046875,
          "content": "# 30 seconds of java8\n\n[![License](https://img.shields.io/badge/license-CC0--1.0-blue.svg)](https://github.com/biezhi/30-seconds-of-java8/blob/master/LICENSE) \n[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](http://makeapullrequest.com) \n[![Travis Build](https://travis-ci.org/biezhi/30-seconds-of-java8.svg?branch=master)](https://travis-ci.org/biezhi/30-seconds-of-java8)\n[![@biezhi on zhihu](https://img.shields.io/badge/zhihu-%40biezhi-red.svg)](https://www.zhihu.com/people/biezhi)\n[![](https://img.shields.io/github/followers/biezhi.svg?style=social&label=Follow%20Me)](https://github.com/biezhi)\n\n> 你可以在30秒或更短时间内收集有用的Java8代码片段。\n\n- 使用 <kbd>Ctrl</kbd> + <kbd>F</kbd> 或者 <kbd>command</kbd> + <kbd>F</kbd> 来查找代码片段。\n- 代码片段基于 Java8，如果你还不熟悉可以在[这里](https://zhuanlan.zhihu.com/java8)学习。\n- 代码片段翻译自 [little-java-functions](https://github.com/shekhargulati/little-java-functions)\n\n## 目录\n\n### 📚 Array (数组相关)\n\n<details>\n<summary>详细信息</summary>\n\n* [`chunk`](#chunk)\n* [`countOccurrences`](#countoccurrences)\n* [`deepFlatten`](#deepflatten)\n* [`difference`](#difference)\n* [`differenceWith`](#differencewith)\n* [`distinctValuesOfArray`](#distinctvaluesofarray)\n* [`dropElements`](#dropelements)\n* [`dropRight`](#dropright)\n* [`everyNth`](#everynth)\n* [`filterNonUnique`](#filternonunique)\n* [`flatten`](#flatten)\n* [`flattenDepth`](#flattendepth)\n* [`groupBy`](#groupby)\n* [`head`](#head)\n* [`initial`](#initial)\n* [`initializeArrayWithRange`](#initializearraywithrange)\n* [`initializeArrayWithValues`](#initializearraywithvalues)\n* [`intersection`](#intersection)\n* [`isSorted`](#issorted)\n* [`join`](#join)\n* [`nthElement`](#nthelement)\n* [`pick`](#pick)\n* [`reducedFilter`](#reducedfilter)\n* [`remove`](#remove)\n* [`sample`](#sample)\n* [`sampleSize`](#samplesize)\n* [`shuffle`](#shuffle)\n* [`similarity`](#similarity)\n* [`sortedIndex`](#sortedindex)\n* [`symmetricDifference`](#symmetricdifference)\n* [`tail`](#tail)\n* [`take`](#take)\n* [`takeRight`](#takeright)\n* [`union`](#union)\n* [`without`](#without)\n* [`zip`](#zip)\n* [`zipObject`](#zipobject)\n\n</details>\n\n### ➗ Math (数学相关)\n\n<details>\n<summary>详细信息</summary>\n\n* [`average`](#average)\n* [`gcd`](#gcd)\n* [`lcm`](#lcm)\n* [`findNextPositivePowerOfTwo`](#findnextpositivepoweroftwo)\n* [`isEven`](#iseven)\n* [`isPowerOfTwo`](#ispoweroftwo)\n* [`generateRandomInt`](#generaterandomint)\n\n</details>\n\n### 📜 String (字符串相关)\n\n<details>\n<summary>详细信息</summary>\n\n* [`anagrams`](#anagrams)\n* [`byteSize`](#bytesize)\n* [`capitalize`](#capitalize)\n* [`capitalizeEveryWord`](#capitalizeeveryword)\n* [`countVowels`](#countvowels)\n* [`escapeRegExp`](#escaperegexp)\n* [`fromCamelCase`](#fromcamelcase)\n* [`isAbsoluteURL`](#isabsoluteurl)\n* [`isLowerCase`](#islowercase)\n* [`isUpperCase`](#isuppercase)\n* [`isPalindrome`](#ispalindrome)\n* [`isNumeric`](#isnumeric)\n* [`mask`](#mask)\n* [`reverseString`](#reversestring)\n* [`sortCharactersInString`](#sortcharactersinstring)\n* [`splitLines`](#splitlines)\n* [`toCamelCase`](#tocamelcase)\n* [`toKebabCase`](#tokebabcase)\n* [`match`](#match)\n* [`toSnakeCase`](#tosnakecase)\n* [`truncateString`](#truncatestring)\n* [`words`](#words)\n* [`stringToIntegers`](#stringtointegers)\n\n</details>\n\n### ⭕️ IO (IO流相关)\n\n<details>\n<summary>详细信息</summary>\n\n* [`convertInputStreamToString`](#convertinputstreamtostring)\n* [`readFileAsString`](#readfileasstring)\n* [`getCurrentWorkingDirectoryPath`](#getcurrentworkingdirectorypath)\n* [`tmpDirName`](#tmpdirname)\n\n</details>\n\n### ❌ Exception (异常相关)\n\n<details>\n<summary>详细信息</summary>\n\n* [`stackTraceAsString`](#stacktraceasstring)\n\n</details>\n\n### 🖥 System (系统相关)\n\n<details>\n<summary>详细信息</summary>\n\n- [`osName`](#osname)\n- [`isDebuggerEnabled`](#isdebuggerenabled)\n\n</details>\n\n### 💡 Class (类相关)\n\n<details>\n<summary>详细信息</summary>\n\n- [`getAllInterfaces`](#getallinterfaces)\n- [`IsInnerClass`](#isinnerclass)\n\n</details>\n\n### 💎 Enum (枚举相关)\n\n<details>\n<summary>详细信息</summary>\n\n- [`getEnumMap`](#getenummap)\n\n</details>\n\n## Array\n\n### chunk\n\n将数组分割成特定大小的小数组。\n\n```java\npublic static int[][] chunk(int[] numbers, int size) {\n    return IntStream.iterate(0, i -> i + size)\n            .limit((long) Math.ceil((double) numbers.length / size))\n            .mapToObj(cur -> Arrays.copyOfRange(numbers, cur, cur + size > numbers.length ? numbers.length : cur + size))\n            .toArray(int[][]::new);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### concat\n\n```java\npublic static <T> T[] concat(T[] first, T[] second) {\n    return Stream.concat(\n            Stream.of(first),\n            Stream.of(second)\n    ).toArray(i -> (T[]) Arrays.copyOf(new Object[0], i, first.getClass()));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### countOccurrences\n\n计算数组中某个值出现的次数。\n\n使用 `Arrays.stream().filter().count()` 计算等于指定值的值的总数。\n\n```java\npublic static long countOccurrences(int[] numbers, int value) {\n    return Arrays.stream(numbers)\n            .filter(number -> number == value)\n            .count();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### deepFlatten\n\n数组扁平化。\n\n使用递归实现，`Arrays.stream().flatMapToInt()`\n\n```java\npublic static int[] deepFlatten(Object[] input) {\n    return Arrays.stream(input)\n            .flatMapToInt(o -> {\n                if (o instanceof Object[]) {\n                    return Arrays.stream(deepFlatten((Object[]) o));\n                }\n                return IntStream.of((Integer) o);\n            }).toArray();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### difference\n\n返回两个数组之间的差异。\n\n从 b 中创建一个集合，然后在 a 上使用 `Arrays.stream().filter()` 只保留 b 中不包含的值。\n\n```java\npublic static int[] difference(int[] first, int[] second) {\n    Set<Integer> set = Arrays.stream(second).boxed().collect(Collectors.toSet());\n    return Arrays.stream(first)\n            .filter(v -> !set.contains(v))\n            .toArray();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### differenceWith\n\n从比较器函数不返回true的数组中筛选出所有值。\n\nint的比较器是使用IntbinaryPerator函数来实现的。\n\n使用 `Arrays.stream().filter()` 和 `Arrays.stream().noneMatch()` 查找相应的值。\n\n```java\npublic static int[] differenceWith(int[] first, int[] second, IntBinaryOperator comparator) {\n    return Arrays.stream(first)\n            .filter(a ->\n                    Arrays.stream(second)\n                            .noneMatch(b -> comparator.applyAsInt(a, b) == 0)\n            ).toArray();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### distinctValuesOfArray\n\n返回数组的所有不同值。 \n\n使用 `Arrays.stream().distinct()` 去除所有重复的值。\n\n```java\npublic static int[] distinctValuesOfArray(int[] elements) {\n    return Arrays.stream(elements).distinct().toArray();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### dropElements\n\n移除数组中的元素，直到传递的函数返回true为止。返回数组中的其余元素。 \n\n使用数组循环遍历数组，将数组的第一个元素删除，直到函数返回的值为真为止。返回其余的元素。\n\n```java\npublic static int[] dropElements(int[] elements, IntPredicate condition) {\n    while (elements.length > 0 && !condition.test(elements[0])) {\n        elements = Arrays.copyOfRange(elements, 1, elements.length);\n    }\n    return elements;\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### dropRight\n\n返回一个新数组，从右边移除n个元素。 \n\n检查n是否短于给定的数组，并使用 `Array.copyOfRange()` 以便对其进行相应的切片或返回一个空数组。\n\n```java\npublic static int[] dropRight(int[] elements, int n) {\n    if (n < 0) {\n        throw new IllegalArgumentException(\"n is less than 0\");\n    }\n    return n < elements.length\n            ? Arrays.copyOfRange(elements, 0, elements.length - n)\n            : new int[0];\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### everyNth\n\n返回数组中的每个第n个元素。 \n\n使用 `IntStream.range().filter()` 创建一个新数组，该数组包含给定数组的每个第n个元素。\n\n```java\npublic static int[] everyNth(int[] elements, int nth) {\n     return IntStream.range(0, elements.length)\n             .filter(i -> i % nth == nth - 1)\n             .map(i -> elements[i])\n             .toArray();\n }\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### indexOf\n\n查找数组中元素的索引，在不存在元素的情况下返回-1。 \n\n使用 `IntStream.range().filter()` 查找数组中元素的索引。\n\n```java\npublic static int indexOf(int[] elements, int el) {\n    return IntStream.range(0, elements.length)\n            .filter(idx -> elements[idx] == el)\n            .findFirst()\n            .orElse(-1);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### lastIndexOf\n\n查找数组中元素的最后索引，在不存在元素的情况下返回-1。 \n\n使用 `IntStream.iterate().limit().filter()` 查找数组中元素的索引。\n\n```java\npublic static int lastIndexOf(int[] elements, int el) {\n    return IntStream.iterate(elements.length - 1, i -> i - 1)\n            .limit(elements.length)\n            .filter(idx -> elements[idx] == el)\n            .findFirst()\n            .orElse(-1);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### filterNonUnique\n\n筛选出数组中的非唯一值。 \n\n对只包含唯一值的数组使用 `Arrays.stream().filter()`。\n\n```java\npublic static int[] filterNonUnique(int[] elements) {\n    return Arrays.stream(elements)\n            .filter(el -> indexOf(elements, el) != lastIndexOf(elements, el))\n            .distinct()\n            .toArray();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### flatten\n\n使数组扁平。\n\n使用 `Arrays.stream().flatMapToInt().toArray()` 创建一个新数组。\n\n```java\npublic static int[] flatten(Object[] elements) {\n    return Arrays.stream(elements)\n            .flatMapToInt(el -> el instanceof int[]\n                    ? Arrays.stream((int[]) el)\n                    : IntStream.of((int) el)\n            ).toArray();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### flattenDepth\n\n将数组压平到指定的深度。\n\n```java\npublic static Object[] flattenDepth(Object[] elements, int depth) {\n    if (depth == 0) {\n        return elements;\n    }\n    return Arrays.stream(elements)\n            .flatMap(el -> el instanceof Object[]\n                    ? Arrays.stream(flattenDepth((Object[]) el, depth - 1))\n                    : Arrays.stream(new Object[]{el})\n            ).toArray();\n\n\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### groupBy\n\n根据给定函数对数组元素进行分组。\n\n使用 `Arrays.stream().collect(Collectors.groupingBy())` 分组。\n\n```java\npublic static <T, R> Map<R, List<T>> groupBy(T[] elements, Function<T, R> func) {\n    return Arrays.stream(elements).collect(Collectors.groupingBy(func));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### initial\n\n返回数组中除去最后一个的所有元素。\n\n使用 `Arrays.copyOfRange()` 返回除最后一个之外的所有元素。\n\n```java\npublic static <T> T[] initial(T[] elements) {\n    return Arrays.copyOfRange(elements, 0, elements.length - 1);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### initializeArrayWithRange\n\n初始化一个数组，该数组包含在指定范围内的数字，传入 `start` 和 `end`。\n\n```java\npublic static int[] initializeArrayWithRange(int end, int start) {\n    return IntStream.rangeClosed(start, end).toArray();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### initializeArrayWithValues\n\n使用指定的值初始化并填充数组。\n\n```java\npublic static int[] initializeArrayWithValues(int n, int value) {\n    return IntStream.generate(() -> value).limit(n).toArray();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### intersection\n\n返回两个数组中存在的元素列表。 \n\n从第二步创建一个集合，然后在 a 上使用 `Arrays.stream().filter()` 来保存包含在 b 中的值。\n\n```java\npublic static int[] intersection(int[] first, int[] second) {\n    Set<Integer> set = Arrays.stream(second).boxed().collect(Collectors.toSet());\n    return Arrays.stream(first)\n            .filter(set::contains)\n            .toArray();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### isSorted\n\n如果数组按升序排序，则返回 `1`，如果数组按降序排序，返回 `-1`，如果没有排序，则返回 `0`。\n\n计算前两个元素的排序 `direction`。使用for循环对数组进行迭代，并对它们进行成对比较。如果 `direction` 发生变化，则返回 `0`，\n如果到达最后一个元素，则返回 `direction`。\n\n```java\npublic static <T extends Comparable<? super T>> int isSorted(T[] arr) {\n    final int direction = arr[0].compareTo(arr[1]) < 0 ? 1 : -1;\n    for (int i = 0; i < arr.length; i++) {\n        T val = arr[i];\n        if (i == arr.length - 1) return direction;\n        else if ((val.compareTo(arr[i + 1]) * direction > 0)) return 0;\n    }\n    return direction;\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### join\n\n将数组的所有元素连接到字符串中，并返回此字符串。\n\n使用 `IntStream.range` 创建一个指定索引的数组。然后，使用 `Stream.reduce` 将元素组合成字符串。\n\n```java\npublic static <T> String join(T[] arr, String separator, String end) {\n    return IntStream.range(0, arr.length)\n            .mapToObj(i -> new SimpleEntry<>(i, arr[i]))\n            .reduce(\"\", (acc, val) -> val.getKey() == arr.length - 2\n                    ? acc + val.getValue() + end\n                    : val.getKey() == arr.length - 1 ? acc + val.getValue() : acc + val.getValue() + separator, (fst, snd) -> fst);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### nthElement\n\n返回数组的第n个元素。\n\nUse `Arrays.copyOfRange()` 优先得到包含第n个元素的数组。 \n\n```Java\npublic static <T> T nthElement(T[] arr, int n) {\n    if (n > 0) {\n        return Arrays.copyOfRange(arr, n, arr.length)[0];\n    }\n    return Arrays.copyOfRange(arr, arr.length + n, arr.length)[0];\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### pick\n\n从对象中选择与给定键对应的键值对。\n\n使用 `Arrays.stream` 过滤 `arr` 中存在的所有键。然后，使用 `Collectors.toMap` 将所有的key转换为Map。\n\n```java\npublic static <T, R> Map<T, R> pick(Map<T, R> obj, T[] arr) {\n    return Arrays.stream(arr)\n            .filter(obj::containsKey)\n            .collect(Collectors.toMap(k -> k, obj::get));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### reducedFilter\n\n根据条件筛选对象数组，同时筛选出未指定的键。\n\n使用 `Arrays.stream().filter()` 根据谓词 `fn` 过滤数组，以便返回条件为真的对象。\n对于每个过滤的Map对象，创建一个新的Map，其中包含 `keys` 中的键。最后，将Map对象收集到一个数组中。\n\n```java\npublic static Map<String, Object>[] reducedFilter(Map<String, Object>[] data, String[] keys, Predicate<Map<String, Object>> fn) {\n    return Arrays.stream(data)\n            .filter(fn)\n            .map(el -> Arrays.stream(keys).filter(el::containsKey)\n                    .collect(Collectors.toMap(Function.identity(), el::get)))\n            .toArray((IntFunction<Map<String, Object>[]>) Map[]::new);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### sample\n\n从数组中返回一个随机元素。\n\n使用 `Math.Randoman()` 生成一个随机数，然后将它乘以数组的 `length`，然后使用 `Math.floor()` 获得一个最近的整数，该方法也适用于字符串。\n\n```java\npublic static <T> T sample(T[] arr) {\n    return arr[(int) Math.floor(Math.random() * arr.length)];\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### sampleSize\n\n从 `array` 到 `array` 大小的唯一键获取 `n` 个随机元素。\n\n根据[Fisher-Yates算法](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)，使用 `Array.copyOfRange()` 获得优先的 `n` 个元素。\n\n```java\npublic static <T> T[] sampleSize(T[] input, int n) {\n    T[] arr = Arrays.copyOf(input, input.length);\n    int length = arr.length;\n    int m = length;\n    while (m > 0) {\n        int i = (int) Math.floor(Math.random() * m--);\n        T tmp = arr[i];\n        arr[i] = arr[m];\n        arr[m] = tmp;\n    }\n    return Arrays.copyOfRange(arr, 0, n > length ? length : n);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### shuffle\n\n将数组值的顺序随机化，返回一个新数组。\n\n根据 [Fisher-Yates 算法](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle) 重新排序数组的元素。\n\n```java\npublic static <T> T[] shuffle(T[] input) {\n    T[] arr = Arrays.copyOf(input, input.length);\n    int length = arr.length;\n    int m = length;\n    while (m > 0) {\n        int i = (int) Math.floor(Math.random() * m--);\n        T tmp = arr[i];\n        arr[i] = arr[m];\n        arr[m] = tmp;\n    }\n    return arr;\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### similarity\n\n返回出现在两个数组中的元素数组。\n\n使用 `Arrays.stream().filter()` 移除，然后使用 `Arrays.stream().anyMatch()` 匹配 `second` 部分的值。\n\n```java\npublic static <T> T[] similarity(T[] first, T[] second) {\n    return Arrays.stream(first)\n            .filter(a -> Arrays.stream(second).anyMatch(b -> Objects.equals(a, b)))\n            // Make a new array of first's runtime type, but empty content:\n            .toArray(i -> (T[]) Arrays.copyOf(new Object[0], i, first.getClass()));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### sortedIndex\n\n返回值应该插入到数组中的最低索引，以保持其排序顺序。\n\n检查数组是否按降序（松散地）排序。 使用 `IntStream.range().filter()` 来找到元素应该被插入的合适的索引。\n\n```java\npublic static <T extends Comparable<? super T>> int sortedIndex(T[] arr, T el) {\n    boolean isDescending = arr[0].compareTo(arr[arr.length - 1]) > 0;\n    return IntStream.range(0, arr.length)\n            .filter(i -> isDescending ? el.compareTo(arr[i]) >= 0 : el.compareTo(arr[i]) <= 0)\n            .findFirst()\n            .orElse(arr.length);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### symmetricDifference\n\n返回两个数组之间的对称差异。\n\n从每个数组中创建一个 `Set`，然后使用 `Arrays.stream().filter()` 来保持其他值不包含的值。最后，连接两个数组并创建一个新数组并返回。\n\n```java\npublic static <T> T[] symmetricDifference(T[] first, T[] second) {\n    Set<T> sA = new HashSet<>(Arrays.asList(first));\n    Set<T> sB = new HashSet<>(Arrays.asList(second));\n\n    return Stream.concat(\n            Arrays.stream(first).filter(a -> !sB.contains(a)),\n            Arrays.stream(second).filter(b -> !sA.contains(b))\n    ).toArray(i -> (T[]) Arrays.copyOf(new Object[0], i, first.getClass()));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### tail\n\n返回数组中除第一个元素外的所有元素。\n\n如果数组的长度大于1，则返回 `Arrays.copyOfRange(1)`，否则返回整个数组。\n\n```java\npublic static <T> T[] tail(T[] arr) {\n    return arr.length > 1\n            ? Arrays.copyOfRange(arr, 1, arr.length)\n            : arr;\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### take\n\n返回一个从开头删除n个元素的数组。\n\n```java\npublic static <T> T[] take(T[] arr, int n) {\n    return Arrays.copyOfRange(arr, 0, n);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### takeRight\n\n返回从末尾移除n个元素的数组。\n\n使用 `Arrays.copyOfRange()` 用从末尾取来的 `N` 个元素来创建一个数组。\n\n```java\npublic static <T> T[] takeRight(T[] arr, int n) {\n    return Arrays.copyOfRange(arr, arr.length - n, arr.length);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### union\n\n返回两个数组中任何一个中存在的每个元素一次。\n\n使用 `a` 和 `b` 的所有值创建一个 `Set`，并将其转换为数组。\n\n```Java\npublic static <T> T[] union(T[] first, T[] second) {\n    Set<T> set = new HashSet<>(Arrays.asList(first));\n    set.addAll(Arrays.asList(second));\n    return set.toArray((T[]) Arrays.copyOf(new Object[0], 0, first.getClass()));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### without\n\n筛选出具有指定值之一的数组的元素。\n\n使用 `Arrays.strean().filter()` 创建一个数组，排除(使用 `!Arrays.asList(elements).contains()`)所有命中的值。\n\n```java\npublic static <T> T[] without(T[] arr, T... elements) {\n    List<T> excludeElements = Arrays.asList(elements);\n    return Arrays.stream(arr)\n            .filter(el -> !excludeElements.contains(el))\n            .toArray(i -> (T[]) Arrays.copyOf(new Object[0], i, arr.getClass()));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### zip\n\n根据原始数组中的位置创建元素数组。\n\n```java\npublic static List<Object[]> zip(Object[]... arrays) {\n    OptionalInt max = Arrays.stream(arrays).mapToInt(arr -> arr.length).max();\n    return IntStream.range(0, max.getAsInt())\n            .mapToObj(i -> Arrays.stream(arrays)\n                    .map(arr -> i < arr.length ? arr[i] : null)\n                    .toArray())\n            .collect(Collectors.toList());\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### zipObject\n\n给定有效的属性标识符数组和值数组，返回将属性与值关联的对象。\n\n```java\npublic static Map<String, Object> zipObject(String[] props, Object[] values) {\n    return IntStream.range(0, props.length)\n            .mapToObj(i -> new SimpleEntry<>(props[i], i < values.length ? values[i] : null))\n            .collect(\n                    HashMap::new, (m, v) -> m.put(v.getKey(), v.getValue()), HashMap::putAll);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n## Maths\n\n### average\n\n返回两个或两个以上数字的平均值。\n\n```java\npublic static double average(int[] arr) {\n    return IntStream.of(arr)\n            .average()\n            .orElseThrow(() -> new IllegalArgumentException(\"Array is empty\"));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### gcd\n\n计算一系列数字的最大公约数(gcd)。\n\n使用 `Arrays.stream().reduce()` 和 GCD（使用递归公式）计算一组数字的最大公约数。\n\n```java\npublic static OptionalInt gcd(int[] numbers) {\n    return Arrays.stream(numbers)\n            .reduce((a, b) -> gcd(a, b));\n}\n\nprivate static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### lcm\n\n计算数字数组的最低公共倍数(LCM)。\n\n使用 `Arrays.stream().reduce()` 和 LCM公式(使用递归)来计算数字数组的最低公共倍数。\n\n```java\npublic static OptionalInt lcm(int[] numbers) {\n    IntBinaryOperator lcm = (x, y) -> (x * y) / gcd(x, y);\n    return Arrays.stream(numbers)\n            .reduce((a, b) -> lcm.applyAsInt(a, b));\n}\n\nprivate static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### findNextPositivePowerOfTwo\n\n查找大于或等于该值的下一个幂。\n\n该方法使用左移运算符将1与右侧的值位移。右侧使用 `Integer.numberOfLeadingZeros`方法。\n`001 << 2` would be `100`. `100` in decimal is equal to `4`.\n\n`Integer.numberOfLeadingZeros` 给出了数值前导零的数目。例如，调用 `Integer.numberOfLeadingZeros(3)` 将赋值为30。\n这是因为3在二进制中表示为 `11`。由于整数有32位，所以有30位有0位。左移运算符的右边变为 `32-30 = 2`。\n左移1，即 `001 << 2` 将是 `100`，十进制中的 `100` 等于 `4`。\n\n```java\npublic static int findNextPositivePowerOfTwo(int value) {\n    return 1 << (32 - Integer.numberOfLeadingZeros(value - 1));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### isEven\n\n检查数字是否是偶数。\n\n这个方法使用按位运算符，`0b1` 是1的二进制表示。\n因为Java 7可以通过用 `0b` 或 `0B` 作为前缀来编写二进制文字。\n数字为偶数时，`＆` 运算符将返回0。 例如，`IsEven(4)` 会导致 `100` `&` `001`，`＆` 的结果将是 `000`。\n\n```java\npublic static boolean isEven(final int value) {\n    return (value & 0b1) == 0;\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### isPowerOfTwo\n\n检查一个值是2的正幂。\n\n为了理解它是如何工作的，让我们假设我们调用了 `IsPowerOfTwo(4)`。\n\n当值大于0时，将评估 `&&` 运算符的右侧。\n\n`(~value + 1)` 的结果等于值本身，`~100 + 001` => `011 + 001` => `100`。\n\n`(value & value)` 的结果是value，`100` & `100` => `100`.。\n\n当值等于值时，这将把值表达为真值。\n\n```Java\npublic static boolean isPowerOfTwo(final int value) {\n    return value > 0 && ((value & (~value + 1)) == value);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### generateRandomInt\n\n生成一个介于 `Integer.MIN_VALUE` 和 `Integer.MAX_VALUE` 之间的随机数。\n\n```java\npublic static int generateRandomInt() {\n    return ThreadLocalRandom.current().nextInt();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n## String\n\n### anagrams\n\n生成一个字符串的所有字符（包含重复）。\n\n```java\npublic static List<String> anagrams(String input) {\n    if (input.length() <= 2) {\n        return input.length() == 2\n                ? Arrays.asList(input, input.substring(1) + input.substring(0, 1))\n                : Collections.singletonList(input);\n    }\n    return IntStream.range(0, input.length())\n            .mapToObj(i -> new SimpleEntry<>(i, input.substring(i, i + 1)))\n            .flatMap(entry ->\n                    anagrams(input.substring(0, entry.getKey()) + input.substring(entry.getKey() + 1))\n                            .stream()\n                            .map(s -> entry.getValue() + s))\n            .collect(Collectors.toList());\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### byteSize\n\n以字节为单位返回字符串的长度。\n\n```java\npublic static int byteSize(String input) {\n    return input.getBytes().length;\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### capitalize\n\n将字符串首字母大写。\n\n```Java\npublic static String capitalize(String input, boolean lowerRest) {\n    return input.substring(0, 1).toUpperCase() +\n            (lowerRest\n                    ? input.substring(1, input.length()).toLowerCase()\n                    : input.substring(1, input.length()));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### capitalizeEveryWord\n\n将字符串中每个单词的首字母大写。\n\n```java\npublic static String capitalizeEveryWord(final String input) {\n    return Pattern.compile(\"\\\\b(?=\\\\w)\").splitAsStream(input)\n            .map(w -> capitalize(w, false))\n            .collect(Collectors.joining());\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### countVowels\n\n在提供的字符串中返回元音的个数。\n\n```java\npublic static int countVowels(String input) {\n    return input.replaceAll(\"[^aeiouAEIOU]\", \"\").length();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### escapeRegExp\n\n转义要在正则表达式中使用的字符串。\n\n```java\npublic static String escapeRegExp(String input) {\n    return Pattern.quote(input);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### fromCamelCase\n\n从驼峰式转换字符串。\n\n```java\npublic static String fromCamelCase(String input, String separator) {\n    return input\n            .replaceAll(\"([a-z\\\\d])([A-Z])\", \"$1\" + separator + \"$2\")\n            .toLowerCase();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### isAbsoluteUrl\n\n如果给定的字符串是绝对URL，则返回 `true`，否则返回 `false`。\n\n```java\npublic static boolean isAbsoluteUrl(String url) {\n    return Pattern.compile(\"^[a-z][a-z0-9+.-]*:\").matcher(url).find();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### isLowerCase\n\n检查字符串是否为小写。\n\n```java\npublic static boolean isLowerCase(String input) {\n    return Objects.equals(input, input.toLowerCase());\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### isUpperCase\n\n检查字符串是否为大写。\n\n```java\npublic static boolean isUpperCase(String input) {\n    return Objects.equals(input, input.toUpperCase());\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### isPalindrome\n\n判断一个字符串是否回文。\n\n```java\npublic static boolean isPalindrome(String input) {\n    String s = input.toLowerCase().replaceAll(\"[\\\\W_]\", \"\");\n    return Objects.equals(\n            s,\n            new StringBuilder(s).reverse().toString()\n    );\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### isNumeric\n\n检查字符串是否为数字。\n\n```java\npublic static boolean isNumeric(final String input) {\n    return IntStream.range(0, input.length())\n            .allMatch(i -> Character.isDigit(input.charAt(i)));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### mask\n\n用指定的掩码字符替换除最后 `num` 个字符以外的所有字符。\n\n```Java\npublic static String mask(String input, int num, String mask) {\n    int length = input.length();\n    return num > 0\n            ?\n            input.substring(0, length - num).replaceAll(\".\", mask)\n                    + input.substring(length - num)\n            :\n            input.substring(0, Math.negateExact(num))\n                    + input.substring(Math.negateExact(num), length).replaceAll(\".\", mask);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### reverseString\n\n反转字符串。\n\n```java\npublic static String reverseString(String input) {\n    return new StringBuilder(input).reverse().toString();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### sortCharactersInString\n\n按字母顺序排列字符串中的字符。\n\n```java\npublic static String sortCharactersInString(String input) {\n    return Arrays.stream(input.split(\"\")).sorted().collect(Collectors.joining());\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### splitLines\n\n将多行字符串拆分为行数组。\n\n```java\npublic static String[] splitLines(String input) {\n    return input.split(\"\\\\r?\\\\n\");\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### toCamelCase\n\n转换一个字符串为驼峰式。\n\n```java\npublic static String toCamelCase(String input) {\n    Matcher matcher = Pattern.compile(\"[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+\").matcher(input);\n    List<String> matchedParts = new ArrayList<>();\n    while (matcher.find()) {\n        matchedParts.add(matcher.group(0));\n    }\n    String s = matchedParts.stream()\n            .map(x -> x.substring(0, 1).toUpperCase() + x.substring(1).toLowerCase())\n            .collect(Collectors.joining());\n    return s.substring(0, 1).toLowerCase() + s.substring(1);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### toKebabCase\n\n将字符串转换为kebab大小写。\n\n```java\npublic static String toKebabCase(String input) {\n    Matcher matcher = Pattern.compile(\"[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+\").matcher(input);\n    List<String> matchedParts = new ArrayList<>();\n    while (matcher.find()) {\n        matchedParts.add(matcher.group(0));\n    }\n    return matchedParts.stream()\n            .map(String::toLowerCase)\n            .collect(Collectors.joining(\"-\"));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### match\n\n正则匹配。\n\n```java\npublic static List<String> match(String input, String regex) {\n    Matcher matcher = Pattern.compile(regex).matcher(input);\n    List<String> matchedParts = new ArrayList<>();\n    while (matcher.find()) {\n        matchedParts.add(matcher.group(0));\n    }\n    return matchedParts;\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### toSnakeCase\n\n将字符串转换为蛇形小写，如 `Im_Biezhi`。\n\n```java\npublic static String toSnakeCase(String input) {\n    Matcher matcher = Pattern.compile(\"[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+\").matcher(input);\n    List<String> matchedParts = new ArrayList<>();\n    while (matcher.find()) {\n        matchedParts.add(matcher.group(0));\n    }\n    return matchedParts.stream()\n            .map(String::toLowerCase)\n            .collect(Collectors.joining(\"_\"));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### truncateString\n\n将字符串截断到指定的长度。\n\n```java\npublic static String truncateString(String input, int num) {\n    return input.length() > num\n            ? input.substring(0, num > 3 ? num - 3 : num) + \"...\"\n            : input;\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### words\n\n将给定的字符串转换为单词数组。\n\n```Java\npublic static String[] words(String input) {\n    return Arrays.stream(input.split(\"[^a-zA-Z-]+\"))\n            .filter(s -> !s.isEmpty())\n            .toArray(String[]::new);\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### stringToIntegers\n\n将由空格分隔的数字字符串转换为 int 数组。\n\n```Java\npublic static int[] stringToIntegers(String numbers) {\n        return Arrays.stream(numbers.split(\" \")).mapToInt(Integer::parseInt).toArray();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n## IO\n\n### convertInputStreamToString\n\n将InputStream转换为字符串。\n\n```java\npublic static String convertInputStreamToString(final InputStream in) throws IOException {\n    ByteArrayOutputStream result = new ByteArrayOutputStream();\n    byte[] buffer = new byte[1024];\n    int length;\n    while ((length = in.read(buffer)) != -1) {\n        result.write(buffer, 0, length);\n    }\n    return result.toString(StandardCharsets.UTF_8.name());\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### readFileAsString\n\n将文件内容读入字符串。\n\n```java\npublic String readFileAsString(Path path) throws IOException {\n    return new String(Files.readAllBytes(path));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### getCurrentWorkingDirectoryPath\n\n获取当前工作目录。\n\n```java\npublic static String getCurrentWorkingDirectoryPath() {\n    return FileSystems.getDefault().getPath(\"\").toAbsolutePath().toString();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### tmpDirName\n\n返回 `java.io.tmpdir` 系统属性的值。如果末尾没有分隔符，则追加分隔符。\n\n```java\npublic static String tmpDirName() {\n    String tmpDirName = System.getProperty(\"java.io.tmpdir\");\n    if (!tmpDirName.endsWith(File.separator)) {\n        tmpDirName += File.separator;\n    }\n\n    return tmpDirName;\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n## Exception\n\n### stackTraceAsString\n\n将异常堆栈跟踪转换为字符串。\n\n```java\npublic static String stackTraceAsString(final Throwable throwable) {\n    final StringWriter sw = new StringWriter();\n    throwable.printStackTrace(new PrintWriter(sw));\n    return sw.toString();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n## System\n\n### osName\n\n以小写字符串的形式获取操作系统的名称。\n\n```java\npublic static String osName() {\n    return System.getProperty(\"os.name\").toLowerCase();\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### isDebuggerEnabled\n\n检查JVM是否为debug模式。\n\n```java\npublic static boolean isDebuggerAttached() {\n    final RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();\n    return runtimeMXBean.getInputArguments()\n            .stream()\n            .anyMatch(arg -> arg.contains(\"-agentlib:jdwp\"));\n\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n## Class\n\n### getAllInterfaces\n\n此方法返回由给定类及其超类实现的所有接口。\n\n该方法通过连接两个Stream来工作。第一个Stream是通过创建带有接口的流和接口实现的所有接口来递归构建的。\n第二个Stream对超类也是如此。其结果是删除重复项后将两个Stream连接起来。\n\n```java\npublic static List<Class<?>> getAllInterfaces(Class<?> cls) {\n    return Stream.concat(\n            Arrays.stream(cls.getInterfaces()).flatMap(intf ->\n                    Stream.concat(Stream.of(intf), getAllInterfaces(intf).stream())),\n            cls.getSuperclass() == null ? Stream.empty() : getAllInterfaces(cls.getSuperclass()).stream()\n    ).distinct().collect(Collectors.toList());\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n### isInnerClass\n\n此方法检查指定的类是内部类还是静态嵌套类。\n\n```Java\npublic static boolean isInnerClass(final Class<?> cls) {\n    return cls != null && cls.getEnclosingClass() != null;\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n\n## Enum\n\n### getEnumMap\n\n将枚举转换为 Map，其中 key 是枚举名，value 是枚举本身。\n\n```java\npublic static <E extends Enum<E>> Map<String, E> getEnumMap(final Class<E> enumClass) {\n    return Arrays.stream(enumClass.getEnumConstants())\n            .collect(Collectors.toMap(Enum::name, Function.identity()));\n}\n```\n\n<br>[⬆ 回到顶部](#目录)\n"
        },
        {
          "name": "pom.xml",
          "type": "blob",
          "size": 1.6748046875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>io.github.biezhi</groupId>\n    <artifactId>30-seconds-of-java8</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n        <junit.version>4.12</junit.version>\n        <assertj.version>3.8.0</assertj.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>${junit.version}</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.assertj</groupId>\n            <artifactId>assertj-core</artifactId>\n            <version>${assertj.version}</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>2.20</version>\n                <configuration>\n                    <includes>\n                        <include>**/Test*.java</include>\n                        <include>**/*Test.java</include>\n                        <include>**/*Tests.java</include>\n                    </includes>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}