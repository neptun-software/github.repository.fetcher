{
  "metadata": {
    "timestamp": 1736609141323,
    "page": 431,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "android-notes/Cockroach",
      "stars": 3247,
      "defaultBranch": "X",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5595703125,
          "content": "\n*.iml\n.gradle\n/local.properties\n/.idea\n/.idea/libraries\n.DS_Store\n/build\n/captures\n.externalNativeBuild\n\n\n# Built application files\n*.apk\n*.ap_\n\n# Files for the ART/Dalvik VM\n*.dex\n\n# Java class files\n*.class\n\n# Generated files\nbin/\ngen/\nout/\n\n# Gradle files\n.gradle/\nbuild/\n\n# Local configuration file (sdk path, etc)\nlocal.properties\n\n# Proguard folder generated by Eclipse\nproguard/\n\n# Log Files\n*.log\n\n# Android Studio Navigation editor temp files\n.navigation/\n\n# Android Studio captures folder\ncaptures/\n\n# Intellij\n*.iml\n.idea/workspace.xml\n\n# Keystore files\n*.jks\n\n"
        },
        {
          "name": ".idea",
          "type": "tree",
          "content": null
        },
        {
          "name": "DefaultUncaughtExceptionHandler.md",
          "type": "blob",
          "size": 6.1025390625,
          "content": "`Thread.setDefaultUncaughtExceptionHandler`\n\n```java\n\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        final Thread.UncaughtExceptionHandler uncaughtExceptionHandler=Thread.getDefaultUncaughtExceptionHandler();\n        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n            @Override\n            public void uncaughtException(Thread t, Throwable e) {\n                Log.e(\"AndroidRuntime\",\"--->uncaughtException:\"+t+\"<---\",e);\n                uncaughtExceptionHandler.uncaughtException(t,e);//若不把异常交给默认的异常处理器处理会导致ANR，交给了就会导致crash\n            }\n        });\n\n\n        findViewById(R.id.but1).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                throw new RuntimeException(\"click exception...\");\n            }\n        });\n\n        findViewById(R.id.but2).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                new Handler().post(new Runnable() {\n                    @Override\n                    public void run() {\n                        throw new RuntimeException(\"handler exception...\");\n                    }\n                });\n            }\n        });\n\n        findViewById(R.id.but3).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                new Thread() {\n                    @Override\n                    public void run() {\n                        super.run();\n                        throw new RuntimeException(\"new thread exception...\");\n                    }\n                }.start();\n            }\n        });\n\n    }\n}\n\n```\n\n\n可以看到主线程的异常被UncaughtExceptionHandler捕获到了，若不把异常交给默认的异常处理器处理会导致ANR，交给了就会导致crash\n            \n```java\n\n02-17 09:36:00.152 19525-19525/wj.com.fuck E/AndroidRuntime: --->uncaughtException:Thread[main,5,main]<---\n                                                             java.lang.RuntimeException: click exception...\n                                                                 at wj.com.fuck.MainActivity$2.onClick(MainActivity.java:46)\n                                                                 at android.view.View.performClick(View.java:4909)\n                                                                 at android.view.View$PerformClick.run(View.java:20390)\n                                                                 at android.os.Handler.handleCallback(Handler.java:815)\n                                                                 at android.os.Handler.dispatchMessage(Handler.java:104)\n                                                                 at android.os.Looper.loop(Looper.java:194)\n                                                                 at android.app.ActivityThread.main(ActivityThread.java:5826)\n                                                                 at java.lang.reflect.Method.invoke(Native Method)\n                                                                 at java.lang.reflect.Method.invoke(Method.java:372)\n                                                                 at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1009)\n                                                                 at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:804)\n02-17 09:36:00.152 19525-19525/wj.com.fuck E/AndroidRuntime: FATAL EXCEPTION: main\n                                                             Process: wj.com.fuck, PID: 19525\n                                                             java.lang.RuntimeException: click exception...\n                                                                 at wj.com.fuck.MainActivity$2.onClick(MainActivity.java:46)\n                                                                 at android.view.View.performClick(View.java:4909)\n                                                                 at android.view.View$PerformClick.run(View.java:20390)\n                                                                 at android.os.Handler.handleCallback(Handler.java:815)\n                                                                 at android.os.Handler.dispatchMessage(Handler.java:104)\n                                                                 at android.os.Looper.loop(Looper.java:194)\n                                                                 at android.app.ActivityThread.main(ActivityThread.java:5826)\n                                                                 at java.lang.reflect.Method.invoke(Native Method)\n                                                                 at java.lang.reflect.Method.invoke(Method.java:372)\n                                                                 at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1009)\n                                                                 at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:804)\n\n```\n \n \n子线程抛出异常也可以被UncaughtExceptionHandler捕获到，即使不把异常交给默认的异常处理器处理也不会导致crash\n\n```java\n\n02-17 09:38:21.555 20825-20933/wj.com.fuck E/AndroidRuntime: --->uncaughtException:Thread[Thread-28481,5,main]<---\n                                                             java.lang.RuntimeException: new thread exception...\n                                                                 at wj.com.fuck.MainActivity$4$1.run(MainActivity.java:69)\n02-17 09:38:21.555 20825-20933/wj.com.fuck E/AndroidRuntime: FATAL EXCEPTION: Thread-28481\n                                                             Process: wj.com.fuck, PID: 20825\n                                                             java.lang.RuntimeException: new thread exception...\n                                                                 at wj.com.fuck.MainActivity$4$1.run(MainActivity.java:69)\n\n\n```\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0322265625,
          "content": "MIT License\n\nCopyright (c) 2017 \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.98046875,
          "content": " \n\n## Cockroach 2.0\n\n\n\n## 为什么开发这个库\n很多时候由于一些微不足道的bug导致app崩溃很可惜，android默认的异常杀进程机制简单粗暴，但很多时候让app崩溃其实也并不能解决问题。\n\n有些bug可能是系统bug，对于这些难以预料的系统bug我们不好绕过，还有一些bug是我们自己编码造成的，对于有些bug来说直接忽略掉的话可能只是导致部分不重要的功能没法使用而已，又或者对用户来说完全没有影响，这种情况总比每次都崩溃要好很多。\n\n下面介绍几个真实案例来说明这个库的优势：\n\n* 有一款特殊的手机，每次开启某个Activity时都报错，提示没有在清单中声明，但其他几百万机型都没问题，这种情况很可能就是系统bug了，由于是在onclick回调里直接使用startActivity来开启Activity，onclick里没有其他逻辑，对于这种情况的话直接忽略掉是最好的选择，因为onclick回调是在一个单独的message中的，执行完了该message就接着执行下一个message，该message执行不完也不会影响下一个message的执行，调用startactivity后会同步等待ams返回的错误码，结果这款特殊的机型返回了没有声明这个Activity，所以对于这种情况可以直接忽略掉，唯一的影响就是这个Activity不会显示，就跟没有调用onClick一样\n\n* 我们在app中集成了个三方的数据统计库，这个库是在Application的onCreate的最后初始化的，但上线后执行初始化时却崩溃了，对于这种情况直接忽略掉也是最好的选择。根据app的启动流程来分析，Application的创建以及onCreate方法的调用都是在同一个message中执行的，该message执行的最后调用了Application的onCreate方法，又由于这个数据统计库是在onCreate的最后才初始化的，所以直接忽略的话也没有影响，就跟没有初始化过一样\n\n* 我们做了个检查app是否需要升级的功能，若需要升级，则使用context开启一个dialog风格的Activity提示是否需要升级，测试阶段没有任何问题，但一上线就崩溃了，提示没有设置FLAG_ACTIVITY_NEW_TASK,由于启动Activity的context是Application，但在高版本android中，可以使用Application启动Activity并且不设置这个FLAG，但在低版本中必须要设置这个FLAG，对于这种问题也可以直接忽略\n\n  API28 ContextImpl startActivity源码\n ```java\n  public void startActivity(Intent intent, Bundle options) {\n        warnIfCallingFromSystemProcess();\n\n        // Calling start activity from outside an activity without FLAG_ACTIVITY_NEW_TASK is\n        // generally not allowed, except if the caller specifies the task id the activity should\n        // be launched in. A bug was existed between N and O-MR1 which allowed this to work. We\n        // maintain this for backwards compatibility.\n        final int targetSdkVersion = getApplicationInfo().targetSdkVersion;\n\n        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0\n                && (targetSdkVersion < Build.VERSION_CODES.N\n                        || targetSdkVersion >= Build.VERSION_CODES.P)\n                && (options == null\n                        || ActivityOptions.fromBundle(options).getLaunchTaskId() == -1)) {\n            throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                            + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                            + \" Is this really what you want?\");\n        }\n        mMainThread.getInstrumentation().execStartActivity(\n                getOuterContext(), mMainThread.getApplicationThread(), null,\n                (Activity) null, intent, -1, options);\n    }\n ```\n\n* 还有各种执行onclick时触发的异常，这些很多时候都是可以直接忽略掉的\n\n### 更新日志\n* 修复Android P反射限制导致的Activity生命周期异常无法finish Activity问题 \n\n[cockroach1.0版在这](https://github.com/android-notes/Cockroach/tree/master)\n\n### Cockroach 2.0新特性\n* Cockroach 2.0减少了Cockroach 1.0版本中Activity生命周期中抛出异常黑屏的问题。\n* Cockroach 1.0未雨绸缪，提前做好准备，等待异常到来。Cockroach 2.0马后炮，只有当抛出异常时才去拯救。\n* Cockroach 2.0试图在APP即将崩溃时尽量去挽救，不至于情况更糟糕。\n\n\n用一张图片来形容就是\n\n![img](https://github.com/android-notes/Cockroach/blob/X/wanjiu.jpeg?raw=true)\n\n\n>特别注意： 当view的measure,layout,draw，以及recyclerview的bindviewholder 方法抛出异常时会导致\nviewrootimpl挂掉，此时会回调 onMayBeBlackScreen 方法，建议直接杀死app。目前可以拦截到抛出异常的ViewRootImpl，具体参考这https://github.com/android-notes/SwissArmyKnife/blob/master/saklib/src/main/java/com/wanjian/sak/system/traversals/ViewTraversalsCompact.java\n\n## 使用姿势\n\n* 必须要在Application初始化时装载\n\n例如：\n\n```java\n  \n    package com.wanjian.demo;\n    \n    import android.app.Application;\n    import android.os.Handler;\n    import android.os.Looper;\n    import android.util.Log;\n    import android.widget.Toast;\n    \n    import com.wanjian.cockroach.Cockroach;\n    \n    /**\n     * Created by wanjian on 2018/5/19.\n     */\n    \n    public class App extends Application {\n    \n        @Override\n        public void onCreate() {\n            super.onCreate();\n            install();\n        }\n    \n    \n        private void install() {\n            Cockroach.install(new ExceptionHandler() {\n                       @Override\n                       protected void onUncaughtExceptionHappened(Thread thread, Throwable throwable) {\n                           Log.e(\"AndroidRuntime\", \"--->onUncaughtExceptionHappened:\" + thread + \"<---\", throwable);\n                           new Handler(Looper.getMainLooper()).post(new Runnable() {\n                               @Override\n                               public void run() {\n                                   toast.setText(R.string.safe_mode_excep_tips);\n                                   toast.show();\n                               }\n                           });\n                       }\n           \n                       @Override\n                       protected void onBandageExceptionHappened(Throwable throwable) {\n                           throwable.printStackTrace();//打印警告级别log，该throwable可能是最开始的bug导致的，无需关心\n                           toast.setText(\"Cockroach Worked\");\n                           toast.show();\n                       }\n           \n                       @Override\n                       protected void onEnterSafeMode() {\n                           int tips = R.string.safe_mode_tips;\n                           Toast.makeText(App.this, getResources().getString(tips), Toast.LENGTH_LONG).show();\n                       \n                       }\n           \n                       @Override\n                       protected void onMayBeBlackScreen(Throwable e) {\n                           Thread thread = Looper.getMainLooper().getThread();\n                           Log.e(\"AndroidRuntime\", \"--->onUncaughtExceptionHappened:\" + thread + \"<---\", e);\n                           //黑屏时建议直接杀死app\n                           sysExcepHandler.uncaughtException(thread, new RuntimeException(\"black screen\"));\n                       }\n           \n                   });\n    \n        }\n    }\n    \n\n```\n\n\n## 原理分析\n\ncockroach2.0通过替换`ActivityThread.mH.mCallback`，实现拦截Activity生命周期，\n通过调用ActivityManager的`finishActivity`结束掉生命周期抛出异常的Activity\n\n\n\n\n\n相关视频 \n[https://github.com/android-notes/Cockroach/blob/master/cockroach.mp4?raw=true](https://github.com/android-notes/Cockroach/blob/master/cockroach.mp4?raw=true)\n\n \n\n \n[相关原理分析](https://github.com/android-notes/Cockroach/blob/master/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.md)\n\n[相关连接](https://github.com/android-notes/Cockroach/tree/master)\n\n\n"
        },
        {
          "name": "app",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.gradle",
          "type": "blob",
          "size": 0.724609375,
          "content": "// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n    repositories {\n        jcenter()\n        maven {\n            url 'https://maven.google.com/'\n            name 'Google'\n        }\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.2.2'\n        classpath 'com.novoda:bintray-release:0.3.4'\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        jcenter()\n        maven {\n            url 'https://maven.google.com/'\n            name 'Google'\n        }\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n"
        },
        {
          "name": "cockroach.mp4",
          "type": "blob",
          "size": 6399.8740234375,
          "content": ""
        },
        {
          "name": "demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradle.properties",
          "type": "blob",
          "size": 0.712890625,
          "content": "# Project-wide Gradle settings.\n\n# IDE (e.g. Android Studio) users:\n# Gradle settings configured through the IDE *will override*\n# any settings specified in this file.\n\n# For more details on how to configure your build environment visit\n# http://www.gradle.org/docs/current/userguide/build_environment.html\n\n# Specifies the JVM arguments used for the daemon process.\n# The setting is particularly useful for tweaking memory settings.\norg.gradle.jvmargs=-Xmx1536m\n\n# When configured, Gradle will run in incubating parallel mode.\n# This option should only be used with decoupled projects. More details, visit\n# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects\n# org.gradle.parallel=true\n"
        },
        {
          "name": "gradle",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradlew",
          "type": "blob",
          "size": 4.8544921875,
          "content": "#!/usr/bin/env bash\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\"\"\n\nAPP_NAME=\"Gradle\"\nAPP_BASE_NAME=`basename \"$0\"`\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD=\"maximum\"\n\nwarn ( ) {\n    echo \"$*\"\n}\n\ndie ( ) {\n    echo\n    echo \"$*\"\n    echo\n    exit 1\n}\n\n# OS specific support (must be 'true' or 'false').\ncygwin=false\nmsys=false\ndarwin=false\ncase \"`uname`\" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\nesac\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG=\"$0\"\n# Need this for relative symlinks.\nwhile [ -h \"$PRG\" ] ; do\n    ls=`ls -ld \"$PRG\"`\n    link=`expr \"$ls\" : '.*-> \\(.*\\)$'`\n    if expr \"$link\" : '/.*' > /dev/null; then\n        PRG=\"$link\"\n    else\n        PRG=`dirname \"$PRG\"`\"/$link\"\n    fi\ndone\nSAVED=\"`pwd`\"\ncd \"`dirname \\\"$PRG\\\"`/\" >/dev/null\nAPP_HOME=\"`pwd -P`\"\ncd \"$SAVED\" >/dev/null\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n \"$JAVA_HOME\" ] ; then\n    if [ -x \"$JAVA_HOME/jre/sh/java\" ] ; then\n        # IBM's JDK on AIX uses strange locations for the executables\n        JAVACMD=\"$JAVA_HOME/jre/sh/java\"\n    else\n        JAVACMD=\"$JAVA_HOME/bin/java\"\n    fi\n    if [ ! -x \"$JAVACMD\" ] ; then\n        die \"ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\n    fi\nelse\n    JAVACMD=\"java\"\n    which java >/dev/null 2>&1 || die \"ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ \"$cygwin\" = \"false\" -a \"$darwin\" = \"false\" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ \"$MAX_FD\" = \"maximum\" -o \"$MAX_FD\" = \"max\" ] ; then\n            MAX_FD=\"$MAX_FD_LIMIT\"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn \"Could not set maximum file descriptor limit: $MAX_FD\"\n        fi\n    else\n        warn \"Could not query maximum file descriptor limit: $MAX_FD_LIMIT\"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS=\"$GRADLE_OPTS \\\"-Xdock:name=$APP_NAME\\\" \\\"-Xdock:icon=$APP_HOME/media/gradle.icns\\\"\"\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed \"$APP_HOME\"`\n    CLASSPATH=`cygpath --path --mixed \"$CLASSPATH\"`\n    JAVACMD=`cygpath --unix \"$JAVACMD\"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=\"\"\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS=\"$ROOTDIRS$SEP$dir\"\n        SEP=\"|\"\n    done\n    OURCYGPATTERN=\"(^($ROOTDIRS))\"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ \"$GRADLE_CYGPATTERN\" != \"\" ] ; then\n        OURCYGPATTERN=\"$OURCYGPATTERN|($GRADLE_CYGPATTERN)\"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in \"$@\" ; do\n        CHECK=`echo \"$arg\"|egrep -c \"$OURCYGPATTERN\" -`\n        CHECK2=`echo \"$arg\"|egrep -c \"^-\"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed \"$arg\"`\n        else\n            eval `echo args$i`=\"\\\"$arg\\\"\"\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- \"$args0\" ;;\n        (2) set -- \"$args0\" \"$args1\" ;;\n        (3) set -- \"$args0\" \"$args1\" \"$args2\" ;;\n        (4) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" ;;\n        (5) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" ;;\n        (6) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" ;;\n        (7) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" ;;\n        (8) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" ;;\n        (9) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" \"$args8\" ;;\n    esac\nfi\n\n# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules\nfunction splitJvmOpts() {\n    JVM_OPTS=(\"$@\")\n}\neval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS\nJVM_OPTS[${#JVM_OPTS[*]}]=\"-Dorg.gradle.appname=$APP_BASE_NAME\"\n\nexec \"$JAVACMD\" \"${JVM_OPTS[@]}\" -classpath \"$CLASSPATH\" org.gradle.wrapper.GradleWrapperMain \"$@\"\n"
        },
        {
          "name": "gradlew.bat",
          "type": "blob",
          "size": 2.34765625,
          "content": "@if \"%DEBUG%\" == \"\" @echo off\r\n@rem ##########################################################################\r\n@rem\r\n@rem  Gradle startup script for Windows\r\n@rem\r\n@rem ##########################################################################\r\n\r\n@rem Set local scope for the variables with windows NT shell\r\nif \"%OS%\"==\"Windows_NT\" setlocal\r\n\r\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\r\nset DEFAULT_JVM_OPTS=\r\n\r\nset DIRNAME=%~dp0\r\nif \"%DIRNAME%\" == \"\" set DIRNAME=.\r\nset APP_BASE_NAME=%~n0\r\nset APP_HOME=%DIRNAME%\r\n\r\n@rem Find java.exe\r\nif defined JAVA_HOME goto findJavaFromJavaHome\r\n\r\nset JAVA_EXE=java.exe\r\n%JAVA_EXE% -version >NUL 2>&1\r\nif \"%ERRORLEVEL%\" == \"0\" goto init\r\n\r\necho.\r\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\r\necho.\r\necho Please set the JAVA_HOME variable in your environment to match the\r\necho location of your Java installation.\r\n\r\ngoto fail\r\n\r\n:findJavaFromJavaHome\r\nset JAVA_HOME=%JAVA_HOME:\"=%\r\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\r\n\r\nif exist \"%JAVA_EXE%\" goto init\r\n\r\necho.\r\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\r\necho.\r\necho Please set the JAVA_HOME variable in your environment to match the\r\necho location of your Java installation.\r\n\r\ngoto fail\r\n\r\n:init\r\n@rem Get command-line arguments, handling Windowz variants\r\n\r\nif not \"%OS%\" == \"Windows_NT\" goto win9xME_args\r\nif \"%@eval[2+2]\" == \"4\" goto 4NT_args\r\n\r\n:win9xME_args\r\n@rem Slurp the command line arguments.\r\nset CMD_LINE_ARGS=\r\nset _SKIP=2\r\n\r\n:win9xME_args_slurp\r\nif \"x%~1\" == \"x\" goto execute\r\n\r\nset CMD_LINE_ARGS=%*\r\ngoto execute\r\n\r\n:4NT_args\r\n@rem Get arguments from the 4NT Shell from JP Software\r\nset CMD_LINE_ARGS=%$\r\n\r\n:execute\r\n@rem Setup the command line\r\n\r\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\r\n\r\n@rem Execute Gradle\r\n\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\r\n\r\n:end\r\n@rem End local scope for the variables with windows NT shell\r\nif \"%ERRORLEVEL%\"==\"0\" goto mainEnd\r\n\r\n:fail\r\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\r\nrem the _cmd.exe /c_ return code!\r\nif  not \"\" == \"%GRADLE_EXIT_CONSOLE%\" exit 1\r\nexit /b 1\r\n\r\n:mainEnd\r\nif \"%OS%\"==\"Windows_NT\" endlocal\r\n\r\n:omega\r\n"
        },
        {
          "name": "settings.gradle",
          "type": "blob",
          "size": 0.0234375,
          "content": "include ':app', ':demo'\n"
        },
        {
          "name": "wanjiu.jpeg",
          "type": "blob",
          "size": 12.076171875,
          "content": null
        },
        {
          "name": "原理分析.md",
          "type": "blob",
          "size": 5.859375,
          "content": "\n### 原理\n\nandroid中最重要的就是Handler机制了，简单来说Handler机制就是在一个死循环内部不断取走阻塞队列头部的Message，这个阻塞队列在主线程中是唯一的，当没有Message时，循环就阻塞，当一旦有Message时就立马被主线程取走并执行Message。\n\n查看android源码可以发现在ActivityThread中main方法（main方法签名 ` public static void main(String[] args){}`,这个main方法是静态的，公有的，可以理解为应用的入口）最后执行了`Looper.loop();`，此方法内部是个死循环(for(;;)循环)，所以一般情况下主线程是不会退出的，除非抛出异常。`queue.next();`就是从阻塞队列里取走头部的Message，当没有Message时主线程就会阻塞在这里，一有Message就会继续往下执行。android的view绘制，事件分发，activity启动，activity的生命周期回调等等都是一个个的Message，android会把这些Message插入到主线程中唯一的queue中，所有的消息都排队等待主线程的执行。\n\n\nActivityThread的main方法如下：\n\n```java\n\n public static void main(String[] args) {\n         \n\t\t ...\n        Looper.prepareMainLooper();//创建主线程唯一的阻塞队列queue\n        ...\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);//执行初始化，往queue中添加Message等\n        ...\n        Looper.loop();//开启死循环，挨个执行Message\n\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n\n```\n\n`Looper.loop()`关键代码如下：\n\n```java\n\n   for (;;) {\n            Message msg = queue.next(); // might block\n            ...\n            msg.target.dispatchMessage(msg);//执行Message\n            ...\n   }\n            \n```\n\n\nandroid消息机制伪代码如下：\n\n```java\n\npublic class ActivityThread {\n\n\tpublic static void main(String[]args){\n\t\t\n\t\tQueue queue=new Queue();// 可以理解为一个加锁的，可以阻塞线程的ArrayList\n\t\t\n\t\tqueue.add(new Message(){\n\t\t\tvoid run(){\n\t\t\t\t...\n\t\t\t\tprint(\"android 启动了，下一步该往queue中插入启动主Activity的Message了\");\n\t\t\t\tMessage msg=getMessage4LaunchMainActivity();\n\t\t\t\tqueue.add(msg);\n\t\t\t}\n\t\t\n\t\t});\n\t\t\n\t\tfor(;;){//开始死循环，for之后的代码永远也得不到执行\n\t\t\tMessage  msg=queue.next();\n\t\t\t\n\t\t\tmsg.run();\n\t\t\n\t\t}\n\t\n\t}\n\n\n\n}\n\n\n```\n看了上面的分析相信大家对android的消息机制很清楚了。\n关于Handler机制更多内容可以看这 \n[java工程实现Handler机制代码](https://android-notes.github.io/2016/12/03/5%E5%88%86%E9%92%9F%E5%AE%8C%E5%85%A8%E7%90%86%E8%A7%A3android-handler/)\n\n\n下面我们看一下Cockroach的核心代码\n\n```java\n\n\n new Handler(Looper.getMainLooper()).post(new Runnable() {\n            @Override\n            public void run() {\n               //主线程异常拦截\n                while (true) {\n                    try {\n                        Looper.loop();//主线程的异常会从这里抛出\n                    } catch (Throwable e) {\n                                                \n                    }\n                }\n            }\n        });\n       \n        sUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();\n         //所有线程异常拦截，由于主线程的异常都被我们catch住了，所以下面的代码拦截到的都是子线程的异常\n        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n            @Override\n            public void uncaughtException(Thread t, Throwable e) {\n                \n            }\n});\n\n```\n\n原理很简单，就是通过Handler往主线程的queue中添加一个Runnable，当主线程执行到该Runnable时，会进入我们的while死循环，如果while内部是空的就会导致代码卡在这里，最终导致ANR，但我们在while死循环中又调用了`Looper.loop()`，这就导致主线程又开始不断的读取queue中的Message并执行，这样就可以保证以后主线程的所有异常都会从我们手动调用的`Looper.loop()`处抛出，一旦抛出就会被try{}catch捕获，这样主线程就不会crash了，如果没有这个while的话那么主线程下次抛出异常时我们就又捕获不到了，这样APP就又crash了，所以我们要通过while让每次crash发生后都再次进入消息循环，while的作用仅限于每次主线程抛出异常后迫使主线程再次进入消息循环。我们可以用下面的伪代码来表示：\n\n```java\n\npublic class ActivityThread {\n\n\tpublic static void main(String[]args){\n\t\t\n\t\tQueue queue=new Queue();// 可以理解为一个加锁的，可以阻塞线程的ArrayList\n\t\t\n\t\t...\n\t\t\n\t\tfor(;;){//开始死循环，for之后的代码永远也得不到执行\n\t\t\tMessage  msg=queue.next();\n\t\t\t\n\t\t\t//如果msg 是我们post的Runnable就会执行如下代码\n\t\t\t\t//我们post的Runnable中的代码\n\t\t\t\t  while (true) {\n                    try {\n                       \t for(;;){//所有主线程的异常都会从msg.run()中抛出，所以我们加一个try{}catch来捕获所有主线程异常，捕获到后再次强迫进入循环，不断读取queue中消息并执行\n                       \t \tMessage  msg=queue.next();\n                       \t \tmsg.run();\n                       \t }\n                       \n                    } catch (Throwable e) {\n                    \n                    }\n\t\t\t//否则执行其他逻辑\t\n\t\t\t \n\t\t\n\t\t}\n\t\n\t}\n\n\n\n```\n\n为什么要通过new Handler.post方式而不是直接在主线程中任意位置执行\n` while (true) {\n                    try {\n                        Looper.loop();\n                    } catch (Throwable e) {}\n                }`  \n                \n 这是因为该方法是个死循环，若在主线程中，比如在Activity的onCreate中执行时会导致while后面的代码得不到执行，activity的生命周期也就不能完整执行，通过Handler.post方式可以保证不影响该条消息中后面的逻辑。\n\n\n\n\n\n\n"
        }
      ]
    }
  ]
}