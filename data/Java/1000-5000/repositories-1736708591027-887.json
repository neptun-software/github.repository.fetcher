{
  "metadata": {
    "timestamp": 1736708591027,
    "page": 887,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "VictorAlbertos/RxCache",
      "stars": 2373,
      "defaultBranch": "2.x",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.4072265625,
          "content": "# Built application files\n*.apk\n*.ap_\n\n# Files for the Dalvik VM\n*.dex\n\n# Java class files\n*.class\n\n# Generated files\nbin/\ngen/\n\n# Gradle files\n.gradle/\n**/build/\n\n# Local configuration file (sdk path, etc)\nlocal.properties\n\n# Proguard folder generated by Eclipse\nproguard/\n\n# Log Files\n*.log\n\n# Android Studio\n.navigation/\n.idea/\n**/*.iml\n\n# Android Studio captures folder\ncaptures/\n\n# .DS_Store files\n**/.DS_Store\n\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2216796875,
          "content": "language: android\njdk: oraclejdk8\nscript: \"./gradlew build\"\nandroid:\n  components:\n    # The BuildTools version used by your project\n    - build-tools-23.0.1\n\n    # The SDK version used to compile your project\n    - android-23\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 11.0810546875,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2015 Víctor Albertos \n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 26.623046875,
          "content": ":warning: This repository is no longer mantained consider using [Room](https://developer.android.com/topic/libraries/architecture/room) as an alternative :warning: \r\n\r\n![Downloads](https://jitpack.io/v/VictorAlbertos/RxCache/month.svg)\r\n\r\n[![Android Arsenal](https://img.shields.io/badge/Android%20Arsenal-RxCache-green.svg?style=true)](https://android-arsenal.com/details/1/3016)\r\n\r\n# RxCache\r\n\r\n> [**中文文档**](http://www.jianshu.com/p/b58ef6b0624b)\r\n\r\n_For a more reactive approach go [here](https://github.com/VictorAlbertos/ReactiveCache/tree/2.x)_.\r\n\r\nThe **goal** of this library is simple: **caching your data models like [Picasso](https://github.com/square/picasso) caches your images, with no effort at all.** \r\n\r\nEvery Android application is a client application, which means it does not make sense to create and maintain a database just for caching data.\r\n\r\nPlus, the fact that you have some sort of legendary database for persisting your data does not solves by itself the real challenge: to be able to configure your caching needs in a flexible and simple way. \r\n\r\nInspired by [Retrofit](http://square.github.io/retrofit/) api, **RxCache is a reactive caching library for Android and Java which turns your caching needs into an interface.** \r\n\r\nWhen supplying an **`observable`, `single`, `maybe` or `flowable` (these are the supported Reactive types)** which contains the data provided by an expensive task -probably an http connection, RxCache determines if it is needed \r\nto subscribe to it or instead fetch the data previously cached. This decision is made based on the providers configuration.\r\n \r\n```java\r\nObservable<List<Mock>> getMocks(Observable<List<Mock>> oMocks);\r\n```\r\n\r\n## Setup\r\n\r\nAdd the JitPack repository in your build.gradle (top level module):\r\n```gradle\r\nallprojects {\r\n    repositories {\r\n        jcenter()\r\n        maven { url \"https://jitpack.io\" }\r\n    }\r\n}\r\n```\r\n\r\nAnd add next dependencies in the build.gradle of the module:\r\n```gradle\r\ndependencies {\r\n    compile \"com.github.VictorAlbertos.RxCache:runtime:1.8.3-2.x\"\r\n    compile \"io.reactivex.rxjava2:rxjava:2.1.6\"\r\n}\r\n```\r\n\r\nBecause RxCache uses internally [Jolyglot](https://github.com/VictorAlbertos/Jolyglot) to serialize and deserialize objects, you need to add one of the next dependency to gradle.\r\n \r\n```gradle\r\ndependencies {\r\n    // To use Gson \r\n    compile 'com.github.VictorAlbertos.Jolyglot:gson:0.0.4'\r\n    \r\n    // To use Jackson\r\n    compile 'com.github.VictorAlbertos.Jolyglot:jackson:0.0.4'\r\n    \r\n    // To use Moshi\r\n    compile 'com.github.VictorAlbertos.Jolyglot:moshi:0.0.4'\r\n}\r\n```\r\n\r\n## Usage\r\n\r\nDefine an `interface` with as much methods as needed to create the caching providers:\r\n\r\n```java\r\ninterface Providers {\r\n\r\n        @ProviderKey(\"mocks\")\r\n        Observable<List<Mock>> getMocks(Observable<List<Mock>> oMocks);\r\n    \r\n        @ProviderKey(\"mocks-5-minute-ttl\")\r\n        @LifeCache(duration = 5, timeUnit = TimeUnit.MINUTES)\r\n        Observable<List<Mock>> getMocksWith5MinutesLifeTime(Observable<List<Mock>> oMocks);\r\n    \r\n        @ProviderKey(\"mocks-evict-provider\")\r\n        Observable<List<Mock>> getMocksEvictProvider(Observable<List<Mock>> oMocks, EvictProvider evictProvider);\r\n    \r\n        @ProviderKey(\"mocks-paginate\")\r\n        Observable<List<Mock>> getMocksPaginate(Observable<List<Mock>> oMocks, DynamicKey page);\r\n    \r\n        @ProviderKey(\"mocks-paginate-evict-per-page\")\r\n        Observable<List<Mock>> getMocksPaginateEvictingPerPage(Observable<List<Mock>> oMocks, DynamicKey page, EvictDynamicKey evictPage);\r\n        \r\n        @ProviderKey(\"mocks-paginate-evict-per-filter\")\r\n        Observable<List<Mock>> getMocksPaginateWithFiltersEvictingPerFilter(Observable<List<Mock>> oMocks, DynamicKeyGroup filterPage, EvictDynamicKey evictFilter);\r\n}\r\n```\r\n\r\nRxCache exposes `evictAll()` method to evict the entire cache in a row. \r\n\r\nRxCache accepts as argument a set of classes to indicate how the provider needs to handle the cached data:\r\n\r\n* A Reactive type is the only object required to create a provider. This Reactive type must be equal to the one specified by the returning value of the provider.\r\n* [EvictProvider](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictProvider.java) allows to explicitly evict all the data associated with the provider.\r\n* [@ProviderKey](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/ProviderKey.java) is an annotation for provider methods that is highly recommended to use and proguard users MUST use this annotation, if not used the method names will be used as provider keys (cache keys) and proguard users will quickly run into problems, please see [Proguard](proguard) for detailed information. Using the annotaiton is also useful when not using Proguard as it makes sure you can change your method names without having to write a migration for old cache files.\r\n* [EvictDynamicKey](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictDynamicKey.java) allows to explicitly evict the data of an specific [DynamicKey](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/DynamicKey.java).\r\n* [EvictDynamicKeyGroup](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictDynamicKeyGroup.java) allows to explicitly evict the data of an specific [DynamicKeyGroup](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/DynamicKeyGroup.java).\r\n* [DynamicKey](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/DynamicKey.java) is a wrapper around the key object for those providers which need to handle multiple records, so they need to provide multiple keys, such us endpoints with pagination, ordering or filtering requirements. To evict the data associated with one particular key use `EvictDynamicKey`.\r\n* [DynamicKeyGroup](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/DynamicKeyGroup.java) is a wrapper around the key and the group for those providers which need to handle multiple records grouped, so they need to provide multiple keys organized in groups, such us endpoints with filtering AND pagination requirements. To evict the data associated with the key of one particular group, use `EvictDynamicKeyGroup`.\r\n\r\nSupported annotations:\r\n\r\n* [@LifeCache](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/LifeCache.java) sets the amount of time before the data would be evicted. If `@LifeCache` is not supplied, the data will be never evicted unless it is required explicitly using [EvictProvider](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictProvider.java), [EvictDynamicKey](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictDynamicKey.java) or [EvictDynamicKeyGroup](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictDynamicKeyGroup.java) .\r\n* [@Actionable](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Actionable.java) offers an easy way to perform write operations using providers. More details [here](#actionable_section)\r\n* [@SchemeMigration](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/SchemeMigration.java) and [@Migration](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Migration.java) provides a simple mechanism for handling migrations between releases. More details [here](#migrations_section)\r\n* [@Expirable](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Expirable.java) determines if that provider will be excluded from the evicting process or not. More details [here](#expirable_section)\r\n* [@EncryptKey](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/EncryptKey.java) and [@Encrypt](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Encrypt.java) provides a simple way to encrypt/decrypt the data on persistence layer. More details [here](#encryption_section)\r\n\r\n### Build an instance of Providers and use it\r\n\r\nFinally, instantiate the Providers `interface` using `RxCache.Builder` and supplying a valid file system path which would allow RxCache to write on disk.\r\n\r\n```java\r\nFile cacheDir = getFilesDir();\r\nProviders providers = new RxCache.Builder()\r\n                            .persistence(cacheDir, new GsonSpeaker())\r\n                            .using(Providers.class);\r\n```\r\n\r\n### Putting It All Together\r\n\r\n```java\r\ninterface Providers {\r\n\r\n    @ProviderKey(\"mocks-evict-provider\")\r\n    Observable<List<Mock>> getMocksEvictProvider(Observable<List<Mock>> oMocks, EvictProvider evictProvider);\r\n\r\n    @ProviderKey(\"mocks-paginate-evict-per-page\")\r\n    Observable<List<Mock>> getMocksPaginateEvictingPerPage(Observable<List<Mock>> oMocks, DynamicKey page, EvictDynamicKey evictPage);\r\n\r\n    @ProviderKey(\"mocks-paginate-evict-per-filter\")\r\n    Observable<List<Mock>> getMocksPaginateWithFiltersEvictingPerFilter(Observable<List<Mock>> oMocks, DynamicKeyGroup filterPage, EvictDynamicKey evictFilter);\r\n}\r\n```\r\n\r\n```java\r\npublic class Repository {\r\n    private final Providers providers;\r\n\r\n    public Repository(File cacheDir) {\r\n        providers = new RxCache.Builder()\r\n                .persistence(cacheDir, new GsonSpeaker())\r\n                .using(Providers.class);\r\n    }\r\n\r\n    public Observable<List<Mock>> getMocks(final boolean update) {\r\n        return providers.getMocksEvictProvider(getExpensiveMocks(), new EvictProvider(update));\r\n    }\r\n\r\n    public Observable<List<Mock>> getMocksPaginate(final int page, final boolean update) {\r\n        return providers.getMocksPaginateEvictingPerPage(getExpensiveMocks(), new DynamicKey(page), new EvictDynamicKey(update));\r\n    }\r\n\r\n    public Observable<List<Mock>> getMocksWithFiltersPaginate(final String filter, final int page, final boolean updateFilter) {\r\n        return providers.getMocksPaginateWithFiltersEvictingPerFilter(getExpensiveMocks(), new DynamicKeyGroup(filter, page), new EvictDynamicKey(updateFilter));\r\n    }\r\n\r\n    //In a real use case, here is when you build your observable with the expensive operation.\r\n    //Or if you are making http calls you can use Retrofit to get it out of the box.\r\n    private Observable<List<Mock>> getExpensiveMocks() {\r\n        return Observable.just(Arrays.asList(new Mock(\"\")));\r\n    }\r\n}\r\n```\r\n\r\n## Use cases\r\n* Using classic API RxCache for read actions with little write needs.\r\n* Using actionable API RxCache, exclusive for write actions.\r\n\r\n## Classic API RxCache:\r\n\r\nFollowing use cases illustrate some common scenarios which will help to understand the usage of `DynamicKey` and `DynamicKeyGroup` classes along with evicting scopes.\r\n\r\n### List\r\n\r\nList without evicting:\r\n```java\r\nObservable<List<Mock>> getMocks(Observable<List<Mock>> oMocks);\r\n```\r\n\r\nList evicting:\r\n```java\r\nObservable<List<Mock>> getMocksEvictProvider(Observable<List<Mock>> oMocks, EvictProvider evictProvider);\r\n```\r\n\r\n> Runtime usage:\r\n\r\n```java\r\n//Hit observable evicting all mocks\r\ngetMocksEvictProvider(oMocks, new EvictProvider(true))\r\n\r\n//This line throws an IllegalArgumentException: \"EvictDynamicKey was provided but not was provided any DynamicKey\"\r\ngetMocksEvictProvider(oMocks, new EvictDynamicKey(true))\r\n```\r\n\r\n### List Filtering\r\n\r\nList filtering without evicting:\r\n```java\r\nObservable<List<Mock>> getMocksFiltered(Observable<List<Mock>> oMocks, DynamicKey filter);\r\n```\r\n\r\n\r\nList filtering evicting:\r\n```java\r\nObservable<List<Mock>> getMocksFilteredEvict(Observable<List<Mock>> oMocks, DynamicKey filter, EvictProvider evictDynamicKey);\r\n```\r\n\r\n> Runtime usage:\r\n\r\n```java\r\n//Hit observable evicting all mocks using EvictProvider\r\ngetMocksFilteredEvict(oMocks, new DynamicKey(\"actives\"), new EvictProvider(true))\r\n\r\n//Hit observable evicting mocks of one filter using EvictDynamicKey\r\ngetMocksFilteredEvict(oMocks, new DynamicKey(\"actives\"), new EvictDynamicKey(true))\r\n\r\n//This line throws an IllegalArgumentException: \"EvictDynamicKeyGroup was provided but not was provided any Group\"\r\ngetMocksFilteredEvict(oMocks, new DynamicKey(\"actives\"), new EvictDynamicKeyGroup(true))\r\n```\r\n\r\n### List Paginated with filters\r\n\r\nList paginated with filters without evicting:\r\n```java\r\nObservable<List<Mock>> getMocksFilteredPaginate(Observable<List<Mock>> oMocks, DynamicKey filterAndPage);\r\n```\r\n\r\n\r\nList paginated with filters evicting:\r\n```java\r\nObservable<List<Mock>> getMocksFilteredPaginateEvict(Observable<List<Mock>> oMocks, DynamicKeyGroup filterAndPage, EvictProvider evictProvider);\r\n```\r\n\r\n> Runtime usage:\r\n\r\n```java\r\n//Hit observable evicting all mocks using EvictProvider\r\ngetMocksFilteredPaginateEvict(oMocks, new DynamicKeyGroup(\"actives\", \"page1\"), new EvictProvider(true))\r\n\r\n//Hit observable evicting all mocks pages of one filter using EvictDynamicKey\r\ngetMocksFilteredPaginateEvict(oMocks, new DynamicKeyGroup(\"actives\", \"page1\"), new EvictDynamicKey(true))\r\n\r\n//Hit observable evicting one page mocks of one filter using EvictDynamicKeyGroup\r\ngetMocksFilteredPaginateInvalidate(oMocks, new DynamicKeyGroup(\"actives\", \"page1\"), new EvictDynamicKeyGroup(true))\r\n```\r\n\r\nAs you may already notice, the whole point of using `DynamicKey` or `DynamicKeyGroup` along with `Evict` classes is to play with several scopes when evicting objects.\r\n\r\nThe above examples declare providers which their method signature accepts `EvictProvider` in order to be able to concrete more specifics types of `EvictProvider` at runtime.\r\n\r\nBut I have done that for demonstration purposes, you always should narrow the evicting classes in your method signature to the type which you really need. For the last example, I would use `EvictDynamicKey` in production code, because this way I would be able to paginate the filtered items and evict them per its filter, triggered by a pull to refresh for instance.\r\n\r\nNevertheless, there are complete examples for [Android and Java projects](https://github.com/VictorAlbertos/RxCacheSamples).\r\n\r\n## <a name=\"actionable_section\"></a>Actionable API RxCache:\r\n\r\n**Limitation: This actionable API only support `Observable` as Reactive type.**\r\n\r\nThis actionable api offers an easy way to perform write operations using providers. Although write operations could be achieved using the classic api too, it's much complex and error-prone. Indeed, the [Actions](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/ActionsList.java) class it's a wrapper around the classic api which play with evicting scopes and lists.\r\n\r\nIn order to use this actionable api, first you need to add the [repository compiler](https://github.com/VictorAlbertos/RxCache/tree/master/compiler) as a dependency to your project using an annotation processor. For Android, it would be as follows:\r\n\r\nAdd this line to your root build.gradle:\r\n\r\n```gradle\r\ndependencies {\r\n     // other classpath definitions here\r\n     classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\r\n }\r\n```\r\n\r\n\r\nThen make sure to apply the plugin in your app/build.gradle and add the compiler dependency:\r\n\r\n```gradle\r\napply plugin: 'com.neenbedankt.android-apt'\r\n\r\ndependencies {\r\n    // apt command comes from the android-apt plugin\r\n    apt \"com.github.VictorAlbertos.RxCache:compiler:1.8.3-2.x\"\r\n}\r\n```\r\n\r\nAfter this configuration, every provider annotated with [@Actionable](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Actionable.java) `annotation` \r\nwill expose an accessor method in a new generated class called with the same name as the interface, but appending an 'Actionable' suffix.\r\n\r\nThe order in the params supplies must be as in the following example:\r\n\r\n```java\r\npublic interface RxProviders {\r\n    @Actionable\r\n    Observable<List<Mock.InnerMock>> mocks(Observable<List<Mock.InnerMock>> message, EvictProvider evictProvider);\r\n\r\n    @Actionable\r\n    Observable<List<Mock>> mocksDynamicKey(Observable<List<Mock>> message, DynamicKey dynamicKey, EvictDynamicKey evictDynamicKey);\r\n\r\n    @Actionable\r\n    Observable<List<Mock>> mocksDynamicKeyGroup(Observable<List<Mock>> message, DynamicKeyGroup dynamicKeyGroup, EvictDynamicKeyGroup evictDynamicKey);\r\n}\r\n```\r\n\r\nThe observable value must be a `List`, otherwise an error will be thrown.\r\n\r\nThe previous RxProviders `interface` will expose the next accessors methods in the generated `RxProvidersActionable` class.\r\n```java\r\nRxProvidersActionable.mocks(RxProviders proxy);\r\nRxProvidersActionable.mocksDynamicKey(RxProviders proxy, DynamicKey dynamicKey);\r\nRxProvidersActionable.mocksDynamicKeyGroup(RxProviders proxy, DynamicKeyGroup dynamicKeyGroup);\r\n```\r\n\r\nThese methods return an instance of the `Actions` class, so now you are ready to use every write operation available in the [Actions](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/ActionsList.java) class. It is advisable to explore the [ActionsTest](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/test/java/io/rx_cache/internal/ActionsListTest.java) class to see what action fits better for your case. If you feel that some action has been missed please don't hesitate to open an issue to request it.\r\n\r\nSome actions examples:\r\n\r\n```java\r\nActionsProviders.mocks(rxProviders)\r\n    .addFirst(new Mock())\r\n    .addLast(new Mock())\r\n    //Add a new mock at 5 position\r\n    .add((position, count) -> position == 5, new Mock())\r\n\r\n    .evictFirst()\r\n    //Evict first element if the cache has already 300 records\r\n    .evictFirst(count -> count > 300)\r\n    .evictLast()\r\n    //Evict last element if the cache has already 300 records\r\n    .evictLast(count -> count > 300)\r\n    //Evict all inactive elements\r\n    .evictIterable((position, count, mock) -> mock.isInactive())\r\n    .evictAll()\r\n\r\n    //Update the mock with id 5\r\n    .update(mock -> mock.getId() == 5, mock -> {\r\n        mock.setActive();\r\n        return mock;\r\n    })\r\n    //Update all inactive mocks\r\n    .updateIterable(mock -> mock.isInactive(), mock -> {\r\n        mock.setActive();\r\n        return mock;\r\n    })\r\n    .toObservable()\r\n    .subscribe(processedMocks -> {})\r\n```\r\n\r\nEvery one of the previous actions will be execute only after the composed observable receives a subscription. This way, the underliyng provider cache will be modified its elements without effort at all.\r\n\r\n## <a name=\"migrations_section\"></a>Migrations\r\n\r\nRxCache provides a simple mechanism for handling migrations between releases.\r\n\r\nYou need to annotate your providers `interface` with [@SchemeMigration](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/SchemeMigration.java). This `annotation` accepts an array of [@Migration](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Migration.java) annotations, and, in turn, `@Migration` annotation accepts both, a version number and an array of `Class`es which will be deleted from persistence layer.\r\n\r\n```java\r\n@SchemeMigration({\r\n            @Migration(version = 1, evictClasses = {Mock.class}),\r\n            @Migration(version = 2, evictClasses = {Mock2.class}),\r\n            @Migration(version = 3, evictClasses = {Mock3.class})\r\n    })\r\ninterface Providers {}\r\n```\r\n\r\nYou want to annotate a new migration only when a new field has been added in a class model used by RxCache.\r\n\r\nDeleting classes or deleting fields of classes would be handle automatically by RxCache, so you don't need to annotate a new migration when a field or an entire class has been deleted.\r\n\r\nFor instance:\r\n\r\nA migration was added at some point. After that, a second one was added eventually.\r\n\r\n```java\r\n@SchemeMigration({\r\n            @Migration(version = 1, evictClasses = {Mock.class}),\r\n            @Migration(version = 2, evictClasses = {Mock2.class})\r\n    })\r\ninterface Providers {}\r\n```\r\n\r\nBut now `Mock` class has been deleted from the project, so it is impossible to reference its class anymore. To fix this, just delete the migration `annotation`.\r\n\r\n```java\r\n@SchemeMigration({\r\n            @Migration(version = 2, evictClasses = {Mock2.class})\r\n    })\r\ninterface Providers {}\r\n```\r\n\r\nBecause RxCache has an internal process to clean memory when it is required, the data will be evicted eventually.\r\n\r\n## <a name=\"encryption_section\"></a>Encryption\r\n\r\nRxCache provides a simple mechanism to encrypt the data.\r\n\r\nYou need to annotate your providers `interface` with [@EncryptKey](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/EncryptKey.java). This `annotation` accepts a string as the `key` necessary to encrypt/decrypt the data. But you will need to annotate your provider's records with [@Encrypt](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Encrypt.java) in order to saved the data encrypted. If no [@Encrypt](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Encrypt.java) is set, then no encryption will be held. \r\n\r\n**Important:** If the value of the `key` supplied on [@EncryptKey](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/EncryptKey.java) is modified between compilations, then the previous persisted data will not be able to be evicted/retrieved by RxCache. \r\n\r\n```java\r\n@EncryptKey(\"myStrongKey-1234\")\r\ninterface Providers {\r\n        @Encrypt\r\n        Observable<List<Mock>> getMocksEncrypted(Observable<List<Mock>> oMocks);\r\n\r\n        Observable<List<Mock>> getMocksNotEncrypted(Observable<List<Mock>> oMocks);\r\n}\r\n```\r\n\r\n## Configure general behaviour\r\n\r\nRxCache allows to set certain parameters when building the providers instance:\r\n\r\n### <a name=\"expirable_section\"></a>Configure the limit in megabytes for the data to be persisted\r\n\r\nBy default, RxCache sets the limit in 100 megabytes, but you can change this value by calling setMaxMBPersistenceCache method when building the provider instance.\r\n\r\n```java\r\nnew RxCache.Builder()\r\n            .setMaxMBPersistenceCache(maxMgPersistenceCache)\r\n            .persistence(cacheDir)\r\n            .using(Providers.class);\r\n```\r\n\r\nThis limit ensure that the disk will no grow up limitless in case you have providers with dynamic keys which values changes dynamically, like filters based on gps location or dynamic filters supplied by your back-end solution.\r\n\r\nWhen this limit is reached, RxCache will not be able to persist in disk new data. That's why RxCache has an automated process to evict any record when the threshold memory assigned to the persistence layer is close to be reached, even if the record life time has not been fulfilled.\r\n\r\nBut provider's record annotated with [@Expirable](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Expirable.java) annotation and set its value to false will be excluded from the process.\r\n\r\n```java\r\ninterface Providers {\r\n    @Expirable(false)\r\n    Observable<List<Mock>> getMocksNotExpirable(Observable<List<Mock>> oMocks);\r\n}\r\n```\r\n\r\n### Use expired data if loader not available\r\n\r\nBy default, RxCache will throw a RuntimeException if the cached data has expired and the data returned by the observable loader is null, \r\npreventing this way serving data which has been marked as evicted.\r\n\r\nYou can modify this behaviour, allowing RxCache serving evicted data when the loader has returned null values, by setting as true the value of useExpiredDataIfLoaderNotAvailable\r\n\r\n```java\r\nnew RxCache.Builder()\r\n            .useExpiredDataIfLoaderNotAvailable(true)\r\n            .persistence(cacheDir)\r\n            .using(Providers.class);\r\n```\r\n\r\n## Android considerations\r\n\r\nTo build an instance of the interface used as provides by RxCache, you need to supply a reference to a file system. On Android, you can get the File reference calling getFilesDir() from the [Android Application](http://developer.android.com/intl/es/reference/android/app/Application.html) class.\r\n\r\nAlso, it is recommended to use this Android Application class to provide a unique instance of RxCache for the entire life cycle of your application.\r\n\r\nIn order execute the Observable on a new thread, and emit results through onNext on the main UI thread, you should use the built in methods provided by [RxAndroid](https://github.com/ReactiveX/RxAndroid).\r\n\r\nCheck the [Android example](https://github.com/VictorAlbertos/RxCacheSamples/tree/master/sample_android)\r\n\r\n## Retrofit\r\n\r\nRxCache is the perfect match for Retrofit to create a repository of auto-managed-caching data pointing to endpoints. \r\nYou can check an [example](https://github.com/VictorAlbertos/RxCacheSamples/blob/master/sample_data/src/main/java/sample_data/Repository.java) of RxCache and Retrofit working together.\r\n\r\n## Internals\r\n\r\nRxCache serves the data from one of its three layers:\r\n\r\n* A memory layer -> Powered by [Apache ReferenceMap](https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/map/ReferenceMap.html).\r\n* A persisting layer -> RxCache uses internally [Jolyglot](https://github.com/VictorAlbertos/Jolyglot) for serialize and deserialize objects.\r\n* A loader layer (the observable supplied by the client library)\r\n\r\nThe policy is very simple: \r\n\r\n* If the data requested is in memory, and It has not been expired, get it from memory.\r\n* Else if the data requested is in persistence layer, and It has not been expired, get it from persistence.\r\n* Else get it from the loader layer. \r\n\r\n## Proguard\r\nProguard users MUST add the two given lines to their proguard configuration file and MUST use the `@ProviderKey` annotation method for every method that is being used as provider. Without the `@ProviderKey` annotation the method name will be used instead which can lead to providers that use the same name, see issue [#96](https://github.com/VictorAlbertos/RxCache/issues/96) for detailed information.\r\n\r\n```\r\n-dontwarn io.rx_cache2.internal.**\r\n-keepclassmembers enum io.rx_cache2.Source { *; }\r\n-keepclassmembernames class * { @io.rx_cache2.* <methods>; }\r\n```\r\n\r\n\r\n## Author\r\n\r\n**Víctor Albertos**\r\n\r\n* <https://twitter.com/_victorAlbertos>\r\n* <https://www.linkedin.com/in/victoralbertos>\r\n* <https://github.com/VictorAlbertos>\r\n\r\n## RxCache Swift version:\r\n[RxCache](https://github.com/VictorAlbertos/RxSCache): Reactive caching library for Swift.\r\n\r\n## Another author's libraries using RxJava:\r\n* [Mockery](https://github.com/VictorAlbertos/Mockery): Android and Java library for mocking and testing networking layers with built-in support for Retrofit.\r\n* [RxActivityResult](https://github.com/VictorAlbertos/RxActivityResult): A reactive-tiny-badass-vindictive library to break with the OnActivityResult implementation as it breaks the observables chain. \r\n* [RxFcm](https://github.com/VictorAlbertos/RxFcm): RxJava extension for Android Firebase Cloud Messaging (aka fcm).\r\n* [RxSocialConnect](https://github.com/VictorAlbertos/RxSocialConnect-Android): OAuth RxJava extension for Android.\r\n"
        },
        {
          "name": "README_ZH.md",
          "type": "blob",
          "size": 28.548828125,
          "content": "![Downloads](https://jitpack.io/v/VictorAlbertos/RxCache/month.svg)\n\n[![Android Arsenal](https://img.shields.io/badge/Android%20Arsenal-RxCache-green.svg?style=true)](https://android-arsenal.com/details/1/3016)\n\n# RxCache中文文档\n\n### [1 概述](#1)\n \n### [2 基本使用](#2)\n \n[2.1 依赖配置](#2.1)\n    \n[2.2 接口配置](#2.2)\n\n[2.3 新建Provider实例并使用它](#2.3)\n\n[2.4 再次回顾整个流程](#2.4)\n    \n### [3 RxCache使用场景](#3)\n \n### [4 RxCache API](#4)\n \n [4.1 EvictProvider:驱逐缓存数据](#4.1)\n\n [4.2 DynamicKey:筛选数据](#4.2)\n\n [4.3 DynamicKeyGroup:分页和过滤](#4.3)\n  \n### [5 Actionable RxCache API](#5)\n\n### [6 高级选项](#6)\n \n [6.1 数据迁移](#6.1)\n\n [6.2 数据加密](#6.2)\n\n [6.3 常规配置](#6.3)\n\n  [6.3.1  配置要保留的数据的大小限制（以兆字节为单位）](#6.3.1)\n\n  [6.3.2 如果未加载到数据，使用过期的缓存数据](#6.3.2)\n\n [6.4 Android注意事项](#6.4)\n\n [6.5 和Retrofit搭配使用](#6.5)\n\n### [7 其他](#7)\n    \n [7.1 RxCache原理](#7.1)\n\n [7.2 代码混淆](#7.2)\n\n [7.3 关于作者](#7.3)\n\n [7.4 RxCache Swift版本](#7.4)\n\n [7.5 作者其它使用RxJava的库](#7.5)\n \n### [8 关于中文文档](#8)\n \n## <h2 id=\"1\">概述</h2>\n\n本库的 **目标** 很简单: **就像[Picasso](https://github.com/square/picasso) 缓存您的图片一样，毫不费力缓存您的数据对象。** \n\n每个Android Application都是一个客户端应用程序，这意味着仅仅为缓存数据创建数据库并进行维护毫无意义。\n\n事实上，传统方式通过数据库来缓存数据并没有解决根本性的问题：以更加灵活简单的方式配置缓存。\n\n灵感来源于 [Retrofit](http://square.github.io/retrofit/) , **RxCache是一个用于Android和Java的响应式缓存库，它可将您的缓存需求转换为一个接口进行配置。** \n\n当提供一个 **`observable`, `single`, `maybe` or `flowable` (这些是RxJava2支持的响应式数据类型)** 这些由耗时操作提供的数据，RxCache确定是否需要subscribe，或覆盖先前缓存的数据。\n \n此决定是基于RxCache的Providers进行配置的。\n \n## <h2 id=\"2\">基本使用</h2>\n## <h3 id=\"2.1\">依赖配置</h3>\n\n在您的Project级的build.gradle中添加JitPack仓库：\n\n```gradle\nallprojects {\n    repositories {\n        jcenter()\n        maven { url \"https://jitpack.io\" }\n    }\n}\n```\n\n将下列的依赖添加到Module的build.gradle中：\n\n```gradle\ndependencies {\n    compile \"com.github.VictorAlbertos.RxCache:runtime:1.8.1-2.x\"\n    compile \"io.reactivex.rxjava2:rxjava:2.0.6\"\n}\n```\n\n因为RxCache在内部使用 [Jolyglot](https://github.com/VictorAlbertos/Jolyglot) 对数据进行序列化和反序列化, 您需要选择下列的依赖中选择一个进行添加：\n \n```gradle\ndependencies {\n    // To use Gson \n    compile 'com.github.VictorAlbertos.Jolyglot:gson:0.0.3'\n    \n    // To use Jackson\n    compile 'com.github.VictorAlbertos.Jolyglot:jackson:0.0.3'\n    \n    // To use Moshi\n    compile 'com.github.VictorAlbertos.Jolyglot:moshi:0.0.3'\n}\n```\n\n## <h3 id=\"2.2\">接口配置</h3> \n\n声明一个接口，常规使用方式中（以Retrofit网络请求为例），创建和API需求同样多的Providers来缓存您的数据。\n> 这意味着，项目中Retrofit的APIService接口有多少个抽象方法的API需要实现缓存，一一对应，就需要Providers提供多少个缓存API方法\n\n```java\ninterface Providers {\n        \n        @ProviderKey(\"mocks\")\n        Observable<List<Mock>> getMocks(Observable<List<Mock>> oMocks);\n    \n        @ProviderKey(\"mocks-5-minute-ttl\")\n        @LifeCache(duration = 5, timeUnit = TimeUnit.MINUTES)   //缓存有效期5分钟\n        Observable<List<Mock>> getMocksWith5MinutesLifeTime(Observable<List<Mock>> oMocks);\n    \n        @ProviderKey(\"mocks-evict-provider\")\n        Observable<List<Mock>> getMocksEvictProvider(Observable<List<Mock>> oMocks, EvictProvider evictProvider);\n    \n        @ProviderKey(\"mocks-paginate\")\n        Observable<List<Mock>> getMocksPaginate(Observable<List<Mock>> oMocks, DynamicKey page);\n    \n        @ProviderKey(\"mocks-paginate-evict-per-page\")\n        Observable<List<Mock>> getMocksPaginateEvictingPerPage(Observable<List<Mock>> oMocks, DynamicKey page, EvictDynamicKey evictPage);\n        \n        @ProviderKey(\"mocks-paginate-evict-per-filter\")\n        Observable<List<Mock>> getMocksPaginateWithFiltersEvictingPerFilter(Observable<List<Mock>> oMocks, DynamicKeyGroup filterPage, EvictDynamicKey evictFilter);\n}\n```\n\nRxCache暴露了`evictAll（）`方法来清除一行中的整个缓存。\n\nRxCache的Provider配置中，方法所需要的参数用来配置Provider处理缓存的方式：\n\n* 无论如何，必不可少的参数是RxJava提供的响应式基本数据类型（如Observable），这个参数的意义是将你想缓存的Retrofit接口作为参数传入，并以相同的RxJava数据类型作为返回。\n  > 这意味着，您可以不配置任何可选项，但是您必须将您要缓存的数据作为参数交给RxCache进行缓存.\n* [EvictProvider](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictProvider.java) 是否驱逐与该Provider相关联的所有缓存数据.\n  > 该对象通过构造方法进行实例化，创建时需要传入boolean类型的参数，当参数为true时，RxCache会直接驱逐该Provider的缓存数据，进行最新的网络请求并进行缓存；若参数为false，若缓存数据未过期，正常加载缓存数据\n* [@ProviderKey](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/ProviderKey.java) 保护用户数据的Provider方法的注解，强烈建议使用这个注解！ 如果不使用该注解，该方法的名称会被作为该Provider的key进行文件缓存, 使用了代码混淆的用户很快会遇到问题，详情请参阅 [Proguard](proguard) . 如果不使用代码混淆，该注解也很有用，因为它可以确保您可以随心所欲修改Provider数据缓存的方法名，而无需为旧缓存文件迁移问题而苦恼。\n  > 该注解是最近版本添加的，在考虑到代码混淆（方法名的改变导致缓存文件命名的改变）和缓存数据迁移,强烈建议使用该注解！\n* [EvictDynamicKey](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictDynamicKey.java) 是否驱逐具体的缓存数据 [DynamicKey](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/DynamicKey.java).\n  > 缓存数据驱逐范围比EvictProvider小（后者是驱逐所有缓存），比EvictDynamicKeyGroup大（后者是驱逐更精细分类的缓存），举例，若将userId（唯一）作为参数传入DynamicKey，清除缓存时，仅清除该userId下的对应缓存\n* [EvictDynamicKeyGroup](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictDynamicKeyGroup.java) 是否驱逐更加具体的缓存数据 [DynamicKeyGroup](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/DynamicKeyGroup.java).\n  > 和EvictDynamicKey对比，上述案例中，DynamicKeyGroup可以filter到某userId下缓存的某一页数据进行驱逐，其他缓存不驱逐\n* [DynamicKey](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/DynamicKey.java) 通过传入一个对象参数（比如userId）实现和对应缓存数据的绑定， 清除该key相关联的缓存数据请使用 `EvictDynamicKey`.\n* [DynamicKeyGroup](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/DynamicKeyGroup.java) 通过传入一个Group参数（比如userId，数据的分类）实现和对应缓存数据的绑定， 清除该keyGroup相关联的缓存数据请使用`EvictDynamicKeyGroup`.\n\nSupported annotations:\n\n* [@LifeCache](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/LifeCache.java) 设置缓存过期时间. 如果没有设置@LifeCache , 数据将被永久缓存，直到你使用了 [EvictProvider](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictProvider.java), [EvictDynamicKey](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictDynamicKey.java) or [EvictDynamicKeyGroup](https://github.com/VictorAlbertos/RxCache/blob/master/core/src/main/java/io/rx_cache/EvictDynamicKeyGroup.java) .\n* [@Actionable](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Actionable.java) 提供了使用提供程序执行写入操作的简单方法。 详情参考 [here](#actionable_section)\n* [@SchemeMigration](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/SchemeMigration.java) 和 [@Migration](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Migration.java) 提供了一种处理版本之间迁移的简单机制。 详情参考 [here](#migrations_section)\n* [@Expirable](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Expirable.java) 决定该Provider是否将被排除在清除范围之外.详情参考 [here](#expirable_section)\n* [@EncryptKey](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/EncryptKey.java) 和 [@Encrypt](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Encrypt.java) 提供了一种在持久层上加密/解密数据的简单方法。详情参考 [here](#encryption_section)\n\n### <h3 id=\"2.3\">新建Provider实例并使用它</h3> \n\n最后，使用RxCache.Builder实例化Provider接口，并提供一个有效的文件系统路径，这将允许RxCache在磁盘上写入缓存数据。\n\n```java\n//获取缓存的文件存放路径\nFile cacheDir = getFilesDir();\nProviders providers = new RxCache.Builder()\n                            .persistence(cacheDir, new GsonSpeaker())//配置缓存的文件存放路径，以及数据的序列化和反序列化\n                            .using(Providers.class);    //和Retrofit相似，传入缓存API的接口\n```\n\n### <h3 id=\"2.4\">再次回顾整个流程</h3> \n\n```java\ninterface Providers {\n    //配置要缓存的数据，以及是否驱逐缓存数据并请求网络\n    @ProviderKey(\"mocks-evict-provider\")\n    Observable<List<Mock>> getMocksEvictProvider(Observable<List<Mock>> oMocks, EvictProvider evictProvider);\n    \n    //配置要缓存的数据，简单的缓存数据分类，以及是否驱逐该分类下的缓存数据并请求网络\n    @ProviderKey(\"mocks-paginate-evict-per-page\")\n    Observable<List<Mock>> getMocksPaginateEvictingPerPage(Observable<List<Mock>> oMocks, DynamicKey page, EvictDynamicKey evictPage);\n    \n    //配置要缓存的数据，复杂的缓存数据分类，以及是否驱逐该详细分类下的缓存数据并请求网络\n    @ProviderKey(\"mocks-paginate-evict-per-filter\")\n    Observable<List<Mock>> getMocksPaginateWithFiltersEvictingPerFilter(Observable<List<Mock>> oMocks, DynamicKeyGroup filterPage, EvictDynamicKey evictFilter);\n}\n```\n\n```java\npublic class Repository {\n    private final Providers providers;\n    \n    //初始化RxCache的Provider\n    public Repository(File cacheDir) {\n        providers = new RxCache.Builder()\n                .persistence(cacheDir, new GsonSpeaker())\n                .using(Providers.class);\n    }\n    \n    //参数update：是否加载最新数据\n    public Observable<List<Mock>> getMocks(final boolean update) {\n        return providers.getMocksEvictProvider(getExpensiveMocks(), new EvictProvider(update));\n    }\n    \n    //参数page：第几页的数据，update：是否加载该页的最新数据\n    public Observable<List<Mock>> getMocksPaginate(final int page, final boolean update) {\n        return providers.getMocksPaginateEvictingPerPage(getExpensiveMocks(), new DynamicKey(page), new EvictDynamicKey(update));\n    }\n    \n    //参数filter：某个条件（比如userName），参数page：第几页数据，参数updateFilter：是否加载该userName该页的最新数据\n    public Observable<List<Mock>> getMocksWithFiltersPaginate(final String filter, final int page, final boolean updateFilter) {\n        return providers.getMocksPaginateWithFiltersEvictingPerFilter(getExpensiveMocks(), new DynamicKeyGroup(filter, page), new EvictDynamicKey(updateFilter));\n    }\n\n    //这个方法的返回值代替了现实开发中，您通过耗时操作获得的数据类型（比如Observable<T>）\n    //如果这里您使用了Retrofit进行网络请求，那么可以说是拿来即用。\n    private Observable<List<Mock>> getExpensiveMocks() {\n        return Observable.just(Arrays.asList(new Mock(\"\")));\n    }\n}\n```\n\n## <h2 id=\"3\">RxCache使用场景</h2>\n\n* 使用经典的RxCache API进行文件的读写操作。\n* 使用Actionable的API，专用于文件的写操作。\n\n## <h2 id=\"4\">RxCache API</h2>\n\n下面的用例说明了一些常见的情况，这将有助于您了解“DynamicKey”和“DynamicKeyGroup”类的使用以及清除数据。\n\n### <h3 id=\"4.1\">EvictProvider:驱逐缓存数据</h3>\n\n不驱逐数据\n```java\nObservable<List<Mock>> getMocks(Observable<List<Mock>> oMocks);\n```\n\n驱逐数据\n```java\nObservable<List<Mock>> getMocksEvictProvider(Observable<List<Mock>> oMocks, EvictProvider evictProvider);\n```\n\n> 业务代码中使用:\n\n```java\n\n//接收到Observable时驱逐该Provider所有缓存数据并重新请求\ngetMocksEvictProvider(oMocks, new EvictProvider(true))\n\n//这行会抛出一个IllegalArgumentException：“提供了EvictDynamicKey但没有提供任何DynamicKey”\ngetMocksEvictProvider(oMocks, new EvictDynamicKey(true))\n```\n\n### <h3 id=\"4.2\">DynamicKey:筛选数据</h3>\n\n指定某个条件，不驱逐该条件下的缓存数据\n```java\nObservable<List<Mock>> getMocksFiltered(Observable<List<Mock>> oMocks, DynamicKey filter);\n```\n\n指定某个条件，可选择是否驱逐该条件下的缓存数据\n```java\nObservable<List<Mock>> getMocksFilteredEvict(Observable<List<Mock>> oMocks, DynamicKey filter, EvictProvider evictDynamicKey);\n```\n\n> 业务代码中使用:\n\n```java\n\n//接收到Observable时驱逐该Provider所有缓存数据并重新请求\ngetMocksFilteredEvict(oMocks, new DynamicKey(\"actives\"), new EvictProvider(true))\n\n//通过使用EvictDynamicKey，接收到Observable时，驱逐该DynamicKey（\"actives\"）下所有缓存数据并重新请求\ngetMocksFilteredEvict(oMocks, new DynamicKey(\"actives\"), new EvictDynamicKey(true))\n\n//这行抛出一个IllegalArgumentException：“提供了EvictDynamicKeyGroup，但没有提供任何DynamicKeyGroup”\ngetMocksFilteredEvict(oMocks, new DynamicKey(\"actives\"), new EvictDynamicKeyGroup(true))\n```\n\n### <h3 id=\"4.3\">DynamicKeyGroup:分页和过滤</h3>\n\nList数据的分页和过滤，不驱逐缓存数据\n```java\nObservable<List<Mock>> getMocksFilteredPaginate(Observable<List<Mock>> oMocks, DynamicKey filterAndPage);\n```\n\n\nList数据的分页和过滤，包含是否驱逐缓存数据选项\n```java\nObservable<List<Mock>> getMocksFilteredPaginateEvict(Observable<List<Mock>> oMocks, DynamicKeyGroup filterAndPage, EvictProvider evictProvider);\n```\n\n> 运行时使用:\n\n```java\n\n//接收到Observable时驱逐该Provider所有缓存数据并重新请求\ngetMocksFilteredPaginateEvict(oMocks, new DynamicKeyGroup(\"actives\", \"page1\"), new EvictProvider(true))\n\n//通过使用EvictDynamicKey，接收到Observable时，驱逐该DynamicKey(\"actives\", \"page1\")下所有缓存数据并重新请求\ngetMocksFilteredPaginateEvict(oMocks, new DynamicKeyGroup(\"actives\", \"page1\"), new EvictDynamicKey(true))\n\n//通过使用EvictDynamicKey，接收到Observable时，驱逐该DynamicKeyGroup(\"actives\", \"page1\")下所有缓存数据并重新请求\ngetMocksFilteredPaginateInvalidate(oMocks, new DynamicKeyGroup(\"actives\", \"page1\"), new EvictDynamicKeyGroup(true))\n```\n\n正如你所看到的，使用“DynamicKey”或“DynamicKeyGroup”以及“EvictProvider”类的重点就是在根据不同范围下，驱逐缓存数据对象。\n\n上述示例代码中展示了方法接收“EvictProvider”的参数，以及EvictProvider的子类DynamicKey、DynamicKeyGroup，保证更详细的数据分类和筛选，并进行缓存。\n\n上述代码中，我已经做到了这一点，您总是可以通过自己的筛选，将数据的key类别缩小到你真正需要驱逐的类型。对于最后一个例子，我将在实际产品代码中使用“EvictDynamicKey”，因为这样我就可以对已过滤的项目进行分页，并将其按过滤器排除，例如通过刷新来触发。\n\n这里还有完整的例子 [Android and Java projects](https://github.com/VictorAlbertos/RxCacheSamples).\n\n## <h2 id=\"5\">Actionable RxCache API</h2>\n\n**限制：目前actionable的API仅支持Observable的数据类型。**\n\n这个actionable的API提供了一种Application执行文件写入操作的简单方法。 尽管使用RxCache经典的api也可以实现写入操作，但经典的api有着复杂性且容易出错。实际上，[Actions](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/ActionsList.java)类是围绕经典api的进行了一层包装。\n\n为了能够使用该actionable API，首先，你需要添加 [repository compiler](https://github.com/VictorAlbertos/RxCache/tree/master/compiler) 的依赖到您的build.gradle:\n\n\n```gradle\ndependencies {\n     // other classpath definitions here\n     classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\n }\n```\n\n然后确保在您的app / build.gradle中应用该插件，并添加编译器依赖关系：\n\n```gradle\napply plugin: 'com.neenbedankt.android-apt'\n\ndependencies {\n    // apt command comes from the android-apt plugin\n    apt \"com.github.VictorAlbertos.RxCache:compiler:1.8.0-1.x\"\n}\n```\n\n配置完成后，为每个Provider添加注解 [@Actionable](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Actionable.java) `annotation` \n\n编译器会生成一个新的类，该类与接口名称相同，但是附加了一个“Actionable”后缀，并暴露出和该接口同样多的方法\n\n参数供应中的顺序必须与以下示例保持一致：\n\n```java\npublic interface RxProviders {\n    @Actionable\n    Observable<List<Mock.InnerMock>> mocks(Observable<List<Mock.InnerMock>> message, EvictProvider evictProvider);\n\n    @Actionable\n    Observable<List<Mock>> mocksDynamicKey(Observable<List<Mock>> message, DynamicKey dynamicKey, EvictDynamicKey evictDynamicKey);\n\n    @Actionable\n    Observable<List<Mock>> mocksDynamicKeyGroup(Observable<List<Mock>> message, DynamicKeyGroup dynamicKeyGroup, EvictDynamicKeyGroup evictDynamicKey);\n}\n```\n\n请注意，Observable内的值必须是“List”类型，否则将抛出异常。\n\n这样上面的RxProviders接口将会在生成的“RxProvidersActionable”类中暴露出下面的方法：\n\n```java\nRxProvidersActionable.mocks(RxProviders proxy);\nRxProvidersActionable.mocksDynamicKey(RxProviders proxy, DynamicKey dynamicKey);\nRxProvidersActionable.mocksDynamicKeyGroup(RxProviders proxy, DynamicKeyGroup dynamicKeyGroup);\n```\n\n这些方法返回“Actions”类的一个实例，现在你已经可以尝试使用每个可用的写操作 [Actions](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/ActionsList.java) .建议您浏览[ActionsTest](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/test/java/io/rx_cache/internal/ActionsListTest.java)类，以查看哪些操作适合更适合你的现实需求。\n\n一些示例代码：\n\n```java\nActionsProviders.mocks(rxProviders)\n    .addFirst(new Mock())\n    .addLast(new Mock())\n    //Add a new mock at 5 position\n    .add((position, count) -> position == 5, new Mock())\n\n    .evictFirst()\n    //Evict first element if the cache has already 300 records\n    .evictFirst(count -> count > 300)\n    .evictLast()\n    //Evict last element if the cache has already 300 records\n    .evictLast(count -> count > 300)\n    //Evict all inactive elements\n    .evictIterable((position, count, mock) -> mock.isInactive())\n    .evictAll()\n\n    //Update the mock with id 5\n    .update(mock -> mock.getId() == 5, mock -> {\n        mock.setActive();\n        return mock;\n    })\n    //Update all inactive mocks\n    .updateIterable(mock -> mock.isInactive(), mock -> {\n        mock.setActive();\n        return mock;\n    })\n    .toObservable()\n    .subscribe(processedMocks -> {})\n```\n\n之前的每个Action只有在composed的observable接收到subscribe之后才会执行。\n\n## <h2 id=\"6\">高级选项</h2>\n\n## <h3 id=\"6.1\">数据迁移</h3>\n\nRxCache提供了一种处理版本之间缓存数据迁移的简单方式。\n\n> 简单来说，最新的版本中某个接口返回值类型内部发生了改变,从而获取数据的方式发生了改变,但是存储在本地的数据,是未改变的版本,这样在反序列化时就可能发生错误,为了规避这个风险,作者就加入了数据迁移的功能\n\n您需要为您的Provider接口添加注解 [@SchemeMigration](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/SchemeMigration.java). 这个注解接受一个数组 [@Migration](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Migration.java) ，反过来，Migration注释同时接受一个版本号和一个Classes的数组，这些数组将从持久层中删除。\n\n```java\n@SchemeMigration({\n            @Migration(version = 1, evictClasses = {Mock.class}),\n            @Migration(version = 2, evictClasses = {Mock2.class}),\n            @Migration(version = 3, evictClasses = {Mock3.class})\n    })\ninterface Providers {}\n```\n\n只有当RxCache使用的Class类中数据结构发生了改变，才需要添加新的迁移注解。\n> 比如说，您的缓存数据User中有 int userId这个属性，新的版本中变成了 long userId,这样缓存数据的反序列化就会出现问题，因此需要配置迁移注解\n\n删除类或删除类的字段将由RxCache自动处理，因此当字段或整个类被删除时，不需要迁移新的注解。\n\n```java\n@SchemeMigration({\n            @Migration(version = 1, evictClasses = {Mock.class}),\n            @Migration(version = 2, evictClasses = {Mock2.class})\n    })\ninterface Providers {}\n```\n\n但是现在，“Mock”类已经从项目中删除了，所以不可能再引用它的类了。 要解决这个问题，只需删除这行迁移的注解即可。\n\n```java\n@SchemeMigration({\n            @Migration(version = 2, evictClasses = {Mock2.class})\n    })\ninterface Providers {}\n```\n\n因为RxCache需要内部进程才能清理内存，所以数据最终将被全部清除。\n\n## <h3 id=\"6.2\">数据加密</h3>\n\nRxCache提供了一种加密数据的简单机制。\n\n您需要为您的Provider接口添加注解[@EncryptKey](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/EncryptKey.java). 这个`annotation`接受一个字符串作为加密/解密数据所必需的`key`。 但是，您需要使用[@Encrypt](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Encrypt.java)对Provider的缓存进行注解，以便缓存数据加密。 如果没有设置[@Encrypt](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Encrypt.java)，则不会进行加密。\n\n**重要提示：**如果提供的“key”值 [@EncryptKey](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/EncryptKey.java) 在编译期间进行了修改，那么以前的缓存数据将无法被RxCache驱逐/获取。\n\n```java\n@EncryptKey(\"myStrongKey-1234\")\ninterface Providers {\n        @Encrypt\n        Observable<List<Mock>> getMocksEncrypted(Observable<List<Mock>> oMocks);\n\n        Observable<List<Mock>> getMocksNotEncrypted(Observable<List<Mock>> oMocks);\n}\n```\n## <h3 id=\"6.3\">常规配置</h3>\n\nRxCache允许在构建Provider实例时设置某些参数：\n\n### <h4 id=\"6.3.1\">配置要保留的数据的大小限制（以兆字节为单位）</h4>\n\n默认情况下，RxCache将限制设置为100M，但您可以在构建Provider实例时调用setMaxMBPersistenceCache方法来更改此值。\n\n```java\nnew RxCache.Builder()\n            .setMaxMBPersistenceCache(maxMgPersistenceCache)\n            .persistence(cacheDir)\n            .using(Providers.class);\n```\n\n当达到此限制时，RxCache将无法继续缓存数据。 这就是为何当缓存数据容量即将达到阈值时，RxCache有一个自动化的过程来驱逐任何记录，即使没有满足失效时间的缓存数据也被驱逐。\n\n唯一的例外是，当您的Provider的某方法用[@Expirable](https://github.com/VictorAlbertos/RxCache/blob/master/runtime/src/main/java/io/rx_cache/Expirable.java) 注解注释，并将其值设置为false将会被保存，而不会被RxCache自动化驱逐。\n\n```java\ninterface Providers {\n    //即使缓存数据达到阈值，也不会被RxCache自动驱逐\n    @Expirable(false)\n    Observable<List<Mock>> getMocksNotExpirable(Observable<List<Mock>> oMocks);\n}\n```\n\n### <h4 id=\"6.3.2\">如果未加载到数据，使用过期的缓存数据</h4>\n\n默认情况下，如果缓存的数据已过期并且observable loader返回的数据为空，RxCache将抛出RuntimeException异常。\n\n您可以修改此行为，允许RxCache在这种情况下提供被驱逐的数据，使用方式很简单，通过将useExpiredDataIfLoaderNotAvailable的值设置为true：\n\n```java\nnew RxCache.Builder()\n            .useExpiredDataIfLoaderNotAvailable(true)   //RxCache提供被驱逐的数据\n            .persistence(cacheDir)\n            .using(Providers.class);\n```\n\n## <h3 id=\"6.4\">Android注意事项</h3>\n\n要构建由RxCache提供的接口实例，您需要提供对文件系统的引用。 在Android上，您可以从[Application](http://developer.android.com/intl/es/reference/android/app/Application.html)类获取文件引用调用getFilesDir（）。\n\n此外，建议您在应用程序的整个生命周期中使用此Android应用程序类来提供RxCache的唯一实例(全局单例)。\n\n为了在子线程上执行Observable，并通过主UI线程上的onNext发出结果，您应该使用[RxAndroid](https://github.com/ReactiveX/RxAndroid)提供的内置方法。\n\n> 即 observable.subscribeOn(Schedulers.io())\n               .observeOn(AndroidSchedulers.mainThread())\n               .subscribe();\n\n你可以查看Demo： [Android example](https://github.com/VictorAlbertos/RxCacheSamples/tree/master/sample_android)\n\n## <h3 id=\"6.5\">和Retrofit搭配使用</h3>\n\nRxCache和Retrofit完美搭配，两者配合可以实现从始至终的自动管理缓存数据库。\n您可以检查RxCache和Retrofit的一个[示例](https://github.com/VictorAlbertos/RxCacheSamples/blob/master/sample_data/src/main/java/sample_data/Repository.java)。\n\n\n## <h2 id=\"7\">其他</h2>\n\n## <h3 id=\"7.1\">RxCache原理</h3>\n\nRxCache的数据来源取决于下面三个数据层中某一层：\n\n*内存层 - >由[Apache ReferenceMap](https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/map/ReferenceMap.html)提供支持。\n*持久层 - > RxCache内部使用[Jolyglot](https://github.com/VictorAlbertos/Jolyglot)来对对象进行序列化和反序列化。\n*加载器层（由客户端库提供的Observable请求，比如网络请求）\n\n*如果请求的数据在内存中，并且尚未过期，则从内存中获取。\n*否则请求的数据在持久层中，并且尚未过期，则从持久层获取。\n*否则从加载器层请求获取数据。\n\n## <h3 id=\"7.2\">代码混淆</h3>\n\n```\n-dontwarn io.rx_cache.internal.**\n-keepclassmembers enum io.rx_cache.Source { *; }\n```\n\n\n## <h3 id=\"7.3\">关于作者</h3>\n\n**Víctor Albertos**\n\n* <https://twitter.com/_victorAlbertos>\n* <https://www.linkedin.com/in/victoralbertos>\n* <https://github.com/VictorAlbertos>\n\n## <h3 id=\"7.4\">RxCache Swift版本：</h3>\n[RxCache](https://github.com/VictorAlbertos/RxSCache): Reactive caching library for Swift.\n\n## <h3 id=\"7.5\">作者其它使用RxJava的库:</h3>\n* [Mockery](https://github.com/VictorAlbertos/Mockery): Android and Java library for mocking and testing networking layers with built-in support for Retrofit.\n* [RxActivityResult](https://github.com/VictorAlbertos/RxActivityResult): A reactive-tiny-badass-vindictive library to break with the OnActivityResult implementation as it breaks the observables chain. \n* [RxFcm](https://github.com/VictorAlbertos/RxFcm): RxJava extension for Android Firebase Cloud Messaging (aka fcm).\n* [RxSocialConnect](https://github.com/VictorAlbertos/RxSocialConnect-Android): OAuth RxJava extension for Android.\n\n## <h2 id=\"8\">关于中文文档</h2>\n\n### 翻译\n\n* 翻译：[qingmei2](https://github.com/qingmei2) \n\n### 参考\n\n* [《你不知道的Retrofit缓存库RxCache》](http://www.jianshu.com/p/b58ef6b0624b)by [@JessYan](https://github.com/JessYanCoding):讲述了RxCache的使用，以及相关功能的原理分析。\n\n"
        },
        {
          "name": "android",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.gradle",
          "type": "blob",
          "size": 0.515625,
          "content": "// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n  repositories {\n    jcenter()\n    google()\n  }\n  dependencies {\n    classpath 'com.android.tools.build:gradle:2.3.3'\n    // NOTE: Do not place your application dependencies here; they belong\n    // in the individual module build.gradle files\n  }\n}\n\nallprojects {\n  repositories {\n    jcenter()\n    maven { url 'https://jitpack.io' }\n    google()\n  }\n}\n\ntask clean(type: Delete) {\n  delete rootProject.buildDir\n}\n"
        },
        {
          "name": "compiler",
          "type": "tree",
          "content": null
        },
        {
          "name": "core",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradle.properties",
          "type": "blob",
          "size": 0.8349609375,
          "content": "# Project-wide Gradle settings.\n\n# IDE (e.g. Android Studio) users:\n# Gradle settings configured through the IDE *will override*\n# any settings specified in this file.\n\n# For more details on how to configure your build environment visit\n# http://www.gradle.org/docs/current/userguide/build_environment.html\n\n# Specifies the JVM arguments used for the daemon process.\n# The setting is particularly useful for tweaking memory settings.\n# Default value: -Xmx10248m -XX:MaxPermSize=256m\n# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8\n\n# When configured, Gradle will run in incubating parallel mode.\n# This option should only be used with decoupled projects. More details, visit\n# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects\n# org.gradle.parallel=true"
        },
        {
          "name": "gradle",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradlew",
          "type": "blob",
          "size": 4.8544921875,
          "content": "#!/usr/bin/env bash\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\"\"\n\nAPP_NAME=\"Gradle\"\nAPP_BASE_NAME=`basename \"$0\"`\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD=\"maximum\"\n\nwarn ( ) {\n    echo \"$*\"\n}\n\ndie ( ) {\n    echo\n    echo \"$*\"\n    echo\n    exit 1\n}\n\n# OS specific support (must be 'true' or 'false').\ncygwin=false\nmsys=false\ndarwin=false\ncase \"`uname`\" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\nesac\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG=\"$0\"\n# Need this for relative symlinks.\nwhile [ -h \"$PRG\" ] ; do\n    ls=`ls -ld \"$PRG\"`\n    link=`expr \"$ls\" : '.*-> \\(.*\\)$'`\n    if expr \"$link\" : '/.*' > /dev/null; then\n        PRG=\"$link\"\n    else\n        PRG=`dirname \"$PRG\"`\"/$link\"\n    fi\ndone\nSAVED=\"`pwd`\"\ncd \"`dirname \\\"$PRG\\\"`/\" >/dev/null\nAPP_HOME=\"`pwd -P`\"\ncd \"$SAVED\" >/dev/null\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n \"$JAVA_HOME\" ] ; then\n    if [ -x \"$JAVA_HOME/jre/sh/java\" ] ; then\n        # IBM's JDK on AIX uses strange locations for the executables\n        JAVACMD=\"$JAVA_HOME/jre/sh/java\"\n    else\n        JAVACMD=\"$JAVA_HOME/bin/java\"\n    fi\n    if [ ! -x \"$JAVACMD\" ] ; then\n        die \"ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\n    fi\nelse\n    JAVACMD=\"java\"\n    which java >/dev/null 2>&1 || die \"ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ \"$cygwin\" = \"false\" -a \"$darwin\" = \"false\" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ \"$MAX_FD\" = \"maximum\" -o \"$MAX_FD\" = \"max\" ] ; then\n            MAX_FD=\"$MAX_FD_LIMIT\"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn \"Could not set maximum file descriptor limit: $MAX_FD\"\n        fi\n    else\n        warn \"Could not query maximum file descriptor limit: $MAX_FD_LIMIT\"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS=\"$GRADLE_OPTS \\\"-Xdock:name=$APP_NAME\\\" \\\"-Xdock:icon=$APP_HOME/media/gradle.icns\\\"\"\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed \"$APP_HOME\"`\n    CLASSPATH=`cygpath --path --mixed \"$CLASSPATH\"`\n    JAVACMD=`cygpath --unix \"$JAVACMD\"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=\"\"\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS=\"$ROOTDIRS$SEP$dir\"\n        SEP=\"|\"\n    done\n    OURCYGPATTERN=\"(^($ROOTDIRS))\"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ \"$GRADLE_CYGPATTERN\" != \"\" ] ; then\n        OURCYGPATTERN=\"$OURCYGPATTERN|($GRADLE_CYGPATTERN)\"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in \"$@\" ; do\n        CHECK=`echo \"$arg\"|egrep -c \"$OURCYGPATTERN\" -`\n        CHECK2=`echo \"$arg\"|egrep -c \"^-\"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed \"$arg\"`\n        else\n            eval `echo args$i`=\"\\\"$arg\\\"\"\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- \"$args0\" ;;\n        (2) set -- \"$args0\" \"$args1\" ;;\n        (3) set -- \"$args0\" \"$args1\" \"$args2\" ;;\n        (4) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" ;;\n        (5) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" ;;\n        (6) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" ;;\n        (7) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" ;;\n        (8) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" ;;\n        (9) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" \"$args8\" ;;\n    esac\nfi\n\n# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules\nfunction splitJvmOpts() {\n    JVM_OPTS=(\"$@\")\n}\neval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS\nJVM_OPTS[${#JVM_OPTS[*]}]=\"-Dorg.gradle.appname=$APP_BASE_NAME\"\n\nexec \"$JAVACMD\" \"${JVM_OPTS[@]}\" -classpath \"$CLASSPATH\" org.gradle.wrapper.GradleWrapperMain \"$@\"\n"
        },
        {
          "name": "gradlew.bat",
          "type": "blob",
          "size": 2.34765625,
          "content": "@if \"%DEBUG%\" == \"\" @echo off\r\n@rem ##########################################################################\r\n@rem\r\n@rem  Gradle startup script for Windows\r\n@rem\r\n@rem ##########################################################################\r\n\r\n@rem Set local scope for the variables with windows NT shell\r\nif \"%OS%\"==\"Windows_NT\" setlocal\r\n\r\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\r\nset DEFAULT_JVM_OPTS=\r\n\r\nset DIRNAME=%~dp0\r\nif \"%DIRNAME%\" == \"\" set DIRNAME=.\r\nset APP_BASE_NAME=%~n0\r\nset APP_HOME=%DIRNAME%\r\n\r\n@rem Find java.exe\r\nif defined JAVA_HOME goto findJavaFromJavaHome\r\n\r\nset JAVA_EXE=java.exe\r\n%JAVA_EXE% -version >NUL 2>&1\r\nif \"%ERRORLEVEL%\" == \"0\" goto init\r\n\r\necho.\r\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\r\necho.\r\necho Please set the JAVA_HOME variable in your environment to match the\r\necho location of your Java installation.\r\n\r\ngoto fail\r\n\r\n:findJavaFromJavaHome\r\nset JAVA_HOME=%JAVA_HOME:\"=%\r\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\r\n\r\nif exist \"%JAVA_EXE%\" goto init\r\n\r\necho.\r\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\r\necho.\r\necho Please set the JAVA_HOME variable in your environment to match the\r\necho location of your Java installation.\r\n\r\ngoto fail\r\n\r\n:init\r\n@rem Get command-line arguments, handling Windowz variants\r\n\r\nif not \"%OS%\" == \"Windows_NT\" goto win9xME_args\r\nif \"%@eval[2+2]\" == \"4\" goto 4NT_args\r\n\r\n:win9xME_args\r\n@rem Slurp the command line arguments.\r\nset CMD_LINE_ARGS=\r\nset _SKIP=2\r\n\r\n:win9xME_args_slurp\r\nif \"x%~1\" == \"x\" goto execute\r\n\r\nset CMD_LINE_ARGS=%*\r\ngoto execute\r\n\r\n:4NT_args\r\n@rem Get arguments from the 4NT Shell from JP Software\r\nset CMD_LINE_ARGS=%$\r\n\r\n:execute\r\n@rem Setup the command line\r\n\r\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\r\n\r\n@rem Execute Gradle\r\n\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\r\n\r\n:end\r\n@rem End local scope for the variables with windows NT shell\r\nif \"%ERRORLEVEL%\"==\"0\" goto mainEnd\r\n\r\n:fail\r\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\r\nrem the _cmd.exe /c_ return code!\r\nif  not \"\" == \"%GRADLE_EXIT_CONSOLE%\" exit 1\r\nexit /b 1\r\n\r\n:mainEnd\r\nif \"%OS%\"==\"Windows_NT\" endlocal\r\n\r\n:omega\r\n"
        },
        {
          "name": "runtime",
          "type": "tree",
          "content": null
        },
        {
          "name": "settings.gradle",
          "type": "blob",
          "size": 0.0517578125,
          "content": "include ':core', ':android', ':compiler', ':runtime'\n"
        }
      ]
    }
  ]
}