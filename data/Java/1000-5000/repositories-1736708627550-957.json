{
  "metadata": {
    "timestamp": 1736708627550,
    "page": 957,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "iqiyi/Andromeda",
      "stars": 2276,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.53515625,
          "content": "# built application files\n*.apk\n*.ap_\n\n# files for the dex VM\n*.dex\n\n# Java class files\n*.class\n\n# generated files\nbin/\ngen/\n\n# Local configuration file (sdk path, etc)\nlocal.properties\ngradle.properties\n\n\n# Eclipse project files\n.classpath\n.project\n\n# Proguard folder generated by Eclipse\nproguard/\n\n# Intellij project files\n*.iml\n*.ipr\n*.iws\n.idea/\nout/\nbuild/\n**/build/\n\n.DS_Store\n.DS_Store?\n\n.gradle\nproduction/\n\nsigning.properties\n\n*~\n#extras/external_tagsoup/\n\nmodule/\ncaptures/\n\n*.pub\n\nfreeline/\nfreeline.py\nfreeline_project_description.json"
        },
        {
          "name": "Andromeda-Lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "Andromeda-Plugin",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHINESE_README.md",
          "type": "blob",
          "size": 13.7587890625,
          "content": "# Andromeda\n![Andromeda_license](https://img.shields.io/badge/license-BSD--3--Clause-brightgreen.svg)\n![Andromeda_core_tag](https://img.shields.io/badge/Andromeda%20Core-1.1.8-brightgreen.svg)\n![Andromeda_plugin_tag](https://img.shields.io/badge/Andromeda%20plugin-1.1.1-brightgreen.svg)\n\nAndromeda提供了接口式的组件间通信管理，包括同进程的本地接口调用和跨进程接口调用。\n\n**注:之所以分成本地服务和远程服务这两种，是由于本地服务的接口可以传递各种类型的参数和返回值，而远程接口则受AIDL的限制，参数和返回值只能是基本类型或者实现了Parcelable接口的自定义类型。**\n\n# 特色\n\n+ 无需开发者进行bindService()操作,也不用定义Service,只需要定义aidl接口和实现\n\n+ 同步获取服务。抛弃了bindService()这种异步获取的方式，改造成了同步获取\n\n+ 生命周期自动管理。可根据Fragment或Activity的生命周期进行提高或降低服务提供方进程的操作\n\n+ 支持IPC的Callback，并且支持跨进程的事件总线\n\n+ 采用\"接口+数据结构\"的方式来实现组件间通信，这种方式相比协议的方式在于实现简单，维护方便\n\n\n**注意这里的服务不是Android中四大组件的Service,而是指提供的接口与实现。为了表示区分，后面的服务均是这个含义，而Service则是指Android中的组件。**\n\nAndromeda和其他组件间通信方案的对比如下:\n\n|                            | 易用性  | IPC性能 | 支持IPC | 支持跨进程事件总线 | 支持IPC Callback |\n| :------------------------: | :--: | :---: | :---: | :-------: | :------------: |\n|         Andromeda          |  好   |   高   |  Yes  |    Yes    |      Yes       |\n|   DDComponentForAndroid    |  较差  |  --   |  No   |    No     |       No       |\n| ModularizationArchitecture |  较差  |   低   |  Yes  |    No     |       No       |\n\n\n# 接入方式\n首先在buildscript中添加classpath(请使用最新的版本名称来替换$version):\n```groovy\n    classpath \"org.qiyi.video.svg:plugin:$version\"\n```\n这两个分别是核心代码库和gradle插件库的路径。\n在Application或library Module中使用核心库:\n```groovy\n    implementation \"org.qiyi.video.svg:core:$version\"\n```\n在application Module中使用gradle插件:\n```groovy\n    apply plugin: 'org.qiyi.svg.plugin'\n```\n\n# 使用方式\n## 为Dispatcher配置进程\n由于Dispatcher负责管理所有进程信息，所以它应该运行在存活时间最长的进程中。\n如果不进行配置，Dispatcher默认运行在主进程中。\n但是考虑到在有些App中，主进程不一定是存活时间最长的(比如音乐播放App中往往是播放进程的存活时间最长),\n所以出现这种情况时开发者应该在application module的build.gradle中为Dispatcher配置进程名，如下:\n```groovy\n    dispatcher{\n        process \":downloader\"\n    }\n```\n在这里，\":downloader\"进程是存活时间最长的.\n\n## 初始化\n最好是在自己进程的Application中进行初始化(每个进程都有自己的Andromeda对象)，代码如下:\n```java\n    Andromeda.init(Context);\n```\n\n## 本地服务的注册与使用\n### 本地接口定义与实现\n本地接口定义与实现这方面，和普通的接口定义、实现没什么太大区别，不一样的地方就两个:\n+ 对外接口需要要暴露出去，使其对项目中的所有模块都可见，比如可以放在一个公共的module中\n+ 如果对于某个接口有多个实现，那么需要根据业务需求在不同的时候注册不同的实现到Andromeda,不过需要注意的是，同一时间Andromeda中只会有一个实现\n\n### 本地服务注册\n本地服务的注册有两种方法，一种是直接调用接口的全路径名和接口的实现，如下:\n```java\n    Andromeda.registerLocalService(ICheckApple.class.getCanonicalName(),new CheckApple());\n```\n还有一种是调用接口class和接口的实现，其实在内部也是获取了它的全路径名,如下:\n```java\n    Andromeda.registerLocalService(ICheckApple.class,new CheckApple());\n```\n其中ICheckApple.class为接口，虽然也可以采用下面这种方式注册:\n```java\n    Andromeda.registerLocalService(\"wang.imallen.blog.moduleexportlib.apple.ICheckApple\",CheckAppleImpl.getInstance());\n```\n**但是考虑到混淆问题，非常不推荐使用这种方式进行注册**，除非双方能够协商一致使用这个key(因为实际上Andromeda只需要保证有一个唯一的key与该服务对应即可).\n\n### 本地服务使用\n注册完之后，与服务提供方同进程的任何模块都可以调用该服务,获取服务的方式与注册对应，也有两种方式，一种是通过接口的class获取,如下:\n```java\n    ICheckApple checkApple = (ICheckApple) Andromeda.getLocalService(ICheckApple.class);\n```\n还有一种方法是通过接口的全路径名获取，如下:\n```java\n    ICheckApple checkApple = (ICheckApple) Andromeda.getLocalService(ICheckApple.class.getCanonicalName());\n```\n与注册类似，仍然不推荐使用如下方式来获取，除非双方始终协商好使用一个唯一的key（但是这样对于新的调用方或者新加入的开发者不友好，容易入坑):\n```java\n    ICheckApple checkApple = (ICheckApple) Andromeda.getLocalService(\"wang.imallen.blog.moduleexportlib.apple.ICheckApple\");\n```\n具体使用，可以察看applemodule中LocalServiceDemo这个Activity。\n\n### 本地接口的Callback问题\n如果是耗时操作，由本地接口自己定义Callback接口，调用方在调用接口时传入Callback对象即可。\n\n## 远程服务的注册与使用\n远程服务的注册与使用略微麻烦一点，因为需要像实现AIDL Service那样定义aidl接口。\n### 远程接口的定义与实现\n定义aidl接口，并且要将编译生成的Stub和Proxy类暴露给所有模块, 类似的，也是放在公共module中，以暴露给其他模块使用。比如定义一个购买苹果的服务接口:\n```aidl\n    package wang.imallen.blog.moduleexportlib.apple;\n    import org.qiyi.video.svg.IPCCallback;\n    \n    interface IBuyApple {\n        int buyAppleInShop(int userId);\n        void buyAppleOnNet(int userId,IPCCallback callback);\n    }\n```\n\n而接口的实现如下:\n```java\npublic class BuyAppleImpl extends IBuyApple.Stub {\n\n    private static BuyAppleImpl instance;\n\n    public static BuyAppleImpl getInstance() {\n        if (null == instance) {\n            synchronized (BuyAppleImpl.class) {\n                if (null == instance) {\n                    instance = new BuyAppleImpl();\n                }\n            }\n        }\n        return instance;\n    }\n\n    private BuyAppleImpl() {\n    }\n\n    @Override\n    public int buyAppleInShop(int userId) throws RemoteException {\n       ...\n    }\n\n    @Override\n    public void buyAppleOnNet(int userId, IPCCallback callback) throws RemoteException {\n       ...\n    }\n}\n\n```\n\n### 远程服务的注册\n与本地接口的注册略有不同，远程接口注册的是继承了Stub类的IBinder部分，注册方式有传递接口Class和接口全路径名两种，如下:\n```java\n    Andromeda.registerRemoteService(IBuyApple.class, BuyAppleImpl.getInstance().asBinder());\n```\n其中BuyAppleImpl是继承了IBuyApple.Stub类的具体实现类,另外，其实这里写成下面这样其实也可以:\n```java\n    Andromeda.registerRemoteService(IBuyApple.class, BuyAppleImpl.getInstance());\n```\n因为BuyAppleImpl继承的IBuyApple.Stub类继承自android.os.Binder,实现了asBinder()接口;\n\n传递全路径名的注册方式如下:\n```java\n    Andromeda.registerRemoteService(IBuyApple.class.getCanonicalName(),BuyAppleImpl.getInstance().asBinder());\n```\n\n### 远程服务的使用\n+ 由于Andromeda利用bindService()来提升通信过程中的优先级，对于在Fragment或者Activity中使用的情形，可在onDestroy()时自动释放连接，所以需要调用先调用with();\n+ 由于跨进程只能传递IBinder,所以只能获取到远程服务的IBinder之后，再调用XX.Stub.asInterface()获取到它的代理.\n\n以FragmentActivity中使用为例,如下的this是指FragmentActivity:\n```java\n        IBinder binder = Andromeda.with(this).getRemoteService(IBuyApple.class);\n        if (binder == null) {\n            return;\n        }\n        IBuyApple buyApple = IBuyApple.Stub.asInterface(binder);\n        if (buyApple == null) {\n            return;\n        }\n        try {\n            buyApple.buyAppleInShop(29);\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n        }\n```\n其他的在android.app.Fragment,android.support.v4.app.Fragment，以及普通的Activity中远程服务的使用类似，可查看app module中的CustomFragment,CustomSupportFragment,FragActivity等，不再赘述。\n\n值得注意的是，**远程服务其实既可在其他进程中调用，也可以在同进程中被调用，当在同一进程时，虽然调用方式一样，但其实会自动降级为进程内普通的接口调用，这个binder会自动处理.**\n\n### 远程服务的Callback问题\n考虑到远程服务也可能有耗时操作，所以需要支持远程调用的Callback功能。\n对于有耗时操作的远程服务，定义接口时需要借助lib中的IPCCallback,如下:\n```aidl\n    interface IBuyApple {\n        int buyAppleInShop(int userId);\n        void buyAppleOnNet(int userId,IPCCallback callback);\n    }\n```\n其中的buyAppleOnNet()方法就是耗时操作，所以需要在定义时加上IPCCallback,注意这里不能是自己随便定义的Callback接口，否则aidl编译通不过。\n其中的IPCCallback本身也是一个aidl接口，如下:\n```aidl\n    interface IPCCallback {\n       void onSuccess(in Bundle result);\n       void onFail(String reason);\n    }\n```\n对于IPCCallback的调用，固然也可以用由调用者直接继承IPCCallback.Stub类，实现相关接口，如:\n```java\n        IBinder buyAppleBinder = Andromeda.getRemoteService(IBuyApple.class);\n        if (null == buyAppleBinder) {\n            return;\n        }\n        IBuyApple buyApple = IBuyApple.Stub.asInterface(buyAppleBinder);\n        if (null != buyApple) {\n            try {\n                buyApple.buyAppleOnNet(10, new IPCCallback.Stub() {\n                    @Override\n                    public void onSuccess(Bundle result) throws RemoteException {\n                       ...\n                    }\n\n                    @Override\n                    public void onFail(String reason) throws RemoteException {\n                       ...\n                    }\n                });\n\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n            }\n        }\n    \n```\n但是考虑到回调是在Binder线程中，而绝大部分情况下调用者希望回调在主线程，所以lib封装了一个BaseCallback给接入方使用，如下:\n```java\n   IBinder buyAppleBinder = Andromeda.getRemoteService(IBuyApple.class);\n        if (null == buyAppleBinder) {\n            return;\n        }\n        IBuyApple buyApple = IBuyApple.Stub.asInterface(buyAppleBinder);\n        if (null != buyApple) {\n            try {\n                buyApple.buyAppleOnNet(10, new BaseCallback() {\n                    @Override\n                    public void onSucceed(Bundle result) {\n                       ...\n                    }\n\n                    @Override\n                    public void onFailed(String reason) {\n                        ...\n                    }\n                });\n\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n            }\n        }\n```\n**第二种方式也是我们推荐的使用方式!**\n\n详情可察看applemodule中的BananaActivity.\n\n### 生命周期自动管理的问题\n对于IPC,为了提高对方进程的优先极，在使用Andromeda.with().getRemoteService()时会进行bindService()操作。\n既然进行了bind操作，那自然要进行unbind操作以释放连接了，目前有如下两种情形。\n+ 对于在Fragment或者Activity中，并且是在主线程中调用的情形，只要在获取远程服务时利用with()传递Fragment或者Activity对象进去，Andromeda就会在onDestroy()时自动释放连接，不需要开发者做任何unbind()操作。\n\n+ 对于在子线程或者不是Fragment/Activity中的情形，只能传递Application Context去获取远程服务。在使用完毕后，需要手动调用Andromeda的unbind()释放连接:\n\n```java\n    public static void unbind(Class<?> serviceClass);\n    public static void unbind(Set<Class<?>> serviceClasses);\n```\n  如果只获取了一个远程服务，那么就使用前一个unbind()方法;否则使用后一个。\n\n## 事件订阅与发布\n### 事件\nAndromeda中Event的定义如下:\n```java\n    public class Event implements Parcelable {\n    \n        private String name;\n    \n        private Bundle data;\n        \n        ...\n    }\n```\n即 事件=名称+数据，通信时将需要传递的数据存放在Bundle中。  \n其中**名称要求在整个项目中唯一**，否则可能出错。\n由于要跨进程传输，所以所有数据只能放在Bundle中进行包装。\n\n### 事件订阅\n事件订阅很简单，首先需要有一个实现了EventListener接口的对象。\n然后就可以订阅自己感兴趣的事件了，如下:\n```java\n    Andromeda.subscribe(EventConstants.APPLE_EVENT,MainActivity.this);\n```\n其中MainActivity实现了EventListener接口，此处表示订阅了名称为EventConstnts.APPLE_EVENT的事件。\n\n### 事件发布\n事件发布很简单，调用publish方法即可，如下:\n```java\n    Bundle bundle = new Bundle();\n    bundle.putString(\"Result\", \"gave u five apples!\");\n    Andromeda.publish(new Event(EventConstants.APPLE_EVENT, bundle));\n```\n# License\nBSD-3-Clause. See the [BSD-3-Clause](https://opensource.org/licenses/BSD-3-Clause) file for details.\n\n# 交流\nAndromeda交流QQ群号是640539737, 二维码如下:\n\n![QQ_group](https://github.com/iqiyi/Andromeda/blob/master/res/qq_group.png)\n\n# 支持\n1. Sample代码\n2. 阅读Wiki或者FAQ\n3. 联系bettarwang@gmail.com"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.4794921875,
          "content": "# Andromeda\n![Andromeda_license](https://img.shields.io/badge/license-BSD--3--Clause-brightgreen.svg)\n![Andromeda_core_tag](https://img.shields.io/badge/Andromeda%20Core-1.1.8-brightgreen.svg)\n![Andromeda_plugin_tag](https://img.shields.io/badge/Andromeda%20plugin-1.1.1-brightgreen.svg)\n\nAndromeda provides communication among modules for both local and remote service.\n\n**Anno:The reason that differentiate local service from remote service is that parameter types in remote service can only be primitive type or custom type that implements Parcelable, while parameter types in local service can be any type such as View and Context.**\n\n[文档，还是中文好](https://github.com/iqiyi/Andromeda/blob/master/CHINESE_README.md)\n\n# Features\n\n+ Aidl interface and implemention are the only thing developers need do. bindService() and Service definition are not necessary.\n\n+ Remote service could be fetched synchronously instead of asynchronously\n\n+ Process-priority-hencing work is managed along with Fragment/Activity's lifecycle\n\n+ IPC Callback is supported\n \n+ Event bus for all processes is supported\n\n**Anno: service here means interface and it's implementation instead of component Service.**\n\nComparsion between other communication solutions and Andromeda:\n\n|                            | Convenience  | IPC efficiency | IPC | IPC EventBus | IPC Callback |\n| :------------------------: | :--: | :---: | :---: | :-------: | :------------: |\n|         Andromeda          |  good   |   high   |  Yes  |    Yes    |      Yes       |\n|   DDComponentForAndroid    |  normal  |  --   |  No   |    No     |       No       |\n| ModularizationArchitecture |  normal  |   low   |  Yes  |    No     |       No       |\n\n# Download\nadd classpath in buildscript(replace $version with latest version name):\n```groovy\n    classpath \"org.qiyi.video.svg:plugin:$version\"\n```\nadd core lib dependency in Application or library Module:\n```groovy\n    implementation \"org.qiyi.video.svg:core:$version\"\n```\napply gradle plugin in application Module:\n```groovy\n    apply plugin: 'org.qiyi.svg.plugin'\n```\n\n# How to use\n## Dispatcher config\n**Dispatcher should always in the process that live longest cause it manager all process infos!.**\nDefault process of Dispatcher is main process if not configed. \nConsidering some process may live longer than main process in some apps(such as music app), developers should\n config process name for Dispatcher in this case. Just as follows in build.gradle of application module:\n```groovy\n    dispatcher{\n        process \":downloader\"\n    }\n``` \nIn this case, \":downloader\" process is the one that live longest.\n\n## init\nadd init code in Application.onCreate():\n```java\n    Andromeda.init(Context);\n```\n\n## Register and use local service\n### Definition and implementation of local service\nThere are only two differences between local service and normal interfaces:\n+ interfaces should be put in a common module to make it accessible to all modules\n+ Andromeda will only hold one implementation at a time\n\n### Register local service\nThere are two methods to register local service, the first one is as follows:\n```java\n    Andromeda.registerLocalService(ICheckApple.class.getCanonicalName(),new CheckApple());\n```\nAnother is as follows:\n```java\n    Andromeda.registerLocalService(ICheckApple.class,new CheckApple());\n```\nICheckApple is interface definition. Considering proguard, registering local service with fixed String is not recommanded, just as follows:\n```java\n    Andromeda.registerLocalService(\"wang.imallen.blog.moduleexportlib.apple.ICheckApple\",CheckAppleImpl.getInstance());\n```\n\n### How to use local service\nAny module that's in the same process with server module could obtain local service after registration. The first method is as follows:\n```java\n    ICheckApple checkApple = (ICheckApple) Andromeda.getLocalService(ICheckApple.class);\n```\nAnother is as follows:\n```java\n    ICheckApple checkApple = (ICheckApple) Andromeda.getLocalService(ICheckApple.class.getCanonicalName());\n```\nSimilarly, considering proguard, obtaining local service with fixed String is not recommanded neighter:\n```java\n    ICheckApple checkApple = (ICheckApple) Andromeda.getLocalService(\"wang.imallen.blog.moduleexportlib.apple.ICheckApple\");\n```\nLocalServiceDemo shows the details of registration and use of local service。\n\n### Callback of local service\nCallback of local service is just as normal interface, which is all up to developers.\nAs a result, Andromeda will not provide any callbacks.\n\n## Registeration and use of remote service\n### Definition and use of remote service\nFirst, define a aidl interface, and expose it to common module along with its Stub and Proxy.\n```aidl\n    package wang.imallen.blog.moduleexportlib.apple;\n    import org.qiyi.video.svg.IPCCallback;\n    \n    interface IBuyApple {\n        int buyAppleInShop(int userId);\n        void buyAppleOnNet(int userId,IPCCallback callback);\n    }\n```\nThen provide implementation:\n```java\npublic class BuyAppleImpl extends IBuyApple.Stub {\n\n    private static BuyAppleImpl instance;\n\n    public static BuyAppleImpl getInstance() {\n        if (null == instance) {\n            synchronized (BuyAppleImpl.class) {\n                if (null == instance) {\n                    instance = new BuyAppleImpl();\n                }\n            }\n        }\n        return instance;\n    }\n\n    private BuyAppleImpl() {\n    }\n\n    @Override\n    public int buyAppleInShop(int userId) throws RemoteException {\n       ...\n    }\n\n    @Override\n    public void buyAppleOnNet(int userId, IPCCallback callback) throws RemoteException {\n       ...\n    }\n}\n\n```\n### Registration of remote service\nDifferen from registration of local service, IBinder of remote service is need for registration :\n```java\n    Andromeda.registerRemoteService(IBuyApple.class, BuyAppleImpl.getInstance().asBinder());\n```\nThe way as follows is also workable cause BuyAppleImpl extends IBuyApple.Stub, which extends android.os.Binder:\n```java\n    Andromeda.registerRemoteService(IBuyApple.class, BuyAppleImpl.getInstance());\n```\nAnother way to register is as follows:\n```java\n    Andromeda.registerRemoteService(IBuyApple.class.getCanonicalName(),BuyAppleImpl.getInstance().asBinder());\n```\n\n### Use of remote service\n+ with() is need before obtain remote service cause Andromeda need to hence server process priority in accordance with Fragment/Activity's lifecycle;\n+ getRemoteService() will return IBinder. Then you can obtain proxy by XXStub.asInterface(binder);\n\nSet use in a FragmentActivity as example:\n```java\n        IBinder binder = Andromeda.with(this).getRemoteService(IBuyApple.class);\n        if (binder == null) {\n            return;\n        }\n        IBuyApple buyApple = IBuyApple.Stub.asInterface(binder);\n        if (buyApple == null) {\n            return;\n        }\n        try {\n            buyApple.buyAppleInShop(29);\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n        }\n```\nUse of remote service in android.app.Fragment,android.support.v4.app.Fragment and normal Activity is similar, demos are CustomFragment,CustomSupportFragment and FragActivity,etc.\n\nAttention:**Remote service could be used both in same process and other processes. When use in the same process, it will turned to local interface invoking.**\n\n### Callback of remote service\nConsidering time-consuming work may be done in server process, Callback of remote service is necessary.。\nFor ones that need callback should add IPCCallback parameter in their aidl definitions:\n```aidl\n    interface IBuyApple {\n        int buyAppleInShop(int userId);\n        void buyAppleOnNet(int userId,IPCCallback callback);\n    }\n```\nThe canonical name of IPCCallback is org.qiyi.video.svg.IPCCallback. Its definition is as follows:\n```aidl\n    interface IPCCallback {\n       void onSuccess(in Bundle result);\n       void onFail(String reason);\n    }\n```\nClient can use IPCCallback as follows:\n```java\n        IBinder buyAppleBinder = Andromeda.getRemoteService(IBuyApple.class);\n        if (null == buyAppleBinder) {\n            return;\n        }\n        IBuyApple buyApple = IBuyApple.Stub.asInterface(buyAppleBinder);\n        if (null != buyApple) {\n            try {\n                buyApple.buyAppleOnNet(10, new IPCCallback.Stub() {\n                    @Override\n                    public void onSuccess(Bundle result) throws RemoteException {\n                       ...\n                    }\n\n                    @Override\n                    public void onFail(String reason) throws RemoteException {\n                       ...\n                    }\n                });\n\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n            }\n        }\n    \n```\nConsidering the callback is in binder thread, while most developers want the callback in UI thread, Andromeda provide a BaseCallback for deverlopers.\n```java\n   IBinder buyAppleBinder = Andromeda.getRemoteService(IBuyApple.class);\n        if (null == buyAppleBinder) {\n            return;\n        }\n        IBuyApple buyApple = IBuyApple.Stub.asInterface(buyAppleBinder);\n        if (null != buyApple) {\n            try {\n                buyApple.buyAppleOnNet(10, new BaseCallback() {\n                    @Override\n                    public void onSucceed(Bundle result) {\n                       ...\n                    }\n\n                    @Override\n                    public void onFailed(String reason) {\n                        ...\n                    }\n                });\n\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n            }\n        }\n```\n**Use BaseCallback instead of IPCCallback is recommanded!**\n\nBananaActivity shows details of how to use it.\n\n### Lifecycle control\nTo enhence server process's priority, Andromeda will do bindService() when Andromeda.with().getRemoteService() in accordance with Fragment/Activity's lifecycle.\nAs a result, unbind action is need when Fragment/Activity destroyed.\nThere are 2 cases now:\n+ For those who obtain remote service with Fragment/Activity and in main thread, Andromeda will do unbind() action automatically\n\n+ For those who obtain not with Fragment/Activity or in work thread, unbind() action should be invoked by developers:\n\n```java\n    public static void unbind(Class<?> serviceClass);\n    public static void unbind(Set<Class<?>> serviceClasses);\n```\n \n## Subscribe and pushlish event\n### Event\nDefinition of Event in Andromeda is as follows:\n```java\n    public class Event implements Parcelable {\n    \n        private String name;\n    \n        private Bundle data;\n        \n        ...\n    }\n```\nObviously, Event consist of name and data, which is Bundle type that can load primitive type parameters or Parcelable type parameters.\n\n### Subscribe event\nSubscribing event is very simple with one who implements EventListenr such as MainActivity:\n```java\n    Andromeda.subscribe(EventConstants.APPLE_EVENT,MainActivity.this);\n```\nThis means it subscribes Event whose name is EventConstans.APPLE_EVENT.\n\n### Publish event\nPublishing event is as simple as follows:\n```java\n    Bundle bundle = new Bundle();\n    bundle.putString(\"Result\", \"gave u five apples!\");\n    Andromeda.publish(new Event(EventConstants.APPLE_EVENT, bundle));\n```\nAfter published, all listeners in any processes could receive the event.\n\nMainActivity shows details of how to subscribe and publish event.\n\n# License\nBSD-3-Clause. See the [BSD-3-Clause](https://opensource.org/licenses/BSD-3-Clause) file for details.\n\n\n# Contact\nQQ group number is 640539737, and its qr code is as follows:\n\n![QQ_group](https://github.com/iqiyi/Andromeda/blob/master/res/qq_group.png)\n\n# Support\n1. Sample codes\n2. Wiki and FAQs\n3. contact bettarwang@gmail.com\n\n"
        },
        {
          "name": "app",
          "type": "tree",
          "content": null
        },
        {
          "name": "applemodule",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.gradle",
          "type": "blob",
          "size": 1.337890625,
          "content": "// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n\n    ext.maven_config=[\n            'nexus_repo_url':NEXUS_REPO_URL,\n            'userName':USER_NAME,\n            'groupId':GROUP_ID,\n            'passWord':PASS_WORD,\n            'version_code':118,\n            'version_name':'1.1.8',\n            'core_build_version':'1.1.8',\n            'plugin_build_version':'1.1.1'\n    ]\n\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.0.1'\n        classpath \"org.qiyi.video.svg:plugin:$maven_config.plugin_build_version\"\n\n        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.0'\n        classpath 'com.github.dcendents:android-maven-gradle-plugin:2.0'\n        classpath 'com.novoda:bintray-release:0.8.1'\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n\n    tasks.withType(Javadoc) {\n        options{ encoding \"UTF-8\"\n            charSet 'UTF-8'\n            links \"http://docs.oracle.com/javase/7/docs/api\"\n        }\n    }\n\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n\nsubprojects{pro->\n    println \"project name:\"+pro.name\n}\n"
        },
        {
          "name": "buildSrc",
          "type": "tree",
          "content": null
        },
        {
          "name": "cherrymodule",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradle.properties",
          "type": "blob",
          "size": 0.9951171875,
          "content": "# Project-wide Gradle settings.\n\n# IDE (e.g. Android Studio) users:\n# Gradle settings configured through the IDE *will override*\n# any settings specified in this file.\n\n# For more details on how to configure your build environment visit\n# http://www.gradle.org/docs/current/userguide/build_environment.html\n\n# Specifies the JVM arguments used for the daemon process.\n# The setting is particularly useful for tweaking memory settings.\norg.gradle.jvmargs=-Xmx1536m\n\n# When configured, Gradle will run in incubating parallel mode.\n# This option should only be used with decoupled projects. More details, visit\n# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects\n# org.gradle.parallel=true\n\nGROUP_ID=org.qiyi.video.svg\n\nPROJ_LICENCE_NAME=The Apache Software License, Version 2.0\nPROJ_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt\nPROJ_LICENCE_DEST=repo\n\nNEXUS_REPO_URL=http://maven.mbd.qiyi.domain/nexus/content/repositories/mcg-arch\n\nUSER_NAME=xxxxx\nPASS_WORD=xxxxx"
        },
        {
          "name": "gradle",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradlew",
          "type": "blob",
          "size": 4.8544921875,
          "content": "#!/usr/bin/env bash\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\"\"\n\nAPP_NAME=\"Gradle\"\nAPP_BASE_NAME=`basename \"$0\"`\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD=\"maximum\"\n\nwarn ( ) {\n    echo \"$*\"\n}\n\ndie ( ) {\n    echo\n    echo \"$*\"\n    echo\n    exit 1\n}\n\n# OS specific support (must be 'true' or 'false').\ncygwin=false\nmsys=false\ndarwin=false\ncase \"`uname`\" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\nesac\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG=\"$0\"\n# Need this for relative symlinks.\nwhile [ -h \"$PRG\" ] ; do\n    ls=`ls -ld \"$PRG\"`\n    link=`expr \"$ls\" : '.*-> \\(.*\\)$'`\n    if expr \"$link\" : '/.*' > /dev/null; then\n        PRG=\"$link\"\n    else\n        PRG=`dirname \"$PRG\"`\"/$link\"\n    fi\ndone\nSAVED=\"`pwd`\"\ncd \"`dirname \\\"$PRG\\\"`/\" >/dev/null\nAPP_HOME=\"`pwd -P`\"\ncd \"$SAVED\" >/dev/null\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n \"$JAVA_HOME\" ] ; then\n    if [ -x \"$JAVA_HOME/jre/sh/java\" ] ; then\n        # IBM's JDK on AIX uses strange locations for the executables\n        JAVACMD=\"$JAVA_HOME/jre/sh/java\"\n    else\n        JAVACMD=\"$JAVA_HOME/bin/java\"\n    fi\n    if [ ! -x \"$JAVACMD\" ] ; then\n        die \"ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\n    fi\nelse\n    JAVACMD=\"java\"\n    which java >/dev/null 2>&1 || die \"ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ \"$cygwin\" = \"false\" -a \"$darwin\" = \"false\" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ \"$MAX_FD\" = \"maximum\" -o \"$MAX_FD\" = \"max\" ] ; then\n            MAX_FD=\"$MAX_FD_LIMIT\"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn \"Could not set maximum file descriptor limit: $MAX_FD\"\n        fi\n    else\n        warn \"Could not query maximum file descriptor limit: $MAX_FD_LIMIT\"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS=\"$GRADLE_OPTS \\\"-Xdock:name=$APP_NAME\\\" \\\"-Xdock:icon=$APP_HOME/media/gradle.icns\\\"\"\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed \"$APP_HOME\"`\n    CLASSPATH=`cygpath --path --mixed \"$CLASSPATH\"`\n    JAVACMD=`cygpath --unix \"$JAVACMD\"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=\"\"\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS=\"$ROOTDIRS$SEP$dir\"\n        SEP=\"|\"\n    done\n    OURCYGPATTERN=\"(^($ROOTDIRS))\"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ \"$GRADLE_CYGPATTERN\" != \"\" ] ; then\n        OURCYGPATTERN=\"$OURCYGPATTERN|($GRADLE_CYGPATTERN)\"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in \"$@\" ; do\n        CHECK=`echo \"$arg\"|egrep -c \"$OURCYGPATTERN\" -`\n        CHECK2=`echo \"$arg\"|egrep -c \"^-\"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed \"$arg\"`\n        else\n            eval `echo args$i`=\"\\\"$arg\\\"\"\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- \"$args0\" ;;\n        (2) set -- \"$args0\" \"$args1\" ;;\n        (3) set -- \"$args0\" \"$args1\" \"$args2\" ;;\n        (4) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" ;;\n        (5) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" ;;\n        (6) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" ;;\n        (7) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" ;;\n        (8) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" ;;\n        (9) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" \"$args8\" ;;\n    esac\nfi\n\n# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules\nfunction splitJvmOpts() {\n    JVM_OPTS=(\"$@\")\n}\neval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS\nJVM_OPTS[${#JVM_OPTS[*]}]=\"-Dorg.gradle.appname=$APP_BASE_NAME\"\n\nexec \"$JAVACMD\" \"${JVM_OPTS[@]}\" -classpath \"$CLASSPATH\" org.gradle.wrapper.GradleWrapperMain \"$@\"\n"
        },
        {
          "name": "gradlew.bat",
          "type": "blob",
          "size": 2.34765625,
          "content": "@if \"%DEBUG%\" == \"\" @echo off\r\n@rem ##########################################################################\r\n@rem\r\n@rem  Gradle startup script for Windows\r\n@rem\r\n@rem ##########################################################################\r\n\r\n@rem Set local scope for the variables with windows NT shell\r\nif \"%OS%\"==\"Windows_NT\" setlocal\r\n\r\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\r\nset DEFAULT_JVM_OPTS=\r\n\r\nset DIRNAME=%~dp0\r\nif \"%DIRNAME%\" == \"\" set DIRNAME=.\r\nset APP_BASE_NAME=%~n0\r\nset APP_HOME=%DIRNAME%\r\n\r\n@rem Find java.exe\r\nif defined JAVA_HOME goto findJavaFromJavaHome\r\n\r\nset JAVA_EXE=java.exe\r\n%JAVA_EXE% -version >NUL 2>&1\r\nif \"%ERRORLEVEL%\" == \"0\" goto init\r\n\r\necho.\r\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\r\necho.\r\necho Please set the JAVA_HOME variable in your environment to match the\r\necho location of your Java installation.\r\n\r\ngoto fail\r\n\r\n:findJavaFromJavaHome\r\nset JAVA_HOME=%JAVA_HOME:\"=%\r\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\r\n\r\nif exist \"%JAVA_EXE%\" goto init\r\n\r\necho.\r\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\r\necho.\r\necho Please set the JAVA_HOME variable in your environment to match the\r\necho location of your Java installation.\r\n\r\ngoto fail\r\n\r\n:init\r\n@rem Get command-line arguments, handling Windowz variants\r\n\r\nif not \"%OS%\" == \"Windows_NT\" goto win9xME_args\r\nif \"%@eval[2+2]\" == \"4\" goto 4NT_args\r\n\r\n:win9xME_args\r\n@rem Slurp the command line arguments.\r\nset CMD_LINE_ARGS=\r\nset _SKIP=2\r\n\r\n:win9xME_args_slurp\r\nif \"x%~1\" == \"x\" goto execute\r\n\r\nset CMD_LINE_ARGS=%*\r\ngoto execute\r\n\r\n:4NT_args\r\n@rem Get arguments from the 4NT Shell from JP Software\r\nset CMD_LINE_ARGS=%$\r\n\r\n:execute\r\n@rem Setup the command line\r\n\r\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\r\n\r\n@rem Execute Gradle\r\n\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\r\n\r\n:end\r\n@rem End local scope for the variables with windows NT shell\r\nif \"%ERRORLEVEL%\"==\"0\" goto mainEnd\r\n\r\n:fail\r\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\r\nrem the _cmd.exe /c_ return code!\r\nif  not \"\" == \"%GRADLE_EXIT_CONSOLE%\" exit 1\r\nexit /b 1\r\n\r\n:mainEnd\r\nif \"%OS%\"==\"Windows_NT\" endlocal\r\n\r\n:omega\r\n"
        },
        {
          "name": "moduleexportlib",
          "type": "tree",
          "content": null
        },
        {
          "name": "res",
          "type": "tree",
          "content": null
        },
        {
          "name": "settings.gradle",
          "type": "blob",
          "size": 0.1171875,
          "content": "include ':app', ':moduleexportlib', ':applemodule', ':cherrymodule', ':Andromeda-Lib', ':buildSrc', ':Andromeda-Plugin'\n"
        }
      ]
    }
  ]
}