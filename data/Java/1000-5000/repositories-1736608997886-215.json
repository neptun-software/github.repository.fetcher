{
  "metadata": {
    "timestamp": 1736608997886,
    "page": 215,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lcodecorex/TwinklingRefreshLayout",
      "stars": 4004,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0869140625,
          "content": "*.iml\n.gradle\n/local.properties\n/.idea\n.DS_Store\n/build\n/captures\ngradle*\n/TODO_list.md\n\n"
        },
        {
          "name": ".idea",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.1298828125,
          "content": "## 【DECREEPTED】\n\n# TwinklingRefreshLayout\n[中文文档](./README_CN.md)\n\nTwinklingRefreshLayout extended the thoughts of SwipeRefreshLayout,using a ViewGroup to include a list of Views, to maintain its low coupling and high versatility. Follows are its main features.\n\n - New overscroll animations, running smoothly, much better than iOS.\n - Support RecyclerView, ScrollView, AbsListView, WebView and so on.\n - Support to load more.\n - Default support cross-border rebound.\n - You can open a pure bounds rebound mode.\n -  Lots of methods in the class OnRefreshListener.\n - It provides an interface to the callback during the sliding coefficient. Personalized offer good support.\n - NestedScroll,CoordinatorLayout\n\n **Any View is supported.**\n\n![](art/structure_v1.0.png)\n\n## Demo\n[Download Demo](art/app-debug.apk)\n\n![](art/gif_recyclerview.gif)  ![](art/gif_listview.gif)  ![](art/gif_gridview.gif) ![](art/gif_recyclerview2.gif) ![](art/gif_scrollview.gif)  ![](art/gif_webview.gif)\n\nYou can download these Videos for more details.\n\n- [Music - ListView - FixedHeader](art/gif_listview.mp4)\n- [Food - RecyclerView - PureScrollMode](art/gif_recyclerview.mp4)\n- [Science - GridView - SinaHeader](art/gif_gridview.mp4)\n- [Photo - RecyclerView - BezierLayout](art/gif_recyclerview2.mp4)\n- [Story - ScrollView - GoogleDotView](art/gif_scrollview.mp4)\n- [Dribbble - WebView - FloatRefresh](art/gif_webview.mp4)\n\n## Usage\n#### 1.Add a gradle dependency.\n```\ncompile 'com.lcodecorex:tkrefreshlayout:1.0.7'\n```\n\n#### 2.Add TwinklingRefreshLayout in the layout xml.\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<com.lcodecore.tkrefreshlayout.TwinklingRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:id=\"@+id/refreshLayout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    app:tr_wave_height=\"180dp\"\n    app:tr_head_height=\"100dp\">\n\n    <android.support.v7.widget.RecyclerView\n        android:id=\"@+id/recyclerview\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:overScrollMode=\"never\"\n        android:background=\"#fff\" />\n</com.lcodecore.library.TwinklingRefreshLayout>\n```\n\nTo get better effect, you'd better add code `android:overScrollMode=\"never\"` to the childView.\n\n#### 3.Coding in the Activity or Fragment.\n##### Change of state need to be manually controlled.\n```java\nrefreshLayout.setOnRefreshListener(new RefreshListenerAdapter(){\n            @Override\n            public void onRefresh(final TwinklingRefreshLayout refreshLayout) {\n                new Handler().postDelayed(new Runnable() {\n                    @Override\n                    public void run() {\n                        refreshLayout.finishRefreshing();\n                    }\n                },2000);\n            }\n\n            @Override\n            public void onLoadMore(final TwinklingRefreshLayout refreshLayout) {\n                new Handler().postDelayed(new Runnable() {\n                    @Override\n                    public void run() {\n                        refreshLayout.finishLoadmore();\n                    }\n                },2000);\n            }\n        });\n    }\n```\n\nUse finishRefreshing() method to end refresh, finishLoadmore() method to end load more. OnRefreshListener there are other methods, you can choose need to override.\n\nAnd if you want you refresh automatically, call the method startRefresh().\n\n##### setWaveHeight、setHeaderHeight、setBottomHeight、setOverScrollHeight\n- setMaxHeadHeight is used To set the maximum height of the head can be stretched.\n- setHeaderHeight is used to set the standard head height.\n- setMaxBottomHeight.\n- setBottomHeight is used to set the Bottom height.\n- setOverScrollHeight is used to set the max height of overscroll.\n\nAnd now dp value is supported.\n\n#### setEnableRefresh、setEnableLoadmore\nFlexible settings for whether to disable the pulling-down mode.\n\n##### setHeaderView(IHeaderView headerView)、setBottomView(IBottomView bottomView)\n\n#### setEnableOverScroll\nWhether to allow overscroll mode, opened by default.\n\n##### setOverScrollTopShow、setOverScrollBottomShow、setOverScrollRefreshShow\nWhether to allow the display refresh control on overscrolling, the default is true.\n\n##### setPureScrollModeOn()\nTo open the pure overscroll mode so that refreshView would gone permanently.\n\n##### setAutoLoadMore\nif open the loadmore mode after overscrolling bottom automatically.\n\n##### addFixedExHeader\nAllow you to add a view fixed on the top.\n\n##### startRefresh、startLoadMore、finishRefreshing、finishLoadmore\n\n##### setFloatRefresh(boolean)\nMake refresh-animation like SwipeRefreshLayout.\n\n##### setTargetView(View view)\nSet the target view that you can scroll.\n\n##### setDefaultHeader、setDefaultFooter\nstatic methods aims to set a default header/footer in a/an Application/Activity.\n\n#### 4.Attributes\n- tr_max_head_height - Flexible head height\n- tr_head_height -  Head height\n- tr_max_bottom_height\n- tr_bottom_height - Bottom height\n- tr_overscroll_height - OverScroll Height\n- tr_enable_refresh - default is true\n- tr_enable_loadmore - default is true\n- tr_pureScrollMode_on - default is false\n- tr_overscroll_top_show - default is true\n- tr_overscroll_bottom_show - default is true\n- tr_enable_overscroll - default is true.\n- tr_floatRefresh - open the float-refresh mode.\n- tr_autoLoadMore\n- tr_enable_keepIView - default is true.\n- tr_showRefreshingWhenOverScroll - default is true.\n- tr_showLoadingWhenOverScroll - default is true.\n\n## Other\n### 1.setOnRefreshListener\n- onPullingDown(TwinklingRefreshLayout refreshLayout, float fraction)  \n- onPullingUp(TwinklingRefreshLayout refreshLayout, float fraction)    \n- onPullDownReleasing(TwinklingRefreshLayout refreshLayout, float fraction)  \n- onPullUpReleasing(TwinklingRefreshLayout refreshLayout, float fraction)  \n- onRefresh(TwinklingRefreshLayout refreshLayout)  \n- onLoadMore(TwinklingRefreshLayout refreshLayout)  \n\nfraction = currentMoveHeight/headHeight OR (fraction = currentMoveHeight/bottomHeight).\n\n### 3.Header and Footer\n##### BezierLayout(pic 4)\n- setWaveColor\n- setRippleColor\n\n##### GoogleDotView(pic 5)\n##### SinaRefreshView(pic 3)\n- setArrowResource\n- setTextColor\n- setPullDownStr\n- setReleaseRefreshStr\n- setRefreshingStr\n\n##### ProgressLayout(SwipeRefreshLayout pic 6)\n- setProgressBackgroundColorSchemeResource(@ColorRes int colorRes)\n- setProgressBackgroundColorSchemeColor(@ColorInt int color)\n- setColorSchemeResources(@ColorRes int... colorResIds)\n\n####Footer\n##### BallPulseView(pic 2)\n- setNormalColor(@ColorInt int color)\n- setAnimatingColor(@ColorInt int color)\n\n##### LoadingView(pic 3)\nHere is more animations.[AVLoadingIndicatorView](https://github.com/81813780/AVLoadingIndicatorView)。\n\n### 3.Personalize the Header and Footer.\nThe Header needs to implement IHeaderView interface and Footer in in the same way(IBottomView).\n```java\npublic interface IHeaderView {\n    View getView();\n\n    void onPullingDown(float fraction,float maxHeadHeight,float headHeight);\n\n    void onPullReleasing(float fraction,float maxHeadHeight,float headHeight);\n\n    void startAnim(float maxHeadHeight,float headHeight);\n\n    void reset();\n}\n```\n\ngetView() method is not allow to return null.\n\n#### Let's implement a simple refresh dynamic efficiency.\n1.Define SinaRefreshHeader extended from FrameLayout and implement IHeaderView interface.\n\n2.Return this in the method getView().\n\n3.Inflate and find Views in the layout xml.\n\n```java\nvoid init() {\n        if (rootView == null) {\n            rootView = View.inflate(getContext(), R.layout.view_sinaheader, null);\n            refreshArrow = (ImageView) rootView.findViewById(R.id.iv_arrow);\n            refreshTextView = (TextView) rootView.findViewById(R.id.tv);\n            loadingView = (ImageView) rootView.findViewById(R.id.iv_loading);\n            addView(rootView);\n        }\n    }\n```\n\n4.Override some methods.\n```java\n@Override\n    public void onPullingDown(float fraction, float maxHeadHeight, float headHeight) {\n        if (fraction < 1f) refreshTextView.setText(pullDownStr);\n        if (fraction > 1f) refreshTextView.setText(releaseRefreshStr);\n        refreshArrow.setRotation(fraction * headHeight / maxHeadHeight * 180);\n\n\n    }\n\n    @Override\n    public void onPullReleasing(float fraction, float maxHeadHeight, float headHeight) {\n        if (fraction < 1f) {\n            refreshTextView.setText(pullDownStr);\n            refreshArrow.setRotation(fraction * headHeight / maxHeadHeight * 180);\n            if (refreshArrow.getVisibility() == GONE) {\n                refreshArrow.setVisibility(VISIBLE);\n                loadingView.setVisibility(GONE);\n            }\n        }\n    }\n\n    @Override\n    public void startAnim(float maxHeadHeight, float headHeight) {\n        refreshTextView.setText(refreshingStr);\n        refreshArrow.setVisibility(GONE);\n        loadingView.setVisibility(VISIBLE);\n    }\n\n    @Override\n    public void onFinish(OnAnimEndListener listener) {\n    listener.onAnimEnd();\n    }\n```\n\n5.layout xml.\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\" android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\">\n    <ImageView\n        android:id=\"@+id/iv_arrow\"\n        android:layout_width=\"24dp\"\n        android:layout_height=\"24dp\"\n        android:src=\"@drawable/ic_arrow\"/>\n\n    <ImageView\n        android:id=\"@+id/iv_loading\"\n        android:visibility=\"gone\"\n        android:layout_width=\"34dp\"\n        android:layout_height=\"34dp\"\n        android:src=\"@drawable/anim_loading_view\"/>\n\n    <TextView\n        android:id=\"@+id/tv\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginLeft=\"16dp\"\n        android:textSize=\"16sp\"\n        android:text=\"pull down to refresh\"/>\n</LinearLayout>\n```\n\nPay attention to the using of the parameter `fraction`. Such as the code above`refreshArrow.setRotation(fraction * headHeight / maxHeadHeight * 180)`，`fraction * headHeight` is the translationY of the Head and 180 is the angle the arrow would rotate，so that we can make the arrow rotate 180 degrees when the translationY is come to the maxHeadHeight.\n\n\nonPullingDown/onPullingUp\nonPullReleasing\nstartAnim - be called automatically after the method onRefresh/onLoadMore is called.\n\nCongratulations! Simple to use and simple to Personalise.（To see a more simple example. **TextHeaderView(pic 4)**）。\n\n### NestedScroll\n#### TwinklingRefreshLayout Nested CoordinatorLayout\n---layout\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<com.lcodecore.tkrefreshlayout.TwinklingRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:id=\"@+id/refresh\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <android.support.design.widget.CoordinatorLayout\n        android:id=\"@+id/coord_container\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:addStatesFromChildren=\"true\"\n        android:fitsSystemWindows=\"true\">\n\n        <android.support.design.widget.AppBarLayout\n            android:id=\"@+id/appbar_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:clipChildren=\"false\">\n\n            <!--...-->\n\n        </android.support.design.widget.AppBarLayout>\n\n        <android.support.v7.widget.RecyclerView\n            android:id=\"@+id/recyclerview\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" />\n\n    </android.support.design.widget.CoordinatorLayout>\n</com.lcodecore.tkrefreshlayout.TwinklingRefreshLayout>\n```\n\n--- code1\n```\nrefreshLayout.setTargetView(rv);\n```\nFind the RecyclerView/ListView.\n\n--- code2\n```java\nAppBarLayout appBarLayout = (AppBarLayout) findViewById(R.id.appbar_layout);\nappBarLayout.addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() {\n    @Override\n    public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {\n        if (verticalOffset >= 0) {\n            refreshLayout.setEnableRefresh(true);\n            refreshLayout.setEnableOverScroll(false);\n        } else {\n            refreshLayout.setEnableRefresh(false);\n            refreshLayout.setEnableOverScroll(false);\n        }\n    }\n});\n```\n\n####CoordinatorLayout nested TwinklingRefreshLayout\n--- layout\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:id=\"@+id/coord_container\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:addStatesFromChildren=\"true\"\n    android:fitsSystemWindows=\"true\">\n\n    <com.lcodecore.tkrefreshlayout.TwinklingRefreshLayout\n        android:id=\"@+id/refresh\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        app:layout_behavior=\"@string/appbar_scrolling_view_behavior\">\n\n        <android.support.v7.widget.RecyclerView\n            android:id=\"@+id/recyclerview\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\" />\n\n    </com.lcodecore.tkrefreshlayout.TwinklingRefreshLayout>\n\n</android.support.design.widget.CoordinatorLayout>\n```\nPay attention to `layout_behavior=\"@string/appbar_scrolling_view_behavior\"` for TwinklingRefreshLayout.\n\n> ps：Contact me: lcodecore@163.com\n> QQ group: 202640706\n\nIf you like this library, you can donate me. Buy me a coffee!\n\n![](art/alipay.jpg) ![](art/wepay.png)\n\n## Update Logs\n#### v1.07\n- NestedScroll,CoordinateLayout\n- Any View\n- Keep state when refreshing/loading.\n\n#### v1.06\n- Repair memory leaks of customized Views.\n- remove the dependence of AVLoadingIndicatorView.\n- Fix bugs of OverScroll when TargetView scrolls at the top/bottom.\n- Repair bugs of touching,scroll-event listeners.\n- Optimization of interface flicker problems after load-more.\n\n#### v1.05 Emergency Fix\n- Fix the bug of setAutoLoadMore().\n- Fix the bug that FixedHeader covered the first item of listview.\n- Add onRefreshCanceled()/onLoadmoreCanceled() for RefreshListenerAdapter.\n\n#### v1.04\n- Refactor the code.\n- Make animations smoothly.\n- Add support to Fixed Header.\n- Add support to float refresh mode.\n- IHeadView.onFinish(animEndListener) -> Available to run animations before finishRefresh.\n\n#### v1.03\n- more attributes.\n- Fix the NullPointerException bug in Fragment.\n- Fix the Sliding conflict.\n\n\nLicense\n-------\n\n    Copyright 2016 lcodecorex\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n"
        },
        {
          "name": "README_CN.md",
          "type": "blob",
          "size": 19.5,
          "content": "# TwinklingRefreshLayout\nTwinklingRefreshLayout延伸了Google的SwipeRefreshLayout的思想,不在列表控件上动刀,而是使用一个ViewGroup来包含列表控件,以保持其较低的耦合性和较高的通用性。其主要特性有：\n\n1. 支持RecyclerView、ScrollView、AbsListView系列(ListView、GridView)、WebView以及其它可以获取到scrollY的控件\n2. 支持加载更多\n3. 默认支持 **越界回弹**，随手势速度有不同的效果\n4. 可开启没有刷新控件的纯净越界回弹模式\n5. setOnRefreshListener中拥有大量可以回调的方法\n6. 将Header和Footer抽象成了接口,并回调了滑动过程中的系数,方便实现个性化的Header和Footer\n7. 支持NestedScroll,嵌套CoordinatorLayout\n\n**目前已经支持了所有的View，比如是一个FrameLayout，LinearLayout,AnyView。**\n\n![](art/structure_v1.0.png)\n\n## Demo\n[下载Demo](art/app-debug.apk)\n\n![](art/gif_recyclerview.gif)  ![](art/gif_listview.gif)  ![](art/gif_gridview.gif) ![](art/gif_recyclerview2.gif) ![](art/gif_scrollview.gif)  ![](art/gif_webview.gif)\n\nYou can download these Videos for more details.\n\n- [Music - ListView - FixedHeader](art/gif_listview.mp4)\n- [Food - RecyclerView - PureScrollMode](art/gif_recyclerview.mp4)\n- [Science - GridView - SinaHeader](art/gif_gridview.mp4)\n- [Photo - RecyclerView - BezierLayout](art/gif_recyclerview2.mp4)\n- [Story - ScrollView - GoogleDotView](art/gif_scrollview.mp4)\n- [Dribbble - WebView - FloatRefresh](art/gif_webview.mp4)\n\n## 使用方法\n#### 1.添加gradle依赖\n将libray模块复制到项目中,或者直接在build.gradle中依赖:\n```\ncompile 'com.lcodecorex:tkrefreshlayout:1.0.7'\n```\n\n#### 2.在xml中添加TwinklingRefreshLayout\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<com.lcodecore.tkrefreshlayout.TwinklingRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:id=\"@+id/refreshLayout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    app:tr_wave_height=\"180dp\"\n    app:tr_head_height=\"100dp\">\n\n    <android.support.v7.widget.RecyclerView\n        android:id=\"@+id/recyclerview\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:overScrollMode=\"never\"\n        android:background=\"#fff\" />\n</com.lcodecore.library.TwinklingRefreshLayout>\n```\n\nAndroid系统为了跟iOS不一样，当界面OverScroll的时候会显示一个阴影。为了达到更好的显示效果，最好禁用系统的overScroll，如上给RecyclerView添加`android:overScrollMode=\"never\"`。\n\n#### 3.在Activity或者Fragment中配置\n##### TwinklingRefreshLayout不会自动结束刷新或者加载更多，需要手动控制\n```java\nrefreshLayout.setOnRefreshListener(new RefreshListenerAdapter(){\n            @Override\n            public void onRefresh(final TwinklingRefreshLayout refreshLayout) {\n                new Handler().postDelayed(new Runnable() {\n                    @Override\n                    public void run() {\n                        refreshLayout.finishRefreshing();\n                    }\n                },2000);\n            }\n\n            @Override\n            public void onLoadMore(final TwinklingRefreshLayout refreshLayout) {\n                new Handler().postDelayed(new Runnable() {\n                    @Override\n                    public void run() {\n                        refreshLayout.finishLoadmore();\n                    }\n                },2000);\n            }\n        });\n    }\n```\n使用finishRefreshing()方法结束刷新，finishLoadmore()方法结束加载更多。此处OnRefreshListener还有其它方法，可以选择需要的来重写。\n\n如果你想进入到界面的时候主动调用下刷新，可以调用startRefresh()/startLoadmore()方法。\n\n##### setWaveHeight、setHeaderHeight、setBottomHeight、setOverScrollHeight\n- setMaxHeadHeight 设置头部可拉伸的最大高度。\n- setHeaderHeight 头部固定高度(在此高度上显示刷新状态)\n- setMaxBottomHeight\n- setBottomHeight 底部高度\n- setOverScrollHeight 设置最大的越界高度\n\n#### setEnableRefresh、setEnableLoadmore\n灵活的设置是否禁用上下拉。\n\n##### setHeaderView(IHeaderView headerView)、setBottomView(IBottomView bottomView)\n设置头部/底部个性化刷新效果，头部需要实现IHeaderView，底部需要实现IBottomView。\n\n#### setEnableOverScroll\n是否允许越界回弹。\n\n##### setOverScrollTopShow、setOverScrollBottomShow、setOverScrollRefreshShow\n是否允许在越界的时候显示刷新控件，默认是允许的，也就是Fling越界的时候Header或Footer照常显示，反之就是不显示；可能有特殊的情况，刷新控件会影响显示体验才设立了这个状态。\n\n##### setPureScrollModeOn()\n开启纯净的越界回弹模式，也就是所有刷新相关的View都不显示，只显示越界回弹效果\n\n##### setAutoLoadMore\n是否在底部越界的时候自动切换到加载更多模式\n\n##### addFixedExHeader\n添加一个固定在顶部的Header(效果还需要优化)\n\n##### startRefresh、startLoadMore、finishRefreshing、finishLoadmore\n\n##### setFloatRefresh(boolean)\n支持切换到像SwipeRefreshLayout一样的悬浮刷新模式了。\n\n##### setTargetView(View view)\n设置滚动事件的作用对象。\n\n##### setDefaultHeader、setDefaultFooter\n现在已经提供了设置默认的Header、Footer的static方法，可在Application或者一个Activity中这样设置：\n```java\nTwinklingRefreshLayout.setDefaultHeader(SinaRefreshView.class.getName());\nTwinklingRefreshLayout.setDefaultFooter(BallPulseView.class.getName());\n```\n\n\n#### 4.扩展属性\n- tr_max_head_height 头部拉伸允许的最大高度\n- tr_head_height  头部高度\n- tr_max_bottom_height\n- tr_bottom_height 底部高度\n- tr_overscroll_height 允许越界的最大高度\n- tr_enable_refresh 是否允许刷新,默认为true\n- tr_enable_loadmore 是否允许加载更多,默认为true\n- tr_pureScrollMode_on 是否开启纯净的越界回弹模式\n- tr_overscroll_top_show - 否允许顶部越界时显示顶部View\n- tr_overscroll_bottom_show 是否允许底部越界时显示底部View\n- tr_enable_overscroll 是否允许越界回弹\n- tr_floatRefresh 开启悬浮刷新模式\n- tr_autoLoadMore 越界时自动加载更多\n- tr_enable_keepIView 是否在开始刷新之后保持状态，默认为true；若需要保持原来的操作逻辑，这里设置为false即可\n- tr_showRefreshingWhenOverScroll 越界时直接显示正在刷新中的头部\n- tr_showLoadingWhenOverScroll 越界时直接显示正在加载更多中的底部\n\n## 其它说明\n### 1.默认支持越界回弹，并可以随手势越界不同的高度\n这一点很多类似SwipeRefreshLayout的刷新控件都没有做到(包括SwipeRefreshLayout),因为没有拦截下来的时间会传递给列表控件，而列表控件的滚动状态很难获取。解决方案就是给列表控件设置了OnTouchListener并把事件交给GestureDetector处理,然后在列表控件的OnScrollListener中监听View是否滚动到了顶部(没有OnScrollListener的则采用延时监听策略)。\n\n### 2.setOnRefreshListener大量可以回调的方法\n- onPullingDown(TwinklingRefreshLayout refreshLayout, float fraction)  正在下拉的过程\n- onPullingUp(TwinklingRefreshLayout refreshLayout, float fraction)    正在上拉的过程\n- onPullDownReleasing(TwinklingRefreshLayout refreshLayout, float fraction)  下拉释放过程\n- onPullUpReleasing(TwinklingRefreshLayout refreshLayout, float fraction)  上拉释放过程\n- onRefresh(TwinklingRefreshLayout refreshLayout)  正在刷新\n- onLoadMore(TwinklingRefreshLayout refreshLayout)  正在加载更多\n\n其中fraction表示当前下拉的距离与Header高度的比值(或者当前上拉距离与Footer高度的比值)。\n\n### 3.Header和Footer\n##### BezierLayout(pic 4)\n- setWaveColor\n- setRippleColor\n\n##### GoogleDotView(pic 5)\n##### SinaRefreshView(pic 3)\n- setArrowResource\n- setTextColor\n- setPullDownStr\n- setReleaseRefreshStr\n- setRefreshingStr\n\n##### ProgressLayout(SwipeRefreshLayout pic 6)\n- setProgressBackgroundColorSchemeResource(@ColorRes int colorRes)\n- setProgressBackgroundColorSchemeColor(@ColorInt int color)\n- setColorSchemeResources(@ColorRes int... colorResIds)\n\n####Footer\n##### BallPulseView(pic 2)\n- setNormalColor(@ColorInt int color)\n- setAnimatingColor(@ColorInt int color)\n\n##### LoadingView(pic 3)\n更多动效可以参考[AVLoadingIndicatorView](https://github.com/81813780/AVLoadingIndicatorView)库。\n\n\n### 3.实现个性化的Header和Footer\n相关接口分别为IHeaderView和IBottomView,代码如下:\n```java\npublic interface IHeaderView {\n    View getView();\n\n    void onPullingDown(float fraction,float maxHeadHeight,float headHeight);\n\n    void onPullReleasing(float fraction,float maxHeadHeight,float headHeight);\n\n    void startAnim(float maxHeadHeight,float headHeight);\n\n    void reset();\n}\n```\n\n其中getView()方法用于在TwinklingRefreshLayout中获取到实际的Header,因此不能返回null。\n\n**实现像新浪微博那样的刷新效果**(有部分修改,具体请看源码),实现代码如下:\n\n1.首先定义SinaRefreshHeader继承自FrameLayout并实现IHeaderView方法\n\n2.getView()方法中返回this\n\n3.在onAttachedToWindow()或者构造函数方法中获取一下需要用到的布局\n\n4. 在onFinish()方法中调用listener.onAnimEnd()。此方法的目的是为了在finish之前可以执行一段动画。\n\n```java\nprivate void init() {\n        View rootView = View.inflate(getContext(), R.layout.view_sinaheader, null);\n        refreshArrow = (ImageView) rootView.findViewById(R.id.iv_arrow);\n        refreshTextView = (TextView) rootView.findViewById(R.id.tv);\n        loadingView = (ImageView) rootView.findViewById(R.id.iv_loading);\n        addView(rootView);\n    }\n```\n\n4.实现其它方法\n```java\n@Override\n    public void onPullingDown(float fraction, float maxHeadHeight, float headHeight) {\n        if (fraction < 1f) refreshTextView.setText(pullDownStr);\n        if (fraction > 1f) refreshTextView.setText(releaseRefreshStr);\n        refreshArrow.setRotation(fraction * headHeight / maxHeadHeight * 180);\n\n\n    }\n\n    @Override\n    public void onPullReleasing(float fraction, float maxHeadHeight, float headHeight) {\n        if (fraction < 1f) {\n            refreshTextView.setText(pullDownStr);\n            refreshArrow.setRotation(fraction * headHeight / maxHeadHeight * 180);\n            if (refreshArrow.getVisibility() == GONE) {\n                refreshArrow.setVisibility(VISIBLE);\n                loadingView.setVisibility(GONE);\n            }\n        }\n    }\n\n    @Override\n    public void startAnim(float maxHeadHeight, float headHeight) {\n        refreshTextView.setText(refreshingStr);\n        refreshArrow.setVisibility(GONE);\n        loadingView.setVisibility(VISIBLE);\n    }\n\n    @Override\n        public void onFinish(OnAnimEndListener listener) {\n            listener.onAnimEnd();\n        }\n```\n\n5.布局文件\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\" android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\">\n    <ImageView\n        android:id=\"@+id/iv_arrow\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:src=\"@drawable/ic_arrow\"/>\n\n    <ImageView\n        android:id=\"@+id/iv_loading\"\n        android:visibility=\"gone\"\n        android:layout_width=\"34dp\"\n        android:layout_height=\"34dp\"\n        android:src=\"@drawable/anim_loading_view\"/>\n\n    <TextView\n        android:id=\"@+id/tv\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginLeft=\"16dp\"\n        android:textSize=\"16sp\"\n        android:text=\"下拉刷新\"/>\n</LinearLayout>\n```\n\n注意fraction的使用,比如上面的代码`refreshArrow.setRotation(fraction * headHeight / maxHeadHeight * 180)`，`fraction * headHeight`表示当前头部滑动的距离，然后算出它和最大高度的比例，然后乘以180，可以使得在滑动到最大距离时Arrow恰好能旋转180度。\n\n\nonPullingDown/onPullingUp表示正在下拉/正在上拉的过程。\nonPullReleasing表示向上拉/下拉释放时回调的状态。\nstartAnim则是在onRefresh/onLoadMore之后才会回调的过程（此处是显示了加载中的小菊花）\n\n如上所示，轻而易举就可以实现一个个性化的Header或者Footer。（更简单的实现请参考Demo中的 **TextHeaderView(图四)**）。\n\n### NestedScroll\n#### TwinklingRefreshLayout嵌套CoordinatorLayout\n---layout\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<com.lcodecore.tkrefreshlayout.TwinklingRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:id=\"@+id/refresh\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <android.support.design.widget.CoordinatorLayout\n        android:id=\"@+id/coord_container\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:addStatesFromChildren=\"true\"\n        android:fitsSystemWindows=\"true\">\n\n        <android.support.design.widget.AppBarLayout\n            android:id=\"@+id/appbar_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:clipChildren=\"false\">\n\n            <!--...-->\n\n        </android.support.design.widget.AppBarLayout>\n\n        <android.support.v7.widget.RecyclerView\n            android:id=\"@+id/recyclerview\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" />\n\n    </android.support.design.widget.CoordinatorLayout>\n</com.lcodecore.tkrefreshlayout.TwinklingRefreshLayout>\n```\n\n--- 代码1\n```\nrefreshLayout.setTargetView(rv);\n```\n让refreshLayout能够找到RecyclerView/ListView\n\n--- 代码2\n```java\nAppBarLayout appBarLayout = (AppBarLayout) findViewById(R.id.appbar_layout);\nappBarLayout.addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() {\n    @Override\n    public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {\n        if (verticalOffset >= 0) {\n            refreshLayout.setEnableRefresh(true);\n            refreshLayout.setEnableOverScroll(false);\n        } else {\n            refreshLayout.setEnableRefresh(false);\n            refreshLayout.setEnableOverScroll(false);\n        }\n    }\n});\n```\n设置AppBarLayout的移动监听器，需要下拉显示AppBarLayout时需设置setEnableRefresh(false),setEnableOverScroll(false)；AppBarLayout隐藏后还原为原来设置的值即可。\n\n####CoordinatorLayout嵌套TwinklingRefreshLayout\n--- layout\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:id=\"@+id/coord_container\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:addStatesFromChildren=\"true\"\n    android:fitsSystemWindows=\"true\">\n\n    <com.lcodecore.tkrefreshlayout.TwinklingRefreshLayout\n        android:id=\"@+id/refresh\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        app:layout_behavior=\"@string/appbar_scrolling_view_behavior\">\n\n        <android.support.v7.widget.RecyclerView\n            android:id=\"@+id/recyclerview\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\" />\n\n    </com.lcodecore.tkrefreshlayout.TwinklingRefreshLayout>\n\n</android.support.design.widget.CoordinatorLayout>\n```\n注意给TwinklingRefreshLayout设置一个layout_behavior=\"@string/appbar_scrolling_view_behavior\"\n\n## TODO\n- 制作一个star相关的动效\n- 带视差效果的Header\n\n> ps：如有任何问题或者是建议，可以邮箱联系我！（lcodecore@163.com）\n> 如有问题或新的需求，请加QQ群202640706讨论，开源库会根据需求持续更新。\n\n开源库消耗了我大量的精力和时间，如果你喜欢这个库或者对自己有所帮助，还请多多支持我。Buy me a coffee!\n\n![](art/alipay.jpg) ![](art/wepay.png)\n\n## 更新日志\n#### v1.07\n- 你们要的设置默认刷新头/脚的方法来啦\n- Demo中集成StrictMode、BlockCanary检测ANR\n- 支持NestedScroll\n- 修复item点击失效/点击闪烁的问题\n- Nested滑动显示刷新头/尾支持\n- 支持刷新/加载更多状态保持\n- 空白View亦可刷新/加载\n\n#### v1.06\n- 修复触摸监听失效问题\n- 修复wrap_content时刷新控件显示在屏幕中央问题\n- 去除AVLoadingIndicatorView等依赖，改为BallPulseView\n- 优化加载更多完成时出现的闪烁问题\n- 修复ValueAnimator以及Demo中WebView带来的内存泄漏问题\n- 理论上解决了触摸、点击以及滚动监听失效等问题\n- 新增setTargetView()方法，可设置滚动事件的作用对象\n- 添加了CoordinateLayout demo(暂未在RefreshLayout中添加相关逻辑)\n- 修复三星、酷派手机出现的兼容问题\n- 修复禁用refresh、loadmore后overscroll不可用的问题\n- 修复在顶部、底部fling时页面闪烁问题\n- 修复IBottomView中的参数错误，新增max_head_height,max_bottom_height属性，setWaveHeight方法为setMaxHeadHeight\n\n#### v1.05紧急修复版\n- 修复底部自动加载更多问题\n- 修复FixedHeader遮挡item问题\n- RefreshListenerAdapter添加接口onRefreshCanceled()/onLoadmoreCanceled() 回调刷新被取消的状态\n- 修复刷新状态重复回调问题\n- 添加Apache License 2.0开源协议\n\n#### v1.04\n##### 新增功能\n- **第二次重构完成**,将核心逻辑拆分为RefreshProcessor、AnimProcessor、OverScrollProcessor、CoProcessor\n- **优化越界策越，手势决定越界高度**\n- **优化界面流畅度**\n- 添加类似SwipeRefreshLayout的**悬浮刷新**功能(ProgressLayout)\n- 滑到底部**自动加载更多**or回弹可选，默认为回弹\n- 允许在结束刷新之前执行一个动效：IHeadView.onFinish(animEndListener)\n- 新增支持Header(Beta)\n- 优化BezierLayout、SinaRefreshLayout等的显示并增加调节属性\n- 新增支持设置是否允许OverScroll\n\n##### fixed bugs\n- 修复刷新或加载更多时，列表item没有铺满列表控件，滑动无效的问题\n- 添加主动刷新/加载更多的方法：startRefresh(),startLoadMore()\n- 修复顶部和底部越界高度不一致的问题\n- 修复WebView在底部fling时不能越界的问题\n- 动画执行时间与高度相关，动效更加柔和\n\n\n#### v1.03\n- 扩展了更多的属性\n- 修复Fragment回收导致的空指针异常问题\n- 加入x方向判断,减小了滑动冲突\n- 优化加载更多列表显示问题\n- 可以灵活的设置是否禁用上下拉\n- 修复GridView滑动过程中出现的白条问题\n- Demo中添加轮播条展示\n\n#### v1.02\n- 修复加载更多列表控件的显示问题\n\n#### v1.01\n- 支持了RecyclerView、ScrollView、AbsListView、WebView\n- 支持越界回弹\n- 支持个性化Header、Footer\n\n\nLicense\n-------\n\n    Copyright 2016 lcodecorex\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n"
        },
        {
          "name": "TODO_list.md",
          "type": "blob",
          "size": 2.578125,
          "content": "# v1.07开发计划\n- 华为7.0 P9奔溃问题\n- setFloatRefresh(true)下拉刷新不可见问题 --View添加顺序的问题 **done**\n- 确认item点击失效问题是否解决\n- header添加时机的空指针和不显示问题 --去掉post **done**\n- 提供设置默认header、footer的方法  **done**\n- 频繁设置禁止下拉和加载失效问题？(增加RefreshMode类)\n- fixedHeader ontouch事件无响应，需手动设置clickable=true\n- setOverScrollTopShow(false)/setOverScrollBottomShow(false)/setOverScrollRefreshShow(false)  设置无效   **done**\n- 兼容nestedscroll\n- 状态保持问题\n- onFinishRefresh不回调问题\n- 刷新时禁止加载更多，去加载更多底部空白没回去\n- 空白View下拉无效\n- 不停下拉导致head悬浮\n- 测试autoLoadMore\n\n\n# v1.06开发计划\n## 存在的问题\n1. 三星、酷派手机的兼容问题\n2. 依赖太旧的问题->选择去除依赖还是更新依赖  **done** 已去除依赖\n3. 自动刷新动画生硬  todo 问题待验证\n4. 加载更多闪烁问题 **done** 做了优化\n5. layout_behavior支持问题 添加了Demo但未完成任何逻辑处理\n6. 是否要支持ViewPager回弹问题 TODO\n7. 是否要支持所有的View TODO  不能滑动NormalView是因为没有焦点的原因（需手动设置），暂时不考虑支持\n8. 测试事件监听冲突问题 理论上修改后已经不存在这个问题 **done**\n9. 内存泄漏问题  -> 解决ValueAnimator潜在的内存泄漏问题；WebView内存泄漏问题；**done**\n10. 仿QQ视差效果\n11. 测试加载更多后不添加数据  **done**\n12. 考虑是否要给Loadmore添加完成延时\n13. FixedHeader问题\n14. 多点触摸处理\n15. 控制底部下拉后或者顶部上拉后再次进入动画可以保持！\n16. Refresh和OverScroll的开关耦合问题,即禁用loadmore后OverScroll不可用问题  **done**\n17. 测试自动加载更多功能是否正常 **done**正常\n\n## 新发现的问题\n1. beizierlayout主动调用刷新时会一片白 todo\n2. BallPulseView引入了内存泄漏 **done**\n3. 新的方案，怎么让scroll更平滑；计算Footer降低与TargetView显示距离是否一致：结论，一致，问题在每次滚动的距离上  **done**\n4. requestLayout时提示 **improperly called by android.support.v7.widget.AppCompatTextView**\n5. WebView上拉不起作用  **done**\n6. 修改IBottomView中的参数错误，增加max_head_height,max_bottom_height属性;修改setWaveHeight方法为setMaxHeadHeight，增加setMaxBottomHeight方法  **done**\n7. 在最顶部或最底部时fling会多次反弹 **done**（解决办法，在最顶端fling时不响应动作）\n"
        },
        {
          "name": "app",
          "type": "tree",
          "content": null
        },
        {
          "name": "art",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.gradle",
          "type": "blob",
          "size": 0.681640625,
          "content": "// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.3.0'\n        classpath 'com.novoda:bintray-release:0.3.4'\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        jcenter()\n    }\n    tasks.withType(Javadoc) {\n        options.addStringOption('Xdoclint:none', '-quiet')\n        options.addStringOption('encoding', 'UTF-8')\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n"
        },
        {
          "name": "introduction.md",
          "type": "blob",
          "size": 23.0625,
          "content": "---\ndate: 2016-10-11 10:00\nstatus: public\ntitle: '想要亲手实现一个刷新控件，你只需要掌握这些知识'\n---\n\n十一期间，大家都去玩耍了，笔者以前写的一个开源库收到了star，笔者非常高兴，心血来潮之下，决定重新搞一搞，耗费了三天的假期。笔者期望，这个刷新控件能像Google的SwipeRefreshLayout一样，支持大多数列表控件，另外还得有加载更多功能，最好要很方便的支持个性化吧。开源库在这，[TwinklingRefreshLayout](https://github.com/lcodecorex/TwinklingRefreshLayout)，如果喜欢请star，笔者的文章也是围绕着这个控件的实现来说的。\n\n为了方便，笔者将TwinklingRefreshLayout直接继承自FrameLayout而不是ViewGroup，可以省去onMeasure、onLayout等一些麻烦，Header和Footer则是通过LayoutParams来设置View的Gravity属性来做的。\n\n## 1. View的onAttachedToWindow()方法\n首先View没有明显的生命周期，我们又不能再构造函数里面addView()给控件添加头部和底部，因此这个操作比较合适的时机就是在onDraw()之前——onAttachedToWindow()方法中。\n\n此时View被添加到了窗体上,View有了一个用于显示的Surface,将开始绘制。因此其保证了在onDraw()之前调用,但可能在调用 onDraw(Canvas) 之前的任何时刻，包括调用 onMeasure(int, int) 之前或之后。\n比较适合去执行一些初始化操作。(此外在屏蔽Home键的时候也会回调这个方法)\n\n- onDetachedFromWindow()与onAttachedToWindow()方法相对应。\n- ViewGroup先是调用自己的onAttachedToWindow()方法，再调用其每个child的onAttachedToWindow()方法，这样此方法就在整个view树中遍布开了，而visibility并不会对这个方法产生影响。\n\n- onAttachedToWindow方法是在Activity resume的时候被调用的，也就是act对应的window被添加的时候，且每个view只会被调用一次，父view的调用在前，不论view的visibility状态都会被调用，适合做些view特定的初始化操作；\n- onDetachedFromWindow方法是在Activity destroy的时候被调用的，也就是act对应的window被删除的时候，且每个view只会被调用一次，父view的调用在后，也不论view的visibility状态都会被调用，适合做最后的清理操作；\n\n就TwinklingRefreshLayout来说,Header和Footer需要及时显示出来,View又没有明显的生命周期,因此在onAttachedToWindow()中进行设置可以保证在onDraw()之前添加了刷新控件。\n```java\n    @Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n\n        //添加头部\n        FrameLayout headViewLayout = new FrameLayout(getContext());\n        LayoutParams layoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0);\n        layoutParams.gravity = Gravity.TOP;\n        headViewLayout.setLayoutParams(layoutParams);\n\n        mHeadLayout = headViewLayout;\n        this.addView(mHeadLayout);//addView(view,-1)添加到-1的位置\n\n        //添加底部\n        FrameLayout bottomViewLayout = new FrameLayout(getContext());\n        LayoutParams layoutParams2 = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0);\n        layoutParams2.gravity = Gravity.BOTTOM;\n        bottomViewLayout.setLayoutParams(layoutParams2);\n\n        mBottomLayout = bottomViewLayout;\n        this.addView(mBottomLayout);\n        //...其它步骤\n    }\n```\n\n但是当TwinklingRefreshLayout应用在Activity或Fragment中时,可能会因为执行onResume重新触发了onAttachedToWindow()方法而导致重复创建Header和Footer挡住原先添加的View,因此需要加上判断:\n```java\n    @Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        System.out.println(\"onAttachedToWindow绑定窗口\");\n\n        //添加头部\n        if (mHeadLayout == null) {\n            FrameLayout headViewLayout = new FrameLayout(getContext());\n            LayoutParams layoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0);\n            layoutParams.gravity = Gravity.TOP;\n            headViewLayout.setLayoutParams(layoutParams);\n\n            mHeadLayout = headViewLayout;\n\n            this.addView(mHeadLayout);//addView(view,-1)添加到-1的位置\n\n            if (mHeadView == null) setHeaderView(new RoundDotView(getContext()));\n        }\n        //...\n    }\n```\n\n## 2. View的事件分发机制\n事件的分发过程由dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent三个方法来共同完成的。由于事件的传递是自顶向下的，对于ViewGroup，笔者觉得最重要的就是onInterceptTouchEvent方法了，它关系到事件是否能够继续向下传递。看如下伪代码：\n```java\npublic boolean dispatchTouchEvent(MotionEvenet ev){\n    boolean consume = false;\n    if (onInterceptTouchEvent(ev)) {\n        consume = onTouchEvent(ev);\n    }else{\n        consume = child.dispatchTouchEvent(ev);\n    }\n    return consume;\n}\n```\n\n如代码所示，如果ViewGroup拦截了(onInterceptTouchEvent返回true)事件，则事件会在ViewGroup的onTouchEvent方法中消费，而不会传到子View；否则事件将交给子View去分发。\n\n我们需要做的就是在子View滚动到顶部或者底部时及时的拦截事件，让ViewGroup的onTouchEvent来交接处理滑动事件。\n\n## 3. 判断子View滚动达到边界\n在什么时候对事件进行拦截呢？对于Header，当手指向下滑动也就是 dy>0 且子View已经滚动到顶部(不能再向上滚动)时拦截；对于bottom则是 dy<0 且子View已经滚动到底部(不能再向下滚动)时拦截：\n```java\n@Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        switch (ev.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                mTouchY = ev.getY();\n                break;\n            case MotionEvent.ACTION_MOVE:\n                float dy = ev.getY() - mTouchY;\n\n                if (dy > 0 && !canChildScrollUp()) {\n                    state = PULL_DOWN_REFRESH;\n                    return true;\n                } else if (dy < 0 && !canChildScrollDown() && enableLoadmore) {\n                    state = PULL_UP_LOAD;\n                    return true;\n                }\n                break;\n        }\n        return super.onInterceptTouchEvent(ev);\n    }\n```\n\n判断View能不能继续向上滚动，对于sdk14以上版本，v4包里提供了方法：\n```java\npublic boolean canChildScrollUp() {\n    return ViewCompat.canScrollVertically(mChildView, -1);\n}\n```\n\n其它情况，直接交给子View了，ViewGroup这里也管不着。\n\n## 4. ViewGroup 的 onTouchEvent 方法\n走到这一步，子View的滚动已经交给子View自己去搞了，ViewGroup需要处理的事件只有两个临界状态，也就是用户在下拉可能想要刷新的状态和用户在上拉可能想要加载更多的状态。也就是上面state记录的状态。接下来的事情就简单咯，监听一下ACTION_MOVE和ACTION_UP就好了。\n\n首先在ACTION_DOWN时需要记录下最原先的手指按下的位置 mTouchY，然后在一系列ACTION_MOVE过程中，获取当前位移(ev.getY()-mTouchY)，然后通过 **某种计算方式** 不断计算当前的子View应该位移的距离offsetY，调用`mChildView.setTranslationY(offsetY)`来不断设置子View的位移，同时需要给HeadLayout申请布局高度来完成顶部控件的显示。这其中笔者使用的计算方式就是插值器(Interpolator)。\n\n在ACTION_UP时，需要判断子View的位移有没有达到进入刷新或者是加载更多状态的要求，即`mChildView.getTranslationY() >= mHeadHeight - mTouchSlop`，mTouchSlop是为了防止发生抖动而存在。判断进入了刷新状态时，当前子View的位移在HeadHeight和maxHeadHeight之间，所以需要让子View的位移回到HeadHeight处，否则就直接回到0处。\n\n## 5. Interpolator插值器\nInterpolator用于动画中的时间插值，其作用就是把0到1的浮点值变化映射到另一个浮点值变化。上面提到的计算方式如下：\n```java\nfloat offsetY = decelerateInterpolator.getInterpolation(dy / mWaveHeight / 2) * dy / 2;\n```\n\n其中(dy / mWaveHeight / 2)是一个0~1之间的浮点值，随着下拉高度的增加，这个值越来越大，通过decelerateInterpolator获取到的插值也越来越大，只不过这些值的变化量是越来越小(decelerate效果)。Interpolator继承自TimeInterpolator接口，源码如下：\n```java\npublic interface TimeInterpolator {\n    /**\n     * Maps a value representing the elapsed fraction of an animation to a value that represents\n     * the interpolated fraction. This interpolated value is then multiplied by the change in\n     * value of an animation to derive the animated value at the current elapsed animation time.\n     *\n     * @param input A value between 0 and 1.0 indicating our current point\n     *        in the animation where 0 represents the start and 1.0 represents\n     *        the end\n     * @return The interpolation value. This value can be more than 1.0 for\n     *         interpolators which overshoot their targets, or less than 0 for\n     *         interpolators that undershoot their targets.\n     */\n    float getInterpolation(float input);\n}\n```\n\ngetInterpolation接收一个0.0~1.0之间的float参数，0.0代表动画的开始，1.0代表动画的结束。返回值则可以超过1.0，也可以小于0.0，比如OvershotInterpolator。所以getInterpolation()是用来实现输入0~1返回0~1左右的函数值的一个函数。\n![](http://www.mincoder.com/images/201502/dr9PkIhoI1mCIasR.jpg)\n\n## 6. 属性动画\n上面说到了手指抬起的时候，mChildView的位移要么回到mHeadHeight处，要么回到0处。直接setTranslationY()不免太不友好，所以我们这里使用属性动画来做。本来是直接可以用mChildView.animate()方法来完成属性动画的，因为需要兼容低版本并回调一些参数，所以这里使用ObjectAnimator:\n```java\nprivate void animChildView(float endValue, long duration) {\n        ObjectAnimator oa = ObjectAnimator.ofFloat(mChildView, \"translationY\", mChildView.getTranslationY(), endValue);\n        oa.setDuration(duration);\n        oa.setInterpolator(new DecelerateInterpolator());//设置速率为递减\n        oa.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                int height = (int) mChildView.getTranslationY();//获得mChildView当前y的位置\n                height = Math.abs(height);\n\n                mHeadLayout.getLayoutParams().height = height;\n                mHeadLayout.requestLayout();\n            }\n        });\n    oa.start();\n}\n```\n\n传统的补间动画只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，而且它只是改变了View的显示效果，改变了画布绘制出来的样子，而不会真正去改变View的属性。比如用补间动画对一个按钮进行了移动，只有在原位置点击按钮才会发生响应，而属性动画则可以真正的移动按钮。属性动画最简单的一种使用方式就是使用ValueAnimator:\n```java\nValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);  \nanim.start();\n```\n\n它可以传入多个参数，如`ValueAnimator.ofFloat(0f, 5f, 3f, 10f)`，他会根据设置的插值器依次计算，比如想做一个心跳的效果，用ValueAnimator来控制心的当前缩放值大小就是个不错的选择。除此之外，还可以调用setStartDelay()方法来设置动画延迟播放的时间，调用setRepeatCount()和setRepeatMode()方法来设置动画循环播放的次数以及循环播放的模式等。\n\n如果想要实现View的位移，ValueAnimator显然是比较麻烦的，我们可以使用ValueAnimator的子类ObjectAnimator，如下：\n```java\nObjectAnimator animator = ObjectAnimator.ofFloat(textview, \"alpha\", 1f, 0f, 1f);  \nanimator.setDuration(5000);  \nanimator.start();  \n```\n\n传入的第一个值是Object，不局限于View，传入的第二个参数为Object的一个属性，比如传入`\"abc\"`，ObjectAnimator会去Object里面找有没有 **getAbc()** 和 **setAbc(...)** 这两个方法，如果没有，动画就没有效果，它内部应该是处理了相应的异常。另外还可以用AnimatorSet来实现多个属性动画同时播放，也可以在xml中写属性动画。\n\n## 7. 个性化Header和Footer的接口\n要实现个性化的Header和Footer，最最重要的当然是把滑动过程中系数都回调出来啦。在ACTION_MOVE的时候，在ACTION_UP的时候，还有在mChildView在执行属性动画的时候，而且mChildView当前所处的状态都是很明确的，写个接口就好了。\n```\npublic interface IHeaderView {\n    View getView();\n\n    void onPullingDown(float fraction,float maxHeadHeight,float headHeight);\n\n    void onPullReleasing(float fraction,float maxHeadHeight,float headHeight);\n\n    void startAnim(float maxHeadHeight,float headHeight);\n\n    void onFinish();\n}\n```\n\ngetView()方法保证在TwinklingRefreshLayout中可以取到在外部设置的View，onPullingDown()是下拉过程中ACTION_MOVE时的回调方法，onPullReleasing()是下拉状态中ACTION_UP时的回调方法，startAnim()则是正在刷新时回调的方法。其中 **fraction=mChildView.getTranslationY()/mHeadHeight**，fraction=1 时，mChildView的位移恰好是HeadLayout的高度，fraction>1 时则超过了HeadLayout的高度，其最大高度可以到达 **mWaveHeight/mHeadHeight**。这样我们只需要写一个View来实现这个接口就可以实现个性化了，该有的参数都有了！\n\n## 8. 实现越界回弹\n不能在手指快速滚动到顶部时对越界做出反馈，这是一个继承及ViewGroup的刷新控件的通病。没有继承自具体的列表控件，它没办法获取到列表控件的Scroller，不能获取到列表控件的当前滚动速度，更是不能预知列表控件什么时候能滚动到顶部；同时ViewGroup除了达到临界状态的事件被拦截了，其它事件全都交给了子View去处理。我们能获取到的有关于子View的操作，只有简简单单的手指的触摸事件。so, let's do it!\n```java\nmChildView.setOnTouchListener(new OnTouchListener() {\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n        return gestureDetector.onTouchEvent(event);\n    }\n});\n```\n\n我们把在mChildView上的触摸事件交给了一个工具类GestureDetector去处理，它可以辅助检测用户的单击、滑动、长按、双击、快速滑动等行为。我们这里只需要重写onFling()方法并获取到手指在Y方向上的速度velocityY，要是再能及时的发现mChildView滚动到了顶部就可以解决问题了。\n```java\nGestureDetector gestureDetector = new GestureDetector(getContext(), new GestureDetector.SimpleOnGestureListener() {\n\n        @Override\n        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {\n            mVelocityY = velocityY;\n        }\n    });\n```\n\n此外获取速度还可以用VelocityTracker，比较麻烦一些：\n```java\nVelocityTracker tracker = VelocityTracker.obtain();\ntracker.addMovement(ev);\n//然后在恰当的位置使用如下方法获取速度\ntracker.computeCurrentVelocity(1000);\nmVelocityY = (int)tracker.getYVelocity();\n```\n\n继续来实现越界回弹。对于RecyclerView、AbsListView，它们提供有OnScrollListener可以获取一下滚动状态：\n```java\nif (mChildView instanceof RecyclerView) {\n            ((RecyclerView) mChildView).addOnScrollListener(new RecyclerView.OnScrollListener() {\n                @Override\n                public void onScrollStateChanged(RecyclerView recyclerView, int newState) {\n                    if (!isRefreshing && !isLoadingmore && newState == RecyclerView.SCROLL_STATE_IDLE) {\n                        if (mVelocityY >= 5000 && ScrollingUtil.isRecyclerViewToTop((RecyclerView) mChildView)) {\n                            animOverScrollTop();\n                        }\n                        if (mVelocityY <= -5000 && ScrollingUtil.isRecyclerViewToBottom((RecyclerView) mChildView)) {\n                            animOverScrollBottom();\n                        }\n                    }\n                    super.onScrollStateChanged(recyclerView, newState);\n                }\n            });\n        }\n```\n\n笔者选取了一个滚动速度的临界值，Y方向的滚动速度大于5000时才允许越界回弹，RecyclerView的OnScrollListener可以让我们获取到滚动状态的改变，滚动到顶部时滚动完成，状态变为SCROLL_STATE_IDLE，执行越界回弹动画。这样的策略也还有一些缺陷，不能获取到mChildView滚动到顶部时的滚动速度，也就不能根据不同的滚动速度来实现更加友好的越界效果。现在的越界高度是固定的，还需要后面进行优化，比如采用加速度来计算，是否可行还待验证。\n\n## 9. 滚动的延时计算策略\n上面的方法对于RecyclerView和AbsListView都好用，对于ScrollView、WebView就头疼了，只能使用延时计算一段时间看有没有到达顶部的方式来判断的策略。延时策略的思想就是通过发送一系列的延时消息从而达到一种渐进式计算的效果，具体来说可以使用Handler或View的postDelayed方法，也可以使用线程的sleep方法。另外提一点，需要不断循环计算一个数值，比如自定义View需要实现根据某个数值变化的动效，最好不要使用Thread + while 循环的方式计算，使用ValueAnimator会是更好的选择。这里笔者选择了Handler的方式。\n```java\n@Override\npublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {\n    mVelocityY = velocityY;\n    if (!(mChildView instanceof AbsListView || mChildView instanceof RecyclerView)) {\n        //既不是AbsListView也不是RecyclerView,由于这些没有实现OnScrollListener接口,无法回调状态,只能采用延时策略\n        if (Math.abs(mVelocityY) >= 5000) {\n            mHandler.sendEmptyMessage(MSG_START_COMPUTE_SCROLL);\n        } else {\n            cur_delay_times = ALL_DELAY_TIMES;\n        }\n    }\n    return false;\n}\n```\n\n在滚动速度大于5000的时候发送一个重新计算的消息，Handler收到消息后，延时一段时间继续给自己发送消息，直到时间用完或者mChildView滚动到顶部或者用户又进行了一次Fling动作。\n```java\nprivate Handler mHandler = new Handler() {\n    @Override\n    public void handleMessage(Message msg) {\n        switch (msg.what) {\n            case MSG_START_COMPUTE_SCROLL:\n                cur_delay_times = -1; //这里没有break,写作-1方便计数\n            case MSG_CONTINUE_COMPUTE_SCROLL:\n                cur_delay_times++;\n\n                if (!isRefreshing && !isLoadingmore && mVelocityY >= 5000 && childScrollToTop()) {\n                    animOverScrollTop();\n                    cur_delay_times = ALL_DELAY_TIMES;\n                }\n\n                if (!isRefreshing && !isLoadingmore && mVelocityY <= -5000 && childScrollToBottom()) {\n                    animOverScrollBottom();\n                    cur_delay_times = ALL_DELAY_TIMES;\n                }\n\n                if (cur_delay_times < ALL_DELAY_TIMES)\n                    mHandler.sendEmptyMessageDelayed(MSG_CONTINUE_COMPUTE_SCROLL, 10);\n                break;\n            case MSG_STOP_COMPUTE_SCROLL:\n                cur_delay_times = ALL_DELAY_TIMES;\n                break;\n        }\n    }\n};\n```\n\nALL_DELAY_TIMES是最多可以计算的次数，当Handler接收到MSG_START_COMPUTE_SCROLL消息时，如果mChildView没有滚动到边界处，则会在10ms之后向自己发送一条MSG_CONTINUE_COMPUTE_SCROLL的消息，然后继续进行判断。然后在合适的时候越界回弹就好了。\n\n## 10. 实现个性化Header\n这里笔者来演示一下，怎么轻轻松松的做一个个性化的Header，比如新浪微博样式的刷新Header(如下面第1图)。\n\n1. 创建 SinaRefreshView 继承自 FrameLayout 并实现 IHeaderView 接口\n\n2. getView()方法中返回this\n\n3. 在onAttachedToWindow()方法中获取一下需要用到的布局(笔者写到了xml中，也可以直接在代码里面写)\n\n```java\n@Override\nprotected void onAttachedToWindow() {\n    super.onAttachedToWindow();\n\n    if (rootView == null) {\n        rootView = View.inflate(getContext(), R.layout.view_sinaheader, null);\n        refreshArrow = (ImageView) rootView.findViewById(R.id.iv_arrow);\n        refreshTextView = (TextView) rootView.findViewById(R.id.tv);\n        loadingView = (ImageView) rootView.findViewById(R.id.iv_loading);\n        addView(rootView);\n    }\n}\n```\n\n4.实现其它方法\n```java\n@Override\npublic void onPullingDown(float fraction, float maxHeadHeight, float headHeight) {\n    if (fraction < 1f) refreshTextView.setText(pullDownStr);\n    if (fraction > 1f) refreshTextView.setText(releaseRefreshStr);\n    refreshArrow.setRotation(fraction * headHeight / maxHeadHeight * 180);\n}\n\n@Override\npublic void onPullReleasing(float fraction, float maxHeadHeight, float headHeight) {\n    if (fraction < 1f) {\n        refreshTextView.setText(pullDownStr);\n        refreshArrow.setRotation(fraction * headHeight / maxHeadHeight * 180);\n        if (refreshArrow.getVisibility() == GONE) {\n            refreshArrow.setVisibility(VISIBLE);\n            loadingView.setVisibility(GONE);\n        }\n    }\n}\n\n@Override\npublic void startAnim(float maxHeadHeight, float headHeight) {\n    refreshTextView.setText(refreshingStr);\n    refreshArrow.setVisibility(GONE);\n    loadingView.setVisibility(VISIBLE);\n}\n```\n\n5.布局文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\" android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\">\n    <ImageView\n        android:id=\"@+id/iv_arrow\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:src=\"@drawable/ic_arrow\"/>\n\n    <ImageView\n        android:id=\"@+id/iv_loading\"\n        android:visibility=\"gone\"\n        android:layout_width=\"34dp\"\n        android:layout_height=\"34dp\"\n        android:src=\"@drawable/anim_loading_view\"/>\n\n    <TextView\n        android:id=\"@+id/tv\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginLeft=\"16dp\"\n        android:textSize=\"16sp\"\n        android:text=\"下拉刷新\"/>\n</LinearLayout>\n```\n\n注意fraction的使用,比如上面的代码 **refreshArrow.setRotation(fraction * headHeight / maxHeadHeight * 180)**，`fraction * headHeight`表示当前头部滑动的距离，然后算出它和最大高度的比例，然后乘以180，可以使得在滑动到最大距离时Arrow恰好能旋转180度。startAnim()方法是在onRefresh之后会自动调用的方法。\n\n要想实现如图2所示效果，可以具体查看笔者的开源库[TwinklingRefreshLayout](https://github.com/lcodecorex/TwinklingRefreshLayout)。\n\n![](https://github.com/lcodecorex/TwinklingRefreshLayout/raw/master/art/gif_gridview.gif) ![](https://github.com/lcodecorex/TwinklingRefreshLayout/raw/master/art/gif_recyclerview.gif)\n\n## 总结\n至此，笔者实现这个刷新控件的所有核心思想都讲完了，其中并没有用到多么高深的技术，只是需要我们多一点耐心，多去调试，不要逃避bug，多挑战一下自己。\n"
        },
        {
          "name": "library",
          "type": "tree",
          "content": null
        },
        {
          "name": "settings.gradle",
          "type": "blob",
          "size": 0.02734375,
          "content": "include ':app', ':library' \n"
        }
      ]
    }
  ]
}