{
  "metadata": {
    "timestamp": 1736608987773,
    "page": 200,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "luckybilly/CC",
      "stars": 4052,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1015625,
          "content": "*.iml\n.gradle\n/local.properties\n/.idea\n.DS_Store\n/build\n/captures\n.externalNativeBuild\nrepo-local\n*.pyc\n"
        },
        {
          "name": "2.0升级指南.MD",
          "type": "blob",
          "size": 7.5146484375,
          "content": "# CC 1.x.x 升级到CC 2.x.x升级指南\n\n### 1. 修改根目录build.gradle\n\n从2.0.0开始，CC的自动注册插件从通用的[AutoRegister](https://github.com/luckybilly/AutoRegister)改为定制化的CCRegister\n在根目录需要将插件地址换一下：\n\n```groovy\nbuildscript {\n    dependencies {\n        classpath 'com.billy.android:autoregister:x.x.x' //使用最新版\n    }\n}\n```\n改为\n```groovy\nbuildscript {\n    dependencies {\n        classpath 'com.billy.android:cc-register:x.x.x' //使用最新版\n    }\n}\n```\n\n### 2. 修改cc-settings.gradle\n由于2.0.0开始使用定制化的插件，插件名称发生了变化，并且将许多原来在cc-settings.gradle中的配置已放在插件中完成，减少配置文件的复杂度\n\n__为了兼容以前直接apply github上cc-settings.gradle文件的用户，2.0版该gradle文件命名为cc-settings-2.gradle__\n\n从2.0.0版本开始，不再推荐直接依赖github上的cc-settings-2.gradle文件，推荐下载到工程根目录下使用，主要原因有：\n\n- github上的文件偶尔会在编译时出现下载失败的情况\n- cc-settings-2.gradle内容只包含了使用插件和添加对CC库的依赖，其它内容都已移至cc-register插件中维护\n- 此文件是为了给用户避免在每个组件中添加重复的代码使用，可在文件中添加自己的配置逻辑，建议在本地维护\n\n##### 2.1 之前依赖的是github上的cc-settings.gradle文件\n之前是通过`apply from: 'https://raw.githubusercontent.com/luckybilly/CC/master/cc-settings.gradle'`方式接入，按如下方式修改：\n\n- 未新增/修改任何配置： \n    - 下载`cc-settings-2.gradle`文件到工程根目录，并使用该文件:`apply from: rootProject.file('cc-settings-2.gradle')`\n- 有类似于cc-settings-demo.gradle的扩展配置文件： \n    - 下载`cc-settings-2.gradle`文件到工程根目录，并使用该文件:`apply from: rootProject.file('cc-settings-2.gradle')`\n    - 将之前在文件中添加的`project.ext.registerInfoList.add`改为：`ccregister.registerInfo.add`放到`cc-settings-2.gradle`文件中\n    \n##### 2.2 之前依赖的是本地cc-settings.gradle文件（从github上下载的文件放在工程根目录）\n之前是通过`apply from: rootProject.file('cc-settings.gradle')`方式接入，按如下方式修改：\n- 未新增/修改任何配置： \n    - 重新下载`cc-settings-2.gradle`文件并替换原来的`cc-settings.gradle`文件（或者复制文件中的内容覆盖原来的内容）\n- 有类似于cc-settings-demo.gradle的扩展配置文件： \n    - 重新下载`cc-settings-2.gradle`文件并替换原来的`cc-settings.gradle`文件（或者复制文件中的内容覆盖原来的内容）\n    - 将文件中的`project.ext.registerInfoList.add`改为：`ccregister.registerInfo.add`\n    \n### 3. 调试组件（组件独立以application方式编译运行）\n2.0以前，组件切换app/lib运行方式的步骤为：\n- 在local.properties中修改配置： module_name=true\n- sync 或 clean\n工程比较大的情况下，sync/clean耗时比较长，影响开发效率\n借鉴[DDComponentForAndroid](https://github.com/luojilab/DDComponentForAndroid)的思路：\n    让所有组件可直接在Android Studio中点击绿色Run按钮独立运行，无需sync和clean\n\n在CC 2.0.0及以上版本中：\n- 不在兼容在module/build.gradle中添加`ext.runAsApp=true`来实现组件独立运行\n    - 但仍然可以通过`if (project.ext.runAsApp) { ... }`来判断当前module当前是否以app方式编译运行\n- 所有组件可直接在Android Studio中点击绿色Run按钮直接运行\n    - 需要注意的是，编译主app时，需要在local.properties添加配置：`module_name=true` 将单独运行的组件从主app打包依赖项中排除\n- 主app module一直以application方式编译，可以用如下方式来标记：\n    - 在module/build.gradle中添加`ext.mainApp=true`\n- 依赖CC的公共库module（如demo_base/demo_interceptors）一直以library方式编译，可选如下方式中的一种来实现：\n    - 直接将CC添加到dependencies列表`api 'com.billy.android:cc:x.x.x'`，而不是apply cc-settings-2.gradle文件\n    - 或者在apply cc-settings-2.gradle之前添加`ext.alwaysLib=true`\n- 默认情况下通过assemble命令打包是打apk包，若要打aar包，可用如下方式来实现：\n    - 在local.properties中添加`assemble_aar_for_cc_component=true`\n    \n### 4. 启用App内部多进程组件调用功能（如果有需求的话）\n\n注：默认情况下未开启App内部多进程的支持\n##### 4.1 启用多进程支持\n可下载`cc-settings-2.gradle`文件到本地根目录，并在文件最后添加：\n```groovy\nccregister.multiProcessEnabled = true\n```\n并在组件类（`IComponent`实现类）上添加一个注解，标明其所在进程（在主进程运行组件无需添加注解）\n\n__注意：这样做并不是创建新的进程，而是指定此组件在哪个进程运行（如果AndroidManifest.xml中没有对应的进程，此组件无效）__\n```java\npublic class DemoComponent implements IComponent{} //DemoComponent组件在主进程运行\n@SubProcess(\":yourProcessName\") //指定DemoComponentA组件所在的进程名称为 'packageName:yourProcessName'\npublic class DemoComponentA implements IComponent{}\n@SubProcess(\"a.b.c\") //指定DemoComponentB组件所在的进程名称为 'a.b.c'\npublic class DemoComponentB implements IComponent{}\n@AllProcess         //指定DemoComponentC组件在主进程和所有子进程内都存在，每个进程调用进程内部的DemoComponentC组件\npublic class DemoComponentC implements IComponent{}\n```\n\n##### 4.2 排除App中没有组件的进程名称\n为了支持多进程通信，CCRegister插件会在编译时扫描合并后的`AndroidManifest.xml`文件中所有四大组件\n收集所有子进程名称，为每个子进程生成一个`RemoteProvider`的子类并注册到`AndroidManifest.xml`文件中\n\n    这样做是因为：\n    如果放在Transform.transform方法中修改，在扫描完class代码之后再修改AndroidManifest.xml，无效\n    欢迎提PR优化\n    \n这将导致一些不含有子进程组件的进程也会生成一个没有任何作用的`RemoteProvider`的子类，这会额外带来一点点内存消耗。\n虽然这种内存消耗是可以基本忽略的，但是还是可以通过如下方式添加配置来避免：\n```groovy\nccregister.excludeProcessNames = [':processNameA', ':processNameB']\n```\n##### 4.3 动态组件不支持`@SubProcess`及`@AllProcess`注解\n动态组件在其被注册的进程中运行，如：在主进程中调用`CC.registerComponent(dynamicComponent);`,dynamicComponent将在主进程中运行\n    \n### 5 关于性能\n5.1 关于CC调用日志\n\n开启verbose日志(`CC.enableVerboseLog(true);`)后\n由于会频繁调用`cc.toString()`、`ccResult.toString()`、`remoteCC.toString()`、`remoteCCResult.toString()`\n会带来一定的性能损耗\n故在打正式上线包时，一定要将其关闭`CC.enableVerboseLog(false);`（默认是关闭状态）\n    \n5.2 关于跨App调用\n\n如果要调用的app不是存活状态，或者刚刚重新安装该app或杀掉重启app（这种情况常见于单组件调试时修改代码重新打包运行）\n跨进程调用之前，会先唤醒该app，并通过`RemoteProvider`获取调用该进程组件的句柄：`RemoteCCService`\n由于（app唤醒 -> ContentProvider初始化完成 -> 获取句柄）这个过程需要一定的时间：根据app初始化耗时不同而有差异\n所以：跨app调用时，初次调用会消耗大约100ms左右的时间，但这只在开发期间有影响，不会影响正式产品\n    \n    "
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README-en-US.md",
          "type": "blob",
          "size": 13.5947265625,
          "content": "## CC : Component Caller (Modularization Architecture for Android)\n\n[中文文档](README.md)\n\n[![Join the chat at https://gitter.im/billy_home/CC](https://badges.gitter.im/billy_home/CC.svg)](https://gitter.im/billy_home/CC?utm_source=share-link&utm_medium=link&utm_campaign=share-link)\n\nName|CC|cc-register\n---|---|---\nVersion| [![Download](https://api.bintray.com/packages/hellobilly/android/cc/images/download.svg)](https://bintray.com/hellobilly/android/cc/_latestVersion)| [![Download](https://api.bintray.com/packages/hellobilly/android/cc-register/images/download.svg)](https://bintray.com/hellobilly/android/cc-register/_latestVersion)\n\n## demo download\n\n[Main App(contains demo and demo_component_a)](https://github.com/luckybilly/CC/raw/master/demo-debug.apk)\n\n[demo_component_b (Demo_B)](https://github.com/luckybilly/CC/raw/master/demo_component_b-debug.apk)\n\ndemo shows cc works on component in or not in main app.\nit looks like below via running both of above app on your device and launch demo app.\n\n\n        Notice: calling across apps is only compat for develop time\n        you need to turnon the permission 'auto start' for Demo_B to make it worked if the process of Demo_B is not alive. \n\n![image](https://raw.githubusercontent.com/luckybilly/CC/master/image/CC.gif)\n\n## What`s different?\n\n- Easy to use, only 4 steps:\n        \n    - Add [AutoRegister](https://github.com/luckybilly/AutoRegister) plug-in classpath in projectRoot/build.gradle \n    - Add gradle file apply in module/build.gradle\n    - Implements a component class for IComponent in the module\n        - specified a name for this component in method: getNae()\n        - call CC.sendCCResult(cc.getCallId, CCResule.success()) in method: onCall(cc).\n    - Then you can call this component at everywhere in you app:\n        - CC.obtainBuilder(\"component_name\").build().call()\n        - CC.obtainBuilder(\"component_name\").build().callAsync()\n    \n- Feature-rich\n\n\n        1. Support inter-component invocation (not just Activity router, call&callback for almost all instructions)\n        2. Support component invocation is associated with Activity and Fragment lifecycle (requires: android api level >= 14, support lib version >= 5.1.0)\n        3. Support inter-app component invocation (component development/commissioning can be run separately as an app)\n        4. Support to switch and permission Settings of the invocation between apps (Meets for the security requirements of different levels, default status: enabled and do not require permission).\n        5. Support for synchronous/asynchronous invocation\n        6. Supports synchronous/asynchronous implementation of components\n        7. The invocation method is unrestricted by implementation (for example, asynchronous implementation of another component can be invoked synchronously. Note: do not use time-consuming operation in the main thread.\n        8. Support for adding custom interceptors (executed in the order of addition)\n        9. Support for timeout Settings (in milliseconds, 0: no timeout, synchronous invocation set as 1000 ms by default)\n        10. Support manual cancellation\n        11. Automatic registration of components (IComponent) at compile time without manually maintain the component registry (implemented by using ASM to modify bytecode)\n        12. Support for dynamic registration/unregistration components (IDynamicComponent)\n        13. Support for non-basic types of objects, such as passing fragments between components\n        14. Try to solve the crash that is caused by incorrect usage:\n            14.1 component invocation, callback, and component implementation crash are all caught within the cc framework\n            14.2 The CCResult object of synchronous return or asynchronous callback must not be null to avoid null pointer\n\n- low cost to convert original code to CC\n\n    Some guys worry about that it's too expensive to convert the code in the old project to a high degree of code coupling\n    CC can only take 2 steps to solve this problem:\n    1. Create a component class (IComponent implementation class) that provides functionality that was previously implemented by class dependencies\n    2. Then change the direct class call to CC call mode\n    \n- monitor the execution process log\n    Developer can monitor execution process logs with Logcat\n    CC disabled this function by default, enable it with code: `CC.enableVerboseLog(true);`        \n        \n## The directory structure\n\n        //core\n        - cc                            core library of CC framework\n        - cc-settings.gradle            common gradle file for user\n        \n        //demos\n        - demo                          demo main app module\n        - demo_component_a              demo ComponentA \n        - demo_component_b              demo ComponentB\n        - cc-settings-demo.gradle       actionProcessor自动注册的配置脚本demo\n        - demo-debug.apk                demo apk(contains demo and demo_component_a)\n        - demo_component_b-debug.apk    apk for demo_component_b only\n\n## How to Use\n\n#### 1. add classpath\n\n```groovy\nbuildscript {\n    dependencies {\n        classpath 'com.billy.android:autoregister:x.x.x'\n    }\n}\n```\n#### 2. modify build.gradle for all component and main app modules：\n```groovy\napply plugin: 'com.android.library'\n//or\napply plugin: 'com.android.application'\n\n//replace to\napply from: cc-settings-2.gradle\n```\n\nsee [demo_component_a/build.gradle](https://github.com/luckybilly/CC/blob/master/demo_component_a/build.gradle)\n\nmodule is setting as library by default. there are 2 ways to set as application for single launch apk:\n\n2.1 modify local.properties\n```properties\ndemo_component_b=true # run as application for module: demo_component_b\n```\n2.2 modify module/build.gradle: add `ext.runAsApp = true` before `apply from: '...cc-settings.gradle'`,ext.runAsApp priority is higher than local.properties.\n```groovy\next.runAsApp = true\napply from: cc-settings-2.gradle\n```\n#### 3. Define a component ([IComponent](https://github.com/luckybilly/CC/blob/master/cc/src/main/java/com/billy/cc/core/component/IComponent.java))\n```java\npublic class ComponentA implements IComponent {\n    \n    @Override\n    public String getName() {\n        // specify the name for this component\n        return \"demo.ComponentA\";\n    }\n\n    @Override\n    public boolean onCall(CC cc) {\n        Context context = cc.getContext();\n        Intent intent = new Intent(context, ActivityComponentA.class);\n        if (!(context instanceof Activity)) {\n            // context maybe an application object if caller dose not setContext \n            // or call across apps\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        }\n        context.startActivity(intent);\n        //send result to caller\n        CC.sendCCResult(cc.getCallId(), CCResult.success());\n        // onCall return false if result is sent synchronization before this method returned\n        return false;\n    }\n}\n```\n#### 4. Call component by CC\n```java\n// Synchronous call, get CCResult by method return\nCCResult result = CC.obtainBuilder(\"demo.ComponentA\").build().call();\n// Asynchronous call, do not need result callback\nString callId = CC.obtainBuilder(\"demo.ComponentA\").build().callAsync();\n// Asynchronous call, result callback in thread pool\nString callId = CC.obtainBuilder(\"demo.ComponentA\").build().callAsync(new IComponentCallback(){...});\n//Asynchronous call, result callback on main thread\nString callId = CC.obtainBuilder(\"demo.ComponentA\").build().callAsyncCallbackOnMainThread(new IComponentCallback(){...});\n```\n\n#### More: Add dependencies in main app module for all component modules like below:\n\n```groovy\ndependencies {\n    addComponent 'demo_component_a' //default add dependency: project(':demo_component_a')\n    addComponent 'demo_component_kt', project(':demo_component_kt')\n    addComponent 'demo_component_b', 'com.billy.demo:demo_b:1.1.0'\n}\n\n\n## Advance usage\n\n```java\n// enable/disable debug log\nCC.enableDebug(trueOrFalse);    \n// enable/disable cc process detail log\nCC.enableVerboseLog(trueOrFalse); \n// enable/disable caller across apps\nCC.enableRemoteCC(trueOrFalse)  \n// cancel a cc by callId\nCC.cancel(callId)\n// set context for cc\nCC.obtainBuilder(\"demo.ComponentA\")...setContext(context)...build().callAsync()\n// cc will cancel automaticly on activity destroyed\nCC.obtainBuilder(\"demo.ComponentA\")...cancelOnDestroyWith(activity)...build().callAsync()\n// cc will cancel automaticly on fragment destroyed\nCC.obtainBuilder(\"demo.ComponentA\")...cancelOnDestroyWith(fragment)...build().callAsync()\n// set cc actionName\nCC.obtainBuilder(\"demo.ComponentA\")...setActionName(actionName)...build().callAsync()\n// set cc timeout in milliseconds\nCC.obtainBuilder(\"demo.ComponentA\")...setTimeout(1000)...build().callAsync()\n// add extenal params\nCC.obtainBuilder(\"demo.ComponentA\")...addParam(\"name\", \"billy\").addParam(\"id\", 12345)...build().callAsync()\n\n\n// build a success CCResult\nCCResult.success(key1, value1).addData(key2, value2)\n// build a failed CCResult\nCCResult.error(message).addData(key, value)\n// send CCResult to caller (you should make sure this method called for each onCall(cc) invoked)\nCC.sendCCResult(cc.getCallId(), ccResult)\n// get cc result if success or not\nccResult.isSuccess()\n// success code(0:success, <0: failed, 1:component reached but result is failed)\nccResult.getCode()\n// get error message\nccResult.getErrorMessage()  \n// get external data\nMap<String, Object> data = ccResult.getDataMap();\nif (data != null) {\n    Object value = data.get(key)   \n}\n```\nCCResult code list:\n\n| code        | error status    |\n| --------   | :----- |\n| 0 | success |\n| 1 | business failed in component |\n| -1 | default error. not used yet |\n| -2 | component name is empty |\n| -3 | CC.sendCCResult(callId, null) or interceptor returns null |\n| -4 | An exception was thrown during cc |\n| -5 | no component object found for the specified component_name |\n| -6 | context is null and get application failed by reflection |\n| -7 | connect failed during cc across apps |\n| -8 | cc is canceled |\n| -9 | cc is timeout |\n| -10 | component.onCall(cc) return false, bus no CCResult found |\n\n- Custom interceptors\n\n    1. Create a class that implements the ICCInterceptor interface\n    2. Call the chain.proceed() method to keep the call chain down and not call to block the CC\n    2. You can modify the parameters of the CC object before calling chain.proceed()\n    3. After calling the chain.proceed() method, you can modify CCResult\n    \n    see demo: [MissYouInterceptor.java](https://github.com/luckybilly/CC/blob/master/demo/src/main/java/com/billy/cc/demo/MissYouInterceptor.java)\n    \n- register/unregister dynamic component\n\nDefinition: Unlike the static component (IComponent), which is automatically registered to ComponentManager at compile time, \ndynamic components do not automatically register and work through manual registration/unregistration\n\n        1. Dynamic components need to implement interfaces: IDynamicComponent\n        2. It is necessary to call CC.registerComponent(component) manually, similar to the BroadcastReceiver dynamic registration\n        3. It is necessary to call CC.unregisterComponent(component) manually, similar to the BroadcastReceiver dynamic unregistration\n        4. Other usage are the same as static components\n\n- You can have multiple modules include in a module\n\n\n        In a module, you can have multiple implementation classes for the IComponent interface (or IDynamicComponent interface)\n        IComponents are automatically registered to the component management class ComponentManager at compile time\n        IDynamicComponents are not\n\n- A component can process multiple actions\n\n        In the onCall(CC cc) method, gets actions to handle separately via cc.getActionName()\n\n    see：[ComponentA](https://github.com/luckybilly/CC/blob/master/demo_component_a/src/main/java/com/billy/cc/demo/component/a/ComponentA.java)\n- Auto register Custom ActionProcessor into component\n\n    see[ComponentB](https://github.com/luckybilly/CC/blob/master/demo_component_b/src/main/java/com/billy/cc/demo/component/b/ComponentB.java)\n    and[cc-settings-demo.gradle](https://github.com/luckybilly/CC/blob/master/cc-settings-demo.gradle)\n\n\n##### watch the sourcecode of demo, demo_component_a and demo_component_b for more details\n\n## More usage\n\nYou can easily do AOP work with CC, such as:\n\n1. Activity open requires user login: \n\n- check the user login status before startActivity\n- already login: \n    - startActivity immediately and CC.sendCCResult(callId, CCResult.success());\n- not login: \n    - start login activity and wait for result\n    - login success: startActivity and CC.sendCCResult(callId, CCResult.success());\n    - login failed: CC.sendCCResult(callId, CCResult.error(\"login failed\"));\n\ndemo: see[LifecycleComponent.java](https://github.com/luckybilly/CC/blob/master/demo/src/main/java/com/billy/cc/demo/LifecycleComponent.java)\n\n2. Pre-load activity data before context.startActivity with [PreLoader](https://github.com/luckybilly/PreLoader)\n\n- define a component for open the activity\n```java\npublic class ComponentA implements IComponent {\n\n    @Override\n    public String getName() {\n        return \"demo.ComponentA\";\n    }\n\n    @Override\n    public boolean onCall(CC cc) {\n        int preLoaderId = PreLoader.preLoad(new Loader());\n        Intent intent = new Intent(this, PreLoadBeforeLaunchActivity.class);\n        intent.putExtra(\"preLoaderId\", preLoaderId);\n        startActivity(intent);\n        CC.sendCCResult(cc.getCallId(), CCResult.success());\n        return false;\n    }\n}\n```\n\n- call that component by CC to open activity\n```java\n// pre-load is needless here, the logistic of component are all inside that component itself\nCC.obtainBuilder(\"demo.ComponentA\").build().call();\n```\n\n\n## Proguard\n\nnone\n\n## Contact me\n\nqiyilike@163.com\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.2626953125,
          "content": "## CC : ComponentCaller\n\n\nCC是一套Android的组件化框架，由CC核心API类库和cc-register插件组成\n\n模块|CC|cc-register\n:---:|:---:|:---:\n当前最新版本| [![Download](https://api.bintray.com/packages/hellobilly/android/cc/images/download.svg)](https://bintray.com/hellobilly/android/cc/_latestVersion)| [![Download](https://api.bintray.com/packages/hellobilly/android/cc-register/images/download.svg)](https://bintray.com/hellobilly/android/cc-register/_latestVersion)\n\n[华丽丽的文档][docs]\n\n<div align=center><img style=\"width:auto;\" src=\"https://github.com/luckybilly/CC/raw/master/image/icon.png\"/></div>\n\n### CC的特色\n- 一静一动，开发时运行2个app：\n  - 静：主App (通过跨App的方式单组件App内的组件)\n  - 动：单组件App (通过跨App的方式调用主App内的组件)\n- 支持[渐进式组件化改造][7]\n  - <font color=red>解耦只是过程，而不是前提</font>\n\n### 一句话介绍CC：\nCC是一套基于组件总线的、支持渐进式改造的、支持跨进程调用的、完整的Android组件化框架\n\n- 基于组件总线： \n    - 不同于市面上种类繁多的路由框架，CC采用了基于组件总线的架构，不依赖于路由([路由 VS 总线][1])\n- 支持渐进式改造： \n    - 接入CC后可立即用以组件的方式开发新业务，可单独运行调试开发，通过跨app的方式调用项目中原有功能\n    - 不需要修改项目中现有的代码，只需要新增一个IComponent接口的实现类（组件类）即可支持新组件的调用\n    - 模块解耦不再是前提，将陡峭的组件化改造实施曲线拉平\n- 支持跨进程调用： \n    - 支持应用内跨进程调用组件，支持跨app调用组件\n    - 调用方式与同一个进程内的调用方式完全一致\n    - 无需bindService、无需自定义AIDL，无需接口下沉\n- 完整：\n    - CC框架下组件提供的服务可以是几乎所有功能，包括但不限于页面跳转、提供服务、获取数据、数据存储等\n    - CC提供了配套插件cc-register，完成了自定义的组件类、全局拦截器类及json转换工具类的自动注册，\n    - cc-register同时还提供了代码隔离、debug代码分离、组件单独调试等各种组件化开发过程中需要的功能\n\nCC的设计灵感来源于服务端的服务化架构，将组件之间的关系拍平，不互相依赖但可以互相调用，不需要再管理复杂的依赖树。\n\n了解业界开源的一些组件化方案：[多个维度对比一些有代表性的开源android组件化开发方案](https://github.com/luckybilly/AndroidComponentizeLibs) \n\n## demo演示\n\n[demo下载(主工程,包含ComponentB之外的所有组件)](https://github.com/luckybilly/CC/raw/master/demo-debug.apk)\n\n[demo_component_b组件单独运行的App(Demo_B)下载](https://github.com/luckybilly/CC/raw/master/demo_component_b-debug.apk)\n\n以上**2个app**用来演示组件打包在主app内和**单独以app运行**时的组件调用，**都安装在手机上**之后的运行效果如下图所示\n\n<div align=center><img style=\"width:auto;\" src=\"https://github.com/luckybilly/CC/raw/master/image/CC.gif\"/></div>\n\n\n## 目录结构\n\n        - cc                            组件化框架基础库（主要）\n        - cc-register                   CC框架配套的gradle插件（主要）\n        - cc-settings-2.gradle          组件化开发构建脚本（主要）\n        - demo                          demo主程序（调用其它组件，并演示了动态组件的使用）\n        - demo_base                     demo公共库(base类、util类、公共Bean等)\n        - demo_component_a              demo组件A\n        - demo_component_b              demo组件B（上方提供下载的apk在打包时local.properties中添加了demo_component_b=true）\n        - demo_component_jsbridge       demo组件(面向组件封装的jsBridge，并演示了如何进行跨进程组件调用)\n        - demo_component_kt             demo组件(kotlin)\n        - demo_interceptors             demo全局拦截器(如果有多个app并且拦截器不同，可以创建多个module给不同app使用)\n        - cc-settings-demo.gradle       演示如何自定义配置文件，如：添加actionProcessor自动注册的配置\n        - demo-debug.apk                demo安装包(包含demo/demo_component_a/demo_component_kt)\n        - demo_component_b-debug.apk    demo组件B单独运行安装包\n\n\n## 创建组件\n\n创建一个组件很简单：只要创建一个`IComponent`接口的实现类，在onCall方法中实现组件暴露的服务即可\n\n```java\npublic class ComponentA implements IComponent {\n  @Override\n  public String getName() {\n      //指定组件的名称\n      return \"ComponentA\";\n  }\n\n  @Override\n  public boolean onCall(CC cc) {\n    //在此处将组件内部的服务暴露给外部调用\n    //组件内部的逻辑与外部完全解耦\n    String actionName = cc.getActionName();\n    switch (actionName) {\n      case \"showActivity\": //响应actionName为\"showActivity\"的组件调用\n        //跳转到页面：ActivityA\n        CCUtil.navigateTo(cc, ActivityA.class);\n        //返回处理结果给调用方\n        CC.sendCCResult(cc.getCallId(), CCResult.success());\n        break;\n      default:\n        //其它actionName当前组件暂时不能响应，可以通过如下方式返回状态码为-12的CCResult给调用方\n        CC.sendCCResult(cc.getCallId(), CCResult.errorUnsupportedActionName());\n        break;\n    }\n    return false;\n  }\n}\n\n```\n\n## 调用组件\n\nCC 使用简明的流式语法API，因此它允许你在一行代码搞定组件调用：\n\n\"CC\"也是本框架主入口API类的类名，是由ComponentCaller缩写而来，其核心职能是:**组件的调用者**。\n\n```java\nCC.obtainBuilder(\"ComponentA\")\n  .setActionName(\"showActivity\")\n  .build()\n  .call();\n```\n也可以这样\n```java\nCC.obtainBuilder(\"ComponentA\")\n  .setActionName(\"showActivity\")\n  .build()\n  .callAsync();\n```\n或者这样\n```java\nCC.obtainBuilder(\"ComponentA\")\n  .setActionName(\"showActivity\")\n  .build()\n  .callAsyncCallbackOnMainThread(new IComponentCallback() {\n        @Override\n        public void onResult(CC cc, CCResult result) {\n          String toast = result.isSuccess() ? \"success\" : \"failed\";\n          Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();\n        }\n    });\n```\n\n## 开始使用\n\n请[看文档][docs]、[看文档][docs]、[看文档][docs]\n\n\n## 混淆配置\n\n不需要额外的混淆配置\n\n## 自动注册插件\nCC专用版：[cc-register](cc-register)，fork自[AutoRegister](https://github.com/luckybilly/AutoRegister)，在自动注册的基础上添加了一些CC专用的业务\n\n通用版：\n\n源码:[AutoRegister](https://github.com/luckybilly/AutoRegister)\n原理:[android扫描接口实现类并通过修改字节码自动生成注册表](http://blog.csdn.net/cdecde111/article/details/78074692)\n\n\n## 版本更新日志\n\n请点击：[更新日志][changelog]\n\n## 遇到问题怎么办？\n\n- 先打开CC的日志开关，看完整的调用过程日志，这往往能帮助我们找到问题\n```java\nCC.enableDebug(true);  //普通调试日志，会提示一些错误信息\nCC.enableVerboseLog(true);  //组件调用的详细过程日志，用于跟踪整个调用过程\n```\n- 看[文档][docs]\n- [看issue](https://github.com/luckybilly/CC/issues)了解开源社区上其它小伙伴提出的问题及解答过程，很可能就有你现在遇到的问题\n- [提issue](https://github.com/luckybilly/CC/issues/new),如果以上还没有解决你的问题，请[提一个issue](https://github.com/luckybilly/CC/issues/new)，这很可能是个新的问题，提issue能帮助到后面遇到相同问题的朋友\n- 加下方的QQ群提问\n\n## QQ群\n\nQQ群号：686844583  \n\n<a target=\"_blank\" href=\"http://shang.qq.com/wpa/qunwpa?idkey=5fdd1171114b5a1eb80ea0be00b392c2e3e8ab6f278f182a07e959e80d4c9409\"><img border=\"0\" src=\"http://pub.idqqimg.com/wpa/images/group.png\" alt=\"CC交流群\" title=\"CC交流群\"></a>\n\n或者扫描下方二维码加群聊\n\n![image](image/CC_QQ.png)\n\n[1]: https://luckybilly.github.io/CC-website/#/article-router_vs_bus\n[7]: https://luckybilly.github.io/CC-website/#/article-componentize-gradually\n[issue]: https://github.com/luckybilly/CC/issues/new\n[docs]: https://luckybilly.github.io/CC-website/\n[changelog]: https://luckybilly.github.io/CC-website/#/changelog\n"
        },
        {
          "name": "android_internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "bintray.gradle",
          "type": "blob",
          "size": 1.640625,
          "content": "\nProperties properties = new Properties()\ntry {\n    properties.load(project.rootProject.file('local.properties').newDataInputStream())\n} catch(Exception ignored) {\n    return\n}\n\nif (!properties.getProperty(\"is_repo_owner\")) {\n    return\n}\n\nif (project.hasProperty(\"android\")) { // Android libraries\n    task sourcesJar(type: Jar) {\n        classifier = 'sources'\n        from android.sourceSets.main.java.srcDirs\n    }\n\n    task javadoc(type: Javadoc) {\n        source = android.sourceSets.main.java.srcDirs\n        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))\n    }\n} else { // Java libraries\n    task sourcesJar(type: Jar, dependsOn: classes) {\n        classifier = 'sources'\n        from sourceSets.main.allSource\n    }\n}\n\ntask javadocJar(type: Jar, dependsOn: javadoc) {\n    classifier = 'javadoc'\n    from javadoc.destinationDir\n}\n\nartifacts {\n    archives javadocJar\n    archives sourcesJar\n}\n\nproject.tasks.withType(Javadoc) {\n    options.addStringOption('Xdoclint:none', '-quiet')\n    options.addStringOption('encoding', 'UTF-8')\n}\n\n// Bintray\napply plugin: 'com.novoda.bintray-release'\npublish {\n    repoName = 'android'\n    userOrg = properties.getProperty(\"bintray.userOrg\")\n    groupId = publishedGroupId\n    artifactId = artifact\n    publishVersion = libraryVersion\n    desc = libraryDescription\n    website = siteUrl\n}\n\napply plugin: 'maven'\nuploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: uri('../repo-local')) //deploy到本地仓库\n            pom.groupId = publishedGroupId\n            pom.artifactId = artifact\n            pom.version = libraryVersion + '-SNAPSHOT'\n        }\n    }\n}\n\n"
        },
        {
          "name": "bintrayUpload.sh",
          "type": "blob",
          "size": 0.177734375,
          "content": "#!/bin/sh\n\nMODULE=${1}\necho $MODULE\n\n. local.properties\n\nNAME=$bintray_user\nKEY=$bintray_apikey\n\n./gradlew :$MODULE:bintrayUpload -PbintrayUser=$NAME -PbintrayKey=$KEY -PdryRun=false"
        },
        {
          "name": "build.gradle",
          "type": "blob",
          "size": 1.13671875,
          "content": "// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n    ext.kotlin_version = '1.2.51'\n    \n    repositories {\n        maven{ url rootProject.file(\"repo-local\") }\n        maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'}\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.0.1'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n\n        classpath 'com.novoda:bintray-release:0.9.2'\n        classpath 'com.billy.android:cc-register:1.1.2'\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        maven{ url rootProject.file(\"repo-local\") }\n        maven { url \"https://jitpack.io\" }\n        google()\n        jcenter()\n    }\n}\n\next {\n    compileVersion = 28\n    buildVersion = '28.0.3'\n    minVersion = 8\n\n    // support v7(28.0.0) minSdkVersion is 14\n    demoMinSdkVersion = 14\n    supportVersion = '28.0.0'\n}\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n"
        },
        {
          "name": "cc-register",
          "type": "tree",
          "content": null
        },
        {
          "name": "cc-settings-2.gradle",
          "type": "blob",
          "size": 2.03125,
          "content": "\n//注： 从CC 1.x升级到CC 2.x的用户，用此文件替换原来的cc-settings.gradle的同时，需要在根目录build.gradle中将插件地址按照如下方式更换一下：\n// classpath 'com.billy.android:autoregister:x.x.x' -> classpath 'com.billy.android:cc-register:x.x.x'\n//cc-register extension:\n// 功能介绍：\n//  完成组件、拦截器及跨进程json解释器等CC库自身需要的自动注册功能\n//  支持新增自定义的其它自动注册功能，参考AutoRegister，用法参考cc-settings-demo.gradle\nproject.apply plugin: 'cc-register'\nproject.dependencies.add('api', \"com.billy.android:cc:2.1.5\") //用最新版\n\n//此文件是作为组件化配置的公共gradle脚本文件，在每个组件中都apply此文件，下载到工程根目录后，可以在下方添加一些自己工程中通用的配置\n// 可参考cc-settings-demo.gradle\n// 例如：\n//      1. 添加全局拦截器、下沉的公共类库等一些公共基础库的依赖；\n//      2. 添加自定义的通过cc-register实现的自动注册配置\n//      3. 开启app内部多进程支持\n//      4. 其它公共配置信息\n\n//开启app内部多进程组件调用时启用下面这行代码\n//文档地址：https://luckybilly.github.io/CC-website/#/manual-multi-process\n//ccregister.multiProcessEnabled = true\n\n//开启app内部多进程组件调用时，可以启用下方的配置排除一些进程\n//ccregister.excludeProcessNames = [':pushservice', ':processNameB']\n\n//按照如下格式添加自定义注册项，可添加多个（也可每次add一个，add多次）\n// 文档地址： https://luckybilly.github.io/CC-website/#/manual-IActionProcessor\n//ccregister.registerInfo.add([\n//        //在自动注册组件的基础上增加：自动注册组件B的processor\n//        'scanInterface'             : 'com.billy.cc.demo.component.b.processor.IActionProcessor'\n//        , 'codeInsertToClassName'   : 'com.billy.cc.demo.component.b.ComponentB'\n//        , 'codeInsertToMethodName'  : 'initProcessors'\n//        , 'registerMethodName'      : 'add'\n//])"
        },
        {
          "name": "cc-settings-demo.gradle",
          "type": "blob",
          "size": 2.4072265625,
          "content": "//-----------------------------------------------------------\n//\n//  demo使用的自定义cc-settings文件\n//  主要是为了演示：\n//      1. 自动注册组件B的processor\n//      2. 全局拦截器的依赖\n//\n//-----------------------------------------------------------\n\nproject.apply plugin: 'cc-register'\n//project.dependencies.add('api', project(':cc')) //用最新版\nproject.dependencies.add('api', \"com.billy.android:cc:2.1.6\") //用最新版\n\ndependencies {\n    //其它apply当前gradle文件的module统一添加对demo_base的依赖\n    if (project.name != 'demo_base'){\n        implementation project(':demo_base')\n    }\n    //2018-06-03新增：这里是为了示例添加全局拦截器\n    if (project.ext.has('runAsApp') && project.ext.runAsApp) {\n        //说明：需要兼容的情况有3种(单独组件作为app运行、打包在主app内、组件在多个app上复用但全局拦截器不同)\n        //     为了兼容以上3种情况，建议将全局拦截器作为一个单独的module，在此处给不同app添加不同拦截器module\n        implementation project(':demo_interceptors')\n    }\n}\n//auto register extension:\n// 源码地址：https://github.com/luckybilly/AutoRegister\n// 功能介绍：\n//  在编译期扫描将打到apk包中的所有类\n//  将 scanInterface的实现类 或 scanSuperClasses的子类\n//  并在 codeInsertToClassName 类的 codeInsertToMethodName 方法中生成如下代码：\n//  codeInsertToClassName.registerMethodName(scanInterface)\n// 要点：\n//  1. codeInsertToMethodName 若未指定，则默认为static块\n//  2. codeInsertToMethodName 与 registerMethodName 需要同为static或非static\n// 自动生成的代码示例：\n/*\n  在com.billy.app_lib_interface.CategoryManager.class文件中\n  static\n  {\n    register(new CategoryA()); //scanInterface的实现类\n    register(new CategoryB()); //scanSuperClass的子类\n  }\n */\nccregister.registerInfo.add([\n    //在自动注册组件的基础上增加：自动注册组件B的processor\n    'scanInterface'             : 'com.billy.cc.demo.component.b.processor.IActionProcessor'\n    , 'codeInsertToClassName'   : 'com.billy.cc.demo.component.b.ComponentB'\n    , 'codeInsertToMethodName'  : 'initProcessors'\n    , 'registerMethodName'      : 'add'\n])\n//也可以按照上述格式继续添加你自己的自动注册需求，俗称：搭顺风车\n\n//开启app内部多进程组件调用\nccregister.multiProcessEnabled = true\n"
        },
        {
          "name": "cc-settings.gradle",
          "type": "blob",
          "size": 10.0166015625,
          "content": "///////////////////////////////////////////////////////////////////////////////////////////////\n//\n//                  注意： 本文件从2.0.0版本开始已废弃\n//\n//      1.1.0版及以前使用此cc-settings.gradle文件\n//      2.0.0版及以后使用新版cc-settings-2.gradle文件\n//      此文件保留是为了不影响以前通过apply github上的此文件使用CC的用户\n//      2.0.0版本以后，不推荐使用github上的文件，建议复制或下载cc-settings-2.gradle的内容到工程根目录使用\n//\n//\n///////////////////////////////////////////////////////////////////////////////////////////////\n\nimport java.util.regex.Pattern\n\n//先加载local.properties文件\nProperties localProperties = new Properties()\ntry {\n    def localFile = project.rootProject.file('local.properties')\n    if (localFile != null && localFile.exists()) {\n        localProperties.load(localFile.newDataInputStream())\n    }\n} catch (Exception ignored) {\n    println(\"local.properties not found\")\n}\n//读取build.gradle中的设置\n// 2018-04-06修改：\n//  为了更利于理解，将ext.runAsApp 改名为 ext.mainApp\n//  ext.mainApp的将仅代表是否作为主app，为true时以application方式编译，为false或未配置时以local.properties中的配置为准\n//  兼容以前的runAsApp设置，ext.runAsApp的功能保持不变，runAsApp优先级高于local.properties\ndef runAsApp = ext.has('runAsApp')\nif (runAsApp) {\n    runAsApp = ext.runAsApp\n} else if(ext.has('mainApp') && ext.mainApp) { //ext.mainApp为true时，代表以app方式运行\n    runAsApp = true\n} else {\n    //build.gradle中没有配置runAsApp，且ext.mainApp=false或未配置\n    //再从local.properties中读取配置，例如： demo_component_a=true\n    //注：如果采用local.properties读取配置，每次修改需要重新同步(Sync Project)一下\n    runAsApp = 'true' == localProperties.getProperty(project.name)\n}\n//设置到ext中，供module的build.gradle使用（例如用于设置sourceSets配置）\next.runAsApp = runAsApp\nif (runAsApp) {\n    apply plugin: 'com.android.application'\n} else {\n    apply plugin: 'com.android.library'\n}\n\n//对组件库的依赖格式： addComponent dependencyName [, realDependency]\n// 使用示例见demo/build.gradle\n//  dependencyName: 组件库的名称，推荐直接使用使用module的名称\n//  realDependency(可选): 组件库对应的实际依赖，可以是module依赖，也可以是maven依赖\n//    如果未配置realDependency，将自动依赖 project(\":$dependencyName\")\n//    realDependency可以为如下2种中的一种:\n//      module依赖 : project(':demo_component_b') //如果module名称跟dependencyName相同，可省略(推荐)\n//      maven依赖  : 'com.billy.demo:demoB:1.1.0' //如果使用了maven私服，请使用此方式\next.addComponent = { dependencyName, realDependency = null ->\n    def curModuleIsBuildingApk = false //当前task是否为给本module打apk包\n    def taskNames = project.gradle.startParameter.taskNames\n    def regex = \"((.*:)?${project.name.toUpperCase()}:)?((ASSEMBLE)|(INSTALL)|((BUILD)?TINKER)|(RESGUARD)).*\"\n    def taskBuildApkPattern = Pattern.compile(regex)\n    for (String task : taskNames) {\n        if (taskBuildApkPattern.matcher(task.toUpperCase()).matches()) {\n            curModuleIsBuildingApk = true\n            break\n        }\n    }\n    //不是在为本app module打apk包，不添加对组件的依赖\n    if (!curModuleIsBuildingApk)\n        return\n    def componentProject = rootProject.subprojects.find { it.name == dependencyName }\n    def app  //dependencyName指定的module是否为配置为以application方式编译\n    if (componentProject && componentProject.ext.has('runAsApp')) {\n        //兼容以前的ext.runAsApp=true的配置方式，runAsApp的优先级高\n        app = componentProject.ext.runAsApp\n    } else if (componentProject && componentProject.ext.has('mainApp') && componentProject.ext.mainApp) {\n        //仅ext.mainApp为true时，确定为application方式编译，若为false，则读取local.properties中的配置\n        app = true\n    } else {\n        //local.properties中配置为true代表该module以application方式编译\n        app = 'true' == localProperties.getProperty(dependencyName)\n    }\n    if (!app) {\n        def dependencyMode = (project.gradle.gradleVersion as float) >= 4.1F ? 'api' : 'compile'\n        if (realDependency) {\n            //通过参数传递的依赖方式，如：\n            // project(':moduleName')\n            // 或\n            // 'com.billy.demo:demoA:1.1.0'\n            project.dependencies.add(dependencyMode, realDependency)\n            println \"CC >>>> add $realDependency to ${project.name}'s dependencies\"\n        } else if (componentProject) {\n            //第二个参数未传，默认为按照module来进行依赖\n            project.dependencies.add(dependencyMode, project(\":$dependencyName\"))\n            println \"CC >>>> add project(\\\":$dependencyName\\\") to ${project.name}'s dependencies\"\n        } else {\n            throw new RuntimeException(\n                    \"CC >>>> add dependency by [ addComponent '$dependencyName' ] occurred an error:\" +\n                    \"\\n'$dependencyName' is not a module in current project\" +\n                    \" and the 2nd param is not specified for realDependency\" +\n                    \"\\nPlease make sure the module name is '$dependencyName'\" +\n                    \"\\nelse\" +\n                    \"\\nyou can specify the real dependency via add the 2nd param, for example: \" +\n                    \"addComponent '$dependencyName', 'com.billy.demo:demoB:1.1.0'\")\n        }\n    }\n}\nrepositories {\n    maven { url rootProject.file(\"repo-local\") }\n    jcenter()\n}\n\n//默认配置了AndroidManifest.xml在library模式和application模式下的文件路径\nandroid {\n    sourceSets {\n        main {\n            //默认的作为application运行时Manifest文件路径\n            def debugManifest = 'src/main/debug/AndroidManifest.xml'\n            if (runAsApp && project.file(debugManifest).exists()) {\n                manifest.srcFile debugManifest\n            } else {\n                manifest.srcFile 'src/main/AndroidManifest.xml'\n                //集成开发模式下自动排除debug文件夹中的所有Java文件\n                // 可以将debug代码放在这个包内，例如：Application子类\n                java {\n                    exclude 'debug/**'\n                }\n            }\n            // 注：2018-03-12推荐：将组件单独以app运行时的测试代码及资源放到src/main/debug/目录下\n            if (runAsApp) {\n                //debug模式下，如果存在src/main/debug/assets，则自动将其添加到assets源码目录\n                if (project.file('src/main/debug/assets').exists()) {\n                    assets.srcDirs = ['src/main/assets', 'src/main/debug/assets']\n                }\n                //debug模式下，如果存在src/main/debug/java，则自动将其添加到java源码目录\n                if (project.file('src/main/debug/java').exists()) {\n                    java.srcDirs = ['src/main/java', 'src/main/debug/java']\n                }\n                //debug模式下，如果存在src/main/debug/res，则自动将其添加到资源目录\n                if (project.file('src/main/debug/res').exists()) {\n                    res.srcDirs = ['src/main/res', 'src/main/debug/res']\n                }\n            }\n        }\n    }\n}\ndef dependencyMode = GradleVersion.version(project.gradle.gradleVersion) >= GradleVersion.version('4.1') ? 'api' : 'compile'\n//project.dependencies.add(dependencyMode, project(\":cc\"))\nproject.dependencies.add(dependencyMode, \"com.billy.android:cc:1.1.0\")\n\n\n\n//auto register extension:\n// 源码地址：https://github.com/luckybilly/AutoRegister\n// 功能介绍：\n//  在编译期扫描将打到apk包中的所有类\n//  将 scanInterface的实现类 或 scanSuperClasses的子类\n//  并在 codeInsertToClassName 类的 codeInsertToMethodName 方法中生成如下代码：\n//  codeInsertToClassName.registerMethodName(scanInterface)\n// 要点：\n//  1. codeInsertToMethodName 若未指定，则默认为static块\n//  2. codeInsertToMethodName 与 registerMethodName 需要同为static或非static\n// 自动生成的代码示例：\n/*\n  在com.billy.app_lib_interface.CategoryManager.class文件中\n  static\n  {\n    register(new CategoryA()); //scanInterface的实现类\n    register(new CategoryB()); //scanSuperClass的子类\n  }\n */\nproject.apply plugin: 'auto-register'\nproject.ext.registerInfoList = [\n    [ //自动注册组件\n        'scanInterface'             : 'com.billy.cc.core.component.IComponent'\n        , 'codeInsertToClassName'   : 'com.billy.cc.core.component.ComponentManager'\n        , 'registerMethodName'      : 'registerComponent'\n        , 'exclude'                 : [//排除的类，支持正则表达式（包分隔符需要用/表示，不能用.）\n            'com.billy.cc.core.component.'.replaceAll(\"\\\\.\", \"/\") + \".*\"\n        ]\n    ],[//自动注册全局拦截器\n        'scanInterface'             : 'com.billy.cc.core.component.IGlobalCCInterceptor'\n        , 'codeInsertToClassName'   : 'com.billy.cc.core.component.GlobalCCInterceptorManager'\n        , 'registerMethodName'      : 'registerGlobalInterceptor'\n        , 'exclude'                 : [//排除的类，支持正则表达式（包分隔符需要用/表示，不能用.）\n            'com.billy.cc.core.component.'.replaceAll(\"\\\\.\", \"/\") + \".*\"\n        ]\n    ],[//自动注册跨进程通信时自定义类型的json转换器，可以用Gson、FastJson等工具来实现\n       // 参考： demo_base/src/main/java/com.billy.cc.demo.base.GsonParamConverter\n        'scanInterface'             : 'com.billy.cc.core.component.IParamJsonConverter'\n        , 'codeInsertToClassName'   : 'com.billy.cc.core.component.RemoteParamUtil'\n        , 'registerMethodName'      : 'initRemoteCCParamJsonConverter'\n        , 'exclude'                 : [//排除的类，支持正则表达式（包分隔符需要用/表示，不能用.）\n            'com.billy.cc.core.component.'.replaceAll(\"\\\\.\", \"/\") + \".*\"\n        ]\n    ]\n]\nautoregister {\n    registerInfo = registerInfoList\n}"
        },
        {
          "name": "cc.keystore",
          "type": "blob",
          "size": 2.013671875,
          "content": null
        },
        {
          "name": "cc",
          "type": "tree",
          "content": null
        },
        {
          "name": "demo-debug.apk",
          "type": "blob",
          "size": 2289.7900390625,
          "content": null
        },
        {
          "name": "demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "demo_base",
          "type": "tree",
          "content": null
        },
        {
          "name": "demo_component_a",
          "type": "tree",
          "content": null
        },
        {
          "name": "demo_component_b-debug.apk",
          "type": "blob",
          "size": 1506.814453125,
          "content": null
        },
        {
          "name": "demo_component_b",
          "type": "tree",
          "content": null
        },
        {
          "name": "demo_component_jsbridge",
          "type": "tree",
          "content": null
        },
        {
          "name": "demo_component_kt",
          "type": "tree",
          "content": null
        },
        {
          "name": "demo_interceptors",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradle.properties",
          "type": "blob",
          "size": 0.7138671875,
          "content": "# Project-wide Gradle settings.\n\n# IDE (e.g. Android Studio) users:\n# Gradle settings configured through the IDE *will override*\n# any settings specified in this file.\n\n# For more details on how to configure your build environment visit\n# http://www.gradle.org/docs/current/userguide/build_environment.html\n\n# Specifies the JVM arguments used for the daemon process.\n# The setting is particularly useful for tweaking memory settings.\norg.gradle.jvmargs=-Xmx1536m\n\n# When configured, Gradle will run in incubating parallel mode.\n# This option should only be used with decoupled projects. More details, visit\n# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects\n# org.gradle.parallel=true\n\n"
        },
        {
          "name": "gradle",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradlew",
          "type": "blob",
          "size": 4.8544921875,
          "content": "#!/usr/bin/env bash\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\"\"\n\nAPP_NAME=\"Gradle\"\nAPP_BASE_NAME=`basename \"$0\"`\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD=\"maximum\"\n\nwarn ( ) {\n    echo \"$*\"\n}\n\ndie ( ) {\n    echo\n    echo \"$*\"\n    echo\n    exit 1\n}\n\n# OS specific support (must be 'true' or 'false').\ncygwin=false\nmsys=false\ndarwin=false\ncase \"`uname`\" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\nesac\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG=\"$0\"\n# Need this for relative symlinks.\nwhile [ -h \"$PRG\" ] ; do\n    ls=`ls -ld \"$PRG\"`\n    link=`expr \"$ls\" : '.*-> \\(.*\\)$'`\n    if expr \"$link\" : '/.*' > /dev/null; then\n        PRG=\"$link\"\n    else\n        PRG=`dirname \"$PRG\"`\"/$link\"\n    fi\ndone\nSAVED=\"`pwd`\"\ncd \"`dirname \\\"$PRG\\\"`/\" >/dev/null\nAPP_HOME=\"`pwd -P`\"\ncd \"$SAVED\" >/dev/null\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n \"$JAVA_HOME\" ] ; then\n    if [ -x \"$JAVA_HOME/jre/sh/java\" ] ; then\n        # IBM's JDK on AIX uses strange locations for the executables\n        JAVACMD=\"$JAVA_HOME/jre/sh/java\"\n    else\n        JAVACMD=\"$JAVA_HOME/bin/java\"\n    fi\n    if [ ! -x \"$JAVACMD\" ] ; then\n        die \"ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\n    fi\nelse\n    JAVACMD=\"java\"\n    which java >/dev/null 2>&1 || die \"ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ \"$cygwin\" = \"false\" -a \"$darwin\" = \"false\" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ \"$MAX_FD\" = \"maximum\" -o \"$MAX_FD\" = \"max\" ] ; then\n            MAX_FD=\"$MAX_FD_LIMIT\"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn \"Could not set maximum file descriptor limit: $MAX_FD\"\n        fi\n    else\n        warn \"Could not query maximum file descriptor limit: $MAX_FD_LIMIT\"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS=\"$GRADLE_OPTS \\\"-Xdock:name=$APP_NAME\\\" \\\"-Xdock:icon=$APP_HOME/media/gradle.icns\\\"\"\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed \"$APP_HOME\"`\n    CLASSPATH=`cygpath --path --mixed \"$CLASSPATH\"`\n    JAVACMD=`cygpath --unix \"$JAVACMD\"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=\"\"\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS=\"$ROOTDIRS$SEP$dir\"\n        SEP=\"|\"\n    done\n    OURCYGPATTERN=\"(^($ROOTDIRS))\"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ \"$GRADLE_CYGPATTERN\" != \"\" ] ; then\n        OURCYGPATTERN=\"$OURCYGPATTERN|($GRADLE_CYGPATTERN)\"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in \"$@\" ; do\n        CHECK=`echo \"$arg\"|egrep -c \"$OURCYGPATTERN\" -`\n        CHECK2=`echo \"$arg\"|egrep -c \"^-\"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed \"$arg\"`\n        else\n            eval `echo args$i`=\"\\\"$arg\\\"\"\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- \"$args0\" ;;\n        (2) set -- \"$args0\" \"$args1\" ;;\n        (3) set -- \"$args0\" \"$args1\" \"$args2\" ;;\n        (4) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" ;;\n        (5) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" ;;\n        (6) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" ;;\n        (7) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" ;;\n        (8) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" ;;\n        (9) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" \"$args8\" ;;\n    esac\nfi\n\n# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules\nfunction splitJvmOpts() {\n    JVM_OPTS=(\"$@\")\n}\neval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS\nJVM_OPTS[${#JVM_OPTS[*]}]=\"-Dorg.gradle.appname=$APP_BASE_NAME\"\n\nexec \"$JAVACMD\" \"${JVM_OPTS[@]}\" -classpath \"$CLASSPATH\" org.gradle.wrapper.GradleWrapperMain \"$@\"\n"
        },
        {
          "name": "gradlew.bat",
          "type": "blob",
          "size": 2.259765625,
          "content": "@if \"%DEBUG%\" == \"\" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif \"%OS%\"==\"Windows_NT\" setlocal\n\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nset DEFAULT_JVM_OPTS=\n\nset DIRNAME=%~dp0\nif \"%DIRNAME%\" == \"\" set DIRNAME=.\nset APP_BASE_NAME=%~n0\nset APP_HOME=%DIRNAME%\n\n@rem Find java.exe\nif defined JAVA_HOME goto findJavaFromJavaHome\n\nset JAVA_EXE=java.exe\n%JAVA_EXE% -version >NUL 2>&1\nif \"%ERRORLEVEL%\" == \"0\" goto init\n\necho.\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:findJavaFromJavaHome\nset JAVA_HOME=%JAVA_HOME:\"=%\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\n\nif exist \"%JAVA_EXE%\" goto init\n\necho.\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:init\n@rem Get command-line arguments, handling Windowz variants\n\nif not \"%OS%\" == \"Windows_NT\" goto win9xME_args\nif \"%@eval[2+2]\" == \"4\" goto 4NT_args\n\n:win9xME_args\n@rem Slurp the command line arguments.\nset CMD_LINE_ARGS=\nset _SKIP=2\n\n:win9xME_args_slurp\nif \"x%~1\" == \"x\" goto execute\n\nset CMD_LINE_ARGS=%*\ngoto execute\n\n:4NT_args\n@rem Get arguments from the 4NT Shell from JP Software\nset CMD_LINE_ARGS=%$\n\n:execute\n@rem Setup the command line\n\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n\n@rem Execute Gradle\n\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\n\n:end\n@rem End local scope for the variables with windows NT shell\nif \"%ERRORLEVEL%\"==\"0\" goto mainEnd\n\n:fail\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\nrem the _cmd.exe /c_ return code!\nif  not \"\" == \"%GRADLE_EXIT_CONSOLE%\" exit 1\nexit /b 1\n\n:mainEnd\nif \"%OS%\"==\"Windows_NT\" endlocal\n\n:omega\n"
        },
        {
          "name": "image",
          "type": "tree",
          "content": null
        },
        {
          "name": "pools",
          "type": "tree",
          "content": null
        },
        {
          "name": "settings.gradle",
          "type": "blob",
          "size": 0.2412109375,
          "content": "include ':cc', ':demo_component_kt', ':cc-register', ':demo_component_jsbridge'\ninclude ':pools'\ninclude ':demo'\ninclude ':demo_component_a'\ninclude ':demo_component_b'\ninclude ':demo_base'\ninclude ':demo_interceptors'\ninclude ':android_internal'\n"
        }
      ]
    }
  ]
}