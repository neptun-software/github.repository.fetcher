{
  "metadata": {
    "timestamp": 1736608873847,
    "page": 45,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "reactive-streams/reactive-streams-jvm",
      "stars": 4823,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2353515625,
          "content": "target/\n.project\n.classpath\n.cache\n.target/\n*~\n.#*\n.*.swp\n.DS_Store\n.codefellow\n.ensime*\n.eprj\n.history\n.idea\n.idea_modules\n.gradle\n.settings\nbin\nbuild\nout\n*.iml\n*.ipr\n*.iws\ntest-output\ntest-results\ntest-tmp\n*.class\ngradle.properties\n*.orig\n"
        },
        {
          "name": ".java-version",
          "type": "blob",
          "size": 0.001953125,
          "content": "9\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 6.521484375,
          "content": "# Contributing to the Reactive Streams Project\n\nThe Reactive Streams project welcomes contributions from anybody who wants to participate in moving this initiative forward. All code or documentation that is contributed will have to be covered by the **MIT No Attribution** (SPDX: MIT-0) license, the rationale for this is that the APIs defined by this project shall be freely implementable and usable by everyone. For more detail, see [LICENSE](https://github.com/reactive-streams/reactive-streams-jvm/blob/master/LICENSE).\n\n## Gatekeepers\n\nTo ensure consistent development of Reactive Streams towards their goal, a group of gatekeepers is defined:\n\n* Kaazing Corp., currently represented by Todd Montgomery (@tmontgomery)\n* Netflix Inc., currently represented by Ben Christensen (@benjchristensen)\n* Pivotal Software Inc., currently represented by Jon Brisbin (@jbrisbin) and Stéphane Maldini (@smaldini)\n* Red Hat Inc., currently represented by Tim Fox (@purplefox) and Norman Maurer (@normanmaurer)\n* Twitter Inc., currently represented by Marius Eriksen (@mariusaeriksen)\n* Typesafe Inc., currently represented by Viktor Klang (@viktorklang) and Roland Kuhn (@rkuhn)\n\nThe role of this group is detailed in the following, additions to this list are made by pull request as defined below, removals require the consent of the entity to be removed or unanimous consent of all other Gatekeepers. Changing a representative of one of the gatekeeper entities can be done by a member of that entity without requiring consent from the other Gatekeepers.\n\nGatekeepers commit to the following:\n\n1. 1-week SLA on :+1: or :-1: Pull Requests\n   * If a Gatekeeper will be unavailable for a period of time, notify @reactive-streams/contributors and appoint who will vote in his/her place in the mean time\n2. tag @reactive-streams/contributors with a deadline when there needs to be a vote on an Issue,\n    with at least 1 week of notice (see rule 1 above)\n\n## General Workflow\n\n1. Before starting to work on a change, make sure that:\n    1. There is a ticket for your work in the project's issue tracker. If not, create it first. It can help accelerating the pull request acceptance process if the change is agreed upon beforehand within the ticket, but in some cases it may be preferable to discuss the necessity of the change in consideration of a concrete proposal.\n    2. The ticket has been scheduled for the current milestone.\n2. You should always perform your work in a Git feature branch within your own fork of the repository your are targeting (even if you should have push rights to the target repository).\n3. When the change is completed you should open a [Pull Request](https://help.github.com/articles/using-pull-requests) on GitHub.\n4. Anyone can comment on the pull request while it is open, and you are expected to answer questions or incorporate feedback.\n5. Once at least two thirds of the gatekeepers have signaled their consent, the pull request is merged by one of the gatekeepers into the branch and repository it is targeting. Consent is signaled by commenting on the pull request with the text “LGTM”, and it suffices for one representative of a gatekeeper to signal consent for that gatekeeper to be counted towards the two thirds quorum.\n6. It is not allowed to force-push to the branch on which the pull request is based. Replacing or adding to the commits on that branch will invalidate all previous consenting comments and consent needs to be re-established.\n7. Before merging a branch that contains multiple commits, it is recommended that these are squashed into a single commit before performing the merge. To aid in verification that no new changes are introduced, a new pull request should be opened in this case, targeting the same branch and repository and containing just one commit which encompasses the full change set of the original pull request.\n\n## Pull Request Requirements\n\nFor a Pull Request to be considered at all it has to meet these requirements:\n\n1. If applicable, the new or fixed features must be accompanied by comprehensive tests.\n2. If applicable, the pull request must contain all necessary documentation updates required by the changes introduced.\n3. The pull request must not contain changes that are unrelated to the ticket that it corresponds to. One pull request is meant to introduce only one logically contiguous change.\n\n## Creating Commits And Writing Commit Messages\n\nFollow these guidelines when creating public commits and writing commit messages.\n\n1. If your work spans multiple local commits (for example; if you do safe point commits while working in a feature branch or work in a branch for long time doing merges/rebases etc.) then please do not commit it all but rewrite the history by squashing the commits into a single big commit which you write a good commit message for (like discussed in the following sections). For more info read this article: [Git Workflow](http://sandofsky.com/blog/git-workflow.html). Every commit should be able to be used in isolation, cherry picked etc.\n\n2. First line should be a descriptive sentence what the commit is doing. It should be possible to fully understand what the commit does—but not necessarily how it does it—by just reading this single line. We follow the “imperative present tense” style for commit messages ([more info here](http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)).\n\n   It is **not ok** to only list the ticket number, type \"minor fix\" or similar. In order to help with automatic filtering of the commit history (generating ChangeLogs, writing the migration guide, code archaeology) we use the following encoding:\n\n3. Following the single line description should be a blank line followed by an enumerated list with the details of the commit. For very simple commits this may be empty.\n\n4. Add keywords for your commit:\n    * ``Review by @gituser`` - if you want to notify someone specifically for review; this has no influence on the acceptance process described above\n\nExample:\n\n    add CONTRIBUTING.md\n\n    * clarify how pull requests should look like\n    * describe the acceptance process\n\n## Performing Official Releases\n\nCreating binary artifacts, uploading them to central repositories and declaring these to be an official release of the Reactive Streams project requires the consent of all gatekeepers. The process is initiated by creating a ticket in the `reactive-streams` repository for this purpose and consent is signaled in the same way as for pull requests. The actual work of updating version numbers and publishing the artifacts will typically involve pull requests targeting the affected repositories.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.8896484375,
          "content": "MIT No Attribution\n\nCopyright 2014 Reactive Streams\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 34.6181640625,
          "content": "# Reactive Streams #\r\n\r\nThe purpose of Reactive Streams is to provide a standard for asynchronous stream processing with non-blocking backpressure.\r\n\r\nThe latest release is available on Maven Central as\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>org.reactivestreams</groupId>\r\n  <artifactId>reactive-streams</artifactId>\r\n  <version>1.0.4</version>\r\n</dependency>\r\n<dependency>\r\n  <groupId>org.reactivestreams</groupId>\r\n  <artifactId>reactive-streams-tck</artifactId>\r\n  <version>1.0.4</version>\r\n  <scope>test</scope>\r\n</dependency>\r\n```\r\n\r\n## Goals, Design and Scope ##\r\n\r\nHandling streams of data—especially “live” data whose volume is not predetermined—requires special care in an asynchronous system. The most prominent issue is that resource consumption needs to be carefully controlled such that a fast data source does not overwhelm the stream destination. Asynchrony is needed in order to enable the parallel use of computing resources, on collaborating network hosts or multiple CPU cores within a single machine.\r\n\r\nThe main goal of Reactive Streams is to govern the exchange of stream data across an asynchronous boundary – think passing elements on to another thread or thread-pool — while ensuring that the receiving side is not forced to buffer arbitrary amounts of data. In other words, backpressure is an integral part of this model in order to allow the queues which mediate between threads to be bounded. The benefits of asynchronous processing would be negated if the backpressure signals were synchronous (see also the [Reactive Manifesto](http://reactivemanifesto.org/)), therefore care has been taken to mandate fully non-blocking and asynchronous behavior of all aspects of a Reactive Streams implementation.\r\n\r\nIt is the intention of this specification to allow the creation of many conforming implementations, which by virtue of abiding by the rules will be able to interoperate smoothly, preserving the aforementioned benefits and characteristics across the whole processing graph of a stream application.\r\n\r\nIt should be noted that the precise nature of stream manipulations (transformation, splitting, merging, etc.) is not covered by this specification. Reactive Streams are only concerned with mediating the stream of data between different [API Components](#api-components). In their development care has been taken to ensure that all basic ways of combining streams can be expressed.\r\n\r\nIn summary, Reactive Streams is a standard and specification for Stream-oriented libraries for the JVM that\r\n\r\n - process a potentially unbounded number of elements\r\n - in sequence,\r\n - asynchronously passing elements between components,\r\n - with mandatory non-blocking backpressure.\r\n\r\nThe Reactive Streams specification consists of the following parts:\r\n\r\n***The API*** specifies the types to implement Reactive Streams and achieve interoperability between different implementations.\r\n\r\n***The Technology Compatibility Kit (TCK)*** is a standard test suite for conformance testing of implementations.\r\n\r\nImplementations are free to implement additional features not covered by the specification as long as they conform to the API requirements and pass the tests in the TCK.\r\n\r\n### API Components ###\r\n\r\nThe API consists of the following components that are required to be provided by Reactive Stream implementations:\r\n\r\n1. Publisher\r\n2. Subscriber\r\n3. Subscription\r\n4. Processor\r\n\r\nA *Publisher* is a provider of a potentially unbounded number of sequenced elements, publishing them according to the demand received from its Subscriber(s).\r\n\r\nIn response to a call to `Publisher.subscribe(Subscriber)` the possible invocation sequences for methods on the `Subscriber` are given by the following protocol:\r\n\r\n```\r\nonSubscribe onNext* (onError | onComplete)?\r\n```\r\n\r\nThis means that `onSubscribe` is always signalled,\r\nfollowed by a possibly unbounded number of `onNext` signals (as requested by `Subscriber`) followed by an `onError` signal if there is a failure, or an `onComplete` signal when no more elements are available—all as long as the `Subscription` is not cancelled.\r\n\r\n#### NOTES\r\n\r\n- The specifications below use binding words in capital letters from https://www.ietf.org/rfc/rfc2119.txt\r\n\r\n### Glossary\r\n\r\n| Term                      | Definition                                                                                             |\r\n| ------------------------- | ------------------------------------------------------------------------------------------------------ |\r\n| <a name=\"term_signal\">Signal</a> | As a noun: one of the `onSubscribe`, `onNext`, `onComplete`, `onError`, `request(n)` or `cancel` methods. As a verb: calling/invoking a signal. |\r\n| <a name=\"term_demand\">Demand</a> | As a noun, the aggregated number of elements requested by a Subscriber which is yet to be delivered (fulfilled) by the Publisher. As a verb, the act of `request`-ing more elements. |\r\n| <a name=\"term_sync\">Synchronous(ly)</a> | Executes on the calling Thread. |\r\n| <a name=\"term_return_normally\">Return normally</a> | Only ever returns a value of the declared type to the caller. The only legal way to signal failure to a `Subscriber` is via the `onError` method.|\r\n| <a name=\"term_responsivity\">Responsivity</a> | Readiness/ability to respond. In this document used to indicate that the different components should not impair each others ability to respond. |\r\n| <a name=\"term_non-obstructing\">Non-obstructing</a> | Quality describing a method which is as quick to execute as possible—on the calling thread. This means, for example, avoids heavy computations and other things that would stall the caller´s thread of execution. |\r\n| <a name=\"term_terminal_state\">Terminal state</a> | For a Publisher: When `onComplete` or `onError` has been signalled. For a Subscriber: When an `onComplete` or `onError` has been received.|\r\n| <a name=\"term_nop\">NOP</a> | Execution that has no detectable effect to the calling thread, and can as such safely be called any number of times.|\r\n| <a name=\"term_serially\">Serial(ly)</a> | In the context of a [Signal](#term_signal), non-overlapping. In the context of the JVM, calls to methods on an object are serial if and only if there is a happens-before relationship between those calls (implying also that the calls do not overlap). When the calls are performed asynchronously, coordination to establish the happens-before relationship is to be implemented using techniques such as, but not limited to, atomics, monitors, or locks. |\r\n| <a name=\"term_thread-safe\">Thread-safe</a> | Can be safely invoked synchronously, or asychronously, without requiring external synchronization to ensure program correctness. |\r\n\r\n### SPECIFICATION\r\n\r\n#### 1. Publisher ([Code](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.4/api/src/main/java/org/reactivestreams/Publisher.java))\r\n\r\n```java\r\npublic interface Publisher<T> {\r\n    public void subscribe(Subscriber<? super T> s);\r\n}\r\n````\r\n\r\n| ID                        | Rule                                                                                                   |\r\n| ------------------------- | ------------------------------------------------------------------------------------------------------ |\r\n| <a name=\"1.1\">1</a>       | The total number of `onNext`´s signalled by a `Publisher` to a `Subscriber` MUST be less than or equal to the total number of elements requested by that `Subscriber`´s `Subscription` at all times. |\r\n| [:bulb:](#1.1 \"1.1 explained\") | *The intent of this rule is to make it clear that Publishers cannot signal more elements than Subscribers have requested. There’s an implicit, but important, consequence to this rule: Since demand can only be fulfilled after it has been received, there’s a happens-before relationship between requesting elements and receiving elements.* |\r\n| <a name=\"1.2\">2</a>       | A `Publisher` MAY signal fewer `onNext` than requested and terminate the `Subscription` by calling `onComplete` or `onError`. |\r\n| [:bulb:](#1.2 \"1.2 explained\") | *The intent of this rule is to make it clear that a Publisher cannot guarantee that it will be able to produce the number of elements requested; it simply might not be able to produce them all; it may be in a failed state; it may be empty or otherwise already completed.* |\r\n| <a name=\"1.3\">3</a>       | `onSubscribe`, `onNext`, `onError` and `onComplete` signaled to a `Subscriber` MUST be signaled [serially](#term_serially). |\r\n| [:bulb:](#1.3 \"1.3 explained\") | *The intent of this rule is to permit the signalling of signals (including from multiple threads) if and only if a happens-before relation between each of the signals is established.* |\r\n| <a name=\"1.4\">4</a>       | If a `Publisher` fails it MUST signal an `onError`. |\r\n| [:bulb:](#1.4 \"1.4 explained\") | *The intent of this rule is to make it clear that a Publisher is responsible for notifying its Subscribers if it detects that it cannot proceed—Subscribers must be given a chance to clean up resources or otherwise deal with the Publisher´s failures.* |\r\n| <a name=\"1.5\">5</a>       | If a `Publisher` terminates successfully (finite stream) it MUST signal an `onComplete`. |\r\n| [:bulb:](#1.5 \"1.5 explained\") | *The intent of this rule is to make it clear that a Publisher is responsible for notifying its Subscribers that it has reached a [terminal state](#term_terminal_state)—Subscribers can then act on this information; clean up resources, etc.* |\r\n| <a name=\"1.6\">6</a>       | If a `Publisher` signals either `onError` or `onComplete` on a `Subscriber`, that `Subscriber`’s `Subscription` MUST be considered cancelled. |\r\n| [:bulb:](#1.6 \"1.6 explained\") | *The intent of this rule is to make sure that a Subscription is treated the same no matter if it was cancelled, the Publisher signalled onError or onComplete.* |\r\n| <a name=\"1.7\">7</a>       | Once a [terminal state](#term_terminal_state) has been signaled (`onError`, `onComplete`) it is REQUIRED that no further signals occur. |\r\n| [:bulb:](#1.7 \"1.7 explained\") | *The intent of this rule is to make sure that onError and onComplete are the final states of an interaction between a Publisher and Subscriber pair.* |\r\n| <a name=\"1.8\">8</a>       | If a `Subscription` is cancelled its `Subscriber` MUST eventually stop being signaled. |\r\n| [:bulb:](#1.8 \"1.8 explained\") | *The intent of this rule is to make sure that Publishers respect a Subscriber’s request to cancel a Subscription when Subscription.cancel() has been called. The reason for **eventually** is because signals can have propagation delay due to being asynchronous.* |\r\n| <a name=\"1.9\">9</a>       | `Publisher.subscribe` MUST call `onSubscribe` on the provided `Subscriber` prior to any other signals to that `Subscriber` and MUST [return normally](#term_return_normally), except when the provided `Subscriber` is `null` in which case it MUST throw a `java.lang.NullPointerException` to the caller, for all other situations the only legal way to signal failure (or reject the `Subscriber`) is by calling `onError` (after calling `onSubscribe`). |\r\n| [:bulb:](#1.9 \"1.9 explained\") | *The intent of this rule is to make sure that `onSubscribe` is always signalled before any of the other signals, so that initialization logic can be executed by the Subscriber when the signal is received. Also `onSubscribe` MUST only be called at most once, [see [2.12](#2.12)]. If the supplied `Subscriber` is `null`, there is nowhere else to signal this but to the caller, which means a `java.lang.NullPointerException` must be thrown. Examples of possible situations: A stateful Publisher can be overwhelmed, bounded by a finite number of underlying resources, exhausted, or in a [terminal state](#term_terminal_state).* |\r\n| <a name=\"1.10\">10</a>     | `Publisher.subscribe` MAY be called as many times as wanted but MUST be with a different `Subscriber` each time [see [2.12](#2.12)]. |\r\n| [:bulb:](#1.10 \"1.10 explained\") | *The intent of this rule is to have callers of `subscribe` be aware that a generic Publisher and a generic Subscriber cannot be assumed to support being attached multiple times. Furthermore, it also mandates that the semantics of `subscribe` must be upheld no matter how many times it is called.* |\r\n| <a name=\"1.11\">11</a>     | A `Publisher` MAY support multiple `Subscriber`s and decides whether each `Subscription` is unicast or multicast. |\r\n| [:bulb:](#1.11 \"1.11 explained\") | *The intent of this rule is to give Publisher implementations the flexibility to decide how many, if any, Subscribers they will support, and how elements are going to be distributed.* |\r\n\r\n#### 2. Subscriber ([Code](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.4/api/src/main/java/org/reactivestreams/Subscriber.java))\r\n\r\n```java\r\npublic interface Subscriber<T> {\r\n    public void onSubscribe(Subscription s);\r\n    public void onNext(T t);\r\n    public void onError(Throwable t);\r\n    public void onComplete();\r\n}\r\n````\r\n\r\n| ID                        | Rule                                                                                                   |\r\n| ------------------------- | ------------------------------------------------------------------------------------------------------ |\r\n| <a name=\"2.1\">1</a>       | A `Subscriber` MUST signal demand via `Subscription.request(long n)` to receive `onNext` signals. |\r\n| [:bulb:](#2.1 \"2.1 explained\") | *The intent of this rule is to establish that it is the responsibility of the Subscriber to decide when and how many elements it is able and willing to receive. To avoid signal reordering caused by reentrant Subscription methods, it is strongly RECOMMENDED for synchronous Subscriber implementations to invoke Subscription methods at the very end of any signal processing. It is RECOMMENDED that Subscribers request the upper limit of what they are able to process, as requesting only one element at a time results in an inherently inefficient \"stop-and-wait\" protocol.* |\r\n| <a name=\"2.2\">2</a>       | If a `Subscriber` suspects that its processing of signals will negatively impact its `Publisher`´s responsivity, it is RECOMMENDED that it asynchronously dispatches its signals. |\r\n| [:bulb:](#2.2 \"2.2 explained\") | *The intent of this rule is that a Subscriber should [not obstruct](#term_non-obstructing) the progress of the Publisher from an execution point-of-view. In other words, the Subscriber should not starve the Publisher from receiving CPU cycles.* |\r\n| <a name=\"2.3\">3</a>       | `Subscriber.onComplete()` and `Subscriber.onError(Throwable t)` MUST NOT call any methods on the `Subscription` or the `Publisher`. |\r\n| [:bulb:](#2.3 \"2.3 explained\") | *The intent of this rule is to prevent cycles and race-conditions—between Publisher, Subscription and Subscriber—during the processing of completion signals.* |\r\n| <a name=\"2.4\">4</a>       | `Subscriber.onComplete()` and `Subscriber.onError(Throwable t)` MUST consider the Subscription cancelled after having received the signal. |\r\n| [:bulb:](#2.4 \"2.4 explained\") | *The intent of this rule is to make sure that Subscribers respect a Publisher’s [terminal state](#term_terminal_state) signals. A Subscription is simply not valid anymore after an onComplete or onError signal has been received.* |\r\n| <a name=\"2.5\">5</a>       | A `Subscriber` MUST call `Subscription.cancel()` on the given `Subscription` after an `onSubscribe` signal if it already has an active `Subscription`. |\r\n| [:bulb:](#2.5 \"2.5 explained\") | *The intent of this rule is to prevent that two, or more, separate Publishers from trying to interact with the same Subscriber. Enforcing this rule means that resource leaks are prevented since extra Subscriptions will be cancelled. Failure to conform to this rule may lead to violations of Publisher rule 1, amongst others. Such violations can lead to hard-to-diagnose bugs.* |\r\n| <a name=\"2.6\">6</a>       | A `Subscriber` MUST call `Subscription.cancel()` if the `Subscription` is no longer needed. |\r\n| [:bulb:](#2.6 \"2.6 explained\") | *The intent of this rule is to establish that Subscribers cannot just throw Subscriptions away when they are no longer needed, they have to call `cancel` so that resources held by that Subscription can be safely, and timely, reclaimed. An example of this would be a Subscriber which is only interested in a specific element, which would then cancel its Subscription to signal its completion to the Publisher.* |\r\n| <a name=\"2.7\">7</a>       | A Subscriber MUST ensure that all calls on its Subscription's request and cancel methods are performed [serially](#term_serially). |\r\n| [:bulb:](#2.7 \"2.7 explained\") | *The intent of this rule is to permit the calling of the request and cancel methods (including from multiple threads) if and only if a [serial](#term_serially) relation between each of the calls is established.* |\r\n| <a name=\"2.8\">8</a>       | A `Subscriber` MUST be prepared to receive one or more `onNext` signals after having called `Subscription.cancel()` if there are still requested elements pending [see [3.12](#3.12)]. `Subscription.cancel()` does not guarantee to perform the underlying cleaning operations immediately. |\r\n| [:bulb:](#2.8 \"2.8 explained\") | *The intent of this rule is to highlight that there may be a delay between calling `cancel` and the Publisher observing that cancellation.* |\r\n| <a name=\"2.9\">9</a>       | A `Subscriber` MUST be prepared to receive an `onComplete` signal with or without a preceding `Subscription.request(long n)` call. |\r\n| [:bulb:](#2.9 \"2.9 explained\") | *The intent of this rule is to establish that completion is unrelated to the demand flow—this allows for streams which complete early, and obviates the need to *poll* for completion.* |\r\n| <a name=\"2.10\">10</a>     | A `Subscriber` MUST be prepared to receive an `onError` signal with or without a preceding `Subscription.request(long n)` call. |\r\n| [:bulb:](#2.10 \"2.10 explained\") | *The intent of this rule is to establish that Publisher failures may be completely unrelated to signalled demand. This means that Subscribers do not need to poll to find out if the Publisher will not be able to fulfill its requests.* |\r\n| <a name=\"2.11\">11</a>     | A `Subscriber` MUST make sure that all calls on its [signal](#term_signal) methods happen-before the processing of the respective signals. I.e. the Subscriber must take care of properly publishing the signal to its processing logic. |\r\n| [:bulb:](#2.11 \"2.11 explained\") | *The intent of this rule is to establish that it is the responsibility of the Subscriber implementation to make sure that asynchronous processing of its signals are thread safe. See [JMM definition of Happens-Before in section 17.4.5](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5).* |\r\n| <a name=\"2.12\">12</a>     | `Subscriber.onSubscribe` MUST be called at most once for a given `Subscriber` (based on object equality). |\r\n| [:bulb:](#2.12 \"2.12 explained\") | *The intent of this rule is to establish that it MUST be assumed that the same Subscriber can only be subscribed at most once. Note that `object equality` is `a.equals(b)`.* |\r\n| <a name=\"2.13\">13</a>     | Calling `onSubscribe`, `onNext`, `onError` or `onComplete` MUST [return normally](#term_return_normally) except when any provided parameter is `null` in which case it MUST throw a `java.lang.NullPointerException` to the caller, for all other situations the only legal way for a `Subscriber` to signal failure is by cancelling its `Subscription`. In the case that this rule is violated, any associated `Subscription` to the `Subscriber` MUST be considered as cancelled, and the caller MUST raise this error condition in a fashion that is adequate for the runtime environment. |\r\n| [:bulb:](#2.13 \"2.13 explained\") | *The intent of this rule is to establish the semantics for the methods of Subscriber and what the Publisher is allowed to do in which case this rule is violated. «Raise this error condition in a fashion that is adequate for the runtime environment» could mean logging the error—or otherwise make someone or something aware of the situation—as the error cannot be signalled to the faulty Subscriber.* |\r\n\r\n#### 3. Subscription ([Code](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.4/api/src/main/java/org/reactivestreams/Subscription.java))\r\n\r\n```java\r\npublic interface Subscription {\r\n    public void request(long n);\r\n    public void cancel();\r\n}\r\n````\r\n\r\n| ID                        | Rule                                                                                                   |\r\n| ------------------------- | ------------------------------------------------------------------------------------------------------ |\r\n| <a name=\"3.1\">1</a>       | `Subscription.request` and `Subscription.cancel` MUST only be called inside of its `Subscriber` context. |\r\n| [:bulb:](#3.1 \"3.1 explained\") | *The intent of this rule is to establish that a Subscription represents the unique relationship between a Subscriber and a Publisher [see [2.12](#2.12)]. The Subscriber is in control over when elements are requested and when more elements are no longer needed.* |\r\n| <a name=\"3.2\">2</a>       | The `Subscription` MUST allow the `Subscriber` to call `Subscription.request` synchronously from within `onNext` or `onSubscribe`. |\r\n| [:bulb:](#3.2 \"3.2 explained\") | *The intent of this rule is to make it clear that implementations of `request` must be reentrant, to avoid stack overflows in the case of mutual recursion between `request` and `onNext` (and eventually `onComplete` / `onError`). This implies that Publishers can be `synchronous`, i.e. signalling `onNext`´s on the thread which calls `request`.* |\r\n| <a name=\"3.3\">3</a>       | `Subscription.request` MUST place an upper bound on possible synchronous recursion between `Publisher` and `Subscriber`. |\r\n| [:bulb:](#3.3 \"3.3 explained\") | *The intent of this rule is to complement [see [3.2](#3.2)] by placing an upper limit on the mutual recursion between `request` and `onNext` (and eventually `onComplete` / `onError`). Implementations are RECOMMENDED to limit this mutual recursion to a depth of `1` (ONE)—for the sake of conserving stack space. An example for undesirable synchronous, open recursion would be Subscriber.onNext -> Subscription.request -> Subscriber.onNext -> …, as it otherwise will result in blowing the calling thread´s stack.* |\r\n| <a name=\"3.4\">4</a>       | `Subscription.request` SHOULD respect the responsivity of its caller by returning in a timely manner. |\r\n| [:bulb:](#3.4 \"3.4 explained\") | *The intent of this rule is to establish that `request` is intended to be a [non-obstructing](#term_non-obstructing) method, and should be as quick to execute as possible on the calling thread, so avoid heavy computations and other things that would stall the caller´s thread of execution.* |\r\n| <a name=\"3.5\">5</a>       | `Subscription.cancel` MUST respect the responsivity of its caller by returning in a timely manner, MUST be idempotent and MUST be [thread-safe](#term_thread-safe). |\r\n| [:bulb:](#3.5 \"3.5 explained\") | *The intent of this rule is to establish that `cancel` is intended to be a [non-obstructing](#term_non-obstructing) method, and should be as quick to execute as possible on the calling thread, so avoid heavy computations and other things that would stall the caller´s thread of execution. Furthermore, it is also important that it is possible to call it multiple times without any adverse effects.* |\r\n| <a name=\"3.6\">6</a>       | After the `Subscription` is cancelled, additional `Subscription.request(long n)` MUST be [NOPs](#term_nop). |\r\n| [:bulb:](#3.6 \"3.6 explained\") | *The intent of this rule is to establish a causal relationship between cancellation of a subscription and the subsequent non-operation of requesting more elements.* |\r\n| <a name=\"3.7\">7</a>       | After the `Subscription` is cancelled, additional `Subscription.cancel()` MUST be [NOPs](#term_nop). |\r\n| [:bulb:](#3.7 \"3.7 explained\") | *The intent of this rule is superseded by [3.5](#3.5).* |\r\n| <a name=\"3.8\">8</a>       | While the `Subscription` is not cancelled, `Subscription.request(long n)` MUST register the given number of additional elements to be produced to the respective subscriber. |\r\n| [:bulb:](#3.8 \"3.8 explained\") | *The intent of this rule is to make sure that `request`-ing is an additive operation, as well as ensuring that a request for elements is delivered to the Publisher.* |\r\n| <a name=\"3.9\">9</a>       | While the `Subscription` is not cancelled, `Subscription.request(long n)` MUST signal `onError` with a `java.lang.IllegalArgumentException` if the argument is <= 0. The cause message SHOULD explain that non-positive request signals are illegal. |\r\n| [:bulb:](#3.9 \"3.9 explained\") | *The intent of this rule is to prevent faulty implementations to proceed operation without any exceptions being raised. Requesting a negative or 0 number of elements, since requests are additive, most likely to be the result of an erroneous calculation on the behalf of the Subscriber.* |\r\n| <a name=\"3.10\">10</a>     | While the `Subscription` is not cancelled, `Subscription.request(long n)` MAY synchronously call `onNext` on this (or other) subscriber(s). |\r\n| [:bulb:](#3.10 \"3.10 explained\") | *The intent of this rule is to establish that it is allowed to create synchronous Publishers, i.e. Publishers who execute their logic on the calling thread.* |\r\n| <a name=\"3.11\">11</a>     | While the `Subscription` is not cancelled, `Subscription.request(long n)` MAY synchronously call `onComplete` or `onError` on this (or other) subscriber(s). |\r\n| [:bulb:](#3.11 \"3.11 explained\") | *The intent of this rule is to establish that it is allowed to create synchronous Publishers, i.e. Publishers who execute their logic on the calling thread.* |\r\n| <a name=\"3.12\">12</a>     | While the `Subscription` is not cancelled, `Subscription.cancel()` MUST request the `Publisher` to eventually stop signaling its `Subscriber`. The operation is NOT REQUIRED to affect the `Subscription` immediately. |\r\n| [:bulb:](#3.12 \"3.12 explained\") | *The intent of this rule is to establish that the desire to cancel a Subscription is eventually respected by the Publisher, acknowledging that it may take some time before the signal is received.* |\r\n| <a name=\"3.13\">13</a>     | While the `Subscription` is not cancelled, `Subscription.cancel()` MUST request the `Publisher` to eventually drop any references to the corresponding subscriber. |\r\n| [:bulb:](#3.13 \"3.13 explained\") | *The intent of this rule is to make sure that Subscribers can be properly garbage-collected after their subscription no longer being valid. Re-subscribing with the same Subscriber object is discouraged [see [2.12](#2.12)], but this specification does not mandate that it is disallowed since that would mean having to store previously cancelled subscriptions indefinitely.* |\r\n| <a name=\"3.14\">14</a>     | While the `Subscription` is not cancelled, calling `Subscription.cancel` MAY cause the `Publisher`, if stateful, to transition into the `shut-down` state if no other `Subscription` exists at this point [see [1.9](#1.9)]. |\r\n| [:bulb:](#3.14 \"3.14 explained\") | *The intent of this rule is to allow for Publishers to signal `onComplete` or `onError` following `onSubscribe` for new Subscribers in response to a cancellation signal from an existing Subscriber.* |\r\n| <a name=\"3.15\">15</a>     | Calling `Subscription.cancel` MUST [return normally](#term_return_normally). |\r\n| [:bulb:](#3.15 \"3.15 explained\") | *The intent of this rule is to disallow implementations to throw exceptions in response to `cancel` being called.* |\r\n| <a name=\"3.16\">16</a>     | Calling `Subscription.request` MUST [return normally](#term_return_normally). |\r\n| [:bulb:](#3.16 \"3.16 explained\") | *The intent of this rule is to disallow implementations to throw exceptions in response to `request` being called.* |\r\n| <a name=\"3.17\">17</a>     | A `Subscription` MUST support an unbounded number of calls to `request` and MUST support a demand up to 2^63-1 (`java.lang.Long.MAX_VALUE`). A demand equal or greater than 2^63-1 (`java.lang.Long.MAX_VALUE`) MAY be considered by the `Publisher` as “effectively unbounded”. |\r\n| [:bulb:](#3.17 \"3.17 explained\") | *The intent of this rule is to establish that the Subscriber can request an unbounded number of elements, in any increment above 0 [see [3.9](#3.9)], in any number of invocations of `request`. As it is not feasibly reachable with current or foreseen hardware within a reasonable amount of time (1 element per nanosecond would take 292 years) to fulfill a demand of 2^63-1, it is allowed for a Publisher to stop tracking demand beyond this point.* |\r\n\r\nA `Subscription` is shared by exactly one `Publisher` and one `Subscriber` for the purpose of mediating the data exchange between this pair. This is the reason why the `subscribe()` method does not return the created `Subscription`, but instead returns `void`; the `Subscription` is only passed to the `Subscriber` via the `onSubscribe` callback.\r\n\r\n#### 4.Processor ([Code](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.4/api/src/main/java/org/reactivestreams/Processor.java))\r\n\r\n```java\r\npublic interface Processor<T, R> extends Subscriber<T>, Publisher<R> {\r\n}\r\n````\r\n\r\n| ID                       | Rule                                                                                                   |\r\n| ------------------------ | ------------------------------------------------------------------------------------------------------ |\r\n| <a name=\"4.1\">1</a>      | A `Processor` represents a processing stage—which is both a `Subscriber` and a `Publisher` and MUST obey the contracts of both. |\r\n| [:bulb:](#4.1 \"4.1 explained\") | *The intent of this rule is to establish that Processors behave, and are bound by, both the Publisher and Subscriber specifications.* |\r\n| <a name=\"4.2\">2</a>      | A `Processor` MAY choose to recover an `onError` signal. If it chooses to do so, it MUST consider the `Subscription` cancelled, otherwise it MUST propagate the `onError` signal to its Subscribers immediately. |\r\n| [:bulb:](#4.2 \"4.2 explained\") | *The intent of this rule is to inform that it’s possible for implementations to be more than simple transformations.* |\r\n\r\nWhile not mandated, it can be a good idea to cancel a `Processor`´s upstream `Subscription` when/if its last `Subscriber` cancels their `Subscription`,\r\nto let the cancellation signal propagate upstream.\r\n\r\n### Asynchronous vs Synchronous Processing ###\r\n\r\nThe Reactive Streams API prescribes that all processing of elements (`onNext`) or termination signals (`onError`, `onComplete`) MUST NOT *block* the `Publisher`. However, each of the `on*` handlers can process the events synchronously or asynchronously.\r\n\r\nTake this example:\r\n\r\n```\r\nnioSelectorThreadOrigin map(f) filter(p) consumeTo(toNioSelectorOutput)\r\n```\r\n\r\nIt has an async origin and an async destination. Let’s assume that both origin and destination are selector event loops. The `Subscription.request(n)` must be chained from the destination to the origin. This is now where each implementation can choose how to do this.\r\n\r\nThe following uses the pipe `|` character to signal async boundaries (queue and schedule) and `R#` to represent resources (possibly threads).\r\n\r\n```\r\nnioSelectorThreadOrigin | map(f) | filter(p) | consumeTo(toNioSelectorOutput)\r\n-------------- R1 ----  | - R2 - | -- R3 --- | ---------- R4 ----------------\r\n```\r\n\r\nIn this example each of the 3 consumers, `map`, `filter` and `consumeTo` asynchronously schedule the work. It could be on the same event loop (trampoline), separate threads, whatever.\r\n\r\n```\r\nnioSelectorThreadOrigin map(f) filter(p) | consumeTo(toNioSelectorOutput)\r\n------------------- R1 ----------------- | ---------- R2 ----------------\r\n```\r\n\r\nHere it is only the final step that asynchronously schedules, by adding work to the NioSelectorOutput event loop. The `map` and `filter` steps are synchronously performed on the origin thread.\r\n\r\nOr another implementation could fuse the operations to the final consumer:\r\n\r\n```\r\nnioSelectorThreadOrigin | map(f) filter(p) consumeTo(toNioSelectorOutput)\r\n--------- R1 ---------- | ------------------ R2 -------------------------\r\n```\r\n\r\nAll of these variants are \"asynchronous streams\". They all have their place and each has different tradeoffs including performance and implementation complexity.\r\n\r\nThe Reactive Streams contract allows implementations the flexibility to manage resources and scheduling and mix asynchronous and synchronous processing within the bounds of a non-blocking, asynchronous, dynamic push-pull stream.\r\n\r\nIn order to allow fully asynchronous implementations of all participating API elements—`Publisher`/`Subscription`/`Subscriber`/`Processor`—all methods defined by these interfaces return `void`.\r\n\r\n### Subscriber controlled queue bounds ###\r\n\r\nOne of the underlying design principles is that all buffer sizes are to be bounded and these bounds must be *known* and *controlled* by the subscribers. These bounds are expressed in terms of *element count* (which in turn translates to the invocation count of onNext). Any implementation that aims to support infinite streams (especially high output rate streams) needs to enforce bounds all along the way to avoid out-of-memory errors and constrain resource usage in general.\r\n\r\nSince back-pressure is mandatory the use of unbounded buffers can be avoided. In general, the only time when a queue might grow without bounds is when the publisher side maintains a higher rate than the subscriber for an extended period of time, but this scenario is handled by backpressure instead.\r\n\r\nQueue bounds can be controlled by a subscriber signaling demand for the appropriate number of elements. At any point in time the subscriber knows:\r\n\r\n - the total number of elements requested: `P`\r\n - the number of elements that have been processed: `N`\r\n\r\nThen the maximum number of elements that may arrive—until more demand is signaled to the Publisher—is `P - N`. In the case that the subscriber also knows the number of elements B in its input buffer then this bound can be refined to `P - B - N`.\r\n\r\nThese bounds must be respected by a publisher independent of whether the source it represents can be backpressured or not. In the case of sources whose production rate cannot be influenced—for example clock ticks or mouse movement—the publisher must choose to either buffer or drop elements to obey the imposed bounds.\r\n\r\nSubscribers signaling a demand for one element after the reception of an element effectively implement a Stop-and-Wait protocol where the demand signal is equivalent to acknowledgement. By providing demand for multiple elements the cost of acknowledgement is amortized. It is worth noting that the subscriber is allowed to signal demand at any point in time, allowing it to avoid unnecessary delays between the publisher and the subscriber (i.e. keeping its input buffer filled without having to wait for full round-trips).\r\n\r\n## Legal\r\n\r\nThis project is a collaboration between engineers from Kaazing, Lightbend, Netflix, Pivotal, Red Hat, Twitter and many others. This project is licensed under MIT No Attribution (SPDX: MIT-0).\r\n"
        },
        {
          "name": "RELEASE-NOTES.md",
          "type": "blob",
          "size": 25.5205078125,
          "content": "# Release notes for Reactive Streams\n\n# Version 1.0.4 released on 2022-05-20\n\n## Announcement:\n\nWe—the Reactive Streams community—are pleased to announce the immediate availability of `Reactive Streams 1.0.4`. This update to `Reactive Streams` brings the following improvements over `1.0.3`.\n\n## Highlights:\n\n- License\n  + This project is now (re-)licensed under MIT No Attribution (SPDX: MIT-0)\n- Specification\n  + No breaking/semantical changes\n  + Rule [clarifications](#specification-clarifications-104)\n- Interfaces\n  + No changes\n- Technology Compatibility Kit (TCK)\n  + Improved verification of Subscriber rule §2.3\n  + Improved JavaDoc\n- Examples\n  + No changes\n- Artifacts\n  + No changes\n\n## Specification clarifications 1.0.4\n\n## Subscriber Rule 7\n\n**1.0.3:** The intent of this rule is to permit the calling of the request and cancel methods (including from multiple threads) if and only if a happens-before relation between each of the calls is established.\n\n**1.0.4:** The intent of this rule is to permit the calling of the request and cancel methods (including from multiple threads) if and only if a [serial](#term_serially) relation between each of the calls is established.\n\n## Contributors\n  + Roland Kuhn [(@rkuhn)](https://github.com/rkuhn)\n  + Ben Christensen [(@benjchristensen)](https://github.com/benjchristensen)\n  + Viktor Klang [(@viktorklang)](https://github.com/viktorklang)\n  + Stephane Maldini [(@smaldini)](https://github.com/smaldini)\n  + Stanislav Savulchik [(@savulchik)](https://github.com/savulchik)\n  + Konrad Malawski [(@ktoso)](https://github.com/ktoso)\n  + Slim Ouertani [(@ouertani)](https://github.com/ouertani)\n  + Martynas Mickevičius [(@2m)](https://github.com/2m)\n  + Luke Daley [(@ldaley)](https://github.com/ldaley)\n  + Colin Godsey [(@colinrgodsey)](https://github.com/colinrgodsey)\n  + David Moten [(@davidmoten)](https://github.com/davidmoten)\n  + Brian Topping [(@briantopping)](https://github.com/briantopping)\n  + Rossen Stoyanchev [(@rstoyanchev)](https://github.com/rstoyanchev)\n  + Björn Hamels [(@BjornHamels)](https://github.com/BjornHamels)\n  + Jake Wharton [(@JakeWharton)](https://github.com/JakeWharton)\n  + Anthony Vanelverdinghe[(@anthonyvdotbe)](https://github.com/anthonyvdotbe)\n  + Kazuhiro Sera [(@seratch)](https://github.com/seratch)\n  + Dávid Karnok [(@akarnokd)](https://github.com/akarnokd)\n  + Evgeniy Getman [(@egetman)](https://github.com/egetman)\n  + Ángel Sanz [(@angelsanz)](https://github.com/angelsanz)\n  + shenghaiyang [(@shenghaiyang)](https://github.com/shenghaiyang)\n  + Kyle Thomson [(@kiiadi)](https://github.com/kiiadi)\n  + Tomislav Hofman [(@tomislavhofman)](https://github.com/tomislavhofman)\n  + Sean Sullivan [(@sullis)](https://github.com/sullis)\n\n---\n\n# Version 1.0.3 released on 2019-08-23\n\n## Announcement:\n\nWe—the Reactive Streams community—are pleased to announce the immediate availability of `Reactive Streams 1.0.3`. This update to `Reactive Streams` brings the following improvements over `1.0.2`.\n\n## Highlights:\n\n- Specification\n  + Glossary term \"External synchronization\" has been [superseded](#Glossary)\n  + No breaking/semantical changes\n  + Rule [clarifications](#specification-clarifications-103-RC1)\n- Interfaces\n  + No changes\n- Technology Compatibility Kit (TCK)\n  + Improved [coverage](#tck-alterations-103-RC1)\n  + Improved JavaDoc\n- Examples\n  + No changes\n- Artifacts\n  + FlowAdapters artifact removed, FlowAdapters moved into the core jar ([#424](https://github.com/reactive-streams/reactive-streams-jvm/issues/424))\n\n## Specification clarifications 1.0.3\n\n## Glossary term \"External synchronization\" replaced by \"Serial(ly)\"\n\n**1.0.2:** Access coordination for thread safety purposes implemented outside of the constructs defined in this specification, using techniques such as, but not limited to, `atomics`, `monitors`, or `locks`.\n\n**1.0.3** In the context of a Signal, non-overlapping. In the context of the JVM, calls to methods on an object are serial if and only if there is a happens-before relationship between those calls (implying also that the calls do not overlap). When the calls are performed asynchronously, coordination to establish the happens-before relationship is to be implemented using techniques such as, but not limited to, atomics, monitors, or locks.\n\n## Publisher Rule 3 (Rule and Intent clarified)\n\n**1.0.2:** `onSubscribe`, `onNext`, `onError` and `onComplete` signaled to a `Subscriber` MUST be signaled in a thread-safe manner—and if performed by multiple threads—use external synchronization.\n\n*The intent of this rule is to make it clear that external synchronization must be employed if the Publisher intends to send signals from multiple/different threads.*\n\n**1.0.3:** `onSubscribe`, `onNext`, `onError` and `onComplete` signaled to a `Subscriber` MUST be signaled serially.\n\n*The intent of this rule is to permit the signalling of signals (including from multiple threads) if and only if a happens-before relation between each of the signals is established.*\n\n## Subscriber Rule 1 (Intent clarified)\n\n**1.0.2:** A `Subscriber` MUST signal demand via `Subscription.request(long n)` to receive `onNext` signals.\n\n*The intent of this rule is to establish that it is the responsibility of the Subscriber to signal when, and how many, elements it is able and willing to receive.*\n\n**1.0.3:** A `Subscriber` MUST signal demand via `Subscription.request(long n)` to receive `onNext` signals.\n\n*The intent of this rule is to establish that it is the responsibility of the Subscriber to decide when and how many elements it is able and willing to receive. To avoid signal reordering caused by reentrant Subscription methods, it is strongly RECOMMENDED for synchronous Subscriber implementations to invoke Subscription methods at the very end of any signal processing. It is RECOMMENDED that Subscribers request the upper limit of what they are able to process, as requesting only one element at a time results in an inherently inefficient \"stop-and-wait\" protocol.*\n\n## Subscriber Rule 5 (Intent clarified)\n\n**1.0.2:** A `Subscriber` MUST call `Subscription.cancel()` on the given `Subscription` after an `onSubscribe` signal if it already has an active `Subscription`\n\n*The intent of this rule is to prevent that two, or more, separate Publishers from thinking that they can interact with the same Subscriber. Enforcing this rule means that resource leaks are prevented since extra Subscriptions will be cancelled.*\n\n**1.0.3:** A `Subscriber` MUST call `Subscription.cancel()` on the given `Subscription` after an `onSubscribe` signal if it already has an active `Subscription`\n\n*The intent of this rule is to prevent that two, or more, separate Publishers from trying to interact with the same Subscriber. Enforcing this rule means that resource leaks are prevented since extra Subscriptions will be cancelled. Failure to conform to this rule may lead to violations of Publisher rule 1, amongst others. Such violations can lead to hard-to-diagnose bugs.*\n\n## Subscriber Rule 7 (Rule and Intent clarified)\n\n**1.0.2:** A `Subscriber` MUST ensure that all calls on its `Subscription` take place from the same thread or provide for respective external synchronization.\n\n*The intent of this rule is to establish that external synchronization must be added if a Subscriber will be using a Subscription concurrently by two or more threads.*\n\n**1.0.3:** A Subscriber MUST ensure that all calls on its Subscription's request and cancel methods are performed serially.\n\n*The intent of this rule is to permit the calling of the request and cancel methods (including from multiple threads) if and only if a happens-before relation between each of the calls is established.*\n\n## TCK alterations 1.0.3\n\n- `PublisherVerification.optional_spec105_emptyStreamMustTerminateBySignallingOnComplete` fails if the publisher completes synchronously ([#422](https://github.com/reactive-streams/reactive-streams-jvm/issues/422))\n- IdentityFlowProcessorVerification throws NPE when `createFailedFlowPublisher` returns null ([#425](https://github.com/reactive-streams/reactive-streams-jvm/issues/425))\n- `required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel` does not wait for request before invoking onNext ([#277](https://github.com/reactive-streams/reactive-streams-jvm/issues/277))\n- Subscriber whitebox verification tests demand ([#280](https://github.com/reactive-streams/reactive-streams-jvm/issues/280))\n- Incomplete documentation on stochastic tests in TCK ([#278](https://github.com/reactive-streams/reactive-streams-jvm/issues/278))\n- TCK performance ([#446](https://github.com/reactive-streams/reactive-streams-jvm/issues/446))\n- TCK: Receptacle#expectError timeout approach ([#451](https://github.com/reactive-streams/reactive-streams-jvm/issues/451))\n\n\n## Contributors\n  + Roland Kuhn [(@rkuhn)](https://github.com/rkuhn)\n  + Ben Christensen [(@benjchristensen)](https://github.com/benjchristensen)\n  + Viktor Klang [(@viktorklang)](https://github.com/viktorklang)\n  + Stephane Maldini [(@smaldini)](https://github.com/smaldini)\n  + Stanislav Savulchik [(@savulchik)](https://github.com/savulchik)\n  + Konrad Malawski [(@ktoso)](https://github.com/ktoso)\n  + Slim Ouertani [(@ouertani)](https://github.com/ouertani)\n  + Martynas Mickevičius [(@2m)](https://github.com/2m)\n  + Luke Daley [(@ldaley)](https://github.com/ldaley)\n  + Colin Godsey [(@colinrgodsey)](https://github.com/colinrgodsey)\n  + David Moten [(@davidmoten)](https://github.com/davidmoten)\n  + Brian Topping [(@briantopping)](https://github.com/briantopping)\n  + Rossen Stoyanchev [(@rstoyanchev)](https://github.com/rstoyanchev)\n  + Björn Hamels [(@BjornHamels)](https://github.com/BjornHamels)\n  + Jake Wharton [(@JakeWharton)](https://github.com/JakeWharton)\n  + Anthony Vanelverdinghe[(@anthonyvdotbe)](https://github.com/anthonyvdotbe)\n  + Kazuhiro Sera [(@seratch)](https://github.com/seratch)\n  + Dávid Karnok [(@akarnokd)](https://github.com/akarnokd)\n  + Evgeniy Getman [(@egetman)](https://github.com/egetman)\n  + Ángel Sanz [(@angelsanz)](https://github.com/angelsanz)\n  + shenghaiyang [(@shenghaiyang)](https://github.com/shenghaiyang)\n  + Kyle Thomson [(@kiiadi)](https://github.com/kiiadi)\n  + (new) James Roper [(@jroper)](https://github.com/jroper)\n  + (new) Oleh Dokuka [(@olegdokuka)](https://github.com/olegdokuka)\n  + (new) Scott Mitchell [(@Scottmitch)](https://github.com/Scottmitch)\n\n\n---\n\n# Version 1.0.2 released on 2017-12-19\n\n## Announcement:\n\nWe—the Reactive Streams community—are pleased to announce the immediate availability of `Reactive Streams 1.0.2`. This update to `Reactive Streams` brings the following improvements over `1.0.1`.\n\n## Highlights:\n\n- Specification\n  + Glossary term added for `Thread-safe`\n  + No breaking/semantical changes\n  + Rule [clarifications](#specification-clarifications-102)\n- Interfaces\n  + No changes\n- Technology Compatibility Kit (TCK)\n  + Improved [coverage](#tck-alterations-102)\n    * Supports Publishers/Processors which do [coordinated emission](http://www.reactive-streams.org/reactive-streams-tck-1.0.2-javadoc/org/reactivestreams/tck/PublisherVerification.html#doesCoordinatedEmission--).\n  + Improved JavaDoc\n- Examples\n  + New example [RangePublisher](http://www.reactive-streams.org/reactive-streams-examples-1.0.2-javadoc/org/reactivestreams/example/unicast/RangePublisher.html)\n- Artifacts\n  + NEW! [Flow adapters](#flow-adapters)\n  + NEW! [Flow TCK](#flow-tck)\n  + Java 9 [Automatic-Module-Name](#automatic-module-name) added for all artifacts\n\n## Specification clarifications 1.0.2\n\n## Subscriber Rule 2\n\n**1.0.1:** The intent of this rule is that a Subscriber should not obstruct the progress of the Publisher from an execution point-of-view. In other words, the Subscriber should not starve the Publisher from CPU cycles.\n\n**1.0.2:** The intent of this rule is that a Subscriber should not obstruct the progress of the Publisher from an execution point-of-view. In other words, the Subscriber should not starve the Publisher from receiving CPU cycles.\n\n## Subscriber Rule 8\n\n**1.0.1:** The intent of this rule is to highlight that there may be a delay between calling `cancel` the Publisher seeing that.\n\n**1.0.2** The intent of this rule is to highlight that there may be a delay between calling `cancel` and the Publisher observing that cancellation.\n\n## Flow adapters\n\nAn adapter library has been created to convert `org.reactivestreams` to `java.util.concurrent.Flow` and vice versa. Read more about it [here](http://www.reactive-streams.org/reactive-streams-flow-adapters-1.0.2-javadoc)\n\n~~~xml\n<dependency>\n   <groupId>org.reactivestreams</groupId>\n   <artifactId>reactive-streams-flow-adapters</artifactId>\n  <version>1.0.2</version>\n</dependency>\n~~~\n\n## Flow TCK\n\nA TCK artifact has been created to allow for direct TCK verification of `java.util.concurrent.Flow` implementations. Read more about it [here](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.2/tck-flow/README.md)\n\n~~~xml\n<dependency>\n   <groupId>org.reactivestreams</groupId>\n   <artifactId>reactive-streams-tck-flow</artifactId>\n  <version>1.0.2</version>\n</dependency>\n~~~\n\n## Automatic Module Name\n\n  * `org.reactivestreams:reactive-streams` => `org.reactivestreams`\n  * `org.reactivestreams:reactive-streams-examples` => `org.reactivestreams.examples`\n  * `org.reactivestreams:reactive-streams-tck` => `org.reactivestreams.tck`\n  * `org.reactivestreams:reactive-streams-flow-adapters` => `org.reactivestreams.flowadapters`\n  * `org.reactivestreams:reactive-streams-tck-flow` => `org.reactivestreams.tckflow`\n\n## TCK alterations 1.0.2\n\n- Added support for Publisher verification of Publishers who do coordinated emission, i.e. where elements only are emitted after all current Subscribers have signalled demand. ([#284](https://github.com/reactive-streams/reactive-streams-jvm/issues/284))\n- The `SubscriberWhiteboxVerification` has been given more user friendly error messages in the case where the user forgets to call `registerOnSubscribe`. (#416)[https://github.com/reactive-streams/reactive-streams-jvm/pull/416]\n\n## Contributors\n  + Roland Kuhn [(@rkuhn)](https://github.com/rkuhn)\n  + Ben Christensen [(@benjchristensen)](https://github.com/benjchristensen)\n  + Viktor Klang [(@viktorklang)](https://github.com/viktorklang)\n  + Stephane Maldini [(@smaldini)](https://github.com/smaldini)\n  + Stanislav Savulchik [(@savulchik)](https://github.com/savulchik)\n  + Konrad Malawski [(@ktoso)](https://github.com/ktoso)\n  + Slim Ouertani [(@ouertani)](https://github.com/ouertani)\n  + Martynas Mickevičius [(@2m)](https://github.com/2m)\n  + Luke Daley [(@ldaley)](https://github.com/ldaley)\n  + Colin Godsey [(@colinrgodsey)](https://github.com/colinrgodsey)\n  + David Moten [(@davidmoten)](https://github.com/davidmoten)\n  + Brian Topping [(@briantopping)](https://github.com/briantopping)\n  + Rossen Stoyanchev [(@rstoyanchev)](https://github.com/rstoyanchev)\n  + Björn Hamels [(@BjornHamels)](https://github.com/BjornHamels)\n  + Jake Wharton [(@JakeWharton)](https://github.com/JakeWharton)\n  + Anthony Vanelverdinghe[(@anthonyvdotbe)](https://github.com/anthonyvdotbe)\n  + Kazuhiro Sera [(@seratch)](https://github.com/seratch)\n  + Dávid Karnok [(@akarnokd)](https://github.com/akarnokd)\n  + Evgeniy Getman [(@egetman)](https://github.com/egetman)\n  + Ángel Sanz [(@angelsanz)](https://github.com/angelsanz)\n  + (new) shenghaiyang [(@shenghaiyang)](https://github.com/shenghaiyang)\n  + (new) Kyle Thomson [(@kiiadi)](https://github.com/kiiadi)\n\n\n---\n\n# Version 1.0.1 released on 2017-08-09\n\n## Announcement: \n\nAfter more than two years since 1.0.0, we are proud to announce the immediate availability of `Reactive Streams version 1.0.1`.\n\nSince 1.0.0 was released `Reactive Streams` has managed to achieve most, if not all, it set out to achieve. There are now numerous implementations, and it is scheduled to be included in [JDK9](http://download.java.net/java/jdk9/docs/api/java/util/concurrent/Flow.html).\n\nAlso, most importantly, there are no semantical incompatibilities included in this release.\n\nWhen JDK9 ships, `Reactive Streams` will publish a compatibility/conversion library to seamlessly convert between the `java.util.concurrent.Flow` and the `org.reactivestreams` namespaces.\n\n## Highlights:\n\n- Specification\n  + A new [Glossary](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#glossary) section\n  + Description of the intent behind every single rule\n  + No breaking semantical changes\n  + Multiple rule [clarifications](#specification-clarifications-1.0.1)\n- Interfaces\n  + No changes\n  + Improved JavaDoc\n- Technology Compatibility Kit (TCK)\n  + Improved coverage\n  + Improved JavaDoc\n  + Multiple test [alterations](#tck-alterations-1.0.1)\n\n## Specification clarifications 1.0.1\n\n## Publisher Rule 1\n\n**1.0.0:** The total number of onNext signals sent by a Publisher to a Subscriber MUST be less than or equal to the total number of elements requested by that Subscriber´s Subscription at all times.\n\n**1.0.1:** The total number of onNext´s signalled by a Publisher to a Subscriber MUST be less than or equal to the total number of elements requested by that Subscriber´s Subscription at all times.\n\n**Comment: Minor spelling update.**\n\n## Publisher Rule 2\n\n**1.0.0:** A Publisher MAY signal less onNext than requested and terminate the Subscription by calling onComplete or onError.\n\n**1.0.1:** A Publisher MAY signal fewer onNext than requested and terminate the Subscription by calling onComplete or onError.\n\n**Comment: Minor spelling update.**\n\n## Publisher Rule 3\n\n**1.0.0:** onSubscribe, onNext, onError and onComplete signaled to a Subscriber MUST be signaled sequentially (no concurrent notifications).\n\n**1.0.1:** onSubscribe, onNext, onError and onComplete signaled to a Subscriber MUST be signaled in a thread-safe manner—and if performed by multiple threads—use external synchronization.\n\n**Comment: Reworded the part about sequential signal and its implications, for clarity.**\n\n## Subscriber Rule 6\n\n**1.0.0:** A Subscriber MUST call Subscription.cancel() if it is no longer valid to the Publisher without the Publisher having signaled onError or onComplete.\n\n**1.0.1:** A Subscriber MUST call Subscription.cancel() if the Subscription is no longer needed.\n\n**Comment: Rule could be reworded since it now has an intent section describing desired effect.**\n\n## Subscriber Rule 11\n\n**1.0.0:** A Subscriber MUST make sure that all calls on its onXXX methods happen-before [1] the processing of the respective signals. I.e. the Subscriber must take care of properly publishing the signal to its processing logic.\n\n**1.0.1:** A Subscriber MUST make sure that all calls on its signal methods happen-before the processing of the respective signals. I.e. the Subscriber must take care of properly publishing the signal to its processing logic.\n\n**Comment: Rule slightly reworded to use the glossary for `signal` instead of the more *ad-hoc* name \"onXXX methods\". Footnote was reworked into the Intent-section of the rule.**\n\n## Subscription Rule 1\n\n**1.0.0:** Subscription.request and Subscription.cancel MUST only be called inside of its Subscriber context. A Subscription represents the unique relationship between a Subscriber and a Publisher [see 2.12].\n\n**1.0.1:** Subscription.request and Subscription.cancel MUST only be called inside of its Subscriber context.\n\n**Comment: Second part of rule moved into the Intent-section of the rule.**\n\n## Subscription Rule 3\n\n**1.0.0:** Subscription.request MUST place an upper bound on possible synchronous recursion between Publisher and Subscriber[1].\n\n**1.0.1:** Subscription.request MUST place an upper bound on possible synchronous recursion between Publisher and Subscriber.\n\n**Comment: Footnote reworked into the Intent-section of the rule.**\n\n## Subscription Rule 4\n\n**1.0.0:** Subscription.request SHOULD respect the responsivity of its caller by returning in a timely manner[2].\n\n**1.0.1:** Subscription.request SHOULD respect the responsivity of its caller by returning in a timely manner.\n\n**Comment: Footnote reworked into the Intent-section of the rule.**\n\n## Subscription Rule 5\n\n**1.0.0:** Subscription.cancel MUST respect the responsivity of its caller by returning in a timely manner[2], MUST be idempotent and MUST be thread-safe.\n\n**1.0.1:** Subscription.cancel MUST respect the responsivity of its caller by returning in a timely manner, MUST be idempotent and MUST be thread-safe.\n\n**Comment: Footnote reworked into the Intent-section of the rule.**\n\n## Subscription Rule 9\n\n**1.0.0:** While the Subscription is not cancelled, Subscription.request(long n) MUST signal onError with a java.lang.IllegalArgumentException if the argument is <= 0. The cause message MUST include a reference to this rule and/or quote the full rule.\n\n**1.0.1:** While the Subscription is not cancelled, Subscription.request(long n) MUST signal onError with a java.lang.IllegalArgumentException if the argument is <= 0. The cause message SHOULD explain that non-positive request signals are illegal.\n\n**Comment: The MUST requirement to include a reference to the rule in the exception message has been dropped, in favor of that the exception message SHOULD explain that non-positive requests are illegal.**\n\n## Subscription Rule 13\n\n**1.0.0:** While the Subscription is not cancelled, Subscription.cancel() MUST request the Publisher to eventually drop any references to the corresponding subscriber. Re-subscribing with the same Subscriber object is discouraged [see 2.12], but this specification does not mandate that it is disallowed since that would mean having to store previously cancelled subscriptions indefinitely.\n\n**1.0.1:** While the Subscription is not cancelled, Subscription.cancel() MUST request the Publisher to eventually drop any references to the corresponding subscriber.\n\n**Comment: Second part of rule reworked into the Intent-section of the rule.**\n\n## Subscription Rule 15\n\n**1.0.0:** Calling Subscription.cancel MUST return normally. The only legal way to signal failure to a Subscriber is via the onError method.\n\n**1.0.1:** Calling Subscription.cancel MUST return normally.\n\n**Comment: Replaced second part of rule with a definition for `return normally` in the glossary.**\n\n## Subscription Rule 16\n\n**1.0.0:** Calling Subscription.request MUST return normally. The only legal way to signal failure to a Subscriber is via the onError method.\n\n**1.0.1:** Calling Subscription.request MUST return normally.\n\n**Comment: Replaced second part of rule with a definition for `return normally` in the glossary.**\n\n## Subscription Rule 17\n\n**1.0.0:** A Subscription MUST support an unbounded number of calls to request and MUST support a demand (sum requested - sum delivered) up to 2^63-1 (java.lang.Long.MAX_VALUE). A demand equal or greater than 2^63-1 (java.lang.Long.MAX_VALUE) MAY be considered by the Publisher as “effectively unbounded”[3].\n\n**1.0.1:** A Subscription MUST support an unbounded number of calls to request and MUST support a demand up to 2^63-1 (java.lang.Long.MAX_VALUE). A demand equal or greater than 2^63-1 (java.lang.Long.MAX_VALUE) MAY be considered by the Publisher as “effectively unbounded”.\n\n**Comment: Rule simplified by defining `demand` in the glossary, and footnote was reworked into the Intent-section of the rule.**\n\n---\n\n## TCK alterations 1.0.1\n\n- Fixed potential resource leaks in partially consuming Publisher tests ([#375](https://github.com/reactive-streams/reactive-streams-jvm/issues/375))\n- Fixed potential resource leaks in partially emitting Subscriber tests ([#372](https://github.com/reactive-streams/reactive-streams-jvm/issues/372), [#373](https://github.com/reactive-streams/reactive-streams-jvm/issues/373))\n- Renamed `untested_spec305_cancelMustNotSynchronouslyPerformHeavyCompuatation` to `untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation` ([#306](https://github.com/reactive-streams/reactive-streams-jvm/issues/306))\n- Allow configuring separate timeout for \"no events during N time\", allowing for more aggressive timeouts in the rest of the test suite if required ([#314](https://github.com/reactive-streams/reactive-streams-jvm/issues/314))\n- New test verifying Rule 2.10, in which subscriber must be prepared to receive onError signal without having signaled request before ([#374](https://github.com/reactive-streams/reactive-streams-jvm/issues/374))\n- The verification of Rule 3.9 has been split up into 2 different tests, one to verify that an IllegalArgumentException is sent, and the other an optional check to verify that the exception message informs that non-positive request signals are illegal.\n---\n\n## Contributors\n  + Roland Kuhn [(@rkuhn)](https://github.com/rkuhn)\n  + Ben Christensen [(@benjchristensen)](https://github.com/benjchristensen)\n  + Viktor Klang [(@viktorklang)](https://github.com/viktorklang)\n  + Stephane Maldini [(@smaldini)](https://github.com/smaldini)\n  + Stanislav Savulchik [(@savulchik)](https://github.com/savulchik)\n  + Konrad Malawski [(@ktoso)](https://github.com/ktoso)\n  + Slim Ouertani [(@ouertani)](https://github.com/ouertani)\n  + Martynas Mickevičius [(@2m)](https://github.com/2m)\n  + Luke Daley [(@ldaley)](https://github.com/ldaley)\n  + Colin Godsey [(@colinrgodsey)](https://github.com/colinrgodsey)\n  + David Moten [(@davidmoten)](https://github.com/davidmoten)\n  + (new) Brian Topping [(@briantopping)](https://github.com/briantopping)\n  + (new) Rossen Stoyanchev [(@rstoyanchev)](https://github.com/rstoyanchev)\n  + (new) Björn Hamels [(@BjornHamels)](https://github.com/BjornHamels)\n  + (new) Jake Wharton [(@JakeWharton)](https://github.com/JakeWharton)\n  + (new) Anthony Vanelverdinghe[(@anthonyvdotbe)](https://github.com/anthonyvdotbe)\n  + (new) Kazuhiro Sera [(@seratch)](https://github.com/seratch)\n  + (new) Dávid Karnok [(@akarnokd)](https://github.com/akarnokd)\n  + (new) Evgeniy Getman [(@egetman)](https://github.com/egetman)\n  + (new) Ángel Sanz [(@angelsanz)](https://github.com/angelsanz)\n"
        },
        {
          "name": "Relicensing.txt",
          "type": "blob",
          "size": 2.2138671875,
          "content": "The following copyright holders agree that all of their contributions originally submitted to this project under Creative Commons\nZero 1.0 Universal (SPDX: CC0-1.0) license are hereby relicensed to MIT No Attribution (SPDX: MIT-0) license, and are submitted pursuant to the Developer Certificate of Origin, version 1.1:\n\n\ngithub name    | Real Name, Email Address used for git commits, Company\n---------------+----------------------------------------------------------------------------\nviktorklang    | Viktor Klang, viktor.klang@gmail.com, Lightbend Inc.\nsavulchik      | Stanislav Savulchik, s.savulchik@gmail.com\nakarnokd       | David Karnok, akarnokd@gmail.com\nOlegDokuka     | Oleh Dokuka,  oleh.dokuka@icloud.com,\n2m             | Martynas Mickevičius, self@2m.lt, Argyle Inc.\nrkuhn          | Dr. Roland Kuhn, dr.roland.kuhn@gmail.com, Actyx AG\nanthonyvdotbe  | Anthony Vanelverdinghe, dev@anthonyv.be\nangelsanz      | Ángel Sanz, angelsanz@users.noreply.github.com\nshenghaiyang   | 盛海洋, shenghaiyang@aliyun.com\ncolinrgodsey   | Colin Godsey, crgodsey@gmail.com\npatriknw       | Patrik Nordwall, patrik.nordwall@gmail.com, Lightbend Inc\nretronym       | Jason Zaugg, jzaugg@gmail.com, Lightbend Inc.\nldaley         | Luke Daley, luke@gradle.com, Gradle Inc.\ndavidmoten     | Dave Moten, davidmoten@gmail.com\ntomislavhofman | Tomislav Hofman, tomislav.hofman@gmail.com\nrstoyanchev    | Rossen Stoyanchev, rstoyanchev@vmware.com, VMware\nouertani       | Slim Ouertani, ouertani@gmail.com\negetman        | Evgeniy Getman, getman.eugene@gmail.com\nktoso          | Konrad Malawski, konrad.malawski@project13.pl\nsullis         | Sean Sullivan, github@seansullivan.com\njroper         | James Roper, james@jazzy.id.au, Lightbend Inc.\nsmaldini       | Stephane Maldini, smaldini@netflix.com, Netflix\ndl             | Doug Lea dl@cs.oswego.edu\nbenjchristensen| Ben Christensen, benjchristensen@gmail.com\nbjornhamels    | Björn Hamels, bjorn@hamels.nl\nScottmitch     | Scott Mitchell, scott_mitchell@apple.com\nseratch        | Kazuhiro Sera, seratch@gmail.com\nbriantopping   | Brian Topping, brian.topping@gmail.com, Mauswerks LLC\nJakeWharton    | Jake Wharton, jakewharton@gmail.com, Square Inc.\nkiiadi         | Kyle Thomson, kylthoms@amazon.com, Amazon.com\n"
        },
        {
          "name": "api",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.gradle",
          "type": "blob",
          "size": 4.865234375,
          "content": "buildscript {\n    repositories { \n        jcenter()\n        mavenCentral()\n        maven {\n            url \"https://plugins.gradle.org/m2/\"\n        }\n    }\n    dependencies {\n        classpath \"biz.aQute.bnd:biz.aQute.bnd.gradle:4.3.1\"\n    }\n}\n\nsubprojects {\n    apply plugin: \"java-library\"\n    apply plugin: 'biz.aQute.bnd.builder'\n\n    group = \"org.reactivestreams\"\n    version = \"1.0.4\"\n\n    sourceCompatibility = 1.6\n    targetCompatibility = 1.6\n\n    tasks.withType(JavaCompile) {\n        configure(options) {\n            compilerArgs << \"-Xlint:unchecked\" << \"-Xlint:deprecation\"\n            encoding = \"UTF-8\"\n        }\n    }\n\n    tasks.withType(Javadoc) {\n        configure(options) {\n            encoding \"UTF-8\"\n            docEncoding \"UTF-8\"\n            charSet \"UTF-8\"\n            linkSource true\n            noTimestamp true\n        }\n    }\n\n    tasks.withType(Test) {\n      testLogging {\n        exceptionFormat \"full\"\n        events \"failed\", \"started\", \"standard_out\", \"standard_error\"\n      }\n    }\n\n    repositories {\n        mavenCentral()\n    }\n\n    if (name in [\"reactive-streams\",\n                 \"reactive-streams-tck\",\n                 \"reactive-streams-tck-flow\",\n                 \"reactive-streams-examples\"]) {\n        apply plugin: \"maven\"\n        apply plugin: \"signing\"\n        apply plugin: \"maven-publish\"\n\n        signing {\n            sign configurations.archives\n            required { gradle.taskGraph.hasTask(uploadArchives) }\n        }\n        task sourcesJar(type: Jar) {\n            classifier \"sources\"\n            from sourceSets.main.allSource\n        }\n\n        task javadocJar(type: Jar) {\n            classifier \"javadoc\"\n            from javadoc\n        }\n\n        publishing {\n          publications {\n            mavenJava(MavenPublication) {\n              from components.java\n            }\n          }\n          repositories {\n            mavenLocal()\n          }\n        }\n\n        artifacts {\n            archives sourcesJar, javadocJar\n        }\n\n        uploadArchives {\n            repositories {\n                mavenDeployer {\n                    gradle.taskGraph.whenReady { taskGraph ->\n                        if (taskGraph.hasTask(uploadArchives)) {\n                            def userProp = \"sonatypeOssUsername\"\n                            def passwordProp = \"sonatypeOssPassword\"\n                            def user = project.properties[userProp]\n                            def password = project.properties[passwordProp]\n\n                            if (user == null || password == null) {\n                                throw new InvalidUserDataException(\n                                        \"Cannot perform $uploadArchives.path due to missing credentials.\\n\" +\n                                        \"Run with command line args `-P$userProp=«username» -P$passwordProp=«password»` or add these properties to $gradle.gradleUserHomeDir/gradle.properties.\\n\")\n                            }\n\n                            repository(url: \"https://oss.sonatype.org/service/local/staging/deploy/maven2/\") {\n                                authentication(userName: user, password: password)\n                            }\n                            snapshotRepository(url: \"https://oss.sonatype.org/content/repositories/snapshots/\") {\n                                authentication(userName: user, password: password)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        tasks.withType(Upload) {\n            repositories.withType(MavenResolver) {\n                it.beforeDeployment { signing.signPom(it) }\n                it.pom.whenConfigured { pom ->\n                    pom.project {\n                        url \"http://www.reactive-streams.org/\"\n                        name \"reactive-streams\"\n                        description \"A Protocol for Asynchronous Non-Blocking Data Sequence\"\n                        inceptionYear \"2014\"\n\n                        scm {\n                            url \"git@github.com:reactive-streams/reactive-streams.git\"\n                            connection \"scm:git:git@github.com:reactive-streams/reactive-streams.git\"\n                        }\n\n                        licenses {\n                            license {\n                                name \"MIT-0\"\n                                url \"https://spdx.org/licenses/MIT-0.html\"\n                                distribution \"repo\"\n                            }\n                        }\n\n                        developers {\n                            developer {\n                                id \"reactive-streams-sig\"\n                                name \"Reactive Streams SIG\"\n                                url \"http://www.reactive-streams.org/\"\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        uploadArchives.enabled = false\n    }\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradle",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradlew",
          "type": "blob",
          "size": 5.171875,
          "content": "#!/usr/bin/env sh\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG=\"$0\"\n# Need this for relative symlinks.\nwhile [ -h \"$PRG\" ] ; do\n    ls=`ls -ld \"$PRG\"`\n    link=`expr \"$ls\" : '.*-> \\(.*\\)$'`\n    if expr \"$link\" : '/.*' > /dev/null; then\n        PRG=\"$link\"\n    else\n        PRG=`dirname \"$PRG\"`\"/$link\"\n    fi\ndone\nSAVED=\"`pwd`\"\ncd \"`dirname \\\"$PRG\\\"`/\" >/dev/null\nAPP_HOME=\"`pwd -P`\"\ncd \"$SAVED\" >/dev/null\n\nAPP_NAME=\"Gradle\"\nAPP_BASE_NAME=`basename \"$0\"`\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\"\"\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD=\"maximum\"\n\nwarn () {\n    echo \"$*\"\n}\n\ndie () {\n    echo\n    echo \"$*\"\n    echo\n    exit 1\n}\n\n# OS specific support (must be 'true' or 'false').\ncygwin=false\nmsys=false\ndarwin=false\nnonstop=false\ncase \"`uname`\" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\n  NONSTOP* )\n    nonstop=true\n    ;;\nesac\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n \"$JAVA_HOME\" ] ; then\n    if [ -x \"$JAVA_HOME/jre/sh/java\" ] ; then\n        # IBM's JDK on AIX uses strange locations for the executables\n        JAVACMD=\"$JAVA_HOME/jre/sh/java\"\n    else\n        JAVACMD=\"$JAVA_HOME/bin/java\"\n    fi\n    if [ ! -x \"$JAVACMD\" ] ; then\n        die \"ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\n    fi\nelse\n    JAVACMD=\"java\"\n    which java >/dev/null 2>&1 || die \"ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ \"$cygwin\" = \"false\" -a \"$darwin\" = \"false\" -a \"$nonstop\" = \"false\" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ \"$MAX_FD\" = \"maximum\" -o \"$MAX_FD\" = \"max\" ] ; then\n            MAX_FD=\"$MAX_FD_LIMIT\"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn \"Could not set maximum file descriptor limit: $MAX_FD\"\n        fi\n    else\n        warn \"Could not query maximum file descriptor limit: $MAX_FD_LIMIT\"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS=\"$GRADLE_OPTS \\\"-Xdock:name=$APP_NAME\\\" \\\"-Xdock:icon=$APP_HOME/media/gradle.icns\\\"\"\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed \"$APP_HOME\"`\n    CLASSPATH=`cygpath --path --mixed \"$CLASSPATH\"`\n    JAVACMD=`cygpath --unix \"$JAVACMD\"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=\"\"\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS=\"$ROOTDIRS$SEP$dir\"\n        SEP=\"|\"\n    done\n    OURCYGPATTERN=\"(^($ROOTDIRS))\"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ \"$GRADLE_CYGPATTERN\" != \"\" ] ; then\n        OURCYGPATTERN=\"$OURCYGPATTERN|($GRADLE_CYGPATTERN)\"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in \"$@\" ; do\n        CHECK=`echo \"$arg\"|egrep -c \"$OURCYGPATTERN\" -`\n        CHECK2=`echo \"$arg\"|egrep -c \"^-\"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed \"$arg\"`\n        else\n            eval `echo args$i`=\"\\\"$arg\\\"\"\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- \"$args0\" ;;\n        (2) set -- \"$args0\" \"$args1\" ;;\n        (3) set -- \"$args0\" \"$args1\" \"$args2\" ;;\n        (4) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" ;;\n        (5) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" ;;\n        (6) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" ;;\n        (7) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" ;;\n        (8) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" ;;\n        (9) set -- \"$args0\" \"$args1\" \"$args2\" \"$args3\" \"$args4\" \"$args5\" \"$args6\" \"$args7\" \"$args8\" ;;\n    esac\nfi\n\n# Escape application args\nsave () {\n    for i do printf %s\\\\n \"$i\" | sed \"s/'/'\\\\\\\\''/g;1s/^/'/;\\$s/\\$/' \\\\\\\\/\" ; done\n    echo \" \"\n}\nAPP_ARGS=$(save \"$@\")\n\n# Collect all arguments for the java command, following the shell quoting and substitution rules\neval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS \"\\\"-Dorg.gradle.appname=$APP_BASE_NAME\\\"\" -classpath \"\\\"$CLASSPATH\\\"\" org.gradle.wrapper.GradleWrapperMain \"$APP_ARGS\"\n\n# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong\nif [ \"$(uname)\" = \"Darwin\" ] && [ \"$HOME\" = \"$PWD\" ]; then\n  cd \"$(dirname \"$0\")\"\nfi\n\nexec \"$JAVACMD\" \"$@\"\n"
        },
        {
          "name": "gradlew.bat",
          "type": "blob",
          "size": 2.20703125,
          "content": "@if \"%DEBUG%\" == \"\" @echo off\r\n@rem ##########################################################################\r\n@rem\r\n@rem  Gradle startup script for Windows\r\n@rem\r\n@rem ##########################################################################\r\n\r\n@rem Set local scope for the variables with windows NT shell\r\nif \"%OS%\"==\"Windows_NT\" setlocal\r\n\r\nset DIRNAME=%~dp0\r\nif \"%DIRNAME%\" == \"\" set DIRNAME=.\r\nset APP_BASE_NAME=%~n0\r\nset APP_HOME=%DIRNAME%\r\n\r\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\r\nset DEFAULT_JVM_OPTS=\r\n\r\n@rem Find java.exe\r\nif defined JAVA_HOME goto findJavaFromJavaHome\r\n\r\nset JAVA_EXE=java.exe\r\n%JAVA_EXE% -version >NUL 2>&1\r\nif \"%ERRORLEVEL%\" == \"0\" goto init\r\n\r\necho.\r\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\r\necho.\r\necho Please set the JAVA_HOME variable in your environment to match the\r\necho location of your Java installation.\r\n\r\ngoto fail\r\n\r\n:findJavaFromJavaHome\r\nset JAVA_HOME=%JAVA_HOME:\"=%\r\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\r\n\r\nif exist \"%JAVA_EXE%\" goto init\r\n\r\necho.\r\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\r\necho.\r\necho Please set the JAVA_HOME variable in your environment to match the\r\necho location of your Java installation.\r\n\r\ngoto fail\r\n\r\n:init\r\n@rem Get command-line arguments, handling Windows variants\r\n\r\nif not \"%OS%\" == \"Windows_NT\" goto win9xME_args\r\n\r\n:win9xME_args\r\n@rem Slurp the command line arguments.\r\nset CMD_LINE_ARGS=\r\nset _SKIP=2\r\n\r\n:win9xME_args_slurp\r\nif \"x%~1\" == \"x\" goto execute\r\n\r\nset CMD_LINE_ARGS=%*\r\n\r\n:execute\r\n@rem Setup the command line\r\n\r\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\r\n\r\n@rem Execute Gradle\r\n\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\r\n\r\n:end\r\n@rem End local scope for the variables with windows NT shell\r\nif \"%ERRORLEVEL%\"==\"0\" goto mainEnd\r\n\r\n:fail\r\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\r\nrem the _cmd.exe /c_ return code!\r\nif  not \"\" == \"%GRADLE_EXIT_CONSOLE%\" exit 1\r\nexit /b 1\r\n\r\n:mainEnd\r\nif \"%OS%\"==\"Windows_NT\" endlocal\r\n\r\n:omega\r\n"
        },
        {
          "name": "settings.gradle",
          "type": "blob",
          "size": 1.638671875,
          "content": "rootProject.name = 'reactive-streams'\n\ndef jdkFlow = false\n\nfinal def ANSI_RESET = \"\\u001B[0m\"\nfinal def ANSI_RED = \"\\u001B[31m\"\nfinal def ANSI_GREEN = \"\\u001B[32m\"\nfinal def ANSI_YELLOW = \"\\u001B[33m\"\n\ntry {\n    Class.forName(\"java.util.concurrent.Flow\")\n    jdkFlow = true\n    println(ANSI_GREEN + \"   INFO: ------------------ JDK9 classes detected ---------------------------------\" + ANSI_RESET)\n    println(ANSI_GREEN + \"   INFO: Java 9 Flow API found; Including [tck-flow] & FlowAdapters in build.      \" + ANSI_RESET)\n    println(ANSI_GREEN + \"   INFO: --------------------------------------------------------------------------\" + ANSI_RESET)\n} catch (Throwable ex) {\n    // Flow API not available\n    println(ANSI_RED + \"WARNING: -------------------- JDK9 classes NOT detected -----------------------------\" + ANSI_RESET)\n    println(ANSI_RED + \"WARNING: Java 9 Flow API not found; Not including [tck-flow] & FlowAdapters in build.\" + ANSI_RESET)\n    println(ANSI_RED + \"WARNING: In order to execute the complete test-suite run the build using JDK9+.      \" + ANSI_RESET)\n    println(ANSI_RED + \"WARNING: ----------------------------------------------------------------------------\" + ANSI_RESET)\n}\n\ninclude ':reactive-streams'\ninclude ':reactive-streams-tck'\ninclude ':reactive-streams-examples'\n\nif (jdkFlow) {\n    include ':reactive-streams-tck-flow'\n}\n\nproject(':reactive-streams').projectDir = \"$rootDir/api\" as File\nproject(':reactive-streams-tck').projectDir = \"$rootDir/tck\" as File\nproject(':reactive-streams-examples').projectDir = \"$rootDir/examples\" as File\nif (jdkFlow) {\n    project(':reactive-streams-tck-flow').projectDir = \"$rootDir/tck-flow\" as File\n}\n"
        },
        {
          "name": "tck-flow",
          "type": "tree",
          "content": null
        },
        {
          "name": "tck",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}