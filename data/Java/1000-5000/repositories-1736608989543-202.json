{
  "metadata": {
    "timestamp": 1736608989543,
    "page": 202,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Snailclimb/guide-rpc-framework",
      "stars": 4035,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.4248046875,
          "content": "/.idea/\n/target/\n/rpc-framework-simple/target/\n/rpc-framework-common/target/\n/hello-service-api/target/\n/example-server/target/\n/example-client/target/\n/example-server/example-server.iml\n/example-client/example-client.iml\n/guide-rpc-framework.iml\n/rpc-framework-simple/rpc-framework-simple.iml\n/rpc-framework-common/rpc-framework-common.iml\n/hello-service-api/hello-service-api.iml\n\n/.settings\n*/.settings\n.classpath\n.project\n.DS_Store"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 9.1298828125,
          "content": "                     木兰宽松许可证, 第1版\r\n\r\n   木兰宽松许可证， 第1版\r\n   2019年8月 http://license.coscl.org.cn/MulanPSL\r\n\r\n   您对“软件”的复制、使用、修改及分发受木兰宽松许可证，第1版（“本许可证”）的如下条款的约束：\r\n\r\n   0. 定义\r\n\r\n      “软件”是指由“贡献”构成的许可在“本许可证”下的程序和相关文档的集合。\r\n\r\n      “贡献者”是指将受版权法保护的作品许可在“本许可证”下的自然人或“法人实体”。\r\n\r\n      “法人实体”是指提交贡献的机构及其“关联实体”。\r\n\r\n      “关联实体”是指，对“本许可证”下的一方而言，控制、受控制或与其共同受控制的机构，此处的控制是指有受控方或共同受控方至少50%直接或间接的投票权、资金或其他有价证券。\r\n\r\n      “贡献”是指由任一“贡献者”许可在“本许可证”下的受版权法保护的作品。\r\n\r\n   1. 授予版权许可\r\n\r\n      每个“贡献者”根据“本许可证”授予您永久性的、全球性的、免费的、非独占的、不可撤销的版权许可，您可以复制、使用、修改、分发其“贡献”，不论修改与否。\r\n\r\n   2. 授予专利许可\r\n\r\n      每个“贡献者”根据“本许可证”授予您永久性的、全球性的、免费的、非独占的、不可撤销的（根据本条规定撤销除外）专利许可，供您制造、委托制造、使用、许诺销售、销售、进口其“贡献”或以其他方式转移其“贡献”。前述专利许可仅限于“贡献者”现在或将来拥有或控制的其“贡献”本身或其“贡献”与许可“贡献”时的“软件”结合而将必然会侵犯的专利权利要求，不包括仅因您或他人修改“贡献”或其他结合而将必然会侵犯到的专利权利要求。如您或您的“关联实体”直接或间接地（包括通过代理、专利被许可人或受让人），就“软件”或其中的“贡献”对任何人发起专利侵权诉讼（包括反诉或交叉诉讼）或其他专利维权行动，指控其侵犯专利权，则“本许可证”授予您对“软件”的专利许可自您提起诉讼或发起维权行动之日终止。\r\n\r\n   3. 无商标许可\r\n\r\n      “本许可证”不提供对“贡献者”的商品名称、商标、服务标志或产品名称的商标许可，但您为满足第4条规定的声明义务而必须使用除外。\r\n\r\n   4. 分发限制\r\n\r\n      您可以在任何媒介中将“软件”以源程序形式或可执行形式重新分发，不论修改与否，但您必须向接收者提供“本许可证”的副本，并保留“软件”中的版权、商标、专利及免责声明。\r\n\r\n   5. 免责声明与责任限制\r\n\r\n      “软件”及其中的“贡献”在提供时不带任何明示或默示的担保。在任何情况下，“贡献者”或版权所有者不对任何人因使用“软件”或其中的“贡献”而引发的任何直接或间接损失承担责任，不论因何种原因导致或者基于何种法律理论,即使其曾被建议有此种损失的可能性。\r\n\r\n   条款结束。\r\n\r\n   如何将木兰宽松许可证，第1版，应用到您的软件\r\n\r\n   如果您希望将木兰宽松许可证，第1版，应用到您的新软件，为了方便接收者查阅，建议您完成如下三步：\r\n\r\n      1， 请您补充如下声明中的空白，包括软件名、软件的首次发表年份以及您作为版权人的名字；\r\n\r\n      2， 请您在软件包的一级目录下创建以“LICENSE”为名的文件，将整个许可证文本放入该文件中；\r\n\r\n      3， 请将如下声明文本放入每个源文件的头部注释中。\r\n\r\n   Copyright (c) [2019] [name of copyright holder]\r\n   [Software Name] is licensed under the Mulan PSL v1.\r\n   You can use this software according to the terms and conditions of the Mulan PSL v1.\r\n   You may obtain a copy of Mulan PSL v1 at:\r\n      http://license.coscl.org.cn/MulanPSL\r\n   THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR\r\n   PURPOSE.\r\n   See the Mulan PSL v1 for more details.\r\n\r\n\r\n                     Mulan Permissive Software License，Version 1\r\n\r\n   Mulan Permissive Software License，Version 1 (Mulan PSL v1)\r\n   August 2019 http://license.coscl.org.cn/MulanPSL\r\n\r\n   Your reproduction, use, modification and distribution of the Software shall be subject to Mulan PSL v1 (this License) with following terms and conditions:\r\n\r\n   0. Definition\r\n\r\n      Software means the program and related documents which are comprised of those Contribution and licensed under this License.\r\n\r\n      Contributor means the Individual or Legal Entity who licenses its copyrightable work under this License.\r\n\r\n      Legal Entity means the entity making a Contribution and all its Affiliates.\r\n\r\n      Affiliates means entities that control, or are controlled by, or are under common control with a party to this License, ‘control’ means direct or indirect ownership of at least fifty percent (50%) of the voting power, capital or other securities of controlled or commonly controlled entity.\r\n\r\n   Contribution means the copyrightable work licensed by a particular Contributor under this License.\r\n\r\n   1. Grant of Copyright License\r\n\r\n      Subject to the terms and conditions of this License, each Contributor hereby grants to you a perpetual, worldwide, royalty-free, non-exclusive, irrevocable copyright license to reproduce, use, modify, or distribute its Contribution, with modification or not.\r\n\r\n   2. Grant of Patent License\r\n\r\n      Subject to the terms and conditions of this License, each Contributor hereby grants to you a perpetual, worldwide, royalty-free, non-exclusive, irrevocable (except for revocation under this Section) patent license to make, have made, use, offer for sale, sell, import or otherwise transfer its Contribution where such patent license is only limited to the patent claims owned or controlled by such Contributor now or in future which will be necessarily infringed by its Contribution alone, or by combination of the Contribution with the Software to which the Contribution was contributed, excluding of any patent claims solely be infringed by your or others’ modification or other combinations. If you or your Affiliates directly or indirectly (including through an agent, patent licensee or assignee）, institute patent litigation (including a cross claim or counterclaim in a litigation) or other patent enforcement activities against any individual or entity by alleging that the Software or any Contribution in it infringes patents, then any patent license granted to you under this License for the Software shall terminate as of the date such litigation or activity is filed or taken.\r\n\r\n   3. No Trademark License\r\n\r\n      No trademark license is granted to use the trade names, trademarks, service marks, or product names of Contributor, except as required to fulfill notice requirements in section 4.\r\n\r\n   4. Distribution Restriction\r\n\r\n      You may distribute the Software in any medium with or without modification, whether in source or executable forms, provided that you provide recipients with a copy of this License and retain copyright, patent, trademark and disclaimer statements in the Software.\r\n\r\n   5. Disclaimer of Warranty and Limitation of Liability\r\n\r\n      The Software and Contribution in it are provided without warranties of any kind, either express or implied. In no event shall any Contributor or copyright holder be liable to you for any damages, including, but not limited to any direct, or indirect, special or consequential damages arising from your use or inability to use the Software or the Contribution in it, no matter how it’s caused or based on which legal theory, even if advised of the possibility of such damages.\r\n\r\n   End of the Terms and Conditions\r\n\r\n   How to apply the Mulan Permissive Software License，Version 1 (Mulan PSL v1) to your software\r\n\r\n      To apply the Mulan PSL v1 to your work, for easy identification by recipients, you are suggested to complete following three steps:\r\n\r\n      i. Fill in the blanks in following statement, including insert your software name, the year of the first publication of your software, and your name identified as the copyright owner;\r\n      ii. Create a file named “LICENSE” which contains the whole context of this License in the first directory of your software package;\r\n      iii. Attach the statement to the appropriate annotated syntax at the beginning of each source file.\r\n   \r\n   Copyright (c) [2019] [name of copyright holder]\r\n   [Software Name] is licensed under the Mulan PSL v1.\r\n   You can use this software according to the terms and conditions of the Mulan PSL v1.\r\n   You may obtain a copy of Mulan PSL v1 at:\r\n      http://license.coscl.org.cn/MulanPSL\r\n   THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR\r\n   PURPOSE.\r\n   \r\n   See the Mulan PSL v1 for more details.\r\n"
        },
        {
          "name": "README-EN.md",
          "type": "blob",
          "size": 9.9306640625,
          "content": "# guide-rpc-framework\n\n[中文](./README.md)|English\n\nSorry, I did not fully translate the Chinese readme. I have translated the important parts. You can translate the rest by yourself through Google.\n\n## Preface\n\nAlthough the principle of RPC is not difficult, I encountered many problems in the process of implementation. [guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework)  implements only the most basic features of the RPC framework, and some of the optimizations are mentioned below for those interested.\n\nWith this simple wheel, you can learn the underlying principles and principles of RPC  framework as well as various Java coding practices.\n\nYou can even use the  [guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework)  as a choice for your graduation/project experience, which is very great! Compared to other job seekers whose project experience is based on a variety of systems, building wheels is a sure way to win an interviewer's favor.\n\nIf you're going to use the  [guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework)  as your graduation/project experience, I want you to understand it rather than just copy and paste my ideas. You can fork my project and then optimize it. If you think the optimization is valuable, you can submit PR to me, and I will deal with it as soon as possible.\n\n##  Introduction\n\n [guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) is an RPC framework based on Netty+Kyro+Zookeeper. Detailed code comments, clear structure, and integrated Check Style specification code structure make it ideal for reading and learning.\n\nDue to the limited energy and ability of me, if you think there is something to be improved and perfected, welcome to fork this project, then clone it to local, and submit PR to me after local modification, I will Review your code as soon as possible.\n\nLet's start with a basic RPC framework design idea!\n\n> **note** ：The RPC framework we mentioned here refers to a framework that allows clients to directly call server-side methods as simple as calling local methods, similar to the Dubbo, Motan, and gRPC I introduced earlier. If you need to deal with the HTTP protocol, parse and encapsulate HTTP requests and responses. Type frameworks are not considered \"RPC frameworks\", such as Feign.\n\nA schematic diagram of the simplest RPC framework usage is shown in the figure below, which is also the current architecture of [guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework):\n\n![](./images/rpc-architure.png)\n\nThe service provider Server registers the service with the registry, and the service consumer Client gets the service-related information through the registry, and then requests the service provider Server through the network.\n\nAs a leader in the field of RPC framework [Dubbo](https://github.com/apache/dubbo), the architecture is shown in the figure below, which is roughly the same as what we drew above.\n\n<img src=\"./images/dubbo-architure.jpg\" style=\"zoom:80%;\" />\n\n**Under normal circumstances, the RPC framework must not only provide service discovery functions, but also provide load balancing, fault tolerance and other functions. Such an RPC framework is truly qualified. ** \n\n**Please let me simply talk about the idea of designing a most basic RPC framework:**\n\n![](./images/rpc-architure-detail.png)\n\n1. **Registration Center**: The registration center is required first, and Zookeeper is recommended. The registration center is responsible for the registration and search of service addresses, which is equivalent to a directory service. When the server starts, the service name and its corresponding address (ip+port) are registered in the registry, and the service consumer finds the corresponding service address according to the service name. With the service address, the service consumer can request the server through the network.\n2. **Network Transmission**: Since you want to call a remote method, you must send a request. The request must at least include the class name, method name, and related parameters you call! Recommend the Netty framework based on NIO.\n3. **Serialization**: Since network transmission is involved, serialization must be involved. You can't directly use the serialization that comes with JDK! The serialization that comes with the JDK is inefficient and has security vulnerabilities. Therefore, you have to consider which serialization protocol to use. The more commonly used ones are hession2, kyro, and protostuff.\n4. **Dynamic Proxy**: In addition, a dynamic proxy is also required. Because the main purpose of RPC is to allow us to call remote methods as easy as calling local methods, the use of dynamic proxy can shield the details of remote method calls such as network transmission. That is to say, when you call a remote method, the network request will actually be transmitted through the proxy object. Otherwise, how could it be possible to call the remote method directly?\n2. **Load Balancing**: Load balancing is also required. Why? For example, a certain service in our system has very high traffic. We deploy this service on multiple servers. When a client initiates a request, multiple servers can handle the request. Then, how to correctly select the server that processes the request is critical. If you need one server to handle requests for the service, the meaning of deploying the service on multiple servers no longer exists. Load balancing is to avoid a single server responding to the same request, which is likely to cause server downtime, crashes and other problems. We can clearly feel its meaning from the four words of load balancing.\n\n## Run the project\n\n### Import the project\n\nFork the project to your own repository, then clone the project to its own locale: `git clone git@github.com:username/guide-rpc-framework.git`  use java IDE such as IDEA to open and wait for the project initialization to complete.\n\n### Initialize git hooks\n\n**This step is mainly to run Check Style before submitting the code to ensure that the code format is correct. If there is a problem, it cannot be submitted. **\n\n>The following demonstrates the operation corresponding to Mac/Linux. Window users need to manually copy the `pre-commit` file under the `config/git-hooks` directory to the `.git/hooks/` directory under the project.\n\nExecute these commands:\n\n```bash\n➜guide-rpc-framework git: (master)✗chmod + x ./init.sh\n➜guide-rpc-framework git: (master)✗./init.sh\n```\n\nThe main function of the `init.sh` script is to copy the git commit hook to the `.git/hooks/` directory under the project so that it will be executed every time you commit.\n\n### CheckStyle plug-in download and configuration\n\nIntelliJ IDEA-> Preferences->Plugins-> search to download CheckStyle plug-in, and then configure it as follows.\n\n![CheckStyle plug-in download and configuration](./images/setting-check-style.png)\n\nAfter the configuration is complete, use this plugin as follows!\n\n![How to use the plug-in](./images/run-check-style.png)\n\n### Download and run zookeeper\n\nDocker is used here to download and install.\n\ndownload:\n\n```shell\ndocker pull zookeeper:3.5.8\n```\n\n运行：\n\n```shell\ndocker run -d --name zookeeper -p 2181:2181 zookeeper:3.5.8\n```\n\n## Use\n\n### Server(service provider)\n\nImplementing the interface：\n\n```java\n@Slf4j\n@RpcService(group = \"test1\", version = \"version1\")\npublic class HelloServiceImpl implements HelloService {\n    static {\n        System.out.println(\"HelloServiceImpl被创建\");\n    }\n\n    @Override\n    public String hello(Hello hello) {\n        log.info(\"HelloServiceImpl收到: {}.\", hello.getMessage());\n        String result = \"Hello description is \" + hello.getDescription();\n        log.info(\"HelloServiceImpl返回: {}.\", result);\n        return result;\n    }\n}\n\t\n@Slf4j\npublic class HelloServiceImpl2 implements HelloService {\n\n    static {\n        System.out.println(\"HelloServiceImpl2被创建\");\n    }\n\n    @Override\n    public String hello(Hello hello) {\n        log.info(\"HelloServiceImpl2收到: {}.\", hello.getMessage());\n        String result = \"Hello description is \" + hello.getDescription();\n        log.info(\"HelloServiceImpl2返回: {}.\", result);\n        return result;\n    }\n}\n```\n\nPublish services (transport using Netty) :\n\n```java\n/**\n * Server: Automatic registration service via @RpcService annotation\n *\n * @author shuang.kou\n * @createTime 2020年05月10日 07:25:00\n */\n@RpcScan(basePackage = {\"github.javaguide.serviceimpl\"})\npublic class NettyServerMain {\n    public static void main(String[] args) {\n        // Register service via annotation\n        new AnnotationConfigApplicationContext(NettyServerMain.class);\n        NettyServer nettyServer = new NettyServer();\n        // Register service manually\n        HelloService helloService2 = new HelloServiceImpl2();\n        RpcServiceProperties rpcServiceConfig = RpcServiceProperties.builder()\n                .group(\"test2\").version(\"version2\").build();\n        nettyServer.registerService(helloService2, rpcServiceConfig);\n        nettyServer.start();\n    }\n}\n```\n\n### Client(srvice consumer)\n\n\n```java\n@Component\npublic class HelloController {\n\n    @RpcReference(version = \"version1\", group = \"test1\")\n    private HelloService helloService;\n\n    public void test() throws InterruptedException {\n        String hello = this.helloService.hello(new Hello(\"111\", \"222\"));\n        //如需使用 assert 断言，需要在 VM options 添加参数：-ea\n        assert \"Hello description is 222\".equals(hello);\n        Thread.sleep(12000);\n        for (int i = 0; i < 10; i++) {\n            System.out.println(helloService.hello(new Hello(\"111\", \"222\")));\n        }\n    }\n}\n```\n\n```java\nClientTransport rpcRequestTransport = new SocketRpcClient();\nRpcServiceProperties rpcServiceConfig = RpcServiceProperties.builder()\n        .group(\"test2\").version(\"version2\").build();\nRpcClientProxy rpcClientProxy = new RpcClientProxy(rpcRequestTransport, rpcServiceConfig);\nHelloService helloService = rpcClientProxy.getProxy(HelloService.class);\nString hello = helloService.hello(new Hello(\"111\", \"222\"));\nSystem.out.println(hello);\n```"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.3447265625,
          "content": "# guide-rpc-framework\n\n> [该 RPC 框架配套教程已经更新在我的星球，点击此链接了解详情。](https://javaguide.cn/zhuanlan/handwritten-rpc-framework.html)\n\n<div align=\"center\">\n  <p> 中文| <a href=\"./README-EN.md\">English</a>\n  </p>\n  <p>\n    <a href=\"https://github.com/Snailclimb/guide-rpc-framework\">Github</a> | <a href=\"https://gitee.com/SnailClimb/guide-rpc-framework \">Gitee</a>\n  </p>\n</div>\n\n## 前言\n\n虽说 RPC 的原理实际不难，但是，自己在实现的过程中自己也遇到了很多问题。[guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 目前只实现了 RPC 框架最基本的功能，一些可优化点都在下面提到了，有兴趣的小伙伴可以自行完善。\n\n通过这个简易的轮子，你可以学到 RPC 的底层原理和原理以及各种 Java 编码实践的运用。\n\n你甚至可以把 [guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 当做你的毕设/项目经验的选择，这是非常不错！对比其他求职者的项目经验都是各种系统，造轮子肯定是更加能赢得面试官的青睐。\n\n如果你要将 [guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 当做你的毕设/项目经验的话，我希望你一定要搞懂，而不是直接复制粘贴我的思想。你可以 fork 我的项目，然后进行优化。如果你觉得的优化是有价值的话，你可以提交 PR 给我，我会尽快处理。\n\n## 介绍\n\n [guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 是一款基于 Netty+Kyro+Zookeeper 实现的 RPC 框架。代码注释详细，结构清晰，并且集成了 Check Style 规范代码结构，非常适合阅读和学习。\n\n由于 Guide哥自身精力和能力有限，如果大家觉得有需要改进和完善的地方的话，欢迎 fork 本项目，然后 clone 到本地，在本地修改后提交 PR 给我，我会在第一时间 Review 你的代码。\n\n**我们先从一个基本的 RPC 框架设计思路说起！**\n\n### 一个基本的 RPC 框架设计思路\n\n> **注意** ：我们这里说的 RPC 框架指的是：可以让客户端直接调用服务端方法就像调用本地方法一样简单的框架，比如我前面介绍的 Dubbo、Motan、gRPC 这些。 如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如 Feign。\n\n一个最简单的 RPC 框架使用示意图如下图所示,这也是 [guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 目前的架构 ：\n\n![](./images/rpc-architure.png)\n\n服务提供端 Server 向注册中心注册服务，服务消费者 Client 通过注册中心拿到服务相关信息，然后再通过网络请求服务提供端 Server。\n\n作为 RPC 框架领域的佼佼者[Dubbo](https://github.com/apache/dubbo)的架构如下图所示,和我们上面画的大体也是差不多的。\n\n<img src=\"./images/dubbo-architure.jpg\" style=\"zoom:80%;\" />\n\n**一般情况下， RPC 框架不仅要提供服务发现功能，还要提供负载均衡、容错等功能，这样的 RPC 框架才算真正合格的。**\n\n**简单说一下设计一个最基本的 RPC 框架的思路：**\n\n![](./images/rpc-architure-detail.png)\n\n1. **注册中心** ：注册中心首先是要有的，推荐使用 Zookeeper。注册中心负责服务地址的注册与查找，相当于目录服务。服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。\n2. **网络传输** ：既然要调用远程的方法就要发请求，请求中至少要包含你调用的类名、方法名以及相关参数吧！推荐基于 NIO 的 Netty 框架。\n3. **序列化** ：既然涉及到网络传输就一定涉及到序列化，你不可能直接使用 JDK 自带的序列化吧！JDK 自带的序列化效率低并且有安全漏洞。 所以，你还要考虑使用哪种序列化协议，比较常用的有 hession2、kyro、protostuff。\n4. **动态代理** ： 另外，动态代理也是需要的。因为 RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，使用动态代理可以屏蔽远程方法调用的细节比如网络传输。也就是说当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法呢？\n5. **负载均衡** ：负载均衡也是需要的。为啥？举个例子我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。\n6. ......\n\n### 项目基本情况和可优化点\n\n为了循序渐进，最初的是时候，我是基于传统的 **BIO** 的方式 **Socket** 进行网络传输，然后利用 **JDK 自带的序列化机制** 来实现这个 RPC 框架的。后面，我对原始版本进行了优化，已完成的优化点和可以完成的优化点我都列在了下面 👇。\n\n**为什么要把可优化点列出来？** 主要是想给哪些希望优化这个 RPC 框架的小伙伴一点思路。欢迎大家 fork 本仓库，然后自己进行优化。\n\n- [x] **使用 Netty（基于 NIO）替代 BIO 实现网络传输；**\n- [x] **使用开源的序列化机制 Kyro（也可以用其它的）替代 JDK 自带的序列化机制；**\n- [x] **使用 Zookeeper 管理相关服务地址信息**\n- [x] Netty 重用 Channel 避免重复连接服务端\n- [x] 使用 `CompletableFuture` 包装接受客户端返回结果（之前的实现是通过 `AttributeMap` 绑定到 Channel 上实现的） 详见：[使用 CompletableFuture 优化接受服务提供端返回结果](./docs/使用CompletableFuture优化接受服务提供端返回结果.md)\n- [x] **增加 Netty 心跳机制** : 保证客户端和服务端的连接不被断掉，避免重连。\n- [x] **客户端调用远程服务的时候进行负载均衡** ：调用服务的时候，从很多服务地址中根据相应的负载均衡算法选取一个服务地址。ps：目前实现了随机负载均衡算法与一致性哈希算法。\n- [x] **处理一个接口有多个类实现的情况** ：对服务分组，发布服务的时候增加一个 group 参数即可。\n- [x] **集成 Spring 通过注解注册服务**\n- [x] **集成 Spring 通过注解进行服务消费** 。参考： [PR#10](https://github.com/Snailclimb/guide-rpc-framework/pull/10)\n- [x] **增加服务版本号** ：建议使用两位数字版本，如：1.0，通常在接口不兼容时版本号才需要升级。为什么要增加服务版本号？为后续不兼容升级提供可能，比如服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。\n- [x] **对 SPI 机制的运用** \n- [ ] **增加可配置比如序列化方式、注册中心的实现方式,避免硬编码** ：通过 API 配置，后续集成 Spring 的话建议使用配置文件的方式进行配置\n- [x] **客户端与服务端通信协议（数据包结构）重新设计** ，可以将原有的 `RpcRequest`和 `RpcRequest` 对象作为消息体，然后增加如下字段（可以参考：《Netty 入门实战小册》和 Dubbo 框架对这块的设计）：\n  - **魔数** ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。\n  - **序列化器编号** ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化方式。\n  - **消息体长度** ： 运行时计算出来。\n  - ......\n- [ ] **编写测试为重构代码提供信心**\n- [ ] **服务监控中心（类似dubbo admin）**\n- [x] **设置 gzip 压缩**\n\n### 项目模块概览\n\n![](./images/RPC框架各个模块介绍.png)\n\n## 运行项目\n\n### 导入项目\n\nfork 项目到自己的仓库，然后克隆项目到自己的本地：`git clone git@github.com:username/guide-rpc-framework.git`，使用 IDEA 打开，等待项目初始化完成。\n\n### 初始化 git hooks\n\n**这一步主要是为了在 commit 代码之前，跑 Check Style，保证代码格式没问题，如果有问题的话就不能提交。**\n\n> 以下演示的是 Mac/Linux 对应的操作，Window 用户需要手动将 `config/git-hooks` 目录下的`pre-commit` 文件拷贝到 项目下的 `.git/hooks/` 目录。\n\n执行下面这些命令：\n\n```shell\n➜  guide-rpc-framework git:(master) ✗ chmod +x ./init.sh\n➜  guide-rpc-framework git:(master) ✗ ./init.sh\n```\n\n`init.sh` 这个脚本的主要作用是将 git commit 钩子拷贝到项目下的 `.git/hooks/` 目录，这样你每次 commit 的时候就会执行了。\n\n### CheckStyle 插件下载和配置\n\n`IntelliJ IDEA-> Preferences->Plugins->搜索下载 CheckStyle 插件`，然后按照如下方式进行配置。\n\n![CheckStyle 插件下载和配置](./images/setting-check-style.png)\n\n配置完成之后，按照如下方式使用这个插件！\n\n![插件使用方式](./images/run-check-style.png)\n\n### 下载运行 zookeeper\n\n这里使用 Docker 来下载安装。\n\n下载：\n\n```shell\ndocker pull zookeeper:3.5.8\n```\n\n运行：\n\n```shell\ndocker run -d --name zookeeper -p 2181:2181 zookeeper:3.5.8\n```\n\n## 使用\n\n### 服务提供端\n\n实现接口：\n\n```java\n@Slf4j\n@RpcService(group = \"test1\", version = \"version1\")\npublic class HelloServiceImpl implements HelloService {\n    static {\n        System.out.println(\"HelloServiceImpl被创建\");\n    }\n\n    @Override\n    public String hello(Hello hello) {\n        log.info(\"HelloServiceImpl收到: {}.\", hello.getMessage());\n        String result = \"Hello description is \" + hello.getDescription();\n        log.info(\"HelloServiceImpl返回: {}.\", result);\n        return result;\n    }\n}\n\t\n@Slf4j\npublic class HelloServiceImpl2 implements HelloService {\n\n    static {\n        System.out.println(\"HelloServiceImpl2被创建\");\n    }\n\n    @Override\n    public String hello(Hello hello) {\n        log.info(\"HelloServiceImpl2收到: {}.\", hello.getMessage());\n        String result = \"Hello description is \" + hello.getDescription();\n        log.info(\"HelloServiceImpl2返回: {}.\", result);\n        return result;\n    }\n}\n```\n\n发布服务(使用 Netty 进行传输)：\n\n```java\n/**\n * Server: Automatic registration service via @RpcService annotation\n *\n * @author shuang.kou\n * @createTime 2020年05月10日 07:25:00\n */\n@RpcScan(basePackage = {\"github.javaguide.serviceimpl\"})\npublic class NettyServerMain {\n    public static void main(String[] args) {\n        // Register service via annotation\n        new AnnotationConfigApplicationContext(NettyServerMain.class);\n        NettyServer nettyServer = new NettyServer();\n        // Register service manually\n        HelloService helloService2 = new HelloServiceImpl2();\n        RpcServiceProperties rpcServiceConfig = RpcServiceProperties.builder()\n                .group(\"test2\").version(\"version2\").build();\n        nettyServer.registerService(helloService2, rpcServiceConfig);\n        nettyServer.start();\n    }\n}\n```\n\n### 服务消费端\n\n```java\n@Component\npublic class HelloController {\n\n    @RpcReference(version = \"version1\", group = \"test1\")\n    private HelloService helloService;\n\n    public void test() throws InterruptedException {\n        String hello = this.helloService.hello(new Hello(\"111\", \"222\"));\n        //如需使用 assert 断言，需要在 VM options 添加参数：-ea\n        assert \"Hello description is 222\".equals(hello);\n        Thread.sleep(12000);\n        for (int i = 0; i < 10; i++) {\n            System.out.println(helloService.hello(new Hello(\"111\", \"222\")));\n        }\n    }\n}\n```\n\n```java\nClientTransport rpcRequestTransport = new SocketRpcClient();\nRpcServiceProperties rpcServiceConfig = RpcServiceProperties.builder()\n        .group(\"test2\").version(\"version2\").build();\nRpcClientProxy rpcClientProxy = new RpcClientProxy(rpcRequestTransport, rpcServiceConfig);\nHelloService helloService = rpcClientProxy.getProxy(HelloService.class);\nString hello = helloService.hello(new Hello(\"111\", \"222\"));\nSystem.out.println(hello);\n```\n\n## 相关问题\n\n### 为什么要造这个轮子？Dubbo 不香么？\n\n写这个 RPC 框架主要是为了通过造轮子的方式来学习，检验自己对于自己所掌握的知识的运用。\n\n实现一个简单的 RPC 框架实际是比较容易的，不过，相比于手写 AOP 和 IoC 还是要难一点点，前提是你搞懂了 RPC 的基本原理。\n\n我之前从理论层面在我的知识星球分享过如何实现一个 RPC。不过理论层面的东西只是支撑，你看懂了理论可能只能糊弄住面试官。咱程序员这一行还是最需要动手能力，即使你是架构师级别的人物。当你动手去实践某个东西，将理论付诸实践的时候，你就会发现有很多坑等着你。\n\n大家在实际项目上还是要尽量少造轮子，有优秀的框架之后尽量就去用，Dubbo 在各个方面做的都比较好和完善。\n\n### 如果我要自己写的话，需要提前了解哪些知识\n\n**Java** ：\n\n1. 动态代理机制；\n2. 序列化机制以及各种序列化框架的对比，比如 hession2、kyro、protostuff。\n3. 线程池的使用；\n4. `CompletableFuture` 的使用\n5. ......\n\n**Netty** ：\n\n1. 使用 Netty 进行网络传输；\n2. `ByteBuf` 介绍\n3. Netty 粘包拆包\n4. Netty 长连接和心跳机制\n\n**Zookeeper** :\n\n1. 基本概念；\n2. 数据结构；\n3. 如何使用 Netflix 公司开源的 zookeeper 客户端框架 Curator 进行增删改查；\n\n## 教程\n\nGuide 的星球正在更新《从零开始手把手教你实现一个简单的 RPC 框架》。扫描下方二维码关注“**JavaGuide**”后回复 “**星球**”即可。\n\n![我的公众号](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/167598cd2e17b8ec.png)\n\n"
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "example-client",
          "type": "tree",
          "content": null
        },
        {
          "name": "example-server",
          "type": "tree",
          "content": null
        },
        {
          "name": "hello-service-api",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "init.sh",
          "type": "blob",
          "size": 0.072265625,
          "content": "cp config/git-hooks/pre-commit .git/hooks/\nchmod +x .git/hooks/pre-commit\n"
        },
        {
          "name": "pom.xml",
          "type": "blob",
          "size": 4.4228515625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>github.javaguide</groupId>\n    <artifactId>guide-rpc-framework</artifactId>\n    <packaging>pom</packaging>\n    <version>1.0-SNAPSHOT</version>\n    <properties>\n        <encoding>UTF-8</encoding>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n        <netty.version>4.1.42.Final</netty.version>\n        <kryo.version>4.0.2</kryo.version>\n        <guava.version>30.1.1-jre</guava.version>\n        <checkstyle-maven-plugin.version>3.1.1</checkstyle-maven-plugin.version>\n        <spring.version>5.2.7.RELEASE</spring.version>\n        <curator-version>4.2.0</curator-version>\n        <!-- test -->\n        <junit.jupiter.version>5.5.2</junit.jupiter.version>\n        <junit.platform.version>1.5.2</junit.platform.version>\n        <!--logging-->\n        <slf4j.version>1.7.25</slf4j.version>\n        <!-- protostuff -->\n        <protostuff.version>1.7.2</protostuff.version>\n        <!--hessian-->\n        <hessian.version>4.0.65</hessian.version>\n    </properties>\n    <modules>\n        <module>rpc-framework-simple</module>\n        <module>hello-service-api</module>\n        <module>example-client</module>\n        <module>example-server</module>\n        <module>rpc-framework-common</module>\n    </modules>\n    <dependencies>\n        <!-- lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.8</version>\n            <scope>provided</scope>\n        </dependency>\n        <!-- guava -->\n        <dependency>\n            <groupId>com.google.guava</groupId>\n            <artifactId>guava</artifactId>\n            <version>${guava.version}</version>\n        </dependency>\n        <!-- log -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>${slf4j.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-simple</artifactId>\n            <version>${slf4j.version}</version>\n        </dependency>\n        <!-- test -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter-engine</artifactId>\n            <version>${junit.jupiter.version}</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.junit.platform</groupId>\n            <artifactId>junit-platform-runner</artifactId>\n            <version>${junit.platform.version}</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.8.1</version>\n                <configuration>\n                    <source>${maven.compiler.source}</source>\n                    <target>${maven.compiler.target}</target>\n                    <encoding>${encoding}</encoding>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-checkstyle-plugin</artifactId>\n                <version>${checkstyle-maven-plugin.version}</version>\n                <configuration>\n                    <configLocation>config/checkstyle.xml</configLocation>\n                </configuration>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>check</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n    <reporting>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-checkstyle-plugin</artifactId>\n                <version>${checkstyle-maven-plugin.version}</version>\n                <configuration>\n                    <configLocation>checkstyle.xml</configLocation>\n                </configuration>\n            </plugin>\n        </plugins>\n    </reporting>\n</project>\n"
        },
        {
          "name": "rpc-framework-common",
          "type": "tree",
          "content": null
        },
        {
          "name": "rpc-framework-simple",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}