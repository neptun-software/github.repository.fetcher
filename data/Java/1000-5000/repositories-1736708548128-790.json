{
  "metadata": {
    "timestamp": 1736708548128,
    "page": 790,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lxy-go/SpringBoot",
      "stars": 2503,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.548828125,
          "content": "由于github下载太慢，所以大家可以在码云下载~  https://gitee.com/lixiyan4633/SpringBoot\n# SpringBoot\n## 这是一个B站的SpringBoot的从入门程序集锦\n\n     终于，终于，把这块骨头给啃了，B站上是16小时的教程，我看了整整10天，哈哈，有点笨，因为我是真的菜，必须一点点看，不会的还得倒回去在看，而且边看边记录文档，反反复复，感觉这辈子都看不完的感觉了，哈哈，不过老师讲的真的好，我没有理由放弃，这个文档是我纯手敲的，看了下21796个字，妈的，比毕业论文还多，没错，我这个文档感觉绝对比老师的多，有很多我的血的教训，虽然一路磕磕碰碰，但是也侥幸过来了。为努力的自己点个赞\n     \n     路过的同学，虽然知道你们主要是来拿文档的，但是能不能看在我这种傻傻的黄牛精神点个**star**或**Fork**,谢谢  各位大佬 \n     \n     哈哈，希望大家一起进步！！！\n     \n     > ps:文档中的图片，需要把对应的图片下载下来【springBoot上--images | springBoot下--images2】，下载后把图片路径名更改成你电脑中图片的路径，建议用编译器，搜索替换全部 \n     \n     **SpringBoot高级功能书写中。。。**\n     \n     已完成\n     \n     - ElasticSearch 全文检索\n     - SpringCould 分布式管理\n     - RabbitMQ中间件\n     - Cache缓存\n\n## 我是法律小白，我自己照着写的文档，如果侵权的话，请给我发邮箱告知一下lixiyan4633@163.com \n"
        },
        {
          "name": "SpringBoot",
          "type": "tree",
          "content": null
        },
        {
          "name": "SpringBoot2",
          "type": "tree",
          "content": null
        },
        {
          "name": "SpringBoot入门简介.md",
          "type": "blob",
          "size": 146.3974609375,
          "content": "# 一、Spring Boot入门\n\n## 1、Spring Boot简介\n\nSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。\n\n## 2、微服务\n\n微服务：架构风格（服务微化）\n\n一个应用应该是一组小型服务，可以通过HTTP的方式进行互通\n\n单体应用：ALL IN ONE\n\n微服务：每个功能元素最终都是一个可以独立替换和升级的软件单元\n\n## 3、环境准备\n\n环境约束\n\n- jdk1.8\n- maven 3.x :maven3.3以上\n- IDEA2017\n- SpringBoot 1.5.9RELEASE\n\n### 1、MAVEN设置\n\n```xml\n<!-- 配置JDK版本 -->\n<profile>    \n    <id>jdk18</id>    \n    <activation>    \n        <activeByDefault>true</activeByDefault>    \n        <jdk>1.8</jdk>    \n    </activation>    \n    <properties>    \n        <maven.compiler.source>1.8</maven.compiler.source>    \n        <maven.compiler.target>1.8</maven.compiler.target>    \n        <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>    \n    </properties>     \n</profile>\n   <!-- 当 nexus-aliyun 下不了的包，或许这个镜像能下，\n        才开放它，这个实在太慢，而且要把它放在首位，即 nexus-aliyun 之前，做过测试。\n        所以它的用途只有那么一瞬间，就是或许它能下载，可以通过 url 去查找确定一下\n    -->\n    <!-- <mirror>\n        <id>spring-libs-milestone</id>\n        <mirrorOf>central</mirrorOf>\n        <name>Spring Milestones</name>\n        <url>http://repo.spring.io/libs-milestone</url>\n    </mirror> -->\n\n    <!-- nexus-aliyun 首选，放第一位,有不能下载的包，再去做其他镜像的选择  -->\n    <mirror>\n        <id>nexus-aliyun</id>\n        <mirrorOf>central</mirrorOf>\n        <name>Nexus aliyun</name>\n        <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n    </mirror>\n\n    <!-- 备选镜像，也是可以通过 url 去查找确定一下，\n        该镜像是否含有你想要的包，它比 spring-libs-milestone 快  -->\n    <mirror>\n        <id>central-repository</id>\n        <mirrorOf>*</mirrorOf>\n        typor<name>Central Repository</name>\n        <url>http://central.maven.org/maven2/</url>\n    </mirror>  \n```\n\n### 2、IDEA设置\n\n​    配置IDEA的Maven，指定Setting的Maven目录和MAVEN的setting.xml文件\n\n​\t快捷键：\n\n​\tCtrl+D 复制一行\n\n​\tCtrl+Y 删除一行\n\n​\tCtrl+P 参数提示\n\n​\tCtrl+Alt+V 自动补齐方法\n\n​\tCtrl+N 查找类方法\n\n​\tAlt+Ins 构造器、getter/setter toString\n\n​\tCtrl+O 重载方法提示\n\n​\tAlt+Enter 提示导入类etc\n\n​\tShift+F6 :文件重命名\n\n## 4、Spring Boot的Hello World\n\n### 1、创建一个Maven工程\n\n\n\n### 2、导入Spring Boot的相关依赖\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.0.1.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n</parent>\n\n<properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n    <java.version>1.8</java.version>\n</properties>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n\n```\n\n### 3、编写个主程序\n\n```java\n@SpringBootApplication\npublic class SpringBoot01HelloQuickApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBoot01HelloQuickApplication.class, args);\n    }\n}\n```\n\n### 4、编写相应的Controller和Service\n\n```java\n@Controller\npublic class HelloController {\n\n    @ResponseBody\n    @RequestMapping(\"/hello\")\n    public  String  hello(){\n        return \"hello world\";\n    }\n}\n```\n\n### 5、运行主程序测试\n\n访问 localhost:8080/hello\n\n### 6、简化部署\n\n在pom.xml文件中，导入build插件\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n\n## 5、HelloWorld深度理解\n\n### 1.POM.xml文件\n\n#### 1、父项目\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.0.1.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n</parent>\n```\n\n这个父项目**spring-boot-starter-parent**又依赖一个父项目\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.0.1.RELEASE</version>\n    <relativePath>../../spring-boot-dependencies</relativePath>\n</parent>\n```\n\n下面有个属性，定义了对应的版本号\n\n```xml\n<properties>\n    <activemq.version>5.15.3</activemq.version>\n    <antlr2.version>2.7.7</antlr2.version>\n    <appengine-sdk.version>1.9.63</appengine-sdk.version>\n    <artemis.version>2.4.0</artemis.version>\n    <aspectj.version>1.8.13</aspectj.version>\n    <assertj.version>3.9.1</assertj.version>\n    <atomikos.version>4.0.6</atomikos.version>\n    <bitronix.version>2.1.4</bitronix.version>\n    <build-helper-maven-plugin.version>3.0.0</build-helper-maven-plugin.version>\n    。。。。。。。\n```\n\nSpring Boot的版本仲裁中心 会自动导入对应的版本，不需要我们自己导入依赖，没有dependencies里面管理的依赖自己声明\n\n#### 2、启动器\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n**spring-boot-starter-web:**帮我们导入web模块正常运行所依赖的组件\n\n**spring boot**将所有的功能场景都抽取出来，做成一个个的starter(启动器)，只需要在项目里引入这些starter相关场景的所有依赖都会被导入进来，要用什么功能就导入什么场景的启动器。\n\n### 2、主程序入口\n\n```java\n@SpringBootApplication\npublic class SpringBoot01HelloQuickApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBoot01HelloQuickApplication.class, args);\n    }\n}\n```\n\n**@SpringBootApplication:** 说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动应用\n\n进入SpringBootApplication注解\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters = {@Filter(\n    type = FilterType.CUSTOM,\n    classes = {TypeExcludeFilter.class}\n), @Filter(\n    type = FilterType.CUSTOM,\n    classes = {AutoConfigurationExcludeFilter.class}\n)}\n)\npublic @interface SpringBootApplication {\n```\n\n**@SpringBootConfiguration**：SpringBoot的配置类： 标准在某个类上，表示这是一个SpringBoot的配置类\n\n**@Configuration**:配置类上，来标注这个注解；\n配置类 ---- 配置文件，也是容器中的一个组件（@Component）\n**@EnableAutoConfiguration**:开启自动配置功能\n以前需要自动配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动\n配置功能；这样自动配置才能生效。 \n\n```java\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration { \n```\n\n**@AutoConfigurationPackage**:自动配置包\n**@Import({Registrar.class})**：底层注解，给容器导入组件；\n将主配置类（@SpringBootApplication标注的类）的所在包及下面所有的子包里面的所有组件扫描到Spring容器； \n\n**@Import({AutoConfigurationImportSelector.class})：**\n给容器导入组件？ \n\nAutoConfigurationImportSelector：导入组件选择器 \n\n将所有需要导入的组件以及全类名的方式返回；这些组件将以字符串数组 String[] 添加到容器中；\n\n会给容器非常多的自动配置类，（xxxAutoConfiguration）;就是给容器中导入这个场景需要的所有组件，并配置\n好这些组件。 \n\n![1.configuration](E:\\工作文档\\SpringBoot\\images\\1.configuration.jpg)\n\n```java\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata,\nAnnotationAttributes attributes) {\n\tList<String> configurations =\nSpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(),\nthis.getBeanClassLoader());\n\tAssert.notEmpty(configurations, \"No auto configuration classes found in META‐INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\");\n\treturn configurations;\n} \n```\n\n`SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(),`\n`this.getBeanClassLoader());` \n\nSpring Boot在启动的时候从类路径下的META-INF/spring.factorys中获取的EnableAutoConfiguration指定的值；\n\n将这些值作为自动配置类导入到容器中，自动配置就生效了。 ![2.factories](E:\\工作文档\\SpringBoot\\images\\2.factories.jpg)\n\nJ2EE的整体解决方案\n\norg\\springframework\\boot\\spring-boot-autoconfigure\\2.0.1.RELEASE\\spring-boot-autoconfigure-2.0.1.RELEASE.jar \n\n## 6、使用Spring Initializer创建一个快速向导 \n\n1.IDE支持使用Spring Initializer\n\n自己选择需要的组件:例如web\n\n默认生成的SpringBoot项目 \n\n- 主程序已经生成好了，我们只需要完成我们的逻辑\n\n\n- resources文件夹目录结构\n\n  - static:保存所有的静态文件；js css images\n\n  - templates:保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat,默认不支持JSP）；可\n\n    以使用模板引擎（freemarker.thymeleaf）;\n\n  - application.properties:Spring Boot的默认配置，例如 server.port=9000 \n\n# 二、配置文件 \n\n## 1、配置文件 \n\nSpring Boot使用全局配置文件，配置文件名是固定的；\n\n- application.properties\n- application.yml \n\n配置文件作用：修改Spring Boot在底层封装好的默认值；\n\nYAML（YAML AIN'T Markup Language）\n\n是一个标记语言\n\n又不是一个标记语言 \n\n**标记语言：**\n\n以前的配置文件；大多数使用的是 xxx.xml文件；\n\n以数据为中心，比json、xml等更适合做配置文件\n\nYAML：配置例子 \n\n```yaml\nserver:\n\tport: 9000 \n```\n\nXML: \n\n```xml\n<server>\n\t<port>9000</port>\n</server> \n```\n\n## 2、YAML语法 \n\n### 1、基本语法 \n\nk:(空格)v:表示一堆键值对（空格必须有）；\n\n以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一层级的 \n\n```yaml\nserver:\n\tport: 9000\n\tpath: /hello \n```\n\n属性和值也是大小写敏感 \n\n### 2、值的写法\n\n**字面量：普通的值（数字，字符串，布尔）** \n\nk: v:字面直接来写；\n\n字符串默认不用加上单引号或者双引号\n\n\"\":**双引号** 不会转义字符串里的特殊字符；特殊字符会作为本身想要表示的意思\n\n`name:\"zhangsan\\n lisi\"` 输出：`zhangsan换行 lisi`\n\n'':**单引号** 会转义特殊字符，特殊字符最终只是一个普通的字符串数据\n\n`name:'zhangsan\\n lisi'` 输出：`zhangsan\\n lisi` \n\n**对象、Map（属性和值）键值对** \n\nk :v ：在下一行来写对象的属性和值的关系；注意空格控制缩进\n\n对象还是k:v的方式 \n\n```yaml\nfrends:\n\tlastName: zhangsan\n\tage: 20 \n```\n\n行内写法 \n\n```yaml\nfriends: {lastName: zhangsan,age: 18} \n```\n\n**数组（List、Set）:**\n用-表示数组中的一个元素 \n\n```yaml\npets:\n ‐ cat\n ‐ dog\n ‐ pig \n```\n\n行内写法 \n\n```yaml\npets: [cat,dog,pig] \n```\n\n**组合变量**\n\n多个组合到一起 \n\n## 3、配置文件值注入 \n\n### 1、@ConfigurationProperties\n\n1、application.yml 配置文件 \n\n```yaml\nperson:\n  age: 18\n  boss: false\n  birth: 2017/12/12\n  maps: {k1: v1,k2: 12}\n  lists:\n   - lisi\n   - zhaoliu\n  dog:\n    name: wangwang\n    age: 2\n  last-name: wanghuahua\n```\n\n`application.properties` 配置文件（二选一） \n\n```properties\nidea配置文件utf-8\nproperties 默认GBK\nperson.age=12\nperson.boss=false\nperson.last-name=张三\nperson.maps.k1=v1\nperson.maps.k2=v2\nperson.lists=a,b,c\nperson.dog.name=wanghuahu\nperson.dog.age=15\n```\n\n所以中文输出乱码，改进settings-->file encoding -->[property-->utf-8 ,勾选转成ascii] \n\njavaBean \n\n```java\n/**\n* 将配置文件的配置每个属性的值，映射到组件中\n* @ConfigurationProperties:告诉SpringBoot将文本的所有属性和配置文件中的相关配置进行绑定；\n* prefix = \"person\" 配置文件爱你的那个属性进行一一映射\n* *\n只有这个组件是容器中的组件，才能提供到容器中\n*/\n@Component\n@ConfigurationProperties(prefix = \"person\")\npublic class Person {\n    private String lastName;\n    private Integer age;\n    private Boolean boss;\n    private Map<String,Object> maps;\n    private List<Object> lists;\n    private Dog dog;\n```\n\n导入配置文件处理器，以后编写配置就有提示了 \n\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring‐boot‐configuration‐processor</artifactId>\n\t<optional>true</optional>\n</dependency> \n```\n### 2、@Value注解\n\n更改javaBean中的注解\n\n```java\n@Component\npublic class Person {\n    /**\n     * <bean class=\"Person\">\n     *     <property name=\"lastName\" value=\"字面量/${key}从环境变量/#{spEL}\"></property>\n     * </bean>\n     */\n    @Value(\"${person.last-name}\")\n    private String lastName;\n    @Value(\"#{11*2}\")\n    private Integer age;\n    @Value(\"true\")\n    private Boolean boss;\n```\n\n|          | @ConfigurationProperties | @Value |\n| :------: | :----------------------: | :----: |\n|    功能    |        批量注入配置文件属性        |  单个指定  |\n| 松散绑定(语法) |            支持            |  不支持   |\n|   spEL   |           不支持            |   支持   |\n| JSR303校验 |            支持            |  不支持   |\n|   复杂类型   |            支持            |  不支持   |\n\n> 松散语法：javaBean中last-name(或者lastName) -->application.properties中的last-name;\n>\n> spEL语法：#{11*2} \n>\n> JSR303：@Value会直接忽略，校验规则\n\nJSR303校验：\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"person\")\n@Validated\npublic class Person {\n    @Email\n    private String lastName;\n```\n\n复杂类型栗子：\n\n```java\n@Component\npublic class Person {\n    /**\n     * <bean class=\"Person\">\n     *     <property name=\"lastName\" value=\"字面量/${key}从环境变量/#{spEL}\"></property>\n     * </bean>\n     */\n    private String lastName;\n    private Integer age;\n    private Boolean boss;\n   // @Value(\"${person.maps}\")\n    private Map<String,Object> maps;\n```\n\n以上会报错，不支持复杂类型\n\n**使用场景分析**\n\n​\t如果说，我们只是在某个业务逻辑中获取一下配置文件的某一项值，使用@Value；\n\n如果专门编写了一个javaBean和配置文件进行映射，我们直接使用@ConfigurationProperties\n\n举栗子：\n\n1、编写新的Controller文件\n\n```java\n@RestController\npublic class HelloController {\n\n    @Value(\"${person.last-name}\")\n    private String name;\n    @RequestMapping(\"/hello\")\n    public  String sayHello(){\n        return \"Hello\"+ name;\n    }\n}\n```\n\n2、配置文件\n\n```properties\nperson.age=12\nperson.boss=false\nperson.last-name=李四\nperson.maps.k1=v1\nperson.maps.k2=v2\nperson.lists=a,b,c\nperson.dog.name=wanghuahu\nperson.dog.age=15\n```\n\n3、测试运行\n\n访问 localhost:9000/hello\n\n结果为`Hello 李四`\n\n### 3、其他注解\n **@PropertySource**\n\n作用：加载指定的properties配置文件\n\n1、新建一个person.properties文件\n\n```properties\nperson.age=12\nperson.boss=false\nperson.last-name=李四\nperson.maps.k1=v1\nperson.maps.k2=v2\nperson.lists=a,b,c\nperson.dog.name=wanghuahu\nperson.dog.age=15\n```\n\n2、在javaBean中加入@PropertySource注解\n\n```java\n@PropertySource(value = {\"classpath:person.properties\"})\n@Component\n@ConfigurationProperties(prefix = \"person\")\npublic class Person {\n    private String lastName;\n```\n\n**@ImportResource**\n\n作用：导入Spring配置文件，并且让这个配置文件生效\n\n1、新建一个Spring的配置文件，bean.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"HelloService\" class=\"com.wdjr.springboot.service.HelloService\"></bean>\n</beans>\n```\n\n2、编写测试类，检查容器是否加载Spring配置文件写的bean\n\n```java\n@Autowired\nApplicationContext ioc;\n\n@Test\npublic void testHelloService(){\n    boolean b = ioc.containsBean(\"HelloService\");\n    System.out.println(b);\n}\n```\n\n> import org.springframework.context.ApplicationContext;\n\n3、运行检测\n\n结果为false，没有加载配置的内容\n\n4、使用@ImportResource注解\n\n将@ImportResource标注在主配置类上\n\n```java\n@ImportResource(locations={\"classpath:beans.xml\"})\n@SpringBootApplication\npublic class SpringBoot02ConfigApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBoot02ConfigApplication.class, args);\n    }\n}\n```\n\n5、再次运行检测\n\n结果为true\n\n缺点：每次指定xml文件太麻烦\n\nSpringBoot推荐给容器添加组件的方式：\n\n1、配置类=====Spring的xml配置文件（old）\n\n2、全注解方式@Configuration+@Bean（new）\n\n![4.MyAppConfig](E:\\工作文档\\SpringBoot\\images\\4.MyAppConfig.jpg)\n\n\n\n```java\n/**\n * @Configuration：指明当前类是一个配置类；就是来代替之前的Spring配置文件\n *\n * 在配置文件中用<bean></bean>标签添加组件\n */\n\n@Configuration\npublic class MyAppConfig {\n\n    //将方法的返回值添加到容器中；容器这个组件id就是方法名\n    @Bean\n    public HelloService helloService01(){\n        System.out.println(\"配置类给容器添加了HelloService组件\");\n        return new HelloService();\n    }\n}\n```\n\n```java\n@Autowired\nApplicationContext ioc;\n\n@Test\npublic void testHelloService(){\n    boolean b = ioc.containsBean(\"helloService01\");\n    System.out.println(b);\n}\n```\n\n *容器这个组件id就是方法名* \n\n## 4、配置文件占位符\n\n#### 1、随机数\n\n```properties\n${random.value} 、${random.int}、${random.long}\n${random.int(10)}、${random.int[100,200]}\n```\n\n#### 2、获取配置值\n\n```properties\nperson.age=${random.int}\nperson.boss=false\nperson.last-name=张三${random.uuid}\nperson.maps.k1=v1\nperson.maps.k2=v2\nperson.lists=a,b,c\nperson.dog.name=${person.last-name}'s wanghuahu\nperson.dog.age=15\n```\n\n存在以下两种情况\n\n没有声明`person.last-name`会报错，新声明的需要加默认值\n\n```properties\nperson.age=${random.int}\nperson.boss=false\nperson.last-name=张三${random.uuid}\nperson.maps.k1=v1\nperson.maps.k2=v2\nperson.lists=a,b,c\nperson.dog.name=${person.hello:hello}'s wanghuahu\nperson.dog.age=15\n```\n\n结果：输出`hello's wanghuahua`\n\n## 5、Profile\n\n### 1、多Profile文件\n\n我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml\n\n- application.properties\n- application-dev.properties\n- application-prod.properties\n\n默认使用application.properties\n\napplication.properties配置文件指定\n\n```properties\nspring.profiles.active=dev\n```\n\n### 2、YAML文档块\n\n```yaml\nserver:\n  port: 8081\nspring:\n  profiles:\n    active: dev\n\n---\n\nserver:\n  port: 9000\nspring:\n  profiles: dev\n\n---\nserver:\n  port: 80\nspring:\n  profiles: prod\n\n```\n\n### 3、激活指定profile\n\n1、在配置文件中激活\n\n2、命令行：\n\n--spring.profiles.active=dev\n\n![5.comandLine](E:\\工作文档\\SpringBoot\\images\\5.comandLine.jpg)\n\n优先级大于配置文件\n\n打包 成jar后\n\n`java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev`\n\n虚拟机参数\n\n`-Dspring.profiles.active=dev`\n\n## 6、加载配置文件位置\n\nSpringBoot启动扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件\n\n- file:./config/\n- file./\n- classpath:/config/\n- classpath:/\n\n优先级从高到低顺序，高优先级会覆盖低优先级的相同配置；互补配置\n\n也可以通过spring.config.location来改变默认配置\n\n> ```\n> server.servlet.context-path=/boot03\n> ```\n\n注：spring boot1x 是server.context.path=/boot02\n\n\n\n![7.priority](E:\\工作文档\\SpringBoot\\images\\7.priority.jpg)\n\n还可以通过spring.config.location来改变配置文件的位置\n\n项目打包好了以后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认的配置文件会共同起作用，互补配置\n\n`java -jar spring-boot-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=E:/work/application.properties`\n\n运维比较有用，从外部加载，不用修改别的文件\n\n## 7.引入外部配置\n\n**SpringBoot也可以从以下位置加载配置；优先级从高到低；高优先级覆盖低优先级，可以互补**\n\n1. 命令行参数\n\n   java -jar spring-boot-config-02-0.0.1-SNAPSHOT.jar --server.port=9005 --server.context-path=/abc\n\n   中间一个空格\n\n2. 来自java:comp/env的JNDI属性\n\n3. java系统属性（System.getProperties()）\n\n4. 操作系统环境变量\n\n5. RandomValuePropertySource配置的random.*属性值\n\n   ​\n\n   **优先加载profile,    由jar包外到jar包内**\n\n6. **jar包外部的application-{profile}.properties或application.yml(带Spring.profile)配置文件**\n\n7. **jar包内部的application-{profile}.properties或application.yml(带Spring.profile)配置文件**\n\n8. **jar包外部的application.properties或application.yml(带Spring.profile)配置文件**\n\n9. **jar包内部的application.properties或application.yml(不带spring.profile)配置文件**\n\n   ​\n\n10. @Configuration注解类的@PropertySource\n\n11. 通过SpringApplication.setDefaultProperties指定的默认属性\n\n[官方文档](https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#boot-features-external-config)\n\n## 8、自动配置\n\n配置文件到底怎么写？\n\n[Spring的所有配置参数](https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties)\n\n自动配置原理很关键\n\n### 1、自动配置原理\n\n1）、SpringBoot启动的时候加载主配置类，开启自动配置功能，@EnableAutoConfiguration\n\n2）、@EnableAutoConfiguration 作用：\n\n- 利用AutoConfigurationImportSelector给容器中导入一些组件？\n- 可以查看selectImports()方法的内容\n- 获取候选的配置\n\n```java\nList<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);\n```\n\n\n- 扫描类路径下的\n```java\n  SpringFactoriesLoader.loadFactoryNames(）\n  扫描所有jar包类路径下的 MATA-INF/spring.factories\n  把扫描到的这些文件的内容包装成properties对象\n  从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加到容器中\n```\n将类路径下 MATE-INF/spring.factories里面配置的所有的EnableAutoConfiguration的值加入到了容器中；\n\n3）、每一个自动配置类进行自动配置功能；\n\n4）、以**HttpEncodingAutoConfiguration** 为例\n\n```java\n@Configuration //表示是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件\n@EnableConfigurationProperties({HttpEncodingProperties.class})//启动指定类的Configurationproperties功能；将配置文件中的值和HttpEncodingProperties绑定起来了；并把HttpEncodingProperties加入ioc容器中\n@ConditionalOnWebApplication//根据不同的条件，进行判断，如果满足条件，整个配置类里面的配置就会失效，判断是否为web应用；\n(\n    type = Type.SERVLET\n)\n@ConditionalOnClass({CharacterEncodingFilter.class})//判断当前项目有没有这个类，解决乱码的过滤器\n@ConditionalOnProperty(\n    prefix = \"spring.http.encoding\",\n    value = {\"enabled\"},\n    matchIfMissing = true\n)//判断配置文件是否存在某个配置 spring.http.encoding，matchIfMissing = true如果不存在也是成立，即使不配置也生效\npublic class HttpEncodingAutoConfiguration {\n   //给容器添加组件，这个组件的值需要从properties属性中获取\n    private final HttpEncodingProperties properties;\n\t//只有一个有参数构造器情况下，参数的值就会从容器中拿\n    public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {\n        this.properties = properties;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean\n    public CharacterEncodingFilter characterEncodingFilter() {\n        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();\n        filter.setEncoding(this.properties.getCharset().name());\n        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.REQUEST));\n        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.RESPONSE));\n        return filter;\n    }\n\n```\n\n5）、所有在配置文件中能配置的属性都是在xxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类\n\n```java\n@ConfigurationProperties(prefix = \"spring.http.encoding\")//从配置文件中的值进行绑定和bean属性进行绑定\npublic class HttpEncodingProperties {\n```\n\n根据当前不同条件判断，决定这个配置类是否生效？\n\n一旦这个配置类生效；这个配置类会给容器添加各种组件；这些组件的属性是从对应的properties中获取的，这些类里面的每个属性又是和配置文件绑定的\n\n\n\n### 2、所有的自动配置组件\n\n每一个xxxAutoConfiguration这样的类都是容器中的一个组件，都加入到容器中；\n\n作用：用他们做自动配置\n\n```properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\\norg.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration\n\n```\n\n### 3、精髓：\n\n1）、SpringBoot启动会加载大量的自动配置类\n\n2）、我们看我们需要的功能有没有SpringBoot默认写好的默认配置类；\n\n3）、如果有在看这个自动配置类中配置了哪些组件；（只要我们要用的组件有，我们需要再来配置）\n\n4）、给容器中自动配置添加组件的时候，会从properties类中获取属性。我们就可以在配置文件中指定这些属性的值\n\nxxxAutoConfiguration:自动配置类；\n\n给容器中添加组件\n\nxxxProperties:封装配置文件中的属性；\n\n跟之前的Person类一样，配置文件中值加入bean中\n\n### 4、细节\n\n#### 1、@Conditional派生注解 \n\n> 利用Spring注解版原生的@Conditional作用\n\n作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；\n\n| @Conditional派生注解                | 作用（判断是否满足当前指定条件）               |\n| ------------------------------- | ------------------------------ |\n| @ConditionalOnJava              | 系统的java版本是否符合要求                |\n| @ConditionalOnBean              | 容器中存在指定Bean                    |\n| @ConditionalOnMissBean          | 容器中不存在指定Bean                   |\n| @ConditionalOnExpression        | 满足spEL表达式                      |\n| @ConditionalOnClass             | 系统中有指定的类                       |\n| @ConditionalOnMissClass         | 系统中没有指定的类                      |\n| @ConditionalOnSingleCandidate   | 容器中只有一个指定的Bean,或者这个Bean是首选Bean |\n| @ConditionalOnProperty          | 系统中指定的属性是否有指定的值                |\n| @ConditionalOnResource          | 类路径下是否存在指定的资源文件                |\n| @ConditionalOnWebApplication    | 当前是web环境                       |\n| @ConditionalOnNotWebApplication | 当前不是web环境                      |\n| @ConditionalOnJndi              | JNDI存在指定项                      |\n\n#### 2、自动配置报告\n\n自动配置类必须在一定条件下生效\n\n我们可以通过启用debug=true属性，配置文件，打印自动配合报告，这样就可以知道自动配置类生效\n\n```properties\ndebug=true\n```\n\n自动配置报告\n\n```java\n============================\n\nCONDITIONS EVALUATION REPORT\n============================\n\n\nPositive matches:（启动的，匹配成功的）\n-----------------\n\n   CodecsAutoConfiguration matched:\n      - @ConditionalOnClass found required class 'org.springframework.http.codec.CodecConfigurer'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)\n        ......\n        \n Negative matches:（没有启动的，没有匹配成功的）\n-----------------\n\n   ActiveMQAutoConfiguration:\n      Did not match:\n         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition)\n.....\n```\n\n# 三、日志\n\n> Spring Boot2对日志有更改\n\n### 1、日志框架\n\n小张：开发一个大型系统；\n\n1、System.out.println(\"\");将关键数据打印在控制台；去掉？卸载文件中\n\n2、框架记录系统的一些运行信息；日志框架zhanglog.jar\n\n3、高大上功能，异步模式？自动归档？xxx?zhanglog-good.jar?\n\n4、将以前的框架卸下来？换上新的框架，重新修改之前的相关API;zhanglog-perfect.jar;\n\n5、JDBC--数据库驱动；\n\n​\t写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar;\n\n​\t给项目中导入具体的日志实现就行；我们之前的日志框架都是实现的抽象层；\n\n市面上的日志框架\n\n| 日志抽象层                                                   | 日志实现                                        |\n| ------------------------------------------------------------ | ----------------------------------------------- |\n| ~~JCL(Jakarta Commons Logging)~~ SLF4j(Simple Logging Facade for Java) ~~jboss-logging~~ | Log4j ~~JUL(java.util.logging)~~ Log4j2 Logback |\n|                                                              |                                                 |\n\n左边的抽象，右边的实现\n\nSLF4J  -- Logback\n\nSpring Boot:底层是Spring框架，Spring默认框架是JCL；\n\n​\tSpringBoot选用SLF4J和logback\n\n### 2、SLF4J使用\n\n#### 1、如何在系统中使用SLF4j\n\n以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；\n\n应该给系统里面导入slf4j的jar包和logback的实现jar\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HelloWorld {\n  public static void main(String[] args) {\n    Logger logger = LoggerFactory.getLogger(HelloWorld.class);\n    logger.info(\"Hello World\");\n  }\n}\n```\n\n![8.slf4j](E:\\工作文档\\SpringBoot\\images\\8.slf4j.jpg)\n\n每个日志框架的实现框架都有自己的配置文件。使用slf4j以后，**配置文件还是做成日志实现框架本身的配置文件**；\n\n#### 2、遗留问题\n\na系统(slf4j+logback)：Spring（commons-logging）、Hibernate（jboss-logging）、Mybatis\n\n统一日志框架，即使是别的框架和我一起统一使用slf4j进行输出；\n\n核心：\n\n1、将系统中其他日志框架排除出去；\n\n2、用中间包来替换原有的日志框架/\n\n3、导入slf4j的其他实现\n\n### 3、SpingBoot日志框架解析\n\n打开IDEA ，打开pom文件的依赖图形化显示\n\n![9.IDEAdependencies](E:\\工作文档\\SpringBoot\\images\\9.IDEAdependencies.jpg)\n\nSpringBoot的基础框架\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\nSpringBoot的日志功能\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-logging</artifactId>\n    <version>2.0.1.RELEASE</version>\n    <scope>compile</scope>\n</dependency>\n```\n\n\n\n![10.slf4jandlogback](E:\\工作文档\\SpringBoot\\images\\10.slf4jandlogback.jpg)\n\n总结：\n\n1. SpringBoot底层也是使用SLF4J+log4jback\n\n2. SpringBoot也把其他日志替换成了slf4j\n\n3. 起着commons.loggings的名字其实new的SLF4J替换中间包\n\n   SpringBoot2中改成了bridge\n\n4. 如果要引入其他框架？一定要把这个框架的日志依赖移除掉，而且底层\n\n### 4、日志的使用\n\n#### 1、默认配置\n\ntrace-debug-info-warn-error\n\n可以调整需要的日志级别进行输出，不用注释语句。\n\n```java\n//记录器\nLogger logger = LoggerFactory.getLogger(getClass());\n@Test\npublic void contextLoads() {\n\n    //日志的级别\n    //从低到高\n    //可以调整输出的日志级别；日志就只会在这个级别以后的高级别生效\n    logger.trace(\"这是trace日志\");\n    logger.debug(\"这是debug信息\");\n    //SpringBoot默认给的是info级别，如果没指定就是默认的root级别\n    logger.info(\"这是info日志\");\n    logger.warn(\"这是warn信息\");\n    logger.error(\"这是Error信息\");\n}\n```\n\n调整指定包的日志级别在配置文件中进行配置\n\n```properties\nlogging.level.com.wdjr=trace\n```\n\n日志输出格式\n\n```properties\n#控制台输出的日志格式 \n#%d：日期\n#%thread：线程号 \n#%-5level：靠左 级别 \n#%logger{50}：全类名50字符限制,否则按照句号分割\n#%msg：消息+换行\n#%n：换行\nlogging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\n```\n\nSpringBoot修改日志的默认配置\n\n```properties\nlogging.level.com.wdjr=trace\n#不指定path就是当前目录下生成springboot.log\n#logging.file=springboot.log\n#当前磁盘下根路径创建spring文件中log文件夹，使用spring.log作为默认\nlogging.path=/spring/log\n#控制台输出的日志格式 日期 + 线程号 + 靠左 级别 +全类名50字符限制+消息+换行\nlogging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\n#指定文件中日志输出的格式\nlogging.pattern.file=xxx\n```\n\n#### 2、指定配置\n\n给类路径下放上每个日志框架自己的配置框架；SpringBoot就不会使用自己默认的配置\n\n| logging System         | Customization                                                |\n| ---------------------- | ------------------------------------------------------------ |\n| Logback                | logback-spring.xml ,logback-spring.groovy,logback.xml or logback.groovy |\n| Log4J2                 | log4j2-spring.xml or log4j2.xml                              |\n| JDK(Java Util Logging) | logging.properties                                           |\n\nlogback.xml直接被日志框架识别 ，logback-spring.xml日志框架就不直接加载日志配置项，由SpringBoot加载\n\n```xml\n<springProfile name=\"dev\">\n\t<!-- 可以指定某段配置只在某个环境下生效 -->\n</springProfile>\n<springProfile name!=\"dev\">\n\t<!-- 可以指定某段配置只在某个环境下生效 -->\n</springProfile>\n```\n\n如何调试开发环境,输入命令行参数\n\n--spring.profiles.active=dev\n\n如果不带后面的xx-spring.xml就会报错\n\n### 3、切换日志框架\n\n可以根据slf4j的日志适配图，进行相关切换；\n\n#### 1、log4j\n\nslf4j+log4j的方式；\n\n![11.log4j](E:\\工作文档\\SpringBoot\\images\\11.log4j.jpg)\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <exclusions>\n        <exclusion>\n            <artifactId>logback-classic</artifactId>\n            <groupId>ch.qos.logback</groupId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-log4j12</artifactId>\n</dependency>\n```\n\n不推荐使用仅作为演示\n\n#### 2、log4j2\n\n切换为log4j2\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <exclusions>\n        <exclusion>\n            <artifactId>spring-boot-starter-logging</artifactId>\n            <groupId>org.springframework.boot</groupId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-log4j2</artifactId>\n</dependency>\n```\n\n# 四、web开发\n\n## 1、简介\n\n使用SpringBoot;\n\n1)、创建SpringBoot应用，选中我们需要的模块；\n\n2)、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来\n\n3)、自己编写业务代码\n\n**自动配置原理？**\n\n这个场景的SpringBoot帮我们配置了什么？能不能修改？能修改那些配置？能不能扩展？xxx\n\n```java\nxxxAutoConfiguration:帮我们给容器中自动配置组件\nxxxProperties:配置类来封装配置文件的内容\n```\n\n## 2、静态资源文件映射规则\n\n```java\n@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)\npublic class ResourceProperties implements ResourceLoaderAware, InitializingBean {\n    //可以设置和静态资源相关的参数，缓存时间等\n```\n\n```java\n@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n   if (!this.resourceProperties.isAddMappings()) {\n      logger.debug(\"Default resource handling disabled\");\n      return;\n   }\n   Integer cachePeriod = this.resourceProperties.getCachePeriod();\n   if (!registry.hasMappingForPattern(\"/webjars/**\")) {\n      customizeResourceHandlerRegistration(registry\n            .addResourceHandler(\"/webjars/**\")\n            .addResourceLocations(\"classpath:/META-INF/resources/webjars/\")\n            .setCachePeriod(cachePeriod));\n   }\n   String staticPathPattern = this.mvcProperties.getStaticPathPattern();\n   if (!registry.hasMappingForPattern(staticPathPattern)) {\n      customizeResourceHandlerRegistration(\n            registry.addResourceHandler(staticPathPattern)\n                  .addResourceLocations(\n                        this.resourceProperties.getStaticLocations())\n                  .setCachePeriod(cachePeriod));\n   }\n}\n```\n\n### 1、webjar\n\n1)、所有的/webjars/**，都去classpath:/META-INF/resources/webjars/找资源；\n\n​\twebjars：以jar包的方式引入静态资源\n\nhttp://www.webjars.org/\n\n![12.jquery](E:\\工作文档\\SpringBoot\\images\\12.jquery.jpg)\n\nlocalhost:8080/webjars/jquery/3.3.1/jquery.js\n\n### 2、本地资源\n\n```\nprivate String staticPathPattern = \"/**\";\n```\n\n访问任何资源\n\n2、会在这几文件夹下去找静态路径（静态资源文件夹）\n\n```\n\"classpath:/META-INF/resources/\", \n\"classpath:/resources/\",\n\"classpath:/static/\", \n\"classpath:/public/\",\n\"/\";当前项目的根路径\n```\n\n![13.static](E:\\工作文档\\SpringBoot\\images\\13.static.jpg)\n\nlocalhost:8080/abc ==>去静态资源文件夹中找abc\n\n![14.static-css](E:\\工作文档\\SpringBoot\\images\\14.static-css.jpg)\n\n3、index页面欢迎页，静态资源文件夹下所有的index.html页面；被“/**”映射；\n\nlocalhost:8080/  -->index页面\n\n```JAVA\n@Bean\npublic WelcomePageHandlerMapping welcomePageHandlerMapping(\n      ResourceProperties resourceProperties) {\n   return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),\n         this.mvcProperties.getStaticPathPattern());\n}\n```\n\n4、喜欢的图标，即网站title的图标favicon\n\n```java\n@Configuration\n@ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true)\npublic static class FaviconConfiguration {\n\n   private final ResourceProperties resourceProperties;\n\n   public FaviconConfiguration(ResourceProperties resourceProperties) {\n      this.resourceProperties = resourceProperties;\n   }\n\n   @Bean\n   public SimpleUrlHandlerMapping faviconHandlerMapping() {\n      SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();\n      mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);\n       //把任何favicon的图标都在静态文件夹下找\n      mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\",\n            faviconRequestHandler()));\n      return mapping;\n   }\n\n   @Bean\n   public ResourceHttpRequestHandler faviconRequestHandler() {\n      ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler();\n      requestHandler\n            .setLocations(this.resourceProperties.getFaviconLocations());\n      return requestHandler;\n   }\n\n}\n```\n\n可以在配置文件配置静态资源文件夹\n\n```properties\nspring.resources.static-locations=classpath:xxxx\n```\n\n## 3、模板引擎\n\n将html和数据 结合到一起 输出组装处理好的新文件\n\nSpringBoot推荐Thymeleaf;语法简单，功能强大\n\n### 1、引入thymeleaf 3\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n\n默认导入thymeleaf2，版本太低 所以使用thymeleaf3.\n\n[官方导入办法](https://docs.spring.io/spring-boot/docs/1.5.12.RELEASE/reference/htmlsingle/#howto-use-thymeleaf-3)\n\n```xml\n<properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n    <java.version>1.8</java.version>\n    <!--thymeleaf 3的导入-->\n    <thymeleaf.version>3.0.9.RELEASE</thymeleaf.version>\n    <!--布局功能支持 同时支持thymeleaf3主程序 layout2.0以上版本  -->\n    <!--布局功能支持 同时支持thymeleaf2主程序 layout1.0以上版本  -->\n    <thymeleaf-layout-dialect.version>2.2.2</thymeleaf-layout-dialect.version>\n</properties>\n```\n\n### 2、Thymeleaf使用和语法\n\n```java\n@ConfigurationProperties(prefix = \"spring.thymeleaf\")\npublic class ThymeleafProperties {\n\n   private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\");\n\n   private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\");\n\n   public static final String DEFAULT_PREFIX = \"classpath:/templates/\";\n\n   public static final String DEFAULT_SUFFIX = \".html\";\n   //只要把HTML文件方法类路径下的template文件夹下，就会自动导入\n```\n\n只要把HTML页面放到classpath:/templates/,thymeleaf就能自动渲染；\n\n使用：\n\n1、导入thymeleaf的名称空间\n\n```html\n<html xmlns:th=\"http://www.thymeleaf.org\">    \n```\n\n2、使用thymeleaf语法；\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\"  xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\" />\n    <title>success</title>\n</head>\n<body>\n<h1>success</h1>\n<!--th:text 将div里面的文本内容设置为-->\n<div th:text=\"${Lion}\">\n前端数据\n</div>\n</body>\n</html>\n```\n\n3、语法规则\n\n1）、th:text=\"${hello}\"可以使用任意标签 替换原生的任何属性\n\n**在SpringBoot的环境下**\n\n```html\n<div id=\"testid\" class=\"testcalss\" th:id=\"${Lion}\" th:class=\"${Lion}\" th:text=\"${Lion}\">\n\t前端数据\n</div>\n```\n\n![15.thtmeleaf-th01](E:\\工作文档\\SpringBoot\\images\\15.thtmeleaf-th01.jpg)\n\n**直接访问HTML页面**\n\n![15.thtmeleaf-th02](E:\\工作文档\\SpringBoot\\images\\15.thtmeleaf-th02.jpg)\n\n**2)、内联写法注意需要在body上加上 th:inline=\"text\"敲黑板**\n\n不然不起作用\n\n```html\n<body class=\"text-center\" th:inline=\"text\"></body>\n```\n\nth标签的访问优先级\n\nOrder Feature Attributes\n\n### 3、语法规则\n\n|      | 功能                            | 标签                                 | 功能和jsp对比                             |\n| ---- | ------------------------------- | ------------------------------------ | ----------------------------------------- |\n| 1    | Fragment inclusion              | th:insert th:replace                 | include(片段包含)                         |\n| 2    | Fragment iteration              | th:each                              | c:forEach(遍历)                           |\n| 3    | Conditional evaluation          | th:if th:unless th:switch th:case    | c:if(条件判断)                            |\n| 4    | Local variable definition       | th:object  th:with                   | c:set(声明变量)                           |\n| 5    | General attribute modification  | th:attr th:attrprepend th:attrappend | 属性修改支持前面和后面追加内容            |\n| 6    | Specific attribute modification | th:value th:href th:src ...          | 修改任意属性值                            |\n| 7    | Text (tag body modification)    | th:text th:utext                     | 修改标签体内容utext：不转义字符<h1>大标题 |\n| 8    | Fragment specification          | th:fragment                          | 声明片段                                  |\n| 9    | Fragment removal                | th:remove                            |                                           |\n\n \n\n```properties\nSimple expressions:(表达式语法)\n    Variable Expressions: ${...}\n    \t1、获取对象属性、调用方法\n    \t2、使用内置基本对象：\n    \t    #ctx : the context object.\n            #vars: the context variables.\n            #locale : the context locale.\n            #request : (only in Web Contexts) the HttpServletRequest object.\n            #response : (only in Web Contexts) the HttpServletResponse object.\n            #session : (only in Web Contexts) the HttpSession object.\n            #servletContext : (only in Web Contexts) the ServletContext object.\n         3、内置一些工具对象\n        \t#execInfo : information about the template being processed.\n        \t#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they\n            would be obtained using #{…} syntax.\n            #uris : methods for escaping parts of URLs/URIs\n            #conversions : methods for executing the configured conversion service (if any).\n            #dates : methods for java.util.Date objects: formatting, component extraction, etc.\n            #calendars : analogous to #dates , but for java.util.Calendar objects.\n            #numbers : methods for formatting numeric objects.\n            #strings : methods for String objects: contains, startsWith, prepending/appending, etc.\n            #objects : methods for objects in general.\n            #bools : methods for boolean evaluation.\n            #arrays : methods for arrays.\n            #lists : methods for lists.\n            #sets : methods for sets.\n            #maps : methods for maps.\n            #aggregates : methods for creating aggregates on arrays or collections.\n            #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).\n    Selection Variable Expressions: *{...} //选择表达式：和${}功能一样，补充功能\n   # 配合th:object使用，object=${object} 以后获取就可以使用*{a}  相当于${object.a}\n  \t    <div th:object=\"${session.user}\">\n            <p>Name: <span th:text=\"*{firstName}\">Sebastian</span>.</p>\n            <p>Surname: <span th:text=\"*{lastName}\">Pepper</span>.</p>\n            <p>Nationality: <span th:text=\"*{nationality}\">Saturn</span>.</p>\n\t\t</div>\n    Message Expressions: #{...} //获取国际化内容\n    Link URL Expressions: @{...} //定义URL链接\n    \t#<a href=\"details.html\" th:href=\"@{/order/details(orderId=${o.id})}\">view</a>\n    Fragment Expressions: ~{...}//片段文档\n    \nLiterals（字面量）\n    Text literals: 'one text' , 'Another one!' ,…\n    Number literals: 0 , 34 , 3.0 , 12.3 ,…\n    Boolean literals: true , false\n    Null literal: null\n    Literal tokens: one , sometext , main ,…\nText operations:(文本操作)\n    String concatenation: +\n    Literal substitutions: |The name is ${name}|\nArithmetic operations:（数学运算）\n    Binary operators: + , - , * , / , %\n    Minus sign (unary operator): -\nBoolean operations:（布尔运算）\n    Binary operators: and , or\n    Boolean negation (unary operator): ! , not\nComparisons and equality:（比较运算）\n    Comparators: > , < , >= , <= ( gt , lt , ge , le )\n    Equality operators: == , != ( eq , ne )\nConditional operators:（条件运算）\n    If-then: (if) ? (then)\n    If-then-else: (if) ? (then) : (else)\n    Default: (value) ?: (defaultvalue)\nSpecial tokens:（空操作）\n\tNo-Operation: _\n```\n\ninline写法\n\n```html\n[[]] -->th:text\n[()] -->th:utext\n```\n\n\n\n## 4、SpringMVC自动配置\n\n### 1、SpringMVC的自动导入\n\n[Spring框架](https://docs.spring.io/spring-boot/docs/1.5.12.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications)\n\n自动配置好了mvc：\n\n以下是SpringBoot对SpringMVC的默认\n\nSpring Boot provides auto-configuration for Spring MVC that works well with most applications.\n\nThe auto-configuration adds the following features on top of Spring’s defaults:\n\n- Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.\n\n  - 自动配置了ViewResolver(视图解析器：根据方法的返回值得到视图对象（View）,视图对象决定如何渲染（转发？重定向？）)\n  - `ContentNegotiatingViewResolver`组合所有视图解析器\n  - 如何定制：我们可以自己给容器中添加一个视图解析器；自动将其整合进来\n\n- Support for serving static resources, including support for WebJars (see below).静态资源\n\n- Static `index.html` support.\n\n- Custom `Favicon` support (see below).\n\n- 自动注册 了`Converter`, `GenericConverter`, `Formatter` beans.\n\n  - `Converter`：类型转换 文本转为字面量\n\n  - `Formatter` ：格式化器 转换后格式转换\n\n    ```java\n    @Bean\n    @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件配置入职格式化的规则\n    public Formatter<Date> dateFormatter() {\n       return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件\n    }\n    ```\n\n    自己添加的格式化转换器，只需要放在容器中即可\n\n- Support for `HttpMessageConverters` (see below).\n\n  - `HttpMessageConverters` ：转换HTTP转换和响应：User - json\n\n  - `HttpMessageConverters` ：是从容器中确定；获取所有的`HttpMessageConverters`  ，将自己的组件注册在容器中@Bean \n\n  - If you need to add or customize converters you can use Spring Boot’s `HttpMessageConverters` class:\n\n    ```java\n    import org.springframework.boot.autoconfigure.web.HttpMessageConverters;\n    import org.springframework.context.annotation.*;\n    import org.springframework.http.converter.*;\n    \n    @Configuration\n    public class MyConfiguration {\n    \n        @Bean\n        public HttpMessageConverters customConverters() {\n            HttpMessageConverter<?> additional = ...\n            HttpMessageConverter<?> another = ...\n            return new HttpMessageConverters(additional, another);\n        }\n    \n    }\n    ```\n\n- Automatic registration of `MessageCodesResolver` (see below).\n\n  - 定义错误代码生成规则\n\n- Automatic use of a `ConfigurableWebBindingInitializer` bean (see below).\n\n  - ```java\n    @Override\n    protected ConfigurableWebBindingInitializer getConfigurableWebBindingInitializer() {\n       try {\n          return this.beanFactory.getBean(ConfigurableWebBindingInitializer.class);\n       }\n       catch (NoSuchBeanDefinitionException ex) {\n          return super.getConfigurableWebBindingInitializer();\n       }\n    }\n    ```\n\n    在beanFactory：中可以自己创建一个，初始化webDataBinder\n\n    请求数据 ==》javaBean\n\nIf you want to keep Spring Boot MVC features, and you just want to add additional [MVC configuration](https://docs.spring.io/spring/docs/4.3.16.RELEASE/spring-framework-reference/htmlsingle#mvc) (interceptors, formatters, view controllers etc.) you can add your own `@Configuration` class of type `WebMvcConfigurerAdapter`, but **without** `@EnableWebMvc`. If you wish to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter` or `ExceptionHandlerExceptionResolver` you can declare a `WebMvcRegistrationsAdapter` instance providing such components.\n\nIf you want to take complete control of Spring MVC, you can add your own `@Configuration` annotated with `@EnableWebMvc`.\n\n思想：修改默认配置\n\n### 2、扩展SpringMVC\n\n编写一个配置类，类型是WebMvcConfigurerAdapter(继承)，使用WebMvcConfigurerAdapter可以扩展，不能标注@EnableWebMvc;既保留了配置，也能拓展我们自己的应用\n\n```java\n@Configuration\npublic class MyMvcConfig extends WebMvcConfigurerAdapter {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n//        super.addViewControllers(registry);\n        //浏览器发送wdjr请求，也来到success页面\n        registry.addViewController(\"/wdjr\").setViewName(\"success\");\n    }\n}\n```\n\n原理：\n\n1）、WebMvcAutoConfiguration是SpringMVC的自动配置\n\n2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class)\n\n```java\n@Configuration\npublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {\n    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();\n\n\t//从容器中获取所有webMVCconfigurer\n\t@Autowired(required = false)\n\tpublic void setConfigurers(List<WebMvcConfigurer> configurers) {\n\t\tif (!CollectionUtils.isEmpty(configurers)) {\n\t\t\tthis.configurers.addWebMvcConfigurers(configurers);\n            \n            \t@Override\n                protected void addViewControllers(ViewControllerRegistry registry) {\n                    this.configurers.addViewControllers(registry);\n                }\n            //一个参考实现,将所有的webMVCconfigurer相关配置一起调用（包括自己的配置类）\n            \t@Override\n               // public void addViewControllers(ViewControllerRegistry registry) {\n                   // for (WebMvcConfigurer delegate : this.delegates) {\n\t\t\t\t //delegate.addViewControllers(registry);\n                    //}\n                }\n\t\t}\n\t}\n    \n```\n\n\n\n3）、自己的配置被调用\n\n效果：SpringMVC的自动配置和我们的扩展配置都会起作用\n\n### 3、全面接管mvc\n\n不需要SpringBoot对SpringMVC的自动配置。\n\n```java\n@EnableWebMvc\n@Configuration\npublic class MyMvcConfig extends WebMvcConfigurerAdapter {\n\n@Override\npublic void addViewControllers(ViewControllerRegistry registry) {\n\n\n//        super.addViewControllers(registry);\n        //浏览器发送wdjr请求，也来到success页面\n        registry.addViewController(\"/wdjr\").setViewName(\"success\");\n    }\n}\n```\n\n例如静态资源访问，不推荐全面接管\n\n原理：\n\n为什么@EnableWebMvc注解，SpringBoot对SpringMVC的控制就失效了\n\n1）、核心配置\n\n```java\n@Import(DelegatingWebMvcConfiguration.class)\npublic @interface EnableWebMvc {\n}\n```\n\n2）、DelegatingWebMvcConfiguration\n\n```java\n@Configuration\npublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {\n```\n\n3）、WebMvcAutoConfiguration\n\n```java\n@Configuration\n@ConditionalOnWebApplication\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,\n      WebMvcConfigurerAdapter.class })\n//容器没有这个组件的时候，这个自动配置类才生效\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\n@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,\n      ValidationAutoConfiguration.class })\npublic class WebMvcAutoConfiguration {\n```\n\n4）、@EnableWebMvc将WebMvcConfigurationSupport导入进来了；\n\n5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能\n\n\n\n## 5、修改SpringMVC默认配置\n\n模式:\n\n​\t1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；\n\n​\t2）、在SpringBoot中会有 xxxConfigurer帮助我们扩展配置。\n\n## 6、RestfulCRUD\n\n### 1、默认访问首页\n\n在config/MyConfig.java中编写配置类\n\n```java\n//所有的webMvcConfigurerAdapter组件会一起起作用\n@Bean //註冊到容器去\npublic WebMvcConfigurerAdapter webMvcConfigurerAdapter(){\n    WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {\n        @Override\n        public void addViewControllers(ViewControllerRegistry registry) {\n            registry.addViewController(\"/\").setViewName(\"login\");\n            registry.addViewController(\"/login.html\").setViewName(\"login\");\n        }\n    };\n    return adapter;\n}\n```\n\n静态资源引用\n\n```html\n<link href=\"#\" th:href=\"@{/css/signin.css}\" rel=\"stylesheet\" />\n```\n\n### 2、国际化\n\n1、编写国际化配置文件\n\n2、使用ResourceBundleMessageSource管理国际化资源文件\n\n3、在页面中使用fmt:message，取出国际化内容\n\n#### 1、浏览器切换国际化\n\n步骤\n\n1、编写国际化配置文件，抽取页面需要的显示的国际化消息\n\n![16.national](E:\\工作文档\\SpringBoot\\images\\16.national.jpg)\n\n2、SpringBoot自动配置好了国际化配置的资源文件\n\n```java\n@ConfigurationProperties(prefix = \"spring.messages\")\npublic class MessageSourceAutoConfiguration {\n    //我们的配置文件可以直接放在类路径下叫messages.properties\n    private String basename = \"messages\";\n    @Bean\n\tpublic MessageSource messageSource() {\n\t\tResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();\n\t\tif (StringUtils.hasText(this.basename)) {\n            //设置国际化文件的基础名，去掉语言国家代码\n\t\t\tmessageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(\n\t\t\t\t\tStringUtils.trimAllWhitespace(this.basename)));\n\t\t}\n\t\tif (this.encoding != null) {\n\t\t\tmessageSource.setDefaultEncoding(this.encoding.name());\n\t\t}\n\t\tmessageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);\n\t\tmessageSource.setCacheSeconds(this.cacheSeconds);\n\t\tmessageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);\n\t\treturn messageSource;\n\t}\n```\n\n3、对IDEA的编码进行设置\n\n![17.encoding](E:\\工作文档\\SpringBoot\\images\\17.encoding.jpg)\n\n4、login进行标签插入\n\n```html\n<!DOCTYPE html>\n<!-- saved from url=(0051)https://getbootstrap.com/docs/4.1/examples/sign-in/ -->\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    \n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\" />\n    <meta name=\"description\" content=\"\" />\n    <meta name=\"author\" content=\"\" />\n    <link rel=\"icon\" href=\"https://getbootstrap.com/favicon.ico\" />\n\n    <title>登录页面</title>\n\n    <!-- Bootstrap core CSS -->\n    <link href=\"#\" th:href=\"@{/css/bootstrap.min.css}\" rel=\"stylesheet\" />\n\n    <!-- Custom styles for this template -->\n    <link href=\"./login_files/signin.css\" th:href=\"@{/css/signin.css}\" rel=\"stylesheet\" />\n  </head>\n\n  <body class=\"text-center\">\n    <form class=\"form-signin\">\n      <img class=\"mb-4\" src=\"./login_files/bootstrap-solid.svg\" th:src=\"@{/img/bootstrap-solid.svg}\" alt=\"\" width=\"72\" height=\"72\" />\n      <h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\">Please sign in</h1>\n      <label  class=\"sr-only\" th:text=\"#{login.username}\">Username</label>\n      <input type=\"text\"  name=\"username\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#{login.username}\" required=\"\" autofocus=\"\"/>\n      <label for=\"inputPassword\" class=\"sr-only\" th:text=\"#{login.password}\">Password</label>\n      <input type=\"password\" name=\"password\" id=\"inputPassword\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#{login.password}\" required=\"\" />\n      <div class=\"checkbox mb-3\">\n        <label>\n          <input type=\"checkbox\" value=\"remember-me\" /> [[#{login.remember}]]\n        </label>\n      </div>\n      <button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#{login.btn}\">Sign in</button>\n      <p class=\"mt-5 mb-3 text-muted\">© 2017-2018</p>\n    </form>\n  \n\n</body></html>\n```\n\n效果根据浏览器语言的信息切换国际化\n\n原理：\n\n国际化locale（区域信息对象）；LocaleResolver(获取区域对象)；\n\n```java\n@Bean\n@ConditionalOnMissingBean\n@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\")\npublic LocaleResolver localeResolver() {\n    if (this.mvcProperties\n        .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {\n        return new FixedLocaleResolver(this.mvcProperties.getLocale());\n    }\n    AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();\n    localeResolver.setDefaultLocale(this.mvcProperties.getLocale());\n    return localeResolver;\n}            \n\n```\n\n默认的就是根据请求头带来的区域信息获取local国际化信息（截图就是这么犀利）\n\n![18.accept-language](E:\\工作文档\\SpringBoot\\images\\18.accept-language.jpg)\n\n#### 2、点击链接切换国际化\n\n自己编写localResolver，加到容器中\n\n1、更改HTML代码\n\n```html\n<p class=\"mt-5 mb-3 text-muted\">© 2017-2018</p>\n  <a href=\"#\" class=\"btn btn-sm\" th:href=\"@{/index.html?lg=zh_CN}\">中文</a>\n  <a href=\"#\" class=\"btn btn-sm\" th:href=\"@{/index.html?lg=en_US}\">English</a>\n```\n\n2、新建一个MyLocaleResolver.class\n\n```java\npublic class MyLocaleResolver implements LocaleResolver {\n\n    //解析区域信息\n    @Override\n    public Locale resolveLocale(HttpServletRequest request) {\n        String l = request.getParameter(\"lg\");\n        Locale locale = Locale.getDefault();\n        if(!StringUtils.isEmpty(l)){\n            String[] split = l.split(\"_\");\n            locale = new Locale(split[0], split[1]);\n        }\n        return locale;\n    }\n\n    @Override\n    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {\n\n    }\n}\n```\n\n3、将MyLocaleResolver加入到容器中\n\n```java\n@Bean\npublic LocaleResolver localeResolver(){\n    return new MyLocalResolver();\n}\n```\n\n4、启动演示\n\n### 3、登录拦截器\n\n#### 1、登录\n\n开发技巧\n\n​\t1、清除模板缓存\n\n​\t2、Ctrl+F9刷新\n\n1、新建一个LoginController\n\n```java\n@Controller\npublic class LoginController {\n\n    @PostMapping(value =\"/user/login\")\n    public String login(@RequestParam(\"username\")String username,\n                        @RequestParam(\"password\")String password,\n                        Map<String,Object> map){\n        if(!StringUtils.isEmpty(username) && \"123456\".equals(password)){\n            //登录成功\n            return \"list\";\n        }else{\n            map.put(\"msg\", \"用户名密码错误\");\n            return \"login\";\n        }\n\n    }\n}\n```\n\n2、登录错误消息显示\n\n```html\n<!--判断-->\n<p style=\"color: red\" th:text=\"${msg}\" th:if=\"${not #strings.isEmpty(msg)}\"></p>\n```\n\n3、表单重复提交\n\n表单重复提交事件 --》重定向来到成功页面--》模板引擎解析\n\n```java\nif(!StringUtils.isEmpty(username) && \"123456\".equals(password)){\n    //登录成功,防止重复提交\n    return \"redirect:/main.html\";\n}else{\n    map.put(\"msg\", \"用户名密码错误\");\n    return \"login\";\n}\n```\n\n模板引擎解析\n\n```java\n@Override\npublic void addViewControllers(ViewControllerRegistry registry) {\n    registry.addViewController(\"/\").setViewName(\"login\");\n    registry.addViewController(\"/index.html\").setViewName(\"login\");\n    registry.addViewController(\"/main.html\").setViewName(\"Dashboard\");\n}\n```\n\n### 4、拦截器\n\n作用：实现权限控制，每个页面请求前中后，都会进入到拦截器进行处理（登录权限）\n\n1、在component下新建一个LoginHandlerInterceptor拦截器\n\n```java\npublic class LoginHandlerInterceptor implements HandlerInterceptor {\n\n    //目标方法执行之前\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        Object user = request.getSession().getAttribute(\"loginUser\");\n        if(user!=null){\n            //已经登录\n            return true;\n        }\n        //未经过验证\n        request.setAttribute(\"msg\", \"没权限请先登录\");\n        request.getRequestDispatcher(\"/index.html\").forward(request, response);\n\n        return false;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n\n    }\n}\n```\n\n2、在MyMvcConfig配置中重写拦截器方法，加入到容器中\n\n```java\n//所有的webMvcConfigurerAdapter组件会一起起作用\n@Bean //註冊到容器去\npublic WebMvcConfigurerAdapter webMvcConfigurerAdapter(){\n    WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {\n        @Override\n        public void addViewControllers(ViewControllerRegistry registry) {\n            registry.addViewController(\"/\").setViewName(\"login\");\n            registry.addViewController(\"/index.html\").setViewName(\"login\");\n            registry.addViewController(\"/main.html\").setViewName(\"Dashboard\");\n        }\n        //注册拦截器\n        @Override\n        public void addInterceptors(InterceptorRegistry registry) {\n            //静态资源 css js img 已经做好了静态资源映射\n            registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\").\n                    excludePathPatterns(\"/index.html\",\"/\",\"/user/login\");\n        }\n    };\n    return adapter;\n}\n```\n\n3、在LoginHandler中添加登录成功写入session\n\n```java\n@Controller\npublic class LoginController {\n\n    @PostMapping(value =\"/user/login\")\n    public String login(@RequestParam(\"username\")String username,\n                        @RequestParam(\"password\")String password,\n                        Map<String,Object> map,\n                        HttpSession session){\n        if(!StringUtils.isEmpty(username) && \"123456\".equals(password)){\n            //登录成功,防止重复提交\n            session.setAttribute(\"loginUser\", username);\n            return \"redirect:/main.html\";\n        }else{\n            map.put(\"msg\", \"用户名密码错误\");\n            return \"login\";\n        }\n\n    }\n}\n```\n\n### 5、CRUD-员工列表\n\n实验要求：\n\n1）、RestfulCRUD：CRUD满足Rest风格\n\nURI:/资源名称/资源标识+HTTP操作\n\n|      | 普通CRUD                | RestfulCRUD       |\n| ---- | ----------------------- | ----------------- |\n| 查询 | getEmp                  | emp -- GET        |\n| 添加 | addEmp?xxx              | emp --POST        |\n| 修改 | updateEmp?id=xxx&xxx=xx | emp/{id} -- PUT   |\n| 删除 | deleteEmp?id=1          | emp/{id} --DELETE |\n\n2、实验的请求架构\n\n|                | 请求URI  | 请求方式 |\n| -------------- | -------- | -------- |\n| 查询所有员工   | emps     | GET      |\n| 查询某个员工   | emp/{id} | GET      |\n| 添加页面       | emp      | GET      |\n| 添加员工       | emp      | POST     |\n| 修改页面(回显) | emp/{id} | GET      |\n| 修改员工       | emp/{id} | PUT      |\n| 删除员工       | emp/{id} | DELETE   |\n\n3、员工列表\n\n#### 1、公共页面抽取\n\n使用方法\n\n```html\n1、抽取公共片段\n<!--footer.html-->\n<div id=\"footid\" th:fragment=\"copy\">xxx</div>\n2、引入公共片段\n<!--test.html-->\n<div th:insert=~{footer::copy}></div>\n~{templatename::selector} 模板名::选择器  footer::#footid\n~{templatename::fragmentname} 模板名::片段名称 footer::copy\n行内写法可以加~{xx::xx} 标签体可以 xx::xx\n```\n\n\n\n**三种引用方式**\n\n**th:insert** :加个外层标签 +1\n\n**th:replace** :完全替换 1\n\n**th:include**：就替换里面的内容 -1\n\n公共页面\n\n```html\n<body>\n\t...\n    <div th:insert=\"footer :: copy\"></div>\n    <div th:replace=\"footer :: copy\"></div>\n    <div th:include=\"footer :: copy\"></div>\n</body>\n```\n\n结果\n\n```html\n<body>\n...\n    <!-- th:insert -->\n    <div>\n        <footer>\n            &copy; 2011 The Good Thymes Virtual Grocery\n        </footer>\n    </div>\n    <!--th:replace-->\n    <footer>\n   \t\t&copy; 2011 The Good Thymes Virtual Grocery\n    </footer>\n    <!--th:include-->\n    <div>\n        &copy; 2011 The Good Thymes Virtual Grocery\n    </div>\n</body>\n```\n\n用此种方法将公共页面引入\n\n#### 2、列表高亮\n\n引入片段的时候传入参数，新建一个commons文件夹存储公共页面bar.html\n\n模板引入变量名\n\ndashboard\n\n```html\n<a class=\"nav-link active\"\n   th:class=\"${activeUri}=='main.html'?'nav-link active':'nav-link'\"\n   href=\"https://getbootstrap.com/docs/4.1/examples/dashboard/#\" th:href=\"@{/main.html}\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\"><path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"></path><polyline points=\"9 22 9 12 15 12 15 22\"></polyline></svg>\n    Dashboard <span class=\"sr-only\">(current)</span>\n</a>\n```\n\n员工管理\n\n```html\n<li class=\"nav-item\">\n    <a class=\"nav-link\"\n       th:class=\"${activeUri}=='emps'?'nav-link active':'nav-link'\"\n       href=\"https://getbootstrap.com/docs/4.1/examples/dashboard/#\" th:href=\"@{/emps}\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-users\"><path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path><circle cx=\"9\" cy=\"7\" r=\"4\"></circle><path d=\"M23 21v-2a4 4 0 0 0-3-3.87\"></path><path d=\"M16 3.13a4 4 0 0 1 0 7.75\"></path></svg>\n        员工管理\n    </a>\n```\n\n引入模板的时候传入参数\n\ndashboard.html引入\n\n```html\n<!--引入侧边栏-->\n   <div th:replace=\"commons/bar :: sidebar(activeUri='main.html')\"></div>\n```\n\nlist.html引入\n\n```html\n<!--引入侧边栏-->\n<div th:replace=\"commons/bar::sidebar(activeUri='emps')\"></div>\n```\n\n### 6、列表数据显示（查）\n\n#### 1、传入员工对象\n\nEmployeeController类,传入员工对象\n\n```java\n@Controller\npublic class EmployeeController {\n\n    @Autowired\n    EmployeeDao employeeDao;\n    /**\n     * 查询所有员工返回列表页面\n     */\n    @GetMapping(value = \"/emps\")\n    public String list(Model model){\n\n        Collection<Employee> employees = employeeDao.getAll();\n        model.addAttribute(\"emps\",employees);\n        return \"emp/list\";\n    }\n}\n```\n\n#### 2、 遍历对象\n\nlist.html中 使用模板的 `th:each`方法\n\n```html\ntable class=\"table table-striped table-sm\">\n    <thead>\n    <tr>\n        <th>#</th>\n        <th>lastName</th>\n        <th>email</th>\n        <th>gender</th>\n        <th>department</th>\n        <th>birth</th>\n        <th>操作</th>\n    </tr>\n    </thead>\n    <tbody>\n        <tr th:each=\"emp:${emps}\">\n            <td th:text=\"${emp.id}\">1</td>\n            <td th:text=\"${emp.lastName}\">1</td>\n            <td th:text=\"${emp.email}\">1</td>\n            <td th:text=\"${emp.gender}\">1</td>\n            <td th:text=\"${emp.department.departmentName}\">1</td>\n            <td th:text=\"${#dates.format(emp.birth,'yyyy-MM-dd HH:mm:ss')}\">1</td>\n            <td>\n                <button class=\"btn btn-sm btn-primary\">编辑</button>\n                <button class=\"btn btn-sm btn-danger\">删除</button>\n            </td>\n        </tr>\n    </tbody>\n</table>\n```\n\n#### 3、效果显示\n\n![19.table list](E:\\工作文档\\SpringBoot\\images\\19.table list.jpg)\n\n\n\n### 7、员工添加（增）\n\n功能：点击添加按钮，出现新增页面\n\n#### 1、新增页面\n\n```html\n<form>\n    <!-- LastName -->\n    <div class=\"form-group\">\n        <label for=\"LastName\">LastName</label>\n        <input type=\"text\" class=\"form-control\" id=\"LastName\"  placeholder=\"LastName\">\n    </div>\n    <!-- Email -->\n    <div class=\"form-group\">\n        <label for=\"Email\">Email</label>\n        <input type=\"email\" class=\"form-control\" id=\"Email\"  placeholder=\"zhangsan@163.com\">\n    </div>\n    <!--gender-->\n    <div class=\"form-group\">\n        <label >Gender</label><br/>\n        <div class=\"form-check form-check-inline\">\n            <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\">\n            <label class=\"form-check-label\" >男</label>\n        </div>\n        <div class=\"form-check form-check-inline\">\n            <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\">\n            <label class=\"form-check-label\" >女</label>\n        </div>\n    </div>\n    <!-- department -->\n    <div class=\"form-group\">\n        <label for=\"exampleFormControlSelect1\">department</label>\n        <select class=\"form-control\" id=\"exampleFormControlSelect1\">\n            <option th:each=\"dept:${depts}\" th:value=\"${dept.id}\" th:text=\"${dept.departmentName}\"></option>\n        </select>\n    </div>\n    <!--Birth-->\n    <div class=\"form-group\">\n        <label for=\"birthDate\">Birth</label>\n        <input type=\"text\" class=\"form-control\" id=\"birthDate\" placeholder=\"2012-12-12\">\n    </div>\n    <button type=\"submit\" class=\"btn btn-primary\">添 加</button>\n</form>\n```\n\n#### 2、页面跳转\n\n在EmployeeController中添加addEmpPage方法\n\n```java\n/**\n * 添加员工\n */\n@GetMapping(value = \"/emp\")\npublic String toAddPage(Model model){\n    //来到添加页面,查出所有部门显示\n    Collection<Department> depts = departmentDao.getDepartments();\n    model.addAttribute(\"depts\",depts);\n    return \"emp/add\";\n}\n```\n\n关键点：在添加部门页面要遍历部门信息，所以在方法中出入部门信息\n\n#### 3、添加功能完成\n\n新建一个PostMapping\n\n> ThymeleafViewResolver 查看redirect和forward,原生的sendredirect方法；\n\n1、新建一个postMapping的方法用来接受页面的添加POST请求\n\n```java\n/**\n * 员工添加\n */\n@PostMapping(value = \"/emp\")\npublic String addEmp(Employee employee){\n\n    employeeDao.save(employee);\n    //来到员工列表页面、redirect:重定向到一个地址，forward转发到一个地址\n    return \"redirect:/emps\";\n}\n```\n\n2、修改添加页面，添加name属性\n\n```html\n<form th:action=\"@{/emp}\" method=\"post\">\n    <!-- LastName -->\n    <div class=\"form-group\">\n        <label for=\"LastName\">LastName</label>\n        <input type=\"text\" class=\"form-control\" id=\"LastName\" name=\"lastName\" placeholder=\"LastName\">\n    </div>\n    <!-- Email -->\n    <div class=\"form-group\">\n        <label for=\"Email\">Email</label>\n        <input type=\"email\" class=\"form-control\" id=\"Email\"  name=\"email\" placeholder=\"zhangsan@163.com\">\n    </div>\n    <!--gender-->\n    <div class=\"form-group\">\n        <label >Gender</label><br/>\n        <div class=\"form-check form-check-inline\">\n            <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\">\n            <label class=\"form-check-label\" >男</label>\n        </div>\n        <div class=\"form-check form-check-inline\">\n            <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\">\n            <label class=\"form-check-label\" >女</label>\n        </div>\n    </div>\n    <!-- department -->\n    <div class=\"form-group\">\n        <label >department</label>\n        <select class=\"form-control\"  name=\"department.id\">\n            <option th:each=\"dept:${depts}\" th:value=\"${dept.id}\" th:text=\"${dept.departmentName}\"></option>\n        </select>\n    </div>\n    <div class=\"form-group\">\n        <label for=\"birthDate\">Birth</label>\n        <input type=\"text\" class=\"form-control\" id=\"birthDate\" placeholder=\"2012-12-12\" name=\"birth\">\n    </div>\n    <button type=\"submit\" class=\"btn btn-primary\">添 加</button>\n</form>\n```\n\n1、部门对象问题？\n\n```html\n<select class=\"form-control\"  name=\"department.id\">\n```\n\n2、日期格式化？\n\n属性中添加 date-formate 默认是 / \n\n```java\n@Bean\n@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")\npublic Formatter<Date> dateFormatter() {\n   return new DateFormatter(this.mvcProperties.getDateFormat());\n}\n\n@Override\npublic MessageCodesResolver getMessageCodesResolver() {\n   if (this.mvcProperties.getMessageCodesResolverFormat() != null) {\n      DefaultMessageCodesResolver resolver = new DefaultMessageCodesResolver();\n      resolver.setMessageCodeFormatter(\n            this.mvcProperties.getMessageCodesResolverFormat());\n      return resolver;\n   }\n   return null;\n}\n```\n\n```properties\nspring.mvc.date-format=yyyy-MM-dd\n```\n\n### 8、员工编辑（改）\n\n思路使用add页面，并且数据回显，然后区分添加，PUT请求\n\n#### 1、修改按钮\n\n在list.html的`编辑`按钮加上链接\n\n```html\n<td>\n    <a  href=\"#\" th:href=\"@{/emp/}+${emp.id}\" class=\"btn btn-sm btn-primary\">编辑</a>\n    <button class=\"btn btn-sm btn-danger\">删除</button>\n</td>\n```\n\n#### 2、编写跳转页面\n\n跳转到员工编辑页面的Controller\n\n```java\n/**\n * 员工编辑页面\n */\n@GetMapping(value = \"/emp/{id}\")\npublic String toEditPage(@PathVariable(\"id\") Integer id ,Model model){\n    Employee emp = employeeDao.getEmpById(id);\n    Collection<Department> departments = departmentDao.getDepartments();\n    model.addAttribute(\"emp\",emp);\n    model.addAttribute(\"depts\",departments);\n    return \"emp/add\";\n}\n   \n```\n\n#### 3、对页面修改\n\n对add页面进行修改\n\n1）、添加回显\n\n2）、添加判断是否emp!=null（区分add or edit）\n\n3）、添加put请求 --两个input的hidden标签\n\n```html\n <form th:action=\"@{/emp}\" method=\"post\">\n        <!--发送put请求-->\n        <!--1.SpringMVC配置HiddenHttpMethodFilter\n            2.页面创建一个post表单\n            3.创建一个 input name_method 值就是我们请求的方式-->\n        <input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"${emp!=null}\">\n\n        <input type=\"hidden\" name=\"id\" th:value=\"${emp.id}\" th:if=\"${emp!=null}\">\n        <!-- LastName -->\n        <div class=\"form-group\">\n            <label for=\"LastName\">LastName</label>\n            <input type=\"text\" class=\"form-control\" id=\"LastName\" name=\"lastName\" placeholder=\"LastName\" th:value=\"${emp!=null}?${emp.lastName}\">\n        </div>\n        <!-- Email -->\n        <div class=\"form-group\">\n            <label for=\"Email\">Email</label>\n            <input type=\"email\" class=\"form-control\" id=\"Email\"  name=\"email\" placeholder=\"zhangsan@163.com\" th:value=\"${emp!=null}?${emp.email}\">\n        </div>\n        <!--gender-->\n        <div class=\"form-group\">\n            <label >Gender</label><br/>\n            <div class=\"form-check form-check-inline\">\n                <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"${emp!=null}?${emp.gender}==1\">\n                <label class=\"form-check-label\" >男</label>\n            </div>\n            <div class=\"form-check form-check-inline\">\n                <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"${emp!=null}?${emp.gender}==0\">\n                <label class=\"form-check-label\" >女</label>\n            </div>\n        </div>\n        <!-- department -->\n        <div class=\"form-group\">\n            <label >department</label>\n            <select class=\"form-control\"  name=\"department.id\" >\n                <option th:selected=\"${emp!=null}?${dept.id == emp.department.id}\" th:each=\"dept:${depts}\" th:value=\"${dept.id}\" th:text=\"${dept.departmentName}\"></option>\n            </select>\n        </div>\n        <div class=\"form-group\">\n            <label for=\"birthDate\">Birth</label>\n            <input type=\"text\" class=\"form-control\" id=\"birthDate\" placeholder=\"2012-12-12\" name=\"birth\" th:value=\"${emp!=null}?${#dates.format(emp.birth,'yyyy-MM-dd HH:mm:ss')}\">\n        </div>\n        <button type=\"submit\" class=\"btn btn-primary\" th:text=\"${emp!=null}?'修改':'添加'\">添 加</button>\n    </form>\n</main>\n```\n### 9、员工删除（删）\n\n#### 1、新建Contoller\n\n```java\n/**\n * 员工删除\n */\n@DeleteMapping(value = \"/emp/{id}\")\npublic String deleteEmp(@PathVariable(\"id\") Integer id){\n    employeeDao.deleteEmpById(id);\n    return \"redirect:/emps\";\n}\n```\n\n#### 2、修改删除标签\n\n```html\n<button th:attr=\"del_uri=@{/emp/}+${emp.id}\"  class=\"btn btn-sm btn-danger deleteBtn\">\n    删除\n</button>\n```\n\n#### 3、写Form表单\n\nform表单卸载外面，input 中 name=\"_method\" value=\"delete\" 模拟delete请求\n\n```html\n                </tbody>\n            </table>\n        </div>\n    </main>\n    <form id=\"deleteEmpForm\" method=\"post\">\n        <input type=\"hidden\" name=\"_method\" value=\"delete\">\n    </form>\n</div>\n```\n\n#### 4、写JS提交\n\n```javascript\n<script>\n    $(\".deleteBtn\").click(function () {\n        $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit();\n        return false;\n    })\n</script>\n```\n\n> return false;禁用btn提交效果\n\n## 7、错误机制的处理\n\n### 1、默认的错误处理机制\n\n默认错误页面\n\n![20.error](E:\\工作文档\\SpringBoot\\images\\20.error.jpg)\n\n原理参照\n\nErrorMvcAutoConfiguration:错误处理的自动配置\n\n```\norg\\springframework\\boot\\spring-boot-autoconfigure\\1.5.12.RELEASE\\spring-boot-autoconfigure-1.5.12.RELEASE.jar!\\org\\springframework\\boot\\autoconfigure\\web\\ErrorMvcAutoConfiguration.class\n\n```\n\n- DefaultErrorAttributes\n\n  帮我们在页面共享信息\n\n  ```java\n  @Override\n  public Map<String, Object> getErrorAttributes(RequestAttributes requestAttributes,\n        boolean includeStackTrace) {\n     Map<String, Object> errorAttributes = new LinkedHashMap<String, Object>();\n     errorAttributes.put(\"timestamp\", new Date());\n     addStatus(errorAttributes, requestAttributes);\n     addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);\n     addPath(errorAttributes, requestAttributes);\n     return errorAttributes;\n  }\n  ```\n\n- BasicErrorController\n\n  ```java\n  @Controller\n  @RequestMapping(\"${server.error.path:${error.path:/error}}\")\n  public class BasicErrorController extends AbstractErrorController {\n      //产生HTML数据\n      @RequestMapping(produces = \"text/html\")\n  \tpublic ModelAndView errorHtml(HttpServletRequest request,\n  \t\t\tHttpServletResponse response) {\n  \t\tHttpStatus status = getStatus(request);\n  \t\tMap<String, Object> model = Collections.unmodifiableMap(getErrorAttributes(\n  \t\t\t\trequest, isIncludeStackTrace(request, MediaType.TEXT_HTML)));\n  \t\tresponse.setStatus(status.value());\n  \t\tModelAndView modelAndView = resolveErrorView(request, response, status, model);\n  \t\treturn (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView);\n  \t}\n  \t//产生Json数据\n  \t@RequestMapping\n  \t@ResponseBody\n  \tpublic ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {\n  \t\tMap<String, Object> body = getErrorAttributes(request,\n  \t\t\t\tisIncludeStackTrace(request, MediaType.ALL));\n  \t\tHttpStatus status = getStatus(request);\n  \t\treturn new ResponseEntity<Map<String, Object>>(body, status);\n  \t}\n  ```\n\n- ErrorPageCustomizer\n\n  ```java\n  @Value(\"${error.path:/error}\")\n  private String path = \"/error\";//系统出现错误以后来到error请求进行处理，(web.xml)\n  ```\n\n- DefaultErrorViewResolver\n\n  ```java\n  @Override\n  public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,\n        Map<String, Object> model) {\n     ModelAndView modelAndView = resolve(String.valueOf(status), model);\n     if (modelAndView == null && SERIES_VIEWS.containsKey(status.series())) {\n        modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);\n     }\n     return modelAndView;\n  }\n  \n  private ModelAndView resolve(String viewName, Map<String, Object> model) {\n      //默认SpringBoot可以找到一个页面？error/状态码\n     String errorViewName = \"error/\" + viewName;\n      //如果模板引擎可以解析地址，就返回模板引擎解析\n     TemplateAvailabilityProvider provider = this.templateAvailabilityProviders\n           .getProvider(errorViewName, this.applicationContext);\n     if (provider != null) {\n         //有模板引擎就返回到errorViewName指定的视图地址\n        return new ModelAndView(errorViewName, model);\n     }\n      //自己的文件 就在静态文件夹下找静态文件 /静态资源文件夹/404.html\n     return resolveResource(errorViewName, model);\n  }\n  ```\n\n一旦系统出现4xx或者5xx错误 ErrorPageCustomizer就回来定制错误的响应规则,就会来到 /error请求,BasicErrorController处理，就是一个Controller\n\n1.响应页面,去哪个页面是由 DefaultErrorViewResolver 拿到所有的错误视图\n\n```java\nprotected ModelAndView resolveErrorView(HttpServletRequest request,\n      HttpServletResponse response, HttpStatus status, Map<String, Object> model) {\n   for (ErrorViewResolver resolver : this.errorViewResolvers) {\n      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);\n      if (modelAndView != null) {\n         return modelAndView;\n      }\n   }\n   return null;\n}\n```\n\nl浏览器发送请求 accpt:text/html\n\n客户端请求：accept:/*\n\n### 2、如何定制错误响应\n\n​\t1）、如何定制错误的页面\n\n​\t\t1.有模板引擎：静态资源/404.html,什么错误什么页面；所有以4开头的 4xx.html 5开头的5xx.html\n\n​\t\t有精确的404和4xx优先选择404\n\n​\t\t页面获得的数据\n\n​\t\t\ttimestamp：时间戳\n\n​\t\t\tstatus：状态码\n\n​\t\t\terror：错误提示\n\n​\t\t\texception：异常对象\n\n​\t\t\tmessage：异常信息\n\n​\t\t\terrors:JSR303有关\n\n​\t\t2.没有放在模板引擎，放在静态文件夹，也可以显示，就是没法使用模板取值\n\n​\t\t3.没有放模板引擎，没放静态，会显示默认的错误\n\n​\t2）、如何定义错误的数据\n\n\n\n举例子：新建4xx和5xx文件\n\n![21.error-static](E:\\工作文档\\SpringBoot\\images\\21.error-static.jpg)\n\n\n\n```html\n<body >\n    <p>status: [[${status}]]</p>\n    <p>timestamp: [[${timestamp}]]</p>\n    <p>error: [[${error}]]</p>\n    <p>message: [[${message}]]</p>\n    <p>exception: [[${exception}]]</p>\n</body>\n```\n\n![22.4xxhtml](E:\\工作文档\\SpringBoot\\images\\22.4xxhtml.jpg)\n\n### 3、如何定制Json数据\n\n#### 1、仅发送json数据\n\n```java\npublic class UserNotExitsException extends  RuntimeException {\n    public UserNotExitsException(){\n        super(\"用户不存在\");\n    }\n}\n```\n\n```java\n/**\n * 异常处理器\n */\n@ControllerAdvice\npublic class MyExceptionHandler {\n\n    @ResponseBody\n    @ExceptionHandler(UserNotExitsException.class)\n    public Map<String ,Object> handlerException(Exception e){\n        Map<String ,Object> map =new HashMap<>();\n        map.put(\"code\", \"user not exist\");\n        map.put(\"message\", e.getMessage());\n        return map;\n    }\n}\n```\n\n无法自适应 都是返回的json数据\n\n#### 2、转发到error自适应处理\n\n```java\n@ExceptionHandler(UserNotExitsException.class)\npublic String handlerException(Exception e, HttpServletRequest request){\n    Map<String ,Object> map =new HashMap<>();\n    //传入自己的状态码\n    request.setAttribute(\"javax.servlet.error.status_code\", 432);\n    map.put(\"code\", \"user not exist\");\n    map.put(\"message\", e.getMessage());\n    //转发到error\n    return \"forward:/error\";\n}\n```\n\n程序默认获取状态码\n\n```java\nprotected HttpStatus getStatus(HttpServletRequest request) {\n   Integer statusCode = (Integer) request\n         .getAttribute(\"javax.servlet.error.status_code\");\n   if (statusCode == null) {\n      return HttpStatus.INTERNAL_SERVER_ERROR;\n   }\n   try {\n      return HttpStatus.valueOf(statusCode);\n   }\n   catch (Exception ex) {\n      return HttpStatus.INTERNAL_SERVER_ERROR;\n   }\n```\n\n没有自己写的自定义异常数据\n\n#### 3、自适应和定制数据传入\n\nSpring 默认的原理，出现错误后回来到error请求，会被BasicErrorController处理,响应出去的数据是由BasicErrorController的父类AbstractErrorController(ErrorController)规定的方法getAttributes得到的；\n\n1、编写一个ErrorController的实现类【或者AbstractErrorController的子类】，放在容器中；\n\n2、页面上能用的数据，或者是json数据返回能用的数据都是通过errorAttributes.getErrorAttributes得到；\n\n容器中的DefaultErrorAtrributes.getErrorAtrributees();默认进行数据处理\n\n```java\npublic class MyErrorAttributes extends DefaultErrorAttributes {\n    @Override\n    public Map<String, Object> getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) {\n        Map<String, Object> map = super.getErrorAttributes(requestAttributes, includeStackTrace);\n        map.put(\"company\", \"wdjr\");\n        return map;\n    }\n}\n```\n\n异常处理：把map方法请求域中\n\n```java\n    @ExceptionHandler(UserNotExitsException.class)\n    public String handlerException(Exception e, HttpServletRequest request){\n        Map<String ,Object> map =new HashMap<>();\n        //传入自己的状态码\n        request.setAttribute(\"javax.servlet.error.status_code\", 432);\n        map.put(\"code\", \"user not exist\");\n        map.put(\"message\", e.getMessage());\n        request.setAttribute(\"ext\", map);\n        //转发到error\n        return \"forward:/error\";\n    }\n}\n```\n\n在上面的MyErrorAttributes类中加上\n\n```java\n//我们的异常处理器\nMap<String,Object> ext = (Map<String, Object>) requestAttributes.getAttribute(\"ext\", 0);\nmap.put(\"ext\", ext);\n```\n\n## 8、配置嵌入式servlet容器\n\n### 1、定制和修改Servlet容器\n\nSpringBoot默认使用Tomcat作为嵌入式的Servlet容器；\n\n![23.tomcat emd](E:\\工作文档\\SpringBoot\\images\\23.tomcat emd.jpg)\n\n问题？\n\n1）、如何定制和修改Servlet容器；\n\n1、 修改Server相关的配置文件 application.properties\n\n```properties\n#通用的servlet容器配置\nserver.xxx\n#tomcat的配置\nserver.tomcat.xxxx\n```\n\n2、编写一个EmbeddedServletContainerCustomizer;嵌入式的Servlet容器的定制器；来修改Servlet的容器配置\n\n```java\n@Bean\npublic EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){\n    return new EmbeddedServletContainerCustomizer() {\n        //定制嵌入式Servlet的容器相关规则\n        @Override\n        public void customize(ConfigurableEmbeddedServletContainer container) {\n            container.setPort(8999);\n        }\n    };\n}\n```\n\n其实同理，都是实现EmbeddedServletContainerCustomizer\n\n### 2、注册Servlet三大组件\n\n三大组件 Servlet Filter Listener\n\n由于SprringBoot默认是以jar包启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml\n\n注册三大组件\n\n#### ServletRegistrationBean\n\n```java\n@Bean\npublic ServletRegistrationBean myServlet(){\n    ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new MyServlet(),\"/servlet\");\n    return servletRegistrationBean;\n}\n```\n\nMyServlet\n\n```java\npublic class MyServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.getWriter().write(\"Hello Servlet\");\n    }\n}\n```\n\n#### FilterRegistrationBean\n\n```java\n@Bean\npublic FilterRegistrationBean myFilter(){\n    FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n    filterRegistrationBean.setFilter(new MyFilter());\n    filterRegistrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\"));\n    return filterRegistrationBean;\n}\n```\n\nMyFilter\n\n```java\npublic class MyFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        System.out.println(\"MyFilter process\");\n        chain.doFilter(request, response);\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n```\n\n#### ServletListenerRegistrationBean\n\n```java\n@Bean\npublic ServletListenerRegistrationBean myListener(){\n    ServletListenerRegistrationBean<MyListener> registrationBean = new ServletListenerRegistrationBean<>(new MyListener());\n    return registrationBean;\n}\n```\n\nMyListener\n\n```java\npublic class MyListener implements ServletContextListener {\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println(\".........web应用启动..........\");\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        System.out.println(\".........web应用销毁..........\");\n    }\n}\n```\n\n\n\nSpringBoot帮助我们自动配置SpringMVC的时候，自动注册SpringMVC的前端控制器；DispatcherServlet;\n\n```java\n@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)\n@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\n   public ServletRegistrationBean dispatcherServletRegistration(\n         DispatcherServlet dispatcherServlet) {\n      ServletRegistrationBean registration = new ServletRegistrationBean(\n            dispatcherServlet, this.serverProperties.getServletMapping());\n       //默认拦截 /所有请求 包括静态资源 不包括jsp\n       //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径\n      registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);\n      registration.setLoadOnStartup(\n            this.webMvcProperties.getServlet().getLoadOnStartup());\n      if (this.multipartConfig != null) {\n         registration.setMultipartConfig(this.multipartConfig);\n      }\n      return registration;\n   }\n\n}\n```\n\n### 3、切换其他的Servlet容器\n\n在ServerProperties中\n\n```java\nprivate final Tomcat tomcat = new Tomcat();\n\nprivate final Jetty jetty = new Jetty();\n\nprivate final Undertow undertow = new Undertow();\n```\n\ntomcat(默认支持)\n\njetty（长连接）\n\nundertow（多并发）\n\n切换容器 仅仅需要修改pom文件的依赖就可以\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n            <exclusions>\n                <exclusion>\n                    <artifactId>spring-boot-starter-tomcat</artifactId>\n                    <groupId>org.springframework.boot</groupId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-jetty</artifactId>\n        </dependency>\n<!--        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-undertow</artifactId>\n        </dependency>-->\n```\n\n### 4、嵌入式Servlet容器自动配置原理\n\n```java\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)\n@Configuration\n@ConditionalOnWebApplication\n@Import(BeanPostProcessorsRegistrar.class)\n//给容器导入组件 后置处理器 在Bean初始化前后执行前置后置的逻辑 创建完对象还没属性赋值进行初始化工作\npublic class EmbeddedServletContainerAutoConfiguration {\n    @Configuration\n\t@ConditionalOnClass({ Servlet.class, Tomcat.class })//当前是否引入tomcat依赖\n    //判断当前容器没有用户自定义EmbeddedServletContainerFactory，就会创建默认的嵌入式容器\n\t@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)\n\tpublic static class EmbeddedTomcat {\n\n\t\t@Bean\n\t\tpublic TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {\n\t\t\treturn new TomcatEmbeddedServletContainerFactory();\n\t\t}\n```\n\n1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）\n\n```java\npublic interface EmbeddedServletContainerFactory {\n\t//获取嵌入式的Servlet容器\n   EmbeddedServletContainer getEmbeddedServletContainer(\n         ServletContextInitializer... initializers);\n\n}\n```\n\n继承关系\n\n![24.EmdServletFactory](E:\\工作文档\\SpringBoot\\images\\24.EmdServletFactory.jpg)\n\n2）、EmbeddedServletContainer:(嵌入式的Servlet容器)\n\n![25.EmdServletContainer](E:\\工作文档\\SpringBoot\\images\\25.EmdServletContainer.jpg)\n\n3）、TomcatEmbeddedServletContainerFactory为例 \n\n```java\n@Override\npublic EmbeddedServletContainer getEmbeddedServletContainer(\n      ServletContextInitializer... initializers) {\n   Tomcat tomcat = new Tomcat();\n    //配置tomcat的基本环节\n   File baseDir = (this.baseDirectory != null ? this.baseDirectory\n         : createTempDir(\"tomcat\"));\n   tomcat.setBaseDir(baseDir.getAbsolutePath());\n   Connector connector = new Connector(this.protocol);\n   tomcat.getService().addConnector(connector);\n   customizeConnector(connector);\n   tomcat.setConnector(connector);\n   tomcat.getHost().setAutoDeploy(false);\n   configureEngine(tomcat.getEngine());\n   for (Connector additionalConnector : this.additionalTomcatConnectors) {\n      tomcat.getService().addConnector(additionalConnector);\n   }\n   prepareContext(tomcat.getHost(), initializers);\n    //将配置好的tomcat传入进去；并且启动tomcat容器\n   return getTomcatEmbeddedServletContainer(tomcat);\n}\n```\n\n4）、嵌入式配置修改\n\n```\nServerProperties、EmbeddedServletContainerCustomizer\n```\n\nEmbeddedServletContainerCustomizer:定制器帮我们修改了Servlet容器配置？\n\n怎么修改？\n\n\n\n5）、容器中导入了**EmbeddedServletContainerCustomizerBeanPostProcessor**\n\n```java\n@Override\npublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,\n      BeanDefinitionRegistry registry) {\n   if (this.beanFactory == null) {\n      return;\n   }\n   registerSyntheticBeanIfMissing(registry,\n         \"embeddedServletContainerCustomizerBeanPostProcessor\",\n         EmbeddedServletContainerCustomizerBeanPostProcessor.class);\n   registerSyntheticBeanIfMissing(registry,\n         \"errorPageRegistrarBeanPostProcessor\",\n         ErrorPageRegistrarBeanPostProcessor.class);\n}\n```\n\n```java\n@Override\npublic Object postProcessBeforeInitialization(Object bean, String beanName)\n      throws BeansException {\n    //如果当前初始化的是一个ConfigurableEmbeddedServletContainer\n   if (bean instanceof ConfigurableEmbeddedServletContainer) {\n      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);\n   }\n   return bean;\n}\n\nprivate void postProcessBeforeInitialization(\n    ConfigurableEmbeddedServletContainer bean) {\n    //获取所有的定制器，调用每个定制器的customer方法给Servlet容器进行赋值\n    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {\n        customizer.customize(bean);\n    }\n}\n\nprivate Collection<EmbeddedServletContainerCustomizer> getCustomizers() {\n    if (this.customizers == null) {\n        // Look up does not include the parent context\n        this.customizers = new ArrayList<EmbeddedServletContainerCustomizer>(\n            this.beanFactory\n            //从容器中获取所有的这个类型的组件：EmbeddedServletContainerCustomizer\n            //定制Servlet,给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件\n            .getBeansOfType(EmbeddedServletContainerCustomizer.class,\n                            false, false)\n            .values());\n        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);\n        this.customizers = Collections.unmodifiableList(this.customizers);\n    }\n    return this.customizers;\n}\n```\n\nServerProperties也是EmbeddedServletContainerCustomizer定制器\n\n步骤：\n\n1）、SpringBoot根据导入的依赖情况，给容器中添加响应的容器工厂 例：tomcat\n\nEmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】\n\n2）、容器中某个组件要创建对象就要通过后置处理器；\n\n```java\nEmbeddedServletContainerCustomizerBeanPostProcessor\n```\n\n只要是嵌入式的Servlet容器工厂，后置处理器就工作；\n\n3）、后置处理器，从容器中获取的所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法\n\n### 5、嵌入式Servlet容器启动原理\n\n什么时候创建嵌入式的Servlet的容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat;\n\n获取嵌入式的容器工厂\n\n1）、SpringBoot应用启动Run方法\n\n2）、刷新IOC容器对象【创建IOC容器对象，并初始化容器，创建容器的每一个组件】；如果是web环境AnnotationConfigEmbeddedWebApplicationContext,如果不是AnnotationConfigApplicationContext\n\n```JAVA\nif (contextClass == null) {\n   try {\n      contextClass = Class.forName(this.webEnvironment\n            ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);\n   }\n```\n\n3）、refresh(context);刷新创建好的IOC容器\n\n```java\ntry {\n   // Allows post-processing of the bean factory in context subclasses.\n   postProcessBeanFactory(beanFactory);\n\n   // Invoke factory processors registered as beans in the context.\n   invokeBeanFactoryPostProcessors(beanFactory);\n\n   // Register bean processors that intercept bean creation.\n   registerBeanPostProcessors(beanFactory);\n\n   // Initialize message source for this context.\n   initMessageSource();\n\n   // Initialize event multicaster for this context.\n   initApplicationEventMulticaster();\n\n   // Initialize other special beans in specific context subclasses.\n   onRefresh();\n\n   // Check for listener beans and register them.\n   registerListeners();\n\n   // Instantiate all remaining (non-lazy-init) singletons.\n   finishBeanFactoryInitialization(beanFactory);\n\n   // Last step: publish corresponding event.\n   finishRefresh();\n}\n```\n\n4）、 onRefresh();web的ioc容器重写了onRefresh方法\n\n5）、webioc会创建嵌入式的Servlet容器；createEmbeddedServletContainer\n\n6）、获取嵌入式的Servlet容器工厂；\n\n```java\nEmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();\n```\n\n从ioc容器中获取EmbeddedServletContainerFactory组件；\n\n```java\n@Bean\npublic TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {\nreturn new TomcatEmbeddedServletContainerFactory();\n}\n```\nTomcatEmbeddedServletContainerFactory创建对象，后置处理器看这个对象，就来获取所有的定制器来定制Servlet容器的相关配置；\n\n7）、使用容器工厂获取嵌入式的Servlet容器\n\n8）、嵌入式的Servlet容器创建对象并启动Servlet容器；\n\n先启动嵌入式的Servlet容器，在将ioc容器中剩下的没有创建出的对象获取出来\n\nioc启动创建Servlet容器\n\n## 9、使用外置的Servlet容器\n\n嵌入式的Servlet容器：应用达成jar包\n\n​\t优点：简单、便携\n\n​\t缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义定制器】，自己来编写嵌入式的容器工厂）\n\n外置的Servlet容器：外面安装Tomcat是以war包的方式打包。\n\n### 1、IDEA操作外部Servlet\n\n1、创建程序为war程序\n\n![26.tomcat1](E:\\工作文档\\SpringBoot\\images\\26.tomcat1.jpg)\n\n2、选择版本\n\n![27.tomcat2](E:\\工作文档\\SpringBoot\\images\\27.tomcat2.jpg)\n\n3、添加tomcat\n\n![28.tomcat3](E:\\工作文档\\SpringBoot\\images\\28.tomcat3.jpg)\n\n4、选择tomcat\n\n![30.tomcat4](E:\\工作文档\\SpringBoot\\images\\30.tomcat4.jpg)\n\n5、选择本地的Tomcat\n\n![31.tomcat5](E:\\工作文档\\SpringBoot\\images\\31.tomcat5.jpg)\n\n6、配置tomcat路径\n\n![32.tomcat6](E:\\工作文档\\SpringBoot\\images\\32.tomcat6.jpg)\n\n7、添加服务器\n\n![33.tomcat7](E:\\工作文档\\SpringBoot\\images\\33.tomcat7.jpg)\n\n8、添加exploded的war配置，应用OK tomcat配置完成\n\n![34.tomcat8](E:\\工作文档\\SpringBoot\\images\\34.tomcat8.jpg)\n\n二、配置webapp文件夹\n\n1、点击配置\n\n![35.tomcat9](E:\\工作文档\\SpringBoot\\images\\35.tomcat9.jpg)\n\n2、添加webapp目录\n\n![36.tomcat10](E:\\工作文档\\SpringBoot\\images\\36.tomcat10.jpg)\n\n3、默认配置就可以\n\n![37.tomcat11](E:\\工作文档\\SpringBoot\\images\\37.tomcat11.jpg)\n\n4、配置web.xml文件\n\n![38.tomcat12](E:\\工作文档\\SpringBoot\\images\\38.tomcat12.jpg)\n\n5、文档目录结构\n\n![39.tomcat13](E:\\工作文档\\SpringBoot\\images\\39.tomcat13.jpg)\n\n### 2、运行一个示例\n\n1、项目目录\n\n![40.demo1](E:\\工作文档\\SpringBoot\\images\\40.demo1.jpg)\n\n2、配置文件写视图解析前后缀\n\n```properties\nspring.mvc.view.prefix=/WEB-INF/jsp/\n\nspring.mvc.view.suffix=.jsp\n```\n\n3、HelloController\n\n```java\n@Controller\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello(Model model){\n        model.addAttribute(\"message\",\"这是Controller传过来的message\");\n        return \"success\";\n    }\n}\n```\n\n4、success.jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Success</title>\n</head>\n<body>\n<h1>Success</h1>\nmessage:${message}\n</body>\n</html>\n```\n\n5、运行结果\n\n![41.demo2](E:\\工作文档\\SpringBoot\\images\\41.demo2.jpg)\n\n步骤\n\n1、必须创建一个war项目；\n\n2、将嵌入式的Tomcat指定为provided\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-tomcat</artifactId>\n    <scope>provided</scope>\n</dependency>\n```\n\n3、必须编写一个SpringBootServletInitializer的子类，并调用configure方法里面的固定写法\n\n```java\npublic class ServletInitializer extends SpringBootServletInitializer {\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n        //传入SpringBoot的主程序，\n        return application.sources(SpringBoot04WebJspApplication.class);\n    }\n\n}\n```\n\n4、启动服务器就可以；\n\n### 3、原理\n\njar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet的容器；\n\nwar包：启动服务器，服务器启动SpringBoot应用，【SpringBootServletInitializer】启动ioc容器\n\nservlet3.0规范\n\n 8.2.4 共享库和运行时插件\n\n规则：\n\n1、服务器启动（web应用启动），会创建当前的web应用里面每一个jar包里面ServletContrainerInitializer的实现类的实例\n\n2、SpringBootServletInitializer这个类的实现需要放在jar包下的META-INF/services文件夹下，有一个命名为javax.servlet.ServletContainerInitalizer的文件，内容就是ServletContainerInitializer的实现类全类名\n\n3、还可以使用@HandlerTypes注解，在应用启动的时候可以启动我们感兴趣的类\n\n\n\n流程：\n\n1、启动Tomcat服务器\n\n2、spring web模块里有这个文件\n\n![42.servletContainerInit](E:\\工作文档\\SpringBoot\\images\\42.servletContainerInit.jpg)\n\n```java\norg.springframework.web.SpringServletContainerInitializer\n```\n\n3、SpringServletContainerInitializer将handlerTypes标注的所有类型的类传入到onStartip方法的Set<Class<?>>;为这些感兴趣类创建实例\n\n4、每个创建好的WebApplicationInitializer调用自己的onStratup\n\n5、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法\n\n6、SpringBootServletInitializer执行onStartup方法会创建createRootApplicationContext\n\n```java\nprotected WebApplicationContext createRootApplicationContext(ServletContext servletContext) {\n    SpringApplicationBuilder builder = this.createSpringApplicationBuilder();\n    //环境构建器\n    StandardServletEnvironment environment = new StandardServletEnvironment();\n    environment.initPropertySources(servletContext, (ServletConfig)null);\n    builder.environment(environment);\n    builder.main(this.getClass());\n    ApplicationContext parent = this.getExistingRootWebApplicationContext(servletContext);\n    if (parent != null) {\n        this.logger.info(\"Root context already created (using as parent).\");\n        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, (Object)null);\n        builder.initializers(new ApplicationContextInitializer[]{new ParentContextApplicationContextInitializer(parent)});\n    }\n\t\n    builder.initializers(new ApplicationContextInitializer[]{new ServletContextApplicationContextInitializer(servletContext)});\n    builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);\n    //调用Configure,子类重写了这个方法，将SpringBoot的主程序类传入进来\n    builder = this.configure(builder);\n    //创建一个spring应用\n    SpringApplication application = builder.build();\n    if (application.getSources().isEmpty() && AnnotationUtils.findAnnotation(this.getClass(), Configuration.class) != null) {\n        application.getSources().add(this.getClass());\n    }\n\n    Assert.state(!application.getSources().isEmpty(), \"No SpringApplication sources have been defined. Either override the configure method or add an @Configuration annotation\");\n    if (this.registerErrorPageFilter) {\n        application.getSources().add(ErrorPageFilterConfiguration.class);\n    }\n\t//最后启动Spring容器\n    return this.run(application);\n}\n```\n\n7、Spring的应用就启动完了并且创建IOC容器；\n\n```java\npublic ConfigurableApplicationContext run(String... args) {\n   StopWatch stopWatch = new StopWatch();\n   stopWatch.start();\n   ConfigurableApplicationContext context = null;\n   FailureAnalyzers analyzers = null;\n   configureHeadlessProperty();\n   SpringApplicationRunListeners listeners = getRunListeners(args);\n   listeners.starting();\n   try {\n      ApplicationArguments applicationArguments = new DefaultApplicationArguments(\n            args);\n      ConfigurableEnvironment environment = prepareEnvironment(listeners,\n            applicationArguments);\n      Banner printedBanner = printBanner(environment);\n      context = createApplicationContext();\n      analyzers = new FailureAnalyzers(context);\n      prepareContext(context, environment, listeners, applicationArguments,\n            printedBanner);\n      refreshContext(context);\n      afterRefresh(context, applicationArguments);\n      listeners.finished(context, null);\n      stopWatch.stop();\n      if (this.logStartupInfo) {\n         new StartupInfoLogger(this.mainApplicationClass)\n               .logStarted(getApplicationLog(), stopWatch);\n      }\n      return context;\n   }\n   catch (Throwable ex) {\n      handleRunFailure(context, listeners, analyzers, ex);\n      throw new IllegalStateException(ex);\n   }\n}\n```\n\n# 五、Docker\n\n## 1、简介\n\nDocker是一个开源的应用容器引擎\n\n将软件编译成一个镜像；然后在镜像里各种软件做好配置，将镜像发布出去，其他的使用这就可以直接使用这个镜像。运行中的这个镜像叫做容器，容器启动速度快，类似ghost操作系统，安装好了什么都有了；\n\n## 2、Docker的核心概念\n\ndocker主机（HOST）:安装了Docker程序的机器（Docker直接安装在操作系统上的）\n\ndocker客户端（Client）:操作docker主机\n\ndocker仓库（Registry）：用来保存打包好的软件镜像\n\ndocker镜像（Image）:软件打好包的镜像，放到docker的仓库中\n\ndocker容器（Container）:镜像启动后的实例（5个容器启动5次镜像）\n\ndocker的步骤：\n\n​\t1、安装Docker\n\n​\t2、去Docker仓库找到这个软件对应的镜像；\n\n​\t3、使用Docker运行的这个镜像，镜像就会生成一个容器\n\n​\t4、对容器的启动停止，就是对软件的启动和停止\n\n## 3、安装Docker\n\n### 1、安装Linux\n\n[安装vxbox并且安装ubuntu](http://note.youdao.com/noteshare?id=06ccb673d253fea78fe35430465758e1)\n\n### 2、在linux上安装docker\n\n```shell\n1、查看centos版本\n# uname -r\n3.10.0-693.el7.x86_64\n要求：大于3.10\n如果小于的话升级*（选做）\n# yum update\n2、安装docker\n# yum install docker\n3、启动docker\n# systemctl start docker\n# docker -v\n4、开机启动docker\n# systemctl enable docker\n5、停止docker\n# systemctl stop docker\n```\n\n## 4、docker的常用操作\n\n### 1、镜像操作\n\n1、搜索\n\n```shell\ndocker search mysql\n```\n\n默认去docker hub网站查找![44.docker1](E:\\工作文档\\SpringBoot\\images\\44.docker1.jpg)\n\n2、拉取\n\n```shell\n默认最新版本\n# docekr pull mysql\n安装指定版本\n# docker pull mysql:5.5\n```\n\n3、查看\n\n```shell\ndocker images\n```\n\n4、删除\n\n```\ndocker rmi imageid\n```\n\n### 2、容器操作\n\n软件的镜像（qq.exe） -- 运行镜像 -- 产生一个容器（正在运行的软件）\n\n```shell\n1、搜索镜像\n# docker search tomcat\n2、拉取镜像\n# docker pull tomcat\n3、根据镜像启动容器\n[root@lion ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ndocker.io/tomcat    latest              d3d38d61e402        35 hours ago        549 MB\n[root@lion ~]# docker run --name mytomcat -d tomcat:latest\n2f0348702f5f2a2777082198795d8059d83e5ee38f430d2d44199939cc63e249\n4、查看那个进程正在进行\n[root@lion ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n2f0348702f5f        tomcat:latest       \"catalina.sh run\"   41 seconds ago      Up 39 seconds       8080/tcp            mytomcat\n5、停止运行中容器\n[root@lion ~]# docker stop 2f0348702f5f\n2f0348702f5f\n6、查看所有容器\n[root@lion ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS               NAMES\n2f0348702f5f        tomcat:latest       \"catalina.sh run\"   52 minutes ago      Exited (143) 2 minutes ago                       mytomcat\n7、启动容器\n[root@lion ~]# docker start 2f0348702f5f\n8、删除docker容器\n[root@lion ~]# docker rm 2f0348702f5f\n2f0348702f5f\n9、端口映射\n[root@lion ~]# docker run --name mytomcat -d -p 8888:8080 tomcat\n692c408c220128014df32ecb6324fb388427d1ecd0ec56325580135c58f63b29\n虚拟机:8888\n容器的:8080\n-d:后台运行\n-p:主机端口映射到容器端口\n浏览器：192.168.179.129:8888\n10、docker的日志\n[root@lion ~]# docker logs 692c408c2201\n11、多个启动\n[root@lion ~]# docker run -d -p 9000:8080 --name mytomcat2 tomcat\n浏览器：192.168.179.129:9000\n```\n\n更多命令参考docker镜像文档\n\n### 3、安装Mysql\n\n```shell\ndocker pull mysql\ndocker run --name mysql001 -e MYSQL_ROOT_PASSWORD -d -p 3307:3306 mysql\n```\n\n# 六、数据访问\n\n## 1、整合JDBC数据源\n\n1、新建项目 spring-boot-06-data-jdbc\n\n- WEB\n- Mysql\n- JDBC\n- SpringBoot1.5\n\n2、编写配置文件appliction.yml\n\n```yaml\nspring:\n  datasource:\n    username: root\n    password: Welcome_1\n    url: jdbc:mysql://192.168.179.131:3306/jdbc\n    driver-class-name: com.mysql.jdbc.Driver\n```\n\n3、编写测试类测试\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBoot06DataJdbcApplicationTests {\n\n    @Autowired\n    DataSource dataSource;\n\n    @Test\n    public void contextLoads() throws SQLException {\n        System.out.println(dataSource.getClass());\n\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection);\n        connection.close();\n    }\n\n}\n```\n\n4、测试结果\n\n```\nclass org.apache.tomcat.jdbc.pool.DataSource\nProxyConnection[PooledConnection[com.mysql.jdbc.JDBC4Connection@c35af2a]]\n```\n\n数据源相关配置都在DataSourceProperties属性里\n\n自动配置原理\n\nE:\\Develop\\Maven_Repo\\org\\springframework\\boot\\spring-boot-autoconfigure\\1.5.13.RELEASE\\spring-boot-autoconfigure-1.5.13.RELEASE.jar!\\org\\springframework\\boot\\autoconfigure\\jdbc\n\n### 1、DataSource\n\n参考DataSourceConfiguration,根据配置创建数据源，默认是使用tomcat连接池，可以使用spring.datasource.type指定自定义的数据源\n\n### 2、SpringBoot默认支持\n\n```\nTomcat数据源\nHikariDataSource\ndbcp.BasicDataSource\ndbcp2.BasicDataSource\n```\n\n### 3、自定义数据源\n\n```java\n */\n@ConditionalOnMissingBean(DataSource.class)\n@ConditionalOnProperty(name = \"spring.datasource.type\")\nstatic class Generic {\n\n   @Bean\n   public DataSource dataSource(DataSourceProperties properties) {\n       //使用builder创建数据源，利用反射创建相应的type数据源，并绑定数据源\n      return properties.initializeDataSourceBuilder().build();\n   }\n\n}\n```\n\n### 4、运行sql建表\n\n在DataSourceAutoConfiguration中**DataSourceInitializer**类\n\n监听器\n\n作用：\n\n1）、postConstruct -》runSchemaScript 运行建表sql文件\n\n2）、runDataScript运行插入数据的sql语句；\n\n默认只需要将文件命名为：\n\n```sql\nschema-*.sql data-*.sql\n默认规则：schema.sql ,schema-all.sql;\n```\n\n**举个栗子**\n\n创建department表\n\n1、department.sql\n\n```sql\n/*\nNavicat MySQL Data Transfer\n\nSource Server         : 192.168.179.131\nSource Server Version : 50719\nSource Host           : 192.168.179.131:3306\nSource Database       : jdbc\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50719\nFile Encoding         : 65001\n\nDate: 2018-05-14 14:28:52\n*/\n\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for department\n-- ----------------------------\nDROP TABLE IF EXISTS `department`;\nCREATE TABLE `department` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `departmentName` varchar(255) DEFAULT '',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n```\n\n2、将department.sql命名为schema-all.sql\n\n![45.schema-all](E:\\工作文档\\SpringBoot\\images\\45.schema-all.jpg)\n\n3、运行测试类\n\n自定义sql的文件名，department.sql在配置文件中\n\n```yaml\nschema:\n  - classpath:department.sql\n```\n\n-----\n\n### 5、操作JdbcTemplate\n\n**FBI warning**:将department.sql删除或者改名，因为运行文件会将表中数据清除\n\n1、新建一个Controller\n\n```java\n@Controller\npublic class HelloController {\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n    @ResponseBody\n    @GetMapping(\"/hello\")\n    public Map<String ,Object> hello(){\n\n        List<Map<String, Object>> list = jdbcTemplate.queryForList(\"select * from department\");\n        return list.get(0);\n    }\n}\n```\n\n2、表中添加数据\n\n![46.department](E:\\工作文档\\SpringBoot\\images\\46.department.jpg)\n\n\n\n3、访问请求查询数据\n\n![47.hello](E:\\工作文档\\SpringBoot\\images\\47.hello.jpg)\n\n\n\n## 2、自定义数据源\n\n1、导入Druid的依赖\n\n```xml\n<!-- https://mvnrepository.com/artifact/com.alibaba/druid -->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.1.9</version>\n</dependency>\n\n```\n\n2、修改配置文件\n\n```yaml\nspring:\n  datasource:\n    username: root\n    password: Welcome_1\n    url: jdbc:mysql://192.168.179.131:3306/jdbc\n    driver-class-name: com.mysql.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n#    schema:\n#      - classpath:department.sql\nserver:\n  port: 9000\n```\n\n已经替换了原来的tomcat数据源\n\n3、配置Druid数据源配置\n\n```yaml\nspring:\n  datasource:\n    username: root\n    password: Welcome_1\n    url: jdbc:mysql://192.168.179.131:3306/jdbc\n    driver-class-name: com.mysql.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n\t# 初始化大小，最小，最大  \n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n    # 配置获取连接等待超时的时间  \n    maxWait: 60000\n    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 \n    timeBetweenEvictionRunsMillis: 60000\n    # 配置一个连接在池中最小生存的时间，单位是毫秒 \n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n    # 配置监控统计拦截的filters,去掉监控界面sql无法统计，‘wall’用于防火墙\n    filters: stat,wall,log4j\n    maxPoolPreparedStatementPerConnectionSize: 20\n    userGlobalDataSourceStat: true\n    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录  \n    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n#    schema:\n#      - classpath:department.sql\nserver:\n  port: 9000\n```\n\n4、Druid配置监控\n\n```java\n@Configuration\npublic class DruidConfig {\n\n    @ConfigurationProperties(prefix = \"spring.datasource\")\n    @Bean\n    public DataSource druid(){\n        return  new DruidDataSource();\n    }\n\n    //配置Druid的监控\n    //1、配置一个管理后台\n    @Bean\n    public ServletRegistrationBean statViewServlet(){\n        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),\"/druid/*\");\n        Map<String,String> initParams =new HashMap<>();\n        initParams.put(\"loginUsername\", \"admin\");\n        initParams.put(\"loginPassword\", \"123456\");\n        bean.setInitParameters(initParams);\n        return bean;\n    }\n    //2、配置监控的filter\n    @Bean\n    public FilterRegistrationBean webstatFilter(){\n        FilterRegistrationBean bean = new FilterRegistrationBean();\n        bean.setFilter(new WebStatFilter());\n\n        Map<String,String> initParams =new HashMap<>();\n        initParams.put(\"exclusions\", \"*.js,*.css,/druid/*\");\n        bean.setInitParameters(initParams);\n        bean.setUrlPatterns(Arrays.asList(\"/*\"));\n        return bean;\n    }\n\n}\n```\n\n5、运行测试，访问 localhost:9000/druid\n\n![48.druid](E:\\工作文档\\SpringBoot\\images\\48.druid.jpg)\n\n输入刚才调好的用户名密码即可访问\n\n## 3、整合Mybatis\n\n1、新建工程，SpringBoot1.5+web+JDBC+Mysql\n\n导入依赖\n\n```xml\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>1.3.2</version>\n</dependency>\n<!-- https://mvnrepository.com/artifact/com.alibaba/druid -->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.1.9</version>\n</dependency>\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <scope>runtime</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n```\n\n2、导入配置文件中关于Druid的配置\n\n​\t2.1、导入依赖\n\n​\t2.2、配置文件application.yml（指定用户名密码...配置Druid的配置参数，修改sql文件加载的默认名）\n\n​\t2.3、将Druid组件加入到容器中（监控）重点\n\n​\t具体同上\n\n3、创建数据表department和employee表\n\n​\t3.1、根据sql文件，新建两张表\n\n​\t3.2、修改加载的sql名（默认为schema.sql和schema-all.sql）\n\n```yaml\nspring:\n  datasource:\n    schema:\n      - classpath:sql/department.sql\n      - classpath:sql/employeee.sql\n```\n\n​\t3.3、运行程序检查数据库是否创建成功\n\n4、创建数据库对应的JavaBean （驼峰命名，getter/setter toString/注释掉schema防止重复创建） \n\n在配置文件中修改驼峰命名开启 ,不写配置文件就写配置类\n\n```yaml\nmybatis:\n  configuration:\n    map-underscore-to-camel-case: true\n```\n\n```java\n//类名冲突所以全类名\n@org.springframework.context.annotation.Configuration\npublic class MyBatisConfig {\n\n    @Bean\n    public ConfigurationCustomizer configurationCustomizer(){\n\n        return new ConfigurationCustomizer() {\n            @Override\n            public void customize(Configuration configuration) {\n                configuration.setMapUnderscoreToCamelCase(true);\n            }\n        };\n    }\n}\n```\n\n### 注解方式\n\n5、新建mapper\n\n```yaml\n//指定是一个mapper\n@Mapper\npublic interface DepartmentMapper {\n\n    @Insert(\"insert into department(dept_name) value(#{deptName})\")\n    public int insertDept(Department department);\n\n    @Delete(\"delete from department where id=#{id}\")\n    public int deleteDeptById(Integer id);\n\n    @Update(\"update department set dept_Name=#{deptName} where id=#{id}\")\n    public int updateDept(Department department);\n\n    @Select(\"select * from department where id=#{id}\")\n    public Department getDeptById(Integer id);\n\n}\n```\n\n6、编写controller测试\n\n```java\n@RestController\npublic class DeptController {\n\n    @Autowired\n    DepartmentMapper departmentMapper;\n\n    @RequestMapping(\"/getDept/{id}\")\n    public Department getDepartment(@PathVariable(\"id\") Integer id){\n        return departmentMapper.getDeptById(id);\n    }\n\n    @RequestMapping(\"/delDept/{id}\")\n    public int delDept(@PathVariable(\"id\") Integer id){\n        return departmentMapper.deleteDeptById(id);\n    }\n\n    @RequestMapping(\"/update/{id}\")\n    public int updateDept(@PathVariable(\"id\") Integer id){\n        return departmentMapper.updateDept(new Department(id, \"开发部\"));\n    }\n\n    @GetMapping(\"/insert\")\n    public int insertDept(Department department){\n        return departmentMapper.insertDept(department);\n    }\n}\n```\n\n问题：\n\nmapper文件夹下有多个mapper文件，加麻烦，可以直接扫描整个mapper文\n\n件夹下的mapper\n\n```java\n//主配置类或者mybatis配置类\n@MapperScan(value = \"com.wdjr.springboot.mapper\")\n```\n\n### 配置文件方式\n\n1、新建文件\n\n![50.mybatisxml](E:\\工作文档\\SpringBoot\\images\\50.mybatisxml.jpg)\n\n2、新建mybatis的配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <settings>\n        <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n    </settings>\n</configuration>\n```\n\n3、新建Employee的接口方法\n\n```java\npublic interface EmployeeMapper {\n\n    public Employee getEmpById(Integer id);\n\n    public void insetEmp(Employee employee);\n}\n```\n\n4、新建Employee的mapper.xml的映射文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.wdjr.springboot.mapper.EmployeeMapper\">\n    <select id=\"getEmpById\" resultType=\"com.wdjr.springboot.bean.Employee\">\n      select * from employee where id=#{id}\n   </select>\n\n    <insert id=\"insetEmp\">\n        INSERT  INTO employee(last_name,email,gender,d_id) VALUES (#{lastName},#{email},#{gender},#{dId})\n    </insert>\n</mapper>\n```\n\n5、修改application.yml配置文件\n\n```yaml\nmybatis:\n  config-location: classpath:mybatis/mybatis-config.xml\n  mapper-locations: classpath:mybatis/mapper/*.xml\n```\n\n6、新建一个Controller访问方法\n\n```java\n@RestController\npublic class EmployeeController {\n    @Autowired\n    EmployeeMapper employeeMapper;\n\n    @RequestMapping(\"/getEmp/{id}\")\n    public Employee getEmp(@PathVariable(\"id\") Integer id){\n        return employeeMapper.getEmpById(id);\n    }\n\n    @GetMapping(\"/insertEmp\")\n    public Employee insertEmp(Employee employee){\n        employeeMapper.insetEmp(employee);\n        return employee;\n    }\n}\n```\n## 4、JPA数据访问\n\n新建工程 springBoot1.5+Web+JPA+MYSQL+JDBC\n\n目录结构\n\n![51.JPA](E:\\工作文档\\SpringBoot\\images\\51.JPA.jpg)\n\n\n\n1、新建一个实体类User\n\n```java\n//使用JPA注解配置映射关系\n@Entity//告诉JPA这是一个实体类（和数据表映射的类）\n@Table(name=\"tbl_user\") //@Table来指定和那个数据表对应，如果省略默认表明就是user;\n\npublic class User {\n\n    @Id //这是一个主键\n    @GeneratedValue(strategy = GenerationType.IDENTITY)//自增组件\n    private Integer id ;\n\n    @Column(name=\"last_name\",length = 50) //这是和数据表对应的一个列\n    private String lastName;\n    @Column//省略默认列名就是属性名\n    private String email;\n    @Column\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n}\n```\n\n2、新建一个UserRepository来继承jpa的绝大多数功能\n\n```java\n//继承jpaRepository\npublic interface UserRepository extends JpaRepository<User,Integer> {\n\n}\n```\n\n3、编写配置文件application.yml\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://192.168.179.131/jpa\n    username: root\n    password: Welcome_1\n    driver-class-name: com.mysql.jdbc.Driver\n  jpa:\n    hibernate:\n    #更新或创建\n      ddl-auto: update\n    show-sql: true\n```\n\n4、编写Controller测试\n\n```java\n@RestController\npublic class UserController {\n    @Autowired\n    UserRepository userRepository;\n\n    @GetMapping(\"/user/{id}\")\n    public User getUser(@PathVariable(\"id\") Integer id){\n        User user = userRepository.findOne(id);\n        return user;\n    }\n\n    @GetMapping(\"/insert\")\n    public User insertUser(User user){\n        User user1 = userRepository.save(user);\n        return  user1;\n    }\n}\n```\n\n# 七、启动配置原理\n\n几个重要的事件回调机制\n\n加载配置文件META-INF/spring.factories\n\n​\tApplicationContextInitializer\n\n​\tSpringApplicationRunListener\n\nioc容器中\n\n​\tApplicationRunner\n\n​\tCommandLineRunner\n\n启动流程\n\n## 1、创建SpringApplicaiotn对象   \n\n```java\nprivate void initialize(Object[] sources) {\n    //保存主配置类\n   if (sources != null && sources.length > 0) {\n      this.sources.addAll(Arrays.asList(sources));\n   }\n    //判断当前是否是个web应用\n   this.webEnvironment = deduceWebEnvironment();\n    //从类路径下找到META-INF/spring.factories配置中的所有ApplicationInitializer 然后保存起来\n   setInitializers((Collection) getSpringFactoriesInstances(\n         ApplicationContextInitializer.class));\n    //从类路径下找到META-INF/spring.factories配置中的所有ApplicationListener 然后保存起来\n   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n    //决定哪一个是主程序\n   this.mainApplicationClass = deduceMainApplicationClass();\n}\n```\n\nApplicationInitializer\n\n![52.applicationCotextInitializer](E:\\工作文档\\SpringBoot\\images\\52.applicationCotextInitializer.jpg)\n\n ApplicationListener\n\n![53.Listener](E:\\工作文档\\SpringBoot\\images\\53.Listener.jpg)\n\n## 2、运行Run方法\n\n```java\npublic ConfigurableApplicationContext run(String... args) {\n   StopWatch stopWatch = new StopWatch();\n   stopWatch.start();\n   ConfigurableApplicationContext context = null;\n   FailureAnalyzers analyzers = null;\n   configureHeadlessProperty();\n    //获取SpringApplicationRunListeners;从类路径下META-INF/spring.factory\n   SpringApplicationRunListeners listeners = getRunListeners(args);\n    //回调所有的SpringApplicationRunListener.starting()方法\n   listeners.starting();\n   try {\n       //封装命令行参数\n      ApplicationArguments applicationArguments = new DefaultApplicationArguments(\n            args);\n       //准备环境\n      ConfigurableEnvironment environment = prepareEnvironment(listeners,\n            applicationArguments);\n       //创建环境，完成后回调SpringApplicationRunListener.environmentPrepared环境准备完成\n       //打印SpringBoot图标\n      Banner printedBanner = printBanner(environment);\n       //创建ApplicationContext，决定创建web的ioc容器还是普通的ioc\n      context = createApplicationContext();\n       //异常分析\n      analyzers = new FailureAnalyzers(context);\n       //重点：将environment保存的ioc中，applyInitializers初始化器上面那6个的获取，并且回调ApplicationContextInitializer.initialize方法\n       \n       //回调所有的SpringApplicationRunListener的contextPrepare()\n       //告诉prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded\n      prepareContext(context, environment, listeners, applicationArguments,\n            printedBanner);\n       //重要：刷新所有组件 ioc容器初始化，如果是web应用还会创建嵌入式的tomcat\n       //扫描 创建加载所有组件的地方\n      refreshContext(context);\n       //从ioc中获取所有的ApplicationRunner和CommandLineRunner\n       //ApplicationRunner先回调\n      afterRefresh(context, applicationArguments);\n       //所有的SpringApplicationRunListener回调finished方法\n      listeners.finished(context, null);\n       //保存应用状态\n      stopWatch.stop();\n      if (this.logStartupInfo) {\n         new StartupInfoLogger(this.mainApplicationClass)\n               .logStarted(getApplicationLog(), stopWatch);\n      }\n       //整个springboot启动完成以后返回启动的ioc容器\n      return context;\n   }\n   catch (Throwable ex) {\n      handleRunFailure(context, listeners, analyzers, ex);\n      throw new IllegalStateException(ex);\n   }\n}\n```\n\n## 3、事件监听机制\n\n新建listener监听\n\n文件目录\n\n![54.listener2](E:\\工作文档\\SpringBoot\\images\\54.listener2.jpg)\n\n\n\n1、HelloApplicationContextInitializer\n\n```java\n//泛型监听ioc容器\npublic class HelloApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {\n    @Override\n    public void initialize(ConfigurableApplicationContext applicationContext) {\n        System.out.println(\"ApplicationContextInitializer...跑起来了.....\"+applicationContext);\n    }\n}\n```\n\n2、HelloSpringApplicationRunListener\n\n加构造器\n\n```java\npublic class HelloSpringApplicationRunListener implements SpringApplicationRunListener {\n\n    public HelloSpringApplicationRunListener(SpringApplication application, String[] args){\n\n    }\n\n    @Override\n    public void starting() {\n        System.out.println(\"监听容器开始......\");\n    }\n\n    @Override\n    public void environmentPrepared(ConfigurableEnvironment environment) {\n        System.out.println(\"环境准备好了......\"+environment.getSystemProperties().get(\"os.name\"));\n    }\n\n    @Override\n    public void contextPrepared(ConfigurableApplicationContext context) {\n        System.out.println(\"ioc容器准备好了......\");\n    }\n\n    @Override\n    public void contextLoaded(ConfigurableApplicationContext context) {\n        System.out.println(\"容器环境已经加载完成......\");\n    }\n\n    @Override\n    public void finished(ConfigurableApplicationContext context, Throwable exception) {\n        System.out.println(\"全部加载完成......\");\n    }\n}\n```\n\n3、HelloApplicationRunner\n\n```java\n@Component\npublic class HelloApplicationRunner implements ApplicationRunner {\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        System.out.println(\"ApplicationRunner.....run....\");\n    }\n}\n```\n\n4、HelloCommandLineRunner\n\n```java\n@Component\npublic class HelloCommandLineRunner implements CommandLineRunner {\n    @Override\n    public void run(String... args) throws Exception {\n        System.out.println(\"CommandLineRunner......run.....\"+Arrays.asList(args));\n    }\n}\n```\n\n事件运行方法\n\nHelloApplicationContextInitializer和HelloSpringApplicationRunListener文件META-INF/spring.factories中加入\n\n```\n# Initializers\norg.springframework.context.ApplicationContextInitializer=\\\ncom.wdjr.springboot.listener.HelloApplicationContextInitializer\n\norg.springframework.boot.SpringApplicationRunListener=\\\ncom.wdjr.springboot.listener.HelloSpringApplicationRunListener\n```\n\nHelloApplicationRunner和HelloCommandLineRunner ioc加入\n\n@Component\n\n# 八、SpringBoot的自定义starter\n\nstarter：场景启动器\n\n1、场景需要使用什么依赖？\n\n2、如何编写自动配置\n\n```java\n@Configuration //指定这个类是一个配置类\n@ConditionalOnXXX //在指定条件下成立的情况下自动配置类生效\n@AutoConfigureAfter //指定自动配置类的顺序\n@Bean //给容器中添加组件\n\n@ConfigurationProperties //结合相关xxxProperties类来绑定相关的配置\n@EnableConfigurationProperties //让xxxProperties生效加到容器中\n\n自动配置类要能加载\n将需要启动就加载的自动配置类，配置在META-INF/spring.factories\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\n```\n\n3、模式\n\n启动器空的jar只需要做依赖管理导入；\n\n专门写一个自动配置模块；\n\n启动器依赖自动配置，别人只需要引入starter\n\nxxx-spring-boot-starter\n\n### 新建一个starter\n\n> 绕的你怀疑人生\n\n#### 1、新建一个空项目工程\n\n![56.starter01](E:\\工作文档\\SpringBoot\\images\\56.starter01.jpg)\n\n2、项目命名\n\n![57.starter02](E:\\工作文档\\SpringBoot\\images\\57.starter02.jpg)\n\n\n\n3、导入module\n\n![58.starter03](E:\\工作文档\\SpringBoot\\images\\58.starter03.jpg)\n\n4、新建一个Maven工程\n\n![59.starter04](E:\\工作文档\\SpringBoot\\images\\59.starter04.jpg)\n\n5、项目命名\n\n![60.starter05](E:\\工作文档\\SpringBoot\\images\\60.starter05.jpg)\n\n\n\n![61.starter06](E:\\工作文档\\SpringBoot\\images\\61.starter06.jpg)\n\n6、在新建一个autoconfiguration类的spring\n\n![62.starter07](E:\\工作文档\\SpringBoot\\images\\62.starter07.jpg)\n\n7、项目命名\n\n![63.starter08](E:\\工作文档\\SpringBoot\\images\\63.starter08.jpg)\n\n8、无需导入依赖\n\n![64.starter09](E:\\工作文档\\SpringBoot\\images\\64.starter09.jpg)\n\n9、next\n\n![65.starter10](E:\\工作文档\\SpringBoot\\images\\65.starter10.jpg)\n\n最后配置完成\n\n#### 2、编写starter\n\n##### autoconfigurer\n\n对**lxy-spring-boot-starter-autoconfigurer**进行删减\n\n目录\n\n![66.starter-build01](E:\\工作文档\\SpringBoot\\images\\66.starter-build01.jpg)\n\n2、pom文件修改\n\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n\n    </dependencies>\n\n\n</project>\n```\n\n3、编写相关的类\n\n![67.starter-build02](E:\\工作文档\\SpringBoot\\images\\67.starter-build02.jpg)\n\n4、HelloProperties\n\n```java\npackage com.lxy.starter;\n\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(prefix = \"lxy.hello\")\npublic class HelloProperties {\n    private String prefix;\n    private String suffix;\n\n    public String getPrefix() {\n        return prefix;\n    }\n\n    public void setPrefix(String prefix) {\n        this.prefix = prefix;\n    }\n\n    public String getSuffix() {\n        return suffix;\n    }\n\n    public void setSuffix(String suffix) {\n        this.suffix = suffix;\n    }\n}\n```\n\n5、HelloService\n\n```java\npackage com.lxy.starter;\n\npublic class HelloService {\n\n    HelloProperties helloProperties;\n\n    public HelloProperties getHelloProperties() {\n        return helloProperties;\n    }\n\n    public void setHelloProperties(HelloProperties helloProperties) {\n        this.helloProperties = helloProperties;\n    }\n\n    public String sayHello(String name){\n        return helloProperties.getPrefix()+name+helloProperties.getSuffix();\n    }\n}\n```\n\n6、HelloServiceAutoConfiguration\n\n\n\n```java\npackage com.lxy.starter;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ConditionalOnWebApplication\n@EnableConfigurationProperties(HelloProperties.class)\npublic class HelloServiceAutoConfiguration {\n\n    @Autowired\n    HelloProperties helloProperties;\n    @Bean\n    public HelloService helloService(){\n        HelloService service = new HelloService();\n        service.setHelloProperties(helloProperties);\n        return service;\n    }\n\n}\n```\n\n7、配置文件\n\n```\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.lxy.starter.HelloServiceAutoConfiguration\n```\n\n8、修改lxy-spring-boot-starter 也就是之前的Maven项目，修改pom文件引入autoconfiguration依赖\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.lxy.starter</groupId>\n        <artifactId>lxy-spring-boot-starter-autoconfigurer</artifactId>\n        <version>0.0.1-SNAPSHOT</version>\n    </dependency>\n</dependencies>\n```\n\n9、install生成\n\n![68.starter-build03](E:\\工作文档\\SpringBoot\\images\\68.starter-build03.jpg)\n\n#### 3、测试\n\n新建一个springboot 1.5+web\n\n1、引入starter\n\n```xml\n    <dependency>\n        <groupId>com.lxy.starter</groupId>\n        <artifactId>lxy-spring-boot-starter</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n\n</dependencies>\n```\n\n2、新建一个Controller用来测试\n\n```java\n@RestController\npublic class HelloController {\n\n    @Autowired\n    HelloService helloService;\n\n    @GetMapping\n    public  String hello(){\n        return helloService.sayHello(\"test\");\n    }\n}\n```\n\n3、编写配置文件制定前缀和后缀名\n\n```properties\nlxy.hello.prefix=Starter-\nlxy.hello.suffix=-Success\n```\n\n4、运行访问http://localhost:8080/hello\n\n![70.starter-build05](E:\\工作文档\\SpringBoot\\images\\70.starter-build05.jpg)\n\n成功爽啊"
        },
        {
          "name": "SpringBoot入门简介.pdf",
          "type": "blob",
          "size": 4339.662109375,
          "content": null
        },
        {
          "name": "SpringBoot高级教程.md",
          "type": "blob",
          "size": 55.5166015625,
          "content": "# SpringBoot的高级教程\n\n## 一、SpringBoot缓存\n\n缓存的场景\n\n- 临时性数据存储【校验码】\n- 避免频繁因为相同的内容查询数据库【查询的信息】\n\n## 1、JSR107缓存规范 \n\n> 用的比较少\n\nJava Caching定义了5个核心接口\n\n- CachingProvider\n\n  定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期间访问多个CachingProvider\n\n- CacheManager\n\n  定义了创建、配置、获取、管理和控制多个唯一命名的Cache,这些Cache存在于CacheManage的上下文中，一个CacheManage只被一个CachingProvider拥有\n\n- Cache\n\n  类似于Map的数据结构并临时储存以key为索引的值，一个Cache仅仅被一个CacheManage所拥有\n\n- Entry\n\n  存储在Cache中的key-value对\n\n- Expiry\n\n  存储在Cache的条目有一个定义的有效期，一旦超过这个时间，就会设置过期的状态，过期无法被访问，更新，删除。缓存的有效期可以通过ExpiryPolicy设置。\n\n  ![35.cache](E:\\工作文档\\SpringBoot\\images2\\35.cache.png)\n\n  \n\n## 2、Spring的缓存抽象\n\n包括一些JSR107的注解\n\nCahceManager\n\nCache\n\n### 1、基本概念\n\n**重要的概念&缓存注解**\n\n|                | 功能                                                         |\n| -------------- | :----------------------------------------------------------- |\n| Cache          | 缓存接口，定义缓存操作，实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 |\n| CacheManager   | 缓存管理器，管理各种缓存（Cache）组件                        |\n| @Cacheable     | 针对方法配置，根据方法的请求参数对其结果进行缓存             |\n| @CacheEvict    | 清空缓存                                                     |\n| @CachePut      | 保证方法被调用，又希望结果被缓存 update，调用，将信息更新缓存 |\n| @EnableCaching | 开启基于注解的缓存                                           |\n| KeyGenerator   | 缓存数据时key生成的策略                                      |\n| serialize      | 缓存数据时value序列化策略                                    |\n\n### 2、整合项目\n\n1、新建一个SpringBoot1.5+web+mysql+mybatis+cache\n\n2、编写配置文件，连接Mysql\n\n```properties\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://192.168.179.131:3306/mybatis01\nspring.datasource.username=root\nspring.datasource.password=Welcome_1\nmybatis.configuration.map-underscore-to-camel-case=true\nserver.port=9000\n```\n\n3、创建一个bean实例\n\nDepartment\n\n```java\npackage com.wdjr.cache.bean;\n\npublic class Department {\n    private Integer id;\n    private String deptName;\n\n    public Department(){\n\n    }\n\n    public Department(Integer id, String deptName) {\n        this.id = id;\n        this.deptName = deptName;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getDeptName() {\n        return deptName;\n    }\n\n    public void setDeptName(String deptName) {\n        this.deptName = deptName;\n    }\n\n    @Override\n    public String toString() {\n        return \"Department{\" +\n                \"id=\" + id +\n                \", deptName='\" + deptName + '\\'' +\n                '}';\n    }\n}\n```\n\nEmployee\n\n```java\npackage com.wdjr.cache.bean;\n\npublic class Employee {\n    private Integer id;\n    private String lastName;\n    private String gender;\n    private String email;\n    private Integer dId;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n\n    public String getGender() {\n        return gender;\n    }\n\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public Integer getdId() {\n        return dId;\n    }\n\n    public void setdId(Integer dId) {\n        this.dId = dId;\n    }\n\n    @Override\n    public String toString() {\n        return \"Employee{\" +\n                \"id=\" + id +\n                \", lastName='\" + lastName + '\\'' +\n                \", gender='\" + gender + '\\'' +\n                \", email='\" + email + '\\'' +\n                \", dId=\" + dId +\n                '}';\n    }\n}\n```\n\n4、创建mapper接口映射数据库，并访问数据库中的数据\n\n```java\npackage com.wdjr.cache.mapper;\n\n\nimport com.wdjr.cache.bean.Employee;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Select;\nimport org.apache.ibatis.annotations.Update;\n\n@Mapper\npublic interface EmployeeMapper {\n\n    @Select(\"SELECT * FROM employee WHERE id = #{id}\")\n    public Employee getEmpById(Integer id);\n    @Update(\"UPDATE employee SET lastName=#{lastName},email=#{email},gender=#{gender},d_id=#{dId} WHERE id=#{id}\")\n    public void updateEmp(Employee employee);\n}\n```\n\n5、主程序添加注解MapperScan，并且使用@EnableCaching开启缓存\n\n```java\npackage com.wdjr.cache;\n\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cache.annotation.EnableCaching;\n\n@EnableCaching\n@MapperScan(\"com.wdjr.cache.mapper\")\n@SpringBootApplication\npublic class Springboot01CacheApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot01CacheApplication.class, args);\n    }\n}\n```\n\n6、编写service，来具体实现mapper中的方法\n\n```java\npackage com.wdjr.cache.service;\n\nimport com.wdjr.cache.bean.Employee;\nimport com.wdjr.cache.mapper.EmployeeMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class EmployeeService {\n\n    @Autowired\n    EmployeeMapper employeeMapper;\n\n    /**\n     * 将方法的运行结果进行缓存，以后要是再有相同的数据，直接从缓存中获取，不用调用方法\n     * CacheManager中管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，每个缓存组件都有自己的唯一名字；\n     *\n     * 属性：\n     *  CacheName/value:指定存储缓存组件的名字\n     *  key:缓存数据使用的key,可以使用它来指定。默认是使用方法参数的值，1-方法的返回值\n     *  编写Spel表达式：#id 参数id的值， #a0/#p0 #root.args[0]\n     *  keyGenerator:key的生成器，自己可以指定key的生成器的组件id\n     *  key/keyGendertor二选一使用\n     *\n     *  cacheManager指定Cache管理器，或者cacheReslover指定获取解析器\n     *  condition:指定符合条件的情况下，才缓存；\n     *  unless：否定缓存，unless指定的条件为true，方法的返回值就不会被缓存，可以获取到结果进行判断\n     *  sync:是否使用异步模式，unless不支持\n     *\n     *\n     * @param id\n     * @return\n     */\n    @Cacheable(cacheNames = {\"emp\"},key = \"#id\",condition = \"#id>0\",unless = \"#result==null\")\n    public Employee getEmp(Integer id){\n        System.out.println(\"查询id= \"+id+\"的员工\");\n        return employeeMapper.getEmpById(id);\n    }\n}\n```\n\n7、编写controller测试\n\n```java\n@RestController\npublic class EmployeeController {\n    @Autowired\n    EmployeeService employeeService;\n\n    @GetMapping(\"/emp/{id}\")\n    public Employee getEmp(@PathVariable(\"id\")Integer id){\n        return employeeService.getEmp(id);\n    }\n}\n```\n\n8、测试结果\n\n![35.cache](E:\\工作文档\\SpringBoot\\images2\\35.cache.jpg)\n\n继续访问，就不会执行方法，因为直接在缓存中取值\n\n### 3、缓存原理\n\n原理：\n\n1、CacheAutoConfiguration\n\n2、导入缓存组件\n\n![36.importcache](E:\\工作文档\\SpringBoot\\images2\\36.importcache.jpg)\n\n3、查看哪个缓存配置生效\n\n```\nSimpleCacheConfiguration生效\n```\n\n4、给容器注册一个CacheManager:ConcurrentMapCacheManager\n\n5、可以获取和创建ConcurrentMapCache,作用是将数据保存在ConcurrentMap中\n\n运行流程\n\n1、方法运行之前，先查Cache(缓存组件），按照cacheName的指定名字获取；\n\n（CacheManager先获取相应的缓存），第一次获取缓存如果没有cache组件会自己创建\n\n2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数；\n\nkey是按照某种策略生成的，默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key\n\n没有参数 key=new SimpleKey()\n\n如果有一个参数 key=参数值\n\n如果多个参数 key=new SimpleKey(params);\n\n3、没有查到缓存就调用目标方法\n\n4、将目标方法返回的结果，放回缓存中\n\n方法执行之前，@Cacheable先来检查缓存中是否有数据，按照参数的值作为key去查询缓存，如果没有，就运行方法，存入缓存，如果有数据，就取出map的值。\n\n### 4、Cache的注解\n\n#### 1、@Cacheput\n\n修改数据库的某个数据，同时更新缓存\n\n运行时机\n\n先运行方法，再将目标结果缓存起来\n\n\n\n>  cacheable的key是不能使用result的参数的\n\n1、编写更新方法\n\n```java\n@CachePut(value = {\"emp\"},key = \"#result.id\")\npublic Employee updateEmp(Employee employee){\n    System.out.println(\"updateEmp\"+employee);\n    employeeMapper.updateEmp(employee);\n    return employee;\n}\n```\n\n2、编写Controller方法\n\n```java\n@GetMapping(\"/emp\")\npublic Employee updateEmp(Employee employee){\n    employeeService.updateEmp(employee);\n    return employee;\n}\n```\n\n测试\n\n测试步骤\n\n1、先查询1号员工\n\n2、更新1号员工数据\n\n3、查询1号员工\n\n可能并没有更新，\n\n是因为查询和更新的key不同\n\n效果：\n\n- 第一次查询：查询mysql\n- 第二次更新：更新mysql\n- 第三次查询：调用内存\n\n#### 2、CacheEvict\n\n清除缓存\n\n编写测试方法\n\n```java\n@CacheEvict(value = \"emp\",key = \"#id\")\npublic  void  deleteEmp(Integer id){\n    System.out.println(\"delete的id\"+id);\n}\n```\n\nallEntries = true,代表不论清除那个key，都重新刷新缓存\n\nbeforeInvocation=true.方法执行前，清空缓存，默认是false,如果程序异常，就不会清除缓存\n\n#### 3、Caching\n\n组合\n\n- Cacheable\n- CachePut\n- CacheEvict\n\nCacheConfig抽取缓存的公共配置\n\n```java\n@CacheConfig(cacheNames = \"emp\")\n@Service\npublic class EmployeeService {\n```\n\n然后下面的value=emp就不用写了\n\n\n\n```java\n@Caching(\n        cacheable = {\n                @Cacheable(value = \"emp\",key = \"#lastName\")\n        },\n        put = {\n                @CachePut(value = \"emp\",key = \"#result.id\"),\n                @CachePut(value = \"emp\",key = \"#result.gender\")\n        }\n)\npublic Employee getEmpByLastName(String lastName){\n    return employeeMapper.getEmpByLastName(lastName);\n}\n```\n\n如果查完lastName,再查的id是刚才的值，就会直接从缓存中获取数据\n\n\n\n### 5、Redis\n\n默认的缓存是在内存中定义HashMap，生产中使用Redis的缓存中间件\n\nRedis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件 \n\n\n\n#### 1、安装Docker\n\n安装redis在docker上\n\n```shell\n#拉取redis镜像\ndocker pull redis\n#启动redis[bfcb1f6df2db]docker images的id\n docker run -d -p 6379:6379 --name redis01 bfcb1f6df2db\n```\n\n#### 2、Redis的Template\n\nRedis的常用五大数据类型\n\nString【字符串】、List【列表】、Set【集合】、Hash【散列】、ZSet【有序集合】\n\n分为两种一种是**StringRedisTemplate**，另一种是**RedisTemplate**\n\n根据不同的数据类型，大致的操作也分为这5种，以StringRedisTemplate为例\n\n```\nstringRedisTemplate.opsForValue()  --String\nstringRedisTemplate.opsForList()  --List\nstringRedisTemplate.opsForSet()  --Set\nstringRedisTemplate.opsForHash()  --Hash\nstringRedisTemplate.opsForZset()  -Zset\n```\n\n1、导入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n2、修改配置文件\n\n```properties\nspring.redis.host=192.168.179.131\n```\n\n3、添加测试类\n\n```java\n    @Autowired\n    StringRedisTemplate stringRedisTemplate;//操作字符串【常用】\n\n    @Autowired\n    RedisTemplate redisTemplate;//操作k-v都是对象    \n\t@Test\n    public void test01(){\n//        stringRedisTemplate.opsForValue().append(\"msg\", \"hello\");\n        String msg = stringRedisTemplate.opsForValue().get(\"msg\");\n        System.out.println(msg);\n    }\n```\n\n写入数据\n\n![37.redis](E:\\工作文档\\SpringBoot\\images2\\37.redis.jpg)\n\n读取数据\n\n![38.redis02](E:\\工作文档\\SpringBoot\\images2\\38.redis02.jpg)\n\n\n\n#### 3、测试保存对象\n\n> 对象需要序列化\n\n1、序列化bean对象\n\n```java\npublic class Employee implements Serializable {\n```\n\n2、将对象存储到Redis\n\n```java\n@Test\npublic  void test02(){\n    Employee emp = employeeMapper.getEmpById(2);\n    redisTemplate.opsForValue().set(\"emp-01\", emp);\n}\n```\n\n3、效果演示\n\n![38.redis03](E:\\工作文档\\SpringBoot\\images2\\38.redis03.jpg)\n\n#### 4、以json方式传输对象\n\n1、新建一个Redis的配置类MyRedisConfig,\n\n```java\n@Configuration\npublic class MyRedisConfig {\n    @Bean\n    public RedisTemplate<Object, Employee> empRedisTemplate(\n            RedisConnectionFactory redisConnectionFactory)\n            throws UnknownHostException {\n        RedisTemplate<Object, Employee> template = new RedisTemplate<Object, Employee>();\n        template.setConnectionFactory(redisConnectionFactory);\n        Jackson2JsonRedisSerializer<Employee> jsonRedisSerializer = new Jackson2JsonRedisSerializer<Employee>(Employee.class);\n        template.setDefaultSerializer(jsonRedisSerializer);\n        return template;\n    }\n```\n\n2、编写测试类\n\n```java\n @Autowired\n RedisTemplate<Object,Employee> empRedisTemplate;\n@Test\npublic  void test02(){\n    Employee emp = employeeMapper.getEmpById(2);\n    empRedisTemplate.opsForValue().set(\"emp-01\", emp);\n\n}\n```\n\n3、测试效果\n\n![39.redis04](E:\\工作文档\\SpringBoot\\images2\\39.redis04.jpg)\n\n\n\n## 二、SpringBoot的消息中间件\n\n### 1、JMS&AMQP简介\n\n1、异步处理\n\n同步机制\n\n![09.同步](E:\\工作文档\\SpringBoot\\images2\\09.同步.png)\n\n并发机制\n\n![10.异步](E:\\工作文档\\SpringBoot\\images2\\10.异步.png)\n\n消息队列机制\n\n![11.消息](E:\\工作文档\\SpringBoot\\images2\\11.消息.png)\n\n\n\n2、应用解耦\n\n使用中间件，将两个服务解耦，一个写入，一个订阅\n\n3、流量削锋\n\n例如消息队列的FIFO，限定元素的长度，防止出现多次请求导致的误操作\n\n#### 概述\n\n1、大多数应用，可以通过消息服务中间件来提升系统的异步通信、拓展解耦能力\n\n2、消息服务中的两个重要概念：\n\n消息代理（message broker）和目的地（destination）,当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定的目的地。\n\n3、消息队列主要的两种形式的目的地\n\n1）、队列（queue）：点对点消息通信【point-to-point】，取出一个没一个，一个发布，多个消费\n\n2）、主题（topic）:发布（publish）/订阅（subscribe）消息通信，多人【订阅者】可以同时接到消息\n\n4、JMS(Java Message Service) Java消息服务：\n\n- 基于JVM消息规范的代理。ActiveMQ/HornetMQ是JMS的实现\n\n5、AMQP(Advanced Message Queuing Protocol)\n\n- 高级消息队列协议，也是一个消息代理的规范，兼容JMS\n- RabbitMQ是AMQP的实现\n\n|              | JMS                                                          | AMQP                                                         |\n| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 定义         | Java API                                                     | 网络线级协议                                                 |\n| 跨平台       | 否                                                           | 是                                                           |\n| 跨语言       | 否                                                           | 是                                                           |\n| Model        | (1)、Peer-2-Peer<br />(2)、Pub/Sub                           | (1)、direct exchange<br />(2)、fanout exchange<br />(3)、topic change<br />(4)、headers exchange<br />(5)、system exchange<br />后四种都是pub/sub ,差别路由机制做了更详细的划分 |\n| 支持消息类型 | TextMessage<br />MapMessage<br />ByteMessage<br />StreamMessage<br />ObjectMessage<br />Message | byte[]通常需要序列化                                         |\n\n6、SpringBoot的支持\n\nspring-jms提供了对JMS的支持\n\nspring-rabbit提供了对AMQP的支持\n\n需要创建ConnectionFactory的实现来连接消息代理\n\n提供JmsTemplate,RabbitTemplate来发送消息\n\n@JmsListener(JMS).@RabbitListener(AMQP)注解在方法上的监听消息代理发布的消息\n\n@EnableJms,@EnableRabbit开启支持\n\n7、SpringBoot的自动配置\n\n- JmsAutoConfiguration\n- RabbitAutoConfiguration\n\n### 2、RabbitMQ简介\n\n>  AMQP的实现\n\n#### 1、核心概念\n\n**Message**:消息头和消息体组成，消息体是不透明的，而消息头上则是由一系列的可选属性组成，属性：路由键【routing-key】,优先级【priority】,指出消息可能需要持久性存储【delivery-mode】\n\n**Publisher**:消息的生产者，也是一个向交换器发布消息的客户端应用程序\n\n**Exchange**:交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列\n\nExchange的4中类型：direct【默认】点对点，fanout,topic和headers, 发布订阅，不同类型的Exchange转发消息的策略有所区别\n\n**Queue**:消息队列，用来保存消息直到发送给消费者，它是消息的容器，也是消息的终点，一个消息可投入一个或多个队列，消息一直在队列里面，等待消费者连接到这个队列将数据取走。\n\n**Binding**:绑定，队列和交换机之间的关联，多对多关系\n\n**Connection**:网络连接，例如TCP连接\n\nChannel:信道，多路复用连接中的一条独立的双向数据流通道，信道是建立在真是的TCP链接之内的虚拟连接AMQP命令都是通过信道发送出去的。不管是发布消息，订阅队列还是接受消息，都是信道，减少TCP的开销，复用一条TCP连接。\n\n**Consumer**:消息的消费者，表示一个从消息队列中取得消息的客户端的 应用程序\n\n**VirtualHost**:小型的rabbitMQ,相互隔离\n\n**Broker**:表示消息队列 服务实体\n\n![13.RabbitMQ结构](E:\\工作文档\\SpringBoot\\images2\\13.RabbitMQ结构.png)\n\n\n\n#### 2、RabbitMQ的运行机制\n\nExchange的三种方式 \n\ndirect：根据路由键直接匹配，一对一\n\n![14.RabbitMQDirect](E:\\工作文档\\SpringBoot\\images2\\14.RabbitMQDirect.png)\n\nfanout:不经过路由键，直接发送到每一个队列\n\n![14.RabbitMQfaout](E:\\工作文档\\SpringBoot\\images2\\14.RabbitMQfaout.png)\n\ntopic:类似模糊匹配的根据路由键，来分配绑定的队列\n\n![14.RabbitMQtopic](E:\\工作文档\\SpringBoot\\images2\\14.RabbitMQtopic.png)\n\n\n\n#### 3、RabbitMQ安装测试\n\n1、打开虚拟机，在docker中安装RabbitMQ\n\n```shell\n#1.安装rabbitmq，使用镜像加速\ndocker pull registry.docker-cn.com/library/rabbitmq:3-management\n[root@node1 ~]# docker images\nREPOSITORY                                     TAG                 IMAGE ID            CREATED             SIZE\nregistry.docker-cn.com/library/rabbitmq        3-management        c51d1c73d028        11 days ago         149 MB\n#2.运行rabbitmq\n##### 端口：5672 客户端和rabbitmq通信 15672：管理界面的web页面\n\ndocker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq c51d1c73d028\n\n#3.查看运行\ndocker ps\n```\n\n2、打开网页客户端并登陆，账号【guest】,密码【guest】，登陆\n\n![13.rabbitmq](E:\\工作文档\\SpringBoot\\images2\\13.rabbitmq.jpg)\n\n\n\n3、添加 【direct】【faout】【topic】的绑定关系等\n\n1）、添加Exchange,分别添加**exchange.direct**、**exchange.fanout**、**exchange.topic**\n\n![15.exchanges](E:\\工作文档\\SpringBoot\\images2\\15.exchanges.jpg)\n\n2）、添加 Queues,分别添加**lxy.news、wdjr、wdjr.emps、wdjr.news**\n\n![16.queues](E:\\工作文档\\SpringBoot\\images2\\16.queues.jpg)\n\n3）、点击【exchange.direct】添加绑定规则\n\n![17.bind](E:\\工作文档\\SpringBoot\\images2\\17.bind.jpg)\n\n\n\n4）、点击【exchange.fanout】添加绑定规则\n\n![18,bindfanout](E:\\工作文档\\SpringBoot\\images2\\18,bindfanout.jpg)\n\n5）、点击【exchange.topic】添加绑定规则\n\n![19,bind_topic](E:\\工作文档\\SpringBoot\\images2\\19,bind_topic.jpg)\n\n\n\n> /*: 代表匹配1个单词\n>\n> /#：代表匹配0个或者多个单词\n\n4、发布信息测试\n\n【direct】发布命令，点击 Publish message\n\n![20.publish-direct](E:\\工作文档\\SpringBoot\\images2\\20.publish-direct.jpg)\n\n查看队列的数量\n\n![21.queue-direct](E:\\工作文档\\SpringBoot\\images2\\21.queue-direct.jpg)\n\n点击查看发送的信息\n\n![22.msg-direct](E:\\工作文档\\SpringBoot\\images2\\22.msg-direct.jpg)\n\n【fanout】的发布消息\n\n![23.pub-fanout](E:\\工作文档\\SpringBoot\\images2\\23.pub-fanout.jpg)\n\n队列信息\n\n![24.queue-fanout](E:\\工作文档\\SpringBoot\\images2\\24.queue-fanout.jpg)\n\n\n\n随意一个数据信息例如：wdjr.emp\n\n![25.msg-fanout](E:\\工作文档\\SpringBoot\\images2\\25.msg-fanout.jpg)\n\n【topic】发布信息测试\n\n![26.pub-topic](E:\\工作文档\\SpringBoot\\images2\\26.pub-topic.jpg)\n\n队列的值\n\n![27.que-topic](E:\\工作文档\\SpringBoot\\images2\\27.que-topic.jpg)\n\n信息查看\n\n![28.msg-topic](E:\\工作文档\\SpringBoot\\images2\\28.msg-topic.jpg)\n\n#### 4、创建工程整合\n\n```java\n1、RabbitAutoConfiguration\n2、自动配置了连接工厂 ConnectionFactory\n3、RabbitProperties封装了 RabbitMQ\n4、RabbitTemplate:给RabbitMQ发送和接受消息的\n5、AmqpAdmin：RabbitMQ的系统管理功能组件\n```\n\n##### 1、RabbitTemplate\n\n1、新建SpringBoot工程，SpringBoot1.5+Integeration/RabbitMQ+Web\n\n2、RabbitAutoConfiguration文件\n\n3、编写配置文件application.yml\n\n```yaml\nspring:\n  rabbitmq:\n    host: 192.168.179.131\n    port: 5672\n    username: guest\n    password: guest\n```\n\n4、编写测试类,将HashMap写入Queue\n\n```java\n @Autowired\n    RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void contextLoads() {\n        //Message需要自己构建一个；定义消息体内容和消息头\n        // rabbitTemplate.send(exchange, routingKey, message);\n        //Object 默认当成消息体，只需要传入要发送的对象，自动化序列发送给rabbitmq；\n        Map<String,Object> map = new HashMap<>();\n        map.put(\"msg\", \"这是第一个信息\");\n        map.put(\"data\", Arrays.asList(\"helloWorld\",123,true));\n        //对象被默认序列以后发送出去\n        rabbitTemplate.convertAndSend(\"exchange.direct\",\"wdjr.news\",map);\n    }\n```\n\n5、查看网页的信息\n\n![29.dir-idea](E:\\工作文档\\SpringBoot\\images2\\29.dir-idea.jpg)\n\n6、取出队列的值\n\n> 取出队列中数据就没了\n\n```java\n@Test\npublic void reciverAndConvert(){\n\n    Object o = rabbitTemplate.receiveAndConvert(\"wdjr.news\");\n    System.out.println(o.getClass());\n    System.out.println(o);\n\n}\n```\n\n结果\n\n```\nclass java.util.HashMap\n{msg=这是第一个信息, data=[helloWorld, 123, true]}\n```\n\n7、使用Json方式传递，并传入对象Book\n\n1）、MyAMQPConfig\n\n```java\n@Configuration\npublic class MyAMQPConfig  {\n\n    @Bean\n    public MessageConverter messageConverter(){\n        return new Jackson2JsonMessageConverter();\n    }\n}\n```\n\n2）、编写Book实体类\n\n```java\npackage com.wdjr.amqp.bean;\n\npublic class Book {\n    private String  bookName;\n    private String author;\n\n    public Book(){\n\n    }\n\n    public Book(String bookName, String author) {\n        this.bookName = bookName;\n        this.author = author;\n    }\n\n    public String getBookName() {\n        return bookName;\n    }\n\n    public void setBookName(String bookName) {\n        this.bookName = bookName;\n    }\n\n    public String getAuthor() {\n        return author;\n    }\n\n    public void setAuthor(String author) {\n        this.author = author;\n    }\n\n    @Override\n    public String toString() {\n        return \"Book{\" +\n                \"bookName='\" + bookName + '\\'' +\n                \", author='\" + author + '\\'' +\n                '}';\n    }\n}\n```\n\n3）、测试类\n\n```java\n@Test\npublic void contextLoads() {\n    //对象被默认序列以后发送出去\n    rabbitTemplate.convertAndSend(\"exchange.direct\",\"wdjr.news\",new Book(\"百年孤独\", \"季羡林\"));\n}\n```\n\n4）、查看wdjr.news\n\n![30.dir-idea-json](E:\\工作文档\\SpringBoot\\images2\\30.dir-idea-json.jpg)\n\n5）、取出数据\n\n```java\n@Test\npublic void reciverAndConvert(){\n    Object o = rabbitTemplate.receiveAndConvert(\"wdjr.news\");\n    System.out.println(o.getClass());\n    System.out.println(o);\n}\n```\n\n6）、结果演示\n\n```\nclass com.wdjr.amqp.bean.Book\nBook{bookName='百年孤独', author='季羡林'}\n```\n\n##### 2、开启基于注解的方式\n\n1、新建一个BookService\n\n```java\n@Service\npublic class BookService {\n    @RabbitListener(queues = \"wdjr.news\")\n    public void receive(Book book){\n        System.out.println(book);\n    }\n\n    @RabbitListener(queues = \"wdjr\")\n    public void receive02(Message message){\n        System.out.println(message.getBody());\n        System.out.println(message.getMessageProperties());\n    }\n}\n```\n\n2、主程序开启RabbitMQ的注解\n\n```java\n@EnableRabbit //开启基于注解的rabbitmq\n@SpringBootApplication\npublic class AmqpApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AmqpApplication.class, args);\n    }\n}\n```\n\n##### 3、AmqpAdmin\n\n> 创建和删除 Exchange 、Queue、Bind\n\n1）、创建Exchange\n\n```java\n@Test\npublic void createExchange(){\n    amqpAdmin.declareExchange(new DirectExchange(\"amqpadmin.direct\"));\n    System.out.println(\"Create Finish\");\n}\n```\n\n效果演示\n\n![31.createAMQP](E:\\工作文档\\SpringBoot\\images2\\31.createAMQP.jpg)\n\n\n\n2）、创建Queue\n\n```java\n@Test\npublic void createQueue(){\n    amqpAdmin.declareQueue(new Queue(\"amqpadmin.queue\",true));\n    System.out.println(\"Create Queue Finish\");\n}\n```\n\n\n\n![32.createQueue](E:\\工作文档\\SpringBoot\\images2\\32.createQueue.jpg)\n\n3）、创建Bind规则\n\n```java\n@Test\npublic void createBind(){\n    amqpAdmin.declareBinding(new Binding(\"amqpadmin.queue\",Binding.DestinationType.QUEUE , \"amqpadmin.direct\", \"amqp.haha\", null));\n}\n```\n\n![33.createBinding](E:\\工作文档\\SpringBoot\\images2\\33.createBinding.jpg)\n\n删除类似\n\n```java\n@Test\npublic void deleteExchange(){\n    amqpAdmin.deleteExchange(\"amqpadmin.direct\");\n    System.out.println(\"delete Finish\");\n}\n```\n\n## 三、SpringBoot的检索\n\n### 1、ElasticSearch简介\n\n​          ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于[云计算](https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97)中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 \n\n### 2、ElasticSearch的安装\n\n1、安装java最新版本\n\n- 下载linux的.tar.gz\n- 解压到指定目录\n- 配置环境变量\n\n2、安装Docker(非必须这是是在Docker中安装)\n\n```shell\n1、查看centos版本\n# uname -r\n3.10.0-693.el7.x86_64\n要求：大于3.10\n如果小于的话升级*（选做）\n# yum update\n2、安装docker\n# yum install docker\n3、启动docker\n# systemctl start docker\n# docker -v\n4、开机启动docker\n# systemctl enable docker\n5、停止docker\n# systemctl stop docker\n```\n\n\n\n3、安装ElasticSearch的镜像\n\n```shell\ndocker pull registry.docker-cn.com/library/elasticsearch\n```\n\n\n\n4、运行ElasticSearch\n\n> -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" 表示占用的最大内存为256m,默认是2G\n\n```shell\n[root@node1 ~]# docker images\nREPOSITORY                                     TAG                 IMAGE ID                                                                   CREATED             SIZE\nregistry.docker-cn.com/library/elasticsearch   latest              671bb2d7da44                                                               32 hours ago        486 MB\n[root@node1 ~]#\n[root@node1 ~]# docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -p 9200:9200 -p 9300:9300 --name ES01 671bb2d7da44\n```\n\n5、测试是否启动成功\n\n访问9200端口：http://192.168.179.131:9200/  查看是否返回json数据\n\n```json\n{\n  \"name\" : \"onB-EUU\",\n  \"cluster_name\" : \"elasticsearch\",\n  \"cluster_uuid\" : \"j3SXX6tdThWUomW3tAvDFg\",\n  \"version\" : {\n    \"number\" : \"5.6.9\",\n    \"build_hash\" : \"877a590\",\n    \"build_date\" : \"2018-04-12T16:25:14.838Z\",\n    \"build_snapshot\" : false,\n    \"lucene_version\" : \"6.6.1\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n```\n\n### 3、Elastic的快速入门\n\n> 最好的工具就是[官方文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/getting-started.html)，以下操作都在文档中进行操作。\n\n#### 1、基础概念\n\n面向文档，JSON作为序列化格式，ElasticSearch的基本概念\n\n**索引（名词）：**\n\n如前所述，一个 *索引* 类似于传统关系数据库中的一个 *数据库* ，是一个存储关系型文档的地方。 *索引* (*index*) 的复数词为 *indices* 或 *indexes* 。\n\n**索引（动词）：**\n\n*索引一个文档* 就是存储一个文档到一个 *索引* （名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 `INSERT` 关键词，除了文档已存在时新文档会替换旧文档情况之外。\n\n**类型**：相当于数据库中的表\n\n**文档**：相当于数据库中的行，即每条数据都叫一个文档\n\n**属性**：相当于数据库中的列，即文档的属性\n\n#### 2、测试\n\n下载[POSTMAN](https://www.getpostman.com/apps)，并使用POSTMAN测试\n\n##### 1、插入数据\n\n具体信息查看[官方示例](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_indexing_employee_documents.html)\n\n重点：PUT请求+请求体\n\n```json\nPUT /megacorp/employee/1\n{\n    \"first_name\" : \"John\",\n    \"last_name\" :  \"Smith\",\n    \"age\" :        25,\n    \"about\" :      \"I love to go rock climbing\",\n    \"interests\": [ \"sports\", \"music\" ]\n}\n```\n\n![01.postman](E:\\工作文档\\SpringBoot\\images2\\01.postman.jpg)\n\n##### 2、检索文档\n\n[官方示例](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_retrieving_a_document.html)\n\n重点：GET请求+URI+index+type+ID\n\n```\nGET /megacorp/employee/1\n```\n\n![02.postmanget](E:\\工作文档\\SpringBoot\\images2\\02.postmanget.jpg)\n\n##### 3、轻量检索\n\n[官方文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_search_lite.html)\n\n重点：GET请求+index+type+_search+条件（非必须）\n\n搜索所有雇员： `_search`\n\n```\nGET /megacorp/employee/_search\n```\n\n高亮搜索：URL参数 \n\n```\nGET /megacorp/employee/_search?q=last_name:Smith\n```\n\n#####  4、使用查询表达式\n\n[官方文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_search_with_query_dsl.html)\n\n重点：GET+URI+index+type+_search+请求体【match】\n\nQuery-string 搜索通过命令非常方便地进行临时性的即席搜索 ，但它有自身的局限性（参见 [*轻量* 搜索](https://www.elastic.co/guide/cn/elasticsearch/guide/current/search-lite.html) ）。Elasticsearch 提供一个丰富灵活的查询语言叫做 *查询表达式* ，它支持构建更加复杂和健壮的查询。\n\n*领域特定语言* （DSL）， 指定了使用一个 JSON 请求。我们可以像这样重写之前的查询所有 Smith 的搜索 ：\n\n```json\nGET /megacorp/employee/_search\n{\n    \"query\" : {\n        \"match\" : {\n            \"last_name\" : \"Smith\"\n        }\n    }\n}\n```\n\n 返回结果与之前的查询一样，但还是可以看到有一些变化。其中之一是，不再使用 *query-string* 参数，而是一个请求体替代。这个请求使用 JSON 构造，并使用了一个 `match` 查询（属于查询类型之一，后续将会了解）。 \n\n##### 5、更加复杂的查询\n\n[官方文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_more_complicated_searches.html)\n\n重点：GET+URI+index+type+_search   + 请求体【match+filter】\n\n现在尝试下更复杂的搜索。 同样搜索姓氏为 Smith 的雇员，但这次我们只需要年龄大于 30 的。查询需要稍作调整，使用过滤器 *filter* ，它支持高效地执行一个结构化查询。 \n\n```json\nGET /megacorp/employee/_search\n{\n    \"query\" : {\n        \"bool\": {\n            \"must\": {\n                \"match\" : {\n                    \"last_name\" : \"smith\" \n                }\n            },\n            \"filter\": {\n                \"range\" : {\n                    \"age\" : { \"gt\" : 30 } \n                }\n            }\n        }\n    }\n}\n```\n\n| [![img](https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/icons/callouts/1.png)](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_more_complicated_searches.html#CO4-1) | 这部分与我们之前使用的 `match` *查询* 一样。                 |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [![img](https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/icons/callouts/2.png)](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_more_complicated_searches.html#CO4-2) | 这部分是一个 `range` *过滤器* ， 它能找到年龄大于 30 的文档，其中 `gt` 表示_大于(_great than)。 |\n\n目前无需太多担心语法问题，后续会更详细地介绍。只需明确我们添加了一个 *过滤器* 用于执行一个范围查询，并复用之前的 `match` 查询。现在结果只返回了一个雇员，叫 Jane Smith，32 岁。 \n\n##### 6、全文搜索\n\n[官方文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_full_text_search.html)\n\n重点：GET+index+type+_search+请求体【match】  ==》看相关性得分\n\n截止目前的搜索相对都很简单：单个姓名，通过年龄过滤。现在尝试下稍微高级点儿的全文搜索——一项传统数据库确实很难搞定的任务。 \n\n搜索下所有喜欢攀岩（rock climbing）的雇员： \n\n```json\nGET /megacorp/employee/_search\n{\n    \"query\" : {\n        \"match\" : {\n            \"about\" : \"rock climbing\"\n        }\n    }\n}\n```\n\n显然我们依旧使用之前的 `match` 查询在`about` 属性上搜索 “rock climbing” 。得到两个匹配的文档： \n\n```json\n{\n   ...\n   \"hits\": {\n      \"total\":      2,\n      \"max_score\":  0.16273327,\n      \"hits\": [\n         {\n            ...\n            \"_score\":         0.16273327, \n            \"_source\": {\n               \"first_name\":  \"John\",\n               \"last_name\":   \"Smith\",\n               \"age\":         25,\n               \"about\":       \"I love to go rock climbing\",\n               \"interests\": [ \"sports\", \"music\" ]\n            }\n         },\n         {\n            ...\n            \"_score\":         0.016878016, \n            \"_source\": {\n               \"first_name\":  \"Jane\",\n               \"last_name\":   \"Smith\",\n               \"age\":         32,\n               \"about\":       \"I like to collect rock albums\",\n               \"interests\": [ \"music\" ]\n            }\n         }\n      ]\n   }\n}\n```\n\n>  \"_score\":相关性得分\n\nElasticsearch 默认按照相关性得分排序，即每个文档跟查询的匹配程度。第一个最高得分的结果很明显：John Smith 的 `about` 属性清楚地写着 “rock climbing” 。\n\n但为什么 Jane Smith 也作为结果返回了呢？原因是她的 `about` 属性里提到了 “rock” 。因为只有 “rock” 而没有 “climbing” ，所以她的相关性得分低于 John 的。\n\n这是一个很好的案例，阐明了 Elasticsearch 如何 *在* 全文属性上搜索并返回相关性最强的结果。Elasticsearch中的 *相关性* 概念非常重要，也是完全区别于传统关系型数据库的一个概念，数据库中的一条记录要么匹配要么不匹配。\n\n##### 7、短语搜索\n\n[官方文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_phrase_search.html)\n\n重点：GET+index+type+_search+请求体【match_phrase 】\n\n找出一个属性中的独立单词是没有问题的，但有时候想要精确匹配一系列单词或者*短语* 。 比如， 我们想执行这样一个查询，仅匹配同时包含 “rock” *和* “climbing” ，*并且* 二者以短语 “rock climbing” 的形式紧挨着的雇员记录。\n\n为此对 `match` 查询稍作调整，使用一个叫做 `match_phrase` 的查询：\n\n```\nGET /megacorp/employee/_search\n{\n    \"query\" : {\n        \"match_phrase\" : {\n            \"about\" : \"rock climbing\"\n        }\n    }\n}\n```\n\n返回的信息\n\n```\n{\n   ...\n   \"hits\": {\n      \"total\":      1,\n      \"max_score\":  0.23013961,\n      \"hits\": [\n         {\n            ...\n            \"_score\":         0.23013961,\n            \"_source\": {\n               \"first_name\":  \"John\",\n               \"last_name\":   \"Smith\",\n               \"age\":         25,\n               \"about\":       \"I love to go rock climbing\",\n               \"interests\": [ \"sports\", \"music\" ]\n            }\n         }\n      ]\n   }\n}\n```\n\n##### 8、高亮搜索\n\n[官方地址](https://www.elastic.co/guide/cn/elasticsearch/guide/current/highlighting-intro.html)\n\n重点：GET+index+type+_search+请求体【match_phrase+highlight】==>返回关键字加了em标签\n\n许多应用都倾向于在每个搜索结果中 *高亮* 部分文本片段，以便让用户知道为何该文档符合查询条件。在 Elasticsearch 中检索出高亮片段也很容易。 \n\n再次执行前面的查询，并增加一个新的 `highlight` 参数： \n\n```\nGET /megacorp/employee/_search\n{\n    \"query\" : {\n        \"match_phrase\" : {\n            \"about\" : \"rock climbing\"\n        }\n    },\n    \"highlight\": {\n        \"fields\" : {\n            \"about\" : {}\n        }\n    }\n}\n```\n\n当执行该查询时，返回结果与之前一样，与此同时结果中还多了一个叫做 `highlight` 的部分。这个部分包含了 `about` 属性匹配的文本片段，并以 HTML 标签 `<em></em>` 封装： \n\n```json\n{\n   ...\n   \"hits\": {\n      \"total\":      1,\n      \"max_score\":  0.23013961,\n      \"hits\": [\n         {\n            ...\n            \"_score\":         0.23013961,\n            \"_source\": {\n               \"first_name\":  \"John\",\n               \"last_name\":   \"Smith\",\n               \"age\":         25,\n               \"about\":       \"I love to go rock climbing\",\n               \"interests\": [ \"sports\", \"music\" ]\n            },\n            \"highlight\": {\n               \"about\": [\n                  \"I love to go <em>rock</em> <em>climbing</em>\" \n               ]\n            }\n         }\n      ]\n   }\n}\n```\n\n##### 9、分析\n\n[官方文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_analytics.html#_analytics)\n\n重点：GET+index+type+_search+请求体【aggs-field】\n\n> aggs：聚合\n\n终于到了最后一个业务需求：支持管理者对雇员目录做分析。 Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 `GROUP BY` 类似但更强大。\n\n举个例子，挖掘出雇员中最受欢迎的兴趣爱好：\n\n```\nGET /megacorp/employee/_search\n{\n  \"aggs\": {\n    \"all_interests\": {\n      \"terms\": { \"field\": \"interests\" }\n    }\n  }\n}\n```\n\n会报错\n\nFielddata is disabled on text fields by default. Set fielddata=true on [inte\n\n默认情况下，字段数据在文本字段上禁用。设置字段数据= TRUE\n\n首先开启数据结构\n\n```\nPUT megacorp/_mapping/employee/\n{\n  \"properties\": {\n    \"interests\": { \n      \"type\":     \"text\",\n      \"fielddata\": true\n    }\n  }\n}\n```\n\n然后在进行请求\n\n```\n{\n   ...\n   \"hits\": { ... },\n   \"aggregations\": {\n      \"all_interests\": {\n         \"buckets\": [\n            {\n               \"key\":       \"music\",\n               \"doc_count\": 2\n            },\n            {\n               \"key\":       \"forestry\",\n               \"doc_count\": 1\n            },\n            {\n               \"key\":       \"sports\",\n               \"doc_count\": 1\n            }\n         ]\n      }\n   }\n}\n```\n\n可以看到，两位员工对音乐感兴趣，一位对林地感兴趣，一位对运动感兴趣。这些聚合并非预先统计，而是从匹配当前查询的文档中即时生成。\n\n如果想知道叫 Smith 的雇员中最受欢迎的兴趣爱好，可以直接添加适当的查询来组合查询： \n\n```\nGET /megacorp/employee/_search\n{\n  \"query\": {\n    \"match\": {\n      \"last_name\": \"smith\"\n    }\n  },\n  \"aggs\": {\n    \"all_interests\": {\n      \"terms\": {\n        \"field\": \"interests\"\n      }\n    }\n  }\n}\n```\n\n`all_interests` 聚合已经变为只包含匹配查询的文档： \n\n```\n ...\n  \"all_interests\": {\n     \"buckets\": [\n        {\n           \"key\": \"music\",\n           \"doc_count\": 2\n        },\n        {\n           \"key\": \"sports\",\n           \"doc_count\": 1\n        }\n     ]\n  }\n```\n\n聚合还支持分级汇总 。比如，查询特定兴趣爱好员工的平均年龄： \n\n```\nGET /megacorp/employee/_search\n{\n    \"aggs\" : {\n        \"all_interests\" : {\n            \"terms\" : { \"field\" : \"interests\" },\n            \"aggs\" : {\n                \"avg_age\" : {\n                    \"avg\" : { \"field\" : \"age\" }\n                }\n            }\n        }\n    }\n}\n```\n\n 输出基本是第一次聚合的加强版。依然有一个兴趣及数量的列表，只不过每个兴趣都有了一个附加的 `avg_age` 属性，代表有这个兴趣爱好的所有员工的平均年龄。\n\n即使现在不太理解这些语法也没有关系，依然很容易了解到复杂聚合及分组通过 Elasticsearch 特性实现得很完美。可提取的数据类型毫无限制。\n\n### 4、SpringBoot+ElasticSearch\n\n1、新建项目SpringBoot1.5+Web+Nosql-->ElasticSearch\n\n2、springBoot默认支持两种技术和ES进行交互\n\n​\t1、Jest【需要导入使用】\n\n​\t\t利用JestClient和服务器的9200端口进行http通信\n\n​\t2、SpringData ElasticSearch【默认】\n\n​\t\t1）、客户端:Client节点信息: clusterNodes: clusterName\n\n​\t\t2）、ElasticsearchTemplate操作es\n\n​\t\t3）、编写ElasticsearchRepository子接口\n\n#### 1、Jest\n\n1、注释SpringDataElasticSearch的依赖，并导入Jest【5.xx】的相关依赖\n\n```xml\n        <!--   SpringData管理ElasticSearch   -->\n<!--        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-elasticsearch</artifactId>\n        </dependency>-->\n\n        <!-- https://mvnrepository.com/artifact/io.searchbox/jest -->\n        <dependency>\n            <groupId>io.searchbox</groupId>\n            <artifactId>jest</artifactId>\n            <version>5.3.3</version>\n        </dependency>\n```\n\n2、修改配置文件application.yml\n\n```yaml\nspring:\n  elasticsearch:\n    jest:\n      uris: http://192.168.179.131:9200\n```\n\n3、创建 bean.Article\n\n```java\npackage com.wdjr.springboot.bean;\n\nimport io.searchbox.annotations.JestId;\n\npublic class Article {\n\n    @JestId\n    private Integer id;\n    private String autor;\n    private String title;\n    private String content;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getAutor() {\n        return autor;\n    }\n\n    public void setAutor(String autor) {\n        this.autor = autor;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n}\n```\n\n4、运行程序\n\n5、编写Jest Cilent的测试类\n\n> 向wdjr-article中插入数据\n\n```java\n@Autowired\nJestClient jestClient;\n\n@Test\npublic void contextLoads() {\n    //1、给Es中索引（保存）一个文档\n    Article article = new Article();\n    article.setId(2);\n    article.setTitle(\"好消息\");\n    article.setAutor(\"zhangsan\");\n    article.setContent(\"Hello World\");\n    //构建一个索引功能\n    Index index = new Index.Builder(article).index(\"wdjr\").type(\"article\").build();\n\n    try {\n        //执行\n        jestClient.execute(index);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n}\n```\n\n> 查询数据\n\n```java\n@Test\npublic void search(){\n    //查询表达式\n    String json = \"{\\n\" +\n            \"    \\\"query\\\" : {\\n\" +\n            \"        \\\"match\\\" : {\\n\" +\n            \"            \\\"content\\\" : \\\"Hello\\\"\\n\" +\n            \"        }\\n\" +\n            \"    }\\n\" +\n            \"}\";\n    //构建搜索操作\n    Search search = new Search.Builder(json).addIndex(\"wdjr\").addType(\"article\").build();\n\n    //执行\n    try {\n        SearchResult result = jestClient.execute(search);\n        System.out.println(result.getJsonString());\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n}\n```\n\n\n\n#### 2、SpringData-Elastic\n\n1、下载对应版本的ElasticSearch\n\n如果版本不适配，会报错，解决方案：升级SpringBoot版本，或者安装合适的ES\n\n| spring data elasticsearch | elasticsearch |\n| ------------------------- | ------------- |\n| 3.1.x                     | 6.2.2         |\n| 3.0.x                     | 5.5.0         |\n| 2.1.x                     | 2.4.0         |\n| 2.0.x                     | 2.2.0         |\n| 1.3.x                     | 1.5.2         |\n\n2、在Docker中安装适合版本的ES【2.4.6】\n\n```shell\ndocker pull elasticsearch:2.4.6\ndocker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -p 9201:9200 -p 9301:9300 --name ES02 elasticsearch:2.4.6\n```\n\n3、编写配置文件\n\n```yaml\nspring:\n  data:\n    elasticsearch:\n      cluster-name: elasticsearch\n      cluster-nodes: 192.168.179.131:9301\n```\n\n4、运行主程序\n\n5、操作ElasticSearch有两种方式\n\n \t1）、编写一个ElasticsearchRepositry\n\n​\t2）、编写一个ElasticsearchTemplate\n\n6、ElasticsearchRepositry的操作\n\n1）、新建一个bean/Book类\n\n```java\n@Document(indexName = \"wdjr\",type=\"book\")\npublic class Book {\n\n    private Integer id;\n    private String bookName;\n    private String auto;\n\n\n    public Book() {\n        super();\n    }\n\n    public Book(Integer id, String bookName, String auto) {\n        super();\n        this.id = id;\n        this.bookName = bookName;\n        this.auto = auto;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getBookName() {\n        return bookName;\n    }\n\n    public void setBookName(String bookName) {\n        this.bookName = bookName;\n    }\n\n    public String getAuto() {\n        return auto;\n    }\n\n    public void setAuto(String auto) {\n        this.auto = auto;\n    }\n\n    @Override\n    public String toString() {\n        return \"Book{\" +\n                \"id=\" + id +\n                \", bookName='\" + bookName + '\\'' +\n                \", auto='\" + auto + '\\'' +\n                '}';\n    }\n}\n```\n\n2）、新建一个repositry/BookRepositry\n\n```java\npublic interface BookRepositry extends ElasticsearchRepository<Book,Integer> {\n\t//自定义查询方法\n    public List<Book> findByBookNameLike(String bookName);\n}\n```\n\n3）、编写测试类\n\n```java\n@Autowired\nBookRepositry bookRepositry;\n@Test\npublic void testSearch(){\n    for (Book book : bookRepositry.findByBookNameLike(\"金\")) {\n        System.out.println(book);\n    }\n\n}\n```\n\n## 四、SpringBoot的任务\n\n## 五、SpringBoot的安全\n\n## 六、SpringBoot的分布式\n\n### 1、Dubbo简介\n\n**1. Dubbo是什么？**\n\ndubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，**说白了就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册）** \n\n**2. Dubbo能做什么？**\n\n1.透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。       \n\n2.软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 \n\n3.服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 \n\n**3、docker的原理**\n\n![03.dubbo](E:\\工作文档\\SpringBoot\\images2\\03.dubbo.jpg)\n\n\n\n#### 调用关系说明：\n\n0. 服务容器负责启动，加载，运行服务提供者。\n\n1. 服务提供者在启动时，向注册中心注册自己提供的服务。\n\n2. 服务消费者在启动时，向注册中心订阅自己所需的服务。\n\n3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n\n4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n### 2、Zookeeper\n\n安装Zookeeper\n\n```shell\n#安装zookeeper镜像\ndocker pull registry.docker-cn.com/library/zookeeper\n#运行zookeeper\n docker run --name zk01  --restart always -d -p 2111:2181 bf5cbc9d5cac\n```\n\n\n\n### 3、Dubbo、Zookeeper整合\n\n目的：完成**服务消费者**从注册中心查询调用**服务生产者**\n\n1、将服务提供者注册到注册中心\n\n1）、引入dubbo和zkclient的相关依赖\n\n```xml\n<dependency>\n    <groupId>com.alibaba.boot</groupId>\n    <artifactId>dubbo-spring-boot-starter</artifactId>\n    <version>0.1.0</version>\n</dependency>\n\n<dependency>\n    <groupId>com.github.sgroschupf</groupId>\n    <artifactId>zkclient</artifactId>\n    <version>0.1</version>\n</dependency>\n```\n\n2）、配置service服务，新建service.TicketService  和service.TicketServiceImp\n\n```java\npublic interface TicketService {\n    public String getTicket();\n}\n```\n\n```java\nimport com.alibaba.dubbo.config.annotation.Service;\n@Component\n//是dubbo包下的service\n@Service\npublic class TicketServiceImp implements TicketService {\n    @Override\n    public String getTicket() {\n        return \"《厉害了，我的国》\";\n    }\n}\n```\n\n3）、配置文件application.yml\n\n```yml\ndubbo:\n  application:\n    name: provider-ticket\n  registry:\n    address: zookeeper://192.168.179.131:2111\n  scan:\n    base-packages: com.wdjr.ticket.service\nserver:\n  port: 9001\n```\n\n4）、启动服务提供者\n\n**2、启动服务消费者**\n\n1）、引入Dubbo和Zookeeper的依赖\n\n```xml\n<dependency>\n    <groupId>com.alibaba.boot</groupId>\n    <artifactId>dubbo-spring-boot-starter</artifactId>\n    <version>0.1.0</version>\n</dependency>\n\n<dependency>\n    <groupId>com.github.sgroschupf</groupId>\n    <artifactId>zkclient</artifactId>\n    <version>0.1</version>\n</dependency>\n```\n\n2）、新建一个service.userService,并将TicketService的接口调用过来【全类名相同-包相同】\n\n![03.dubbo2](E:\\工作文档\\SpringBoot\\images2\\03.dubbo2.jpg)\n\n```java\npackage com.wdjr.user.service;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport com.wdjr.ticket.service.TicketService;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserService {\n\n    @Reference\n    TicketService ticketService;\n\n    public void hello(){\n        String ticket = ticketService.getTicket();\n        System.out.println(\"您已经成功买票：\"+ticket);\n    }\n}\n```\n\n3）、配置文件application.yml\n\n```yaml\ndubbo:\n  application:\n    name: comsumer-user\n  registry:\n    address: zookeeper://192.168.179.131:2111\n```\n\n4）、编写测试类测试\n\n```java\n@Autowired\nUserService userService;\n@Test\npublic void contextLoads() {\n    userService.hello();\n}\n```\n\n\n\n结果展示：\n\n![04.dubbo+zk3](E:\\工作文档\\SpringBoot\\images2\\04.dubbo+zk3.jpg)\n\n\n\n### 4、SpringCloud\n\nSpringCloud是一个分布式的整体解决方案，Spring Cloud为开发者提供了在分布式系统（配置管理，服务器发现，熔断，路由，微代理，控制总线，一次性token,全局锁，leader选举，分布式session，集群状态）中快速构建的工具，使用SpringCloud的开发者可以快速的驱动服务或者构建应用，同时能够和云平台资源进行对接。\n\n\n\n**SpringCloud分布式开发的五大常用组件**\n\n>  Eureka:找到\n\n- 服务器发现 ——Netflix Eureka \n- 客服端负载均衡——Netflix Ribbon\n- 断路器——Netflix Hystrix 发现不了就及时断开\n- 服务网关——Netflix Zuul  过滤请求\n- 分布式配置——SpringCloud Config\n\n目的：\n\n多个A服务调用多个B服务，负载均衡\n\n注册中心+服务提供者+服务消费者\n\n![05.springCloud](E:\\工作文档\\SpringBoot\\images2\\05.springCloud.jpg)\n\n\n\n##### 1、注册中心（eureka-server）\n\n1、新建Spring项目 ，SpringBoot1.5+Eureka Server \n\n2、编写application.yml\n\n```yaml\nserver:\n  port: 8761\neureka:\n  instance:\n    hostname: eureka-server #实例的主机名\n  client:\n    register-with-eureka: false #不把自己注册到euraka上\n    fetch-registry: false #不从euraka上来获取服务的注册信息\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n```\n\n3、编写主程序\n\n```java\n@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaServerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n```\n\n\n\n##### 2、服务提供者（provider-ticket）\n\n1、新建Spring项目，SpringBoot1.5+Eureka Discovery\n\n2、编写配置文件application.yml\n\n```yaml\nserver:\n  port: 8002\nspring:\n  application:\n    name: provider-ticket\n\n\neureka:\n  instance:\n    prefer-ip-address: true #注册是服务使用IP地址\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n```\n\n3、创建一个售票的service\n\n```java\n@Service\npublic class TicketService {\n\n    public String getTicket(){\n        System.out.println(\"8001\");\n        return \"《厉害了，我的国》\";\n    }\n}\n```\n\n4、创建一个用于访问的controller\n\n```java\n@RestController\npublic class TicketController {\n\n    @Autowired\n    TicketService ticketService;\n\n    @GetMapping(\"/ticket\")\n    public String getTicket(){\n        return ticketService.getTicket();\n    }\n}\n```\n\n5、完毕\n\n\n\n##### 3、服务消费者（consumer-user）\n\n1、新建Spring项目，SpringBoot1.5+Eureka Discovery\n\n2、编写application.yml文件\n\n```yaml\nspring:\n  application:\n    name: consumer-user\nserver:\n  port: 9001\neureka:\n  instance:\n    prefer-ip-address: true\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n```\n\n3、编写一个controller\n\n```java\n@RestController\npublic class UserController {\n\n    @Autowired\n    RestTemplate restTemplate;\n    @GetMapping(\"/buy\")\n    public String buyTicket(String name){\n        String s = restTemplate.getForObject(\"http://PROVIDER-TICKET/ticket\", String.class);\n        return name+\"购买了\"+\"  \"+s;\n    }\n}\n```\n\n4、编写主程序\n\n```java\n@EnableDiscoveryClient //开启发现服务功能\n@SpringBootApplication\npublic class ConsumerUserApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ConsumerUserApplication.class, args);\n\n    }\n\n    @LoadBalanced //使用负载均衡机制\n    @Bean\n    public RestTemplate restTemplate(){\n        return new RestTemplate();\n    }\n}\n```\n\n5、完毕\n\n##### 4、测试\n\n1、运行Eureka-server，provider-ticket【8002执行】(端口改为8001打成jar包，执行)，consumer-user\n\n![06.EurekaServer](E:\\工作文档\\SpringBoot\\images2\\06.EurekaServer.jpg)\n\n2、provider-ticket\n\n\n\n![07.provider-ticket](E:\\工作文档\\SpringBoot\\images2\\07.provider-ticket.jpg)\n\n![07.provider-ticket](E:\\工作文档\\SpringBoot\\images2\\07.provider-ticket02.jpg)\n\n\n\n3、consumer-user\n\n![08.consumer](E:\\工作文档\\SpringBoot\\images2\\08.consumer.jpg)\n\n访问是以负载均衡的方式，所以每次都是 8001 。8002.轮询访问\n\n\n\n## 七、SpringBoot的监管"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "images2",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}