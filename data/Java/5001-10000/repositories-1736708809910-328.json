{
  "metadata": {
    "timestamp": 1736708809910,
    "page": 328,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hustcc/JS-Sorting-Algorithm",
      "stars": 5167,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.384765625,
          "content": "# Node rules:\n## Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n## Dependency directory\n## Commenting this out is preferred by some people, see\n## https://docs.npmjs.com/misc/faq#should-i-check-my-node_modules-folder-into-git\nnode_modules\n\n# Book build output\n_book\n\n# eBook build output\n*.epub\n*.mobi\n*.pdf\n\\.idea/\n\n*.iml\n\nsrc/javaSortTest/target/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.09375,
          "content": "language: node_js\nnode_js:\n  - \"10\"\nbefore_install:\n  - npm i -g lint-md-cli\nscript: lint-md ./\n"
        },
        {
          "name": "1.bubbleSort.md",
          "type": "blob",
          "size": 3.7158203125,
          "content": "# 冒泡排序\n\n冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。\n\n\n## 1. 算法步骤\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n\n## 2. 动图演示\n\n![动图演示](res/bubbleSort.gif)\n\n\n## 3. 什么时候最快\n\n当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。\n\n\n## 4. 什么时候最慢\n\n当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。\n\n\n## 5. JavaScript 代码实现\n\n```js\nfunction bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i < len - 1; i++) {\n        for (var j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j+1]) {        // 相邻元素两两对比\n                var temp = arr[j+1];        // 元素交换\n                arr[j+1] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\n```\n\n\n\n## 6. Python 代码实现\n\n```python\ndef bubbleSort(arr):\n    for i in range(1, len(arr)):\n        for j in range(0, len(arr)-i):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n```\n\n## 7. Go 代码实现\n\n```go\nfunc bubbleSort(arr []int) []int {\n\tlength := len(arr)\n\tfor i := 0; i < length; i++ {\n\t\tfor j := 0; j < length-1-i; j++ {\n\t\t\tif arr[j] > arr[j+1] {\n\t\t\t\tarr[j], arr[j+1] = arr[j+1], arr[j]\n\t\t\t}\n\t\t}\n\t}\n\treturn arr\n}\n```\n\n## 8. Java 代码实现\n\n```java\npublic class BubbleSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) throws Exception {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        for (int i = 1; i < arr.length; i++) {\n            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。\n            boolean flag = true;\n\n            for (int j = 0; j < arr.length - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int tmp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = tmp;\n\n                    flag = false;\n                }\n            }\n\n            if (flag) {\n                break;\n            }\n        }\n        return arr;\n    }\n}\n```\n\n## 9. PHP 代码实现\n\n```php\nfunction bubbleSort($arr)\n{\n    $len = count($arr);\n    for ($i = 0; $i < $len - 1; $i++) {\n        for ($j = 0; $j < $len - 1 - $i; $j++) {\n            if ($arr[$j] > $arr[$j+1]) {\n                $tmp = $arr[$j];\n                $arr[$j] = $arr[$j+1];\n                $arr[$j+1] = $tmp;\n            }\n        }\n    }\n    return $arr;\n}\n```\n"
        },
        {
          "name": "10.radixSort.md",
          "type": "blob",
          "size": 5.205078125,
          "content": "# 基数排序\n\n基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n\n## 1. 基数排序 vs 计数排序 vs 桶排序\n\n基数排序有两种方法：\n\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异案例看大家发的：\n\n - 基数排序：根据键值的每位数字来分配桶；\n - 计数排序：每个桶只存储单一键值；\n - 桶排序：每个桶存储一定范围的数值；\n\n\n## 2. LSD 基数排序动图演示\n\n![动图演示](res/radixSort.gif)\n\n\n## 3. JavaScript 代码实现\n\n```js\n//LSD Radix Sort\nvar counter = [];\nfunction radixSort(arr, maxDigit) {\n    var mod = 10;\n    var dev = 1;\n    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {\n        for(var j = 0; j < arr.length; j++) {\n            var bucket = parseInt((arr[j] % mod) / dev);\n            if(counter[bucket]==null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        var pos = 0;\n        for(var j = 0; j < counter.length; j++) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos++] = value;\n                }\n          }\n        }\n    }\n    return arr;\n}\n```\n\n\n## 4. python 代码实现\n\n```python\ndef radix(arr):\n    \n    digit = 0\n    max_digit = 1\n    max_value = max(arr)\n    #找出列表中最大的位数\n    while 10**max_digit < max_value:\n        max_digit = max_digit + 1\n    \n    while digit < max_digit:\n        temp = [[] for i in range(10)]\n        for i in arr:\n            #求出每一个元素的个、十、百位的值\n            t = int((i/10**digit)%10)\n            temp[t].append(i)\n        \n        coll = []\n        for bucket in temp:\n            for i in bucket:\n                coll.append(i)\n                \n        arr = coll\n        digit = digit + 1\n\n    return arr\n```\n\n\n## 5. Java 代码实现\n\n```java\n/**\n * 基数排序\n * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9\n */\npublic class RadixSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) throws Exception {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        int maxDigit = getMaxDigit(arr);\n        return radixSort(arr, maxDigit);\n    }\n\n    /**\n     * 获取最高位数\n     */\n    private int getMaxDigit(int[] arr) {\n        int maxValue = getMaxValue(arr);\n        return getNumLenght(maxValue);\n    }\n\n    private int getMaxValue(int[] arr) {\n        int maxValue = arr[0];\n        for (int value : arr) {\n            if (maxValue < value) {\n                maxValue = value;\n            }\n        }\n        return maxValue;\n    }\n\n    protected int getNumLenght(long num) {\n        if (num == 0) {\n            return 1;\n        }\n        int lenght = 0;\n        for (long temp = num; temp != 0; temp /= 10) {\n            lenght++;\n        }\n        return lenght;\n    }\n\n    private int[] radixSort(int[] arr, int maxDigit) {\n        int mod = 10;\n        int dev = 1;\n\n        for (int i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {\n            // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)\n            int[][] counter = new int[mod * 2][0];\n\n            for (int j = 0; j < arr.length; j++) {\n                int bucket = ((arr[j] % mod) / dev) + mod;\n                counter[bucket] = arrayAppend(counter[bucket], arr[j]);\n            }\n\n            int pos = 0;\n            for (int[] bucket : counter) {\n                for (int value : bucket) {\n                    arr[pos++] = value;\n                }\n            }\n        }\n\n        return arr;\n    }\n\n    /**\n     * 自动扩容，并保存数据\n     *\n     * @param arr\n     * @param value\n     */\n    private int[] arrayAppend(int[] arr, int value) {\n        arr = Arrays.copyOf(arr, arr.length + 1);\n        arr[arr.length - 1] = value;\n        return arr;\n    }\n}\n```\n\n## 6. PHP 代码实现\n\n```php\nfunction radixSort($arr, $maxDigit = null)\n{\n    if ($maxDigit === null) {\n        $maxDigit = max($arr);\n    }\n    $counter = [];\n    for ($i = 0; $i < $maxDigit; $i++) {\n        for ($j = 0; $j < count($arr); $j++) {\n            preg_match_all('/\\d/', (string) $arr[$j], $matches);\n            $numArr = $matches[0];\n            $lenTmp = count($numArr);\n            $bucket = array_key_exists($lenTmp - $i - 1, $numArr)\n                ? intval($numArr[$lenTmp - $i - 1])\n                : 0;\n            if (!array_key_exists($bucket, $counter)) {\n                $counter[$bucket] = [];\n            }\n            $counter[$bucket][] = $arr[$j];\n        }\n        $pos = 0;\n        for ($j = 0; $j < count($counter); $j++) {\n            $value = null;\n            if ($counter[$j] !== null) {\n                while (($value = array_shift($counter[$j])) !== null) {\n                    $arr[$pos++] = $value;\n                }\n          }\n        }\n    }\n\n    return $arr;\n}\n```\n"
        },
        {
          "name": "2.selectionSort.md",
          "type": "blob",
          "size": 3.03515625,
          "content": "# 选择排序\n\n选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。\n\n\n## 1. 算法步骤\n\n1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n\n2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n3. 重复第二步，直到所有元素均排序完毕。\n\n\n## 2. 动图演示\n\n![动图演示](res/selectionSort.gif)\n\n\n## 3. JavaScript 代码实现\n\n```js\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     // 寻找最小的数\n                minIndex = j;                 // 将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n}\n```\n\n## 4. Python 代码实现\n\n```python\ndef selectionSort(arr):\n    for i in range(len(arr) - 1):\n        # 记录最小数的索引\n        minIndex = i\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[minIndex]:\n                minIndex = j\n        # i 不是最小数时，将 i 和最小数进行交换\n        if i != minIndex:\n            arr[i], arr[minIndex] = arr[minIndex], arr[i]\n    return arr\n```\n\n## 5. Go 代码实现\n\n```go\nfunc selectionSort(arr []int) []int {\n\tlength := len(arr)\n\tfor i := 0; i < length-1; i++ {\n\t\tmin := i\n\t\tfor j := i + 1; j < length; j++ {\n\t\t\tif arr[min] > arr[j] {\n\t\t\t\tmin = j\n\t\t\t}\n\t\t}\n\t\tarr[i], arr[min] = arr[min], arr[i]\n\t}\n\treturn arr\n}\n```\n\n## 6. Java 代码实现\n\n```java\npublic class SelectionSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) throws Exception {\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        // 总共要经过 N-1 轮比较\n        for (int i = 0; i < arr.length - 1; i++) {\n            int min = i;\n\n            // 每轮需要比较的次数 N-i\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[j] < arr[min]) {\n                    // 记录目前能找到的最小值元素的下标\n                    min = j;\n                }\n            }\n\n            // 将找到的最小值和i位置所在的值进行交换\n            if (i != min) {\n                int tmp = arr[i];\n                arr[i] = arr[min];\n                arr[min] = tmp;\n            }\n\n        }\n        return arr;\n    }\n}\n```\n\n## 7. PHP 代码实现\n\n```php\nfunction selectionSort($arr)\n{\n    $len = count($arr);\n    for ($i = 0; $i < $len - 1; $i++) {\n        $minIndex = $i;\n        for ($j = $i + 1; $j < $len; $j++) {\n            if ($arr[$j] < $arr[$minIndex]) {\n                $minIndex = $j;\n            }\n        }\n        $temp = $arr[$i];\n        $arr[$i] = $arr[$minIndex];\n        $arr[$minIndex] = $temp;\n    }\n    return $arr;\n}\n```\n"
        },
        {
          "name": "3.insertionSort.md",
          "type": "blob",
          "size": 3.197265625,
          "content": "# 插入排序\n\n插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。\n\n\n## 1. 算法步骤\n\n1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n\n2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n\n\n## 2. 动图演示\n\n![动图演示](res/insertionSort.gif)\n\n\n## 3. JavaScript 代码实现\n\n```js\nfunction insertionSort(arr) {\n    var len = arr.length;\n    var preIndex, current;\n    for (var i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while(preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex+1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex+1] = current;\n    }\n    return arr;\n}\n```\n\n## 4. Python 代码实现\n\n```python\ndef insertionSort(arr):\n    for i in range(len(arr)):\n        preIndex = i-1\n        current = arr[i]\n        while preIndex >= 0 and arr[preIndex] > current:\n            arr[preIndex+1] = arr[preIndex]\n            preIndex-=1\n        arr[preIndex+1] = current\n    return arr\n```\n\n## 5. Go 代码实现\n```go\nfunc insertionSort(arr []int) []int {\n\tfor i := range arr {\n\t\tpreIndex := i - 1\n\t\tcurrent := arr[i]\n\t\tfor preIndex >= 0 && arr[preIndex] > current {\n\t\t\tarr[preIndex+1] = arr[preIndex]\n\t\t\tpreIndex -= 1\n\t\t}\n\t\tarr[preIndex+1] = current\n\t}\n\treturn arr\n}\n```\n\n## 6. Java 代码实现\n\n```java\npublic class InsertSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) throws Exception {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的\n        for (int i = 1; i < arr.length; i++) {\n\n            // 记录要插入的数据\n            int tmp = arr[i];\n\n            // 从已经排序的序列最右边的开始比较，找到比其小的数\n            int j = i;\n            while (j > 0 && tmp < arr[j - 1]) {\n                arr[j] = arr[j - 1];\n                j--;\n            }\n\n            // 存在比其小的数，插入\n            if (j != i) {\n                arr[j] = tmp;\n            }\n\n        }\n        return arr;\n    }\n}\n```\n\n## 7. PHP 代码实现\n\n```php\nfunction insertionSort($arr)\n{\n    $len = count($arr);\n    for ($i = 1; $i < $len; $i++) {\n        $preIndex = $i - 1;\n        $current = $arr[$i];\n        while($preIndex >= 0 && $arr[$preIndex] > $current) {\n            $arr[$preIndex+1] = $arr[$preIndex];\n            $preIndex--;\n        }\n        $arr[$preIndex+1] = $current;\n    }\n    return $arr;\n}\n```\n"
        },
        {
          "name": "4.shellSort.md",
          "type": "blob",
          "size": 4.0615234375,
          "content": "# 希尔排序\n\n希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n\n - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；\n - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；\n\n希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。\n\n\n## 1. 算法步骤\n\n1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n\n2. 按增量序列个数 k，对序列进行 k 趟排序；\n\n3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n\n## 2. JavaScript 代码实现\n\n```js\nfunction shellSort(arr) {\n    var len = arr.length,\n        temp,\n        gap = 1;\n    while(gap < len/3) {          //动态定义间隔序列\n        gap =gap*3+1;\n    }\n    for (gap; gap > 0; gap = Math.floor(gap/3)) {\n        for (var i = gap; i < len; i++) {\n            temp = arr[i];\n            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {\n                arr[j+gap] = arr[j];\n            }\n            arr[j+gap] = temp;\n        }\n    }\n    return arr;\n}\n```\n\n## 3. Python 代码实现\n\n```python\ndef shellSort(arr):\n    import math\n    gap=1\n    while(gap < len(arr)/3):\n        gap = gap*3+1\n    while gap > 0:\n        for i in range(gap,len(arr)):\n            temp = arr[i]\n            j = i-gap\n            while j >=0 and arr[j] > temp:\n                arr[j+gap]=arr[j]\n                j-=gap\n            arr[j+gap] = temp\n        gap = math.floor(gap/3)\n    return arr\n}\n```\n\n## 4. Go 代码实现\n\n```go\nfunc shellSort(arr []int) []int {\n\tlength := len(arr)\n\tgap := 1\n\tfor gap < length/3 {\n\t\tgap = gap*3 + 1\n\t}\n\tfor gap > 0 {\n\t\tfor i := gap; i < length; i++ {\n\t\t\ttemp := arr[i]\n\t\t\tj := i - gap\n\t\t\tfor j >= 0 && arr[j] > temp {\n\t\t\t\tarr[j+gap] = arr[j]\n\t\t\t\tj -= gap\n\t\t\t}\n\t\t\tarr[j+gap] = temp\n\t\t}\n\t\tgap = gap / 3\n\t}\n\treturn arr\n}\n```\n\n## 5. Java 代码实现\n\n```java\npublic class ShellSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) throws Exception {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        int gap = 1;\n        while (gap < arr.length/3) {\n            gap = gap * 3 + 1;\n        }\n\n        while (gap > 0) {\n            for (int i = gap; i < arr.length; i++) {\n                int tmp = arr[i];\n                int j = i - gap;\n                while (j >= 0 && arr[j] > tmp) {\n                    arr[j + gap] = arr[j];\n                    j -= gap;\n                }\n                arr[j + gap] = tmp;\n            }\n            gap = (int) Math.floor(gap / 3);\n        }\n\n        return arr;\n    }\n}\n```\n\n## 6. PHP 代码实现\n\n```php\nfunction shellSort($arr)\n{\n    $len = count($arr);\n    $temp = 0;\n    $gap = 1;\n    while($gap < $len / 3) {\n        $gap = $gap * 3 + 1;\n    }\n    for ($gap; $gap > 0; $gap = floor($gap / 3)) {\n        for ($i = $gap; $i < $len; $i++) {\n            $temp = $arr[$i];\n            for ($j = $i - $gap; $j >= 0 && $arr[$j] > $temp; $j -= $gap) {\n                $arr[$j+$gap] = $arr[$j];\n            }\n            $arr[$j+$gap] = $temp;\n        }\n    }\n    return $arr;\n}\n```\n\n## 7. C++ 代码实现\n\n```cpp\nvoid shellSort(vector<int>& arr) {\n    int gap = 1;\n    while (gap < (int)arr.size() / 3) {\n    \tgap = gap * 3 + 1;\n    }\n    for (; gap >= 1; gap /= 3) {\n\tfor (int i = 0; i < gap; ++i) {\n\t    for (int j = i + gap; j < arr.size(); j += gap) {\n\t\tfor (int k = j; k - gap >= 0 && arr[k] < arr[k - gap]; k -= gap) {\n                    swap(arr[k], arr[k - gap]);\n                }\n            }\n        }\n    }\n}\n```\n"
        },
        {
          "name": "5.mergeSort.md",
          "type": "blob",
          "size": 6.53125,
          "content": "# 归并排序\n\n归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。\n\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n - 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；\n - 自下而上的迭代；\n\n在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：\n\n> However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.\n>\n> 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。\n\n\n说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。\n\n和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。\n\n\n## 2. 算法步骤\n\n1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n\n2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n\n3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n\n4. 重复步骤 3 直到某一指针达到序列尾；\n\n5. 将另一序列剩下的所有元素直接复制到合并序列尾。\n\n\n## 3. 动图演示\n\n![动图演示](res/mergeSort.gif)\n\n\n## 4. JavaScript 代码实现\n\n```js\nfunction mergeSort(arr) {  // 采用自上而下的递归方法\n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right)\n{\n    var result = [];\n\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n\n    return result;\n}\n```\n\n## 5. Python 代码实现\n\n```python\ndef mergeSort(arr):\n    import math\n    if(len(arr)<2):\n        return arr\n    middle = math.floor(len(arr)/2)\n    left, right = arr[0:middle], arr[middle:]\n    return merge(mergeSort(left), mergeSort(right))\n\ndef merge(left,right):\n    result = []\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left.pop(0));\n        else:\n            result.append(right.pop(0));\n    while left:\n        result.append(left.pop(0));\n    while right:\n        result.append(right.pop(0));\n    return result\n```\n\n## 6. Go 代码实现\n\n```go\nfunc mergeSort(arr []int) []int {\n\tlength := len(arr)\n\tif length < 2 {\n\t\treturn arr\n\t}\n\tmiddle := length / 2\n\tleft := arr[0:middle]\n\tright := arr[middle:]\n\treturn merge(mergeSort(left), mergeSort(right))\n}\n\nfunc merge(left []int, right []int) []int {\n\tvar result []int\n\tfor len(left) != 0 && len(right) != 0 {\n\t\tif left[0] <= right[0] {\n\t\t\tresult = append(result, left[0])\n\t\t\tleft = left[1:]\n\t\t} else {\n\t\t\tresult = append(result, right[0])\n\t\t\tright = right[1:]\n\t\t}\n\t}\n\n\tfor len(left) != 0 {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t}\n\n\tfor len(right) != 0 {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n\n\treturn result\n}\n```\n\n## 7. Java 代码实现\n\n```java\npublic class MergeSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) throws Exception {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        if (arr.length < 2) {\n            return arr;\n        }\n        int middle = (int) Math.floor(arr.length / 2);\n\n        int[] left = Arrays.copyOfRange(arr, 0, middle);\n        int[] right = Arrays.copyOfRange(arr, middle, arr.length);\n\n        return merge(sort(left), sort(right));\n    }\n\n    protected int[] merge(int[] left, int[] right) {\n        int[] result = new int[left.length + right.length];\n        int i = 0;\n        while (left.length > 0 && right.length > 0) {\n            if (left[0] <= right[0]) {\n                result[i++] = left[0];\n                left = Arrays.copyOfRange(left, 1, left.length);\n            } else {\n                result[i++] = right[0];\n                right = Arrays.copyOfRange(right, 1, right.length);\n            }\n        }\n\n        while (left.length > 0) {\n            result[i++] = left[0];\n            left = Arrays.copyOfRange(left, 1, left.length);\n        }\n\n        while (right.length > 0) {\n            result[i++] = right[0];\n            right = Arrays.copyOfRange(right, 1, right.length);\n        }\n\n        return result;\n    }\n\n}\n```\n\n## 8. PHP 代码实现\n\n```php\nfunction mergeSort($arr)\n{\n    $len = count($arr);\n    if ($len < 2) {\n        return $arr;\n    }\n    $middle = floor($len / 2);\n    $left = array_slice($arr, 0, $middle);\n    $right = array_slice($arr, $middle);\n    return merge(mergeSort($left), mergeSort($right));\n}\n\nfunction merge($left, $right)\n{\n    $result = [];\n\n    while (count($left) > 0 && count($right) > 0) {\n        if ($left[0] <= $right[0]) {\n            $result[] = array_shift($left);\n        } else {\n            $result[] = array_shift($right);\n        }\n    }\n\n    while (count($left))\n        $result[] = array_shift($left);\n\n    while (count($right))\n        $result[] = array_shift($right);\n\n    return $result;\n}\n```\n\n## 9. C++ 代码实现\n\n```cpp\nvoid merge(vector<int>& arr, int l, int mid, int r) {\n    int index = 0;\n    int ptrL = l;\n    int ptrR = mid;\n    static vector<int>tempary;\n    if (arr.size() > tempary.size()) {\n        tempary.resize(arr.size());\n    }\n    while (ptrL != mid && ptrR != r) {\n        if (arr[ptrL] < arr[ptrR]) {\n            tempary[index++] = arr[ptrL++];\n        } else {\n            tempary[index++] = arr[ptrR++];\n        }\n    }\n    while (ptrL != mid) {\n        tempary[index++] = arr[ptrL++];\n    }\n    while (ptrR != r) {\n        tempary[index++] = arr[ptrR++];\n    }\n    copy(tempary.begin(), tempary.begin() + index, arr.begin() + l);\n}\nvoid mergeSort(vector<int>& arr, int l, int r) { // sort the range [l, r) in arr\n    if (r - l <= 1) {\n        return;\n    }\n    int mid = (l + r) / 2;\n    mergeSort(arr, l, mid);\n    mergeSort(arr, mid, r);\n    merge(arr, l, mid, r);\n}\n```\n"
        },
        {
          "name": "6.quickSort.md",
          "type": "blob",
          "size": 7.2578125,
          "content": "# 快速排序\n\n快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。\n\n快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。\n\n快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。\n\n快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：\n\n> 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。\n\n\n## 1. 算法步骤\n\n1. 从数列中挑出一个元素，称为 “基准”（pivot）;\n\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\n\n\n## 2. 动图演示\n\n![动图演示](res/quickSort.gif)\n\n\n## 3. JavaScript 代码实现\n\n```js\nfunction quickSort(arr, left, right) {\n    var len = arr.length,\n        partitionIndex,\n        left = typeof left != 'number' ? 0 : left,\n        right = typeof right != 'number' ? len - 1 : right;\n\n    if (left < right) {\n        partitionIndex = partition(arr, left, right);\n        quickSort(arr, left, partitionIndex-1);\n        quickSort(arr, partitionIndex+1, right);\n    }\n    return arr;\n}\n\nfunction partition(arr, left ,right) {     // 分区操作\n    var pivot = left,                      // 设定基准值（pivot）\n        index = pivot + 1;\n    for (var i = index; i <= right; i++) {\n        if (arr[i] < arr[pivot]) {\n            swap(arr, i, index);\n            index++;\n        }        \n    }\n    swap(arr, pivot, index - 1);\n    return index-1;\n}\n\nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\nfunction partition2(arr, low, high) {\n  let pivot = arr[low];\n  while (low < high) {\n    while (low < high && arr[high] > pivot) {\n      --high;\n    }\n    arr[low] = arr[high];\n    while (low < high && arr[low] <= pivot) {\n      ++low;\n    }\n    arr[high] = arr[low];\n  }\n  arr[low] = pivot;\n  return low;\n}\n\nfunction quickSort2(arr, low, high) {\n  if (low < high) {\n    let pivot = partition2(arr, low, high);\n    quickSort2(arr, low, pivot - 1);\n    quickSort2(arr, pivot + 1, high);\n  }\n  return arr;\n}\n\n```\n\n\n## 4. Python 代码实现\n\n```python\ndef quickSort(arr, left=None, right=None):\n    left = 0 if not isinstance(left,(int, float)) else left\n    right = len(arr)-1 if not isinstance(right,(int, float)) else right\n    if left < right:\n        partitionIndex = partition(arr, left, right)\n        quickSort(arr, left, partitionIndex-1)\n        quickSort(arr, partitionIndex+1, right)\n    return arr\n\ndef partition(arr, left, right):\n    pivot = left\n    index = pivot+1\n    i = index\n    while  i <= right:\n        if arr[i] < arr[pivot]:\n            swap(arr, i, index)\n            index+=1\n        i+=1\n    swap(arr,pivot,index-1)\n    return index-1\n\ndef swap(arr, i, j):\n    arr[i], arr[j] = arr[j], arr[i]\n```\n\n## 5. Go 代码实现\n\n```go\nfunc quickSort(arr []int) []int {\n\treturn _quickSort(arr, 0, len(arr)-1)\n}\n\nfunc _quickSort(arr []int, left, right int) []int {\n\tif left < right {\n\t\tpartitionIndex := partition(arr, left, right)\n\t\t_quickSort(arr, left, partitionIndex-1)\n\t\t_quickSort(arr, partitionIndex+1, right)\n\t}\n\treturn arr\n}\n\nfunc partition(arr []int, left, right int) int {\n\tpivot := left\n\tindex := pivot + 1\n\n\tfor i := index; i <= right; i++ {\n\t\tif arr[i] < arr[pivot] {\n\t\t\tswap(arr, i, index)\n\t\t\tindex += 1\n\t\t}\n\t}\n\tswap(arr, pivot, index-1)\n\treturn index - 1\n}\n\nfunc swap(arr []int, i, j int) {\n\tarr[i], arr[j] = arr[j], arr[i]\n}\n```\n\n## 6. C++版\n\n\n```C++\n //严蔚敏《数据结构》标准分割函数\n Paritition1(int A[], int low, int high) {\n   int pivot = A[low];\n   while (low < high) {\n     while (low < high && A[high] >= pivot) {\n       --high;\n     }\n     A[low] = A[high];\n     while (low < high && A[low] <= pivot) {\n       ++low;\n     }\n     A[high] = A[low];\n   }\n   A[low] = pivot;\n   return low;\n }\n\n void QuickSort(int A[], int low, int high) //快排母函数\n {\n   if (low < high) {\n     int pivot = Paritition1(A, low, high);\n     QuickSort(A, low, pivot - 1);\n     QuickSort(A, pivot + 1, high);\n   }\n }\n```\n\n## 7. Java 代码实现\n\n```java\npublic class QuickSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) throws Exception {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        return quickSort(arr, 0, arr.length - 1);\n    }\n\n    private int[] quickSort(int[] arr, int left, int right) {\n        if (left < right) {\n            int partitionIndex = partition(arr, left, right);\n            quickSort(arr, left, partitionIndex - 1);\n            quickSort(arr, partitionIndex + 1, right);\n        }\n        return arr;\n    }\n\n    private int partition(int[] arr, int left, int right) {\n        // 设定基准值（pivot）\n        int pivot = left;\n        int index = pivot + 1;\n        for (int i = index; i <= right; i++) {\n            if (arr[i] < arr[pivot]) {\n                swap(arr, i, index);\n                index++;\n            }\n        }\n        swap(arr, pivot, index - 1);\n        return index - 1;\n    }\n\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n}\n```\n\n## 8. PHP 代码实现\n\n```php\nfunction quickSort($arr)\n{\n    if (count($arr) <= 1)\n        return $arr;\n    $middle = $arr[0];\n    $leftArray = array();\n    $rightArray = array();\n\n    for ($i = 1; $i < count($arr); $i++) {\n        if ($arr[$i] > $middle)\n            $rightArray[] = $arr[$i];\n        else\n            $leftArray[] = $arr[$i];\n    }\n    $leftArray = quickSort($leftArray);\n    $leftArray[] = $middle;\n\n    $rightArray = quickSort($rightArray);\n    return array_merge($leftArray, $rightArray);\n}\n```\n"
        },
        {
          "name": "7.heapSort.md",
          "type": "blob",
          "size": 5.46484375,
          "content": "# 堆排序\n\n堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：\n\n1. 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；\n2. 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；\n\n堆排序的平均时间复杂度为 Ο(nlogn)。\n\n\n## 1. 算法步骤\n\n1. 将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆；\n\n2. 把堆首（最大值）和堆尾互换；\n\n3. 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；\n\n4. 重复步骤 2，直到堆的尺寸为 1。\n\n\n## 2. 动图演示\n\n![动图演示](res/heapSort.gif)\n\n\n## 3. JavaScript 代码实现\n\n```js\nvar len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量\n\nfunction buildMaxHeap(arr) {   // 建立大顶堆\n    len = arr.length;\n    for (var i = Math.floor(len/2); i >= 0; i--) {\n        heapify(arr, i);\n    }\n}\n\nfunction heapify(arr, i) {     // 堆调整\n    var left = 2 * i + 1,\n        right = 2 * i + 2,\n        largest = i;\n\n    if (left < len && arr[left] > arr[largest]) {\n        largest = left;\n    }\n\n    if (right < len && arr[right] > arr[largest]) {\n        largest = right;\n    }\n\n    if (largest != i) {\n        swap(arr, i, largest);\n        heapify(arr, largest);\n    }\n}\n\nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nfunction heapSort(arr) {\n    buildMaxHeap(arr);\n\n    for (var i = arr.length-1; i > 0; i--) {\n        swap(arr, 0, i);\n        len--;\n        heapify(arr, 0);\n    }\n    return arr;\n}\n```\n## 4. Python 代码实现\n\n```python\ndef buildMaxHeap(arr):\n    import math\n    for i in range(math.floor(len(arr)/2),-1,-1):\n        heapify(arr,i)\n\ndef heapify(arr, i):\n    left = 2*i+1\n    right = 2*i+2\n    largest = i\n    if left < arrLen and arr[left] > arr[largest]:\n        largest = left\n    if right < arrLen and arr[right] > arr[largest]:\n        largest = right\n\n    if largest != i:\n        swap(arr, i, largest)\n        heapify(arr, largest)\n\ndef swap(arr, i, j):\n    arr[i], arr[j] = arr[j], arr[i]\n\ndef heapSort(arr):\n    global arrLen\n    arrLen = len(arr)\n    buildMaxHeap(arr)\n    for i in range(len(arr)-1,0,-1):\n        swap(arr,0,i)\n        arrLen -=1\n        heapify(arr, 0)\n    return arr\n```\n\n## 5. Go 代码实现\n\n```go\nfunc heapSort(arr []int) []int {\n\tarrLen := len(arr)\n\tbuildMaxHeap(arr, arrLen)\n\tfor i := arrLen - 1; i >= 0; i-- {\n\t\tswap(arr, 0, i)\n\t\tarrLen -= 1\n\t\theapify(arr, 0, arrLen)\n\t}\n\treturn arr\n}\n\nfunc buildMaxHeap(arr []int, arrLen int) {\n\tfor i := arrLen / 2; i >= 0; i-- {\n\t\theapify(arr, i, arrLen)\n\t}\n}\n\nfunc heapify(arr []int, i, arrLen int) {\n\tleft := 2*i + 1\n\tright := 2*i + 2\n\tlargest := i\n\tif left < arrLen && arr[left] > arr[largest] {\n\t\tlargest = left\n\t}\n\tif right < arrLen && arr[right] > arr[largest] {\n\t\tlargest = right\n\t}\n\tif largest != i {\n\t\tswap(arr, i, largest)\n\t\theapify(arr, largest, arrLen)\n\t}\n}\n\nfunc swap(arr []int, i, j int) {\n\tarr[i], arr[j] = arr[j], arr[i]\n}\n```\n\n## 6. Java 代码实现\n\n```java\npublic class HeapSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) throws Exception {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        int len = arr.length;\n\n        buildMaxHeap(arr, len);\n\n        for (int i = len - 1; i > 0; i--) {\n            swap(arr, 0, i);\n            len--;\n            heapify(arr, 0, len);\n        }\n        return arr;\n    }\n\n    private void buildMaxHeap(int[] arr, int len) {\n        for (int i = (int) Math.floor(len / 2); i >= 0; i--) {\n            heapify(arr, i, len);\n        }\n    }\n\n    private void heapify(int[] arr, int i, int len) {\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        int largest = i;\n\n        if (left < len && arr[left] > arr[largest]) {\n            largest = left;\n        }\n\n        if (right < len && arr[right] > arr[largest]) {\n            largest = right;\n        }\n\n        if (largest != i) {\n            swap(arr, i, largest);\n            heapify(arr, largest, len);\n        }\n    }\n\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n}\n```\n\n## 7. PHP 代码实现\n\n```php\nfunction buildMaxHeap(&$arr)\n{\n    global $len;\n    for ($i = floor($len/2); $i >= 0; $i--) {\n        heapify($arr, $i);\n    }\n}\n\nfunction heapify(&$arr, $i)\n{\n    global $len;\n    $left = 2 * $i + 1;\n    $right = 2 * $i + 2;\n    $largest = $i;\n\n    if ($left < $len && $arr[$left] > $arr[$largest]) {\n        $largest = $left;\n    }\n\n    if ($right < $len && $arr[$right] > $arr[$largest]) {\n        $largest = $right;\n    }\n\n    if ($largest != $i) {\n        swap($arr, $i, $largest);\n        heapify($arr, $largest);\n    }\n}\n\nfunction swap(&$arr, $i, $j)\n{\n    $temp = $arr[$i];\n    $arr[$i] = $arr[$j];\n    $arr[$j] = $temp;\n}\n\nfunction heapSort($arr) {\n    global $len;\n    $len = count($arr);\n    buildMaxHeap($arr);\n    for ($i = count($arr) - 1; $i > 0; $i--) {\n        swap($arr, 0, $i);\n        $len--;\n        heapify($arr, 0);\n    }\n    return $arr;\n}\n```\n"
        },
        {
          "name": "8.countingSort.md",
          "type": "blob",
          "size": 3.2958984375,
          "content": "# 计数排序\n\n计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n\n## 1. 动图演示\n\n![动图演示](res/countingSort.gif)\n\n\n## 2. JavaScript 代码实现\n\n```js\nfunction countingSort(arr, maxValue) {\n    var bucket = new Array(maxValue+1),\n        sortedIndex = 0;\n        arrLen = arr.length,\n        bucketLen = maxValue + 1;\n\n    for (var i = 0; i < arrLen; i++) {\n        if (!bucket[arr[i]]) {\n            bucket[arr[i]] = 0;\n        }\n        bucket[arr[i]]++;\n    }\n\n    for (var j = 0; j < bucketLen; j++) {\n        while(bucket[j] > 0) {\n            arr[sortedIndex++] = j;\n            bucket[j]--;\n        }\n    }\n\n    return arr;\n}\n```\n\n## 3. Python 代码实现\n\n\n```python\ndef countingSort(arr, maxValue):\n    bucketLen = maxValue+1\n    bucket = [0]*bucketLen\n    sortedIndex =0\n    arrLen = len(arr)\n    for i in range(arrLen):\n        if not bucket[arr[i]]:\n            bucket[arr[i]]=0\n        bucket[arr[i]]+=1\n    for j in range(bucketLen):\n        while bucket[j]>0:\n            arr[sortedIndex] = j\n            sortedIndex+=1\n            bucket[j]-=1\n    return arr\n```\n\n## 4. Go 代码实现\n\n```go\nfunc countingSort(arr []int, maxValue int) []int {\n\tbucketLen := maxValue + 1\n\tbucket := make([]int, bucketLen) // 初始为0的数组\n\n\tsortedIndex := 0\n\tlength := len(arr)\n\n\tfor i := 0; i < length; i++ {\n\t\tbucket[arr[i]] += 1\n\t}\n\n\tfor j := 0; j < bucketLen; j++ {\n\t\tfor bucket[j] > 0 {\n\t\t\tarr[sortedIndex] = j\n\t\t\tsortedIndex += 1\n\t\t\tbucket[j] -= 1\n\t\t}\n\t}\n\n\treturn arr\n}\n```\n\n## 5. Java 代码实现\n\n```java\npublic class CountingSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) throws Exception {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        int maxValue = getMaxValue(arr);\n\n        return countingSort(arr, maxValue);\n    }\n\n    private int[] countingSort(int[] arr, int maxValue) {\n        int bucketLen = maxValue + 1;\n        int[] bucket = new int[bucketLen];\n\n        for (int value : arr) {\n            bucket[value]++;\n        }\n\n        int sortedIndex = 0;\n        for (int j = 0; j < bucketLen; j++) {\n            while (bucket[j] > 0) {\n                arr[sortedIndex++] = j;\n                bucket[j]--;\n            }\n        }\n        return arr;\n    }\n\n    private int getMaxValue(int[] arr) {\n        int maxValue = arr[0];\n        for (int value : arr) {\n            if (maxValue < value) {\n                maxValue = value;\n            }\n        }\n        return maxValue;\n    }\n\n}\n```\n\n## 6. PHP 代码实现\n\n```php\nfunction countingSort($arr, $maxValue = null)\n{\n    if ($maxValue === null) {\n        $maxValue = max($arr);\n    }\n    for ($m = 0; $m < $maxValue + 1; $m++) {\n        $bucket[] = null;\n    }\n\n    $arrLen = count($arr);\n    for ($i = 0; $i < $arrLen; $i++) {\n        if (!array_key_exists($arr[$i], $bucket)) {\n            $bucket[$arr[$i]] = 0;\n        }\n        $bucket[$arr[$i]]++;\n    }\n\n    $sortedIndex = 0;\n    foreach ($bucket as $key => $len) {\n        if($len !== null){\n            for($j = 0; $j < $len; $j++){\n                $arr[$sortedIndex++] = $key;\n            }\n        }\n    }\n\n    return $arr;\n}\n```"
        },
        {
          "name": "9.bucketSort.md",
          "type": "blob",
          "size": 4.630859375,
          "content": "# 桶排序\n\n桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：\n\n1. 在额外空间充足的情况下，尽量增大桶的数量\n2. 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中\n\n同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。\n\n\n## 1. 什么时候最快\n\n当输入的数据可以均匀的分配到每一个桶中。\n\n\n## 2. 什么时候最慢\n\n当输入的数据被分配到了同一个桶中。\n\n\n## 3. JavaScript 代码实现\n\n```js\nfunction bucketSort(arr, bucketSize) {\n    if (arr.length === 0) {\n      return arr;\n    }\n\n    var i;\n    var minValue = arr[0];\n    var maxValue = arr[0];\n    for (i = 1; i < arr.length; i++) {\n      if (arr[i] < minValue) {\n          minValue = arr[i];                // 输入数据的最小值\n      } else if (arr[i] > maxValue) {\n          maxValue = arr[i];                // 输入数据的最大值\n      }\n    }\n\n    //桶的初始化\n    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5\n    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;\n    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   \n    var buckets = new Array(bucketCount);\n    for (i = 0; i < buckets.length; i++) {\n        buckets[i] = [];\n    }\n\n    //利用映射函数将数据分配到各个桶中\n    for (i = 0; i < arr.length; i++) {\n        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);\n    }\n\n    arr.length = 0;\n    for (i = 0; i < buckets.length; i++) {\n        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序\n        for (var j = 0; j < buckets[i].length; j++) {\n            arr.push(buckets[i][j]);                      \n        }\n    }\n\n    return arr;\n}\n```\n\n## 4. Java 代码实现\n\n```java\npublic class BucketSort implements IArraySort {\n\n    private static final InsertSort insertSort = new InsertSort();\n\n    @Override\n    public int[] sort(int[] sourceArray) throws Exception {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        return bucketSort(arr, 5);\n    }\n\n    private int[] bucketSort(int[] arr, int bucketSize) throws Exception {\n        if (arr.length == 0) {\n            return arr;\n        }\n\n        int minValue = arr[0];\n        int maxValue = arr[0];\n        for (int value : arr) {\n            if (value < minValue) {\n                minValue = value;\n            } else if (value > maxValue) {\n                maxValue = value;\n            }\n        }\n\n        int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;\n        int[][] buckets = new int[bucketCount][0];\n\n        // 利用映射函数将数据分配到各个桶中\n        for (int i = 0; i < arr.length; i++) {\n            int index = (int) Math.floor((arr[i] - minValue) / bucketSize);\n            buckets[index] = arrAppend(buckets[index], arr[i]);\n        }\n\n        int arrIndex = 0;\n        for (int[] bucket : buckets) {\n            if (bucket.length <= 0) {\n                continue;\n            }\n            // 对每个桶进行排序，这里使用了插入排序\n            bucket = insertSort.sort(bucket);\n            for (int value : bucket) {\n                arr[arrIndex++] = value;\n            }\n        }\n\n        return arr;\n    }\n\n    /**\n     * 自动扩容，并保存数据\n     *\n     * @param arr\n     * @param value\n     */\n    private int[] arrAppend(int[] arr, int value) {\n        arr = Arrays.copyOf(arr, arr.length + 1);\n        arr[arr.length - 1] = value;\n        return arr;\n    }\n\n}\n```\n\n## 5. PHP 代码实现\n\n```php\nfunction bucketSort($arr, $bucketSize = 5)\n{\n    if (count($arr) === 0) {\n      return $arr;\n    }\n\n    $minValue = $arr[0];\n    $maxValue = $arr[0];\n    for ($i = 1; $i < count($arr); $i++) {\n      if ($arr[$i] < $minValue) {\n          $minValue = $arr[$i];\n      } else if ($arr[$i] > $maxValue) {\n          $maxValue = $arr[$i];\n      }\n    }\n\n    $bucketCount = floor(($maxValue - $minValue) / $bucketSize) + 1;\n    $buckets = array();\n    for ($i = 0; $i < count($buckets); $i++) {\n        $buckets[$i] = [];\n    }\n\n    for ($i = 0; $i < count($arr); $i++) {\n        $buckets[floor(($arr[$i] - $minValue) / $bucketSize)][] = $arr[$i];\n    }\n\n    $arr = array();\n    for ($i = 0; $i < count($buckets); $i++) {\n        $bucketTmp = $buckets[$i];\n        sort($bucketTmp);\n        for ($j = 0; $j < count($bucketTmp); $j++) {\n            $arr[] = $bucketTmp[$j];\n        }\n    }\n\n    return $arr;\n}\n```"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.32421875,
          "content": "# 十大经典排序算法\n\n[![Build Status](https://travis-ci.org/hustcc/JS-Sorting-Algorithm.svg?branch=master)](https://travis-ci.org/hustcc/JS-Sorting-Algorithm)\n\n排序算法是《数据结构与算法》中最基本的算法之一。\n\n排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：**插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序**等。用一张图概括：\n\n![十大经典排序算法 概览截图](res/sort.png)\n\n\n**关于时间复杂度**：\n\n1. 平方阶 (O(n2)) 排序\n\t各类简单排序：直接插入、直接选择和冒泡排序。\n2. 线性对数阶 (O(nlog2n)) 排序\n\t快速排序、堆排序和归并排序；\n3. O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。\n    希尔排序\n4. 线性阶 (O(n)) 排序\n\t基数排序，此外还有桶、箱排序。\n\n\n**关于稳定性**：\n\n稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。\n\n不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。\n\n\n**名词解释**：\n\n**n**：数据规模\n\n**k**：“桶”的个数\n\n**In-place**：占用常数内存，不占用额外内存\n\n**Out-place**：占用额外内存\n\n**稳定性**：排序后 2 个相等键值的顺序和排序之前它们的顺序相同\n\n----\n\n\n**GitBook 内容大纲**\n\n1. [冒泡排序](1.bubbleSort.md)\n2. [选择排序](2.selectionSort.md)\n3. [插入排序](3.insertionSort.md)\n4. [希尔排序](4.shellSort.md)\n5. [归并排序](5.mergeSort.md)\n6. [快速排序](6.quickSort.md)\n7. [堆排序](7.heapSort.md)\n8. [计数排序](8.countingSort.md)\n9. [桶排序](9.bucketSort.md)\n10. [基数排序](10.radixSort.md)\n\n----\n\n本书内容几乎完全来源于网络。\n\n开源项目地址：[https://github.com/hustcc/JS-Sorting-Algorithm](https://github.com/hustcc/JS-Sorting-Algorithm)，整理人 [hustcc](https://github.com/hustcc)。\n\nGitBook 在线阅读地址：[https://sort.hust.cc/](https://sort.hust.cc/)。\n\n本项目使用 [lint-md](https://github.com/hustcc/lint-md) 进行中文 Markdown 文件的格式检查，务必在提交 Pr 之前，保证 Markdown 格式正确。\n"
        },
        {
          "name": "SUMMARY.md",
          "type": "blob",
          "size": 0.3505859375,
          "content": "# Summary\n\n1. [冒泡排序](1.bubbleSort.md)\n2. [选择排序](2.selectionSort.md)\n3. [插入排序](3.insertionSort.md)\n4. [希尔排序](4.shellSort.md)\n5. [归并排序](5.mergeSort.md)\n6. [快速排序](6.quickSort.md)\n7. [堆排序](7.heapSort.md)\n8. [计数排序](8.countingSort.md)\n9. [桶排序](9.bucketSort.md)\n10. [基数排序](10.radixSort.md)\n"
        },
        {
          "name": "res",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}