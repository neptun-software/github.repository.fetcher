{
  "metadata": {
    "timestamp": 1736708763640,
    "page": 240,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "DerekYRC/mini-spring",
      "stars": 5745,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.05078125,
          "content": "out/\ntarget/\n.idea/\n.idea_modules/\n*.iml\n*.ipr\n*.iws"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.3837890625,
          "content": "# <img src=\"assets/spring-framework.png\" width=\"80\" height=\"80\"> mini-spring\n[![Build Status](https://img.shields.io/badge/build-passing-brightgreen)](https://github.com/DerekYRC/mini-spring)\n[![License](https://img.shields.io/badge/license-Apache%202-4EB1BA.svg)](https://www.apache.org/licenses/LICENSE-2.0.html)\n[![Stars](https://img.shields.io/github/stars/DerekYRC/mini-spring)](https://img.shields.io/github/stars/DerekYRC/mini-spring)\n[![Forks](https://img.shields.io/github/forks/DerekYRC/mini-spring)](https://img.shields.io/github/forks/DerekYRC/mini-spring)\n\n**[English](./README_en.md) | 简体中文**\n\n**姊妹版：**[**mini-spring-cloud**](https://github.com/DerekYRC/mini-spring-cloud) **(简化版的spring cloud框架)**\n\n## 关于\n\n**mini-spring**是简化版的spring框架，能帮助你快速熟悉spring源码和掌握spring的核心原理。抽取了spring的核心逻辑，**代码极度简化，保留spring的核心功能**，如IoC和AOP、资源加载器、事件监听器、类型转换、容器扩展点、bean生命周期和作用域、应用上下文等核心功能。\n\n如果本项目能帮助到你，请给个**STAR，谢谢！！！**\n\n## 功能\n#### 基础篇\n* [IoC](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#基础篇IoC)\n    * [实现一个简单的容器](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#最简单的bean容器)\n    * [BeanDefinition和BeanDefinitionRegistry](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#BeanDefinition和BeanDefinitionRegistry)\n    * [Bean实例化策略InstantiationStrategy](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#Bean实例化策略InstantiationStrategy)\n    * [为bean填充属性](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#为bean填充属性)\n    * [为bean注入bean](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#为bean注入bean)\n    * [资源和资源加载器](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#资源和资源加载器)\n    * [在xml文件中定义bean](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#在xml文件中定义bean)\n    * [容器扩展机制BeanFactoryPostProcess和BeanPostProcessor](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#BeanFactoryPostProcess和BeanPostProcessor)\n    * [应用上下文ApplicationContext](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#应用上下文ApplicationContext)\n    * [bean的初始化和销毁方法](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#bean的初始化和销毁方法)\n    * [Aware接口](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#Aware接口)\n    * [bean作用域，增加prototype的支持](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#bean作用域增加prototype的支持)\n    * [FactoryBean](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#FactoryBean)\n    * [容器事件和事件监听器](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#容器事件和事件监听器)\n* [AOP](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#基础篇AOP)\n    * [切点表达式](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#切点表达式)\n    * [基于JDK的动态代理](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#基于JDK的动态代理)\n    * [基于CGLIB的动态代理](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#基于CGLIB的动态代理)\n    * [AOP代理工厂ProxyFactory](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#AOP代理工厂)\n    * [几种常用的Advice: BeforeAdvice/AfterAdvice/AfterReturningAdvice/ThrowsAdvice](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#几种常用的AdviceBeforeAdviceAfterAdviceAfterReturningAdviceThrowsAdvice)\n    * [PointcutAdvisor：Pointcut和Advice的组合](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#pointcutadvisorpointcut和advice的组合)\n    * [动态代理融入bean生命周期](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#动态代理融入bean生命周期)\n    \n#### 扩展篇\n* [PropertyPlaceholderConfigurer](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#propertyplaceholderconfigurer)\n* [包扫描](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#包扫描)\n* [@Value注解](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#value注解)\n* [基于注解@Autowired的依赖注入](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#autowired注解)\n* [类型转换（一）](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#类型转换一)\n* [类型转换（二）](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#类型转换二)\n\n#### 高级篇\n* [解决循环依赖问题（一）：没有代理对象](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#解决循环依赖问题一没有代理对象)\n* [解决循环依赖问题（二）：有代理对象](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#解决循环依赖问题二有代理对象)\n\n#### 其他\n* [没有为代理bean设置属性(discovered and fixed by kerwin89)](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#bug-fix没有为代理bean设置属性discovered-and-fixed-by-kerwin89)\n* [支持懒加载和多切面增强(by zqczgl)](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#支持懒加载和多切面增强by-zqczgl)\n\n## 使用方法\n阅读[changelog.md](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md)\n\n[视频教程(完整版)](https://www.bilibili.com/video/BV1nb4y1A7YJ)\n\n## 提问\n[**点此提问**](https://github.com/DerekYRC/mini-spring/issues/4)\n\n## 贡献\n欢迎Pull Request\n\n## 关于我\n[**点此了解**](https://github.com/DerekYRC)\n\n手机/微信：**15975984828**  邮箱：**15975984828@163.com**\n\n## Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=DerekYRC/mini-spring&type=Date)](https://star-history.com/#DerekYRC/mini-spring&Date)\n\n## 版权说明\n未取得本人书面许可，不得将该项目用于商业用途\n\n## 参考\n- [《Spring源码深度解析》](https://book.douban.com/subject/25866350/)\n- [《Spring 源码解析》](http://svip.iocoder.cn/categories/Spring)\n- [《精通Spring 4.x》](https://book.douban.com/subject/26952826/)\n- [《tiny-spring》](https://github.com/code4craft/tiny-spring)\n"
        },
        {
          "name": "README_en.md",
          "type": "blob",
          "size": 4.111328125,
          "content": "# <img src=\"assets/spring-framework.png\" width=\"80\" height=\"80\"> mini-spring\n[![Build Status](https://img.shields.io/badge/build-passing-brightgreen)](https://github.com/DerekYRC/mini-spring)\n[![License](https://img.shields.io/badge/license-Apache%202-4EB1BA.svg)](https://www.apache.org/licenses/LICENSE-2.0.html)\n[![Stars](https://img.shields.io/github/stars/DerekYRC/mini-spring)](https://img.shields.io/github/stars/DerekYRC/mini-spring)\n[![Forks](https://img.shields.io/github/forks/DerekYRC/mini-spring)](https://img.shields.io/github/forks/DerekYRC/mini-spring)\n\n**English | [简体中文](./README.md)**\n\n[**mini-spring-cloud**](https://github.com/DerekYRC/mini-spring-cloud) **(simplified version of the Spring Cloud framework)**\n\n## About\n\nThe **mini-spring** is a simplified version of the Spring framework that will help you quickly get familiar with the Spring source code and grasp the core principles of Spring. The core logic of Spring is extracted, the code is extremely simplified, and the core functions of Spring, such as IoC and AOP, resource loaders, event listeners, type conversion, container extension points, bean life cycle and scope, and application context, are retained.\n\nIf this project can help you, please **STAR the project, thank you!!!**\n\n## Contents\n#### Basics\n* [IoC](#Ioc)\n    * [Implement a simple container](#实现一个简单的容器)\n    * [BeanDefinition and BeanDefinitionRegistry](#BeanDefinition和BeanDefinitionRegistry)\n    * [Bean Instantiation Strategy](#Bean实例化策略InstantiationStrategy)\n    * [Populate bean with property values](#为bean填充属性)\n    * [Populate bean with bean](#为bean注入bean)\n    * [Resource and ResourceLoader](#资源和资源加载器)\n    * [Define the bean in the XML file](#在xml文件中定义bean)\n    * [Container extension mechanism：BeanFactoryPostProcess and BeanPostProcessor](#容器扩展机制BeanFactoryPostProcess和BeanPostProcessor)\n    * [ApplicationContext](#应用上下文ApplicationContext)\n    * [Init method and destroy method of bean](#bean的初始化和销毁方法)\n    * [Aware interface](#Aware接口)\n    * [Bean scope, added prototype support](#bean作用域，增加prototype的支持)\n    * [FactoryBean](#FactoryBean)\n    * [Event and event listener](#容器事件和事件监听器)\n* [AOP](#AOP)\n    * [Pointcut expression](#切点表达式)\n    * [JDK-based dynamic proxy](#基于JDK的动态代理)\n    * [CGLIB-based dynamic proxy](#基于CGLIB的动态代理)\n    * [AOP ProxyFactory](#AOP代理工厂ProxyFactory)\n    * [Common Advice: BeforeAdvice/AfterAdvice/AfterReturningAdvice/ThrowsAdvice](#几种常用的Advice)\n    * [PointcutAdvisor：A combination of Pointcut and Advice](#PointcutAdvisor：Pointcut和Advice的组合)\n    * [Dynamic proxies are integrated into the bean lifecycle](#动态代理融入bean生命周期)\n    \n\n#### Expanding \n* [PropertyPlaceholderConfigurer](#PropertyPlaceholderConfigurer)\n* [Package scan](#包扫描)\n* [Value annotation](#Value)\n* [Autowired annotation](#Autowired)\n* [Type conversion(first part)](#类型转换一)\n* [Type conversion(second part)](#类型转换二)\n\n#### Advanced\n* [Solve the problem of circular dependencies(first part): without proxy bean](#解决循环依赖问题一)\n* [Solve the problem of circular dependencies(second part): with proxy bean](#解决循环依赖问题二)\n\n#### Bug fix\n* [populate proxy bean with property values(discovered and fixed by kerwin89)](#没有为代理bean设置属性)\n\n## Usage\nEach function point corresponds to a branch. Switch to the branch corresponding to the function point to see the new function. The incremental change point is described in the [changelog.md](https://github.com/DerekYRC/mini-spring/blob/main/changelog.md) file.\n\n## Contributing\nAny contributions you make are greatly appreciated.\n\n## Contact\nPlease feel free to ask me any questions related to mini-spring and other technologies. My email is **15521077528@163.com**. \n\n## Reference\n- [《Spring源码深度解析》](https://book.douban.com/subject/25866350/)\n- [《精通Spring 4.x》](https://book.douban.com/subject/26952826/)\n- [tiny-spring](https://github.com/code4craft/tiny-spring)\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "changelog.md",
          "type": "blob",
          "size": 73.1953125,
          "content": " # [基础篇：IoC](#基础篇IoC)\n ## [最简单的bean容器](#最简单的bean容器)\n > 代码分支：simple-bean-container\n\n定义一个简单的bean容器BeanFactory，内部包含一个map用以保存bean，只有注册bean和获取bean两个方法\n```java\npublic class BeanFactory {\n\tprivate Map<String, Object> beanMap = new HashMap<>();\n\n\tpublic void registerBean(String name, Object bean) {\n\t\tbeanMap.put(name, bean);\n\t}\n\n\tpublic Object getBean(String name) {\n\t\treturn beanMap.get(name);\n\t}\n}\n```\n\n测试：\n```java\npublic class SimpleBeanContainerTest {\n\n\t@Test\n\tpublic void testGetBean() throws Exception {\n\t\tBeanFactory beanFactory = new BeanFactory();\n\t\tbeanFactory.registerBean(\"helloService\", new HelloService());\n\t\tHelloService helloService = (HelloService) beanFactory.getBean(\"helloService\");\n\t\tassertThat(helloService).isNotNull();\n\t\tassertThat(helloService.sayHello()).isEqualTo(\"hello\");\n\t}\n\n\tclass HelloService {\n\t\tpublic String sayHello() {\n\t\t\tSystem.out.println(\"hello\");\n\t\t\treturn \"hello\";\n\t\t}\n\t}\n}\n```\n\n## [BeanDefinition和BeanDefinitionRegistry](#BeanDefinition和BeanDefinitionRegistry)\n> 代码分支：bean-definition-and-bean-definition-registry\n\n主要增加如下类：\n- BeanDefinition，顾名思义，用于定义bean信息的类，包含bean的class类型、构造参数、属性值等信息，每个bean对应一个BeanDefinition的实例。简化BeanDefinition仅包含bean的class类型。\n- BeanDefinitionRegistry，BeanDefinition注册表接口，定义注册BeanDefinition的方法。\n- SingletonBeanRegistry及其实现类DefaultSingletonBeanRegistry，定义添加和获取单例bean的方法。\n\nbean容器作为BeanDefinitionRegistry和SingletonBeanRegistry的实现类，具备两者的能力。向bean容器中注册BeanDefinition后，使用bean时才会实例化。\n\n![](./assets/bean-definition-and-bean-definition-registry.png)\n\n测试：\n```java\npublic class BeanDefinitionAndBeanDefinitionRegistryTest {\n\n\t@Test\n\tpublic void testBeanFactory() throws Exception {\n\t\tDefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n\t\tBeanDefinition beanDefinition = new BeanDefinition(HelloService.class);\n\t\tbeanFactory.registerBeanDefinition(\"helloService\", beanDefinition);\n\n\t\tHelloService helloService = (HelloService) beanFactory.getBean(\"helloService\");\n\t\thelloService.sayHello();\n\t}\n}\n\nclass HelloService {\n\tpublic String sayHello() {\n\t\tSystem.out.println(\"hello\");\n\t\treturn \"hello\";\n\t}\n}\n```\n\n## [Bean实例化策略InstantiationStrategy](#Bean实例化策略InstantiationStrategy)\n> 代码分支：instantiation-strategy\n\n现在bean是在AbstractAutowireCapableBeanFactory.doCreateBean方法中用beanClass.newInstance()来实例化，仅适用于bean有无参构造函数的情况。\n\n![](./assets/instantiation-strategy.png)\n\n针对bean的实例化，抽象出一个实例化策略的接口InstantiationStrategy，有两个实现类：\n- SimpleInstantiationStrategy，使用bean的构造函数来实例化\n- CglibSubclassingInstantiationStrategy，使用CGLIB动态生成子类\n\n## [为bean填充属性](#为bean填充属性)\n> 代码分支：populate-bean-with-property-values\n\n在BeanDefinition中增加和bean属性对应的PropertyValues，实例化bean之后，为bean填充属性(AbstractAutowireCapableBeanFactory#applyPropertyValues)。\n\n测试：\n```java\npublic class PopulateBeanWithPropertyValuesTest {\n\n\t@Test\n\tpublic void testPopulateBeanWithPropertyValues() throws Exception {\n\t\tDefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n\t\tPropertyValues propertyValues = new PropertyValues();\n\t\tpropertyValues.addPropertyValue(new PropertyValue(\"name\", \"derek\"));\n\t\tpropertyValues.addPropertyValue(new PropertyValue(\"age\", 18));\n\t\tBeanDefinition beanDefinition = new BeanDefinition(Person.class, propertyValues);\n\t\tbeanFactory.registerBeanDefinition(\"person\", beanDefinition);\n\n\t\tPerson person = (Person) beanFactory.getBean(\"person\");\n\t\tSystem.out.println(person);\n\t\tassertThat(person.getName()).isEqualTo(\"derek\");\n\t\tassertThat(person.getAge()).isEqualTo(18);\n\t}\n}\n```\n\n## [为bean注入bean](#为bean注入bean)\n> 代码分支：populate-bean-with-bean\n\n增加BeanReference类，包装一个bean对另一个bean的引用。实例化beanA后填充属性时，若PropertyValue#value为BeanReference，引用beanB，则先去实例化beanB。\n由于不想增加代码的复杂度提高理解难度，暂时不支持循环依赖，后面会在高级篇中解决该问题。\n```java\nprotected void applyPropertyValues(String beanName, Object bean, BeanDefinition beanDefinition) {\n    try {\n        for (PropertyValue propertyValue : beanDefinition.getPropertyValues().getPropertyValues()) {\n            String name = propertyValue.getName();\n            Object value = propertyValue.getValue();\n            if (value instanceof BeanReference) {\n                // beanA依赖beanB，先实例化beanB\n                BeanReference beanReference = (BeanReference) value;\n                value = getBean(beanReference.getBeanName());\n            }\n\n            //通过反射设置属性\n            BeanUtil.setFieldValue(bean, name, value);\n        }\n    } catch (Exception ex) {\n        throw new BeansException(\"Error setting property values for bean: \" + beanName, ex);\n    }\n}\n```\n\n测试：\n```java\npublic class PopulateBeanWithPropertyValuesTest {\n\n\t/**\n\t * 为bean注入bean\n\t *\n\t * @throws Exception\n\t */\n\t@Test\n\tpublic void testPopulateBeanWithBean() throws Exception {\n\t\tDefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n\n\t\t//注册Car实例\n\t\tPropertyValues propertyValuesForCar = new PropertyValues();\n\t\tpropertyValuesForCar.addPropertyValue(new PropertyValue(\"brand\", \"porsche\"));\n\t\tBeanDefinition carBeanDefinition = new BeanDefinition(Car.class, propertyValuesForCar);\n\t\tbeanFactory.registerBeanDefinition(\"car\", carBeanDefinition);\n\n\t\t//注册Person实例\n\t\tPropertyValues propertyValuesForPerson = new PropertyValues();\n\t\tpropertyValuesForPerson.addPropertyValue(new PropertyValue(\"name\", \"derek\"));\n\t\tpropertyValuesForPerson.addPropertyValue(new PropertyValue(\"age\", 18));\n\t\t//Person实例依赖Car实例\n\t\tpropertyValuesForPerson.addPropertyValue(new PropertyValue(\"car\", new BeanReference(\"car\")));\n\t\tBeanDefinition beanDefinition = new BeanDefinition(Person.class, propertyValuesForPerson);\n\t\tbeanFactory.registerBeanDefinition(\"person\", beanDefinition);\n\n\t\tPerson person = (Person) beanFactory.getBean(\"person\");\n\t\tSystem.out.println(person);\n\t\tassertThat(person.getName()).isEqualTo(\"derek\");\n\t\tassertThat(person.getAge()).isEqualTo(18);\n\t\tCar car = person.getCar();\n\t\tassertThat(car).isNotNull();\n\t\tassertThat(car.getBrand()).isEqualTo(\"porsche\");\n\t}\n}\n```\n\n## [资源和资源加载器](#资源和资源加载器)\n> 代码分支：resource-and-resource-loader\n\nResource是资源的抽象和访问接口，简单写了三个实现类\n\n![](./assets/resource.png)\n\n- FileSystemResource，文件系统资源的实现类\n- ClassPathResource，classpath下资源的实现类\n- UrlResource，对java.net.URL进行资源定位的实现类\n\nResourceLoader接口则是资源查找定位策略的抽象，DefaultResourceLoader是其默认实现类\n\n测试：\n```java\npublic class ResourceAndResourceLoaderTest {\n\n\t@Test\n\tpublic void testResourceLoader() throws Exception {\n\t\tDefaultResourceLoader resourceLoader = new DefaultResourceLoader();\n\n\t\t//加载classpath下的资源\n\t\tResource resource = resourceLoader.getResource(\"classpath:hello.txt\");\n\t\tInputStream inputStream = resource.getInputStream();\n\t\tString content = IoUtil.readUtf8(inputStream);\n\t\tSystem.out.println(content);\n\t\tassertThat(content).isEqualTo(\"hello world\");\n\n\t\t//加载文件系统资源\n\t\tresource = resourceLoader.getResource(\"src/test/resources/hello.txt\");\n\t\tassertThat(resource instanceof FileSystemResource).isTrue();\n\t\tinputStream = resource.getInputStream();\n\t\tcontent = IoUtil.readUtf8(inputStream);\n\t\tSystem.out.println(content);\n\t\tassertThat(content).isEqualTo(\"hello world\");\n\n\t\t//加载url资源\n\t\tresource = resourceLoader.getResource(\"https://www.baidu.com\");\n\t\tassertThat(resource instanceof UrlResource).isTrue();\n\t\tinputStream = resource.getInputStream();\n\t\tcontent = IoUtil.readUtf8(inputStream);\n\t\tSystem.out.println(content);\n\t}\n}\n```\n\n## [在xml文件中定义bean](#在xml文件中定义bean)\n> 代码分支：xml-file-define-bean\n\n有了资源加载器，就可以在xml格式配置文件中声明式地定义bean的信息，资源加载器读取xml文件，解析出bean的信息，然后往容器中注册BeanDefinition。\n\nBeanDefinitionReader是读取bean定义信息的抽象接口，XmlBeanDefinitionReader是从xml文件中读取的实现类。BeanDefinitionReader需要有获取资源的能力，且读取bean定义信息后需要往容器中注册BeanDefinition，因此BeanDefinitionReader的抽象实现类AbstractBeanDefinitionReader拥有ResourceLoader和BeanDefinitionRegistry两个属性。\n\n由于从xml文件中读取的内容是String类型，所以属性仅支持String类型和引用其他Bean。后面会讲到类型转换器，实现类型转换。\n\n为了方便后面的讲解和功能实现，并且尽量保持和spring中BeanFactory的继承层次一致，对BeanFactory的继承层次稍微做了调整。\n\n![](./assets/xml-file-define-bean.png)\n\n测试：\nbean定义文件spring.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean id=\"person\" class=\"org.springframework.test.bean.Person\">\n        <property name=\"name\" value=\"derek\"/>\n        <property name=\"car\" ref=\"car\"/>\n    </bean>\n\n    <bean id=\"car\" class=\"org.springframework.test.bean.Car\">\n        <property name=\"brand\" value=\"porsche\"/>\n    </bean>\n\n</beans>\n```\n\n```java\npublic class XmlFileDefineBeanTest {\n\n\t@Test\n\tpublic void testXmlFile() throws Exception {\n\t\tDefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n\t\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\t\tbeanDefinitionReader.loadBeanDefinitions(\"classpath:spring.xml\");\n\n\t\tPerson person = (Person) beanFactory.getBean(\"person\");\n\t\tSystem.out.println(person);\n\t\tassertThat(person.getName()).isEqualTo(\"derek\");\n\t\tassertThat(person.getCar().getBrand()).isEqualTo(\"porsche\");\n\n\t\tCar car = (Car) beanFactory.getBean(\"car\");\n\t\tSystem.out.println(car);\n\t\tassertThat(car.getBrand()).isEqualTo(\"porsche\");\n\t}\n}\n```\n\n## [BeanFactoryPostProcessor和BeanPostProcessor](#BeanFactoryPostProcessor和BeanPostProcessor)\n> 代码分支：bean-factory-post-processor-and-bean-post-processor\n\nBeanFactoryPostProcessor和BeanPostProcessor是spring框架中具有重量级地位的两个接口，理解了这两个接口的作用，基本就理解spring的核心原理了。为了降低理解难度分两个小节实现。\n\nBeanFactoryPostProcessor是spring提供的容器扩展机制，允许我们在bean实例化之前修改bean的定义信息即BeanDefinition的信息。其重要的实现类有PropertyPlaceholderConfigurer和CustomEditorConfigurer，PropertyPlaceholderConfigurer的作用是用properties文件的配置值替换xml文件中的占位符，CustomEditorConfigurer的作用是实现类型转换。BeanFactoryPostProcessor的实现比较简单，看单元测试BeanFactoryPostProcessorAndBeanPostProcessorTest#testBeanFactoryPostProcessor追下代码。\n\nBeanPostProcessor也是spring提供的容器扩展机制，不同于BeanFactoryPostProcessor的是，BeanPostProcessor在bean实例化后修改bean或替换bean。BeanPostProcessor是后面实现AOP的关键。\n\nBeanPostProcessor的两个方法分别在bean执行初始化方法（后面实现）之前和之后执行，理解其实现重点看单元测试BeanFactoryPostProcessorAndBeanPostProcessorTest#testBeanPostProcessor和AbstractAutowireCapableBeanFactory#initializeBean方法，有些地方做了微调，可不必关注。\n\n```java\npublic interface BeanPostProcessor {\n\t/**\n\t * 在bean执行初始化方法之前执行此方法\n\t */\n\tObject postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n\n\t/**\n\t * 在bean执行初始化方法之后执行此方法\n\t */\n\tObject postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n}\n```\n\n下一节将引入ApplicationContext，能自动识别BeanFactoryPostProcessor和BeanPostProcessor，就可以在xml文件中配置而不需要手动添加到BeanFactory了。\n\n测试：\n```java\npublic class BeanFactoryProcessorAndBeanPostProcessorTest {\n\n\t@Test\n\tpublic void testBeanFactoryPostProcessor() throws Exception {\n\t\tDefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n\t\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\t\tbeanDefinitionReader.loadBeanDefinitions(\"classpath:spring.xml\");\n\n\t\t//在所有BeanDefintion加载完成后，但在bean实例化之前，修改BeanDefinition的属性值\n\t\tCustomBeanFactoryPostProcessor beanFactoryPostProcessor = new CustomBeanFactoryPostProcessor();\n\t\tbeanFactoryPostProcessor.postProcessBeanFactory(beanFactory);\n\n\t\tPerson person = (Person) beanFactory.getBean(\"person\");\n\t\tSystem.out.println(person);\n\t\t//name属性在CustomBeanFactoryPostProcessor中被修改为ivy\n\t\tassertThat(person.getName()).isEqualTo(\"ivy\");\n\t}\n\n\t@Test\n\tpublic void testBeanPostProcessor() throws Exception {\n\t\tDefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n\t\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\t\tbeanDefinitionReader.loadBeanDefinitions(\"classpath:spring.xml\");\n\n\t\t//添加bean实例化后的处理器\n\t\tCustomerBeanPostProcessor customerBeanPostProcessor = new CustomerBeanPostProcessor();\n\t\tbeanFactory.addBeanPostProcessor(customerBeanPostProcessor);\n\n\t\tCar car = (Car) beanFactory.getBean(\"car\");\n\t\tSystem.out.println(car);\n\t\t//brand属性在CustomerBeanPostProcessor中被修改为lamborghini\n\t\tassertThat(car.getBrand()).isEqualTo(\"lamborghini\");\n\t}\n}\n```\n\n## [应用上下文ApplicationContext](#应用上下文ApplicationContext)\n> 代码分支：application-context\n\n应用上下文ApplicationContext是spring中较之于BeanFactory更为先进的IOC容器，ApplicationContext除了拥有BeanFactory的所有功能外，还支持特殊类型bean如上一节中的BeanFactoryPostProcessor和BeanPostProcessor的自动识别、资源加载、容器事件和监听器、国际化支持、单例bean自动初始化等。\n\nBeanFactory是spring的基础设施，面向spring本身；而ApplicationContext面向spring的使用者，应用场合使用ApplicationContext。\n\n具体实现查看AbstractApplicationContext#refresh方法即可。注意BeanFactoryPostProcessor和BeanPostProcessor的自动识别，这样就可以在xml文件中配置二者而不需要像上一节一样手动添加到容器中了。\n\n从bean的角度看，目前生命周期如下：\n\n![](./assets/application-context-life-cycle.png)\n\n测试：见ApplicationContextTest\n\n## [bean的初始化和销毁方法](#bean的初始化和销毁方法)\n> 代码分支：init-and-destroy-method\n\n在spring中，定义bean的初始化和销毁方法有三种方法：\n- 在xml文件中制定init-method和destroy-method\n- 继承自InitializingBean和DisposableBean\n- 在方法上加注解PostConstruct和PreDestroy\n\n第三种通过BeanPostProcessor实现，在扩展篇中实现，本节只实现前两种。\n\n针对第一种在xml文件中指定初始化和销毁方法的方式，在BeanDefinition中增加属性initMethodName和destroyMethodName。\n\n初始化方法在AbstractAutowireCapableBeanFactory#invokeInitMethods执行。DefaultSingletonBeanRegistry中增加属性disposableBeans保存拥有销毁方法的bean，拥有销毁方法的bean在AbstractAutowireCapableBeanFactory#registerDisposableBeanIfNecessary中注册到disposableBeans中。\n\n为了确保销毁方法在虚拟机关闭之前执行，向虚拟机中注册一个钩子方法，查看AbstractApplicationContext#registerShutdownHook（非web应用需要手动调用该方法）。当然也可以手动调用ApplicationContext#close方法关闭容器。\n\n到此为止，bean的生命周期如下：\n\n![](./assets/init-and-destroy-method.png)\n\n测试：\ninit-and-destroy-method.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean id=\"person\" class=\"org.springframework.test.bean.Person\" init-method=\"customInitMethod\" destroy-method=\"customDestroyMethod\">\n        <property name=\"name\" value=\"derek\"/>\n        <property name=\"car\" ref=\"car\"/>\n    </bean>\n\n    <bean id=\"car\" class=\"org.springframework.test.bean.Car\">\n        <property name=\"brand\" value=\"porsche\"/>\n    </bean>\n\n</beans>\n```\n\n```java\npublic class Person implements InitializingBean, DisposableBean {\n\n\tprivate String name;\n\n\tprivate int age;\n\n\tprivate Car car;\n\n\tpublic void customInitMethod() {\n\t\tSystem.out.println(\"I was born in the method named customInitMethod\");\n\t}\n\n\tpublic void customDestroyMethod() {\n\t\tSystem.out.println(\"I died in the method named customDestroyMethod\");\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\tSystem.out.println(\"I was born in the method named afterPropertiesSet\");\n\t}\n\n\t@Override\n\tpublic void destroy() throws Exception {\n\t\tSystem.out.println(\"I died in the method named destroy\");\n\t}\n\n    //setter and getter\n}\n```\n\n```java\npublic class InitAndDestoryMethodTest {\n\n\t@Test\n\tpublic void testInitAndDestroyMethod() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:init-and-destroy-method.xml\");\n\t\tapplicationContext.registerShutdownHook();  //或者手动关闭 applicationContext.close();\n\t}\n}\n```\n\n## [Aware接口](#Aware接口)\n> 代码分支：aware-interface\n\nAware是感知、意识的意思，Aware接口是标记性接口，其实现子类能感知容器相关的对象。常用的Aware接口有BeanFactoryAware和ApplicationContextAware，分别能让其实现者感知所属的BeanFactory和ApplicationContext。\n\n让实现BeanFactoryAware接口的类能感知所属的BeanFactory，实现比较简单，查看AbstractAutowireCapableBeanFactory#initializeBean前三行。\n\n实现ApplicationContextAware的接口感知ApplicationContext，是通过BeanPostProcessor。由bean的生命周期可知，bean实例化后会经过BeanPostProcessor的前置处理和后置处理。定义一个BeanPostProcessor的实现类ApplicationContextAwareProcessor，在AbstractApplicationContext#refresh方法中加入到BeanFactory中，在前置处理中为bean设置所属的ApplicationContext。\n\n改用dom4j解析xml文件。\n\n至止，bean的生命周期如下：\n\n![](./assets/aware-interface.png)\n\n测试：\nspring.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean id=\"helloService\" class=\"org.springframework.test.service.HelloService\"/>\n\n</beans>\n```\n\n```java\npublic class HelloService implements ApplicationContextAware, BeanFactoryAware {\n\n\tprivate ApplicationContext applicationContext;\n\n\tprivate BeanFactory beanFactory;\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t\tthis.beanFactory = beanFactory;\n\t}\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\tpublic ApplicationContext getApplicationContext() {\n\t\treturn applicationContext;\n\t}\n\n\tpublic BeanFactory getBeanFactory() {\n\t\treturn beanFactory;\n\t}\n}\n```\n\n```java\npublic class AwareInterfaceTest {\n\n\t@Test\n\tpublic void test() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:spring.xml\");\n\t\tHelloService helloService = applicationContext.getBean(\"helloService\", HelloService.class);\n\t\tassertThat(helloService.getApplicationContext()).isNotNull();\n\t\tassertThat(helloService.getBeanFactory()).isNotNull();\n\t}\n}\n```\n\n## [bean作用域，增加prototype的支持](#bean作用域增加prototype的支持)\n> 代码分支：prototype-bean\n\n每次向容器获取prototype作用域bean时，容器都会创建一个新的实例。在BeanDefinition中增加描述bean的作用域的字段scope，创建prototype作用域bean时（AbstractAutowireCapableBeanFactory#doCreateBean），不往singletonObjects中增加该bean。prototype作用域bean不执行销毁方法，查看AbstractAutowireCapableBeanFactory#registerDisposableBeanIfNecessary方法。\n\n至止，bean的生命周期如下：\n\n![](./assets/prototype-bean.png)\n\n测试：\nprototype-bean.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean id=\"car\" class=\"org.springframework.test.bean.Car\" scope=\"prototype\">\n        <property name=\"brand\" value=\"porsche\"/>\n    </bean>\n\n</beans>\n```\n\n```java\npublic class PrototypeBeanTest {\n\n\t@Test\n\tpublic void testPrototype() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:prototype-bean.xml\");\n\n\t\tCar car1 = applicationContext.getBean(\"car\", Car.class);\n\t\tCar car2 = applicationContext.getBean(\"car\", Car.class);\n\t\tassertThat(car1 != car2).isTrue();\n\t}\n}\n```\n\n## [FactoryBean](#FactoryBean)\n> 代码分支：factory-bean\n\nFactoryBean是一种特殊的bean，当向容器获取该bean时，容器不是返回其本身，而是返回其FactoryBean#getObject方法的返回值，可通过编码方式定义复杂的bean。\n\n实现逻辑比较简单，当容器发现bean为FactoryBean类型时，调用其getObject方法返回最终bean。当FactoryBean#isSingleton==true，将最终bean放进缓存中，下次从缓存中获取。改动点见AbstractBeanFactory#getBean。\n\n测试：\nfactory-bean.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean id=\"car\" class=\"org.springframework.test.common.CarFactoryBean\">\n        <property name=\"brand\" value=\"porsche\"/>\n    </bean>\n\n</beans>\n```\n\n```java\npublic class CarFactoryBean implements FactoryBean<Car> {\n\n\tprivate String brand;\n\n\t@Override\n\tpublic Car getObject() throws Exception {\n\t\tCar car = new Car();\n\t\tcar.setBrand(brand);\n\t\treturn car;\n\t}\n\n\t@Override\n\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}\n\n\tpublic void setBrand(String brand) {\n\t\tthis.brand = brand;\n\t}\n}\n```\n\n```java\npublic class FactoryBeanTest {\n\n\t@Test\n\tpublic void testFactoryBean() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:factory-bean.xml\");\n\n\t\tCar car = applicationContext.getBean(\"car\", Car.class);\n\t\tapplicationContext.getBean(\"car\");\n\t\tassertThat(car.getBrand()).isEqualTo(\"porsche\");\n\t}\n}\n```\n\n## [容器事件和事件监听器](#容器事件和事件监听器)\n\n> 代码分支：event-and-event-listener\n\nApplicationContext容器提供了完善的事件发布和事件监听功能。\n\nApplicationEventMulticaster接口是注册监听器和发布事件的抽象接口，AbstractApplicationContext包含其实现类实例作为其属性，使得ApplicationContext容器具有注册监听器和发布事件的能力。在AbstractApplicationContext#refresh方法中，会实例化ApplicationEventMulticaster、注册监听器并发布容器刷新事件ContextRefreshedEvent；在AbstractApplicationContext#doClose方法中，发布容器关闭事件ContextClosedEvent。\n\n测试：\nevent-and-event-listener.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean class=\"org.springframework.test.common.event.ContextRefreshedEventListener\"/>\n\n    <bean class=\"org.springframework.test.common.event.CustomEventListener\"/>\n\n    <bean class=\"org.springframework.test.common.event.ContextClosedEventListener\"/>\n</beans>\n```\n\n```java\npublic class EventAndEventListenerTest {\n\n\t@Test\n\tpublic void testEventListener() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:event-and-event-listener.xml\");\n\t\tapplicationContext.publishEvent(new CustomEvent(applicationContext));\n\n\t\tapplicationContext.registerShutdownHook();//或者applicationContext.close()主动关闭容器;\n\t}\n}\n```\n\n观察输出：\n```\norg.springframework.test.common.event.ContextRefreshedEventListener\norg.springframework.test.common.event.CustomEventListener\norg.springframework.test.common.event.ContextClosedEventListener\n```\n\n# [基础篇：AOP](#基础篇AOP)\n\n## [切点表达式](#切点表达式)\n> 代码分支：pointcut-expression\n\nJoinpoint，织入点，指需要执行代理操作的某个类的某个方法(仅支持方法级别的JoinPoint)；Pointcut是JoinPoint的表述方式，能捕获JoinPoint。\n\n最常用的切点表达式是AspectJ的切点表达式。需要匹配类，定义ClassFilter接口；匹配方法，定义MethodMatcher接口。PointCut需要同时匹配类和方法，包含ClassFilter和MethodMatcher，AspectJExpressionPointcut是支持AspectJ切点表达式的PointCut实现，简单实现仅支持execution函数。\n\n测试：\n```java\npublic class HelloService {\n\tpublic String sayHello() {\n\t\tSystem.out.println(\"hello\");\n\t\treturn \"hello\";\n\t}\n}\n```\n\n```java\npublic class PointcutExpressionTest {\n\n\t@Test\n\tpublic void testPointcutExpression() throws Exception {\n\t\tAspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(\"execution(* org.springframework.test.service.HelloService.*(..))\");\n\t\tClass<HelloService> clazz = HelloService.class;\n\t\tMethod method = clazz.getDeclaredMethod(\"sayHello\");\n\n\t\tassertThat(pointcut.matches(clazz)).isTrue();\n\t\tassertThat(pointcut.matches(method, clazz)).isTrue();\n\t}\n}\n```\n\n## [基于JDK的动态代理](#基于JDK的动态代理)\n> 代码分支：jdk-dynamic-proxy\n\nAopProxy是获取代理对象的抽象接口，JdkDynamicAopProxy的基于JDK动态代理的具体实现。TargetSource，被代理对象的封装。MethodInterceptor，方法拦截器，是AOP Alliance的\"公民\"，顾名思义，可以拦截方法，可在被代理执行的方法前后增加代理行为。\n\n测试;\n```java\npublic class DynamicProxyTest {\n\n\t@Test\n\tpublic void testJdkDynamicProxy() throws Exception {\n\t\tWorldService worldService = new WorldServiceImpl();\n\n\t\tAdvisedSupport advisedSupport = new AdvisedSupport();\n\t\tTargetSource targetSource = new TargetSource(worldService);\n\t\tWorldServiceInterceptor methodInterceptor = new WorldServiceInterceptor();\n\t\tMethodMatcher methodMatcher = new AspectJExpressionPointcut(\"execution(* org.springframework.test.service.WorldService.explode(..))\").getMethodMatcher();\n\t\tadvisedSupport.setTargetSource(targetSource);\n\t\tadvisedSupport.setMethodInterceptor(methodInterceptor);\n\t\tadvisedSupport.setMethodMatcher(methodMatcher);\n\n\t\tWorldService proxy = (WorldService) new JdkDynamicAopProxy(advisedSupport).getProxy();\n\t\tproxy.explode();\n\t}\n}\n```\n\n## [基于CGLIB的动态代理](#基于CGLIB的动态代理)\n> 代码分支：cglib-dynamic-proxy\n\n基于CGLIB的动态代理实现逻辑也比较简单，查看CglibAopProxy。与基于JDK的动态代理在运行期间为接口生成对象的代理对象不同，基于CGLIB的动态代理能在运行期间动态构建字节码的class文件，为类生成子类，因此被代理类不需要继承自任何接口。\n\n测试：\n```java\npublic class DynamicProxyTest {\n\n\tprivate AdvisedSupport advisedSupport;\n\n\t@Before\n\tpublic void setup() {\n\t\tWorldService worldService = new WorldServiceImpl();\n\n\t\tadvisedSupport = new AdvisedSupport();\n\t\tTargetSource targetSource = new TargetSource(worldService);\n\t\tWorldServiceInterceptor methodInterceptor = new WorldServiceInterceptor();\n\t\tMethodMatcher methodMatcher = new AspectJExpressionPointcut(\"execution(* org.springframework.test.service.WorldService.explode(..))\").getMethodMatcher();\n\t\tadvisedSupport.setTargetSource(targetSource);\n\t\tadvisedSupport.setMethodInterceptor(methodInterceptor);\n\t\tadvisedSupport.setMethodMatcher(methodMatcher);\n\t}\n\n\t@Test\n\tpublic void testCglibDynamicProxy() throws Exception {\n\t\tWorldService proxy = (WorldService) new CglibAopProxy(advisedSupport).getProxy();\n\t\tproxy.explode();\n\t}\n}\n```\n\n## [AOP代理工厂](#AOP代理工厂)\n> 代码分支：proxy-factory\n\n增加AOP代理工厂ProxyFactory，由AdvisedSupport#proxyTargetClass属性决定使用JDK动态代理还是CGLIB动态代理。\n\n测试：\n```java\npublic class DynamicProxyTest {\n\n\tprivate AdvisedSupport advisedSupport;\n\n\t@Before\n\tpublic void setup() {\n\t\tWorldService worldService = new WorldServiceImpl();\n\n\t\tadvisedSupport = new AdvisedSupport();\n\t\tTargetSource targetSource = new TargetSource(worldService);\n\t\tWorldServiceInterceptor methodInterceptor = new WorldServiceInterceptor();\n\t\tMethodMatcher methodMatcher = new AspectJExpressionPointcut(\"execution(* org.springframework.test.service.WorldService.explode(..))\").getMethodMatcher();\n\t\tadvisedSupport.setTargetSource(targetSource);\n\t\tadvisedSupport.setMethodInterceptor(methodInterceptor);\n\t\tadvisedSupport.setMethodMatcher(methodMatcher);\n\t}\n\n\t@Test\n\tpublic void testProxyFactory() throws Exception {\n\t\t// 使用JDK动态代理\n\t\tadvisedSupport.setProxyTargetClass(false);\n\t\tWorldService proxy = (WorldService) new ProxyFactory(advisedSupport).getProxy();\n\t\tproxy.explode();\n\n\t\t// 使用CGLIB动态代理\n\t\tadvisedSupport.setProxyTargetClass(true);\n\t\tproxy = (WorldService) new ProxyFactory(advisedSupport).getProxy();\n\t\tproxy.explode();\n\t}\n}\n```\n\n## [几种常用的Advice：BeforeAdvice/AfterAdvice/AfterReturningAdvice/ThrowsAdvice...](#几种常用的AdviceBeforeAdviceAfterAdviceAfterReturningAdviceThrowsAdvice)\n> 代码分支： common-advice\n\nSpring将AOP联盟中的Advice细化出各种类型的Advice，常用的有BeforeAdvice/AfterAdvice/AfterReturningAdvice/ThrowsAdvice，我们可以通过扩展MethodInterceptor来实现。\n\n只简单实现BeforeAdvice，有兴趣的同学可以帮忙实现另外几种Advice。定义MethodBeforeAdviceInterceptor拦截器，在执行被代理方法之前，先执行BeforeAdvice的方法。\n- [x] BeforeAdvice\n- [ ] AfterAdvice\n- [ ] AfterReturningAdvice\n- [ ] ThrowsAdvice   \n\n测试：\n```java\npublic class WorldServiceBeforeAdvice implements MethodBeforeAdvice {\n\n\t@Override\n\tpublic void before(Method method, Object[] args, Object target) throws Throwable {\n\t\tSystem.out.println(\"BeforeAdvice: do something before the earth explodes\");\n\t}\n}\n```\n\n```java\npublic class DynamicProxyTest {\n\n\tprivate AdvisedSupport advisedSupport;\n\n\t@Before\n\tpublic void setup() {\n\t\tWorldService worldService = new WorldServiceImpl();\n\n\t\tadvisedSupport = new AdvisedSupport();\n\t\tTargetSource targetSource = new TargetSource(worldService);\n\t\tMethodMatcher methodMatcher = new AspectJExpressionPointcut(\"execution(* org.springframework.test.service.WorldService.explode(..))\").getMethodMatcher();\n\t\tadvisedSupport.setTargetSource(targetSource);\n\t\tadvisedSupport.setMethodMatcher(methodMatcher);\n\t}\n\n\t@Test\n\tpublic void testBeforeAdvice() throws Exception {\n\t\t//设置BeforeAdvice\n\t\tWorldServiceBeforeAdvice beforeAdvice = new WorldServiceBeforeAdvice();\n\t\tMethodBeforeAdviceInterceptor methodInterceptor = new MethodBeforeAdviceInterceptor(beforeAdvice);\n\t\tadvisedSupport.setMethodInterceptor(methodInterceptor);\n\n\t\tWorldService proxy = (WorldService) new ProxyFactory(advisedSupport).getProxy();\n\t\tproxy.explode();\n\t}\n}\n```\n\n## [PointcutAdvisor：Pointcut和Advice的组合](#PointcutAdvisorPointcut和Advice的组合)\n> 代码分支：pointcut-advisor\n\nAdvisor是包含一个Pointcut和一个Advice的组合，Pointcut用于捕获JoinPoint，Advice决定在JoinPoint执行某种操作。实现了一个支持aspectj表达式的AspectJExpressionPointcutAdvisor。\n\n测试：\n```java\npublic class DynamicProxyTest {\n\n\t@Test\n\tpublic void testAdvisor() throws Exception {\n\t\tWorldService worldService = new WorldServiceImpl();\n\n\t\t//Advisor是Pointcut和Advice的组合\n\t\tString expression = \"execution(* org.springframework.test.service.WorldService.explode(..))\";\n\t\tAspectJExpressionPointcutAdvisor advisor = new AspectJExpressionPointcutAdvisor();\n\t\tadvisor.setExpression(expression);\n\t\tMethodBeforeAdviceInterceptor methodInterceptor = new MethodBeforeAdviceInterceptor(new WorldServiceBeforeAdvice());\n\t\tadvisor.setAdvice(methodInterceptor);\n\n\t\tClassFilter classFilter = advisor.getPointcut().getClassFilter();\n\t\tif (classFilter.matches(worldService.getClass())) {\n\t\t\tAdvisedSupport advisedSupport = new AdvisedSupport();\n\t\t\tTargetSource targetSource = new TargetSource(worldService);\n\t\t\tadvisedSupport.setTargetSource(targetSource);\n\t\t\tadvisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());\n\t\t\tadvisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());\n//\t\t\tadvisedSupport.setProxyTargetClass(true);   //JDK or CGLIB\n\n\t\t\tWorldService proxy = (WorldService) new ProxyFactory(advisedSupport).getProxy();\n\t\t\tproxy.explode();\n\t\t}\n\t}\n}\n```\n\n## [动态代理融入bean生命周期](#动态代理融入bean生命周期)\n\n> 代码分支：auto-proxy\n\n结合前面讲解的bean的生命周期，BeanPostProcessor处理阶段可以修改和替换bean，正好可以在此阶段返回代理对象替换原对象。不过我们引入一种特殊的BeanPostProcessor——InstantiationAwareBeanPostProcessor，如果InstantiationAwareBeanPostProcessor处理阶段返回代理对象，会导致短路，不会继续走原来的创建bean的流程，具体实现查看AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation。\n\nDefaultAdvisorAutoProxyCreator是处理横切逻辑的织入返回代理对象的InstantiationAwareBeanPostProcessor实现类，当对象实例化时，生成代理对象并返回。\n\n至此，bean的生命周期如下：\n\n![](./assets/auto-proxy.png)\n\n测试：\nauto-proxy.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean id=\"worldService\" class=\"org.springframework.test.service.WorldServiceImpl\"/>\n\n    <bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/>\n\n    <bean id=\"pointcutAdvisor\" class=\"org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor\">\n        <property name=\"expression\" value=\"execution(* org.springframework.test.service.WorldService.explode(..))\"/>\n        <property name=\"advice\" ref=\"methodInterceptor\"/>\n    </bean>\n\n\n    <bean id=\"methodInterceptor\" class=\"org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor\">\n        <property name=\"advice\" ref=\"beforeAdvice\"/>\n    </bean>\n\n    <bean id=\"beforeAdvice\" class=\"org.springframework.test.common.WorldServiceBeforeAdvice\"/>\n\n</beans>\n```\n```java\npublic class AutoProxyTest {\n\n\t@Test\n\tpublic void testAutoProxy() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:auto-proxy.xml\");\n\n\t\t//获取代理对象\n\t\tWorldService worldService = applicationContext.getBean(\"worldService\", WorldService.class);\n\t\tworldService.explode();\n\t}\n}\n```\n\n# [扩展篇](#扩展篇)\n\n## [PropertyPlaceholderConfigurer](#PropertyPlaceholderConfigurer)\n> 代码分支：property-placeholder-configurer\n\n经常需要将配置信息配置在properties文件中，然后在XML文件中以占位符的方式引用。\n\n实现思路很简单，在bean实例化之前，编辑BeanDefinition，解析XML文件中的占位符，然后用properties文件中的配置值替换占位符。而BeanFactoryPostProcessor具有编辑BeanDefinition的能力，因此PropertyPlaceholderConfigurer继承自BeanFactoryPostProcessor。\n\n测试：\ncar.properties\n```properties\nbrand=lamborghini\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean class=\"org.springframework.beans.factory.PropertyPlaceholderConfigurer\">\n        <property name=\"location\" value=\"classpath:car.properties\" />\n    </bean>\n\n    <bean id=\"car\" class=\"org.springframework.test.bean.Car\">\n        <property name=\"brand\" value=\"${brand}\" />\n    </bean>\n\n</beans>\n```\n\n```java\npublic class PropertyPlaceholderConfigurerTest {\n\n\t@Test\n\tpublic void test() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:property-placeholder-configurer.xml\");\n\n\t\tCar car = applicationContext.getBean(\"car\", Car.class);\n\t\tassertThat(car.getBrand()).isEqualTo(\"lamborghini\");\n\t}\n}\n```\n\n## [包扫描](#包扫描)\n> 代码分支：package-scan\n\n结合bean的生命周期，包扫描只不过是扫描特定注解的类，提取类的相关信息组装成BeanDefinition注册到容器中。\n\n在XmlBeanDefinitionReader中解析```<context:component-scan />```标签，扫描类组装BeanDefinition然后注册到容器中的操作在ClassPathBeanDefinitionScanner#doScan中实现。\n\n测试：\n```java\n@Component\npublic class Car {\n\n}\n```\n\npackage-scan.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <context:component-scan base-package=\"org.springframework.test.bean\"/>\n\n</beans>\n```\n\n```java\npublic class PackageScanTest {\n\n\t@Test\n\tpublic void testScanPackage() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:package-scan.xml\");\n\n\t\tCar car = applicationContext.getBean(\"car\", Car.class);\n\t\tassertThat(car).isNotNull();\n\t}\n}\n```\n\n## [@Value注解](#Value注解)\n> 代码分支：value-annotation\n\n注解@Value和@Autowired通过BeanPostProcessor处理。InstantiationAwareBeanPostProcessor增加postProcessPropertyValues方法，在bean实例化之后设置属性之前执行，查看AbstractAutowireCapableBeanFactory#doCreateBean方法。\n\n增加AutowiredAnnotationBeanPostProcessor用于处理注解@Value，@Autowired的处理在下一节实现，在ClassPathBeanDefinitionScanner#doScan将其添加到容器中。查看AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues，其中字符解析器StringValueResolver在PropertyPlaceholderConfigurer中添加到BeanFactory中。\n\n测试：\n```java\n@Component\npublic class Car {\n\n\t@Value(\"${brand}\")\n\tprivate String brand;\n}\n```\n\nvalue-annotation.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean class=\"org.springframework.beans.factory.PropertyPlaceholderConfigurer\">\n        <property name=\"location\" value=\"classpath:car.properties\" />\n    </bean>\n\n    <context:component-scan base-package=\"org.springframework.test.bean\"/>\n\n</beans>\n```\n\ncar.properties\n```properties\nbrand=lamborghini\n```\n\n```java\npublic class ValueAnnotationTest {\n\n\t@Test\n\tpublic void testValueAnnotation() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:value-annotation.xml\");\n\n\t\tCar car = applicationContext.getBean(\"car\", Car.class);\n\t\tassertThat(car.getBrand()).isEqualTo(\"lamborghini\");\n\t}\n}\n```\n\n## [@Autowired注解](#Autowired注解)\n> 代码分支：autowired-annotation\n\n@Autowired注解的处理见AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues\n\n测试：\n```java\n@Component\npublic class Car {\n\n}\n\n@Component\npublic class Person implements InitializingBean, DisposableBean {\n\n\t@Autowired\n\tprivate Car car;\n}\n```\nautowired-annotation.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <context:component-scan base-package=\"org.springframework.test.bean\"/>\n\n</beans>\n```\n\n```java\npublic class AutowiredAnnotationTest {\n\n\t@Test\n\tpublic void testAutowiredAnnotation() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:autowired-annotation.xml\");\n\n\t\tPerson person = applicationContext.getBean(Person.class);\n\t\tassertThat(person.getCar()).isNotNull();\n\t}\n}\n```\n## [bug fix：没有为代理bean设置属性（discovered and fixed by @kerwin89）](#bug-fix没有为代理bean设置属性discovered-and-fixed-by-kerwin89)\n> 代码分支: populate-proxy-bean-with-property-values\n\n问题现象：没有为代理bean设置属性\n\n问题原因：织入逻辑在InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation中执行，而该方法如果返回非null，会导致\"短路\"，不会执行后面的设置属性逻辑。因此如果该方法中返回代理bean后，不会为代理bean设置属性。\n\n修复方案：跟spring保持一致，将织入逻辑迁移到BeanPostProcessor#postProcessAfterInitialization，即将DefaultAdvisorAutoProxyCreator#postProcessBeforeInstantiation的内容迁移到DefaultAdvisorAutoProxyCreator#postProcessAfterInitialization中。\n\n顺便完善spring的扩展机制，为InstantiationAwareBeanPostProcessor增加postProcessAfterInstantiation方法，该方法在bean实例化之后设置属性之前执行。\n\n至此，bean的生命周期比较完整了，如下：\n\n![](./assets/populate-proxy-bean-with-property-values.png)\n\n测试：\npopulate-proxy-bean-with-property-values.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean id=\"worldService\" class=\"org.springframework.test.service.WorldServiceImpl\">\n        <property name=\"name\" value=\"earth\"/>\n    </bean>\n\n    <bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/>\n\n    <bean id=\"pointcutAdvisor\" class=\"org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor\">\n        <property name=\"expression\" value=\"execution(* org.springframework.test.service.WorldService.explode(..))\"/>\n        <property name=\"advice\" ref=\"methodInterceptor\"/>\n    </bean>\n\n\n    <bean id=\"methodInterceptor\" class=\"org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor\">\n        <property name=\"advice\" ref=\"beforeAdvice\"/>\n    </bean>\n\n    <bean id=\"beforeAdvice\" class=\"org.springframework.test.common.WorldServiceBeforeAdvice\"/>\n\n</beans>\n```\n\n```java\npublic class WorldServiceImpl implements WorldService {\n\n\tprivate String name;\n\n\t@Override\n\tpublic void explode() {\n\t\tSystem.out.println(\"The \" + name + \" is going to explode\");\n\t}\n\n\t//setter and getter\n}\n```\n\n```java\npublic class AutoProxyTest {\n\n\t@Test\n\tpublic void testPopulateProxyBeanWithPropertyValues() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:populate-proxy-bean-with-property-values.xml\");\n\n\t\t//获取代理对象\n\t\tWorldService worldService = applicationContext.getBean(\"worldService\", WorldService.class);\n\t\tworldService.explode();\n\t\tassertThat(worldService.getName()).isEqualTo(\"earth\");\n\t}\n}\n```\n\n## [类型转换（一）](#类型转换一)\n> 代码分支：type-conversion-first-part\n\nspring在org.springframework.core.convert.converter包中定义了三种类型转换器接口：Converter、ConverterFactory、GenericConverter。\n\n### 一、Converter\n```java\npublic interface Converter<S, T> {\n\n\t/**\n\t * 类型转换\n\t */\n\tT convert(S source);\n}\n```\nConverter能将S类型的对象转换为T类型的对象，比如将String类型的对象转换为Integer类型的对象的实现类：\n```java\npublic class StringToIntegerConverter implements Converter<String, Integer> {\n\t@Override\n\tpublic Integer convert(String source) {\n\t\treturn Integer.valueOf(source);\n\t}\n}\n```\n使用：\n```java\nInteger num = new StringToIntegerConverter().convert(\"8888\");\n```\n\n### 二、ConverterFactory\n```java\npublic interface ConverterFactory<S, R> {\n\n\t<T extends R> Converter<S, T> getConverter(Class<T> targetType);\n}\n```\nConverter<S,T>接口适合一对一的类型转换，如果要将String类型转换为Ineger/Long/Float/Double/Decimal等类型，就要实现一系列的StringToInteger/StringToLongConverter/StringToFloatConverter转换器，非常不优雅。\n\nConverterFactory接口则适合一对多的类型转换，可以将一种类型转换为另一种类型及其子类。比如将String类型转换为Ineger/Long/Float/Double/Decimal等Number类型时，只需定义一个ConverterFactory转换器：\n```java\npublic class StringToNumberConverterFactory implements ConverterFactory<String, Number> {\n\n\t@Override\n\tpublic <T extends Number> Converter<String, T> getConverter(Class<T> targetType) {\n\t\treturn new StringToNumber<T>(targetType);\n\t}\n\n\tprivate static final class StringToNumber<T extends Number> implements Converter<String, T> {\n\n\t\tprivate final Class<T> targetType;\n\n\t\tpublic StringToNumber(Class<T> targetType) {\n\t\t\tthis.targetType = targetType;\n\t\t}\n\n\t\t@Override\n\t\tpublic T convert(String source) {\n\t\t\tif (source.length() == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (targetType.equals(Integer.class)) {\n\t\t\t\treturn (T) Integer.valueOf(source);\n\t\t\t} else if (targetType.equals(Long.class)) {\n\t\t\t\treturn (T) Long.valueOf(source);\n\t\t\t}\n\t\t\t//TODO 其他数字类型\n\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot convert String [\" + source + \"] to target class [\" + targetType.getName() + \"]\");\n\t\t\t}\n\t\t}\n\t}\n\n}\n```\n使用：\n```java\nStringToNumberConverterFactory converterFactory = new StringToNumberConverterFactory();\nConverter<String, Integer> stringToIntegerConverter = converterFactory.getConverter(Integer.class);\nInteger num = stringToIntegerConverter.convert(\"8888\");\n```\n\n### 三、GenericConverter\n```java\npublic interface GenericConverter {\n\n\tSet<ConvertiblePair> getConvertibleTypes();\n\n\tObject convert(Object source, Class sourceType, Class targetType);\n}\n```\nString类型转换为Boolean类型的实现类：\n```java\npublic class StringToBooleanConverter implements GenericConverter {\n\t@Override\n\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\treturn Collections.singleton(new ConvertiblePair(String.class, Boolean.class));\n\t}\n\n\t@Override\n\tpublic Object convert(Object source, Class sourceType, Class targetType) {\n\t\treturn Boolean.valueOf((String) source);\n\t}\n}\n```\n使用:\n```java\nBoolean flag = new StringToBooleanConverter().convert(\"true\", String.class, Boolean.class);\n```\n\nConversionService是类型转换体系的核心接口，将以上三种类型转换器整合到一起，GenericConversionService是其实现类，DefaultConversionService在GenericConversionService的基础上添加内置转换器。\n\n测试见TypeConversionFirstPartTest。\n\n## [类型转换（二）](#类型转换二)\n> 代码分支：type-conversion-second-part\n\n上一节实现了spring中的类型转换体系，本节将类型转换的能力整合到容器中。\n\n为了方便使用，提供了创建ConversionService的FactoryBean——ConversionServiceFactoryBean。\n\n如果有定义ConversionService，在AbstractApplicationContext#finishBeanFactoryInitialization方法中设置到容器中。\n\n类型转换的时机有两个：\n\n- 为bean填充属性时，见AbstractAutowireCapableBeanFactory#applyPropertyValues \n- 处理@Value注解时，见AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues\n\n你可能会有疑问，如果没有定义ConversionService，是怎么进行基本类型的转换的？其实spring为了向下兼容保留了一套比较旧的类型转换机制，没有定义ConversionService时会使用其进行基本类型的转换工作，不必关注旧的类型转换机制。\n\n测试：\n```java\npublic class Car {\n\n\tprivate int price;\n\n\tprivate LocalDate produceDate;\n}\n```\n\n```java\npublic class StringToLocalDateConverter implements Converter<String, LocalDate> {\n\n\tprivate final DateTimeFormatter DATE_TIME_FORMATTER;\n\n\tpublic StringToLocalDateConverter(String pattern) {\n\t\tDATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(pattern);\n\t}\n\n\t@Override\n\tpublic LocalDate convert(String source) {\n\t\treturn LocalDate.parse(source, DATE_TIME_FORMATTER);\n\t}\n}\n```\n\ntype-conversion-second-part.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean id=\"car\" class=\"org.springframework.test.bean.Car\">\n        <property name=\"price\" value=\"1000000\"/>\n        <property name=\"produceDate\" value=\"2021-01-01\"/>\n    </bean>\n\n    <bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n        <property name=\"converters\" ref=\"converters\"/>\n    </bean>\n\n    <bean id=\"converters\" class=\"org.springframework.test.common.ConvertersFactoryBean\"/>\n\n</beans>\n```\n\n```java\npublic class TypeConversionSecondPartTest {\n\n\t@Test\n\tpublic void testConversionService() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:type-conversion-second-part.xml\");\n\n\t\tCar car = applicationContext.getBean(\"car\", Car.class);\n\t\tassertThat(car.getPrice()).isEqualTo(1000000);\n\t\tassertThat(car.getProduceDate()).isEqualTo(LocalDate.of(2021, 1, 1));\n\t}\n}\n```\n\n# [高级篇](#高级篇)\n\n## [解决循环依赖问题（一）：没有代理对象](#解决循环依赖问题一没有代理对象)\n> 代码分支：circular-reference-without-proxy-bean\n\n虽然放在高级篇，其实解决循环依赖问题的方法非常简单。\n\n先理解spring中为什么会有循环依赖的问题。比如如下的代码\n\n```java\npublic class A {\n\n\tprivate B b;\n\n\t//getter and setter\n}\n```\n\n```java\npublic class B {\n\n\tprivate A a;\n\n\t//getter and setter\n}\n```\n\n```xml\n<beans>\n    <bean id=\"a\" class=\"org.springframework.test.bean.A\">\n        <property name=\"b\" ref=\"b\"/>\n    </bean>\n    <bean id=\"b\" class=\"org.springframework.test.bean.B\">\n        <property name=\"a\" ref=\"a\"/>\n    </bean>\n</beans>\n```\n\nA依赖B，B又依赖A，循环依赖。容器加载时会执行依赖流程：\n\n- 实例化A，发现依赖B，然后实例化B\n- 实例化B，发现依赖A，然后实例化A\n- 实例化A，发现依赖B，然后实例化B\n- ...\n\n死循环直至栈溢出。\n\n解决该问题的关键在于何时将实例化后的bean放进容器中，设置属性前还是设置属性后。现有的执行流程，bean实例化后并且设置属性后会被放进singletonObjects单例缓存中。如果我们调整一下顺序，当bean实例化后就放进singletonObjects单例缓存中，提前暴露引用，然后再设置属性，就能解决上面的循环依赖问题，执行流程变为：\n\n- 步骤一：getBean(a)，检查singletonObjects是否包含a，singletonObjects不包含a，实例化A放进singletonObjects，设置属性b，发现依赖B，尝试getBean(b)\n- 步骤二：getBean(b)，检查singletonObjects是否包含b，singletonObjects不包含b，实例化B放进singletonObjects，设置属性a，发现依赖A，尝试getBean(a)\n- 步骤三：getBean(a)，检查singletonObjects是否包含a，singletonObjects包含a，返回a\n- 步骤四：步骤二中的b拿到a，设置属性a，然后返回b\n- 步骤五：步骤一中的a拿到b，设置属性b，然后返回a\n\n可见调整bean放进singletonObjects（人称一级缓存）的时机到bean实例化后即可解决循环依赖问题。但为了和spring保持一致，我们增加一个二级缓存earlySingletonObjects，在bean实例化后将bean放进earlySingletonObjects中（见AbstractAutowireCapableBeanFactory#doCreateBean方法第6行），getBean()时检查一级缓存singletonObjects和二级缓存earlySingletonObjects中是否包含该bean，包含则直接返回（见AbstractBeanFactory#getBean第1行）。\n\n单测见CircularReferenceWithoutProxyBeanTest#testCircularReference。\n\n增加二级缓存，不能解决有代理对象时的循环依赖。原因是放进二级缓存earlySingletonObjects中的bean是实例化后的bean，而放进一级缓存singletonObjects中的bean是代理对象（代理对象在BeanPostProcessor#postProcessAfterInitialization中返回），两个缓存中的bean不一致。比如上面的例子，如果A被代理，那么B拿到的a是实例化后的A，而a是被代理后的对象，即b.getA() != a，见单测CircularReferenceWithProxyBeanTest。\n\n下一节填坑。\n\n## [解决循环依赖问题（二）：有代理对象](#解决循环依赖问题二有代理对象)\n> 代码分支：circular-reference-with-proxy-bean\n\n解决有代理对象时的循环依赖问题，需要提前暴露代理对象的引用，而不是暴露实例化后的bean的引用（这是上节的遗留问题的原因，应该提前暴露A的代理对象的引用）。\n\nspring中用singletonFactories（一般称第三级缓存）解决有代理对象时的循环依赖问题。在实例化后提前暴露代理对象的引用（见AbstractAutowireCapableBeanFactory#doCreateBean方法第6行）。\n\ngetBean()时依次检查一级缓存singletonObjects、二级缓存earlySingletonObjects和三级缓存singletonFactories中是否包含该bean。如果三级缓存中包含该bean，则挪至二级缓存中，然后直接返回该bean。见AbstractBeanFactory#getBean方法第1行。\n\n最后将代理bean放进一级缓存singletonObjects，见AbstractAutowireCapableBeanFactory第104行。\n\n单测见CircularReferenceWithProxyBeanTest。\n\n## [支持懒加载和多切面增强(By @zqczgl)](#支持懒加载和多切面增强by-zqczgl)\n\n### [懒加载](#懒加载)\n\n> 代码分支:  lazy-init-and-multi-advice\n\n事实上，并不是所有的bean在初始化容器的时候都会创建。随着项目规模的不断扩大，bean的数目也越来越多。如果每次启动容器都需要加载大量的bean，这无疑会带来大量的资源浪费。所有spring提供了懒加载机制，我们可以将我们认为暂时用不到的bean设为懒加载，这样只有在我们需要这个bean的时候这个bean才会被创建。\n\n测试\n\nlazy-test.xml\n\n```java\n//只有当bean是单例且不为懒加载才会被创建\t\npublic void preInstantiateSingletons() throws BeansException {\n\t\tbeanDefinitionMap.forEach((beanName, beanDefinition) -> {\n\t\t\tif(beanDefinition.isSingleton()&&!beanDefinition.isLazyInit()){\n\t\t\t\tgetBean(beanName);\n\t\t\t}\n\t\t});\n\t}\n```\n\n```java\npublic class LazyInitTest {\n    @Test\n    public void testLazyInit() throws InterruptedException {\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:lazy-test.xml\");\n        System.out.println(System.currentTimeMillis()+\":applicationContext-over\");\n        TimeUnit.SECONDS.sleep(1);\n        Car c= (Car) applicationContext.getBean(\"car\");\n        c.showTime();//显示bean的创建时间\n    }\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"car\" class=\"org.springframework.test.bean.Car\" lazyInit=\"true\" init-method=\"init\">\n        <property name=\"brand\" value=\"porsche\"/>\n    </bean>\n</beans>\n\n```\n\n关闭懒加载的输出:\n\n```\n1671698959957:applicationContext-over\n1671698959951:bean create\n```\n\n开启懒加载：\n\n```\n1671699030293:applicationContext-over\n1671699031328:bean create\n```\n\n可以清楚的看到开启和不开启懒加载bean的创建时机的差异\n\n### [多个切面匹配同一方法](#多个切面匹配同一方法)\n\n> 代码分支:  lazy-init-and-multi-advice\n\n虽然在前面我们完成了对方法的增强，但并不完美。我们的目前的代码只能支持对方法的单个增强。作为spring的核心功能如果不支持多切面的话有点太别扭了。spring利用了拦截器链来完成了对多个切面的支持。\n\n#### [ProxyFactory](#ProxyFactory)\n\n让我们从ProxyFactory开始，来看一下代理对象的整个创建流程。至于为什么从ProxyFactory开，这是因为代理对象最终是用ProxyFactory的getProxy()函数来获得的。\n\n```java\npublic class ProxyFactory extends AdvisedSupport{\n\n\n\tpublic ProxyFactory() {\n\t}\n\n\tpublic Object getProxy() {\n\t\treturn createAopProxy().getProxy();\n\t}\n\n\tprivate AopProxy createAopProxy() {\n\t\tif (this.isProxyTargetClass()||this.getTargetSource().getTargetClass().length==0) {\n\t\t\treturn new CglibAopProxy(this);\n\t\t}\n\t\treturn new JdkDynamicAopProxy(this);\n\t}\n}\n```\n\n为了更贴合spring的实现，这里更改了ProxyFactory使其继承了AdvisedSupport，正如spring源码中做的那样。\n\n#### [基于JDK动态代理](#基于JDK动态代理)\n\nProxyFactory只是简单的做了下选择，当我们设置proxyTargetClass属性或者被代理对象没有接口时会调用cjlib动态代理，否则调用jdk动态代理。二者实现并没有太大区别，这里只贴出jdk动态代理的实现。\n\n```java\n\tpublic Object getProxy() {\n\t\treturn Proxy.newProxyInstance(getClass().getClassLoader(), advised.getTargetSource().getTargetClass(), this);\n\t}\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t// 获取目标对象\n\t\tObject target=advised.getTargetSource().getTarget();\n\t\tClass<?> targetClass = target.getClass();\n\t\tObject retVal = null;\n\t\t// 获取拦截器链\n\t\tList<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\t\tif(chain==null||chain.isEmpty()){\n\t\t\treturn method.invoke(target, args);\n\t\t}else{\n\t\t\t// 将拦截器统一封装成ReflectiveMethodInvocation\n\t\t\tMethodInvocation invocation =\n\t\t\t\t\tnew ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n\t\t\t// Proceed to the joinpoint through the interceptor chain.\n\t\t\t// 执行拦截器链\n\t\t\tretVal = invocation.proceed();\n\t\t}\n\t\treturn retVal;\n\t}\n```\n\njdk动态代理可以分为获取拦截器链，将拦截器统一封装成ReflectiveMethodInvocation，执行拦截器链三部分。我们来逐一看一下这三部分。\n\n##### [1.获取拦截器链](#1.获取拦截器链)\n\n首先将获取到所有与当前method匹配的advice(增强)，跟踪getInterceptorsAndDynamicInterceptionAdvice代码，我们发现Spring AOP也使用缓存进行提高性能，如果该方法已经获取过拦截器，则直接取缓存，否则通过advisorChainFactory获取拦截器链。AdvisorChainFactory是用来获得拦截器链接口。它的一个实现类为DefaultAdvisorChainFactory\n\nAdvisedSupport#getInterceptorsAndDynamicInterceptionAdvice：\n\n```java\n\tpublic List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, Class<?> targetClass) {\n\t\tInteger cacheKey=method.hashCode();\n\t\tList<Object> cached = this.methodCache.get(cacheKey);\n\t\tif (cached == null) {\n\t\t\tcached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\t\t\tthis, method, targetClass);\n\t\t\tthis.methodCache.put(cacheKey, cached);\n\t\t}\n\t\treturn cached;\n\t}\n```\n\n整体代码并不复杂，首先获取所有Advisor(切面)，通过pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)校验当前代理对象是否匹配该Advisor，再通过pointcutAdvisor.getPointcut().getMethodMatcher()校验是否匹配当前调用method。如果通过校验，则提取advisor中的interceptors增强，添加到interceptorList中。这里可能有读者会疑惑，我们明明是要获取MethodInterceptor，可AdvisedSupport的getAdvice()返回的是Advice(增强),其实如果我们点开MethodInterceptor的源码，我们会发现MethodInterceptor继承了Interceptor接口，而Interceptor又继承了Advice接口。因为这里的Advice和MethodInterceptor我们都是用的AOP联盟的接口，所以特此说明一下。\n\nDefultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice\n\n```java\npublic List<Object> getInterceptorsAndDynamicInterceptionAdvice(AdvisedSupport config, Method method, Class<?> targetClass) {\n        Advisor[] advisors = config.getAdvisors().toArray(new Advisor[0]);\n        List<Object> interceptorList = new ArrayList<>(advisors.length);\n        Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());\n        for (Advisor advisor : advisors) {\n            if (advisor instanceof PointcutAdvisor) {\n                // Add it conditionally.\n                PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;\n                // 校验当前Advisor是否适用于当前对象\n                if (pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {\n                    MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();\n                    boolean match;\n                    // 校验Advisor是否应用到当前方法上\n                    match = mm.matches(method,actualClass);\n                    if (match) {\n                        MethodInterceptor interceptor = (MethodInterceptor) advisor.getAdvice();\n                            interceptorList.add(interceptor);\n                    }\n                }\n            }\n        }\n        return interceptorList;\n    }\n```\n\n##### [2.将拦截器封装成ReflectiveMethodInvocation](#2.将拦截器封装成ReflectiveMethodInvocation)\n\n这里也是重写了ReflectiveMethodInvocation的实现，来支持多切面。\n\n```java\n\tpublic ReflectiveMethodInvocation(Object proxy,Object target, Method method, Object[] arguments,Class<?> targetClass,List<Object> chain) {\n\t\tthis.proxy=proxy;\n\t\tthis.target = target;\n\t\tthis.method = method;\n\t\tthis.arguments = arguments;\n\t\tthis.targetClass=targetClass;\n\t\tthis.interceptorsAndDynamicMethodMatchers=chain;\n\t}\n```\n\n\n\n##### [3.执行拦截器链](#3.执行拦截器链)\n\nspring能够保证多个切面同时匹配同一方法的而不出现乱序的关键就在下面一段代码了。\n\nReflectiveMethodInvocation#proceed()\n\n```java\n\tpublic Object proceed() throws Throwable {\n\t\t// 初始currentInterceptorIndex为-1，每调用一次proceed就把currentInterceptorIndex+1\n\t\tif (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n\t\t\t// 当调用次数 = 拦截器个数时\n\t\t\t// 触发当前method方法\n\t\t\treturn method.invoke(this.target, this.arguments);\n\t\t}\n\n\t\tObject interceptorOrInterceptionAdvice =\n\t\t\t\tthis.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n\t\t// 普通拦截器，直接触发拦截器invoke方法\n\t\treturn ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n\t}\n```\n\n我们看到，MethodInvocation只是简单的将拦截器链的所有拦截器一一执行，最后再触发当前的method方法。这是很简单高效的方法，但问题是我们希望某些增强比如AfterReturningAdvice能够在方法执行完才被执行，这就涉及到不同增强的执行顺序的问题了。而MethodInvocation显然没有考虑顺序的问题，一个AfterReturningAdvice很可能在BeforeAdvice之前被调用。那么该如何保证顺序问题呢？\n\n答案是，控制增强的调用顺序其实由每个拦截器负责，所以我们需要分析`MethodBeforeAdviceInterceptor`和`AfterReturningAdviceInterceptor`\n\n```java\npublic class MethodBeforeAdviceInterceptor implements MethodInterceptor, BeforeAdvice {\n\n\tprivate MethodBeforeAdvice advice;\n\n\tpublic MethodBeforeAdviceInterceptor() {\n\t}\n\n\tpublic MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {\n\t\tthis.advice = advice;\n\t}\n\n\tpublic void setAdvice(MethodBeforeAdvice advice) {\n\t\tthis.advice = advice;\n\t}\n\n\t@Override\n\tpublic Object invoke(MethodInvocation mi) throws Throwable {\n\t\tthis.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());\n\t\treturn mi.proceed();\n\t}\n}\n```\n\n```java\npackage org.springframework.aop.framework.adapter;\n\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.springframework.aop.AfterAdvice;\nimport org.springframework.aop.AfterReturningAdvice;\n\n/**\n * @author zqc\n * @date 2022/12/20\n */\npublic class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice {\n\n    private  AfterReturningAdvice advice;\n\n    public AfterReturningAdviceInterceptor() {\n    }\n\n    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) {\n        this.advice = advice;\n    }\n\n\n    @Override\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        Object retVal = mi.proceed();\n        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());\n        return retVal;\n    }\n}\n\n```\n\n看了源码大家应该就清楚了，拦截器链执行的顺序正时在各个拦截器的`invoke`方法中实现的。`before`会先执行`advice`增强方法再链式调用，这个比较好理解而`after`则是先执行链式调用，再调用`advice`增强方法，也就是一个递归的过程。和二叉树的遍历有些异曲同工之处。\t\n\n![](./assets/chainProceed.png)\n\n#### [测试](#测试)\n\n！！！！！！！注意，使用过高版本的java可以因为java版本和cjlib冲突导致报错。建议使用java8进行测试\n\n```java\npublic class WorldServiceImpl implements WorldService {\n\n\tprivate String name;\n\n\t@Override\n\tpublic void explode() {\n\t\tSystem.out.println(\"The \" + name + \" is going to explode\");\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n```\n\n前置增强：\n\n```java\npublic class WorldServiceBeforeAdvice implements MethodBeforeAdvice {\n\n\t@Override\n\tpublic void before(Method method, Object[] args, Object target) throws Throwable {\n\t\tSystem.out.println(\"BeforeAdvice: do something before the earth explodes\");\n\t}\n}\n```\n\n后置返回增强：\n\n```java\npublic class WorldServiceAfterReturnAdvice implements AfterReturningAdvice {\n    @Override\n    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\n        System.out.println(\"AfterAdvice: do something after the earth explodes\");\n    }\n}\n```\n\n测试代码：\n\n```java\npublic class ProxyFactoryTest {\n    @Test\n    public void testAdvisor() throws Exception {\n        WorldService worldService = new WorldServiceImpl();\n\n        //Advisor是Pointcut和Advice的组合\n        String expression = \"execution(* org.springframework.test.service.WorldService.explode(..))\";\n        //第一个切面\n        AspectJExpressionPointcutAdvisor advisor = new AspectJExpressionPointcutAdvisor();\n        advisor.setExpression(expression);\n        MethodBeforeAdviceInterceptor methodInterceptor = new MethodBeforeAdviceInterceptor(new WorldServiceBeforeAdvice());\n        advisor.setAdvice(methodInterceptor);\n        //第二个切面\n        AspectJExpressionPointcutAdvisor advisor1=new AspectJExpressionPointcutAdvisor();\n        advisor1.setExpression(expression);\n        AfterReturningAdviceInterceptor afterReturningAdviceInterceptor=new AfterReturningAdviceInterceptor(new WorldServiceAfterReturnAdvice());\n        advisor1.setAdvice(afterReturningAdviceInterceptor);\n        //通过ProxyFactory来获得代理\n        ProxyFactory factory = new ProxyFactory();\n        TargetSource targetSource = new TargetSource(worldService);\n        factory.setTargetSource(targetSource);\n        factory.setProxyTargetClass(true);\n        factory.addAdvisor(advisor);\n        factory.addAdvisor(advisor1);\n        WorldService proxy = (WorldService) factory.getProxy();\n        proxy.explode();\n    }\n}\n```\n\n输出：\n\n```\nBeforeAdvice: do something before the earth explodes\nThe null is going to explode\nAfterAdvice: do something after the earth explodes\n\n进程已结束，退出代码为 0\n```\n\n#### [多切面动态代理融入bean生命周期](#多切面动态代理融入bean生命周期)\n\n```java\n\tpublic void testAutoProxy() throws Exception {\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:auto-proxy.xml\");\n\n\t\t//获取代理对象\n\t\tWorldService worldService = applicationContext.getBean(\"worldService\", WorldService.class);\n\t\tworldService.explode();\n\t}\n```\n\nauto-proxy.xml：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t         http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t http://www.springframework.org/schema/context\n\t\t http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n    <bean id=\"worldService\" class=\"org.springframework.test.service.WorldServiceImpl\"/>\n\n    <bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/>\n\n    <bean id=\"pointcutAdvisor\" class=\"org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor\">\n        <property name=\"expression\" value=\"execution(* org.springframework.test.service.WorldService.explode(..))\"/>\n        <property name=\"advice\" ref=\"methodInterceptor\"/>\n    </bean>\n    <bean id=\"pointcutAdvisor2\" class=\"org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor\">\n        <property name=\"expression\" value=\"execution(* org.springframework.test.service.WorldService.explode(..))\"/>\n        <property name=\"advice\" ref=\"methodInterceptor2\"/>\n    </bean>\n\n    <bean id=\"methodInterceptor\" class=\"org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor\">\n        <property name=\"advice\" ref=\"beforeAdvice\"/>\n    </bean>\n    <bean id=\"methodInterceptor2\" class=\"org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor\">\n        <property name=\"advice\" ref=\"afterAdvice\"/>\n    </bean>\n    <bean id=\"afterAdvice\" class=\"org.springframework.test.common.WorldServiceAfterReturnAdvice\"/>\n    <bean id=\"beforeAdvice\" class=\"org.springframework.test.common.WorldServiceBeforeAdvice\"/>\n\n</beans>\n\n```\n\n输出：\n\n```\nBeforeAdvice: do something before the earth explodes\nThe null is going to explode\nAfterAdvice: do something after the earth explodes\n\n进程已结束，退出代码为 0\n```\n\n至此，我们已经解决多切面匹配同一方法的问题。\n"
        },
        {
          "name": "pom.xml",
          "type": "blob",
          "size": 2.1357421875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.springframework</groupId>\n    <artifactId>mini-spring</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <name>mini-spring</name>\n\n    <url>https://github.com/DerekYRC/mini-spring</url>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>cglib</groupId>\n            <artifactId>cglib-nodep</artifactId>\n            <version>3.3.0</version>\n        </dependency>\n\n        <dependency>\n            <groupId>aopalliance</groupId>\n            <artifactId>aopalliance</artifactId>\n            <version>1.0</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.0</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.dom4j</groupId>\n            <artifactId>dom4j</artifactId>\n            <version>2.1.3</version>\n        </dependency>\n\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>5.5.0</version>\n        </dependency>\n\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.11</version>\n            <scope>test</scope>\n        </dependency>\n\n        <dependency>\n            <groupId>org.assertj</groupId>\n            <artifactId>assertj-core</artifactId>\n            <version>3.11.1</version>\n            <scope>test</scope>\n        </dependency>\n\n        <dependency>\n            <groupId>cglib</groupId>\n            <artifactId>cglib</artifactId>\n            <version>3.3.0</version>\n        </dependency>\n\n    </dependencies>\n</project>\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}