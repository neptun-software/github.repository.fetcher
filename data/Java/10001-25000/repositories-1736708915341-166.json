{
  "metadata": {
    "timestamp": 1736708915341,
    "page": 166,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jwtk/jjwt",
      "stars": 10436,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2431640625,
          "content": ".DS_Store\n\n# Mobile Tools for Java (J2ME)\n.mtj.tmp/\n\n# Package Files #\n*.jar\n*.war\n*.ear\n\n# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml\nhs_err_pid*\n\ntarget/\n.idea\n*.iml\n*.iws\n\n.classpath\n.project\n.settings\n"
        },
        {
          "name": ".mvn",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 52.333984375,
          "content": "## Release Notes\n\n### 0.12.6\n\nThis patch release:\n\n* Ensures that after successful JWS signature verification, an application-configured Base64Url `Decoder` output is\n  used to construct a `Jws` instance (instead of JJWT's default decoder). See\n  [Issue 947](https://github.com/jwtk/jjwt/issues/947).\n* Fixes a decompression memory leak in concurrent/multi-threaded environments introduced in 0.12.0 when decompressing JWTs with a `zip` header of `GZIP`. See [Issue 949](https://github.com/jwtk/jjwt/issues/949).\n* Upgrades BouncyCastle to 1.78 via [PR 941](https://github.com/jwtk/jjwt/pull/941).\n\n### 0.12.5\n\nThis patch release:\n\n* Ensures that builders' `NestedCollection` changes are applied to the collection immediately as mutation methods are called, no longer\n  requiring application developers to call `.and()` to 'commit' or apply a change.  For example, prior to this release,\n  the following code did not apply changes:\n  ```java\n  JwtBuilder builder = Jwts.builder();\n  builder.audience().add(\"an-audience\"); // no .and() call\n  builder.compact(); // would not keep 'an-audience'\n  ```\n  Now this code works as expected and all other `NestedCollection` instances like it apply changes immediately (e.g. when calling\n  `.add(value)`).\n  \n  However, standard fluent builder chains are still recommended for readability when feasible, e.g.\n  \n  ```java\n  Jwts.builder()\n      .audience().add(\"an-audience\").and() // allows fluent chaining\n      .subject(\"Joe\")\n      // etc...\n      .compact()\n  ```\n  See [Issue 916](https://github.com/jwtk/jjwt/issues/916).\n\n### 0.12.4\n\nThis patch release includes various changes listed below.\n\n#### Jackson Default Parsing Behavior\n\nThis release makes two behavioral changes to JJWT's default Jackson `ObjectMapper` parsing settings:\n\n1. In the interest of having stronger standards to reject potentially malformed/malicious/accidental JSON that could\n   have undesirable effects on an application, JJWT's default `ObjectMapper `is now configured to explicitly reject/fail \n   parsing JSON (JWT headers and/or Claims) if/when that JSON contains duplicate JSON member names. \n   \n   For example, now the following JSON, if parsed, would fail (be rejected) by default:\n   ```json\n   {\n     \"hello\": \"world\",\n     \"thisWillFail\": 42,\n     \"thisWillFail\": \"test\"\n   }\n    ```\n   \n   Technically, the JWT RFCs _do allow_ duplicate named fields as long as the last parsed member is the one used\n   (see [JWS RFC 7515, Section 4](https://datatracker.ietf.org/doc/html/rfc7515#section-4)), so this is allowed.\n   However, because JWTs often reflect security concepts, it's usually better to be defensive and reject these \n   unexpected scenarios by default. The RFC later supports this position/preference in \n   [Section 10.12](https://datatracker.ietf.org/doc/html/rfc7515#section-10.12):\n       \n       Ambiguous and potentially exploitable situations\n       could arise if the JSON parser used does not enforce the uniqueness\n       of member names or returns an unpredictable value for duplicate\n       member names.\n       \n   Finally, this is just a default, and the RFC does indeed allow duplicate member names if the last value is used,\n   so applications that require duplicates to be allowed can simply configure their own `ObjectMapper` and use\n   that with JJWT instead of assuming this (new) JJWT default. See \n   [Issue #877](https://github.com/jwtk/jjwt/issues/877) for more.\n2. If using JJWT's support to use Jackson to parse \n   [Custom Claim Types](https://github.com/jwtk/jjwt#json-jackson-custom-types) (for example, a Claim that should be\n   unmarshalled into a POJO), and the JSON for that POJO contained a member that is not represented in the specified\n   class, Jackson would fail parsing by default.  Because POJOs and JSON data models can sometimes be out of sync\n   due to different class versions, the default behavior has been changed to ignore these unknown JSON members instead \n   of failing (i.e. the `ObjectMapper`'s  `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` is now set to `false`)\n   by default.\n   \n   Again, if you prefer the stricter behavior of rejecting JSON with extra or unknown properties, you can configure\n   `true` on your own `ObjectMapper` instance and use that instance with the `Jwts.parser()` builder.\n\n#### Additional Changes\n\nThis release also:\n\n* Fixes a thread-safety issue when using `java.util.ServiceLoader` to dynamically lookup/instantiate pluggable \n  implementations of JJWT interfaces (e.g. JSON parsers, etc).  See \n  [Issue #873](https://github.com/jwtk/jjwt/issues/873) and its documented fix in \n  [PR #893](https://github.com/jwtk/jjwt/pull/892).\n* Ensures Android environments and older `org.json` library usages can parse JSON from a `JwtBuilder`-provided\n  `java.io.Reader` instance. [Issue 882](https://github.com/jwtk/jjwt/issues/882).\n* Ensures a single string `aud` (Audience) claim is retained (without converting it to a `Set`) when copying/applying a \n  source Claims instance to a destination Claims builder. [Issue 890](https://github.com/jwtk/jjwt/issues/890).\n* Ensures P-256, P-384 and P-521 Elliptic Curve JWKs zero-pad their field element (`x`, `y`, and `d`) byte array values\n  if necessary before Base64Url-encoding per [RFC 7518](https://datatracker.ietf.org/doc/html/rfc7518), Sections \n  [6.2.1.2](https://datatracker.ietf.org/doc/html/rfc7518#section-6.2.1.2), \n  [6.2.1.3](https://datatracker.ietf.org/doc/html/rfc7518#section-6.2.1.3), and\n  [6.2.2.1](https://datatracker.ietf.org/doc/html/rfc7518#section-6.2.2.1), respectively. \n  [Issue 901](https://github.com/jwtk/jjwt/issues/901).\n* Ensures that Secret JWKs for HMAC-SHA algorithms with `k` sizes larger than the algorithm minimum can\n  be parsed/used as expected. See [Issue #905](https://github.com/jwtk/jjwt/issues/905) \n* Ensures there is an upper bound (maximum) iterations enforced for PBES2 decryption to help mitigate potential DoS \n  attacks. Many thanks to Jingcheng Yang and Jianjun Chen from Sichuan University and Zhongguancun Lab for their \n  work on this. See [PR 911](https://github.com/jwtk/jjwt/pull/911).\n* Fixes various typos in documentation and JavaDoc. Thanks to those contributing pull requests for these!\n\n### 0.12.3\n\nThis patch release:\n\n* Upgrades the `org.json` dependency to `20231013` to address that library's\n  [CVE-2023-5072](https://nvd.nist.gov/vuln/detail/CVE-2023-5072) vulnerability.\n* (Re-)enables empty values for custom claims, which was the behavior in <= 0.11.5. \n  [Issue 858](https://github.com/jwtk/jjwt/issues/858).\n\n### 0.12.2\n\nThis is a follow-up release to finalize the work in 0.12.1 that tried to fix a reflection scope problem\non >= JDK 17.  The 0.12.1 fix worked, but only if the importing project or application did _not_ have its own\n`module-info.java` file.\n\nThis release removes that reflection code entirely in favor of a JJWT-native implementation, eliminating JPMS \nmodule (scope) problems on >= JDK 17. As such, `--add-opens` flags are no longer required to use JJWT.\n\nThe fix has been tested up through JDK 21 in a separate application environment (out of JJWT's codebase) to assert\nexpected functionality in a 'clean room' environment in a project both with and without `module-info.java` usage.\n\n### 0.12.1\n\nEnabled reflective access on JDK 17+ to `java.io.ByteArrayInputStream` and `sun.security.util.KeyUtil` for\n`jjwt-impl.jar`\n\n### 0.12.0\n\nThis is a big release! JJWT now fully supports Encrypted JSON Web Tokens (JWE), JSON Web Keys (JWK) and more!  See the \nsections below enumerating all new features as well as important notes on breaking changes or backwards-incompatible \nchanges made in preparation for the upcoming 1.0 release.\n\n**Because breaking changes are being introduced, it is strongly recommended to wait until the upcoming 1.0 release\nwhere you can address breaking changes one time only**.\n\nThose that need immediate JWE encryption and JWK key support\nhowever will likely want to upgrade now and deal with the smaller subset of breaking changes in the 1.0 release.\n\n#### Simplified Starter Jar\n\nThose upgrading to new modular JJWT versions from old single-jar versions will transparently obtain everything \nthey need in their Maven, Gradle or Android projects.\n\nJJWT's early releases had one and only one .jar: `jjwt.jar`.  Later releases moved to a modular design with 'api' and\n'impl' jars including 'plugin' jars for Jackson, GSON, org.json, etc.  Some users upgrading from the earlier single \njar to JJWT's later versions have been frustrated by being forced to learn how to configure the more modular .jars.\n\nThis release re-introduces the `jjwt.jar` artifact again, but this time it is simply an empty .jar with Maven \nmetadata that will automatically transitively download the following into a project, retaining the old single-jar \nbehavior:\n* `jjwt-api.jar`\n* `jjwt-impl.jar`\n* `jjwt-jackson.jar`\n\nNaturally, developers are still encouraged to configure the modular .jars as described in JJWT's documentation for \ngreater control and to enable their preferred JSON parser, but this stop-gap should help those unaware when upgrading.\n\n#### JSON Web Encryption (JWE) Support!\n\nThis has been a long-awaited feature for JJWT, years in the making, and it is quite extensive - so many encryption \nalgorithms and key management algorithms are defined by the JWA specification, and new API concepts had to be \nintroduced for all of them, as well as extensive testing with RFC-defined test vectors.  The wait is over!  \nAll JWA-defined encryption algorithms and key management algorithms are fully implemented and supported and \navailable immediately.  For example:\n\n```java\nAeadAlgorithm enc = Jwts.ENC.A256GCM;\nSecretKey key = enc.key().build();\nString compact = Jwts.builder().setSubject(\"Joe\").encryptWith(key, enc).compact();\n\nJwe<Claims> jwe = Jwts.parser().decryptWith(key).build().parseEncryptedClaims(compact);\n```\n\nMany other RSA and Elliptic Curve examples are in the full README documentation. \n\n#### JSON Web Key (JWK) Support!\n\nRepresenting cryptographic keys - SecretKeys, RSA Public and Private Keys, Elliptic Curve Public and \nPrivate keys - as fully encoded JSON objects according to the JWK specification - is now fully implemented and\nsupported.  The new `Jwks` utility class exists to create JWK builders and parsers as desired.  For example:\n\n```java\nSecretKey key = Jwts.SIG.HS256.key().build();\nSecretJwk jwk = Jwks.builder().forKey(key).build();\nassert key.equals(jwk.toKey());\n\n// or if receiving a JWK string:\nJwk<?> parsedJwk = Jwks.parser().build().parse(jwkString);\nassert jwk.equals(parsedJwk);\nassert key.equals(parsedJwk.toKey());\n```\n\nMany JJWT users won't need to use JWKs explicitly, but some JWA Key Management Algorithms (and lots of RFC test \nvectors) utilize JWKs when transmitting JWEs.  As this was required by JWE, it is now implemented in full for \nJWE use as well as general-purpose JWK support.\n\n#### JWK Thumbprint and JWK Thumbprint URI support\n\nThe [JWK Thumbprint](https://www.rfc-editor.org/rfc/rfc7638.html) and \n[JWK Thumbprint URI](https://www.rfc-editor.org/rfc/rfc9278.html) RFC specifications are now fully supported.  Please\nsee the README.md file's corresponding named sections for both for full documentation and usage examples.\n\n#### JWS Unencoded Payload Option (`b64`) support\n\nThe [JSON Web Signature (JWS) Unencoded Payload Option](https://www.rfc-editor.org/rfc/rfc7797.html) RFC specification\nis now fully supported.  Please see the README.md corresponding named section for documentation and usage examples.\n\n#### Better PKCS11 and Hardware Security Module (HSM) support\n\nPrevious versions of JJWT enforced that Private Keys implemented the `RSAKey` and `ECKey` interfaces to enforce key \nlength requirements.  With this release, JJWT will still perform those checks when those data types are available, \nbut if not, as is common with keys from PKCS11 and HSM KeyStores, JJWT will still allow those Keys to be used, \nexpecting the underlying Security Provider to enforce any key requirements. This should reduce or eliminate any \ncustom code previously written to extend JJWT to use keys from those KeyStores or Providers.\n\nAdditionally, PKCS11/HSM tests using [SoftHSMv2](https://www.opendnssec.org/softhsm/) are run on every build with\nevery JWS MAC and Signature algorithm and every JWE Key algorithm to ensure continued stable support with\nAndroid and Sun PKCS11 implementations and spec-compliant Hardware Security Modules that use the PKCS11 interface\n(such as YubiKey, etc.)\n\n#### Custom Signature Algorithms\n\nThe `io.jsonwebtoken.SignatureAlgorithm` enum has been deprecated in favor of new \n`io.jsonwebtoken.security.SecureDigestAlgorithm`, `io.jsonwebtoken.security.MacAlgorithm`, and \n`io.jsonwebtoken.security.SignatureAlgorithm` interfaces to allow custom algorithm implementations.  The new nested\n`Jwts.SIG` static inner class is a registry of all standard JWS algorithms as expected, exactly like the \nold enum.  This change was made because enums are a static concept by design and cannot \nsupport custom values: those who wanted to use custom signature algorithms could not do so until now.  The new \ninterfaces now allow anyone to plug in and support custom algorithms with JJWT as desired.\n\n#### KeyBuilder and KeyPairBuilder\n\nBecause the `io.jsonwebtoken.security.Keys#secretKeyFor` and `io.jsonwebtoken.security.Keys#keyPairFor` methods \naccepted the now-deprecated `io.jsonwebtoken.SignatureAlgorithm` enum, they have also been deprecated in favor of \ncalling new `key()` or `keyPair()` builder methods on `MacAlgorithm` and `SignatureAlgorithm` instances directly.  \nFor example:\n\n```java\nSecretKey key = Jwts.SIG.HS256.key().build();\nKeyPair pair = Jwts.SIG.RS256.keyPair().build();\n```\n\nThe builders allow for customization of the JCA `Provider` and `SecureRandom` during Key or KeyPair generation if desired, whereas\nthe old enum-based static utility methods did not.\n\n#### Preparation for 1.0\n\nNow that the JWE and JWK specifications are implemented, only a few things remain for JJWT to be considered at \nversion 1.0.  We have been waiting to apply the 1.0 release version number until the entire set of JWT specifications \nare fully supported **and** we drop JDK 7 support (to allow users to use JDK 8 APIs).  To that end, we have had to \ndeprecate some concepts, or in some cases, completely break backwards compatibility to ensure the transition to \n1.0 (and JDK 8 APIs) are possible.  Most backwards-incompatible changes are listed in the next section below.\n\n#### Backwards Compatibility Breaking Changes, Warnings and Deprecations\n\n* `io.jsonwebtoken.Jwt`'s `getBody()` method has been deprecated in favor of a new `getPayload()` method to\n  reflect correct JWT specification nomenclature/taxonomy.\n\n\n* `io.jsonwebtoken.Jws`'s `getSignature()` method has been deprecated in favor of a new `getDigest()` method to\n  support expected congruent behavior with `Jwe` instances (both have digests).\n\n\n* `io.jsonwebtoken.JwtParser`'s `parseContentJwt`, `parseClaimsJwt`, `parseContentJws`, and `parseClaimsJws` methods\n  have been deprecated in favor of more intuitive respective `parseUnsecuredContent`, `parseUnsecuredClaims`,\n  `parseSignedContent` and `parseSignedClaims` methods.\n\n\n* `io.jsonwebtoken.CompressionCodec` is now deprecated in favor of the new `io.jsonwebtoken.io.CompressionAlgorithm`\n  interface. This is to guarantee API congruence with all other JWT-identifiable algorithm IDs that can be set as a \n  header value.\n\n\n* `io.jsonwebtoken.CompressionCodecResolver` has been deprecated in favor of the new\n  `JwtParserBuilder#addCompressionAlgorithms` method.\n\n\n#### Breaking Changes\n\n* **`io.jsonwebtoken.Claims` and `io.jsonwebtoken.Header` instances are now immutable** to enhance security and thread\n  safety.  Creation and mutation are supported with newly introduced `ClaimsBuilder` and `HeaderBuilder` concepts.\n  Even though mutation methods have migrated, there are a couple that have been removed entirely:\n  * `io.jsonwebtoken.JwsHeader#setAlgorithm` has been removed - the `JwtBuilder` will always set the appropriate\n    `alg` header automatically based on builder state.\n  * `io.jsonwebtoken.Header#setCompressionAlgorithm` has been removed - the `JwtBuilder` will always set the appropriate\n  `zip` header automatically based on builder state.\n\n\n* `io.jsonwebtoken.Jwts`'s `header(Map)`, `jwsHeader()` and `jwsHeader(Map)` methods have been removed in favor\n  of the new `header()` method that returns a `HeaderBuilder` to support method chaining and dynamic `Header` type \n  creation. The `HeaderBuilder` will dynamically create a `Header`, `JwsHeader` or `JweHeader` automatically based on \n  builder state.\n\n\n* Similarly, `io.jsonwebtoken.Jwts`'s `claims()` static method has been changed to return a `ClaimsBuilder` instead\n  of a `Claims` instance.\n\n\n* **JWTs that do not contain JSON Claims now have a payload type of `byte[]` instead of `String`** (that is, \n  `Jwt<byte[]>` instead of `Jwt<String>`).  This is because JWTs, especially when used with the \n  `cty` (Content Type) header, are capable of handling _any_ type of payload, not just Strings. The previous JJWT \n  releases didn't account for this, and now the API accurately reflects the JWT RFC specification payload \n  capabilities. Additionally, the name of `plaintext` has been changed to `content` in method names and JavaDoc to \n  reflect this taxonomy. This change has impacted the following JJWT APIs:\n\n  * The `JwtBuilder`'s `setPayload(String)` method has been deprecated in favor of two new methods:\n  \n    * `setContent(byte[])`, and \n    * `setContent(byte[], String contentType)`\n    \n    These new methods allow any kind of content\n    within a JWT, not just Strings. The existing `setPayload(String)` method implementation has been changed to \n    delegate to this new `setContent(byte[])` method with the argument's UTF-8 bytes, for example \n    `setContent(payloadString.getBytes(StandardCharsets.UTF_8))`.\n\n  * The `JwtParser`'s `Jwt<Header, String> parsePlaintextJwt(String plaintextJwt)` and\n    `Jws<String> parsePlaintextJws(String plaintextJws)` methods have been changed to\n    `Jwt<Header, byte[]> parseContentJwt(String plaintextJwt)` and\n    `Jws<byte[]> parseContentJws(String plaintextJws)` respectively.\n\n  * `JwtHandler`'s `onPlaintextJwt(String)` and `onPlaintextJws(String)` methods have been changed to\n    `onContentJwt(byte[])` and `onContentJws(byte[])` respectively.\n\n  * `io.jsonwebtoken.JwtHandlerAdapter` has been changed to reflect the above-mentioned name and `String`-to-`byte[]` \n    argument changes, as well adding the `abstract` modifier.  This class was never intended\n    to be instantiated directly, and is provided for subclassing only.  The missing modifier has been added to ensure\n    the class is used as it had always been intended.\n\n  * `io.jsonwebtoken.SigningKeyResolver`'s `resolveSigningKey(JwsHeader, String)` method has been changed to\n    `resolveSigningKey(JwsHeader, byte[])`.\n\n\n* `io.jsonwebtoken.JwtParser` is now immutable.  All mutation/modification methods (setters, etc) deprecated 4 years \n  ago have been removed.  All parser configuration requires using the `JwtParserBuilder`.\n\n\n* Similarly, `io.jsonwebtoken.Jwts`'s `parser()` method deprecated 4 years ago has been changed to now return a \n  `JwtParserBuilder` instead of a direct `JwtParser` instance.  The previous `Jwts.parserBuilder()` method has been \n  removed as it is now redundant.\n\n\n* The `JwtParserBuilder` no longer supports `PrivateKey`s for signature verification.  This was an old\n  legacy behavior scheduled for removal years ago, and that change is now complete.  For various cryptographic/security\n  reasons, asymmetric public/private key signatures should always be created with `PrivateKey`s and verified with\n  `PublicKey`s.\n\n\n* `io.jsonwebtoken.CompressionCodec` implementations are no longer discoverable via `java.util.ServiceLoader` due to\n  runtime performance problems with the JDK's `ServiceLoader` implementation per\n  https://github.com/jwtk/jjwt/issues/648.  Custom implementations should be made available to the `JwtParser` via\n  the new `JwtParserBuilder#addCompressionAlgorithms` method.\n\n\n* Prior to this release, if there was a serialization problem when serializing the JWT Header, an `IllegalStateException`\n  was thrown. If there was a problem when serializing the JWT claims, an `IllegalArgumentException` was\n  thrown.  This has been changed up to ensure consistency: any serialization error with either headers or claims\n  will now throw a `io.jsonwebtoken.io.SerializationException`.\n\n\n* Parsing of unsecured JWTs (`alg` header of `none`) are now disabled by default as mandated by \n  [RFC 7518, Section 3.6](https://www.rfc-editor.org/rfc/rfc7518.html#section-3.6). If you require parsing of\n  unsecured JWTs, you must call the `JwtParserBuilder#enableUnsecured()` method, but note the security\n  implications mentioned in that method's JavaDoc before doing so.\n\n\n* `io.jsonwebtoken.gson.io.GsonSerializer` now requires `Gson` instances that have a registered\n  `GsonSupplierSerializer` type adapter, for example:\n  ```java\n  new GsonBuilder()\n    .registerTypeHierarchyAdapter(io.jsonwebtoken.lang.Supplier.class, GsonSupplierSerializer.INSTANCE)    \n    .disableHtmlEscaping().create();\n  ```\n  This is to ensure JWKs have `toString()` and application log safety (do not print secure material), but still \n  serialize to JSON correctly.\n\n\n* `io.jsonwebtoken.InvalidClaimException` and its two subclasses (`IncorrectClaimException` and `MissingClaimException`)\n  were previously mutable, allowing the corresponding claim name and claim value to be set on the exception after\n  creation.  These should have always been immutable without those setters (just getters), and this was a previous\n  implementation oversight.  This release has ensured they are immutable without the setters.\n\n### 0.11.5\n\nThis patch release adds additional security guards against an ECDSA bug in Java SE versions 15-15.0.6, 17-17.0.2, and 18\n([CVE-2022-21449](https://nvd.nist.gov/vuln/detail/CVE-2022-21449)) in addition to the guards added in the JJWT 0.11.3 \nrelease. This patch allows JJWT users using those JVM versions to upgrade to JJWT 0.11.5, even if they are unable to \nupgrade their JVM to patched/fixed JVM version in a timely manner.  Note: if your application does not use these JVM \nversions, you are not exposed to the JVM vulnerability.\n\nNote that the CVE is not a bug within JJWT itself - it is a bug within the above listed JVM versions, and the\nJJWT 0.11.5 release adds additional precautions within JJWT in case an application team is not able to upgrade\ntheir JVM in a timely manner.\n\nHowever, even with these additional JJWT security guards, the root cause of the issue is the JVM, so it **strongly\nrecommended** to upgrade your JVM to version\n15.0.7, 17.0.3, or 18.0.1 or later to ensure the bug does not surface elsewhere in your application code or any other\nthird party library in your application that may not contain similar security guards. \n\nIssues included in this patch are listed in the [JJWT 0.11.5 milestone](https://github.com/jwtk/jjwt/milestone/26?closed=1).\n\n#### Credits\n\nThank you to [Neil Madden](https://neilmadden.blog), the security researcher that first discovered the JVM\nvulnerability as covered in his [Psychic Signatures in Java](https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/) \nblog post.  Neil worked directly with the JJWT team to provide these additional guards, beyond what was in the JJWT 0.11.3\nrelease, and we're grateful for his help and collaboration in reviewing our fixes and for the additional tests he\nprovided the JJWT team.\n\n### 0.11.4\n\nThis patch release:\n\n* Adds additional handling for rare JSON parsing exceptions and wraps them in a `JwtException` to allow the application to handle these conditions as JWT concerns.\n* Upgrades the `jjwt-jackson` module's Jackson dependency to `2.12.6.1`.\n* Upgrades the `jjwt-orgjson` module's org.json:json dependency to `20220320`.\n* Upgrades the `jjwt-gson` module's gson dependency to `2.9.0`.\n* Upgrades the internal testing BouncyCastle version and any references in README documentation examples to `1.70`.\n* Contains various documentation and typo fixes.\n\nThe patch also makes various internal project POM and build enhancements to reduce repetition and the chance for \nstale references, and overall create a cleaner build with less warnings.  It also ensures that CI testing builds\nand executes on all latest OpenJDK versions from Java 7 to Java 18 (inclusive).\n\nIssues included in this patch are listed in the [JJWT 0.11.4 milestone](https://github.com/jwtk/jjwt/milestone/25?closed=1).\n\n### 0.11.3\n\nThis patch release adds security guards against an ECDSA bug in Java SE versions 15-15.0.6, 17-17.0.2, and 18\n([CVE-2022-21449](https://nvd.nist.gov/vuln/detail/CVE-2022-21449)). Note: if your application does not use these \nJVM versions, you are not exposed to the JVM vulnerability.\n\nNote that the CVE is not a bug within JJWT itself - it is a bug within the above listed JVM versions.  However, even \nwith these additional JJWT security guards, the root cause of the issue is the JVM, so it **strongly \nrecommended** to upgrade your JVM to version 15.0.7, 17.0.3, or 18.0.1 or later to ensure the bug does not surface \nelsewhere in your application code or any other third party library in your application that may not contain similar \nsecurity guards.\n\nIssues included in this patch are listed in the [JJWT 0.11.3 milestone](https://github.com/jwtk/jjwt/milestone/24).\n\n#### Backwards Compatibility Warning\n\nIn addition to additional protections against \n[r or s values of zero in ECDSA signatures](https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/), this \nrelease also disables by default legacy DER-encoded signatures that might be included in an ECDSA-signed JWT. \n(DER-encoded signatures are not supported by the JWT RFC specifications, so they are not frequently encountered.)\n\nHowever, if you are using an application that needs to consume such legacy JWTs (either produced by a very \nearly version of JJWT, or a different JWT library), you may re-enable DER-encoded ECDSA signatures by setting the \n`io.jsonwebtoken.impl.crypto.EllipticCurveSignatureValidator.derEncodingSupported` System property to the _exact_ \n`String` value `true`.  For example:\n\n```java\nSystem.setProperty(\"io.jsonwebtoken.impl.crypto.EllipticCurveSignatureValidator.derEncodingSupported\", \"true\");\n```\n\n*BUT BE CAREFUL*:  **DO NOT** set this System property if your application may run on one of the vulnerable JVMs\nnoted above (Java SE versions 15-15.0.6, 17-17.0.2, and 18).\n\nYou may safely set this property to a `String` value of `true` on all other versions of the JVM if you need to \nsupport these legacy JWTs, *otherwise it is best to ignore (not set) the property entirely*.\n\n#### Credits\n\nThank you to [Neil Madden](https://neilmadden.blog), the security researcher that first discovered the JVM\nvulnerability as covered in his [Psychic Signatures in Java](https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/) blog post.\n\nWe'd also like to thank Toshiki Sasazaki, a member of [LINE Corporation](https://linecorp.com)'s Application Security \nTeam as the first person to report the concern directly to the JJWT team, as well as for working with us during testing \nleading to our conclusions and subsequent 0.11.3 patch release.\n\n### 0.11.2\n\nThis patch release:\n\n* Allows empty JWS bodies to support [RFC 8555](https://tools.ietf.org/html/rfc8555) and similar initiatives. [Pull Request 540](https://github.com/jwtk/jjwt/pull/540)\n* Ensures OSGi environments can access JJWT implementation bundles (`jjwt-jackson`, `jjwt-gson`, etc) as fragments to `jjwt-api` bundle. [Pull Request 580](https://github.com/jwtk/jjwt/pull/580)\n* Rejects `allowedClockSkewSeconds` values that would cause numeric overflow. [Issue 583](https://github.com/jwtk/jjwt/issues/583) \n* Upgrades Jackson dependency to version `2.9.10.4` to address all known Jackson CVE vulnerabilities. [Issue 585](https://github.com/jwtk/jjwt/issues/585)\n* Updates `SecretKey` algorithm name validation to allow PKCS12 KeyStore OIDs in addition to JCA Names. [Issue 588](https://github.com/jwtk/jjwt/issues/588)\n* Enabled CI builds on JDK 14. [Pull Request 590](https://github.com/jwtk/jjwt/pull/590)\n* Adds missing parameters type to `Maps.add()`, which removes an unchecked type warning. [Issue 591](https://github.com/jwtk/jjwt/issues/591)\n* Ensures `GsonDeserializer` always uses `UTF-8` for encoding bytes to Strings. [Pull Request 592](https://github.com/jwtk/jjwt/pull/592)\n\nAll issues and PRs are listed in the Github [JJWT 0.11.2 milestone](https://github.com/jwtk/jjwt/milestone/23?closed=1).\n\n\n### 0.11.1\n\nThis patch release:\n\n* Upgrades the `jjwt-jackson` module's Jackson dependency to `2.9.10.3`.\n* Fixes an issue when using Java 9+ `Map.of` with `JacksonDeserializer` that resulted in an `NullPointerException`.\n* Fixes an issue that prevented the `jjwt-gson` .jar's seralizer/deserializer implementation from being detected automatically.\n* Ensures service implementations are now loaded from the context class loader, Services.class.classLoader, and the system classloader, the first classloader with a service wins, and the others are ignored. This mimics how `Classes.forName()` works, and how JJWT attempted to auto-discover various implementations in previous versions.\n* Fixes a minor error in the `Claims#getIssuedAt` JavaDoc.\n\n### 0.11.0\n\nThis minor release:\n\n* Adds [Google's Gson](https://github.com/google/gson) as a natively supported JSON parser. Installation instructions \n  have been updated and new [JJWT Gson usage guidelines](https://github.com/jwtk/jjwt#json-gson) have been added.\n* Updates the Jackson dependency version to [2.9.10](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9#patches)\nto address three security vulnerabilities in Jackson.\n* A new `JwtParserBuilder` interface has been added and is the recommended way of creating an immutable and thread-safe JwtParser instance.  Mutable methods in `JwtParser` will be removed before v1.0.\n    Migration to the new signatures is straightforward, for example:\n    \n    Previous Version:\n    ```java \n     Jwts.parser()\n         .requireAudience(\"string\")\n         .parse(jwtString)\n    ```\n    Current Version:\n    ```java\n    Jwts.parserBuilder()\n        .requireAudience(\"string\")\n        .build()\n        .parse(jwtString)\n    ```\n* Adds `io.jsonwebtoken.lang.Maps` utility class to make creation of maps fluent, as demonstrated next.\n* Adds support for custom types when deserializing with Jackson. To use configure your parser:\n    ```java\n    Jwts.parserBuilder().deserializeJsonWith(\n        new JacksonDeserializer(\n            Maps.of(\"claimName\", YourType.class).build() // <--\n        )\n    ).build()\n  ```\n* Moves JSON Serializer/Deserializer implementations to a different package name.\n  - `io.jsonwebtoken.io.JacksonSerializer` -> `io.jsonwebtoken.jackson.io.JacksonSerializer`\n  - `io.jsonwebtoken.io.JacksonDeserializer` -> `io.jsonwebtoken.jackson.io.JacksonDeserializer`\n  - `io.jsonwebtoken.io.OrgJsonSerializer` -> `io.jsonwebtoken.orgjson.io.OrgJsonSerializer`\n  - `io.jsonwebtoken.io.OrgJsonDeserializer` -> `io.jsonwebtoken.orgjson.io.OrgJsonDeserializer`\n\n  A backward compatibility modules has been created using the `deprecated` classifier (`io.jsonwebtoken:jjwt-jackson:0.11.0:deprecated` and `io.jsonwebtoken:jjwt-orjson:0.11.0:deprecated`), if you are compiling against these classes directly, otherwise you will be unaffected.\n\n#### Backwards Compatibility Warning\n\nDue to this package move, if you are currently using one of the above four existing (pre 0.11.0) classes with `compile` scope, you must either:\n  1. change your code to use the newer package classes (recommended), or \n  1. change your build/dependency configuration to use the `deprecated` dependency classifier to use the existing classes, as follows:\n      \n**Maven**\n\n```xml\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-jackson</artifactId>\n    <version>0.11.0</version>\n    <classifier>deprecated</classifier>\n    <scope>compile</scope>\n</dependency>\n```\n\n**Gradle**\n\n```groovy\ncompile 'io.jsonwebtoken:jjwt-jackson:0.11.0:deprecated'\n```\n\n**Note:** that the first option is recommended since the second option will not be available starting with the 1.0 release.\n\n### 0.10.8\n\nThis patch release:\n\n* Ensures that SignatureAlgorithms `PS256`, `PS384`, and `PS512` work properly on JDK 11 and later without the need\n  for BouncyCastle.  Previous releases referenced a BouncyCastle-specific \n  algorithm name instead of the Java Security Standard Algorithm Name of \n  [`RSASSA-PSS`](https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#signature-algorithms).\n  This release ensures the standard name is used moving forward.\n  \n* Fixes a backwards-compatibility [bug](https://github.com/jwtk/jjwt/issues/536) when parsing compressed JWTs \n  created from 0.10.6 or earlier using the `DEFLATE` compression algorithm.  \n\n### 0.10.7\n\nThis patch release:\n \n* Adds a new [Community section](https://github.com/jwtk/jjwt#community) in the documentation discussing asking \n  questions, using Slack and Gittr, and opening new issues and pull requests. \n* Fixes a [memory leak](https://github.com/jwtk/jjwt/issues/392) found in the DEFLATE compression \ncodec implementation.\n* Updates the Jackson dependency version to [2.9.9.1](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9#patches)\nto address three security vulnerabilities in Jackson:\n[CVE-2019-12086](https://nvd.nist.gov/vuln/detail/CVE-2019-12086),\n[CVE-2019-12384](https://nvd.nist.gov/vuln/detail/CVE-2019-12384), and\n[CVE-2019-12814](https://nvd.nist.gov/vuln/detail/CVE-2019-12814).\n* Fixes a [bug](https://github.com/jwtk/jjwt/issues/397) when Jackson is in the classpath but the `jjwt-jackson` .jar is not.\n* Fixes various documentation and typo fixes.\n\n### 0.10.6\n\nThis patch release updates the jackson-databind version to 2.9.8 to address a critical security vulnerability in that\nlibrary.\n\n### 0.10.5\n\nThis patch release fixed an Android `org.json` library compatibility [issue](https://github.com/jwtk/jjwt/issues/388).\n\n### 0.10.4\n\nThis patch release fixed an [outstanding issue](https://github.com/jwtk/jjwt/issues/381) with JCA name \ncase-sensitivity that impacted Android that was not caught in the 0.10.3 release.\n\n### 0.10.3\n\nThis is a minor patch release that fixed a key length assertion for `SignatureAlgorithm.forSigningKey` that was \nfailing in Android environments.  The Android dependencies and ProGuard exclusions documentation was updated as \nwell to reflect Android Studio 3.0 conventions.\n\n### 0.10.2\n\nThis is a minor patch release that ensures the `OrgJsonSerializer` and `OrgJsonDeserializer` implementations are \ncompatible with Android's older `org.json` API.  Previously JJWT used newer `org.json` APIs that are not \navailable on Android.\n\n### 0.10.1\n\nThis is a minor point release that ensures the BouncyCastle dependency is optional and not pulled in as a transitive\ndependency into projects.\n \nInternal implementation code (not impacting the JJWT API) and documentation was also updated to reflect that all \nElliptic Curve algorithms are standard on the JDK and do not require Bouncy Castle.\n\nBouncy Castle is only needed when using PS256, PS384, and PS512 signature algorithms on < JDK 11. \n[JDK 11 and later](https://bugs.openjdk.java.net/browse/JDK-8146293) supports these algorithms natively.\n\n### 0.10.0\n\nThis is a fairly large feature enhancement release that enables the following:\n\n* Modular project structure resulting in pluggable JJWT dependencies ([Issue 348](https://github.com/jwtk/jjwt/issues/348))\n* Auto-configuration for Jackson or JSON-Java [JSON processors](https://github.com/jwtk/jjwt#json).\n* [Automatic SignatureAlgorithm selection](https://github.com/jwtk/jjwt#jws-create-key) based on specified signing Key.\n* Algorithm and Key [Strength Assertions](https://github.com/jwtk/jjwt#jws-key)\n* [Simplified Key generation](https://github.com/jwtk/jjwt#jws-key-create)\n* Deterministic [Base64(URL) support](https://github.com/jwtk/jjwt#base64) on all JDK and Android platforms\n* [Custom JSON processing](https://github.com/jwtk/jjwt#json-custom)\n* Complete [documentation](https://github.com/jwtk/jjwt)\n* and a bunch of other [minor fixes and enhancements](https://github.com/jwtk/jjwt/milestone/11).\n\n**BACKWARDS-COMPATIBILITY NOTICE:**\n\nJJWT's new modular design utilizes distinctions between compile and runtime dependencies to ensure you only depend\non the public APIs that are safe to use in your application.  All internal/private implementation classes have\nbeen moved to a new `jjwt-impl` runtime dependency.\n\nIf you depended on any internal implementation classes in the past, you have two choices:\n\n1. Refactor your code to use the public-only API classes and interfaces in the `jjwt-api` .jar.  Any functionality\n   you might have used in the internal implementation should be available via newer cleaner interfaces and helper \n   classes in that .jar.\n   \n2. Specify the new `jjwt-impl` .jar not as a runtime dependency but as a compile dependency.  This would make your\n   upgrade to JJWT 0.10.0 fully backwards compatible, but you do so _at your own risk_.  JJWT will make **NO** \n   semantic version compatibility guarantees in the `jjwt-impl` .jar moving forward.  Semantic versioning will be \n   very carefully adhered to in all other JJWT dependencies however.\n\n### 0.9.1\n\nThis is a minor patch release that updates the Jackson dependency to 2.9.6 to address Jackson CVE-2017-17485.\n\n### 0.9.0\n\nThis is a minor release that includes changes to dependencies and plugins to allow for building jjwt with Java 9.\nJavadocs in a few classes were updated as well to support proper linting in both Java 8 and Java 9.\n\n### 0.8.0\n\nThis is a minor feature enhancement, dependency version update and build update release. We switched from Jacoco to \nOpenClover as OpenClover delivers a higher quality of test metrics. As an interim measure, we introduced a new \nrepository that has an updated version of the coveralls-maven-plugin which includes support for Clover reporting to\nCoveralls. Once this change has been merged and released to the official coveralls-maven-plugin on maven central, \nthis repository will be removed. The following dependencies were updated to the latest release version: maven \ncompiler, maven enforcer, maven failsafe, maven release, maven scm provider, maven bundle, maven gpg, maven source, \nmaven javadoc, jackson, bouncy castle, groovy, logback and powermock. Of significance, is the upgrade for jackson as \na security issue was addressed in its latest release.\n\nAn `addClaims` method is added to the `JwtBuilder` interface in this release. It adds all given name/value pairs to\nthe JSON Claims in the payload.\n\nAdditional tests were added to improve overall test coverage.\n\n### 0.7.0\n\nThis is a minor feature enhancement and bugfix release.  One of the bug fixes is particularly important if using\nelliptic curve signatures, please see below.\n\n#### Elliptic Curve Signature Length Bug Fix\n\nPrevious versions of JJWT safely calculated and verified Elliptic Curve signatures (no security risks), however, the\n signatures were encoded using the JVM's default ASN.1/DER format.  The JWS specification however \nrequires EC signatures to be in a R + S format.  JJWT >= 0.7.0 now correctly represents newly computed EC signatures in \nthis spec-compliant format.\n\nWhat does this mean for you?\n\nSignatures created from previous JJWT versions can still be verified, so your existing tokens will still be parsed \ncorrectly. HOWEVER, new JWTs with EC signatures created by JJWT >= 0.7.0 are now spec compliant and therefore can only \nbe verified by JJWT >= 0.7.0 (or any other spec compliant library).\n\n**This means that if you generate JWTs using Elliptic Curve Signatures after upgrading to JJWT >= 0.7.0, you _must_ \nalso upgrade any applications that parse these JWTs to upgrade to JJWT >= 0.7.0 as well.**\n\n#### Clock Skew Support\n\nWhen parsing a JWT, you might find that `exp` or `nbf` claims fail because the clock on the parsing machine is not \nperfectly in sync with the clock on the machine that created the JWT.  You can now account for these differences \n(usually no more than a few minutes) when parsing using the new `setAllowedClockSkewSeconds` method on the parser.\nFor example:\n\n```java\nlong seconds = 3 * 60; //3 minutes\nJwts.parser().setAllowedClockSkewSeconds(seconds).setSigningKey(key).parseClaimsJws(jwt);\n```\n\nThis ensures that clock differences between machines can be ignored.  Two or three minutes should be more than enough; it\nwould be very strange if a machine's clock was more than 5 minutes difference from most atomic clocks around the world.\n\n#### Custom Clock Support\n\nTimestamps created during parsing can now be obtained via a custom time source via an implementation of\n the new `io.jsonwebtoken.Clock` interface.  The default implementation simply returns `new Date()` to reflect the time\n  when parsing occurs, as most would expect.  However, supplying your own clock could be useful, especially during test \n  cases to guarantee deterministic behavior.\n\n#### Android RSA Private Key Support\n\nPrevious versions of JJWT required RSA private keys to implement `java.security.interfaces.RSAPrivateKey`, but Android \n6 RSA private keys do not implement this interface.  JJWT now asserts that RSA keys are instances of both \n`java.security.interfaces.RSAKey` and `java.security.PrivateKey` which should work fine on both Android and all other\n'standard' JVMs as well.\n\n#### Library version updates\n\nThe few dependencies JWWT has (e.g. Jackson) have been updated to their latest stable versions at the time of release.\n\n#### Issue List\n\nFor all completed issues, please see the [0.7.0 Milestone List](https://github.com/jwtk/jjwt/milestone/7?closed=1)\n\n### 0.6.0\n\n#### Enforce JWT Claims when Parsing\n\nYou can now enforce that JWT claims have expected values when parsing a compact JWT string.\n\nFor example, let's say that you require that the JWT you are parsing has a specific `sub` (subject) value,\notherwise you may not trust the token.  You can do that by using one of the `require` methods on the parser builder:\n\n```java\ntry {\n    Jwts.parser().requireSubject(\"jsmith\").setSigningKey(key).parseClaimsJws(s);\n} catch(InvalidClaimException ice) {\n    // the sub claim was missing or did not have a 'jsmith' value\n}\n```\n\nIf it is important to react to a missing vs an incorrect value, instead of catching `InvalidClaimException`, you can catch either `MissingClaimException` or `IncorrectClaimException`:\n\n```java\ntry {\n    Jwts.parser().requireSubject(\"jsmith\").setSigningKey(key).parseClaimsJws(s);\n} catch(MissingClaimException mce) {\n    // the parsed JWT did not have the sub claim\n} catch(IncorrectClaimException ice) {\n    // the parsed JWT had a sub claim, but its value was not equal to 'jsmith'\n}\n```\n\nYou can also require custom claims by using the `require(claimName, requiredValue)` method - for example:\n\n```java\ntry {\n    Jwts.parser().require(\"myClaim\", \"myRequiredValue\").setSigningKey(key).parseClaimsJws(s);\n} catch(InvalidClaimException ice) {\n    // the 'myClaim' claim was missing or did not have a 'myRequiredValue' value\n}\n```\n(or, again, you could catch either MissingClaimException or IncorrectClaimException instead)\n\n#### Body Compression\n\n**This feature is NOT JWT specification compliant**, *but it can be very useful when you parse your own tokens*.\n\nIf your JWT body is large and you have size restrictions (for example, if embedding a JWT in a URL and the URL must be under a certain length for legacy browsers or mail user agents), you may now compress the JWT body using a `CompressionCodec`:\n\n```java\nJwts.builder().claim(\"foo\", \"someReallyLongDataString...\")\n    .compressWith(CompressionCodecs.DEFLATE) // or CompressionCodecs.GZIP\n    .signWith(SignatureAlgorithm.HS256, key)\n    .compact();\n```\n\nThis will set a new `zip` header with the name of the compression algorithm used so that parsers can see that value and decompress accordingly.\n\nThe default parser implementation will automatically decompress DEFLATE or GZIP compressed bodies, so you don't need to set anything on the parser - it looks like normal:\n\n```java\nJwts.parser().setSigningKey(key).parseClaimsJws(compact);\n```\n\n##### Custom Compression Algorithms\n\nIf the DEFLATE or GZIP algorithms are not sufficient for your needs, you can specify your own Compression algorithms by implementing the `CompressionCodec` interface and setting it on the parser:\n\n```java\nJwts.builder().claim(\"foo\", \"someReallyLongDataString...\")\n    .compressWith(new MyCompressionCodec())\n    .signWith(SignatureAlgorithm.HS256, key)\n    .compact();\n```\n\nYou will then need to specify a `CompressionCodecResolver` on the parser, so you can inspect the `zip` header and return your custom codec when discovered:\n\n```java\nJwts.parser().setSigningKey(key)\n    .setCompressionCodecResolver(new MyCustomCompressionCodecResolver())\n    .parseClaimsJws(compact);\n```\n\n*NOTE*: Because body compression is not JWT specification compliant, you should only enable compression if both your JWT builder and parser are JJWT versions >= 0.6.0, or if you're using another library that implements the exact same functionality.  This feature is best reserved for your own use cases - where you both create and later parse the tokens.  It will likely cause problems if you compressed a token and expected a 3rd party (who doesn't use JJWT) to parse the token.\n\n### 0.5.1\n\n- Minor [bug](https://github.com/jwtk/jjwt/issues/31) fix [release](https://github.com/jwtk/jjwt/issues?q=milestone%3A0.5.1+is%3Aclosed) that ensures correct Base64 padding in Android runtimes.\n\n### 0.5\n\n- Android support! Android's built-in Base64 codec will be used if JJWT detects it is running in an Android environment.  Other than Base64, all other parts of JJWT were already Android-compliant.  Now it is fully compliant.\n\n- Elliptic Curve signature algorithms!  `SignatureAlgorithm.ES256`, `ES384` and `ES512` are now supported.\n\n- Super convenient key generation methods, so you don't have to worry how to do this safely:\n  - `MacProvider.generateKey(); //or generateKey(SignatureAlgorithm)`\n  - `RsaProvider.generateKeyPair(); //or generateKeyPair(sizeInBits)`\n  - `EllipticCurveProvider.generateKeyPair(); //or generateKeyPair(SignatureAlgorithm)`\n\n  The `generate`* methods that accept an `SignatureAlgorithm` argument know to generate a key of sufficient strength that reflects the specified algorithm strength.\n\nPlease see the full [0.5 closed issues list](https://github.com/jwtk/jjwt/issues?q=milestone%3A0.5+is%3Aclosed) for more information.\n\n### 0.4\n\n- [Issue 8](https://github.com/jwtk/jjwt/issues/8): Add ability to find signing key by inspecting the JWS values before verifying the signature.\n\nThis is a handy little feature.  If you need to parse a signed JWT (a JWS) and you don't know which signing key was used to sign it, you can now use the new `SigningKeyResolver` concept.\n\nA `SigningKeyresolver` can inspect the JWS header and body (Claims or String) _before_ the JWS signature is verified. By inspecting the data, you can find the key and return it, and the parser will use the returned key to validate the signature.  For example:\n\n```java\nSigningKeyResolver resolver = new MySigningKeyResolver();\n\nJws<Claims> jws = Jwts.parser().setSigningKeyResolver(resolver).parseClaimsJws(compact);\n```\n\nThe signature is still validated, and the JWT instance will still not be returned if the jwt string is invalid, as \nexpected.  You just get to 'see' the JWT data for key discovery before the parser validates.  Nice.\n\nThis of course requires that you put some sort of information in the JWS when you create it so that your \n`SigningKeyResolver` implementation can look at it later and look up the key.  The *standard* way to do this is to \nuse the JWS `kid` ('key id') header parameter, for example:\n\n```java\nJwts.builder().setHeaderParam(\"kid\", your_signing_key_id_NOT_THE_SECRET).build();\n```\n\nYou could of course set any other header parameter or claims instead of setting `kid` if you want - \nthat's just the default parameter reserved for signing key identification.  If you can locate the signing key based \non other information in the header or claims, you don't need to set the `kid` parameter - just make sure your \nresolver implementation knows how to look up the key.\n\nFinally, a nice `SigningKeyResolverAdapter` is provided to allow you to write quick and simple subclasses or \nanonymous classes instead of having to implement the `SigningKeyResolver` interface directly.  For example:\n\n```java\nJws<Claims> jws = Jwts.parser().setSigningKeyResolver(new SigningKeyResolverAdapter() {\n        @Override\n        public byte[] resolveSigningKeyBytes(JwsHeader header, Claims claims) {\n            //inspect the header or claims, lookup and return the signing key\n            String keyId = header.getKeyId(); //or any other parameter that you need to inspect\n            return getSigningKey(keyId); //implement me\n        }})\n    .parseClaimsJws(compact);\n```\n\n### 0.3\n\n- [Issue 6](https://github.com/jwtk/jjwt/issues/6): Parsing an expired Claims JWT or JWS (as determined by the `exp` \n  claim) will now throw an `ExpiredJwtException`.\n- [Issue 7](https://github.com/jwtk/jjwt/issues/7): Parsing a premature Claims JWT or JWS (as determined by the `nbf`\n  claim) will now throw a `PrematureJwtException`.\n\n### 0.2\n\n#### More convenient Claims building\n\nThis release adds convenience methods to the `JwtBuilder` interface so you can set claims directly on the builder without having to create a separate Claims instance/builder, reducing the amount of code you have to write.  For example, this:\n\n```java\nClaims claims = Jwts.claims().setSubject(\"Joe\");\n\nString compactJwt = Jwts.builder().setClaims(claims).signWith(HS256, key).compact();\n```\n\ncan now be written as:\n\n```java\nString compactJwt = Jwts.builder().setSubject(\"Joe\").signWith(HS256, key).compact();\n```\n\nA Claims instance based on the specified claims will be created and set as the JWT's payload automatically.\n\n#### Type-safe handling for JWT and JWS with generics\n\nThe following < 0.2 code produced a JWT as expected:\n\n```java\nJwt jwt = Jwts.parser().setSigningKey(key).parse(compact);\n```\n\nBut you couldn't easily determine if the `jwt` was a `JWT` or `JWS` instance or if the body was a `Claims` instance or a plaintext `String` without resorting to a bunch of yucky `instanceof` checks.  In 0.2, we introduce the `JwtHandler` when you don't know the exact format of the compact JWT string ahead of time, and parsing convenience methods when you do.\n\n##### JwtHandler\n\nIf you do not know the format of the compact JWT string at the time you try to parse it, you can determine what type it is after parsing by providing a `JwtHandler` instance to the `JwtParser` with the new `parse(String compactJwt, JwtHandler handler)` method.  For example:\n\n```java\nT returnVal = Jwts.parser().setSigningKey(key).parse(compact, new JwtHandler<T>() {\n    @Override\n    public T onPlaintextJwt(Jwt<Header, String> jwt) {\n        //the JWT parsed was an unsigned plaintext JWT\n        //inspect it, then return an instance of T (see returnVal above)\n    }\n\n    @Override\n    public T onClaimsJwt(Jwt<Header, Claims> jwt) {\n        //the JWT parsed was an unsigned Claims JWT\n        //inspect it, then return an instance of T (see returnVal above)\n    }\n\n    @Override\n    public T onPlaintextJws(Jws<String> jws) {\n        //the JWT parsed was a signed plaintext JWS\n        //inspect it, then return an instance of T (see returnVal above)\n    }\n\n    @Override\n    public T onClaimsJws(Jws<Claims> jws) {\n        //the JWT parsed was a signed Claims JWS\n        //inspect it, then return an instance of T (see returnVal above)\n    }\n});\n```\n\nOf course, if you know you'll only have to parse a subset of the above, you can use the `JwtHandlerAdapter` and implement only the methods you need.  For example:\n\n```java\nT returnVal = Jwts.parser().setSigningKey(key).parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, T>>() {\n    @Override\n    public T onPlaintextJws(Jws<String> jws) {\n        //the JWT parsed was a signed plaintext JWS\n        //inspect it, then return an instance of T (see returnVal above)\n    }\n\n    @Override\n    public T onClaimsJws(Jws<Claims> jws) {\n        //the JWT parsed was a signed Claims JWS\n        //inspect it, then return an instance of T (see returnVal above)\n    }\n});\n```\n\n##### Known Type convenience parse methods\n\nIf, unlike above, you are confident of the compact string format and know which type of JWT or JWS it will produce, you can just use one of the 4 new convenience parsing methods to get exactly the type of JWT or JWS you know exists.  For example:\n\n```java\n\n//for a known plaintext jwt string:\nJwt<Header,String> jwt = Jwts.parser().parsePlaintextJwt(compact);\n\n//for a known Claims JWT string:\nJwt<Header,Claims> jwt = Jwts.parser().parseClaimsJwt(compact);\n\n//for a known signed plaintext JWT (aka a plaintext JWS):\nJws<String> jws = Jwts.parser().setSigningKey(key).parsePlaintextJws(compact);\n\n//for a known signed Claims JWT (aka a Claims JWS):\nJws<Claims> jws = Jwts.parser().setSigningKey(key).parseClaimsJws(compact);\n\n```\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.05859375,
          "content": "Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "NOTICE.md",
          "type": "blob",
          "size": 2.994140625,
          "content": "## Base64 implementation\n\nJJWT's `io.jsonwebtoken.io.Base64` implementation is based on [MigBase64](https://github.com/brsanthu/migbase64) with \ncontinued modifications for Base64 URL support and additional test cases. The MigBase64 copyright and license notice \nhave been retained and are repeated here per that code's requirements:\n\n```\nLicence (BSD):\n==============\n\nCopyright (c) 2004, Mikael Grev, MiG InfoCom AB. (base64 @ miginfocom . com)\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\nRedistributions of source code must retain the above copyright notice, this list\nof conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this\nlist of conditions and the following disclaimer in the documentation and/or other\nmaterials provided with the distribution.\nNeither the name of the MiG InfoCom AB nor the names of its contributors may be\nused to endorse or promote products derived from this software without specific\nprior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\nOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\nOF SUCH DAMAGE.\n```\n\nAdditionally, the following classes were copied from the Apache Commons-Codec project, with further JJWT-specific\nmodifications:\n* io.jsonwebtoken.impl.io.Base64Codec\n* io.jsonwebtoken.impl.io.Base64InputStream\n* io.jsonwebtoken.impl.io.Base64OutputStream\n* io.jsonwebtoken.impl.io.BaseNCodec\n* io.jsonwebtoken.impl.io.BaseNCodecInputStream\n* io.jsonwebtoken.impl.io.BaseNCodecOutputStream\n* io.jsonwebtoken.impl.io.CodecPolicy\n\nIts attribution:\n\n```\nApache Commons Codec\nCopyright 2002-2023 The Apache Software Foundation\n\nThis product includes software developed at\nThe Apache Software Foundation (https://www.apache.org/).\n```\n\nAlso, the following classes were copied from the Apache Commons-IO project, with further JJWT-specific modifications:\n* io.jsonwebtoken.impl.io.CharSequenceReader\n* io.jsonwebtoken.impl.io.FilteredInputStream\n* io.jsonwebtoken.impl.io.FilteredOutputStream\n* io.jsonwebtoken.impl.io.ClosedInputStream\n* io.jsonwebtoken.impl.io.UncloseableInputStream\n\nIt's attribution:\n\n```\nApache Commons IO\nCopyright 2002-2023 The Apache Software Foundation\n\nThis product includes software developed at\nThe Apache Software Foundation (https://www.apache.org/).\n```"
        },
        {
          "name": "README.adoc",
          "type": "blob",
          "size": 160.623046875,
          "content": ":doctype: book\n= Java JWT: JSON Web Token for Java and Android\n:project-version: 0.12.6\n:toc:\n:toc-title:\n:toc-placement!:\n:toclevels: 4\n\nifdef::env-github[]\n:tip-caption: TIP\n:note-caption:  NOTE\n:important-caption: IMPORTANT\n:caution-caption: CAUTION\n:warning-caption: WARNING\nendif::[]\n\n// Macros\n:fn-require-java8-plus: Requires Java 8 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.\n:fn-require-java11-plus: Requires Java 11 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.\n:fn-require-java15-plus: Requires Java 15 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.\n\nimage:https://github.com/jwtk/jjwt/actions/workflows/ci.yml/badge.svg?branch=master[Build Status,link=https://github.com/jwtk/jjwt/actions/workflows/ci.yml?query=branch%3Amaster]\nimage:https://coveralls.io/repos/github/jwtk/jjwt/badge.svg?branch=master[Coverage Status,link=https://coveralls.io/github/jwtk/jjwt?branch=master]\nimage:https://snyk-widget.herokuapp.com/badge/mvn/io.jsonwebtoken/jjwt-root/badge.svg[Vuln score,link=https://snyk-widget.herokuapp.com/badge/mvn/io.jsonwebtoken/jjwt-root/badge.svg]\nimage:https://snyk.io/test/github/jwtk/jjwt/badge.svg[Known Vulns,link=https://snyk.io/test/github/jwtk/jjwt/badge.svg]\n\nJJWT aims to be the easiest to use and understand library for creating and verifying JSON Web Tokens (JWTs) and\nJSON Web Keys (JWKs) on the JVM and Android.\n\nJJWT is a pure Java implementation based exclusively on the\nhttps://datatracker.ietf.org/wg/jose/documents/[JOSE Working Group] RFC specifications:\n\n* https://tools.ietf.org/html/rfc7519[RFC 7519: JSON Web Token (JWT)]\n* https://tools.ietf.org/html/rfc7515[RFC 7515: JSON Web Signature (JWS)]\n* https://tools.ietf.org/html/rfc7516[RFC 7516: JSON Web Encryption (JWE)]\n* https://tools.ietf.org/html/rfc7517[RFC 7517: JSON Web Key (JWK)]\n* https://tools.ietf.org/html/rfc7518[RFC 7518: JSON Web Algorithms (JWA)]\n* https://www.rfc-editor.org/rfc/rfc7638.html[RFC 7638: JSON Web Key Thumbprint]\n* https://www.rfc-editor.org/rfc/rfc9278.html[RFC 9278: JSON Web Key Thumbprint URI]\n* https://www.rfc-editor.org/rfc/rfc7797.html[RFC 7797: JWS Unencoded Payload Option]\n* https://www.rfc-editor.org/rfc/rfc8037[RFC 8037: Edwards Curve algorithms and JWKs]\n\nIt was created by https://github.com/lhazlewood[Les Hazlewood]\nand is supported and maintained by a https://github.com/jwtk/jjwt/graphs/contributors[community] of contributors.\n\nJJWT is open source under the terms of the http://www.apache.org/licenses/LICENSE-2.0[Apache 2.0 License].\n\n====\n[discrete]\n== Table of Contents\n---\ntoc::[]\n====\n\n+++<a name=\"features\">++++++</a>+++\n\n== Features\n\n* Fully functional on all Java 7+ JDKs and Android\n* Automatic security best practices and assertions\n* Easy to learn and read API\n* Convenient and readable http://en.wikipedia.org/wiki/Fluent_interface[fluent] interfaces, great for IDE\nauto-completion to write code quickly\n* Fully RFC specification compliant on all implemented functionality, tested against RFC-specified test vectors\n* Stable implementation with almost 1,700 tests and enforced 100% test code coverage.  Every single method, statement\nand conditional branch variant in the entire codebase is tested and required to pass on every build.\n* Creating, parsing and verifying digitally signed compact JWTs (aka JWSs) with all standard JWS algorithms:\n+\n|===\n| Identifier | Signature Algorithm\n\n| `HS256`\n| HMAC using SHA-256\n\n| `HS384`\n| HMAC using SHA-384\n\n| `HS512`\n| HMAC using SHA-512\n\n| `ES256`\n| ECDSA using P-256 and SHA-256\n\n| `ES384`\n| ECDSA using P-384 and SHA-384\n\n| `ES512`\n| ECDSA using P-521 and SHA-512\n\n| `RS256`\n| RSASSA-PKCS-v1_5 using SHA-256\n\n| `RS384`\n| RSASSA-PKCS-v1_5 using SHA-384\n\n| `RS512`\n| RSASSA-PKCS-v1_5 using SHA-512\n\n| `PS256`\n| RSASSA-PSS using SHA-256 and MGF1 with SHA-256^*1*^\n\n| `PS384`\n| RSASSA-PSS using SHA-384 and MGF1 with SHA-384^*1*^\n\n| `PS512`\n| RSASSA-PSS using SHA-512 and MGF1 with SHA-512^*1*^\n\n| `EdDSA`\n| Edwards-curve Digital Signature Algorithm^*2*^\n|===\n+\n^*1.*{sp}{fn-require-java11-plus}^\n+\n^*2*.{sp}{fn-require-java15-plus}^\n\n* Creating, parsing and decrypting encrypted compact JWTs (aka JWEs) with all standard JWE encryption algorithms:\n+\n|===\n| Identifier | Encryption Algorithm\n\n| `A128CBCHS256`\n| https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.3[AES_128_CBC_HMAC_SHA_256] authenticated encryption algorithm\n\n| `A192CBC-HS384`\n| https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.4[AES_192_CBC_HMAC_SHA_384] authenticated encryption algorithm\n\n| `A256CBC-HS512`\n| https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.5[AES_256_CBC_HMAC_SHA_512] authenticated encryption algorithm\n\n| `A128GCM`\n| AES GCM using 128-bit key^*1*^\n\n| `A192GCM`\n| AES GCM using 192-bit key^*1*^\n\n| `A256GCM`\n| AES GCM using 256-bit key^*1*^\n|===\n+\n^*1*.{sp}{fn-require-java8-plus}^\n\n* All Key Management Algorithms for obtaining JWE encryption and decryption keys:\n+\n|===\n| Identifier | Key Management Algorithm\n\n| `RSA1_5`\n| RSAES-PKCS1-v1_5\n\n| `RSA-OAEP`\n| RSAES OAEP using default parameters\n\n| `RSA-OAEP-256`\n| RSAES OAEP using SHA-256 and MGF1 with SHA-256\n\n| `A128KW`\n| AES Key Wrap with default initial value using 128-bit key\n\n| `A192KW`\n| AES Key Wrap with default initial value using 192-bit key\n\n| `A256KW`\n| AES Key Wrap with default initial value using 256-bit key\n\n| `dir`\n| Direct use of a shared symmetric key as the CEK\n\n| `ECDH-ES`\n| Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF\n\n| `ECDH-ES+A128KW`\n| ECDH-ES using Concat KDF and CEK wrapped with \"A128KW\"\n\n| `ECDH-ES+A192KW`\n| ECDH-ES using Concat KDF and CEK wrapped with \"A192KW\"\n\n| `ECDH-ES+A256KW`\n| ECDH-ES using Concat KDF and CEK wrapped with \"A256KW\"\n\n| `A128GCMKW`\n| Key wrapping with AES GCM using 128-bit key^*1*^\n\n| `A192GCMKW`\n| Key wrapping with AES GCM using 192-bit key^*1*^\n\n| `A256GCMKW`\n| Key wrapping with AES GCM using 256-bit key^*1*^\n\n| `PBES2-HS256+A128KW`\n| PBES2 with HMAC SHA-256 and \"A128KW\" wrapping^*1*^\n\n| `PBES2-HS384+A192KW`\n| PBES2 with HMAC SHA-384 and \"A192KW\" wrapping^*1*^\n\n| `PBES2HS512+A256KW`\n| PBES2 with HMAC SHA-512 and \"A256KW\" wrapping^*1*^\n|===\n+\n^*1*.{sp}{fn-require-java8-plus}^\n\n* Creating, parsing and verifying JSON Web Keys (JWKs) in all standard JWA key formats using native Java `Key` types:\n+\n|===\n| JWK Key Format | Java `Key` Type | JJWT `Jwk` Type\n\n| Symmetric Key\n| `SecretKey`\n| `SecretJwk`\n\n| Elliptic Curve Public Key\n| `ECPublicKey`\n| `EcPublicJwk`\n\n| Elliptic Curve Private Key\n| `ECPrivateKey`\n| `EcPrivateJwk`\n\n| RSA Public Key\n| `RSAPublicKey`\n| `RsaPublicJwk`\n\n| RSA Private Key\n| `RSAPrivateKey`\n| `RsaPrivateJwk`\n\n| XDH Private Key\n| `XECPublicKey`^*1*^\n| `OctetPublicJwk`\n\n| XDH Private Key\n| `XECPrivateKey`^*1*^\n| `OctetPrivateJwk`\n\n| EdDSA Public Key\n| `EdECPublicKey`^*2*^\n| `OctetPublicJwk`\n\n| EdDSA Private Key\n| `EdECPublicKey`^*2*^\n| `OctetPrivateJwk`\n|===\n+\n^*1*.{sp}{fn-require-java15-plus}^\n+\n^*2*.{sp}{fn-require-java15-plus}^\n\n* Convenience enhancements beyond the specification such as\n ** Payload compression for any large JWT, not just JWEs\n ** Claims assertions (requiring specific values)\n ** Claim POJO marshaling and unmarshalling when using a compatible JSON parser (e.g. Jackson)\n ** Secure Key generation based on desired JWA algorithms\n ** and more...\n\n+++<a name=\"features-unsupported\">++++++</a>+++\n\n=== Currently Unsupported Features\n\n* https://tools.ietf.org/html/rfc7515#section-7.2[Non-compact] serialization and parsing.\n\nThis feature may be implemented in a future release.  Community contributions are welcome!\n\n+++<a name=\"community\">++++++</a>+++\n\n== Community\n\n+++<a name=\"help\">++++++</a>+++\n\n=== Getting Help\n\nIf you have trouble using JJWT, please first read the documentation on this page before asking questions.  We try\nvery hard to ensure JJWT's documentation is robust, categorized with a table of contents, and up to date for each\nrelease.\n\n+++<a name=\"help-questions\">++++++</a>+++\n\n==== Questions\n\nIf the documentation or the API JavaDoc isn't sufficient, and you either have usability questions or are confused\nabout something, please https://github.com/jwtk/jjwt/discussions/new?category=q-a[ask your question here]. However:\n\n*Please do not create a GitHub issue to ask a question.*\n\nWe use GitHub Issues to track actionable work that requires changes to JJWT's design and/or codebase.  If you have a\nusability question, instead please\nhttps://github.com/jwtk/jjwt/discussions/new?category=q-a[ask your question here], and we can convert that to an\nissue if necessary.\n\n*If a GitHub Issue is created that does not represent actionable work for JJWT's codebase, it will be promptly\nclosed.*\n\n+++<a name=\"help-issues\">++++++</a>+++\n\n==== Bugs, Feature Requests, Ideas and General Discussions\n\nIf you do not have a usability question and believe you have a legitimate bug or feature request,\nplease https://github.com/jwtk/jjwt/discussions[discuss it here] *_FIRST_*. Please do a quick search first to\nsee if an existing discussion related to yours exist already and join that existing discussion if necesary.\n\nIf you feel like you'd like to help fix a bug or implement the new feature yourself, please read the Contributing\nsection next before starting any work.\n\n+++<a name=\"contributing\">++++++</a>+++\n\n=== Contributing\n\n+++<a name=\"contributing-pull-requests\">++++++</a>+++\n\n==== Pull Requests\n\nSimple Pull Requests that fix anything other than JJWT core code (documentation, JavaDoc, typos, test cases, etc) are\nalways appreciated and have a high likelihood of being merged quickly. Please send them!\n\nHowever, if you want or feel the need to change JJWT's functionality or core code, please do not issue a pull request\nwithout https://github.com/jwtk/jjwt/discussions[starting a new JJWT discussion] and discussing your desired\nchanges *first*, _before you start working on it_.\n\nIt would be a shame to reject your earnest and genuinely-appreciated pull request if it might not align with the\nproject's goals, design expectations or planned functionality.  We've sadly had to reject large PRs in the past because\nthey were out of sync with project or design expectations - all because the PR author didn't first check in with\nthe team first before working on a solution.\n\nSo, please https://github.com/jwtk/jjwt/discussions[create a new JJWT discussion] first to discuss, and then we\ncan see easily convert the discussion to an issue and then see if (or how) a PR is warranted.  Thank you!\n\n+++<a name=\"contributing-help-wanted\">++++++</a>+++\n\n==== Help Wanted\n\nIf you would like to help, but don't know where to start, please visit the\nhttps://github.com/jwtk/jjwt/labels/help%20wanted[Help Wanted Issues] page and pick any of the\nones there, and we'll be happy to discuss and answer questions in the issue comments.\n\nIf any of those don't appeal to you, no worries! Any help you would like to offer would be\nappreciated based on the above caveats concerning <<contributing-pull-requests,contributing pull requests>>. Feel free\nto https://github.com/jwtk/jjwt/discussions[discuss or ask questions first] if you're not sure. :)\n\n+++<a name=\"overview\">++++++</a>+++\n\n== What is a JSON Web Token?\n\nJSON Web Token (JWT) is a _general-purpose_ text-based messaging format for transmitting information in a\ncompact and secure way.  Contrary to popular belief, JWT is not just useful for sending and receiving identity tokens\non the web - even if that is the most common use case.  JWTs can be used as messages for _any_ type of data.\n\nA JWT in its simplest form contains two parts:\n\n. The primary data within the JWT, called the `payload`, and\n. A JSON `Object` with name/value pairs that represent metadata about the `payload` and the\nmessage itself, called the `header`.\n\nA JWT `payload` can be absolutely anything at all - anything that can be represented as a byte array, such as Strings,\nimages, documents, etc.\n\nBut because a JWT `header` is a JSON `Object`, it would make sense that a JWT `payload` could also be a JSON\n`Object` as well. In many cases, developers like the `payload` to be JSON that\nrepresents data about a user or computer or similar identity concept. When used this way, the `payload` is called a\nJSON `Claims` object, and each name/value pair within that object is called a `claim` - each piece of information\nwithin 'claims' something about an identity.\n\nAnd while it is useful to 'claim' something about an identity, really anyone can do that. What's important is that you\n_trust_ the claims by verifying they come from a person or computer you trust.\n\nA nice feature of JWTs is that they can be secured in various ways. A JWT can be cryptographically signed (making it\nwhat we call a https://tools.ietf.org/html/rfc7515[JWS]) or encrypted (making it a\nhttps://tools.ietf.org/html/rfc7516[JWE]).  This adds a powerful layer of verifiability to the JWT - a\nJWS or JWE recipient can have a high degree of confidence it comes from someone they trust\nby verifying a signature or decrypting it. It is this feature of verifiability that makes JWT a good choice\nfor sending and receiving secure information, like identity claims.\n\nFinally, JSON with whitespace for human readability is nice, but it doesn't make for a very efficient message\nformat.  Therefore, JWTs can be _compacted_ (and even compressed) to a minimal representation - basically\nBase64URL-encoded strings - so they can be transmitted around the web more efficiently, such as in HTTP headers or URLs.\n\n+++<a name=\"overview-example-jwt\">++++++</a>+++\n\n=== JWT Example\n\nOnce you have a `payload` and `header`, how are they compacted for web transmission, and what does the final JWT\nactually look like? Let's walk through a simplified version of the process with some pseudocode:\n\n. Assume we have a JWT with a JSON `header` and a simple text message payload:\n+\n*header*\n+\n----\n{\n  \"alg\": \"none\"\n}\n----\n+\n*payload*\n+\n----\nThe true sign of intelligence is not knowledge but imagination.\n----\n\n. Remove all unnecessary whitespace in the JSON:\n+\n[,groovy]\n----\nString header = '{\"alg\":\"none\"}'\nString payload = 'The true sign of intelligence is not knowledge but imagination.'\n----\n\n. Get the UTF-8 bytes and Base64URL-encode each:\n+\n[,groovy]\n----\nString encodedHeader = base64URLEncode( header.getBytes(\"UTF-8\") )\nString encodedPayload = base64URLEncode( payload.getBytes(\"UTF-8\") )\n----\n\n. Join the encoded header and claims with period ('.') characters:\n+\n[,groovy]\n----\nString compact = encodedHeader + '.' + encodedPayload + '.'\n----\n\nThe final concatenated `compact` JWT String looks like this:\n\n----\neyJhbGciOiJub25lIn0.VGhlIHRydWUgc2lnbiBvZiBpbnRlbGxpZ2VuY2UgaXMgbm90IGtub3dsZWRnZSBidXQgaW1hZ2luYXRpb24u.\n----\n\nThis is called an 'unprotected' JWT because no security was involved - no digital signatures or encryption to\n'protect' the JWT to ensure it cannot be changed by 3rd parties.\n\nIf we wanted to digitally sign the compact form so that we could at least guarantee that no-one changes the data\nwithout us detecting it, we'd have to perform a few more steps, shown next.\n\n+++<a name=\"overview-example-jws\">++++++</a>+++\n\n=== JWS Example\n\nInstead of a plain text payload, the next example will use probably the most common type of payload - a JSON claims\n`Object` containing information about a particular identity.  We'll also digitally sign the JWT to ensure it\ncannot be changed by a 3rd party without us knowing.\n\n. Assume we have a JSON `header` and a claims `payload`:\n+\n*header*\n+\n[,json]\n----\n{\n  \"alg\": \"HS256\"\n}\n----\n+\n*payload*\n+\n[,json]\n----\n{\n  \"sub\": \"Joe\"\n}\n----\n+\nIn this case, the `header` indicates that the `HS256` (HMAC using SHA-256) algorithm will be used to cryptographically sign\nthe JWT. Also, the `payload` JSON object has a single claim, `sub` with value `Joe`.\n+\nThere are a number of standard claims, called https://tools.ietf.org/html/rfc7519#section-4.1[Registered Claims],\nin the specification and `sub` (for 'Subject') is one of them.\n\n. Remove all unnecessary whitespace in both JSON objects:\n+\n[,groovy]\n----\nString header = '{\"alg\":\"HS256\"}'\nString claims = '{\"sub\":\"Joe\"}'\n----\n\n. Get their UTF-8 bytes and Base64URL-encode each:\n+\n[,groovy]\n----\nString encodedHeader = base64URLEncode( header.getBytes(\"UTF-8\") )\nString encodedClaims = base64URLEncode( claims.getBytes(\"UTF-8\") )\n----\n\n. Concatenate the encoded header and claims with a period character '.' delimiter:\n+\n[,groovy]\n----\nString concatenated = encodedHeader + '.' + encodedClaims\n----\n\n. Use a sufficiently-strong cryptographic secret or private key, along with a signing algorithm of your choice\n (we'll use HMAC-SHA-256 here), and sign the concatenated string:\n+\n[,groovy]\n----\n SecretKey key = getMySecretKey()\n byte[] signature = hmacSha256( concatenated, key )\n----\n\n. Because signatures are always byte arrays, Base64URL-encode the signature and join it to the `concatenated` string\nwith a period character '.' delimiter:\n+\n[,groovy]\n----\nString compact = concatenated + '.' + base64URLEncode( signature )\n----\n\nAnd there you have it, the final `compact` String looks like this:\n\n----\neyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJKb2UifQ.1KP0SsvENi7Uz1oQc07aXTL7kpQG5jBNIybqr60AlD4\n----\n\nThis is called a 'JWS' - short for _signed_ JWT.\n\nOf course, no one would want to do this manually in code, and worse, if you get anything wrong, you could introduce\nserious security problems and weaknesses.  As a result, JJWT was created to handle all of this for you: JJWT completely\nautomates both the creation of JWSs and the parsing and verification of JWSs for you.\n\n+++<a name=\"overview-example-jwe\">++++++</a>+++\n\n=== JWE Example\n\nSo far we have seen an unprotected JWT and a cryptographically signed JWT (called a 'JWS').  One of the things\nthat is inherent to both of these two is that all the information within them can be seen by anyone - all the data in\nboth the header and the payload is publicly visible.  JWS just ensures the data hasn't been changed by anyone -\nit doesn't prevent anyone from seeing it.  Many times, this is just fine because the data within them is not\nsensitive information.\n\nBut what if you needed to represent information in a JWT that _is_ considered sensitive information - maybe someone's\npostal address or social security number or bank account number?\n\nIn these cases, we'd want a fully-encrypted JWT, called a 'JWE' for short.  A JWE uses cryptography to ensure that the\npayload remains fully encrypted _and_ authenticated so unauthorized parties cannot see data within, nor change the data\nwithout being detected.  Specifically, the JWE specification requires that\nhttps://en.wikipedia.org/wiki/Authenticated_encryption#Authenticated_encryption_with_associated_data_(AEAD)[Authenticated Encryption with Associated Data]\nalgorithms are used to fully encrypt and protect data.\n\nA full overview of AEAD algorithms are out of scope for this documentation, but here's an example of a final compact\nJWE that utilizes these algorithms (line breaks are for readability only):\n\n----\neyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\n6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\nAxY8DCtDaGlsbGljb3RoZQ.\nKDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\nU0m_YmjN04DJvceFICbCVQ\n----\n\nNext we'll cover how to install JJWT in your project, and then we'll see how to use JJWT's nice fluent API instead\nof risky string manipulation to quickly and safely build JWTs, JWSs, and JWEs.\n\n+++<a name=\"install\">++++++</a>+++\n\n== Installation\n\nUse your favorite Maven-compatible build tool to pull the dependencies from Maven Central.\n\nThe dependencies could differ slightly if you are working with a <<install-jdk,JDK project>> or an\n<<install-android,Android project>>.\n\n+++<a name=\"install-jdk\">++++++</a>+++\n\n=== JDK Projects\n\nIf you're building a (non-Android) JDK project, you will want to define the following dependencies:\n\n+++<a name=\"install-jdk-maven\">++++++</a>+++\n\n==== Maven\n\n[,xml,subs=\"+attributes\"]\n----\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-api</artifactId>\n    <version>{project-version}</version>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-impl</artifactId>\n    <version>{project-version}</version>\n    <scope>runtime</scope>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-jackson</artifactId> <!-- or jjwt-gson if Gson is preferred -->\n    <version>{project-version}</version>\n    <scope>runtime</scope>\n</dependency>\n<!-- Uncomment this next dependency if you are using:\n     - JDK 10 or earlier, and you want to use RSASSA-PSS (PS256, PS384, PS512) signature algorithms.\n     - JDK 10 or earlier, and you want to use EdECDH (X25519 or X448) Elliptic Curve Diffie-Hellman encryption.\n     - JDK 14 or earlier, and you want to use EdDSA (Ed25519 or Ed448) Elliptic Curve signature algorithms.\n     It is unnecessary for these algorithms on JDK 15 or later.\n<dependency>\n    <groupId>org.bouncycastle</groupId>\n    <artifactId>bcprov-jdk18on</artifactId> or bcprov-jdk15to18 on JDK 7\n    <version>1.76</version>\n    <scope>runtime</scope>\n</dependency>\n-->\n----\n\n+++<a name=\"install-jdk-gradle\">++++++</a>+++\n\n==== Gradle\n\n[,groovy,subs=\"+attributes\"]\n----\ndependencies {\n    implementation 'io.jsonwebtoken:jjwt-api:{project-version}'\n    runtimeOnly 'io.jsonwebtoken:jjwt-impl:{project-version}'\n    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:{project-version}' // or 'io.jsonwebtoken:jjwt-gson:{project-version}' for gson\n    /*\n      Uncomment this next dependency if you are using:\n       - JDK 10 or earlier, and you want to use RSASSA-PSS (PS256, PS384, PS512) signature algorithms.\n       - JDK 10 or earlier, and you want to use EdECDH (X25519 or X448) Elliptic Curve Diffie-Hellman encryption.\n       - JDK 14 or earlier, and you want to use EdDSA (Ed25519 or Ed448) Elliptic Curve signature algorithms.\n      It is unnecessary for these algorithms on JDK 15 or later.\n    */\n    // runtimeOnly 'org.bouncycastle:bcprov-jdk18on:1.76' // or bcprov-jdk15to18 on JDK 7\n}\n----\n\n+++<a name=\"install-android\">++++++</a>+++\n\n=== Android Projects\n\nAndroid projects will want to define the following dependencies and Proguard exclusions, and optional\nBouncyCastle `Provider`:\n\n+++<a name=\"install-android-dependencies\">++++++</a>+++\n\n==== Dependencies\n\nAdd the dependencies to your project:\n\n[,groovy,subs=\"+attributes\"]\n----\ndependencies {\n    api('io.jsonwebtoken:jjwt-api:{project-version}')\n    runtimeOnly('io.jsonwebtoken:jjwt-impl:{project-version}')\n    runtimeOnly('io.jsonwebtoken:jjwt-orgjson:{project-version}') {\n        exclude(group: 'org.json', module: 'json') //provided by Android natively\n    }\n    /*\n      Uncomment this next dependency if you want to use:\n       - RSASSA-PSS (PS256, PS384, PS512) signature algorithms.\n       - EdECDH (X25519 or X448) Elliptic Curve Diffie-Hellman encryption.\n       - EdDSA (Ed25519 or Ed448) Elliptic Curve signature algorithms.\n      ** AND ALSO ensure you enable the BouncyCastle provider as shown below **\n    */\n    //implementation('org.bouncycastle:bcprov-jdk18on:1.76') // or bcprov-jdk15to18 for JDK 7\n}\n----\n\n+++<a name=\"install-android-proguard\">++++++</a>+++\n\n==== Proguard\n\nYou can use the following https://developer.android.com/studio/build/shrink-code[Android Proguard] exclusion rules:\n\n----\n-keepattributes InnerClasses\n\n-keep class io.jsonwebtoken.** { *; }\n-keepnames class io.jsonwebtoken.* { *; }\n-keepnames interface io.jsonwebtoken.* { *; }\n\n-keep class org.bouncycastle.** { *; }\n-keepnames class org.bouncycastle.** { *; }\n-dontwarn org.bouncycastle.**\n----\n\n+++<a name=\"install-android-bc\">++++++</a>+++\n\n==== Bouncy Castle\n\nIf you want to use JWT RSASSA-PSS algorithms (i.e. `PS256`, `PS384`, and `PS512`), EdECDH (`X25512` or `X448`)\nElliptic Curve Diffie-Hellman encryption, EdDSA (`Ed25519` or `Ed448`) signature algorithms, or you just want to\nensure your Android application is running an updated version of BouncyCastle, you will need to:\n\n. Uncomment the BouncyCastle dependency as commented above in the <<install-android-dependencies,dependencies>> section.\n. Replace the legacy Android custom `BC` provider with the updated one.\n\nProvider registration needs to be done _early_ in the application's lifecycle, preferably in your application's\nmain `Activity` class as a static initialization block.  For example:\n\n[,kotlin]\n----\nclass MainActivity : AppCompatActivity() {\n\n    companion object {\n        init {\n            Security.removeProvider(\"BC\") //remove old/legacy Android-provided BC provider\n            Security.addProvider(BouncyCastleProvider()) // add 'real'/correct BC provider\n        }\n    }\n\n    // ... etc ...\n}\n----\n\n+++<a name=\"install-understandingdependencies\">++++++</a>+++\n\n=== Understanding JJWT Dependencies\n\nNotice the above JJWT dependency declarations all have only one compile-time dependency and the rest are declared as\n_runtime_ dependencies.\n\nThis is because JJWT is designed so you only depend on the APIs that are explicitly designed for you to use in\nyour applications and all other internal implementation details - that can change without warning - are relegated to\nruntime-only dependencies.  This is an extremely important point if you want to ensure stable JJWT usage and\nupgrades over time:\n\n[WARNING]\n====\nJJWT guarantees semantic versioning compatibility for all of its artifacts _except_ the `jjwt-impl` .jar.  No such\nguarantee is made for the `jjwt-impl` .jar and internal changes in that .jar can happen at any time.  Never add the\n`jjwt-impl` .jar to your project with `compile` scope - always declare it with `runtime` scope.\n====\n\nThis is done to benefit you: great care goes into curating the `jjwt-api` .jar and ensuring it contains what you need\nand remains backwards compatible as much as is possible so you can depend on that safely with compile scope.  The\nruntime `jjwt-impl` .jar strategy affords the JJWT developers the flexibility to change the internal packages and\nimplementations whenever and however necessary.  This helps us implement features, fix bugs, and ship new releases to\nyou more quickly and efficiently.\n\n+++<a name=\"quickstart\">++++++</a>+++\n\n== Quickstart\n\nMost complexity is hidden behind a convenient and readable builder-based\nhttp://en.wikipedia.org/wiki/Fluent_interface[fluent interface], great for relying on IDE auto-completion to write\ncode quickly.  Here's an example:\n\n[,java]\n----\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.security.Keys;\nimport java.security.Key;\n\n// We need a signing key, so we'll create one just for this example. Usually\n// the key would be read from your application configuration instead.\nSecretKey key = Jwts.SIG.HS256.key().build();\n\nString jws = Jwts.builder().subject(\"Joe\").signWith(key).compact();\n----\n\nHow easy was that!?\n\nIn this case, we are:\n\n. _building_ a JWT that will have the\nhttps://tools.ietf.org/html/rfc7519#section-4.1[registered claim] `sub` (Subject) set to `Joe`. We are then\n. _signing_ the JWT using a key suitable for the HMAC-SHA-256 algorithm.  Finally, we are\n. _compacting_ it into its final `String` form.  A signed JWT is called a 'JWS'.\n\nThe resultant `jws` String looks like this:\n\n----\neyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJKb2UifQ.1KP0SsvENi7Uz1oQc07aXTL7kpQG5jBNIybqr60AlD4\n----\n\nNow let's verify the JWT (you should always discard JWTs that don't match an expected signature):\n\n[,java]\n----\nassert Jwts.parser().verifyWith(key).build().parseSignedClaims(jws).getPayload().getSubject().equals(\"Joe\");\n----\n\nThere are two things going on here. The `key` from before is being used to verify the signature of the JWT. If it\nfails to verify the JWT, a `SignatureException` (which extends `JwtException`) is thrown. Assuming the JWT is\nverified, we parse the claims and assert that that subject is set to `Joe`.  You have to love code one-liners\nthat pack a punch!\n\n[NOTE]\n====\n*Type-safe JWTs:* To get a type-safe `Claims` JWT result, call the `parseSignedClaims` method (since there are many\nsimilar methods available). You will get an `UnsupportedJwtException` if you parse your JWT with wrong method.\n====\n\nBut what if parsing or signature validation failed?  You can catch `JwtException` and react accordingly:\n\n[,java]\n----\ntry {\n\n    Jwts.parser().verifyWith(key).build().parseSignedClaims(compactJws);\n\n    //OK, we can trust this JWT\n\n} catch (JwtException e) {\n\n    //don't trust the JWT!\n}\n----\n\nNow that we've had a quickstart 'taste' of how to create and parse JWTs, let's cover JJWT's API in-depth.\n\n+++<a name=\"jwt-create\">++++++</a>+++\n\n== Creating a JWT\n\nYou create a JWT as follows:\n\n. Use the `Jwts.builder()` method to create a `JwtBuilder` instance.\n. Optionally set any <<jwt-header,`header` parameters>> as desired.\n. Call builder methods to set the payload <<jwt-content,content>> or <<jwt-claims,claims>>.\n. Optionally call `signWith` or `encryptWith` methods if you want to digitally sign or encrypt the JWT.\n. Call the `compact()` method to produce the resulting compact JWT string.\n\nFor example:\n\n[,java]\n----\nString jwt = Jwts.builder()                     // (1)\n\n    .header()                                   // (2) optional\n        .keyId(\"aKeyId\")\n        .and()\n\n    .subject(\"Bob\")                             // (3) JSON Claims, or\n    //.content(aByteArray, \"text/plain\")        //     any byte[] content, with media type\n\n    .signWith(signingKey)                       // (4) if signing, or\n    //.encryptWith(key, keyAlg, encryptionAlg)  //     if encrypting\n\n    .compact();                                 // (5)\n----\n\n* The JWT `payload` may be either `byte[]` content (via `content`) _or_ JSON Claims\n(such as `subject`, `claims`, etc), but not both.\n* Either digital signatures (`signWith`) or encryption (`encryptWith`) may be used, but not both.\n\n[WARNING]\n====\n*Unprotected JWTs*: If you do not use the `signWith` or `encryptWith` builder methods, *an Unprotected JWT will be\ncreated, which offers no security protection at all*.  If you need security protection, consider either\n<<jws,digitally signing>> or <<jwe,encrypting>> the JWT before calling the `compact()` builder method.\n====\n\n+++<a name=\"jwt-header\">++++++</a>++++++<a name=\"jws-create-header\">++++++</a>+++\n// legacy anchors for old links\n\n=== JWT Header\n\nA JWT header is a JSON `Object` that provides metadata about the contents, format, and any cryptographic operations\nrelevant to the JWT `payload`.  JJWT provides a number of ways of setting the entire header and/or multiple individual\nheader parameters (name/value pairs).\n\n+++<a name=\"jwt-header-builder\">++++++</a>++++++<a name=\"jws-create-header-instance\">++++++</a>+++\n// legacy anchors for old links\n\n==== JwtBuilder Header\n\nThe easiest and recommended way to set one or more JWT header parameters (name/value pairs) is to use the\n``JwtBuilder``'s `header()` builder as desired, and then call its `and()` method to return back\nto the `JwtBuilder` for further configuration. For example:\n\n[,java]\n----\nString jwt = Jwts.builder()\n\n    .header()                        // <----\n        .keyId(\"aKeyId\")\n        .x509Url(aUri)\n        .add(\"someName\", anyValue)\n        .add(mapValues)\n        // ... etc ...\n        .and()                      // go back to the JwtBuilder\n\n    .subject(\"Joe\")                 // resume JwtBuilder calls...\n    // ... etc ...\n    .compact();\n----\n\nThe `JwtBuilder` `header()` builder also supports automatically calculating X.509 thumbprints and other builder-style benefits that\na simple property getter/setter object would not do.\n\n[NOTE]\n====\n*Automatic Headers*: You do not need to set the `alg`, `enc` or `zip` headers - JJWT will always set them\nautomatically as needed.\n====\n\n+++<a name=\"jwt-header-params\">++++++</a>+++\n\n===== Custom Header Parameters\n\nIn addition to type-safe builder methods for standard header parameters, `JwtBuilder.header()` can also support\narbitrary name/value pairs via the `add` method:\n\n[,java]\n----\nJwts.builder()\n\n    .header()\n        .add(\"aHeaderName\", aValue)\n        // ... etc ...\n        .and() // return to the JwtBuilder\n\n// ... etc ...\n----\n\n+++<a name=\"jwt-header-map\">++++++</a>++++++<a name=\"jws-create-header-map\">++++++</a>+++\n// legacy anchors for old links\n\n===== Header Parameter Map\n\nThe `add` method is also overloaded to support multiple parameters in a `Map`:\n\n[,java]\n----\nJwts.builder()\n\n    .header()\n        .add(multipleHeaderParamsMap)\n        // ... etc ...\n        .and() // return to the JwtBuilder\n\n// ... etc ...\n----\n\n==== Jwts HeaderBuilder\n\nUsing `Jwts.builder().header()` shown above is the preferred way to modify a header when using the `JwtBuilder`.\n\nHowever, if you would like to create a 'standalone' `Header` outside of the context of using the `JwtBuilder`, you\ncan use `Jwts.header()` instead to return an independent `Header` builder.  For example:\n\n[,java]\n----\nHeader header = Jwts.header()\n\n        .keyId(\"aKeyId\")\n        .x509Url(aUri)\n        .add(\"someName\", anyValue)\n        .add(mapValues)\n        // ... etc ...\n\n        .build()  // <---- not 'and()'\n----\n\nThere are only two differences between `Jwts.header()` and `Jwts.builder().header()`:\n\n. `Jwts.header()` builds a 'detached' `Header` that is not associated with any particular JWT, whereas\n`Jwts.builder().header()` always modifies the header of the immediate JWT being constructed by its parent\n`JwtBuilder`.\n. `Jwts.header()` has a `build()` method to produce an explicit `Header` instance and\n`Jwts.builder().header()` does not (it has an `and()` method instead) because its parent `JwtBuilder` will implicitly\ncreate the header instance when necessary.\n\nA standalone header might be useful if you want to aggregate common header parameters in a single 'template'\ninstance so you don't have to repeat them for each `JwtBuilder` usage.  Then this 'template' `Header` can be used to\npopulate `JwtBuilder` usages by just appending it to the `JwtBuilder` header, for example:\n\n[,java]\n----\n// perhaps somewhere in application configuration:\nHeader commonHeaders = Jwts.header()\n    .issuer(\"My Company\")\n    // ... etc ...\n    .build();\n\n// --------------------------------\n\n// somewhere else during actual Jwt construction:\nString jwt = Jwts.builder()\n\n    .header()\n        .add(commonHeaders)                   // <----\n        .add(\"specificHeader\", specificValue) // jwt-specific headers...\n        .and()\n\n    .subject(\"whatever\")\n    // ... etc ...\n    .compact();\n----\n\n+++<a name=\"jwt-payload\">++++++</a>+++\n\n=== JWT Payload\n\nA JWT `payload` can be anything at all - anything that can be represented as a byte array, such as text, images,\ndocuments, and more.  But since a JWT `header` is always JSON, it makes sense that the `payload` could also be JSON,\nespecially for representing identity claims.\n\nAs a result, the `JwtBuilder` supports two distinct payload options:\n\n* `content` if you would like the payload to be arbitrary byte array content, or\n* `claims` (and supporting helper methods) if you would like the payload to be a JSON Claims `Object`.\n\nEither option may be used, but not both. Using both will cause `compact()` to throw an exception.\n\n+++<a name=\"jwt-content\">++++++</a>+++\n\n==== Arbitrary Content\n\nYou can set the JWT payload to be any arbitrary byte array content by using the `JwtBuilder` `content` method.\nFor example:\n\n[,java]\n----\nbyte[] content = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n\nString jwt = Jwts.builder()\n\n    .content(content, \"text/plain\") // <---\n\n    // ... etc ...\n\n    .build();\n----\n\nNotice this particular example of `content` uses the two-argument convenience variant:\n\n. The first argument is the actual byte content to set as the JWT payload\n. The second argument is a String identifier of an IANA Media Type.\n\nThe second argument will cause the `JwtBuilder` to automatically set the `cty` (Content Type) header according to the\nJWT specification's https://www.rfc-editor.org/rfc/rfc7515.html#section-4.1.10[recommended compact format].\n\nThis two-argument variant is typically recommended over the single-argument `content(byte[])` method because it\nguarantees the JWT recipient can inspect the `cty` header to determine how to convert the `payload` byte array into\na final form that the application can use.\n\nWithout setting the `cty` header, the JWT recipient _must_ know via out-of-band (external) information how to process\nthe byte array, which is usually less convenient and always requires code changes if the content format ever changes.\nFor these reasons, it is strongly recommended to use the two-argument `content` method variant.\n\n+++<a name=\"jwt-claims\">++++++</a>++++++<a name=\"jws-create-claims\">++++++</a>+++\n// legacy anchors for old links\n\n==== JWT Claims\n\nInstead of a content byte array, a JWT payload may contain assertions or claims for a JWT recipient. In\nthis case, the payload is a `Claims` JSON `Object`, and JJWT supports claims creation with type-safe\nbuilder methods.\n\n+++<a name=\"jwt-claims-standard\">++++++</a>++++++<a name=\"jws-create-claims-standard\">++++++</a>+++\n// legacy anchors for old links\n\n===== Standard Claims\n\nThe `JwtBuilder` provides convenient builder methods for standard registered Claim names defined in the JWT\nspecification.  They are:\n\n* `issuer`: sets the https://tools.ietf.org/html/rfc7519#section-4.1.1[`iss` (Issuer) Claim]\n* `subject`: sets the https://tools.ietf.org/html/rfc7519#section-4.1.2[`sub` (Subject) Claim]\n* `audience`: sets the https://tools.ietf.org/html/rfc7519#section-4.1.3[`aud` (Audience) Claim]\n* `expiration`: sets the https://tools.ietf.org/html/rfc7519#section-4.1.4[`exp` (Expiration Time) Claim]\n* `notBefore`: sets the https://tools.ietf.org/html/rfc7519#section-4.1.5[`nbf` (Not Before) Claim]\n* `issuedAt`: sets the https://tools.ietf.org/html/rfc7519#section-4.1.6[`iat` (Issued At) Claim]\n* `id`: sets the https://tools.ietf.org/html/rfc7519#section-4.1.7[`jti` (JWT ID) Claim]\n\nFor example:\n\n[,java]\n----\n\nString jws = Jwts.builder()\n\n    .issuer(\"me\")\n    .subject(\"Bob\")\n    .audience().add(\"you\").and()\n    .expiration(expiration) //a java.util.Date\n    .notBefore(notBefore) //a java.util.Date\n    .issuedAt(new Date()) // for example, now\n    .id(UUID.randomUUID().toString()) //just an example id\n\n    /// ... etc ...\n----\n\n+++<a name=\"jwt-claims-custom\">++++++</a>++++++<a name=\"jws-create-claims-custom\">++++++</a>+++\n// legacy anchors for old links\n\n===== Custom Claims\n\nIf you need to set one or more custom claims that don't match the standard setter method claims shown above, you\ncan simply call the `JwtBuilder` `claim` method one or more times as needed:\n\n[,java]\n----\nString jws = Jwts.builder()\n\n    .claim(\"hello\", \"world\")\n\n    // ... etc ...\n----\n\nEach time `claim` is called, it simply appends the key-value pair to an internal `Claims` builder, potentially\noverwriting any existing identically-named key/value pair.\n\nObviously, you do not need to call `claim` for any <<jws-create-claims-standard,standard claim name>>, and it is\nrecommended instead to call the standard respective type-safe named builder method as this enhances readability.\n\n+++<a name=\"jws-create-claims-instance\">++++++</a>+++\n// legacy anchors for old links\n+++<a name=\"jwt-claims-instance\">++++++</a>+++\n+++<a name=\"jwt-claims-map\">++++++</a>++++++<a name=\"jws-create-claims-map\">++++++</a>+++\n// legacy anchors for old links\n\n===== Claims Map\n\nIf you want to add multiple claims at once, you can use `JwtBuilder` `claims(Map)` method:\n\n[,java]\n----\n\nMap<String,?> claims = getMyClaimsMap(); //implement me\n\nString jws = Jwts.builder()\n\n    .claims(claims)\n\n    // ... etc ...\n----\n\n+++<a name=\"jwt-compression\">++++++</a>++++++<a name=\"jws-create-compression\">++++++</a>+++\n// legacy anchors for old links\n\n=== JWT Compression\n\nIf your JWT payload is large (contains a lot of data), you might want to compress the JWT to reduce its size.  Note\nthat this is _not_ a standard feature for all JWTs - only JWEs - and is not likely to be supported by other JWT\nlibraries for non-JWE tokens.  JJWT supports compression for both JWSs and JWEs, however.\n\nPlease see the main <<compression,Compression>> section to see how to compress and decompress JWTs.\n\n+++<a name=\"jwt-read\">++++++</a>+++\n\n== Reading a JWT\n\nYou read (parse) a JWT as follows:\n\n. Use the `Jwts.parser()` method to create a `JwtParserBuilder` instance.\n. Optionally call `keyLocator`, `verifyWith` or `decryptWith` methods if you expect to parse <<jws,signed>> or <<jwe,encrypted>> JWTs.\n. Call the `build()` method on the `JwtParserBuilder` to create and return a thread-safe `JwtParser`.\n. Call one of the various `parse*` methods with your compact JWT string, depending on the type of JWT you expect.\n. Wrap the `parse*` call in a try/catch block in case parsing, signature verification, or decryption fails.\n\nFor example:\n\n[,java]\n----\nJwt<?,?> jwt;\n\ntry {\n    jwt = Jwts.parser()     // (1)\n\n    .keyLocator(keyLocator) // (2) dynamically locate signing or encryption keys\n    //.verifyWith(key)      //     or a constant key used to verify all signed JWTs\n    //.decryptWith(key)     //     or a constant key used to decrypt all encrypted JWTs\n\n    .build()                // (3)\n\n    .parse(compact);        // (4) or parseSignedClaims, parseEncryptedClaims, parseSignedContent, etc\n\n    // we can safely trust the JWT\n\ncatch (JwtException ex) {   // (5)\n\n    // we *cannot* use the JWT as intended by its creator\n}\n----\n\n[NOTE]\n====\n*Type-safe JWTs:* If you are certain your parser will only ever encounter a specific kind of JWT (for example, you only\never use signed JWTs with `Claims` payloads, or encrypted JWTs with `byte[]` content payloads, etc), you can call the\nassociated type-safe `parseSignedClaims`, `parseEncryptedClaims`, (etc) method variant instead of the generic `parse` method.\n\nThese `parse*` methods will return the type-safe JWT you are expecting, for example, a `Jws<Claims>` or `Jwe<byte[]>`\ninstead of a generic `Jwt<?,?>` instance.\n====\n\n+++<a name=\"jwt-read-key\">++++++</a>+++\n\n=== Constant Parsing Key\n\nIf the JWT parsed is a JWS or JWE, a key will be necessary to verify the signature or decrypt it.  If a JWS and\nsignature verification fails, or if a JWE and decryption fails, the JWT cannot be safely trusted and should be\ndiscarded.\n\nSo which key do we use?\n\n* If parsing a JWS and the JWS was signed with a `SecretKey`, the same `SecretKey` should be specified on the\n`JwtParserBuilder`.  For example:\n+\n[,java]\n----\nJwts.parser()\n\n  .verifyWith(secretKey) // <----\n\n  .build()\n  .parseSignedClaims(jwsString);\n----\n\n* If parsing a JWS and the JWS was signed with a `PrivateKey`, that key's corresponding `PublicKey` (not the\n`PrivateKey`) should be specified on the `JwtParserBuilder`.  For example:\n+\n[,java]\n----\nJwts.parser()\n\n  .verifyWith(publicKey) // <---- publicKey, not privateKey\n\n  .build()\n  .parseSignedClaims(jwsString);\n----\n\n* If parsing a JWE and the JWE was encrypted with direct encryption using a `SecretKey`, the same `SecretKey` should be\nspecified on the `JwtParserBuilder`. For example:\n+\n[,java]\n----\nJwts.parser()\n\n  .decryptWith(secretKey) // <---- or a Password from Keys.password(charArray)\n\n  .build()\n  .parseEncryptedClaims(jweString);\n----\n\n* If parsing a JWE and the JWE was encrypted with a key algorithm using with a `PublicKey`, that key's corresponding\n`PrivateKey` (not the `PublicKey`) should be specified on the `JwtParserBuilder`.  For example:\n+\n[,java]\n----\nJwts.parser()\n\n  .decryptWith(privateKey) // <---- privateKey, not publicKey\n\n  .build()\n  .parseEncryptedClaims(jweString);\n----\n\n==== Multiple Keys?\n\nBut you might have noticed something - what if your application doesn't use just a single `SecretKey` or `KeyPair`? What\nif JWSs and JWEs can be created with different ``SecretKey``s or public/private keys, or a combination of both?  How do\nyou know which key to specify if you don't inspect the JWT first?\n\nIn these cases, you can't call the ``JwtParserBuilder``'s `verifyWith` or `decryptWith` methods with a single key -\ninstead, you'll need to configure a parsing Key Locator, discussed next.\n\n+++<a name=\"key-locator\">++++++</a>+++\n\n=== Dynamic Key Lookup\n\nIt is common in many applications to receive JWTs that can be encrypted or signed by different cryptographic keys.  For\nexample, maybe a JWT created to assert a specific user identity uses a Key specific to that exact user. Or perhaps JWTs\nspecific to a particular customer all use that customer's Key.  Or maybe your application creates JWTs that are\nencrypted with a key specific to your application for your own use (e.g. a user session token).\n\nIn all of these and similar scenarios, you won't know which key was used to sign or encrypt a JWT until the JWT is\nreceived, at parse time, so you can't 'hard code' any verification or decryption key using the ``JwtParserBuilder``'s\n`verifyWith` or `decryptWith` methods.  Those are only to be used when the same key is used to verify or decrypt\n_all_ JWSs or JWEs, which won't work for dynamically signed or encrypted JWTs.\n\n+++<a name=\"key-locator-custom\">++++++</a>+++\n\n==== Key Locator\n\nIf you need to support dynamic key lookup when encountering JWTs, you'll need to implement\nthe `Locator<Key>` interface and specify an instance on the `JwtParserBuilder` via the `keyLocator` method. For\nexample:\n\n[,java]\n----\nLocator<Key> keyLocator = getMyKeyLocator();\n\nJwts.parser()\n\n    .keyLocator(keyLocator) // <----\n\n    .build()\n    // ... etc ...\n----\n\nA `Locator<Key>` is used to lookup _both_ JWS signature verification keys _and_ JWE decryption keys.  You need to\ndetermine which key to return based on information in the JWT `header`, for example:\n\n[,java]\n----\npublic class MyKeyLocator extends LocatorAdapter<Key> {\n\n    @Override\n    public Key locate(ProtectedHeader<?> header) { // a JwsHeader or JweHeader\n        // implement me\n    }\n}\n----\n\nThe `JwtParser` will invoke the `locate` method after parsing the JWT `header`, but _before parsing the `payload`,\nor verifying any JWS signature or decrypting any JWE ciphertext_. This allows you to inspect the `header` argument\nfor any information that can help you look up the `Key` to use for verifying _that specific jwt_.  This is very\npowerful for applications with more complex security models that might use different keys at different times or for\ndifferent users or customers.\n\n+++<a name=\"key-locator-strategy\">++++++</a>+++\n\n==== Key Locator Strategy\n\nWhat data might you inspect to determine how to lookup a signature verification or decryption key?\n\nThe JWT specifications' preferred approach is to set a `kid` (Key ID) header value when the JWT is being created,\nfor example:\n\n[,java]\n----\nKey key = getSigningKey(); // or getEncryptionKey() for JWE\n\nString keyId = getKeyId(key); //any mechanism you have to associate a key with an ID is fine\n\nString jws = Jwts.builder()\n\n    .header().keyId(keyId).and()               // <--- add `kid` header\n\n    .signWith(key)                             // for JWS\n    //.encryptWith(key, keyAlg, encryptionAlg) // for JWE\n    .compact();\n----\n\nThen during parsing, your `Locator<Key>` implementation can inspect the `header` to get the `kid` value and then use it\nto look up the verification or decryption key from somewhere, like a database, keystore or Hardware Security Module\n(HSM).  For example:\n\n[,java]\n----\npublic class MyKeyLocator extends LocatorAdapter<Key> {\n\n    @Override\n    public Key locate(ProtectedHeader<?> header) { // both JwsHeader and JweHeader extend ProtectedHeader\n\n        //inspect the header, lookup and return the verification key\n        String keyId = header.getKeyId(); //or any other parameter that you need to inspect\n\n        Key key = lookupKey(keyId); //implement me\n\n        return key;\n    }\n}\n----\n\nNote that inspecting the `header.getKeyId()` is just the most common approach to look up a key - you could inspect any\nnumber of header parameters to determine how to lookup the verification or decryption key.  It is all based on how\nthe JWT was created.\n\nIf you extend `LocatorAdapter<Key>` as shown above, but for some reason have different lookup strategies for\nsignature verification keys versus decryption keys, you can forego overriding the `locate(ProtectedHeader<?>)` method\nin favor of two respective `locate(JwsHeader)` and `locate(JweHeader)` methods:\n\n[,java]\n----\npublic class MyKeyLocator extends LocatorAdapter<Key> {\n\n    @Override\n    public Key locate(JwsHeader header) {\n        String keyId = header.getKeyId(); //or any other parameter that you need to inspect\n        return lookupSignatureVerificationKey(keyId); //implement me\n    }\n\n    @Override\n    public Key locate(JweHeader header) {\n        String keyId = header.getKeyId(); //or any other parameter// that you need to inspect\n        return lookupDecryptionKey(keyId); //implement me\n    }\n}\n----\n\n[NOTE]\n====\n*Simpler Lookup*: If possible, try to keep the key lookup strategy the same between JWSs and JWEs (i.e. using\nonly `locate(ProtectedHeader<?>)`), preferably using only\nthe `kid` (Key ID) header value or perhaps a public key thumbprint.  You will find the implementation is much\nsimpler and easier to maintain over time, and also creates smaller headers for compact transmission.\n====\n\n+++<a name=\"key-locator-retvals\">++++++</a>+++\n\n==== Key Locator Return Values\n\nRegardless of which implementation strategy you choose, remember to return the appropriate type of key depending\non the type of JWS or JWE algorithm used.  That is:\n\n* For JWS:\n ** For HMAC-based signature algorithms, the returned verification key should be a `SecretKey`, and,\n ** For asymmetric signature algorithms, the returned verification key should be a `PublicKey` (not a `PrivateKey`).\n* For JWE:\n ** For JWE direct encryption, the returned decryption key should be a `SecretKey`.\n ** For password-based key derivation algorithms, the returned decryption key should be a\n`io.jsonwebtoken.security.Password`.  You can create a `Password` instance by calling\n`Keys.password(char[] passwordCharacters)`.\n ** For asymmetric key management algorithms, the returned decryption key should be a `PrivateKey` (not a `PublicKey`).\n\n+++<a name=\"key-locator-provider\">++++++</a>+++\n\n==== Provider-constrained Keys\n\nIf any verification or decryption key returned from a Key `Locator` must be used with a specific security `Provider`\n(such as for PKCS11 or Hardware Security Module (HSM) keys), you must make that `Provider` available for JWT parsing\nin one of 3 ways, listed in order of recommendation and simplicity:\n\n. https://docs.oracle.com/en/java/javase/17/security/howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33[Configure the Provider in the JVM],\neither by modifying the `java.security` file or by registering the `Provider` dynamically via\nhttps://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/Security.html#addProvider(java.security.Provider)[Security.addProvider(Provider)].\nThis is the recommended approach so you do not need to modify code anywhere that may need to parse JWTs.\n. Set the `Provider` as the parser default by calling `JwtParserBuilder#provider(Provider)`.  This will\nensure the provider is used by default with _all_ located keys unless overridden by a key-specific Provider. This\nis only recommended when you are confident that all JWTs encountered by the parser instance will use keys\nattributed to the same `Provider`, unless overridden by a specific key.\n. Associate the `Provider` with a specific key using `Keys.builder` so it is used for that key only.  This option is\nuseful if some located keys require a specific provider, while other located keys can assume a default provider. For\nexample:\n+\n[,java]\n----\npublic Key locate(Header<?> header) {\n\n    PrivateKey /* or SecretKey */ key = findKey(header); // implement me\n\n    Provider keySpecificProvider = findKeyProvider(key); // implement me\n    if (keySpecificProvider != null) {\n        // Ensure the key-specific provider (e.g. for PKCS11 or HSM) will be used\n        // during decryption with the KeyAlgorithm in the JWE 'alg' header\n        return Keys.builder(key).provider(keySpecificProvider).build();\n    }\n\n    // otherwise default provider is fine:\n    return key;\n}\n----\n\n+++<a name=\"jwt-read-claims\">++++++</a>++++++<a name=\"jws-read-claims\">++++++</a>+++\n// legacy anchor for old links\n\n=== Claim Assertions\n\nYou can enforce that the JWT you are parsing conforms to expectations that you require and are important for your\napplication.\n\nFor example, let's say that you require that the JWT you are parsing has a specific `sub` (subject) value,\notherwise you may not trust the token.  You can do that by using one of the various `require`* methods on the\n`JwtParserBuilder`:\n\n[,java]\n----\ntry {\n    Jwts.parser().requireSubject(\"jsmith\")/* etc... */.build().parse(s);\n} catch (InvalidClaimException ice) {\n    // the sub claim was missing or did not have a 'jsmith' value\n}\n----\n\nIf it is important to react to a missing vs an incorrect value, instead of catching `InvalidClaimException`,\nyou can catch either `MissingClaimException` or `IncorrectClaimException`:\n\n[,java]\n----\ntry {\n    Jwts.parser().requireSubject(\"jsmith\")/* etc... */.build().parse(s);\n} catch(MissingClaimException mce) {\n    // the parsed JWT did not have the sub claim\n} catch(IncorrectClaimException ice) {\n    // the parsed JWT had a sub claim, but its value was not equal to 'jsmith'\n}\n----\n\nYou can also require custom claims by using the `require(claimName, requiredValue)` method - for example:\n\n[,java]\n----\ntry {\n    Jwts.parser().require(\"myClaim\", \"myRequiredValue\")/* etc... */.build().parse(s);\n} catch(InvalidClaimException ice) {\n    // the 'myClaim' claim was missing or did not have a 'myRequiredValue' value\n}\n----\n\n(or, again, you could catch either `MissingClaimException` or `IncorrectClaimException` instead).\n\nPlease see the `JwtParserBuilder` class and/or JavaDoc for a full list of the various `require`* methods you may use\nfor claims assertions.\n\n+++<a name=\"jwt-read-clock\">++++++</a>++++++<a name=\"jws-read-clock\">++++++</a>+++\n// legacy anchor for old links\n\n=== Accounting for Clock Skew\n\nWhen parsing a JWT, you might find that `exp` or `nbf` claim assertions fail (throw exceptions) because the clock on\nthe parsing machine is not perfectly in sync with the clock on the machine that created the JWT.  This can cause\nobvious problems since `exp` and `nbf` are time-based assertions, and clock times need to be reliably in sync for shared\nassertions.\n\nYou can account for these differences (usually no more than a few minutes) when parsing using the ``JwtParserBuilder``'s\n`clockSkewSeconds`. For example:\n\n[,java]\n----\nlong seconds = 3 * 60; //3 minutes\n\nJwts.parser()\n\n    .clockSkewSeconds(seconds) // <----\n\n    // ... etc ...\n    .build()\n    .parse(jwt);\n----\n\nThis ensures that minor clock differences between the machines can be ignored. Two or three minutes should be more than\nenough; it would be fairly strange if a production machine's clock was more than 5 minutes difference from most\natomic clocks around the world.\n\n+++<a name=\"jwt-read-clock-custom\">++++++</a>++++++<a name=\"jws-read-clock-custom\">++++++</a>+++\n// legacy anchor for old links\n\n==== Custom Clock Support\n\nIf the above `clockSkewSeconds` isn't sufficient for your needs, the timestamps created\nduring parsing for timestamp comparisons can be obtained via a custom time source.  Call the ``JwtParserBuilder``'s\n`clock` method with an implementation of the `io.jsonwebtoken.Clock` interface.  For example:\n\n[,java]\n----\nClock clock = new MyClock();\n\nJwts.parser().clock(myClock) //... etc ...\n----\n\nThe ``JwtParser``'s default `Clock` implementation simply returns `new Date()` to reflect the time when parsing occurs,\nas most would expect.  However, supplying your own clock could be useful, especially when writing test cases to\nguarantee deterministic behavior.\n\n+++<a name=\"jwt-read-decompression\">++++++</a>+++\n\n=== JWT Decompression\n\nIf you used JJWT to compress a JWT and you used a custom compression algorithm, you will need to tell the\n`JwtParserBuilder` how to resolve your `CompressionAlgorithm` to decompress the JWT.\n\nPlease see the <<compression,Compression>> section below to see how to decompress JWTs during parsing.\n\n+++<a name=\"jws\">++++++</a>+++\n\n== Signed JWTs\n\nThe JWT specification provides for the ability to\nhttps://en.wikipedia.org/wiki/Digital_signature[cryptographically _sign_] a JWT.  Signing a JWT:\n\n. guarantees the JWT was created by someone we know (it is authentic) as well as\n. guarantees that no-one has manipulated or changed the JWT after it was created (its integrity is maintained).\n\nThese two properties - authenticity and integrity - assure us that a JWT contains information we can trust.  If a\nJWT fails authenticity or integrity checks, we should always reject that JWT because we can't trust it.\n\nBut before we dig in to showing you how to create a JWS using JJWT, let's briefly discuss Signature Algorithms and\nKeys, specifically as they relate to the JWT specifications.  Understanding them is critical to being able to create a\nJWS properly.\n\n+++<a name=\"jws-alg\">++++++</a>+++\n\n=== Standard Signature Algorithms\n\nThe JWT specifications identify 13 standard signature algorithms - 3 secret key algorithms and 10 asymmetric\nkey algorithms:\n\n|===\n| Identifier | Signature Algorithm\n\n| `HS256`\n| HMAC using SHA-256\n\n| `HS384`\n| HMAC using SHA-384\n\n| `HS512`\n| HMAC using SHA-512\n\n| `ES256`\n| ECDSA using P-256 and SHA-256\n\n| `ES384`\n| ECDSA using P-384 and SHA-384\n\n| `ES512`\n| ECDSA using P-521 and SHA-512\n\n| `RS256`\n| RSASSA-PKCS-v1_5 using SHA-256\n\n| `RS384`\n| RSASSA-PKCS-v1_5 using SHA-384\n\n| `RS512`\n| RSASSA-PKCS-v1_5 using SHA-512\n\n| `PS256`\n| RSASSA-PSS using SHA-256 and MGF1 with SHA-256^*1*^\n\n| `PS384`\n| RSASSA-PSS using SHA-384 and MGF1 with SHA-384^*1*^\n\n| `PS512`\n| RSASSA-PSS using SHA-512 and MGF1 with SHA-512^*1*^\n\n| `EdDSA`\n| Edwards-Curve Digital Signature Algorithm (EdDSA)^*2*^\n|===\n\n^*1*.{sp}{fn-require-java15-plus}^\n\n^*2*.{sp}{fn-require-java15-plus}^\n\nThese are all represented as constants in the `io.jsonwebtoken.Jwts.SIG` registry class.\n\n+++<a name=\"jws-key\">++++++</a>+++\n\n=== Signature Algorithms Keys\n\nWhat's really important about the above standard signature algorithms - other than their security properties - is that\nthe JWT specification https://tools.ietf.org/html/rfc7518#section-3[RFC 7518, Sections 3.2 through 3.5]\n_requires_ (mandates) that you MUST use keys that are sufficiently strong for a chosen algorithm.\n\nThis means that JJWT - a specification-compliant library - will also enforce that you use sufficiently strong keys\nfor the algorithms you choose.  If you provide a weak key for a given algorithm, JJWT will reject it and throw an\nexception.\n\nThis is not because we want to make your life difficult, we promise! The reason why the JWT specification, and\nconsequently JJWT, mandates key lengths is that the security model of a particular algorithm can completely break\ndown if you don't adhere to the mandatory key properties of the algorithm, effectively having no security at all.  No\none wants completely insecure JWTs, right?  Right!\n\nSo what are the key strength requirements?\n\n+++<a name=\"jws-key-hmacsha\">++++++</a>+++\n\n==== HMAC-SHA\n\nJWT HMAC-SHA signature algorithms `HS256`, `HS384`, and `HS512` require a secret key that is _at least_ as many bits as\nthe algorithm's signature (digest) length per https://tools.ietf.org/html/rfc7518#section-3.2[RFC 7512 Section 3.2].\nThis means:\n\n* `HS256` is HMAC-SHA-256, and that produces digests that are 256 bits (32 bytes) long, so `HS256` _requires_ that you\nuse a secret key that is at least 32 bytes long.\n* `HS384` is HMAC-SHA-384, and that produces digests that are 384 bits (48 bytes) long, so `HS384` _requires_ that you\nuse a secret key that is at least 48 bytes long.\n* `HS512` is HMAC-SHA-512, and that produces digests that are 512 bits (64 bytes) long, so `HS512` _requires_ that you\nuse a secret key that is at least 64 bytes long.\n\n+++<a name=\"jws-key-rsa\">++++++</a>+++\n\n==== RSA\n\nJWT RSA signature algorithms `RS256`, `RS384`, `RS512`, `PS256`, `PS384` and `PS512` all require a minimum key length\n(aka an RSA modulus bit length) of `2048` bits per RFC 7512 Sections\nhttps://tools.ietf.org/html/rfc7518#section-3.3[3.3] and https://tools.ietf.org/html/rfc7518#section-3.5[3.5].\nAnything smaller than this (such as 1024 bits) will be rejected with an `WeakKeyException`.\n\nThat said, in keeping with best practices and increasing key lengths for security longevity, JJWT\nrecommends that you use:\n\n* at least 2048 bit keys with `RS256` and `PS256`\n* at least 3072 bit keys with `RS384` and `PS384`\n* at least 4096 bit keys with `RS512` and `PS512`\n\nThese are only JJWT suggestions and not requirements. JJWT only enforces JWT specification requirements and\nfor any RSA key, the requirement is the RSA key (modulus) length in bits MUST be >= 2048 bits.\n\n+++<a name=\"jws-key-ecdsa\">++++++</a>+++\n\n==== Elliptic Curve\n\nJWT Elliptic Curve signature algorithms `ES256`, `ES384`, and `ES512` all require a key length\n(aka an Elliptic Curve order bit length) equal to the algorithm signature's individual\n`R` and `S` components per https://tools.ietf.org/html/rfc7518#section-3.4[RFC 7512 Section 3.4].  This means:\n\n* `ES256` requires that you use a private key that is exactly 256 bits (32 bytes) long.\n* `ES384` requires that you use a private key that is exactly 384 bits (48 bytes) long.\n* `ES512` requires that you use a private key that is exactly 521 bits (65 or 66 bytes) long (depending on format).\n\n+++<a name=\"jws-key-eddsa\">++++++</a>+++\n\n==== Edwards Curve\n\nThe JWT Edwards Curve signature algorithm `EdDSA` supports two sizes of private and public ``EdECKey``s (these types\nwere introduced in Java 15):\n\n* `Ed25519` algorithm keys must be 256 bits (32 bytes) long and produce signatures 512 bits (64 bytes) long.\n* `Ed448` algorithm keys must be 456 bits (57 bytes) long and produce signatures 912 bits (114 bytes) long.\n\n+++<a name=\"jws-key-create\">++++++</a>+++\n\n==== Creating Safe Keys\n\nIf you don't want to think about bit length requirements or just want to make your life easier, JJWT has\nprovided convenient builder classes that can generate sufficiently secure keys for any given\nJWT signature algorithm you might want to use.\n\n+++<a name=\"jws-key-create-secret\">++++++</a>+++\n\n===== Secret Keys\n\nIf you want to generate a sufficiently strong `SecretKey` for use with the JWT HMAC-SHA algorithms, use the respective\nalgorithm's `key()` builder method:\n\n[,java]\n----\nSecretKey key = Jwts.SIG.HS256.key().build(); //or HS384.key() or HS512.key()\n----\n\nUnder the hood, JJWT uses the JCA default provider's `KeyGenerator` to create a secure-random key with the correct\nminimum length for the given algorithm.\n\nIf you want to specify a specific JCA `Provider` or `SecureRandom` to use during key generation, you may specify those\nas builder arguments. For example:\n\n[,java]\n----\nSecretKey key = Jwts.SIG.HS256.key().provider(aProvider).random(aSecureRandom).build();\n----\n\nIf you need to save this new `SecretKey`, you can Base64 (or Base64URL) encode it:\n\n[,java]\n----\nString secretString = Encoders.BASE64.encode(key.getEncoded());\n----\n\nEnsure you save the resulting `secretString` somewhere safe -\n<<base64-not-encryption,Base64-encoding is not encryption>>, so it's still considered sensitive information. You can\nfurther encrypt it, etc, before saving to disk (for example).\n\n+++<a name=\"jws-key-create-asym\">++++++</a>+++\n\n===== Asymmetric Keys\n\nIf you want to generate sufficiently strong Elliptic Curve or RSA asymmetric key pairs for use with JWT ECDSA or RSA\nalgorithms, use an algorithm's respective `keyPair()` builder method:\n\n[,java]\n----\nKeyPair keyPair = Jwts.SIG.RS256.keyPair().build(); //or RS384, RS512, PS256, etc...\n----\n\nOnce you've generated a `KeyPair`, you can use the private key (`keyPair.getPrivate()`) to create a JWS and the\npublic key (`keyPair.getPublic()`) to parse/verify a JWS.\n\n[NOTE]\n====\n* *The `PS256`, `PS384`, and `PS512` algorithms require JDK 11 or a compatible JCA Provider\n(like BouncyCastle) in the runtime classpath.*\n* *The `EdDSA` algorithms requires JDK 15 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.*\n\nIf you want to use either set of algorithms, and you are on an earlier JDK that does not support them,\nsee the <<Installation,Installation>> section to see how to enable BouncyCastle.  All other algorithms are\nnatively supported by the JDK.\n====\n\n+++<a name=\"jws-create\">++++++</a>+++\n\n=== Creating a JWS\n\nYou create a JWS as follows:\n\n. Use the `Jwts.builder()` method to create a `JwtBuilder` instance.\n. Call `JwtBuilder` methods to set the `payload` content or claims and any header parameters as desired.\n. Specify the `SecretKey` or asymmetric `PrivateKey` you want to use to sign the JWT.\n. Finally, call the `compact()` method to compact and sign, producing the final jws.\n\nFor example:\n\n[,java]\n----\nString jws = Jwts.builder() // (1)\n\n    .subject(\"Bob\")         // (2)\n\n    .signWith(key)          // (3) <---\n\n    .compact();             // (4)\n----\n\n+++<a name=\"jws-create-key\">++++++</a>+++\n\n==== Signing Key\n\nIt is usually recommended to specify the signing key by calling the ``JwtBuilder``'s `signWith` method and let JJWT\ndetermine the most secure algorithm allowed for the specified key.:\n\n[,java]\n----\nString jws = Jwts.builder()\n\n   // ... etc ...\n\n   .signWith(key) // <---\n\n   .compact();\n----\n\nFor example, if you call `signWith` with a `SecretKey` that is 256 bits (32 bytes) long, it is not strong enough for\n`HS384` or `HS512`, so JJWT will automatically sign the JWT using `HS256`.\n\nWhen using `signWith` JJWT will also automatically set the required `alg` header with the associated algorithm\nidentifier.\n\nSimilarly, if you called `signWith` with an RSA `PrivateKey` that was 4096 bits long, JJWT will use the `RS512`\nalgorithm and automatically set the `alg` header to `RS512`.\n\nThe same selection logic applies for Elliptic Curve ``PrivateKey``s.\n\n[NOTE]\n====\n*You cannot sign JWTs with ``PublicKey``s as this is always insecure.* JJWT will reject any specified\n`PublicKey` for signing with an `InvalidKeyException`.\n====\n\n+++<a name=\"jws-create-key-secret\">++++++</a>+++\n\n===== SecretKey Formats\n\nIf you want to sign a JWS using HMAC-SHA algorithms, and you have a secret key `String` or\nhttps://docs.oracle.com/javase/8/docs/api/java/security/Key.html#getEncoded--[encoded byte array], you will need\nto convert it into a `SecretKey` instance to use as the `signWith` method argument.\n\nIf your secret key is:\n\n* An https://docs.oracle.com/javase/8/docs/api/java/security/Key.html#getEncoded--[encoded byte array]:\n+\n[,java]\n----\nSecretKey key = Keys.hmacShaKeyFor(encodedKeyBytes);\n----\n\n* A Base64-encoded string:\n+\n[,java]\n----\nSecretKey key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretString));\n----\n\n* A Base64URL-encoded string:\n+\n[,java]\n----\nSecretKey key = Keys.hmacShaKeyFor(Decoders.BASE64URL.decode(secretString));\n----\n\n* A raw (non-encoded) string (e.g. a password String):\n+\n[,java]\n----\nPassword key = Keys.password(secretString.toCharArray());\n----\n\n[WARNING]\n====\nIt is almost always incorrect to call any variant of `secretString.getBytes` in any cryptographic context. +\nSafe cryptographic keys are never represented as direct (unencoded) strings.  If you have a password that should\nbe represented as a `Key` for `HMAC-SHA` algorithms, it is _strongly_ recommended to use a key derivation\nalgorithm to derive a cryptographically-strong `Key` from the password, and never use the password directly.\n====\n\n+++<a name=\"jws-create-key-algoverride\">++++++</a>+++\n\n===== SignatureAlgorithm Override\n\nIn some specific cases, you might want to override JJWT's default selected signature algorithm for a given key.\n\nFor example, if you have an RSA `PrivateKey` that is 2048 bits, JJWT would automatically choose the `RS256` algorithm.\nIf you wanted to use `RS384` or `RS512` instead, you could manually specify it with the overloaded `signWith` method\nthat accepts the `SignatureAlgorithm` as an additional argument:\n\n[,java]\n----\n\n   .signWith(privateKey, Jwts.SIG.RS512) // <---\n\n   .compact();\n----\n\nThis is allowed because the JWT specification allows any RSA algorithm strength for any RSA key >= 2048 bits.  JJWT just\nprefers `RS512` for keys >= 4096 bits, followed by `RS384` for keys >= 3072 bits and finally `RS256` for keys >= 2048\nbits.\n\n*In all cases however, regardless of your chosen algorithms, JJWT will assert that the specified key is allowed to be\nused for that algorithm when possible according to the JWT specification requirements.*\n\n+++<a name=\"jws-create-compression\">++++++</a>+++\n\n==== JWS Compression\n\nIf your JWT payload is large (contains a lot of data), and you are certain that JJWT will also be the same library\nthat reads/parses your JWS, you might want to compress the JWS to reduce its size.\n\n[WARNING]\n====\n*Not Standard for JWS*: JJWT supports compression for JWS, but it is not a standard feature for JWS.  The\nJWT RFC specifications standardize this _only_ for JWEs, and it is not likely to be supported by other JWT libraries\nfor JWS.  Use JWS compression only if you are certain that JJWT (or another library that supports JWS compression)\nwill be parsing the JWS.\n====\n\nPlease see the main <<compression,Compression>> section to see how to compress and decompress JWTs.\n\n+++<a name=\"jws-read\">++++++</a>+++\n\n=== Reading a JWS\n\nYou read (parse) a JWS as follows:\n\n. Use the `Jwts.parser()` method to create a `JwtParserBuilder` instance.\n. Call either <<key-locator,keyLocator>> or `verifyWith` methods to determine the key used to verify the JWS signature.\n. Call the `build()` method on the `JwtParserBuilder` to return a thread-safe `JwtParser`.\n. Finally, call the `parseSignedClaims(String)` method with your jws `String`, producing the original JWS.\n. The entire call is wrapped in a try/catch block in case parsing or signature validation fails.  We'll cover\nexceptions and causes for failure later.\n\nFor example:\n\n[,java]\n----\nJws<Claims> jws;\n\ntry {\n    jws = Jwts.parser()            // (1)\n\n    .keyLocator(keyLocator)        // (2) dynamically lookup verification keys based on each JWS\n    //.verifyWith(key)             //     or a static key used to verify all encountered JWSs\n\n    .build()                       // (3)\n    .parseSignedClaims(jwsString); // (4) or parseSignedContent(jwsString)\n\n    // we can safely trust the JWT\n\ncatch (JwtException ex) {          // (5)\n\n    // we *cannot* use the JWT as intended by its creator\n}\n----\n\n[NOTE]\n====\n.Type-safe JWSs\n\n* If you are expecting a JWS with a Claims `payload`, call the ``JwtParser``'s `parseSignedClaims` method.\n* If you are expecting a JWS with a content `payload`, call the ``JwtParser``'s `parseSignedContent` method.\n====\n\n+++<a name=\"jws-read-key\">++++++</a>+++\n\n==== Verification Key\n\nThe most important thing to do when reading a JWS is to specify the key used to verify the JWS's\ncryptographic signature.  If signature verification fails, the JWT cannot be safely trusted and should be\ndiscarded.\n\nSo which key do we use for verification?\n\n* If the jws was signed with a `SecretKey`, the same `SecretKey` should be specified on the `JwtParserBuilder`. +\nFor example:\n+\n[,java]\n----\nJwts.parser()\n\n  .verifyWith(secretKey) // <----\n\n  .build()\n  .parseSignedClaims(jwsString);\n----\n\n* If the jws was signed with a `PrivateKey`, that key's corresponding `PublicKey` (not the `PrivateKey`) should be\nspecified on the `JwtParserBuilder`.  For example:\n+\n[,java]\n----\nJwts.parser()\n\n  .verifyWith(publicKey) // <---- publicKey, not privateKey\n\n  .build()\n  .parseSignedClaims(jwsString);\n----\n\n+++<a name=\"jws-read-key-locator\">++++++</a>++++++<a name=\"jws-read-key-resolver\">++++++</a>+++\n// legacy anchors for old links\n\n==== Verification Key Locator\n\nBut you might have noticed something - what if your application doesn't use just a single `SecretKey` or `KeyPair`? What\nif JWSs can be created with different ``SecretKey``s or public/private keys, or a combination of both?  How do you\nknow which key to specify if you can't inspect the JWT first?\n\nIn these cases, you can't call the ``JwtParserBuilder``'s `verifyWith` method with a single key - instead, you'll need a\nKey Locator.  Please see the <<key-locator,Key Lookup>> section to see how to dynamically obtain different keys when\nparsing JWSs or JWEs.\n\n+++<a name=\"jws-read-decompression\">++++++</a>+++\n\n==== JWS Decompression\n\nIf you used JJWT to compress a JWS and you used a custom compression algorithm, you will need to tell the\n`JwtParserBuilder` how to resolve your `CompressionAlgorithm` to decompress the JWT.\n\nPlease see the <<compression,Compression>> section below to see how to decompress JWTs during parsing.\n\n+++<a name=\"jws-unencoded\">++++++</a>+++\n\n=== Unencoded Payload Option\n\nIn some cases, especially if a JWS payload is large, it could be desirable to _not_ Base64URL-encode the JWS payload,\nor even exclude the payload from the compact JWS string entirely.  The JWT RFC specifications provide support\nfor these use cases via the\nhttps://www.rfc-editor.org/rfc/rfc7797.html[JSON Web Signature (JWS) Unencoded Payload Option] specification,\nwhich JJWT supports.\n\nThis option comes with both benefits and disadvantages:\n\n==== Benefits\n\nA JWS producer can still create a JWS string to use for payload integrity verification without having to either:\n\n. Base64URL-encode the (potentially very large) payload, saving the time that could take.\n. Include the payload in the compact JWS string at all. Omitting the payload from the JWS compact string\nentirely produces smaller JWSs that can be more efficient to transfer.\n\n==== Disadvantages\n\n. Your application, and not JJWT, incurs the responsibility to ensure the payload is not modified during transmission\nso the recipient can verify the JWS signature. For example, by using a sufficiently strong TLS (https) cipher\nsuite as well as any additional care before and after transmission, since\nhttps://tozny.com/blog/end-to-end-encryption-vs-https/[TLS does not guarantee end-to-end security].\n. If you choose to include the unencoded payload in the JWS compact string, your application\nhttps://www.rfc-editor.org/rfc/rfc7797.html#section-5.2[MUST] ensure that the payload does not contain a\nperiod (`.`) character anywhere in the payload.  The JWS recipient will experience parsing errors otherwise.\n\nBefore attempting to use this option, one should be aware of the RFC's\nhttps://www.rfc-editor.org/rfc/rfc7797.html#section-8[security considerations] first.\n\n[NOTE]\n====\n.Protected JWS Only\n\nThe RFC specification defines the Unencoded Payload option for use only with JWSs. It may not be used with\nwith unprotected JWTs or encrypted JWEs.\n====\n\n+++<a name=\"jws-unencoded-detached\">++++++</a>+++\n\n==== Detached Payload Example\n\nThis example shows creating and parsing a compact JWS using an unencoded payload that is detached, i.e. where the\npayload is not embedded in the compact JWS string at all.\n\nWe need to do three things during creation:\n\n. Specify the JWS signing key; it's a JWS and still needs to be signed.\n. Specify the raw payload bytes via the ``JwtBuilder``'s `content` method.\n. Indicate that the payload should _not_ be Base64Url-encoded using the ``JwtBuilder``'s `encodePayload(false)` method.\n\n[,java]\n----\n// create a test key for this example:\nSecretKey testKey = Jwts.SIG.HS512.key().build();\n\nString message = \"Hello World. It's a Beautiful Day!\";\nbyte[] content = message.getBytes(StandardCharsets.UTF_8);\n\nString jws = Jwts.builder().signWith(testKey) // #1\n        .content(content)                     // #2\n        .encodePayload(false)                 // #3\n        .compact();\n----\n\nTo parse the resulting `jws` string, we need to do two things when creating the `JwtParser`:\n\n. Specify the signature verification key.\n. Specify the externally-transmitted unencoded payload bytes, required for signature verification.\n\n[,java]\n----\nJws<byte[]> parsed = Jwts.parser().verifyWith(testKey) // 1\n        .build()\n        .parseSignedContent(jws, content);             // 2\n\nassertArrayEquals(content, parsed.getPayload());\n----\n\n+++<a name=\"jws-unencoded-nondetached\">++++++</a>+++\n\n==== Non-Detached Payload Example\n\nThis example shows creating and parsing a compact JWS with what the RFC calls a 'non-detached' unencoded payload, i.e.\na raw string directly embedded as the payload in the compact JWS string.\n\nWe need to do three things during creation:\n\n. Specify the JWS signing key; it's a JWS and still needs to be signed.\n. Specify the raw payload string via the ``JwtBuilder``'s `content` method.  Per\nhttps://www.rfc-editor.org/rfc/rfc7797.html#section-5.2[the RFC], the payload string *_MUST NOT contain any\nperiod (`.`) characters_*.\n. Indicate that the payload should _not_ be Base64Url-encoded using the ``JwtBuilder``'s `encodePayload(false)` method.\n\n[,java]\n----\n// create a test key for this example:\nSecretKey testKey = Jwts.SIG.HS512.key().build();\n\nString claimsString = \"{\\\"sub\\\":\\\"joe\\\",\\\"iss\\\":\\\"me\\\"}\";\n\nString jws = Jwts.builder().signWith(testKey) // #1\n        .content(claimsString)                // #2\n        .encodePayload(false)                 // #3\n        .compact();\n----\n\nIf you were to print the `jws` string, you'd see something like this:\n\n----\neyJhbGciOiJIUzUxMiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19.{\"sub\":\"joe\",\"iss\":\"me\"}.wkoxYEd//...etc...\n----\n\nSee how the `claimsString` is embedded directly as the center `payload` token instead of a standard Base64URL value?\nThis is why no period (`.`) characters can exist in the payload.  If they did, any standard JWT parser would see more\nthan two periods total, which is required for parsing standard JWSs.\n\nTo parse the resulting `jws` string, we need to do two things when creating the `JwtParser`:\n\n. Specify the signature verification key.\n. Indicate that we want to support Unencoded Payload Option JWSs by enabling the `b64` `crit` header parameter.\n\n[,java]\n----\nJws<Claims> parsed = Jwts.parser().verifyWith(testKey) // 1\n        .critical().add(\"b64\").and()                   // 2\n        .build()\n        .parseSignedClaims(jws);\n\nassert \"joe\".equals(parsed.getPayload().getSubject());\nassert \"me\".equals(parsed.getPayload().getIssuer());\n----\n\nDid you notice we used the `.parseSignedClaims(String)` method instead of `.parseSignedClaims(String, byte[])`? This is\nbecause the non-detached payload is already present and JJWT has what it needs for signature verification.\n\nAdditionally, we needed to specify the `b64` critical value:  because we're not using the two-argument\n`parseSignedClaims(jws, content)` method, the parser has no way of knowing if you wish to allow or support unencoded\npayloads. Unencoded payloads have additional security considerations as described above, so they are disabled by\nthe parser by default unless you indicate you want to support them by using `critical().add(\"b64\")`.\n\nFinally, even if the payload contains a non-detached String, you could still use the two-argument method using the\npayload String's UTF-8 bytes instead:\n\n[,java]\n----\nparsed = Jwts.parser().verifyWith(testKey)\n        .build()\n        .parseSignedClaims(jws, claimsString.getBytes(StandardCharsets.UTF_8)); // <---\n----\n\n+++<a name=\"jwe\">++++++</a>+++\n\n== Encrypted JWTs\n\nThe JWT specification also provides for the ability to encrypt and decrypt a JWT.  Encrypting a JWT:\n\n. guarantees that no-one other than the intended JWT recipient can see the JWT `payload` (it is confidential), and\n. guarantees that no-one has manipulated or changed the JWT after it was created (its integrity is maintained).\n\nThese two properties - confidentiality and integrity - assure us that an encrypted JWT contains a `payload` that\nno-one else can see, _nor_ has anyone changed or altered the data in transit.\n\nEncryption and confidentiality seem somewhat obvious: if you encrypt a message, it is confidential by the notion that\nrandom 3rd parties cannot make sense of the encrypted message. But some might be surprised to know that *_general\nencryption does _not_ guarantee that someone hasn't tampered/altered an encrypted message in transit_*.  Most of us\nassume that if a message can be decrypted, then the message would be authentic and unchanged - after all, if you can\ndecrypt it, it must not have been tampered with, right? Because if it was changed, decryption would surely fail, right?\n\nUnfortunately, this is not actually guaranteed in all cryptographic ciphers. There are certain attack vectors where\nit is possible to change an encrypted payload (called 'ciphertext'), and the message recipient is still able to\nsuccessfully decrypt the (modified) payload.  In these cases, the ciphertext integrity was not maintained - a\nmalicious 3rd party could intercept a message and change the payload content, even if they don't understand what is\ninside the payload, and the message recipient could never know.\n\nTo combat this, there is a category of encryption algorithms that ensures                                                                                 both confidentiality _and_ integrity of the\nciphertext data.  These types of algorithms are called\nhttps://en.wikipedia.org/wiki/Authenticated_encryption[Authenticated Encryption] algorithms.\n\nAs a result, to ensure JWTs do not suffer from this problem, the JWE RFC specifications require that any encryption\nalgorithm used to encrypt a JWT _MUST_ be an Authenticated Encryption algorithm.  JWT users can be sufficiently\nconfident their encrypted JWTs maintain the properties of both confidentiality and integrity.\n\n+++<a name=\"jwe-enc\">++++++</a>+++\n\n=== JWE Encryption Algorithms\n\nThe JWT specification defines 6 standard Authenticated Encryption algorithms used to encrypt a JWT `payload`:\n\n|===\n| Identifier | Required Key Bit Length | Encryption Algorithm\n\n| `A128CBCHS256`\n| 256\n| https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.3[AES_128_CBC_HMAC_SHA_256] authenticated encryption algorithm\n\n| `A192CBC-HS384`\n| 384\n| https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.4[AES_192_CBC_HMAC_SHA_384] authenticated encryption algorithm\n\n| `A256CBC-HS512`\n| 512\n| https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.5[AES_256_CBC_HMAC_SHA_512] authenticated encryption algorithm\n\n| `A128GCM`\n| 128\n| AES GCM using 128-bit key^*1*^\n\n| `A192GCM`\n| 192\n| AES GCM using 192-bit key^*1*^\n\n| `A256GCM`\n| 256\n| AES GCM using 256-bit key^*1*^\n|===\n\n^*1*.{sp}{fn-require-java8-plus}^\n\nThese are all represented as constants in the `io.jsonwebtoken.Jwts.ENC` registry singleton as\nimplementations of the `io.jsonwebtoken.security.AeadAlgorithm` interface.\n\nAs shown in the table above, each algorithm requires a key of sufficient length.  The JWT specification\nhttps://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.3[RFC 7518, Sections 5.2.3 through 5.3]\n_requires_ (mandates) that you MUST use keys that are sufficiently strong for a chosen algorithm.  This means that\nJJWT - a specification-compliant library - will also enforce that you use sufficiently strong keys\nfor the algorithms you choose.  If you provide a weak key for a given algorithm, JJWT will reject it and throw an\nexception.\n\nThe reason why the JWT specification, and consequently JJWT, mandates key lengths is that the security model of a\nparticular algorithm can completely break down if you don't adhere to the mandatory key properties of the algorithm,\neffectively having no security at all.\n\n+++<a name=\"jwe-enc-symmetric\">++++++</a>+++\n\n==== Symmetric Ciphers\n\nYou might have noticed something about the above Authenticated Encryption algorithms: they're all variants of the\nAES algorithm, and AES always uses a symmetric (secret) key to perform encryption and decryption.  That's kind of\nstrange, isn't it?\n\nWhat about RSA and Elliptic Curve asymmetric key cryptography? And Diffie-Hellman key exchange?  What about\npassword-based key derivation algorithms? Surely any of those could be desirable depending on the use case, no?\n\nYes, they definitely can, and the JWT specifications do support them, albeit indirectly:  those other\nalgorithms _are_ indeed supported and used, but they aren't used to encrypt the JWT `payload` directly.  They are\nused to _produce_ the actual key used to encrypt the `JWT` payload.\n\nThis is all done via the JWT specification's concept of a Key Management Algorithm, covered next.  After we cover that,\nwe'll show you how to encrypt and parse your own JWTs with the `JwtBuilder` and `JwtParserBuilder`.\n\n+++<a name=\"jwe-alg\">++++++</a>+++\n\n=== JWE Key Management Algorithms\n\nAs stated above, all standard JWA Encryption Algorithms are AES-based authenticated encryption algorithms.  So what\nabout RSA and Elliptic Curve cryptography? And password-based key derivation, or Diffie-Hellman exchange?\n\nAll of those are supported as well, but they are not used directly for encryption. They are used to _produce_ the\nkey that will be used to directly encrypt the JWT `payload`.\n\nThat is, JWT encryption can be thought of as a two-step process, shown in the following pseudocode:\n\n[,groovy]\n----\nKey algorithmKey = getKeyManagementAlgorithmKey(); // PublicKey, SecretKey, or Password\n\nSecretKey contentEncryptionKey = keyManagementAlgorithm.produceEncryptionKey(algorithmKey); // 1\n\nbyte[] ciphertext = encryptionAlgorithm.encrypt(payload, contentEncryptionKey);             // 2\n----\n\nSteps:\n\n. Use the `algorithmKey` to produce the actual key that will be used to encrypt the payload.  The JWT specifications\ncall this result the 'Content Encryption Key'.\n. Take the resulting Content Encryption Key and use it directly with the Authenticated Encryption algorithm to\nactually encrypt the JWT `payload`.\n\nSo why the indirection?  Why not just use any `PublicKey`, `SecretKey` or `Password` to encrypt the `payload`\n_directly_ ?\n\nThere are quite a few reasons for this.\n\n. Asymmetric key encryption (like RSA and Elliptic Curve) tends to be slow.  Like _really_ slow.  Symmetric key\ncipher algorithms in contrast are _really fast_.  This matters a lot in production applications that could be\nhandling a JWT on every HTTP request, which could be thousands per second.\n. RSA encryption (for example) can only encrypt a relatively small amount of data. A 2048-bit RSA key can only\nencrypt up to a maximum of 245 bytes.  A 4096-bit RSA key can only encrypt up to a maximum of 501 bytes.  There are\nplenty of JWTs that can exceed 245 bytes, and that would make RSA unusable.\n. Passwords usually make for very poor encryption keys - they often have poor entropy, or they themselves are\noften too short to be used directly with algorithms that mandate minimum key lengths to help ensure safety.\n\nFor these reasons and more, using one secure algorithm to generate or encrypt a key used for another (very fast) secure\nalgorithm has been proven to be a great way to increase security through many more secure algorithms while\nalso still resulting in very fast and secure output.  This is after all how TLS (for https encryption) works -\ntwo parties can use more complex cryptography (like RSA or Elliptic Curve) to negotiate a small, fast encryption key.\nThis fast encryption key is produced during the 'TLS handshake' and is called the TLS 'session key'.\n\nSo the JWT specifications work much in the same way: one key from any number of various algorithm types can be used\nto produce a final symmetric key, and that symmetric key is used to encrypt the JWT `payload`.\n\n+++<a name=\"jwe-alg-standard\">++++++</a>+++\n\n==== JWE Standard Key Management Algorithms\n\nThe JWT specification defines 17 standard Key Management Algorithms used to produce the JWE\nContent Encryption Key (CEK):\n\n|===\n| Identifier | Key Management Algorithm\n\n| `RSA1_5`\n| RSAES-PKCS1-v1_5\n\n| `RSA-OAEP`\n| RSAES OAEP using default parameters\n\n| `RSA-OAEP-256`\n| RSAES OAEP using SHA-256 and MGF1 with SHA-256\n\n| `A128KW`\n| AES Key Wrap with default initial value using 128-bit key\n\n| `A192KW`\n| AES Key Wrap with default initial value using 192-bit key\n\n| `A256KW`\n| AES Key Wrap with default initial value using 256-bit key\n\n| `dir`\n| Direct use of a shared symmetric key as the Content Encryption Key\n\n| `ECDH-ES`\n| Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF\n\n| `ECDH-ES+A128KW`\n| ECDH-ES using Concat KDF and CEK wrapped with \"A128KW\"\n\n| `ECDH-ES+A192KW`\n| ECDH-ES using Concat KDF and CEK wrapped with \"A192KW\"\n\n| `ECDH-ES+A256KW`\n| ECDH-ES using Concat KDF and CEK wrapped with \"A256KW\"\n\n| `A128GCMKW`\n| Key wrapping with AES GCM using 128-bit key^*1*^\n\n| `A192GCMKW`\n| Key wrapping with AES GCM using 192-bit key^*1*^\n\n| `A256GCMKW`\n| Key wrapping with AES GCM using 256-bit key^*1*^\n\n| `PBES2-HS256+A128KW`\n| PBES2 with HMAC SHA-256 and \"A128KW\" wrapping^*1*^\n\n| `PBES2-HS384+A192KW`\n| PBES2 with HMAC SHA-384 and \"A192KW\" wrapping^*1*^\n\n| `PBES2HS512+A256KW`\n| PBES2 with HMAC SHA-512 and \"A256KW\" wrapping^*1*^\n|===\n\n^*1*.{sp}{fn-require-java8-plus}^\n\nThese are all represented as constants in the `io.jsonwebtoken.Jwts.KEY` registry singleton as\nimplementations of the `io.jsonwebtoken.security.KeyAlgorithm` interface.\n\nBut 17 algorithms are a lot to choose from.  When would you use them?  The sections below describe when you might\nchoose each category of algorithms and how they behave.\n\n+++<a name=\"jwe-alg-rsa\">++++++</a>+++\n\n===== RSA Key Encryption\n\nThe JWT RSA key management algorithms `RSA1_5`, `RSA-OAEP`, and `RSA-OAEP-256` are used when you want to use the\nJWE recipient's RSA _public_ key during encryption.  This ensures that only the JWE recipient can decrypt\nand read the JWE (using their RSA `private` key).\n\nDuring JWE creation, these algorithms:\n\n* Generate a new secure-random Content Encryption Key (CEK) suitable for the desired <<jwe-enc,encryption algorithm>>.\n* Encrypt the JWE payload with the desired encryption algorithm using the new CEK, producing the JWE payload ciphertext.\n* Encrypt the CEK itself with the specified RSA key wrap algorithm using the JWE recipient's RSA public key.\n* Embed the payload ciphertext and encrypted CEK in the resulting JWE.\n\nDuring JWE decryption, these algorithms:\n\n* Retrieve the encrypted Content Encryption Key (CEK) embedded in the JWE.\n* Decrypt the encrypted CEK with the discovered RSA key unwrap algorithm using the JWE recipient's RSA private key,\nproducing the decrypted Content Encryption Key (CEK).\n* Decrypt the JWE ciphertext payload with the JWE's identified <<jwe-enc,encryption algorithm>> using the decrypted CEK.\n\n[WARNING]\n====\nRFC 7518 Sections https://www.rfc-editor.org/rfc/rfc7518.html#section-4.2[4.2] and\nhttps://www.rfc-editor.org/rfc/rfc7518.html#section-4.3[4.3] _require_ (mandate) that RSA keys >= 2048 bits\nMUST be used with these algorithms. JJWT will throw an exception if it detects weaker keys being used.\n====\n\n+++<a name=\"jwe-alg-aes\">++++++</a>+++\n\n===== AES Key Encryption\n\nThe JWT AES key management algorithms `A128KW`, `A192KW`, `A256KW`, `A128GCMKW`, `A192GCMKW`, and `A256GCMKW` are\nused when you have a symmetric secret key, but you don't want to use that secret key to directly\nencrypt/decrypt the JWT.\n\nInstead, a new secure-random key is generated each time a JWE is created, and that new/random key is used to directly\nencrypt/decrypt the JWT payload.  The secure-random key is itself encrypted with your symmetric secret key\nusing the AES Wrap algorithm, and the encrypted key is embedded in the resulting JWE.\n\nThis allows the JWE to be encrypted with a random short-lived key, reducing material exposure of the potentially\nlonger-lived symmetric secret key.\n\nBecause these particular algorithms use a symmetric secret key, they are best suited when the JWE creator and\nreceiver are the same, ensuring the secret key does not need to be shared with multiple parties.\n\nDuring JWE creation, these algorithms:\n\n* Generate a new secure-random Content Encryption Key (CEK) suitable for the desired <<jwe-enc,encryption algorithm>>.\n* Encrypt the JWE payload with the desired encryption algorithm using the new CEK, producing the JWE payload ciphertext.\n* Encrypt the CEK itself with the specified AES key algorithm (either AES Key Wrap or AES with GCM encryption),\nproducing the encrypted CEK.\n* Embed the payload ciphertext and encrypted CEK in the resulting JWE.\n\nDuring JWE decryption, these algorithms:\n\n* Retrieve the encrypted Content Encryption Key (CEK) embedded in the JWE.\n* Decrypt the encrypted CEK with the discovered AES key algorithm using the symmetric secret key.\n* Decrypt the JWE ciphertext payload with the JWE's identified <<jwe-enc,encryption algorithm>> using the decrypted CEK.\n\n[WARNING]\n====\nThe symmetric key used for the AES key algorithms MUST be 128, 192 or 256 bits as required by the specific AES\nkey algorithm.  JJWT will throw an exception if it detects weaker keys than what is required.\n====\n\n+++<a name=\"jwe-alg-dir\">++++++</a>+++\n\n===== Direct Key Encryption\n\nThe JWT `dir` (direct) key management algorithm is used when you have a symmetric secret key, and you want to use it\nto directly encrypt the JWT payload.\n\nBecause this algorithm uses a symmetric secret key, it is best suited when the JWE creator and receiver are the\nsame, ensuring the secret key does not need to be shared with multiple parties.\n\nThis is the simplest key algorithm for direct encryption that does not perform any key encryption.  It is essentially\na 'no op' key algorithm, allowing the shared key to be used to directly encrypt the JWT payload.\n\nDuring JWE creation, this algorithm:\n\n* Encrypts the JWE payload with the desired encryption algorithm directly using the symmetric secret key,\nproducing the JWE payload ciphertext.\n* Embeds the payload ciphertext in the resulting JWE.\n\nNote that because this algorithm does not produce an encrypted key value, an encrypted CEK is _not_ embedded in the\nresulting JWE.\n\nDuring JWE decryption, this algorithm decrypts the JWE ciphertext payload with the JWE's\nidentified <<jwe-enc,encryption algorithm>> directly using the symmetric secret key.  No encrypted CEK is used.\n\n[WARNING]\n====\nThe symmetric secret key MUST be 128, 192 or 256 bits as required by the associated\n<<jwe-enc,AEAD encryption algorithm>> used to encrypt the payload. JJWT will throw an exception if it detects\nweaker keys than what is required.\n====\n\n+++<a name=\"jwe-alg-pbes2\">++++++</a>+++\n\n===== Password-Based Key Encryption\n\nThe JWT password-based key encryption algorithms `PBES2-HS256+A128KW`, `PBES2-HS384+A192KW`, and `PBES2-HS512+A256KW`\nare used when you want to use a password (character array) to encrypt and decrypt a JWT.\n\nHowever, because passwords are usually too weak or problematic to use directly in cryptographic contexts, these\nalgorithms utilize key derivation techniques with work factors (e.g. computation iterations) and secure-random salts\nto produce stronger cryptographic keys suitable for cryptographic operations.\n\nThis allows the payload to be encrypted with a random short-lived cryptographically-stronger key, reducing the need to\nexpose the longer-lived (and potentially weaker) password.\n\nBecause these algorithms use a secret password, they are best suited when the JWE creator and receiver are the\nsame, ensuring the secret password does not need to be shared with multiple parties.\n\nDuring JWE creation, these algorithms:\n\n* Generate a new secure-random Content Encryption Key (CEK) suitable for the desired <<jwe-enc,encryption algorithm>>.\n* Encrypt the JWE payload with the desired encryption algorithm using the new CEK, producing the JWE payload ciphertext.\n* Derive a 'key encryption key' (KEK) with the desired \"PBES2 with HMAC SHA\" algorithm using the password, a suitable\nnumber of computational iterations, and a secure-random salt value.\n* Encrypt the generated CEK with the corresponding AES Key Wrap algorithm using the password-derived KEK.\n* Embed the payload ciphertext and encrypted CEK in the resulting JWE.\n\n[NOTE]\n====\n.Secure defaults\n\nWhen using these algorithms, if you do not specify a work factor (i.e. number of computational\niterations), JJWT will automatically use an\nhttps://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2[OWASP PBKDF2 recommended]\ndefault appropriate for the specified `PBES2` algorithm.\n====\n\nDuring JWE decryption, these algorithms:\n\n* Retrieve the encrypted Content Encryption Key (CEK) embedded in the JWE.\n* Derive the 'key encryption key' (KEK) with the discovered \"PBES2 with HMAC SHA\" algorithm using the password and the\nnumber of computational iterations and secure-random salt value discovered in the JWE header.\n* Decrypt the encrypted CEK with the corresponding AES Key Unwrap algorithm using the password-derived KEK.\n* Decrypt the JWE ciphertext payload with the JWE's identified <<jwe-enc,encryption algorithm>> using the decrypted CEK.\n\n+++<a name=\"jwe-alg-ecdhes\">++++++</a>+++\n\n===== Elliptic Curve Diffie-Hellman Ephemeral Static Key Agreement (ECDH-ES)\n\nThe JWT Elliptic Curve Diffie-Hellman Ephemeral Static key agreement algorithms `ECDH-ES`, `ECDH-ES+A128KW`,\n`ECDH-ES+A192KW`, and `ECDH-ES+A256KW` are used when you want to use the JWE recipient's Elliptic Curve _public_ key\nduring encryption.  This ensures that only the JWE recipient can decrypt and read the JWE (using their Elliptic Curve\n_private_ key).\n\nDuring JWE creation, these algorithms:\n\n* Obtain the Content Encryption Key (CEK) used to encrypt the JWE payload as follows:\n ** Inspect the JWE recipient's Elliptic Curve public key and determine its Curve.\n ** Generate a new secure-random ephemeral Elliptic Curve public/private key pair on this same Curve.\n ** Add the ephemeral EC public key to the JWE\nhttps://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1[epk header] for inclusion in the final JWE.\n ** Produce an ECDH shared secret with the ECDH Key Agreement algorithm using the JWE recipient's EC public key\nand the ephemeral EC private key.\n ** Derive a symmetric secret key with the Concat Key Derivation Function\n(https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf[NIST.800-56A], Section 5.8.1) using\nthis ECDH shared secret and any provided\nhttps://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.2[PartyUInfo] and/or\nhttps://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.3[PartyVInfo].\n ** If the key algorithm is `ECDH-ES`:\n  *** Use the Concat KDF-derived symmetric secret key directly as the Content Encryption Key (CEK). No encrypted key\nis created, nor embedded in the resulting JWE.\n ** Otherwise, if the key algorithm is `ECDH-ES+A128KW`, `ECDH-ES+A192KW`, or `ECDH-ES+A256KW`:\n  *** Generate a new secure-random Content Encryption Key (CEK) suitable for the desired <<jwe-enc,encryption algorithm>>.\n  *** Encrypt this new CEK with the corresponding AES Key Wrap algorithm using the Concat KDF-derived secret key,\nproducing the encrypted CEK.\n  *** Embed the encrypted CEK in the resulting JWE.\n* Encrypt the JWE payload with the desired encryption algorithm using the obtained CEK, producing the JWE payload\nciphertext.\n* Embed the payload ciphertext in the resulting JWE.\n\nDuring JWE decryption, these algorithms:\n\n* Obtain the Content Encryption Key (CEK) used to decrypt the JWE payload as follows:\n ** Retrieve the required ephemeral Elliptic Curve public key from the JWE's\nhttps://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1[epk header].\n ** Ensure the ephemeral EC public key exists on the same curve as the JWE recipient's EC private key.\n ** Produce the ECDH shared secret with the ECDH Key Agreement algorithm using the JWE recipient's EC private key\nand the ephemeral EC public key.\n ** Derive a symmetric secret key with the Concat Key Derivation Function\n(https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf[NIST.800-56A], Section 5.8.1) using\nthis ECDH shared secret and any\nhttps://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.2[PartyUInfo] and/or\nhttps://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.3[PartyVInfo] found in the JWE header.\n ** If the key algorithm is `ECDH-ES`:\n  *** Use the Concat KDF-derived secret key directly as the Content Encryption Key (CEK). No encrypted key is used.\n ** Otherwise, if the key algorithm is `ECDH-ES+A128KW`, `ECDH-ES+A192KW`, or `ECDH-ES+A256KW`:\n  *** Obtain the encrypted key ciphertext embedded in the JWE.\n  *** Decrypt the encrypted key ciphertext with the associated AES Key Unwrap algorithm using the Concat KDF-derived\nsecret key, producing the unencrypted Content Encryption Key (CEK).\n* Decrypt the JWE payload ciphertext with the JWE's discovered encryption algorithm using the obtained CEK.\n\n+++<a name=\"jwe-create\">++++++</a>+++\n\n=== Creating a JWE\n\nNow that we know the difference between a JWE Encryption Algorithm and a JWE Key Management Algorithm, how do we use\nthem to encrypt a JWT?\n\nYou create an encrypted JWT (called a 'JWE') as follows:\n\n. Use the `Jwts.builder()` method to create a `JwtBuilder` instance.\n. Call `JwtBuilder` methods to set the `payload` content or claims and any <<jws-create-header,header>> parameters as desired.\n. Call the `encryptWith` method, specifying the Key, Key Algorithm, and Encryption Algorithm you want to use.\n. Finally, call the `compact()` method to compact and encrypt, producing the final jwe.\n\nFor example:\n\n[,java]\n----\nString jwe = Jwts.builder()                              // (1)\n\n    .subject(\"Bob\")                                      // (2)\n\n    .encryptWith(key, keyAlgorithm, encryptionAlgorithm) // (3)\n\n    .compact();                                          // (4)\n----\n\nBefore calling `compact()`,  you may set any <<jws-create-header,header>> parameters and <<jws-create-claims,claims>>\nexactly the same way as described for JWS.\n\n+++<a name=\"jwe-compression\">++++++</a>+++\n\n==== JWE Compression\n\nIf your JWT payload or Claims set is large (contains a lot of data), you might want to compress the JWE to reduce\nits size.  Please see the main <<compression,Compression>> section to see how to compress and decompress JWTs.\n\n+++<a name=\"jwe-read\">++++++</a>+++\n\n=== Reading a JWE\n\nYou read (parse) a JWE as follows:\n\n. Use the `Jwts.parser()` method to create a `JwtParserBuilder` instance.\n. Call either <<key-locator,keyLocator>> or `decryptWith` methods to determine the key used to decrypt the JWE.\n. Call the ``JwtParserBuilder``'s `build()` method to create a thread-safe `JwtParser`.\n. Parse the jwe string with the ``JwtParser``'s `parseEncryptedClaims` or `parseEncryptedContent` method.\n. Wrap the entire call is in a try/catch block in case decryption or integrity verification fails.\n\nFor example:\n\n[,java]\n----\nJwe<Claims> jwe;\n\ntry {\n    jwe = Jwts.parser()               // (1)\n\n    .keyLocator(keyLocator)           // (2) dynamically lookup decryption keys based on each JWE\n    //.decryptWith(key)               //     or a static key used to decrypt all encountered JWEs\n\n    .build()                          // (3)\n    .parseEncryptedClaims(jweString); // (4) or parseEncryptedContent(jweString);\n\n    // we can safely trust the JWT\n\ncatch (JwtException ex) {             // (5)\n\n    // we *cannot* use the JWT as intended by its creator\n}\n----\n\n[NOTE]\n====\n.Type-safe JWEs\n\n* If you are expecting a JWE with a Claims `payload`, call the ``JwtParser``'s `parseEncryptedClaims` method.\n* If you are expecting a JWE with a content `payload`, call the ``JwtParser``'s `parseEncryptedContent` method.\n====\n\n+++<a name=\"jwe-read-key\">++++++</a>+++\n\n==== Decryption Key\n\nThe most important thing to do when reading a JWE is to specify the key used during decryption.  If decryption or\nintegrity protection checks fail, the JWT cannot be safely trusted and should be discarded.\n\nSo which key do we use for decryption?\n\n* If the jwe was encrypted _directly_ with a `SecretKey`, the same `SecretKey` must be specified on the\n`JwtParserBuilder`. For example:\n+\n[,java]\n----\nJwts.parser()\n\n  .decryptWith(secretKey) // <----\n\n  .build()\n  .parseEncryptedClaims(jweString);\n----\n\n* If the jwe was encrypted using a key produced by a Password-based key derivation `KeyAlgorithm`, the same\n`Password` must be specified on the `JwtParserBuilder`. For example:\n+\n[,java]\n----\nPassword password = Keys.password(passwordChars);\n\nJwts.parser()\n\n  .decryptWith(password) // <---- an `io.jsonwebtoken.security.Password` instance\n\n  .build()\n  .parseEncryptedClaims(jweString);\n----\n\n* If the jwe was encrypted with a key produced by an asymmetric `KeyAlgorithm`, the corresponding `PrivateKey` (not\nthe `PublicKey`) must be specified on the `JwtParserBuilder`.  For example:\n+\n[,java]\n----\nJwts.parser()\n\n  .decryptWith(privateKey) // <---- a `PrivateKey`, not a `PublicKey`\n\n  .build()\n  .parseSignedClaims(jweString);\n----\n\n+++<a name=\"jwe-key-locator\">++++++</a>+++\n\n==== Decryption Key Locator\n\nWhat if your application doesn't use just a single `SecretKey` or `KeyPair`? What\nif JWEs can be created with different ``SecretKey``s, ``Password``s or public/private keys, or a combination of all of\nthem?  How do you know which key to specify if you can't inspect the JWT first?\n\nIn these cases, you can't call the ``JwtParserBuilder``'s `decryptWith` method with a single key - instead, you'll need\nto use a Key `Locator`.  Please see the <<key-locator,Key Lookup>> section to see how to dynamically obtain different\nkeys when parsing JWSs or JWEs.\n\n+++<a name=\"jwe-key-pkcs11\">++++++</a>+++\n\n==== ECDH-ES Decryption with PKCS11 PrivateKeys\n\nThe JWT `ECDH-ES`, `ECDH-ES+A128KW`, `ECDH-ES+A192KW`, and `ECDH-ES+A256KW` key algorithms validate JWE input using\npublic key information, even when using ``PrivateKey``s to decrypt.  Ordinarily this is automatically performed\nby JJWT when your `PrivateKey` instances implement the\nhttps://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/interfaces/ECKey.html[ECKey] or\nhttps://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/interfaces/EdECKey.html[EdECKey]\n(or BouncyCastle equivalent) interfaces, which is the case for most JCA `Provider` implementations.\n\nHowever, if your decryption ``PrivateKey``s are stored in a Hardware Security Module (HSM) and/or you use the\nhttps://docs.oracle.com/en/java/javase/17/security/pkcs11-reference-guide1.html#GUID-6DA72F34-6C6A-4F7D-ADBA-5811576A9331[SunPKCS11 Provider],\nit is likely that your `PrivateKey` instances _do not_ implement `ECKey`.\n\nIn these cases, you need to provide both the PKCS11 `PrivateKey` and it's companion `PublicKey` during decryption\nby using the `Keys.builder` method. For example:\n\n[,java]\n----\nKeyPair pair = getMyPkcs11KeyPair();\nPrivateKey jwtParserDecryptionKey = Keys.builder(pair.getPrivate())\n    .publicKey(pair.getPublic()) // PublicKey must implement ECKey or EdECKey or BouncyCastle equivalent\n    .build();\n----\n\nYou then use the resulting `jwtParserDecryptionKey` (not `pair.getPrivate()`) with the `JwtParserBuilder` or as\nthe return value from a custom <<key-locator,Key Locator>> implementation.  For example:\n\n[,java]\n----\nPrivateKey decryptionKey = Keys.builder(pkcs11PrivateKey).publicKey(pkcs11PublicKey).build();\n\nJwts.parser()\n    .decryptWith(decryptionKey) // <----\n    .build()\n    .parseEncryptedClaims(jweString);\n----\n\nOr as the return value from your key locator:\n\n[,java]\n----\nJwts.parser()\n    .keyLocator(keyLocator) // your keyLocator.locate(header) would return Keys.builder...\n    .build()\n    .parseEncryptedClaims(jweString);\n----\n\nPlease see the <<key-locator-provider,Provider-constrained Keys>> section for more information, as well as\ncode examples of how to implement a Key `Locator` using the `Keys.builder` technique.\n\n+++<a name=\"jwe-read-decompression\">++++++</a>+++\n\n==== JWE Decompression\n\nIf a JWE is compressed using the `DEF` (https://www.rfc-editor.org/rfc/rfc1951[DEFLATE]) or `GZIP`\n(https://www.rfc-editor.org/rfc/rfc1952.html[GZIP]) compression algorithms, it will automatically be decompressed\nafter decryption, and there is nothing you need to configure.\n\nIf, however, a custom compression algorithm was used to compress the JWE, you will need to tell the\n`JwtParserBuilder` how to resolve your `CompressionAlgorithm` to decompress the JWT.\n\nPlease see the <<compression,Compression>> section below to see how to decompress JWTs during parsing.\n\n+++<a name=\"jwk\">++++++</a>+++\n\n== JSON Web Keys (JWKs)\n\nhttps://www.rfc-editor.org/rfc/rfc7517.html[JSON Web Keys] (JWKs) are JSON serializations of cryptographic keys,\nallowing key material to be embedded in JWTs or transmitted between parties in a standard JSON-based text format. They\nare essentially a JSON-based alternative to other text-based key formats, such as the\nhttps://serverfault.com/a/9717[DER, PEM and PKCS12] text strings or files commonly used when configuring TLS on web\nservers, for example.\n\nFor example, an identity web service may expose its RSA or Elliptic Curve Public Keys to 3rd parties in the JWK format.\nA client may then parse the public key JWKs to verify the service's <<jws,JWS>> tokens, as well as send encrypted\ninformation to the service using <<jwe,JWE>>s.\n\nJWKs can be converted to and from standard Java `Key` types as expected using the same builder/parser patterns we've\nseen for JWTs.\n\n+++<a name=\"jwk-create\">++++++</a>+++\n\n=== Create a JWK\n\nYou create a JWK as follows:\n\n. Use the `Jwks.builder()` method to create a `JwkBuilder` instance.\n. Call the `key` method with the Java key you wish to represent as a JWK.\n. Call builder methods to set any additional key parameters or metadata, such as a `kid` (Key ID), X509 Certificates,\netc as desired.\n. Call the `build()` method to produce the resulting JWK.\n\nFor example:\n\n[,java]\n----\nSecretKey key = getSecretKey();     // or RSA or EC PublicKey or PrivateKey\nSecretJwk = Jwks.builder().key(key) // (1) and (2)\n\n    .id(\"mySecretKeyId\")            // (3)\n    // ... etc ...\n\n    .build();                       // (4)\n----\n\n==== JWK from a Map\n\nIf you have a `Map<String,?>` of name/value pairs that reflect an existing JWK, you add them and build a type-safe\n`Jwk` instance:\n\n[,java]\n----\nMap<String,?> jwkValues = getMyJwkMap();\n\nJwk<?> jwk = Jwks.builder().add(jwkValues).build();\n----\n\n+++<a name=\"jwk-read\">++++++</a>+++\n\n=== Read a JWK\n\nYou can read/parse a JWK by building a `JwkParser` and parsing the JWK JSON string with its `parse` method:\n\n[,java]\n----\nString json = getJwkJsonString();\nJwk<?> jwk = Jwks.parser()\n    //.provider(aJcaProvider)     // optional\n    //.deserializer(deserializer) // optional\n    .build()                      // create the parser\n    .parse(json);                 // actually parse the JSON\n\nKey key = jwk.toKey();            // convert to a Java Key instance\n----\n\nAs shown above you can specify a custom JCA Provider or <<json,JSON deserializer>> in the same way as the `JwtBuilder`.\n\n+++<a name=\"jwk-private\">++++++</a>+++\n\n=== PrivateKey JWKs\n\nUnlike Java, the JWA specification requires a private JWKs to contain _both_ public key _and_ private key material\n(see https://www.rfc-editor.org/rfc/rfc7518.html#section-6.2.2[RFC 7518, Section 6.1.1] and\nhttps://www.rfc-editor.org/rfc/rfc7518.html#section-6.3.2[RFC 7518, Section 6.3.2]).\n\nIn this sense, a private JWK (represented as a `PrivateJwk` or a subtype, such as `RsaPrivateJwk`, `EcPrivateJwk`, etc)\ncan be thought of more like a Java `KeyPair` instance.  Consequently, when creating a `PrivateJwk` instance,\nthe ``PrivateKey``'s corresponding `PublicKey` is required.\n\n+++<a name=\"jwk-private-public\">++++++</a>+++\n\n==== Private JWK `PublicKey`\n\nIf you do not provide a `PublicKey` when creating a `PrivateJwk`, JJWT will automatically derive the `PublicKey` from\nthe `PrivateKey` instance if possible. However, because this can add\nsome computing time, it is typically recommended to provide the `PublicKey` when possible to avoid this extra work.\n\nFor example:\n\n[,java]\n----\nRSAPrivateKey rsaPrivateKey = getRSAPrivateKey(); // or ECPrivateKey\n\nRsaPrivateJwk jwk = Jwks.builder().key(rsaPrivateKey)\n\n        //.publicKey(rsaPublicKey)  // optional, but recommended to avoid extra computation work\n\n        .build();\n----\n\n+++<a name=\"jwk-private-keypair\">++++++</a>+++\n\n==== Private JWK from KeyPair\n\nIf you have a Java `KeyPair` instance, then you have both the public and private key material necessary to create a\n`PrivateJwk`. For example:\n\n[,java]\n----\nKeyPair rsaKeyPair = getRSAKeyPair();\nRsaPrivateJwk rsaPrivJwk = Jwks.builder().rsaKeyPair(rsaKeyPair).build();\n\nKeyPair ecKeyPair = getECKeyPair();\nEcPrivateJwk ecPrivJwk = Jwks.builder().ecKeyPair(ecKeyPair).build();\n\nKeyPair edEcKeyPair = getEdECKeyPair();\nOctetPrivateJwk edEcPrivJwk = Jwks.builder().octetKeyPair(edEcKeyPair).build();\n----\n\nNote that:\n\n* An exception will be thrown when calling `rsaKeyPair` if the specified `KeyPair` instance does not contain\n`RSAPublicKey` and `RSAPrivateKey` instances.\n* Similarly, an exception will be thrown when calling `ecKeyPair` if\nthe `KeyPair` instance does not contain `ECPublicKey` and `ECPrivateKey` instances.\n* Finally, an exception will be\nthrown when calling `octetKeyPair` if the `KeyPair` instance does not contain X25519, X448, Ed25519, or Ed448 keys\n(introduced in JDK 11 and 15 or when using BouncyCastle).\n\n+++<a name=\"jwk-private-topub\">++++++</a>+++\n\n==== Private JWK Public Conversion\n\nBecause private JWKs contain public key material, you can always obtain the private JWK's corresponding public JWK and\nJava `PublicKey` or `KeyPair`.  For example:\n\n[,java]\n----\nRsaPrivateJwk privateJwk = Jwks.builder().key(rsaPrivateKey).build(); // or ecPrivateKey or edEcPrivateKey\n\n// Get the matching public JWK and/or PublicKey:\nRsaPublicJwk pubJwk = privateJwk.toPublicJwk();       // JWK instance\nRSAPublicKey pubKey = pubJwk.toKey();                 // Java PublicKey instance\nKeyPair pair = privateJwk.toKeyPair();                // io.jsonwebtoken.security.KeyPair retains key types\njava.security.KeyPair jdkPair = pair.toJavaKeyPair(); // does not retain pub/private key types\n----\n\n+++<a name=\"jwk-thumbprint\">++++++</a>+++\n\n=== JWK Thumbprints\n\nA https://www.rfc-editor.org/rfc/rfc7638.html[JWK Thumbprint] is a digest (aka hash) of a canonical JSON\nrepresentation of a JWK's public properties. 'Canonical' in this case means that only RFC-specified values in any JWK\nare used in an exact order thumbprint calculation.  This ensures that anyone can calculate a JWK's same exact\nthumbprint, regardless of custom parameters or JSON key/value ordering differences in a JWK.\n\nAll `Jwk` instances support https://www.rfc-editor.org/rfc/rfc7638.html[JWK Thumbprint]s via the\n`thumbprint()` and `thumbprint(HashAlgorithm)` methods:\n\n[,java]\n----\nHashAlgorithm hashAlg = Jwks.HASH.SHA256; // or SHA384, SHA512, etc.\n\nJwk<?> jwk = Jwks.builder(). /* ... */ .build();\n\nJwkThumbprint sha256Thumbprint = jwk.thumbprint(); // SHA-256 thumbprint by default\n\nJwkThumbprint anotherThumbprint = jwk.thumbprint(Jwks.HASH.SHA512); // or a specified hash algorithm\n----\n\nThe resulting `JwkThumbprint` instance provides some useful methods:\n\n* `jwkThumbprint.toByteArray()`: the thumbprint's actual digest bytes - i.e. the raw output from the hash algorithm\n* `jwkThumbprint.toString()`: the digest bytes as a Base64URL-encoded string\n* `jwkThumbprint.getHashAlgorithm()`: the specific `HashAlgorithm` used to compute the thumbprint. Many standard IANA\n                                    hash algorithms are available as constants in the `Jwks.HASH` utility class.\n* `jwkThumbprint.toURI()`: the thumbprint's canonical URI as defined by the https://www.rfc-editor.org/rfc/rfc9278.html[JWK Thumbprint URI] specification\n\n+++<a name=\"jwk-thumbprint-kid\">++++++</a>+++\n\n==== JWK Thumbprint as a Key ID\n\nBecause a thumbprint is an order-guaranteed unique digest of a JWK, JWK thumbprints are often used as convenient\nunique identifiers for a JWK (e.g. the JWK's `kid` (Key ID) value). These identifiers can be useful when\n<<key-locator,locating keys>> for JWS signature verification or JWE decryption, for example.\n\nFor example:\n\n[,java]\n----\nString kid = jwk.thumbprint().toString(); // Thumbprint bytes as a Base64URL-encoded string\nKey key = findKey(kid);\nassert jwk.toKey().equals(key);\n----\n\nHowever, because `Jwk` instances are immutable, you can't set the key id after the JWK is created. For example, the\nfollowing is not possible:\n\n[,java]\n----\nString kid = jwk.thumbprint().toString();\njwk.setId(kid) // Jwks are immutable - there is no `setId` method\n----\n\nInstead, you may use the `idFromThumbprint` methods on the `JwkBuilder` when creating a `Jwk`:\n\n[,java]\n----\nJwk<?> jwk = Jwks.builder().key(aKey)\n\n    .idFromThumbprint() // or idFromThumbprint(HashAlgorithm)\n\n    .build();\n----\n\nCalling either `idFromThumbprint` method will ensure that calling `jwk.getId()` equals `thumbprint.toString()`\n(which is `Encoders.BASE64URL.encode(thumbprint.toByteArray())`).\n\n+++<a name=\"jwk-thumbprint-uri\">++++++</a>+++\n\n==== JWK Thumbprint URI\n\nA JWK's thumbprint's canonical URI as defined by the https://www.rfc-editor.org/rfc/rfc9278.html[JWK Thumbprint URI]\nspecification may be obtained by calling the thumbprint's `toURI()` method:\n\n[,java]\n----\nURI canonicalThumbprintURI = jwk.thumbprint().toURI();\n----\n\nPer the RFC specification, if you call `canonicalThumbprintURI.toString()`, you would see a string that looks like this:\n\n[,text]\n----\nurn:ietf:params:oauth:jwk-thumbprint:HASH_ALG_ID:BASE64URL_DIGEST\n----\n\nwhere:\n\n* `urn:ietf:params:oauth:jwk-thumbprint:` is the URI scheme+prefix\n* `HASH_ALG_ID` is the standard identifier used to compute the thumbprint as defined in the\nhttps://www.iana.org/assignments/named-information/named-information.xhtml[IANA Named Information Hash Algorithm Registry].\nThis is the same as `thumbprint.getHashAlgorithm().getId()`.\n* `BASE64URL_DIGEST` is the Base64URL-encoded thumbprint bytes, equal to `jwkThumbprint.toString()`.\n\n+++<a name=\"jwk-security\">++++++</a>+++\n\n=== JWK Security Considerations\n\nBecause they contain secret or private key material, `SecretJwk` and `PrivateJwk` (e.g. `RsaPrivateJwk`, +\n`EcPrivateJwk`, etc) instances should be used with great care and never accidentally transmitted to 3rd parties.\n\nEven so, JJWT's `Jwk` implementations will suppress certain values in `toString()` output for safety as described\nnext.\n\n+++<a name=\"jwk-tostring\">++++++</a>+++\n\n==== JWK `toString()` Safety\n\nBecause it would be incredibly easy to accidentally print key material to `System.out.println()` or application\nlogs, all `Jwk` implementations will print redacted values instead of actual secret or private key material.\n\nFor example, consider the following Secret JWK JSON example from\nhttps://www.rfc-editor.org/rfc/rfc7515#appendix-A.1.1[RFC 7515, Appendix A.1.1]:\n\n[,json]\n----\n{\n  \"kty\": \"oct\",\n  \"k\": \"AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow\",\n  \"kid\": \"HMAC key used in https://www.rfc-editor.org/rfc/rfc7515#appendix-A.1.1 example.\"\n}\n----\n\nThe `k` value (`+AyAyM1SysPpby...+`) reflects secure key material and should never be accidentally\nexposed.\n\nIf you were to parse this JSON as a `Jwk`, calling `toString()` will _NOT_ print this value.  It will\ninstead print the string literal `<redacted>` for any secret or private key data value.  For example:\n\n[,java]\n----\nString json = getExampleSecretKeyJson();\nJwk<?> jwk = Jwks.parser().build().parse(json);\n\nSystem.out.printn(jwk);\n----\n\nThis code would print the following string literal to the System console:\n\n[,text]\n----\n{kty=oct, k=<redacted>, kid=HMAC key used in https://www.rfc-editor.org/rfc/rfc7515#appendix-A.1.1 example.}\n----\n\nThis is true for all secret or private key members in `SecretJwk` and `PrivateJwk` (e.g. `RsaPrivateJwk`,\n`EcPrivateJwk`, etc) instances.\n\n+++<a name=\"jwkset\">++++++</a>+++\n\n== JWK Sets\n\nThe JWK specification specification also defines the concept of a\nhttps://datatracker.ietf.org/doc/html/rfc7517#section-5[JWK Set]:\n\n A JWK Set is a JSON object that represents a set of JWKs.  The JSON\n object MUST have a \"keys\" member, with its value being an array of\n JWKs.\n\nFor example:\n\n[,txt]\n----\n{\n  \"keys\": [jwk1, jwk2, ...]\n}\n----\n\nWhere `jwk1`, `jwk2`, etc., are each a single <<jwk,JWK>> JSON Object.\n\nA JWK Set _may_ have other members that are peers to the `keys` member, but the JWK specification does not define any\nothers - any such additional members would be custom or unique based on an application's needs or preferences.\n\nA JWK Set can be useful for conveying multiple keys simultaneously.  For example, an identity web service could expose\nall of its RSA or Elliptic Curve public keys that might be used for various purposes or different algorithms to\n3rd parties or API clients as a single JWK Set JSON Object or document.  An API client can then parse the JWK Set\nto obtain the keys that might be used to verify or decrypt JWTs sent by the web service.\n\nJWK Sets are (mostly) simple collections of JWKs, and they are easily supported by JJWT with parallel builder/parser\nconcepts we've seen above.\n\n+++<a name=\"jwkset-create\">++++++</a>+++\n\n=== Create a JWK Set\n\nYou create a JWK Set as follows:\n\n. Use the `Jwks.set()` method to create a `JwkSetBuilder` instance.\n. Call the `add(Jwk)` method any number of times to add one or more JWKs to the set.\n. Call builder methods to set any additional JSON members if desired, or the `operationPolicy(KeyOperationPolicy)`\nbuilder method to control what key operations may be assigned to any given JWK added to the set.\n. Call the `build()` method to produce the resulting JWK Set.\n\nFor example:\n\n[,java]\n----\nJwk<?> jwk = Jwks.builder()/* ... */.build();\nSecretJwk = Jwks.set()              // 1\n    .add(jwk)                       // 2, appends a key\n    //.add(aCollection)             //    append multiple keys\n    //.keys(allJwks)                //    sets/replaces all keys\n    //.add(\"aName\", \"aValue\")       // 3, optional\n    //.operationPolicy(Jwks.OP      // 3, optional\n    //     .policy()\n    //     /* etc... */\n    //     .build())\n    //.provider(aJcaProvider)       //    optional\n    .build();                       // (4)\n----\n\nAs shown, you can optionally configure the `.operationPolicy(KeyOperationPolicy)` method using a\n`Jwts.OP.policy()` builder.  A `KeyOperationPolicy` allows you control what operations are allowed for any JWK\nbefore being added to the JWK Set; any JWK that does not match the policy will be rejected and not added to the set.\nJJWT internally defaults to a standard RFC-compliant policy, but you can create a\npolicy to override the default if desired using the `Jwks.OP.policy()` builder method.\n\n+++<a name=\"jwkset-read\">++++++</a>+++\n\n=== Read a JWK Set\n\nYou can read/parse a JWK Set by building a JWK Set `Parser` and parsing the JWK Set JSON with one of its various\n`parse` methods:\n\n[,java]\n----\nJwkSet jwkSet = Jwks.setParser()\n    //.provider(aJcaProvider)      // optional\n    //.deserializer(deserializer)  // optional\n    //.policy(aKeyOperationPolicy) // optional\n    .build()                       // create the parser\n    .parse(json);                  // actually parse JSON String, InputStream, Reader, etc.\n\njwkSet.forEach(jwk -> System.out.println(jwk));\n----\n\nAs shown above, you can specify a custom JCA Provider, <<json,JSON deserializer>> or `KeyOperationPolicy` in the\nsame way as the `JwkSetBuilder`. Any JWK that does not match the default (or configured) policy will be\nrejected. You can create a policy to override the default if desired using the `Jwks.OP.policy()` builder method.\n\n+++<a name=\"compression\">++++++</a>+++\n\n== Compression\n\n[WARNING]\n====\nThe JWT specification standardizes compression for JWEs (Encrypted JWTs) ONLY, however JJWT supports it for JWS\n(Signed JWTs) as well.\n\nIf you are positive that a JWS you create with JJWT will _also_ be parsed with JJWT,\nyou can use this feature with both JWEs and JWSs, otherwise it is best to only use it for JWEs.\n====\n\nIf a JWT's `payload` is sufficiently large - that is, it is a large content byte array or JSON with a lot of\nname/value pairs (or individual values are very large or verbose) - you can reduce the size of the compact JWT by\ncompressing the payload.\n\nThis might be important to you if the resulting JWT is used in a URL for example, since URLs are best kept under\n4096 characters due to browser, user mail agent, or HTTP gateway compatibility issues.  Smaller JWTs also help reduce\nbandwidth utilization, which may or may not be important depending on your application's volume or needs.\n\nIf you want to compress your JWT, you can use the ``JwtBuilder``'s  `compressWith(CompressionAlgorithm)` method.  For\nexample:\n\n[,java]\n----\nJwts.builder()\n\n   .compressWith(Jwts.ZIP.DEF) // DEFLATE compression algorithm\n\n   // .. etc ...\n----\n\nIf you use any of the algorithm constants in the `Jwts.ZIP` class, that's it, you're done.  You don't have to\ndo anything during parsing or configure the `JwtParserBuilder` for compression - JJWT will automatically decompress\nthe payload as expected.\n\n+++<a name=\"compression-custom\">++++++</a>+++\n\n=== Custom Compression Algorithm\n\nIf the default `Jwts.ZIP` compression algorithms are not suitable for your needs, you can create your own\n`CompressionAlgorithm` implementation(s).\n\nJust as you would with the default algorithms, you may specify that you want a JWT compressed by calling the\n``JwtBuilder``'s `compressWith` method, supplying your custom implementation instance.  For example:\n\n[,java]\n----\nCompressionAlgorithm myAlg = new MyCompressionAlgorithm();\n\nJwts.builder()\n\n   .compressWith(myAlg) // <----\n\n   // .. etc ...\n----\n\nWhen you call `compressWith`, the JWT `payload` will be compressed with your algorithm, and the\nhttps://www.rfc-editor.org/rfc/rfc7516.html#section-4.1.3[`zip` (Compression Algorithm)]\nheader will automatically be set to the value returned by your algorithm's `algorithm.getId()` method as\nrequired by the JWT specification.\n\n+++<a name=\"compression-custom-locator\">++++++</a>+++\n// legacy link\nHowever, the `JwtParser` needs to be aware of this custom algorithm as well, so it can use it while parsing. You do this\nby modifying the ``JwtParserBuilder``'s `zip()` collection.  For example:\n\n[,java]\n----\nCompressionAlgorithm myAlg = new MyCompressionAlgorithm();\n\nJwts.parser()\n\n    .zip().add(myAlg).and() // <----\n\n    // .. etc ...\n----\n\nThis adds additional `CompressionAlgorithm` implementations to the parser's overall total set of supported compression\nalgorithms (which already includes all of the `Jwts.ZIP` algorithms by default).\n\nThe parser will then automatically check to see if the JWT `zip` header has been set to see if a compression\nalgorithm has been used to compress the JWT.  If set, the parser will automatically look up your\n`CompressionAlgorithm` by its `getId()` value, and use it to decompress the JWT.\n\n+++<a name=\"json\">++++++</a>+++\n\n== JSON Support\n\nA `JwtBuilder` will serialize the `Header` and `Claims` maps (and potentially any Java objects they\ncontain) to JSON with a `Serializer<Map<String, ?>>` instance.  Similarly, a `JwtParser` will\ndeserialize JSON into the `Header` and `Claims` using a `Deserializer<Map<String, ?>>` instance.\n\nIf you don't explicitly configure a ``JwtBuilder``'s `Serializer` or a ``JwtParserBuilder``'s `Deserializer`, JJWT will\nautomatically attempt to discover and use the following JSON implementations if found in the runtime classpath. +\nThey are checked in order, and the first one found is used:\n\n. Jackson: This will automatically be used if you specify `io.jsonwebtoken:jjwt-jackson` as a project runtime\ndependency.  Jackson supports POJOs as claims with full marshaling/unmarshaling as necessary.\n. Gson: This will automatically be used if you specify `io.jsonwebtoken:jjwt-gson` as a project runtime dependency.\nGson also supports POJOs as claims with full marshaling/unmarshaling as necessary.\n. JSON-Java (`org.json`): This will be used automatically if you specify `io.jsonwebtoken:jjwt-orgjson` as a\nproject runtime dependency.\n+\n[NOTE]\n====\n`org.json` APIs are natively enabled in Android environments so this is the recommended JSON processor for\nAndroid applications _unless_ you want to use POJOs as claims.  The `org.json` library supports simple\nObject-to-JSON marshaling, but it _does not_ support JSON-to-Object unmarshalling.\n====\n\n*If you want to use POJOs as claim values, use either the `io.jsonwebtoken:jjwt-jackson` or\n`io.jsonwebtoken:jjwt-gson` dependency* (or implement your own Serializer and Deserializer if desired). *But beware*,\nJackson will force a sizable (> 1 MB) dependency to an Android application thus increasing the app download size for\nmobile users.\n\n+++<a name=\"json-custom\">++++++</a>+++\n\n=== Custom JSON Processor\n\nIf you don't want to use JJWT's runtime dependency approach, or just want to customize how JSON serialization and\ndeserialization works, you can implement the `Serializer` and `Deserializer` interfaces and specify instances of\nthem on the `JwtBuilder` and `JwtParserBuilder` respectively.  For example:\n\nWhen creating a JWT:\n\n[,java]\n----\nSerializer<Map<String,?>> serializer = getMySerializer(); //implement me\n\nJwts.builder()\n\n    .json(serializer)\n\n    // ... etc ...\n----\n\nWhen reading a JWT:\n\n[,java]\n----\nDeserializer<Map<String,?>> deserializer = getMyDeserializer(); //implement me\n\nJwts.parser()\n\n    .json(deserializer)\n\n    // ... etc ...\n----\n\n+++<a name=\"json-jackson\">++++++</a>+++\n\n=== Jackson JSON Processor\n\nIf you want to use Jackson for JSON processing, just including the `io.jsonwebtoken:jjwt-jackson` dependency as a\nruntime dependency is all that is necessary in most projects, since Gradle and Maven will automatically pull in\nthe necessary Jackson dependencies as well.\n\nAfter including this dependency, JJWT will automatically find the Jackson implementation on the runtime classpath and\nuse it internally for JSON parsing.  There is nothing else you need to do - JJWT will automatically create a new\nJackson ObjectMapper for its needs as required.\n\nHowever, if you have an application-wide Jackson `ObjectMapper` (as is typically recommended for most applications),\nyou can configure JJWT to use your own `ObjectMapper` instead.\n\nYou do this by declaring the `io.jsonwebtoken:jjwt-jackson` dependency with *compile* scope (not runtime\nscope which is the typical JJWT default).  That is:\n\n*Maven*\n\n[,xml,subs=\"+attributes\"]\n----\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-jackson</artifactId>\n    <version>{project-version}</version>\n    <scope>compile</scope> <!-- Not runtime -->\n</dependency>\n----\n\n*Gradle or Android*\n\n[,groovy,subs=\"+attributes\"]\n----\ndependencies {\n    implementation 'io.jsonwebtoken:jjwt-jackson:{project-version}'\n}\n----\n\nAnd then you can specify the `JacksonSerializer` using your own `ObjectMapper` on the `JwtBuilder`:\n\n[,java]\n----\nObjectMapper objectMapper = getMyObjectMapper(); //implement me\n\nString jws = Jwts.builder()\n\n    .json(new JacksonSerializer(objectMapper))\n\n    // ... etc ...\n----\n\nand the `JacksonDeserializer` using your `ObjectMapper` on the `JwtParserBuilder`:\n\n[,java]\n----\nObjectMapper objectMapper = getMyObjectMapper(); //implement me\n\nJwts.parser()\n\n    .json(new JacksonDeserializer(objectMapper))\n\n    // ... etc ...\n----\n\n+++<a name=\"json-jackson-custom-types\">++++++</a>+++\n\n==== Parsing of Custom Claim Types\n\nBy default, JJWT will only convert simple claim types: String, Date, Long, Integer, Short and Byte.  If you need to\ndeserialize other types you can configure the `JacksonDeserializer` by passing a `Map` of claim names to types in\nthrough a constructor. For example:\n\n[,java]\n----\nnew JacksonDeserializer(Maps.of(\"user\", User.class).build())\n----\n\nThis would trigger the value in the `user` claim to be deserialized into the custom type of `User`.  Given the claims\npayload of:\n\n[,json]\n----\n{\n    \"issuer\": \"https://example.com/issuer\",\n    \"user\": {\n      \"firstName\": \"Jill\",\n      \"lastName\": \"Coder\"\n    }\n}\n----\n\nThe `User` object could be retrieved from the `user` claim with the following code:\n\n[,java]\n----\nJwts.parser()\n\n    .json(new JacksonDeserializer(Maps.of(\"user\", User.class).build())) // <-----\n\n    .build()\n\n    .parseUnprotectedClaims(aJwtString)\n\n    .getPayload()\n\n    .get(\"user\", User.class); // <-----\n----\n\n[NOTE]\n====\nUsing this constructor is mutually exclusive with the `JacksonDeserializer(ObjectMapper)` constructor\n<<json-jackson,described above>>. This is because JJWT configures an `ObjectMapper` directly and could have negative\nconsequences for a shared `ObjectMapper` instance. This should work for most applications, if you need a more advanced\nparsing options, <<json-jackson,configure the mapper directly>>.\n====\n\n+++<a name=\"json-gson\">++++++</a>+++\n\n=== Gson JSON Processor\n\nIf you want to use Gson for JSON processing, just including the `io.jsonwebtoken:jjwt-gson` dependency as a\nruntime dependency is all that is necessary in most projects, since Gradle and Maven will automatically pull in\nthe necessary Gson dependencies as well.\n\nAfter including this dependency, JJWT will automatically find the Gson implementation on the runtime classpath and\nuse it internally for JSON parsing.  There is nothing else you need to do - just declaring the dependency is\nall that is required, no code or config is necessary.\n\nIf you're curious, JJWT will automatically create an internal default Gson instance for its own needs as follows:\n\n[,java]\n----\nnew GsonBuilder()\n    .registerTypeHierarchyAdapter(io.jsonwebtoken.lang.Supplier.class, GsonSupplierSerializer.INSTANCE)\n    .disableHtmlEscaping().create();\n----\n\nThe `registerTypeHierarchyAdapter` builder call is required to serialize JWKs with secret or private values.\n\nHowever, if you prefer to use a different Gson instance instead of JJWT's default, you can configure JJWT to use your\nown - just don't forget to register the necessary JJWT type hierarchy adapter.\n\nYou do this by declaring the `io.jsonwebtoken:jjwt-gson` dependency with *compile* scope (not runtime\nscope which is the typical JJWT default).  That is:\n\n*Maven*\n\n[,xml,subs=\"+attributes\"]\n----\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-gson</artifactId>\n    <version>{project-version}</version>\n    <scope>compile</scope> <!-- Not runtime -->\n</dependency>\n----\n\n*Gradle or Android*\n\n[,groovy,subs=\"+attributes\"]\n----\ndependencies {\n    implementation 'io.jsonwebtoken:jjwt-gson:{project-version}'\n}\n----\n\nAnd then you can specify the `GsonSerializer` using your own `Gson` instance on the `JwtBuilder`:\n\n[,java]\n----\n\nGson gson = new GsonBuilder()\n    // don't forget this line!:\n    .registerTypeHierarchyAdapter(io.jsonwebtoken.lang.Supplier.class, GsonSupplierSerializer.INSTANCE)\n    .disableHtmlEscaping().create();\n\nString jws = Jwts.builder()\n\n    .json(new GsonSerializer(gson))\n\n    // ... etc ...\n----\n\nand the `GsonDeserializer` using your `Gson` instance on the `JwtParser`:\n\n[,java]\n----\nGson gson = getGson(); //implement me\n\nJwts.parser()\n\n    .json(new GsonDeserializer(gson))\n\n    // ... etc ...\n----\n\nAgain, as shown above, it is critical to create your `Gson` instance using the `GsonBuilder` and include the line:\n\n[,java]\n----\n.registerTypeHierarchyAdapter(io.jsonwebtoken.lang.Supplier.class, GsonSupplierSerializer.INSTANCE)\n----\n\nto ensure JWK serialization works as expected.\n\n+++<a name=\"base64\">++++++</a>+++\n\n== Base64 Support\n\nJJWT uses a very fast pure-Java https://tools.ietf.org/html/rfc4648[Base64] codec for Base64 and\nBase64Url encoding and decoding that is guaranteed to work deterministically in all JDK and Android environments.\n\nYou can access JJWT's encoders and decoders using the `io.jsonwebtoken.io.Encoders` and `io.jsonwebtoken.io.Decoders`\nutility classes.\n\n`io.jsonwebtoken.io.Encoders`:\n\n* `BASE64` is an RFC 4648 https://tools.ietf.org/html/rfc4648#section-4[Base64] encoder\n* `BASE64URL` is an RFC 4648 https://tools.ietf.org/html/rfc4648#section-5[Base64URL] encoder\n\n`io.jsonwebtoken.io.Decoders`:\n\n* `BASE64` is an RFC 4648 https://tools.ietf.org/html/rfc4648#section-4[Base64] decoder\n* `BASE64URL` is an RFC 4648 https://tools.ietf.org/html/rfc4648#section-5[Base64URL] decoder\n\n+++<a name=\"base64-security\">++++++</a>+++\n\n=== Understanding Base64 in Security Contexts\n\nAll cryptographic operations, like encryption and message digest calculations, result in binary data - raw byte arrays.\n\nBecause raw byte arrays cannot be represented natively in JSON, the JWT\nspecifications employ the Base64URL encoding scheme to represent these raw byte values in JSON documents or compound\nstructures like a JWT.\n\nThis means that the Base64 and Base64URL algorithms take a raw byte array and converts the bytes into a string suitable\nto use in text documents and protocols like HTTP.  These algorithms can also convert these strings back\ninto the original raw byte arrays for decryption or signature verification as necessary.\n\nThat's nice and convenient, but there are two very important properties of Base64 (and Base64URL) text strings that\nare critical to remember when they are used in security scenarios like with JWTs:\n\n* <<base64-not-encryption,Base64 is not encryption>>\n* <<base64-changing-characters,Changing Base64 characters>> *does not automatically invalidate data*.\n\n+++<a name=\"base64-not-encryption\">++++++</a>+++\n\n==== Base64 is not encryption\n\nBase64-encoded text is _not_ encrypted.\n\nWhile a byte array representation can be converted to text with the Base64 algorithms,\nanyone in the world can take Base64-encoded text, decode it with any standard Base64 decoder, and obtain the\nunderlying raw byte array data.  No key or secret is required to decode Base64 text - anyone can do it.\n\nBased on this, when encoding sensitive byte data with Base64 - like a shared or private key - *the resulting\nstring is NOT safe to expose publicly*.\n\nA base64-encoded key is still sensitive information and must be kept as secret and as safe as the original source\nof the bytes (e.g. a Java `PrivateKey` or `SecretKey` instance).\n\nAfter Base64-encoding data into a string, it is possible to then encrypt the string to keep it safe from prying\neyes if desired, but this is different.  Encryption is not encoding.  They are separate concepts.\n\n+++<a name=\"base64-changing-characters\">++++++</a>+++\n\n==== Changing Base64 Characters\n\nIn an effort to see if signatures or encryption is truly validated correctly, some try to edit a JWT\nstring - particularly the Base64-encoded signature part - to see if the edited string fails security validations.\n\nThis conceptually makes sense: change the signature string, you would assume that signature validation would fail.\n\n_But this doesn't always work. Changing base64 characters is an invalid test_.\n\nWhy?\n\nBecause of the way the Base64 algorithm works, there are multiple Base64 strings that can represent the same raw byte\narray.\n\nGoing into the details of the Base64 algorithm is out of scope for this documentation, but there are many good\nStackoverflow https://stackoverflow.com/questions/33663113/multiple-strings-base64-decoded-to-same-byte-array?noredirect=1&lq=1[answers]\nand https://github.com/jwtk/jjwt/issues/211#issuecomment-283076269[JJWT issue comments] that explain this in detail.\nHere's one https://stackoverflow.com/questions/29941270/why-do-base64-decode-produce-same-byte-array-for-different-strings[good answer]:\n\n[IMPORTANT]\n====\nRemember that Base64 encodes each 8 bit entity into 6 bit chars. The resulting string then needs exactly\n11 * 8 / 6 bytes, or 14 2/3 chars. But you can't write partial characters. Only the first 4 bits (or 2/3 of the\nlast char) are significant. The last two bits are not decoded. Thus all of:\n\n[,text]\n----\ndGVzdCBzdHJpbmo\ndGVzdCBzdHJpbmp\ndGVzdCBzdHJpbmq\ndGVzdCBzdHJpbmr \n----\nAll decode to the same 11 bytes (116, 101, 115, 116, 32, 115, 116, 114, 105, 110, 106).\n====\n\nAs you can see by the above 4 examples, they all decode to the same exact 11 bytes.  So just changing one or two\ncharacters at the end of a Base64 string may not work and can often result in an invalid test.\n\n+++<a name=\"base64-invalid-characters\">++++++</a>+++\n\n===== Adding Invalid Characters\n\nJJWT's default Base64/Base64URL decoders automatically ignore illegal Base64 characters located in the beginning and\nend of an encoded string. Therefore, prepending or appending invalid characters like `{` or `]` or similar will also\nnot fail JJWT's signature checks either.  Why?\n\nBecause such edits - whether changing a trailing character or two, or appending invalid characters - do not actually\nchange the _real_ signature, which in cryptographic contexts, is always a byte array. Instead, tests like these\nchange a text encoding of the byte array, and as we covered above, they are different things.\n\nSo JJWT 'cares' more about the real byte array and less about its text encoding because that is what actually matters\nin cryptographic operations.  In this sense, JJWT follows the https://en.wikipedia.org/wiki/Robustness_principle[Robustness Principle]\nin being _slightly_ lenient on what is accepted per the rules of Base64, but if anything in the real underlying\nbyte array is changed, then yes, JJWT's cryptographic assertions will definitely fail.\n\nTo help understand JJWT's approach, we have to remember why signatures exist. From our documentation above on\n<<jws,signing JWTs>>:\n\n____\n* guarantees it was created by someone we know (it is authentic), as well as\n* guarantees that no-one has manipulated or changed it after it was created (its integrity is maintained).\n____\n\nJust prepending or appending invalid text to try to 'trick' the algorithm doesn't change the integrity of the\nunderlying claims or signature byte arrays, nor the authenticity of the claims byte array, because those byte\narrays are still obtained intact.\n\nPlease see https://github.com/jwtk/jjwt/issues/518[JJWT Issue #518] and its referenced issues and links for more\ninformation.\n\n+++<a name=\"base64-custom\">++++++</a>+++\n\n=== Custom Base64\n\nIf for some reason you want to specify your own Base64Url encoder and decoder, you can use the `JwtBuilder`\n`encoder` method to set the encoder:\n\n[,java]\n----\nEncoder<byte[], String> encoder = getMyBase64UrlEncoder(); //implement me\n\nString jws = Jwts.builder()\n\n    .b64Url(encoder)\n\n    // ... etc ...\n----\n\nand the ``JwtParserBuilder``'s `decoder` method to set the decoder:\n\n[,java]\n----\nDecoder<String, byte[]> decoder = getMyBase64UrlDecoder(); //implement me\n\nJwts.parser()\n\n    .b64Url(decoder)\n\n    // ... etc ...\n----\n\n+++<a name=\"examples\">++++++</a>+++\n\n== Examples\n\n* <<example-jws-hs,JWS Signed with HMAC>>\n* <<example-jws-rsa,JWS Signed with RSA>>\n* <<example-jws-ecdsa,JWS Signed with ECDSA>>\n* <<example-jws-eddsa,JWS Signed with EdDSA>>\n* <<example-jwe-dir,JWE Encrypted Directly with a SecretKey>>\n* <<example-jwe-rsa,JWE Encrypted with RSA>>\n* <<example-jwe-aeskw,JWE Encrypted with AES Key Wrap>>\n* <<example-jwe-ecdhes,JWE Encrypted with ECDH-ES>>\n* <<example-jwe-password,JWE Encrypted with a Password>>\n* <<example-jwk-secret,SecretKey JWK>>\n* <<example-jwk-rsapub,RSA Public JWK>>\n* <<example-jwk-rsapriv,RSA Private JWK>>\n* <<example-jwk-ecpub,Elliptic Curve Public JWK>>\n* <<example-jwk-ecpriv,Elliptic Curve Private JWK>>\n* <<example-jwk-edpub,Edwards Elliptic Curve Public JWK>>\n* <<example-jwk-edpriv,Edwards Elliptic Curve Private JWK>>\n\n+++<a name=\"example-jws-hs\">++++++</a>+++\n\n=== JWT Signed with HMAC\n\nThis is an example showing how to digitally sign a JWT using an https://en.wikipedia.org/wiki/HMAC[HMAC]\n(hash-based message authentication code).  The JWT specifications define 3 standard HMAC signing algorithms:\n\n* `HS256`: HMAC with SHA-256. This requires a 256-bit (32 byte) `SecretKey` or larger.\n* `HS384`: HMAC with SHA-384. This requires a 384-bit (48 byte) `SecretKey` or larger.\n* `HS512`: HMAC with SHA-512. This requires a 512-bit (64 byte) `SecretKey` or larger.\n\nExample:\n\n[,java]\n----\n// Create a test key suitable for the desired HMAC-SHA algorithm:\nMacAlgorithm alg = Jwts.SIG.HS512; //or HS384 or HS256\nSecretKey key = alg.key().build();\n\nString message = \"Hello World!\";\nbyte[] content = message.getBytes(StandardCharsets.UTF_8);\n\n// Create the compact JWS:\nString jws = Jwts.builder().content(content, \"text/plain\").signWith(key, alg).compact();\n\n// Parse the compact JWS:\ncontent = Jwts.parser().verifyWith(key).build().parseSignedContent(jws).getPayload();\n\nassert message.equals(new String(content, StandardCharsets.UTF_8));\n----\n\n+++<a name=\"example-jws-rsa\">++++++</a>+++\n\n=== JWT Signed with RSA\n\nThis is an example showing how to digitally sign and verify a JWT using RSA cryptography. The JWT specifications\ndefine <<jws-alg,6 standard RSA signing algorithms>>.  All 6 require that <<jws-key-rsa,RSA keys 2048-bits or larger>>\nmust be used.\n\nIn this example, Bob will sign a JWT using his RSA private key, and Alice can verify it came from Bob using Bob's RSA\npublic key:\n\n[,java]\n----\n// Create a test key suitable for the desired RSA signature algorithm:\nSignatureAlgorithm alg = Jwts.SIG.RS512; //or PS512, RS256, etc...\nKeyPair pair = alg.keyPair().build();\n\n// Bob creates the compact JWS with his RSA private key:\nString jws = Jwts.builder().subject(\"Alice\")\n    .signWith(pair.getPrivate(), alg) // <-- Bob's RSA private key\n    .compact();\n\n// Alice receives and verifies the compact JWS came from Bob:\nString subject = Jwts.parser()\n    .verifyWith(pair.getPublic()) // <-- Bob's RSA public key\n    .build().parseSignedClaims(jws).getPayload().getSubject();\n\nassert \"Alice\".equals(subject);\n----\n\n+++<a name=\"example-jws-ecdsa\">++++++</a>+++\n\n=== JWT Signed with ECDSA\n\nThis is an example showing how to digitally sign and verify a JWT using the Elliptic Curve Digital Signature Algorithm.\nThe JWT specifications define <<jws-alg,3 standard ECDSA signing algorithms>>:\n\n* `ES256`: ECDSA using P-256 and SHA-256. This requires an EC Key exactly 256 bits (32 bytes) long.\n* `ES384`: ECDSA using P-384 and SHA-384. This requires an EC Key exactly 384 bits (48 bytes) long.\n* `ES512`: ECDSA using P-521 and SHA-512. This requires an EC Key exactly 521 bits (65 or 66 bytes depending on format) long.\n\nIn this example, Bob will sign a JWT using his EC private key, and Alice can verify it came from Bob using Bob's EC\npublic key:\n\n[,java]\n----\n// Create a test key suitable for the desired ECDSA signature algorithm:\nSignatureAlgorithm alg = Jwts.SIG.ES512; //or ES256 or ES384\nKeyPair pair = alg.keyPair().build();\n\n// Bob creates the compact JWS with his EC private key:\nString jws = Jwts.builder().subject(\"Alice\")\n    .signWith(pair.getPrivate(), alg) // <-- Bob's EC private key\n    .compact();\n\n// Alice receives and verifies the compact JWS came from Bob:\nString subject = Jwts.parser()\n    .verifyWith(pair.getPublic()) // <-- Bob's EC public key\n    .build().parseSignedClaims(jws).getPayload().getSubject();\n\nassert \"Alice\".equals(subject);\n----\n\n+++<a name=\"example-jws-eddsa\">++++++</a>+++\n\n=== JWT Signed with EdDSA\n\nThis is an example showing how to digitally sign and verify a JWT using the\nhttps://www.rfc-editor.org/rfc/rfc8032[Edwards Curve Digital Signature Algorithm] using\n`Ed25519` or `Ed448` keys.\n\n[NOTE]\n====\nThe `Ed25519` and `Ed448` algorithms require JDK 15 or a compatible JCA Provider\n(like BouncyCastle) in the runtime classpath.\n\nIf you are using JDK 14 or earlier and you want to use them, see\nthe <<Installation,Installation>> section to see how to enable BouncyCastle.\n====\n\nThe `EdDSA` signature algorithm is defined for JWS in https://www.rfc-editor.org/rfc/rfc8037#section-3.1[RFC 8037, Section 3.1]\nusing keys for two Edwards curves:\n\n* `Ed25519`: `EdDSA` using curve `Ed25519`. `Ed25519` algorithm keys must be 255 bits long and produce\n           signatures 512 bits (64 bytes) long.\n* `Ed448`: `EdDSA` using curve `Ed448`. `Ed448` algorithm keys must be 448 bits long and produce signatures\n         912 bits (114 bytes) long.\n\nIn this example, Bob will sign a JWT using his Edwards Curve private key, and Alice can verify it came from Bob\nusing Bob's Edwards Curve public key:\n\n[,java]\n----\n// Create a test key suitable for the EdDSA signature algorithm using Ed25519 or Ed448 keys:\nCurve curve = Jwks.CRV.Ed25519; //or Ed448\nKeyPair pair = curve.keyPair().build();\n\n// Bob creates the compact JWS with his Edwards Curve private key:\nString jws = Jwts.builder().subject(\"Alice\")\n    .signWith(pair.getPrivate(), Jwts.SIG.EdDSA) // <-- Bob's Edwards Curve private key w/ EdDSA\n    .compact();\n\n// Alice receives and verifies the compact JWS came from Bob:\nString subject = Jwts.parser()\n    .verifyWith(pair.getPublic()) // <-- Bob's Edwards Curve public key\n    .build().parseSignedClaims(jws).getPayload().getSubject();\n\nassert \"Alice\".equals(subject);\n----\n\n+++<a name=\"example-jwe-dir\">++++++</a>+++\n\n=== JWT Encrypted Directly with a SecretKey\n\nThis is an example showing how to encrypt a JWT <<jwe-alg-dir,directly using a symmetric secret key>>.  The\nJWT specifications define <<jwe-enc,6 standard AEAD Encryption algorithms>>:\n\n* `A128GCM`: AES GCM using a 128-bit (16 byte) `SecretKey` or larger.\n* `A192GCM`: AES GCM using a 192-bit (24 byte) `SecretKey` or larger.\n* `A256GCM`: AES GCM using a 256-bit (32 byte) `SecretKey` or larger.\n* `A128CBC-HS256`: https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.3[AES_128_CBC_HMAC_SHA_256] using a\n256-bit (32 byte) `SecretKey`.\n* `A192CBC-HS384`: https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.4[AES_192_CBC_HMAC_SHA_384] using a\n384-bit (48 byte) `SecretKey`.\n* `A256CBC-HS512`: https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.5[AES_256_CBC_HMAC_SHA_512] using a\n512-bit (64 byte) `SecretKey`.\n\nThe AES GCM (`A128GCM`, `A192GCM` and `A256GCM`) algorithms are strongly recommended - they are faster and more\nefficient than the `A*CBC-HS*` variants, but they do require JDK 8 or later (or JDK 7 + BouncyCastle).\n\nExample:\n\n[,java]\n----\n// Create a test key suitable for the desired payload encryption algorithm:\n// (A*GCM algorithms are recommended, but require JDK >= 8 or BouncyCastle)\nAeadAlgorithm enc = Jwts.ENC.A256GCM; //or A128GCM, A192GCM, A256CBC-HS512, etc...\nSecretKey key = enc.key().build();\n\nString message = \"Live long and prosper.\";\nbyte[] content = message.getBytes(StandardCharsets.UTF_8);\n\n// Create the compact JWE:\nString jwe = Jwts.builder().content(content, \"text/plain\").encryptWith(key, enc).compact();\n\n// Parse the compact JWE:\ncontent = Jwts.parser().decryptWith(key).build().parseEncryptedContent(jwe).getPayload();\n\nassert message.equals(new String(content, StandardCharsets.UTF_8));\n----\n\n+++<a name=\"example-jwe-rsa\">++++++</a>+++\n\n=== JWT Encrypted with RSA\n\nThis is an example showing how to encrypt and decrypt a JWT using RSA cryptography.\n\nBecause RSA cannot encrypt much data, RSA is used to encrypt and decrypt a secure-random key, and that generated key\nin turn is used to actually encrypt the payload as described in the link:jwe-alg-rsa[RSA Key Encryption] section\nabove. As such, RSA Key Algorithms must be paired with an AEAD Encryption Algorithm, as shown below.\n\nIn this example, Bob will encrypt a JWT using Alice's RSA public key to ensure only she may read it.  Alice can then\ndecrypt the JWT using her RSA private key:\n\n[,java]\n----\n// Create a test KeyPair suitable for the desired RSA key algorithm:\nKeyPair pair = Jwts.SIG.RS512.keyPair().build();\n\n// Choose the key algorithm used encrypt the payload key:\nKeyAlgorithm<PublicKey, PrivateKey> alg = Jwts.KEY.RSA_OAEP_256; //or RSA_OAEP or RSA1_5\n// Choose the Encryption Algorithm to encrypt the payload:\nAeadAlgorithm enc = Jwts.ENC.A256GCM; //or A192GCM, A128GCM, A256CBC-HS512, etc...\n\n// Bob creates the compact JWE with Alice's RSA public key so only she may read it:\nString jwe = Jwts.builder().audience().add(\"Alice\").and()\n    .encryptWith(pair.getPublic(), alg, enc) // <-- Alice's RSA public key\n    .compact();\n\n// Alice receives and decrypts the compact JWE:\nSet<String> audience = Jwts.parser()\n    .decryptWith(pair.getPrivate()) // <-- Alice's RSA private key\n    .build().parseEncryptedClaims(jwe).getPayload().getAudience();\n\nassert audience.contains(\"Alice\");\n----\n\n+++<a name=\"example-jwe-aeskw\">++++++</a>+++\n\n=== JWT Encrypted with AES Key Wrap\n\nThis is an example showing how to encrypt and decrypt a JWT using AES Key Wrap algorithms.\n\nThese algorithms use AES to encrypt and decrypt a secure-random key, and that generated key in turn is used to actually encrypt\nthe payload as described in the link:jwe-alg-aes[AES Key Encryption] section above. This allows the payload to be\nencrypted with a random short-lived key, reducing material exposure of the potentially longer-lived symmetric secret\nkey.  This approach requires the AES Key Wrap algorithms to be paired with an AEAD content encryption algorithm,\nas shown below.\n\nThe AES GCM Key Wrap algorithms (`A128GCMKW`, `A192GCMKW` and `A256GCMKW`) are preferred - they are faster and more\nefficient than the `A*KW` variants, but they do require JDK 8 or later (or JDK 7 + BouncyCastle).\n\n[,java]\n----\n// Create a test SecretKey suitable for the desired AES Key Wrap algorithm:\nSecretKeyAlgorithm alg = Jwts.KEY.A256GCMKW; //or A192GCMKW, A128GCMKW, A256KW, etc...\nSecretKey key = alg.key().build();\n\n// Chooose the Encryption Algorithm used to encrypt the payload:\nAeadAlgorithm enc = Jwts.ENC.A256GCM; //or A192GCM, A128GCM, A256CBC-HS512, etc...\n\n// Create the compact JWE:\nString jwe = Jwts.builder().issuer(\"me\").encryptWith(key, alg, enc).compact();\n\n// Parse the compact JWE:\nString issuer = Jwts.parser().decryptWith(key).build()\n    .parseEncryptedClaims(jwe).getPayload().getIssuer();\n\nassert \"me\".equals(issuer);\n----\n\n+++<a name=\"example-jwe-ecdhes\">++++++</a>+++\n\n=== JWT Encrypted with ECDH-ES\n\nThis is an example showing how to encrypt and decrypt a JWT using Elliptic Curve Diffie-Hellman Ephemeral Static\nKey Agreement (ECDH-ES) algorithms.\n\nThese algorithms use ECDH-ES to encrypt and decrypt a secure-random key, and that\ngenerated key in turn is used to actually encrypt the payload as described in the\nlink:jwe-alg-ecdhes[Elliptic Curve Diffie-Hellman Ephemeral Static Key Agreement] section above. Because of this, ECDH-ES\nKey Algorithms must be paired with an AEAD Encryption Algorithm, as shown below.\n\nIn this example, Bob will encrypt a JWT using Alice's Elliptic Curve public key to ensure only she may read it. +\nAlice can then decrypt the JWT using her Elliptic Curve private key:\n\n[,java]\n----\n// Create a test KeyPair suitable for the desired EC key algorithm:\nKeyPair pair = Jwts.SIG.ES512.keyPair().build();\n\n// Choose the key algorithm used encrypt the payload key:\nKeyAlgorithm<PublicKey, PrivateKey> alg = Jwts.KEY.ECDH_ES_A256KW; //ECDH_ES_A192KW, etc...\n// Choose the Encryption Algorithm to encrypt the payload:\nAeadAlgorithm enc = Jwts.ENC.A256GCM; //or A192GCM, A128GCM, A256CBC-HS512, etc...\n\n// Bob creates the compact JWE with Alice's EC public key so only she may read it:\nString jwe = Jwts.builder().audience().add(\"Alice\").and()\n    .encryptWith(pair.getPublic(), alg, enc) // <-- Alice's EC public key\n    .compact();\n\n// Alice receives and decrypts the compact JWE:\nSet<String> audience = Jwts.parser()\n    .decryptWith(pair.getPrivate()) // <-- Alice's EC private key\n    .build().parseEncryptedClaims(jwe).getPayload().getAudience();\n\nassert audience.contains(\"Alice\");\n----\n\n+++<a name=\"example-jwe-password\">++++++</a>+++\n\n=== JWT Encrypted with a Password\n\nThis is an example showing how to encrypt and decrypt a JWT using Password-based key-derivation algorithms.\n\nThese algorithms use a password to securely derive a random key, and that derived random key in turn is used to actually\nencrypt the payload as described in the link:jwe-alg-pbes2[Password-based Key Encryption] section above. This allows\nthe payload to be encrypted with a random short-lived cryptographically-stronger key, reducing the need to\nexpose the longer-lived (and potentially weaker) password.\n\nThis approach requires the Password-based Key Wrap algorithms to be paired with an AEAD content encryption algorithm,\nas shown below.\n\n[,java]\n----\n//DO NOT use this example password in a real app, it is well-known to password crackers:\nString pw = \"correct horse battery staple\";\nPassword password = Keys.password(pw.toCharArray());\n\n// Choose the desired PBES2 key derivation algorithm:\nKeyAlgorithm<Password, Password> alg = Jwts.KEY.PBES2_HS512_A256KW; //or PBES2_HS384_A192KW or PBES2_HS256_A128KW\n\n// Optionally choose the number of PBES2 computational iterations to use to derive the key.\n// This is optional - if you do not specify a value, JJWT will automatically choose a value\n// based on your chosen PBES2 algorithm and OWASP PBKDF2 recommendations here:\n// https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2\n//\n// If you do specify a value, ensure the iterations are large enough for your desired alg\n//int pbkdf2Iterations = 120000; //for HS512. Needs to be much higher for smaller hash algs.\n\n// Choose the Encryption Algorithm used to encrypt the payload:\nAeadAlgorithm enc = Jwts.ENC.A256GCM; //or A192GCM, A128GCM, A256CBC-HS512, etc...\n\n// Create the compact JWE:\nString jwe = Jwts.builder().issuer(\"me\")\n    // Optional work factor is specified in the header:\n    //.header().pbes2Count(pbkdf2Iterations)).and()\n    .encryptWith(password, alg, enc)\n    .compact();\n\n// Parse the compact JWE:\nString issuer = Jwts.parser().decryptWith(password)\n    .build().parseEncryptedClaims(jwe).getPayload().getIssuer();\n\nassert \"me\".equals(issuer);\n----\n\n+++<a name=\"example-jwk-secret\">++++++</a>+++\n\n=== SecretKey JWK\n\nExample creating and parsing a secret JWK:\n\n[,java]\n----\nSecretKey key = Jwts.SIG.HS512.key().build(); // or HS384 or HS256\nSecretJwk jwk = Jwks.builder().key(key).idFromThumbprint().build();\n\nassert jwk.getId().equals(jwk.thumbprint().toString());\nassert key.equals(jwk.toKey());\n\nbyte[] utf8Bytes = new JacksonSerializer().serialize(jwk); // or GsonSerializer(), etc\nString jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);\nJwk<?> parsed = Jwks.parser().build().parse(jwkJson);\n\nassert parsed instanceof SecretJwk;\nassert jwk.equals(parsed);\n----\n\n+++<a name=\"example-jwk-rsapub\">++++++</a>+++\n\n=== RSA Public JWK\n\nExample creating and parsing an RSA Public JWK:\n\n[,java]\n----\nRSAPublicKey key = (RSAPublicKey)Jwts.SIG.RS512.keyPair().build().getPublic();\nRsaPublicJwk jwk = Jwks.builder().key(key).idFromThumbprint().build();\n\nassert jwk.getId().equals(jwk.thumbprint().toString());\nassert key.equals(jwk.toKey());\n\nbyte[] utf8Bytes = new JacksonSerializer().serialize(jwk); // or GsonSerializer(), etc\nString jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);\nJwk<?> parsed = Jwks.parser().build().parse(jwkJson);\n\nassert parsed instanceof RsaPublicJwk;\nassert jwk.equals(parsed);\n----\n\n+++<a name=\"example-jwk-rsapriv\">++++++</a>+++\n\n=== RSA Private JWK\n\nExample creating and parsing an RSA Private JWK:\n\n[,java]\n----\nKeyPair pair = Jwts.SIG.RS512.keyPair().build();\nRSAPublicKey pubKey = (RSAPublicKey) pair.getPublic();\nRSAPrivateKey privKey = (RSAPrivateKey) pair.getPrivate();\n\nRsaPrivateJwk privJwk = Jwks.builder().key(privKey).idFromThumbprint().build();\nRsaPublicJwk pubJwk = privJwk.toPublicJwk();\n\nassert privJwk.getId().equals(privJwk.thumbprint().toString());\nassert pubJwk.getId().equals(pubJwk.thumbprint().toString());\nassert privKey.equals(privJwk.toKey());\nassert pubKey.equals(pubJwk.toKey());\n\nbyte[] utf8Bytes = new JacksonSerializer().serialize(privJwk); // or GsonSerializer(), etc\nString jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);\nJwk<?> parsed = Jwks.parser().build().parse(jwkJson);\n\nassert parsed instanceof RsaPrivateJwk;\nassert privJwk.equals(parsed);\n----\n\n+++<a name=\"example-jwk-ecpub\">++++++</a>+++\n\n=== Elliptic Curve Public JWK\n\nExample creating and parsing an Elliptic Curve Public JWK:\n\n[,java]\n----\nECPublicKey key = (ECPublicKey) Jwts.SIG.ES512.keyPair().build().getPublic();\nEcPublicJwk jwk = Jwks.builder().key(key).idFromThumbprint().build();\n\nassert jwk.getId().equals(jwk.thumbprint().toString());\nassert key.equals(jwk.toKey());\n\nbyte[] utf8Bytes = new JacksonSerializer().serialize(jwk); // or GsonSerializer(), etc\nString jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);\nJwk<?> parsed = Jwks.parser().build().parse(jwkJson);\n\nassert parsed instanceof EcPublicJwk;\nassert jwk.equals(parsed);\n----\n\n+++<a name=\"example-jwk-ecpriv\">++++++</a>+++\n\n=== Elliptic Curve Private JWK\n\nExample creating and parsing an Elliptic Curve Private JWK:\n\n[,java]\n----\nKeyPair pair = Jwts.SIG.ES512.keyPair().build();\nECPublicKey pubKey = (ECPublicKey) pair.getPublic();\nECPrivateKey privKey = (ECPrivateKey) pair.getPrivate();\n\nEcPrivateJwk privJwk = Jwks.builder().key(privKey).idFromThumbprint().build();\nEcPublicJwk pubJwk = privJwk.toPublicJwk();\n\nassert privJwk.getId().equals(privJwk.thumbprint().toString());\nassert pubJwk.getId().equals(pubJwk.thumbprint().toString());\nassert privKey.equals(privJwk.toKey());\nassert pubKey.equals(pubJwk.toKey());\n\nbyte[] utf8Bytes = new JacksonSerializer().serialize(privJwk); // or GsonSerializer(), etc\nString jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);\nJwk<?> parsed = Jwks.parser().build().parse(jwkJson);\n\nassert parsed instanceof EcPrivateJwk;\nassert privJwk.equals(parsed);\n----\n\n+++<a name=\"example-jwk-edpub\">++++++</a>+++\n\n=== Edwards Elliptic Curve Public JWK\n\nExample creating and parsing an Edwards Elliptic Curve (Ed25519, Ed448, X25519, X448) Public JWK\n(the JWT https://www.rfc-editor.org/rfc/rfc8037[RFC 8037] specification calls these `Octet` keys, hence the\n`OctetPublicJwk` interface names):\n\n[,java]\n----\nPublicKey key = Jwks.CRV.Ed25519.keyPair().build().getPublic(); // or Ed448, X25519, X448\nOctetPublicJwk<PublicKey> jwk = builder().octetKey(key).idFromThumbprint().build();\n\nassert jwk.getId().equals(jwk.thumbprint().toString());\nassert key.equals(jwk.toKey());\n\nbyte[] utf8Bytes = new JacksonSerializer().serialize(jwk); // or GsonSerializer(), etc\nString jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);\nJwk<?> parsed = Jwks.parser().build().parse(jwkJson);\n\nassert parsed instanceof OctetPublicJwk;\nassert jwk.equals(parsed);\n----\n\n+++<a name=\"example-jwk-edpriv\">++++++</a>+++\n\n=== Edwards Elliptic Curve Private JWK\n\nExample creating and parsing an Edwards Elliptic Curve (Ed25519, Ed448, X25519, X448) Private JWK\n(the JWT https://www.rfc-editor.org/rfc/rfc8037[RFC 8037] specification calls these `Octet` keys, hence the\n`OctetPrivateJwk` and `OctetPublicJwk` interface names):\n\n[,java]\n----\nKeyPair pair = Jwks.CRV.Ed448.keyPair().build(); // or Ed25519, X25519, X448\nPublicKey pubKey = pair.getPublic();\nPrivateKey privKey = pair.getPrivate();\n\nOctetPrivateJwk<PrivateKey, PublicKey> privJwk = builder().octetKey(privKey).idFromThumbprint().build();\nOctetPublicJwk<PublicKey> pubJwk = privJwk.toPublicJwk();\n\nassert privJwk.getId().equals(privJwk.thumbprint().toString());\nassert pubJwk.getId().equals(pubJwk.thumbprint().toString());\nassert privKey.equals(privJwk.toKey());\nassert pubKey.equals(pubJwk.toKey());\n\nbyte[] utf8Bytes = new JacksonSerializer().serialize(privJwk); // or GsonSerializer(), etc\nString jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);\nJwk<?> parsed = Jwks.parser().build().parse(jwkJson);\n\nassert parsed instanceof OctetPrivateJwk;\nassert privJwk.equals(parsed);\n----\n\n== Learn More\n\n* https://web.archive.org/web/20230427122653/https://stormpath.com/blog/jjwt-how-it-works-why[JSON Web Token for Java and Android]\n* https://web.archive.org/web/20230426235608/https://stormpath.com/blog/jwt-java-create-verify[How to Create and Verify JWTs in Java]\n* https://web.archive.org/web/20230428094039/https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage[Where to Store Your JWTs - Cookies vs HTML5 Web Storage]\n* https://web.archive.org/web/20230428184004/https://stormpath.com/blog/jwt-the-right-way[Use JWT the Right Way!]\n* https://web.archive.org/web/20230427151310/https://stormpath.com/blog/token-auth-for-java[Token Authentication for Java Applications]\n* xref:CHANGELOG.adoc[JJWT Changelog]\n\n== Author\n\nMaintained by Les Hazlewood & the extended Java community :heart:\n\n+++<a name=\"license\">++++++</a>+++\n\n== License\n\nThis project is open-source via the http://www.apache.org/licenses/LICENSE-2.0[Apache 2.0 License].\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 2.783203125,
          "content": "Thanks for helping make JJWT safe for everyone.\n\n# Security Policy\n\nThe JJWT development team are security professionals who take security seriously.  However, as we are an unpaid team of volunteers, we are unable to offer a bug bounty program.  Even so, we welcome any potential good faith security reports.\n\n## Supported Versions\n\nAs JJWT isn't yet at version 1.0, only the latest minor and point revisions are supported for security fixes.  \nWe ask that all users or security researchers upgrade to the latest stable release version and use that for testing before issuing a security report.\n\n| Version  | Supported          |\n| -------- | ------------------ |\n| 0.12.x   | :white_check_mark: |\n| < 0.12.0 | :x:                |\n\n## Reporting Security Issues\n\nIf you believe you have found a security vulnerability in the JJWT codebase, please report it to us through coordinated disclosure.\n\n**Please do not report security vulnerabilities through public GitHub issues, discussions, or pull requests.**\n\nInstead, please send an email to security[@]jjwt.org.\n\nPlease include as much of the information listed below as you can to help us better understand and resolve the issue:\n\n  * The type of issue (e.g., buffer overflow, invalid header behavior, etc)\n  * Full paths of source file(s) related to the manifestation of the issue\n  * The location of the affected source code (tag/branch/commit or direct URL)\n  * Any special configuration required to reproduce the issue\n  * Step-by-step instructions to reproduce the issue\n  * Proof-of-concept or exploit code (if possible)\n  * Impact of the issue, including how an attacker might exploit the issue\n\nThis information will help us triage your report more quickly.\n\n### Valid Issues\n\nIf we find the report to be valid - that is, we recognize it as actual security issue that needs to be fixed in the codebase - \nwe will work with you to identify a timeline for a public fix to be released.\n\nPlease do not publish any details related to the issue in any communication medium (blog posts, social media posts, etc) \nexcept via the above JJWT security email address.  This allows us to create and publish a pointfix release that \ncontains the necessary fix(es) to the public before public discussion might occur, allowing JJWT users to fix their applications.  \n\nOnce the fix is publicly released, we ask for one week of time to pass to allow application developers to upgrade to this \npointfix security release before publishing public communication or analysis (blog posts, etc) about the security vulnerability.\n\n### Invalid Issues\n\nIf we find that a report is not a problem with the JJWT codebase - such as a problem with how JJWT is being used, or counter to or in conflict with JJWT's documentation - we \nwill explain why we do not consider it a security issue and explain the expected solution.\n"
        },
        {
          "name": "api",
          "type": "tree",
          "content": null
        },
        {
          "name": "bom",
          "type": "tree",
          "content": null
        },
        {
          "name": "extensions",
          "type": "tree",
          "content": null
        },
        {
          "name": "impl",
          "type": "tree",
          "content": null
        },
        {
          "name": "mvnw",
          "type": "blob",
          "size": 9.8232421875,
          "content": "#!/bin/sh\n# ----------------------------------------------------------------------------\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n# ----------------------------------------------------------------------------\n\n# ----------------------------------------------------------------------------\n# Apache Maven Wrapper startup batch script, version 3.2.0\n#\n# Optional ENV vars\n# -----------------\n#   JAVA_HOME - location of a JDK home dir, required when download maven via java source\n#   MVNW_REPOURL - repo url base for downloading maven distribution\n#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven\n#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output\n# ----------------------------------------------------------------------------\n\nset -euf\n[ \"${MVNW_VERBOSE-}\" != debug ] || set -x\n\n# OS specific support.\nnative_path() { printf %s\\\\n \"$1\"; }\ncase \"$(uname)\" in\n(CYGWIN*|MINGW*) [ -z \"${JAVA_HOME-}\" ] || JAVA_HOME=\"$(cygpath --unix \"$JAVA_HOME\")\"\n                 native_path() { cygpath --path --windows \"$1\"; } ;;\nesac\n\n# set JAVACMD and JAVACCMD\nset_java_home() {\n  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched\n  if [ -n \"${JAVA_HOME-}\" ] ; then\n    if [ -x \"$JAVA_HOME/jre/sh/java\" ] ; then\n      # IBM's JDK on AIX uses strange locations for the executables\n      JAVACMD=\"$JAVA_HOME/jre/sh/java\"\n      JAVACCMD=\"$JAVA_HOME/jre/sh/javac\"\n    else\n      JAVACMD=\"$JAVA_HOME/bin/java\"\n      JAVACCMD=\"$JAVA_HOME/bin/javac\"\n\n      if [ ! -x \"$JAVACMD\" ] || [ ! -x \"$JAVACCMD\" ] ; then\n        echo \"The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run.\" >&2\n        echo \"JAVA_HOME is set to \\\"$JAVA_HOME\\\", but \\\"\\$JAVA_HOME/bin/java\\\" or \\\"\\$JAVA_HOME/bin/javac\\\" does not exist.\" >&2\n        return 1\n      fi\n    fi\n  else\n    JAVACMD=\"$('set' +e; 'unset' -f command 2>/dev/null; 'command' -v java)\" || :\n    JAVACCMD=\"$('set' +e; 'unset' -f command 2>/dev/null; 'command' -v javac)\" || :\n\n    if [ ! -x \"${JAVACMD-}\" ] || [ ! -x \"${JAVACCMD-}\" ] ; then\n      echo \"The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run.\" >&2\n      return 1\n    fi\n  fi\n}\n\n# hash string like Java String::hashCode\nhash_string() {\n  str=\"${1:-}\" h=0\n  while [ -n \"$str\" ]; do\n    h=$(( ( h * 31 + $(LC_CTYPE=C printf %d \"'$str\") ) % 4294967296 ))\n    str=\"${str#?}\"\n  done\n  printf %x\\\\n $h\n}\n\nverbose() { :; }\n[ \"${MVNW_VERBOSE-}\" != true ] || verbose() { printf %s\\\\n \"${1-}\"; }\n\ndie() {\n  printf %s\\\\n \"$1\" >&2\n  exit 1\n}\n\n# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties\nwhile IFS=\"=\" read -r key value; do\n  case \"${key-}\" in\n    distributionUrl) distributionUrl=\"${value-}\" ;;\n    distributionSha256Sum) distributionSha256Sum=\"${value-}\" ;;\n  esac\ndone < \"${0%/*}/.mvn/wrapper/maven-wrapper.properties\"\n[ -n \"${distributionUrl-}\" ] || die \"cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties\"\n\n\ncase \"${distributionUrl##*/}\" in\n(maven-mvnd-*bin.*)\n  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/\n  case \"${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)\" in\n  (*AMD64:CYGWIN*|*AMD64:MINGW*) distributionPlatform=windows-amd64 ;;\n  (:Darwin*x86_64) distributionPlatform=darwin-amd64 ;;\n  (:Darwin*arm64) distributionPlatform=darwin-aarch64 ;;\n  (:Linux*x86_64*) distributionPlatform=linux-amd64 ;;\n  (*) echo \"Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version\" >&2\n      distributionPlatform=linux-amd64\n      ;;\n  esac\n  distributionUrl=\"${distributionUrl%-bin.*}-$distributionPlatform.zip\"\n  ;;\n(maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;\n(*) MVN_CMD=\"mvn${0##*/mvnw}\" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;\nesac\n\n# apply MVNW_REPOURL and calculate MAVEN_HOME\n# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>\n[ -z \"${MVNW_REPOURL-}\" ] || distributionUrl=\"$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*\"$_MVNW_REPO_PATTERN\"}\"\ndistributionUrlName=\"${distributionUrl##*/}\"\ndistributionUrlNameMain=\"${distributionUrlName%.*}\"\ndistributionUrlNameMain=\"${distributionUrlNameMain%-bin}\"\nMAVEN_HOME=\"$HOME/.m2/wrapper/dists/${distributionUrlNameMain-}/$(hash_string \"$distributionUrl\")\"\n\nexec_maven() {\n  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :\n  exec \"$MAVEN_HOME/bin/$MVN_CMD\" \"$@\" || die \"cannot exec $MAVEN_HOME/bin/$MVN_CMD\"\n}\n\nif [ -d \"$MAVEN_HOME\" ]; then\n  verbose \"found existing MAVEN_HOME at $MAVEN_HOME\"\n  exec_maven \"$@\"\nfi\n\ncase \"${distributionUrl-}\" in\n(*?-bin.zip|*?maven-mvnd-?*-?*.zip) ;;\n(*) die \"distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'\" ;;\nesac\n\n# prepare tmp dir\nif TMP_DOWNLOAD_DIR=\"$(mktemp -d)\" && [ -d \"$TMP_DOWNLOAD_DIR\" ]; then\n  clean() { rm -rf -- \"$TMP_DOWNLOAD_DIR\"; }\n  trap clean HUP INT TERM EXIT\nelse\n  die \"cannot create temp dir\"\nfi\n\nmkdir -p -- \"${MAVEN_HOME%/*}\"\n\n# Download and Install Apache Maven\nverbose \"Couldn't find MAVEN_HOME, downloading and installing it ...\"\nverbose \"Downloading from: $distributionUrl\"\nverbose \"Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName\"\n\n# select .zip or .tar.gz\nif ! command -v unzip >/dev/null; then\n  distributionUrl=\"${distributionUrl%.zip}.tar.gz\"\n  distributionUrlName=\"${distributionUrl##*/}\"\nfi\n\n# verbose opt\n__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''\n[ \"${MVNW_VERBOSE-}\" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v\n\n# normalize http auth\ncase \"${MVNW_PASSWORD:+has-password}\" in\n'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;\nhas-password) [ -n \"${MVNW_USERNAME-}\" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;\nesac\n\nif [ -z \"${MVNW_USERNAME-}\" ] && command -v wget > /dev/null; then\n  verbose \"Found wget ... using wget\"\n  wget ${__MVNW_QUIET_WGET:+\"$__MVNW_QUIET_WGET\"} \"$distributionUrl\" -O \"$TMP_DOWNLOAD_DIR/$distributionUrlName\"\nelif [ -z \"${MVNW_USERNAME-}\" ] && command -v curl > /dev/null; then\n  verbose \"Found curl ... using curl\"\n  curl ${__MVNW_QUIET_CURL:+\"$__MVNW_QUIET_CURL\"} -f -L -o \"$TMP_DOWNLOAD_DIR/$distributionUrlName\" \"$distributionUrl\"\nelif set_java_home; then\n  verbose \"Falling back to use Java to download\"\n  javaSource=\"$TMP_DOWNLOAD_DIR/Downloader.java\"\n  targetZip=\"$TMP_DOWNLOAD_DIR/$distributionUrlName\"\n  cat > \"$javaSource\" <<-END\n\tpublic class Downloader extends java.net.Authenticator\n\t{\n\t  protected java.net.PasswordAuthentication getPasswordAuthentication()\n\t  {\n\t    return new java.net.PasswordAuthentication( System.getenv( \"MVNW_USERNAME\" ), System.getenv( \"MVNW_PASSWORD\" ).toCharArray() );\n\t  }\n\t  public static void main( String[] args ) throws Exception\n\t  {\n\t    setDefault( new Downloader() );\n\t    java.nio.file.Files.copy( new java.net.URL( args[0] ).openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );\n\t  }\n\t}\n\tEND\n  # For Cygwin/MinGW, switch paths to Windows format before running javac and java\n  verbose \" - Compiling Downloader.java ...\"\n  \"$(native_path \"$JAVACCMD\")\" \"$(native_path \"$javaSource\")\"\n  verbose \" - Running Downloader.java ...\"\n  \"$(native_path \"$JAVACMD\")\" -cp \"$(native_path \"$TMP_DOWNLOAD_DIR\")\" Downloader \"$distributionUrl\" \"$(native_path \"$targetZip\")\"\nfi\n\n# If specified, validate the SHA-256 sum of the Maven distribution zip file\nif [ -n \"${distributionSha256Sum-}\" ]; then\n  distributionSha256Result=false\n  if [ \"$MVN_CMD\" = mvnd.sh ]; then\n    echo \"Checksum validation is not supported for maven-mvnd.\" >&2\n    echo \"Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties.\" >&2\n    exit 1\n  elif command -v sha256sum > /dev/null; then\n    if echo \"$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName\" | sha256sum -c > /dev/null 2>&1; then\n      distributionSha256Result=true\n    fi\n  elif command -v shasum > /dev/null; then\n    if echo \"$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName\" | shasum -a 256 -c > /dev/null 2>&1; then\n      distributionSha256Result=true\n    fi\n  else\n    echo \"Checksum validation was requested but neither 'sha256sum' or 'shasum' are available.\" >&2\n    echo \"Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties.\" >&2\n    exit 1\n  fi\n  if [ $distributionSha256Result = false ]; then\n    echo \"Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised.\" >&2\n    echo \"If you updated your Maven version, you need to update the specified distributionSha256Sum property.\" >&2\n    exit 1\n  fi\nfi\n\n# unzip and move\nif command -v unzip > /dev/null; then\n  unzip ${__MVNW_QUIET_UNZIP:+\"$__MVNW_QUIET_UNZIP\"} \"$TMP_DOWNLOAD_DIR/$distributionUrlName\" -d \"$TMP_DOWNLOAD_DIR\"\nelse\n  tar xzf${__MVNW_QUIET_TAR:+\"$__MVNW_QUIET_TAR\"} \"$TMP_DOWNLOAD_DIR/$distributionUrlName\" -C \"$TMP_DOWNLOAD_DIR\"\nfi\nprintf %s\\\\n \"$distributionUrl\" > \"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url\"\nmv -- \"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain\" \"$MAVEN_HOME\" || [ -d \"$MAVEN_HOME\" ] || die \"fail to move MAVEN_HOME\"\n\nclean || :\nexec_maven \"$@\"\n"
        },
        {
          "name": "mvnw.cmd",
          "type": "blob",
          "size": 6.697265625,
          "content": "<# : batch portion\r\n@REM ----------------------------------------------------------------------------\r\n@REM Licensed to the Apache Software Foundation (ASF) under one\r\n@REM or more contributor license agreements.  See the NOTICE file\r\n@REM distributed with this work for additional information\r\n@REM regarding copyright ownership.  The ASF licenses this file\r\n@REM to you under the Apache License, Version 2.0 (the\r\n@REM \"License\"); you may not use this file except in compliance\r\n@REM with the License.  You may obtain a copy of the License at\r\n@REM\r\n@REM    http://www.apache.org/licenses/LICENSE-2.0\r\n@REM\r\n@REM Unless required by applicable law or agreed to in writing,\r\n@REM software distributed under the License is distributed on an\r\n@REM \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n@REM KIND, either express or implied.  See the License for the\r\n@REM specific language governing permissions and limitations\r\n@REM under the License.\r\n@REM ----------------------------------------------------------------------------\r\n\r\n@REM ----------------------------------------------------------------------------\r\n@REM Apache Maven Wrapper startup batch script, version 3.2.0\r\n@REM\r\n@REM Optional ENV vars\r\n@REM   MVNW_REPOURL - repo url base for downloading maven distribution\r\n@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven\r\n@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output\r\n@REM ----------------------------------------------------------------------------\r\n\r\n@IF \"%__MVNW_ARG0_NAME__%\"==\"\" (SET __MVNW_ARG0_NAME__=%~nx0)\r\n@SET __MVNW_CMD__=\r\n@SET __MVNW_ERROR__=\r\n@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%\r\n@SET PSModulePath=\r\n@FOR /F \"usebackq tokens=1* delims==\" %%A IN (`powershell -noprofile \"& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}\"`) DO @(\r\n  IF \"%%A\"==\"MVN_CMD\" (set __MVNW_CMD__=%%B) ELSE IF \"%%B\"==\"\" (echo %%A) ELSE (echo %%A=%%B)\r\n)\r\n@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%\r\n@SET __MVNW_PSMODULEP_SAVE=\r\n@SET __MVNW_ARG0_NAME__=\r\n@SET MVNW_USERNAME=\r\n@SET MVNW_PASSWORD=\r\n@IF NOT \"%__MVNW_CMD__%\"==\"\" (%__MVNW_CMD__% %*)\r\n@echo Cannot start maven from wrapper >&2 && exit /b 1\r\n@GOTO :EOF\r\n: end batch / begin powershell #>\r\n\r\n$ErrorActionPreference = \"Stop\"\r\nif ($env:MVNW_VERBOSE -eq \"true\") {\r\n  $VerbosePreference = \"Continue\"\r\n}\r\n\r\n# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties\r\n$distributionUrl = (Get-Content -Raw \"$scriptDir/.mvn/wrapper/maven-wrapper.properties\" | ConvertFrom-StringData).distributionUrl\r\nif (!$distributionUrl) {\r\n  Write-Error \"cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties\"\r\n}\r\n\r\nswitch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {\r\n  \"maven-mvnd-*\" {\r\n    $USE_MVND = $true\r\n    $distributionUrl = $distributionUrl -replace '-bin\\.[^.]*$',\"-windows-amd64.zip\"\r\n    $MVN_CMD = \"mvnd.cmd\"\r\n    break\r\n  }\r\n  default {\r\n    $USE_MVND = $false\r\n    $MVN_CMD = $script -replace '^mvnw','mvn'\r\n    break\r\n  }\r\n}\r\n\r\n# apply MVNW_REPOURL and calculate MAVEN_HOME\r\n# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>\r\nif ($env:MVNW_REPOURL) {\r\n  $MVNW_REPO_PATTERN = if ($USE_MVND) { \"/org/apache/maven/\" } else { \"/maven/mvnd/\" }\r\n  $distributionUrl = \"$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')\"\r\n}\r\n$distributionUrlName = $distributionUrl -replace '^.*/',''\r\n$distributionUrlNameMain = $distributionUrlName -replace '\\.[^.]*$','' -replace '-bin$',''\r\n$MAVEN_HOME_PARENT = \"$HOME/.m2/wrapper/dists/$distributionUrlNameMain\"\r\n$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString(\"x2\")}) -join ''\r\n$MAVEN_HOME = \"$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME\"\r\n\r\nif (Test-Path -Path \"$MAVEN_HOME\" -PathType Container) {\r\n  Write-Verbose \"found existing MAVEN_HOME at $MAVEN_HOME\"\r\n  Write-Output \"MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD\"\r\n  exit $?\r\n}\r\n\r\nif (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {\r\n  Write-Error \"distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl\"\r\n}\r\n\r\n# prepare tmp dir\r\n$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile\r\n$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path \"$TMP_DOWNLOAD_DIR_HOLDER.dir\"\r\n$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null\r\ntrap {\r\n  if ($TMP_DOWNLOAD_DIR.Exists) {\r\n    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }\r\n    catch { Write-Warning \"Cannot remove $TMP_DOWNLOAD_DIR\" }\r\n  }\r\n}\r\n\r\nNew-Item -Itemtype Directory -Path \"$MAVEN_HOME_PARENT\" -Force | Out-Null\r\n\r\n# Download and Install Apache Maven\r\nWrite-Verbose \"Couldn't find MAVEN_HOME, downloading and installing it ...\"\r\nWrite-Verbose \"Downloading from: $distributionUrl\"\r\nWrite-Verbose \"Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName\"\r\n\r\n$webclient = New-Object System.Net.WebClient\r\nif ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {\r\n  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)\r\n}\r\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\r\n$webclient.DownloadFile($distributionUrl, \"$TMP_DOWNLOAD_DIR/$distributionUrlName\") | Out-Null\r\n\r\n# If specified, validate the SHA-256 sum of the Maven distribution zip file\r\n$distributionSha256Sum = (Get-Content -Raw \"$scriptDir/.mvn/wrapper/maven-wrapper.properties\" | ConvertFrom-StringData).distributionSha256Sum\r\nif ($distributionSha256Sum) {\r\n  if ($USE_MVND) {\r\n    Write-Error \"Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties.\"\r\n  }\r\n  if ((Get-FileHash \"$TMP_DOWNLOAD_DIR/$distributionUrlName\" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {\r\n    Write-Error \"Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property.\"\r\n  }\r\n}\r\n\r\n# unzip and move\r\nExpand-Archive \"$TMP_DOWNLOAD_DIR/$distributionUrlName\" -DestinationPath \"$TMP_DOWNLOAD_DIR\" | Out-Null\r\nRename-Item -Path \"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain\" -NewName $MAVEN_HOME_NAME | Out-Null\r\ntry {\r\n  Move-Item -Path \"$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME\" -Destination $MAVEN_HOME_PARENT | Out-Null\r\n} catch {\r\n  if (! (Test-Path -Path \"$MAVEN_HOME\" -PathType Container)) {\r\n    Write-Error \"fail to move MAVEN_HOME\"\r\n  }\r\n} finally {\r\n  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }\r\n  catch { Write-Warning \"Cannot remove $TMP_DOWNLOAD_DIR\" }\r\n}\r\n\r\nWrite-Output \"MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD\"\r\n"
        },
        {
          "name": "pom.xml",
          "type": "blob",
          "size": 35.955078125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n  ~ Copyright (C) 2014-2023 jsonwebtoken.io\n  ~\n  ~ Licensed under the Apache License, Version 2.0 (the \"License\");\n  ~ you may not use this file except in compliance with the License.\n  ~ You may obtain a copy of the License at\n  ~\n  ~     http://www.apache.org/licenses/LICENSE-2.0\n  ~\n  ~ Unless required by applicable law or agreed to in writing, software\n  ~ distributed under the License is distributed on an \"AS IS\" BASIS,\n  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  ~ See the License for the specific language governing permissions and\n  ~ limitations under the License.\n  -->\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-root</artifactId>\n    <version>0.12.7-SNAPSHOT</version>\n    <name>JJWT</name>\n    <description>JSON Web Token support for the JVM and Android</description>\n    <packaging>pom</packaging>\n    <url>https://github.com/jwtk/jjwt</url>\n\n    <organization>\n        <name>jsonwebtoken.io</name>\n        <url>https://github.com/jwtk/jjwt</url>\n    </organization>\n    <inceptionYear>2014</inceptionYear>\n\n    <licenses>\n        <license>\n            <name>Apache License, Version 2.0</name>\n            <url>https://www.apache.org/licenses/LICENSE-2.0</url>\n            <distribution>repo</distribution>\n        </license>\n    </licenses>\n\n    <developers>\n        <developer>\n            <name>Les Hazlewood</name>\n            <email>121180+lhazlewood@users.noreply.github.com</email>\n            <organization>JJWT</organization>\n            <organizationUrl>https://github.com/jwtk/jjwt</organizationUrl>\n        </developer>\n    </developers>\n\n    <scm>\n        <connection>scm:git:https://github.com/jwtk/jjwt.git</connection>\n        <developerConnection>scm:git:https://github.com/jwtk/jjwt.git</developerConnection>\n        <url>https://github.com/jwtk/jjwt.git</url>\n        <tag>HEAD</tag>\n    </scm>\n    <issueManagement>\n        <system>GitHub Issues</system>\n        <url>https://github.com/jwtk/jjwt/issues</url>\n    </issueManagement>\n    <ciManagement>\n        <system>TravisCI</system>\n        <url>https://travis-ci.org/jwtk/jjwt</url>\n    </ciManagement>\n    <distributionManagement>\n        <snapshotRepository>\n            <id>ossrh</id>\n            <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n        </snapshotRepository>\n        <repository>\n            <id>ossrh</id>\n            <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>\n        </repository>\n    </distributionManagement>\n\n    <repositories>\n        <repository>\n            <id>ossrh</id>\n            <name>OSSRH Snapshots</name>\n            <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n            <releases>\n                <enabled>false</enabled>\n            </releases>\n            <snapshots>\n                <enabled>true</enabled>\n            </snapshots>\n        </repository>\n    </repositories>\n\n    <properties>\n\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <arguments />\n\n        <jjwt.root>${basedir}</jjwt.root>\n        <jjwt.previousVersion>0.11.2</jjwt.previousVersion>\n\n        <maven.jar.version>3.3.0</maven.jar.version>\n        <maven.compiler.version>3.11.0</maven.compiler.version>\n        <maven.javadoc.version>3.1.1</maven.javadoc.version> <!-- max version allowed for JDK 7 builds -->\n        <maven.source.version>3.2.1</maven.source.version>\n        <maven.resources.version>3.1.0</maven.resources.version>\n        <maven.gpg.version>1.6</maven.gpg.version> <!-- max version allowed for JDK 7 builds -->\n        <maven.japicmp.version>0.13.1</maven.japicmp.version> <!-- max version allowed for JDK 7 builds -->\n        <gmavenplus.version>1.6.1</gmavenplus.version> <!-- higher version used in jdk8AndLater profile below -->\n        <maven.license.version>4.2.rc3</maven.license.version>\n        <maven.license.skipExistingHeaders>true</maven.license.skipExistingHeaders>\n\n        <jdk.version>7</jdk.version>\n        <buildNumber>${user.name}-${maven.build.timestamp}</buildNumber>\n\n        <jackson.version>2.12.7.1</jackson.version>\n        <orgjson.version>20231013</orgjson.version>\n        <gson.version>2.9.0</gson.version>\n\n        <maven.javadoc.additionalOptions />\n\n        <!-- Optional Runtime Dependencies: -->\n        <bouncycastle.version>1.78</bouncycastle.version>\n        <bcprov.artifactId>bcprov-jdk18on</bcprov.artifactId>\n        <bcpkix.artifactId>bcpkix-jdk18on</bcpkix.artifactId>\n\n        <!-- Test Dependencies: Only required for testing when building.  Not required by users at runtime: -->\n        <groovy.version>2.5.16</groovy.version> <!-- higher version used in jdk8AndLater profile below -->\n        <easymock.version>3.6</easymock.version> <!-- higher version used in jdk8AndLater profile below -->\n        <junit.version>4.12</junit.version>\n        <powermock.version>2.0.0-beta.5</powermock.version> <!-- higher version used in jdk8AndLater profile below -->\n        <failsafe.plugin.version>3.0.0-M5</failsafe.plugin.version>\n        <surefire.plugin.version>3.0.0-M5</surefire.plugin.version>\n        <clover.version>4.3.1</clover.version> <!-- max version allowed for JDK 7 builds -->\n        <clover.db>${jjwt.root}/target/clover/clover.db</clover.db>\n        <surefire.argLine />\n        <test.addOpens>\n            --add-opens java.base/java.lang=ALL-UNNAMED, <!-- Needed by EasyMock/cglib -->\n            --add-opens java.desktop/java.beans=ALL-UNNAMED, <!-- Needed by EasyMock/cglib -->\n            --add-opens java.base/java.lang.ref=ALL-UNNAMED, <!-- Needed by PowerMock -->\n            <!-- needed by KeysImplTest.testKeyPairFor, KeysTest.testDeprecatedKeyPairFor, and\n                 KeysTest.testKeyPairBuilder: -->\n            --add-opens java.base/sun.security.util=ALL-UNNAMED\n        </test.addOpens>\n\n    </properties>\n\n    <modules>\n        <module>api</module>\n        <module>impl</module>\n        <module>extensions</module>\n        <module>tdjar</module>\n        <module>bom</module>\n    </modules>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>io.jsonwebtoken</groupId>\n                <artifactId>jjwt-api</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>io.jsonwebtoken</groupId>\n                <artifactId>jjwt-impl</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>io.jsonwebtoken</groupId>\n                <artifactId>jjwt-jackson</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>io.jsonwebtoken</groupId>\n                <artifactId>jjwt-orgjson</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>io.jsonwebtoken</groupId>\n                <artifactId>jjwt-gson</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.fasterxml.jackson.core</groupId>\n                <artifactId>jackson-databind</artifactId>\n                <version>${jackson.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.json</groupId>\n                <artifactId>json</artifactId>\n                <version>${orgjson.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.google.code.gson</groupId>\n                <artifactId>gson</artifactId>\n                <version>${gson.version}</version>\n            </dependency>\n\n            <!-- Used only during testing for PS256, PS384 and PS512 since JDK <= 10 doesn't support them: -->\n            <dependency>\n                <groupId>org.bouncycastle</groupId>\n                <artifactId>${bcprov.artifactId}</artifactId>\n                <version>${bouncycastle.version}</version>\n                <scope>test</scope>\n            </dependency>\n            <dependency>\n                <groupId>org.bouncycastle</groupId>\n                <artifactId>${bcpkix.artifactId}</artifactId>\n                <version>${bouncycastle.version}</version>\n                <scope>test</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <dependencies>\n        <!-- Test Dependencies: Only required for testing when building.  Not required by users at runtime: -->\n        <dependency>\n            <groupId>org.codehaus.groovy</groupId>\n            <artifactId>groovy</artifactId>\n            <version>${groovy.version}</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.easymock</groupId>\n            <artifactId>easymock</artifactId>\n            <version>${easymock.version}</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.powermock</groupId>\n            <artifactId>powermock-module-junit4</artifactId>\n            <version>${powermock.version}</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.powermock</groupId>\n            <artifactId>powermock-api-easymock</artifactId>\n            <version>${powermock.version}</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.powermock</groupId>\n            <artifactId>powermock-core</artifactId>\n            <version>${powermock.version}</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.13.1</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <pluginManagement>\n            <plugins>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-release-plugin</artifactId>\n                    <version>2.5.3</version>\n                    <dependencies>\n                        <dependency>\n                            <groupId>org.apache.maven.scm</groupId>\n                            <artifactId>maven-scm-provider-gitexe</artifactId>\n                            <version>1.9.5</version>\n                        </dependency>\n                    </dependencies>\n                    <configuration>\n                        <mavenExecutorId>forked-path</mavenExecutorId>\n                        <releaseProfiles>ossrh</releaseProfiles>\n                        <autoVersionSubmodules>true</autoVersionSubmodules>\n                    </configuration>\n                </plugin>\n                <plugin>\n                    <groupId>org.openclover</groupId>\n                    <artifactId>clover-maven-plugin</artifactId>\n                    <version>${clover.version}</version>\n                    <configuration>\n                        <cloverDatabase>${clover.db}</cloverDatabase>\n                        <!--\n                        cloverDatabase>${user.home}/.clover/${project.groupId}/jjwt/clover.db</cloverDatabase>\n                        <snapshot>${user.home}/.clover/${project.groupId}/jjwt/clover.snapshot</snapshot>\n                        <historyDir>${user.home}/.clover/${project.groupId}/jjwt</historyDir> -->\n                        <excludes>\n                            <exclude>io/jsonwebtoken/lang/*</exclude>\n                            <exclude>io/jsonwebtoken/all/JavaReadmeTest.java</exclude>\n                            <!-- Imported from commons-codec 585497f09b026f6602daf986723a554e051bdfe6, don't\n                            need full coverage: -->\n                            <exclude>io/jsonwebtoken/impl/io/CodecPolicy.java</exclude>\n                            <exclude>io/jsonwebtoken/impl/io/BaseNCodec.java</exclude>\n                            <exclude>io/jsonwebtoken/impl/io/Base64Codec.java</exclude>\n                            <exclude>io/jsonwebtoken/impl/io/BaseNCodecOutputStream.java</exclude>\n                            <exclude>io/jsonwebtoken/impl/io/BaseNCodecInputStream.java</exclude>\n                            <exclude>io/jsonwebtoken/impl/io/Base64OutputStream.java</exclude>\n                            <exclude>io/jsonwebtoken/impl/io/Base64InputStream.java</exclude>\n                            <exclude>io/jsonwebtoken/impl/io/FilteredInputStream.java</exclude>\n                            <exclude>io/jsonwebtoken/impl/io/FilteredOutputStream.java</exclude>\n                            <exclude>io/jsonwebtoken/impl/io/CharSequenceReader.java</exclude>\n                            <exclude>io/jsonwebtoken/impl/lang/AddOpens.java</exclude>\n                        </excludes>\n                        <methodPercentage>100.000000%</methodPercentage>\n                        <statementPercentage>100.000000%</statementPercentage>\n                        <conditionalPercentage>100.000000%</conditionalPercentage>\n                        <targetPercentage>100.000000%</targetPercentage>\n                    </configuration>\n                </plugin>\n                <plugin>\n                    <groupId>com.mycila</groupId>\n                    <artifactId>license-maven-plugin</artifactId>\n                    <version>${maven.license.version}</version>\n                    <configuration>\n                        <skipExistingHeaders>${maven.license.skipExistingHeaders}</skipExistingHeaders>\n                        <mapping>\n                            <toml>SCRIPT_STYLE</toml> <!-- yaml -->\n                            <pem>SCRIPT_STYLE</pem> <!-- any will do -->\n                        </mapping>\n                        <licenseSets>\n                            <licenseSet>\n                                <header>${jjwt.root}/src/license/header.txt</header>\n                                <excludes>\n                                    <exclude>**/license/header.txt</exclude>\n                                    <exclude>**/*.test.orgjson</exclude>\n                                    <exclude>**/*.test.gson</exclude>\n                                    <exclude>**/*.test.override</exclude>\n                                    <exclude>**/*.bnd</exclude>\n                                    <exclude>LICENSE</exclude>\n                                    <exclude>**/mvnw</exclude>\n                                    <exclude>**/lombok.config</exclude>\n                                    <exclude>.gitattributes</exclude>\n                                    <exclude>**/genkeys</exclude>\n                                    <exclude>**/softhsm</exclude>\n                                    <exclude>**.adoc</exclude>\n                                </excludes>\n                            </licenseSet>\n                        </licenseSets>\n                    </configuration>\n                    <dependencies>\n                        <dependency>\n                            <groupId>com.mycila</groupId>\n                            <artifactId>license-maven-plugin-git</artifactId>\n                            <version>${maven.license.version}</version>\n                        </dependency>\n                    </dependencies>\n                    <executions>\n                        <execution>\n                            <goals>\n                                <goal>check</goal>\n                            </goals>\n                        </execution>\n                    </executions>\n                </plugin>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-javadoc-plugin</artifactId>\n                    <version>${maven.javadoc.version}</version>\n                    <executions>\n                        <execution>\n                            <id>attach-javadocs</id>\n                            <goals>\n                                <goal>jar</goal>\n                            </goals>\n                        </execution>\n                    </executions>\n                    <configuration>\n                        <source>${jdk.version}</source>\n                        <failOnError>true</failOnError>\n                        <failOnWarnings>false</failOnWarnings>\n                        <additionalOptions>${maven.javadoc.additionalOptions}</additionalOptions>\n                    </configuration>\n                    <dependencies>\n                        <!-- Workaround for Java 9 -->\n                        <dependency>\n                            <groupId>commons-lang</groupId>\n                            <artifactId>commons-lang</artifactId>\n                            <version>2.6</version>\n                        </dependency>\n                    </dependencies>\n                </plugin>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-jar-plugin</artifactId>\n                    <version>${maven.jar.version}</version>\n                    <configuration>\n                        <archive>\n                            <manifest>\n                                <addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>\n                                <addDefaultImplementationEntries>true</addDefaultImplementationEntries>\n                            </manifest>\n                            <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>\n                        </archive>\n                    </configuration>\n                </plugin>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-source-plugin</artifactId>\n                    <version>${maven.source.version}</version>\n                    <executions>\n                        <execution>\n                            <id>attach-sources</id>\n                            <goals>\n                                <goal>jar-no-fork</goal>\n                            </goals>\n                        </execution>\n                    </executions>\n                </plugin>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-resources-plugin</artifactId>\n                    <version>${maven.resources.version}</version>\n                </plugin>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-gpg-plugin</artifactId>\n                    <version>${maven.gpg.version}</version>\n                    <executions>\n                        <execution>\n                            <id>sign-artifacts</id>\n                            <phase>verify</phase>\n                            <goals>\n                                <goal>sign</goal>\n                            </goals>\n                        </execution>\n                    </executions>\n                </plugin>\n                <plugin>\n                    <!-- japicmp will scan code for binary breaking changes, Open api/target/japicmp/japicmp.html\n                         for a report of the changes since ${jjwt.previousVersion} -->\n                    <groupId>com.github.siom79.japicmp</groupId>\n                    <artifactId>japicmp-maven-plugin</artifactId>\n                    <version>${maven.japicmp.version}</version>\n                    <configuration>\n                        <oldVersion>\n                            <dependency>\n                                <groupId>${project.groupId}</groupId>\n                                <artifactId>${project.artifactId}</artifactId>\n                                <version>${jjwt.previousVersion}</version>\n                                <type>jar</type>\n                            </dependency>\n                        </oldVersion>\n                        <parameter>\n                            <onlyModified>true</onlyModified>\n                            <!-- <breakBuildOnBinaryIncompatibleModifications>true</breakBuildOnBinaryIncompatibleModifications> -->\n                            <!-- TODO: enable after 1.0 -->\n                            <breakBuildBasedOnSemanticVersioning>true</breakBuildBasedOnSemanticVersioning>\n\n                            <!-- All of the following can be removed after 0.11.1 is released: -->\n                            <!-- <excludes>\n                                <exclude>io.jsonwebtoken.Header#getAlgorithm()</exclude>\n                                <exclude>io.jsonwebtoken.Header#setAlgorithm(java.lang.String)</exclude>\n                                <exclude>io.jsonwebtoken.JwsHeader#getAlgorithm()</exclude>\n                                <exclude>io.jsonwebtoken.JwsHeader#setAlgorithm(java.lang.String)</exclude>\n                                <exclude>io.jsonwebtoken.lang.Assert#notNull(java.lang.Object,java.lang.String)</exclude>\n                            </excludes> -->\n                        </parameter>\n                    </configuration>\n                    <executions>\n                        <execution>\n                            <id>japicmp</id>\n                            <goals>\n                                <goal>cmp</goal>\n                            </goals>\n                        </execution>\n                    </executions>\n                </plugin>\n\n                <!-- The following plugin section is used in jjwt-jackson and jjwt-orgjson, to repackage (and verify)\n                     binary compatibility with previous versions. In v0.11.0 the implementations changed packages to\n                     avoid split package issues with Java 9+ see: https://github.com/jwtk/jjwt/issues/399 -->\n                <!-- TODO: remove these deprecated packages and this config before v1.0 -->\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-shade-plugin</artifactId>\n                    <version>3.2.1</version>\n                    <configuration>\n                        <shadedClassifierName>deprecated</shadedClassifierName>\n                        <shadedArtifactAttached>true</shadedArtifactAttached>\n                        <createDependencyReducedPom>false</createDependencyReducedPom>\n                        <artifactSet>\n                            <includes>\n                                <include>${project.groupId}:${project.artifactId}</include>\n                            </includes>\n                        </artifactSet>\n                        <transformers>\n                            <transformer implementation=\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\" />\n                        </transformers>\n                    </configuration>\n                    <executions>\n                        <execution>\n                            <phase>package</phase>\n                            <goals>\n                                <goal>shade</goal>\n                            </goals>\n                        </execution>\n                    </executions>\n                </plugin>\n            </plugins>\n        </pluginManagement>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-enforcer-plugin</artifactId>\n                <version>1.4.1</version>\n                <executions>\n                    <execution>\n                        <id>enforce-banned-dependencies</id>\n                        <goals>\n                            <goal>enforce</goal>\n                        </goals>\n                        <configuration>\n                            <rules>\n                                <bannedDependencies>\n                                    <searchTransitive>true</searchTransitive>\n                                    <excludes>\n                                        <exclude>commons-logging</exclude>\n                                    </excludes>\n                                </bannedDependencies>\n                            </rules>\n                            <fail>true</fail>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n<!--            <plugin>-->\n<!--                <groupId>org.apache.maven.plugins</groupId>-->\n<!--                <artifactId>maven-compiler-plugin</artifactId>-->\n<!--                <version>${maven.compiler.version}</version>-->\n<!--                <executions>-->\n<!--                    <execution>-->\n<!--                        <id>default-compile</id>-->\n<!--                        <configuration>-->\n<!--                            <release>9</release>-->\n<!--                            &lt;!&ndash; no excludes: compile everything to ensure module-info contains right entries &ndash;&gt;-->\n<!--                        </configuration>-->\n<!--                    </execution>-->\n<!--                    <execution>-->\n<!--                        <id>base-compile</id>-->\n<!--                        <goals>-->\n<!--                            <goal>compile</goal>-->\n<!--                        </goals>-->\n<!--                        <configuration>-->\n<!--                            &lt;!&ndash; recompile everything for target VM except the module-info.java &ndash;&gt;-->\n<!--                            <excludes>-->\n<!--                                <exclude>module-info.java</exclude>-->\n<!--                            </excludes>-->\n<!--                        </configuration>-->\n<!--                    </execution>-->\n<!--                </executions>-->\n<!--                &lt;!&ndash; defaults for compile and testCompile &ndash;&gt;-->\n<!--                <configuration>-->\n<!--                    <release>${jdk.version}</release>-->\n<!--&lt;!&ndash;                    &lt;!&ndash; Only required when Maven runtime JAVA_HOME isn't at least Java 9 and when haven't configured the maven-toolchains-plugin &ndash;&gt;&ndash;&gt;-->\n<!--&lt;!&ndash;                    <jdkToolchain>&ndash;&gt;-->\n<!--&lt;!&ndash;                        <version>9</version>&ndash;&gt;-->\n<!--&lt;!&ndash;                    </jdkToolchain>&ndash;&gt;-->\n<!--                </configuration>-->\n<!--            </plugin>-->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>${maven.compiler.version}</version>\n                <configuration>\n                    <source>${jdk.version}</source>\n                    <target>${jdk.version}</target>\n                    <encoding>${project.build.sourceEncoding}</encoding>\n                </configuration>\n            </plugin>\n            <!-- Allow for writing tests in Groovy: -->\n            <plugin>\n                <groupId>org.codehaus.gmavenplus</groupId>\n                <artifactId>gmavenplus-plugin</artifactId>\n                <version>${gmavenplus.version}</version>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>addSources</goal>\n                            <goal>addTestSources</goal>\n                            <goal>generateStubs</goal>\n                            <goal>compile</goal>\n                            <goal>generateTestStubs</goal>\n                            <goal>compileTests</goal>\n                            <goal>removeStubs</goal>\n                            <goal>removeTestStubs</goal>\n                        </goals>\n                    </execution>\n                </executions>\n                <dependencies>\n                    <dependency>\n                        <groupId>org.codehaus.groovy</groupId>\n                        <artifactId>groovy</artifactId>\n                        <version>${groovy.version}</version>\n                    </dependency>\n                </dependencies>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>${surefire.plugin.version}</version>\n                <configuration>\n                    <argLine>${surefire.argLine}</argLine>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-failsafe-plugin</artifactId>\n                <version>${failsafe.plugin.version}</version>\n                <configuration>\n                    <includes>\n                        <include>**/*IT.java</include>\n                        <include>**/*IT.groovy</include>\n                        <include>**/*ITCase.java</include>\n                        <include>**/*ITCase.groovy</include>\n                    </includes>\n                    <excludes>\n                        <exclude>**/*ManualIT.java</exclude>\n                        <exclude>**/*ManualIT.groovy</exclude>\n                    </excludes>\n                </configuration>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>integration-test</goal>\n                            <goal>verify</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.openclover</groupId>\n                <artifactId>clover-maven-plugin</artifactId>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-release-plugin</artifactId>\n            </plugin>\n            <plugin>\n                <groupId>org.sonatype.plugins</groupId>\n                <artifactId>nexus-staging-maven-plugin</artifactId>\n                <version>1.6.7</version>\n                <extensions>true</extensions>\n                <configuration>\n                    <serverId>ossrh</serverId>\n                    <nexusUrl>https://oss.sonatype.org/</nexusUrl>\n                    <autoReleaseAfterClose>false</autoReleaseAfterClose>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.felix</groupId>\n                <artifactId>maven-bundle-plugin</artifactId>\n                <version>3.5.0</version>\n                <executions>\n                    <execution>\n                        <id>bundle-manifest</id>\n                        <phase>process-classes</phase>\n                        <goals>\n                            <goal>manifest</goal>\n                        </goals>\n                    </execution>\n                </executions>\n                <configuration>\n                    <instructions>\n                        <_include>-bnd.bnd</_include>\n                    </instructions>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n            </plugin>\n            <plugin>\n                <groupId>io.jsonwebtoken.coveralls</groupId>\n                <artifactId>coveralls-maven-plugin</artifactId>\n                <version>4.4.1</version>\n            </plugin>\n        </plugins>\n    </build>\n    <profiles>\n        <profile>\n            <id>jdk7</id>\n            <activation>\n                <jdk>1.7</jdk>\n            </activation>\n            <properties>\n                <maven.jar.version>3.2.2</maven.jar.version>\n                <maven.compiler.version>3.8.1</maven.compiler.version>\n                <orgjson.version>20230618</orgjson.version>\n                <bcprov.artifactId>bcprov-jdk15to18</bcprov.artifactId>\n                <bcpkix.artifactId>bcpkix-jdk15to18</bcpkix.artifactId>\n            </properties>\n        </profile>\n        <profile>\n            <id>jdk8AndLater</id>\n            <activation>\n                <jdk>[1.8,)</jdk>\n            </activation>\n            <properties>\n                <gmavenplus.version>3.0.2</gmavenplus.version>\n                <groovy.version>3.0.19</groovy.version>\n                <easymock.version>4.2</easymock.version>\n                <powermock.version>2.0.7</powermock.version>\n                <maven.japicmp.version>0.15.6</maven.japicmp.version>\n                <failsafe.plugin.version>3.1.2</failsafe.plugin.version>\n                <surefire.plugin.version>3.1.2</surefire.plugin.version>\n            </properties>\n        </profile>\n<!--        <profile>-->\n<!--            <id>jdk7And8</id>-->\n<!--            <activation>-->\n<!--                <jdk>[1.7,9)</jdk>-->\n<!--            </activation>-->\n<!--            <build>-->\n<!--                <plugins>-->\n<!--                    <plugin>-->\n<!--                        <groupId>org.apache.maven.plugins</groupId>-->\n<!--                        <artifactId>maven-compiler-plugin</artifactId>-->\n<!--                        <version>${maven.compiler.version}</version>-->\n<!--                        <configuration>-->\n<!--                            <source>${jdk.version}</source>-->\n<!--                            <target>${jdk.version}</target>-->\n<!--                            <release />-->\n<!--                            <encoding>${project.build.sourceEncoding}</encoding>-->\n<!--                            <excludes>-->\n<!--                                <exclude>module-info.java</exclude>-->\n<!--                            </excludes>-->\n<!--                        </configuration>-->\n<!--                    </plugin>-->\n<!--                </plugins>-->\n<!--            </build>-->\n<!--        </profile>-->\n        <profile>\n            <!-- Added profile to address https://github.com/jwtk/jjwt/issues/364 -->\n            <id>jdk9AndLater</id>\n            <activation>\n                <jdk>[1.9,)</jdk>\n            </activation>\n            <properties>\n                <maven.compiler.version>3.11.0</maven.compiler.version>\n                <surefire.useModulePath>false</surefire.useModulePath>\n                <maven.javadoc.additionalOptions>-html5</maven.javadoc.additionalOptions>\n                <surefire.argLine>${test.addOpens}, --illegal-access=debug</surefire.argLine>\n            </properties>\n        </profile>\n        <profile>\n            <id>jdk17AndLater</id>\n            <activation>\n                <jdk>[17,)</jdk>\n            </activation>\n            <properties>\n                <maven.javadoc.additionalOptions>-html5</maven.javadoc.additionalOptions>\n                <surefire.argLine>${test.addOpens}</surefire.argLine>\n            </properties>\n        </profile>\n        <profile>\n            <id>jdk21AndLater</id>\n            <activation>\n                <jdk>[21,)</jdk>\n            </activation>\n            <properties>\n                <!-- normally this is 1.7, but as of 21, JDK 8 is the lowest source/target -->\n                <jdk.version>8</jdk.version>\n            </properties>\n        </profile>\n        <profile>\n            <id>docs</id>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>org.apache.maven.plugins</groupId>\n                        <artifactId>maven-source-plugin</artifactId>\n                    </plugin>\n                    <plugin>\n                        <groupId>org.apache.maven.plugins</groupId>\n                        <artifactId>maven-javadoc-plugin</artifactId>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n        <profile>\n            <id>ossrh</id>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>org.apache.maven.plugins</groupId>\n                        <artifactId>maven-source-plugin</artifactId>\n                    </plugin>\n                    <plugin>\n                        <groupId>org.apache.maven.plugins</groupId>\n                        <artifactId>maven-javadoc-plugin</artifactId>\n                    </plugin>\n                    <plugin>\n                        <groupId>org.apache.maven.plugins</groupId>\n                        <artifactId>maven-gpg-plugin</artifactId>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n    </profiles>\n</project>\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tdjar",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}