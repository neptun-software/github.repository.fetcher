{
  "metadata": {
    "timestamp": 1736561385275,
    "page": 5,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "PaddlePaddle/PaddleOCR",
      "stars": 45650,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang_format.hook",
          "type": "blob",
          "size": 0.513671875,
          "content": "#!/bin/bash\nset -e\n\nreadonly VERSION=\"13.0.0\"\n\nversion=$(clang-format -version)\n\nif ! [[ $(python -V 2>&1 | awk '{print $2}' | awk -F '.' '{print $1$2}') -ge 36 ]]; then\n    echo \"clang-format installation by pip need python version great equal 3.6,\n          please change the default python to higher version.\"\n    exit 1\nfi\n\nif ! [[ $version == *\"$VERSION\"* ]]; then\n    # low version of pip may not have the source of clang-format whl\n    pip install --upgrade pip\n    pip install clang-format==13.0.0\nfi\n\nclang-format $@\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.458984375,
          "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n.ipynb_checkpoints/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\ninference/\ninference_results/\noutput/\ntrain_data/\nlog/\n*.DS_Store\n*.vs\n*.user\n*~\n*.vscode\n*.idea\n\n*.log\n.clang-format\n.clang_format.hook\n\nbuild/\ndist/\npaddleocr.egg-info/\n/deploy/android_demo/app/OpenCV/\n/deploy/android_demo/app/PaddleLite/\n/deploy/android_demo/app/.cxx/\n/deploy/android_demo/app/cache/\ntest_tipc/web/models/\ntest_tipc/web/node_modules/\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 1.232421875,
          "content": "repos:\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v5.0.0\n    hooks:\n    -   id: check-added-large-files\n        args: ['--maxkb=512']\n    -   id: check-case-conflict\n    -   id: check-merge-conflict\n    -   id: check-symlinks\n    -   id: detect-private-key\n    -   id: end-of-file-fixer\n    -   id: trailing-whitespace\n        files: \\.(c|cc|cxx|cpp|cu|h|hpp|hxx|py)$\n-   repo: https://github.com/Lucas-C/pre-commit-hooks\n    rev: v1.5.5\n    hooks:\n    -   id: remove-crlf\n    -   id: remove-tabs\n        files: \\.(c|cc|cxx|cpp|cu|h|hpp|hxx|py)$\n-   repo: local\n    hooks:\n    -   id: clang-format\n        name: clang-format\n        description: Format files with ClangFormat\n        entry: bash .clang_format.hook -i\n        language: system\n        files: \\.(c|cc|cxx|cpp|cu|h|hpp|hxx|cuh|proto)$\n# For Python files\n-   repo: https://github.com/psf/black.git\n    rev: 24.10.0\n    hooks:\n    -   id: black\n        files: (.*\\.(py|pyi|bzl)|BUILD|.*\\.BUILD|WORKSPACE)$\n\n# Flake8\n-   repo: https://github.com/pycqa/flake8\n    rev: 7.1.1\n    hooks:\n    -   id: flake8\n        args:\n            - --count\n            - --select=E9,F63,F7,F82,E721\n            - --show-source\n            - --statistics\n        exclude: ^benchmark/|^test_tipc/\n"
        },
        {
          "name": ".style.yapf",
          "type": "blob",
          "size": 0.046875,
          "content": "[style]\nbased_on_style = pep8\ncolumn_limit = 80\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.169921875,
          "content": "Copyright (c) 2016 PaddlePaddle Authors. All Rights Reserved\n\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright (c) 2016 PaddlePaddle Authors. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.3896484375,
          "content": "prune .github\nprune applications\nprune benchmark\nprune configs\nprune deploy\nprune doc\nprune docs\nprune overrides\nprune ppocr/ext_op\nprune ppocr/losses\nprune ppocr/metrics\nprune ppocr/modeling\nprune ppocr/optimizer\nprune ppstructure/docs\nprune test_tipc\nprune tests\nexclude .clang_format.hook\nexclude .gitignore\nexclude .pre-commit-config.yaml\nexclude .style.yapf\nexclude mkdocs.yml\nexclude train.sh\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.4580078125,
          "content": "[English](README_en.md) | 简体中文\n\n<p align=\"center\">\n <img src=\"https://github.com/PaddlePaddle/PaddleOCR/releases/download/v2.8.0/PaddleOCR_logo.png\" align=\"middle\" width = \"600\"/>\n<p align=\"center\">\n<p align=\"center\">\n    <a href=\"https://discord.gg/z9xaRVjdbD\"><img src=\"https://img.shields.io/badge/Chat-on%20discord-7289da.svg?sanitize=true\" alt=\"Chat\"></a>\n    <a href=\"./LICENSE\"><img src=\"https://img.shields.io/badge/license-Apache%202-dfd.svg\"></a>\n    <a href=\"https://github.com/PaddlePaddle/PaddleOCR/releases\"><img src=\"https://img.shields.io/github/v/release/PaddlePaddle/PaddleOCR?color=ffa\"></a>\n    <a href=\"\"><img src=\"https://img.shields.io/badge/python-3.7+-aff.svg\"></a>\n    <a href=\"\"><img src=\"https://img.shields.io/badge/os-linux%2C%20win%2C%20mac-pink.svg\"></a>\n    <a href=\"https://pypi.org/project/PaddleOCR/\"><img src=\"https://img.shields.io/pypi/dm/PaddleOCR?color=9cf\"></a>\n    <a href=\"https://github.com/PaddlePaddle/PaddleOCR/stargazers\"><img src=\"https://img.shields.io/github/stars/PaddlePaddle/PaddleOCR?color=ccf\"></a>\n</p>\n\n## 简介\n\nPaddleOCR 旨在打造一套丰富、领先、且实用的 OCR 工具库，助力开发者训练出更好的模型，并应用落地。\n\n<div align=\"center\">\n    <img src=\"https://github.com/PaddlePaddle/PaddleOCR/releases/download/v2.8.0/demo.gif\" width=\"800\">\n</div>\n\n## 🚀 社区\n\nPaddleOCR 由 [PMC](https://github.com/PaddlePaddle/PaddleOCR/issues/12122) 监督。Issues 和 PRs 将在尽力的基础上进行审查。欲了解 PaddlePaddle 社区的完整概况，请访问 [community](https://github.com/PaddlePaddle/community)。\n\n⚠️注意：[Issues](https://github.com/PaddlePaddle/PaddleOCR/issues)模块仅用来报告程序🐞Bug，其余提问请移步[Discussions](https://github.com/PaddlePaddle/PaddleOCR/discussions)模块提问。如所提Issue不是Bug，会被移到Discussions模块，敬请谅解。\n\n## 📣 近期更新([more](https://paddlepaddle.github.io/PaddleOCR/latest/update.html))\n\n- 🔥🔥《PaddleOCR 2.9 发布，正式开源文本图像智能分析利器》，文本图像版面解析实现高精度实时预测，低代码全流程开发加速产业应用。集成文本图像矫正、版面区域检测、常规文本检测、印章文本检测、文本识别、表格识别等多功能。6条模型产线一键调用，显著降低开发成本。支持高性能推理、服务化部署和端侧部署等多种部署方式。**10月24日（周四）19：00**直播为您深度解析最新升级亮点。 [报名链接](https://www.wjx.top/vm/PExy7cM.aspx?udsid=896077)\n\n- **🔥2024.10.1 添加OCR领域低代码全流程开发能力**:\n    - 飞桨低代码开发工具PaddleX，依托于PaddleOCR的先进技术，支持了OCR领域的低代码全流程开发能力：\n        - 🎨 [**模型丰富一键调用**](https://paddlepaddle.github.io/PaddleOCR/latest/paddlex/quick_start.html)：将文本图像智能分析、通用OCR、通用版面解析、通用表格识别、公式识别、印章文本识别涉及的**17个模型**整合为6条模型产线，通过极简的**Python API一键调用**，快速体验模型效果。此外，同一套API，也支持图像分类、目标检测、图像分割、时序预测等共计**200+模型**，形成20+单功能模块，方便开发者进行**模型组合**使用。\n        - 🚀[**提高效率降低门槛**](https://paddlepaddle.github.io/PaddleOCR/latest/paddlex/overview.html)：提供基于**统一命令**和**图形界面**两种方式，实现模型简洁高效的使用、组合与定制。支持**高性能推理、服务化部署和端侧部署**等多种部署方式。此外，对于各种主流硬件如**英伟达GPU、昆仑芯、昇腾、寒武纪和海光**等，进行模型开发时，都可以**无缝切换**。\n\n    - 支持文档场景信息抽取v3[PP-ChatOCRv3-doc](https://paddlepaddle.github.io/PaddleX/latest/pipeline_usage/tutorials/information_extraction_pipelines/document_scene_information_extraction.html)、基于RT-DETR的[高精度版面区域检测模型](https://paddlepaddle.github.io/PaddleX/latest/module_usage/tutorials/ocr_modules/layout_detection.html)和PicoDet的[高效率版面区域检测模型](https://paddlepaddle.github.io/PaddleX/latest/module_usage/tutorials/ocr_modules/layout_detection.html)、高精度表格结构识别模型[SLANet_Plus](https://paddlepaddle.github.io/PaddleX/latest/module_usage/tutorials/ocr_modules/table_structure_recognition.html)、文本图像矫正模型[UVDoc](https://paddlepaddle.github.io/PaddleX/latest/module_usage/tutorials/ocr_modules/text_image_unwarping.html)、公式识别模型[LatexOCR](https://paddlepaddle.github.io/PaddleX/latest/module_usage/tutorials/ocr_modules/formula_recognition.html)、基于PP-LCNet的[文档图像方向分类模型](https://paddlepaddle.github.io/PaddleX/latest/module_usage/tutorials/ocr_modules/doc_img_orientation_classification.html)\n\n- **🔥2024.7 添加 PaddleOCR 算法模型挑战赛冠军方案**：\n    - 赛题一：OCR 端到端识别任务冠军方案——[场景文本识别算法-SVTRv2](https://paddlepaddle.github.io/PaddleOCR/latest/algorithm/text_recognition/algorithm_rec_svtrv2.html)；\n    - 赛题二：通用表格识别任务冠军方案——[表格识别算法-SLANet-LCNetV2](https://paddlepaddle.github.io/PaddleOCR/latest/algorithm/table_recognition/algorithm_table_slanet.html)。\n\n## 🌟 特性\n\n支持多种 OCR 相关前沿算法，在此基础上打造产业级特色模型PP-OCR、PP-Structure和PP-ChatOCR，并打通数据生产、模型训练、压缩、预测部署全流程。\n\n<div align=\"center\">\n    <img src=\"./docs/images/ppocrv4.png\">\n</div>\n\n## ⚡ [快速开始](https://paddlepaddle.github.io/PaddleOCR/latest/quick_start.html)\n\n## 🔥 [低代码全流程开发](https://paddlepaddle.github.io/PaddleOCR/latest/paddlex/overview.html)\n\n## 📝 文档\n\n完整文档请移步：[docs](https://paddlepaddle.github.io/PaddleOCR/latest/)\n\n## 📚《动手学 OCR》电子书\n\n- [《动手学 OCR》电子书](https://paddlepaddle.github.io/PaddleOCR/latest/ppocr/blog/ocr_book.html)\n\n## 🎖 贡献者\n\n<a href=\"https://github.com/PaddlePaddle/PaddleOCR/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=PaddlePaddle/PaddleOCR&max=400&columns=20\"  width=\"800\"/>\n</a>\n\n## ⭐️ Star\n\n[![Star History Chart](https://api.star-history.com/svg?repos=PaddlePaddle/PaddleOCR&type=Date)](https://star-history.com/#PaddlePaddle/PaddleOCR&Date)\n\n## 许可证书\n\n本项目的发布受 [Apache License Version 2.0](./LICENSE) 许可认证。\n"
        },
        {
          "name": "README_en.md",
          "type": "blob",
          "size": 8.3984375,
          "content": "English | [简体中文](README.md)\n\n<p align=\"center\">\n <img src=\"https://github.com/PaddlePaddle/PaddleOCR/releases/download/v2.8.0/PaddleOCR_logo.png\" align=\"middle\" width = \"600\"/>\n<p align=\"center\">\n<p align=\"center\">\n    <a href=\"https://discord.gg/z9xaRVjdbD\"><img src=\"https://img.shields.io/badge/Chat-on%20discord-7289da.svg?sanitize=true\" alt=\"Chat\"></a>\n    <a href=\"./LICENSE\"><img src=\"https://img.shields.io/badge/license-Apache%202-dfd.svg\"></a>\n    <a href=\"https://github.com/PaddlePaddle/PaddleOCR/releases\"><img src=\"https://img.shields.io/github/v/release/PaddlePaddle/PaddleOCR?color=ffa\"></a>\n    <a href=\"\"><img src=\"https://img.shields.io/badge/python-3.7+-aff.svg\"></a>\n    <a href=\"\"><img src=\"https://img.shields.io/badge/os-linux%2C%20win%2C%20mac-pink.svg\"></a>\n    <a href=\"https://pypi.org/project/PaddleOCR/\"><img src=\"https://img.shields.io/pypi/dm/PaddleOCR?color=9cf\"></a>\n    <a href=\"https://github.com/PaddlePaddle/PaddleOCR/stargazers\"><img src=\"https://img.shields.io/github/stars/PaddlePaddle/PaddleOCR?color=ccf\"></a>\n</p>\n\n## Introduction\n\nPaddleOCR aims to create multilingual, awesome, leading, and practical OCR tools that help users train better models and apply them into practice.\n\n<div align=\"center\">\n    <img src=\"https://github.com/PaddlePaddle/PaddleOCR/releases/download/v2.8.0/demo.gif\" width=\"800\">\n</div>\n\n## 🚀 Community\n\nPaddleOCR is being oversight by a [PMC](https://github.com/PaddlePaddle/PaddleOCR/issues/12122). Issues and PRs will be reviewed on a best-effort basis. For a complete overview of PaddlePaddle community, please visit [community](https://github.com/PaddlePaddle/community).\n\n⚠️ Note: The [Issues](https://github.com/PaddlePaddle/PaddleOCR/issues) module is only for reporting program 🐞 bugs, for the rest of the questions, please move to the [Discussions](https://github.com/PaddlePaddle/PaddleOCR/discussions). Please note that if the Issue mentioned is not a bug, it will be moved to the Discussions module.\n\n## 📣 Recent updates ([more](https://paddlepaddle.github.io/PaddleOCR/latest/en/update.html))\n\n- **🔥 2024.10.18 release PaddleOCR v2.9, including**:\n    - PaddleX, an All-in-One development tool based on PaddleOCR's advanced technology, supports low-code full-process development capabilities in the OCR field:\n        - 🎨 [**Rich Model One-Click Call**](https://paddlepaddle.github.io/PaddleOCR/latest/en/paddlex/quick_start.html): Integrates **17 models** related to text image intelligent analysis, general OCR, general layout parsing, table recognition, formula recognition, and seal recognition into 6 pipelines, which can be quickly experienced through a simple **Python API one-click call**. In addition, the same set of APIs also supports a total of **200+ models** in image classification, object detection, image segmentation, and time series forcasting, forming 20+ single-function modules, making it convenient for developers to use **model combinations**.\n\n        - 🚀 [**High Efficiency and Low barrier of entry**](https://paddlepaddle.github.io/PaddleOCR/latest/en/paddlex/overview.html): Provides two methods based on **unified commands** and **GUI** to achieve simple and efficient use, combination, and customization of models. Supports multiple deployment methods such as **high-performance inference, service-oriented deployment, and edge deployment**. Additionally, for various mainstream hardware such as **NVIDIA GPU, Kunlunxin XPU, Ascend NPU, Cambricon MLU, and Haiguang DCU**, models can be developed with **seamless switching**.\n\n    - Supports [PP-ChatOCRv3-doc](https://paddlepaddle.github.io/PaddleX/latest/en/pipeline_usage/tutorials/information_extraction_pipelines/document_scene_information_extraction.html), [high-precision layout detection model based on RT-DETR](https://paddlepaddle.github.io/PaddleX/latest/en/module_usage/tutorials/ocr_modules/layout_detection.html) and [high-efficiency layout area detection model based on PicoDet](https://paddlepaddle.github.io/PaddleX/latest/en/module_usage/tutorials/ocr_modules/layout_detection.html), [high-precision table structure recognition model](https://paddlepaddle.github.io/PaddleX/latest/en/module_usage/tutorials/ocr_modules/table_structure_recognition.html), text image unwarping model [UVDoc](https://paddlepaddle.github.io/PaddleX/latest/en/module_usage/tutorials/ocr_modules/text_image_unwarping.html), formula recognition model [LatexOCR](https://paddlepaddle.github.io/PaddleX/latest/en/module_usage/tutorials/ocr_modules/formula_recognition.html), and [document image orientation classification model based on PP-LCNet](https://paddlepaddle.github.io/PaddleX/latest/en/module_usage/tutorials/ocr_modules/doc_img_orientation_classification.html).\n\n- **🔥2024.7 Added PaddleOCR Algorithm Model Challenge Champion Solutions**:\n    - Challenge One, OCR End-to-End Recognition Task Champion Solution: [Scene Text Recognition Algorithm-SVTRv2](https://paddlepaddle.github.io/PaddleOCR/algorithm/text_recognition/algorithm_rec_svtrv2.html);\n    - Challenge Two, General Table Recognition Task Champion Solution: [Table Recognition Algorithm-SLANet-LCNetV2](https://paddlepaddle.github.io/PaddleOCR/algorithm/table_recognition/algorithm_table_slanet.html).\n\n## 📚 Documentation\n\nFull documentation can be found on [docs](https://paddlepaddle.github.io/PaddleOCR/latest/en/index.html).\n\n## 🌟 Features\n\nPaddleOCR support a variety of cutting-edge algorithms related to OCR, and developed industrial featured models/solution [PP-OCR](https://paddlepaddle.github.io/PaddleOCR/latest/en/ppocr/overview.html)、 [PP-Structure](https://paddlepaddle.github.io/PaddleOCR/latest/en/ppstructure/overview.html) and [PP-ChatOCR](https://aistudio.baidu.com/aistudio/projectdetail/6488689) on this basis, and get through the whole process of data production, model training, compression, inference and deployment.\n\n<div align=\"center\">\n    <img src=\"./docs/images/ppocrv4_en.jpg\">\n</div>\n\n> It is recommended to start with the “quick experience” in the document tutorial\n\n## ⚡ [Quick Start](https://paddlepaddle.github.io/PaddleOCR/latest/en/quick_start.html)\n\n## 📖 Technical exchange and cooperation\n\nPaddleX provides a one-stop full-process high-efficiency development platform for flying paddle ecological model training, pressure, and push. Its mission is to help AI technology quickly land, and its vision is to make everyone an AI Developer!\n\n- PaddleX currently covers areas such as image classification, object detection, image segmentation, 3D, OCR, and time series prediction, and has built-in 36 basic single models, such as RP-DETR, PP-YOLOE, PP-HGNet, PP-LCNet, PP- LiteSeg, etc.; integrated 12 practical industrial solutions, such as PP-OCRv4, PP-ChatOCR, PP-ShiTu, PP-TS, vehicle-mounted road waste detection, identification of prohibited wildlife products, etc.\n- PaddleX provides two AI development modes: \"Toolbox\" and \"Developer\". The toolbox mode can tune key hyperparameters without code, and the developer mode can perform single-model training, push and multi-model serial inference with low code, and supports both cloud and local terminals.\n- PaddleX also supports joint innovation and development, profit sharing! At present, PaddleX is rapidly iterating, and welcomes the participation of individual developers and enterprise developers to create a prosperous AI technology ecosystem!\n\n## 📚 E-book: *Dive Into OCR*\n\n- [Dive Into OCR](./doc/doc_en/ocr_book_en.md)\n\n## 🎖 Contributors\n\n<a href=\"https://github.com/PaddlePaddle/PaddleOCR/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=PaddlePaddle/PaddleOCR&max=400&columns=20\"  width=\"800\"/>\n</a>\n\n## ⭐️ Star\n\n[![Star History Chart](https://api.star-history.com/svg?repos=PaddlePaddle/PaddleOCR&type=Date)](https://star-history.com/#PaddlePaddle/PaddleOCR&Date)\n\n## 🇺🇳 Guideline for New Language Requests\n\nIf you want to request a new language support, a PR with 1 following files are needed：\n\n- In folder [ppocr/utils/dict](./ppocr/utils/dict),\nit is necessary to submit the dict text to this path and name it with `{language}_dict.txt` that contains a list of all characters. Please see the format example from other files in that folder.\n\nIf your language has unique elements, please tell me in advance within any way, such as useful links, wikipedia and so on.\n\nMore details, please refer to [Multilingual OCR Development Plan](https://github.com/PaddlePaddle/PaddleOCR/discussions/12734).\n\n## 📄 License\n\nThis project is released under [Apache License Version 2.0](./LICENSE).\n"
        },
        {
          "name": "__init__.py",
          "type": "blob",
          "size": 1.21875,
          "content": "# Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom .paddleocr import (\n    PaddleOCR,\n    PPStructure,\n    draw_ocr,\n    draw_structure_result,\n    save_structure_res,\n    download_with_progressbar,\n    sorted_layout_boxes,\n    convert_info_docx,\n    to_excel,\n)\nimport importlib.metadata as importlib_metadata\n\ntry:\n    __version__ = importlib_metadata.version(__package__ or __name__)\nexcept importlib_metadata.PackageNotFoundError:\n    __version__ = \"0.0.0\"\n\n__all__ = [\n    \"PaddleOCR\",\n    \"PPStructure\",\n    \"draw_ocr\",\n    \"draw_structure_result\",\n    \"save_structure_res\",\n    \"download_with_progressbar\",\n    \"sorted_layout_boxes\",\n    \"convert_info_docx\",\n    \"to_excel\",\n]\n"
        },
        {
          "name": "applications",
          "type": "tree",
          "content": null
        },
        {
          "name": "benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "configs",
          "type": "tree",
          "content": null
        },
        {
          "name": "deploy",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "mkdocs.yml",
          "type": "blob",
          "size": 17.3681640625,
          "content": "site_name: PaddleOCR 文档\nsite_url: https://paddlepaddle.github.io/PaddleOCR/\nsite_author: PaddleOCR PMC\nsite_description:\n  Awesome multilingual OCR toolkits based on PaddlePaddle (practical ultra lightweight OCR system, support 80+ languages recognition, provide data annotation and synthesis tools, support training and deployment among server, mobile, embedded and IoT devices)\n\nrepo_name: PaddlePaddle/PaddleOCR\nrepo_url: https://github.com/PaddlePaddle/PaddleOCR\n\ncopyright: Copyright &copy; 2024 Maintained by PaddleOCR PMC.\n\nedit_uri: edit/main/docs/\n\ntheme:\n  name: material\n  logo: ./static/images/logo.jpg\n  favicon: ./static/images/logo.jpg\n  custom_dir: overrides\n  features:\n    - announce.dismiss\n    - content.tooltips\n    - content.code.copy\n    - content.tabs.link\n    - content.footnote.tooltips\n    - content.action.edit\n    - content.action.view\n    - navigation.expand  # 默认打开所有的字节\n    - navigation.tabs # 顶级索引被作为tab\n    - navigation.tabs.sticky # tab始终可见\n    - navigation.top # 开启顶部导航栏\n    - navigation.tracking # 导航栏跟踪\n    - navigation.footer\n    - navigation.indexes\n    - search.highlight # 搜索高亮\n    - search.share # 搜索分享\n    - search.suggest # 搜索建议\n    - toc.follow # 目录跟踪-页面右侧的小目录\n\n  palette:\n    - media: \"(prefers-color-scheme: light)\" # 浅色\n      scheme: default\n      primary: indigo\n      accent: indigo\n      toggle:\n        icon: material/brightness-7\n        name: Switch to dark mode\n    - media: \"(prefers-color-scheme: dark)\" # 深色\n      scheme: slate\n      primary: black\n      accent: indigo\n      toggle:\n        icon: material/brightness-4\n        name: Switch to system preference\n\n  icon:\n    logo: logo\n    previous: fontawesome/solid/angle-left\n    next: fontawesome/solid/angle-right\n    repo: fontawesome/brands/github\n    edit: material/pencil\n    view: material/eye\n    tag:\n      default-tag: fontawesome/solid/tag\n      hardware-tag: fontawesome/solid/microchip\n      software-tag: fontawesome/solid/laptop-code\n    admonition:\n      note: octicons/tag-16\n      abstract: octicons/checklist-16\n      info: octicons/info-16\n      tip: octicons/squirrel-16\n      success: octicons/check-16\n      question: octicons/question-16\n      warning: octicons/alert-16\n      failure: octicons/x-circle-16\n      danger: octicons/zap-16\n      bug: octicons/bug-16\n      example: octicons/beaker-16\n      quote: octicons/quote-16\n\nplugins:\n  - tags\n  - offline\n  - search:\n      separator: '[\\s\\u200b\\-_,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])'\n  - i18n:\n      docs_structure: suffix\n      fallback_to_default: true\n      reconfigure_material: true\n      reconfigure_search: true\n      languages:\n        - locale: zh\n          name: 简体中文\n          default: true\n          build: true\n        - locale: en\n          name: English\n          site_name: PaddleOCR Documentation\n          link: /en/\n          nav_translations:\n            Home: Home\n            快速开始: Quick Start\n            近期更新: Recently Update\n            低代码全流程开发: All-in-One Development\n            概述: Overview\n            模型: Model\n            PP-OCR 文本检测识别: PP-OCR\n            快速安装: Quick Installation\n            效果展示: Visualization\n            运行环境: Environment Preparation\n            模型库: Model\n            模型训练: Model Training\n            基本概念: Basic concepts\n            文本检测: Text Detection\n            文本识别: Text Recognition\n            文本方向分类器: Text Angle Classification\n            关键信息提取: Key Information Extraction\n            模型微调: Fine-tune\n            训练tricks: Training Tricks\n            模型压缩: Model Compression\n            模型量化: Model Quantization\n            模型裁剪: Model Prune\n            知识蒸馏: Knowledge Distillation\n            推理部署: Model Deploy\n            基于Python预测引擎推理: Python Inference\n            基于C++预测引擎推理: CPP Inference\n            Visual Studio 2019 Community CMake 编译指南: Visual Studio 2019 Community CMake Compilation Guide\n            服务化部署: Sever Deployment\n            Jetson部署: Jetson Deployment\n            端侧部署: Device-side Deployment\n            网页前端部署: Paddle.js Web Deployment\n            Paddle2ONNX模型转化与预测: Paddle2ONNX\n            云上飞桨部署工具: Paddle Cloud\n            Benchmark: Benchmark\n            博客: Blog\n            paddleocr package使用说明: Paddleocr Package Instructions\n            多语言模型: Multi-language model\n            动手学OCR: Dive into OCR\n            切片操作: Slice\n            PaddleOCR模型推理参数解释: PaddleOCR Model Inference Parameter Explanation\n            分布式训练: Distributed training\n            项目克隆: Project Clone\n            配置文件内容与生成: Configuration\n            如何生产自定义超轻量模型？: How To Make Your own lightweight OCR model?\n            PP-Structure文档分析: PP-Structure\n            版面分析: Layout Analysis\n            版面恢复: Recovery To Doc\n            表格识别: Table Recognition\n            返回识别位置: Return Recognition Location\n            怎样完成基于图像数据的信息抽取任务: Key Information Extraction Pipeline\n            前沿算法与模型: Academic Algorithms\n            文本检测算法: Text Detection Algorithms\n            DB与DB++: DB and DB++\n            文本识别算法: Text Recognition Algorithms\n            文本超分辨率算法: Text Super-Resolution Algorithm\n            公式识别算法: Formulat Recognition\n            端到端OCR算法: End-to-End OCR Algorithms\n            表格识别算法: Table Recognition Algorithms\n            关键信息抽取算法: Key Information Extraction Algorithms\n            使用PaddleOCR架构添加新算法: Add new algorithms\n            场景应用: Applications\n            数据标注与合成: Data Annotation and Synthesis\n            其它数据标注工具: Other data annotation tools\n            其它数据合成工具: Others data synthesis tools\n            数据集: Datasets\n            通用中英文OCR数据集: General Chinese and English OCR dataset\n            手写中文OCR数据集: Handwritten Chinese OCR Dataset\n            垂类多语言OCR数据集: Vertical multi-language OCR dataset\n            版面分析数据集: Layout Analysis Dataset\n            表格识别数据集: Table recognition dataset\n            关键信息提取数据集: Key Information Extraction Dataset\n            FAQ: FAQ\n            社区: Community\n            社区贡献: Community Contribution\n            附录: Appendix\n        - locale: ja\n          name: 日本語\n          site_name: PaddleOCR ドキュメント\n          link: /ja/\n          nav_translations:\n            Home: トップページ\n        - locale: ru\n          name: Pу́сский язы́к\n          site_name: Документация PaddleOCR\n          link: /ru/\n          nav_translations:\n            Home: Главная страница\n        - locale: hi\n          name: हिन्दी\n          site_name: पैडलओसीआर दस्तावेज़ीकरण\n          link: /hi/\n          nav_translations:\n            Home: घर पृष्ठ\n        - locale: ko\n          name: 한국인\n          site_name: PaddleOCR 문서\n          link: /ko/\n          nav_translations:\n            Home: 첫 페이지\n        - locale: \"null\"\n          name: Help translating\n          build: false\n          fixed_link: \"https://github.com/PaddlePaddle/PaddleOCR/discussions/13374\"\n  - git-committers:\n      repository: PaddlePaddle/PaddleOCR\n      branch: main\n      token: !!python/object/apply:os.getenv [\"MKDOCS_GIT_COMMITTERS_APIKEY\"]\n  - git-revision-date-localized:\n      enable_creation_date: true\n\nmarkdown_extensions:\n  - abbr\n  - attr_list\n  - pymdownx.snippets\n  - pymdownx.critic\n  - pymdownx.caret\n  - pymdownx.keys\n  - pymdownx.mark\n  - pymdownx.tilde\n  - footnotes\n  - def_list\n  - md_in_html\n  - pymdownx.tasklist:\n      custom_checkbox: true\n  - toc:\n      permalink: true\n  - pymdownx.superfences:\n      custom_fences:\n        - name: mermaid\n          class: mermaid\n          format: !!python/name:pymdownx.superfences.fence_code_format\n  - pymdownx.emoji:\n      emoji_index: !!python/name:material.extensions.emoji.twemoji\n      emoji_generator: !!python/name:material.extensions.emoji.to_svg\n  - pymdownx.highlight:\n        anchor_linenums: true\n        line_spans: __span\n        pygments_lang_class: true\n  - pymdownx.inlinehilite\n  - pymdownx.tabbed:\n      alternate_style: true\n  - admonition\n  - pymdownx.details\n  - pymdownx.superfences\n  - pymdownx.arithmatex:\n      generic: true\n\nextra:\n  social:\n    - icon: fontawesome/brands/github\n      link: https://github.com/PaddlePaddle/PaddleOCR\n    - icon: fontawesome/brands/python\n      link: https://pypi.org/project/paddleocr/\n  version:\n    provider: mike\n\nextra_javascript:\n  - javascripts/katex.min.js\n  - https://unpkg.com/katex@0/dist/katex.min.js\n  - https://unpkg.com/katex@0/dist/contrib/auto-render.min.js\n\nextra_css:\n  - https://unpkg.com/katex@0/dist/katex.min.css\n\nnav:\n  - Home: index.md\n  - 快速开始: quick_start.md\n  - 近期更新: update.md\n  - 低代码全流程开发:\n      - 概述: paddlex/overview.md\n      - 快速开始: paddlex/quick_start.md\n  - 模型:\n    - 概览: model/index.md\n    - 多硬件安装飞桨:\n      - 多硬件安装飞桨: model/hardware/install_other_devices.md\n      - 支持硬件列表: model/hardware/supported_models.md\n  - PP-OCR 文本检测识别:\n    - 概述: ppocr/overview.md\n    - 快速开始: ppocr/quick_start.md\n    - 快速安装: ppocr/installation.md\n    - 效果展示: ppocr/visualization.md\n    - 运行环境: ppocr/environment.md\n    - 模型库: ppocr/model_list.md\n    - 模型训练:\n      - 基本概念: ppocr/model_train/training.md\n      - 文本检测: ppocr/model_train/detection.md\n      - 文本识别: ppocr/model_train/recognition.md\n      - 文本方向分类器: ppocr/model_train/angle_class.md\n      - 关键信息提取: ppocr/model_train/kie.md\n      - 模型微调: ppocr/model_train/finetune.md\n      - 训练tricks: ppocr/model_train/tricks.md\n    - 模型压缩:\n      - 模型量化: ppocr/model_compress/quantization.md\n      - 模型裁剪: ppocr/model_compress/prune.md\n      - 知识蒸馏: ppocr/model_compress/knowledge_distillation.md\n    - 推理部署:\n      - 概述: ppocr/infer_deploy/index.md\n      - 基于Python预测引擎推理: ppocr/infer_deploy/python_infer.md\n      - 基于C++预测引擎推理: ppocr/infer_deploy/cpp_infer.md\n      - Visual Studio 2019 Community CMake 编译指南: ppocr/infer_deploy/windows_vs2019_build.md\n      - 服务化部署: ppocr/infer_deploy/paddle_server.md\n      - Android部署: ppocr/infer_deploy/android_demo.md\n      - Jetson部署: ppocr/infer_deploy/Jetson_infer.md\n      - 端侧部署: ppocr/infer_deploy/lite.md\n      - 网页前端部署: ppocr/infer_deploy/paddle_js.md\n      - Paddle2ONNX模型转化与预测: ppocr/infer_deploy/paddle2onnx.md\n      - 云上飞桨部署工具: ppocr/infer_deploy/paddle_cloud.md\n      - Benchmark: ppocr/infer_deploy/benchmark.md\n    - 博客:\n      - PP-OCRv3技术报告: ppocr/blog/PP-OCRv3_introduction.md\n      - PP-OCRv4技术报告: ppocr/blog/PP-OCRv4_introduction.md\n      - paddleocr package使用说明: ppocr/blog/whl.md\n      - 多语言模型: ppocr/blog/multi_languages.md\n      - 动手学OCR: ppocr/blog/ocr_book.md\n      - Enhanced CTC Loss: ppocr/blog/enhanced_ctc_loss.md\n      - 切片操作: ppocr/blog/slice.md\n      - PaddleOCR模型推理参数解释: ppocr/blog/inference_args.md\n      - 分布式训练: ppocr/blog/distributed_training.md\n      - 项目克隆: ppocr/blog/clone.md\n      - 配置文件内容与生成: ppocr/blog/config.md\n      - 如何生产自定义超轻量模型？: ppocr/blog/customize.md\n  - PP-Structure文档分析:\n    - 概述: ppstructure/overview.md\n    - 快速开始: ppstructure/quick_start.md\n    - 模型库: ppstructure/models_list.md\n    - 模型训练:\n      - 基本概念: ppstructure/model_train/training.md\n      - 版面分析: ppstructure/model_train/train_layout.md\n      - 表格识别: ppstructure/model_train/train_table.md\n      - 版面恢复: ppstructure/model_train/recovery_to_doc.md\n      - 关键信息提取: ppstructure/model_train/train_kie.md\n    - 推理部署:\n      - 概述: ppstructure/infer_deploy/index.md\n      - 基于Python预测引擎推理: ppstructure/infer_deploy/python_infer.md\n      - 基于C++预测引擎推理: ppstructure/infer_deploy/cpp_infer.md\n      - 服务化部署: ppstructure/infer_deploy/paddle_server.md\n    - 博客:\n      - 返回识别位置: ppstructure/blog/return_word_pos.md\n      - 怎样完成基于图像数据的信息抽取任务: ppstructure/blog/how_to_do_kie.md\n  - 前沿算法与模型:\n    - 概述: algorithm/overview.md\n    - 文本检测算法:\n      - DB与DB++: algorithm/text_detection/algorithm_det_db.md\n      - EAST: algorithm/text_detection/algorithm_det_east.md\n      - SAST: algorithm/text_detection/algorithm_det_sast.md\n      - PSENet: algorithm/text_detection/algorithm_det_psenet.md\n      - FCENet: algorithm/text_detection/algorithm_det_fcenet.md\n      - DRRG: algorithm/text_detection/algorithm_det_drrg.md\n      - CT: algorithm/text_detection/algorithm_det_ct.md\n    - 文本识别算法:\n      - CRNN: algorithm/text_recognition/algorithm_rec_crnn.md\n      - Rosetta: algorithm/text_recognition/algorithm_rec_rosetta.md\n      - STAR-Net: algorithm/text_recognition/algorithm_rec_starnet.md\n      - RARE: algorithm/text_recognition/algorithm_rec_rare.md\n      - SRN: algorithm/text_recognition/algorithm_rec_srn.md\n      - NRTR: algorithm/text_recognition/algorithm_rec_nrtr.md\n      - SAR: algorithm/text_recognition/algorithm_rec_sar.md\n      - SEED: algorithm/text_recognition/algorithm_rec_seed.md\n      - SVTR: algorithm/text_recognition/algorithm_rec_svtr.md\n      - SVTRv2: algorithm/text_recognition/algorithm_rec_svtrv2.md\n      - ViTSTR: algorithm/text_recognition/algorithm_rec_vitstr.md\n      - ABINet: algorithm/text_recognition/algorithm_rec_abinet.md\n      - VisionLAN: algorithm/text_recognition/algorithm_rec_visionlan.md\n      - SPIN: algorithm/text_recognition/algorithm_rec_spin.md\n      - RobustScanner: algorithm/text_recognition/algorithm_rec_robustscanner.md\n      - RFL: algorithm/text_recognition/algorithm_rec_rfl.md\n      - ParseQ: algorithm/text_recognition/algorithm_rec_parseq.md\n      - CPPD: algorithm/text_recognition/algorithm_rec_cppd.md\n      - SATRN: algorithm/text_recognition/algorithm_rec_satrn.md\n    - 文本超分辨率算法:\n      - Text Gestalt: algorithm/super_resolution/algorithm_sr_gestalt.md\n      - Text Telescope: algorithm/super_resolution/algorithm_sr_telescope.md\n    - 公式识别算法:\n      - CAN: algorithm/formula_recognition/algorithm_rec_can.md\n      - LaTeX-OCR: algorithm/formula_recognition/algorithm_rec_latex_ocr.md\n      - UniMERNet: algorithm/formula_recognition/algorithm_rec_unimernet.md\n      - PP-FormulaNet: algorithm/formula_recognition/algorithm_rec_ppformulanet.md\n    - 端到端OCR算法:\n      - PGNet: algorithm/end_to_end/algorithm_e2e_pgnet.md\n    - 表格识别算法:\n      - TableMaster: algorithm/table_recognition/algorithm_table_master.md\n      - TableSLANet: algorithm/table_recognition/algorithm_table_slanet.md\n    - 关键信息抽取算法:\n      - VI-LayoutXLM: algorithm/kie/algorithm_kie_vi_layoutxlm.md\n      - LayoutLM: algorithm/kie/algorithm_kie_layoutxlm.md\n      # - LayoutLMv2: algorithm/kie/algorithm_kie_layoutxlm.md\n      # - LayoutXLM: algorithm/kie/algorithm_kie_layoutxlm.md\n      - SDMGR: algorithm/kie/./algorithm_kie_sdmgr.md\n    - 使用PaddleOCR架构添加新算法: algorithm/add_new_algorithm.md\n  - 场景应用:\n    - 概述: applications/overview.md\n    - 通用:\n      - 高精度中文场景文本识别模型SVTR: applications/高精度中文识别模型.md\n      - 手写体识别: applications/手写文字识别.md\n    - 制造:\n      - 数码管识别: applications/光功率计数码管字符识别.md\n      - 液晶屏读数识别: applications/液晶屏读数识别.md\n      - 包装生产日期: applications/包装生产日期识别.md\n      - PCB文字识别: applications/PCB字符识别.md\n    - 金融:\n      - 表单VQA: applications/多模态表单识别.md\n      - 增值税发票: applications/发票关键信息抽取.md\n      - 印章检测与识别: applications/印章弯曲文字识别.md\n      - 通用卡证识别: applications/快速构建卡证类OCR.md\n      - 合同比对: applications/扫描合同关键信息提取.md\n    - 交通:\n      - 车牌识别: applications/轻量级车牌识别.md\n  - 数据标注与合成:\n    - 概述: data_anno_synth/overview.md\n    - 其它数据标注工具: data_anno_synth/data_annotation.md\n    - 其它数据合成工具: data_anno_synth/data_synthesis.md\n  - 数据集:\n    - 通用中英文OCR数据集: datasets/datasets.md\n    - 手写中文OCR数据集: datasets/handwritten_datasets.md\n    - 垂类多语言OCR数据集: datasets/vertical_and_multilingual_datasets.md\n    - 版面分析数据集: datasets/layout_datasets.md\n    - 表格识别数据集: datasets/table_datasets.md\n    - 关键信息提取数据集: datasets/kie_datasets.md\n  - FAQ: FAQ.md\n  - 社区:\n    - 社区贡献: community/community_contribution.md\n    - 附录: community/code_and_doc.md\n"
        },
        {
          "name": "overrides",
          "type": "tree",
          "content": null
        },
        {
          "name": "paddleocr.py",
          "type": "blob",
          "size": 41.2548828125,
          "content": "# Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport sys\nimport importlib\n\n__dir__ = os.path.dirname(__file__)\n\nfrom paddle.utils import try_import\n\nsys.path.append(os.path.join(__dir__, \"\"))\n\nimport cv2\nfrom copy import deepcopy\nimport logging\nimport numpy as np\nfrom pathlib import Path\nimport base64\nfrom io import BytesIO\nimport pprint\nfrom PIL import Image\n\n\ndef _import_file(module_name, file_path, make_importable=False):\n    spec = importlib.util.spec_from_file_location(module_name, file_path)\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    if make_importable:\n        sys.modules[module_name] = module\n    return module\n\n\ntools = _import_file(\n    \"tools\", os.path.join(__dir__, \"tools/__init__.py\"), make_importable=True\n)\nppocr = importlib.import_module(\"ppocr\", \"paddleocr\")\nppstructure = importlib.import_module(\"ppstructure\", \"paddleocr\")\nfrom ppocr.utils.logging import get_logger\n\nfrom ppocr.utils.utility import (\n    check_and_read,\n    get_image_file_list,\n    alpha_to_color,\n    binarize_img,\n)\nfrom ppocr.utils.network import (\n    maybe_download,\n    download_with_progressbar,\n    is_link,\n    confirm_model_dir_url,\n)\nfrom tools.infer import predict_system\nfrom tools.infer.utility import draw_ocr, str2bool, check_gpu\nfrom ppstructure.utility import init_args, draw_structure_result\nfrom ppstructure.predict_system import StructureSystem, save_structure_res, to_excel\nfrom ppstructure.recovery.recovery_to_doc import sorted_layout_boxes, convert_info_docx\nfrom ppstructure.recovery.recovery_to_markdown import convert_info_markdown\n\nlogger = get_logger()\n\n__all__ = [\n    \"PaddleOCR\",\n    \"PPStructure\",\n    \"draw_ocr\",\n    \"draw_structure_result\",\n    \"save_structure_res\",\n    \"download_with_progressbar\",\n    \"to_excel\",\n    \"sorted_layout_boxes\",\n    \"convert_info_docx\",\n    \"convert_info_markdown\",\n]\n\nSUPPORT_DET_MODEL = [\"DB\"]\nSUPPORT_REC_MODEL = [\"CRNN\", \"SVTR_LCNet\"]\nBASE_DIR = os.path.expanduser(\"~/.paddleocr/\")\n\nDEFAULT_OCR_MODEL_VERSION = \"PP-OCRv4\"\nSUPPORT_OCR_MODEL_VERSION = [\"PP-OCR\", \"PP-OCRv2\", \"PP-OCRv3\", \"PP-OCRv4\"]\nDEFAULT_STRUCTURE_MODEL_VERSION = \"PP-StructureV2\"\nSUPPORT_STRUCTURE_MODEL_VERSION = [\"PP-Structure\", \"PP-StructureV2\"]\nMODEL_URLS = {\n    \"OCR\": {\n        \"PP-OCRv4\": {\n            \"det\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv4/chinese/ch_PP-OCRv4_det_infer.tar\",\n                },\n                \"en\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_det_infer.tar\",\n                },\n                \"ml\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/Multilingual_PP-OCRv3_det_infer.tar\"\n                },\n            },\n            \"rec\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv4/chinese/ch_PP-OCRv4_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/ppocr_keys_v1.txt\",\n                },\n                \"en\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv4/english/en_PP-OCRv4_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/en_dict.txt\",\n                },\n                \"korean\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv4/multilingual/korean_PP-OCRv4_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/korean_dict.txt\",\n                },\n                \"japan\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv4/multilingual/japan_PP-OCRv4_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/japan_dict.txt\",\n                },\n                \"chinese_cht\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/chinese_cht_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/chinese_cht_dict.txt\",\n                },\n                \"ta\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv4/multilingual/ta_PP-OCRv4_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/ta_dict.txt\",\n                },\n                \"te\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv4/multilingual/te_PP-OCRv4_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/te_dict.txt\",\n                },\n                \"ka\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv4/multilingual/ka_PP-OCRv4_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/ka_dict.txt\",\n                },\n                \"latin\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/latin_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/latin_dict.txt\",\n                },\n                \"arabic\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv4/multilingual/arabic_PP-OCRv4_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/arabic_dict.txt\",\n                },\n                \"cyrillic\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/cyrillic_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/cyrillic_dict.txt\",\n                },\n                \"devanagari\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv4/multilingual/devanagari_PP-OCRv4_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/devanagari_dict.txt\",\n                },\n            },\n            \"cls\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/ch/ch_ppocr_mobile_v2.0_cls_infer.tar\",\n                }\n            },\n        },\n        \"PP-OCRv3\": {\n            \"det\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/chinese/ch_PP-OCRv3_det_infer.tar\",\n                },\n                \"en\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_det_infer.tar\",\n                },\n                \"ml\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/Multilingual_PP-OCRv3_det_infer.tar\"\n                },\n            },\n            \"rec\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/chinese/ch_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/ppocr_keys_v1.txt\",\n                },\n                \"en\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/en_dict.txt\",\n                },\n                \"korean\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/korean_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/korean_dict.txt\",\n                },\n                \"japan\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/japan_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/japan_dict.txt\",\n                },\n                \"chinese_cht\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/chinese_cht_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/chinese_cht_dict.txt\",\n                },\n                \"ta\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/ta_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/ta_dict.txt\",\n                },\n                \"te\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/te_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/te_dict.txt\",\n                },\n                \"ka\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/ka_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/ka_dict.txt\",\n                },\n                \"latin\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/latin_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/latin_dict.txt\",\n                },\n                \"arabic\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/arabic_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/arabic_dict.txt\",\n                },\n                \"cyrillic\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/cyrillic_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/cyrillic_dict.txt\",\n                },\n                \"devanagari\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv3/multilingual/devanagari_PP-OCRv3_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/devanagari_dict.txt\",\n                },\n            },\n            \"cls\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/ch/ch_ppocr_mobile_v2.0_cls_infer.tar\",\n                }\n            },\n        },\n        \"PP-OCRv2\": {\n            \"det\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv2/chinese/ch_PP-OCRv2_det_infer.tar\",\n                },\n            },\n            \"rec\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/PP-OCRv2/chinese/ch_PP-OCRv2_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/ppocr_keys_v1.txt\",\n                }\n            },\n            \"cls\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/ch/ch_ppocr_mobile_v2.0_cls_infer.tar\",\n                }\n            },\n        },\n        \"PP-OCR\": {\n            \"det\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/ch/ch_ppocr_mobile_v2.0_det_infer.tar\",\n                },\n                \"en\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/en_ppocr_mobile_v2.0_det_infer.tar\",\n                },\n                \"structure\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/table/en_ppocr_mobile_v2.0_table_det_infer.tar\"\n                },\n            },\n            \"rec\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/ch/ch_ppocr_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/ppocr_keys_v1.txt\",\n                },\n                \"en\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/en_number_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/en_dict.txt\",\n                },\n                \"french\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/french_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/french_dict.txt\",\n                },\n                \"german\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/german_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/german_dict.txt\",\n                },\n                \"korean\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/korean_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/korean_dict.txt\",\n                },\n                \"japan\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/japan_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/japan_dict.txt\",\n                },\n                \"chinese_cht\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/chinese_cht_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/chinese_cht_dict.txt\",\n                },\n                \"ta\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/ta_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/ta_dict.txt\",\n                },\n                \"te\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/te_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/te_dict.txt\",\n                },\n                \"ka\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/ka_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/ka_dict.txt\",\n                },\n                \"latin\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/latin_ppocr_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/latin_dict.txt\",\n                },\n                \"arabic\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/arabic_ppocr_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/arabic_dict.txt\",\n                },\n                \"cyrillic\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/cyrillic_ppocr_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/cyrillic_dict.txt\",\n                },\n                \"devanagari\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/multilingual/devanagari_ppocr_mobile_v2.0_rec_infer.tar\",\n                    \"dict_path\": \"./ppocr/utils/dict/devanagari_dict.txt\",\n                },\n                \"structure\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/table/en_ppocr_mobile_v2.0_table_rec_infer.tar\",\n                    \"dict_path\": \"ppocr/utils/dict/table_dict.txt\",\n                },\n            },\n            \"cls\": {\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/ch/ch_ppocr_mobile_v2.0_cls_infer.tar\",\n                }\n            },\n        },\n    },\n    \"STRUCTURE\": {\n        \"PP-Structure\": {\n            \"table\": {\n                \"en\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/dygraph_v2.0/table/en_ppocr_mobile_v2.0_table_structure_infer.tar\",\n                    \"dict_path\": \"ppocr/utils/dict/table_structure_dict.txt\",\n                }\n            }\n        },\n        \"PP-StructureV2\": {\n            \"table\": {\n                \"en\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/ppstructure/models/slanet/paddle3.0b2/en_ppstructure_mobile_v2.0_SLANet_infer.tar\",\n                    \"dict_path\": \"ppocr/utils/dict/table_structure_dict.txt\",\n                },\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/ppstructure/models/slanet/paddle3.0b2/ch_ppstructure_mobile_v2.0_SLANet_infer.tar\",\n                    \"dict_path\": \"ppocr/utils/dict/table_structure_dict_ch.txt\",\n                },\n            },\n            \"layout\": {\n                \"en\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/ppstructure/models/layout/picodet_lcnet_x1_0_fgd_layout_infer.tar\",\n                    \"dict_path\": \"ppocr/utils/dict/layout_dict/layout_publaynet_dict.txt\",\n                },\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/ppstructure/models/layout/picodet_lcnet_x1_0_fgd_layout_cdla_infer.tar\",\n                    \"dict_path\": \"ppocr/utils/dict/layout_dict/layout_cdla_dict.txt\",\n                },\n            },\n            \"formula\": {\n                \"en\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/contribution/rec_latex_ocr_infer.tar\",\n                    \"dict_path\": \"ppocr/utils/dict/latex_ocr_tokenizer.json\",\n                },\n                \"ch\": {\n                    \"url\": \"https://paddleocr.bj.bcebos.com/contribution/rec_latex_ocr_infer.tar\",\n                    \"dict_path\": \"ppocr/utils/dict/latex_ocr_tokenizer.json\",\n                },\n            },\n        },\n    },\n}\n\n\ndef parse_args(mMain=True):\n    import argparse\n\n    parser = init_args()\n    parser.add_help = mMain\n    parser.add_argument(\"--lang\", type=str, default=\"ch\")\n    parser.add_argument(\"--det\", type=str2bool, default=True)\n    parser.add_argument(\"--rec\", type=str2bool, default=True)\n    parser.add_argument(\"--type\", type=str, default=\"ocr\")\n    parser.add_argument(\"--savefile\", type=str2bool, default=False)\n    parser.add_argument(\n        \"--ocr_version\",\n        type=str,\n        choices=SUPPORT_OCR_MODEL_VERSION,\n        default=\"PP-OCRv4\",\n        help=\"OCR Model version, the current model support list is as follows: \"\n        \"1. PP-OCRv4/v3 Support Chinese and English detection and recognition model, and direction classifier model\"\n        \"2. PP-OCRv2 Support Chinese detection and recognition model. \"\n        \"3. PP-OCR support Chinese detection, recognition and direction classifier and multilingual recognition model.\",\n    )\n    parser.add_argument(\n        \"--structure_version\",\n        type=str,\n        choices=SUPPORT_STRUCTURE_MODEL_VERSION,\n        default=\"PP-StructureV2\",\n        help=\"Model version, the current model support list is as follows:\"\n        \" 1. PP-Structure Support en table structure model.\"\n        \" 2. PP-StructureV2 Support ch and en table structure model.\",\n    )\n\n    for action in parser._actions:\n        if action.dest in [\n            \"rec_char_dict_path\",\n            \"table_char_dict_path\",\n            \"layout_dict_path\",\n            \"formula_char_dict_path\",\n        ]:\n            action.default = None\n    if mMain:\n        return parser.parse_args()\n    else:\n        inference_args_dict = {}\n        for action in parser._actions:\n            inference_args_dict[action.dest] = action.default\n        return argparse.Namespace(**inference_args_dict)\n\n\ndef parse_lang(lang):\n    latin_lang = [\n        \"af\",\n        \"az\",\n        \"bs\",\n        \"cs\",\n        \"cy\",\n        \"da\",\n        \"de\",\n        \"es\",\n        \"et\",\n        \"fr\",\n        \"ga\",\n        \"hr\",\n        \"hu\",\n        \"id\",\n        \"is\",\n        \"it\",\n        \"ku\",\n        \"la\",\n        \"lt\",\n        \"lv\",\n        \"mi\",\n        \"ms\",\n        \"mt\",\n        \"nl\",\n        \"no\",\n        \"oc\",\n        \"pi\",\n        \"pl\",\n        \"pt\",\n        \"ro\",\n        \"rs_latin\",\n        \"sk\",\n        \"sl\",\n        \"sq\",\n        \"sv\",\n        \"sw\",\n        \"tl\",\n        \"tr\",\n        \"uz\",\n        \"vi\",\n        \"french\",\n        \"german\",\n    ]\n    arabic_lang = [\"ar\", \"fa\", \"ug\", \"ur\"]\n    cyrillic_lang = [\n        \"ru\",\n        \"rs_cyrillic\",\n        \"be\",\n        \"bg\",\n        \"uk\",\n        \"mn\",\n        \"abq\",\n        \"ady\",\n        \"kbd\",\n        \"ava\",\n        \"dar\",\n        \"inh\",\n        \"che\",\n        \"lbe\",\n        \"lez\",\n        \"tab\",\n    ]\n    devanagari_lang = [\n        \"hi\",\n        \"mr\",\n        \"ne\",\n        \"bh\",\n        \"mai\",\n        \"ang\",\n        \"bho\",\n        \"mah\",\n        \"sck\",\n        \"new\",\n        \"gom\",\n        \"sa\",\n        \"bgc\",\n    ]\n    if lang in latin_lang:\n        lang = \"latin\"\n    elif lang in arabic_lang:\n        lang = \"arabic\"\n    elif lang in cyrillic_lang:\n        lang = \"cyrillic\"\n    elif lang in devanagari_lang:\n        lang = \"devanagari\"\n    assert (\n        lang in MODEL_URLS[\"OCR\"][DEFAULT_OCR_MODEL_VERSION][\"rec\"]\n    ), \"param lang must in {}, but got {}\".format(\n        MODEL_URLS[\"OCR\"][DEFAULT_OCR_MODEL_VERSION][\"rec\"].keys(), lang\n    )\n    if lang == \"ch\":\n        det_lang = \"ch\"\n    elif lang == \"structure\":\n        det_lang = \"structure\"\n    elif lang in [\"en\", \"latin\"]:\n        det_lang = \"en\"\n    else:\n        det_lang = \"ml\"\n    return lang, det_lang\n\n\ndef get_model_config(type, version, model_type, lang):\n    if type == \"OCR\":\n        DEFAULT_MODEL_VERSION = DEFAULT_OCR_MODEL_VERSION\n    elif type == \"STRUCTURE\":\n        DEFAULT_MODEL_VERSION = DEFAULT_STRUCTURE_MODEL_VERSION\n    else:\n        raise NotImplementedError\n\n    model_urls = MODEL_URLS[type]\n    if version not in model_urls:\n        version = DEFAULT_MODEL_VERSION\n    if model_type not in model_urls[version]:\n        if model_type in model_urls[DEFAULT_MODEL_VERSION]:\n            version = DEFAULT_MODEL_VERSION\n        else:\n            logger.error(\n                \"{} models is not support, we only support {}\".format(\n                    model_type, model_urls[DEFAULT_MODEL_VERSION].keys()\n                )\n            )\n            sys.exit(-1)\n\n    if lang not in model_urls[version][model_type]:\n        if lang in model_urls[DEFAULT_MODEL_VERSION][model_type]:\n            version = DEFAULT_MODEL_VERSION\n        else:\n            logger.error(\n                \"lang {} is not support, we only support {} for {} models\".format(\n                    lang,\n                    model_urls[DEFAULT_MODEL_VERSION][model_type].keys(),\n                    model_type,\n                )\n            )\n            sys.exit(-1)\n    return model_urls[version][model_type][lang]\n\n\ndef img_decode(content: bytes):\n    np_arr = np.frombuffer(content, dtype=np.uint8)\n    return cv2.imdecode(np_arr, cv2.IMREAD_UNCHANGED)\n\n\ndef check_img(img, alpha_color=(255, 255, 255)):\n    \"\"\"\n    Check the image data. If it is another type of image file, try to decode it into a numpy array.\n    The inference network requires three-channel images, So the following channel conversions are done\n        single channel image: Gray to RGB R←Y,G←Y,B←Y\n        four channel image: alpha_to_color\n    args:\n        img: image data\n            file format: jpg, png and other image formats that opencv can decode, as well as gif and pdf formats\n            storage type: binary image, net image file, local image file\n        alpha_color: Background color in images in RGBA format\n        return: numpy.array (h, w, 3) or list (p, h, w, 3) (p: page of pdf), boolean, boolean\n    \"\"\"\n    flag_gif, flag_pdf = False, False\n    if isinstance(img, bytes):\n        img = img_decode(img)\n    if isinstance(img, str):\n        # download net image\n        if is_link(img):\n            download_with_progressbar(img, \"tmp.jpg\")\n            img = \"tmp.jpg\"\n        image_file = img\n        img, flag_gif, flag_pdf = check_and_read(image_file)\n        if not flag_gif and not flag_pdf:\n            with open(image_file, \"rb\") as f:\n                img_str = f.read()\n                img = img_decode(img_str)\n            if img is None:\n                try:\n                    buf = BytesIO()\n                    image = BytesIO(img_str)\n                    im = Image.open(image)\n                    rgb = im.convert(\"RGB\")\n                    rgb.save(buf, \"jpeg\")\n                    buf.seek(0)\n                    image_bytes = buf.read()\n                    data_base64 = str(base64.b64encode(image_bytes), encoding=\"utf-8\")\n                    image_decode = base64.b64decode(data_base64)\n                    img_array = np.frombuffer(image_decode, np.uint8)\n                    img = cv2.imdecode(img_array, cv2.IMREAD_COLOR)\n                except:\n                    logger.error(\"error in loading image:{}\".format(image_file))\n                    return None, flag_gif, flag_pdf\n        if img is None:\n            logger.error(\"error in loading image:{}\".format(image_file))\n            return None, flag_gif, flag_pdf\n    # single channel image array.shape:h,w\n    if isinstance(img, np.ndarray) and len(img.shape) == 2:\n        img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    # four channel image array.shape:h,w,c\n    if isinstance(img, np.ndarray) and len(img.shape) == 3 and img.shape[2] == 4:\n        img = alpha_to_color(img, alpha_color)\n    return img, flag_gif, flag_pdf\n\n\nclass PaddleOCR(predict_system.TextSystem):\n    def __init__(self, **kwargs):\n        \"\"\"\n        paddleocr package\n        args:\n            **kwargs: other params show in paddleocr --help\n        \"\"\"\n        params = parse_args(mMain=False)\n        params.__dict__.update(**kwargs)\n        assert (\n            params.ocr_version in SUPPORT_OCR_MODEL_VERSION\n        ), \"ocr_version must in {}, but get {}\".format(\n            SUPPORT_OCR_MODEL_VERSION, params.ocr_version\n        )\n        params.use_gpu = check_gpu(params.use_gpu)\n\n        if not params.show_log:\n            logger.setLevel(logging.INFO)\n        self.use_angle_cls = params.use_angle_cls\n        lang, det_lang = parse_lang(params.lang)\n\n        # init model dir\n        det_model_config = get_model_config(\"OCR\", params.ocr_version, \"det\", det_lang)\n        params.det_model_dir, det_url = confirm_model_dir_url(\n            params.det_model_dir,\n            os.path.join(BASE_DIR, \"whl\", \"det\", det_lang),\n            det_model_config[\"url\"],\n        )\n        rec_model_config = get_model_config(\"OCR\", params.ocr_version, \"rec\", lang)\n        params.rec_model_dir, rec_url = confirm_model_dir_url(\n            params.rec_model_dir,\n            os.path.join(BASE_DIR, \"whl\", \"rec\", lang),\n            rec_model_config[\"url\"],\n        )\n        cls_model_config = get_model_config(\"OCR\", params.ocr_version, \"cls\", \"ch\")\n        params.cls_model_dir, cls_url = confirm_model_dir_url(\n            params.cls_model_dir,\n            os.path.join(BASE_DIR, \"whl\", \"cls\"),\n            cls_model_config[\"url\"],\n        )\n        if params.ocr_version in [\"PP-OCRv3\", \"PP-OCRv4\"]:\n            params.rec_image_shape = \"3, 48, 320\"\n        else:\n            params.rec_image_shape = \"3, 32, 320\"\n        if kwargs.get(\"rec_image_shape\") is not None:\n            params.rec_image_shape = kwargs.get(\"rec_image_shape\")\n        # download model if using paddle infer\n        if not params.use_onnx:\n            maybe_download(params.det_model_dir, det_url)\n            maybe_download(params.rec_model_dir, rec_url)\n            maybe_download(params.cls_model_dir, cls_url)\n\n        if params.det_algorithm not in SUPPORT_DET_MODEL:\n            logger.error(\"det_algorithm must in {}\".format(SUPPORT_DET_MODEL))\n            sys.exit(0)\n        if params.rec_algorithm not in SUPPORT_REC_MODEL:\n            logger.error(\"rec_algorithm must in {}\".format(SUPPORT_REC_MODEL))\n            sys.exit(0)\n\n        if params.rec_char_dict_path is None:\n            params.rec_char_dict_path = str(\n                Path(__file__).parent / rec_model_config[\"dict_path\"]\n            )\n\n        logger.debug(params)\n        # init det_model and rec_model\n        super().__init__(params)\n        self.page_num = params.page_num\n\n    def ocr(\n        self,\n        img,\n        det=True,\n        rec=True,\n        cls=True,\n        bin=False,\n        inv=False,\n        alpha_color=(255, 255, 255),\n        slice={},\n    ):\n        \"\"\"\n        OCR with PaddleOCR\n\n        Args:\n            img: Image for OCR. It can be an ndarray, img_path, or a list of ndarrays.\n            det: Use text detection or not. If False, only text recognition will be executed. Default is True.\n            rec: Use text recognition or not. If False, only text detection will be executed. Default is True.\n            cls: Use angle classifier or not. Default is True. If True, the text with a rotation of 180 degrees can be recognized. If no text is rotated by 180 degrees, use cls=False to get better performance.\n            bin: Binarize image to black and white. Default is False.\n            inv: Invert image colors. Default is False.\n            alpha_color: Set RGB color Tuple for transparent parts replacement. Default is pure white.\n            slice: Use sliding window inference for large images. Both det and rec must be True. Requires int values for slice[\"horizontal_stride\"], slice[\"vertical_stride\"], slice[\"merge_x_thres\"], slice[\"merge_y_thres\"] (See doc/doc_en/slice_en.md). Default is {}.\n\n        Returns:\n            If both det and rec are True, returns a list of OCR results for each image. Each OCR result is a list of bounding boxes and recognized text for each detected text region.\n            If det is True and rec is False, returns a list of detected bounding boxes for each image.\n            If det is False and rec is True, returns a list of recognized text for each image.\n            If both det and rec are False, returns a list of angle classification results for each image.\n\n        Raises:\n            AssertionError: If the input image is not of type ndarray, list, str, or bytes.\n            SystemExit: If det is True and the input is a list of images.\n\n        Note:\n            - If the angle classifier is not initialized (use_angle_cls=False), it will not be used during the forward process.\n            - For PDF files, if the input is a list of images and the page_num is specified, only the first page_num images will be processed.\n            - The preprocess_image function is used to preprocess the input image by applying alpha color replacement, inversion, and binarization if specified.\n        \"\"\"\n        assert isinstance(img, (np.ndarray, list, str, bytes))\n        if isinstance(img, list) and det == True:\n            logger.error(\"When input a list of images, det must be false\")\n            exit(0)\n        if cls == True and self.use_angle_cls == False:\n            logger.warning(\n                \"Since the angle classifier is not initialized, it will not be used during the forward process\"\n            )\n\n        img, flag_gif, flag_pdf = check_img(img, alpha_color)\n        # for infer pdf file\n        if isinstance(img, list) and flag_pdf:\n            if self.page_num > len(img) or self.page_num == 0:\n                imgs = img\n            else:\n                imgs = img[: self.page_num]\n        else:\n            imgs = [img]\n\n        def preprocess_image(_image):\n            _image = alpha_to_color(_image, alpha_color)\n            if inv:\n                _image = cv2.bitwise_not(_image)\n            if bin:\n                _image = binarize_img(_image)\n            return _image\n\n        if det and rec:\n            ocr_res = []\n            for img in imgs:\n                img = preprocess_image(img)\n                dt_boxes, rec_res, _ = self.__call__(img, cls, slice)\n                if not dt_boxes and not rec_res:\n                    ocr_res.append(None)\n                    continue\n                tmp_res = [[box.tolist(), res] for box, res in zip(dt_boxes, rec_res)]\n                ocr_res.append(tmp_res)\n            return ocr_res\n        elif det and not rec:\n            ocr_res = []\n            for img in imgs:\n                img = preprocess_image(img)\n                dt_boxes, elapse = self.text_detector(img)\n                if dt_boxes.size == 0:\n                    ocr_res.append(None)\n                    continue\n                tmp_res = [box.tolist() for box in dt_boxes]\n                ocr_res.append(tmp_res)\n            return ocr_res\n        else:\n            ocr_res = []\n            cls_res = []\n            for img in imgs:\n                if not isinstance(img, list):\n                    img = preprocess_image(img)\n                    img = [img]\n                if self.use_angle_cls and cls:\n                    img, cls_res_tmp, elapse = self.text_classifier(img)\n                    if not rec:\n                        cls_res.append(cls_res_tmp)\n                rec_res, elapse = self.text_recognizer(img)\n                ocr_res.append(rec_res)\n            if not rec:\n                return cls_res\n            return ocr_res\n\n\nclass PPStructure(StructureSystem):\n    \"\"\"\n    PPStructure class represents the structure analysis system for PaddleOCR.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initializes the PPStructure object with the given parameters.\n\n        Args:\n            **kwargs: Additional keyword arguments to customize the behavior of the structure analysis system.\n\n        Raises:\n            AssertionError: If the structure version is not supported.\n\n        \"\"\"\n        params = parse_args(mMain=False)\n        params.__dict__.update(**kwargs)\n        assert (\n            params.structure_version in SUPPORT_STRUCTURE_MODEL_VERSION\n        ), \"structure_version must in {}, but get {}\".format(\n            SUPPORT_STRUCTURE_MODEL_VERSION, params.structure_version\n        )\n        params.use_gpu = check_gpu(params.use_gpu)\n        params.mode = \"structure\"\n\n        if not params.show_log:\n            logger.setLevel(logging.INFO)\n        lang, det_lang = parse_lang(params.lang)\n        if lang == \"ch\":\n            table_lang = \"ch\"\n        else:\n            table_lang = \"en\"\n        if params.structure_version == \"PP-Structure\":\n            params.merge_no_span_structure = False\n\n        # init model dir\n        det_model_config = get_model_config(\"OCR\", params.ocr_version, \"det\", det_lang)\n        params.det_model_dir, det_url = confirm_model_dir_url(\n            params.det_model_dir,\n            os.path.join(BASE_DIR, \"whl\", \"det\", det_lang),\n            det_model_config[\"url\"],\n        )\n        rec_model_config = get_model_config(\"OCR\", params.ocr_version, \"rec\", lang)\n        params.rec_model_dir, rec_url = confirm_model_dir_url(\n            params.rec_model_dir,\n            os.path.join(BASE_DIR, \"whl\", \"rec\", lang),\n            rec_model_config[\"url\"],\n        )\n        table_model_config = get_model_config(\n            \"STRUCTURE\", params.structure_version, \"table\", table_lang\n        )\n        params.table_model_dir, table_url = confirm_model_dir_url(\n            params.table_model_dir,\n            os.path.join(BASE_DIR, \"whl\", \"table\"),\n            table_model_config[\"url\"],\n        )\n        layout_model_config = get_model_config(\n            \"STRUCTURE\", params.structure_version, \"layout\", lang\n        )\n        params.layout_model_dir, layout_url = confirm_model_dir_url(\n            params.layout_model_dir,\n            os.path.join(BASE_DIR, \"whl\", \"layout\"),\n            layout_model_config[\"url\"],\n        )\n        formula_model_config = get_model_config(\n            \"STRUCTURE\", params.structure_version, \"formula\", lang\n        )\n        params.formula_model_dir, formula_url = confirm_model_dir_url(\n            params.formula_model_dir,\n            os.path.join(BASE_DIR, \"whl\", \"formula\"),\n            formula_model_config[\"url\"],\n        )\n        # download model\n        if not params.use_onnx:\n            maybe_download(params.det_model_dir, det_url)\n            maybe_download(params.rec_model_dir, rec_url)\n            maybe_download(params.table_model_dir, table_url)\n            maybe_download(params.layout_model_dir, layout_url)\n            maybe_download(params.formula_model_dir, formula_url)\n\n        if params.rec_char_dict_path is None:\n            params.rec_char_dict_path = str(\n                Path(__file__).parent / rec_model_config[\"dict_path\"]\n            )\n        if params.table_char_dict_path is None:\n            params.table_char_dict_path = str(\n                Path(__file__).parent / table_model_config[\"dict_path\"]\n            )\n        if params.layout_dict_path is None:\n            params.layout_dict_path = str(\n                Path(__file__).parent / layout_model_config[\"dict_path\"]\n            )\n        if params.formula_char_dict_path is None:\n            params.formula_char_dict_path = str(\n                Path(__file__).parent / formula_model_config[\"dict_path\"]\n            )\n        logger.debug(params)\n        super().__init__(params)\n\n    def __call__(\n        self,\n        img,\n        return_ocr_result_in_table=False,\n        img_idx=0,\n        alpha_color=(255, 255, 255),\n    ):\n        \"\"\"\n        Performs structure analysis on the input image.\n\n        Args:\n            img (str or numpy.ndarray): The input image to perform structure analysis on.\n            return_ocr_result_in_table (bool, optional): Whether to return OCR results in table format. Defaults to False.\n            img_idx (int, optional): The index of the image. Defaults to 0.\n            alpha_color (tuple, optional): The alpha color for transparent images. Defaults to (255, 255, 255).\n\n        Returns:\n            list or dict: The structure analysis results.\n\n        \"\"\"\n        img, flag_gif, flag_pdf = check_img(img, alpha_color)\n        if isinstance(img, list) and flag_pdf:\n            res_list = []\n            for index, pdf_img in enumerate(img):\n                logger.info(\"processing {}/{} page:\".format(index + 1, len(img)))\n                res, _ = super().__call__(\n                    pdf_img, return_ocr_result_in_table, img_idx=index\n                )\n                res_list.append(res)\n            return res_list\n        res, _ = super().__call__(img, return_ocr_result_in_table, img_idx=img_idx)\n        return res\n\n\ndef main():\n    \"\"\"\n    Main function for running PaddleOCR or PPStructure.\n\n    This function takes command line arguments, processes the images, and performs OCR or structure analysis based on the specified type.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    # for cmd\n    args = parse_args(mMain=True)\n    logger.info(\"for usage help, please use `paddleocr --help`\")\n    image_dir = args.image_dir\n    if is_link(image_dir):\n        os.remove(\"tmp.jpg\") if os.path.exists(\"tmp.jpg\") else None\n        download_with_progressbar(image_dir, \"tmp.jpg\")\n        image_file_list = [\"tmp.jpg\"]\n    else:\n        image_file_list = get_image_file_list(args.image_dir)\n    if len(image_file_list) == 0:\n        logger.error(\"no images find in {}\".format(args.image_dir))\n        return\n    if args.type == \"ocr\":\n        engine = PaddleOCR(**(args.__dict__))\n    elif args.type == \"structure\":\n        engine = PPStructure(**(args.__dict__))\n    else:\n        raise NotImplementedError\n\n    for img_path in image_file_list:\n        img_name = os.path.basename(img_path).split(\".\")[0]\n        logger.info(\"{}{}{}\".format(\"*\" * 10, img_path, \"*\" * 10))\n        if args.type == \"ocr\":\n            result = engine.ocr(\n                img_path,\n                det=args.det,\n                rec=args.rec,\n                cls=args.use_angle_cls,\n                bin=args.binarize,\n                inv=args.invert,\n                alpha_color=args.alphacolor,\n            )\n            if result is not None:\n                lines = []\n                for res in result:\n                    if res is None:\n                        logger.warning(f\"No text found in image {img_path}\")\n                        continue\n                    for line in res:\n                        logger.info(line)\n                        lines.append(pprint.pformat(line) + \"\\n\")\n                if args.savefile:\n                    if os.path.exists(args.output) is False:\n                        os.mkdir(args.output)\n                    outfile = args.output + \"/\" + img_name + \".txt\"\n                    with open(outfile, \"w\", encoding=\"utf-8\") as f:\n                        f.writelines(lines)\n\n        elif args.type == \"structure\":\n            img, flag_gif, flag_pdf = check_and_read(img_path)\n            if not flag_gif and not flag_pdf:\n                img = cv2.imread(img_path)\n\n            if args.recovery and args.use_pdf2docx_api and flag_pdf:\n                try_import(\"pdf2docx\")\n                from pdf2docx.converter import Converter\n\n                docx_file = os.path.join(args.output, \"{}.docx\".format(img_name))\n                cv = Converter(img_path)\n                cv.convert(docx_file)\n                cv.close()\n                logger.info(\"docx save to {}\".format(docx_file))\n                continue\n\n            if not flag_pdf:\n                if img is None:\n                    logger.error(\"error in loading image:{}\".format(img_path))\n                    continue\n                img_paths = [[img_path, img]]\n            else:\n                img_paths = []\n                for index, pdf_img in enumerate(img):\n                    os.makedirs(os.path.join(args.output, img_name), exist_ok=True)\n                    pdf_img_path = os.path.join(\n                        args.output, img_name, img_name + \"_\" + str(index) + \".jpg\"\n                    )\n                    cv2.imwrite(pdf_img_path, pdf_img)\n                    img_paths.append([pdf_img_path, pdf_img])\n\n            all_res = []\n            for index, (new_img_path, img) in enumerate(img_paths):\n                logger.info(\"processing {}/{} page:\".format(index + 1, len(img_paths)))\n                result = engine(img, img_idx=index)\n                save_structure_res(result, args.output, img_name, index)\n\n                if args.recovery and result != []:\n                    h, w, _ = img.shape\n                    result_cp = deepcopy(result)\n                    result_sorted = sorted_layout_boxes(result_cp, w)\n                    all_res += result_sorted\n\n            if args.recovery and all_res != []:\n                try:\n                    convert_info_docx(img, all_res, args.output, img_name)\n                    if args.recovery_to_markdown:\n                        convert_info_markdown(all_res, args.output, img_name)\n                except Exception as ex:\n                    logger.error(\n                        \"error in layout recovery image:{}, err msg: {}\".format(\n                            img_name, ex\n                        )\n                    )\n                    continue\n\n            for item in all_res:\n                item.pop(\"img\")\n                item.pop(\"res\")\n                logger.info(item)\n            logger.info(\"result save to {}\".format(args.output))\n"
        },
        {
          "name": "ppocr",
          "type": "tree",
          "content": null
        },
        {
          "name": "ppstructure",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 1.9951171875,
          "content": "[build-system]\nrequires = [\"setuptools==72.1.0\", \"wheel\", \"setuptools_scm\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"paddleocr\"\n# After each version release, the version number needs to be incremented\ndynamic = [\"version\"]\ndescription = \"Awesome OCR toolkits based on PaddlePaddle(8.6M ultra-lightweight pre-trained model, support training and deployment among server, mobile, embedded and IoT devices)\"\nauthors = [\n    {name = \"PaddlePaddle\", email = \"Paddle-better@baidu.com\"},\n]\nmaintainers = [\n    {name = \"PaddlePaddle\", email = \"Paddle-better@baidu.com\"},\n]\nreadme = \"README.md\"\nrequires-python = \">=3.8\"\nkeywords = [\n    \"ocr\",\n    \"textdetection\",\n    \"textrecognition\",\n    \"paddleocr\",\n    \"crnn\",\n    \"east\",\n    \"star-net\",\n    \"rosetta\",\n    \"ocrlite\",\n    \"db\",\n    \"chineseocr\",\n    \"chinesetextdetection\",\n    \"chinesetextrecognition\",\n]\nlicense = {text = \"Apache License 2.0\"}\nclassifiers = [\n    \"Intended Audience :: Developers\",\n    \"Operating System :: OS Independent\",\n    \"Natural Language :: Chinese (Simplified)\",\n    \"Programming Language :: Python :: 3\",\n    \"Topic :: Utilities\",\n]\ndependencies = [\n    \"shapely\",\n    \"scikit-image\",\n    \"pyclipper\",\n    \"lmdb\",\n    \"tqdm\",\n    \"numpy\",\n    \"rapidfuzz\",\n    \"opencv-python\",\n    \"opencv-contrib-python\",\n    \"cython\",\n    \"Pillow\",\n    \"pyyaml\",\n    \"python-docx\",\n    \"beautifulsoup4\",\n    \"fonttools>=4.24.0\",\n    \"fire>=0.3.0\",\n    \"requests\",\n    \"albumentations==1.4.10\",\n    # to be compatible with albumentations\n    \"albucore==0.0.13\"\n]\n\n[project.urls]\nhomepage = \"https://github.com/PaddlePaddle/PaddleOCR\"\ndocumentation = \"https://github.com/PaddlePaddle/PaddleOCR/blob/main/README.md\"\nrepository = \"https://github.com/PaddlePaddle/PaddleOCR.git\"\nissues = \"https://github.com/PaddlePaddle/PaddleOCR/issues\"\n\n[project.scripts]\npaddleocr = \"paddleocr.paddleocr:main\"\n\n[tool.setuptools]\npackages = [\"paddleocr\"]\npackage-dir = { \"paddleocr\" = \"\" }\ninclude-package-data = true\n\n[tool.setuptools_scm]\nversion_scheme = 'release-branch-semver'\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.20703125,
          "content": "shapely\nscikit-image\npyclipper\nlmdb\ntqdm\nnumpy\nrapidfuzz\nopencv-python\nopencv-contrib-python\ncython\nPillow\npyyaml\nrequests\nalbumentations==1.4.10\n# to be compatible with albumentations\nalbucore==0.0.13\npackaging\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 0.634765625,
          "content": "# Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom setuptools import setup\n\n\nsetup()\n"
        },
        {
          "name": "test_tipc",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "train.sh",
          "type": "blob",
          "size": 0.177734375,
          "content": "# recommended paddle.__version__ == 2.0.0\npython3 -m paddle.distributed.launch --log_dir=./debug/ --gpus '0,1,2,3,4,5,6,7'  tools/train.py -c configs/rec/rec_mv3_none_bilstm_ctc.yml\n"
        }
      ]
    }
  ]
}