{
  "metadata": {
    "timestamp": 1736560760162,
    "page": 444,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "stamparm/maltrail",
      "stars": 6695,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1748046875,
          "content": "*.py text eol=lf\n*.txt text eol=lf\n*.csv text eol=lf\n*.js text eol=lf\n*.ccs text eol=lf\n*.css text eol=lf\n*.html text eol=lf\n*.conf text eol=lf\n*.md text eol=lf\n*.pem text eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.021484375,
          "content": "*.py[cod]\n*~\nPipfile*\n"
        },
        {
          "name": "CHANGELOG",
          "type": "blob",
          "size": 10.7587890625,
          "content": "# Copyright (c) 2014-2025 Maltrail developers (https://github.com/stamparm/maltrail/)\n# See the file 'LICENSE' for copying permission\n\n#################################################################\n#                 Maltrail Changelog File                       #\n#################################################################\n\n[+] Added functionality\n[-] Deleted functionality\n[!] Bug fixing\n[=] Minor update or changed functionality\n\n#################################################################\n\n\n\n- Version 0.77 -> 0.78 (Upcoming release)\n\n\n\n- Version 0.76 -> 0.77 (01 Jan 2025)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n- Version 0.75 -> 0.76 (01 Dec 2024)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n- Version 0.74 -> 0.75 (01 Nov 2024)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n- Version 0.73 -> 0.74 (01 Oct 2024)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n- Version 0.72 -> 0.73 (01 Sep 2024)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.71 -> 0.72 (01 Aug 2024)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.70 -> 0.71 (01 Jul 2024)\n\n[=] Maltrail docker container run is improved (Issue #19260)\n[=] php-inj detection is improved (Issue #19262)\n[=] Python 3.12 compability is improved (Issue #19257)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n- Version 0.69 -> 0.70 (01 Jun 2024)\n\n[=] cruzit feed URL changed (Issue #19253)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.68 -> 0.69 (01 May 2024)\n\n[+] Support of simpleton IPv6 bogon address handling was added\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n\n\n- Version 0.68 -> 0.69 (01 May 2024)\n\n[+] Support of simpleton IPv6 bogon address handling was added\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n- Version 0.67 -> 0.68 (01 Apr 2024)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.66 -> 0.67 (01 Mar 2024)\n\n[=] Handling usage of pcapy lib instead of pcapy-ng is improved (Issue #19242)\n[=] Fixed /server.py and /sensor.py restart in docker container (Issue #19243)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.65 -> 0.66 (01 Feb 2024)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.64 -> 0.65 (01 Jan 2024)\n\n[+] Customisable blacklists via BLACKLIST option in /maltrail.conf file (Issue #19230)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n\n- Version 0.63 -> 0.64 (01 Dec 2023)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n\n- Version 0.62 -> 0.63 (01 Nov 2023)\n\n[=] FAIL2BAN_REGEX and REMOTE_SEVERITY_REGEX options were updated to handle \"potential iot-malware download\" heur (Issue #19207)\n[=] Abuseipdb feed was updated (Issue #19208)\n[=] \"potential remote code execution\" heur for CVE-2016-0545 detection is updated (Issue #19210)\n[=] \"potential remote code execution\" heur is updated for MacOS process list tracking in HTTP POST-req (Issue #19214)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n\n- Version 0.61 -> 0.62 (01 Oct 2023)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n[=] Updates for mass_scanner and worst_asns trails\n\n\n\n\n- Version 0.60 -> 0.61 (01 Sep 2023)\n\n[!] Workaround to have working searx server (Issue #19199)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n- Version 0.59 -> 0.60 (01 Aug 2023)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.58 -> 0.59 (01 Jul 2023)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.57 -> 0.58 (01 Jun 2023)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.56 -> 0.57 (01 May 2023)\n\n[!] Fixed login page GUI issue for mobile devices (Issue #19153)\n[!] Fixed incorrect parsing of ViriBack feed (Issue #19154)\n[=] Added new descriptions in \"Specific detections\" Wiki chapter\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.55 -> 0.56 (01 Apr 2023)\n\n[=] Minor update for /feeds/emergingthreatsdns.py (Issue #19147)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.54 -> 0.55 (01 Mar 2023)\n\n[!] Fixed unauthenticated OS command injection vulnerability in http.py (Issue #19146)\n[=] Minor update for _process_packet func in sensor (Issue #19129)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n\n- Version 0.53 -> 0.54 (01 Feb 2023)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.52 -> 0.53 (01 Jan 2023)\n\n[-] Defunct 360-netlab feeds were deleted (Issue #19138)\n[=] \"potential data leakage\" heur is improved\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.51 -> 0.52 (01 Dec 2022)\n\n[=] \"potential iot-malware download\" heur is improved\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.50 -> 0.51 (01 Nov 2022)\n\n[+] New Wiki pages are added\n[!] Fixed deadlock of Docker output to stdout (Issue #19121)\n[!] Definition of network interfaces is improved (Issue #19123)\n[!] Fixed regex for /360bigviktor.py feed (Issue #19124)\n[!] Fixed syscalls handling (Issue #19125)\n[=] \"potential remote code execution\" heuristic is improved\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.49 -> 0.50 (01 Oct 2022)\n\n[=] \"potential remote code execution\" heur for CVE-2022-30190 detection is updated\n[=] \"Maltrail detection nuances\" wiki-page is updated\n[=] \"Trail classes\" wiki-page is updated\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n- Version 0.48 -> 0.49 (01 Sep 2022)\n\n[!] Fixed row rendering in UI (Issue #19109)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.47 -> 0.48 (01 Aug 2022)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.46 -> 0.47 (01 Jul 2022)\n\n[+] \"potential ssti injection\" heuristic is added (CVE-2022-26134)\n[=] \"potential data leak\" heuristic is improved\n[=] \"Trail-classes\" wiki page is updated\n[=] /requirements.txt file is updated (pcapy-ng)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.45 -> 0.46 (01 Jun 2022)\n\n[+] New Wiki page is added\n[=] \"potential remote code execution\" heuristic is improved (CVE-2022-1388)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.44 -> 0.45 (01 May 2022)\n\n[+] systemd-based realization for Maltrail sensor.py, server.py and ipset/iptables ban-list (dedicated repo) have added\n[+] New Wiki pages are added\n[=] \"potential remote code execution\" heuristic is improved (detection for Java-related RCE stuff)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.43 -> 0.44 (01 Apr 2022)\n\n[=] \"potential remote code execution\" heuristic is improved\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.42 -> 0.43 (01 Mar 2022)\n\n[=] \"potential remote code execution\" heuristic is improved\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.41 -> 0.42 (01 Feb 2022)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.40 -> 0.41 (01 Jan 2022)\n\n[+] \"potential remote code execution\" heuristic is extended for log4j/log4shell (CVE-2021-44228) vulnerability detection\n[+] \"generic_log4shell.txt\" and \"hacked_log4j.txt\" trails were added for log4j/log4shell (CVE-2021-44228) vulnerability static detection\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.39 -> 0.40 (01 Dec 2021)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.38 -> 0.39 (01 Nov 2021)\n\n[=] \"potential directory traversal\" heuristic is extended\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.37 -> 0.38 (03 Oct 2021)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.36 -> 0.37 (02 Sep 2021)\n\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.35 -> 0.36 (02 Aug 2021)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.34 -> 0.35 (04 Jul 2021)\n\n[+] Added the prototype of heur for potential web scanning attempts\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.33 -> 0.34 (10 Jun 2021)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.32 -> 0.33 (10 Jun 2021)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.31 -> 0.32 (10 May 2021)\n\n[!] Fixed PR_END_OF_FILE_ERROR bug, when using HTTPS for Maltrail's server (Issue #16217)\n[!] Fixed bug with TLSv1_2_METHOD (Issue #16250)\n[+] Added displaying real IP behind Cloudflare's one (Issue #20)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.30 -> 0.31 (01 Apr 2021)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.29 -> 0.30 (01 Mar 2021)\n\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n\n\n\n- Version 0.28 -> 0.29 (01 Feb 2021)\n\n[+] Two new UI features (hide threat and report false positive options)\n[+] Auto-refresh for Maltrail web-page (/?refresh=N, where N in seconds. Issue #624)\n[+] Maltrail demo pages are released: maltraildemo.github.io\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n[=] Potential DNS changer heur is improved\n[+] Implemented colorized console output\n[=] Minor style revamp and improved look and feel on mobile phones\n[-] Memory check is removed\n[+] Added info for proper Maltrail citation (/CITATION.cff)\n[=] Added starting and ending times to console output\n\n\n\n- Version 0.27 -> 0.28 (01 Jan 2021)\n\n[+] Implementing support for LOGSTASH_SERVER (Logs in JSON format)\n[+] Implementing REMOTE_SEVERITY_REGEX (Issue #13251)\n[=] Sensor is able to get started without server (Issue #6020)\n[=] Multiple updates and optimizations for regular static trails and the whitelist\n"
        },
        {
          "name": "CITATION.cff",
          "type": "blob",
          "size": 0.6943359375,
          "content": "# YAML 1.2\n---\ncff-version: \"1.1.0\"\nmessage: \"If you use this software, please cite it using these metadata.\"\ndoi: 10.23721/100/1503924\ntitle: \"Maltrail - Malicious traffic detection system\"\nauthors: \n  -\n    family-names: Stampar\n    given-names: Miroslav\n    orcid: \"https://orcid.org/0000-0002-2662-5469\"\n  -\n    family-names: Kasimov\n    given-names: Mikhail\nabstract: \"Maltrail is a malicious traffic detection system, utilizing publicly available (black)lists containing malicious and/or generally suspicious trails, along with static trails compiled from various AV reports and custom user defined lists\"\ndate-released: 2014-12-04\nrepository-code: \"https://github.com/stamparm/maltrail\"\nlicense: MIT\n...\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1044921875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014-2025 Maltrail developers (https://github.com/stamparm/maltrail/)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 43.9482421875,
          "content": "![Maltrail](https://i.imgur.com/3xjInOD.png)\n\n[![Python 2.6|2.7|3.x](https://img.shields.io/badge/python-2.6|2.7|3.x-yellow.svg)](https://www.python.org/) [![License](https://img.shields.io/badge/license-MIT-red.svg)](https://github.com/stamparm/maltrail#license) [![Malware families](https://img.shields.io/badge/malware_families-1494-orange.svg)](https://github.com/stamparm/maltrail/tree/master/trails/static/malware) [![Malware sinkholes](https://img.shields.io/badge/malware_sinkholes-1354-green.svg)](https://github.com/stamparm/maltrail/tree/master/trails/static/malware) [![Twitter](https://img.shields.io/badge/twitter-@maltrail-blue.svg)](https://twitter.com/maltrail)\n\n## Content\n\n- [Introduction](#introduction)\n- [Architecture](#architecture)\n- [Demo pages](#demo-pages)\n- [Requirements](#requirements)\n- [Quick start](#quick-start)\n- [Administrator's guide](#administrators-guide)\n - [Sensor](#sensor)\n - [Server](#server)\n- [User's guide](#users-guide)\n - [Reporting interface](#reporting-interface)\n- [Real-life cases](#real-life-cases)\n - [Mass scans](#mass-scans)\n - [Anonymous attackers](#anonymous-attackers)\n - [Service attackers](#service-attackers)\n - [Malware](#malware)\n - [Suspicious domain lookups](#suspicious-domain-lookups)\n - [Suspicious ipinfo requests](#suspicious-ipinfo-requests)\n - [Suspicious direct file downloads](#suspicious-direct-file-downloads)\n - [Suspicious HTTP requests](#suspicious-http-requests)\n - [Port scanning](#port-scanning)\n - [DNS resource exhaustion](#dns-resource-exhaustion)\n - [Data leakage](#data-leakage)\n - [False positives](#false-positives)\n- [Best practice(s)](#best-practices)\n- [License](#license)\n- [Sponsors](#sponsors)\n- [Developers](#developers)\n- [Presentations](#presentations)\n- [Publications](#publications)\n- [Blacklist](#blacklist)\n- [Thank you](#thank-you)\n- [Third-party integrations](#third-party-integrations)\n\n## Introduction\n\n**Maltrail** is a malicious traffic detection system, utilizing publicly available (black)lists containing malicious and/or generally suspicious trails, along with static trails compiled from various AV reports and custom user defined lists, where trail can be anything from domain name (e.g. `zvpprsensinaix.com` for [Banjori](http://www.johannesbader.ch/2015/02/the-dga-of-banjori/) malware), URL (e.g. `hXXp://109.162.38.120/harsh02.exe` for known malicious [executable](https://www.virustotal.com/en/file/61f56f71b0b04b36d3ef0c14bbbc0df431290d93592d5dd6e3fffcc583ec1e12/analysis/)), IP address (e.g. `185.130.5.231` for known attacker) or HTTP User-Agent header value (e.g. `sqlmap` for automatic SQL injection and database takeover tool). Also, it uses (optional) advanced heuristic mechanisms that can help in discovery of unknown threats (e.g. new malware).\n\n![Reporting tool](https://i.imgur.com/Sd9eqoa.png)\n\nThe following (black)lists (i.e. feeds) are being utilized:\n\n```\n360bigviktor, 360chinad, 360conficker, 360cryptolocker, 360gameover, \n360locky, 360necurs, 360suppobox, 360tofsee, 360virut, abuseipdb, alienvault, \natmos, badips, bitcoinnodes, blackbook, blocklist, botscout, \nbruteforceblocker, ciarmy, cobaltstrike, cruzit, cybercrimetracker, \ndataplane, dshieldip, emergingthreatsbot, emergingthreatscip, \nemergingthreatsdns, feodotrackerip, gpfcomics, greensnow, ipnoise,\nkriskinteldns, kriskintelip, malc0de, malwaredomainlistdns, malwaredomains,\nmaxmind, minerchk, myip, openphish, palevotracker, policeman, pony,\nproxylists, proxyrss, proxyspy, ransomwaretrackerdns, ransomwaretrackerip, \nransomwaretrackerurl, riproxies, rutgers, sblam, socksproxy, sslbl, \nsslproxies, talosintelligence, torproject, trickbot, turris, urlhaus, \nviriback, vxvault, zeustrackermonitor, zeustrackerurl, etc.\n```\n\nAs of static entries, the trails for the following malicious entities (e.g. malware C&Cs or sinkholes) have been manually included (from various AV reports and personal research):\n\n```\n1ms0rry, 404, 9002, aboc, absent, ab, acbackdoor, acridrain, activeagent, \nadrozek, advisorbot, adwind, adylkuzz, adzok, afrodita, agaadex, agenttesla, \naldibot, alina, allakore, almalocker, almashreq, alpha, alureon, amadey, \namavaldo, amend_miner, ammyyrat, android_acecard, android_actionspy, \nandroid_adrd, android_ahmythrat, android_alienspy, android_andichap, \nandroid_androrat, android_anubis, android_arspam, android_asacub, \nandroid_backflash, android_bankbot, android_bankun, android_basbanke, \nandroid_basebridge, android_besyria, android_blackrock, android_boxer, \nandroid_buhsam, android_busygasper, android_calibar, android_callerspy, \nandroid_camscanner, android_cerberus, android_chuli, android_circle, \nandroid_claco, android_clickfraud, android_cometbot, android_cookiethief, \nandroid_coolreaper, android_copycat, android_counterclank, android_cyberwurx, \nandroid_darkshades, android_dendoroid, android_dougalek, android_droidjack, \nandroid_droidkungfu, android_enesoluty, android_eventbot, android_ewalls, \nandroid_ewind, android_exodus, android_exprespam, android_fakeapp, \nandroid_fakebanco, android_fakedown, android_fakeinst, android_fakelog, \nandroid_fakemart, android_fakemrat, android_fakeneflic, android_fakesecsuit, \nandroid_fanta, android_feabme, android_flexispy, android_fobus, \nandroid_fraudbot, android_friend, android_frogonal, android_funkybot, \nandroid_gabas, android_geinimi, android_generic, android_geost, \nandroid_ghostpush, android_ginmaster, android_ginp, android_gmaster, \nandroid_gnews, android_godwon, android_golddream, android_goldencup, \nandroid_golfspy, android_gonesixty, android_goontact, android_gplayed, \nandroid_gustuff, android_gypte, android_henbox, android_hiddad, \nandroid_hydra, android_ibanking, android_joker, android_jsmshider, \nandroid_kbuster, android_kemoge, android_ligarat, android_lockdroid, \nandroid_lotoor, android_lovetrap, android_malbus, android_mandrake, \nandroid_maxit, android_mobok, android_mobstspy, android_monokle, \nandroid_notcompatible, android_oneclickfraud, android_opfake, \nandroid_ozotshielder, android_parcel, android_phonespy, android_pikspam, \nandroid_pjapps, android_qdplugin, android_raddex, android_ransomware, \nandroid_redalert, android_regon, android_remotecode, android_repane, \nandroid_riltok, android_roamingmantis, android_roidsec, android_rotexy, \nandroid_samsapo, android_sandrorat, android_selfmite, android_shadowvoice, \nandroid_shopper, android_simbad, android_simplocker, android_skullkey, \nandroid_sndapps, android_spynote, android_spytekcell, android_stels, \nandroid_svpeng, android_swanalitics, android_teelog, android_telerat, \nandroid_tetus, android_thiefbot, android_tonclank, android_torec, \nandroid_triada, android_uracto, android_usbcleaver, android_viceleaker, \nandroid_vmvol, android_walkinwat, android_windseeker, android_wirex, \nandroid_wolfrat, android_xavirad, android_xbot007, android_xerxes, \nandroid_xhelper, android_xploitspy, android_z3core, android_zertsecurity, \nandroid_ztorg, andromeda, antefrigus, antibot, anubis, anuna, apocalypse, \napt_12, apt_17, apt_18, apt_23, apt_27, apt_30, apt_33, apt_37, apt_38, \napt_aridviper, apt_babar, apt_bahamut, etc.\n```\n\n## Architecture\n\nMaltrail is based on the **Traffic** -&gt; **Sensor** &lt;-&gt; **Server** &lt;-&gt; **Client** architecture. **Sensor**(s) is a standalone component running on the monitoring node (e.g. Linux platform connected passively to the SPAN/mirroring port or transparently inline on a Linux bridge) or at the standalone machine (e.g. Honeypot) where it \"monitors\" the passing **Traffic** for blacklisted items/trails (i.e. domain names, URLs and/or IPs). In case of a positive match, it sends the event details to the (central) **Server** where they are being stored inside the appropriate logging directory (i.e. `LOG_DIR` described in the *Configuration* section). If **Sensor** is being run on the same machine as **Server** (default configuration), logs are stored directly into the local logging directory. Otherwise, they are being sent via UDP messages to the remote server (i.e. `LOG_SERVER` described in the *Configuration* section).\n\n![Architecture diagram](https://i.imgur.com/2IP9Mh2.png)\n\n**Server**'s primary role is to store the event details and provide back-end support for the reporting web application. In default configuration, server and sensor will run on the same machine. So, to prevent potential disruptions in sensor activities, the front-end reporting part is based on the [\"Fat client\"](https://en.wikipedia.org/wiki/Fat_client) architecture (i.e. all data post-processing is being done inside the client's web browser instance). Events (i.e. log entries) for the chosen (24h) period are transferred to the **Client**, where the reporting web application is solely responsible for the presentation part. Data is sent toward the client in compressed chunks, where they are processed sequentially. The final report is created in a highly condensed form, practically allowing presentation of virtually unlimited number of events.\n\nNote: **Server** component can be skipped altogether, and just use the standalone **Sensor**. In such case, all events would be stored in the local logging directory, while the log entries could be examined either manually or by some CSV reading application.\n\n## Demo pages\n\nFully functional demo pages with collected real-life threats can be found [here](https://maltraildemo.github.io/).\n\n## Requirements\n\nTo run Maltrail properly, [Python](http://www.python.org/download/) **2.6**, **2.7** or **3.x** is required on \\*nix/BSD system, together with installed [pcapy-ng](https://pypi.org/project/pcapy-ng/) package.\n\n**NOTE:** Using of ```pcapy``` lib instead of ```pcapy-ng``` can lead to incorrect work of Maltrail, especially on **Python 3.x** environments. [Examples](https://github.com/stamparm/maltrail/issues?q=label%3Apcapy-ng-related+is%3Aclosed).\n\n- **Sensor** component requires at least 1GB of RAM to run in single-process mode or more if run in multiprocessing mode, depending on the value used for option `CAPTURE_BUFFER`. Additionally, **Sensor** component (in general case) requires administrative/root privileges.\n\n- **Server** component does not have any special requirements.\n\n## Quick start\n\nThe following set of commands should get your Maltrail **Sensor** up and running (out of the box with default settings and monitoring interface \"any\"):\n\n- For **Ubuntu/Debian**\n\n```sh\nsudo apt-get install git python3 python3-dev python3-pip python-is-python3 libpcap-dev build-essential procps schedtool\nsudo pip3 install pcapy-ng\ngit clone --depth 1 https://github.com/stamparm/maltrail.git\ncd maltrail\nsudo python3 sensor.py\n```\n\n- For **SUSE/openSUSE**\n\n```sh\nsudo zypper install gcc gcc-c++ git libpcap-devel python3-devel python3-pip procps schedtool\nsudo pip3 install pcapy-ng\ngit clone --depth 1 https://github.com/stamparm/maltrail.git\ncd maltrail\nsudo python3 sensor.py\n```\n\n- For **Docker** environment instructions can be found [here](docker).\n\n![Sensor](https://i.imgur.com/E9tt2ek.png)\n\nTo start the (optional) **Server** on same machine, open a new terminal and execute the following:\n\n```sh\n[[ -d maltrail ]] || git clone --depth 1 https://github.com/stamparm/maltrail.git\ncd maltrail\npython server.py\n```\n\n![Server](https://i.imgur.com/loGW6GA.png)\n\nTo test that everything is up and running execute the following:\n\n```sh\nping -c 1 136.161.101.53\ncat /var/log/maltrail/$(date +\"%Y-%m-%d\").log\n```\n\n![Test](https://i.imgur.com/NYJg6Kl.png)\n\nAlso, to test the capturing of DNS traffic you can try the following:\n\n```sh\nnslookup morphed.ru\ncat /var/log/maltrail/$(date +\"%Y-%m-%d\").log\n```\n\n![Test2](https://i.imgur.com/62oafEe.png)\n\nTo stop **Sensor** and **Server** instances (if running in background) execute the following:\n\n```sh\nsudo pkill -f sensor.py\npkill -f server.py\n```\n\nAccess the reporting interface (i.e. **Client**) by visiting the http://127.0.0.1:8338 (default credentials: `admin:changeme!`) from your web browser:\n\n![Reporting interface](https://i.imgur.com/VAsq8cs.png)\n\n## Administrator's guide\n\n### Sensor\n\nSensor's configuration can be found inside the `maltrail.conf` file's section `[Sensor]`:\n\n![Sensor's configuration](https://i.imgur.com/8yZKH14.png)\n\nIf option `USE_MULTIPROCESSING` is set to `true` then all CPU cores will be used. One core will be used only for packet capture (with appropriate affinity, IO priority and nice level settings), while other cores will be used for packet processing. Otherwise, everything will be run on a single core. Option `USE_FEED_UPDATES` can be used to turn off the trail updates from feeds altogether (and just use the provided static ones). Option `UPDATE_PERIOD` contains the number of seconds between each automatic trails update (Note: default value is set to `86400` (i.e. one day)) by using definitions inside the `trails` directory (Note: both **Sensor** and **Server** take care of the trails update). Option `CUSTOM_TRAILS_DIR` can be used by user to provide location of directory containing the custom trails (`*.txt`) files.\n\nOption `USE_HEURISTICS` turns on heuristic mechanisms (e.g. `long domain name (suspicious)`, `excessive no such domain name (suspicious)`, `direct .exe download (suspicious)`, etc.), potentially introducing false positives. Option `CAPTURE_BUFFER` presents a total memory (in bytes of percentage of total physical memory) to be used in case of multiprocessing mode for storing packet capture in a ring buffer for further processing by non-capturing processes. Option `MONITOR_INTERFACE` should contain the name of the capturing interface. Use value `any` to capture from all interfaces (if OS supports this). Option `CAPTURE_FILTER` should contain the network capture (`tcpdump`) filter to skip the uninteresting packets and ease the capturing process. Option `SENSOR_NAME` contains the name that should be appearing inside the events `sensor_name` value, so the event from one sensor could be distinguished from the other. If option `LOG_SERVER` is set, then all events are being sent remotely to the **Server**, otherwise they are stored directly into the logging directory set with option `LOG_DIR`, which can be found inside the `maltrail.conf` file's section `[All]`. In case that the option `UPDATE_SERVER` is set, then all the trails are being pulled from the given location, otherwise they are being updated from trails definitions located inside the installation itself.\n\nOptions `SYSLOG_SERVER` and/or `LOGSTASH_SERVER` can be used to send sensor events (i.e. log data) to non-Maltrail servers. In case of `SYSLOG_SERVER`, event data will be sent in CEF (*Common Event Format*) format to UDP (e.g. Syslog) service listening at the given address (e.g. `192.168.2.107:514`), while in case of `LOGSTASH_SERVER` event data will be sent in JSON format to UDP (e.g. Logstash) service listening at the given address (e.g. `192.168.2.107:5000`).\n\nExample of event data being sent over UDP is as follows:\n\n- For option `SYSLOG_SERVER` (Note: `LogSeverity` values are 0 (for low), 1 (for medium) and 2 (for high)):\n\n```Dec 24 15:05:55 beast CEF:0|Maltrail|sensor|0.27.68|2020-12-24|andromeda (malware)|2|src=192.168.5.137 spt=60453 dst=8.8.8.8 dpt=53 trail=morphed.ru ref=(static)```\n\n- For option `LOGSTASH_SERVER`:\n\n```{\"timestamp\": 1608818692, \"sensor\": \"beast\", \"severity\": \"high\", \"src_ip\": \"192.168.5.137\", \"src_port\": 48949, \"dst_ip\": \"8.8.8.8\", \"dst_port\": 53, \"proto\": \"UDP\", \"type\": \"DNS\", \"trail\": \"morphed.ru\", \"info\": \"andromeda (malware)\", \"reference\": \"(static)\"}```\n\nWhen running the sensor (e.g. `sudo python sensor.py`) for the first time and/or after a longer period of non-running, it will automatically update the trails from trail definitions (Note: stored inside the `trails` directory). After the initialization, it will start monitoring the configured interface (option `MONITOR_INTERFACE` inside the `maltrail.conf`) and write the events to either the configured log directory (option `LOG_DIR` inside the `maltrail.conf` file's section `[All]`) or send them remotely to the logging/reporting **Server** (option `LOG_SERVER`).\n\n![Sensor run](https://i.imgur.com/A0qROp8.png)\n\nDetected events are stored inside the **Server**'s logging directory (i.e. option `LOG_DIR` inside the `maltrail.conf` file's section `[All]`) in easy-to-read CSV format (Note: whitespace ' ' is used as a delimiter) as single line entries consisting of: `time` `sensor` `src_ip` `src_port` `dst_ip` `dst_port` `proto` `trail_type` `trail` `trail_info` `reference` (e.g. `\"2015-10-19 15:48:41.152513\" beast 192.168.5.33 32985 8.8.8.8 53 UDP DNS 0000mps.webpreview.dsl.net malicious siteinspector.comodo.com`):\n\n![Sample log](https://i.imgur.com/RycgVru.png)\n\n### Server\n\nServer's configuration can be found inside the `maltrail.conf` section `[Server]`:\n\n![Server's configuration](https://i.imgur.com/TiUpLX8.png)\n\nOption `HTTP_ADDRESS` contains the web server's listening address (Note: use `0.0.0.0` to listen on all interfaces). Option `HTTP_PORT` contains the web server's listening port. Default listening port is set to `8338`. If option `USE_SSL` is set to `true` then `SSL/TLS` will be used for accessing the web server (e.g. `https://192.168.6.10:8338/`). In that case, option `SSL_PEM` should be pointing to the server's private/cert PEM file. \n\nSubsection `USERS` contains user's configuration settings. Each user entry consists of the `username:sha256(password):UID:filter_netmask(s)`. Value `UID` represents the unique user identifier, where it is recommended to use values lower than 1000 for administrative accounts, while higher value for non-administrative accounts. The part `filter_netmask(s)` represents the comma-delimited hard filter(s) that can be used to filter the shown events depending on the user account(s). Default entry is as follows:\n\n![Configuration users](https://i.imgur.com/PYwsZkn.png)\n\nOption `UDP_ADDRESS` contains the server's log collecting listening address (Note: use `0.0.0.0` to listen on all interfaces), while option `UDP_PORT` contains listening port value. If turned on, when used in combination with option `LOG_SERVER`, it can be used for distinct (multiple) **Sensor** <-> **Server** architecture.\n\nOption `FAIL2BAN_REGEX` contains the regular expression (e.g. `attacker|reputation|potential[^\"]*(web scan|directory traversal|injection|remote code|iot-malware download|spammer|mass scanner`) to be used in `/fail2ban` web calls for extraction of today's attacker source IPs. This allows the usage of IP blocking mechanisms (e.g. `fail2ban`, `iptables` or `ipset`) by periodic pulling of blacklisted IP addresses from remote location. Example usage would be the following script (e.g. run as a `root` cronjob on a minute basis):\n\n```sh\n#!/bin/bash\nipset -q flush maltrail\nipset -q create maltrail hash:net\nfor ip in $(curl http://127.0.0.1:8338/fail2ban 2>/dev/null | grep -P '^[0-9.]+$'); do ipset add maltrail $ip; done\niptables -I INPUT -m set --match-set maltrail src -j DROP\n```\n\nOption `BLACKLIST` allows to build regular expressions to apply on one field. For each rule, the syntax is : `<field> <control> <regexp>` where :\n* `field` indicates the field to compage, it can be: `src_ip`,`src_port`,`dst_ip`,`dst_port`,`protocol`,`type`,`trail` or `filter`.\n* `control` can be either `~` for *matches* or `!~` for *doesn't match*\n* `regexp` is the regular expression to apply to the field.\nChain another rule with the `and` keyword (the `or` keyword is not supported, just add a line for this).\n\nYou can use the keyword `BLACKLIST` alone or add a name : `BLACKLIST_NAME`. In the latter case, the url will be : `/blacklist/name`\n\nFor example, the following will build an out blacklist for all traffic from another source than `192.168.0.0/16` to destination port `SSH` or matching the filters `scan` or `known attacker`\n```\nBLACKLIST_OUT\n    src_ip !~ ^192.168. and dst_port ~ ^22$\n    src_ip !~ ^192.168. and filter ~ scan\n    src_ip !~ ^192.168. and filter ~ known attacker\n\nBLACKLIST_IN\n    src_ip ~ ^192.168. and filter ~ malware\n```\nThe way to build ipset blacklist is the same (see above) excepted that URLs will be `/blacklist/in` and `/blacklist/out` in our example.\n\nSame as for **Sensor**, when running the **Server** (e.g. `python server.py`) for the first time and/or after a longer period of non-running, if option `USE_SERVER_UPDATE_TRAILS` is set to `true`, it will automatically update the trails from trail definitions (Note: stored inside the `trails` directory). Its basic function is to store the log entries inside the logging directory (i.e. option `LOG_DIR` inside the `maltrail.conf` file's section `[All]`) and provide the web reporting interface for presenting those same entries to the end-user (Note: there is no need install the 3rd party web server packages like Apache):\n\n![Server run](https://i.imgur.com/GHdGPw7.png)\n\n## User's guide\n\n### Reporting interface\n\nWhen entering the **Server**'s reporting interface (i.e. via the address defined by options `HTTP_ADDRESS` and `HTTP_PORT`), user will be presented with the following authentication dialog. User has to enter the proper credentials that have been set by the server's administrator inside the configuration file `maltrail.conf` (Note: default credentials are `admin:changeme!`):\n\n![User login](https://i.imgur.com/WVpASAI.png)\n\nOnce inside, user will be presented with the following reporting interface:\n\n![Reporting interface](https://i.imgur.com/PZY8JEC.png)\n\nThe top part holds a sliding timeline (Note: activated after clicking the current date label and/or the calendar icon ![Calendar icon](https://i.imgur.com/NfNore9.png)) where user can select logs for past events (Note: mouse over event will trigger display of tooltip with approximate number of events for current date). Dates are grouped by months, where 4 month period of data are displayed inside the widget itself. However, by using the provided slider (i.e. ![Timeline slider](https://i.imgur.com/SNGVSaP.png)) user can easily access events from previous months.\n\n![Timeline](https://i.imgur.com/RnIROcn.png)\n\nOnce clicking the date, all events for that particular date should be loaded and represented by the client's web browser. Depending on number of events and the network connection speed, loading and display of logged events could take from couple of seconds, up to several minutes (e.g. 100,000 events takes around 5 seconds in total). For the whole processing time, animated loader will be displayed across the disabled user interface:\n\n![Loader](https://i.imgur.com/oX7Rtjo.png)\n\nMiddle part holds a summary of displayed events. `Events` box represents total number of events in a selected 24-hour period, where red line represents IP-based events, blue line represents DNS-based events and yellow line represents URL-based events. `Sources` box represents number of events per top sources in form of a stacked column chart, with total number of sources on top. `Threats` box represents percentage of top threats in form of a pie chart (Note: gray area holds all threats having each &lt;1% in total events), with total number of threats on top. `Trails` box represents percentage of top trails in form of a pie chart (Note: gray area holds all trails having each &lt;1% in total events), with total number of trails on top. Each of those boxes are active, hence the click on one of those will result with a more detailed graph.\n\n![Summary](https://i.imgur.com/5NFbqCb.png)\n\nBottom part holds a condensed representation of logged events in form of a paginated table. Each entry holds details for a single threat (Note: uniquely identified by a pair `(src_ip, trail)` or `(dst_ip, trail)` if the `src_ip` is the same as the `trail` as in case of attacks coming from the outside):\n\n![Single threat](https://i.imgur.com/IxPwKKZ.png)\n\nColumn `threat` holds threat's unique ID (e.g. `85fdb08d`) and color (Note: extruded from the threat's ID), `sensor` holds sensor name(s) where the event has been triggered (e.g. `blitvenica`), `events` holds total number of events for a current threat, `severity` holds evaluated severity of threat (Note: calculated based on values in `info` and `reference` columns, prioritizing malware generated traffic), `first_seen` holds time of first event in a selected (24h) period (e.g. `06th 08:21:54`), `last_seen` holds time of last event in a selected (24h) period (e.g. `06th 15:21:23`), `sparkline` holds a small sparkline graph representing threat's activity in selected period, `src_ip` holds source IP(s) of a threat (e.g. `99.102.41.102`), `src_port` holds source port(s) (e.g. `44556, 44589, 44601`), `dst_ip` holds destination IP(s) (e.g. `213.202.100.28`), `dst_port` holds destination port(s) (e.g. `80 (HTTP)`), `proto` holds protocol(s), (e.g. `TCP`), `trail` holds a blacklisted (or heuristic) entry that triggered the event(s), `info` holds more information about the threat/trail (e.g. `known attacker` for known attacker's IP addresses or `ipinfo` for known IP information service commonly used by malware during a startup), `reference` holds a source of the blacklisted entry (e.g. `(static)` for static trails or `myip.ms` for a dynamic feed retrieved from that same source) and `tags` holds user defined tags for a given trail (e.g. `APT28`).\n\nWhen moving mouse over `src_ip` and `dst_ip` table entries, information tooltip is being displayed with detailed reverse DNS and WHOIS information (Note: [RIPE](http://www.ripe.net/) is the information provider):\n\n![On mouse over IP](https://i.imgur.com/BgKchAX.png)\n\nEvent details (e.g. `src_port`, `dst_port`, `proto`, etc.) that differ inside same threat entry are condensed in form of a bubble icon (i.e. ![Ellipsis](https://raw.githubusercontent.com/stamparm/maltrail/master/html/images/ellipsis.png)). This is performed to get an usable reporting interface with as less rows as possible. Moving mouse over such icon will result in a display of an information tooltip with all items held (e.g. all port numbers being scanned by `attacker`):\n\n![On mouse over bubble](https://i.imgur.com/BfYT2u7.png)\n\nClicking on one such icon will open a new dialog containing all stored items (Note: in their uncondensed form) ready to be Copy-Paste(d) for further analysis:\n\n![Ctrl-C dialog](https://i.imgur.com/9pgMpiR.png)\n\nWhen hovering mouse pointer over the threat's trail for couple of seconds it will result in a frame consisted of results using the trail as a search term performed against ~~[Search Encrypt](https://www.searchencrypt.com/)~~ [searX](https://searx.nixnet.services/) search engine. In lots of cases, this provides basic information about the threat itself, eliminating the need for user to do the manual search for it. In upper right corner of the opened frame window there are two extra buttons. By clicking the first one (i.e. ![New tab icon](https://raw.githubusercontent.com/stamparm/maltrail/master/html/images/newtab.png)), the resulting frame will be opened inside the new browser's tab (or window), while by clicking the second one (i.e. ![Close icon](https://raw.githubusercontent.com/stamparm/maltrail/master/html/images/close.png)) will immediately close the frame (Note: the same action is achieved by moving the mouse pointer outside the frame borders):\n\n![On mouse over trail](https://i.imgur.com/ZxnHn1N.png)\n\nFor each threat there is a column `tag` that can be filled with arbitrary \"tags\" to closely describe all threats sharing the same trail. Also, it is a great way to describe threats individually, so all threats sharing the same tag (e.g. `yahoo`) could be grouped out later:\n\n![Tags](https://i.imgur.com/u5Z4752.png)\n\n### Real-life cases\n\nIn the following section some of the \"usual suspects\" scenarios will be described through the real-life cases.\n\n#### Mass scans\n\nMass scans is a fairly common phenomenon where individuals and/or organizations give themselves a right to scan the whole 0.0.0.0/0 IP range (i.e. whole Internet) on a daily basis, with disclaimer where they say that if you don't like it then you should contact them privately to be skipped from future scans. \n\n![Shodan FileZilla results](https://i.imgur.com/nwOwLP9.png)\n\nTo make stuff worse, organizations as [Shodan](https://www.shodan.io/) and [ZoomEye](http://www.zoomeye.org) give all results freely available (to other potential attackers) through their search engine. In the following screenshots you'll see details of Shodan scans in one single day.\n\nHere is a reverse DNS and WHOIS lookup of the \"attacker\"'s address:\n\n![Shodan 1](https://i.imgur.com/LQ6Vu00.png)\n\nWhen hovering mouse pointer over the `trail` column's content (IP address), you'll be presented with the search results from [searX](https://searx.nixnet.services/) where you'll be able to find more information about the \"attacker\":\n\n![Shodan 2](https://i.imgur.com/vIzB8bA.png)\n\nIn the `dst_ip` column, if you have a large organization, you'll be presented with large list of scanned IP addresses:\n![Shodan 3](https://i.imgur.com/EhAtXs7.png)\n\nIn the `dst_port` column you'll be able to see all ports that have been scanned by such mass scans:\n\n![Shodan 4](https://i.imgur.com/Wk8Xjhq.png)\n\nIn other similar situations you'll see the same behaviour, coming from blacklisted individual attacker(s) (in this case by [cinsscore.com](http://cinsscore.com/)):\n\n![Known attacker](https://i.imgur.com/wSOOnQM.png)\n\nOne more common behaviour is scanning of the whole 0.0.0.0/0 IP range (i.e. Internet) in search for one particular port (e.g. TCP port 443 when [Heartbleed](http://heartbleed.com/) has been found). In the following screenshot you'll find one such case for previously blacklisted attacker(s) (in this case by [alienvault.com](http://alienvault.com) and two other blacklists) targeting the UDP port 5060 (i.e. SIP) in search for [misconfigured VoIP devices](https://isc.sans.edu/diary/Targeting+VoIP%3A+Increase+in+SIP+Connections+on+UDP+port+5060/9193):\n\n![SIP scan](https://i.imgur.com/dkJfU86.png)\n\n#### Anonymous attackers\n\nTo spot the potential attackers hidden behind the [Tor](https://www.torproject.org/) anonymity network, Maltrail utilizes publicly available lists of Tor exit nodes. In the following screenshot you'll see a case where potential attacker has been utilizing the Tor network to access the web target (over HTTP) in our organization's range in suspicious way (total 171 connection requests in 10 minutes):\n\n![Tor attacker](https://i.imgur.com/dXF8r2K.png)\n\n#### Service attackers\n\nFairly similar case to the previous one is when previously blacklisted attacker tries to access particular (e.g. non-HTTP(s)) service in our organization's range in rather suspicious way (i.e. total 1513 connection attempts in less than 15 minutes):\n\n![RDP brute force](https://i.imgur.com/Oo2adCf.png)\n\nIf we enter the `ssh attacker` to the `Filter` field, we'll be able to see all similar occurrences for that day, but in this case for port 22 (i.e. SSH):\n\n![SSH attackers filter](https://i.imgur.com/oCv42jd.png)\n\n#### Malware\n\nIn case of connection attempts coming from infected computers inside our organization toward already known C&C servers, you'll be able to find threats similar to the following (in this case [Beebone](https://www.microsoft.com/security/portal/threat/encyclopedia/entry.aspx?Name=Win32/Beebone)):\n\n![beebone malware](https://i.imgur.com/GBLWISo.png)\n\nIn case of DNS requests containing known [DGA](https://en.wikipedia.org/wiki/Domain_generation_algorithm) domain names, threat will be shown like (in this case [Necurs](https://www.microsoft.com/security/portal/threat/encyclopedia/entry.aspx?Name=Win32/Necurs)):\n\n![necurs malware](https://i.imgur.com/8tWj2pm.png)\n\nIn the following case file downloads from blacklisted (in this case by [malwarepatrol.net](https://malwarepatrol.net/)) URL(s) have occurred:\n\n![malware download](https://i.imgur.com/g2NH7sT.png)\n\nIf we enter the particular malware name (in this case [Ramnit](https://www.microsoft.com/security/portal/threat/encyclopedia/entry.aspx?Name=Win32%2fRamnit)) into the `Filter` field, only threats that are known to be linked to this malware will be filtered in (showing you all affected internal computers):\n\n![ramnit malware](https://i.imgur.com/zcoPnZk.png)\n\nMore generally, if we enter the `malware` into the `Filter` field, all threats that have been found by malware(-related) trails (e.g. `IP` addresses) will be filtered in:\n\n![malware filter](https://i.imgur.com/gVYAfSU.png)\n\n#### Suspicious domain lookups\n\nMaltrail uses the static list of TLD [domains](https://github.com/stamparm/maltrail/blob/master/trails/static/suspicious/domain.txt) that are known to be commonly involved in suspicious activities. Most such [TLD](https://en.wikipedia.org/wiki/Top-level_domain) domains are coming from free domain registrars (e.g. [Freenom](http://www.freenom.com)), hence they should be under greater scrutiny. In the following screenshot we can find a case where one such TLD domain `.cm` has been used by unknown malware using the [DGA](https://en.wikipedia.org/wiki/Domain_generation_algorithm) algorithm to contact its [C&C](https://www.trendmicro.com/vinfo/us/security/definition/command-and-control-%28c-c%29-server) server(s):\n\n![cm DGA](https://i.imgur.com/JTGdtJ0.png)\n\nThere are also cases when perfectly valid TLD domains (e.g. `.ru`) are used for suspicious activities, such in this case (e.g. `long domain name (suspicious)`) where the domains are obviously DGA generated by unknown malware:\n\n![Suspicious long domains](https://i.imgur.com/EJOS5Qb.png)\n\nMaltrail uses static [list](https://github.com/stamparm/maltrail/blob/master/trails/static/suspicious/dynamic_domain.txt) of so-called \"dynamic domains\" that are often used in suspicious activities (e.g. for malware C&C servers that often change the destination's IP addresses):\n\n![Suspicious dynamic domains](https://i.imgur.com/1WVLMf9.png)\n\nAlso, Maltrail uses static [list](https://github.com/stamparm/maltrail/blob/master/trails/static/suspicious/onion.txt) of \"onion\"-related domains that are also often used in suspicious activities (e.g. malware contacting C&amp;C servers by using Tor2Web service(s)):\n\n![Suspicious onion](https://i.imgur.com/QdoAY0w.png)\n\nIn case of old and/or obsolete malware that sits undetected on organization's infected internal computers, there is often a \"phenomenon\" where malware continuously tries to contact the long dead C&amp;C server's domain without any DNS resolution. Hence, those kind of (potential) threats will be marked as `excessive no such domain (suspicious)`:\n\n![Excessive no such domain name](https://i.imgur.com/KPwNOM8.png)\n\nIn case that one trail is responsible for too many threats (e.g. in case of fake source IPs like in DNS amplification attacks), all similar threats will be grouped under a single `flood` threat (Note: threat's ID will be marked with suffix `F0`), like in the following example:\n\n![Flood](https://i.imgur.com/ZtpMR3d.png)\n\n#### Suspicious ipinfo requests\n\nLots of malware uses some kind of `ipinfo` service (e.g. [ipinfo.io](http://ipinfo.io)) to find out the victim's Internet IP address. In case of regular and especially in out-of-office hours, those kind of requests should be closely monitored, like in the following example:\n\n![suspicious ipinfo](https://i.imgur.com/3THOoWW.png)\n\nBy using filter `ipinfo` all potentially infected computers in our organization's range can be listed that share this kind of suspicious behaviour:\n\n![ipinfo filter](https://i.imgur.com/6SMN0at.png)\n\n#### Suspicious direct file downloads\n\nMaltrail tracks all suspicious direct file download attempts (e.g. `.apk`, `.bin`, `.class`, `.chm`, `.dll`, `.egg`, `.exe`, `.hta`, `.hwp`, `.lnk`, `.ps1`, `.scr`, `.sct`, `.wbk` and `.xpi` file extensions). This can trigger lots of false positives, but eventually could help in reconstruction of the chain of infection (Note: legitimate service providers, like Google, usually use encrypted HTTPS to perform this kind of downloads):\n\n![Direct .exe download](https://i.imgur.com/jr5BS1h.png)\n\n#### Suspicious HTTP requests\n\nIn case of suspicious requests coming from outer web application security scanners (e.g. searching for SQLi, XSS, LFI, etc. vulnerabilities) and/or the internal user malicious attempts toward unknown web sites, threats like the following could be found (real case of attackers trying to exploit Joomla! CMS CVE-2015-7297, CVE-2015-7857, and CVE-2015-7858 [vulnerabilities](https://blog.sucuri.net/2015/10/joomla-3-4-5-released-fixing-a-serious-sql-injection-vulnerability.html)):\n\n![SQLi com_contenthistory](https://i.imgur.com/pZuGXpr.png)\n\nIn following example, web application vulnerability scan has been marked as \"suspicious\":\n\n![Vulnerability scan](https://i.imgur.com/QzcaEsG.png)\n\nIf we click on the bubble icon (i.e. ![Ellipsis](https://raw.githubusercontent.com/stamparm/maltrail/master/html/images/ellipsis.png)) for details and copy paste the whole content to a textual file, we'll be able to see all suspicious HTTP requests:\n\n![Vulnerability scan requests](https://i.imgur.com/XY9K01o.png)\n\nIn the following screenshot, a run of popular SQLi vulnerability tool [sqlmap](https://github.com/sqlmapproject/sqlmap/) can be found inside our logs:\n\n![sqlmap scan requests](https://i.imgur.com/mHZmM7t.png)\n\n#### Port scanning\n\nIn case of too many connection attempts toward considerable amount of different TCP ports, Maltrail will warn about the potential port scanning, as a result of its heuristic mechanism detection. It the following screenshot such warning(s) can be found for a run of popular port scanning tool [nmap](https://nmap.org/):\n\n![nmap scan](https://i.imgur.com/VS7L2A3.png)\n\n#### DNS resource exhaustion\n\nOne popular DDoS attack against the web server(s) infrastructure is the resource exhaustion of its (main) DNS server by making valid DNS recursion queries for (pseudo)random subdomain names (e.g. `abpdrsguvjkyz.www.dedeni.com`):\n\n![DNS resource exhaustion](https://i.imgur.com/RujhnKW.png)\n\n#### Data leakage\n\nMiscellaneous programs (especially mobile-based) present malware(-like) behaviour where they send potentially sensitive data to the remote beacon posts. Maltrail will try to capture such behaviour like in the following example:\n\n![Data leakage](https://i.imgur.com/6zt2gXg.png)\n\n#### False positives\n\nLike in all other security solutions, Maltrail is prone to \"[false positives](https://en.wikipedia.org/wiki/False_positives_and_false_negatives)\". In those kind of cases, Maltrail will (especially in case of `suspicious` threats) record a regular user's behaviour and mark it as malicious and/or suspicious. In the following example it can be seen that a blacklist feed provider `blocklist.de` marked regular Google server as `attacker`(s), resulting with the following threat:\n\n![Google false positive 1](https://i.imgur.com/HFvCNNK.png)\n\nBy hovering mouse over the trail, frame with results from [searX](https://searx.nixnet.services/) search show that this is (most probably) a regular Google's server:\n\n![Google false positive 2](https://i.imgur.com/i3oydv6.png)\n\nAs another example, access to regular `.work` domains (popular TLD for malicious purposes) resulted with the following threat:\n\n![Suspicious domain false positive](https://i.imgur.com/Msq8HgH.png)\n\nNevertheless, administrator(s) should invest some extra time and check (with other means) whether the \"suspicious\" means malicious or not, as in the following example:\n\n![Suspicious .ws](https://i.imgur.com/bOLmXUE.png)\n\n## Best practice(s)\n\n1. Install Maltrail:\n\n- On **Ubuntu/Debian**\n\n    ```sh\n    sudo apt-get install git python3 python3-dev python3-pip python-is-python3 libpcap-dev build-essential procps schedtool\n    sudo pip3 install pcapy-ng\n    cd /tmp\n    git clone --depth 1 https://github.com/stamparm/maltrail.git\n    sudo mv /tmp/maltrail /opt\n    sudo chown -R $USER:$USER /opt/maltrail\n    ```\n    \n- On **SUSE/openSUSE**\n\n   ```sh\n   sudo zypper install gcc gcc-c++ git libpcap-devel python3-devel python3-pip procps schedtool\n   sudo pip3 install pcapy-ng\n   cd /tmp\n   git clone --depth 1 https://github.com/stamparm/maltrail.git\n   sudo mv /tmp/maltrail /opt\n   sudo chown -R $USER:$USER /opt/maltrail\n   ```\n\n2. Set working environment:\n\n    ```sh\n    sudo mkdir -p /var/log/maltrail\n    sudo mkdir -p /etc/maltrail\n    sudo cp /opt/maltrail/maltrail.conf /etc/maltrail\n    sudo nano /etc/maltrail/maltrail.conf\n    ```\n\n3. Set running environment:\n\n    * `crontab -e  # autostart server & periodic update`\n\n    ```\n    */5 * * * * if [ -n \"$(ps -ef | grep -v grep | grep 'server.py')\" ]; then : ; else python3 /opt/maltrail/server.py -c /etc/maltrail/maltrail.conf; fi\n    0 1 * * * cd /opt/maltrail && git pull\n    ```\n\n    * `sudo crontab -e  # autostart sensor & periodic restart`\n\n    ```\n    */1 * * * * if [ -n \"$(ps -ef | grep -v grep | grep 'sensor.py')\" ]; then : ; else python3 /opt/maltrail/sensor.py -c /etc/maltrail/maltrail.conf; fi\n    2 1 * * * /usr/bin/pkill -f maltrail\n    ```\n\n4. Enable as systemd services (Linux only):\n\n    ```sh\n    sudo cp /opt/maltrail/maltrail-sensor.service /etc/systemd/system/maltrail-sensor.service\n    sudo cp /opt/maltrail/maltrail-server.service /etc/systemd/system/maltrail-server.service\n    sudo systemctl daemon-reload\n    sudo systemctl start maltrail-server.service\n    sudo systemctl start maltrail-sensor.service\n    sudo systemctl enable maltrail-server.service\n    sudo systemctl enable maltrail-sensor.service\n    systemctl status maltrail-server.service && systemctl status maltrail-sensor.service\n    \n    ```\n    \n  **Note**: ```/maltrail-sensor.service``` can be started as dedicated service without pre-started ```/maltrail-server.service```. This is useful for case, when ```/maltrail-server.service``` is installed and works on another machine in you network environment.\n\n\n## License\n\nThis software is provided under a MIT License. See the accompanying [LICENSE](https://github.com/stamparm/maltrail/blob/master/LICENSE) file for more information.\n\n## Sponsors\n\n* [Sansec](https://sansec.io/) (2024-)\n* [Sansec](https://sansec.io/) (2020-2021)\n\n## Developers\n\n* Miroslav Stampar ([@stamparm](https://github.com/stamparm))\n* Mikhail Kasimov ([@MikhailKasimov](https://github.com/MikhailKasimov))\n\n## Presentations\n\n* 47th TF-CSIRT Meeting, Prague (Czech Republic), 2016 ([slides](https://www.terena.org/activities/tf-csirt/meeting47/M.Stampar-Maltrail.pdf))\n\n## Publications\n\n* Detect attacks on your network with Maltrail, Linux Magazine, 2022 ([Annotation](https://www.linux-magazine.com/Issues/2022/258/Maltrail))\n* Best Cyber Threat Intelligence Feeds ([SilentPush Review, 2022](https://www.silentpush.com/blog/best-cyber-threat-intelligence-feeds))\n* Research on Network Malicious Traffic Detection System Based on Maltrail ([Nanotechnology Perceptions, ISSN 1660-6795, 2024](https://nano-ntp.com/index.php/nano/article/view/1915/1497))\n\n## Blacklist\n\n* Maltrail's daily updated blacklist of malware-related domains can be found [here](https://raw.githubusercontent.com/stamparm/aux/master/maltrail-malware-domains.txt). It is based on trails found at [trails/static/malware](trails/static/malware) and can be safely used for DNS traffic blocking purposes.\n\n## Thank you\n\n* Thomas Kristner\n* Eduardo Arcusa Les\n* James Lay\n* Ladislav Baco (@laciKE)\n* John Kristoff (@jtkdpu)\n* Michael M&uuml;nz (@mimugmail)\n* David Brush\n* @Godwottery\n* Chris Wild (@briskets)\n\n## Third-party integrations\n\n* [FreeBSD Port](https://www.freshports.org/security/maltrail)\n* [OPNSense Gateway Plugin](https://github.com/opnsense/plugins/pull/1257)\n* [D4 Project](https://www.d4-project.org/2019/09/25/maltrail-integration.html)\n* [BlackArch Linux](https://github.com/BlackArch/blackarch/blob/master/packages/maltrail/PKGBUILD)\n* [Validin LLC](https://twitter.com/ValidinLLC/status/1719666086390517762)\n* [Maltrail Add-on for Splunk](https://splunkbase.splunk.com/app/7211)\n* [GScan](https://github.com/grayddq/GScan) <sup>1</sup>\n* [MalwareWorld](https://www.malwareworld.com/) <sup>1</sup>\n* [oisd | domain blocklist](https://oisd.nl/?p=inc) <sup>1</sup>\n* [NextDNS](https://github.com/nextdns/metadata/blob/e0c9c7e908f5d10823b517ad230df214a7251b13/security/threat-intelligence-feeds.json) <sup>1</sup>\n* [NoTracking](https://github.com/notracking/hosts-blocklists/blob/master/SOURCES.md) <sup>1</sup>\n* [OWASP Mobile Audit](https://github.com/mpast/mobileAudit#environment-variables) <sup>1</sup>\n* [Mobile-Security-Framework-MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF/commit/12b07370674238fa4281fc7989b34decc2e08876) <sup>1</sup>\n* [pfBlockerNG-devel](https://github.com/pfsense/FreeBSD-ports/blob/devel/net/pfSense-pkg-pfBlockerNG-devel/files/usr/local/www/pfblockerng/pfblockerng_feeds.json) <sup>1</sup>\n* [Sansec eComscan](https://sansec.io/kb/about-ecomscan/ecomscan-license)<sup>1</sup>\n* [Palo Alto Networks Cortex XSOAR](https://xsoar.pan.dev/docs/reference/integrations/github-maltrail-feed)<sup>2</sup>\n \n<sup>1</sup> Using (only) trails\n\n<sup>2</sup> Connector to trails (only)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.9013671875,
          "content": "---\ntitle: Maltrail Security Vulnerability Reports\ncategory: contributing\nlayout: default\nSPDX-License-Identifier: MIT\n---\n\n## Reporting Maltrail Security Vulnerability\n\nMaltrail team appreciates your efforts on discovering security vulnerabilities in [Maltrail](https://github.com/stamparm/maltrail): Malicious traffic detection system.\n\nIf you discover a Maltrail security vulnerability, we'd appreciate a non-public disclosure. Maltrail team developers can be contacted privately on the **maltrail.vulns[@]gmail.com** email address.\n\nThe disclosure of discovered security vulnerability will be coordinated with Maltrail team.\n\nMaltrail's [issues tracker](https://github.com/stamparm/maltrail/issues) and [pull requests tracker](https://github.com/stamparm/maltrail/pulls) are fully public.\n\n## Supported Versions\n\n\n| Version | Supported          |\n| ------- | ------------------ |\n| All versions  | :white_check_mark: |\n"
        },
        {
          "name": "core",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "fail2ban",
          "type": "tree",
          "content": null
        },
        {
          "name": "html",
          "type": "tree",
          "content": null
        },
        {
          "name": "maltrail-sensor.service",
          "type": "blob",
          "size": 0.4267578125,
          "content": "[Unit]\nDescription=Maltrail. Sensor of malicious traffic detection system\nDocumentation=https://github.com/stamparm/maltrail#readme\nDocumentation=https://github.com/stamparm/maltrail/wiki\nRequires=network.target\nWants=maltrail-server.service\nAfter=network-online.target maltrail-server.service\n\n[Service]\nUser=root\nWorkingDirectory=/opt/maltrail/\nExecStart=/usr/bin/python3 sensor.py\nKillMode=mixed\n\n[Install]\nWantedBy=multi-user.target\n"
        },
        {
          "name": "maltrail-server.service",
          "type": "blob",
          "size": 0.419921875,
          "content": "[Unit]\r\nDescription=Maltrail. Server of malicious traffic detection system\r\nDocumentation=https://github.com/stamparm/maltrail#readme\r\nDocumentation=https://github.com/stamparm/maltrail/wiki\r\nRequires=network.target\r\nBefore=maltrail-sensor.service\r\nAfter=network-online.target\r\n\r\n[Service]\r\nUser=root\r\nWorkingDirectory=/opt/maltrail/\r\nExecStart=/usr/bin/python3 server.py\r\nKillMode=mixed\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n"
        },
        {
          "name": "maltrail.conf",
          "type": "blob",
          "size": 5.837890625,
          "content": "# [Server]\n\n# Listen address of (reporting) HTTP server\nHTTP_ADDRESS 0.0.0.0\n#HTTP_ADDRESS ::\n#HTTP_ADDRESS fe80::12c3:7bff:fe6d:cf9b%eno1\n\n# Listen port of (reporting) HTTP server\nHTTP_PORT 8338\n\n# Use SSL/TLS\nUSE_SSL false\n\n# SSL/TLS (private/cert) PEM file (e.g. openssl req -new -x509 -keyout server.pem -out server.pem -days 1023 -nodes)\n#SSL_PEM misc/server.pem\n\n# User entries (username:sha256(password):UID:filter_netmask(s))\n# Note(s): sha256(password) can be generated on Linux with: echo -n 'password' | sha256sum | cut -d \" \" -f 1\n#          UID >= 1000 have only rights to display results (Note: this moment only functionality implemented at the client side)\n#          filter_netmask(s) is/are used to filter results\nUSERS\n    admin:9ab3cd9d67bf49d01f6a2e33d0bd9bc804ddbe6ce1ff5d219c42624851db5dbc:0:                        # changeme!\n#    local:9ab3cd9d67bf49d01f6a2e33d0bd9bc804ddbe6ce1ff5d219c42624851db5dbc:1000:192.168.0.0/16       # changeme!\n\n# Mask custom trail names for non-admin users (UID >= 1000)\nENABLE_MASK_CUSTOM true\n\n# Listen address of (log collecting) UDP server\n#UDP_ADDRESS 0.0.0.0\n#UDP_ADDRESS ::\n#UDP_ADDRESS fe80::12c3:7bff:fe6d:cf9b%eno1\n\n# Listen port of (log collecting) UDP server\n#UDP_PORT 8337\n\n# Should server do the trail updates too (to support UPDATE_SERVER directive in [Sensor] parameters)\nUSE_SERVER_UPDATE_TRAILS false\n\n# Aliases used in client's web browser interface to describe the src_ip and/or dst_ip column entries\n#IP_ALIASES\n#    8.8.8.8:google\n#    8.8.4.4:google\n\n# Option to change the top-left logo with a custom image/text\n#HEADER_LOGO <img src=\"https://i.imgur.com/JxYJ5yX.png\" style=\"width: 26px\"> XYZ\n\n# Regular expression to be used in external /fail2ban calls for extraction of attacker source IPs\nFAIL2BAN_REGEX attacker|reputation|potential[^\"]*(web scan|directory traversal|injection|remote code|iot-malware download)|spammer|mass scanner\n\n# Blacklist generation rules \n# BLACKLIST\n#     src_ip !~ ^192.168. and dst_port ~ ^22$\n#     src_ip ~ ^192.168. and filter ~ malware\n\n# [Sensor]\n\n# Number of processes\nPROCESS_COUNT 1\n\n# Disable setting of CPU affinity (with schedtool) on Linux machines (e.g. because of load issues with other processes)\nDISABLE_CPU_AFFINITY false\n\n# Use feeds (too) in trail updates\nUSE_FEED_UPDATES true\n\n# Disable (retrieval from) specified feeds (Note: respective .py files inside /trails/feeds; turris and ciarmy/cinsscore seem to be too \"noisy\" lately; policeman is old and produces lots of false positives)\nDISABLED_FEEDS turris, ciarmy, policeman, myip, alienvault\n\n# Ignore IPs that appear on lower than IP_MINIMUM_FEEDS number of feeds (Note: static IP trails are always included)\nIP_MINIMUM_FEEDS 3\n\n# Disable trails based on the following regular expression run against the corresponding info\n#DISABLED_TRAILS_INFO_REGEX known attacker|tor exit node\n\n# Update trails after every given period (seconds)\nUPDATE_PERIOD 86400\n\n# Use remote custom feed (too) in trail updates\n#CUSTOM_TRAILS_URL http://www.test.com/custom.txt\n\n# Location of directory with custom trails (*.txt) files\nCUSTOM_TRAILS_DIR ./trails/custom\n\n# (Max.) size of multiprocessing network capture ring buffer (in bytes or percentage of total physical memory) used by sensor (e.g. 512MB)\nCAPTURE_BUFFER 10%\n\n# Interface used for monitoring (e.g. eth0, eth1)\nMONITOR_INTERFACE any\n\n# Network capture filter (e.g. ip)\n# Note(s): more info about filters can be found at: https://danielmiessler.com/study/tcpdump/\n#CAPTURE_FILTER ip or ip6\nCAPTURE_FILTER udp or icmp or (tcp and (tcp[tcpflags] == tcp-syn or port 80 or port 1080 or port 3128 or port 8000 or port 8080 or port 8118))\n\n# Sensor name to appear in produced logs\nSENSOR_NAME $HOSTNAME\n\n# Remote Maltrail server instance to send log entries (Note: listening at <UDP_ADDRESS>:<UDP_PORT>)\n#LOG_SERVER 192.168.2.107:8337\n#LOG_SERVER [fe80::12c3:7bff:fe6d:cf9b%eno1]:8337\n\n# Remote address to send Syslog events\n#SYSLOG_SERVER 192.168.2.107:514\n\n# Remote address to send JSON events (e.g. Logstash)\n#LOGSTASH_SERVER 192.168.2.107:5000\n\n# Regular expression used for calculating severity attribute when sending events to SYSLOG_SERVER or LOGSTASH_SERVER\nREMOTE_SEVERITY_REGEX (?P<high>(remote )?custom\\)|malwaredomainlist|iot-malware|malware(?! (distribution|site))|adversary|ransomware)|(?P<medium>potential malware site|malware distribution)|(?P<low>mass scanner|reputation|attacker|spammer|compromised|crawler|scanning)\n\n# Set only (!) in cases when LOG_SERVER should be exclusively used for log storage\nDISABLE_LOCAL_LOG_STORAGE false\n\n# Remote address for pulling (latest) trail definitions (e.g. http://192.168.2.107:8338/trails). USE_SERVER_UPDATE_TRAILS directive should be active in [Server] parameters.\n#UPDATE_SERVER http://192.168.2.107:8338/trails\n\n# Use heuristic methods\nUSE_HEURISTICS true\n\n# Capture HTTP requests with missing Host header (introducing potential false positives)\nCHECK_MISSING_HOST false\n\n# Check values in Host header (along with standard non-HTTP checks) for malicious DNS trails (introducing greater number of events)\nCHECK_HOST_DOMAINS false\n\n# Location of file with whitelisted entries (i.e. IP addresses, domain names, etc.) (note: take a look into 'misc/whitelist.txt')\n#USER_WHITELIST\n\n# Location of file with ignore event rules. Example under misc/ignore_events.txt\n#USER_IGNORELIST misc/ignore_events.txt\n\n# Regular expression to be used against the whole event entry to be ignored\n#IGNORE_EVENTS_REGEX sql injection|long domain|117.21.225.3|sinkhole\n\n# [All]\n\n# Show debug messages (in console output)\nSHOW_DEBUG false\n\n# Directory used for log storage\nLOG_DIR $SYSTEM_LOG_DIR/maltrail\n\n# HTTP(s) proxy address\n#PROXY_ADDRESS http://192.168.5.101:8118\n\n# Disable checking of sudo/Administrator privileges (e.g. if using: setcap 'CAP_NET_RAW+eip CAP_NET_ADMIN+eip' /bin/python)\n#DISABLE_CHECK_SUDO true\n\n# Override default location for trail storage (~/.maltrail/trails.csv)\n#TRAILS_FILE /etc/maltrail.csv\n"
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "plugins",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0087890625,
          "content": "pcapy-ng\n"
        },
        {
          "name": "sensor.py",
          "type": "blob",
          "size": 62.56640625,
          "content": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2014-2025 Maltrail developers (https://github.com/stamparm/maltrail/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function  # Requires: Python >= 2.6\n\nimport sys\n\nsys.dont_write_bytecode = True\n\nimport cProfile\nimport inspect\nimport math\nimport mmap\nimport optparse\nimport os\nimport platform\nimport re\nimport socket\nimport subprocess\nimport struct\nimport threading\nimport time\nimport traceback\nimport warnings\n\nfrom core.addr import inet_ntoa6\nfrom core.addr import addr_port\nfrom core.attribdict import AttribDict\nfrom core.common import check_connection\nfrom core.common import check_sudo\nfrom core.common import check_whitelisted\nfrom core.common import get_ex_message\nfrom core.common import get_text\nfrom core.common import is_local\nfrom core.common import load_trails\nfrom core.common import patch_parser\nfrom core.compat import xrange\nfrom core.datatype import LRUDict\nfrom core.enums import BLOCK_MARKER\nfrom core.enums import CACHE_TYPE\nfrom core.enums import PROTO\nfrom core.enums import TRAIL\nfrom core.log import create_log_directory\nfrom core.log import flush_condensed_events\nfrom core.log import get_error_log_handle\nfrom core.log import log_error\nfrom core.log import log_event\nfrom core.parallel import worker\nfrom core.parallel import write_block\nfrom core.settings import config\nfrom core.settings import CAPTURE_TIMEOUT\nfrom core.settings import CHECK_CONNECTION_MAX_RETRIES\nfrom core.settings import CONFIG_FILE\nfrom core.settings import CONSONANTS\nfrom core.settings import DLT_OFFSETS\nfrom core.settings import DNS_EXHAUSTION_THRESHOLD\nfrom core.settings import GENERIC_SINKHOLE_REGEX\nfrom core.settings import HOMEPAGE\nfrom core.settings import HOURLY_SECS\nfrom core.settings import HTTP_TIME_FORMAT\nfrom core.settings import IGNORE_DNS_QUERY_SUFFIXES\nfrom core.settings import IPPROTO_LUT\nfrom core.settings import IS_WIN\nfrom core.settings import LOCALHOST_IP\nfrom core.settings import LOCAL_SUBDOMAIN_LOOKUPS\nfrom core.settings import MAX_CACHE_ENTRIES\nfrom core.settings import MMAP_ZFILL_CHUNK_LENGTH\nfrom core.settings import NAME\nfrom core.settings import NO_SUCH_NAME_COUNTERS\nfrom core.settings import NO_SUCH_NAME_PER_HOUR_THRESHOLD\nfrom core.settings import INFECTION_SCANNING_THRESHOLD\nfrom core.settings import PORT_SCANNING_THRESHOLD\nfrom core.settings import POTENTIAL_INFECTION_PORTS\nfrom core.settings import read_config\nfrom core.settings import REGULAR_SENSOR_SLEEP_TIME\nfrom core.settings import SNAP_LEN\nfrom core.settings import SUSPICIOUS_CONTENT_TYPES\nfrom core.settings import SUSPICIOUS_DIRECT_DOWNLOAD_EXTENSIONS\nfrom core.settings import SUSPICIOUS_DIRECT_IP_URL_REGEX\nfrom core.settings import SUSPICIOUS_DOMAIN_CONSONANT_THRESHOLD\nfrom core.settings import SUSPICIOUS_DOMAIN_ENTROPY_THRESHOLD\nfrom core.settings import SUSPICIOUS_DOMAIN_LENGTH_THRESHOLD\nfrom core.settings import SUSPICIOUS_HTTP_PATH_REGEXES\nfrom core.settings import SUSPICIOUS_HTTP_REQUEST_PRE_CONDITION\nfrom core.settings import SUSPICIOUS_HTTP_REQUEST_REGEXES\nfrom core.settings import SUSPICIOUS_HTTP_REQUEST_FORCE_ENCODE_CHARS\nfrom core.settings import SUSPICIOUS_PROXY_PROBE_PRE_CONDITION\nfrom core.settings import SUSPICIOUS_UA_REGEX\nfrom core.settings import VALID_DNS_NAME_REGEX\nfrom core.settings import trails\nfrom core.settings import VERSION\nfrom core.settings import WEB_SCANNING_THRESHOLD\nfrom core.settings import WHITELIST\nfrom core.settings import WHITELIST_DIRECT_DOWNLOAD_KEYWORDS\nfrom core.settings import WHITELIST_LONG_DOMAIN_NAME_KEYWORDS\nfrom core.settings import WHITELIST_HTTP_REQUEST_PATHS\nfrom core.settings import WHITELIST_UA_REGEX\nfrom core.update import update_ipcat\nfrom core.update import update_trails\nfrom thirdparty import six\nfrom thirdparty.six.moves import urllib as _urllib\n\nwarnings.filterwarnings(action=\"ignore\", category=DeprecationWarning)       # NOTE: https://github.com/helpsystems/pcapy/pull/67/files\n\n_buffer = None\n_caps = []\n_connect_sec = 0\n_connect_src_dst = {}\n_connect_src_details = {}\n_path_src_dst = {}\n_path_src_dst_details = {}\n_count = 0\n_locks = AttribDict()\n_multiprocessing = None\n_n = None\n_result_cache = LRUDict(MAX_CACHE_ENTRIES)\n_local_cache = LRUDict(MAX_CACHE_ENTRIES)\n_last_syn = None\n_last_logged_syn = None\n_last_udp = None\n_last_logged_udp = None\n_done_count = 0\n_done_lock = threading.Lock()\n_subdomains = {}\n_subdomains_sec = None\n_dns_exhausted_domains = set()\n\nclass _set(set):\n    pass\n\ntry:\n    import __builtin__\nexcept ImportError:\n    # Python 3\n    import builtins as __builtin__\n\n\ndef print(*args, **kwargs):\n    ret = __builtin__.print(*args, **kwargs)\n    sys.stdout.flush()\n    return ret\n\n\ntry:\n    import pcapy\nexcept ImportError:\n    if IS_WIN:\n        sys.exit(\"[!] please install 'WinPcap' (e.g. 'http://www.winpcap.org/install/') and Pcapy (e.g. 'https://breakingcode.wordpress.com/?s=pcapy')\")\n    else:\n        msg = \"[!] please install 'pcapy or pcapy-ng' (e.g. 'sudo pip%s install pcapy-ng')\" % ('3' if six.PY3 else '2')\n\n        sys.exit(msg)\n\ndef _check_domain_member(query, domains):\n    parts = query.lower().split('.')\n\n    for i in xrange(0, len(parts)):\n        domain = '.'.join(parts[i:])\n        if domain in domains:\n            return True\n\n    return False\n\ndef _check_domain_whitelisted(query):\n    result = _result_cache.get((CACHE_TYPE.DOMAIN_WHITELISTED, query))\n\n    if result is None:\n        result = _check_domain_member(re.split(r\"(?i)[^A-Z0-9._-]\", query or \"\")[0], WHITELIST)\n        _result_cache[(CACHE_TYPE.DOMAIN_WHITELISTED, query)] = result\n\n    return result\n\ndef _check_domain(query, sec, usec, src_ip, src_port, dst_ip, dst_port, proto, packet=None):\n    if query:\n        query = query.lower()\n        if ':' in query:\n            query = query.split(':', 1)[0]\n\n    if query.replace('.', \"\").isdigit():  # IP address\n        return\n\n    if _result_cache.get((CACHE_TYPE.DOMAIN, query)) is False:\n        return\n\n    result = False\n    if re.search(VALID_DNS_NAME_REGEX, query) is not None and not _check_domain_whitelisted(query):\n        parts = query.split('.')\n\n        if query.endswith(\".ip-adress.com\"):  # Reference: https://www.virustotal.com/gui/domain/ip-adress.com/relations\n            _ = '.'.join(parts[:-2])\n            trail = \"%s(.ip-adress.com)\" % _\n            if _ in trails:\n                result = True\n                log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, proto, TRAIL.DNS, trail, trails[_][0], trails[_][1]), packet)\n\n        if not result:\n            for i in xrange(0, len(parts)):\n                domain = '.'.join(parts[i:])\n                if domain in trails:\n                    if domain == query:\n                        trail = domain\n                    else:\n                        _ = \".%s\" % domain\n                        trail = \"(%s)%s\" % (query[:-len(_)], _)\n\n                    if not (re.search(r\"(?i)\\A([rd]?ns|nf|mx|nic)\\d*\\.\", query) and any(_ in trails.get(domain, \" \")[0] for _ in (\"suspicious\", \"sinkhole\"))):  # e.g. ns2.nobel.su\n                        if not ((query == trail or parts[0] == \"www\") and any(_ in trails.get(domain, \" \")[0] for _ in (\"dynamic\", \"free web\"))):  # e.g. noip.com\n                            result = True\n                            log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, proto, TRAIL.DNS, trail, trails[domain][0], trails[domain][1]), packet)\n                            break\n\n        if not result and config.USE_HEURISTICS:\n            if len(parts[0]) > SUSPICIOUS_DOMAIN_LENGTH_THRESHOLD and '-' not in parts[0]:\n                trail = None\n\n                if len(parts) > 2:\n                    trail = \"(%s).%s\" % ('.'.join(parts[:-2]), '.'.join(parts[-2:]))\n                elif len(parts) == 2:\n                    trail = \"(%s).%s\" % (parts[0], parts[1])\n                else:\n                    trail = query\n\n                if trail and not any(_ in trail for _ in WHITELIST_LONG_DOMAIN_NAME_KEYWORDS):\n                    result = True\n                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, proto, TRAIL.DNS, trail, \"long domain (suspicious)\", \"(heuristic)\"), packet)\n\n        if not result and trails._regex:\n            match = re.search(trails._regex, query)\n            if match:\n                group, trail = [_ for _ in match.groupdict().items() if _[1] is not None][0]\n                candidate = trails._regex.split(\"(?P<\")[int(group[1:]) + 1]\n                candidate = candidate.split('>', 1)[-1].rstrip('|')[:-1]\n                if candidate in trails:\n                    result = True\n                    trail = match.group(0)\n\n                    prefix, suffix = query[:match.start()], query[match.end():]\n                    if prefix:\n                        trail = \"(%s)%s\" % (prefix, trail)\n                    if suffix:\n                        trail = \"%s(%s)\" % (trail, suffix)\n\n                    trail = trail.replace(\".)\", \").\")\n\n                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, proto, TRAIL.DNS, trail, trails[candidate][0], trails[candidate][1]), packet)\n\n        if not result and \".onion.\" in query:\n            trail = re.sub(r\"(\\.onion)(\\..*)\", r\"\\1(\\2)\", query)\n            _ = trail.split('(')[0]\n            if _ in trails:\n                result = True\n                log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, proto, TRAIL.DNS, trail, trails[_][0], trails[_][1]), packet)\n\n    if result is False:\n        _result_cache[(CACHE_TYPE.DOMAIN, query)] = False\n\ndef _get_local_prefix():\n    _sources = set(_.split('~')[0] for _ in _connect_src_dst.keys())\n    _candidates = [re.sub(r\"\\d+\\.\\d+\\Z\", \"\", _) for _ in _sources]\n    _ = sorted(((_candidates.count(_), _) for _ in set(_candidates)), reverse=True)\n    result = _[0][1] if _ else \"\"\n\n    if result:\n        _result_cache[(CACHE_TYPE.LOCAL_PREFIX, \"\")] = result\n    else:\n        result = _result_cache.get((CACHE_TYPE.LOCAL_PREFIX, \"\"))\n\n    return result or '_'\n\ndef _process_packet(packet, sec, usec, ip_offset):\n    \"\"\"\n    Processes single (raw) IP layer data\n    \"\"\"\n\n    global _connect_sec\n    global _last_syn\n    global _last_logged_syn\n    global _last_udp\n    global _last_logged_udp\n    global _subdomains_sec\n\n    try:\n        if config.USE_HEURISTICS:\n            if _locks.connect_sec:\n                _locks.connect_sec.acquire()\n\n            connect_sec = _connect_sec\n            _connect_sec = sec\n\n            if _locks.connect_sec:\n                _locks.connect_sec.release()\n\n            if sec > connect_sec:\n                for key in _connect_src_dst:\n                    _src_ip, _dst = key.split('~')\n                    if not _dst.isdigit() and len(_connect_src_dst[key]) > PORT_SCANNING_THRESHOLD:\n                        if not check_whitelisted(_src_ip):\n                            _dst_ip = _dst\n                            for _ in _connect_src_details[key]:\n                                log_event((sec, usec, _src_ip, _[2], _dst_ip, _[3], PROTO.TCP, TRAIL.IP, _src_ip, \"potential port scanning\", \"(heuristic)\"), packet)\n                    elif len(_connect_src_dst[key]) > INFECTION_SCANNING_THRESHOLD:\n                        _dst_port = _dst\n                        _dst_ip = [_[-1] for _ in _connect_src_details[key]]\n                        _src_port = [_[-2] for _ in _connect_src_details[key]]\n\n                        if len(_dst_ip) == len(set(_dst_ip)):\n                            if _src_ip.startswith(_get_local_prefix()):\n                                log_event((sec, usec, _src_ip, _src_port[0], _dst_ip[0], _dst_port, PROTO.TCP, TRAIL.PORT, _dst_port, \"potential infection\", \"(heuristic)\"), packet)\n\n                _connect_src_dst.clear()\n                _connect_src_details.clear()\n\n                for key in _path_src_dst:\n                    if len(_path_src_dst[key]) > WEB_SCANNING_THRESHOLD:\n                        _src_ip, _dst_ip = key.split('~')\n                        _sec, _usec, _src_port, _dst_port, _path = _path_src_dst_details[key].pop()\n                        log_event((_sec, _usec, _src_ip, _src_port, _dst_ip, _dst_port, PROTO.TCP, TRAIL.PATH, \"*\", \"potential web scanning\", \"(heuristic)\"), packet)\n\n                _path_src_dst.clear()\n                _path_src_dst_details.clear()\n\n        ip_data = packet[ip_offset:]\n        ip_version = ord(ip_data[0:1]) >> 4\n        localhost_ip = LOCALHOST_IP[ip_version]\n\n        if ip_version == 0x04:  # IPv4\n            ip_header = struct.unpack(\"!BBHHHBBH4s4s\", ip_data[:20])\n            fragment_offset = ip_header[4] & 0x1fff\n            if fragment_offset != 0:\n                return\n            iph_length = (ip_header[0] & 0xf) << 2\n            protocol = ip_header[6]\n            src_ip = socket.inet_ntoa(ip_header[8])\n            dst_ip = socket.inet_ntoa(ip_header[9])\n        elif ip_version == 0x06:  # IPv6\n            # Reference: http://chrisgrundemann.com/index.php/2012/introducing-ipv6-understanding-ipv6-addresses/\n            ip_header = struct.unpack(\"!BBHHBB16s16s\", ip_data[:40])\n            iph_length = 40\n            protocol = ip_header[4]\n            src_ip = inet_ntoa6(ip_header[6])\n            dst_ip = inet_ntoa6(ip_header[7])\n        else:\n            return\n\n        if protocol == socket.IPPROTO_TCP:  # TCP\n            src_port, dst_port, _, _, doff_reserved, flags = struct.unpack(\"!HHLLBB\", ip_data[iph_length:iph_length + 14])\n\n            if flags != 2 and config.plugin_functions:\n                if dst_ip in trails:\n                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.IP, dst_ip, trails[dst_ip][0], trails[dst_ip][1]), packet, skip_write=True)\n                elif src_ip in trails and dst_ip != localhost_ip:\n                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.IP, src_ip, trails[src_ip][0], trails[src_ip][1]), packet, skip_write=True)\n\n            if flags == 2:  # SYN set (only)\n                _ = _last_syn\n                _last_syn = (sec, src_ip, src_port, dst_ip, dst_port)\n                if _ == _last_syn:  # skip bursts\n                    return\n\n                if dst_ip in trails or addr_port(dst_ip, dst_port) in trails:\n                    _ = _last_logged_syn\n                    _last_logged_syn = _last_syn\n                    if _ != _last_logged_syn:\n                        trail = addr_port(dst_ip, dst_port)\n                        if trail not in trails:\n                            trail = dst_ip\n                        if not any(_ in trails[trail][0] for _ in (\"attacker\",)) and not (\"parking site\" in trails[trail][0] and dst_port not in (80, 443)):\n                            log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.IP if ':' not in trail else TRAIL.IPORT, trail, trails[trail][0], trails[trail][1]), packet)\n\n                elif (src_ip in trails or addr_port(src_ip, src_port) in trails) and dst_ip != localhost_ip:\n                    _ = _last_logged_syn\n                    _last_logged_syn = _last_syn\n                    if _ != _last_logged_syn:\n                        trail = addr_port(src_ip, src_port)\n                        if trail not in trails:\n                            trail = src_ip\n                        if not any(_ in trails[trail][0] for _ in (\"malware\",)):\n                            log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.IP if ':' not in trail else TRAIL.IPORT, trail, trails[trail][0], trails[trail][1]), packet)\n\n                if config.USE_HEURISTICS:\n                    if dst_ip != localhost_ip:\n                        key = \"%s~%s\" % (src_ip, dst_ip)\n                        if key not in _connect_src_dst:\n                            _connect_src_dst[key] = set()\n                            _connect_src_details[key] = set()\n                        _connect_src_dst[key].add(dst_port)\n                        _connect_src_details[key].add((sec, usec, src_port, dst_port))\n\n                        if dst_port in POTENTIAL_INFECTION_PORTS:\n                            key = \"%s~%s\" % (src_ip, dst_port)\n                            if key not in _connect_src_dst:\n                                _connect_src_dst[key] = set()\n                                _connect_src_details[key] = set()\n                            _connect_src_dst[key].add(dst_ip)\n                            _connect_src_details[key].add((sec, usec, src_port, dst_ip))\n            else:\n                tcph_length = doff_reserved >> 4\n                h_size = iph_length + (tcph_length << 2)\n                tcp_data = get_text(ip_data[h_size:])\n\n                if tcp_data.startswith(\"HTTP/\"):\n                    match = re.search(GENERIC_SINKHOLE_REGEX, tcp_data[:2000])\n                    if match:\n                        trail = match.group(0)\n                        log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.HTTP, trail, \"sinkhole response (malware)\", \"(heuristic)\"), packet)\n                    else:\n                        index = tcp_data.find(\"<title>\")\n                        if index >= 0:\n                            title = tcp_data[index + len(\"<title>\"):tcp_data.find(\"</title>\", index)]\n                            if re.search(r\"domain name has been seized by|Domain Seized|Domain Seizure\", title):\n                                log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.HTTP, title, \"seized domain (suspicious)\", \"(heuristic)\"), packet)\n\n                    content_type = None\n                    first_index = tcp_data.find(\"\\r\\nContent-Type:\")\n                    if first_index >= 0:\n                        first_index = first_index + len(\"\\r\\nContent-Type:\")\n                        last_index = tcp_data.find(\"\\r\\n\", first_index)\n                        if last_index >= 0:\n                            content_type = tcp_data[first_index:last_index].strip().lower()\n\n                    if content_type and content_type in SUSPICIOUS_CONTENT_TYPES:\n                        log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.HTTP, content_type, \"content type (suspicious)\", \"(heuristic)\"), packet)\n\n                method, path = None, None\n\n                if \" HTTP/\" in tcp_data:\n                    index = tcp_data.find(\"\\r\\n\")\n                    if index >= 0:\n                        line = tcp_data[:index]\n                        if line.count(' ') == 2 and \" HTTP/\" in line:\n                            method, path, _ = line.split(' ')\n\n                if method and path:\n                    post_data = None\n                    host = dst_ip\n                    first_index = tcp_data.find(\"\\r\\nHost:\")\n                    path = path.lower()\n\n                    if first_index >= 0:\n                        first_index = first_index + len(\"\\r\\nHost:\")\n                        last_index = tcp_data.find(\"\\r\\n\", first_index)\n                        if last_index >= 0:\n                            host = tcp_data[first_index:last_index]\n                            host = host.strip().lower()\n                            if host.endswith(\":80\"):\n                                host = host[:-3]\n                            if host and host[0].isalpha() and dst_ip in trails:\n                                log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.IP, \"%s (%s)\" % (dst_ip, host.split(':')[0]), trails[dst_ip][0], trails[dst_ip][1]), packet)\n                            elif re.search(r\"\\A\\d+\\.[0-9.]+\\Z\", host or \"\") and re.search(SUSPICIOUS_DIRECT_IP_URL_REGEX, \"%s%s\" % (host, path)):\n                                if not dst_ip.startswith(_get_local_prefix()):\n                                    trail = \"(%s)%s\" % (host, path)\n                                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.HTTP, trail, \"potential iot-malware download (suspicious)\", \"(heuristic)\"), packet)\n                                    return\n                            elif config.CHECK_HOST_DOMAINS:\n                                _check_domain(host, sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, packet)\n                    elif config.USE_HEURISTICS and config.CHECK_MISSING_HOST:\n                        log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.HTTP, \"%s%s\" % (host, path), \"missing host header (suspicious)\", \"(heuristic)\"), packet)\n\n                    index = tcp_data.find(\"\\r\\n\\r\\n\")\n                    if index >= 0:\n                        post_data = tcp_data[index + 4:]\n\n                    url = None\n                    if config.USE_HEURISTICS and path.startswith('/'):\n                        _path = path.split('/')[1]\n\n                        key = \"%s~%s\" % (src_ip, dst_ip)\n                        if key not in _path_src_dst:\n                            _path_src_dst[key] = set()\n                        _path_src_dst[key].add(_path)\n\n                        if key not in _path_src_dst_details:\n                            _path_src_dst_details[key] = set()\n                        _path_src_dst_details[key].add((sec, usec, src_port, dst_port, path))\n\n                    elif config.USE_HEURISTICS and dst_port == 80 and path.startswith(\"http://\") and any(_ in path for _ in SUSPICIOUS_PROXY_PROBE_PRE_CONDITION) and not _check_domain_whitelisted(path.split('/')[2]):\n                        trail = re.sub(r\"(http://[^/]+/)(.+)\", r\"\\g<1>(\\g<2>)\", path)\n                        trail = re.sub(r\"(http://)([^/(]+)\", lambda match: \"%s%s\" % (match.group(1), match.group(2).split(':')[0].rstrip('.')), trail)\n                        log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.HTTP, trail, \"potential proxy probe (suspicious)\", \"(heuristic)\"), packet)\n                        return\n                    elif \"://\" in path:\n                        unquoted_path = _urllib.parse.unquote(path)\n\n                        key = \"code execution\"\n                        if key not in _local_cache:\n                            _local_cache[key] = next(_[1] for _ in SUSPICIOUS_HTTP_REQUEST_REGEXES if \"code execution\" in _[0])\n\n                        if re.search(_local_cache[key], unquoted_path, re.I) is None:    # NOTE: to prevent malware domain FPs in case of outside scanners\n                            url = path.split(\"://\", 1)[1]\n\n                            if '/' not in url:\n                                url = \"%s/\" % url\n\n                            host, path = url.split('/', 1)\n                            if host.endswith(\":80\"):\n                                host = host[:-3]\n                            path = \"/%s\" % path\n                            proxy_domain = host.split(':')[0]\n                            _check_domain(proxy_domain, sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, packet)\n                    elif method == \"CONNECT\":\n                        if '/' in path:\n                            host, path = path.split('/', 1)\n                            path = \"/%s\" % path\n                        else:\n                            host, path = path, '/'\n                        if host.endswith(\":80\"):\n                            host = host[:-3]\n                        url = \"%s%s\" % (host, path)\n                        proxy_domain = host.split(':')[0]\n                        _check_domain(proxy_domain, sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, packet)\n\n                    if url is None:\n                        url = \"%s%s\" % (host, path)\n\n                    if config.USE_HEURISTICS:\n                        user_agent, result = None, None\n\n                        first_index = tcp_data.find(\"\\r\\nUser-Agent:\")\n                        if first_index >= 0:\n                            first_index = first_index + len(\"\\r\\nUser-Agent:\")\n                            last_index = tcp_data.find(\"\\r\\n\", first_index)\n                            if last_index >= 0:\n                                user_agent = tcp_data[first_index:last_index]\n                                user_agent = _urllib.parse.unquote(user_agent).strip()\n\n                        if user_agent:\n                            result = _result_cache.get((CACHE_TYPE.USER_AGENT, user_agent))\n                            if result is None:\n                                if re.search(WHITELIST_UA_REGEX, user_agent, re.I) is None:\n                                    match = re.search(SUSPICIOUS_UA_REGEX, user_agent)\n                                    if match and match.group(0):\n                                        def _(value):\n                                            return value.rstrip('\\\\').replace('(', \"\\\\(\").replace(')', \"\\\\)\")\n\n                                        parts = user_agent.split(match.group(0), 1)\n\n                                        if len(parts) > 1 and parts[0] and parts[-1]:\n                                            result = _result_cache[(CACHE_TYPE.USER_AGENT, user_agent)] = \"%s (%s)\" % (_(match.group(0)), _(user_agent))\n                                        else:\n                                            result = _result_cache[(CACHE_TYPE.USER_AGENT, user_agent)] = _(match.group(0)).join((\"(%s)\" if part else \"%s\") % _(part) for part in parts)\n                                if not result:\n                                    _result_cache[(CACHE_TYPE.USER_AGENT, user_agent)] = False\n\n                            if result:\n                                log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.UA, result, \"user agent (suspicious)\", \"(heuristic)\"), packet)\n\n                    if not _check_domain_whitelisted(host):\n                        path = path.replace(\"//\", '/')\n\n                        unquoted_path = _urllib.parse.unquote(path)\n                        unquoted_post_data = _urllib.parse.unquote(post_data or \"\")\n\n                        checks = [path.rstrip('/')]\n\n                        if '?' in path:\n                            checks.append(path.split('?')[0].rstrip('/'))\n\n                            if '=' in path:\n                                checks.append(path[:path.index('=') + 1])\n\n                            _ = re.sub(r\"(\\w+=)[^&=]+\", r\"\\g<1>\", path)\n                            if _ not in checks:\n                                checks.append(_)\n                                if _.count('/') > 1:\n                                    checks.append(\"/%s\" % _.split('/')[-1])\n                        elif post_data:\n                            checks.append(\"%s?%s\" % (path, unquoted_post_data.lower()))\n\n                        if checks[-1].count('/') > 1:\n                            checks.append(checks[-1][:checks[-1].rfind('/')])\n                            checks.append(checks[0][checks[0].rfind('/'):].split('?')[0])\n\n                        for check in filter(None, checks):\n                            for _ in (\"\", host):\n                                check = \"%s%s\" % (_, check)\n                                if check in trails:\n                                    if '?' not in path and '?' in check and post_data:\n                                        trail = \"%s(%s \\\\(%s %s\\\\))\" % (host, path, method, post_data.strip())\n                                        log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.HTTP, trail, trails[check][0], trails[check][1]))\n                                    else:\n                                        parts = url.split(check)\n                                        other = (\"(%s)\" % _ if _ else _ for _ in parts)\n                                        trail = check.join(other)\n                                        log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.URL, trail, trails[check][0], trails[check][1]))\n\n                                    return\n\n                        if \"%s/\" % host in trails:\n                            trail = \"%s/\" % host\n                            log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.URL, trail, trails[trail][0], trails[trail][1]))\n                            return\n\n                        if config.USE_HEURISTICS:\n                            match = re.search(r\"\\b(CF-Connecting-IP|True-Client-IP|X-Forwarded-For):\\s*([0-9.]+)\".encode(), packet, re.I)\n                            if match:\n                                src_ip = \"%s,%s\" % (src_ip, match.group(1))\n\n                            for char in SUSPICIOUS_HTTP_REQUEST_FORCE_ENCODE_CHARS:\n                                replacement = SUSPICIOUS_HTTP_REQUEST_FORCE_ENCODE_CHARS[char]\n                                path = path.replace(char, replacement)\n                                if post_data:\n                                    post_data = post_data.replace(char, replacement)\n\n                            if not any(_ in unquoted_path.lower() for _ in WHITELIST_HTTP_REQUEST_PATHS):\n                                if any(_ in unquoted_path for _ in SUSPICIOUS_HTTP_REQUEST_PRE_CONDITION):\n                                    found = _result_cache.get((CACHE_TYPE.PATH, unquoted_path))\n                                    if found is None:\n                                        for desc, regex in SUSPICIOUS_HTTP_REQUEST_REGEXES:\n                                            if re.search(regex, unquoted_path, re.I | re.DOTALL):\n                                                found = desc\n                                                break\n                                        _result_cache[(CACHE_TYPE.PATH, unquoted_path)] = found or \"\"\n                                    if found and not (\"data leakage\" in found and is_local(dst_ip)):\n                                        trail = \"%s(%s)\" % (host, path)\n                                        log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.URL, trail, \"%s (suspicious)\" % found, \"(heuristic)\"), packet)\n                                        return\n\n                                if any(_ in unquoted_post_data for _ in SUSPICIOUS_HTTP_REQUEST_PRE_CONDITION):\n                                    found = _result_cache.get((CACHE_TYPE.POST_DATA, unquoted_post_data))\n                                    if found is None:\n                                        for desc, regex in SUSPICIOUS_HTTP_REQUEST_REGEXES:\n                                            if re.search(regex, unquoted_post_data, re.I | re.DOTALL):\n                                                found = desc\n                                                break\n                                        _result_cache[(CACHE_TYPE.POST_DATA, unquoted_post_data)] = found or \"\"\n                                    if found:\n                                        trail = \"%s(%s \\\\(%s %s\\\\))\" % (host, path, method, post_data.strip())\n                                        log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.HTTP, trail, \"%s (suspicious)\" % found, \"(heuristic)\"), packet)\n                                        return\n\n                            if '.' in path:\n                                _ = _urllib.parse.urlparse(\"http://%s\" % url)  # dummy scheme\n                                path = path.lower()\n                                filename = _.path.split('/')[-1]\n                                name, extension = os.path.splitext(filename)\n                                trail = \"%s(%s)\" % (host, path)\n                                if extension in SUSPICIOUS_DIRECT_DOWNLOAD_EXTENSIONS and not is_local(dst_ip) and not any(_ in path for _ in WHITELIST_DIRECT_DOWNLOAD_KEYWORDS) and '=' not in _.query and len(name) < 10:\n                                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.URL, trail, \"direct %s download (suspicious)\" % extension, \"(heuristic)\"), packet)\n                                else:\n                                    for desc, regex in SUSPICIOUS_HTTP_PATH_REGEXES:\n                                        if re.search(regex, filename, re.I):\n                                            log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.URL, trail, \"%s (suspicious)\" % desc, \"(heuristic)\"), packet)\n                                            break\n\n        elif protocol == socket.IPPROTO_UDP:  # UDP\n            _ = ip_data[iph_length:iph_length + 4]\n            if len(_) < 4:\n                return\n\n            src_port, dst_port = struct.unpack(\"!HH\", _)\n\n            _ = _last_udp\n            _last_udp = (sec, src_ip, src_port, dst_ip, dst_port)\n            if _ == _last_udp:  # skip bursts\n                return\n\n            if src_port != 53 and dst_port != 53:  # not DNS\n                if dst_ip in trails:\n                    trail = dst_ip\n                elif src_ip in trails:\n                    trail = src_ip\n                else:\n                    trail = None\n\n                if trail:\n                    _ = _last_logged_udp\n                    _last_logged_udp = _last_udp\n                    if _ != _last_logged_udp:\n                        if not any(_ in trails[trail][0] for _ in (\"malware\",)):\n                            log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.UDP, TRAIL.IP, trail, trails[trail][0], trails[trail][1]), packet)\n\n            else:\n                dns_data = ip_data[iph_length + 8:]\n\n                # Reference: http://www.ccs.neu.edu/home/amislove/teaching/cs4700/fall09/handouts/project1-primer.pdf\n                if len(dns_data) > 6:\n                    qdcount = struct.unpack(\"!H\", dns_data[4:6])[0]\n                    if qdcount > 0:\n                        offset = 12\n                        query = \"\"\n\n                        while len(dns_data) > offset:\n                            length = ord(dns_data[offset:offset + 1])\n                            if not length:\n                                query = query[:-1]\n                                break\n                            query += get_text(dns_data[offset + 1:offset + length + 1]) + '.'\n                            offset += length + 1\n\n                        query = query.lower()\n\n                        if not query or re.search(VALID_DNS_NAME_REGEX, query) is None or any(_ in query for _ in (\".intranet.\",)) or query.split('.')[-1] in IGNORE_DNS_QUERY_SUFFIXES:\n                            return\n\n                        parts = query.split('.')\n\n                        if ord(dns_data[2:3]) & 0xfa == 0x00:  # standard query (both recursive and non-recursive)\n                            type_, class_ = struct.unpack(\"!HH\", dns_data[offset + 1:offset + 5])\n\n                            if len(parts) > 2:\n                                if len(parts) > 3 and len(parts[-2]) <= 3:\n                                    domain = '.'.join(parts[-3:])\n                                else:\n                                    domain = '.'.join(parts[-2:])\n\n                                if not _check_domain_whitelisted(domain):  # e.g. <hash>.hashserver.cs.trendmicro.com\n                                    if (sec - (_subdomains_sec or 0)) > HOURLY_SECS:\n                                        _subdomains.clear()\n                                        _dns_exhausted_domains.clear()\n                                        _subdomains_sec = sec\n\n                                    subdomains = _subdomains.get(domain)\n\n                                    if not subdomains:\n                                        subdomains = _subdomains[domain] = _set()\n                                        subdomains._start = sec\n\n                                    if not re.search(r\"\\A\\d+\\-\\d+\\-\\d+\\-\\d+\\Z\", parts[0]):\n                                        if sec - subdomains._start > 60:\n                                            subdomains._start = sec\n                                            subdomains.clear()\n                                        elif len(subdomains) < DNS_EXHAUSTION_THRESHOLD:\n                                            subdomains.add('.'.join(parts[:-2]))\n                                        else:\n                                            trail = \"(%s).%s\" % ('.'.join(parts[:-2]), '.'.join(parts[-2:]))\n                                            if re.search(r\"bl\\b\", trail) is None:                                               # generic check for DNSBLs\n                                                if not any(_ in subdomains for _ in LOCAL_SUBDOMAIN_LOOKUPS):                   # generic check for local DNS resolutions\n                                                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.UDP, TRAIL.DNS, trail, \"potential dns exhaustion (suspicious)\", \"(heuristic)\"), packet)\n                                                    _dns_exhausted_domains.add(domain)\n\n                                            return\n\n                            # Reference: http://en.wikipedia.org/wiki/List_of_DNS_record_types\n                            if type_ not in (12, 28) and class_ == 1:  # Type not in (PTR, AAAA), Class IN\n                                if addr_port(dst_ip, dst_port) in trails:\n                                    trail = addr_port(dst_ip, dst_port)\n                                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.UDP, TRAIL.IPORT, \"%s (%s)\" % (dst_ip, query), trails[trail][0], trails[trail][1]), packet)\n                                elif dst_ip in trails:\n                                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.UDP, TRAIL.IP, \"%s (%s)\" % (dst_ip, query), trails[dst_ip][0], trails[dst_ip][1]), packet)\n                                elif src_ip in trails:\n                                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.UDP, TRAIL.IP, src_ip, trails[src_ip][0], trails[src_ip][1]), packet)\n\n                                _check_domain(query, sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.UDP, packet)\n\n                        elif config.USE_HEURISTICS:\n                            if ord(dns_data[2:3]) & 0x80:  # standard response\n                                if ord(dns_data[3:4]) == 0x80:  # recursion available, no error\n                                    _ = offset + 5\n                                    try:\n                                        while _ < len(dns_data):\n                                            if ord(dns_data[_:_ + 1]) & 0xc0 != 0 and dns_data[_ + 2] == \"\\00\" and dns_data[_ + 3] == \"\\x01\":  # Type A\n                                                break\n                                            else:\n                                                _ += 12 + struct.unpack(\"!H\", dns_data[_ + 10: _ + 12])[0]\n\n                                        _ = dns_data[_ + 12:_ + 16]\n                                        if _:\n                                            answer = socket.inet_ntoa(_)\n                                            if answer in trails and not _check_domain_whitelisted(query):\n                                                _ = trails[answer]\n                                                if \"sinkhole\" in _[0]:\n                                                    trail = \"(%s).%s\" % ('.'.join(parts[:-1]), '.'.join(parts[-1:]))\n                                                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.UDP, TRAIL.DNS, trail, \"sinkholed by %s (malware)\" % _[0].split(\" \")[1], \"(heuristic)\"), packet)  # (e.g. kitro.pl, devomchart.com, jebena.ananikolic.su, vuvet.cn)\n                                                elif \"parking\" in _[0]:\n                                                    trail = \"(%s).%s\" % ('.'.join(parts[:-1]), '.'.join(parts[-1:]))\n                                                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.UDP, TRAIL.DNS, trail, \"parked site (suspicious)\", \"(heuristic)\"), packet)\n                                    except IndexError:\n                                        pass\n\n                                elif ord(dns_data[3:4]) == 0x83:  # recursion available, no such name\n                                    if '.'.join(parts[-2:]) not in _dns_exhausted_domains and not _check_domain_whitelisted(query) and not _check_domain_member(query, trails):\n                                        if parts[-1].isdigit():\n                                            return\n\n                                        if not (len(parts) > 4 and all(_.isdigit() and int(_) < 256 for _ in parts[:4])):  # generic check for DNSBL IP lookups\n                                            if not is_local(dst_ip):  # prevent FPs caused by local queries\n                                                for _ in filter(None, (query, \"*.%s\" % '.'.join(parts[-2:]) if query.count('.') > 1 else None)):\n                                                    if _ not in NO_SUCH_NAME_COUNTERS or NO_SUCH_NAME_COUNTERS[_][0] != sec // 3600:\n                                                        NO_SUCH_NAME_COUNTERS[_] = [sec // 3600, 1, set()]\n                                                    else:\n                                                        NO_SUCH_NAME_COUNTERS[_][1] += 1\n                                                        NO_SUCH_NAME_COUNTERS[_][2].add(query)\n\n                                                        if NO_SUCH_NAME_COUNTERS[_][1] > NO_SUCH_NAME_PER_HOUR_THRESHOLD:\n                                                            if _.startswith(\"*.\"):\n                                                                trail = \"%s%s\" % (\"(%s)\" % ','.join(item.replace(_[1:], \"\") for item in NO_SUCH_NAME_COUNTERS[_][2]), _[1:])\n                                                                if not any(subdomain in trail for subdomain in LOCAL_SUBDOMAIN_LOOKUPS):  # generic check for local DNS resolutions\n                                                                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.UDP, TRAIL.DNS, trail, \"excessive no such domain (suspicious)\", \"(heuristic)\"), packet)\n                                                                for item in NO_SUCH_NAME_COUNTERS[_][2]:\n                                                                    try:\n                                                                        del NO_SUCH_NAME_COUNTERS[item]\n                                                                    except KeyError:\n                                                                        pass\n                                                            else:\n                                                                log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.UDP, TRAIL.DNS, _, \"excessive no such domain (suspicious)\", \"(heuristic)\"), packet)\n\n                                                            try:\n                                                                del NO_SUCH_NAME_COUNTERS[_]\n                                                            except KeyError:\n                                                                pass\n\n                                                            break\n\n                                            if len(parts) == 2 and parts[0] and '-' not in parts[0]:\n                                                part = parts[0]\n                                                trail = \"(%s).%s\" % (parts[0], parts[1])\n\n                                                result = _result_cache.get(part)\n\n                                                if result is None:\n                                                    # Reference: https://github.com/exp0se/dga_detector\n                                                    probabilities = (float(part.count(c)) / len(part) for c in set(_ for _ in part))\n                                                    entropy = -sum(p * math.log(p) / math.log(2.0) for p in probabilities)\n                                                    if entropy > SUSPICIOUS_DOMAIN_ENTROPY_THRESHOLD:\n                                                        result = \"entropy threshold no such domain (suspicious)\"\n\n                                                    if not result:\n                                                        if sum(_ in CONSONANTS for _ in part) > SUSPICIOUS_DOMAIN_CONSONANT_THRESHOLD:\n                                                            result = \"consonant threshold no such domain (suspicious)\"\n\n                                                    _result_cache[part] = result or False\n\n                                                if result:\n                                                    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.UDP, TRAIL.DNS, trail, result, \"(heuristic)\"), packet)\n\n        elif protocol in IPPROTO_LUT:  # non-TCP/UDP (e.g. ICMP)\n            if protocol == socket.IPPROTO_ICMP:\n                if ord(ip_data[iph_length:iph_length + 1]) != 0x08:  # Non-echo request\n                    return\n            elif protocol == socket.IPPROTO_ICMPV6:\n                if ord(ip_data[iph_length:iph_length + 1]) != 0x80:  # Non-echo request\n                    return\n\n            if dst_ip in trails:\n                log_event((sec, usec, src_ip, '-', dst_ip, '-', IPPROTO_LUT[protocol], TRAIL.IP, dst_ip, trails[dst_ip][0], trails[dst_ip][1]), packet)\n            elif src_ip in trails:\n                log_event((sec, usec, src_ip, '-', dst_ip, '-', IPPROTO_LUT[protocol], TRAIL.IP, src_ip, trails[src_ip][0], trails[src_ip][1]), packet)\n\n    except struct.error:\n        pass\n\n    except Exception:\n        if config.SHOW_DEBUG:\n            traceback.print_exc()\n\ndef init():\n    \"\"\"\n    Performs sensor initialization\n    \"\"\"\n\n    global _multiprocessing\n\n    try:\n        import multiprocessing\n\n        if config.PROCESS_COUNT > 1 and not config.profile:\n            _multiprocessing = multiprocessing\n    except (ImportError, OSError, NotImplementedError):\n        pass\n\n    def update_timer():\n        retries = 0\n        if not config.offline:\n            while retries < CHECK_CONNECTION_MAX_RETRIES and not check_connection():\n                sys.stdout.write(\"[!] can't update because of lack of Internet connection (waiting...\" if not retries else '.')\n                sys.stdout.flush()\n                time.sleep(10)\n                retries += 1\n\n            if retries:\n                print(\")\")\n\n        if config.offline or retries == CHECK_CONNECTION_MAX_RETRIES:\n            if retries == CHECK_CONNECTION_MAX_RETRIES:\n                print(\"[x] going to continue without online update\")\n            _ = update_trails(offline=True)\n        else:\n            _ = update_trails()\n            update_ipcat()\n\n        if _:\n            trails.clear()\n            trails.update(_)\n        elif not trails:\n            _ = load_trails()\n            trails.update(_)\n\n        _regex = \"\"\n        for trail in trails:\n            if \"static\" in trails[trail][1]:\n                if re.search(r\"[\\].][*+]|\\[[a-z0-9_.\\-]+\\]\", trail, re.I):\n                    try:\n                        re.compile(trail)\n                    except re.error:\n                        pass\n                    else:\n                        if re.escape(trail) != trail:\n                            index = _regex.count(\"(?P<g\")\n                            if index < 100:  # Reference: https://stackoverflow.com/questions/478458/python-regular-expressions-with-more-than-100-groups\n                                _regex += \"|(?P<g%s>%s)\" % (index, trail)\n\n        trails._regex = _regex.strip('|')\n\n        thread = threading.Timer(config.UPDATE_PERIOD, update_timer)\n        thread.daemon = True\n        thread.start()\n\n    create_log_directory()\n    get_error_log_handle()\n\n    msg = \"[i] using '%s' for trail storage\" % config.TRAILS_FILE\n    if os.path.isfile(config.TRAILS_FILE):\n        mtime = time.gmtime(os.path.getmtime(config.TRAILS_FILE))\n        msg += \" (last modification: '%s')\" % time.strftime(HTTP_TIME_FORMAT, mtime)\n\n    print(msg)\n\n    update_timer()\n\n    if not config.DISABLE_CHECK_SUDO and check_sudo() is False:\n        sys.exit(\"[!] please run '%s' with root privileges\" % __file__)\n\n    if config.plugins:\n        config.plugin_functions = []\n        for plugin in re.split(r\"[,;]\", config.plugins):\n            plugin = plugin.strip()\n            found = False\n\n            for _ in (plugin, os.path.join(\"plugins\", plugin), os.path.join(\"plugins\", \"%s.py\" % plugin)):\n                if os.path.isfile(_):\n                    plugin = _\n                    found = True\n                    break\n\n            if not found:\n                sys.exit(\"[!] plugin script '%s' not found\" % plugin)\n            else:\n                dirname, filename = os.path.split(plugin)\n                dirname = os.path.abspath(dirname)\n                if not os.path.exists(os.path.join(dirname, '__init__.py')):\n                    sys.exit(\"[!] empty file '__init__.py' required inside directory '%s'\" % dirname)\n\n                if not filename.endswith(\".py\"):\n                    sys.exit(\"[!] plugin script '%s' should have an extension '.py'\" % filename)\n\n                if dirname not in sys.path:\n                    sys.path.insert(0, dirname)\n\n                try:\n                    module = __import__(filename[:-3])\n                except (ImportError, SyntaxError) as msg:\n                    sys.exit(\"[!] unable to import plugin script '%s' (%s)\" % (filename, msg))\n\n                found = False\n                for name, function in inspect.getmembers(module, inspect.isfunction):\n                    if name == \"plugin\" and not set(inspect.getargspec(function).args) & set((\"event_tuple', 'packet\")):\n                        found = True\n                        config.plugin_functions.append(function)\n                        function.__name__ = module.__name__\n\n                if not found:\n                    sys.exit(\"[!] missing function 'plugin(event_tuple, packet)' in plugin script '%s'\" % filename)\n\n    if config.pcap_file:\n        for _ in config.pcap_file.split(','):\n            _caps.append(pcapy.open_offline(_))\n    else:\n        interfaces = set(_.strip() for _ in config.MONITOR_INTERFACE.split(','))\n\n        try:\n            devices = pcapy.findalldevs()\n        except:\n            devices = []\n\n        if (config.MONITOR_INTERFACE or \"\").lower() == \"any\":\n            if devices and (IS_WIN or \"any\" not in devices):\n                print(\"[x] virtual interface 'any' missing. Replacing it with all interface names\")\n                interfaces = devices\n            else:\n                print(\"[?] in case of any problems with packet capture on virtual interface 'any', please put all monitoring interfaces to promiscuous mode manually (e.g. 'sudo ifconfig eth0 promisc')\")\n\n        for interface in interfaces:\n            if interface.lower() != \"any\" and devices and re.sub(r\"(?i)\\Anetmap:\", \"\", interface) not in devices:\n                hint = \"[?] available interfaces: '%s'\" % \",\".join(devices)\n                sys.exit(\"[!] interface '%s' not found\\n%s\" % (interface, hint))\n\n            print(\"[i] opening interface '%s'\" % interface)\n            try:\n                _caps.append(pcapy.open_live(interface, SNAP_LEN, True, CAPTURE_TIMEOUT))\n            except (socket.error, pcapy.PcapError):\n                if \"permitted\" in str(sys.exc_info()[1]):\n                    sys.exit(\"[!] permission problem occurred ('%s')\" % sys.exc_info()[1])\n                elif \"No such device\" in str(sys.exc_info()[1]):\n                    sys.exit(\"[!] no such device '%s'\" % interface)\n                else:\n                    raise\n\n    if config.LOG_SERVER and ':' not in config.LOG_SERVER:\n        sys.exit(\"[!] invalid configuration value for 'LOG_SERVER' ('%s')\" % config.LOG_SERVER)\n\n    if config.SYSLOG_SERVER and not len(config.SYSLOG_SERVER.split(':')) == 2:\n        sys.exit(\"[!] invalid configuration value for 'SYSLOG_SERVER' ('%s')\" % config.SYSLOG_SERVER)\n\n    if config.LOGSTASH_SERVER and not len(config.LOGSTASH_SERVER.split(':')) == 2:\n        sys.exit(\"[!] invalid configuration value for 'LOGSTASH_SERVER' ('%s')\" % config.LOGSTASH_SERVER)\n\n    if config.REMOTE_SEVERITY_REGEX:\n        try:\n            re.compile(config.REMOTE_SEVERITY_REGEX)\n        except re.error:\n            sys.exit(\"[!] invalid configuration value for 'REMOTE_SEVERITY_REGEX' ('%s')\" % config.REMOTE_SEVERITY_REGEX)\n\n    if config.CAPTURE_FILTER:\n        print(\"[i] setting capture filter '%s'\" % config.CAPTURE_FILTER)\n        for _cap in _caps:\n            try:\n                _cap.setfilter(config.CAPTURE_FILTER)\n            except:\n                pass\n\n    if _multiprocessing:\n        _init_multiprocessing()\n\n    if not IS_WIN and not config.DISABLE_CPU_AFFINITY:\n        try:\n            try:\n                mod = int(subprocess.check_output(\"grep -c ^processor /proc/cpuinfo\", stderr=subprocess.STDOUT, shell=True).strip())\n                used = subprocess.check_output(\"for pid in $(ps aux | grep python | grep sensor.py | grep -E -o 'root[ ]*[0-9]*' | tr -d '[:alpha:] '); do schedtool $pid; done | grep -E -o 'AFFINITY .*' | cut -d ' ' -f 2 | grep -v 0xf\", stderr=subprocess.STDOUT, shell=True).strip().split('\\n')\n                max_used = max(int(_, 16) for _ in used)\n                affinity = max(1, (max_used << 1) % 2 ** mod)\n            except:\n                affinity = 1\n            p = subprocess.Popen(\"schedtool -n -2 -M 2 -p 10 -a 0x%02x %d\" % (affinity, os.getpid()), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            _, stderr = p.communicate()\n            if \"not found\" in stderr:\n                msg, _ = \"[?] please install 'schedtool' for better CPU scheduling\", platform.linux_distribution()[0].lower()\n                for distro, install in {(\"fedora\", \"centos\"): \"sudo yum install schedtool\", (\"debian\", \"ubuntu\"): \"sudo apt-get install schedtool\"}.items():\n                    if _ in distro:\n                        msg += \" (e.g. '%s')\" % install\n                        break\n                print(msg)\n        except:\n            pass\n\ndef _init_multiprocessing():\n    \"\"\"\n    Inits worker processes used in multiprocessing mode\n    \"\"\"\n\n    global _buffer\n    global _multiprocessing\n    global _n\n\n    if _multiprocessing:\n        print(\"[i] preparing capture buffer...\")\n        try:\n            _buffer = mmap.mmap(-1, config.CAPTURE_BUFFER)  # http://www.alexonlinux.com/direct-io-in-python\n\n            _ = b\"\\x00\" * MMAP_ZFILL_CHUNK_LENGTH\n            for i in xrange(config.CAPTURE_BUFFER // MMAP_ZFILL_CHUNK_LENGTH):\n                _buffer.write(_)\n            _buffer.seek(0)\n        except KeyboardInterrupt:\n            raise\n        except:\n            sys.exit(\"[!] unable to allocate network capture buffer. Please adjust value of 'CAPTURE_BUFFER'\")\n\n        _n = _multiprocessing.Value('L', lock=False)\n\n        try:\n            for i in xrange(config.PROCESS_COUNT - 1):\n                process = _multiprocessing.Process(target=worker, name=str(i), args=(_buffer, _n, i, config.PROCESS_COUNT - 1, _process_packet))\n                process.daemon = True\n                process.start()\n        except TypeError:   # Note: https://github.com/stamparm/maltrail/issues/11823\n            _buffer = None\n            _multiprocessing = None\n        else:\n            print(\"[i] created %d more processes (out of total %d)\" % (config.PROCESS_COUNT - 1, config.PROCESS_COUNT))\n\ndef monitor():\n    \"\"\"\n    Sniffs/monitors given capturing interface\n    \"\"\"\n\n    print(\"[^] running...\")\n\n    def packet_handler(datalink, header, packet):\n        global _count\n\n        ip_offset = None\n        try:\n            dlt_offset = DLT_OFFSETS[datalink]\n        except KeyError:\n            log_error(\"Received unexpected datalink (%d)\" % datalink, single=True)\n            return\n\n        try:\n            if datalink == pcapy.DLT_RAW:\n                ip_offset = dlt_offset\n\n            elif datalink == pcapy.DLT_PPP:\n                if packet[2:4] in (b\"\\x00\\x21\", b\"\\x00\\x57\"):  # (IPv4, IPv6)\n                    ip_offset = dlt_offset\n\n            elif datalink == pcapy.DLT_NULL:\n                if packet[0:4] in (b\"\\x02\\x00\\x00\\x00\", b\"\\x23\\x00\\x00\\x00\"):  # (IPv4, IPv6)\n                    ip_offset = dlt_offset\n\n            elif dlt_offset >= 2:\n                if packet[dlt_offset - 2:dlt_offset] == b\"\\x81\\x00\":  # VLAN\n                    dlt_offset += 4\n                if packet[dlt_offset - 2:dlt_offset] in (b\"\\x08\\x00\", b\"\\x86\\xdd\"):  # (IPv4, IPv6)\n                    ip_offset = dlt_offset\n\n        except IndexError:\n            pass\n\n        if ip_offset is None:\n            return\n\n        try:\n            if six.PY3:  # https://github.com/helpsystems/pcapy/issues/37#issuecomment-530795813\n                sec, usec = [int(_) for _ in (\"%.6f\" % time.time()).split('.')]\n            else:\n                sec, usec = header.getts()\n\n            if _multiprocessing:\n                block = struct.pack(\"=III\", sec, usec, ip_offset) + packet\n\n                if _locks.count:\n                    _locks.count.acquire()\n\n                write_block(_buffer, _count, block)\n                _n.value = _count = _count + 1\n\n                if _locks.count:\n                    _locks.count.release()\n            else:\n                _process_packet(packet, sec, usec, ip_offset)\n\n        except socket.timeout:\n            pass\n\n    try:\n        def _(_cap):\n            global _done_count\n\n            datalink = _cap.datalink()\n\n\n#\n# NOTE: currently an issue with pcapy-png and loop()\n#\n#            if six.PY3 and not config.pcap_file:  # https://github.com/helpsystems/pcapy/issues/37#issuecomment-530795813\n#                def _loop_handler(header, packet):\n#                    packet_handler(datalink, header, packet)\n#\n#                _cap.loop(-1, _loop_handler)\n#            else:\n\n            while True:\n                success = False\n                try:\n                    (header, packet) = _cap.next()\n                    if header is not None:\n                        success = True\n                        packet_handler(datalink, header, packet)\n                    elif config.pcap_file:\n                        with _done_lock:\n                            _done_count += 1\n                        break\n                except (pcapy.PcapError, socket.timeout):\n                    pass\n                except SystemError as ex:\n                    if \"PY_SSIZE_T_CLEAN\" in str(ex):\n                        sys.exit(\"[!] seems that you are not using pcapy-ng (https://pypi.org/project/pcapy-ng/)\")\n                    else:\n                        raise\n\n                if not success:\n                    time.sleep(REGULAR_SENSOR_SLEEP_TIME)\n\n        if config.profile and len(_caps) == 1:\n            print(\"[=] will store profiling results to '%s'...\" % config.profile)\n            _(_caps[0])\n        else:\n            if len(_caps) > 1:\n                if _multiprocessing:\n                    _locks.count = threading.Lock()\n                _locks.connect_sec = threading.Lock()\n\n            for _cap in _caps:\n                threading.Thread(target=_, args=(_cap,)).start()\n\n            while _caps and not _done_count == (config.pcap_file or \"\").count(',') + 1:\n                time.sleep(1)\n\n        if not config.pcap_file:\n            print(\"[i] all capturing interfaces closed\")\n    except SystemError as ex:\n        if \"error return without\" in str(ex):\n            print(\"\\r[x] stopping (Ctrl-C pressed)\")\n        else:\n            raise\n    except KeyboardInterrupt:\n        print(\"\\r[x] stopping (Ctrl-C pressed)\")\n    finally:\n        print(\"\\r[i] cleaning up...\")\n\n        if _multiprocessing:\n            try:\n                for _ in xrange(config.PROCESS_COUNT - 1):\n                    write_block(_buffer, _n.value, b\"\", BLOCK_MARKER.END)\n                    _n.value = _n.value + 1\n                while _multiprocessing.active_children():\n                    time.sleep(REGULAR_SENSOR_SLEEP_TIME)\n            except KeyboardInterrupt:\n                pass\n\n        if config.pcap_file:\n            flush_condensed_events(True)\n\ndef main():\n    for i in xrange(1, len(sys.argv)):\n        if sys.argv[i] == \"-q\":\n            sys.stdout = open(os.devnull, 'w')\n        if sys.argv[i] == \"-i\":\n            for j in xrange(i + 2, len(sys.argv)):\n                value = sys.argv[j]\n                if os.path.isfile(value):\n                    sys.argv[i + 1] += \",%s\" % value\n                    sys.argv[j] = ''\n                else:\n                    break\n\n    print(\"%s (sensor) #v%s {%s}\\n\" % (NAME, VERSION, HOMEPAGE))\n\n    if \"--version\" in sys.argv:\n        raise SystemExit\n\n    parser = optparse.OptionParser(version=VERSION)\n    parser.add_option(\"-c\", dest=\"config_file\", default=CONFIG_FILE, help=\"configuration file (default: '%s')\" % os.path.split(CONFIG_FILE)[-1])\n    parser.add_option(\"-r\", dest=\"pcap_file\", help=\"pcap file for offline analysis\")\n    parser.add_option(\"-p\", dest=\"plugins\", help=\"plugin(s) to be used per event\")\n    parser.add_option(\"-q\", \"--quiet\", dest=\"quiet\", action=\"store_true\", help=\"turn off regular output\")\n    parser.add_option(\"--console\", dest=\"console\", action=\"store_true\", help=\"print events to console\")\n    parser.add_option(\"--offline\", dest=\"offline\", action=\"store_true\", help=\"disable (online) trail updates\")\n    parser.add_option(\"--debug\", dest=\"debug\", action=\"store_true\", help=optparse.SUPPRESS_HELP)\n    parser.add_option(\"--profile\", dest=\"profile\", help=optparse.SUPPRESS_HELP)\n\n    patch_parser(parser)\n\n    options, _ = parser.parse_args()\n\n    print(\"[*] starting @ %s\\n\" % time.strftime(\"%X /%Y-%m-%d/\"))\n\n    read_config(options.config_file)\n\n    for option in dir(options):\n        if isinstance(getattr(options, option), (six.string_types, bool)) and not option.startswith('_'):\n            config[option] = getattr(options, option)\n\n    if options.debug:\n        config.console = True\n        config.PROCESS_COUNT = 1\n        config.SHOW_DEBUG = True\n\n    if options.pcap_file:\n        if options.pcap_file == '-':\n            print(\"[i] using STDIN\")\n        else:\n            for _ in options.pcap_file.split(','):\n                if not os.path.isfile(_):\n                    sys.exit(\"[!] missing pcap file '%s'\" % _)\n\n            print(\"[i] using pcap file(s) '%s'\" % options.pcap_file)\n\n    if not config.DISABLE_CHECK_SUDO and not check_sudo():\n        sys.exit(\"[!] please run '%s' with root privileges\" % __file__)\n\n    try:\n        init()\n        if config.profile:\n            open(config.profile, \"w+b\").write(\"\")\n            cProfile.run(\"monitor()\", config.profile)\n        else:\n            monitor()\n    except KeyboardInterrupt:\n        print(\"\\r[x] stopping (Ctrl-C pressed)\")\n\nif __name__ == \"__main__\":\n    code = 0\n\n    try:\n        main()\n    except SystemExit as ex:\n        if isinstance(get_ex_message(ex), six.string_types) and get_ex_message(ex).strip('0'):\n            print(get_ex_message(ex))\n            code = 1\n    except IOError:\n        log_error(\"\\n\\n[!] session abruptly terminated\\n[?] (hint: \\\"https://stackoverflow.com/a/20997655\\\")\")\n        code = 1\n    except Exception:\n        msg = \"\\r[!] unhandled exception occurred ('%s')\" % sys.exc_info()[1]\n        msg += \"\\n[x] please report the following details at 'https://github.com/stamparm/maltrail/issues':\\n---\\n'%s'\\n---\" % traceback.format_exc()\n        log_error(\"\\n\\n%s\" % msg.replace(\"\\r\", \"\"))\n\n        print(msg)\n        code = 1\n    finally:\n        if not any(_ in sys.argv for _ in (\"--version\", \"-h\", \"--help\")):\n            print(\"\\n[*] ending @ %s\" % time.strftime(\"%X /%Y-%m-%d/\"))\n\n        os._exit(code)\n"
        },
        {
          "name": "server.py",
          "type": "blob",
          "size": 4.9814453125,
          "content": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2014-2025 Maltrail developers (https://github.com/stamparm/maltrail/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function  # Requires: Python >= 2.6\n\nimport sys\n\nsys.dont_write_bytecode = True\n\nimport optparse\nimport os\nimport platform\nimport threading\nimport time\nimport traceback\n\nfrom core.common import check_connection\nfrom core.common import check_sudo\nfrom core.common import get_ex_message\nfrom core.common import patch_parser\nfrom core.httpd import start_httpd\nfrom core.log import create_log_directory\nfrom core.log import log_error\nfrom core.log import start_logd\nfrom core.settings import config\nfrom core.settings import read_config\nfrom core.settings import CHECK_CONNECTION_MAX_RETRIES\nfrom core.settings import CONFIG_FILE\nfrom core.settings import HOMEPAGE\nfrom core.settings import IS_WIN\nfrom core.settings import NAME\nfrom core.settings import VERSION\nfrom core.update import update_ipcat\nfrom core.update import update_trails\nfrom thirdparty import six\n\ndef main():\n    print(\"%s (server) #v%s {%s}\\n\" % (NAME, VERSION, HOMEPAGE))\n\n    if \"--version\" in sys.argv:\n        raise SystemExit\n\n    parser = optparse.OptionParser(version=VERSION)\n    parser.add_option(\"-c\", dest=\"config_file\", default=CONFIG_FILE, help=\"configuration file (default: '%s')\" % os.path.split(CONFIG_FILE)[-1])\n    parser.add_option(\"--debug\", dest=\"debug\", action=\"store_true\", help=optparse.SUPPRESS_HELP)\n\n    patch_parser(parser)\n\n    options, _ = parser.parse_args()\n\n    print(\"[*] starting @ %s\\n\" % time.strftime(\"%X /%Y-%m-%d/\"))\n\n    read_config(options.config_file)\n\n    if options.debug:\n        config.SHOW_DEBUG = True\n\n    if six.PY2 and config.USE_SSL:\n        try:\n            __import__(\"OpenSSL\")\n        except ImportError:\n            if IS_WIN:\n                sys.exit(\"[!] please install 'pyopenssl' (e.g. 'pip install pyopenssl')\")\n            else:\n                msg = \"[!] please install 'pyopenssl'\"\n\n                for distros, install in {(\"fedora\", \"centos\"): \"sudo yum install pyOpenSSL\", (\"debian\", \"ubuntu\"): \"sudo apt-get install python-openssl\"}.items():\n                    for distro in distros:\n                        if distro in (platform.uname()[3] or \"\").lower():\n                            msg += \" (e.g. '%s')\" % install\n                            break\n\n                sys.exit(msg)\n\n        if not config.SSL_PEM or not os.path.isfile(config.SSL_PEM):\n            hint = \"openssl req -new -x509 -keyout %s -out %s -days 365 -nodes -subj '/O=%s CA/C=EU'\" % (config.SSL_PEM or \"server.pem\", config.SSL_PEM or \"server.pem\", NAME)\n            sys.exit(\"[!] invalid configuration value for 'SSL_PEM' ('%s')\\n[?] (hint: \\\"%s\\\")\" % (config.SSL_PEM, hint))\n\n    def update_timer():\n        retries = 0\n        while retries < CHECK_CONNECTION_MAX_RETRIES and not check_connection():\n            sys.stdout.write(\"[!] can't update because of lack of Internet connection (waiting...\" if not retries else '.')\n            sys.stdout.flush()\n            time.sleep(10)\n            retries += 1\n\n        if retries:\n            print(\")\")\n\n        if retries == CHECK_CONNECTION_MAX_RETRIES:\n            print(\"[x] going to continue without online update\")\n            _ = update_trails(offline=True)\n        else:\n            _ = update_trails()\n            update_ipcat()\n\n        thread = threading.Timer(config.UPDATE_PERIOD, update_timer)\n        thread.daemon = True\n        thread.start()\n\n    if config.UDP_ADDRESS and config.UDP_PORT:\n        if config.UDP_PORT <= 1024 and not config.DISABLE_CHECK_SUDO and check_sudo() is False:\n            sys.exit(\"[!] please run '%s' with root privileges when using 'UDP_ADDRESS' configuration value\" % __file__)\n\n        create_log_directory()\n        start_logd(address=config.UDP_ADDRESS, port=config.UDP_PORT, join=False)\n\n    try:\n        if config.USE_SERVER_UPDATE_TRAILS:\n            update_timer()\n\n        start_httpd(address=config.HTTP_ADDRESS, port=config.HTTP_PORT, pem=config.SSL_PEM if config.USE_SSL else None, join=True)\n    except KeyboardInterrupt:\n        print(\"\\r[x] stopping (Ctrl-C pressed)\")\n\nif __name__ == \"__main__\":\n    code = 0\n\n    try:\n        main()\n    except SystemExit as ex:\n        if isinstance(get_ex_message(ex), six.string_types) and get_ex_message(ex).strip('0'):\n            print(get_ex_message(ex))\n            code = 1\n    except IOError:\n        log_error(\"\\n\\n[!] session abruptly terminated\\n[?] (hint: \\\"https://stackoverflow.com/a/20997655\\\")\")\n        code = 1\n    except Exception:\n        msg = \"\\r[!] unhandled exception occurred ('%s')\" % sys.exc_info()[1]\n        msg += \"\\n[x] please report the following details at 'https://github.com/stamparm/maltrail/issues':\\n---\\n'%s'\\n---\" % traceback.format_exc()\n        log_error(\"\\n\\n%s\" % msg.replace(\"\\r\", \"\"))\n\n        print(msg)\n        code = 1\n    finally:\n        if not any(_ in sys.argv for _ in (\"--version\", \"-h\", \"--help\")):\n            print(\"\\n[*] ending @ %s\" % time.strftime(\"%X /%Y-%m-%d/\"))\n\n        os._exit(code)\n"
        },
        {
          "name": "thirdparty",
          "type": "tree",
          "content": null
        },
        {
          "name": "trails",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}