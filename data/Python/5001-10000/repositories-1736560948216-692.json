{
  "metadata": {
    "timestamp": 1736560948216,
    "page": 692,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "martinblech/xmltodict",
      "stars": 5545,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3017578125,
          "content": "*.py[cod]\n\n# C extensions\n*.so\n\n# Packages\n*.egg\n*.egg-info\ndist\nbuild\neggs\nparts\nbin\nvar\nsdist\ndevelop-eggs\n.installed.cfg\nlib\nlib64\n\n# Installer logs\npip-log.txt\n\n# Unit test / coverage reports\n.coverage\n.tox\nnosetests.xml\n\n#Translations\n*.mo\n\n#Mr Developer\n.mr.developer.cfg\n\n#setuptools MANIFEST\nMANIFEST\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1875,
          "content": "language: python\n\npython:\n  - \"3.6\"\n  - \"3.7\"\n  - \"3.8\"\n  - \"3.9\"\n  - \"3.10\"\n  - \"3.11\"\n  - \"3.12\"\n  - \"3.13\"\n  - \"pypy\"\n\ninstall: pip install nose2\n\nscript: nose2 -vv --coverage=xmltodict.py\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 7.4560546875,
          "content": "CHANGELOG\n=========\n\nv0.14.2\n-------\n* Revert \"Ensure significant whitespace is not trimmed\"\n  * This changed was backwards incompatible and caused downstream issues.\n\nv0.14.1\n-------\n* Drop support for Python older than 3.6\n* Additional ruff/Pyflakes/codespell fixes.\n  * Thanks @DimitriPapadopoulos!\n\nv0.14.0\n-------\n\n* Drop old Python 2 support leftover code and apply several RUFF code health fixes.\n  * Thanks, @DimitriPapadopoulos!\n* Add Python 3.11, 3.12 and 3.13 support and tests.\n  * Thanks, @angvp!\n* Tests in gh-action.\n  * Thanks, @almaz.kun!\n* Remove defusedexpat import.\n  * Thanks, @hanno!\n* Replace deprecated BadZipfile with BadZipFile.\n  * Thanks, @hugovk!\n* Support indent using integer format, enable `python -m unittest tests/*.py`.\n  * Thanks, @hiiwave!\n* Ensure significant whitespace is not trimmed\n  * Thanks, @trey.franklin!\n* added conda installation command\n  * Thanks, @sugatoray!\n* fix attributes not appearing in streaming mode\n  * Thanks, @timnguyen001! \n* Fix Travis CI status badge URL\n* Update push_release.sh to use twine.\n\nv0.13.0\n-------\n\n* Add install info to readme for openSUSE. (#205)\n  * Thanks, @smarlowucf!\n* Support defaultdict for namespace mapping (#211)\n  * Thanks, @nathanalderson!\n* parse(generator) is now possible (#212)\n  * Thanks, @xandey!\n* Processing comments on parsing from xml to dict (connected to #109) (#221)\n  * Thanks, @svetazol!\n* Add expand_iter kw to unparse to expand iterables (#213)\n  * Thanks, @claweyenuk!\n* Fixed some typos\n  * Thanks, @timgates42 and @kianmeng!\n* Add support for python3.8\n  * Thanks, @t0b3!\n* Drop Jython/Python 2 and add Python 3.9/3.10.\n* Drop OrderedDict in Python >= 3.7\n* Do not use len() to determine if a sequence is empty\n  * Thanks, @DimitriPapadopoulos!\n* Add more namespace attribute tests\n  * Thanks, @leogregianin!\n* Fix encoding issue in setup.py\n  * Thanks, @rjarry!\n\nv0.12.0\n-------\n\n* Allow force_commits=True for getting all keys as lists (#204)\n* README.md: fix useless uses of cat (#200)\n* Add FreeBSD install instructions (#199)\n* Fix and simplify travis config (#192)\n* Add support for Python 3.7 (#189)\n* Drop support for EOL Python (#191)\n* Use Markdown long_description on PyPI (#190)\n* correct spelling mistake (#165)\n* correctly unparse booleans (#180)\n* Updates README.md with svg badge\n\nv0.11.0\n-------\n\n* Determine fileness by checking for `read` attr\n  * Thanks, @jwodder!\n* Add support for Python 3.6.\n  * Thanks, @cclauss!\n* Release as a universal wheel.\n  * Thanks, @adamchainz!\n* Updated docs examples to use print function.\n  * Thanks, @cdeil!\n* unparse: pass short_empty_elements to XMLGenerator\n  * Thanks, @zhanglei002!\n* Added namespace support when unparsing.\n  * Thanks, @imiric!\n\nv0.10.2\n-------\n\n* Fixed defusedexpat expat import.\n  * Thanks, @fiebiga!\n\nv0.10.1\n-------\n\n* Use defusedexpat if available.\n* Allow non-string attributes in unparse.\n* Add postprocessor support for attributes.\n* Make command line interface Python 3-compatible.\n\nv0.10.0\n-------\n\n* Add force_list feature.\n  * Thanks, @guewen and @jonlooney!\n* Add support for Python 3.4 and 3.5.\n* Performance optimization: use list instead of string for CDATA.\n  * Thanks, @bharel!\n* Include Arch Linux package instructions in README.\n  * Thanks, @felixonmars!\n* Improved documentation.\n  * Thanks, @ubershmekel!\n* Allow any iterable in unparse, not just lists.\n  * Thanks, @bzamecnik!\n* Bugfix: Process namespaces in attributes too.\n* Better testing under Python 2.6.\n  * Thanks, @TyMaszWeb!\n\nv0.9.2\n------\n\n* Fix multiroot check for list values (edge case reported by @JKillian)\n\nv0.9.1\n------\n\n* Only check single root when full_document=True (Thanks @JKillian!)\n\nv0.9.0\n------\n\n* Added CHANGELOG.md\n* Avoid ternary operator in call to ParserCreate().\n* Adding Python 3.4 to Tox test environment.\n* Added full_document flag to unparse (default=True).\n\nv0.8.7\n------\n\n* Merge pull request #56 from HansWeltar/master\n* Improve performance for large files\n* Updated README unparse example with pretty=True.\n\nv0.8.6\n------\n\n* Fixed extra newlines in pretty print mode.\n* Fixed all flake8 warnings.\n\nv0.8.5\n------\n\n* Added Tox config.\n* Let expat figure out the doc encoding.\n\nv0.8.4\n------\n\n* Fixed Jython TravisCI build.\n* Moved nose and coverage to tests_require.\n* Dropping python 2.5 from travis.yml.\n\nv0.8.3\n------\n\n* Use system setuptools if available.\n\nv0.8.2\n------\n\n* Switch to latest setuptools.\n\nv0.8.1\n------\n\n* Include distribute_setup.py in MANIFEST.in\n* Updated package classifiers (python versions, PyPy, Jython).\n\nv0.8.0\n------\n\n* Merge pull request #40 from martinblech/jython-support\n* Adding Jython support.\n* Fix streaming example callback (must return True)\n\nv0.7.0\n------\n\n* Merge pull request #35 from martinblech/namespace-support\n* Adding support for XML namespaces.\n* Merge pull request #33 from bgilb/master\n* fixes whitespace style\n* changes module import syntax and assertRaises\n* adds unittest assertRaises\n\nv0.6.0\n------\n\n* Merge pull request #31 from martinblech/document-unparse\n* Adding documentation for unparse()\n* Merge pull request #30 from martinblech/prettyprint\n* Adding support for pretty print in unparse()\n\nv0.5.1\n------\n\n* Merge pull request #29 from dusual/master\n* ordereddict import for less 2.6 if available\n\nv0.5.0\n------\n\n* Allow using alternate versions of `expat`.\n* Added shameless link to GitTip.\n* Merge pull request #20 from kevbo/master\n* Adds unparse example to README\n\nv0.4.6\n------\n\n* fix try/catch block for pypi (throws AttributeError instead of TypeError)\n* prevent encoding an already encoded string\n* removed unnecessary try/catch for xml_input.encode(). check if file or string, EAFP style. (thanks @turicas)\n\nv0.4.5\n------\n\n* test with python 3.3 too\n* avoid u'unicode' syntax (fails in python 3.2)\n* handle unicode input strings properly\n* add strip_whitespace option (default=True)\n* Merge pull request #16 from slestak/master\n* fix unittest\n* working with upstream to improve #15\n* remove pythonpath tweaks, change loc of #15 patch\n* upstream  #15\n\nv0.4.4\n------\n\n* test attribute order roundtrip only if OrderedDict is available (python >= 2.7)\n* Merge branch 'master' of github.com:martinblech/xmltodict\n* preserve xml attribute order (fixes #13)\n\nv0.4.3\n------\n\n* fix #12: postprocess cdata items too\n* added info about official fedora package\n\nv0.4.2\n------\n\n* Merge pull request #11 from ralphbean/master\n* Include README, LICENSE, and tests in the distributed tarball.\n\nv0.4.1\n------\n\n* take all characters (no need to strip and filter)\n* fixed CLI (marshal only takes dict, not OrderedDict)\n* ignore MANIFEST\n\nv0.4\n----\n\n* #8 preprocessing callback in unparse()\n\nv0.3\n----\n\n* implemented postprocessor callback (#6)\n* update readme with install instructions\n\nv0.2\n----\n\n* link to travis-ci build status\n* more complete info in setup.py (for uploading to PyPi)\n* coverage annotations for tricky py3k workarounds\n* py3k compatibility\n* removed unused __future__ print_function\n* using io.StringIO on py3k\n* removed unnecessary exception catching\n* initial travis-ci configuration\n* made _emit function private\n* unparse functionality\n* added tests\n* updated (c) notice to acknowledge individual contributors\n* added license information\n* fixed README\n* removed temp build directory and added a .gitignore to avoid that happening again\n* Merge pull request #1 from scottscott/master\n* Added setup script to make xmltodict a Python module.\n* fixed bad handling of cdata in semistructured xml, changed _CDATA_ to #text as default\n* added attr_prefix, cdata_key and force_cdata parameters\n* links in README\n* links in README\n* improved README\n* initial commit\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "Copyright (C) 2012 Martin Blech and individual contributors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.078125,
          "content": "include README.md\ninclude LICENSE\ninclude ez_setup.py\nrecursive-include tests *\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.7197265625,
          "content": "# xmltodict\n\n`xmltodict` is a Python module that makes working with XML feel like you are working with [JSON](http://docs.python.org/library/json.html), as in this [\"spec\"](http://www.xml.com/pub/a/2006/05/31/converting-between-xml-and-json.html):\n\n[![Build Status](https://app.travis-ci.com/martinblech/xmltodict.svg?branch=master)](https://app.travis-ci.com/martinblech/xmltodict)\n\n```python\n>>> print(json.dumps(xmltodict.parse(\"\"\"\n...  <mydocument has=\"an attribute\">\n...    <and>\n...      <many>elements</many>\n...      <many>more elements</many>\n...    </and>\n...    <plus a=\"complex\">\n...      element as well\n...    </plus>\n...  </mydocument>\n...  \"\"\"), indent=4))\n{\n    \"mydocument\": {\n        \"@has\": \"an attribute\", \n        \"and\": {\n            \"many\": [\n                \"elements\", \n                \"more elements\"\n            ]\n        }, \n        \"plus\": {\n            \"@a\": \"complex\", \n            \"#text\": \"element as well\"\n        }\n    }\n}\n```\n\n## Namespace support\n\nBy default, `xmltodict` does no XML namespace processing (it just treats namespace declarations as regular node attributes), but passing `process_namespaces=True` will make it expand namespaces for you:\n\n```python\n>>> xml = \"\"\"\n... <root xmlns=\"http://defaultns.com/\"\n...       xmlns:a=\"http://a.com/\"\n...       xmlns:b=\"http://b.com/\">\n...   <x>1</x>\n...   <a:y>2</a:y>\n...   <b:z>3</b:z>\n... </root>\n... \"\"\"\n>>> xmltodict.parse(xml, process_namespaces=True) == {\n...     'http://defaultns.com/:root': {\n...         'http://defaultns.com/:x': '1',\n...         'http://a.com/:y': '2',\n...         'http://b.com/:z': '3',\n...     }\n... }\nTrue\n```\n\nIt also lets you collapse certain namespaces to shorthand prefixes, or skip them altogether:\n\n```python\n>>> namespaces = {\n...     'http://defaultns.com/': None, # skip this namespace\n...     'http://a.com/': 'ns_a', # collapse \"http://a.com/\" -> \"ns_a\"\n... }\n>>> xmltodict.parse(xml, process_namespaces=True, namespaces=namespaces) == {\n...     'root': {\n...         'x': '1',\n...         'ns_a:y': '2',\n...         'http://b.com/:z': '3',\n...     },\n... }\nTrue\n```\n\n## Streaming mode\n\n`xmltodict` is very fast ([Expat](http://docs.python.org/library/pyexpat.html)-based) and has a streaming mode with a small memory footprint, suitable for big XML dumps like [Discogs](http://discogs.com/data/) or [Wikipedia](http://dumps.wikimedia.org/):\n\n```python\n>>> def handle_artist(_, artist):\n...     print(artist['name'])\n...     return True\n>>> \n>>> xmltodict.parse(GzipFile('discogs_artists.xml.gz'),\n...     item_depth=2, item_callback=handle_artist)\nA Perfect Circle\nFantômas\nKing Crimson\nChris Potter\n...\n```\n\nIt can also be used from the command line to pipe objects to a script like this:\n\n```python\nimport sys, marshal\nwhile True:\n    _, article = marshal.load(sys.stdin)\n    print(article['title'])\n```\n\n```sh\n$ bunzip2 enwiki-pages-articles.xml.bz2 | xmltodict.py 2 | myscript.py\nAccessibleComputing\nAnarchism\nAfghanistanHistory\nAfghanistanGeography\nAfghanistanPeople\nAfghanistanCommunications\nAutism\n...\n```\n\nOr just cache the dicts so you don't have to parse that big XML file again. You do this only once:\n\n```sh\n$ bunzip2 enwiki-pages-articles.xml.bz2 | xmltodict.py 2 | gzip > enwiki.dicts.gz\n```\n\nAnd you reuse the dicts with every script that needs them:\n\n```sh\n$ gunzip enwiki.dicts.gz | script1.py\n$ gunzip enwiki.dicts.gz | script2.py\n...\n```\n\n## Roundtripping\n\nYou can also convert in the other direction, using the `unparse()` method:\n\n```python\n>>> mydict = {\n...     'response': {\n...             'status': 'good',\n...             'last_updated': '2014-02-16T23:10:12Z',\n...     }\n... }\n>>> print(unparse(mydict, pretty=True))\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<response>\n\t<status>good</status>\n\t<last_updated>2014-02-16T23:10:12Z</last_updated>\n</response>\n```\n\nText values for nodes can be specified with the `cdata_key` key in the python dict, while node properties can be specified with the `attr_prefix` prefixed to the key name in the python dict. The default value for `attr_prefix` is `@` and the default value for `cdata_key` is `#text`.\n\n```python\n>>> import xmltodict\n>>> \n>>> mydict = {\n...     'text': {\n...         '@color':'red',\n...         '@stroke':'2',\n...         '#text':'This is a test'\n...     }\n... }\n>>> print(xmltodict.unparse(mydict, pretty=True))\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<text stroke=\"2\" color=\"red\">This is a test</text>\n```\n\nLists that are specified under a key in a dictionary use the key as a tag for each item. But if a list does have a parent key, for example if a list exists inside another list, it does not have a tag to use and the items are converted to a string as shown in the example below.  To give tags to nested lists, use the `expand_iter` keyword argument to provide a tag as demonstrated below. Note that using `expand_iter` will break roundtripping.\n\n```python\n>>> mydict = {\n...     \"line\": {\n...         \"points\": [\n...             [1, 5],\n...             [2, 6],\n...         ]\n...     }\n... }\n>>> print(xmltodict.unparse(mydict, pretty=True))\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<line>\n        <points>[1, 5]</points>\n        <points>[2, 6]</points>\n</line>\n>>> print(xmltodict.unparse(mydict, pretty=True, expand_iter=\"coord\"))\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<line>\n        <points>\n                <coord>1</coord>\n                <coord>5</coord>\n        </points>\n        <points>\n                <coord>2</coord>\n                <coord>6</coord>\n        </points>\n</line>\n```\n\n## Ok, how do I get it?\n\n### Using pypi\n\nYou just need to\n\n```sh\n$ pip install xmltodict\n```\n\n### Using conda\n\nFor installing `xmltodict` using Anaconda/Miniconda (*conda*) from the \n[conda-forge channel][#xmltodict-conda] all you need to do is:\n\n[#xmltodict-conda]: https://anaconda.org/conda-forge/xmltodict\n\n```sh\n$ conda install -c conda-forge xmltodict\n```\n\n### RPM-based distro (Fedora, RHEL, …)\n\nThere is an [official Fedora package for xmltodict](https://apps.fedoraproject.org/packages/python-xmltodict).\n\n```sh\n$ sudo yum install python-xmltodict\n```\n\n### Arch Linux\n\nThere is an [official Arch Linux package for xmltodict](https://www.archlinux.org/packages/community/any/python-xmltodict/).\n\n```sh\n$ sudo pacman -S python-xmltodict\n```\n\n### Debian-based distro (Debian, Ubuntu, …)\n\nThere is an [official Debian package for xmltodict](https://tracker.debian.org/pkg/python-xmltodict).\n\n```sh\n$ sudo apt install python-xmltodict\n```\n\n### FreeBSD\n\nThere is an [official FreeBSD port for xmltodict](https://svnweb.freebsd.org/ports/head/devel/py-xmltodict/).\n\n```sh\n$ pkg install py36-xmltodict\n```\n\n### openSUSE/SLE (SLE 15, Leap 15, Tumbleweed)\n\nThere is an [official openSUSE package for xmltodict](https://software.opensuse.org/package/python-xmltodict).\n\n```sh\n# Python2\n$ zypper in python2-xmltodict\n\n# Python3\n$ zypper in python3-xmltodict\n```\n"
        },
        {
          "name": "ez_setup.py",
          "type": "blob",
          "size": 12.1611328125,
          "content": "#!/usr/bin/env python\n\n\"\"\"\nSetuptools bootstrapping installer.\n\nMaintained at https://github.com/pypa/setuptools/tree/bootstrap.\n\nRun this script to install or upgrade setuptools.\n\nThis method is DEPRECATED. Check https://github.com/pypa/setuptools/issues/581 for more details.\n\"\"\"\n\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport zipfile\nimport optparse\nimport subprocess\nimport platform\nimport textwrap\nimport contextlib\n\nfrom distutils import log\n\ntry:\n    from urllib.request import urlopen\nexcept ImportError:\n    from urllib2 import urlopen\n\ntry:\n    from site import USER_SITE\nexcept ImportError:\n    USER_SITE = None\n\n# 33.1.1 is the last version that supports setuptools self upgrade/installation.\nDEFAULT_VERSION = \"33.1.1\"\nDEFAULT_URL = \"https://pypi.io/packages/source/s/setuptools/\"\nDEFAULT_SAVE_DIR = os.curdir\nDEFAULT_DEPRECATION_MESSAGE = \"ez_setup.py is deprecated and when using it setuptools will be pinned to {0} since it's the last version that supports setuptools self upgrade/installation, check https://github.com/pypa/setuptools/issues/581 for more info; use pip to install setuptools\"\n\nMEANINGFUL_INVALID_ZIP_ERR_MSG = 'Maybe {0} is corrupted, delete it and try again.'\n\nlog.warn(DEFAULT_DEPRECATION_MESSAGE.format(DEFAULT_VERSION))\n\n\ndef _python_cmd(*args):\n    \"\"\"\n    Execute a command.\n\n    Return True if the command succeeded.\n    \"\"\"\n    args = (sys.executable,) + args\n    return subprocess.call(args) == 0\n\n\ndef _install(archive_filename, install_args=()):\n    \"\"\"Install Setuptools.\"\"\"\n    with archive_context(archive_filename):\n        # installing\n        log.warn('Installing Setuptools')\n        if not _python_cmd('setup.py', 'install', *install_args):\n            log.warn('Something went wrong during the installation.')\n            log.warn('See the error message above.')\n            # exitcode will be 2\n            return 2\n\n\ndef _build_egg(egg, archive_filename, to_dir):\n    \"\"\"Build Setuptools egg.\"\"\"\n    with archive_context(archive_filename):\n        # building an egg\n        log.warn('Building a Setuptools egg in %s', to_dir)\n        _python_cmd('setup.py', '-q', 'bdist_egg', '--dist-dir', to_dir)\n    # returning the result\n    log.warn(egg)\n    if not os.path.exists(egg):\n        raise OSError('Could not build the egg.')\n\n\nclass ContextualZipFile(zipfile.ZipFile):\n\n    \"\"\"Supplement ZipFile class to support context manager for Python 2.6.\"\"\"\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, traceback):\n        self.close()\n\n    def __new__(cls, *args, **kwargs):\n        \"\"\"Construct a ZipFile or ContextualZipFile as appropriate.\"\"\"\n        if hasattr(zipfile.ZipFile, '__exit__'):\n            return zipfile.ZipFile(*args, **kwargs)\n        return super().__new__(cls)\n\n\n@contextlib.contextmanager\ndef archive_context(filename):\n    \"\"\"\n    Unzip filename to a temporary directory, set to the cwd.\n\n    The unzipped target is cleaned up after.\n    \"\"\"\n    tmpdir = tempfile.mkdtemp()\n    log.warn('Extracting in %s', tmpdir)\n    old_wd = os.getcwd()\n    try:\n        os.chdir(tmpdir)\n        try:\n            with ContextualZipFile(filename) as archive:\n                archive.extractall()\n        except zipfile.BadZipFile as err:\n            if not err.args:\n                err.args = ('', )\n            err.args = err.args + (\n                MEANINGFUL_INVALID_ZIP_ERR_MSG.format(filename),\n            )\n            raise\n\n        # going in the directory\n        subdir = os.path.join(tmpdir, os.listdir(tmpdir)[0])\n        os.chdir(subdir)\n        log.warn('Now working in %s', subdir)\n        yield\n\n    finally:\n        os.chdir(old_wd)\n        shutil.rmtree(tmpdir)\n\n\ndef _do_download(version, download_base, to_dir, download_delay):\n    \"\"\"Download Setuptools.\"\"\"\n    py_desig = f'py{sys.version_info[0]}.{sys.version_info[1]}'\n    tp = f'setuptools-{version}-{py_desig}.egg'\n    egg = os.path.join(to_dir, tp.format(**locals()))\n    if not os.path.exists(egg):\n        archive = download_setuptools(version, download_base,\n            to_dir, download_delay)\n        _build_egg(egg, archive, to_dir)\n    sys.path.insert(0, egg)\n\n    # Remove previously-imported pkg_resources if present (see\n    # https://bitbucket.org/pypa/setuptools/pull-request/7/ for details).\n    if 'pkg_resources' in sys.modules:\n        _unload_pkg_resources()\n\n    import setuptools\n    setuptools.bootstrap_install_from = egg\n\n\ndef use_setuptools(\n        version=DEFAULT_VERSION, download_base=DEFAULT_URL,\n        to_dir=DEFAULT_SAVE_DIR, download_delay=15):\n    \"\"\"\n    Ensure that a setuptools version is installed.\n\n    Return None. Raise SystemExit if the requested version\n    or later cannot be installed.\n    \"\"\"\n    to_dir = os.path.abspath(to_dir)\n\n    # prior to importing, capture the module state for\n    # representative modules.\n    rep_modules = 'pkg_resources', 'setuptools'\n    imported = set(sys.modules).intersection(rep_modules)\n\n    try:\n        import pkg_resources\n        pkg_resources.require(\"setuptools>=\" + version)\n        # a suitable version is already installed\n        return\n    except ImportError:\n        # pkg_resources not available; setuptools is not installed; download\n        pass\n    except pkg_resources.DistributionNotFound:\n        # no version of setuptools was found; allow download\n        pass\n    except pkg_resources.VersionConflict as VC_err:\n        if imported:\n            _conflict_bail(VC_err, version)\n\n        # otherwise, unload pkg_resources to allow the downloaded version to\n        #  take precedence.\n        del pkg_resources\n        _unload_pkg_resources()\n\n    return _do_download(version, download_base, to_dir, download_delay)\n\n\ndef _conflict_bail(VC_err, version):\n    \"\"\"\n    Setuptools was imported prior to invocation, so it is\n    unsafe to unload it. Bail out.\n    \"\"\"\n    conflict_tmpl = textwrap.dedent(f\"\"\"\n        The required version of setuptools (>={version}) is not available,\n        and can't be installed while this script is running. Please\n        install a more recent version first, using\n        'easy_install -U setuptools'.\n\n        (Currently using {VC_err.args[0]!r})\n        \"\"\")\n    msg = conflict_tmpl.format(**locals())\n    sys.stderr.write(msg)\n    sys.exit(2)\n\n\ndef _unload_pkg_resources():\n    sys.meta_path = [\n        importer\n        for importer in sys.meta_path\n        if importer.__class__.__module__ != 'pkg_resources.extern'\n    ]\n    del_modules = [\n        name for name in sys.modules\n        if name.startswith('pkg_resources')\n    ]\n    for mod_name in del_modules:\n        del sys.modules[mod_name]\n\n\ndef _clean_check(cmd, target):\n    \"\"\"\n    Run the command to download target.\n\n    If the command fails, clean up before re-raising the error.\n    \"\"\"\n    try:\n        subprocess.check_call(cmd)\n    except subprocess.CalledProcessError:\n        if os.access(target, os.F_OK):\n            os.unlink(target)\n        raise\n\n\ndef download_file_powershell(url, target):\n    \"\"\"\n    Download the file at url to target using Powershell.\n\n    Powershell will validate trust.\n    Raise an exception if the command cannot complete.\n    \"\"\"\n    target = os.path.abspath(target)\n    ps_cmd = (\n        \"[System.Net.WebRequest]::DefaultWebProxy.Credentials = \"\n        \"[System.Net.CredentialCache]::DefaultCredentials; \"\n        '(new-object System.Net.WebClient).DownloadFile(\"{url}\", \"{target}\")'.format(**locals())\n    )\n    cmd = [\n        'powershell',\n        '-Command',\n        ps_cmd,\n    ]\n    _clean_check(cmd, target)\n\n\ndef has_powershell():\n    \"\"\"Determine if Powershell is available.\"\"\"\n    if platform.system() != 'Windows':\n        return False\n    cmd = ['powershell', '-Command', 'echo test']\n    with open(os.path.devnull, 'wb') as devnull:\n        try:\n            subprocess.check_call(cmd, stdout=devnull, stderr=devnull)\n        except Exception:\n            return False\n    return True\ndownload_file_powershell.viable = has_powershell\n\n\ndef download_file_curl(url, target):\n    cmd = ['curl', url, '--location', '--silent', '--output', target]\n    _clean_check(cmd, target)\n\n\ndef has_curl():\n    cmd = ['curl', '--version']\n    with open(os.path.devnull, 'wb') as devnull:\n        try:\n            subprocess.check_call(cmd, stdout=devnull, stderr=devnull)\n        except Exception:\n            return False\n    return True\ndownload_file_curl.viable = has_curl\n\n\ndef download_file_wget(url, target):\n    cmd = ['wget', url, '--quiet', '--output-document', target]\n    _clean_check(cmd, target)\n\n\ndef has_wget():\n    cmd = ['wget', '--version']\n    with open(os.path.devnull, 'wb') as devnull:\n        try:\n            subprocess.check_call(cmd, stdout=devnull, stderr=devnull)\n        except Exception:\n            return False\n    return True\ndownload_file_wget.viable = has_wget\n\n\ndef download_file_insecure(url, target):\n    \"\"\"Use Python to download the file, without connection authentication.\"\"\"\n    src = urlopen(url)\n    try:\n        # Read all the data in one block.\n        data = src.read()\n    finally:\n        src.close()\n\n    # Write all the data in one block to avoid creating a partial file.\n    with open(target, \"wb\") as dst:\n        dst.write(data)\ndownload_file_insecure.viable = lambda: True\n\n\ndef get_best_downloader():\n    downloaders = (\n        download_file_powershell,\n        download_file_curl,\n        download_file_wget,\n        download_file_insecure,\n    )\n    viable_downloaders = (dl for dl in downloaders if dl.viable())\n    return next(viable_downloaders, None)\n\n\ndef download_setuptools(\n        version=DEFAULT_VERSION, download_base=DEFAULT_URL,\n        to_dir=DEFAULT_SAVE_DIR, delay=15,\n        downloader_factory=get_best_downloader):\n    \"\"\"\n    Download setuptools from a specified location and return its filename.\n\n    `version` should be a valid setuptools version number that is available\n    as an sdist for download under the `download_base` URL (which should end\n    with a '/'). `to_dir` is the directory where the egg will be downloaded.\n    `delay` is the number of seconds to pause before an actual download\n    attempt.\n\n    ``downloader_factory`` should be a function taking no arguments and\n    returning a function for downloading a URL to a target.\n    \"\"\"\n    # making sure we use the absolute path\n    to_dir = os.path.abspath(to_dir)\n    zip_name = f\"setuptools-{version}.zip\"\n    url = download_base + zip_name\n    saveto = os.path.join(to_dir, zip_name)\n    if not os.path.exists(saveto):  # Avoid repeated downloads\n        log.warn(\"Downloading %s\", url)\n        downloader = downloader_factory()\n        downloader(url, saveto)\n    return os.path.realpath(saveto)\n\n\ndef _build_install_args(options):\n    \"\"\"\n    Build the arguments to 'python setup.py install' on the setuptools package.\n\n    Returns list of command line arguments.\n    \"\"\"\n    return ['--user'] if options.user_install else []\n\n\ndef _parse_args():\n    \"\"\"Parse the command line for options.\"\"\"\n    parser = optparse.OptionParser()\n    parser.add_option(\n        '--user', dest='user_install', action='store_true', default=False,\n        help='install in user site package')\n    parser.add_option(\n        '--download-base', dest='download_base', metavar=\"URL\",\n        default=DEFAULT_URL,\n        help='alternative URL from where to download the setuptools package')\n    parser.add_option(\n        '--insecure', dest='downloader_factory', action='store_const',\n        const=lambda: download_file_insecure, default=get_best_downloader,\n        help='Use internal, non-validating downloader'\n    )\n    parser.add_option(\n        '--version', help=\"Specify which version to download\",\n        default=DEFAULT_VERSION,\n    )\n    parser.add_option(\n        '--to-dir',\n        help=\"Directory to save (and reuse) package\",\n        default=DEFAULT_SAVE_DIR,\n    )\n    options, _ = parser.parse_args()\n    return options\n\n\ndef _download_args(options):\n    \"\"\"Return args for download_setuptools function from cmdline args.\"\"\"\n    return dict(\n        version=options.version,\n        download_base=options.download_base,\n        downloader_factory=options.downloader_factory,\n        to_dir=options.to_dir,\n    )\n\n\ndef main():\n    \"\"\"Install or upgrade setuptools and EasyInstall.\"\"\"\n    options = _parse_args()\n    archive = download_setuptools(**_download_args(options))\n    return _install(archive, _build_install_args(options))\n\nif __name__ == '__main__':\n    sys.exit(main())\n"
        },
        {
          "name": "push_release.sh",
          "type": "blob",
          "size": 0.0859375,
          "content": "#!/usr/bin/env sh\npython setup.py clean sdist bdist_wheel\npython -m twine upload dist/*\n"
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.02734375,
          "content": "[bdist_wheel]\nuniversal = 1\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.5458984375,
          "content": "#!/usr/bin/env python\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from ez_setup import use_setuptools\n    use_setuptools()\n    from setuptools import setup\n\nimport xmltodict\n\nwith open('README.md', 'rb') as f:\n    long_description = f.read().decode('utf-8')\n\n\nsetup(name='xmltodict',\n      version=xmltodict.__version__,\n      description=xmltodict.__doc__,\n      long_description=long_description,\n      long_description_content_type='text/markdown',\n      author=xmltodict.__author__,\n      author_email='martinblech@gmail.com',\n      url='https://github.com/martinblech/xmltodict',\n      license=xmltodict.__license__,\n      platforms=['all'],\n      python_requires='>=3.6',\n      classifiers=[\n          'Intended Audience :: Developers',\n          'License :: OSI Approved :: MIT License',\n          'Operating System :: OS Independent',\n          'Programming Language :: Python',\n          'Programming Language :: Python :: 3',\n          'Programming Language :: Python :: 3.6',\n          'Programming Language :: Python :: 3.7',\n          'Programming Language :: Python :: 3.8',\n          'Programming Language :: Python :: 3.9',\n          'Programming Language :: Python :: 3.10',\n          'Programming Language :: Python :: 3.11',\n          'Programming Language :: Python :: 3.12',\n          'Programming Language :: Python :: 3.13',\n          'Programming Language :: Python :: Implementation :: PyPy',\n          'Topic :: Text Processing :: Markup :: XML',\n      ],\n      py_modules=['xmltodict'],\n      tests_require=['nose2', 'coverage'],\n      )\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tox.ini",
          "type": "blob",
          "size": 0.2841796875,
          "content": "[tox]\nenvlist = py36, py37, py38, py39, py310, py311, py312, py313, pypy\n\n[gh-actions]\npython =\n    3.6: py36\n    3.7: py37\n    3.8: py38\n    3.9: py39\n    3.11: py311\n    3.12: py312\n    3.13: py313\n    pypy: pypy\n\n[testenv]\ndeps =\n  coverage\n  nose2\ncommands=nose2 --coverage=xmltodict.py\n"
        },
        {
          "name": "xmltodict.py",
          "type": "blob",
          "size": 18.046875,
          "content": "#!/usr/bin/env python\n\"Makes working with XML feel like you are working with JSON\"\n\nfrom xml.parsers import expat\nfrom xml.sax.saxutils import XMLGenerator\nfrom xml.sax.xmlreader import AttributesImpl\nfrom io import StringIO\n\n_dict = dict\nimport platform\nif tuple(map(int, platform.python_version_tuple()[:2])) < (3, 7):\n    from collections import OrderedDict as _dict\n\nfrom inspect import isgenerator\n\n__author__ = 'Martin Blech'\n__version__ = \"0.14.2\"\n__license__ = 'MIT'\n\n\nclass ParsingInterrupted(Exception):\n    pass\n\n\nclass _DictSAXHandler:\n    def __init__(self,\n                 item_depth=0,\n                 item_callback=lambda *args: True,\n                 xml_attribs=True,\n                 attr_prefix='@',\n                 cdata_key='#text',\n                 force_cdata=False,\n                 cdata_separator='',\n                 postprocessor=None,\n                 dict_constructor=_dict,\n                 strip_whitespace=True,\n                 namespace_separator=':',\n                 namespaces=None,\n                 force_list=None,\n                 comment_key='#comment'):\n        self.path = []\n        self.stack = []\n        self.data = []\n        self.item = None\n        self.item_depth = item_depth\n        self.xml_attribs = xml_attribs\n        self.item_callback = item_callback\n        self.attr_prefix = attr_prefix\n        self.cdata_key = cdata_key\n        self.force_cdata = force_cdata\n        self.cdata_separator = cdata_separator\n        self.postprocessor = postprocessor\n        self.dict_constructor = dict_constructor\n        self.strip_whitespace = strip_whitespace\n        self.namespace_separator = namespace_separator\n        self.namespaces = namespaces\n        self.namespace_declarations = dict_constructor()\n        self.force_list = force_list\n        self.comment_key = comment_key\n\n    def _build_name(self, full_name):\n        if self.namespaces is None:\n            return full_name\n        i = full_name.rfind(self.namespace_separator)\n        if i == -1:\n            return full_name\n        namespace, name = full_name[:i], full_name[i+1:]\n        try:\n            short_namespace = self.namespaces[namespace]\n        except KeyError:\n            short_namespace = namespace\n        if not short_namespace:\n            return name\n        else:\n            return self.namespace_separator.join((short_namespace, name))\n\n    def _attrs_to_dict(self, attrs):\n        if isinstance(attrs, dict):\n            return attrs\n        return self.dict_constructor(zip(attrs[0::2], attrs[1::2]))\n\n    def startNamespaceDecl(self, prefix, uri):\n        self.namespace_declarations[prefix or ''] = uri\n\n    def startElement(self, full_name, attrs):\n        name = self._build_name(full_name)\n        attrs = self._attrs_to_dict(attrs)\n        if attrs and self.namespace_declarations:\n            attrs['xmlns'] = self.namespace_declarations\n            self.namespace_declarations = self.dict_constructor()\n        self.path.append((name, attrs or None))\n        if len(self.path) >= self.item_depth:\n            self.stack.append((self.item, self.data))\n            if self.xml_attribs:\n                attr_entries = []\n                for key, value in attrs.items():\n                    key = self.attr_prefix+self._build_name(key)\n                    if self.postprocessor:\n                        entry = self.postprocessor(self.path, key, value)\n                    else:\n                        entry = (key, value)\n                    if entry:\n                        attr_entries.append(entry)\n                attrs = self.dict_constructor(attr_entries)\n            else:\n                attrs = None\n            self.item = attrs or None\n            self.data = []\n\n    def endElement(self, full_name):\n        name = self._build_name(full_name)\n        if len(self.path) == self.item_depth:\n            item = self.item\n            if item is None:\n                item = (None if not self.data\n                        else self.cdata_separator.join(self.data))\n\n            should_continue = self.item_callback(self.path, item)\n            if not should_continue:\n                raise ParsingInterrupted\n        if self.stack:\n            data = (None if not self.data\n                    else self.cdata_separator.join(self.data))\n            item = self.item\n            self.item, self.data = self.stack.pop()\n            if self.strip_whitespace and data:\n                data = data.strip() or None\n            if data and self.force_cdata and item is None:\n                item = self.dict_constructor()\n            if item is not None:\n                if data:\n                    self.push_data(item, self.cdata_key, data)\n                self.item = self.push_data(self.item, name, item)\n            else:\n                self.item = self.push_data(self.item, name, data)\n        else:\n            self.item = None\n            self.data = []\n        self.path.pop()\n\n    def characters(self, data):\n        if not self.data:\n            self.data = [data]\n        else:\n            self.data.append(data)\n\n    def comments(self, data):\n        if self.strip_whitespace:\n            data = data.strip()\n        self.item = self.push_data(self.item, self.comment_key, data)\n\n    def push_data(self, item, key, data):\n        if self.postprocessor is not None:\n            result = self.postprocessor(self.path, key, data)\n            if result is None:\n                return item\n            key, data = result\n        if item is None:\n            item = self.dict_constructor()\n        try:\n            value = item[key]\n            if isinstance(value, list):\n                value.append(data)\n            else:\n                item[key] = [value, data]\n        except KeyError:\n            if self._should_force_list(key, data):\n                item[key] = [data]\n            else:\n                item[key] = data\n        return item\n\n    def _should_force_list(self, key, value):\n        if not self.force_list:\n            return False\n        if isinstance(self.force_list, bool):\n            return self.force_list\n        try:\n            return key in self.force_list\n        except TypeError:\n            return self.force_list(self.path[:-1], key, value)\n\n\ndef parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n          namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n    \"\"\"Parse the given XML input and convert it into a dictionary.\n\n    `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n\n    If `xml_attribs` is `True`, element attributes are put in the dictionary\n    among regular child elements, using `@` as a prefix to avoid collisions. If\n    set to `False`, they are just ignored.\n\n    Simple example::\n\n        >>> import xmltodict\n        >>> doc = xmltodict.parse(\\\"\\\"\\\"\n        ... <a prop=\"x\">\n        ...   <b>1</b>\n        ...   <b>2</b>\n        ... </a>\n        ... \\\"\\\"\\\")\n        >>> doc['a']['@prop']\n        u'x'\n        >>> doc['a']['b']\n        [u'1', u'2']\n\n    If `item_depth` is `0`, the function returns a dictionary for the root\n    element (default behavior). Otherwise, it calls `item_callback` every time\n    an item at the specified depth is found and returns `None` in the end\n    (streaming mode).\n\n    The callback function receives two parameters: the `path` from the document\n    root to the item (name-attribs pairs), and the `item` (dict). If the\n    callback's return value is false-ish, parsing will be stopped with the\n    :class:`ParsingInterrupted` exception.\n\n    Streaming example::\n\n        >>> def handle(path, item):\n        ...     print('path:%s item:%s' % (path, item))\n        ...     return True\n        ...\n        >>> xmltodict.parse(\\\"\\\"\\\"\n        ... <a prop=\"x\">\n        ...   <b>1</b>\n        ...   <b>2</b>\n        ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n        path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n        path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n\n    The optional argument `postprocessor` is a function that takes `path`,\n    `key` and `value` as positional arguments and returns a new `(key, value)`\n    pair where both `key` and `value` may have changed. Usage example::\n\n        >>> def postprocessor(path, key, value):\n        ...     try:\n        ...         return key + ':int', int(value)\n        ...     except (ValueError, TypeError):\n        ...         return key, value\n        >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n        ...                 postprocessor=postprocessor)\n        {'a': {'b:int': [1, 2], 'b': 'x'}}\n\n    You can pass an alternate version of `expat` (such as `defusedexpat`) by\n    using the `expat` parameter. E.g:\n\n        >>> import defusedexpat\n        >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n        {'a': 'hello'}\n\n    You can use the force_list argument to force lists to be created even\n    when there is only a single child of a given level of hierarchy. The\n    force_list argument is a tuple of keys. If the key for a given level\n    of hierarchy is in the force_list argument, that level of hierarchy\n    will have a list as a child (even if there is only one sub-element).\n    The index_keys operation takes precedence over this. This is applied\n    after any user-supplied postprocessor has already run.\n\n        For example, given this input:\n        <servers>\n          <server>\n            <name>host1</name>\n            <os>Linux</os>\n            <interfaces>\n              <interface>\n                <name>em0</name>\n                <ip_address>10.0.0.1</ip_address>\n              </interface>\n            </interfaces>\n          </server>\n        </servers>\n\n        If called with force_list=('interface',), it will produce\n        this dictionary:\n        {'servers':\n          {'server':\n            {'name': 'host1',\n             'os': 'Linux'},\n             'interfaces':\n              {'interface':\n                [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n\n        `force_list` can also be a callable that receives `path`, `key` and\n        `value`. This is helpful in cases where the logic that decides whether\n        a list should be forced is more complex.\n\n\n        If `process_comment` is `True` then comment will be added with comment_key\n        (default=`'#comment'`) to then tag which contains comment\n\n            For example, given this input:\n            <a>\n              <b>\n                <!-- b comment -->\n                <c>\n                    <!-- c comment -->\n                    1\n                </c>\n                <d>2</d>\n              </b>\n            </a>\n\n            If called with process_comment=True, it will produce\n            this dictionary:\n            'a': {\n                'b': {\n                    '#comment': 'b comment',\n                    'c': {\n\n                        '#comment': 'c comment',\n                        '#text': '1',\n                    },\n                    'd': '2',\n                },\n            }\n    \"\"\"\n    handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                              **kwargs)\n    if isinstance(xml_input, str):\n        encoding = encoding or 'utf-8'\n        xml_input = xml_input.encode(encoding)\n    if not process_namespaces:\n        namespace_separator = None\n    parser = expat.ParserCreate(\n        encoding,\n        namespace_separator\n    )\n    try:\n        parser.ordered_attributes = True\n    except AttributeError:\n        # Jython's expat does not support ordered_attributes\n        pass\n    parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n    parser.StartElementHandler = handler.startElement\n    parser.EndElementHandler = handler.endElement\n    parser.CharacterDataHandler = handler.characters\n    if process_comments:\n        parser.CommentHandler = handler.comments\n    parser.buffer_text = True\n    if disable_entities:\n        try:\n            # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n            feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n            parser._reader.setFeature(feature, True)\n        except AttributeError:\n            # For CPython / expat parser.\n            # Anything not handled ends up here and entities aren't expanded.\n            parser.DefaultHandler = lambda x: None\n            # Expects an integer return; zero means failure -> expat.ExpatError.\n            parser.ExternalEntityRefHandler = lambda *x: 1\n    if hasattr(xml_input, 'read'):\n        parser.ParseFile(xml_input)\n    elif isgenerator(xml_input):\n        for chunk in xml_input:\n            parser.Parse(chunk, False)\n        parser.Parse(b'', True)\n    else:\n        parser.Parse(xml_input, True)\n    return handler.item\n\n\ndef _process_namespace(name, namespaces, ns_sep=':', attr_prefix='@'):\n    if not namespaces:\n        return name\n    try:\n        ns, name = name.rsplit(ns_sep, 1)\n    except ValueError:\n        pass\n    else:\n        ns_res = namespaces.get(ns.strip(attr_prefix))\n        name = '{}{}{}{}'.format(\n            attr_prefix if ns.startswith(attr_prefix) else '',\n            ns_res, ns_sep, name) if ns_res else name\n    return name\n\n\ndef _emit(key, value, content_handler,\n          attr_prefix='@',\n          cdata_key='#text',\n          depth=0,\n          preprocessor=None,\n          pretty=False,\n          newl='\\n',\n          indent='\\t',\n          namespace_separator=':',\n          namespaces=None,\n          full_document=True,\n          expand_iter=None):\n    key = _process_namespace(key, namespaces, namespace_separator, attr_prefix)\n    if preprocessor is not None:\n        result = preprocessor(key, value)\n        if result is None:\n            return\n        key, value = result\n    if not hasattr(value, '__iter__') or isinstance(value, (str, dict)):\n        value = [value]\n    for index, v in enumerate(value):\n        if full_document and depth == 0 and index > 0:\n            raise ValueError('document with multiple roots')\n        if v is None:\n            v = _dict()\n        elif isinstance(v, bool):\n            v = 'true' if v else 'false'\n        elif not isinstance(v, (dict, str)):\n            if expand_iter and hasattr(v, '__iter__'):\n                v = _dict(((expand_iter, v),))\n            else:\n                v = str(v)\n        if isinstance(v, str):\n            v = _dict(((cdata_key, v),))\n        cdata = None\n        attrs = _dict()\n        children = []\n        for ik, iv in v.items():\n            if ik == cdata_key:\n                cdata = iv\n                continue\n            if ik.startswith(attr_prefix):\n                ik = _process_namespace(ik, namespaces, namespace_separator,\n                                        attr_prefix)\n                if ik == '@xmlns' and isinstance(iv, dict):\n                    for k, v in iv.items():\n                        attr = 'xmlns{}'.format(f':{k}' if k else '')\n                        attrs[attr] = str(v)\n                    continue\n                if not isinstance(iv, str):\n                    iv = str(iv)\n                attrs[ik[len(attr_prefix):]] = iv\n                continue\n            children.append((ik, iv))\n        if isinstance(indent, int):\n            indent = ' ' * indent\n        if pretty:\n            content_handler.ignorableWhitespace(depth * indent)\n        content_handler.startElement(key, AttributesImpl(attrs))\n        if pretty and children:\n            content_handler.ignorableWhitespace(newl)\n        for child_key, child_value in children:\n            _emit(child_key, child_value, content_handler,\n                  attr_prefix, cdata_key, depth+1, preprocessor,\n                  pretty, newl, indent, namespaces=namespaces,\n                  namespace_separator=namespace_separator,\n                  expand_iter=expand_iter)\n        if cdata is not None:\n            content_handler.characters(cdata)\n        if pretty and children:\n            content_handler.ignorableWhitespace(depth * indent)\n        content_handler.endElement(key)\n        if pretty and depth:\n            content_handler.ignorableWhitespace(newl)\n\n\ndef unparse(input_dict, output=None, encoding='utf-8', full_document=True,\n            short_empty_elements=False,\n            **kwargs):\n    \"\"\"Emit an XML document for the given `input_dict` (reverse of `parse`).\n\n    The resulting XML document is returned as a string, but if `output` (a\n    file-like object) is specified, it is written there instead.\n\n    Dictionary keys prefixed with `attr_prefix` (default=`'@'`) are interpreted\n    as XML node attributes, whereas keys equal to `cdata_key`\n    (default=`'#text'`) are treated as character data.\n\n    The `pretty` parameter (default=`False`) enables pretty-printing. In this\n    mode, lines are terminated with `'\\n'` and indented with `'\\t'`, but this\n    can be customized with the `newl` and `indent` parameters.\n\n    \"\"\"\n    if full_document and len(input_dict) != 1:\n        raise ValueError('Document must have exactly one root.')\n    must_return = False\n    if output is None:\n        output = StringIO()\n        must_return = True\n    if short_empty_elements:\n        content_handler = XMLGenerator(output, encoding, True)\n    else:\n        content_handler = XMLGenerator(output, encoding)\n    if full_document:\n        content_handler.startDocument()\n    for key, value in input_dict.items():\n        _emit(key, value, content_handler, full_document=full_document,\n              **kwargs)\n    if full_document:\n        content_handler.endDocument()\n    if must_return:\n        value = output.getvalue()\n        try:  # pragma no cover\n            value = value.decode(encoding)\n        except AttributeError:  # pragma no cover\n            pass\n        return value\n\n\nif __name__ == '__main__':  # pragma: no cover\n    import sys\n    import marshal\n    try:\n        stdin = sys.stdin.buffer\n        stdout = sys.stdout.buffer\n    except AttributeError:\n        stdin = sys.stdin\n        stdout = sys.stdout\n\n    (item_depth,) = sys.argv[1:]\n    item_depth = int(item_depth)\n\n    def handle_item(path, item):\n        marshal.dump((path, item), stdout)\n        return True\n\n    try:\n        root = parse(stdin,\n                     item_depth=item_depth,\n                     item_callback=handle_item,\n                     dict_constructor=dict)\n        if item_depth == 0:\n            handle_item([], root)\n    except KeyboardInterrupt:\n        pass\n"
        }
      ]
    }
  ]
}