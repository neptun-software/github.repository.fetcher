{
  "metadata": {
    "timestamp": 1736561007803,
    "page": 766,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fogleman/Minecraft",
      "stars": 5299,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.03515625,
          "content": "Copyright (C) 2013 Michael Fogleman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.91015625,
          "content": "# Minecraft\n\nSimple Minecraft-inspired demo written in Python and Pyglet.\n\nhttp://www.youtube.com/watch?v=kC3lwK631X8\n\n**Like this project?**\n\nYou might also like my other Minecraft clone written in C using modern OpenGL (GL shader language). It performs better, has better terrain generation and saves state to a sqlite database. See here:\n\nhttps://github.com/fogleman/Craft\n\n## Goals and Vision\n\nI would like to see this project turn into an educational tool. Kids love Minecraft and Python is a great first language.\nThis is a good opportunity to get children excited about programming.\n\nThe code should become well commented and more easily configurable. It should be easy to make some simple changes\nand see the results quickly.\n\nI think it would be great to turn the project into more of a library / API... a Python package that you import and then\nuse / configure to setup a world and run it. Something along these lines...\n\n\n```python\nimport mc\n\nworld = mc.World(...)\nworld.set_block(x, y, z, mc.DIRT)\nmc.run(world)\n```\n\nThe API could contain functionality for the following:\n\n- Easily configurable parameters like gravity, jump velocity, walking speed, etc.\n- Hooks for terrain generation.\n\n## How to Run\n\n```shell\npip install pyglet\ngit clone https://github.com/fogleman/Minecraft.git\ncd Minecraft\npython main.py\n```\n\n### Mac\n\nOn Mac OS X, you may have an issue with running Pyglet in 64-bit mode. Try running Python in 32-bit mode first:\n\n```shell\narch -i386 python main.py\n```\n\nIf that doesn't work, set Python to run in 32-bit mode by default:\n\n```shell\ndefaults write com.apple.versioner.python Prefer-32-Bit -bool yes \n```\n\nThis assumes you are using the OS X default Python.  Works on Lion 10.7 with the default Python 2.7, and may work on other versions too.  Please raise an issue if not.\n    \nOr try Pyglet 1.2 alpha, which supports 64-bit mode:  \n\n```shell\npip install https://pyglet.googlecode.com/files/pyglet-1.2alpha1.tar.gz \n```\n\n### If you don't have pip or git\n\nFor pip:\n\n- Mac or Linux: install with `sudo easy_install pip` (Mac or Linux) - or (Linux) find a package called something like 'python-pip' in your package manager.\n- Windows: [install Distribute then Pip](http://stackoverflow.com/a/12476379/992887) using the linked .MSI installers.\n\nFor git:\n\n- Mac: install [Homebrew](http://mxcl.github.com/homebrew/) first, then `brew install git`.\n- Windows or Linux: see [Installing Git](http://git-scm.com/book/en/Getting-Started-Installing-Git) from the _Pro Git_ book.\n\nSee the [wiki](https://github.com/fogleman/Minecraft/wiki) for this project to install Python, and other tips.\n\n## How to Play\n\n### Moving\n\n- W: forward\n- S: back\n- A: strafe left\n- D: strafe right\n- Mouse: look around\n- Space: jump\n- Tab: toggle flying mode\n\n### Building\n\n- Selecting type of block to create:\n    - 1: brick\n    - 2: grass\n    - 3: sand\n- Mouse left-click: remove block\n- Mouse right-click: create block\n\n### Quitting\n\n- ESC: release mouse, then close window\n"
        },
        {
          "name": "main.py",
          "type": "blob",
          "size": 29.404296875,
          "content": "from __future__ import division\n\nimport sys\nimport math\nimport random\nimport time\n\nfrom collections import deque\nfrom pyglet import image\nfrom pyglet.gl import *\nfrom pyglet.graphics import TextureGroup\nfrom pyglet.window import key, mouse\n\nTICKS_PER_SEC = 60\n\n# Size of sectors used to ease block loading.\nSECTOR_SIZE = 16\n\nWALKING_SPEED = 5\nFLYING_SPEED = 15\n\nGRAVITY = 20.0\nMAX_JUMP_HEIGHT = 1.0 # About the height of a block.\n# To derive the formula for calculating jump speed, first solve\n#    v_t = v_0 + a * t\n# for the time at which you achieve maximum height, where a is the acceleration\n# due to gravity and v_t = 0. This gives:\n#    t = - v_0 / a\n# Use t and the desired MAX_JUMP_HEIGHT to solve for v_0 (jump speed) in\n#    s = s_0 + v_0 * t + (a * t^2) / 2\nJUMP_SPEED = math.sqrt(2 * GRAVITY * MAX_JUMP_HEIGHT)\nTERMINAL_VELOCITY = 50\n\nPLAYER_HEIGHT = 2\n\nif sys.version_info[0] >= 3:\n    xrange = range\n\ndef cube_vertices(x, y, z, n):\n    \"\"\" Return the vertices of the cube at position x, y, z with size 2*n.\n\n    \"\"\"\n    return [\n        x-n,y+n,z-n, x-n,y+n,z+n, x+n,y+n,z+n, x+n,y+n,z-n,  # top\n        x-n,y-n,z-n, x+n,y-n,z-n, x+n,y-n,z+n, x-n,y-n,z+n,  # bottom\n        x-n,y-n,z-n, x-n,y-n,z+n, x-n,y+n,z+n, x-n,y+n,z-n,  # left\n        x+n,y-n,z+n, x+n,y-n,z-n, x+n,y+n,z-n, x+n,y+n,z+n,  # right\n        x-n,y-n,z+n, x+n,y-n,z+n, x+n,y+n,z+n, x-n,y+n,z+n,  # front\n        x+n,y-n,z-n, x-n,y-n,z-n, x-n,y+n,z-n, x+n,y+n,z-n,  # back\n    ]\n\n\ndef tex_coord(x, y, n=4):\n    \"\"\" Return the bounding vertices of the texture square.\n\n    \"\"\"\n    m = 1.0 / n\n    dx = x * m\n    dy = y * m\n    return dx, dy, dx + m, dy, dx + m, dy + m, dx, dy + m\n\n\ndef tex_coords(top, bottom, side):\n    \"\"\" Return a list of the texture squares for the top, bottom and side.\n\n    \"\"\"\n    top = tex_coord(*top)\n    bottom = tex_coord(*bottom)\n    side = tex_coord(*side)\n    result = []\n    result.extend(top)\n    result.extend(bottom)\n    result.extend(side * 4)\n    return result\n\n\nTEXTURE_PATH = 'texture.png'\n\nGRASS = tex_coords((1, 0), (0, 1), (0, 0))\nSAND = tex_coords((1, 1), (1, 1), (1, 1))\nBRICK = tex_coords((2, 0), (2, 0), (2, 0))\nSTONE = tex_coords((2, 1), (2, 1), (2, 1))\n\nFACES = [\n    ( 0, 1, 0),\n    ( 0,-1, 0),\n    (-1, 0, 0),\n    ( 1, 0, 0),\n    ( 0, 0, 1),\n    ( 0, 0,-1),\n]\n\n\ndef normalize(position):\n    \"\"\" Accepts `position` of arbitrary precision and returns the block\n    containing that position.\n\n    Parameters\n    ----------\n    position : tuple of len 3\n\n    Returns\n    -------\n    block_position : tuple of ints of len 3\n\n    \"\"\"\n    x, y, z = position\n    x, y, z = (int(round(x)), int(round(y)), int(round(z)))\n    return (x, y, z)\n\n\ndef sectorize(position):\n    \"\"\" Returns a tuple representing the sector for the given `position`.\n\n    Parameters\n    ----------\n    position : tuple of len 3\n\n    Returns\n    -------\n    sector : tuple of len 3\n\n    \"\"\"\n    x, y, z = normalize(position)\n    x, y, z = x // SECTOR_SIZE, y // SECTOR_SIZE, z // SECTOR_SIZE\n    return (x, 0, z)\n\n\nclass Model(object):\n\n    def __init__(self):\n\n        # A Batch is a collection of vertex lists for batched rendering.\n        self.batch = pyglet.graphics.Batch()\n\n        # A TextureGroup manages an OpenGL texture.\n        self.group = TextureGroup(image.load(TEXTURE_PATH).get_texture())\n\n        # A mapping from position to the texture of the block at that position.\n        # This defines all the blocks that are currently in the world.\n        self.world = {}\n\n        # Same mapping as `world` but only contains blocks that are shown.\n        self.shown = {}\n\n        # Mapping from position to a pyglet `VertextList` for all shown blocks.\n        self._shown = {}\n\n        # Mapping from sector to a list of positions inside that sector.\n        self.sectors = {}\n\n        # Simple function queue implementation. The queue is populated with\n        # _show_block() and _hide_block() calls\n        self.queue = deque()\n\n        self._initialize()\n\n    def _initialize(self):\n        \"\"\" Initialize the world by placing all the blocks.\n\n        \"\"\"\n        n = 80  # 1/2 width and height of world\n        s = 1  # step size\n        y = 0  # initial y height\n        for x in xrange(-n, n + 1, s):\n            for z in xrange(-n, n + 1, s):\n                # create a layer stone an grass everywhere.\n                self.add_block((x, y - 2, z), GRASS, immediate=False)\n                self.add_block((x, y - 3, z), STONE, immediate=False)\n                if x in (-n, n) or z in (-n, n):\n                    # create outer walls.\n                    for dy in xrange(-2, 3):\n                        self.add_block((x, y + dy, z), STONE, immediate=False)\n\n        # generate the hills randomly\n        o = n - 10\n        for _ in xrange(120):\n            a = random.randint(-o, o)  # x position of the hill\n            b = random.randint(-o, o)  # z position of the hill\n            c = -1  # base of the hill\n            h = random.randint(1, 6)  # height of the hill\n            s = random.randint(4, 8)  # 2 * s is the side length of the hill\n            d = 1  # how quickly to taper off the hills\n            t = random.choice([GRASS, SAND, BRICK])\n            for y in xrange(c, c + h):\n                for x in xrange(a - s, a + s + 1):\n                    for z in xrange(b - s, b + s + 1):\n                        if (x - a) ** 2 + (z - b) ** 2 > (s + 1) ** 2:\n                            continue\n                        if (x - 0) ** 2 + (z - 0) ** 2 < 5 ** 2:\n                            continue\n                        self.add_block((x, y, z), t, immediate=False)\n                s -= d  # decrement side length so hills taper off\n\n    def hit_test(self, position, vector, max_distance=8):\n        \"\"\" Line of sight search from current position. If a block is\n        intersected it is returned, along with the block previously in the line\n        of sight. If no block is found, return None, None.\n\n        Parameters\n        ----------\n        position : tuple of len 3\n            The (x, y, z) position to check visibility from.\n        vector : tuple of len 3\n            The line of sight vector.\n        max_distance : int\n            How many blocks away to search for a hit.\n\n        \"\"\"\n        m = 8\n        x, y, z = position\n        dx, dy, dz = vector\n        previous = None\n        for _ in xrange(max_distance * m):\n            key = normalize((x, y, z))\n            if key != previous and key in self.world:\n                return key, previous\n            previous = key\n            x, y, z = x + dx / m, y + dy / m, z + dz / m\n        return None, None\n\n    def exposed(self, position):\n        \"\"\" Returns False is given `position` is surrounded on all 6 sides by\n        blocks, True otherwise.\n\n        \"\"\"\n        x, y, z = position\n        for dx, dy, dz in FACES:\n            if (x + dx, y + dy, z + dz) not in self.world:\n                return True\n        return False\n\n    def add_block(self, position, texture, immediate=True):\n        \"\"\" Add a block with the given `texture` and `position` to the world.\n\n        Parameters\n        ----------\n        position : tuple of len 3\n            The (x, y, z) position of the block to add.\n        texture : list of len 3\n            The coordinates of the texture squares. Use `tex_coords()` to\n            generate.\n        immediate : bool\n            Whether or not to draw the block immediately.\n\n        \"\"\"\n        if position in self.world:\n            self.remove_block(position, immediate)\n        self.world[position] = texture\n        self.sectors.setdefault(sectorize(position), []).append(position)\n        if immediate:\n            if self.exposed(position):\n                self.show_block(position)\n            self.check_neighbors(position)\n\n    def remove_block(self, position, immediate=True):\n        \"\"\" Remove the block at the given `position`.\n\n        Parameters\n        ----------\n        position : tuple of len 3\n            The (x, y, z) position of the block to remove.\n        immediate : bool\n            Whether or not to immediately remove block from canvas.\n\n        \"\"\"\n        del self.world[position]\n        self.sectors[sectorize(position)].remove(position)\n        if immediate:\n            if position in self.shown:\n                self.hide_block(position)\n            self.check_neighbors(position)\n\n    def check_neighbors(self, position):\n        \"\"\" Check all blocks surrounding `position` and ensure their visual\n        state is current. This means hiding blocks that are not exposed and\n        ensuring that all exposed blocks are shown. Usually used after a block\n        is added or removed.\n\n        \"\"\"\n        x, y, z = position\n        for dx, dy, dz in FACES:\n            key = (x + dx, y + dy, z + dz)\n            if key not in self.world:\n                continue\n            if self.exposed(key):\n                if key not in self.shown:\n                    self.show_block(key)\n            else:\n                if key in self.shown:\n                    self.hide_block(key)\n\n    def show_block(self, position, immediate=True):\n        \"\"\" Show the block at the given `position`. This method assumes the\n        block has already been added with add_block()\n\n        Parameters\n        ----------\n        position : tuple of len 3\n            The (x, y, z) position of the block to show.\n        immediate : bool\n            Whether or not to show the block immediately.\n\n        \"\"\"\n        texture = self.world[position]\n        self.shown[position] = texture\n        if immediate:\n            self._show_block(position, texture)\n        else:\n            self._enqueue(self._show_block, position, texture)\n\n    def _show_block(self, position, texture):\n        \"\"\" Private implementation of the `show_block()` method.\n\n        Parameters\n        ----------\n        position : tuple of len 3\n            The (x, y, z) position of the block to show.\n        texture : list of len 3\n            The coordinates of the texture squares. Use `tex_coords()` to\n            generate.\n\n        \"\"\"\n        x, y, z = position\n        vertex_data = cube_vertices(x, y, z, 0.5)\n        texture_data = list(texture)\n        # create vertex list\n        # FIXME Maybe `add_indexed()` should be used instead\n        self._shown[position] = self.batch.add(24, GL_QUADS, self.group,\n            ('v3f/static', vertex_data),\n            ('t2f/static', texture_data))\n\n    def hide_block(self, position, immediate=True):\n        \"\"\" Hide the block at the given `position`. Hiding does not remove the\n        block from the world.\n\n        Parameters\n        ----------\n        position : tuple of len 3\n            The (x, y, z) position of the block to hide.\n        immediate : bool\n            Whether or not to immediately remove the block from the canvas.\n\n        \"\"\"\n        self.shown.pop(position)\n        if immediate:\n            self._hide_block(position)\n        else:\n            self._enqueue(self._hide_block, position)\n\n    def _hide_block(self, position):\n        \"\"\" Private implementation of the 'hide_block()` method.\n\n        \"\"\"\n        self._shown.pop(position).delete()\n\n    def show_sector(self, sector):\n        \"\"\" Ensure all blocks in the given sector that should be shown are\n        drawn to the canvas.\n\n        \"\"\"\n        for position in self.sectors.get(sector, []):\n            if position not in self.shown and self.exposed(position):\n                self.show_block(position, False)\n\n    def hide_sector(self, sector):\n        \"\"\" Ensure all blocks in the given sector that should be hidden are\n        removed from the canvas.\n\n        \"\"\"\n        for position in self.sectors.get(sector, []):\n            if position in self.shown:\n                self.hide_block(position, False)\n\n    def change_sectors(self, before, after):\n        \"\"\" Move from sector `before` to sector `after`. A sector is a\n        contiguous x, y sub-region of world. Sectors are used to speed up\n        world rendering.\n\n        \"\"\"\n        before_set = set()\n        after_set = set()\n        pad = 4\n        for dx in xrange(-pad, pad + 1):\n            for dy in [0]:  # xrange(-pad, pad + 1):\n                for dz in xrange(-pad, pad + 1):\n                    if dx ** 2 + dy ** 2 + dz ** 2 > (pad + 1) ** 2:\n                        continue\n                    if before:\n                        x, y, z = before\n                        before_set.add((x + dx, y + dy, z + dz))\n                    if after:\n                        x, y, z = after\n                        after_set.add((x + dx, y + dy, z + dz))\n        show = after_set - before_set\n        hide = before_set - after_set\n        for sector in show:\n            self.show_sector(sector)\n        for sector in hide:\n            self.hide_sector(sector)\n\n    def _enqueue(self, func, *args):\n        \"\"\" Add `func` to the internal queue.\n\n        \"\"\"\n        self.queue.append((func, args))\n\n    def _dequeue(self):\n        \"\"\" Pop the top function from the internal queue and call it.\n\n        \"\"\"\n        func, args = self.queue.popleft()\n        func(*args)\n\n    def process_queue(self):\n        \"\"\" Process the entire queue while taking periodic breaks. This allows\n        the game loop to run smoothly. The queue contains calls to\n        _show_block() and _hide_block() so this method should be called if\n        add_block() or remove_block() was called with immediate=False\n\n        \"\"\"\n        start = time.perf_counter()\n        while self.queue and time.perf_counter() - start < 1.0 / TICKS_PER_SEC:\n            self._dequeue()\n\n    def process_entire_queue(self):\n        \"\"\" Process the entire queue with no breaks.\n\n        \"\"\"\n        while self.queue:\n            self._dequeue()\n\n\nclass Window(pyglet.window.Window):\n\n    def __init__(self, *args, **kwargs):\n        super(Window, self).__init__(*args, **kwargs)\n\n        # Whether or not the window exclusively captures the mouse.\n        self.exclusive = False\n\n        # When flying gravity has no effect and speed is increased.\n        self.flying = False\n\n        # Strafing is moving lateral to the direction you are facing,\n        # e.g. moving to the left or right while continuing to face forward.\n        #\n        # First element is -1 when moving forward, 1 when moving back, and 0\n        # otherwise. The second element is -1 when moving left, 1 when moving\n        # right, and 0 otherwise.\n        self.strafe = [0, 0]\n\n        # Current (x, y, z) position in the world, specified with floats. Note\n        # that, perhaps unlike in math class, the y-axis is the vertical axis.\n        self.position = (0, 0, 0)\n\n        # First element is rotation of the player in the x-z plane (ground\n        # plane) measured from the z-axis down. The second is the rotation\n        # angle from the ground plane up. Rotation is in degrees.\n        #\n        # The vertical plane rotation ranges from -90 (looking straight down) to\n        # 90 (looking straight up). The horizontal rotation range is unbounded.\n        self.rotation = (0, 0)\n\n        # Which sector the player is currently in.\n        self.sector = None\n\n        # The crosshairs at the center of the screen.\n        self.reticle = None\n\n        # Velocity in the y (upward) direction.\n        self.dy = 0\n\n        # A list of blocks the player can place. Hit num keys to cycle.\n        self.inventory = [BRICK, GRASS, SAND]\n\n        # The current block the user can place. Hit num keys to cycle.\n        self.block = self.inventory[0]\n\n        # Convenience list of num keys.\n        self.num_keys = [\n            key._1, key._2, key._3, key._4, key._5,\n            key._6, key._7, key._8, key._9, key._0]\n\n        # Instance of the model that handles the world.\n        self.model = Model()\n\n        # The label that is displayed in the top left of the canvas.\n        self.label = pyglet.text.Label('', font_name='Arial', font_size=18,\n            x=10, y=self.height - 10, anchor_x='left', anchor_y='top',\n            color=(0, 0, 0, 255))\n\n        # This call schedules the `update()` method to be called\n        # TICKS_PER_SEC. This is the main game event loop.\n        pyglet.clock.schedule_interval(self.update, 1.0 / TICKS_PER_SEC)\n\n    def set_exclusive_mouse(self, exclusive):\n        \"\"\" If `exclusive` is True, the game will capture the mouse, if False\n        the game will ignore the mouse.\n\n        \"\"\"\n        super(Window, self).set_exclusive_mouse(exclusive)\n        self.exclusive = exclusive\n\n    def get_sight_vector(self):\n        \"\"\" Returns the current line of sight vector indicating the direction\n        the player is looking.\n\n        \"\"\"\n        x, y = self.rotation\n        # y ranges from -90 to 90, or -pi/2 to pi/2, so m ranges from 0 to 1 and\n        # is 1 when looking ahead parallel to the ground and 0 when looking\n        # straight up or down.\n        m = math.cos(math.radians(y))\n        # dy ranges from -1 to 1 and is -1 when looking straight down and 1 when\n        # looking straight up.\n        dy = math.sin(math.radians(y))\n        dx = math.cos(math.radians(x - 90)) * m\n        dz = math.sin(math.radians(x - 90)) * m\n        return (dx, dy, dz)\n\n    def get_motion_vector(self):\n        \"\"\" Returns the current motion vector indicating the velocity of the\n        player.\n\n        Returns\n        -------\n        vector : tuple of len 3\n            Tuple containing the velocity in x, y, and z respectively.\n\n        \"\"\"\n        if any(self.strafe):\n            x, y = self.rotation\n            strafe = math.degrees(math.atan2(*self.strafe))\n            y_angle = math.radians(y)\n            x_angle = math.radians(x + strafe)\n            if self.flying:\n                m = math.cos(y_angle)\n                dy = math.sin(y_angle)\n                if self.strafe[1]:\n                    # Moving left or right.\n                    dy = 0.0\n                    m = 1\n                if self.strafe[0] > 0:\n                    # Moving backwards.\n                    dy *= -1\n                # When you are flying up or down, you have less left and right\n                # motion.\n                dx = math.cos(x_angle) * m\n                dz = math.sin(x_angle) * m\n            else:\n                dy = 0.0\n                dx = math.cos(x_angle)\n                dz = math.sin(x_angle)\n        else:\n            dy = 0.0\n            dx = 0.0\n            dz = 0.0\n        return (dx, dy, dz)\n\n    def update(self, dt):\n        \"\"\" This method is scheduled to be called repeatedly by the pyglet\n        clock.\n\n        Parameters\n        ----------\n        dt : float\n            The change in time since the last call.\n\n        \"\"\"\n        self.model.process_queue()\n        sector = sectorize(self.position)\n        if sector != self.sector:\n            self.model.change_sectors(self.sector, sector)\n            if self.sector is None:\n                self.model.process_entire_queue()\n            self.sector = sector\n        m = 8\n        dt = min(dt, 0.2)\n        for _ in xrange(m):\n            self._update(dt / m)\n\n    def _update(self, dt):\n        \"\"\" Private implementation of the `update()` method. This is where most\n        of the motion logic lives, along with gravity and collision detection.\n\n        Parameters\n        ----------\n        dt : float\n            The change in time since the last call.\n\n        \"\"\"\n        # walking\n        speed = FLYING_SPEED if self.flying else WALKING_SPEED\n        d = dt * speed # distance covered this tick.\n        dx, dy, dz = self.get_motion_vector()\n        # New position in space, before accounting for gravity.\n        dx, dy, dz = dx * d, dy * d, dz * d\n        # gravity\n        if not self.flying:\n            # Update your vertical speed: if you are falling, speed up until you\n            # hit terminal velocity; if you are jumping, slow down until you\n            # start falling.\n            self.dy -= dt * GRAVITY\n            self.dy = max(self.dy, -TERMINAL_VELOCITY)\n            dy += self.dy * dt\n        # collisions\n        x, y, z = self.position\n        x, y, z = self.collide((x + dx, y + dy, z + dz), PLAYER_HEIGHT)\n        self.position = (x, y, z)\n\n    def collide(self, position, height):\n        \"\"\" Checks to see if the player at the given `position` and `height`\n        is colliding with any blocks in the world.\n\n        Parameters\n        ----------\n        position : tuple of len 3\n            The (x, y, z) position to check for collisions at.\n        height : int or float\n            The height of the player.\n\n        Returns\n        -------\n        position : tuple of len 3\n            The new position of the player taking into account collisions.\n\n        \"\"\"\n        # How much overlap with a dimension of a surrounding block you need to\n        # have to count as a collision. If 0, touching terrain at all counts as\n        # a collision. If .49, you sink into the ground, as if walking through\n        # tall grass. If >= .5, you'll fall through the ground.\n        pad = 0.25\n        p = list(position)\n        np = normalize(position)\n        for face in FACES:  # check all surrounding blocks\n            for i in xrange(3):  # check each dimension independently\n                if not face[i]:\n                    continue\n                # How much overlap you have with this dimension.\n                d = (p[i] - np[i]) * face[i]\n                if d < pad:\n                    continue\n                for dy in xrange(height):  # check each height\n                    op = list(np)\n                    op[1] -= dy\n                    op[i] += face[i]\n                    if tuple(op) not in self.model.world:\n                        continue\n                    p[i] -= (d - pad) * face[i]\n                    if face == (0, -1, 0) or face == (0, 1, 0):\n                        # You are colliding with the ground or ceiling, so stop\n                        # falling / rising.\n                        self.dy = 0\n                    break\n        return tuple(p)\n\n    def on_mouse_press(self, x, y, button, modifiers):\n        \"\"\" Called when a mouse button is pressed. See pyglet docs for button\n        amd modifier mappings.\n\n        Parameters\n        ----------\n        x, y : int\n            The coordinates of the mouse click. Always center of the screen if\n            the mouse is captured.\n        button : int\n            Number representing mouse button that was clicked. 1 = left button,\n            4 = right button.\n        modifiers : int\n            Number representing any modifying keys that were pressed when the\n            mouse button was clicked.\n\n        \"\"\"\n        if self.exclusive:\n            vector = self.get_sight_vector()\n            block, previous = self.model.hit_test(self.position, vector)\n            if (button == mouse.RIGHT) or \\\n                    ((button == mouse.LEFT) and (modifiers & key.MOD_CTRL)):\n                # ON OSX, control + left click = right click.\n                if previous:\n                    self.model.add_block(previous, self.block)\n            elif button == pyglet.window.mouse.LEFT and block:\n                texture = self.model.world[block]\n                if texture != STONE:\n                    self.model.remove_block(block)\n        else:\n            self.set_exclusive_mouse(True)\n\n    def on_mouse_motion(self, x, y, dx, dy):\n        \"\"\" Called when the player moves the mouse.\n\n        Parameters\n        ----------\n        x, y : int\n            The coordinates of the mouse click. Always center of the screen if\n            the mouse is captured.\n        dx, dy : float\n            The movement of the mouse.\n\n        \"\"\"\n        if self.exclusive:\n            m = 0.15\n            x, y = self.rotation\n            x, y = x + dx * m, y + dy * m\n            y = max(-90, min(90, y))\n            self.rotation = (x, y)\n\n    def on_key_press(self, symbol, modifiers):\n        \"\"\" Called when the player presses a key. See pyglet docs for key\n        mappings.\n\n        Parameters\n        ----------\n        symbol : int\n            Number representing the key that was pressed.\n        modifiers : int\n            Number representing any modifying keys that were pressed.\n\n        \"\"\"\n        if symbol == key.W:\n            self.strafe[0] -= 1\n        elif symbol == key.S:\n            self.strafe[0] += 1\n        elif symbol == key.A:\n            self.strafe[1] -= 1\n        elif symbol == key.D:\n            self.strafe[1] += 1\n        elif symbol == key.SPACE:\n            if self.dy == 0:\n                self.dy = JUMP_SPEED\n        elif symbol == key.ESCAPE:\n            self.set_exclusive_mouse(False)\n        elif symbol == key.TAB:\n            self.flying = not self.flying\n        elif symbol in self.num_keys:\n            index = (symbol - self.num_keys[0]) % len(self.inventory)\n            self.block = self.inventory[index]\n\n    def on_key_release(self, symbol, modifiers):\n        \"\"\" Called when the player releases a key. See pyglet docs for key\n        mappings.\n\n        Parameters\n        ----------\n        symbol : int\n            Number representing the key that was pressed.\n        modifiers : int\n            Number representing any modifying keys that were pressed.\n\n        \"\"\"\n        if symbol == key.W:\n            self.strafe[0] += 1\n        elif symbol == key.S:\n            self.strafe[0] -= 1\n        elif symbol == key.A:\n            self.strafe[1] += 1\n        elif symbol == key.D:\n            self.strafe[1] -= 1\n\n    def on_resize(self, width, height):\n        \"\"\" Called when the window is resized to a new `width` and `height`.\n\n        \"\"\"\n        # label\n        self.label.y = height - 10\n        # reticle\n        if self.reticle:\n            self.reticle.delete()\n        x, y = self.width // 2, self.height // 2\n        n = 10\n        self.reticle = pyglet.graphics.vertex_list(4,\n            ('v2i', (x - n, y, x + n, y, x, y - n, x, y + n))\n        )\n\n    def set_2d(self):\n        \"\"\" Configure OpenGL to draw in 2d.\n\n        \"\"\"\n        width, height = self.get_size()\n        glDisable(GL_DEPTH_TEST)\n        viewport = self.get_viewport_size()\n        glViewport(0, 0, max(1, viewport[0]), max(1, viewport[1]))\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        glOrtho(0, max(1, width), 0, max(1, height), -1, 1)\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n\n    def set_3d(self):\n        \"\"\" Configure OpenGL to draw in 3d.\n\n        \"\"\"\n        width, height = self.get_size()\n        glEnable(GL_DEPTH_TEST)\n        viewport = self.get_viewport_size()\n        glViewport(0, 0, max(1, viewport[0]), max(1, viewport[1]))\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        gluPerspective(65.0, width / float(height), 0.1, 60.0)\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n        x, y = self.rotation\n        glRotatef(x, 0, 1, 0)\n        glRotatef(-y, math.cos(math.radians(x)), 0, math.sin(math.radians(x)))\n        x, y, z = self.position\n        glTranslatef(-x, -y, -z)\n\n    def on_draw(self):\n        \"\"\" Called by pyglet to draw the canvas.\n\n        \"\"\"\n        self.clear()\n        self.set_3d()\n        glColor3d(1, 1, 1)\n        self.model.batch.draw()\n        self.draw_focused_block()\n        self.set_2d()\n        self.draw_label()\n        self.draw_reticle()\n\n    def draw_focused_block(self):\n        \"\"\" Draw black edges around the block that is currently under the\n        crosshairs.\n\n        \"\"\"\n        vector = self.get_sight_vector()\n        block = self.model.hit_test(self.position, vector)[0]\n        if block:\n            x, y, z = block\n            vertex_data = cube_vertices(x, y, z, 0.51)\n            glColor3d(0, 0, 0)\n            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)\n            pyglet.graphics.draw(24, GL_QUADS, ('v3f/static', vertex_data))\n            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)\n\n    def draw_label(self):\n        \"\"\" Draw the label in the top left of the screen.\n\n        \"\"\"\n        x, y, z = self.position\n        self.label.text = '%02d (%.2f, %.2f, %.2f) %d / %d' % (\n            pyglet.clock.get_fps(), x, y, z,\n            len(self.model._shown), len(self.model.world))\n        self.label.draw()\n\n    def draw_reticle(self):\n        \"\"\" Draw the crosshairs in the center of the screen.\n\n        \"\"\"\n        glColor3d(0, 0, 0)\n        self.reticle.draw(GL_LINES)\n\n\ndef setup_fog():\n    \"\"\" Configure the OpenGL fog properties.\n\n    \"\"\"\n    # Enable fog. Fog \"blends a fog color with each rasterized pixel fragment's\n    # post-texturing color.\"\n    glEnable(GL_FOG)\n    # Set the fog color.\n    glFogfv(GL_FOG_COLOR, (GLfloat * 4)(0.5, 0.69, 1.0, 1))\n    # Say we have no preference between rendering speed and quality.\n    glHint(GL_FOG_HINT, GL_DONT_CARE)\n    # Specify the equation used to compute the blending factor.\n    glFogi(GL_FOG_MODE, GL_LINEAR)\n    # How close and far away fog starts and ends. The closer the start and end,\n    # the denser the fog in the fog range.\n    glFogf(GL_FOG_START, 20.0)\n    glFogf(GL_FOG_END, 60.0)\n\n\ndef setup():\n    \"\"\" Basic OpenGL configuration.\n\n    \"\"\"\n    # Set the color of \"clear\", i.e. the sky, in rgba.\n    glClearColor(0.5, 0.69, 1.0, 1)\n    # Enable culling (not rendering) of back-facing facets -- facets that aren't\n    # visible to you.\n    glEnable(GL_CULL_FACE)\n    # Set the texture minification/magnification function to GL_NEAREST (nearest\n    # in Manhattan distance) to the specified texture coordinates. GL_NEAREST\n    # \"is generally faster than GL_LINEAR, but it can produce textured images\n    # with sharper edges because the transition between texture elements is not\n    # as smooth.\"\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)\n    setup_fog()\n\n\ndef main():\n    window = Window(width=800, height=600, caption='Pyglet', resizable=True)\n    # Hide the mouse cursor and prevent the mouse from leaving the window.\n    window.set_exclusive_mouse(True)\n    setup()\n    pyglet.app.run()\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "texture.png",
          "type": "blob",
          "size": 5.1337890625,
          "content": null
        }
      ]
    }
  ]
}