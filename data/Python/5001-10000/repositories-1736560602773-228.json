{
  "metadata": {
    "timestamp": 1736560602773,
    "page": 228,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "docopt/docopt",
      "stars": 7957,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.291015625,
          "content": "*.py[co]\n\n# Vim\n*.swp\n\n# Packages\n*.egg\n*.egg-info\ndist\nbuild\neggs\nparts\nbin\nvar\nsdist\ndevelop-eggs\n.installed.cfg\n\n# Installer logs\npip-log.txt\n\n# Unit test / coverage reports\n.coverage\n.tox\nnosetests.xml\n\n#Translations\n*.mo\n\n#Mr Developer\n.mr.developer.cfg\n\n# Sphinx\ndocs/_*\n\n# jython\n*$py.class\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.12109375,
          "content": "language: python\ncache: pip\npython:\n  - \"2.7\"\n  - \"3.4\"\n  - \"3.5\"\n  - \"3.6\"\ninstall: pip install tox tox-travis\nscript: tox\n"
        },
        {
          "name": "LICENSE-MIT",
          "type": "blob",
          "size": 1.060546875,
          "content": "Copyright (c) 2012 Vladimir Keleshev, <vladimir@keleshev.com>\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the Software\nwithout restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to\nwhom the Software is furnished to do so, subject to the\nfollowing conditions:\n\nThe above copyright notice and this permission notice shall\nbe included in all copies or substantial portions of the\nSoftware.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY\nKIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.0615234375,
          "content": "include README.rst LICENSE-MIT\nrecursive-include examples *.py\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 17.5517578125,
          "content": "``docopt`` creates *beautiful* command-line interfaces\n======================================================================\n\n.. image:: https://travis-ci.org/docopt/docopt.svg?branch=master\n    :target: https://travis-ci.org/docopt/docopt\n\n.. image:: https://img.shields.io/pypi/v/docopt.svg\n    :target: https://pypi.python.org/pypi/docopt\n\nVideo introduction to **docopt**: `PyCon UK 2012: Create *beautiful*\ncommand-line interfaces with Python <http://youtu.be/pXhcPJK5cMc>`_\n\n    New in version 0.6.1:\n\n    - Fix issue `#85 <https://github.com/docopt/docopt/issues/85>`_\n      which caused improper handling of ``[options]`` shortcut\n      if it was present several times.\n\n    New in version 0.6.0:\n\n    - New argument ``options_first``, disallows interspersing options\n      and arguments.  If you supply ``options_first=True`` to\n      ``docopt``, it will interpret all arguments as positional\n      arguments after first positional argument.\n\n    - If option with argument could be repeated, its default value\n      will be interpreted as space-separated list. E.g. with\n      ``[default: ./here ./there]`` will be interpreted as\n      ``['./here', './there']``.\n\n    Breaking changes:\n\n    - Meaning of ``[options]`` shortcut slightly changed. Previously\n      it meant *\"any known option\"*. Now it means *\"any option not in\n      usage-pattern\"*.  This avoids the situation when an option is\n      allowed to be repeated unintentionally.\n\n    - ``argv`` is ``None`` by default, not ``sys.argv[1:]``.\n      This allows ``docopt`` to always use the *latest* ``sys.argv``,\n      not ``sys.argv`` during import time.\n\nIsn't it awesome how ``optparse`` and ``argparse`` generate help\nmessages based on your code?!\n\n*Hell no!*  You know what's awesome?  It's when the option parser *is*\ngenerated based on the beautiful help message that you write yourself!\nThis way you don't need to write this stupid repeatable parser-code,\nand instead can write only the help message--*the way you want it*.\n\n**docopt** helps you create most beautiful command-line interfaces\n*easily*:\n\n.. code:: python\n\n    \"\"\"Naval Fate.\n\n    Usage:\n      naval_fate.py ship new <name>...\n      naval_fate.py ship <name> move <x> <y> [--speed=<kn>]\n      naval_fate.py ship shoot <x> <y>\n      naval_fate.py mine (set|remove) <x> <y> [--moored | --drifting]\n      naval_fate.py (-h | --help)\n      naval_fate.py --version\n\n    Options:\n      -h --help     Show this screen.\n      --version     Show version.\n      --speed=<kn>  Speed in knots [default: 10].\n      --moored      Moored (anchored) mine.\n      --drifting    Drifting mine.\n\n    \"\"\"\n    from docopt import docopt\n\n\n    if __name__ == '__main__':\n        arguments = docopt(__doc__, version='Naval Fate 2.0')\n        print(arguments)\n\nBeat that! The option parser is generated based on the docstring above\nthat is passed to ``docopt`` function.  ``docopt`` parses the usage\npattern (``\"Usage: ...\"``) and option descriptions (lines starting\nwith dash \"``-``\") and ensures that the program invocation matches the\nusage pattern; it parses options, arguments and commands based on\nthat. The basic idea is that *a good help message has all necessary\ninformation in it to make a parser*.\n\nAlso, `PEP 257 <http://www.python.org/dev/peps/pep-0257/>`_ recommends\nputting help message in the module docstrings.\n\nInstallation\n======================================================================\n\nUse `pip <http://pip-installer.org>`_ or easy_install::\n\n    pip install docopt==0.6.2\n\nAlternatively, you can just drop ``docopt.py`` file into your\nproject--it is self-contained.\n\n**docopt** is tested with Python 2.7, 3.4, 3.5, and 3.6.\n\nTesting\n======================================================================\n\nYou can run unit tests using the command:\n\n    python setup.py test\n\nAPI\n======================================================================\n\n.. code:: python\n\n    from docopt import docopt\n\n.. code:: python\n\n    docopt(doc, argv=None, help=True, version=None, options_first=False)\n\n``docopt`` takes 1 required and 4 optional arguments:\n\n- ``doc`` could be a module docstring (``__doc__``) or some other\n  string that contains a **help message** that will be parsed to\n  create the option parser.  The simple rules of how to write such a\n  help message are given in next sections.  Here is a quick example of\n  such a string:\n\n.. code:: python\n\n    \"\"\"Usage: my_program.py [-hso FILE] [--quiet | --verbose] [INPUT ...]\n\n    -h --help    show this\n    -s --sorted  sorted output\n    -o FILE      specify output file [default: ./test.txt]\n    --quiet      print less text\n    --verbose    print more text\n\n    \"\"\"\n\n- ``argv`` is an optional argument vector; by default ``docopt`` uses\n  the argument vector passed to your program (``sys.argv[1:]``).\n  Alternatively you can supply a list of strings like ``['--verbose',\n  '-o', 'hai.txt']``.\n\n- ``help``, by default ``True``, specifies whether the parser should\n  automatically print the help message (supplied as ``doc``) and\n  terminate, in case ``-h`` or ``--help`` option is encountered\n  (options should exist in usage pattern, more on that below). If you\n  want to handle ``-h`` or ``--help`` options manually (as other\n  options), set ``help=False``.\n\n- ``version``, by default ``None``, is an optional argument that\n  specifies the version of your program. If supplied, then, (assuming\n  ``--version`` option is mentioned in usage pattern) when parser\n  encounters the ``--version`` option, it will print the supplied\n  version and terminate.  ``version`` could be any printable object,\n  but most likely a string, e.g. ``\"2.1.0rc1\"``.\n\n    Note, when ``docopt`` is set to automatically handle ``-h``,\n    ``--help`` and ``--version`` options, you still need to mention\n    them in usage pattern for this to work. Also, for your users to\n    know about them.\n\n- ``options_first``, by default ``False``.  If set to ``True`` will\n  disallow mixing options and positional argument.  I.e. after first\n  positional argument, all arguments will be interpreted as positional\n  even if the look like options.  This can be used for strict\n  compatibility with POSIX, or if you want to dispatch your arguments\n  to other programs.\n\nThe **return** value is a simple dictionary with options, arguments\nand commands as keys, spelled exactly like in your help message.  Long\nversions of options are given priority. For example, if you invoke the\ntop example as::\n\n    naval_fate.py ship Guardian move 100 150 --speed=15\n\nthe return dictionary will be:\n\n.. code:: python\n\n    {'--drifting': False,    'mine': False,\n     '--help': False,        'move': True,\n     '--moored': False,      'new': False,\n     '--speed': '15',        'remove': False,\n     '--version': False,     'set': False,\n     '<name>': ['Guardian'], 'ship': True,\n     '<x>': '100',           'shoot': False,\n     '<y>': '150'}\n\nHelp message format\n======================================================================\n\nHelp message consists of 2 parts:\n\n- Usage pattern, e.g.::\n\n    Usage: my_program.py [-hso FILE] [--quiet | --verbose] [INPUT ...]\n\n- Option descriptions, e.g.::\n\n    -h --help    show this\n    -s --sorted  sorted output\n    -o FILE      specify output file [default: ./test.txt]\n    --quiet      print less text\n    --verbose    print more text\n\nTheir format is described below; other text is ignored.\n\nUsage pattern format\n----------------------------------------------------------------------\n\n**Usage pattern** is a substring of ``doc`` that starts with\n``usage:`` (case *insensitive*) and ends with a *visibly* empty line.\nMinimum example:\n\n.. code:: python\n\n    \"\"\"Usage: my_program.py\n\n    \"\"\"\n\nThe first word after ``usage:`` is interpreted as your program's name.\nYou can specify your program's name several times to signify several\nexclusive patterns:\n\n.. code:: python\n\n    \"\"\"Usage: my_program.py FILE\n              my_program.py COUNT FILE\n\n    \"\"\"\n\nEach pattern can consist of the following elements:\n\n- **<arguments>**, **ARGUMENTS**. Arguments are specified as either\n  upper-case words, e.g. ``my_program.py CONTENT-PATH`` or words\n  surrounded by angular brackets: ``my_program.py <content-path>``.\n- **--options**.  Options are words started with dash (``-``), e.g.\n  ``--output``, ``-o``.  You can \"stack\" several of one-letter\n  options, e.g. ``-oiv`` which will be the same as ``-o -i -v``. The\n  options can have arguments, e.g.  ``--input=FILE`` or ``-i FILE`` or\n  even ``-iFILE``. However it is important that you specify option\n  descriptions if you want your option to have an argument, a default\n  value, or specify synonymous short/long versions of the option (see\n  next section on option descriptions).\n- **commands** are words that do *not* follow the described above\n  conventions of ``--options`` or ``<arguments>`` or ``ARGUMENTS``,\n  plus two special commands: dash \"``-``\" and double dash \"``--``\"\n  (see below).\n\nUse the following constructs to specify patterns:\n\n- **[ ]** (brackets) **optional** elements.  e.g.: ``my_program.py\n  [-hvqo FILE]``\n- **( )** (parens) **required** elements.  All elements that are *not*\n  put in **[ ]** are also required, e.g.: ``my_program.py\n  --path=<path> <file>...`` is the same as ``my_program.py\n  (--path=<path> <file>...)``.  (Note, \"required options\" might be not\n  a good idea for your users).\n- **|** (pipe) **mutually exclusive** elements. Group them using **(\n  )** if one of the mutually exclusive elements is required:\n  ``my_program.py (--clockwise | --counter-clockwise) TIME``. Group\n  them using **[ ]** if none of the mutually-exclusive elements are\n  required: ``my_program.py [--left | --right]``.\n- **...** (ellipsis) **one or more** elements. To specify that\n  arbitrary number of repeating elements could be accepted, use\n  ellipsis (``...``), e.g.  ``my_program.py FILE ...`` means one or\n  more ``FILE``-s are accepted.  If you want to accept zero or more\n  elements, use brackets, e.g.: ``my_program.py [FILE ...]``. Ellipsis\n  works as a unary operator on the expression to the left.\n- **[options]** (case sensitive) shortcut for any options.  You can\n  use it if you want to specify that the usage pattern could be\n  provided with any options defined below in the option-descriptions\n  and do not want to enumerate them all in usage-pattern.\n- \"``[--]``\". Double dash \"``--``\" is used by convention to separate\n  positional arguments that can be mistaken for options. In order to\n  support this convention add \"``[--]``\" to your usage patterns.\n- \"``[-]``\". Single dash \"``-``\" is used by convention to signify that\n  ``stdin`` is used instead of a file. To support this add \"``[-]``\"\n  to your usage patterns. \"``-``\" acts as a normal command.\n\nIf your pattern allows to match argument-less option (a flag) several\ntimes::\n\n    Usage: my_program.py [-v | -vv | -vvv]\n\nthen number of occurrences of the option will be counted. I.e.\n``args['-v']`` will be ``2`` if program was invoked as ``my_program\n-vv``. Same works for commands.\n\nIf your usage patterns allows to match same-named option with argument\nor positional argument several times, the matched arguments will be\ncollected into a list::\n\n    Usage: my_program.py <file> <file> --path=<path>...\n\nI.e. invoked with ``my_program.py file1 file2 --path=./here\n--path=./there`` the returned dict will contain ``args['<file>'] ==\n['file1', 'file2']`` and ``args['--path'] == ['./here', './there']``.\n\n\nOption descriptions format\n----------------------------------------------------------------------\n\n**Option descriptions** consist of a list of options that you put\nbelow your usage patterns.\n\nIt is necessary to list option descriptions in order to specify:\n\n- synonymous short and long options,\n- if an option has an argument,\n- if option's argument has a default value.\n\nThe rules are as follows:\n\n- Every line in ``doc`` that starts with ``-`` or ``--`` (not counting\n  spaces) is treated as an option description, e.g.::\n\n    Options:\n      --verbose   # GOOD\n      -o FILE     # GOOD\n    Other: --bad  # BAD, line does not start with dash \"-\"\n\n- To specify that option has an argument, put a word describing that\n  argument after space (or equals \"``=``\" sign) as shown below. Follow\n  either <angular-brackets> or UPPER-CASE convention for options'\n  arguments.  You can use comma if you want to separate options. In\n  the example below, both lines are valid, however you are recommended\n  to stick to a single style.::\n\n    -o FILE --output=FILE       # without comma, with \"=\" sign\n    -i <file>, --input <file>   # with comma, without \"=\" sign\n\n- Use two spaces to separate options with their informal description::\n\n    --verbose More text.   # BAD, will be treated as if verbose option had\n                           # an argument \"More\", so use 2 spaces instead\n    -q        Quit.        # GOOD\n    -o FILE   Output file. # GOOD\n    --stdout  Use stdout.  # GOOD, 2 spaces\n\n- If you want to set a default value for an option with an argument,\n  put it into the option-description, in form ``[default:\n  <my-default-value>]``::\n\n    --coefficient=K  The K coefficient [default: 2.95]\n    --output=FILE    Output file [default: test.txt]\n    --directory=DIR  Some directory [default: ./]\n\n- If the option is not repeatable, the value inside ``[default: ...]``\n  will be interpreted as string.  If it *is* repeatable, it will be\n  splited into a list on whitespace::\n\n    Usage: my_program.py [--repeatable=<arg> --repeatable=<arg>]\n                         [--another-repeatable=<arg>]...\n                         [--not-repeatable=<arg>]\n\n    # will be ['./here', './there']\n    --repeatable=<arg>          [default: ./here ./there]\n\n    # will be ['./here']\n    --another-repeatable=<arg>  [default: ./here]\n\n    # will be './here ./there', because it is not repeatable\n    --not-repeatable=<arg>      [default: ./here ./there]\n\nExamples\n----------------------------------------------------------------------\n\nWe have an extensive list of `examples\n<https://github.com/docopt/docopt/tree/master/examples>`_ which cover\nevery aspect of functionality of **docopt**.  Try them out, read the\nsource if in doubt.\n\nSubparsers, multi-level help and *huge* applications (like git)\n----------------------------------------------------------------------\n\nIf you want to split your usage-pattern into several, implement\nmulti-level help (with separate help-screen for each subcommand),\nwant to interface with existing scripts that don't use **docopt**, or\nyou're building the next \"git\", you will need the new ``options_first``\nparameter (described in API section above). To get you started quickly\nwe implemented a subset of git command-line interface as an example:\n`examples/git\n<https://github.com/docopt/docopt/tree/master/examples/git>`_\n\n\nData validation\n----------------------------------------------------------------------\n\n**docopt** does one thing and does it well: it implements your\ncommand-line interface.  However it does not validate the input data.\nOn the other hand there are libraries like `python schema\n<https://github.com/halst/schema>`_ which make validating data a\nbreeze.  Take a look at `validation_example.py\n<https://github.com/docopt/docopt/tree/master/examples/validation_example.py>`_\nwhich uses **schema** to validate data and report an error to the\nuser.\n\nUsing docopt with config-files\n----------------------------------------------------------------------\n\nOften configuration files are used to provide default values which\ncould be overriden by command-line arguments.  Since **docopt**\nreturns a simple dictionary it is very easy to integrate with\nconfig-files written in JSON, YAML or INI formats.\n`config_file_example.py <examples/config_file_example.py>`_ provides\nand example of how to use **docopt** with JSON or INI config-file.\n\n\nDevelopment\n======================================================================\n\nWe would *love* to hear what you think about **docopt** on our `issues\npage <http://github.com/docopt/docopt/issues>`_\n\nMake pull requests, report bugs, suggest ideas and discuss\n**docopt**. You can also drop a line directly to\n<vladimir@keleshev.com>.\n\nPorting ``docopt`` to other languages\n======================================================================\n\nWe think **docopt** is so good, we want to share it beyond the Python\ncommunity! All official docopt ports to other languages can be found\nunder the `docopt organization page <http://github.com/docopt>`_\non GitHub.\n\nIf your favourite language isn't among then, you can always create a\nport for it! You are encouraged to use the Python version as a\nreference implementation.  A Language-agnostic test suite is bundled\nwith `Python implementation <http://github.com/docopt/docopt>`_.\n\nPorting discussion is on `issues page\n<http://github.com/docopt/docopt/issues>`_.\n\nChangelog\n======================================================================\n\n**docopt** follows `semantic versioning <http://semver.org>`_.  The\nfirst release with stable API will be 1.0.0 (soon).  Until then, you\nare encouraged to specify explicitly the version in your dependency\ntools, e.g.::\n\n    pip install docopt==0.6.2\n\n- 0.6.2 Bugfix release.\n- 0.6.1 Bugfix release.\n- 0.6.0 ``options_first`` parameter.\n  **Breaking changes**: Corrected ``[options]`` meaning.\n  ``argv`` defaults to ``None``.\n- 0.5.0 Repeated options/commands are counted or accumulated into a\n  list.\n- 0.4.2 Bugfix release.\n- 0.4.0 Option descriptions become optional,\n  support for \"``--``\" and \"``-``\" commands.\n- 0.3.0 Support for (sub)commands like `git remote add`.\n  Introduce ``[options]`` shortcut for any options.\n  **Breaking changes**: ``docopt`` returns dictionary.\n- 0.2.0 Usage pattern matching. Positional arguments parsing based on\n  usage patterns.\n  **Breaking changes**: ``docopt`` returns namespace (for arguments),\n  not list. Usage pattern is formalized.\n- 0.1.0 Initial release. Options-parsing only (based on options\n  description).\n"
        },
        {
          "name": "conftest.py",
          "type": "blob",
          "size": 2.1552734375,
          "content": "import re\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\nimport pytest\n\nimport docopt\n\n\ndef pytest_collect_file(path, parent):\n    if path.ext == \".docopt\" and path.basename.startswith(\"test\"):\n        return DocoptTestFile(path, parent)\n\n\ndef parse_test(raw):\n    raw = re.compile('#.*$', re.M).sub('', raw).strip()\n    if raw.startswith('\"\"\"'):\n        raw = raw[3:]\n\n    for fixture in raw.split('r\"\"\"'):\n        name = ''\n        doc, _, body = fixture.partition('\"\"\"')\n        cases = []\n        for case in body.split('$')[1:]:\n            argv, _, expect = case.strip().partition('\\n')\n            expect = json.loads(expect)\n            prog, _, argv = argv.strip().partition(' ')\n            cases.append((prog, argv, expect))\n\n        yield name, doc, cases\n\n\nclass DocoptTestFile(pytest.File):\n\n    def collect(self):\n        raw = self.fspath.open().read()\n        index = 1\n\n        for name, doc, cases in parse_test(raw):\n            name = self.fspath.purebasename\n            for case in cases:\n                yield DocoptTestItem(\"%s(%d)\" % (name, index), self, doc, case)\n                index += 1\n\n\nclass DocoptTestItem(pytest.Item):\n\n    def __init__(self, name, parent, doc, case):\n        super(DocoptTestItem, self).__init__(name, parent)\n        self.doc = doc\n        self.prog, self.argv, self.expect = case\n\n    def runtest(self):\n        try:\n            result = docopt.docopt(self.doc, argv=self.argv)\n        except docopt.DocoptExit:\n            result = 'user-error'\n\n        if self.expect != result:\n            raise DocoptTestException(self, result)\n\n    def repr_failure(self, excinfo):\n        \"\"\"Called when self.runtest() raises an exception.\"\"\"\n        if isinstance(excinfo.value, DocoptTestException):\n            return \"\\n\".join((\n                \"usecase execution failed:\",\n                self.doc.rstrip(),\n                \"$ %s %s\" % (self.prog, self.argv),\n                \"result> %s\" % json.dumps(excinfo.value.args[1]),\n                \"expect> %s\" % json.dumps(self.expect),\n            ))\n\n    def reportinfo(self):\n        return self.fspath, 0, \"usecase: %s\" % self.name\n\n\nclass DocoptTestException(Exception):\n    pass\n"
        },
        {
          "name": "docopt.py",
          "type": "blob",
          "size": 19.3203125,
          "content": "\"\"\"Pythonic command-line interface parser that will make you smile.\n\n * http://docopt.org\n * Repository and issue-tracker: https://github.com/docopt/docopt\n * Licensed under terms of MIT license (see LICENSE-MIT)\n * Copyright (c) 2013 Vladimir Keleshev, vladimir@keleshev.com\n\n\"\"\"\nimport sys\nimport re\n\n\n__all__ = ['docopt']\n__version__ = '0.6.2'\n\n\nclass DocoptLanguageError(Exception):\n\n    \"\"\"Error in construction of usage-message by developer.\"\"\"\n\n\nclass DocoptExit(SystemExit):\n\n    \"\"\"Exit in case user invoked program with incorrect arguments.\"\"\"\n\n    usage = ''\n\n    def __init__(self, message=''):\n        SystemExit.__init__(self, (message + '\\n' + self.usage).strip())\n\n\nclass Pattern(object):\n\n    def __eq__(self, other):\n        return repr(self) == repr(other)\n\n    def __hash__(self):\n        return hash(repr(self))\n\n    def fix(self):\n        self.fix_identities()\n        self.fix_repeating_arguments()\n        return self\n\n    def fix_identities(self, uniq=None):\n        \"\"\"Make pattern-tree tips point to same object if they are equal.\"\"\"\n        if not hasattr(self, 'children'):\n            return self\n        uniq = list(set(self.flat())) if uniq is None else uniq\n        for i, child in enumerate(self.children):\n            if not hasattr(child, 'children'):\n                assert child in uniq\n                self.children[i] = uniq[uniq.index(child)]\n            else:\n                child.fix_identities(uniq)\n\n    def fix_repeating_arguments(self):\n        \"\"\"Fix elements that should accumulate/increment values.\"\"\"\n        either = [list(child.children) for child in transform(self).children]\n        for case in either:\n            for e in [child for child in case if case.count(child) > 1]:\n                if type(e) is Argument or type(e) is Option and e.argcount:\n                    if e.value is None:\n                        e.value = []\n                    elif type(e.value) is not list:\n                        e.value = e.value.split()\n                if type(e) is Command or type(e) is Option and e.argcount == 0:\n                    e.value = 0\n        return self\n\n\ndef transform(pattern):\n    \"\"\"Expand pattern into an (almost) equivalent one, but with single Either.\n\n    Example: ((-a | -b) (-c | -d)) => (-a -c | -a -d | -b -c | -b -d)\n    Quirks: [-a] => (-a), (-a...) => (-a -a)\n\n    \"\"\"\n    result = []\n    groups = [[pattern]]\n    while groups:\n        children = groups.pop(0)\n        parents = [Required, Optional, OptionsShortcut, Either, OneOrMore]\n        if any(t in map(type, children) for t in parents):\n            child = [c for c in children if type(c) in parents][0]\n            children.remove(child)\n            if type(child) is Either:\n                for c in child.children:\n                    groups.append([c] + children)\n            elif type(child) is OneOrMore:\n                groups.append(child.children * 2 + children)\n            else:\n                groups.append(child.children + children)\n        else:\n            result.append(children)\n    return Either(*[Required(*e) for e in result])\n\n\nclass LeafPattern(Pattern):\n\n    \"\"\"Leaf/terminal node of a pattern tree.\"\"\"\n\n    def __init__(self, name, value=None):\n        self.name, self.value = name, value\n\n    def __repr__(self):\n        return '%s(%r, %r)' % (self.__class__.__name__, self.name, self.value)\n\n    def flat(self, *types):\n        return [self] if not types or type(self) in types else []\n\n    def match(self, left, collected=None):\n        collected = [] if collected is None else collected\n        pos, match = self.single_match(left)\n        if match is None:\n            return False, left, collected\n        left_ = left[:pos] + left[pos + 1:]\n        same_name = [a for a in collected if a.name == self.name]\n        if type(self.value) in (int, list):\n            if type(self.value) is int:\n                increment = 1\n            else:\n                increment = ([match.value] if type(match.value) is str\n                             else match.value)\n            if not same_name:\n                match.value = increment\n                return True, left_, collected + [match]\n            same_name[0].value += increment\n            return True, left_, collected\n        return True, left_, collected + [match]\n\n\nclass BranchPattern(Pattern):\n\n    \"\"\"Branch/inner node of a pattern tree.\"\"\"\n\n    def __init__(self, *children):\n        self.children = list(children)\n\n    def __repr__(self):\n        return '%s(%s)' % (self.__class__.__name__,\n                           ', '.join(repr(a) for a in self.children))\n\n    def flat(self, *types):\n        if type(self) in types:\n            return [self]\n        return sum([child.flat(*types) for child in self.children], [])\n\n\nclass Argument(LeafPattern):\n\n    def single_match(self, left):\n        for n, pattern in enumerate(left):\n            if type(pattern) is Argument:\n                return n, Argument(self.name, pattern.value)\n        return None, None\n\n    @classmethod\n    def parse(class_, source):\n        name = re.findall('(<\\S*?>)', source)[0]\n        value = re.findall('\\[default: (.*)\\]', source, flags=re.I)\n        return class_(name, value[0] if value else None)\n\n\nclass Command(Argument):\n\n    def __init__(self, name, value=False):\n        self.name, self.value = name, value\n\n    def single_match(self, left):\n        for n, pattern in enumerate(left):\n            if type(pattern) is Argument:\n                if pattern.value == self.name:\n                    return n, Command(self.name, True)\n                else:\n                    break\n        return None, None\n\n\nclass Option(LeafPattern):\n\n    def __init__(self, short=None, long=None, argcount=0, value=False):\n        assert argcount in (0, 1)\n        self.short, self.long, self.argcount = short, long, argcount\n        self.value = None if value is False and argcount else value\n\n    @classmethod\n    def parse(class_, option_description):\n        short, long, argcount, value = None, None, 0, False\n        options, _, description = option_description.strip().partition('  ')\n        options = options.replace(',', ' ').replace('=', ' ')\n        for s in options.split():\n            if s.startswith('--'):\n                long = s\n            elif s.startswith('-'):\n                short = s\n            else:\n                argcount = 1\n        if argcount:\n            matched = re.findall('\\[default: (.*)\\]', description, flags=re.I)\n            value = matched[0] if matched else None\n        return class_(short, long, argcount, value)\n\n    def single_match(self, left):\n        for n, pattern in enumerate(left):\n            if self.name == pattern.name:\n                return n, pattern\n        return None, None\n\n    @property\n    def name(self):\n        return self.long or self.short\n\n    def __repr__(self):\n        return 'Option(%r, %r, %r, %r)' % (self.short, self.long,\n                                           self.argcount, self.value)\n\n\nclass Required(BranchPattern):\n\n    def match(self, left, collected=None):\n        collected = [] if collected is None else collected\n        l = left\n        c = collected\n        for pattern in self.children:\n            matched, l, c = pattern.match(l, c)\n            if not matched:\n                return False, left, collected\n        return True, l, c\n\n\nclass Optional(BranchPattern):\n\n    def match(self, left, collected=None):\n        collected = [] if collected is None else collected\n        for pattern in self.children:\n            m, left, collected = pattern.match(left, collected)\n        return True, left, collected\n\n\nclass OptionsShortcut(Optional):\n\n    \"\"\"Marker/placeholder for [options] shortcut.\"\"\"\n\n\nclass OneOrMore(BranchPattern):\n\n    def match(self, left, collected=None):\n        assert len(self.children) == 1\n        collected = [] if collected is None else collected\n        l = left\n        c = collected\n        l_ = None\n        matched = True\n        times = 0\n        while matched:\n            # could it be that something didn't match but changed l or c?\n            matched, l, c = self.children[0].match(l, c)\n            times += 1 if matched else 0\n            if l_ == l:\n                break\n            l_ = l\n        if times >= 1:\n            return True, l, c\n        return False, left, collected\n\n\nclass Either(BranchPattern):\n\n    def match(self, left, collected=None):\n        collected = [] if collected is None else collected\n        outcomes = []\n        for pattern in self.children:\n            matched, _, _ = outcome = pattern.match(left, collected)\n            if matched:\n                outcomes.append(outcome)\n        if outcomes:\n            return min(outcomes, key=lambda outcome: len(outcome[1]))\n        return False, left, collected\n\n\nclass Tokens(list):\n\n    def __init__(self, source, error=DocoptExit):\n        self += source.split() if hasattr(source, 'split') else source\n        self.error = error\n\n    @staticmethod\n    def from_pattern(source):\n        source = re.sub(r'([\\[\\]\\(\\)\\|]|\\.\\.\\.)', r' \\1 ', source)\n        source = [s for s in re.split('\\s+|(\\S*<.*?>)', source) if s]\n        return Tokens(source, error=DocoptLanguageError)\n\n    def move(self):\n        return self.pop(0) if len(self) else None\n\n    def current(self):\n        return self[0] if len(self) else None\n\n\ndef parse_long(tokens, options):\n    \"\"\"long ::= '--' chars [ ( ' ' | '=' ) chars ] ;\"\"\"\n    long, eq, value = tokens.move().partition('=')\n    assert long.startswith('--')\n    value = None if eq == value == '' else value\n    similar = [o for o in options if o.long == long]\n    if tokens.error is DocoptExit and similar == []:  # if no exact match\n        similar = [o for o in options if o.long and o.long.startswith(long)]\n    if len(similar) > 1:  # might be simply specified ambiguously 2+ times?\n        raise tokens.error('%s is not a unique prefix: %s?' %\n                           (long, ', '.join(o.long for o in similar)))\n    elif len(similar) < 1:\n        argcount = 1 if eq == '=' else 0\n        o = Option(None, long, argcount)\n        options.append(o)\n        if tokens.error is DocoptExit:\n            o = Option(None, long, argcount, value if argcount else True)\n    else:\n        o = Option(similar[0].short, similar[0].long,\n                   similar[0].argcount, similar[0].value)\n        if o.argcount == 0:\n            if value is not None:\n                raise tokens.error('%s must not have an argument' % o.long)\n        else:\n            if value is None:\n                if tokens.current() in [None, '--']:\n                    raise tokens.error('%s requires argument' % o.long)\n                value = tokens.move()\n        if tokens.error is DocoptExit:\n            o.value = value if value is not None else True\n    return [o]\n\n\ndef parse_shorts(tokens, options):\n    \"\"\"shorts ::= '-' ( chars )* [ [ ' ' ] chars ] ;\"\"\"\n    token = tokens.move()\n    assert token.startswith('-') and not token.startswith('--')\n    left = token.lstrip('-')\n    parsed = []\n    while left != '':\n        short, left = '-' + left[0], left[1:]\n        similar = [o for o in options if o.short == short]\n        if len(similar) > 1:\n            raise tokens.error('%s is specified ambiguously %d times' %\n                               (short, len(similar)))\n        elif len(similar) < 1:\n            o = Option(short, None, 0)\n            options.append(o)\n            if tokens.error is DocoptExit:\n                o = Option(short, None, 0, True)\n        else:  # why copying is necessary here?\n            o = Option(short, similar[0].long,\n                       similar[0].argcount, similar[0].value)\n            value = None\n            if o.argcount != 0:\n                if left == '':\n                    if tokens.current() in [None, '--']:\n                        raise tokens.error('%s requires argument' % short)\n                    value = tokens.move()\n                else:\n                    value = left\n                    left = ''\n            if tokens.error is DocoptExit:\n                o.value = value if value is not None else True\n        parsed.append(o)\n    return parsed\n\n\ndef parse_pattern(source, options):\n    tokens = Tokens.from_pattern(source)\n    result = parse_expr(tokens, options)\n    if tokens.current() is not None:\n        raise tokens.error('unexpected ending: %r' % ' '.join(tokens))\n    return Required(*result)\n\n\ndef parse_expr(tokens, options):\n    \"\"\"expr ::= seq ( '|' seq )* ;\"\"\"\n    seq = parse_seq(tokens, options)\n    if tokens.current() != '|':\n        return seq\n    result = [Required(*seq)] if len(seq) > 1 else seq\n    while tokens.current() == '|':\n        tokens.move()\n        seq = parse_seq(tokens, options)\n        result += [Required(*seq)] if len(seq) > 1 else seq\n    return [Either(*result)] if len(result) > 1 else result\n\n\ndef parse_seq(tokens, options):\n    \"\"\"seq ::= ( atom [ '...' ] )* ;\"\"\"\n    result = []\n    while tokens.current() not in [None, ']', ')', '|']:\n        atom = parse_atom(tokens, options)\n        if tokens.current() == '...':\n            atom = [OneOrMore(*atom)]\n            tokens.move()\n        result += atom\n    return result\n\n\ndef parse_atom(tokens, options):\n    \"\"\"atom ::= '(' expr ')' | '[' expr ']' | 'options'\n             | long | shorts | argument | command ;\n    \"\"\"\n    token = tokens.current()\n    result = []\n    if token in '([':\n        tokens.move()\n        matching, pattern = {'(': [')', Required], '[': [']', Optional]}[token]\n        result = pattern(*parse_expr(tokens, options))\n        if tokens.move() != matching:\n            raise tokens.error(\"unmatched '%s'\" % token)\n        return [result]\n    elif token == 'options':\n        tokens.move()\n        return [OptionsShortcut()]\n    elif token.startswith('--') and token != '--':\n        return parse_long(tokens, options)\n    elif token.startswith('-') and token not in ('-', '--'):\n        return parse_shorts(tokens, options)\n    elif token.startswith('<') and token.endswith('>') or token.isupper():\n        return [Argument(tokens.move())]\n    else:\n        return [Command(tokens.move())]\n\n\ndef parse_argv(tokens, options, options_first=False):\n    \"\"\"Parse command-line argument vector.\n\n    If options_first:\n        argv ::= [ long | shorts ]* [ argument ]* [ '--' [ argument ]* ] ;\n    else:\n        argv ::= [ long | shorts | argument ]* [ '--' [ argument ]* ] ;\n\n    \"\"\"\n    parsed = []\n    while tokens.current() is not None:\n        if tokens.current() == '--':\n            return parsed + [Argument(None, v) for v in tokens]\n        elif tokens.current().startswith('--'):\n            parsed += parse_long(tokens, options)\n        elif tokens.current().startswith('-') and tokens.current() != '-':\n            parsed += parse_shorts(tokens, options)\n        elif options_first:\n            return parsed + [Argument(None, v) for v in tokens]\n        else:\n            parsed.append(Argument(None, tokens.move()))\n    return parsed\n\n\ndef parse_defaults(doc):\n    defaults = []\n    for s in parse_section('options:', doc):\n        # FIXME corner case \"bla: options: --foo\"\n        _, _, s = s.partition(':')  # get rid of \"options:\"\n        split = re.split('\\n[ \\t]*(-\\S+?)', '\\n' + s)[1:]\n        split = [s1 + s2 for s1, s2 in zip(split[::2], split[1::2])]\n        options = [Option.parse(s) for s in split if s.startswith('-')]\n        defaults += options\n    return defaults\n\n\ndef parse_section(name, source):\n    pattern = re.compile('^([^\\n]*' + name + '[^\\n]*\\n?(?:[ \\t].*?(?:\\n|$))*)',\n                         re.IGNORECASE | re.MULTILINE)\n    return [s.strip() for s in pattern.findall(source)]\n\n\ndef formal_usage(section):\n    _, _, section = section.partition(':')  # drop \"usage:\"\n    pu = section.split()\n    return '( ' + ' '.join(') | (' if s == pu[0] else s for s in pu[1:]) + ' )'\n\n\ndef extras(help, version, options, doc):\n    if help and any((o.name in ('-h', '--help')) and o.value for o in options):\n        print(doc.strip(\"\\n\"))\n        sys.exit()\n    if version and any(o.name == '--version' and o.value for o in options):\n        print(version)\n        sys.exit()\n\n\nclass Dict(dict):\n    def __repr__(self):\n        return '{%s}' % ',\\n '.join('%r: %r' % i for i in sorted(self.items()))\n\n\ndef docopt(doc, argv=None, help=True, version=None, options_first=False):\n    \"\"\"Parse `argv` based on command-line interface described in `doc`.\n\n    `docopt` creates your command-line interface based on its\n    description that you pass as `doc`. Such description can contain\n    --options, <positional-argument>, commands, which could be\n    [optional], (required), (mutually | exclusive) or repeated...\n\n    Parameters\n    ----------\n    doc : str\n        Description of your command-line interface.\n    argv : list of str, optional\n        Argument vector to be parsed. sys.argv[1:] is used if not\n        provided.\n    help : bool (default: True)\n        Set to False to disable automatic help on -h or --help\n        options.\n    version : any object\n        If passed, the object will be printed if --version is in\n        `argv`.\n    options_first : bool (default: False)\n        Set to True to require options precede positional arguments,\n        i.e. to forbid options and positional arguments intermix.\n\n    Returns\n    -------\n    args : dict\n        A dictionary, where keys are names of command-line elements\n        such as e.g. \"--verbose\" and \"<path>\", and values are the\n        parsed values of those elements.\n\n    Example\n    -------\n    >>> from docopt import docopt\n    >>> doc = '''\n    ... Usage:\n    ...     my_program tcp <host> <port> [--timeout=<seconds>]\n    ...     my_program serial <port> [--baud=<n>] [--timeout=<seconds>]\n    ...     my_program (-h | --help | --version)\n    ...\n    ... Options:\n    ...     -h, --help  Show this screen and exit.\n    ...     --baud=<n>  Baudrate [default: 9600]\n    ... '''\n    >>> argv = ['tcp', '127.0.0.1', '80', '--timeout', '30']\n    >>> docopt(doc, argv)\n    {'--baud': '9600',\n     '--help': False,\n     '--timeout': '30',\n     '--version': False,\n     '<host>': '127.0.0.1',\n     '<port>': '80',\n     'serial': False,\n     'tcp': True}\n\n    See also\n    --------\n    * For video introduction see http://docopt.org\n    * Full documentation is available in README.rst as well as online\n      at https://github.com/docopt/docopt#readme\n\n    \"\"\"\n    argv = sys.argv[1:] if argv is None else argv\n\n    usage_sections = parse_section('usage:', doc)\n    if len(usage_sections) == 0:\n        raise DocoptLanguageError('\"usage:\" (case-insensitive) not found.')\n    if len(usage_sections) > 1:\n        raise DocoptLanguageError('More than one \"usage:\" (case-insensitive).')\n    DocoptExit.usage = usage_sections[0]\n\n    options = parse_defaults(doc)\n    pattern = parse_pattern(formal_usage(DocoptExit.usage), options)\n    # [default] syntax for argument is disabled\n    #for a in pattern.flat(Argument):\n    #    same_name = [d for d in arguments if d.name == a.name]\n    #    if same_name:\n    #        a.value = same_name[0].value\n    argv = parse_argv(Tokens(argv), list(options), options_first)\n    pattern_options = set(pattern.flat(Option))\n    for options_shortcut in pattern.flat(OptionsShortcut):\n        doc_options = parse_defaults(doc)\n        options_shortcut.children = list(set(doc_options) - pattern_options)\n        #if any_options:\n        #    options_shortcut.children += [Option(o.short, o.long, o.argcount)\n        #                    for o in argv if type(o) is Option]\n    extras(help, version, argv, doc)\n    matched, left, collected = pattern.fix().match(argv)\n    if matched and left == []:  # better error message if left?\n        return Dict((a.name, a.value) for a in (pattern.flat() + collected))\n    raise DocoptExit()\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.021484375,
          "content": "[wheel]\nuniversal = 1\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.369140625,
          "content": "import sys\nfrom setuptools import setup\nfrom setuptools.command.test import test as TestCommand\n\nfrom docopt import __version__\n\n\nclass PyTestCommand(TestCommand):\n    \"\"\" Command to run unit py.test unit tests\n    \"\"\"\n    def finalize_options(self):\n        TestCommand.finalize_options(self)\n        self.test_args = []\n        self.test_suite = True\n\n    def run(self):\n        import pytest\n        rcode = pytest.main(self.test_args)\n        sys.exit(rcode)\n\n\nsetup(\n    name='docopt',\n    version=__version__,\n    author='Vladimir Keleshev',\n    author_email='vladimir@keleshev.com',\n    description='Pythonic argument parser, that will make you smile',\n    license='MIT',\n    keywords='option arguments parsing optparse argparse getopt',\n    url='http://docopt.org',\n    py_modules=['docopt'],\n    long_description=open('README.rst').read(),\n    classifiers=[\n        'Development Status :: 3 - Alpha',\n        'Topic :: Utilities',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'License :: OSI Approved :: MIT License',\n    ],\n    tests_require=[\n            'pytest',\n        ],\n    cmdclass={\n            'test': PyTestCommand,\n        }\n)\n"
        },
        {
          "name": "test_docopt.py",
          "type": "blob",
          "size": 25.2822265625,
          "content": "from __future__ import with_statement\nfrom docopt import (docopt, DocoptExit, DocoptLanguageError,\n                    Option, Argument, Command, OptionsShortcut,\n                    Required, Optional, Either, OneOrMore,\n                    parse_argv, parse_pattern, parse_section,\n                    parse_defaults, formal_usage, Tokens, transform\n                   )\nfrom pytest import raises\n\n\ndef test_pattern_flat():\n    assert Required(OneOrMore(Argument('N')),\n                    Option('-a'), Argument('M')).flat() == \\\n                            [Argument('N'), Option('-a'), Argument('M')]\n    assert Required(Optional(OptionsShortcut()),\n                    Optional(Option('-a', None))).flat(OptionsShortcut) == \\\n                            [OptionsShortcut()]\n\n\ndef test_option():\n    assert Option.parse('-h') == Option('-h', None)\n    assert Option.parse('--help') == Option(None, '--help')\n    assert Option.parse('-h --help') == Option('-h', '--help')\n    assert Option.parse('-h, --help') == Option('-h', '--help')\n\n    assert Option.parse('-h TOPIC') == Option('-h', None, 1)\n    assert Option.parse('--help TOPIC') == Option(None, '--help', 1)\n    assert Option.parse('-h TOPIC --help TOPIC') == Option('-h', '--help', 1)\n    assert Option.parse('-h TOPIC, --help TOPIC') == Option('-h', '--help', 1)\n    assert Option.parse('-h TOPIC, --help=TOPIC') == Option('-h', '--help', 1)\n\n    assert Option.parse('-h  Description...') == Option('-h', None)\n    assert Option.parse('-h --help  Description...') == Option('-h', '--help')\n    assert Option.parse('-h TOPIC  Description...') == Option('-h', None, 1)\n\n    assert Option.parse('    -h') == Option('-h', None)\n\n    assert Option.parse('-h TOPIC  Descripton... [default: 2]') == \\\n               Option('-h', None, 1, '2')\n    assert Option.parse('-h TOPIC  Descripton... [default: topic-1]') == \\\n               Option('-h', None, 1, 'topic-1')\n    assert Option.parse('--help=TOPIC  ... [default: 3.14]') == \\\n               Option(None, '--help', 1, '3.14')\n    assert Option.parse('-h, --help=DIR  ... [default: ./]') == \\\n               Option('-h', '--help', 1, \"./\")\n    assert Option.parse('-h TOPIC  Descripton... [dEfAuLt: 2]') == \\\n               Option('-h', None, 1, '2')\n\n\ndef test_option_name():\n    assert Option('-h', None).name == '-h'\n    assert Option('-h', '--help').name == '--help'\n    assert Option(None, '--help').name == '--help'\n\n\ndef test_commands():\n    assert docopt('Usage: prog add', 'add') == {'add': True}\n    assert docopt('Usage: prog [add]', '') == {'add': False}\n    assert docopt('Usage: prog [add]', 'add') == {'add': True}\n    assert docopt('Usage: prog (add|rm)', 'add') == {'add': True, 'rm': False}\n    assert docopt('Usage: prog (add|rm)', 'rm') == {'add': False, 'rm': True}\n    assert docopt('Usage: prog a b', 'a b') == {'a': True, 'b': True}\n    with raises(DocoptExit):\n        docopt('Usage: prog a b', 'b a')\n\n\ndef test_formal_usage():\n    doc = \"\"\"\n    Usage: prog [-hv] ARG\n           prog N M\n\n    prog is a program.\"\"\"\n    usage, = parse_section('usage:', doc)\n    assert usage == \"Usage: prog [-hv] ARG\\n           prog N M\"\n    assert formal_usage(usage) == \"( [-hv] ARG ) | ( N M )\"\n\n\ndef test_parse_argv():\n    o = [Option('-h'), Option('-v', '--verbose'), Option('-f', '--file', 1)]\n    TS = lambda s: Tokens(s, error=DocoptExit)\n    assert parse_argv(TS(''), options=o) == []\n    assert parse_argv(TS('-h'), options=o) == [Option('-h', None, 0, True)]\n    assert parse_argv(TS('-h --verbose'), options=o) == \\\n            [Option('-h', None, 0, True), Option('-v', '--verbose', 0, True)]\n    assert parse_argv(TS('-h --file f.txt'), options=o) == \\\n            [Option('-h', None, 0, True), Option('-f', '--file', 1, 'f.txt')]\n    assert parse_argv(TS('-h --file f.txt arg'), options=o) == \\\n            [Option('-h', None, 0, True),\n             Option('-f', '--file', 1, 'f.txt'),\n             Argument(None, 'arg')]\n    assert parse_argv(TS('-h --file f.txt arg arg2'), options=o) == \\\n            [Option('-h', None, 0, True),\n             Option('-f', '--file', 1, 'f.txt'),\n             Argument(None, 'arg'),\n             Argument(None, 'arg2')]\n    assert parse_argv(TS('-h arg -- -v'), options=o) == \\\n            [Option('-h', None, 0, True),\n             Argument(None, 'arg'),\n             Argument(None, '--'),\n             Argument(None, '-v')]\n\n\ndef test_parse_pattern():\n    o = [Option('-h'), Option('-v', '--verbose'), Option('-f', '--file', 1)]\n    assert parse_pattern('[ -h ]', options=o) == \\\n               Required(Optional(Option('-h')))\n    assert parse_pattern('[ ARG ... ]', options=o) == \\\n               Required(Optional(OneOrMore(Argument('ARG'))))\n    assert parse_pattern('[ -h | -v ]', options=o) == \\\n               Required(Optional(Either(Option('-h'),\n                                Option('-v', '--verbose'))))\n    assert parse_pattern('( -h | -v [ --file <f> ] )', options=o) == \\\n               Required(Required(\n                   Either(Option('-h'),\n                          Required(Option('-v', '--verbose'),\n                               Optional(Option('-f', '--file', 1, None))))))\n    assert parse_pattern('(-h|-v[--file=<f>]N...)', options=o) == \\\n               Required(Required(Either(Option('-h'),\n                              Required(Option('-v', '--verbose'),\n                                  Optional(Option('-f', '--file', 1, None)),\n                                     OneOrMore(Argument('N'))))))\n    assert parse_pattern('(N [M | (K | L)] | O P)', options=[]) == \\\n               Required(Required(Either(\n                   Required(Argument('N'),\n                            Optional(Either(Argument('M'),\n                                            Required(Either(Argument('K'),\n                                                            Argument('L')))))),\n                   Required(Argument('O'), Argument('P')))))\n    assert parse_pattern('[ -h ] [N]', options=o) == \\\n               Required(Optional(Option('-h')),\n                        Optional(Argument('N')))\n    assert parse_pattern('[options]', options=o) == \\\n            Required(Optional(OptionsShortcut()))\n    assert parse_pattern('[options] A', options=o) == \\\n            Required(Optional(OptionsShortcut()),\n                     Argument('A'))\n    assert parse_pattern('-v [options]', options=o) == \\\n            Required(Option('-v', '--verbose'),\n                     Optional(OptionsShortcut()))\n    assert parse_pattern('ADD', options=o) == Required(Argument('ADD'))\n    assert parse_pattern('<add>', options=o) == Required(Argument('<add>'))\n    assert parse_pattern('add', options=o) == Required(Command('add'))\n\n\ndef test_option_match():\n    assert Option('-a').match([Option('-a', value=True)]) == \\\n            (True, [], [Option('-a', value=True)])\n    assert Option('-a').match([Option('-x')]) == (False, [Option('-x')], [])\n    assert Option('-a').match([Argument('N')]) == (False, [Argument('N')], [])\n    assert Option('-a').match([Option('-x'), Option('-a'), Argument('N')]) == \\\n            (True, [Option('-x'), Argument('N')], [Option('-a')])\n    assert Option('-a').match([Option('-a', value=True), Option('-a')]) == \\\n            (True, [Option('-a')], [Option('-a', value=True)])\n\n\ndef test_argument_match():\n    assert Argument('N').match([Argument(None, 9)]) == \\\n            (True, [], [Argument('N', 9)])\n    assert Argument('N').match([Option('-x')]) == (False, [Option('-x')], [])\n    assert Argument('N').match([Option('-x'),\n                                Option('-a'),\n                                Argument(None, 5)]) == \\\n            (True, [Option('-x'), Option('-a')], [Argument('N', 5)])\n    assert Argument('N').match([Argument(None, 9), Argument(None, 0)]) == \\\n            (True, [Argument(None, 0)], [Argument('N', 9)])\n\n\ndef test_command_match():\n    assert Command('c').match([Argument(None, 'c')]) == \\\n            (True, [], [Command('c', True)])\n    assert Command('c').match([Option('-x')]) == (False, [Option('-x')], [])\n    assert Command('c').match([Option('-x'),\n                               Option('-a'),\n                               Argument(None, 'c')]) == \\\n            (True, [Option('-x'), Option('-a')], [Command('c', True)])\n    assert Either(Command('add', False), Command('rm', False)).match(\n            [Argument(None, 'rm')]) == (True, [], [Command('rm', True)])\n\n\ndef test_optional_match():\n    assert Optional(Option('-a')).match([Option('-a')]) == \\\n            (True, [], [Option('-a')])\n    assert Optional(Option('-a')).match([]) == (True, [], [])\n    assert Optional(Option('-a')).match([Option('-x')]) == \\\n            (True, [Option('-x')], [])\n    assert Optional(Option('-a'), Option('-b')).match([Option('-a')]) == \\\n            (True, [], [Option('-a')])\n    assert Optional(Option('-a'), Option('-b')).match([Option('-b')]) == \\\n            (True, [], [Option('-b')])\n    assert Optional(Option('-a'), Option('-b')).match([Option('-x')]) == \\\n            (True, [Option('-x')], [])\n    assert Optional(Argument('N')).match([Argument(None, 9)]) == \\\n            (True, [], [Argument('N', 9)])\n    assert Optional(Option('-a'), Option('-b')).match(\n                [Option('-b'), Option('-x'), Option('-a')]) == \\\n            (True, [Option('-x')], [Option('-a'), Option('-b')])\n\n\ndef test_required_match():\n    assert Required(Option('-a')).match([Option('-a')]) == \\\n            (True, [], [Option('-a')])\n    assert Required(Option('-a')).match([]) == (False, [], [])\n    assert Required(Option('-a')).match([Option('-x')]) == \\\n            (False, [Option('-x')], [])\n    assert Required(Option('-a'), Option('-b')).match([Option('-a')]) == \\\n            (False, [Option('-a')], [])\n\n\ndef test_either_match():\n    assert Either(Option('-a'), Option('-b')).match(\n            [Option('-a')]) == (True, [], [Option('-a')])\n    assert Either(Option('-a'), Option('-b')).match(\n            [Option('-a'), Option('-b')]) == \\\n                    (True, [Option('-b')], [Option('-a')])\n    assert Either(Option('-a'), Option('-b')).match(\n            [Option('-x')]) == (False, [Option('-x')], [])\n    assert Either(Option('-a'), Option('-b'), Option('-c')).match(\n            [Option('-x'), Option('-b')]) == \\\n                    (True, [Option('-x')], [Option('-b')])\n    assert Either(Argument('M'),\n                  Required(Argument('N'), Argument('M'))).match(\n                                   [Argument(None, 1), Argument(None, 2)]) == \\\n            (True, [], [Argument('N', 1), Argument('M', 2)])\n\n\ndef test_one_or_more_match():\n    assert OneOrMore(Argument('N')).match([Argument(None, 9)]) == \\\n            (True, [], [Argument('N', 9)])\n    assert OneOrMore(Argument('N')).match([]) == (False, [], [])\n    assert OneOrMore(Argument('N')).match([Option('-x')]) == \\\n            (False, [Option('-x')], [])\n    assert OneOrMore(Argument('N')).match(\n            [Argument(None, 9), Argument(None, 8)]) == (\n                    True, [], [Argument('N', 9), Argument('N', 8)])\n    assert OneOrMore(Argument('N')).match(\n            [Argument(None, 9), Option('-x'), Argument(None, 8)]) == (\n                    True, [Option('-x')], [Argument('N', 9), Argument('N', 8)])\n    assert OneOrMore(Option('-a')).match(\n            [Option('-a'), Argument(None, 8), Option('-a')]) == \\\n                    (True, [Argument(None, 8)], [Option('-a'), Option('-a')])\n    assert OneOrMore(Option('-a')).match([Argument(None, 8),\n                                          Option('-x')]) == \\\n                    (False, [Argument(None, 8), Option('-x')], [])\n    assert OneOrMore(Required(Option('-a'), Argument('N'))).match(\n            [Option('-a'), Argument(None, 1), Option('-x'),\n             Option('-a'), Argument(None, 2)]) == \\\n             (True, [Option('-x')],\n              [Option('-a'), Argument('N', 1), Option('-a'), Argument('N', 2)])\n    assert OneOrMore(Optional(Argument('N'))).match([Argument(None, 9)]) == \\\n                    (True, [], [Argument('N', 9)])\n\n\ndef test_list_argument_match():\n    assert Required(Argument('N'), Argument('N')).fix().match(\n            [Argument(None, '1'), Argument(None, '2')]) == \\\n                    (True, [], [Argument('N', ['1', '2'])])\n    assert OneOrMore(Argument('N')).fix().match(\n          [Argument(None, '1'), Argument(None, '2'), Argument(None, '3')]) == \\\n                    (True, [], [Argument('N', ['1', '2', '3'])])\n    assert Required(Argument('N'), OneOrMore(Argument('N'))).fix().match(\n          [Argument(None, '1'), Argument(None, '2'), Argument(None, '3')]) == \\\n                    (True, [], [Argument('N', ['1', '2', '3'])])\n    assert Required(Argument('N'), Required(Argument('N'))).fix().match(\n            [Argument(None, '1'), Argument(None, '2')]) == \\\n                    (True, [], [Argument('N', ['1', '2'])])\n\n\ndef test_basic_pattern_matching():\n    # ( -a N [ -x Z ] )\n    pattern = Required(Option('-a'), Argument('N'),\n                       Optional(Option('-x'), Argument('Z')))\n    # -a N\n    assert pattern.match([Option('-a'), Argument(None, 9)]) == \\\n            (True, [], [Option('-a'), Argument('N', 9)])\n    # -a -x N Z\n    assert pattern.match([Option('-a'), Option('-x'),\n                          Argument(None, 9), Argument(None, 5)]) == \\\n            (True, [], [Option('-a'), Argument('N', 9),\n                        Option('-x'), Argument('Z', 5)])\n    # -x N Z  # BZZ!\n    assert pattern.match([Option('-x'),\n                          Argument(None, 9),\n                          Argument(None, 5)]) == \\\n            (False, [Option('-x'), Argument(None, 9), Argument(None, 5)], [])\n\n\ndef test_pattern_either():\n    assert transform(Option('-a')) == Either(Required(Option('-a')))\n    assert transform(Argument('A')) == Either(Required(Argument('A')))\n    assert transform(Required(Either(Option('-a'), Option('-b')),\n                    Option('-c'))) == \\\n            Either(Required(Option('-a'), Option('-c')),\n                   Required(Option('-b'), Option('-c')))\n    assert transform(Optional(Option('-a'), Either(Option('-b'),\n                                                   Option('-c')))) == \\\n            Either(Required(Option('-b'), Option('-a')),\n                   Required(Option('-c'), Option('-a')))\n    assert transform(Either(Option('-x'),\n                            Either(Option('-y'), Option('-z')))) == \\\n            Either(Required(Option('-x')),\n                   Required(Option('-y')),\n                   Required(Option('-z')))\n    assert transform(OneOrMore(Argument('N'), Argument('M'))) == \\\n            Either(Required(Argument('N'), Argument('M'),\n                            Argument('N'), Argument('M')))\n\n\ndef test_pattern_fix_repeating_arguments():\n    assert Option('-a').fix_repeating_arguments() == Option('-a')\n    assert Argument('N', None).fix_repeating_arguments() == Argument('N', None)\n    assert Required(Argument('N'),\n                    Argument('N')).fix_repeating_arguments() == \\\n            Required(Argument('N', []), Argument('N', []))\n    assert Either(Argument('N'),\n                        OneOrMore(Argument('N'))).fix() == \\\n            Either(Argument('N', []), OneOrMore(Argument('N', [])))\n\n\ndef test_set():\n    assert Argument('N') == Argument('N')\n    assert set([Argument('N'), Argument('N')]) == set([Argument('N')])\n\n\ndef test_pattern_fix_identities_1():\n    pattern = Required(Argument('N'), Argument('N'))\n    assert pattern.children[0] == pattern.children[1]\n    assert pattern.children[0] is not pattern.children[1]\n    pattern.fix_identities()\n    assert pattern.children[0] is pattern.children[1]\n\n\ndef test_pattern_fix_identities_2():\n    pattern = Required(Optional(Argument('X'), Argument('N')), Argument('N'))\n    assert pattern.children[0].children[1] == pattern.children[1]\n    assert pattern.children[0].children[1] is not pattern.children[1]\n    pattern.fix_identities()\n    assert pattern.children[0].children[1] is pattern.children[1]\n\n\ndef test_long_options_error_handling():\n#    with raises(DocoptLanguageError):\n#        docopt('Usage: prog --non-existent', '--non-existent')\n#    with raises(DocoptLanguageError):\n#        docopt('Usage: prog --non-existent')\n    with raises(DocoptExit):\n        docopt('Usage: prog', '--non-existent')\n    with raises(DocoptExit):\n        docopt('Usage: prog [--version --verbose]\\n'\n               'Options: --version\\n --verbose', '--ver')\n    with raises(DocoptLanguageError):\n        docopt('Usage: prog --long\\nOptions: --long ARG')\n    with raises(DocoptExit):\n        docopt('Usage: prog --long ARG\\nOptions: --long ARG', '--long')\n    with raises(DocoptLanguageError):\n        docopt('Usage: prog --long=ARG\\nOptions: --long')\n    with raises(DocoptExit):\n        docopt('Usage: prog --long\\nOptions: --long', '--long=ARG')\n\n\ndef test_short_options_error_handling():\n    with raises(DocoptLanguageError):\n        docopt('Usage: prog -x\\nOptions: -x  this\\n -x  that')\n\n#    with raises(DocoptLanguageError):\n#        docopt('Usage: prog -x')\n    with raises(DocoptExit):\n        docopt('Usage: prog', '-x')\n\n    with raises(DocoptLanguageError):\n        docopt('Usage: prog -o\\nOptions: -o ARG')\n    with raises(DocoptExit):\n        docopt('Usage: prog -o ARG\\nOptions: -o ARG', '-o')\n\n\ndef test_matching_paren():\n    with raises(DocoptLanguageError):\n        docopt('Usage: prog [a [b]')\n    with raises(DocoptLanguageError):\n        docopt('Usage: prog [a [b] ] c )')\n\n\ndef test_allow_double_dash():\n    assert docopt('usage: prog [-o] [--] <arg>\\nkptions: -o',\n                  '-- -o') == {'-o': False, '<arg>': '-o', '--': True}\n    assert docopt('usage: prog [-o] [--] <arg>\\nkptions: -o',\n                  '-o 1') == {'-o': True, '<arg>': '1', '--': False}\n    with raises(DocoptExit):  # \"--\" is not allowed; FIXME?\n        docopt('usage: prog [-o] <arg>\\noptions:-o', '-- -o')\n\n\ndef test_docopt():\n    doc = '''Usage: prog [-v] A\n\n             Options: -v  Be verbose.'''\n    assert docopt(doc, 'arg') == {'-v': False, 'A': 'arg'}\n    assert docopt(doc, '-v arg') == {'-v': True, 'A': 'arg'}\n\n    doc = \"\"\"Usage: prog [-vqr] [FILE]\n              prog INPUT OUTPUT\n              prog --help\n\n    Options:\n      -v  print status messages\n      -q  report only file names\n      -r  show all occurrences of the same error\n      --help\n\n    \"\"\"\n    a = docopt(doc, '-v file.py')\n    assert a == {'-v': True, '-q': False, '-r': False, '--help': False,\n                 'FILE': 'file.py', 'INPUT': None, 'OUTPUT': None}\n\n    a = docopt(doc, '-v')\n    assert a == {'-v': True, '-q': False, '-r': False, '--help': False,\n                 'FILE': None, 'INPUT': None, 'OUTPUT': None}\n\n    with raises(DocoptExit):  # does not match\n        docopt(doc, '-v input.py output.py')\n\n    with raises(DocoptExit):\n        docopt(doc, '--fake')\n\n    with raises(SystemExit):\n        docopt(doc, '--hel')\n\n    #with raises(SystemExit):\n    #    docopt(doc, 'help')  XXX Maybe help command?\n\n\ndef test_language_errors():\n    with raises(DocoptLanguageError):\n        docopt('no usage with colon here')\n    with raises(DocoptLanguageError):\n        docopt('usage: here \\n\\n and again usage: here')\n\n\ndef test_issue_40():\n    with raises(SystemExit):  # i.e. shows help\n        docopt('usage: prog --help-commands | --help', '--help')\n    assert docopt('usage: prog --aabb | --aa', '--aa') == {'--aabb': False,\n                                                           '--aa': True}\n\n\ndef test_issue34_unicode_strings():\n    try:\n        assert docopt(eval(\"u'usage: prog [-o <a>]'\"), '') == \\\n                {'-o': False, '<a>': None}\n    except SyntaxError:\n        pass  # Python 3\n\n\ndef test_count_multiple_flags():\n    assert docopt('usage: prog [-v]', '-v') == {'-v': True}\n    assert docopt('usage: prog [-vv]', '') == {'-v': 0}\n    assert docopt('usage: prog [-vv]', '-v') == {'-v': 1}\n    assert docopt('usage: prog [-vv]', '-vv') == {'-v': 2}\n    with raises(DocoptExit):\n        docopt('usage: prog [-vv]', '-vvv')\n    assert docopt('usage: prog [-v | -vv | -vvv]', '-vvv') == {'-v': 3}\n    assert docopt('usage: prog -v...', '-vvvvvv') == {'-v': 6}\n    assert docopt('usage: prog [--ver --ver]', '--ver --ver') == {'--ver': 2}\n\n\ndef test_any_options_parameter():\n    with raises(DocoptExit):\n        docopt('usage: prog [options]', '-foo --bar --spam=eggs')\n#    assert docopt('usage: prog [options]', '-foo --bar --spam=eggs',\n#                  any_options=True) == {'-f': True, '-o': 2,\n#                                         '--bar': True, '--spam': 'eggs'}\n    with raises(DocoptExit):\n        docopt('usage: prog [options]', '--foo --bar --bar')\n#    assert docopt('usage: prog [options]', '--foo --bar --bar',\n#                  any_options=True) == {'--foo': True, '--bar': 2}\n    with raises(DocoptExit):\n        docopt('usage: prog [options]', '--bar --bar --bar -ffff')\n#    assert docopt('usage: prog [options]', '--bar --bar --bar -ffff',\n#                  any_options=True) == {'--bar': 3, '-f': 4}\n    with raises(DocoptExit):\n        docopt('usage: prog [options]', '--long=arg --long=another')\n#    assert docopt('usage: prog [options]', '--long=arg --long=another',\n#                  any_options=True) == {'--long': ['arg', 'another']}\n\n\n#def test_options_shortcut_multiple_commands():\n#    # any_options is disabled\n#    assert docopt('usage: prog c1 [options] prog c2 [options]',\n#        'c2 -o', any_options=True) == {'-o': True, 'c1': False, 'c2': True}\n#    assert docopt('usage: prog c1 [options] prog c2 [options]',\n#        'c1 -o', any_options=True) == {'-o': True, 'c1': True, 'c2': False}\n\n\ndef test_default_value_for_positional_arguments():\n    doc = \"\"\"Usage: prog [--data=<data>...]\\n\n             Options:\\n\\t-d --data=<arg>    Input data [default: x]\n          \"\"\"\n    a = docopt(doc, '')\n    assert a == {'--data': ['x']}\n    doc = \"\"\"Usage: prog [--data=<data>...]\\n\n             Options:\\n\\t-d --data=<arg>    Input data [default: x y]\n          \"\"\"\n    a = docopt(doc, '')\n    assert a == {'--data': ['x', 'y']}\n    doc = \"\"\"Usage: prog [--data=<data>...]\\n\n             Options:\\n\\t-d --data=<arg>    Input data [default: x y]\n          \"\"\"\n    a = docopt(doc, '--data=this')\n    assert a == {'--data': ['this']}\n\n\n#def test_parse_defaults():\n#    assert parse_defaults(\"\"\"usage: prog\n#                          options:\n#                          -o, --option <o>\n#                          --another <a>  description\n#                                         [default: x]\n#                          <a>\n#                          <another>  description [default: y]\"\"\") == \\\n#           ([Option('-o', '--option', 1, None),\n#             Option(None, '--another', 1, 'x')],\n#            [Argument('<a>', None),\n#             Argument('<another>', 'y')])\n#\n#    doc = '''\n#    -h, --help  Print help message.\n#    -o FILE     Output file.\n#    --verbose   Verbose mode.'''\n#    assert parse_defaults(doc)[0] == [Option('-h', '--help'),\n#                                      Option('-o', None, 1),\n#                                      Option(None, '--verbose')]\n\n\ndef test_issue_59():\n    assert docopt('usage: prog --long=<a>', '--long=') == {'--long': ''}\n    assert docopt('usage: prog -l <a>\\n'\n                  'options: -l <a>', ['-l', '']) == {'-l': ''}\n\n\ndef test_options_first():\n    assert docopt('usage: prog [--opt] [<args>...]',\n                  '--opt this that') == {'--opt': True,\n                                         '<args>': ['this', 'that']}\n    assert docopt('usage: prog [--opt] [<args>...]',\n                  'this that --opt') == {'--opt': True,\n                                         '<args>': ['this', 'that']}\n    assert docopt('usage: prog [--opt] [<args>...]',\n                  'this that --opt',\n                  options_first=True) == {'--opt': False,\n                                          '<args>': ['this', 'that', '--opt']}\n\n\ndef test_issue_68_options_shortcut_does_not_include_options_in_usage_pattern():\n    args = docopt('usage: prog [-ab] [options]\\n'\n                  'options: -x\\n -y', '-ax')\n    # Need to use `is` (not `==`) since we want to make sure\n    # that they are not 1/0, but strictly True/False:\n    assert args['-a'] is True\n    assert args['-b'] is False\n    assert args['-x'] is True\n    assert args['-y'] is False\n\n\ndef test_issue_65_evaluate_argv_when_called_not_when_imported():\n    import sys\n    sys.argv = 'prog -a'.split()\n    assert docopt('usage: prog [-ab]') == {'-a': True, '-b': False}\n    sys.argv = 'prog -b'.split()\n    assert docopt('usage: prog [-ab]') == {'-a': False, '-b': True}\n\n\ndef test_issue_71_double_dash_is_not_a_valid_option_argument():\n    with raises(DocoptExit):\n        docopt('usage: prog [--log=LEVEL] [--] <args>...', '--log -- 1 2')\n    with raises(DocoptExit):\n        docopt('''usage: prog [-l LEVEL] [--] <args>...\n                  options: -l LEVEL''', '-l -- 1 2')\n\n\nusage = '''usage: this\n\nusage:hai\nusage: this that\n\nusage: foo\n       bar\n\nPROGRAM USAGE:\n foo\n bar\nusage:\n\\ttoo\n\\ttar\nUsage: eggs spam\nBAZZ\nusage: pit stop'''\n\n\ndef test_parse_section():\n    assert parse_section('usage:', 'foo bar fizz buzz') == []\n    assert parse_section('usage:', 'usage: prog') == ['usage: prog']\n    assert parse_section('usage:',\n                         'usage: -x\\n -y') == ['usage: -x\\n -y']\n    assert parse_section('usage:', usage) == [\n            'usage: this',\n            'usage:hai',\n            'usage: this that',\n            'usage: foo\\n       bar',\n            'PROGRAM USAGE:\\n foo\\n bar',\n            'usage:\\n\\ttoo\\n\\ttar',\n            'Usage: eggs spam',\n            'usage: pit stop',\n    ]\n\n\ndef test_issue_126_defaults_not_parsed_correctly_when_tabs():\n    section = 'Options:\\n\\t--foo=<arg>  [default: bar]'\n    assert parse_defaults(section) == [Option(None, '--foo', 1, 'bar')]\n"
        },
        {
          "name": "testcases.docopt",
          "type": "blob",
          "size": 11.689453125,
          "content": "r\"\"\"Usage: prog\n\n\"\"\"\n$ prog\n{}\n\n$ prog --xxx\n\"user-error\"\n\n\nr\"\"\"Usage: prog [options]\n\nOptions: -a  All.\n\n\"\"\"\n$ prog\n{\"-a\": false}\n\n$ prog -a\n{\"-a\": true}\n\n$ prog -x\n\"user-error\"\n\n\nr\"\"\"Usage: prog [options]\n\nOptions: --all  All.\n\n\"\"\"\n$ prog\n{\"--all\": false}\n\n$ prog --all\n{\"--all\": true}\n\n$ prog --xxx\n\"user-error\"\n\n\nr\"\"\"Usage: prog [options]\n\nOptions: -v, --verbose  Verbose.\n\n\"\"\"\n$ prog --verbose\n{\"--verbose\": true}\n\n$ prog --ver\n{\"--verbose\": true}\n\n$ prog -v\n{\"--verbose\": true}\n\n\nr\"\"\"Usage: prog [options]\n\nOptions: -p PATH\n\n\"\"\"\n$ prog -p home/\n{\"-p\": \"home/\"}\n\n$ prog -phome/\n{\"-p\": \"home/\"}\n\n$ prog -p\n\"user-error\"\n\n\nr\"\"\"Usage: prog [options]\n\nOptions: --path <path>\n\n\"\"\"\n$ prog --path home/\n{\"--path\": \"home/\"}\n\n$ prog --path=home/\n{\"--path\": \"home/\"}\n\n$ prog --pa home/\n{\"--path\": \"home/\"}\n\n$ prog --pa=home/\n{\"--path\": \"home/\"}\n\n$ prog --path\n\"user-error\"\n\n\nr\"\"\"Usage: prog [options]\n\nOptions: -p PATH, --path=<path>  Path to files.\n\n\"\"\"\n$ prog -proot\n{\"--path\": \"root\"}\n\n\nr\"\"\"Usage: prog [options]\n\nOptions:    -p --path PATH  Path to files.\n\n\"\"\"\n$ prog -p root\n{\"--path\": \"root\"}\n\n$ prog --path root\n{\"--path\": \"root\"}\n\n\nr\"\"\"Usage: prog [options]\n\nOptions:\n -p PATH  Path to files [default: ./]\n\n\"\"\"\n$ prog\n{\"-p\": \"./\"}\n\n$ prog -phome\n{\"-p\": \"home\"}\n\n\nr\"\"\"UsAgE: prog [options]\n\nOpTiOnS: --path=<files>  Path to files\n                [dEfAuLt: /root]\n\n\"\"\"\n$ prog\n{\"--path\": \"/root\"}\n\n$ prog --path=home\n{\"--path\": \"home\"}\n\n\nr\"\"\"usage: prog [options]\n\noptions:\n    -a        Add\n    -r        Remote\n    -m <msg>  Message\n\n\"\"\"\n$ prog -a -r -m Hello\n{\"-a\": true,\n \"-r\": true,\n \"-m\": \"Hello\"}\n\n$ prog -armyourass\n{\"-a\": true,\n \"-r\": true,\n \"-m\": \"yourass\"}\n\n$ prog -a -r\n{\"-a\": true,\n \"-r\": true,\n \"-m\": null}\n\n\nr\"\"\"Usage: prog [options]\n\nOptions: --version\n         --verbose\n\n\"\"\"\n$ prog --version\n{\"--version\": true,\n \"--verbose\": false}\n\n$ prog --verbose\n{\"--version\": false,\n \"--verbose\": true}\n\n$ prog --ver\n\"user-error\"\n\n$ prog --verb\n{\"--version\": false,\n \"--verbose\": true}\n\n\nr\"\"\"usage: prog [-a -r -m <msg>]\n\noptions:\n -a        Add\n -r        Remote\n -m <msg>  Message\n\n\"\"\"\n$ prog -armyourass\n{\"-a\": true,\n \"-r\": true,\n \"-m\": \"yourass\"}\n\n\nr\"\"\"usage: prog [-armmsg]\n\noptions: -a        Add\n         -r        Remote\n         -m <msg>  Message\n\n\"\"\"\n$ prog -a -r -m Hello\n{\"-a\": true,\n \"-r\": true,\n \"-m\": \"Hello\"}\n\n\nr\"\"\"usage: prog -a -b\n\noptions:\n -a\n -b\n\n\"\"\"\n$ prog -a -b\n{\"-a\": true, \"-b\": true}\n\n$ prog -b -a\n{\"-a\": true, \"-b\": true}\n\n$ prog -a\n\"user-error\"\n\n$ prog\n\"user-error\"\n\n\nr\"\"\"usage: prog (-a -b)\n\noptions: -a\n         -b\n\n\"\"\"\n$ prog -a -b\n{\"-a\": true, \"-b\": true}\n\n$ prog -b -a\n{\"-a\": true, \"-b\": true}\n\n$ prog -a\n\"user-error\"\n\n$ prog\n\"user-error\"\n\n\nr\"\"\"usage: prog [-a] -b\n\noptions: -a\n -b\n\n\"\"\"\n$ prog -a -b\n{\"-a\": true, \"-b\": true}\n\n$ prog -b -a\n{\"-a\": true, \"-b\": true}\n\n$ prog -a\n\"user-error\"\n\n$ prog -b\n{\"-a\": false, \"-b\": true}\n\n$ prog\n\"user-error\"\n\n\nr\"\"\"usage: prog [(-a -b)]\n\noptions: -a\n         -b\n\n\"\"\"\n$ prog -a -b\n{\"-a\": true, \"-b\": true}\n\n$ prog -b -a\n{\"-a\": true, \"-b\": true}\n\n$ prog -a\n\"user-error\"\n\n$ prog -b\n\"user-error\"\n\n$ prog\n{\"-a\": false, \"-b\": false}\n\n\nr\"\"\"usage: prog (-a|-b)\n\noptions: -a\n         -b\n\n\"\"\"\n$ prog -a -b\n\"user-error\"\n\n$ prog\n\"user-error\"\n\n$ prog -a\n{\"-a\": true, \"-b\": false}\n\n$ prog -b\n{\"-a\": false, \"-b\": true}\n\n\nr\"\"\"usage: prog [ -a | -b ]\n\noptions: -a\n         -b\n\n\"\"\"\n$ prog -a -b\n\"user-error\"\n\n$ prog\n{\"-a\": false, \"-b\": false}\n\n$ prog -a\n{\"-a\": true, \"-b\": false}\n\n$ prog -b\n{\"-a\": false, \"-b\": true}\n\n\nr\"\"\"usage: prog <arg>\"\"\"\n$ prog 10\n{\"<arg>\": \"10\"}\n\n$ prog 10 20\n\"user-error\"\n\n$ prog\n\"user-error\"\n\n\nr\"\"\"usage: prog [<arg>]\"\"\"\n$ prog 10\n{\"<arg>\": \"10\"}\n\n$ prog 10 20\n\"user-error\"\n\n$ prog\n{\"<arg>\": null}\n\n\nr\"\"\"usage: prog <kind> <name> <type>\"\"\"\n$ prog 10 20 40\n{\"<kind>\": \"10\", \"<name>\": \"20\", \"<type>\": \"40\"}\n\n$ prog 10 20\n\"user-error\"\n\n$ prog\n\"user-error\"\n\n\nr\"\"\"usage: prog <kind> [<name> <type>]\"\"\"\n$ prog 10 20 40\n{\"<kind>\": \"10\", \"<name>\": \"20\", \"<type>\": \"40\"}\n\n$ prog 10 20\n{\"<kind>\": \"10\", \"<name>\": \"20\", \"<type>\": null}\n\n$ prog\n\"user-error\"\n\n\nr\"\"\"usage: prog [<kind> | <name> <type>]\"\"\"\n$ prog 10 20 40\n\"user-error\"\n\n$ prog 20 40\n{\"<kind>\": null, \"<name>\": \"20\", \"<type>\": \"40\"}\n\n$ prog\n{\"<kind>\": null, \"<name>\": null, \"<type>\": null}\n\n\nr\"\"\"usage: prog (<kind> --all | <name>)\n\noptions:\n --all\n\n\"\"\"\n$ prog 10 --all\n{\"<kind>\": \"10\", \"--all\": true, \"<name>\": null}\n\n$ prog 10\n{\"<kind>\": null, \"--all\": false, \"<name>\": \"10\"}\n\n$ prog\n\"user-error\"\n\n\nr\"\"\"usage: prog [<name> <name>]\"\"\"\n$ prog 10 20\n{\"<name>\": [\"10\", \"20\"]}\n\n$ prog 10\n{\"<name>\": [\"10\"]}\n\n$ prog\n{\"<name>\": []}\n\n\nr\"\"\"usage: prog [(<name> <name>)]\"\"\"\n$ prog 10 20\n{\"<name>\": [\"10\", \"20\"]}\n\n$ prog 10\n\"user-error\"\n\n$ prog\n{\"<name>\": []}\n\n\nr\"\"\"usage: prog NAME...\"\"\"\n$ prog 10 20\n{\"NAME\": [\"10\", \"20\"]}\n\n$ prog 10\n{\"NAME\": [\"10\"]}\n\n$ prog\n\"user-error\"\n\n\nr\"\"\"usage: prog [NAME]...\"\"\"\n$ prog 10 20\n{\"NAME\": [\"10\", \"20\"]}\n\n$ prog 10\n{\"NAME\": [\"10\"]}\n\n$ prog\n{\"NAME\": []}\n\n\nr\"\"\"usage: prog [NAME...]\"\"\"\n$ prog 10 20\n{\"NAME\": [\"10\", \"20\"]}\n\n$ prog 10\n{\"NAME\": [\"10\"]}\n\n$ prog\n{\"NAME\": []}\n\n\nr\"\"\"usage: prog [NAME [NAME ...]]\"\"\"\n$ prog 10 20\n{\"NAME\": [\"10\", \"20\"]}\n\n$ prog 10\n{\"NAME\": [\"10\"]}\n\n$ prog\n{\"NAME\": []}\n\n\nr\"\"\"usage: prog (NAME | --foo NAME)\n\noptions: --foo\n\n\"\"\"\n$ prog 10\n{\"NAME\": \"10\", \"--foo\": false}\n\n$ prog --foo 10\n{\"NAME\": \"10\", \"--foo\": true}\n\n$ prog --foo=10\n\"user-error\"\n\n\nr\"\"\"usage: prog (NAME | --foo) [--bar | NAME]\n\noptions: --foo\noptions: --bar\n\n\"\"\"\n$ prog 10\n{\"NAME\": [\"10\"], \"--foo\": false, \"--bar\": false}\n\n$ prog 10 20\n{\"NAME\": [\"10\", \"20\"], \"--foo\": false, \"--bar\": false}\n\n$ prog --foo --bar\n{\"NAME\": [], \"--foo\": true, \"--bar\": true}\n\n\nr\"\"\"Naval Fate.\n\nUsage:\n  prog ship new <name>...\n  prog ship [<name>] move <x> <y> [--speed=<kn>]\n  prog ship shoot <x> <y>\n  prog mine (set|remove) <x> <y> [--moored|--drifting]\n  prog -h | --help\n  prog --version\n\nOptions:\n  -h --help     Show this screen.\n  --version     Show version.\n  --speed=<kn>  Speed in knots [default: 10].\n  --moored      Mored (anchored) mine.\n  --drifting    Drifting mine.\n\n\"\"\"\n$ prog ship Guardian move 150 300 --speed=20\n{\"--drifting\": false,\n \"--help\": false,\n \"--moored\": false,\n \"--speed\": \"20\",\n \"--version\": false,\n \"<name>\": [\"Guardian\"],\n \"<x>\": \"150\",\n \"<y>\": \"300\",\n \"mine\": false,\n \"move\": true,\n \"new\": false,\n \"remove\": false,\n \"set\": false,\n \"ship\": true,\n \"shoot\": false}\n\n\nr\"\"\"usage: prog --hello\"\"\"\n$ prog --hello\n{\"--hello\": true}\n\n\nr\"\"\"usage: prog [--hello=<world>]\"\"\"\n$ prog\n{\"--hello\": null}\n\n$ prog --hello wrld\n{\"--hello\": \"wrld\"}\n\n\nr\"\"\"usage: prog [-o]\"\"\"\n$ prog\n{\"-o\": false}\n\n$ prog -o\n{\"-o\": true}\n\n\nr\"\"\"usage: prog [-opr]\"\"\"\n$ prog -op\n{\"-o\": true, \"-p\": true, \"-r\": false}\n\n\nr\"\"\"usage: prog --aabb | --aa\"\"\"\n$ prog --aa\n{\"--aabb\": false, \"--aa\": true}\n\n$ prog --a\n\"user-error\"  # not a unique prefix\n\n#\n# Counting number of flags\n#\n\nr\"\"\"Usage: prog -v\"\"\"\n$ prog -v\n{\"-v\": true}\n\n\nr\"\"\"Usage: prog [-v -v]\"\"\"\n$ prog\n{\"-v\": 0}\n\n$ prog -v\n{\"-v\": 1}\n\n$ prog -vv\n{\"-v\": 2}\n\n\nr\"\"\"Usage: prog -v ...\"\"\"\n$ prog\n\"user-error\"\n\n$ prog -v\n{\"-v\": 1}\n\n$ prog -vv\n{\"-v\": 2}\n\n$ prog -vvvvvv\n{\"-v\": 6}\n\n\nr\"\"\"Usage: prog [-v | -vv | -vvv]\n\nThis one is probably most readable user-friednly variant.\n\n\"\"\"\n$ prog\n{\"-v\": 0}\n\n$ prog -v\n{\"-v\": 1}\n\n$ prog -vv\n{\"-v\": 2}\n\n$ prog -vvvv\n\"user-error\"\n\n\nr\"\"\"usage: prog [--ver --ver]\"\"\"\n$ prog --ver --ver\n{\"--ver\": 2}\n\n\n#\n# Counting commands\n#\n\nr\"\"\"usage: prog [go]\"\"\"\n$ prog go\n{\"go\": true}\n\n\nr\"\"\"usage: prog [go go]\"\"\"\n$ prog\n{\"go\": 0}\n\n$ prog go\n{\"go\": 1}\n\n$ prog go go\n{\"go\": 2}\n\n$ prog go go go\n\"user-error\"\n\nr\"\"\"usage: prog go...\"\"\"\n$ prog go go go go go\n{\"go\": 5}\n\n#\n# [options] does not include options from usage-pattern\n#\nr\"\"\"usage: prog [options] [-a]\n\noptions: -a\n         -b\n\"\"\"\n$ prog -a\n{\"-a\": true, \"-b\": false}\n\n$ prog -aa\n\"user-error\"\n\n#\n# Test [options] shourtcut\n#\n\nr\"\"\"Usage: prog [options] A\nOptions:\n    -q  Be quiet\n    -v  Be verbose.\n\n\"\"\"\n$ prog arg\n{\"A\": \"arg\", \"-v\": false, \"-q\": false}\n\n$ prog -v arg\n{\"A\": \"arg\", \"-v\": true, \"-q\": false}\n\n$ prog -q arg\n{\"A\": \"arg\", \"-v\": false, \"-q\": true}\n\n#\n# Test single dash\n#\n\nr\"\"\"usage: prog [-]\"\"\"\n\n$ prog -\n{\"-\": true}\n\n$ prog\n{\"-\": false}\n\n#\n# If argument is repeated, its value should always be a list\n#\n\nr\"\"\"usage: prog [NAME [NAME ...]]\"\"\"\n\n$ prog a b\n{\"NAME\": [\"a\", \"b\"]}\n\n$ prog\n{\"NAME\": []}\n\n#\n# Option's argument defaults to null/None\n#\n\nr\"\"\"usage: prog [options]\noptions:\n -a        Add\n -m <msg>  Message\n\n\"\"\"\n$ prog -a\n{\"-m\": null, \"-a\": true}\n\n#\n# Test options without description\n#\n\nr\"\"\"usage: prog --hello\"\"\"\n$ prog --hello\n{\"--hello\": true}\n\nr\"\"\"usage: prog [--hello=<world>]\"\"\"\n$ prog\n{\"--hello\": null}\n\n$ prog --hello wrld\n{\"--hello\": \"wrld\"}\n\nr\"\"\"usage: prog [-o]\"\"\"\n$ prog\n{\"-o\": false}\n\n$ prog -o\n{\"-o\": true}\n\nr\"\"\"usage: prog [-opr]\"\"\"\n$ prog -op\n{\"-o\": true, \"-p\": true, \"-r\": false}\n\nr\"\"\"usage: git [-v | --verbose]\"\"\"\n$ prog -v\n{\"-v\": true, \"--verbose\": false}\n\nr\"\"\"usage: git remote [-v | --verbose]\"\"\"\n$ prog remote -v\n{\"remote\": true, \"-v\": true, \"--verbose\": false}\n\n#\n# Test empty usage pattern\n#\n\nr\"\"\"usage: prog\"\"\"\n$ prog\n{}\n\nr\"\"\"usage: prog\n           prog <a> <b>\n\"\"\"\n$ prog 1 2\n{\"<a>\": \"1\", \"<b>\": \"2\"}\n\n$ prog\n{\"<a>\": null, \"<b>\": null}\n\nr\"\"\"usage: prog <a> <b>\n           prog\n\"\"\"\n$ prog\n{\"<a>\": null, \"<b>\": null}\n\n#\n# Option's argument should not capture default value from usage pattern\n#\n\nr\"\"\"usage: prog [--file=<f>]\"\"\"\n$ prog\n{\"--file\": null}\n\nr\"\"\"usage: prog [--file=<f>]\n\noptions: --file <a>\n\n\"\"\"\n$ prog\n{\"--file\": null}\n\nr\"\"\"Usage: prog [-a <host:port>]\n\nOptions: -a, --address <host:port>  TCP address [default: localhost:6283].\n\n\"\"\"\n$ prog\n{\"--address\": \"localhost:6283\"}\n\n#\n# If option with argument could be repeated,\n# its arguments should be accumulated into a list\n#\n\nr\"\"\"usage: prog --long=<arg> ...\"\"\"\n\n$ prog --long one\n{\"--long\": [\"one\"]}\n\n$ prog --long one --long two\n{\"--long\": [\"one\", \"two\"]}\n\n#\n# Test multiple elements repeated at once\n#\n\nr\"\"\"usage: prog (go <direction> --speed=<km/h>)...\"\"\"\n$ prog  go left --speed=5  go right --speed=9\n{\"go\": 2, \"<direction>\": [\"left\", \"right\"], \"--speed\": [\"5\", \"9\"]}\n\n#\n# Required options should work with option shortcut\n#\n\nr\"\"\"usage: prog [options] -a\n\noptions: -a\n\n\"\"\"\n$ prog -a\n{\"-a\": true}\n\n#\n# If option could be repeated its defaults should be split into a list\n#\n\nr\"\"\"usage: prog [-o <o>]...\n\noptions: -o <o>  [default: x]\n\n\"\"\"\n$ prog -o this -o that\n{\"-o\": [\"this\", \"that\"]}\n\n$ prog\n{\"-o\": [\"x\"]}\n\nr\"\"\"usage: prog [-o <o>]...\n\noptions: -o <o>  [default: x y]\n\n\"\"\"\n$ prog -o this\n{\"-o\": [\"this\"]}\n\n$ prog\n{\"-o\": [\"x\", \"y\"]}\n\n#\n# Test stacked option's argument\n#\n\nr\"\"\"usage: prog -pPATH\n\noptions: -p PATH\n\n\"\"\"\n$ prog -pHOME\n{\"-p\": \"HOME\"}\n\n#\n# Issue 56: Repeated mutually exclusive args give nested lists sometimes\n#\n\nr\"\"\"Usage: foo (--xx=x|--yy=y)...\"\"\"\n$ prog --xx=1 --yy=2\n{\"--xx\": [\"1\"], \"--yy\": [\"2\"]}\n\n#\n# POSIXly correct tokenization\n#\n\nr\"\"\"usage: prog [<input file>]\"\"\"\n$ prog f.txt\n{\"<input file>\": \"f.txt\"}\n\nr\"\"\"usage: prog [--input=<file name>]...\"\"\"\n$ prog --input a.txt --input=b.txt\n{\"--input\": [\"a.txt\", \"b.txt\"]}\n\n#\n# Issue 85: `[options]` shourtcut with multiple subcommands\n#\n\nr\"\"\"usage: prog good [options]\n           prog fail [options]\n\noptions: --loglevel=N\n\n\"\"\"\n$ prog fail --loglevel 5\n{\"--loglevel\": \"5\", \"fail\": true, \"good\": false}\n\n#\n# Usage-section syntax\n#\n\nr\"\"\"usage:prog --foo\"\"\"\n$ prog --foo\n{\"--foo\": true}\n\nr\"\"\"PROGRAM USAGE: prog --foo\"\"\"\n$ prog --foo\n{\"--foo\": true}\n\nr\"\"\"Usage: prog --foo\n           prog --bar\nNOT PART OF SECTION\"\"\"\n$ prog --foo\n{\"--foo\": true, \"--bar\": false}\n\nr\"\"\"Usage:\n prog --foo\n prog --bar\n\nNOT PART OF SECTION\"\"\"\n$ prog --foo\n{\"--foo\": true, \"--bar\": false}\n\nr\"\"\"Usage:\n prog --foo\n prog --bar\nNOT PART OF SECTION\"\"\"\n$ prog --foo\n{\"--foo\": true, \"--bar\": false}\n\n#\n# Options-section syntax\n#\n\nr\"\"\"Usage: prog [options]\n\nglobal options: --foo\nlocal options: --baz\n               --bar\nother options:\n --egg\n --spam\n-not-an-option-\n\n\"\"\"\n$ prog --baz --egg\n{\"--foo\": false, \"--baz\": true, \"--bar\": false, \"--egg\": true, \"--spam\": false}\n"
        },
        {
          "name": "tox.ini",
          "type": "blob",
          "size": 0.412109375,
          "content": "# Tox (http://tox.testrun.org/) is a tool for running tests in\n# multiple virtualenvs. This configuration file will run the\n# test suite on all supported python versions. To use it, \"pip\n# install tox\" and then run \"tox\" from this directory.\n\n[tox]\nenvlist = py27, py34, py35, py36\n\n[testenv]\ncommands = py.test\ndeps = pytest\n\n[testenv:py27]\ncommands = py.test\n           py.test --doctest-modules docopt.py\ndeps = pytest\n"
        }
      ]
    }
  ]
}