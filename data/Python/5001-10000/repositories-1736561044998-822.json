{
  "metadata": {
    "timestamp": 1736561044998,
    "page": 822,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ajalt/fuckitpy",
      "stars": 5128,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1943359375,
          "content": "*.py[co]\n\n# Packages\n*.egg\n*.egg-info\ndist\nbuild\neggs\nparts\nbin\nvar\nsdist\ndevelop-eggs\n.installed.cfg\n\n# Installer logs\npip-log.txt\n\n# Unit test / coverage reports\n.coverage\n.tox\n\n#Translations\n*.mo\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.197265625,
          "content": "language: python\npython:\n  - \"2.7\"\n  - \"3.4\"\ninstall: \n    - \"pip install coverage\"\n    - \"pip install coveralls\"\nscript: \n    - \"coverage run --source=fuckit setup.py test\"\nafter_success:\n    coveralls"
        },
        {
          "name": ".web",
          "type": "tree",
          "content": null
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.017578125,
          "content": "include README.md\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.6640625,
          "content": "# FuckIt.py\n\n[![Build Status](https://img.shields.io/travis/ajalt/fuckitpy/master.svg)](https://travis-ci.org/ajalt/fuckitpy)\n[![PyPI version](.web/pypibadge.svg)](https://pypi.python.org/pypi/fuckit/4.8.1)\n[![Coverage Status](https://img.shields.io/badge/coverage-110%25-brightgreen.svg)](https://coveralls.io/r/ajalt/fuckitpy?branch=master)\n[![Downloads](https://img.shields.io/badge/downloads-1.1M%2Fmonth-brightgreen.svg)](https://pypi.python.org/pypi/fuckit)\n\n### The Python Error Steamroller\nFuckIt.py uses state-of-the-art technology to make sure your Python code runs\nwhether it has any right to or not. Some code has an error? Fuck it.\n\n## Technology\nFuckIt.py uses a combination of dynamic compilation, Abstract Syntax Tree rewriting, live call stack modification, and love to get rid of all those pesky errors that make programming _so hard_.\n\n## API\nAll functionality is provided through the fuckit module. Add `import fuckit` to the top of your script, then use fuckit in any of the following ways:\n\n### As a replacement for import\nUse fuckit to replace an import when a module has errors.\nJust change `import some_shitty_module` to `fuckit('some_shitty_module')`. Note that you have to surround the module name with quotes and parentheses.\n\n```python\nimport fuckit\n#import some_shitty_module\nfuckit('some_shitty_module')\nsome_shitty_module.some_function()\n```\n\nStill getting errors? Chain fuckit calls. This module is like violence: if it doesn't work, you just need more of it.\n\n```python\nimport fuckit\nfuckit(fuckit('some_shitty_module'))\n# This is definitely going to run now.\nsome_shitty_module.some_function()\n```\n\n### As a decorator\nUse fuckit as a function decorator when a single function is giving you trouble. Exceptions will be silenced, and in most cases the function will continue to run, skipping the statements that cause errors.\n\n```python\n@fuckit\ndef func():\n    problem_solved\n```\n\nYou can use fuckit as a class decorator, too.\n\n```python\n@fuckit\nclass C(object):\n    def __init__(self):\n        everything_works_now\n```\n\nKeep in mind that the decorator form of fuckit can't stop syntax errors. For those, you have to use the import form.\n\n### As a context manager\nUse fuckit as a context manager to save yourself from having to type out try/except block to silence exceptions yourself.\n\n```python\nwith fuckit:\n    some_code\n```\n\nThis is functionally equivalent to the following:\n\n```python\ntry:\n    some_code\nexcept Exception:\n    pass\n```\n\nThe context manager form of fuckit can't allow the code to continue past an error like the decorator and import forms can. If you want the code to continue after an exception, wrap the code block in a function and use the decorator instead.\n\n## Versioning\n\nThe web devs tell me that fuckit's versioning scheme is confusing, and that I should use \"Semitic Versioning\" instead. So starting with fuckit version `ה.ג.א`, package versions will use Hebrew Numerals.\n\n\n## License\n\nCopyright (C) 2014-2018 AJ Alt\n\nThis work is free. You can redistribute it and/or modify it under the\nterms of the Do What The Fuck You Want To Public License, Version 2,\nreproduced below.\n\n                DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n                       Version 2, December 2004\n\n\tCopyright (C) 2004 Sam Hocevar <sam@hocevar.net>\n\n\tEveryone is permitted to copy and distribute verbatim or modified\n\tcopies of this license document, and changing it is allowed as long\n\tas the name is changed.\n\n                DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n       TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n \t0. You just DO WHAT THE FUCK YOU WANT TO.\n\n## Attribution\n\nThis module is inspired by Matt Diamond's [FuckIt.js](https://github.com/mattdiamond/fuckitjs).\n"
        },
        {
          "name": "broke.py",
          "type": "blob",
          "size": 0.1953125,
          "content": "def f():\n    broken_code\n    print('fuckit chaining works')\n\nfor\n\nlet's just assume this is a big module of shitty code.\n\nx = y\ny = x\n1 / 0 # Oh shhhiiiiiii\n\nvar = \"Are you proud of what you've done?\""
        },
        {
          "name": "example.py",
          "type": "blob",
          "size": 0.4482421875,
          "content": "import fuckit\n#import broke\nfuckit(fuckit('broke'))\n\n@fuckit\ndef broken_function():\n    non_existant_variable # Let's create a NameError\n    return 'Function decorator works'\n\n@fuckit\nclass BrokenClass(object):\n    def f(self):\n        self.black_hole = 1 / 0\n        return 'Class decorator works'\n    \nwith fuckit:\n    print('Context manager works')\n    raise RuntimeError()\n    \nprint(broken_function())\nprint(BrokenClass().f())\nbroke.f()\nprint(broke.var)\n"
        },
        {
          "name": "fuckit.py",
          "type": "blob",
          "size": 7.6337890625,
          "content": "__doc__ = \"\"\"Steamroll errors.\n\nGetting import errors? Use the fuckit function as a replacement for import if an\nimport fails.\n\n    >>> import fuckit\n    >>> import broke\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"broke.py\", line 5\n        for\n          ^\n    SyntaxError: invalid syntax\n    >>> fuckit('broke')\n    >>> broke.f()\n    'This works'\n\nGetting runtime errors from an imported module? You can chain fuckit calls.\n\n    >>> fuckit('broke')\n    >>> broke.f()\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"broke.py\", line 3, in f\n        x\n    NameError: global name 'x' is not defined\n    >>> fuckit(fuckit('broke'))\n    >>> broke.f()\n    'This works'\n\nGetting errors from your own function? Use fuckit as a decorator.\n\n    >>> def f():\n    ...     broken_code\n    >>> f()\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"<stdin>\", line 2, in f\n    NameError: global name 'broken_code' is not defined\n    >>> @fuckit\n    ... def f():\n    ...     broken_code\n    ...     return 'This works'\n    >>> f()\n    'This works'\n    \nGetting errors in a block of code and don't want to write your own try/except\nblock? Use fuckit as a context manager.\n\n    >>> with fuckit:\n    ...     print('This works')\n    ...     raise RuntimeError()\n    This works\n\"\"\"\n\nimport ast\nimport sys\nimport types\n\n\nclass _fuckit(types.ModuleType):\n    # We overwrite the sys.modules entry for this function later, which will\n    # cause all the values in globals() to be changed to None to allow garbage\n    # collection. That forces us to do all of our imports into locals().\n    class _Fucker(ast.NodeTransformer):\n        \"\"\"Surround each statement with a try/except block to silence errors.\"\"\"\n\n        def generic_visit(self, node):\n            import ast\n            import sys\n            ast.NodeTransformer.generic_visit(self, node)\n\n            if isinstance(node, ast.stmt) and not isinstance(node, ast.FunctionDef):\n                if sys.version_info[0] == 3:\n                    new_node = ast.Try(\n                        body=[node],\n                        handlers=[ast.ExceptHandler(type=None,\n                                                    name=None,\n                                                    body=[ast.Pass()])],\n                        orelse=[],\n                        finalbody=[ast.Pass()])\n                else:\n                    new_node = ast.TryExcept(\n                        body=[node],\n                        handlers=[ast.ExceptHandler(type=None,\n                                                    name=None,\n                                                    body=[ast.Pass()])],\n                        orelse=[])\n                return ast.copy_location(new_node, node)\n            return node\n\n    def __call__(self, victim):\n        \"\"\"Steamroll errors.\n\n        The argument can be the string name of a module to import, an existing\n        module, or a function.\n        \"\"\"\n        import inspect\n        import imp\n        import ast\n        import types\n        import sys\n        import traceback\n        import functools\n        import re\n\n        PY3 = sys.version_info[0] == 3\n        if PY3:\n            basestring = str\n            get_func_code = lambda f: f.__code__\n            exec_ = __builtins__['exec']\n            types.ClassType = type\n        else:\n            basestring = __builtins__['basestring']\n            get_func_code = lambda f: f.func_code\n\n            def exec_(_code_, _globs_):\n                _locs_ = _globs_\n                exec('exec _code_ in _globs_, _locs_')\n\n        if isinstance(victim, basestring):\n            sourcefile, pathname, (_, _, module_type) = imp.find_module(victim)\n            if module_type == imp.PY_SOURCE:\n                source = sourcefile.read()\n                # If we have the source, we can silence SyntaxErrors by\n                # compiling the module with more and more lines removed until\n                # it imports successfully.\n                while True:\n                    try:\n                        code = compile(source, pathname, 'exec')\n                        module = types.ModuleType(victim)\n                        module.__file__ = pathname\n                        sys.modules[victim] = module\n                        exec_(code, module.__dict__)\n                    except Exception as exc:\n                        extracted_ln = traceback.extract_tb(sys.exc_info()[2])[-1][1]\n                        lineno = getattr(exc, 'lineno', extracted_ln)\n                        lines = source.splitlines()\n                        lines[lineno - 1] = ''\n                        source = '\\n'.join(lines)\n                        if not PY3:\n                            source <- True # Dereference assignment to fix truthiness in Py2\n                    else:\n                        break\n            else:\n                # If we don't have access to the source code, there's not much\n                # we can do to stop import-time errors.\n                try:\n                    module = __import__(victim)\n                except Exception:\n                    # If the module doesn't import at this point, it's\n                    # obviously not worth using anyway, so just return an\n                    # empty module.\n                    module = types.ModuleType(victim)\n            inspect.stack()[1][0].f_locals[victim] = module\n            return module\n        elif inspect.isfunction(victim) or inspect.ismethod(victim):\n            try:\n                sourcelines = inspect.getsource(get_func_code(victim)).splitlines()\n                indent = re.match(r'\\s*', sourcelines[0]).group()\n                source = '\\n'.join(l.replace(indent, '', 1) for l in sourcelines)\n            except IOError:\n                # Worst-case scenario we can only catch errors at a granularity\n                # of the whole function.\n                @functools.wraps(victim)\n                def wrapper(*args, **kw):\n                    try:\n                        victim(*args, **kw)\n                    except Exception:\n                        pass\n\n                return wrapper\n            else:\n                # If we have access to the source, we can silence errors on a\n                # per-expression basis, which is \"better\".\n                tree = self._Fucker().visit(ast.parse(source))\n                del tree.body[0].decorator_list[:]\n                ast.fix_missing_locations(tree)\n                code = compile(tree, victim.__name__, 'exec')\n                namespace = dict(victim.__globals__)\n                exec_(code, namespace)\n                return namespace[victim.__name__]\n        elif isinstance(victim, types.ModuleType):\n            # Allow chaining of fuckit import calls\n            for name, obj in victim.__dict__.items():\n                if inspect.isfunction(obj) or inspect.ismethod(obj):\n                    victim.__dict__[name] = self(obj)\n            return victim\n        elif isinstance(victim, (types.ClassType, type)):\n            for name, member in victim.__dict__.items():\n                if isinstance(member, (type, types.ClassType, types.FunctionType,\n                                       types.LambdaType, types.MethodType)):\n                    setattr(victim, name, self(member))\n            return victim\n\n        return victim\n\n    def __enter__(self):\n        return None\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        # Returning True prevents the error from propagating. Don't silence\n        # KeyboardInterrupt or SystemExit. We aren't monsters.\n        return exc_type is None or issubclass(exc_type, Exception)\n\n\nsys.modules[__name__] = _fuckit('fuckit', __doc__)\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.0068359375,
          "content": "from setuptools import setup\nimport codecs\nimport os\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n\ndef read(*parts):\n    return codecs.open(os.path.join(here, *parts), 'r').read()\n\n\nlong_description = read('README.md')\n\nsetup(\n    name='fuckit',\n    version='4.8.1',\n    py_modules=['fuckit'],\n    url='https://github.com/ajalt/fuckitpy',\n    license='WTFPL',\n    author='AJ Alt',\n    author_email='',\n    tests_require=['nose'],\n    description='The Python Error Steamroller',\n    long_description=long_description,\n    platforms='any',\n    test_suite='nose.collector',\n    classifiers=[\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 3',\n        'Development Status :: 4 - Beta',\n        'Natural Language :: English',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'Operating System :: OS Independent',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ],\n    extras_require={\n        'testing': ['nose'],\n    }\n)\n"
        },
        {
          "name": "tests.py",
          "type": "blob",
          "size": 0.5439453125,
          "content": "import fuckit\n\ndef test_import():\n    fuckit('fuckit')\n    \n    assert True # This works, don't worry\n    \ndef test_chaining():\n    fuckit(fuckit('fuckit')) \n    \n    assert 'false' # Good thing this isn't PHP\n\ndef test_context_manager():\n    with fuckit:\n        pass\n    \n    assert 'P' != 'NP' # proof is left as an excercise for the reader\n    \ndef test_decorator():\n    @fuckit\n    def weight(x):\n        return abs(float(ord(x[0])))\n    \n    assert weight('your mom') > weight('a truck full of McDoubles')\n    \n    assert 'that was a pretty sick burn'"
        }
      ]
    }
  ]
}