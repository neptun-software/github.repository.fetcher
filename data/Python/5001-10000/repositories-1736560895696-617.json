{
  "metadata": {
    "timestamp": 1736560895696,
    "page": 617,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pytransitions/transitions",
      "stars": 5870,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".coveragerc",
          "type": "blob",
          "size": 0.0478515625,
          "content": "[run]\nsource = transitions\nrelative_files = True\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2158203125,
          "content": "*.pyc\n*.DS_Store\n*~\nbuild/\ndist\ndist/*\n*.egg-info\n.eggs/\n*.iml\n.idea\n.vscode\n.coverage\nexamples/.ipynb_checkpoints\nexamples/state.png\n.tox\n.python-version\nMANIFEST\n*.bak\npylint.log\nsandbox*\ncoverage.xml\n.dmypy.json\n.venv\n"
        },
        {
          "name": ".pylintrc",
          "type": "blob",
          "size": 14.564453125,
          "content": "[MASTER]\n\n# A comma-separated list of package or module names from where C extensions may\n# be loaded. Extensions are loading into the active Python interpreter and may\n# run arbitrary code\nextension-pkg-whitelist=\n\n# Add files or directories to the blacklist. They should be base names, not\n# paths.\nignore=CVS\n\n# Add files or directories matching the regex patterns to the blacklist. The\n# regex matches against base names, not paths.\nignore-patterns=\n\n# Python code to execute, usually for sys.path manipulation such as\n# pygtk.require().\n#init-hook=\n\n# Use multiple processes to speed up Pylint.\njobs=1\n\n# List of plugins (as comma separated values of python modules names) to load,\n# usually to register additional checkers.\nload-plugins=\n\n# Pickle collected data for later comparisons.\npersistent=yes\n\n# Specify a configuration file.\n#rcfile=\n\n# Allow loading of arbitrary C extensions. Extensions are imported into the\n# active Python interpreter and may run arbitrary code.\nunsafe-load-any-extension=no\n\n\n[MESSAGES CONTROL]\n\n# Only show warnings with the listed confidence levels. Leave empty to show\n# all. Valid levels: HIGH, INFERENCE, INFERENCE_FAILURE, UNDEFINED\nconfidence=\n\n# Disable the message, report, category or checker with the given id(s). You\n# can either give multiple identifiers separated by comma (,) or put this\n# option multiple times (only on the command line, not in the configuration\n# file where it should appear only once).You can also use \"--disable=all\" to\n# disable everything first and then reenable specific checks. For example, if\n# you want to run only the similarities checker, you can use \"--disable=all\n# --enable=similarities\". If you want to run only the classes checker, but have\n# no Warning level messages displayed, use\"--disable=all --enable=classes\n# --disable=W\"\ndisable=print-statement,parameter-unpacking,unpacking-in-except,old-raise-syntax,backtick,long-suffix,old-ne-operator,\n    old-octal-literal,import-star-module-level,raw-checker-failed,bad-inline-option,locally-disabled,locally-enabled,\n    file-ignored,suppressed-message,useless-suppression,deprecated-pragma,apply-builtin,basestring-builtin,\n    buffer-builtin,cmp-builtin,coerce-builtin,execfile-builtin,file-builtin,long-builtin,raw_input-builtin,\n    reduce-builtin,standarderror-builtin,unicode-builtin,xrange-builtin,coerce-method,delslice-method,\n    getslice-method,setslice-method,no-absolute-import,old-division,dict-iter-method,dict-view-method,\n    next-method-called,metaclass-assignment,indexing-exception,raising-string,reload-builtin,oct-method,\n    hex-method,nonzero-method,cmp-method,input-builtin,round-builtin,intern-builtin,unichr-builtin,\n    map-builtin-not-iterating,zip-builtin-not-iterating,range-builtin-not-iterating,filter-builtin-not-iterating,\n    using-cmp-argument,eq-without-hash,div-method,idiv-method,rdiv-method,exception-message-attribute,invalid-str-codec,\n    sys-max-int,bad-python3-import,deprecated-string-function,deprecated-str-translate-call,\n    too-few-public-methods,\n    super-with-arguments,\n    useless-object-inheritance,\n    raise-missing-from\n\n# Enable the message, report, category or checker with the given id(s). You can\n# either give multiple identifier separated by comma (,) or put this option\n# multiple time (only on the command line, not in the configuration file where\n# it should appear only once). See also the \"--disable\" option for examples.\nenable=\n\n\n[REPORTS]\n\n# Python expression which should return a note less than 10 (10 is the highest\n# note). You have access to the variables errors warning, statement which\n# respectively contain the number of errors / warnings messages and the total\n# number of statements analyzed. This is used by the global evaluation report\n# (RP0004).\nevaluation=10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)\n\n# Template used to display messages. This is a python new-style format string\n# used to format the message information. See doc for all details\n#msg-template=\n\n# Set the output format. Available formats are text, parseable, colorized, json\n# and msvs (visual studio).You can also give a reporter class, eg\n# mypackage.mymodule.MyReporterClass.\noutput-format=text\n\n# Tells whether to display a full report or only the messages\nreports=no\n\n# Activate the evaluation score.\nscore=yes\n\n\n[REFACTORING]\n\n# Maximum number of nested blocks for function / method body\nmax-nested-blocks=5\n\n\n[BASIC]\n\n# Naming hint for argument names\nargument-name-hint=(([a-z][a-z0-9_]{2,30})|(_[a-z0-9_]*))$\n\n# Regular expression matching correct argument names\nargument-rgx=(([a-z][a-z0-9_]{2,30})|(_[a-z0-9_]*))$\n\n# Naming hint for attribute names\nattr-name-hint=(([a-z][a-z0-9_]{2,30})|(_[a-z0-9_]*))$\n\n# Regular expression matching correct attribute names\nattr-rgx=(([a-z][a-z0-9_]{2,30})|(_[a-z0-9_]*))$\n\n# Bad variable names which should always be refused, separated by a comma\nbad-names=foo,bar,baz,toto,tutu,tata\n\n# Naming hint for class attribute names\nclass-attribute-name-hint=([A-Za-z_][A-Za-z0-9_]{2,30}|(__.*__))$\n\n# Regular expression matching correct class attribute names\nclass-attribute-rgx=([A-Za-z_][A-Za-z0-9_]{2,30}|(__.*__))$\n\n# Naming hint for class names\nclass-name-hint=[A-Z_][a-zA-Z0-9]+$\n\n# Regular expression matching correct class names\nclass-rgx=[A-Z_][a-zA-Z0-9]+$\n\n# Naming hint for constant names\nconst-name-hint=(([A-Z_][A-Z0-9_]*)|(__.*__))$\n\n# Regular expression matching correct constant names\nconst-rgx=(([A-Z_][A-Z0-9_]*)|(__.*__))$\n\n# Minimum line length for functions/classes that require docstrings, shorter\n# ones are exempt.\ndocstring-min-length=-1\n\n# Naming hint for function names\nfunction-name-hint=(([a-z][a-z0-9_]{2,30})|(_[a-z0-9_]*))$\n\n# Regular expression matching correct function names\nfunction-rgx=(([a-z][a-z0-9_]{2,30})|(_[a-z0-9_]*))$\n\n# Good variable names which should always be accepted, separated by a comma\ngood-names=i,j,k,ex,Run,_\n\n# Include a hint for the correct naming format with invalid-name\ninclude-naming-hint=no\n\n# Naming hint for inline iteration names\ninlinevar-name-hint=[A-Za-z_][A-Za-z0-9_]*$\n\n# Regular expression matching correct inline iteration names\ninlinevar-rgx=[A-Za-z_][A-Za-z0-9_]*$\n\n# Naming hint for method names\nmethod-name-hint=(([a-z][a-z0-9_]{2,30})|(_[a-z0-9_]*))$\n\n# Regular expression matching correct method names\nmethod-rgx=(([a-z][a-z0-9_]{2,30})|(_[a-z0-9_]*))$\n\n# Naming hint for module names\nmodule-name-hint=(([a-z_][a-z0-9_]*)|([A-Z][a-zA-Z0-9]+))$\n\n# Regular expression matching correct module names\nmodule-rgx=(([a-z_][a-z0-9_]*)|([A-Z][a-zA-Z0-9]+))$\n\n# Colon-delimited sets of names that determine each other's naming style when\n# the name regexes allow several styles.\nname-group=\n\n# Regular expression which should only match function or class names that do\n# not require a docstring.\nno-docstring-rgx=^_\n\n# List of decorators that produce properties, such as abc.abstractproperty. Add\n# to this list to register other decorators that produce valid properties.\nproperty-classes=abc.abstractproperty\n\n# Naming hint for variable names\nvariable-name-hint=(([a-z][a-z0-9_]{2,30})|(_[a-z0-9_]*))$\n\n# Regular expression matching correct variable names\nvariable-rgx=(([a-z][a-z0-9_]{2,30})|(_[a-z0-9_]*))$\n\n\n[FORMAT]\n\n# Expected format of line ending, e.g. empty (any line ending), LF or CRLF.\nexpected-line-ending-format=\n\n# Regexp for a line that is allowed to be longer than the limit.\nignore-long-lines=^\\s*(# )?<?https?://\\S+>?$\n\n# Number of spaces of indent required inside a hanging  or continued line.\nindent-after-paren=4\n\n# String used as indentation unit. This is usually \"    \" (4 spaces) or \"\\t\" (1\n# tab).\nindent-string='    '\n\n# Maximum number of characters on a single line.\nmax-line-length=120\n\n# Maximum number of lines in a module\nmax-module-lines=1000\n\n# List of optional constructs for which whitespace checking is disabled. `dict-\n# separator` is used to allow tabulation in dicts, etc.: {1  : 1,\\n222: 2}.\n# `trailing-comma` allows a space between comma and closing bracket: (a, ).\n# `empty-line` allows space-only lines.\nno-space-check=trailing-comma,dict-separator\n\n# Allow the body of a class to be on the same line as the declaration if body\n# contains single statement.\nsingle-line-class-stmt=no\n\n# Allow the body of an if to be on the same line as the test if there is no\n# else.\nsingle-line-if-stmt=no\n\n\n[LOGGING]\n\n# Logging modules to check that the string format arguments are in logging\n# function parameter format\nlogging-modules=logging\n\n\n[MISCELLANEOUS]\n\n# List of note tags to take in consideration, separated by a comma.\nnotes=FIXME,XXX,TODO\n\n\n[SIMILARITIES]\n\n# Ignore comments when computing similarities.\nignore-comments=yes\n\n# Ignore docstrings when computing similarities.\nignore-docstrings=yes\n\n# Ignore imports when computing similarities.\nignore-imports=no\n\n# Minimum lines number of a similarity.\nmin-similarity-lines=4\n\n\n[SPELLING]\n\n# Spelling dictionary name. Available dictionaries: none. To make it working\n# install python-enchant package.\nspelling-dict=\n\n# List of comma separated words that should not be checked.\nspelling-ignore-words=\n\n# A path to a file that contains private dictionary; one word per line.\nspelling-private-dict-file=\n\n# Tells whether to store unknown words to indicated private dictionary in\n# --spelling-private-dict-file option instead of raising a message.\nspelling-store-unknown-words=no\n\n\n[TYPECHECK]\n\n# List of decorators that produce context managers, such as\n# contextlib.contextmanager. Add to this list to register other decorators that\n# produce valid context managers.\ncontextmanager-decorators=contextlib.contextmanager\n\n# List of members which are set dynamically and missed by pylint inference\n# system, and so shouldn't trigger E1101 when accessed. Python regular\n# expressions are accepted.\ngenerated-members=\n\n# Tells whether missing members accessed in mixin class should be ignored. A\n# mixin class is detected if its name ends with \"mixin\" (case insensitive).\nignore-mixin-members=yes\n\n# This flag controls whether pylint should warn about no-member and similar\n# checks whenever an opaque object is returned when inferring. The inference\n# can return multiple potential results while evaluating a Python object, but\n# some branches might not be evaluated, which results in partial inference. In\n# that case, it might be useful to still emit no-member and other checks for\n# the rest of the inferred objects.\nignore-on-opaque-inference=yes\n\n# List of class names for which member attributes should not be checked (useful\n# for classes with dynamically set attributes). This supports the use of\n# qualified names.\nignored-classes=optparse.Values,thread._local,_thread._local\n\n# List of module names for which member attributes should not be checked\n# (useful for modules/projects where namespaces are manipulated during runtime\n# and thus existing member attributes cannot be deduced by static analysis. It\n# supports qualified module names, as well as Unix pattern matching.\nignored-modules=\n\n# Show a hint with possible names when a member name was not found. The aspect\n# of finding the hint is based on edit distance.\nmissing-member-hint=yes\n\n# The minimum edit distance a name should have in order to be considered a\n# similar match for a missing member name.\nmissing-member-hint-distance=1\n\n# The total number of similar names that should be taken in consideration when\n# showing a hint for a missing member.\nmissing-member-max-choices=1\n\n\n[VARIABLES]\n\n# List of additional names supposed to be defined in builtins. Remember that\n# you should avoid to define new builtins when possible.\nadditional-builtins=\n\n# Tells whether unused global variables should be treated as a violation.\nallow-global-unused-variables=yes\n\n# List of strings which can identify a callback function by name. A callback\n# name must start or end with one of those strings.\ncallbacks=cb_,_cb\n\n# A regular expression matching the name of dummy variables (i.e. expectedly\n# not used).\ndummy-variables-rgx=_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_\n\n# Argument names that match this expression will be ignored. Default to name\n# with leading underscore\nignored-argument-names=_.*|^ignored_|^unused_\n\n# Tells whether we should check for unused import in __init__ files.\ninit-import=no\n\n# List of qualified module names which can have objects that can redefine\n# builtins.\nredefining-builtins-modules=six.moves,future.builtins,builtins\n\n\n[CLASSES]\n\n# List of method names used to declare (i.e. assign) instance attributes.\ndefining-attr-methods=__init__,__new__,setUp\n\n# List of member names, which should be excluded from the protected access\n# warning.\nexclude-protected=_asdict,_fields,_replace,_source,_make\n\n# List of valid names for the first argument in a class method.\nvalid-classmethod-first-arg=cls\n\n# List of valid names for the first argument in a metaclass class method.\nvalid-metaclass-classmethod-first-arg=mcs\n\n\n[DESIGN]\n\n# Maximum number of arguments for function / method\nmax-args=5\n\n# Maximum number of attributes for a class (see R0902).\nmax-attributes=7\n\n# Maximum number of boolean expressions in a if statement\nmax-bool-expr=5\n\n# Maximum number of branch for function / method body\nmax-branches=12\n\n# Maximum number of locals for function / method body\nmax-locals=15\n\n# Maximum number of parents for a class (see R0901).\nmax-parents=7\n\n# Maximum number of public methods for a class (see R0904).\nmax-public-methods=20\n\n# Maximum number of return / yield for function / method body\nmax-returns=6\n\n# Maximum number of statements in function / method body\nmax-statements=50\n\n# Minimum number of public methods for a class (see R0903).\nmin-public-methods=2\n\n\n[IMPORTS]\n\n# Allow wildcard imports from modules that define __all__.\nallow-wildcard-with-all=no\n\n# Analyse import fallback blocks. This can be used to support both Python 2 and\n# 3 compatible code, which means that the block might have code that exists\n# only in one or another interpreter, leading to false positives when analysed.\nanalyse-fallback-blocks=no\n\n# Deprecated modules which should not be used, separated by a comma\ndeprecated-modules=regsub,TERMIOS,Bastion,rexec\n\n# Create a graph of external dependencies in the given file (report RP0402 must\n# not be disabled)\next-import-graph=\n\n# Create a graph of every (i.e. internal and external) dependencies in the\n# given file (report RP0402 must not be disabled)\nimport-graph=\n\n# Create a graph of internal dependencies in the given file (report RP0402 must\n# not be disabled)\nint-import-graph=\n\n# Force import order to recognize a module as part of the standard\n# compatibility libraries.\nknown-standard-library=\n\n# Force import order to recognize a module as part of a third party library.\nknown-third-party=enchant\n\n\n[EXCEPTIONS]\n\n# Exceptions that will emit a warning when being caught. Defaults to\n# \"Exception\"\novergeneral-exceptions=Exception\n"
        },
        {
          "name": "Changelog.md",
          "type": "blob",
          "size": 32.2900390625,
          "content": "# Changelog\n\n## 0.9.3 ()\n\n- Bug #683: Typing wrongly suggested that `Transition` instances can be passed to `Machine.__init__` and/or `Machine.add_transition(s)` (thanks @antonio-antuan)\n- Typing should be more precise now\n  - Made `transitions.core.(Async)TransitionConfigDict` a `TypedDict` which can be used to spot parameter errors during static analysis\n  - `Machine.add_transitions` and `Machine.__init__` expect a `Sequence` of configurations for transitions now\n  - Added 'async' callbacks to types in `asyncio` extension\n\n## 0.9.2 (August 2024)\n\nRelease 0.9.2 is a minor release and contains a new mermaid diagram backend, a new model decoration mode for easier development with types and some more features and bugfixes.\n\n- Bug #610: Decorate models appropriately when `HierarchicalMachine` is passed to `add_state` (thanks @e0lithic)\n- Bug #647: Let `may_<trigger>` check all parallel states in processing order (thanks @spearsear)\n- Bug: `HSM.is_state` works with parallel states now\n- Experimental features: \n  + Add `model_override` to Machine constructor to determine the mode of operation. With `model_override=Fale` (default), `transitions` will not override already defined methods on a model just as it did before. For workflows relying on typing, `model_override=True` will override methods already defined on the model and only those (!). This allows to control which convenience methods shall be assigned to the model and keeps the statically 'assumed' model in sync with its runtime counterpart. Since defining each and every method manually is rather tiresome, `transitions.experimental.utils.generate_base_model` features a way to convert a machine configuration into a `BaseClass` with all convenience functions and callbacks.\n  + Add `transitions.experimental.utils.{add_transitions, event, with_model_definitions, transition}` to define trigger methods in a class model for more convenient type checking. `add_transitions` can be used as a function decorator and is stackable. `event` returns a placeholder object for attribute assigment. `add_transitions` and `event` have the same signature and support transition definition like machine constructors. The function `transition` can used for better typing and returns a dictionary that can be passed to the utility functions but also to a machine constructor. `add_transitions` and `event` require a machine decorated with `with_model_definitions`. Decorating a machine `with_model_definitions` implies `model_override=True`.\n- Feature: Add `may_trigger` to models to check whether transitions can be conducted by trigger name.\n- Feature: Add Mermaid diagram backend that returns a mermaid diagram as a string. `use_pygraphviz` is deprecated in favour for `graph_engine` which may be `pygraphviz` (default), `graphviz` or `mermaid`.\n\n## 0.9.1 (May 2024)\n\nRelease 0.9.1 is a minor release and contains several bugfixes and some (typing) improvements. This release also introduces `on_final` callbacks on machines (as well as `NestedState`) and `final` flags for states.\n\n- Bug #594: Fix may_<trigger> always returning false for internal transitions (thanks @a-schade)\n- PR #592: Pass investigated transition to `EventData` context in 'may' check (thanks @msclock)\n- PR #634: Improve the handling of diagrams when working with parallel states, especially when using the show_roi option (thanks @seanxlliu)\n- Bug #619/#639: `Exception` is not broad enough and does not catch `asyncio.CancelledError` or `KeyboardInterrupt`; use `BaseException` instead (thanks @e0lithic and @ofacklam)\n- '_anchor' suffix has been removed for (py)graphviz cluster node anchors\n- local testing switched from [tox](https://github.com/tox-dev/tox) to [nox](https://github.com/wntrblm/nox)\n- PR #633: Remove surrounding whitespace from docstrings (thanks @artofhuman)\n- PR #665: Add `on_final` to `Machine` and `NestedState` constructor and `final` to `State`. Callbacks passed to `on_final` will be executed when a State with `final=True` is entered or all children of a parallel state are final.\n- Bug #626: Process exceptions with `Machine.on_exception` in may_<trigger> as well (thanks @match1)\n- PR #666: Improved handling of removing transitions for `GraphMachine` and `HiearachicalMachine` (thanks @drpjm)\n- PR #667: Better handling of unset styling in `GraphMachine`\n- Typing:\n  + Added `--strict` mypy flag for `transitions` type checks (not `tests` though)\n  + Made state, event and machine property mandatory in (Nested)EventData\n  + Transition.dest may be None\n  + Introduced (Async)CallbackFunc to declutter callback-related signatures\n  + Add stub file for extension package for explicite reexport (thanks @DrewDevereux)\n\n## 0.9.0 (September 2022)\n\nRelease 0.9.0 is a major release and contains improvements to ease development, adds some new features and removes the legacy hierarchical machine:\n\n- removed legacy implementation of `HierarchicalMachine` from the package\n- Bug #551: Fix active state styling in `GraphMachine` (thanks @betaboon)\n- Bug #554: Fix issues related to scopes and queueing in `HierachicalMachine` (thanks @jankrejci)\n- Bug #568: Reflexive transitions (dest: '=') had not been resolved correctly when source was a wildcard (thanks @jnu)\n- Bug #568: HSM did not detect reflexive transitions if src was a parent state (thanks @lostcontrol)\n- Bug #569: Fix implicit fallback to `graphviz` when `pygraphviz` was not installed (thanks @FridjofAmundsen)\n- Bug #580: Fix `on_timeout` callback resolution when timeout had been initialized with `timeout=0` (thanks @Rysbai)\n- Bug #582: Last label in `GraphSupport` was not correctly aligned when `show_attributes=True` (thanks @spagh-eddie)\n- Feature: Add pyi stub files for better type hinting. Since many functions and constructors allow rather arbitrary arguments time will tell whether typing should be strict (and cause more mypy issues) or more relaxed (and thus less precise).\n- Feature: Reviewed and improved method documentation\n- Feature #549: Add `may` transition check to transitions (thanks @artofhuman)\n- Feature #552: Refactored error handling to be able to handle `MachineError` in `on_exception` callbacks (thanks @kpihus)\n- Feature: Add `mypy` to test workflow\n- PR #461: Add `Retry` state to supported state stereotypes (thanks @rgov)\n- Internal: `Machine._identify_callback` has been converted to instance method from class method\n- Internal: `LockedMachine._get_qualified_state_name` has been converted to instance method from static method\n- Internal: Removed `_super` workaround related to dill (see https://github.com/pytransitions/transitions/issues/236)\n\n## 0.8.11 (February 2022)\n\nRelease 0.8.11 is the last 0.8 release and contains fixes for Python 3.10 compatibility issues\n\n- Bug #559: Rewrote an async test and replaced `setDaemon` with `daemon` property assignment for thread handling (thanks @debalance)\n\n## 0.8.10 (October 2021)\n\nRelease 0.8.10 is a minor release and contains two bug fixes for the HSM extension and changes how the 'self' literal string is handled.\n\n- Feature #545: The literal 'self' (default model parameter of `Machine`) has been replaced by the class variable `Machine.self_literal = 'self'`. `Machine` now performs an identity check (instead of a value check) with `mod is self.self_literal` to determine whether it should act as a model. While 'self' should still work when passed to the `model` parameter, we encourage using `Machine.self_literal` from now on. This was done to enable easier override of `Machine.__eq__` in subclasses (thanks @VKSolovev).\n- Bug #547: Introduce `HierarchicalMachine.prefix_path` to resolve global state names since the HSM stack is not reliable when `queued=True` (thanks @jankrejci).\n- Bug #548: `HSM` source states were exited even though they are parents of the destination state (thanks @wes-public-apps).\n\n## 0.8.9 (September 2021)\n\nRelease 0.8.9 is a minor release and contains a bugfix for HSM, a feature for `GraphSupport` and changes internal cache handling:\n\n- Bugfix #544: `NestedEvent` now wraps the machine's scope into partials passed to `HierarchicalMachine._process`. This prevents queued transitions from losing their scope.\n- Feature #533: `(A)Graph.draw` function (object returned by `GraphMachine.get_graph()`) can be passed a file/stream object as first parameter or `None`. The later will result in `draw` returning a binary string. (thanks @Blindfreddy).\n- Feature #532: Use id(model) instead of model for machine-bound caches in `LockedMachine`, `AsyncMachine` and `GraphMachine`. This might influence pickling (thanks @thedrow).\n\n## 0.8.8 (April 2021)\n\nRelease 0.8.8 is a minor release and contains a bugfix and several new or improved features:\n\n- Bugfix #526: `AsyncMachine` does not remove models when `remove_models` is called (thanks @Plazas87)\n- Feature #517: Introduce `try/except` for finalize callbacks in `Machine` and `HierachicalMachine`. Thus, errors occurring in finalize callbacks will be suppressed and only the original error will be raised.\n- Feature #520: Show references in graphs and markup. Introduce `MarkupMachine.format_references` to tweak reference formatting (thanks @StephenCarboni)\n- Feature #485: Introduce `Machine.on_exception` to handle raised exceptions in callbacks (thanks @thedrow)\n- Feature #527: `Machine.get_triggers` now supports `State` and `Enum` as arguments (thanks @luup2k)\n- Feature #506: `NestedState` and `HierachicalMachine.add_states` now accept (lists of) states and enums as `initial` parameter\n\n## 0.8.7 (February 2021)\n\nRelease 0.8.7 is a minor release and contains a bugfix, a feature and adjustments to internal processes:\n\n- State configuration dictionaries passed to `HierarchicalMachine` can also use `states` as a keyword to define substates. If `children` and `states` are present, only `children` will be considered.\n- Feature #500: `HierarchicalMachine` with custom separator now adds `is_state` partials for nested states (e.g. `is_C.s3.a()`) to models (thanks @alterscape)\n- Bugfix #512: Use `model_attribute` consistently in `AsyncMachine` (thanks @thedrow)\n- Testing now treats most warnings as errors (thanks @thedrow)\n- As a consequence, `pygraphviz.Agraph` in `diagrams_pygraphviz` are now copied by `transitions` since `AGraph.copy` as of version `1.6` does not close temporary files appropriately\n- `HierarchicalMachine` now checks whether `state_cls`, `event_cls` and `transition_cls` have been subclassed from nested base classes (e.g. `NestedState`) to prevent hard to debug inheritance errors\n\n## 0.8.6 (December 2020)\n\nRelease 0.8.6 is a minor release and contains bugfixes and new features:\n\n- `HierarchicalMachine.add_states` will raise a `ValueError` when an `Enum` name contains the currently used `NestedState.separator`.\n- Bugfix #486: Reset `NestedState._scope` when enter/exit callbacks raise an exception (thanks @m986883511)\n- Bugfix #488: Let `HierarchicalMachine._get_trigger` which is bound to `model.trigger` raise a `MachineError` for invalid events and `AttributeError` for unknown events (thanks @hsharrison)\n- Introduced `HierarchicalMachine.has_trigger` to determine whether an event is valid for an HSM\n- Feature #490: `AsyncMachine` features an event queue dictionary for individual models when `queued='model'` (thanks @jekel)\n- Feature #490: `Machine.remove_model` will now also remove model events from the event queue when `queued=True`\n- Feature #491: `Machine.get_transitions` and its HSM counterpart now accept `Enum` and `State` for `source` and `dest` (thanks @thedrow)\n\n## 0.8.5 (November 2020)\n\nRelease 0.8.5 is a minor release and contains bugfixes:\n\n- `AsyncMachine.switch_model_context` is expected to be `async` now for easier integration of async code during model switch.\n- Bugfix #478: Initializing a machine with `GraphSupport` threw an exception when initial was set to a nested or parallel state (thanks @nickvazztau)\n\n## 0.8.4 (October 2020)\n\nRelease 0.8.4 is a minor release and contains bugfixes as well as new features:\n\n- Bugfix #477: Model callbacks were not added to a LockedHierarchicalMachine when the machine itself served as a model (thanks @oliver-goetz)\n- Bugfix #475: Clear collection of tasks to prevent memory leak when initializing many models (thanks @h-nakai)\n- Feature #474: Added static `AsyncMachine.protected_tasks` list which can be used to prevent `transitions` to cancel certain tasks.\n- Feature: Constructor of `HierarchicalMachine` now accepts substates ('A_1_c') and parallel states (['A', 'B']) as `initial` parameter\n\n## 0.8.3 (September 2020)\n\nRelease 0.8.3 is a minor release and contains several bugfixes mostly related to `HierarchicalStateMachine`:\n\n- Feature #473: Assign `is_<model_attribute>_<state_name>` instead of `is_<state_name>` when `model_attribute != \"state\"` to enable multiple versions of such convenience functions. A warning will be raised when `is_<state_name>` is used. (thanks @artofhuman)\n- Similarly, auto transitions (`to_<state_name>`) will be assigned as `to_<model_attribute>_<state_name>`. `to_<state_name>` will work as before but raise a warning until version 0.9.0.\n- Bugfix: `allow_substates` did not consider enum states\n- Feature: Nested enums can now be passed in a dict as `children` with `initial` parameter\n- Bugfix #449: get_triggers/get_transitions did not return nested triggers correctly (thanks @alexandretanem)\n- Feature #452: Improve handling of label attributes in custom diagram states and `TransitionGraphSupport` (thanks @badiku)\n- Bugfix #456: Prevent parents from overriding (falsy) results of their children's events (thanks @alexandretanem)\n- Bugfix #458: Entering the same state caused key errors when transition was defined on a parent (thanks @matlom)\n- Bugfix #459: Do not remove current timeout runner in AsyncTimeout to prevent accidental overrides (thanks @rgov)\n- Rewording of `State.enter/exit` debug message emitted when callbacks have been processed.\n- Bugfix #370: Fix order of `before_state_change/before` and `after/after_state_change` in `AsyncMachine` (thanks @tzoiker and @vishes-shell)\n- Bugfix #470: `Graph.get_graph()` did not consider `enum` states when `show_roi=True` (thanks @termim)\n\n## 0.8.2 (June 2020)\n\nRelease 0.8.2 is a minor release and contains several bugfixes and improvements:\n\n- Bugfix #438: Improved testing without any optional `graphviz` package\n- Bugfix: `_check_event_result` failed when model was in parallel state\n- Bugfix #440: Only allow explicit `dest=None` in `Machine.add_transition` (not just falsy) for internal transitions (thanks @Pathfinder216)\n- Bugfix #419: Fix state creation of nested enums (thanks @thedrow)\n- Bugfix #428: HierarchicalGraphMachine did not find/apply styling for parallel states (thanks @xiaohuihui1024)\n- Bugfix: `Model.trigger` now considers the machine's and current state's `ignore_invalid_triggers` attribute and can be called with non-existing events (thanks @potens1)\n- Bugfix: Child states may not have been exited when the executed transition had been defined on a parent (thanks @thedrow)\n- Feature #429: Introduced `transitions.extensions.asyncio.AsyncTimeout` as a state decorator to avoid threads used in `transitions.extensions.state.Timeout` (thanks @potens1)\n- Feature #444: `transitions` can now be tested online at mybinder.org\n- PR #418: Use sets instead of lists to cache already covered transitions in nested state machines (thanks @thedrow)\n- PR #422: Improve handling of unresolved attributes for easier inheritance (thanks @thedrow)\n- PR #445: Refactored AsyncMachine to enable trio/anyio override\n\n## 0.8.1 (April 2020)\n\nRelease 0.8.1 is a minor release of HSM improvements and bugfixes in the diagram and async extension:\n\n- Feature: Introduced experimental `HierarchicalAsync(Graph)Machine`\n- Feature #405: Support for nested Enums in `HierarchicalMachine` (thanks @thedrow)\n- Bugfix #400: Fix style initialization when initial state is an `Enum` (thanks @kbinpgh)\n- Bugfix #403: AsyncMachine.dispatch now returns a boolean as expected (thanks @thedrow)\n- Bugfix #413: Improve diagram output for `HierarchicalMachine` (thanks @xiaohuihui1024)\n- Increased coverage (thanks @thedrow)\n- Introduced `xdist` for parallel testing with `pytest` (thanks @thedrow)\n\n## 0.8.0 (March 2020)\n\nRelease 0.8.0 is a major release and introduces asyncio support for Python 3.7+, parallel state support and some bugfixes:\n\n- Feature: `HierarchicalMachine` has been rewritten to support parallel states. Please have a look at the ReadMe.md to check what has changed.\n  - The previous version can be found in `transitions.extensions.nesting_legacy` for now\n- Feature: Introduced `AsyncMachine` (see discussion #259); note that async HSMs are not yet supported\n- Feature #390: String callbacks can now point to properties and attributes (thanks @jsenecal)\n- Bugfix: Auto transitions are added multiple times when add_states is called more than once\n- Bugfix: Convert state.\\_name from `Enum` into strings in `MarkupMachine` when necessary\n- Bugfix #392: Allow `Machine.add_ordered_transitions` to be called without the initial state (thanks @mkaranki and @facundofc)\n- `GraphMachine` now attempts to fall back to `graphviz` when importing `pygraphviz` fails\n- Not implemented/tested so far (contributions are welcome!):\n  - Proper Graphviz support of parallel states\n  - AsyncHierachicalMachine\n\n## 0.7.2 (January 2020)\n\nRelease 0.7.2 is a minor release and contains bugfixes and a new feature:\n\n- Bugfix #386: Fix transitions for enums with str behavior (thanks @artofhuman)\n- Bugfix #378: Don't mask away KeyError when executing a transition (thanks @facundofc)\n- Feature #387: Add support for dynamic model state attribute (thanks @v1k45)\n\n## 0.7.1 (September 2019)\n\nRelease 0.7.1 is a minor release and contains several documentation improvements and a new feature:\n\n- Feature #334: Added Enum (Python 3.4+: `enum` Python 2.7: `enum34`) support (thanks @artofhuman and @justinttl)\n- Replaced test framework `nosetests` with `pytest` (thanks @artofhuman)\n- Extended `add_ordered_transitions` documentation in `Readme.md`\n- Collected code snippets from earlier discussions in `examples/Frequently asked questions.ipynb`\n- Improved stripping of `long_description` in `setup.py` (thanks @artofhuman)\n\n## 0.7.0 (August 2019)\n\nRelease 0.7.0 is a major release with fundamental changes to the diagram extension. It also introduces an intermediate `MarkupMachine` which can be used to transfer and (re-)initialize machine configurations.\n\n- Feature #263: `MarkupMachine` can be used to retrieve a Machine's dictionary representation\n  - `GraphMachine` uses this representation for Graphs now and does not rely on `Machine` attributes any longer\n- Feature: The default value of `State.ignore_invalid_triggers` changed to `None`. If it is not explicitly set, the `Machine`'s value is used instead.\n- Feature #325: transitions now supports `pygraphviz` and `graphviz` for the creation of diagrams. Currently, `GraphMachine` will check for `pygraphviz` first and fall back to `graphviz`. To use `graphviz` directly pass `use_pygraphiv=False` to the constructor of `GraphMachine`\n- Diagram style has been overhauled. Have a look at `GraphMachine`'s attributes `machine_attributes` and `style_attributes` to adjust it to your needs.\n- Feature #305: Timeouts and other features are now marked in the graphs\n- Bugfix #343: `get_graph` was not assigned to models added during machine runtime\n\n## 0.6.9 (October 2018)\n\nRelease 0.6.9 is a minor release and contains two bugfixes:\n\n- Bugfix #314: Do not override already defined model functions with convenience functions (thanks @Arkanayan)\n- Bugfix #316: `state.Error` did not call parent's `enter` method (thanks @potens1)\n\n## 0.6.8 (May, 2018)\n\nRelease 0.6.8 is a minor release and contains a critical bugfix:\n\n- Bugfix #301: Reading `Readme.md` in `setup.py` causes a `UnicodeDecodeError` in non-UTF8-locale environments (thanks @jodal)\n\n## 0.6.7 (May, 2018)\n\nRelease 0.6.7 is identical to 0.6.6. A release had been necessary due to #294 related to PyPI.\n\n## 0.6.6 (May, 2018)\n\nRelease 0.6.6 is a minor release and contains several bugfixes and new features:\n\n- Bugfix: `HierarchicalMachine` now considers the initial state of `NestedState` instances/names passed to `initial`.\n- Bugfix: `HierarchicalMachine` used to ignore children when `NestedStates` were added to the machine.\n- Bugfix #300: Fixed missing brackets in `TimeoutState` (thanks @Synss)\n- Feature #289: Introduced `Machine.resolve_callable(func, event_data)` to enable customization of callback definitions (thanks @ollamh and @paulbovbel)\n- Feature #299: Added support for internal transitions with `dest=None` (thanks @maueki)\n- Feature: Added `Machine.dispatch` to trigger events on all models assigned to `Machine`\n\n## 0.6.5 (April, 2018)\n\nRelease 0.6.5 is a minor release and contains a new feature and a bugfix:\n\n- Feature #287: Embedding `HierarchicalMachine` will now reuse the machine's `initial` state. Passing `initial: False` overrides this (thanks @mrjogo).\n- Bugfix #292: Models using `GraphMashine` were not picklable in the past due to `graph` property. Graphs for each model are now stored in `GraphMachine.model_graphs` (thanks @ansumanm).\n\n## 0.6.4 (January, 2018)\n\nRelease 0.6.4 is a minor release and contains a new feature and two bug fixes related to `HierachicalMachine`:\n\n- Bugfix #274: `initial` has not been passed to super in `HierachicalMachine.add_model` (thanks to @illes).\n- Feature #275: `HierarchicalMachine.add_states` now supports keyword `parent` to be a `NestedState` or a string.\n- Bugfix #278: `NestedState` has not been exited correctly during reflexive triggering (thanks to @hrsmanian).\n\n## 0.6.3 (November, 2017)\n\nRelease 0.6.3 is a minor release and contains a new feature and two bug fixes:\n\n- Bugfix #268: `Machine.add_ordered_transitions` changed states' order if `initial` is not the first or last state (thanks to @janekbaraniewski).\n- Bugfix #265: Renamed `HierarchicalMachine.to` to `to_state` to prevent warnings when HSM is used as a model.\n- Feature #266: Introduce `Machine.get_transitions` to get a list of transitions for alteration (thanks to @Synss).\n\n## 0.6.2 (November, 2017)\n\nRelease 0.6.2 is a minor release and contains new features and bug fixes but also several internal changes:\n\n- Documentation: Add docstring to every public method\n- Bugfix #257: Readme example variable had been capitalized (thanks to @fedesismo)\n- Add `appveyor.yml` for Windows testing; However, Windows testing is disabled due to #258\n- Bugfix #262: Timeout threads prevented program from execution when main thread ended (thanks to @tkuester)\n- `prep_ordered_arg` is now protected in `core`\n- Convert `logger` instances to `_LOGGER` to comply with protected module constant naming standards\n- `traverse` is now protected in `HierarchicalMachine`\n- Remove abstract class `Diagram` since it did not add functionality to `diagrams`\n- Specify several overrides of `add_state` or `add_transition` to keep the base class parameters instead of `*args` and `**kwargs`\n- Change several `if len(x) > 0:` checks to `if x:` as suggested by the static code analysis to make use of falsy empty lists/strings.\n\n## 0.6.1 (September, 2017)\n\nRelease 0.6.1 is a minor release and contains new features as well as bug fixes:\n\n- Feature #245: Callback definitions ('before', 'on_enter', ...) have been moved to classes `Transition` and `State`\n- Bugfix #253: `Machine.remove_transitions` converted `defaultdict` into dict (thanks @Synss)\n- Bugfix #248: `HierarchicalStateMachine`'s copy procedure used to cause issues with function callbacks and object references (thanks @Grey-Bit)\n- Renamed `Machine.id` to `Machine.name` to be consistent with the constructor parameter `name`\n- Add `Machine.add_transitions` for adding multiple transitions at once (thanks @Synss)\n\n## 0.6.0 (August, 2017)\n\nRelease 0.6.0 is a major release and introduces new state features and bug fixes:\n\n- `add_state_features` convenience decorator supports creation of custom states\n- `Tags` makes states taggable\n- `Error` checks for error states (not accepted states that cannot be left); subclass of `Tags`\n- `Volatile` enables scoped/temporary state objects to handle context parameters\n- Removed `add_self` from `Machine` constructor\n- `pygraphviz` is now optional; use `pip install transitions[diagrams]` to install it\n- Narrowed warnings filter to prevent output cluttering by other 3rd party modules (thanks to @ksandeep)\n- Reword HSM exception when wrong state object had been passedn (thanks to @Blindfreddy)\n- Improved handling of partials during graph generation (thanks to @Synss)\n- Introduced check to allow explicit passing of callback functions which match the `on_enter_<state>` scheme (thanks to @termim)\n- Bug #243: on_enter/exit callbacks defined in dictionaries had not been assigned correctly in HSMs (thanks to @Blindfreddy)\n- Introduced workaround for Python 3 versions older than 3.4 to support dill version 0.2.7 and higher (thanks to @mmckerns)\n- Improved manifest (#242) to comply with distribution standards (thanks to @jodal)\n\n## 0.5.3 (May, 2017)\n\nRelease 0.5.3 is a minor release and contains several bug fixes:\n\n- Bug #214: `LockedMachine` as a model prevented correct addition of `on_enter/exit_<state>` (thanks to @kr2)\n- Bug #217: Filtering rules for auto transitions in graphs falsely filtered certain transitions (thanks to @KarolOlko)\n- Bug #218: Uninitialized `EventData.transition` caused `AttributeError` in `EventData.__repr__` (thanks to @kunalbhagawati)\n- Bug #215: State instances passed to `initial` parameter of `Machine` constructor had not been processed properly (thanks @mathiasimmer)\n\n## 0.5.2 (April, 2017)\n\nRelease 0.5.2 is a minor release and contains a bug fix:\n\n- Bug #213: prevent `LICENSE` to be installed to root of installation path\n\n## 0.5.1 (April, 2017)\n\nRelease 0.5.1 is a minor release and contains new features and bug fixes:\n\n- Added reflexive transitions (thanks to @janLo)\n- Wildcards for reflexive (`wildcard_same`) and all (`wildcard_all`) destinations are `Machine` class variables now which can be altered if necessary.\n- Add LICENSE to packaged distribution (thanks to @bachp)\n- Bug #211: `prepare` and `finalized` had not been called for HierarchicalMachines (thanks to @booware)\n\n## 0.5.0 (March, 2017)\n\nRelease 0.5.0 is a major release:\n\n- CHANGED API: `MachineError` is now limited to internal error and has been replaced by `AttributeError` and `ValueError` where applicable (thanks to @ankostis)\n- CHANGED API: Phasing out `add_self`; `model=None` will add NO model starting from next major release; use `model='self'` instead.\n- Introduced deprecation warnings for upcoming changes concerning `Machine` keywords `model` and `add_self`\n- Introduced `Machine.remove_transition` (thanks to @PaleNeutron)\n- Introduced `Machine._create_state` for easier subclassing of states\n- `LockedMachine` now supports custom context managers for each model (thanks to @paulbovbel)\n- `Machine.before/after_state_change` can now be altered dynamically (thanks to @peendebak)\n- `Machine.add_ordered_transitions` now supports `prepare`, `conditons`, `unless`, `before` and `after` (thanks to @aforren1)\n- New `prepare_event` and `finalize_event` keywords to handle transitions globally (thanks to @ankostis)\n- New `show_auto_transitions` keyword for `GraphMachine.__init__` (default `False`); if enabled, show auto transitions in graph\n- New `show_roi` keyword for `GraphMachine._get_graph` (default `False`); if `True`, show only reachable states in retrieved graph\n- Test suite now skips contextual tests (e.g. pygraphviz) if dependencies cannot be found (thanks to @ankostis)\n- Improved string representation of several classes (thanks to @ankostis)\n- Improved `LockedMachine` performance by removing recursive locking\n- Improved graph layout for nested graphs\n- `transitions.extensions.nesting.AGraph` has been split up into `Graph` and `NestedGraph` for easier maintenance\n- Fixed bug related to pickling `RLock` in nesting\n- Fixed order of callback execution (thanks to @ankostis)\n- Fixed representation of condition names in graphs (thanks to @cemoody)\n\n## 0.4.3 (December, 2016)\n\nRelease 0.4.3 is a minor release and contains bug fixes and several new features:\n\n- Support dynamic model addition via `Machine.add_model` (thanks to @paulbovbel)\n- Allow user to explicitly pass a lock instance or context manager to LockedMachine (thanks to @paulbovbel)\n- Fixed issue related to parsing of HSMs (thanks to @steval and @user2154065 from SO)\n- When `State` is passed to `Machine.add_transition`, it will check if the state (and not just the name) is known to the machine\n\n## 0.4.2 (October, 2016)\n\nRelease 0.4.2 contains several new features and bugfixes:\n\n- Machines can work with multiple models now (thanks to @gemerden)\n- New `initial` keyword for nested states to automatically enter a child\n- New `Machine.trigger` method to trigger events by name (thanks to @IwanLD)\n- Bug fixes related to remapping in nested (thanks to @imbaczek)\n- Log messages in `Transition.execute` and `Machine.__init__` have been reassigned to DEBUG log level (thanks to @ankostis)\n- New `Machine.get_triggers` method to return all valid transitions from (a) certain state(s) (thanks to @limdauto and @guilhermecgs)\n\n## 0.4.1 (July, 2016)\n\nRelease 0.4.1 is a minor release containing bug fixes, minor API changes, and community feedback:\n\n- `async` is renamed to `queued` since it describes the mechanism better\n- HierarchicalStateMachine.is_state now provides `allow_substates` as an optional argument(thanks to @jonathanunderwood)\n- Machine can now be used in scenarios where multiple inheritance is required (thanks to @jonathanunderwood)\n- Adds support for tox (thanks to @medecau and @aisbaa)\n- Bug fixes:\n\n  - Problems with conditions shown multiple times in graphs\n  - Bug which omitted transitions with same source and destination in diagrams (thanks to @aisbaa)\n  - Conditions passed incorrectly when HSMs are used as a nested state\n  - Class nesting issue that prevented pickling with dill\n  - Two bugs in HierarchicalStateMachine (thanks to @ajax2leet)\n  - Avoided recursion error when naming a transition 'process' (thanks to @dceresuela)\n\n- Minor PEP8 fixes (thanks to @medecau)\n\n## 0.4.0 (April, 2016)\n\nRelease 0.4 is a major release that includes several new features:\n\n- New `async` Machine keyword allows queueing of transitions (thanks to @khigia)\n- New `name` Machine keyword customizes transitions logger output for easier debugging of multiple running instances\n- New `prepare` Transition keyword for callbacks before any 'conditions' are checked (thanks to @TheMysteriousX)\n- New `show_conditions` GraphSupport keyword adds condition checks to dot graph edges (thanks to @khigia)\n- Nesting now supports custom (unicode) substate separators\n- Nesting no longer requires a leaf state (e.g. to_C() does not enter C_1 automatically)\n- Factory for convenient extension mixins\n- Numerous minor improvements and bug fixes\n\n## 0.3.1 (January 3, 2016)\n\nMostly a bug fix release. Changes include:\n\n- Fixes graphing bug introduced in 0.3.0 (thanks to @wtgee)\n- Fixes bug in dynamic addition of before/after callbacks (though this is a currently undocumented feature)\n- Adds coveralls support and badge\n- Adds a few tests to achieve near-100% coverage\n\n## 0.3.0 (January 2, 2016)\n\nRelease 0.3 includes a number of new features (nesting, multithreading, and graphing) as well as bug fixes and minor improvements:\n\n- Support for nested states (thanks to @aleneum)\n- Basic multithreading support for function access (thanks to @aleneum)\n- Basic graphing support via graphviz (thanks to @svdgraaf)\n- Stylistic edits, minor fixes, and improvements to README\n- Expanded and refactored tests\n- Minor bug fixes\n\n## 0.2.9 (November 10, 2015)\n\n- Enabled pickling in Python 3.4 (and in < 3.4 with the dill module)\n- Added reference to generating Transition in EventData objects\n- Fixed minor bugs\n\n## 0.2.8 (August, 6, 2015)\n\n- README improvements, added TOC, and typo fixes\n- Condition checks now receive optional data\n- Removed invasive basicConfig() call introduced with logging in 0.2.6\n\n## 0.2.7 (July 27, 2015)\n\n- Fixed import bug that prevented dependency installation at setup\n\n## 0.2.6 (July 26, 2015)\n\n- Added rudimentary logging for key transition and state change events\n- Added generic before/after callbacks that apply to all state changes\n- Ensured string type compatibility across Python 2 and 3\n\n## 0.2.5 (May 4, 2015)\n\n- Added ability to suppress invalid trigger calls\n- Shorthand definition of transitions via lists\n\n## 0.2.4 (March 11, 2015)\n\n- Automatic detection of predefined state callbacks\n- Fixed bug in automatic transition creation\n- Added Changelog\n\n## 0.2.3 (January 14, 2015)\n\n- Added travis-ci support\n- Cleaned up and PEP8fied code\n- Added 'unless' argument to transitions that mirrors 'conditions'\n\n## 0.2.2 (December 28, 2014)\n\n- Python 2/3 compatibility\n- Added automatic to\\_{state}() methods\n- Added ability to easily add ordered transitions\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.072265625,
          "content": "The MIT License\n\nCopyright (c) 2014 - 2020 Tal Yarkoni, Alexander Neumann\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.3388671875,
          "content": "include *.md\ninclude *.txt\ninclude .coveragerc\ninclude .pylintrc\ninclude LICENSE\ninclude MANIFEST\ninclude *.ini\ninclude conftest.py\ninclude noxfile.py\n\nrecursive-include transitions *.pyi\nrecursive-include examples *.ipynb\nrecursive-include tests *.py\nrecursive-exclude examples/.ipynb_checkpoints *.ipynb\nrecursive-include binder *.txt postBuild\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 96.55078125,
          "content": "# <a name=\"transitions-module\"></a> transitions\n\n[![Version](https://img.shields.io/badge/version-v0.9.3-orange.svg)](https://github.com/pytransitions/transitions)\n[![Build Status](https://github.com/pytransitions/transitions/actions/workflows/pytest.yml/badge.svg)](https://github.com/pytransitions/transitions/actions?query=workflow%3Apytest)\n[![Coverage Status](https://coveralls.io/repos/github/pytransitions/transitions/badge.svg?branch=master)](https://coveralls.io/github/pytransitions/transitions?branch=master)\n[![PyPi](https://img.shields.io/pypi/v/transitions.svg)](https://pypi.org/project/transitions)\n[![Copr](https://img.shields.io/badge/dynamic/json?color=blue&label=copr&query=builds.latest.source_package.version&url=https%3A%2F%2Fcopr.fedorainfracloud.org%2Fapi_3%2Fpackage%3Fownername%3Daleneum%26projectname%3Dpython-transitions%26packagename%3Dpython-transitions%26with_latest_build%3DTrue)](https://copr.fedorainfracloud.org/coprs/aleneum/python-transitions/)\n[![GitHub commits](https://img.shields.io/github/commits-since/pytransitions/transitions/0.9.2.svg)](https://github.com/pytransitions/transitions/compare/0.9.2...master)\n[![License](https://img.shields.io/github/license/pytransitions/transitions.svg)](LICENSE)\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/pytransitions/transitions/master?filepath=examples%2FPlayground.ipynb)\n\n<!-- [![Pylint](https://img.shields.io/badge/pylint-9.71%2F10-green.svg)](https://github.com/pytransitions/transitions) -->\n<!--[![Name](Image)](Link)-->\n\nA lightweight, object-oriented state machine implementation in Python with many extensions. Compatible with Python 2.7+ and 3.0+.\n\n## Installation\n\n    pip install transitions\n\n... or clone the repo from GitHub and then:\n\n    python setup.py install\n\n## Table of Contents\n\n- [Quickstart](#quickstart)\n- [Non-Quickstart](#the-non-quickstart)\n  - [Some key concepts](#some-key-concepts)\n  - [Basic initialization](#basic-initialization)\n  - [States](#states)\n    - [Callbacks](#state-callbacks)\n    - [Checking state](#checking-state)\n    - [Enumerations](#enum-state)\n  - [Transitions](#transitions)\n    - [Triggering a transition](#triggers)\n    - [Automatic transitions](#automatic-transitions-for-all-states)\n    - [Transitioning from multiple states](#transitioning-from-multiple-states)\n    - [Reflexive transitions from multiple states](#reflexive-from-multiple-states)\n    - [Internal transitions](#internal-transitions)\n    - [Ordered transitions](#ordered-transitions)\n    - [Queued transitions](#queued-transitions)\n    - [Conditional transitions](#conditional-transitions)\n    - [Check transitions](#check-transitions)\n    - [Callbacks](#transition-callbacks)\n  - [Callable resolution](#resolution)\n  - [Callback execution order](#execution-order)\n  - [Passing data](#passing-data)\n  - [Alternative initialization patterns](#alternative-initialization-patterns)\n  - [Logging](#logging)\n  - [(Re-)Storing machine instances](#restoring)\n  - [Typing support](#typing-support)\n  - [Extensions](#extensions)\n    - [Hierarchical State Machine](#hsm)\n    - [Diagrams](#diagrams)\n    - [Threading](#threading)\n    - [Async](#async)\n    - [State features](#state-features)\n    - [Django](#django-support)\n  - [Bug reports etc.](#bug-reports)\n\n## Quickstart\n\nThey say [a good example is worth](https://www.google.com/webhp?ie=UTF-8#q=%22a+good+example+is+worth%22&start=20) 100 pages of API documentation, a million directives, or a thousand words.\n\nWell, \"they\" probably lie... but here's an example anyway:\n\n```python\nfrom transitions import Machine\nimport random\n\nclass NarcolepticSuperhero(object):\n\n    # Define some states. Most of the time, narcoleptic superheroes are just like\n    # everyone else. Except for...\n    states = ['asleep', 'hanging out', 'hungry', 'sweaty', 'saving the world']\n\n    def __init__(self, name):\n\n        # No anonymous superheroes on my watch! Every narcoleptic superhero gets\n        # a name. Any name at all. SleepyMan. SlumberGirl. You get the idea.\n        self.name = name\n\n        # What have we accomplished today?\n        self.kittens_rescued = 0\n\n        # Initialize the state machine\n        self.machine = Machine(model=self, states=NarcolepticSuperhero.states, initial='asleep')\n\n        # Add some transitions. We could also define these using a static list of\n        # dictionaries, as we did with states above, and then pass the list to\n        # the Machine initializer as the transitions= argument.\n\n        # At some point, every superhero must rise and shine.\n        self.machine.add_transition(trigger='wake_up', source='asleep', dest='hanging out')\n\n        # Superheroes need to keep in shape.\n        self.machine.add_transition('work_out', 'hanging out', 'hungry')\n\n        # Those calories won't replenish themselves!\n        self.machine.add_transition('eat', 'hungry', 'hanging out')\n\n        # Superheroes are always on call. ALWAYS. But they're not always\n        # dressed in work-appropriate clothing.\n        self.machine.add_transition('distress_call', '*', 'saving the world',\n                         before='change_into_super_secret_costume')\n\n        # When they get off work, they're all sweaty and disgusting. But before\n        # they do anything else, they have to meticulously log their latest\n        # escapades. Because the legal department says so.\n        self.machine.add_transition('complete_mission', 'saving the world', 'sweaty',\n                         after='update_journal')\n\n        # Sweat is a disorder that can be remedied with water.\n        # Unless you've had a particularly long day, in which case... bed time!\n        self.machine.add_transition('clean_up', 'sweaty', 'asleep', conditions=['is_exhausted'])\n        self.machine.add_transition('clean_up', 'sweaty', 'hanging out')\n\n        # Our NarcolepticSuperhero can fall asleep at pretty much any time.\n        self.machine.add_transition('nap', '*', 'asleep')\n\n    def update_journal(self):\n        \"\"\" Dear Diary, today I saved Mr. Whiskers. Again. \"\"\"\n        self.kittens_rescued += 1\n\n    @property\n    def is_exhausted(self):\n        \"\"\" Basically a coin toss. \"\"\"\n        return random.random() < 0.5\n\n    def change_into_super_secret_costume(self):\n        print(\"Beauty, eh?\")\n```\n\nThere, now you've baked a state machine into `NarcolepticSuperhero`. Let's take him/her/it out for a spin...\n\n```python\n>>> batman = NarcolepticSuperhero(\"Batman\")\n>>> batman.state\n'asleep'\n\n>>> batman.wake_up()\n>>> batman.state\n'hanging out'\n\n>>> batman.nap()\n>>> batman.state\n'asleep'\n\n>>> batman.clean_up()\nMachineError: \"Can't trigger event clean_up from state asleep!\"\n\n>>> batman.wake_up()\n>>> batman.work_out()\n>>> batman.state\n'hungry'\n\n# Batman still hasn't done anything useful...\n>>> batman.kittens_rescued\n0\n\n# We now take you live to the scene of a horrific kitten entreement...\n>>> batman.distress_call()\n'Beauty, eh?'\n>>> batman.state\n'saving the world'\n\n# Back to the crib.\n>>> batman.complete_mission()\n>>> batman.state\n'sweaty'\n\n>>> batman.clean_up()\n>>> batman.state\n'asleep'   # Too tired to shower!\n\n# Another productive day, Alfred.\n>>> batman.kittens_rescued\n1\n```\n\nWhile we cannot read the mind of the actual batman, we surely can visualize the current state of our `NarcolepticSuperhero`.\n\n![batman diagram](https://user-images.githubusercontent.com/205986/104932302-c2f24580-59a7-11eb-8963-5dce738b9305.png)\n\nHave a look at the [Diagrams](#diagrams) extensions if you want to know how.\n\n## The non-quickstart\n\nA state machine is a _model_ of behavior composed of a finite number of _states_ and _transitions_ between those states. Within each state and transition some _action_ can be performed. A state machine needs to start at some _initial state_. When using `transitions`, a state machine may consist of multiple objects where some (_machines_) contain definitions for the manipulation of other (_models_). Below, we will look at some core concepts and how to work with them.\n\n### Some key concepts\n\n- **State**. A state represents a particular condition or stage in the state machine. It's a distinct mode of behavior or phase in a process.\n\n- **Transition**. This is the process or event that causes the state machine to change from one state to another.\n\n- **Model**. The actual stateful structure. It's the entity that gets updated during transitions. It may also define _actions_ that will be executed during transitions. For instance, right before a transition or when a state is entered or exited.\n\n- **Machine**. This is the entity that manages and controls the model, states, transitions, and actions. It's the conductor that orchestrates the entire process of the state machine.\n\n- **Trigger**. This is the event that initiates a transition, the method that sends the signal to start a transition.\n\n- **Action**. Specific operation or task that is performed when a certain state is entered, exited, or during a transition. The action is implemented through _callbacks_, which are functions that get executed when some event happens.\n\n### Basic initialization\n\nGetting a state machine up and running is pretty simple. Let's say you have the object `lump` (an instance of class `Matter`), and you want to manage its states:\n\n```python\nclass Matter(object):\n    pass\n\nlump = Matter()\n```\n\nYou can initialize a (_minimal_) working state machine bound to the model `lump` like this:\n\n```python\nfrom transitions import Machine\nmachine = Machine(model=lump, states=['solid', 'liquid', 'gas', 'plasma'], initial='solid')\n\n# Lump now has a new state attribute!\nlump.state\n>>> 'solid'\n```\n\nAn alternative is to not explicitly pass a model to the `Machine` initializer:\n\n```python\n\nmachine = Machine(states=['solid', 'liquid', 'gas', 'plasma'], initial='solid')\n\n# The machine instance itself now acts as a model\nmachine.state\n>>> 'solid'\n```\n\nNote that this time I did not pass the `lump` model as an argument. The first argument passed to `Machine` acts as a model. So when I pass something there, all the convenience functions will be added to the object. If no model is provided then the `machine` instance itself acts as a model.\n\nWhen at the beginning I said \"minimal\", it was because while this state machine is technically operational, it doesn't actually _do_ anything. It starts in the `'solid'` state, but won't ever move into another state, because no transitions are defined... yet!\n\nLet's try again.\n\n```python\n# The states\nstates=['solid', 'liquid', 'gas', 'plasma']\n\n# And some transitions between states. We're lazy, so we'll leave out\n# the inverse phase transitions (freezing, condensation, etc.).\ntransitions = [\n    { 'trigger': 'melt', 'source': 'solid', 'dest': 'liquid' },\n    { 'trigger': 'evaporate', 'source': 'liquid', 'dest': 'gas' },\n    { 'trigger': 'sublimate', 'source': 'solid', 'dest': 'gas' },\n    { 'trigger': 'ionize', 'source': 'gas', 'dest': 'plasma' }\n]\n\n# Initialize\nmachine = Machine(lump, states=states, transitions=transitions, initial='liquid')\n\n# Now lump maintains state...\nlump.state\n>>> 'liquid'\n\n# And that state can change...\n# Either calling the shiny new trigger methods\nlump.evaporate()\nlump.state\n>>> 'gas'\n\n# Or by calling the trigger method directly\nlump.trigger('ionize')\nlump.state\n>>> 'plasma'\n```\n\nNotice the shiny new methods attached to the `Matter` instance (`evaporate()`, `ionize()`, etc.).\nEach method triggers the corresponding transition.\nTransitions can also be triggered _dynamically_ by calling the `trigger()` method provided with the name of the transition, as shown above.\nMore on this in the [Triggering a transition](#triggers) section.\n\n\n### <a name=\"states\"></a>States\n\nThe soul of any good state machine (and of many bad ones, no doubt) is a set of states. Above, we defined the valid model states by passing a list of strings to the `Machine` initializer. But internally, states are actually represented as `State` objects.\n\nYou can initialize and modify States in a number of ways. Specifically, you can:\n\n- pass a string to the `Machine` initializer giving the name(s) of the state(s), or\n- directly initialize each new `State` object, or\n- pass a dictionary with initialization arguments\n\nThe following snippets illustrate several ways to achieve the same goal:\n\n```python\n# import Machine and State class\nfrom transitions import Machine, State\n\n# Create a list of 3 states to pass to the Machine\n# initializer. We can mix types; in this case, we\n# pass one State, one string, and one dict.\nstates = [\n    State(name='solid'),\n    'liquid',\n    { 'name': 'gas'}\n    ]\nmachine = Machine(lump, states)\n\n# This alternative example illustrates more explicit\n# addition of states and state callbacks, but the net\n# result is identical to the above.\nmachine = Machine(lump)\nsolid = State('solid')\nliquid = State('liquid')\ngas = State('gas')\nmachine.add_states([solid, liquid, gas])\n```\n\nStates are initialized _once_ when added to the machine and will persist until they are removed from it. In other words: if you alter the attributes of a state object, this change will NOT be reset the next time you enter that state. Have a look at how to [extend state features](#state-features) in case you require some other behaviour.\n\n#### <a name=\"state-callbacks\"></a>Callbacks\n\nBut just having states and being able to move around between them (transitions) isn't very useful by itself. What if you want to do something, perform some _action_ when you enter or exit a state? This is where _callbacks_ come in.\n\nA `State` can also be associated with a list of `enter` and `exit` callbacks, which are called whenever the state machine enters or leaves that state. You can specify callbacks during initialization by passing them to a `State` object constructor, in a state property dictionary, or add them later.\n\nFor convenience, whenever a new `State` is added to a `Machine`, the methods `on_enter_state name` and `on_exit_state name` are dynamically created on the Machine (not on the model!), which allow you to dynamically add new enter and exit callbacks later if you need them.\n\n```python\n# Our old Matter class, now with  a couple of new methods we\n# can trigger when entering or exit states.\nclass Matter(object):\n    def say_hello(self): print(\"hello, new state!\")\n    def say_goodbye(self): print(\"goodbye, old state!\")\n\nlump = Matter()\n\n# Same states as above, but now we give StateA an exit callback\nstates = [\n    State(name='solid', on_exit=['say_goodbye']),\n    'liquid',\n    { 'name': 'gas', 'on_exit': ['say_goodbye']}\n    ]\n\nmachine = Machine(lump, states=states)\nmachine.add_transition('sublimate', 'solid', 'gas')\n\n# Callbacks can also be added after initialization using\n# the dynamically added on_enter_ and on_exit_ methods.\n# Note that the initial call to add the callback is made\n# on the Machine and not on the model.\nmachine.on_enter_gas('say_hello')\n\n# Test out the callbacks...\nmachine.set_state('solid')\nlump.sublimate()\n>>> 'goodbye, old state!'\n>>> 'hello, new state!'\n```\n\nNote that `on_enter_state name` callback will _not_ fire when a Machine is first initialized. For example if you have an `on_enter_A()` callback defined, and initialize the `Machine` with `initial='A'`, `on_enter_A()` will not be fired until the next time you enter state `A`. (If you need to make sure `on_enter_A()` fires at initialization, you can simply create a dummy initial state and then explicitly call `to_A()` inside the `__init__` method.)\n\nIn addition to passing in callbacks when initializing a `State`, or adding them dynamically, it's also possible to define callbacks in the model class itself, which may increase code clarity. For example:\n\n```python\nclass Matter(object):\n    def say_hello(self): print(\"hello, new state!\")\n    def say_goodbye(self): print(\"goodbye, old state!\")\n    def on_enter_A(self): print(\"We've just entered state A!\")\n\nlump = Matter()\nmachine = Machine(lump, states=['A', 'B', 'C'])\n```\n\nNow, any time `lump` transitions to state `A`, the `on_enter_A()` method defined in the `Matter` class will fire.\n\nYou can make use of `on_final` callbacks which will be triggered when a state with `final=True` is entered.\n```python\nfrom transitions import Machine, State\n\nstates = [State(name='idling'),\n          State(name='rescuing_kitten'),\n          State(name='offender_gone', final=True),\n          State(name='offender_caught', final=True)]\n\ntransitions = [[\"called\", \"idling\", \"rescuing_kitten\"],  # we will come when  called\n               {\"trigger\": \"intervene\",\n                \"source\": \"rescuing_kitten\",\n                \"dest\": \"offender_gone\",  # we\n                \"conditions\": \"offender_is_faster\"},  # unless they are faster\n               [\"intervene\", \"rescuing_kitten\", \"offender_caught\"]]\n\n\nclass FinalSuperhero(object):\n\n    def __init__(self, speed):\n        self.machine = Machine(self, states=states, transitions=transitions, initial=\"idling\", on_final=\"claim_success\")\n        self.speed = speed\n\n    def offender_is_faster(self, offender_speed):\n        return self.speed < offender_speed\n\n    def claim_success(self, **kwargs):\n        print(\"The kitten is safe.\")\n\n\nhero = FinalSuperhero(speed=10)  # we are not in shape today\nhero.called()\nassert hero.is_rescuing_kitten()\nhero.intervene(offender_speed=15)\n# >>> 'The kitten is safe'\nassert hero.machine.get_state(hero.state).final  # it's over\nassert hero.is_offender_gone()  # maybe next time ...\n```\n\n#### <a name=\"checking-state\"></a>Checking state\n\nYou can always check the current state of the model by either:\n\n- inspecting the `.state` attribute, or\n- calling `is_state name()`\n\nAnd if you want to retrieve the actual `State` object for the current state, you can do that through the `Machine` instance's `get_state()` method.\n\n```python\nlump.state\n>>> 'solid'\nlump.is_gas()\n>>> False\nlump.is_solid()\n>>> True\nmachine.get_state(lump.state).name\n>>> 'solid'\n```\n\nIf you'd like you can choose your own state attribute name by passing the `model_attribute` argument while initializing the `Machine`. This will also change the name of `is_state name()` to `is_model_attribute_state name()` though. Similarly, auto transitions will be named `to_model_attribute_state name()` instead of `to_state name()`. This is done to allow multiple machines to work on the same model with individual state attribute names.\n\n```python\nlump = Matter()\nmachine = Machine(lump, states=['solid', 'liquid', 'gas'],  model_attribute='matter_state', initial='solid')\nlump.matter_state\n>>> 'solid'\n# with a custom 'model_attribute', states can also be checked like this:\nlump.is_matter_state_solid()\n>>> True\nlump.to_matter_state_gas()\n>>> True\n```\n\n#### <a name=\"enum-state\"></a>Enumerations\n\nSo far we have seen how we can give state names and use these names to work with our state machine.\nIf you favour stricter typing and more IDE code completion (or you just can't type 'sesquipedalophobia' any longer because the word scares you) using [Enumerations](https://docs.python.org/3/library/enum.html) might be what you are looking for:\n\n```python\nimport enum  # Python 2.7 users need to have 'enum34' installed\nfrom transitions import Machine\n\nclass States(enum.Enum):\n    ERROR = 0\n    RED = 1\n    YELLOW = 2\n    GREEN = 3\n\ntransitions = [['proceed', States.RED, States.YELLOW],\n               ['proceed', States.YELLOW, States.GREEN],\n               ['error', '*', States.ERROR]]\n\nm = Machine(states=States, transitions=transitions, initial=States.RED)\nassert m.is_RED()\nassert m.state is States.RED\nstate = m.get_state(States.RED)  # get transitions.State object\nprint(state.name)  # >>> RED\nm.proceed()\nm.proceed()\nassert m.is_GREEN()\nm.error()\nassert m.state is States.ERROR\n```\n\nYou can mix enums and strings if you like (e.g. `[States.RED, 'ORANGE', States.YELLOW, States.GREEN]`) but note that internally, `transitions` will still handle states by name (`enum.Enum.name`).\nThus, it is not possible to have the states `'GREEN'` and `States.GREEN` at the same time.\n\n### <a name=\"transitions\"></a>Transitions\n\nSome of the above examples already illustrate the use of transitions in passing, but here we'll explore them in more detail.\n\nAs with states, each transition is represented internally as its own object  an instance of class `Transition`. The quickest way to initialize a set of transitions is to pass a dictionary, or list of dictionaries, to the `Machine` initializer. We already saw this above:\n\n```python\ntransitions = [\n    { 'trigger': 'melt', 'source': 'solid', 'dest': 'liquid' },\n    { 'trigger': 'evaporate', 'source': 'liquid', 'dest': 'gas' },\n    { 'trigger': 'sublimate', 'source': 'solid', 'dest': 'gas' },\n    { 'trigger': 'ionize', 'source': 'gas', 'dest': 'plasma' }\n]\nmachine = Machine(model=Matter(), states=states, transitions=transitions)\n```\n\nDefining transitions in dictionaries has the benefit of clarity, but can be cumbersome. If you're after brevity, you might choose to define transitions using lists. Just make sure that the elements in each list are in the same order as the positional arguments in the `Transition` initialization (i.e., `trigger`, `source`, `destination`, etc.).\n\nThe following list-of-lists is functionally equivalent to the list-of-dictionaries above:\n\n```python\ntransitions = [\n    ['melt', 'solid', 'liquid'],\n    ['evaporate', 'liquid', 'gas'],\n    ['sublimate', 'solid', 'gas'],\n    ['ionize', 'gas', 'plasma']\n]\n```\n\nAlternatively, you can add transitions to a `Machine` after initialization:\n\n```python\nmachine = Machine(model=lump, states=states, initial='solid')\nmachine.add_transition('melt', source='solid', dest='liquid')\n```\n\n#### <a name=\"triggers\"></a>Triggering a transition\n\nFor a transition to be executed, some event needs to _trigger_ it. There are two ways to do this:\n\n1. Using the automatically attached method in the base model:\n    ```python\n    >>> lump.melt()\n    >>> lump.state\n    'liquid'\n    >>> lump.evaporate()\n    >>> lump.state\n    'gas'\n    ```\n    \n    Note how you don't have to explicitly define these methods anywhere; the name of each transition is bound to the model passed to the `Machine` initializer (in this case, `lump`). This also means that your model **should not** already contain methods with the same name as event triggers since `transitions` will only attach convenience methods to your model if the spot is not already taken. If you want to modify that behaviour, have a look at the [FAQ](examples/Frequently%20asked%20questions.ipynb).\n2. Using the `trigger` method, now attached to your model (if it hasn't been there before). This method lets you execute transitions by name in case dynamic triggering is required:\n    ```python\n    >>> lump.trigger('melt')\n    >>> lump.state\n    'liquid'\n    >>> lump.trigger('evaporate')\n    >>> lump.state\n    'gas'\n    ```\n\n#### Triggering invalid transitions\n\nBy default, triggering an invalid transition will raise an exception:\n\n```python\n>>> lump.to_gas()\n>>> # This won't work because only objects in a solid state can melt\n>>> lump.melt()\ntransitions.core.MachineError: \"Can't trigger event melt from state gas!\"\n```\n\nThis behavior is generally desirable, since it helps alert you to problems in your code. But in some cases, you might want to silently ignore invalid triggers. You can do this by setting `ignore_invalid_triggers=True` (either on a state-by-state basis, or globally for all states):\n\n```python\n>>> # Globally suppress invalid trigger exceptions\n>>> m = Machine(lump, states, initial='solid', ignore_invalid_triggers=True)\n>>> # ...or suppress for only one group of states\n>>> states = ['new_state1', 'new_state2']\n>>> m.add_states(states, ignore_invalid_triggers=True)\n>>> # ...or even just for a single state. Here, exceptions will only be suppressed when the current state is A.\n>>> states = [State('A', ignore_invalid_triggers=True), 'B', 'C']\n>>> m = Machine(lump, states)\n>>> # ...this can be inverted as well if just one state should raise an exception\n>>> # since the machine's global value is not applied to a previously initialized state.\n>>> states = ['A', 'B', State('C')] # the default value for 'ignore_invalid_triggers' is False\n>>> m = Machine(lump, states, ignore_invalid_triggers=True)\n```\n\nIf you need to know which transitions are valid from a certain state, you can use `get_triggers`:\n\n```python\nm.get_triggers('solid')\n>>> ['melt', 'sublimate']\nm.get_triggers('liquid')\n>>> ['evaporate']\nm.get_triggers('plasma')\n>>> []\n# you can also query several states at once\nm.get_triggers('solid', 'liquid', 'gas', 'plasma')\n>>> ['melt', 'evaporate', 'sublimate', 'ionize']\n```\n\nIf you have followed this documentation from the beginning, you will notice that `get_triggers` actually returns more triggers than the explicitly defined ones shown above, such as `to_liquid` and so on.\nThese are called `auto-transitions` and will be introduced in the next section.\n\n#### <a name=\"automatic-transitions-for-all-states\"></a>Automatic transitions for all states\n\nIn addition to any transitions added explicitly, a `to_state()` method is created automatically whenever a state is added to a `Machine` instance. This method transitions to the target state no matter which state the machine is currently in:\n\n```python\nlump.to_liquid()\nlump.state\n>>> 'liquid'\nlump.to_solid()\nlump.state\n>>> 'solid'\n```\n\nIf you desire, you can disable this behavior by setting `auto_transitions=False` in the `Machine` initializer.\n\n#### <a name=\"transitioning-from-multiple-states\"></a>Transitioning from multiple states\n\nA given trigger can be attached to multiple transitions, some of which can potentially begin or end in the same state. For example:\n\n```python\nmachine.add_transition('transmogrify', ['solid', 'liquid', 'gas'], 'plasma')\nmachine.add_transition('transmogrify', 'plasma', 'solid')\n# This next transition will never execute\nmachine.add_transition('transmogrify', 'plasma', 'gas')\n```\n\nIn this case, calling `transmogrify()` will set the model's state to `'solid'` if it's currently `'plasma'`, and set it to `'plasma'` otherwise. (Note that only the _first_ matching transition will execute; thus, the transition defined in the last line above won't do anything.)\n\nYou can also make a trigger cause a transition from _all_ states to a particular destination by using the `'*'` wildcard:\n\n```python\nmachine.add_transition('to_liquid', '*', 'liquid')\n```\n\nNote that wildcard transitions will only apply to states that exist at the time of the add_transition() call. Calling a wildcard-based transition when the model is in a state added after the transition was defined will elicit an invalid transition message, and will not transition to the target state.\n\n#### <a name=\"reflexive-from-multiple-states\"></a>Reflexive transitions from multiple states\n\nA reflexive trigger (trigger that has the same state as source and destination) can easily be added specifying `=` as destination.\nThis is handy if the same reflexive trigger should be added to multiple states.\nFor example:\n\n```python\nmachine.add_transition('touch', ['liquid', 'gas', 'plasma'], '=', after='change_shape')\n```\n\nThis will add reflexive transitions for all three states with `touch()` as trigger and with `change_shape` executed after each trigger.\n\n#### <a name=\"internal-transitions\"></a>Internal transitions\n\nIn contrast to reflexive transitions, internal transitions will never actually leave the state.\nThis means that transition-related callbacks such as `before` or `after` will be processed while state-related callbacks `exit` or `enter` will not.\nTo define a transition to be internal, set the destination to `None`.\n\n```python\nmachine.add_transition('internal', ['liquid', 'gas'], None, after='change_shape')\n```\n\n#### <a name=\"ordered-transitions\"></a> Ordered transitions\n\nA common desire is for state transitions to follow a strict linear sequence. For instance, given states `['A', 'B', 'C']`, you might want valid transitions for `A`  `B`, `B`  `C`, and `C`  `A` (but no other pairs).\n\nTo facilitate this behavior, Transitions provides an `add_ordered_transitions()` method in the `Machine` class:\n\n```python\nstates = ['A', 'B', 'C']\n # See the \"alternative initialization\" section for an explanation of the 1st argument to init\nmachine = Machine(states=states, initial='A')\nmachine.add_ordered_transitions()\nmachine.next_state()\nprint(machine.state)\n>>> 'B'\n# We can also define a different order of transitions\nmachine = Machine(states=states, initial='A')\nmachine.add_ordered_transitions(['A', 'C', 'B'])\nmachine.next_state()\nprint(machine.state)\n>>> 'C'\n# Conditions can be passed to 'add_ordered_transitions' as well\n# If one condition is passed, it will be used for all transitions\nmachine = Machine(states=states, initial='A')\nmachine.add_ordered_transitions(conditions='check')\n# If a list is passed, it must contain exactly as many elements as the\n# machine contains states (A->B, ..., X->A)\nmachine = Machine(states=states, initial='A')\nmachine.add_ordered_transitions(conditions=['check_A2B', ..., 'check_X2A'])\n# Conditions are always applied starting from the initial state\nmachine = Machine(states=states, initial='B')\nmachine.add_ordered_transitions(conditions=['check_B2C', ..., 'check_A2B'])\n# With `loop=False`, the transition from the last state to the first state will be omitted (e.g. C->A)\n# When you also pass conditions, you need to pass one condition less (len(states)-1)\nmachine = Machine(states=states, initial='A')\nmachine.add_ordered_transitions(loop=False)\nmachine.next_state()\nmachine.next_state()\nmachine.next_state() # transitions.core.MachineError: \"Can't trigger event next_state from state C!\"\n```\n\n#### <a name=\"queued-transitions\"></a>Queued transitions\n\nThe default behaviour in Transitions is to process events instantly. This means events within an `on_enter` method will be processed _before_ callbacks bound to `after` are called.\n\n```python\ndef go_to_C():\n    global machine\n    machine.to_C()\n\ndef after_advance():\n    print(\"I am in state B now!\")\n\ndef entering_C():\n    print(\"I am in state C now!\")\n\nstates = ['A', 'B', 'C']\nmachine = Machine(states=states, initial='A')\n\n# we want a message when state transition to B has been completed\nmachine.add_transition('advance', 'A', 'B', after=after_advance)\n\n# call transition from state B to state C\nmachine.on_enter_B(go_to_C)\n\n# we also want a message when entering state C\nmachine.on_enter_C(entering_C)\nmachine.advance()\n>>> 'I am in state C now!'\n>>> 'I am in state B now!' # what?\n```\n\nThe execution order of this example is\n\n```\nprepare -> before -> on_enter_B -> on_enter_C -> after.\n```\n\nIf queued processing is enabled, a transition will be finished before the next transition is triggered:\n\n```python\nmachine = Machine(states=states, queued=True, initial='A')\n...\nmachine.advance()\n>>> 'I am in state B now!'\n>>> 'I am in state C now!' # That's better!\n```\n\nThis results in\n\n```\nprepare -> before -> on_enter_B -> queue(to_C) -> after  -> on_enter_C.\n```\n\n**Important note:** when processing events in a queue, the trigger call will _always_ return `True`, since there is no way to determine at queuing time whether a transition involving queued calls will ultimately complete successfully. This is true even when only a single event is processed.\n\n```python\nmachine.add_transition('jump', 'A', 'C', conditions='will_fail')\n...\n# queued=False\nmachine.jump()\n>>> False\n# queued=True\nmachine.jump()\n>>> True\n```\n\nWhen a model is removed from the machine, `transitions` will also remove all related events from the queue.\n\n```python\nclass Model:\n    def on_enter_B(self):\n        self.to_C()  # add event to queue ...\n        self.machine.remove_model(self)  # aaaand it's gone\n```\n\n#### <a name=\"conditional-transitions\"></a>Conditional transitions\n\nSometimes you only want a particular transition to execute if a specific condition occurs. You can do this by passing a method, or list of methods, in the `conditions` argument:\n\n```python\n# Our Matter class, now with a bunch of methods that return booleans.\nclass Matter(object):\n    def is_flammable(self): return False\n    def is_really_hot(self): return True\n\nmachine.add_transition('heat', 'solid', 'gas', conditions='is_flammable')\nmachine.add_transition('heat', 'solid', 'liquid', conditions=['is_really_hot'])\n```\n\nIn the above example, calling `heat()` when the model is in state `'solid'` will transition to state `'gas'` if `is_flammable` returns `True`. Otherwise, it will transition to state `'liquid'` if `is_really_hot` returns `True`.\n\nFor convenience, there's also an `'unless'` argument that behaves exactly like conditions, but inverted:\n\n```python\nmachine.add_transition('heat', 'solid', 'gas', unless=['is_flammable', 'is_really_hot'])\n```\n\nIn this case, the model would transition from solid to gas whenever `heat()` fires, provided that both `is_flammable()` and `is_really_hot()` return `False`.\n\nNote that condition-checking methods will passively receive optional arguments and/or data objects passed to triggering methods. For instance, the following call:\n\n```python\nlump.heat(temp=74)\n# equivalent to lump.trigger('heat', temp=74)\n```\n\n... would pass the `temp=74` optional kwarg to the `is_flammable()` check (possibly wrapped in an `EventData` instance). For more on this, see the [Passing data](#passing-data) section below.\n\n#### <a name=\"check-transitions\"></a>Check transitions\n\nIf you want to make sure a transition is possible before you go ahead with it, you can use the `may_<trigger_name>` functions that have been added to your model.\nYour model also contains the `may_trigger` function to check a trigger by name:\n\n```python\n# check if the current temperature is hot enough to trigger a transition\nif lump.may_heat():\n# if lump.may_trigger(\"heat\"):\n    lump.heat()\n```\n\nThis will execute all `prepare` callbacks and evaluate the conditions assigned to the potential transitions.\nTransition checks can also be used when a transition's destination is not available (yet):\n\n```python\nmachine.add_transition('elevate', 'solid', 'spiritual')\nassert not lump.may_elevate()  # not ready yet :(\nassert not lump.may_trigger(\"elevate\")  # same result for checks via trigger name\n```\n\n#### <a name=\"transition-callbacks\"></a>Callbacks\n\nYou can attach callbacks to transitions as well as states. Every transition has `'before'` and `'after'` attributes that contain a list of methods to call before and after the transition executes:\n\n```python\nclass Matter(object):\n    def make_hissing_noises(self): print(\"HISSSSSSSSSSSSSSSS\")\n    def disappear(self): print(\"where'd all the liquid go?\")\n\ntransitions = [\n    { 'trigger': 'melt', 'source': 'solid', 'dest': 'liquid', 'before': 'make_hissing_noises'},\n    { 'trigger': 'evaporate', 'source': 'liquid', 'dest': 'gas', 'after': 'disappear' }\n]\n\nlump = Matter()\nmachine = Machine(lump, states, transitions=transitions, initial='solid')\nlump.melt()\n>>> \"HISSSSSSSSSSSSSSSS\"\nlump.evaporate()\n>>> \"where'd all the liquid go?\"\n```\n\nThere is also a `'prepare'` callback that is executed as soon as a transition starts, before any `'conditions'` are checked or other callbacks are executed.\n\n```python\nclass Matter(object):\n    heat = False\n    attempts = 0\n    def count_attempts(self): self.attempts += 1\n    def heat_up(self): self.heat = random.random() < 0.25\n    def stats(self): print('It took you %i attempts to melt the lump!' %self.attempts)\n\n    @property\n    def is_really_hot(self):\n        return self.heat\n\n\nstates=['solid', 'liquid', 'gas', 'plasma']\n\ntransitions = [\n    { 'trigger': 'melt', 'source': 'solid', 'dest': 'liquid', 'prepare': ['heat_up', 'count_attempts'], 'conditions': 'is_really_hot', 'after': 'stats'},\n]\n\nlump = Matter()\nmachine = Machine(lump, states, transitions=transitions, initial='solid')\nlump.melt()\nlump.melt()\nlump.melt()\nlump.melt()\n>>> \"It took you 4 attempts to melt the lump!\"\n```\n\nNote that `prepare` will not be called unless the current state is a valid source for the named transition.\n\nDefault actions meant to be executed before or after _every_ transition can be passed to `Machine` during initialization with\n`before_state_change` and `after_state_change` respectively:\n\n```python\nclass Matter(object):\n    def make_hissing_noises(self): print(\"HISSSSSSSSSSSSSSSS\")\n    def disappear(self): print(\"where'd all the liquid go?\")\n\nstates=['solid', 'liquid', 'gas', 'plasma']\n\nlump = Matter()\nm = Machine(lump, states, before_state_change='make_hissing_noises', after_state_change='disappear')\nlump.to_gas()\n>>> \"HISSSSSSSSSSSSSSSS\"\n>>> \"where'd all the liquid go?\"\n```\n\nThere are also two keywords for callbacks which should be executed _independently_ a) of how many transitions are possible,\nb) if any transition succeeds and c) even if an error is raised during the execution of some other callback.\nCallbacks passed to `Machine` with `prepare_event` will be executed _once_ before processing possible transitions\n(and their individual `prepare` callbacks) takes place.\nCallbacks of `finalize_event` will be executed regardless of the success of the processed transitions.\nNote that if an error occurred it will be attached to `event_data` as `error` and can be retrieved with `send_event=True`.\n\n```python\nfrom transitions import Machine\n\nclass Matter(object):\n    def raise_error(self, event): raise ValueError(\"Oh no\")\n    def prepare(self, event): print(\"I am ready!\")\n    def finalize(self, event): print(\"Result: \", type(event.error), event.error)\n\nstates=['solid', 'liquid', 'gas', 'plasma']\n\nlump = Matter()\nm = Machine(lump, states, prepare_event='prepare', before_state_change='raise_error',\n            finalize_event='finalize', send_event=True)\ntry:\n    lump.to_gas()\nexcept ValueError:\n    pass\nprint(lump.state)\n\n# >>> I am ready!\n# >>> Result:  <class 'ValueError'> Oh no\n# >>> initial\n```\n\nSometimes things just don't work out as intended and we need to handle exceptions and clean up the mess to keep things going.\nWe can pass callbacks to `on_exception` to do this:\n\n```python\nfrom transitions import Machine\n\nclass Matter(object):\n    def raise_error(self, event): raise ValueError(\"Oh no\")\n    def handle_error(self, event):\n        print(\"Fixing things ...\")\n        del event.error  # it did not happen if we cannot see it ...\n\nstates=['solid', 'liquid', 'gas', 'plasma']\n\nlump = Matter()\nm = Machine(lump, states, before_state_change='raise_error', on_exception='handle_error', send_event=True)\ntry:\n    lump.to_gas()\nexcept ValueError:\n    pass\nprint(lump.state)\n\n# >>> Fixing things ...\n# >>> initial\n```\n\n### <a name=\"resolution\"></a>Callable resolution\n\nAs you have probably already realized, the standard way of passing callables to states, conditions and transitions is by name. When processing callbacks and conditions, `transitions` will use their name to retrieve the related callable from the model. If the method cannot be retrieved and it contains dots, `transitions` will treat the name as a path to a module function and try to import it. Alternatively, you can pass names of properties or attributes. They will be wrapped into functions but cannot receive event data for obvious reasons. You can also pass callables such as (bound) functions directly. As mentioned earlier, you can also pass lists/tuples of callables names to the callback parameters. Callbacks will be executed in the order they were added.\n\n```python\nfrom transitions import Machine\nfrom mod import imported_func\n\nimport random\n\n\nclass Model(object):\n\n    def a_callback(self):\n        imported_func()\n\n    @property\n    def a_property(self):\n        \"\"\" Basically a coin toss. \"\"\"\n        return random.random() < 0.5\n\n    an_attribute = False\n\n\nmodel = Model()\nmachine = Machine(model=model, states=['A'], initial='A')\nmachine.add_transition('by_name', 'A', 'A', conditions='a_property', after='a_callback')\nmachine.add_transition('by_reference', 'A', 'A', unless=['a_property', 'an_attribute'], after=model.a_callback)\nmachine.add_transition('imported', 'A', 'A', after='mod.imported_func')\n\nmodel.by_name()\nmodel.by_reference()\nmodel.imported()\n```\n\nThe callable resolution is done in `Machine.resolve_callable`.\nThis method can be overridden in case more complex callable resolution strategies are required.\n\n**Example**\n\n```python\nclass CustomMachine(Machine):\n    @staticmethod\n    def resolve_callable(func, event_data):\n        # manipulate arguments here and return func, or super() if no manipulation is done.\n        super(CustomMachine, CustomMachine).resolve_callable(func, event_data)\n```\n\n### <a name=\"execution-order\"></a>Callback execution order\n\nIn summary, there are currently three ways to trigger events. You can call a model's convenience functions like `lump.melt()`,\nexecute triggers by name such as `lump.trigger(\"melt\")` or dispatch events on multiple models with `machine.dispatch(\"melt\")`\n(see section about multiple models in [alternative initialization patterns](#alternative-initialization-patterns)).\nCallbacks on transitions are then executed in the following order:\n\n| Callback                        |    Current State     | Comments                                                                                    |\n|---------------------------------| :------------------: |---------------------------------------------------------------------------------------------|\n| `'machine.prepare_event'`       |       `source`       | executed _once_ before individual transitions are processed                                 |\n| `'transition.prepare'`          |       `source`       | executed as soon as the transition starts                                                   |\n| `'transition.conditions'`       |       `source`       | conditions _may_ fail and halt the transition                                               |\n| `'transition.unless'`           |       `source`       | conditions _may_ fail and halt the transition                                               |\n| `'machine.before_state_change'` |       `source`       | default callbacks declared on model                                                         |\n| `'transition.before'`           |       `source`       |                                                                                             |\n| `'state.on_exit'`               |       `source`       | callbacks declared on the source state                                                      |\n| `<STATE CHANGE>`                |                      |                                                                                             |\n| `'state.on_enter'`              |    `destination`     | callbacks declared on the destination state                                                 |\n| `'transition.after'`            |    `destination`     |                                                                                             |\n| `'machine.on_final'`            |    `destination`     | callbacks on children will be called first                                                  |\n| `'machine.after_state_change'`  |    `destination`     | default callbacks declared on model; will also be called after internal transitions         |\n| `'machine.on_exception'`        | `source/destination` | callbacks will be executed when an exception has been raised                                |\n| `'machine.finalize_event'`      | `source/destination` | callbacks will be executed even if no transition took place or an exception has been raised |\n\nIf any callback raises an exception, the processing of callbacks is not continued. This means that when an error occurs before the transition (in `state.on_exit` or earlier), it is halted. In case there is a raise after the transition has been conducted (in `state.on_enter` or later), the state change persists and no rollback is happening. Callbacks specified in `machine.finalize_event` will always be executed unless the exception is raised by a finalizing callback itself. Note that each callback sequence has to be finished before the next stage is executed. Blocking callbacks will halt the execution order and therefore block the `trigger` or `dispatch` call itself. If you want callbacks to be executed in parallel, you could have a look at the [extensions](#extensions) `AsyncMachine` for asynchronous processing or `LockedMachine` for threading.\n\n### <a name=\"passing-data\"></a>Passing data\n\nSometimes you need to pass the callback functions registered at machine initialization some data that reflects the model's current state.\nTransitions allows you to do this in two different ways.\n\nFirst (the default), you can pass any positional or keyword arguments directly to the trigger methods (created when you call `add_transition()`):\n\n```python\nclass Matter(object):\n    def __init__(self): self.set_environment()\n    def set_environment(self, temp=0, pressure=101.325):\n        self.temp = temp\n        self.pressure = pressure\n    def print_temperature(self): print(\"Current temperature is %d degrees celsius.\" % self.temp)\n    def print_pressure(self): print(\"Current pressure is %.2f kPa.\" % self.pressure)\n\nlump = Matter()\nmachine = Machine(lump, ['solid', 'liquid'], initial='solid')\nmachine.add_transition('melt', 'solid', 'liquid', before='set_environment')\n\nlump.melt(45)  # positional arg;\n# equivalent to lump.trigger('melt', 45)\nlump.print_temperature()\n>>> 'Current temperature is 45 degrees celsius.'\n\nmachine.set_state('solid')  # reset state so we can melt again\nlump.melt(pressure=300.23)  # keyword args also work\nlump.print_pressure()\n>>> 'Current pressure is 300.23 kPa.'\n\n```\n\nYou can pass any number of arguments you like to the trigger.\n\nThere is one important limitation to this approach: every callback function triggered by the state transition must be able to handle _all_ of the arguments. This may cause problems if the callbacks each expect somewhat different data.\n\nTo get around this, Transitions supports an alternate method for sending data. If you set `send_event=True` at `Machine` initialization, all arguments to the triggers will be wrapped in an `EventData` instance and passed on to every callback. (The `EventData` object also maintains internal references to the source state, model, transition, machine, and trigger associated with the event, in case you need to access these for anything.)\n\n```python\nclass Matter(object):\n\n    def __init__(self):\n        self.temp = 0\n        self.pressure = 101.325\n\n    # Note that the sole argument is now the EventData instance.\n    # This object stores positional arguments passed to the trigger method in the\n    # .args property, and stores keywords arguments in the .kwargs dictionary.\n    def set_environment(self, event):\n        self.temp = event.kwargs.get('temp', 0)\n        self.pressure = event.kwargs.get('pressure', 101.325)\n\n    def print_pressure(self): print(\"Current pressure is %.2f kPa.\" % self.pressure)\n\nlump = Matter()\nmachine = Machine(lump, ['solid', 'liquid'], send_event=True, initial='solid')\nmachine.add_transition('melt', 'solid', 'liquid', before='set_environment')\n\nlump.melt(temp=45, pressure=1853.68)  # keyword args\nlump.print_pressure()\n>>> 'Current pressure is 1853.68 kPa.'\n\n```\n\n### <a name=\"alternative-initialization-patterns\"></a>Alternative initialization patterns\n\nIn all of the examples so far, we've attached a new `Machine` instance to a separate model (`lump`, an instance of class `Matter`). While this separation keeps things tidy (because you don't have to monkey patch a whole bunch of new methods into the `Matter` class), it can also get annoying, since it requires you to keep track of which methods are called on the state machine, and which ones are called on the model that the state machine is bound to (e.g., `lump.on_enter_StateA()` vs. `machine.add_transition()`).\n\nFortunately, Transitions is flexible, and supports two other initialization patterns.\n\nFirst, you can create a standalone state machine that doesn't require another model at all. Simply omit the model argument during initialization:\n\n```python\nmachine = Machine(states=states, transitions=transitions, initial='solid')\nmachine.melt()\nmachine.state\n>>> 'liquid'\n```\n\nIf you initialize the machine this way, you can then attach all triggering events (like `evaporate()`, `sublimate()`, etc.) and all callback functions directly to the `Machine` instance.\n\nThis approach has the benefit of consolidating all of the state machine functionality in one place, but can feel a little bit unnatural if you think state logic should be contained within the model itself rather than in a separate controller.\n\nAn alternative (potentially better) approach is to have the model inherit from the `Machine` class. Transitions is designed to support inheritance seamlessly. (just be sure to override class `Machine`'s `__init__` method!):\n\n```python\nclass Matter(Machine):\n    def say_hello(self): print(\"hello, new state!\")\n    def say_goodbye(self): print(\"goodbye, old state!\")\n\n    def __init__(self):\n        states = ['solid', 'liquid', 'gas']\n        Machine.__init__(self, states=states, initial='solid')\n        self.add_transition('melt', 'solid', 'liquid')\n\nlump = Matter()\nlump.state\n>>> 'solid'\nlump.melt()\nlump.state\n>>> 'liquid'\n```\n\nHere you get to consolidate all state machine functionality into your existing model, which often feels more natural than sticking all of the functionality we want in a separate standalone `Machine` instance.\n\nA machine can handle multiple models which can be passed as a list like `Machine(model=[model1, model2, ...])`.\nIn cases where you want to add models _as well as_ the machine instance itself, you can pass the class variable placeholder (string) `Machine.self_literal` during initialization like `Machine(model=[Machine.self_literal, model1, ...])`.\nYou can also create a standalone machine, and register models dynamically via `machine.add_model` by passing `model=None` to the constructor.\nFurthermore, you can use `machine.dispatch` to trigger events on all currently added models.\nRemember to call `machine.remove_model` if machine is long-lasting and your models are temporary and should be garbage collected:\n\n```python\nclass Matter():\n    pass\n\nlump1 = Matter()\nlump2 = Matter()\n\n# setting 'model' to None or passing an empty list will initialize the machine without a model\nmachine = Machine(model=None, states=states, transitions=transitions, initial='solid')\n\nmachine.add_model(lump1)\nmachine.add_model(lump2, initial='liquid')\n\nlump1.state\n>>> 'solid'\nlump2.state\n>>> 'liquid'\n\n# custom events as well as auto transitions can be dispatched to all models\nmachine.dispatch(\"to_plasma\")\n\nlump1.state\n>>> 'plasma'\nassert lump1.state == lump2.state\n\nmachine.remove_model([lump1, lump2])\ndel lump1  # lump1 is garbage collected\ndel lump2  # lump2 is garbage collected\n```\n\nIf you don't provide an initial state in the state machine constructor, `transitions` will create and add a default state called `'initial'`.\nIf you do not want a default initial state, you can pass `initial=None`.\nHowever, in this case you need to pass an initial state every time you add a model.\n\n```python\nmachine = Machine(model=None, states=states, transitions=transitions, initial=None)\n\nmachine.add_model(Matter())\n>>> \"MachineError: No initial state configured for machine, must specify when adding model.\"\nmachine.add_model(Matter(), initial='liquid')\n```\n\nModels with multiple states could attach multiple machines using different `model_attribute` values. As mentioned in [Checking state](#checking-state), this will add custom `is/to_<model_attribute>_<state_name>` functions:\n\n```python\nlump = Matter()\n\nmatter_machine = Machine(lump, states=['solid', 'liquid', 'gas'], initial='solid')\n# add a second machine to the same model but assign a different state attribute\nshipment_machine = Machine(lump, states=['delivered', 'shipping'], initial='delivered', model_attribute='shipping_state')\n\nlump.state\n>>> 'solid'\nlump.is_solid()  # check the default field\n>>> True\nlump.shipping_state\n>>> 'delivered'\nlump.is_shipping_state_delivered()  # check the custom field.\n>>> True\nlump.to_shipping_state_shipping()\n>>> True\nlump.is_shipping_state_delivered()\n>>> False\n```\n\n### Logging\n\nTransitions includes very rudimentary logging capabilities. A number of events  namely, state changes, transition triggers, and conditional checks  are logged as INFO-level events using the standard Python `logging` module. This means you can easily configure logging to standard output in a script:\n\n```python\n# Set up logging; The basic log level will be DEBUG\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n# Set transitions' log level to INFO; DEBUG messages will be omitted\nlogging.getLogger('transitions').setLevel(logging.INFO)\n\n# Business as usual\nmachine = Machine(states=states, transitions=transitions, initial='solid')\n...\n```\n\n### <a name=\"restoring\"></a>(Re-)Storing machine instances\n\nMachines are picklable and can be stored and loaded with `pickle`. For Python 3.3 and earlier `dill` is required.\n\n```python\nimport dill as pickle # only required for Python 3.3 and earlier\n\nm = Machine(states=['A', 'B', 'C'], initial='A')\nm.to_B()\nm.state\n>>> B\n\n# store the machine\ndump = pickle.dumps(m)\n\n# load the Machine instance again\nm2 = pickle.loads(dump)\n\nm2.state\n>>> B\n\nm2.states.keys()\n>>> ['A', 'B', 'C']\n```\n\n### <a name=\"typing-support\"></a> Typing support\n\nAs you probably noticed, `transitions` uses some of Python's dynamic features to give you handy ways to handle models. However, static type checkers don't like model attributes and methods not being known before runtime. Historically, `transitions` also didn't assign convenience methods already defined on models to prevent accidental overrides.\n\nBut don't worry!  You can use the machine constructor parameter `model_override` to change how models are decorated. If you set `model_override=True`, `transitions` will only override already defined methods. This prevents new methods from showing up at runtime and also allows you to define which helper methods you want to use.\n\n```python\nfrom transitions import Machine\n\n# Dynamic assignment\nclass Model:\n    pass\n\nmodel = Model()\ndefault_machine = Machine(model, states=[\"A\", \"B\"], transitions=[[\"go\", \"A\", \"B\"]], initial=\"A\")\nprint(model.__dict__.keys())  # all convenience functions have been assigned\n# >> dict_keys(['trigger', 'to_A', 'may_to_A', 'to_B', 'may_to_B', 'go', 'may_go', 'is_A', 'is_B', 'state'])\nassert model.is_A()  # Unresolved attribute reference 'is_A' for class 'Model'\n\n\n# Predefined assigment: We are just interested in calling our 'go' event and will trigger the other events by name\nclass PredefinedModel:\n    # state (or another parameter if you set 'model_attribute') will be assigned anyway \n    # because we need to keep track of the model's state\n    state: str\n\n    def go(self) -> bool:\n        raise RuntimeError(\"Should be overridden!\")\n\n    def trigger(self, trigger_name: str) -> bool:\n        raise RuntimeError(\"Should be overridden!\")\n\n\nmodel = PredefinedModel()\noverride_machine = Machine(model, states=[\"A\", \"B\"], transitions=[[\"go\", \"A\", \"B\"]], initial=\"A\", model_override=True)\nprint(model.__dict__.keys())\n# >> dict_keys(['trigger', 'go', 'state'])\nmodel.trigger(\"to_B\")\nassert model.state == \"B\"\n```\n\nIf you want to use all the convenience functions and throw some callbacks into the mix, defining a model can get pretty complicated when you have a lot of states and transitions defined.\nThe method `generate_base_model` in `transitions` can generate a base model from a machine configuration to help you out with that.\n\n```python\nfrom transitions.experimental.utils import generate_base_model\nsimple_config = {\n    \"states\": [\"A\", \"B\"],\n    \"transitions\": [\n        [\"go\", \"A\", \"B\"],\n    ],\n    \"initial\": \"A\",\n    \"before_state_change\": \"call_this\",\n    \"model_override\": True,\n} \n\nclass_definition = generate_base_model(simple_config)\nwith open(\"base_model.py\", \"w\") as f:\n    f.write(class_definition)\n\n# ... in another file\nfrom transitions import Machine\nfrom base_model import BaseModel\n\nclass Model(BaseModel):  #  call_this will be an abstract method in BaseModel\n\n    def call_this(self) -> None:\n        # do something  \n\nmodel = Model()\nmachine = Machine(model, **simple_config)\n```\n\nDefining model methods that will be overridden adds a bit of extra work.\nIt might be cumbersome to switch back and forth to make sure event names are spelled correctly, especially if states and transitions are defined in lists before or after your model. You can cut down on the boilerplate and the uncertainty of working with strings by defining states as enums. You can also define transitions right in your model class with the help of `add_transitions` and `event`. \nIt's up to you whether you use the function decorator `add_transitions` or event to assign values to attributes depends on your preferred code style.\nThey both work the same way, have the same signature, and should result in (almost) the same IDE type hints.\nAs this is still a work in progress, you'll need to create a custom Machine class and use with_model_definitions for transitions to check for transitions defined that way.\n\n```python\nfrom enum import Enum\n\nfrom transitions.experimental.utils import with_model_definitions, event, add_transitions, transition\nfrom transitions import Machine\n\n\nclass State(Enum):\n    A = \"A\"\n    B = \"B\"\n    C = \"C\"\n\n\nclass Model:\n\n    state: State = State.A\n\n    @add_transitions(transition(source=State.A, dest=State.B), [State.C, State.A])\n    @add_transitions({\"source\": State.B,  \"dest\": State.A})\n    def foo(self): ...\n\n    bar = event(\n        {\"source\": State.B, \"dest\": State.A, \"conditions\": lambda: False},\n        transition(source=State.B, dest=State.C)\n    )\n\n\n@with_model_definitions  # don't forget to define your model with this decorator!\nclass MyMachine(Machine):\n    pass\n\n\nmodel = Model()\nmachine = MyMachine(model, states=State, initial=model.state)\nmodel.foo()\nmodel.bar()\nassert model.state == State.C\nmodel.foo()\nassert model.state == State.A\n```\n\n### <a name=\"extensions\"></a> Extensions\n\nEven though the core of transitions is kept lightweight, there are a variety of MixIns to extend its functionality. Currently supported are:\n\n- **Hierarchical State Machines** for nesting and reuse\n- **Diagrams** to visualize the current state of a machine\n- **Threadsafe Locks** for parallel execution\n- **Async callbacks** for asynchronous execution\n- **Custom States** for extended state-related behaviour\n\nThere are two mechanisms to retrieve a state machine instance with the desired features enabled.\nThe first approach makes use of the convenience `factory` with the four parameters `graph`, `nested`, `locked` or `asyncio` set to `True` if the feature is required:\n\n```python\nfrom transitions.extensions import MachineFactory\n\n# create a machine with mixins\ndiagram_cls = MachineFactory.get_predefined(graph=True)\nnested_locked_cls = MachineFactory.get_predefined(nested=True, locked=True)\nasync_machine_cls = MachineFactory.get_predefined(asyncio=True)\n\n# create instances from these classes\n# instances can be used like simple machines\nmachine1 = diagram_cls(model, state, transitions)\nmachine2 = nested_locked_cls(model, state, transitions)\n```\n\nThis approach targets experimental use since in this case the underlying classes do not have to be known.\nHowever, classes can also be directly imported from `transitions.extensions`. The naming scheme is as follows:\n\n|                                | Diagrams | Nested | Locked | Asyncio |\n| -----------------------------: | :------: | :----: | :----: | :-----: |\n|                        Machine |         |       |       |        |\n|                   GraphMachine |         |       |       |        |\n|            HierarchicalMachine |         |       |       |        |\n|                  LockedMachine |         |       |       |        |\n|       HierarchicalGraphMachine |         |       |       |        |\n|             LockedGraphMachine |         |       |       |        |\n|      LockedHierarchicalMachine |         |       |       |        |\n| LockedHierarchicalGraphMachine |         |       |       |        |\n|                   AsyncMachine |         |       |       |        |\n|              AsyncGraphMachine |         |       |       |        |\n|       HierarchicalAsyncMachine |         |       |       |        |\n|  HierarchicalAsyncGraphMachine |         |       |       |        |\n\nTo use a feature-rich state machine, one could write:\n\n```python\nfrom transitions.extensions import LockedHierarchicalGraphMachine as LHGMachine\n\nmachine = LHGMachine(model, states, transitions)\n```\n\n#### <a name=\"hsm\"></a>Hierarchical State Machine (HSM)\n\nTransitions includes an extension module which allows nesting states.\nThis allows us to create contexts and to model cases where states are related to certain subtasks in the state machine.\nTo create a nested state, either import `NestedState` from transitions or use a dictionary with the initialization arguments `name` and `children`.\nOptionally, `initial` can be used to define a sub state to transit to, when the nested state is entered.\n\n```python\nfrom transitions.extensions import HierarchicalMachine\n\nstates = ['standing', 'walking', {'name': 'caffeinated', 'children':['dithering', 'running']}]\ntransitions = [\n  ['walk', 'standing', 'walking'],\n  ['stop', 'walking', 'standing'],\n  ['drink', '*', 'caffeinated'],\n  ['walk', ['caffeinated', 'caffeinated_dithering'], 'caffeinated_running'],\n  ['relax', 'caffeinated', 'standing']\n]\n\nmachine = HierarchicalMachine(states=states, transitions=transitions, initial='standing', ignore_invalid_triggers=True)\n\nmachine.walk() # Walking now\nmachine.stop() # let's stop for a moment\nmachine.drink() # coffee time\nmachine.state\n>>> 'caffeinated'\nmachine.walk() # we have to go faster\nmachine.state\n>>> 'caffeinated_running'\nmachine.stop() # can't stop moving!\nmachine.state\n>>> 'caffeinated_running'\nmachine.relax() # leave nested state\nmachine.state # phew, what a ride\n>>> 'standing'\n# machine.on_enter_caffeinated_running('callback_method')\n```\n\nA configuration making use of `initial` could look like this:\n\n```python\n# ...\nstates = ['standing', 'walking', {'name': 'caffeinated', 'initial': 'dithering', 'children': ['dithering', 'running']}]\ntransitions = [\n  ['walk', 'standing', 'walking'],\n  ['stop', 'walking', 'standing'],\n  # this transition will end in 'caffeinated_dithering'...\n  ['drink', '*', 'caffeinated'],\n  # ... that is why we do not need do specify 'caffeinated' here anymore\n  ['walk', 'caffeinated_dithering', 'caffeinated_running'],\n  ['relax', 'caffeinated', 'standing']\n]\n# ...\n```\n\nThe `initial` keyword of the `HierarchicalMachine` constructor accepts nested states (e.g. `initial='caffeinated_running'`) and a list of states which is considered to be a parallel state (e.g. `initial=['A', 'B']`) or the current state of another model (`initial=model.state`) which should be effectively one of the previous mentioned options. Note that when passing a string, `transition` will check the targeted state for `initial` substates and use this as an entry state. This will be done recursively until a substate does not mention an initial state. Parallel states or a state passed as a list will be used 'as is' and no further initial evaluation will be conducted.\n\nNote that your previously created state object _must be_ a `NestedState` or a derived class of it.\nThe standard `State` class used in simple `Machine` instances lacks features required for nesting.\n\n```python\nfrom transitions.extensions.nesting import HierarchicalMachine, NestedState\nfrom transitions import  State\nm = HierarchicalMachine(states=['A'], initial='initial')\nm.add_state('B')  # fine\nm.add_state({'name': 'C'})  # also fine\nm.add_state(NestedState('D'))  # fine as well\nm.add_state(State('E'))  # does not work!\n```\n\nSome things that have to be considered when working with nested states: State _names are concatenated_ with `NestedState.separator`.\nCurrently the separator is set to underscore ('\\_') and therefore behaves similar to the basic machine.\nThis means a substate `bar` from state `foo` will be known by `foo_bar`. A substate `baz` of `bar` will be referred to as `foo_bar_baz` and so on.\nWhen entering a substate, `enter` will be called for all parent states. The same is true for exiting substates.\nThird, nested states can overwrite transition behaviour of their parents.\nIf a transition is not known to the current state it will be delegated to its parent.\n\n**This means that in the standard configuration, state names in HSMs MUST NOT contain underscores.**\nFor `transitions` it's impossible to tell whether `machine.add_state('state_name')` should add a state named `state_name` or add a substate `name` to the state `state`.\nIn some cases this is not sufficient however.\nFor instance if state names consist of more than one word and you want/need to use underscore to separate them instead of `CamelCase`.\nTo deal with this, you can change the character used for separation quite easily.\nYou can even use fancy unicode characters if you use Python 3.\nSetting the separator to something else than underscore changes some of the behaviour (auto_transition and setting callbacks) though:\n\n```python\nfrom transitions.extensions import HierarchicalMachine\nfrom transitions.extensions.nesting import NestedState\nNestedState.separator = ''\nstates = ['A', 'B',\n  {'name': 'C', 'children':['1', '2',\n    {'name': '3', 'children': ['a', 'b', 'c']}\n  ]}\n]\n\ntransitions = [\n    ['reset', 'C', 'A'],\n    ['reset', 'C2', 'C']  # overwriting parent reset\n]\n\n# we rely on auto transitions\nmachine = HierarchicalMachine(states=states, transitions=transitions, initial='A')\nmachine.to_B()  # exit state A, enter state B\nmachine.to_C()  # exit B, enter C\nmachine.to_C.s3.a()  # enter Ca; enter C3a;\nmachine.state\n>>> 'C3a'\nassert machine.is_C.s3.a()\nmachine.to('C2')  # not interactive; exit C3a, exit C3, enter C2\nmachine.reset()  # exit C2; reset C has been overwritten by C3\nmachine.state\n>>> 'C'\nmachine.reset()  # exit C, enter A\nmachine.state\n>>> 'A'\n# s.on_enter('C3a', 'callback_method')\n```\n\nInstead of `to_C_3_a()` auto transition is called as `to_C.s3.a()`. If your substate starts with a digit, transitions adds a prefix 's' ('3' becomes 's3') to the auto transition `FunctionWrapper` to comply with the attribute naming scheme of Python.\nIf interactive completion is not required, `to('C3a')` can be called directly. Additionally, `on_enter/exit_<<state name>>` is replaced with `on_enter/exit(state_name, callback)`. State checks can be conducted in a similar fashion. Instead of `is_C_3_a()`, the `FunctionWrapper` variant `is_C.s3.a()` can be used.\n\nTo check whether the current state is a substate of a specific state, `is_state` supports the keyword `allow_substates`:\n\n```python\nmachine.state\n>>> 'C.2.a'\nmachine.is_C() # checks for specific states\n>>> False\nmachine.is_C(allow_substates=True)\n>>> True\nassert machine.is_C.s2() is False\nassert machine.is_C.s2(allow_substates=True)  # FunctionWrapper support allow_substate as well\n```\n\nYou can use enumerations in HSMs as well but keep in mind that `Enum` are compared by value.\nIf you have a value more than once in a state tree those states cannot be distinguished.\n\n```python\nstates = [States.RED, States.YELLOW, {'name': States.GREEN, 'children': ['tick', 'tock']}]\nstates = ['A', {'name': 'B', 'children': states, 'initial': States.GREEN}, States.GREEN]\nmachine = HierarchicalMachine(states=states)\nmachine.to_B()\nmachine.is_GREEN()  # returns True even though the actual state is B_GREEN\n```\n\n`HierarchicalMachine` has been rewritten from scratch to support parallel states and better isolation of nested states.\nThis involves some tweaks based on community feedback.\nTo get an idea of processing order and configuration have a look at the following example:\n\n```python\nfrom transitions.extensions.nesting import HierarchicalMachine\nimport logging\nstates = ['A', 'B', {'name': 'C', 'parallel': [{'name': '1', 'children': ['a', 'b', 'c'], 'initial': 'a',\n                                                'transitions': [['go', 'a', 'b']]},\n                                               {'name': '2', 'children': ['x', 'y', 'z'], 'initial': 'z'}],\n                      'transitions': [['go', '2_z', '2_x']]}]\n\ntransitions = [['reset', 'C_1_b', 'B']]\nlogging.basicConfig(level=logging.INFO)\nmachine = HierarchicalMachine(states=states, transitions=transitions, initial='A')\nmachine.to_C()\n# INFO:transitions.extensions.nesting:Exited state A\n# INFO:transitions.extensions.nesting:Entered state C\n# INFO:transitions.extensions.nesting:Entered state C_1\n# INFO:transitions.extensions.nesting:Entered state C_2\n# INFO:transitions.extensions.nesting:Entered state C_1_a\n# INFO:transitions.extensions.nesting:Entered state C_2_z\nmachine.go()\n# INFO:transitions.extensions.nesting:Exited state C_1_a\n# INFO:transitions.extensions.nesting:Entered state C_1_b\n# INFO:transitions.extensions.nesting:Exited state C_2_z\n# INFO:transitions.extensions.nesting:Entered state C_2_x\nmachine.reset()\n# INFO:transitions.extensions.nesting:Exited state C_1_b\n# INFO:transitions.extensions.nesting:Exited state C_2_x\n# INFO:transitions.extensions.nesting:Exited state C_1\n# INFO:transitions.extensions.nesting:Exited state C_2\n# INFO:transitions.extensions.nesting:Exited state C\n# INFO:transitions.extensions.nesting:Entered state B\n```\n\nWhen using `parallel` instead of `children`, `transitions` will enter all states of the passed list at the same time.\nWhich substate to enter is defined by `initial` which should _always_ point to a direct substate.\nA novel feature is to define local transitions by passing the `transitions` keyword in a state definition.\nThe above defined transition `['go', 'a', 'b']` is only valid in `C_1`.\nWhile you can reference substates as done in `['go', '2_z', '2_x']` you cannot reference parent states directly in locally defined transitions.\nWhen a parent state is exited, its children will also be exited.\nIn addition to the processing order of transitions known from `Machine` where transitions are considered in the order they were added, `HierarchicalMachine` considers hierarchy as well.\nTransitions defined in substates will be evaluated first (e.g. `C_1_a` is left before `C_2_z`) and transitions defined with wildcard `*` will (for now) only add transitions to root states (in this example `A`, `B`, `C`)\nStarting with _0.8.0_ nested states can be added directly and will issue the creation of parent states on-the-fly:\n\n```python\nm = HierarchicalMachine(states=['A'], initial='A')\nm.add_state('B_1_a')\nm.to_B_1()\nassert m.is_B(allow_substates=True)\n```\n\n_Experimental in 0.9.1:_\nYou can make use of `on_final` callbacks either in states or on the HSM itself. Callbacks will be triggered if a) the state itself is tagged with `final` and has just been entered or b) all substates are considered final and at least one substate just entered a final state. In case of b) all parents will be considered final as well if condition b) holds true for them. This might be useful in cases where processing happens in parallel and your HSM or any parent state should be notified when all substates have reached a final state:\n\n\n```python\nfrom transitions.extensions import HierarchicalMachine\nfrom functools import partial\n\n# We initialize this parallel HSM in state A:\n#        / X\n#       /   / yI\n# A -> B - Y - yII [final]\n#        \\ Z - zI\n#            \\ zII [final]\n\ndef final_event_raised(name):\n    print(\"{} is final!\".format(name))\n\n\nstates = ['A', {'name': 'B', 'parallel': [{'name': 'X', 'final': True, 'on_final': partial(final_event_raised, 'X')},\n                                          {'name': 'Y', 'transitions': [['final_Y', 'yI', 'yII']],\n                                           'initial': 'yI',\n                                           'on_final': partial(final_event_raised, 'Y'),\n                                           'states':\n                                               ['yI', {'name': 'yII', 'final': True}]\n                                           },\n                                          {'name': 'Z', 'transitions': [['final_Z', 'zI', 'zII']],\n                                           'initial': 'zI',\n                                           'on_final': partial(final_event_raised, 'Z'),\n                                           'states':\n                                               ['zI', {'name': 'zII', 'final': True}]\n                                           },\n                                          ],\n                \"on_final\": partial(final_event_raised, 'B')}]\n\nmachine = HierarchicalMachine(states=states, on_final=partial(final_event_raised, 'Machine'), initial='A')\n# X will emit a final event right away\nmachine.to_B()\n# >>> X is final!\nprint(machine.state)\n# >>> ['B_X', 'B_Y_yI', 'B_Z_zI']\n# Y's substate is final now and will trigger 'on_final' on Y\nmachine.final_Y()\n# >>> Y is final!\nprint(machine.state)\n# >>> ['B_X', 'B_Y_yII', 'B_Z_zI']\n# Z's substate becomes final which also makes all children of B final and thus machine itself\nmachine.final_Z()\n# >>> Z is final!\n# >>> B is final!\n# >>> Machine is final!\n```\n\n##### Reuse of previously created HSMs\n\nBesides semantic order, nested states are very handy if you want to specify state machines for specific tasks and plan to reuse them.\nBefore _0.8.0_, a `HierarchicalMachine` would not integrate the machine instance itself but the states and transitions by creating copies of them.\nHowever, since _0.8.0_ `(Nested)State` instances are just **referenced** which means changes in one machine's collection of states and events will influence the other machine instance. Models and their state will not be shared though.\nNote that events and transitions are also copied by reference and will be shared by both instances if you do not use the `remap` keyword.\nThis change was done to be more in line with `Machine` which also uses passed `State` instances by reference.\n\n```python\ncount_states = ['1', '2', '3', 'done']\ncount_trans = [\n    ['increase', '1', '2'],\n    ['increase', '2', '3'],\n    ['decrease', '3', '2'],\n    ['decrease', '2', '1'],\n    ['done', '3', 'done'],\n    ['reset', '*', '1']\n]\n\ncounter = HierarchicalMachine(states=count_states, transitions=count_trans, initial='1')\n\ncounter.increase() # love my counter\nstates = ['waiting', 'collecting', {'name': 'counting', 'children': counter}]\n\ntransitions = [\n    ['collect', '*', 'collecting'],\n    ['wait', '*', 'waiting'],\n    ['count', 'collecting', 'counting']\n]\n\ncollector = HierarchicalMachine(states=states, transitions=transitions, initial='waiting')\ncollector.collect()  # collecting\ncollector.count()  # let's see what we got; counting_1\ncollector.increase()  # counting_2\ncollector.increase()  # counting_3\ncollector.done()  # collector.state == counting_done\ncollector.wait()  # collector.state == waiting\n```\n\nIf a `HierarchicalMachine` is passed with the `children` keyword, the initial state of this machine will be assigned to the new parent state.\nIn the above example we see that entering `counting` will also enter `counting_1`.\nIf this is undesired behaviour and the machine should rather halt in the parent state, the user can pass `initial` as `False` like `{'name': 'counting', 'children': counter, 'initial': False}`.\n\nSometimes you want such an embedded state collection to 'return' which means after it is done it should exit and transit to one of your super states.\nTo achieve this behaviour you can remap state transitions.\nIn the example above we would like the counter to return if the state `done` was reached.\nThis is done as follows:\n\n```python\nstates = ['waiting', 'collecting', {'name': 'counting', 'children': counter, 'remap': {'done': 'waiting'}}]\n\n... # same as above\n\ncollector.increase() # counting_3\ncollector.done()\ncollector.state\n>>> 'waiting' # be aware that 'counting_done' will be removed from the state machine\n```\n\nAs mentioned above, using `remap` will **copy** events and transitions since they could not be valid in the original state machine.\nIf a reused state machine does not have a final state, you can of course add the transitions manually.\nIf 'counter' had no 'done' state, we could just add `['done', 'counter_3', 'waiting']` to achieve the same behaviour.\n\nIn cases where you want states and transitions to be copied by value rather than reference (for instance, if you want to keep the pre-0.8 behaviour) you can do so by creating a `NestedState` and assigning deep copies of the machine's events and states to it.\n\n```python\nfrom transitions.extensions.nesting import NestedState\nfrom copy import deepcopy\n\n# ... configuring and creating counter\n\ncounting_state = NestedState(name=\"counting\", initial='1')\ncounting_state.states = deepcopy(counter.states)\ncounting_state.events = deepcopy(counter.events)\n\nstates = ['waiting', 'collecting', counting_state]\n```\n\nFor complex state machines, sharing configurations rather than instantiated machines might be more feasible.\nEspecially since instantiated machines must be derived from `HierarchicalMachine`.\nSuch configurations can be stored and loaded easily via JSON or YAML (see the [FAQ](examples/Frequently%20asked%20questions.ipynb)).\n`HierarchicalMachine` allows defining substates either with the keyword `children` or `states`.\nIf both are present, only `children` will be considered.\n\n```python\ncounter_conf = {\n    'name': 'counting',\n    'states': ['1', '2', '3', 'done'],\n    'transitions': [\n        ['increase', '1', '2'],\n        ['increase', '2', '3'],\n        ['decrease', '3', '2'],\n        ['decrease', '2', '1'],\n        ['done', '3', 'done'],\n        ['reset', '*', '1']\n    ],\n    'initial': '1'\n}\n\ncollector_conf = {\n    'name': 'collector',\n    'states': ['waiting', 'collecting', counter_conf],\n    'transitions': [\n        ['collect', '*', 'collecting'],\n        ['wait', '*', 'waiting'],\n        ['count', 'collecting', 'counting']\n    ],\n    'initial': 'waiting'\n}\n\ncollector = HierarchicalMachine(**collector_conf)\ncollector.collect()\ncollector.count()\ncollector.increase()\nassert collector.is_counting_2()\n```\n\n#### <a name=\"diagrams\"></a> Diagrams\n\nAdditional Keywords:\n\n- `title` (optional): Sets the title of the generated image.\n- `show_conditions` (default False): Shows conditions at transition edges\n- `show_auto_transitions` (default False): Shows auto transitions in graph\n- `show_state_attributes` (default False): Show callbacks (enter, exit), tags and timeouts in graph\n\nTransitions can generate basic state diagrams displaying all valid transitions between states.\nThe basic diagram support generates a [mermaid](https://mermaid.js.org) state machine definition which can be used with mermaid's [live editor](https://mermaid.live), in markdown files in GitLab or GitHub and other web services.\nFor instance, this code:\n```python\nfrom transitions.extensions.diagrams import HierarchicalGraphMachine\nimport pyperclip\n\nstates = ['A', 'B', {'name': 'C',\n                     'final': True,\n                     'parallel': [{'name': '1', 'children': ['a', {\"name\": \"b\", \"final\": True}],\n                                   'initial': 'a',\n                                   'transitions': [['go', 'a', 'b']]},\n                                  {'name': '2', 'children': ['a', {\"name\": \"b\", \"final\": True}],\n                                   'initial': 'a',\n                                   'transitions': [['go', 'a', 'b']]}]}]\ntransitions = [['reset', 'C', 'A'], [\"init\", \"A\", \"B\"], [\"do\", \"B\", \"C\"]]\n\n\nm = HierarchicalGraphMachine(states=states, transitions=transitions, initial=\"A\", show_conditions=True,\n                             title=\"Mermaid\", graph_engine=\"mermaid\", auto_transitions=False)\nm.init()\n\npyperclip.copy(m.get_graph().draw(None))  # using pyperclip for convenience\nprint(\"Graph copied to clipboard!\")\n```\n\nProduces this diagram (check the document source to see the markdown notation):\n\n```mermaid\n---\nMermaid Graph\n---\nstateDiagram-v2\n  direction LR\n  classDef s_default fill:white,color:black\n  classDef s_inactive fill:white,color:black\n  classDef s_parallel color:black,fill:white\n  classDef s_active color:red,fill:darksalmon\n  classDef s_previous color:blue,fill:azure\n  \n  state \"A\" as A\n  Class A s_previous\n  state \"B\" as B\n  Class B s_active\n  state \"C\" as C\n  C --> [*]\n  Class C s_default\n  state C {\n    state \"1\" as C_1\n    state C_1 {\n      [*] --> C_1_a\n      state \"a\" as C_1_a\n      state \"b\" as C_1_b\n      C_1_b --> [*]\n    }\n    --\n    state \"2\" as C_2\n    state C_2 {\n      [*] --> C_2_a\n      state \"a\" as C_2_a\n      state \"b\" as C_2_b\n      C_2_b --> [*]\n    }\n  }\n  \n  C --> A: reset\n  A --> B: init\n  B --> C: do\n  C_1_a --> C_1_b: go\n  C_2_a --> C_2_b: go\n  [*] --> A\n```\n\nTo use more sophisticated graphing functionality, you'll need to have `graphviz` and/or `pygraphviz` installed.\nTo generate graphs with the package `graphviz`, you need to install [Graphviz](https://graphviz.org/) manually or via a package manager.\n\n    sudo apt-get install graphviz graphviz-dev  # Ubuntu and Debian\n    brew install graphviz  # MacOS\n    conda install graphviz python-graphviz  # (Ana)conda\n\nNow you can install the actual Python packages\n\n    pip install graphviz pygraphviz  # install graphviz and/or pygraphviz manually...\n    pip install transitions[diagrams]  # ... or install transitions with 'diagrams' extras which currently depends on pygraphviz\n\nCurrently, `GraphMachine` will use `pygraphviz` when available and fall back to `graphviz` when `pygraphviz` cannot be\nfound.\nIf `graphviz` is not available either, `mermaid` will be used.\nThis can be overridden by passing `graph_engine=\"graphviz\"` (or `\"mermaid\"`) to the constructor.\nNote that this default might change in the future and `pygraphviz` support may be dropped.\nWith `Model.get_graph()` you can get the current graph or the region of interest (roi) and draw it like this:\n\n```python\n# import transitions\n\nfrom transitions.extensions import GraphMachine\nm = Model()\n# without further arguments pygraphviz will be used\nmachine = GraphMachine(model=m, ...)\n# when you want to use graphviz explicitly\nmachine = GraphMachine(model=m, graph_engine=\"graphviz\", ...)\n# in cases where auto transitions should be visible\nmachine = GraphMachine(model=m, show_auto_transitions=True, ...)\n\n# draw the whole graph ...\nm.get_graph().draw('my_state_diagram.png', prog='dot')\n# ... or just the region of interest\n# (previous state, active state and all reachable states)\nroi = m.get_graph(show_roi=True).draw('my_state_diagram.png', prog='dot')\n```\n\nThis produces something like this:\n\n![state diagram example](https://user-images.githubusercontent.com/205986/47524268-725c1280-d89a-11e8-812b-1d3b6e667b91.png)\n\nIndependent of the backend you use, the draw function also accepts a file descriptor or a binary stream as the first argument. If you set this parameter to `None`, the byte stream will be returned:\n\n```python\nimport io\n\nwith open('a_graph.png', 'bw') as f:\n    # you need to pass the format when you pass objects instead of filenames.\n    m.get_graph().draw(f, format=\"png\", prog='dot')\n\n# you can pass a (binary) stream too\nb = io.BytesIO()\nm.get_graph().draw(b, format=\"png\", prog='dot')\n\n# or just handle the binary string yourself\nresult = m.get_graph().draw(None, format=\"png\", prog='dot')\nassert result == b.getvalue()\n```\n\nReferences and partials passed as callbacks will be resolved as good as possible:\n\n```python\nfrom transitions.extensions import GraphMachine\nfrom functools import partial\n\n\nclass Model:\n\n    def clear_state(self, deep=False, force=False):\n        print(\"Clearing state ...\")\n        return True\n\n\nmodel = Model()\nmachine = GraphMachine(model=model, states=['A', 'B', 'C'],\n                       transitions=[\n                           {'trigger': 'clear', 'source': 'B', 'dest': 'A', 'conditions': model.clear_state},\n                           {'trigger': 'clear', 'source': 'C', 'dest': 'A',\n                            'conditions': partial(model.clear_state, False, force=True)},\n                       ],\n                       initial='A', show_conditions=True)\n\nmodel.get_graph().draw('my_state_diagram.png', prog='dot')\n```\n\nThis should produce something similar to this:\n\n![state diagram references_example](https://user-images.githubusercontent.com/205986/110783076-39087f80-8268-11eb-8fa1-fc7bac97f4cf.png)\n\nIf the format of references does not suit your needs, you can override the static method `GraphMachine.format_references`. If you want to skip reference entirely, just let `GraphMachine.format_references` return `None`.\nAlso, have a look at our [example](./examples) IPython/Jupyter notebooks for a more detailed example about how to use and edit graphs.\n\n#### <a name=\"threading\"></a> Threadsafe(-ish) State Machine\n\nIn cases where event dispatching is done in threads, one can use either `LockedMachine` or `LockedHierarchicalMachine` where **function access** (!sic) is secured with reentrant locks.\nThis does not save you from corrupting your machine by tinkering with member variables of your model or state machine.\n\n```python\nfrom transitions.extensions import LockedMachine\nfrom threading import Thread\nimport time\n\nstates = ['A', 'B', 'C']\nmachine = LockedMachine(states=states, initial='A')\n\n# let us assume that entering B will take some time\nthread = Thread(target=machine.to_B)\nthread.start()\ntime.sleep(0.01) # thread requires some time to start\nmachine.to_C() # synchronized access; won't execute before thread is done\n# accessing attributes directly\nthread = Thread(target=machine.to_B)\nthread.start()\nmachine.new_attrib = 42 # not synchronized! will mess with execution order\n```\n\nAny python context manager can be passed in via the `machine_context` keyword argument:\n\n```python\nfrom transitions.extensions import LockedMachine\nfrom threading import RLock\n\nstates = ['A', 'B', 'C']\n\nlock1 = RLock()\nlock2 = RLock()\n\nmachine = LockedMachine(states=states, initial='A', machine_context=[lock1, lock2])\n```\n\nAny contexts via `machine_model` will be shared between all models registered with the `Machine`.\nPer-model contexts can be added as well:\n\n```python\nlock3 = RLock()\n\nmachine.add_model(model, model_context=lock3)\n```\n\nIt's important that all user-provided context managers are re-entrant since the state machine will call them multiple\ntimes, even in the context of a single trigger invocation.\n\n#### <a name=\"async\"></a> Using async callbacks\n\nIf you are using Python 3.7 or later, you can use `AsyncMachine` to work with asynchronous callbacks.\nYou can mix synchronous and asynchronous callbacks if you like but this may have undesired side effects.\nNote that events need to be awaited and the event loop must also be handled by you.\n\n```python\nfrom transitions.extensions.asyncio import AsyncMachine\nimport asyncio\nimport time\n\n\nclass AsyncModel:\n\n    def prepare_model(self):\n        print(\"I am synchronous.\")\n        self.start_time = time.time()\n\n    async def before_change(self):\n        print(\"I am asynchronous and will block now for 100 milliseconds.\")\n        await asyncio.sleep(0.1)\n        print(\"I am done waiting.\")\n\n    def sync_before_change(self):\n        print(\"I am synchronous and will block the event loop (what I probably shouldn't)\")\n        time.sleep(0.1)\n        print(\"I am done waiting synchronously.\")\n\n    def after_change(self):\n        print(f\"I am synchronous again. Execution took {int((time.time() - self.start_time) * 1000)} ms.\")\n\n\ntransition = dict(trigger=\"start\", source=\"Start\", dest=\"Done\", prepare=\"prepare_model\",\n                  before=[\"before_change\"] * 5 + [\"sync_before_change\"],\n                  after=\"after_change\")  # execute before function in asynchronously 5 times\nmodel = AsyncModel()\nmachine = AsyncMachine(model, states=[\"Start\", \"Done\"], transitions=[transition], initial='Start')\n\nasyncio.get_event_loop().run_until_complete(model.start())\n# >>> I am synchronous.\n#     I am asynchronous and will block now for 100 milliseconds.\n#     I am asynchronous and will block now for 100 milliseconds.\n#     I am asynchronous and will block now for 100 milliseconds.\n#     I am asynchronous and will block now for 100 milliseconds.\n#     I am asynchronous and will block now for 100 milliseconds.\n#     I am synchronous and will block the event loop (what I probably shouldn't)\n#     I am done waiting synchronously.\n#     I am done waiting.\n#     I am done waiting.\n#     I am done waiting.\n#     I am done waiting.\n#     I am done waiting.\n#     I am synchronous again. Execution took 101 ms.\nassert model.is_Done()\n```\n\nSo, why do you need to use Python 3.7 or later you may ask.\nAsync support has been introduced earlier.\n`AsyncMachine` makes use of `contextvars` to handle running callbacks when new events arrive before a transition\nhas been finished:\n\n```python\nasync def await_never_return():\n    await asyncio.sleep(100)\n    raise ValueError(\"That took too long!\")\n\nasync def fix():\n    await m2.fix()\n\nm1 = AsyncMachine(states=['A', 'B', 'C'], initial='A', name=\"m1\")\nm2 = AsyncMachine(states=['A', 'B', 'C'], initial='A', name=\"m2\")\nm2.add_transition(trigger='go', source='A', dest='B', before=await_never_return)\nm2.add_transition(trigger='fix', source='A', dest='C')\nm1.add_transition(trigger='go', source='A', dest='B', after='go')\nm1.add_transition(trigger='go', source='B', dest='C', after=fix)\nasyncio.get_event_loop().run_until_complete(asyncio.gather(m2.go(), m1.go()))\n\nassert m1.state == m2.state\n```\n\nThis example actually illustrates two things:\nFirst, that 'go' called in m1's transition from `A` to be `B` is not cancelled and second, calling `m2.fix()` will\nhalt the transition attempt of m2 from `A` to `B` by executing 'fix' from `A` to `C`.\nThis separation would not be possible without `contextvars`.\nNote that `prepare` and `conditions` are NOT treated as ongoing transitions.\nThis means that after `conditions` have been evaluated, a transition is executed even though another event already happened.\nTasks will only be cancelled when run as a `before` callback or later.\n\n`AsyncMachine` features a model-special queue mode which can be used when `queued='model'` is passed to the constructor.\nWith a model-specific queue, events will only be queued when they belong to the same model.\nFurthermore, a raised exception will only clear the event queue of the model that raised that exception.\nFor the sake of simplicity, let's assume that every event in `asyncio.gather` below is not triggered at the same time but slightly delayed:\n\n```python\nasyncio.gather(model1.event1(), model1.event2(), model2.event1())\n# execution order with AsyncMachine(queued=True)\n# model1.event1 -> model1.event2 -> model2.event1\n# execution order with AsyncMachine(queued='model')\n# (model1.event1, model2.event1) -> model1.event2\n\nasyncio.gather(model1.event1(), model1.error(), model1.event3(), model2.event1(), model2.event2(), model2.event3())\n# execution order with AsyncMachine(queued=True)\n# model1.event1 -> model1.error\n# execution order with AsyncMachine(queued='model')\n# (model1.event1, model2.event1) -> (model1.error, model2.event2) -> model2.event3\n```\n\nNote that queue modes must not be changed after machine construction.\n\n#### <a name=\"state-features\"></a>Adding features to states\n\nIf your superheroes need some custom behaviour, you can throw in some extra functionality by decorating machine states:\n\n```python\nfrom time import sleep\nfrom transitions import Machine\nfrom transitions.extensions.states import add_state_features, Tags, Timeout\n\n\n@add_state_features(Tags, Timeout)\nclass CustomStateMachine(Machine):\n    pass\n\n\nclass SocialSuperhero(object):\n    def __init__(self):\n        self.entourage = 0\n\n    def on_enter_waiting(self):\n        self.entourage += 1\n\n\nstates = [{'name': 'preparing', 'tags': ['home', 'busy']},\n          {'name': 'waiting', 'timeout': 1, 'on_timeout': 'go'},\n          {'name': 'away'}]  # The city needs us!\n\ntransitions = [['done', 'preparing', 'waiting'],\n               ['join', 'waiting', 'waiting'],  # Entering Waiting again will increase our entourage\n               ['go', 'waiting', 'away']]  # Okay, let' move\n\nhero = SocialSuperhero()\nmachine = CustomStateMachine(model=hero, states=states, transitions=transitions, initial='preparing')\nassert hero.state == 'preparing'  # Preparing for the night shift\nassert machine.get_state(hero.state).is_busy  # We are at home and busy\nhero.done()\nassert hero.state == 'waiting'  # Waiting for fellow superheroes to join us\nassert hero.entourage == 1  # It's just us so far\nsleep(0.7)  # Waiting...\nhero.join()  # Weeh, we got company\nsleep(0.5)  # Waiting...\nhero.join()  # Even more company \\o/\nsleep(2)  # Waiting...\nassert hero.state == 'away'  # Impatient superhero already left the building\nassert machine.get_state(hero.state).is_home is False  # Yupp, not at home anymore\nassert hero.entourage == 3  # At least he is not alone\n```\n\nCurrently, transitions comes equipped with the following state features:\n\n- **Timeout** -- triggers an event after some time has passed\n\n  - keyword: `timeout` (int, optional) -- if passed, an entered state will timeout after `timeout` seconds\n  - keyword: `on_timeout` (string/callable, optional) -- will be called when timeout time has been reached\n  - will raise an `AttributeError` when `timeout` is set but `on_timeout` is not\n  - Note: A timeout is triggered in a thread. This implies several limitations (e.g. catching Exceptions raised in timeouts). Consider an event queue for more sophisticated applications.\n\n- **Tags** -- adds tags to states\n\n  - keyword: `tags` (list, optional) -- assigns tags to a state\n  - `State.is_<tag_name>` will return `True` when the state has been tagged with `tag_name`, else `False`\n\n- **Error** -- raises a `MachineError` when a state cannot be left\n  - inherits from `Tags` (if you use `Error` do not use `Tags`)\n  - keyword: `accepted` (bool, optional) -- marks a state as accepted\n  - alternatively the keyword `tags` can be passed, containing 'accepted'\n  - Note: Errors will only be raised if `auto_transitions` has been set to `False`. Otherwise every state can be exited with `to_<state>` methods.\n- **Volatile** -- initialises an object every time a state is entered\n  - keyword: `volatile` (class, optional) -- every time the state is entered an object of type class will be assigned to the model. The attribute name is defined by `hook`. If omitted, an empty VolatileObject will be created instead\n  - keyword: `hook` (string, default='scope') -- The model's attribute name for the temporal object.\n\nYou can write your own `State` extensions and add them the same way. Just note that `add_state_features` expects _Mixins_. This means your extension should always call the overridden methods `__init__`, `enter` and `exit`. Your extension may inherit from _State_ but will also work without it.\nUsing `@add_state_features` has a drawback which is that decorated machines cannot be pickled (more precisely, the dynamically generated `CustomState` cannot be pickled).\nThis might be a reason to write a dedicated custom state class instead.\nDepending on the chosen state machine, your custom state class may need to provide certain state features. For instance, `HierarchicalMachine` requires your custom state to be an instance of `NestedState` (`State` is not sufficient). To inject your states you can either assign them to your `Machine`'s class attribute `state_cls` or override `Machine.create_state` in case you need some specific procedures done whenever a state is created:\n\n```python\nfrom transitions import Machine, State\n\nclass MyState(State):\n    pass\n\nclass CustomMachine(Machine):\n    # Use MyState as state class\n    state_cls = MyState\n\n\nclass VerboseMachine(Machine):\n\n    # `Machine._create_state` is a class method but we can\n    # override it to be an instance method\n    def _create_state(self, *args, **kwargs):\n        print(\"Creating a new state with machine '{0}'\".format(self.name))\n        return MyState(*args, **kwargs)\n```\n\nIf you want to avoid threads in your `AsyncMachine` entirely, you can replace the `Timeout` state feature with `AsyncTimeout` from the `asyncio` extension:\n\n```python\nimport asyncio\nfrom transitions.extensions.states import add_state_features\nfrom transitions.extensions.asyncio import AsyncTimeout, AsyncMachine\n\n@add_state_features(AsyncTimeout)\nclass TimeoutMachine(AsyncMachine):\n    pass\n\nstates = ['A', {'name': 'B', 'timeout': 0.2, 'on_timeout': 'to_C'}, 'C']\nm = TimeoutMachine(states=states, initial='A', queued=True)  # see remark below\nasyncio.run(asyncio.wait([m.to_B(), asyncio.sleep(0.1)]))\nassert m.is_B()  # timeout shouldn't be triggered\nasyncio.run(asyncio.wait([m.to_B(), asyncio.sleep(0.3)]))\nassert m.is_C()   # now timeout should have been processed\n```\n\nYou should consider passing `queued=True` to the `TimeoutMachine` constructor. This will make sure that events are processed sequentially and avoid asynchronous [racing conditions](https://github.com/pytransitions/transitions/issues/459) that may appear when timeout and event happen in proximity.\n\n#### <a name=\"django-support\"></a> Using transitions together with Django\n\nYou can have a look at the [FAQ](examples/Frequently%20asked%20questions.ipynb) for some inspiration or checkout `django-transitions`.\nIt has been developed by Christian Ledermann and is also hosted on [Github](https://github.com/PrimarySite/django-transitions).\n[The documentation](https://django-transitions.readthedocs.io/en/latest/) contains some usage examples.\n\n### <a name=\"bug-reports\"></a>I have a [bug report/issue/question]...\n\nFirst, congratulations! You reached the end of the documentation!\nIf you want to try out `transitions` before you install it, you can do that in an interactive Jupyter notebook at mybinder.org.\nJust click this button  [![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/pytransitions/transitions/master?filepath=examples%2FPlayground.ipynb).\n\nFor bug reports and other issues, please [open an issue](https://github.com/pytransitions/transitions) on GitHub.\n\nFor usage questions, post on Stack Overflow, making sure to tag your question with the [`pytransitions` tag](https://stackoverflow.com/questions/tagged/pytransitions). Do not forget to have a look at the [extended examples](./examples)!\n\nFor any other questions, solicitations, or large unrestricted monetary gifts, email [Tal Yarkoni](mailto:tyarkoni@gmail.com) (initial author) and/or [Alexander Neumann](mailto:aleneum@gmail.com) (current maintainer).\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 1.185546875,
          "content": "environment:\n\n  matrix:\n    # http://www.appveyor.com/docs/installed-software#python\n    - PYTHON: \"C:\\\\Python27\"\n    - PYTHON: \"C:\\\\Python33\"\n    - PYTHON: \"C:\\\\Python34\"\n    - PYTHON: \"C:\\\\Python35\"\n    - PYTHON: \"C:\\\\Python36\"\n    - PYTHON: \"C:\\\\Python27-x64\"\n    - PYTHON: \"C:\\\\Python33-x64\"\n    - PYTHON: \"C:\\\\Python34-x64\"\n    - PYTHON: \"C:\\\\Python35-x64\"\n    - PYTHON: \"C:\\\\Python36-x64\"\n\ninstall:\n  - \"%PYTHON%\\\\python.exe -m pip install -r requirements.txt\"\n  - \"%PYTHON%\\\\python.exe -m pip install -r requirements_test.txt\"\n\nbuild: off\n\ntest_script:\n  - \"%PYTHON%\\\\python.exe -m pytest --doctest-modules --cov transitions/\"\n\n#after_test:\n#  # This step builds your wheels.\n#  # Again, you only need build.cmd if you're building C extensions for\n#  # 64-bit Python 3.3/3.4. And you need to use %PYTHON% to get the correct\n#  # interpreter\n#  - \"%PYTHON%\\\\python.exe setup.py bdist_wheel\"\n\n#artifacts:\n#  # bdist_wheel puts your built wheel in the dist directory\n#  - path: dist\\*\n\n#on_success:\n#  You can use this step to upload your artifacts to a public website.\n#  See Appveyor's documentation for more details. Or you can simply\n#  access your wheels from the Appveyor \"artifacts\" tab for your build.\n"
        },
        {
          "name": "binder",
          "type": "tree",
          "content": null
        },
        {
          "name": "conftest.py",
          "type": "blob",
          "size": 0.6005859375,
          "content": "\"\"\"\npytest configuration - Tests async functionality only when asyncio and contextvars are available (Python 3.7+)\n\"\"\"\n# imports are required to check whether the modules are available\n# pylint: disable=unused-import\n\nfrom os.path import basename\ntry:\n    import asyncio\n    import contextvars\n    WITH_ASYNC = True\nexcept ImportError:\n    WITH_ASYNC = False\n\nasync_files = ['test_async.py', 'asyncio.py']\n\n\ndef pytest_ignore_collect(collection_path):\n    \"\"\"Text collection function executed by pytest\"\"\"\n    if not WITH_ASYNC and basename(str(collection_path)) in async_files:\n        return True\n    return None\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "mypy.ini",
          "type": "blob",
          "size": 0.369140625,
          "content": "[mypy]\ndisallow_untyped_defs = True\ndisallow_any_unimported = True\nno_implicit_optional = True\ncheck_untyped_defs = True\nwarn_return_any = True\nwarn_unused_ignores = True\nshow_error_codes = True\nignore_missing_imports = False\n\n[mypy-pygraphviz.*]\nignore_missing_imports = True\n\n[mypy-graphviz.*]\nignore_missing_imports = True\n\n[mypy-pycodestyle.*]\nignore_missing_imports = True\n"
        },
        {
          "name": "noxfile.py",
          "type": "blob",
          "size": 0.9150390625,
          "content": "import nox\n\n\npython = [\"2.7\", \"3.8\", \"3.9\", \"3.10\", \"3.11\", \"3.12\"]\nnox.options.stop_on_first_error = True\n\n\n@nox.session(python=python[-1])\ndef test_check_manifest(session):\n    session.install(\"check-manifest\")\n    session.run(\"check-manifest\")\n\n\n@nox.session(python=python[-1])\ndef test_mypy(session):\n    session.install(\".\")\n    session.install(\"-rrequirements_test.txt\")\n    session.install(\"-rrequirements_diagrams.txt\")\n    session.install(\"-rrequirements_mypy.txt\")\n    session.run(\"pytest\", \"-nauto\", \"--doctest-modules\", \"tests/\")\n\n\n@nox.session(python=python)\ndef test(session):\n    session.install(\".\")\n    session.install(\"-rrequirements_test.txt\")\n    session.install(\"-rrequirements_diagrams.txt\")\n    session.run(\"pytest\", \"-nauto\", \"tests/\")\n\n\n@nox.session(python=python[-1])\ndef test_no_gv(session):\n    session.install(\".\")\n    session.install(\"-rrequirements_test.txt\")\n    session.run(\"pytest\", \"-nauto\", \"tests/\")\n"
        },
        {
          "name": "pytest.ini",
          "type": "blob",
          "size": 0.1220703125,
          "content": "[pytest]\nfilterwarnings =\n    error\n    ignore:.*With-statements.*:DeprecationWarning\naddopts = -x -rf\njunit_family = xunit2\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.00390625,
          "content": "six\n"
        },
        {
          "name": "requirements_diagrams.txt",
          "type": "blob",
          "size": 0.01953125,
          "content": "pygraphviz\ngraphviz\n"
        },
        {
          "name": "requirements_mypy.txt",
          "type": "blob",
          "size": 0.0234375,
          "content": "mypy\ngraphviz\ntypes-six\n"
        },
        {
          "name": "requirements_test.txt",
          "type": "blob",
          "size": 0.0654296875,
          "content": "pytest\npytest-cov\npytest-runner\npytest-xdist\nmock\ndill\npycodestyle\n"
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.130859375,
          "content": "[metadata]\ndescription_file = README.md\n\n[check-manifest]\nignore =\n    .scrutinizer.yml\n    appveyor.yml\n\n[bdist_wheel]\nuniversal = 1\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 2.109375,
          "content": "import codecs\nimport sys\nfrom setuptools import setup, find_packages\n\nwith open(\"transitions/version.py\") as f:\n    exec(f.read())\n\nwith codecs.open(\"README.md\", \"r\", \"utf-8\") as f:\n    import re\n\n    # cut the badges from the description and also the TOC which is currently not working on PyPi\n    regex = r\"([\\s\\S]*)## Quickstart\"\n    readme = f.read()\n\n    long_description = re.sub(regex, \"## Quickstart\", readme, 1)\n    assert (\n        long_description[:13] == \"## Quickstart\"\n    )  # Description should start with a headline (## Quickstart)\n\ntests_require = [\"mock\", \"tox\", \"graphviz\", \"pygraphviz\"]\n\nextras_require = {\"diagrams\": [\"pygraphviz\"]}\n\nextra_setuptools_args = {}\nif \"setuptools\" in sys.modules:\n    extras_require[\"test\"] = [\"pytest\"]\n    tests_require.append(\"pytest\")\n\nsetup(\n    name=\"transitions\",\n    version=__version__,\n    description=\"A lightweight, object-oriented Python state machine implementation with many extensions.\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Tal Yarkoni\",\n    author_email=\"tyarkoni@gmail.com\",\n    maintainer=\"Alexander Neumann\",\n    maintainer_email=\"aleneum@gmail.com\",\n    url=\"http://github.com/pytransitions/transitions\",\n    packages=find_packages(exclude=[\"tests\", \"test_*\"]),\n    package_data={\n        \"transitions\": [\"py.typed\", \"data/*\"],\n        \"transitions.tests\": [\"data/*\"],\n    },\n    include_package_data=True,\n    install_requires=[\"six\"],\n    extras_require=extras_require,\n    tests_require=tests_require,\n    license=\"MIT\",\n    download_url=\"https://github.com/pytransitions/transitions/archive/%s.tar.gz\"\n    % __version__,\n    classifiers=[\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python :: 2\",\n        \"Programming Language :: Python :: 2.7\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n    ],\n    **extra_setuptools_args,\n)\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "transitions",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}