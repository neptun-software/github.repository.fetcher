{
  "metadata": {
    "timestamp": 1736560504931,
    "page": 99,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "newren/git-filter-repo",
      "stars": 8865,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1025390625,
          "content": "*.sh eol=lf\n*.py eol=lf\n/git-filter-repo eol=lf\n/contrib/filter-repo-demos/[a-z]* eol=lf\n/t/t9*/* eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.08984375,
          "content": "/Documentation/html/\n/Documentation/man1/\n/t/test-results\n/t/trash directory*\n/__pycache__/\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.1318359375,
          "content": "git-filter-repo itself and most the files in this repository (exceptions\nnoted below) are provided under the MIT license (see COPYING.mit).\n\nThe usage of the MIT license probably makes filter-repo compatible with\neverything, but just in case, these files can also be used under whatever\nopen source license[1] that git.git or libgit2 use now or in the future\n(currently GPL[2] and GPL-with-linking-exception[3]).  Further, the\nexamples (in contrib/filter-repo-demos/ and t/t9391/) can also be used\nunder the same license that libgit2 provides their examples under (CC0,\ncurrently[4]).\n\nExceptions:\n\n  - The test harness (t/test-lib.sh, t/test-lib-functions.sh) is a slightly\n    modified copy of git.git's test harness (the difference being that my\n    copy doesn't require a built version of 'git' to be present).  These\n    are thus GPL2 (see COPYING.gpl), and are individually marked as such.\n\n\n[1] ...as defined by the Open Source Initiative (https://opensource.org/)\n[2] https://git.kernel.org/pub/scm/git/git.git/tree/COPYING\n[3] https://github.com/libgit2/libgit2/blob/master/COPYING\n[4] https://github.com/libgit2/libgit2/blob/master/examples/COPYING\n"
        },
        {
          "name": "COPYING.gpl",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "COPYING.mit",
          "type": "blob",
          "size": 1.029296875,
          "content": "Copyright (c) 2009, 2018-2019\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Documentation",
          "type": "tree",
          "content": null
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 8.95703125,
          "content": "# Table of Contents\n\n  * [Pre-requisites](#pre-requisites)\n  * [Simple Installation](#simple-installation)\n  * [Installation via Package Manager](#installation-via-package-manager)\n  * [Detailed installation explanation for\n     packagers](#detailed-installation-explanation-for-packagers)\n  * [Installation as Python Package from\n     PyPI](#installation-as-python-package-from-pypi)\n  * [Installation via Makefile](#installation-via-makefile)\n  * [Notes for Windows Users](#notes-for-windows-users)\n\n# Pre-requisites\n\nInstructions on this page assume you have already installed both\n[Git](https://git-scm.com) and [Python](https://www.python.org/)\n(though the [Notes for Windows Users](#notes-for-windows-users) has\nsome tips on Python).\n\n# Simple Installation\n\nAll you need to do is download one file: the [git-filter-repo script\nin this repository](git-filter-repo) ([direct link to raw\nfile](https://raw.githubusercontent.com/newren/git-filter-repo/main/git-filter-repo)),\nmaking sure to preserve its name (`git-filter-repo`, with no\nextension).  **That's it**.  You're done.\n\nThen you can run any command you want, such as\n\n    $ python3 git-filter-repo --analyze\n\nIf you place the git-filter-repo script in your $PATH, then you can\nshorten commands by replacing `python3 git-filter-repo` with `git\nfilter-repo`; the manual assumes this but you can use the longer form.\n\nOptionally, if you also want to use some of the contrib scripts, then\nyou need to make sure you have a `git_filter_repo.py` file which is\neither a link to or copy of `git-filter-repo`, and you need to place\nthat git_filter_repo.py file in $PYTHONPATH.\n\nIf you prefer an \"official\" installation over the manual installation\nexplained above, the other sections may have useful tips.\n\n# Installation via Package Manager\n\nIf you want to install via some [package\nmanager](https://alternativeto.net/software/yellowdog-updater-modified/?license=opensource),\nyou can run\n\n    $ PACKAGE_TOOL install git-filter-repo\n\nThe following package managers have packaged git-filter-repo:\n\n[![Packaging status](https://repology.org/badge/vertical-allrepos/git-filter-repo.svg)](https://repology.org/project/git-filter-repo/versions)\n\nThis list covers at least Windows (Scoop), Mac OS X (Homebrew), and\nLinux (most the rest).  Note that I do not curate this list (and have\nno interest in doing so); https://repology.org tracks who packages\nthese versions.\n\n# Detailed installation explanation for packagers\n\nfilter-repo only consists of a few files that need to be installed:\n\n  * git-filter-repo\n\n    This is the _only_ thing needed for basic use.\n\n    This can be installed in the directory pointed to by `git --exec-path`,\n    or placed anywhere in $PATH.\n\n    If your python3 executable is named \"python\" instead of \"python3\"\n    (this particularly appears to affect a number of Windows users),\n    then you'll also need to modify the first line of git-filter-repo\n    to replace \"python3\" with \"python\".\n\n  * git_filter_repo.py\n\n    This is needed if you want to make use of one of the scripts in\n    contrib/filter-repo-demos/, or want to write your own script making use\n    of filter-repo as a python library.\n\n    You can create this symlink to (or copy of) git-filter-repo named\n    git_filter_repo.py and place it in your python site packages; `python\n    -c \"import site; print(site.getsitepackages())\"` may help you find the\n    appropriate location for your system.  Alternatively, you can place\n    this file anywhere within $PYTHONPATH.\n\n  * git-filter-repo.1\n\n    This is needed if you want `git filter-repo --help` to succeed in\n    displaying the manpage, when help.format is \"man\" (the default on Linux\n    and Mac).\n\n    This can be installed in the directory pointed to by `$(git\n    --man-path)/man1/`, or placed anywhere in $MANDIR/man1/ where $MANDIR\n    is some entry from $MANPATH.\n\n    Note that `git filter-repo -h` will show a more limited built-in set of\n    instructions regardless of whether the manpage is installed.\n\n  * git-filter-repo.html\n\n    This is needed if you want `git filter-repo --help` to succeed in\n    displaying the html version of the help, when help.format is set to\n    \"html\" (the default on Windows).\n\n    This can be installed in the directory pointed to by `git --html-path`.\n\n    Note that `git filter-repo -h` will show a more limited built-in set of\n    instructions regardless of whether the html version of help is\n    installed.\n\nSo, installation might look something like the following:\n\n1. If you don't have the necessary documentation files (because you\n   are installing from a clone of filter-repo instead of from a\n   tarball) then you can first run:\n\n   `make snag_docs`\n\n   (which just copies the generated documentation files from the\n   `docs` branch)\n\n2. Run the following\n\n   ```\n   cp -a git-filter-repo $(git --exec-path)\n   cp -a git-filter-repo.1 $(git --man-path)/man1 && mandb\n   cp -a git-filter-repo.html $(git --html-path)\n   ln -s $(git --exec-path)/git-filter-repo \\\n       $(python -c \"import site; print(site.getsitepackages()[-1])\")/git_filter_repo.py\n   ```\n\nor you can use the provided Makefile, as noted below.\n\n# Installation as Python Package from PyPI\n\n`git-filter-repo` is also available as\n[PyPI-package](https://pypi.org/project/git-filter-repo/).\n\nTherefore, it can be installed with [pipx](https://pypa.github.io/pipx/)\nor [uv tool](https://docs.astral.sh/uv/concepts/tools/).\nCommand example for pipx:\n\n`pipx install git-filter-repo`\n\n# Installation via Makefile\n\nInstalling should be doable by hand, but a Makefile is provided for those\nthat prefer it.  However, usage of the Makefile really requires overriding\nat least a couple of the directories with sane values, e.g.\n\n    $ make prefix=/usr pythondir=/usr/lib64/python3.8/site-packages install\n\nAlso, the Makefile will not edit the shebang line (the first line) of\ngit-filter-repo if your python executable is not named \"python3\";\nyou'll still need to do that yourself.\n\n# Notes for Windows Users\n\ngit-filter-repo can be installed with multiple tools, such as\n[pipx](https://pypa.github.io/pipx/) or a Windows-specific package manager\nlike Scoop (both of which were covered above).\n\nSadly, Windows sometimes makes things difficult.  Common and historical issues:\n\n  * **Non-functional Python stub**: Windows apparently ships with a\n    [non-functional\n    python](https://github.com/newren/git-filter-repo/issues/36#issuecomment-568933825).\n    This can even manifest as [the app\n    hanging](https://github.com/newren/git-filter-repo/issues/36) or\n    [the system appearing to\n    hang](https://github.com/newren/git-filter-repo/issues/312).  Try\n    installing\n    [Python](https://docs.microsoft.com/en-us/windows/python/beginners)\n    from the [Microsoft\n    Store](https://apps.microsoft.com/store/search?publisher=Python%20Software%20Foundation)\n  * **Modifying PATH, making the script executable**: If modifying your PATH\n    and/or making scripts executable is difficult for you, you can skip that\n    step by just using `python3 git-filter-repo` instead of `git filter-repo`\n    in your commands.\n  * **Different python executable name**:  Some users don't have\n    a `python3` executable but one named something else like `python`\n    or `python3.8` or whatever.  You may need to edit the first line\n    of the git-filter-repo script to specify the appropriate path.  Or\n    just don't bother and instead use the long form for executing\n    filter-repo commands.  Namely, replace the `git filter-repo` part\n    of commands with `PYTHON_EXECUTABLE git-filter-repo`. (Where\n    `PYTHON_EXECUTABLE` is something like `python` or `python3.8` or\n    `C:\\PATH\\TO\\INSTALLATION\\OF\\python3.exe` or whatever).\n  * **Symlink issues**:  git_filter_repo.py is supposed to be a symlink to\n    git-filter-repo, so that it appears to have identical contents.\n    If your system messed up the symlink (usually meaning it looks like a\n    regular file with just one line), then delete git_filter_repo.py and\n    replace it with a copy of git-filter-repo.\n  * **Old GitBash limitations**: older versions of GitForWindows had an\n    unfortunate shebang length limitation (see [git-for-windows issue\n    #3165](https://github.com/git-for-windows/git/pull/3165)).  If\n    you're affected, just use the long form for invoking filter-repo\n    commands, i.e. replace the `git filter-repo` part of commands with\n    `python3 git-filter-repo`.\n\nFor additional historical context, see:\n  * [#371](https://github.com/newren/git-filter-repo/issues/371#issuecomment-1267116186)\n  * [#360](https://github.com/newren/git-filter-repo/issues/360#issuecomment-1276813596)\n  * [#312](https://github.com/newren/git-filter-repo/issues/312)\n  * [#307](https://github.com/newren/git-filter-repo/issues/307)\n  * [#225](https://github.com/newren/git-filter-repo/pull/225)\n  * [#231](https://github.com/newren/git-filter-repo/pull/231)\n  * [#124](https://github.com/newren/git-filter-repo/issues/124)\n  * [#36](https://github.com/newren/git-filter-repo/issues/36)\n  * [this git mailing list\n     thread](https://lore.kernel.org/git/nycvar.QRO.7.76.6.2004251610300.18039@tvgsbejvaqbjf.bet/)\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 6.4931640625,
          "content": "# A bunch of installation-related paths people can override on the command line\nDESTDIR = /\nINSTALL = install\nprefix = $(HOME)\nbindir = $(prefix)/libexec/git-core\nlocaledir = $(prefix)/share/locale\nmandir = $(prefix)/share/man\nhtmldir = $(prefix)/share/doc/git-doc\npythondir = $(prefix)/lib64/python3.6/site-packages\n\ndefault: build\n\nbuild:\n\t@echo Nothing to do: filter-repo is a script which needs no compilation.\n\ntest:\n\ttime t/run_coverage\n\n# fixup_locale might matter once we actually have translations, but right now\n# we don't.  It might not even matter then, because python has a fallback podir.\nfixup_locale:\n\tsed -ie s%@@LOCALEDIR@@%$(localedir)% git-filter-repo\n\n# People installing from tarball will already have man1/git-filter-repo.1 and\n# html/git-filter-repo.html.  But let's support people installing from a git\n# clone too; for them, just cheat and snag a copy of the built docs that I\n# record in a different branch.\nsnag_docs: Documentation/man1/git-filter-repo.1 Documentation/html/git-filter-repo.html\n\nDocumentation/man1/git-filter-repo.1:\n\tmkdir -p Documentation/man1\n\tgit show origin/docs:man1/git-filter-repo.1 >Documentation/man1/git-filter-repo.1\n\nDocumentation/html/git-filter-repo.html:\n\tmkdir -p Documentation/html\n\tgit show origin/docs:html/git-filter-repo.html >Documentation/html/git-filter-repo.html\n\ninstall: snag_docs #fixup_locale\n\t$(INSTALL) -Dm0755 git-filter-repo \"$(DESTDIR)/$(bindir)/git-filter-repo\"\n\t$(INSTALL) -dm0755 \"$(DESTDIR)/$(pythondir)\"\n\tln -sf \"$(bindir)/git-filter-repo\" \"$(DESTDIR)/$(pythondir)/git_filter_repo.py\"\n\t$(INSTALL) -Dm0644 Documentation/man1/git-filter-repo.1 \"$(DESTDIR)/$(mandir)/man1/git-filter-repo.1\"\n\t$(INSTALL) -Dm0644 Documentation/html/git-filter-repo.html \"$(DESTDIR)/$(htmldir)/git-filter-repo.html\"\n\tif which mandb > /dev/null; then mandb; fi\n\n\n#\n# The remainder of the targets are meant for tasks for the maintainer; if they\n# don't work for you, I don't care.  These tasks modify branches and upload\n# releases and whatnot, and presume a directory layout I have locally.\n#\nupdate_docs:\n\t# Set environment variables once\n\texport GIT_WORK_TREE=$(shell mktemp -d) \\\n\texport GIT_INDEX_FILE=$(shell mktemp) \\\n\tCOMMIT=$(shell git rev-parse HEAD) \\\n\t&& \\\n\t# Sanity check; we'll build docs in a clone of a git repo \\\n\ttest -d ../git && \\\n\t# Sanity check; docs == origin/docs \\\n\ttest -z \"$(git rev-parse docs origin/docs | uniq -u)\" && \\\n\t# Avoid spurious errors by forcing index to be well formatted, if empty \\\n\tgit read-tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904 && # empty tree \\\n\t# Symlink git-filter-repo.txt documentation into git and build it \\\n\tln -sf ../../git-filter-repo/Documentation/git-filter-repo.txt ../git/Documentation/ && \\\n\tmake -C ../git/Documentation -j4 man html && \\\n\t# Take the built documentation and lay it out nicely \\\n\tmkdir $$GIT_WORK_TREE/html && \\\n\tmkdir $$GIT_WORK_TREE/man1 && \\\n\tcp -a ../git/Documentation/*.html $$GIT_WORK_TREE/html/ && \\\n\tcp -a ../git/Documentation/git-filter-repo.1 $$GIT_WORK_TREE/man1/ && \\\n\tdos2unix $$GIT_WORK_TREE/html/* && \\\n\t# Add new version of the documentation as a commit, if it differs \\\n\tgit --work-tree $$GIT_WORK_TREE add . && \\\n\tgit diff --quiet docs || git write-tree \\\n\t\t| xargs git commit-tree -p docs -m \"Update docs to $$COMMIT\" \\\n\t\t| xargs git update-ref refs/heads/docs && \\\n\t# Remove temporary files \\\n\trm -rf $$GIT_WORK_TREE && \\\n\trm $$GIT_INDEX_FILE && \\\n\t# Push the new documentation upstream \\\n\tgit push origin docs && \\\n\t# Notify of completion \\\n\techo && \\\n\techo === filter-repo docs branch updated ===\n\n# Call like this:\n#   make GITHUB_COM_TOKEN=$KEY TAGNAME=v2.23.0 release\nrelease: github_release pypi_release\n\n# Call like this:\n#   make GITHUB_COM_TOKEN=$KEY TAGNAME=v2.23.0 github_release\ngithub_release: update_docs\n\tFILEBASE=git-filter-repo-$(shell echo $(TAGNAME) | tail -c +2) \\\n\tTMP_INDEX_FILE=$(shell mktemp) \\\n\tCOMMIT=$(shell git rev-parse HEAD) \\\n\t&& \\\n\ttest -n \"$(GITHUB_COM_TOKEN)\" && \\\n\ttest -n \"$(TAGNAME)\" && \\\n\ttest -n \"$$COMMIT\" && \\\n\t# Make sure we don't have any staged or unstaged changes \\\n\tgit diff --quiet --staged HEAD && git diff --quiet HEAD && \\\n\t# Make sure 'jq' is installed \\\n\ttype -p jq && \\\n\t# Tag the release, push it to GitHub \\\n\tgit tag -a -m \"filter-repo $(TAGNAME)\" $(TAGNAME) $$COMMIT && \\\n\tgit push origin $(TAGNAME) && \\\n\t# Create the tarball \\\n\tGIT_INDEX_FILE=$$TMP_INDEX_FILE git read-tree $$COMMIT && \\\n\tgit ls-tree -r docs | grep filter-repo    \\\n\t\t| sed -e 's%\\t%\\tDocumentation/%' \\\n\t\t| GIT_INDEX_FILE=$$TMP_INDEX_FILE git update-index --index-info && \\\n\tGIT_INDEX_FILE=$$TMP_INDEX_FILE git write-tree                                    \\\n\t\t| xargs git archive --prefix=$$FILEBASE/ \\\n\t\t| xz -c >$$FILEBASE.tar.xz && \\\n\trm $$TMP_INDEX_FILE && \\\n\t# Make GitHub mark our new tag as an official release \\\n\tcurl -s -H \"Authorization: token $(GITHUB_COM_TOKEN)\" -X POST \\\n\t\thttps://api.github.com/repos/newren/git-filter-repo/releases \\\n\t\t--data \"{                                  \\\n\t\t  \\\"tag_name\\\": \\\"$(TAGNAME)\\\",            \\\n\t\t  \\\"target_commitish\\\": \\\"$$COMMIT\\\",      \\\n\t\t  \\\"name\\\": \\\"$(TAGNAME)\\\",                \\\n\t\t  \\\"body\\\": \\\"filter-repo $(TAGNAME)\\\"     \\\n\t\t}\" | jq -r .id >asset_id && \\\n\t# Upload our tarball \\\n\tcat asset_id | xargs -I ASSET_ID curl -s -H \"Authorization: token $(GITHUB_COM_TOKEN)\" -H \"Content-Type: application/octet-stream\" --data-binary @$$FILEBASE.tar.xz https://uploads.github.com/repos/newren/git-filter-repo/releases/ASSET_ID/assets?name=$$FILEBASE.tar.xz && \\\n\t# Remove temporary file(s) \\\n\trm asset_id && \\\n\t# Notify of completion \\\n\techo && \\\n\techo === filter-repo $(TAGNAME) created and uploaded to GitHub ===\n\npypi_release: # Has an implicit dependency on github_release because...\n\t# Upload to PyPI, automatically picking tag created by github_release\n\tpython3 -m venv venv\n\tvenv/bin/pip install --upgrade pip\n\tvenv/bin/pip install build twine\n\tvenv/bin/pyproject-build\n\t# Note: Retrieve \"git-filter-repo releases\" token; username is 'newren'\n\tvenv/bin/twine upload dist/*\n\t# Remove temporary file(s)\n\trm -rf dist/ venv/ git_filter_repo.egg-info/\n\n# NOTE TO FUTURE SELF: If you accidentally push a bad release, you can remove\n# all but the git-filter-repo-$VERSION.tar.xz asset with\n#    git push --delete origin $TAGNAME\n# To remove the git-filter-repo-$VERSION.tar.xz asset as well:\n#    curl -s -H \"Authorization: token $GITHUB_COM_TOKEN\" -X GET \\\n#        https://api.github.com/repos/newren/git-filter-repo/releases\n# and look for the \"id\", then run\n#    curl -s -H \"Authorization: token $GITHUB_COM_TOKEN\" -X DELETE \\\n#        https://api.github.com/repos/newren/git-filter-repo/releases/$ID\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.068359375,
          "content": "git filter-repo is a versatile tool for rewriting history, which includes\n[capabilities I have not found anywhere\nelse](#design-rationale-behind-filter-repo).  It roughly falls into the\nsame space of tool as [git\nfilter-branch](https://git-scm.com/docs/git-filter-branch) but without the\ncapitulation-inducing poor\n[performance](https://public-inbox.org/git/CABPp-BGOz8nks0+Tdw5GyGqxeYR-3FF6FT5JcgVqZDYVRQ6qog@mail.gmail.com/),\nwith far more capabilities, and with a design that scales usability-wise\nbeyond trivial rewriting cases.  [git filter-repo is now recommended by the\ngit project](https://git-scm.com/docs/git-filter-branch#_warning) instead\nof git filter-branch.\n\nWhile most users will probably just use filter-repo as a simple command\nline tool (and likely only use a few of its flags), at its core filter-repo\ncontains a library for creating history rewriting tools.  As such, users\nwith specialized needs can leverage it to quickly create [entirely new\nhistory rewriting tools](contrib/filter-repo-demos).\n\n# Table of Contents\n\n  * [Prerequisites](#prerequisites)\n  * [How do I install it?](#how-do-i-install-it)\n  * [How do I use it?](#how-do-i-use-it)\n  * [Why filter-repo instead of other alternatives?](#why-filter-repo-instead-of-other-alternatives)\n    * [filter-branch](#filter-branch)\n    * [BFG Repo Cleaner](#bfg-repo-cleaner)\n  * [Simple example, with comparisons](#simple-example-with-comparisons)\n    * [Solving this with filter-repo](#solving-this-with-filter-repo)\n    * [Solving this with BFG Repo Cleaner](#solving-this-with-bfg-repo-cleaner)\n    * [Solving this with filter-branch](#solving-this-with-filter-branch)\n    * [Solving this with fast-export/fast-import](#solving-this-with-fast-exportfast-import)\n  * [Design rationale behind filter-repo](#design-rationale-behind-filter-repo)\n  * [How do I contribute?](#how-do-i-contribute)\n  * [Is there a Code of Conduct?](#is-there-a-code-of-conduct)\n  * [Upstream Improvements](#upstream-improvements)\n\n# Prerequisites\n\nfilter-repo requires:\n\n  * git >= 2.22.0 at a minimum; [some features](#upstream-improvements)\n    require git >= 2.24.0 or later\n  * python3 >= 3.6\n\n# How do I install it?\n\nWhile the `git-filter-repo` repository has many files, the main logic\nis all contained in a single-file python script named\n`git-filter-repo`, which was done to make installation for basic use\non many systems trivial: just place that one file into your $PATH.\n\nSee [INSTALL.md](INSTALL.md) for things beyond basic usage or special\ncases.  The more involved instructions are only needed if one of the\nfollowing apply:\n\n  * you do not find the above comment about trivial installation intuitively\n    obvious\n  * you are working with a python3 executable named something other than\n    \"python3\"\n  * you want to install documentation (beyond the builtin docs shown with -h)\n  * you want to run some of the [contrib](contrib/filter-repo-demos/) examples\n  * you want to create your own python filtering scripts using filter-repo as\n    a module/library\n\n# How do I use it?\n\nFor comprehensive documentation:\n  * see the [user manual](https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html)\n  * alternative formating of the user manual is available on various\n    external sites\n    ([example](https://www.mankier.com/1/git-filter-repo)), for those\n    that don't like the htmlpreview.github.io layout, though it may\n    only be up-to-date as of the latest release\n\nIf you prefer learning from examples:\n  * there is a [cheat sheet for converting filter-branch\n    commands](Documentation/converting-from-filter-branch.md#cheat-sheet-conversion-of-examples-from-the-filter-branch-manpage),\n    which covers every example from the filter-branch manual\n  * there is a [cheat sheet for converting BFG Repo Cleaner\n    commands](Documentation/converting-from-bfg-repo-cleaner.md#cheat-sheet-conversion-of-examples-from-bfg),\n    which covers every example from the BFG website\n  * the [simple example](#simple-example-with-comparisons) below may\n    be of interest\n  * the user manual has an extensive [examples\nsection](https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html#EXAMPLES)\n  * I have collected a set of [example filterings based on user-filed issues](Documentation/examples-from-user-filed-issues.md)\n\nIn either case, you may also find the [Frequently Answered Questions](Documentation/FAQ.md) useful.\n\n# Why filter-repo instead of other alternatives?\n\nThis was covered in more detail in a [Git Rev News article on\nfilter-repo](https://git.github.io/rev_news/2019/08/21/edition-54/#an-introduction-to-git-filter-repo--written-by-elijah-newren),\nbut some highlights for the main competitors:\n\n## filter-branch\n\n  * filter-branch is [extremely to unusably\n    slow](https://public-inbox.org/git/CABPp-BGOz8nks0+Tdw5GyGqxeYR-3FF6FT5JcgVqZDYVRQ6qog@mail.gmail.com/)\n    ([multiple orders of magnitude slower than it should\n    be](https://git-scm.com/docs/git-filter-branch#PERFORMANCE))\n    for non-trivial repositories.\n\n  * [filter-branch is riddled with\n    gotchas](https://git-scm.com/docs/git-filter-branch#SAFETY) that can\n    silently corrupt your rewrite or at least thwart your \"cleanup\"\n    efforts by giving you something more problematic and messy than what\n    you started with.\n\n  * filter-branch is [very onerous](#simple-example-with-comparisons)\n    [to\n    use](https://github.com/newren/git-filter-repo/blob/a6a6a1b0f62d365bbe2e76f823e1621857ec4dbd/contrib/filter-repo-demos/filter-lamely#L9-L61)\n    for any rewrite which is even slightly non-trivial.\n\n  * the git project has stated that the above issues with filter-branch\n    cannot be backward compatibly fixed; they recommend that you [stop\n    using\n    filter-branch](https://git-scm.com/docs/git-filter-branch#_warning)\n\n  * die-hard fans of filter-branch may be interested in\n    [filter-lamely](contrib/filter-repo-demos/filter-lamely)\n    (a.k.a. [filter-branch-ish](contrib/filter-repo-demos/filter-branch-ish)),\n    a reimplementation of filter-branch based on filter-repo which is\n    more performant (though not nearly as fast or safe as\n    filter-repo).\n\n  * a [cheat\n    sheet](Documentation/converting-from-filter-branch.md#cheat-sheet-conversion-of-examples-from-the-filter-branch-manpage)\n    is available showing how to convert example commands from the manual of\n    filter-branch into filter-repo commands.\n\n## BFG Repo Cleaner\n\n  * great tool for its time, but while it makes some things simple, it\n    is limited to a few kinds of rewrites.\n\n  * its architecture is not amenable to handling more types of\n    rewrites.\n\n  * its architecture presents some shortcomings and bugs even for its\n    intended usecase.\n\n  * fans of bfg may be interested in\n    [bfg-ish](contrib/filter-repo-demos/bfg-ish), a reimplementation of bfg\n    based on filter-repo which includes several new features and bugfixes\n    relative to bfg.\n\n  * a [cheat\n    sheet](Documentation/converting-from-bfg-repo-cleaner.md#cheat-sheet-conversion-of-examples-from-bfg)\n    is available showing how to convert example commands from the manual of\n    BFG Repo Cleaner into filter-repo commands.\n\n# Simple example, with comparisons\n\nLet's say that we want to extract a piece of a repository, with the intent\non merging just that piece into some other bigger repo.  For extraction, we\nwant to:\n\n  * extract the history of a single directory, src/.  This means that only\n    paths under src/ remain in the repo, and any commits that only touched\n    paths outside this directory will be removed.\n  * rename all files to have a new leading directory, my-module/ (e.g. so that\n    src/foo.c becomes my-module/src/foo.c)\n  * rename any tags in the extracted repository to have a 'my-module-'\n    prefix (to avoid any conflicts when we later merge this repo into\n    something else)\n\n## Solving this with filter-repo\n\nDoing this with filter-repo is as simple as the following command:\n```shell\n  git filter-repo --path src/ --to-subdirectory-filter my-module --tag-rename '':'my-module-'\n```\n(the single quotes are unnecessary, but make it clearer to a human that we\nare replacing the empty string as a prefix with `my-module-`)\n\n## Solving this with BFG Repo Cleaner\n\nBFG Repo Cleaner is not capable of this kind of rewrite; in fact, all\nthree types of wanted changes are outside of its capabilities.\n\n## Solving this with filter-branch\n\nfilter-branch comes with a pile of caveats (more on that below) even\nonce you figure out the necessary invocation(s):\n\n```shell\n  git filter-branch \\\n      --tree-filter 'mkdir -p my-module && \\\n                     git ls-files \\\n                         | grep -v ^src/ \\\n                         | xargs git rm -f -q && \\\n                     ls -d * \\\n                         | grep -v my-module \\\n                         | xargs -I files mv files my-module/' \\\n          --tag-name-filter 'echo \"my-module-$(cat)\"' \\\n\t  --prune-empty -- --all\n  git clone file://$(pwd) newcopy\n  cd newcopy\n  git for-each-ref --format=\"delete %(refname)\" refs/tags/ \\\n      | grep -v refs/tags/my-module- \\\n      | git update-ref --stdin\n  git gc --prune=now\n```\n\nSome might notice that the above filter-branch invocation will be really\nslow due to using --tree-filter; you could alternatively use the\n--index-filter option of filter-branch, changing the above commands to:\n\n```shell\n  git filter-branch \\\n      --index-filter 'git ls-files \\\n                          | grep -v ^src/ \\\n                          | xargs git rm -q --cached;\n                      git ls-files -s \\\n                          | sed \"s%$(printf \\\\t)%&my-module/%\" \\\n                          | git update-index --index-info;\n                      git ls-files \\\n                          | grep -v ^my-module/ \\\n                          | xargs git rm -q --cached' \\\n      --tag-name-filter 'echo \"my-module-$(cat)\"' \\\n      --prune-empty -- --all\n  git clone file://$(pwd) newcopy\n  cd newcopy\n  git for-each-ref --format=\"delete %(refname)\" refs/tags/ \\\n      | grep -v refs/tags/my-module- \\\n      | git update-ref --stdin\n  git gc --prune=now\n```\n\nHowever, for either filter-branch command there are a pile of caveats.\nFirst, some may be wondering why I list five commands here for\nfilter-branch.  Despite the use of --all and --tag-name-filter, and\nfilter-branch's manpage claiming that a clone is enough to get rid of\nold objects, the extra steps to delete the other tags and do another\ngc are still required to clean out the old objects and avoid mixing\nnew and old history before pushing somewhere.  Other caveats:\n  * Commit messages are not rewritten; so if some of your commit\n    messages refer to prior commits by (abbreviated) sha1, after the\n    rewrite those messages will now refer to commits that are no longer\n    part of the history.  It would be better to rewrite those\n    (abbreviated) sha1 references to refer to the new commit ids.\n  * The --prune-empty flag sometimes misses commits that should be\n    pruned, and it will also prune commits that *started* empty rather\n    than just ended empty due to filtering.  For repositories that\n    intentionally use empty commits for versioning and publishing\n    related purposes, this can be detrimental.\n  * The commands above are OS-specific.  GNU vs. BSD issues for sed,\n    xargs, and other commands often trip up users; I think I failed to\n    get most folks to use --index-filter since the only example in the\n    filter-branch manpage that both uses it and shows how to move\n    everything into a subdirectory is linux-specific, and it is not\n    obvious to the reader that it has a portability issue since it\n    silently misbehaves rather than failing loudly.\n  * The --index-filter version of the filter-branch command may be two to\n    three times faster than the --tree-filter version, but both\n    filter-branch commands are going to be multiple orders of magnitude\n    slower than filter-repo.\n  * Both commands assume all filenames are composed entirely of ascii\n    characters (even special ascii characters such as tabs or double\n    quotes will wreak havoc and likely result in missing files or\n    misnamed files)\n\n## Solving this with fast-export/fast-import\n\nOne can kind of hack this together with something like:\n\n```shell\n  git fast-export --no-data --reencode=yes --mark-tags --fake-missing-tagger \\\n      --signed-tags=strip --tag-of-filtered-object=rewrite --all \\\n      | grep -vP '^M [0-9]+ [0-9a-f]+ (?!src/)' \\\n      | grep -vP '^D (?!src/)' \\\n      | perl -pe 's%^(M [0-9]+ [0-9a-f]+ )(.*)$%\\1my-module/\\2%' \\\n      | perl -pe 's%^(D )(.*)$%\\1my-module/\\2%' \\\n      | perl -pe s%refs/tags/%refs/tags/my-module-% \\\n      | git -c core.ignorecase=false fast-import --date-format=raw-permissive \\\n            --force --quiet\n  git for-each-ref --format=\"delete %(refname)\" refs/tags/ \\\n      | grep -v refs/tags/my-module- \\\n      | git update-ref --stdin\n  git reset --hard\n  git reflog expire --expire=now --all\n  git gc --prune=now\n```\n\nBut this comes with some nasty caveats and limitations:\n  * The various greps and regex replacements operate on the entire\n    fast-export stream and thus might accidentally corrupt unintended\n    portions of it, such as commit messages.  If you needed to edit\n    file contents and thus dropped the --no-data flag, it could also\n    end up corrupting file contents.\n  * This command assumes all filenames in the repository are composed\n    entirely of ascii characters, and also exclude special characters\n    such as tabs or double quotes.  If such a special filename exists\n    within the old src/ directory, it will be pruned even though it\n    was intended to be kept.  (In slightly different repository\n    rewrites, this type of editing also risks corrupting filenames\n    with special characters by adding extra double quotes near the end\n    of the filename and in some leading directory name.)\n  * This command will leave behind huge numbers of useless empty\n    commits, and has no realistic way of pruning them.  (And if you\n    tried to combine this technique with another tool to prune the\n    empty commits, then you now have no way to distinguish between\n    commits which were made empty by the filtering that you want to\n    remove, and commits which were empty before the filtering process\n    and which you thus may want to keep.)\n  * Commit messages which reference other commits by hash will now\n    reference old commits that no longer exist.  Attempting to edit\n    the commit messages to update them is extraordinarily difficult to\n    add to this kind of direct rewrite.\n\n# Design rationale behind filter-repo\n\nNone of the existing repository filtering tools did what I wanted;\nthey all came up short for my needs. No tool provided any of the\nfirst eight traits below I wanted, and no tool provided more than\ntwo of the last four traits either:\n\n  1. [Starting report] Provide user an analysis of their repo to help\n     them get started on what to prune or rename, instead of expecting\n     them to guess or find other tools to figure it out.  (Triggered, e.g.\n     by running the first time with a special flag, such as --analyze.)\n\n  1. [Keep vs. remove] Instead of just providing a way for users to\n     easily remove selected paths, also provide flags for users to\n     only *keep* certain paths.  Sure, users could workaround this by\n     specifying to remove all paths other than the ones they want to\n     keep, but the need to specify all paths that *ever* existed in\n     **any** version of the repository could sometimes be quite\n     painful.  For filter-branch, using pipelines like `git ls-files |\n     grep -v ... | xargs -r git rm` might be a reasonable workaround\n     but can get unwieldy and isn't as straightforward for users; plus\n     those commands are often operating-system specific (can you spot\n     the GNUism in the snippet I provided?).\n\n  1. [Renaming] It should be easy to rename paths.  For example, in\n     addition to allowing one to treat some subdirectory as the root\n     of the repository, also provide options for users to make the\n     root of the repository just become a subdirectory.  And more\n     generally allow files and directories to be easily renamed.\n     Provide sanity checks if renaming causes multiple files to exist\n     at the same path.  (And add special handling so that if a commit\n     merely copied oldname->newname without modification, then\n     filtering oldname->newname doesn't trigger the sanity check and\n     die on that commit.)\n\n  1. [More intelligent safety] Writing copies of the original refs to\n     a special namespace within the repo does not provide a\n     user-friendly recovery mechanism.  Many would struggle to recover\n     using that.  Almost everyone I've ever seen do a repository\n     filtering operation has done so with a fresh clone, because\n     wiping out the clone in case of error is a vastly easier recovery\n     mechanism.  Strongly encourage that workflow by [detecting and\n     bailing if we're not in a fresh\n     clone](https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html#FRESHCLONE),\n     unless the user overrides with --force.\n\n  1. [Auto shrink] Automatically remove old cruft and repack the\n     repository for the user after filtering (unless overridden); this\n     simplifies things for the user, helps avoid mixing old and new\n     history together, and avoids problems where the multi-step\n     process for shrinking the repo documented in the manpage doesn't\n     actually work in some cases.  (I'm looking at you,\n     filter-branch.)\n\n  1. [Clean separation] Avoid confusing users (and prevent accidental\n     re-pushing of old stuff) due to mixing old repo and rewritten\n     repo together.  (This is particularly a problem with filter-branch\n     when using the --tag-name-filter option, and sometimes also an\n     issue when only filtering a subset of branches.)\n\n  1. [Versatility] Provide the user the ability to extend the tool or\n     even write new tools that leverage existing capabilities, and\n     provide this extensibility in a way that (a) avoids the need to\n     fork separate processes (which would destroy performance), (b)\n     avoids making the user specify OS-dependent shell commands (which\n     would prevent users from sharing commands with each other), (c)\n     takes advantage of rich data structures (because hashes, dicts,\n     lists, and arrays are prohibitively difficult in shell) and (d)\n     provides reasonable string manipulation capabilities (which are\n     sorely lacking in shell).\n\n  1. [Old commit references] Provide a way for users to use old commit\n     IDs with the new repository (in particular via mapping from old to\n     new hashes with refs/replace/ references).\n\n  1. [Commit message consistency] If commit messages refer to other\n     commits by ID (e.g. \"this reverts commit 01234567890abcdef\", \"In\n     commit 0013deadbeef9a...\"), those commit messages should be\n     rewritten to refer to the new commit IDs.\n\n  1. [Become-empty pruning] Commits which become empty due to filtering\n     should be pruned.  If the parent of a commit is pruned, the first\n     non-pruned ancestor needs to become the new parent.  If no\n     non-pruned ancestor exists and the commit was not a merge, then it\n     becomes a new root commit.  If no non-pruned ancestor exists and\n     the commit was a merge, then the merge will have one less parent\n     (and thus make it likely to become a non-merge commit which would\n     itself be pruned if it had no file changes of its own).  One\n     special thing to note here is that we prune commits which become\n     empty, NOT commits which start empty.  Some projects intentionally\n     create empty commits for versioning or publishing reasons, and\n     these should not be removed.  (As a special case, commits which\n     started empty but whose parent was pruned away will also be\n     considered to have \"become empty\".)\n\n  1. [Become-degenerate pruning] Pruning of commits which become empty\n     can potentially cause topology changes, and there are lots of\n     special cases.  Normally, merge commits are not removed since they\n     are needed to preserve the graph topology, but the pruning of\n     parents and other ancestors can ultimately result in the loss of\n     one or more parents.  A simple case was already noted above: if a\n     merge commit loses enough parents to become a non-merge commit and\n     it has no file changes, then it too can be pruned.  Merge commits\n     can also have a topology that becomes degenerate: it could end up\n     with the merge_base serving as both parents (if all intervening\n     commits from the original repo were pruned), or it could end up\n     with one parent which is an ancestor of its other parent.  In such\n     cases, if the merge has no file changes of its own, then the merge\n     commit can also be pruned.  However, much as we do with empty\n     pruning we do not prune merge commits that started degenerate\n     (which indicates it may have been intentional, such as with --no-ff\n     merges) but only merge commits that become degenerate and have no\n     file changes of their own.\n\n  1. [Speed] Filtering should be reasonably fast\n\n# How do I contribute?\n\nSee the [contributing guidelines](Documentation/Contributing.md).\n\n# Is there a Code of Conduct?\n\nParticipants in the filter-repo community are expected to adhere to\nthe same standards as for the git project, so the [git Code of\nConduct](https://git.kernel.org/pub/scm/git/git.git/tree/CODE_OF_CONDUCT.md)\napplies.\n\n# Upstream Improvements\n\nWork on filter-repo and [its\npredecessor](https://public-inbox.org/git/51419b2c0904072035u1182b507o836a67ac308d32b9@mail.gmail.com/)\nhas also driven numerous improvements to fast-export and fast-import\n(and occasionally other commands) in core git, based on things\nfilter-repo needs to do its work:\n\n  * git-2.48.0 (to be released Jan 2025)\n    * [fast-import: disallow more path components](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=da91a90c2f)\n    * [fast-import: disallow \".\" and \"..\" path components](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=4a2790a257)\n    * [fast-import: avoid making replace refs point to themselves](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=5e904f1a4a)\n  * git-2.28.0\n    * [fast-import: add new --date-format=raw-permissive format](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=d42a2fb72f)\n  * git-2.24.0\n    * [fast-export: handle nested tags](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=941790d7de)\n    * [t9350: add tests for tags of things other than a commit](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=8d7d33c1ce)\n    * [fast-export: allow user to request tags be marked with --mark-tags](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=a1638cfe12)\n    * [fast-export: add support for --import-marks-if-exists](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=208d69246e)\n    * [fast-import: add support for new 'alias' command](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=b8f50e5b60)\n    * [fast-import: allow tags to be identified by mark labels](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=f73b2aba05)\n    * [fast-import: fix handling of deleted tags](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=3164e6bd24)\n    * [fast-export: fix exporting a tag and nothing else](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=af2abd870b)\n    * [git-fast-import.txt: clarify that multiple merge commits are allowed](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=d1387d3895)\n  * git-2.23.0\n    * [t9350: fix encoding test to actually test reencoding](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=32615ce762)\n    * [fast-import: support 'encoding' commit header](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=3edfcc65fd)\n    * [fast-export: avoid stripping encoding header if we cannot reencode](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=ccbfc96dc4)\n    * [fast-export: differentiate between explicitly UTF-8 and implicitly\n      UTF-8](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=57a8be2cb0)\n    * [fast-export: do automatic reencoding of commit messages only if\n      requested](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=e80001f8fd)\n  * git-2.22.0\n    * [log,diff-tree: add --combined-all-paths option](\n        https://git.kernel.org/pub/scm/git/git.git/commit/?id=d76ce4f734)\n    * [t9300: demonstrate bug with get-mark and empty orphan commits](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=62edbec7de)\n    * [git-fast-import.txt: fix wording about where ls command can appear](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=a63c54a019)\n    * [fast-import: check most prominent commands first](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=5056bb7646)\n    * [fast-import: only allow cat-blob requests where it makes sense](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=7ffde293f2)\n    * [fast-import: fix erroneous handling of get-mark with empty orphan\n      commits](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=cf7b857a77)\n    * [Honor core.precomposeUnicode in more places](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=8e712ef6fc)\n  * git-2.21.0\n    * [fast-export: convert sha1 to oid](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=843b9e6d48)\n    * [git-fast-import.txt: fix documentation for --quiet option](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=f55c979b14)\n    * [git-fast-export.txt: clarify misleading documentation about rev-list\n      args](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=4532be7cba)\n    * [fast-export: use value from correct enum](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=b93b81e799)\n    * [fast-export: avoid dying when filtering by paths and old tags exist](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=1f30c904b3)\n    * [fast-export: move commit rewriting logic into a function for reuse](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=f129c4275c)\n    * [fast-export: when using paths, avoid corrupt stream with non-existent\n      mark](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=cd13762d8f)\n    * [fast-export: ensure we export requested refs](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=fdf31b6369)\n    * [fast-export: add --reference-excluded-parents option](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=530ca19c02)\n    * [fast-import: remove unmaintained duplicate documentation](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=25dd3e4889)\n    * [fast-export: add a --show-original-ids option to show\n      original names](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=a965bb3116)\n    * [git-show-ref.txt: fix order of flags](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=bd8d6f0def)\n  * git-2.20.0\n    * [update-ref: fix type of update_flags variable to\n      match its usage](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=e4c34855a2)\n    * [update-ref: allow --no-deref with --stdin](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=d345e9fbe7)\n  * git-1.7.3\n    * [fast-export: Fix dropping of files with --import-marks and path\n      limiting](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=4087a02e45)\n    * [fast-export: Add a --full-tree option](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=7f40ab0916)\n    * [fast-export: Fix output order of D/F changes](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=060df62422)\n    * [fast-import: Improve robustness when D->F changes provided in wrong\n      order](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=253fb5f889)\n  * git-1.6.4:\n    * [fast-export: Set revs.topo_order before calling setup_revisions](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=668f3aa776)\n    * [fast-export: Omit tags that tag trees](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=02c48cd69b)\n    * [fast-export: Make sure we show actual ref names instead of \"(null)\"](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=2374502c6c)\n    * [fast-export: Do parent rewriting to avoid dropping relevant commits](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=32164131db)\n    * [fast-export: Add a --tag-of-filtered-object option for newly\n      dangling tags](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=2d8ad46919)\n    * [Add new fast-export testcases](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=25e0ca5dd6)\n    * [fast-export: Document the fact that git-rev-list arguments are\n      accepted](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=8af15d282e)\n  * git-1.6.3:\n    * [git-filter-branch: avoid collisions with variables in eval'ed\n      commands](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=d5b0c97d13)\n    * [Correct missing SP characters in grammar comment at top of\n      fast-import.c](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=98e1a4186a)\n    * [fast-export: Avoid dropping files from commits](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=ebeec7dbc5)\n  * git-1.6.1.4:\n    * [fast-export: ensure we traverse commits in topological order](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=784f8affe4)\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "git-filter-repo",
          "type": "blob",
          "size": 205.9677734375,
          "content": "#!/usr/bin/env python3\n\n\"\"\"\ngit-filter-repo filters git repositories, similar to git filter-branch, BFG\nrepo cleaner, and others.  The basic idea is that it works by running\n   git fast-export <options> | filter | git fast-import <options>\nwhere this program not only launches the whole pipeline but also serves as\nthe 'filter' in the middle.  It does a few additional things on top as well\nin order to make it into a well-rounded filtering tool.\n\ngit-filter-repo can also be used as a library for more involved filtering\noperations; however:\n  ***** API BACKWARD COMPATIBILITY CAVEAT *****\n  Programs using git-filter-repo as a library can reach pretty far into its\n  internals, but I am not prepared to guarantee backward compatibility of\n  all APIs.  I suspect changes will be rare, but I reserve the right to\n  change any API.  Since it is assumed that repository filtering is\n  something one would do very rarely, and in particular that it's a\n  one-shot operation, this should not be a problem in practice for anyone.\n  However, if you want to re-use a program you have written that uses\n  git-filter-repo as a library (or makes use of one of its --*-callback\n  arguments), you should either make sure you are using the same version of\n  git and git-filter-repo, or make sure to re-test it.\n\n  If there are particular pieces of the API you are concerned about, and\n  there is not already a testcase for it in t9391-lib-usage.sh or\n  t9392-python-callback.sh, please contribute a testcase.  That will not\n  prevent me from changing the API, but it will allow you to look at the\n  history of a testcase to see whether and how the API changed.\n  ***** END API BACKWARD COMPATIBILITY CAVEAT *****\n\"\"\"\n\nimport argparse\nimport collections\nimport fnmatch\nimport gettext\nimport io\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport time\nimport textwrap\n\nfrom datetime import tzinfo, timedelta, datetime\n\n__all__ = [\"Blob\", \"Reset\", \"FileChange\", \"Commit\", \"Tag\", \"Progress\",\n           \"Checkpoint\", \"FastExportParser\", \"ProgressWriter\",\n           \"string_to_date\", \"date_to_string\",\n           \"record_id_rename\", \"GitUtils\", \"FilteringOptions\", \"RepoFilter\"]\n\n# The globals to make visible to callbacks. They will see all our imports for\n# free, as well as our public API.\npublic_globals = [\"__builtins__\", \"argparse\", \"collections\", \"fnmatch\",\n                  \"gettext\", \"io\", \"os\", \"platform\", \"re\", \"shutil\",\n                  \"subprocess\", \"sys\", \"time\", \"textwrap\", \"tzinfo\",\n                  \"timedelta\", \"datetime\"] + __all__\n\ndeleted_hash = b'0'*40\nwrite_marks = True\ndate_format_permissive = True\n\ndef gettext_poison(msg):\n  if \"GIT_TEST_GETTEXT_POISON\" in os.environ: # pragma: no cover\n    return \"# GETTEXT POISON #\"\n  return gettext.gettext(msg)\n\n_ = gettext_poison\n\ndef setup_gettext():\n  TEXTDOMAIN=\"git-filter-repo\"\n  podir = os.environ.get(\"GIT_TEXTDOMAINDIR\") or \"@@LOCALEDIR@@\"\n  if not os.path.isdir(podir): # pragma: no cover\n    podir = None  # Python has its own fallback; use that\n\n  ## This looks like the most straightforward translation of the relevant\n  ## code in git.git:gettext.c and git.git:perl/Git/I18n.pm:\n  #import locale\n  #locale.setlocale(locale.LC_MESSAGES, \"\");\n  #locale.setlocale(locale.LC_TIME, \"\");\n  #locale.textdomain(TEXTDOMAIN);\n  #locale.bindtextdomain(TEXTDOMAIN, podir);\n  ## but the python docs suggest using the gettext module (which doesn't\n  ## have setlocale()) instead, so:\n  gettext.textdomain(TEXTDOMAIN);\n  gettext.bindtextdomain(TEXTDOMAIN, podir);\n\ndef _timedelta_to_seconds(delta):\n  \"\"\"\n  Converts timedelta to seconds\n  \"\"\"\n  offset = delta.days*86400 + delta.seconds + (delta.microseconds+0.0)/1000000\n  return round(offset)\n\nclass FixedTimeZone(tzinfo):\n  \"\"\"\n  Fixed offset in minutes east from UTC.\n  \"\"\"\n\n  tz_re = re.compile(br'^([-+]?)(\\d\\d)(\\d\\d)$')\n\n  def __init__(self, offset_string):\n    tzinfo.__init__(self)\n    sign, hh, mm = FixedTimeZone.tz_re.match(offset_string).groups()\n    factor = -1 if (sign and sign == b'-') else 1\n    self._offset = timedelta(minutes = factor*(60*int(hh) + int(mm)))\n    self._offset_string = offset_string\n\n  def utcoffset(self, dt):\n    return self._offset\n\n  def tzname(self, dt):\n    return self._offset_string\n\n  def dst(self, dt):\n    return timedelta(0)\n\ndef string_to_date(datestring):\n  (unix_timestamp, tz_offset) = datestring.split()\n  return datetime.fromtimestamp(int(unix_timestamp),\n                                FixedTimeZone(tz_offset))\n\ndef date_to_string(dateobj):\n  epoch = datetime.fromtimestamp(0, dateobj.tzinfo)\n  return(b'%d %s' % (int(_timedelta_to_seconds(dateobj - epoch)),\n                     dateobj.tzinfo.tzname(0)))\n\ndef decode(bytestr):\n  'Try to convert bytestr to utf-8 for outputting as an error message.'\n  return bytestr.decode('utf-8', 'backslashreplace')\n\ndef glob_to_regex(glob_bytestr):\n  'Translate glob_bytestr into a regex on bytestrings'\n\n  # fnmatch.translate is idiotic and won't accept bytestrings\n  if (decode(glob_bytestr).encode() != glob_bytestr): # pragma: no cover\n    raise SystemExit(_(\"Error: Cannot handle glob %s\").format(glob_bytestr))\n\n  # Create regex operating on string\n  regex = fnmatch.translate(decode(glob_bytestr))\n\n  # FIXME: This is an ugly hack...\n  # fnmatch.translate tries to do multi-line matching and wants the glob to\n  # match up to the end of the input, which isn't relevant for us, so we\n  # have to modify the regex.  fnmatch.translate has used different regex\n  # constructs to achieve this with different python versions, so we have\n  # to check for each of them and then fix it up.  It would be much better\n  # if fnmatch.translate could just take some flags to allow us to specify\n  # what we want rather than employing this hackery, but since it\n  # doesn't...\n  if regex.endswith(r'\\Z(?ms)'): # pragma: no cover\n    regex = regex[0:-7]\n  elif regex.startswith(r'(?s:') and regex.endswith(r')\\Z'): # pragma: no cover\n    regex = regex[4:-3]\n\n  # Finally, convert back to regex operating on bytestr\n  return regex.encode()\n\nclass PathQuoting:\n  _unescape = {b'a': b'\\a',\n               b'b': b'\\b',\n               b'f': b'\\f',\n               b'n': b'\\n',\n               b'r': b'\\r',\n               b't': b'\\t',\n               b'v': b'\\v',\n               b'\"': b'\"',\n               b'\\\\':b'\\\\'}\n  _unescape_re = re.compile(br'\\\\([a-z\"\\\\]|[0-9]{3})')\n  _escape = [bytes([x]) for x in range(127)]+[\n             b'\\\\'+bytes(ord(c) for c in oct(x)[2:]) for x in range(127,256)]\n  _reverse = dict(map(reversed, _unescape.items()))\n  for x in _reverse:\n    _escape[ord(x)] = b'\\\\'+_reverse[x]\n  _special_chars = [len(x) > 1 for x in _escape]\n\n  @staticmethod\n  def unescape_sequence(orig):\n    seq = orig.group(1)\n    return PathQuoting._unescape[seq] if len(seq) == 1 else bytes([int(seq, 8)])\n\n  @staticmethod\n  def dequote(quoted_string):\n    if quoted_string.startswith(b'\"'):\n      assert quoted_string.endswith(b'\"')\n      return PathQuoting._unescape_re.sub(PathQuoting.unescape_sequence,\n                                          quoted_string[1:-1])\n    return quoted_string\n\n  @staticmethod\n  def enquote(unquoted_string):\n    # Option 1: Quoting when fast-export would:\n    #    pqsc = PathQuoting._special_chars\n    #    if any(pqsc[x] for x in set(unquoted_string)):\n    # Option 2, perf hack: do minimal amount of quoting required by fast-import\n    if unquoted_string.startswith(b'\"') or b'\\n' in unquoted_string:\n      pqe = PathQuoting._escape\n      return b'\"' + b''.join(pqe[x] for x in unquoted_string) + b'\"'\n    return unquoted_string\n\nclass AncestryGraph(object):\n  \"\"\"\n  A class that maintains a direct acycle graph of commits for the purpose of\n  determining if one commit is the ancestor of another.\n\n  A note about identifiers in Commit objects:\n    * Commit objects have 2 identifiers: commit.old_id and commit.id, because:\n    * The original fast-export stream identified commits by an identifier.\n      This is often an integer, but is sometimes a hash (particularly when\n      --reference-excluded-parents is provided)\n    * The new fast-import stream we use may not use the same identifiers.\n      If new blobs or commits are inserted (such as lint-history does), then\n      the integer (or hash) are no longer valid.\n\n  A note about identifiers in AncestryGraph objects, of which there are three:\n    * A given AncestryGraph is based on either commit.old_id or commit.id, but\n      not both.  These are the keys for self.value.\n    * Using full hashes (occasionally) for children in self.graph felt\n      wasteful, so we use our own internal integer within self.graph.\n      self.value maps from commit {old_}id to our internal integer id.\n    * When working with commit.old_id, it is also sometimes useful to be able\n      to map these to the original hash, i.e. commit.original_id.  So, we\n      also have self.git_hash for mapping from commit.old_id to git's commit\n      hash.\n  \"\"\"\n\n  def __init__(self):\n    # The next internal identifier we will use; increments with every commit\n    # added to the AncestryGraph\n    self.cur_value = 0\n\n    # A mapping from the external identifers given to us to the simple integers\n    # we use in self.graph\n    self.value = {}\n\n    # A tuple of (depth, list-of-ancestors).  Values and keys in this graph are\n    # all integers from the (values of the) self.value dict.  The depth of a\n    # commit is one more than the max depth of any of its ancestors.\n    self.graph = {}\n\n    # A mapping from external identifier (i.e. from the keys of self.value) to\n    # the hash of the given commit.  Only populated for graphs based on\n    # commit.old_id, since we won't know until later what the git_hash for\n    # graphs based on commit.id (since we have to wait for fast-import to\n    # create the commit and notify us of its hash; see _pending_renames).\n    # elsewhere\n    self.git_hash = {}\n\n    # Reverse maps; only populated if needed.  Caller responsible to check\n    # and ensure they are populated\n    self._reverse_value = {}\n    self._hash_to_id = {}\n\n    # Cached results from previous calls to is_ancestor().\n    self._cached_is_ancestor = {}\n\n  def record_external_commits(self, external_commits):\n    \"\"\"\n    Record in graph that each commit in external_commits exists, and is\n    treated as a root commit with no parents.\n    \"\"\"\n    for c in external_commits:\n      if c not in self.value:\n        self.cur_value += 1\n        self.value[c] = self.cur_value\n        self.graph[self.cur_value] = (1, [])\n        self.git_hash[c] = c\n\n  def add_commit_and_parents(self, commit, parents, githash = None):\n    \"\"\"\n    Record in graph that commit has the given parents (all identified by\n    fast export stream identifiers, usually integers but sometimes hashes).\n    parents _MUST_ have been first recorded.  commit _MUST_ not have been\n    recorded yet.  Also, record the mapping between commit and githash, if\n    githash is given.\n    \"\"\"\n    assert all(p in self.value for p in parents)\n    assert commit not in self.value\n\n    # Get values for commit and parents\n    self.cur_value += 1\n    self.value[commit] = self.cur_value\n    if githash:\n      self.git_hash[commit] = githash\n    graph_parents = [self.value[x] for x in parents]\n\n    # Determine depth for commit, then insert the info into the graph\n    depth = 1\n    if parents:\n      depth += max(self.graph[p][0] for p in graph_parents)\n    self.graph[self.cur_value] = (depth, graph_parents)\n\n  def record_hash(self, commit_id, githash):\n    '''\n    If a githash was not recorded for commit_id, when add_commit_and_parents\n    was called, add it now.\n    '''\n    assert commit_id in self.value\n    assert commit_id not in self.git_hash\n    self.git_hash[commit_id] = githash\n\n  def _ensure_reverse_maps_populated(self):\n    if not self._hash_to_id:\n      assert not self._reverse_value\n      self._hash_to_id = {v: k for k, v in self.git_hash.items()}\n      self._reverse_value = {v: k for k, v in self.value.items()}\n\n  def get_parent_hashes(self, commit_hash):\n    '''\n    Given a commit_hash, return its parents hashes\n    '''\n    #\n    # We have to map:\n    #    commit hash -> fast export stream id -> graph id\n    # then lookup\n    #    parent graph ids for given graph id\n    # then we need to map\n    #    parent graph ids -> parent fast export ids -> parent commit hashes\n    #\n    self._ensure_reverse_maps_populated()\n    commit_fast_export_id = self._hash_to_id[commit_hash]\n    commit_graph_id = self.value[commit_fast_export_id]\n    parent_graph_ids = self.graph[commit_graph_id][1]\n    parent_fast_export_ids = [self._reverse_value[x] for x in parent_graph_ids]\n    parent_hashes = [self.git_hash[x] for x in parent_fast_export_ids]\n    return parent_hashes\n\n  def map_to_hash(self, commit_id):\n    '''\n    Given a commit (by fast export stream id), return its hash\n    '''\n    return self.git_hash.get(commit_id, None)\n\n  def is_ancestor(self, possible_ancestor, check):\n    \"\"\"\n    Return whether possible_ancestor is an ancestor of check\n    \"\"\"\n    a, b = self.value[possible_ancestor], self.value[check]\n    original_pair = (a,b)\n    a_depth = self.graph[a][0]\n    ancestors = [b]\n    visited = set()\n    while ancestors:\n      ancestor = ancestors.pop()\n      prev_pair = (a, ancestor)\n      if prev_pair in self._cached_is_ancestor:\n        if not self._cached_is_ancestor[prev_pair]:\n          continue\n        self._cached_is_ancestor[original_pair] = True\n        return True\n      if ancestor in visited:\n        continue\n      visited.add(ancestor)\n      depth, more_ancestors = self.graph[ancestor]\n      if ancestor == a:\n        self._cached_is_ancestor[original_pair] = True\n        return True\n      elif depth <= a_depth:\n        continue\n      ancestors.extend(more_ancestors)\n    self._cached_is_ancestor[original_pair] = False\n    return False\n\nclass MailmapInfo(object):\n  def __init__(self, filename):\n    self.changes = {}\n    self._parse_file(filename)\n\n  def _parse_file(self, filename):\n    name_and_email_re = re.compile(br'(.*?)\\s*<([^>]*)>\\s*')\n    comment_re = re.compile(br'\\s*#.*')\n    if not os.access(filename, os.R_OK):\n      raise SystemExit(_(\"Cannot read %s\") % decode(filename))\n    with open(filename, 'br') as f:\n      count = 0\n      for line in f:\n        count += 1\n        err = \"Unparseable mailmap file: line #{} is bad: {}\".format(count, line)\n        # Remove comments\n        line = comment_re.sub(b'', line)\n        # Remove leading and trailing whitespace\n        line = line.strip()\n        if not line:\n          continue\n\n        m = name_and_email_re.match(line)\n        if not m:\n          raise SystemExit(err)\n        proper_name, proper_email = m.groups()\n        if len(line) == m.end():\n          self.changes[(None, proper_email)] = (proper_name, proper_email)\n          continue\n        rest = line[m.end():]\n        m = name_and_email_re.match(rest)\n        if m:\n          commit_name, commit_email = m.groups()\n          if len(rest) != m.end():\n            raise SystemExit(err)\n        else:\n          commit_name, commit_email = rest, None\n        self.changes[(commit_name, commit_email)] = (proper_name, proper_email)\n\n  def translate(self, name, email):\n    ''' Given a name and email, return the expected new name and email from the\n        mailmap if there is a translation rule for it, otherwise just return\n        the given name and email.'''\n    for old, new in self.changes.items():\n      old_name, old_email = old\n      new_name, new_email = new\n      if (old_email is None or email.lower() == old_email.lower()) and (\n          name == old_name or not old_name):\n        return (new_name or name, new_email or email)\n    return (name, email)\n\nclass ProgressWriter(object):\n  def __init__(self):\n    self._last_progress_update = time.time()\n    self._last_message = None\n\n  def show(self, msg):\n    self._last_message = msg\n    now = time.time()\n    if now - self._last_progress_update > .1:\n      self._last_progress_update = now\n      sys.stdout.write(\"\\r{}\".format(msg))\n      sys.stdout.flush()\n\n  def finish(self):\n    self._last_progress_update = 0\n    if self._last_message:\n      self.show(self._last_message)\n    sys.stdout.write(\"\\n\")\n\nclass _IDs(object):\n  \"\"\"\n  A class that maintains the 'name domain' of all the 'marks' (short int\n  id for a blob/commit git object). There are two reasons this mechanism\n  is necessary:\n    (1) the output text of fast-export may refer to an object using a different\n        mark than the mark that was assigned to that object using IDS.new().\n        (This class allows you to translate the fast-export marks, \"old\" to\n         the marks assigned from IDS.new(), \"new\").\n    (2) when we prune a commit, its \"old\" id becomes invalid.  Any commits\n        which had that commit as a parent needs to use the nearest unpruned\n        ancestor as its parent instead.\n\n  Note that for purpose (1) above, this typically comes about because the user\n  manually creates Blob or Commit objects (for insertion into the stream).\n  It could also come about if we attempt to read the data from two different\n  repositories and trying to combine the data (git fast-export will number ids\n  from 1...n, and having two 1's, two 2's, two 3's, causes issues; granted, we\n  this scheme doesn't handle the two streams perfectly either, but if the first\n  fast export stream is entirely processed and handled before the second stream\n  is started, this mechanism may be sufficient to handle it).\n  \"\"\"\n\n  def __init__(self):\n    \"\"\"\n    Init\n    \"\"\"\n    # The id for the next created blob/commit object\n    self._next_id = 1\n\n    # A map of old-ids to new-ids (1:1 map)\n    self._translation = {}\n\n    # A map of new-ids to every old-id that points to the new-id (1:N map)\n    self._reverse_translation = {}\n\n  def has_renames(self):\n    \"\"\"\n    Return whether there have been ids remapped to new values\n    \"\"\"\n    return bool(self._translation)\n\n  def new(self):\n    \"\"\"\n    Should be called whenever a new blob or commit object is created. The\n    returned value should be used as the id/mark for that object.\n    \"\"\"\n    rv = self._next_id\n    self._next_id += 1\n    return rv\n\n  def record_rename(self, old_id, new_id, handle_transitivity = False):\n    \"\"\"\n    Record that old_id is being renamed to new_id.\n    \"\"\"\n    if old_id != new_id or old_id in self._translation:\n      # old_id -> new_id\n      self._translation[old_id] = new_id\n\n      # Transitivity will be needed if new commits are being inserted mid-way\n      # through a branch.\n      if handle_transitivity:\n        # Anything that points to old_id should point to new_id\n        if old_id in self._reverse_translation:\n          for id_ in self._reverse_translation[old_id]:\n            self._translation[id_] = new_id\n\n      # Record that new_id is pointed to by old_id\n      if new_id not in self._reverse_translation:\n        self._reverse_translation[new_id] = []\n      self._reverse_translation[new_id].append(old_id)\n\n  def translate(self, old_id):\n    \"\"\"\n    If old_id has been mapped to an alternate id, return the alternate id.\n    \"\"\"\n    if old_id in self._translation:\n      return self._translation[old_id]\n    else:\n      return old_id\n\n  def __str__(self):\n    \"\"\"\n    Convert IDs to string; used for debugging\n    \"\"\"\n    rv = \"Current count: %d\\nTranslation:\\n\" % self._next_id\n    for k in sorted(self._translation):\n      rv += \"  %d -> %s\\n\" % (k, self._translation[k])\n\n    rv += \"Reverse translation:\\n\"\n    reverse_keys = list(self._reverse_translation.keys())\n    if None in reverse_keys: # pragma: no cover\n      reverse_keys.remove(None)\n      reverse_keys = sorted(reverse_keys)\n      reverse_keys.append(None)\n    for k in reverse_keys:\n      rv += \"  \" + str(k) + \" -> \" + str(self._reverse_translation[k]) + \"\\n\"\n\n    return rv\n\nclass _GitElement(object):\n  \"\"\"\n  The base class for all git elements that we create.\n  \"\"\"\n\n  def __init__(self):\n    # A string that describes what type of Git element this is\n    self.type = None\n\n    # A flag telling us if this Git element has been dumped\n    # (i.e. printed) or skipped.  Typically elements that have been\n    # dumped or skipped will not be dumped again.\n    self.dumped = 0\n\n  def dump(self, file_):\n    \"\"\"\n    This version should never be called. Derived classes need to\n    override! We should note that subclasses should implement this\n    method such that the output would match the format produced by\n    fast-export.\n    \"\"\"\n    raise SystemExit(_(\"Unimplemented function: %s\") % type(self).__name__\n                     +\".dump()\") # pragma: no cover\n\n  def __bytes__(self):\n    \"\"\"\n    Convert GitElement to bytestring; used for debugging\n    \"\"\"\n    old_dumped = self.dumped\n    writeme = io.BytesIO()\n    self.dump(writeme)\n    output_lines = writeme.getvalue().splitlines()\n    writeme.close()\n    self.dumped = old_dumped\n    return b\"%s:\\n  %s\" % (type(self).__name__.encode(),\n                           b\"\\n  \".join(output_lines))\n\n  def skip(self, new_id=None):\n    \"\"\"\n    Ensures this element will not be written to output\n    \"\"\"\n    self.dumped = 2\n\nclass _GitElementWithId(_GitElement):\n  \"\"\"\n  The base class for Git elements that have IDs (commits and blobs)\n  \"\"\"\n\n  def __init__(self):\n    _GitElement.__init__(self)\n\n    # The mark (short, portable id) for this element\n    self.id = _IDS.new()\n\n    # The previous mark for this element\n    self.old_id = None\n\n  def skip(self, new_id=None):\n    \"\"\"\n    This element will no longer be automatically written to output. When a\n    commit gets skipped, it's ID will need to be translated to that of its\n    parent.\n    \"\"\"\n    self.dumped = 2\n\n    _IDS.record_rename(self.old_id or self.id, new_id)\n\nclass Blob(_GitElementWithId):\n  \"\"\"\n  This class defines our representation of git blob elements (i.e. our\n  way of representing file contents).\n  \"\"\"\n\n  def __init__(self, data, original_id = None):\n    _GitElementWithId.__init__(self)\n\n    # Denote that this is a blob\n    self.type = 'blob'\n\n    # Record original id\n    self.original_id = original_id\n\n    # Stores the blob's data\n    assert(type(data) == bytes)\n    self.data = data\n\n  def dump(self, file_):\n    \"\"\"\n    Write this blob element to a file.\n    \"\"\"\n    self.dumped = 1\n    BLOB_HASH_TO_NEW_ID[self.original_id] = self.id\n    BLOB_NEW_ID_TO_HASH[self.id] = self.original_id\n\n    file_.write(b'blob\\n')\n    file_.write(b'mark :%d\\n' % self.id)\n    file_.write(b'data %d\\n%s' % (len(self.data), self.data))\n    file_.write(b'\\n')\n\n\nclass Reset(_GitElement):\n  \"\"\"\n  This class defines our representation of git reset elements.  A reset\n  event is the creation (or recreation) of a named branch, optionally\n  starting from a specific revision).\n  \"\"\"\n\n  def __init__(self, ref, from_ref = None):\n    _GitElement.__init__(self)\n\n    # Denote that this is a reset\n    self.type = 'reset'\n\n    # The name of the branch being (re)created\n    self.ref = ref\n\n    # Some reference to the branch/commit we are resetting from\n    self.from_ref = from_ref\n\n  def dump(self, file_):\n    \"\"\"\n    Write this reset element to a file\n    \"\"\"\n    self.dumped = 1\n\n    file_.write(b'reset %s\\n' % self.ref)\n    if self.from_ref:\n      if isinstance(self.from_ref, int):\n        file_.write(b'from :%d\\n' % self.from_ref)\n      else:\n        file_.write(b'from %s\\n' % self.from_ref)\n      file_.write(b'\\n')\n\nclass FileChange(_GitElement):\n  \"\"\"\n  This class defines our representation of file change elements. File change\n  elements are components within a Commit element.\n  \"\"\"\n\n  def __init__(self, type_, filename = None, id_ = None, mode = None):\n    _GitElement.__init__(self)\n\n    # Denote the type of file-change (b'M' for modify, b'D' for delete, etc)\n    # We could\n    #   assert(type(type_) == bytes)\n    # here but I don't just due to worries about performance overhead...\n    self.type = type_\n\n    # Record the name of the file being changed\n    self.filename = filename\n\n    # Record the mode (mode describes type of file entry (non-executable,\n    # executable, or symlink)).\n    self.mode = mode\n\n    # blob_id is the id (mark) of the affected blob\n    self.blob_id = id_\n\n    if type_ == b'DELETEALL':\n      assert filename is None and id_ is None and mode is None\n      self.filename = b'' # Just so PathQuoting.enquote doesn't die\n    else:\n      assert filename is not None\n\n    if type_ == b'M':\n      assert id_ is not None and mode is not None\n    elif type_ == b'D':\n      assert id_ is None and mode is None\n    elif type_ == b'R':  # pragma: no cover (now avoid fast-export renames)\n      assert mode is None\n      if id_ is None:\n        raise SystemExit(_(\"new name needed for rename of %s\") % filename)\n      self.filename = (self.filename, id_)\n      self.blob_id = None\n\n  def dump(self, file_):\n    \"\"\"\n    Write this file-change element to a file\n    \"\"\"\n    skipped_blob = (self.type == b'M' and self.blob_id is None)\n    if skipped_blob: return\n    self.dumped = 1\n\n    quoted_filename = PathQuoting.enquote(self.filename)\n    if self.type == b'M' and isinstance(self.blob_id, int):\n      file_.write(b'M %s :%d %s\\n' % (self.mode, self.blob_id, quoted_filename))\n    elif self.type == b'M':\n      file_.write(b'M %s %s %s\\n' % (self.mode, self.blob_id, quoted_filename))\n    elif self.type == b'D':\n      file_.write(b'D %s\\n' % quoted_filename)\n    elif self.type == b'DELETEALL':\n      file_.write(b'deleteall\\n')\n    else:\n      raise SystemExit(_(\"Unhandled filechange type: %s\") % self.type) # pragma: no cover\n\nclass Commit(_GitElementWithId):\n  \"\"\"\n  This class defines our representation of commit elements. Commit elements\n  contain all the information associated with a commit.\n  \"\"\"\n\n  def __init__(self, branch,\n               author_name,    author_email,    author_date,\n               committer_name, committer_email, committer_date,\n               message,\n               file_changes,\n               parents,\n               original_id = None,\n               encoding = None, # encoding for message; None implies UTF-8\n               **kwargs):\n    _GitElementWithId.__init__(self)\n    self.old_id = self.id\n\n    # Denote that this is a commit element\n    self.type = 'commit'\n\n    # Record the affected branch\n    self.branch = branch\n\n    # Record original id\n    self.original_id = original_id\n\n    # Record author's name\n    self.author_name  = author_name\n\n    # Record author's email\n    self.author_email = author_email\n\n    # Record date of authoring\n    self.author_date  = author_date\n\n    # Record committer's name\n    self.committer_name  = committer_name\n\n    # Record committer's email\n    self.committer_email = committer_email\n\n    # Record date the commit was made\n    self.committer_date  = committer_date\n\n    # Record commit message and its encoding\n    self.encoding = encoding\n    self.message = message\n\n    # List of file-changes associated with this commit. Note that file-changes\n    # are also represented as git elements\n    self.file_changes = file_changes\n\n    self.parents = parents\n\n  def dump(self, file_):\n    \"\"\"\n    Write this commit element to a file.\n    \"\"\"\n    self.dumped = 1\n\n    # Make output to fast-import slightly easier for humans to read if the\n    # message has no trailing newline of its own; cosmetic, but a nice touch...\n    extra_newline = b'\\n'\n    if self.message.endswith(b'\\n') or not (self.parents or self.file_changes):\n      extra_newline = b''\n\n    if not self.parents:\n      file_.write(b'reset %s\\n' % self.branch)\n    file_.write((b'commit %s\\n'\n                 b'mark :%d\\n'\n                 b'author %s <%s> %s\\n'\n                 b'committer %s <%s> %s\\n'\n                ) % (\n                  self.branch, self.id,\n                  self.author_name, self.author_email, self.author_date,\n                  self.committer_name, self.committer_email, self.committer_date\n               ))\n    if self.encoding:\n      file_.write(b'encoding %s\\n' % self.encoding)\n    file_.write(b'data %d\\n%s%s' %\n                (len(self.message), self.message, extra_newline))\n    for i, parent in enumerate(self.parents):\n      file_.write(b'from ' if i==0 else b'merge ')\n      if isinstance(parent, int):\n        file_.write(b':%d\\n' % parent)\n      else:\n        file_.write(b'%s\\n' % parent)\n    for change in self.file_changes:\n      change.dump(file_)\n    if not self.parents and not self.file_changes:\n      # Workaround a bug in pre-git-2.22 versions of fast-import with\n      # the get-mark directive.\n      file_.write(b'\\n')\n    file_.write(b'\\n')\n\n  def first_parent(self):\n    \"\"\"\n    Return first parent commit\n    \"\"\"\n    if self.parents:\n      return self.parents[0]\n    return None\n\n  def skip(self, new_id=None):\n    _SKIPPED_COMMITS.add(self.old_id or self.id)\n    _GitElementWithId.skip(self, new_id)\n\nclass Tag(_GitElementWithId):\n  \"\"\"\n  This class defines our representation of annotated tag elements.\n  \"\"\"\n\n  def __init__(self, ref, from_ref,\n               tagger_name, tagger_email, tagger_date, tag_msg,\n               original_id = None):\n    _GitElementWithId.__init__(self)\n    self.old_id = self.id\n\n    # Denote that this is a tag element\n    self.type = 'tag'\n\n    # Store the name of the tag\n    self.ref = ref\n\n    # Store the entity being tagged (this should be a commit)\n    self.from_ref = from_ref\n\n    # Record original id\n    self.original_id = original_id\n\n    # Store the name of the tagger\n    self.tagger_name  = tagger_name\n\n    # Store the email of the tagger\n    self.tagger_email = tagger_email\n\n    # Store the date\n    self.tagger_date  = tagger_date\n\n    # Store the tag message\n    self.message = tag_msg\n\n  def dump(self, file_):\n    \"\"\"\n    Write this tag element to a file\n    \"\"\"\n\n    self.dumped = 1\n\n    file_.write(b'tag %s\\n' % self.ref)\n    if (write_marks and self.id):\n      file_.write(b'mark :%d\\n' % self.id)\n    markfmt = b'from :%d\\n' if isinstance(self.from_ref, int) else b'from %s\\n'\n    file_.write(markfmt % self.from_ref)\n    if self.tagger_name:\n      file_.write(b'tagger %s <%s> ' % (self.tagger_name, self.tagger_email))\n      file_.write(self.tagger_date)\n      file_.write(b'\\n')\n    file_.write(b'data %d\\n%s' % (len(self.message), self.message))\n    file_.write(b'\\n')\n\nclass Progress(_GitElement):\n  \"\"\"\n  This class defines our representation of progress elements. The progress\n  element only contains a progress message, which is printed by fast-import\n  when it processes the progress output.\n  \"\"\"\n\n  def __init__(self, message):\n    _GitElement.__init__(self)\n\n    # Denote that this is a progress element\n    self.type = 'progress'\n\n    # Store the progress message\n    self.message = message\n\n  def dump(self, file_):\n    \"\"\"\n    Write this progress element to a file\n    \"\"\"\n    self.dumped = 1\n\n    file_.write(b'progress %s\\n' % self.message)\n    file_.write(b'\\n')\n\nclass Checkpoint(_GitElement):\n  \"\"\"\n  This class defines our representation of checkpoint elements.  These\n  elements represent events which force fast-import to close the current\n  packfile, start a new one, and to save out all current branch refs, tags\n  and marks.\n  \"\"\"\n\n  def __init__(self):\n    _GitElement.__init__(self)\n\n    # Denote that this is a checkpoint element\n    self.type = 'checkpoint'\n\n  def dump(self, file_):\n    \"\"\"\n    Write this checkpoint element to a file\n    \"\"\"\n    self.dumped = 1\n\n    file_.write(b'checkpoint\\n')\n    file_.write(b'\\n')\n\nclass LiteralCommand(_GitElement):\n  \"\"\"\n  This class defines our representation of commands. The literal command\n  includes only a single line, and is not processed in any special way.\n  \"\"\"\n\n  def __init__(self, line):\n    _GitElement.__init__(self)\n\n    # Denote that this is a literal element\n    self.type = 'literal'\n\n    # Store the command\n    self.line = line\n\n  def dump(self, file_):\n    \"\"\"\n    Write this progress element to a file\n    \"\"\"\n    self.dumped = 1\n\n    file_.write(self.line)\n\nclass Alias(_GitElement):\n  \"\"\"\n  This class defines our representation of fast-import alias elements.  An\n  alias element is the setting of one mark to the same sha1sum as another,\n  usually because the newer mark corresponded to a pruned commit.\n  \"\"\"\n\n  def __init__(self, ref, to_ref):\n    _GitElement.__init__(self)\n    # Denote that this is a reset\n    self.type = 'alias'\n\n    self.ref = ref\n    self.to_ref = to_ref\n\n  def dump(self, file_):\n    \"\"\"\n    Write this reset element to a file\n    \"\"\"\n    self.dumped = 1\n\n    file_.write(b'alias\\nmark :%d\\nto :%d\\n\\n' % (self.ref, self.to_ref))\n\nclass FastExportParser(object):\n  \"\"\"\n  A class for parsing and handling the output from fast-export. This\n  class allows the user to register callbacks when various types of\n  data are encountered in the fast-export output. The basic idea is that,\n  FastExportParser takes fast-export output, creates the various objects\n  as it encounters them, the user gets to use/modify these objects via\n  callbacks, and finally FastExportParser outputs the modified objects\n  in fast-import format (presumably so they can be used to create a new\n  repo).\n  \"\"\"\n\n  def __init__(self,\n               tag_callback = None,   commit_callback = None,\n               blob_callback = None,  progress_callback = None,\n               reset_callback = None, checkpoint_callback = None,\n               done_callback = None):\n    # Members below simply store callback functions for the various git\n    # elements\n    self._tag_callback        = tag_callback\n    self._blob_callback       = blob_callback\n    self._reset_callback      = reset_callback\n    self._commit_callback     = commit_callback\n    self._progress_callback   = progress_callback\n    self._checkpoint_callback = checkpoint_callback\n    self._done_callback       = done_callback\n\n    # Keep track of which refs appear from the export, and which make it to\n    # the import (pruning of empty commits, renaming of refs, and creating\n    # new manual objects and inserting them can cause these to differ).\n    self._exported_refs = set()\n    self._imported_refs = set()\n\n    # A list of the branches we've seen, plus the last known commit they\n    # pointed to.  An entry in latest_*commit will be deleted if we get a\n    # reset for that branch.  These are used because of fast-import's weird\n    # decision to allow having an implicit parent via naming the branch\n    # instead of requiring branches to be specified via 'from' directives.\n    self._latest_commit = {}\n    self._latest_orig_commit = {}\n\n    # A handle to the input source for the fast-export data\n    self._input = None\n\n    # A handle to the output file for the output we generate (we call dump\n    # on many of the git elements we create).\n    self._output = None\n\n    # Stores the contents of the current line of input being parsed\n    self._currentline = ''\n\n    # Tracks LFS objects we have found\n    self._lfs_object_tracker = None\n\n    # Compile some regexes and cache those\n    self._mark_re = re.compile(br'mark :(\\d+)\\n$')\n    self._parent_regexes = {}\n    parent_regex_rules = (br' :(\\d+)\\n$', br' ([0-9a-f]{40})\\n')\n    for parent_refname in (b'from', b'merge'):\n      ans = [re.compile(parent_refname+x) for x in parent_regex_rules]\n      self._parent_regexes[parent_refname] = ans\n    self._quoted_string_re = re.compile(br'\"(?:[^\"\\\\]|\\\\.)*\"')\n    self._refline_regexes = {}\n    for refline_name in (b'reset', b'commit', b'tag', b'progress'):\n      self._refline_regexes[refline_name] = re.compile(refline_name+b' (.*)\\n$')\n    self._user_regexes = {}\n    for user in (b'author', b'committer', b'tagger'):\n      self._user_regexes[user] = re.compile(user + b' (.*?) <(.*?)> (.*)\\n$')\n\n  def _advance_currentline(self):\n    \"\"\"\n    Grab the next line of input\n    \"\"\"\n    self._currentline = self._input.readline()\n\n  def _parse_optional_mark(self):\n    \"\"\"\n    If the current line contains a mark, parse it and advance to the\n    next line; return None otherwise\n    \"\"\"\n    mark = None\n    matches = self._mark_re.match(self._currentline)\n    if matches:\n      mark = int(matches.group(1))\n      self._advance_currentline()\n    return mark\n\n  def _parse_optional_parent_ref(self, refname):\n    \"\"\"\n    If the current line contains a reference to a parent commit, then\n    parse it and advance the current line; otherwise return None. Note\n    that the name of the reference ('from', 'merge') must match the\n    refname arg.\n    \"\"\"\n    orig_baseref, baseref = None, None\n    rule, altrule = self._parent_regexes[refname]\n    matches = rule.match(self._currentline)\n    if matches:\n      orig_baseref = int(matches.group(1))\n      # We translate the parent commit mark to what it needs to be in\n      # our mark namespace\n      baseref = _IDS.translate(orig_baseref)\n      self._advance_currentline()\n    else:\n      matches = altrule.match(self._currentline)\n      if matches:\n        orig_baseref = matches.group(1)\n        baseref = orig_baseref\n        self._advance_currentline()\n    return orig_baseref, baseref\n\n  def _parse_optional_filechange(self):\n    \"\"\"\n    If the current line contains a file-change object, then parse it\n    and advance the current line; otherwise return None. We only care\n    about file changes of type b'M' and b'D' (these are the only types\n    of file-changes that fast-export will provide).\n    \"\"\"\n    filechange = None\n    changetype = self._currentline[0:1]\n    if changetype == b'M':\n      (changetype, mode, idnum, path) = self._currentline.split(None, 3)\n      if idnum[0:1] == b':':\n        idnum = idnum[1:]\n      path = path.rstrip(b'\\n')\n      # Check for LFS objects from sources before we might toss this filechange\n      if self._lfs_object_tracker:\n        value = int(idnum) if len(idnum) != 40 else idnum\n        self._lfs_object_tracker.check_file_change_data(value, True)\n      # We translate the idnum to our id system\n      if len(idnum) != 40:\n        idnum = _IDS.translate( int(idnum) )\n      if idnum is not None:\n        if path.startswith(b'\"'):\n          path = PathQuoting.dequote(path)\n        filechange = FileChange(b'M', path, idnum, mode)\n      else:\n        filechange = b'skipped'\n      self._advance_currentline()\n    elif changetype == b'D':\n      (changetype, path) = self._currentline.split(None, 1)\n      path = path.rstrip(b'\\n')\n      if path.startswith(b'\"'):\n        path = PathQuoting.dequote(path)\n      filechange = FileChange(b'D', path)\n      self._advance_currentline()\n    elif changetype == b'R':  # pragma: no cover (now avoid fast-export renames)\n      rest = self._currentline[2:-1]\n      if rest.startswith(b'\"'):\n        m = self._quoted_string_re.match(rest)\n        if not m:\n          raise SystemExit(_(\"Couldn't parse rename source\"))\n        orig = PathQuoting.dequote(m.group(0))\n        new = rest[m.end()+1:]\n      else:\n        orig, new = rest.split(b' ', 1)\n      if new.startswith(b'\"'):\n        new = PathQuoting.dequote(new)\n      filechange = FileChange(b'R', orig, new)\n      self._advance_currentline()\n    return filechange\n\n  def _parse_original_id(self):\n    original_id = self._currentline[len(b'original-oid '):].rstrip()\n    self._advance_currentline()\n    return original_id\n\n  def _parse_encoding(self):\n    encoding = self._currentline[len(b'encoding '):].rstrip()\n    self._advance_currentline()\n    return encoding\n\n  def _parse_ref_line(self, refname):\n    \"\"\"\n    Parses string data (often a branch name) from current-line. The name of\n    the string data must match the refname arg. The program will crash if\n    current-line does not match, so current-line will always be advanced if\n    this method returns.\n    \"\"\"\n    matches = self._refline_regexes[refname].match(self._currentline)\n    if not matches:\n      raise SystemExit(_(\"Malformed %(refname)s line: '%(line)s'\") %\n                       ({'refname': refname, 'line':self._currentline})\n                       ) # pragma: no cover\n    ref = matches.group(1)\n    self._advance_currentline()\n    return ref\n\n  def _parse_user(self, usertype):\n    \"\"\"\n    Get user name, email, datestamp from current-line. Current-line will\n    be advanced.\n    \"\"\"\n    user_regex = self._user_regexes[usertype]\n    (name, email, when) = user_regex.match(self._currentline).groups()\n\n    self._advance_currentline()\n    return (name, email, when)\n\n  def _parse_data(self):\n    \"\"\"\n    Reads data from _input. Current-line will be advanced until it is beyond\n    the data.\n    \"\"\"\n    fields = self._currentline.split()\n    assert fields[0] == b'data'\n    size = int(fields[1])\n    data = self._input.read(size)\n    self._advance_currentline()\n    if self._currentline == b'\\n':\n      self._advance_currentline()\n    return data\n\n  def _parse_blob(self):\n    \"\"\"\n    Parse input data into a Blob object. Once the Blob has been created, it\n    will be handed off to the appropriate callbacks. Current-line will be\n    advanced until it is beyond this blob's data. The Blob will be dumped\n    to _output once everything else is done (unless it has been skipped by\n    the callback).\n    \"\"\"\n    # Parse the Blob\n    self._advance_currentline()\n    id_ = self._parse_optional_mark()\n\n    original_id = None\n    if self._currentline.startswith(b'original-oid'):\n      original_id = self._parse_original_id();\n\n    data = self._parse_data()\n    if self._currentline == b'\\n':\n      self._advance_currentline()\n\n    # Create the blob\n    blob = Blob(data, original_id)\n\n    # If fast-export text had a mark for this blob, need to make sure this\n    # mark translates to the blob's true id.\n    if id_:\n      blob.old_id = id_\n      _IDS.record_rename(id_, blob.id)\n\n    # Check for LFS objects\n    if self._lfs_object_tracker:\n      self._lfs_object_tracker.check_blob_data(data, blob.old_id, True)\n\n    # Call any user callback to allow them to use/modify the blob\n    if self._blob_callback:\n      self._blob_callback(blob)\n\n    # Now print the resulting blob\n    if not blob.dumped:\n      blob.dump(self._output)\n\n  def _parse_reset(self):\n    \"\"\"\n    Parse input data into a Reset object. Once the Reset has been created,\n    it will be handed off to the appropriate callbacks. Current-line will\n    be advanced until it is beyond the reset data. The Reset will be dumped\n    to _output once everything else is done (unless it has been skipped by\n    the callback).\n    \"\"\"\n    # Parse the Reset\n    ref = self._parse_ref_line(b'reset')\n    self._exported_refs.add(ref)\n    ignoreme, from_ref = self._parse_optional_parent_ref(b'from')\n    if self._currentline == b'\\n':\n      self._advance_currentline()\n\n    # fast-export likes to print extraneous resets that serve no purpose.\n    # While we could continue processing such resets, that is a waste of\n    # resources.  Also, we want to avoid recording that this ref was\n    # seen in such cases, since this ref could be rewritten to nothing.\n    if not from_ref:\n      self._latest_commit.pop(ref, None)\n      self._latest_orig_commit.pop(ref, None)\n      return\n\n    # Create the reset\n    reset = Reset(ref, from_ref)\n\n    # Call any user callback to allow them to modify the reset\n    if self._reset_callback:\n      self._reset_callback(reset)\n\n    # Update metadata\n    self._latest_commit[reset.ref] = reset.from_ref\n    self._latest_orig_commit[reset.ref] = reset.from_ref\n\n    # Now print the resulting reset\n    if not reset.dumped:\n      self._imported_refs.add(reset.ref)\n      reset.dump(self._output)\n\n  def _parse_commit(self):\n    \"\"\"\n    Parse input data into a Commit object. Once the Commit has been created,\n    it will be handed off to the appropriate callbacks. Current-line will\n    be advanced until it is beyond the commit data. The Commit will be dumped\n    to _output once everything else is done (unless it has been skipped by\n    the callback OR the callback has removed all file-changes from the commit).\n    \"\"\"\n    # Parse the Commit. This may look involved, but it's pretty simple; it only\n    # looks bad because a commit object contains many pieces of data.\n    branch = self._parse_ref_line(b'commit')\n    self._exported_refs.add(branch)\n    id_ = self._parse_optional_mark()\n\n    original_id = None\n    if self._currentline.startswith(b'original-oid'):\n      original_id = self._parse_original_id();\n\n    author_name = None\n    author_email = None\n    if self._currentline.startswith(b'author'):\n      (author_name, author_email, author_date) = self._parse_user(b'author')\n\n    (committer_name, committer_email, committer_date) = \\\n      self._parse_user(b'committer')\n\n    if not author_name and not author_email:\n      (author_name, author_email, author_date) = \\\n        (committer_name, committer_email, committer_date)\n\n    encoding = None\n    if self._currentline.startswith(b'encoding '):\n      encoding = self._parse_encoding()\n\n    commit_msg = self._parse_data()\n\n    pinfo = [self._parse_optional_parent_ref(b'from')]\n    # Due to empty pruning, we can have real 'from' and 'merge' lines that\n    # due to commit rewriting map to a parent of None.  We need to record\n    # 'from' if its non-None, and we need to parse all 'merge' lines.\n    while self._currentline.startswith(b'merge '):\n      pinfo.append(self._parse_optional_parent_ref(b'merge'))\n    orig_parents, parents = [list(tmp) for tmp in zip(*pinfo)]\n\n    # No parents is oddly represented as [None] instead of [], due to the\n    # special 'from' handling.  Convert it here to a more canonical form.\n    if parents == [None]:\n      parents = []\n    if orig_parents == [None]:\n      orig_parents = []\n\n    # fast-import format is kinda stupid in that it allows implicit parents\n    # based on the branch name instead of requiring them to be specified by\n    # 'from' directives.  The only way to get no parent is by using a reset\n    # directive first, which clears the latest_commit_for_this_branch tracking.\n    if not orig_parents and self._latest_commit.get(branch):\n      parents = [self._latest_commit[branch]]\n    if not orig_parents and self._latest_orig_commit.get(branch):\n      orig_parents = [self._latest_orig_commit[branch]]\n\n    # Get the list of file changes\n    file_changes = []\n    file_change = self._parse_optional_filechange()\n    had_file_changes = file_change is not None\n    while file_change:\n      if not (type(file_change) == bytes and file_change == b'skipped'):\n        file_changes.append(file_change)\n      file_change = self._parse_optional_filechange()\n    if self._currentline == b'\\n':\n      self._advance_currentline()\n\n    # Okay, now we can finally create the Commit object\n    commit = Commit(branch,\n                    author_name,    author_email,    author_date,\n                    committer_name, committer_email, committer_date,\n                    commit_msg, file_changes, parents, original_id, encoding)\n\n    # If fast-export text had a mark for this commit, need to make sure this\n    # mark translates to the commit's true id.\n    if id_:\n      commit.old_id = id_\n      _IDS.record_rename(id_, commit.id)\n\n    # refs/notes/ put commit-message-related material in blobs, and name their\n    # files according to the hash of other commits.  That totally messes with\n    # all normal callbacks; fast-export should really export these as different\n    # kinds of objects.  Until then, let's just pass these commits through as-is\n    # and hope the blob callbacks don't mess things up.\n    if commit.branch.startswith(b'refs/notes/'):\n      self._imported_refs.add(commit.branch)\n      commit.dump(self._output)\n      return\n\n    # Call any user callback to allow them to modify the commit\n    aux_info = {'orig_parents': orig_parents,\n                'had_file_changes': had_file_changes}\n    if self._commit_callback:\n      self._commit_callback(commit, aux_info)\n\n    # Now print the resulting commit, or if prunable skip it\n    self._latest_orig_commit[branch] = commit.id\n    if not (commit.old_id or commit.id) in _SKIPPED_COMMITS:\n      self._latest_commit[branch] = commit.id\n    if not commit.dumped:\n      self._imported_refs.add(commit.branch)\n      commit.dump(self._output)\n\n  def _parse_tag(self):\n    \"\"\"\n    Parse input data into a Tag object. Once the Tag has been created,\n    it will be handed off to the appropriate callbacks. Current-line will\n    be advanced until it is beyond the tag data. The Tag will be dumped\n    to _output once everything else is done (unless it has been skipped by\n    the callback).\n    \"\"\"\n    # Parse the Tag\n    tag = self._parse_ref_line(b'tag')\n    self._exported_refs.add(b'refs/tags/'+tag)\n    id_ = self._parse_optional_mark()\n    ignoreme, from_ref = self._parse_optional_parent_ref(b'from')\n\n    original_id = None\n    if self._currentline.startswith(b'original-oid'):\n      original_id = self._parse_original_id();\n\n    tagger_name, tagger_email, tagger_date = None, None, None\n    if self._currentline.startswith(b'tagger'):\n      (tagger_name, tagger_email, tagger_date) = self._parse_user(b'tagger')\n    tag_msg = self._parse_data()\n    if self._currentline == b'\\n':\n      self._advance_currentline()\n\n    # Create the tag\n    tag = Tag(tag, from_ref,\n              tagger_name, tagger_email, tagger_date, tag_msg,\n              original_id)\n\n    # If fast-export text had a mark for this tag, need to make sure this\n    # mark translates to the tag's true id.\n    if id_:\n      tag.old_id = id_\n      _IDS.record_rename(id_, tag.id)\n\n    # Call any user callback to allow them to modify the tag\n    if self._tag_callback:\n      self._tag_callback(tag)\n\n    # The tag might not point at anything that still exists (self.from_ref\n    # will be None if the commit it pointed to and all its ancestors were\n    # pruned due to being empty)\n    if tag.from_ref:\n      # Print out this tag's information\n      if not tag.dumped:\n        self._imported_refs.add(b'refs/tags/'+tag.ref)\n        tag.dump(self._output)\n    else:\n      tag.skip()\n\n  def _parse_progress(self):\n    \"\"\"\n    Parse input data into a Progress object. Once the Progress has\n    been created, it will be handed off to the appropriate\n    callbacks. Current-line will be advanced until it is beyond the\n    progress data. The Progress will be dumped to _output once\n    everything else is done (unless it has been skipped by the callback).\n    \"\"\"\n    # Parse the Progress\n    message = self._parse_ref_line(b'progress')\n    if self._currentline == b'\\n':\n      self._advance_currentline()\n\n    # Create the progress message\n    progress = Progress(message)\n\n    # Call any user callback to allow them to modify the progress messsage\n    if self._progress_callback:\n      self._progress_callback(progress)\n\n    # NOTE: By default, we do NOT print the progress message; git\n    # fast-import would write it to fast_import_pipes which could mess with\n    # our parsing of output from the 'ls' and 'get-mark' directives we send\n    # to fast-import.  If users want these messages, they need to process\n    # and handle them in the appropriate callback above.\n\n  def _parse_checkpoint(self):\n    \"\"\"\n    Parse input data into a Checkpoint object. Once the Checkpoint has\n    been created, it will be handed off to the appropriate\n    callbacks. Current-line will be advanced until it is beyond the\n    checkpoint data. The Checkpoint will be dumped to _output once\n    everything else is done (unless it has been skipped by the callback).\n    \"\"\"\n    # Parse the Checkpoint\n    self._advance_currentline()\n    if self._currentline == b'\\n':\n      self._advance_currentline()\n\n    # Create the checkpoint\n    checkpoint = Checkpoint()\n\n    # Call any user callback to allow them to drop the checkpoint\n    if self._checkpoint_callback:\n      self._checkpoint_callback(checkpoint)\n\n    # NOTE: By default, we do NOT print the checkpoint message; although it\n    # we would only realistically get them with --stdin, the fact that we\n    # are filtering makes me think the checkpointing is less likely to be\n    # reasonable.  In fact, I don't think it's necessary in general.  If\n    # users do want it, they should process it in the checkpoint_callback.\n\n  def _parse_literal_command(self):\n    \"\"\"\n    Parse literal command.  Then just dump the line as is.\n    \"\"\"\n    # Create the literal command object\n    command = LiteralCommand(self._currentline)\n    self._advance_currentline()\n\n    # Now print the resulting literal command\n    if not command.dumped:\n      command.dump(self._output)\n\n  def insert(self, obj):\n    assert not obj.dumped\n    obj.dump(self._output)\n    if type(obj) == Commit:\n      self._imported_refs.add(obj.branch)\n    elif type(obj) in (Reset, Tag):\n      self._imported_refs.add(obj.ref)\n\n  def run(self, input, output):\n    \"\"\"\n    This method filters fast export output.\n    \"\"\"\n    # Set input. If no args provided, use stdin.\n    self._input = input\n    self._output = output\n\n    # Run over the input and do the filtering\n    self._advance_currentline()\n    while self._currentline:\n      if   self._currentline.startswith(b'blob'):\n        self._parse_blob()\n      elif self._currentline.startswith(b'reset'):\n        self._parse_reset()\n      elif self._currentline.startswith(b'commit'):\n        self._parse_commit()\n      elif self._currentline.startswith(b'tag'):\n        self._parse_tag()\n      elif self._currentline.startswith(b'progress'):\n        self._parse_progress()\n      elif self._currentline.startswith(b'checkpoint'):\n        self._parse_checkpoint()\n      elif self._currentline.startswith(b'feature'):\n        self._parse_literal_command()\n      elif self._currentline.startswith(b'option'):\n        self._parse_literal_command()\n      elif self._currentline.startswith(b'done'):\n        if self._done_callback:\n          self._done_callback()\n        self._parse_literal_command()\n        # Prevent confusion from others writing additional stuff that'll just\n        # be ignored\n        self._output.close()\n      elif self._currentline.startswith(b'#'):\n        self._parse_literal_command()\n      elif self._currentline.startswith(b'get-mark') or \\\n           self._currentline.startswith(b'cat-blob') or \\\n           self._currentline.startswith(b'ls'):\n        raise SystemExit(_(\"Unsupported command: '%s'\") % self._currentline)\n      else:\n        raise SystemExit(_(\"Could not parse line: '%s'\") % self._currentline)\n\n  def get_exported_and_imported_refs(self):\n    return self._exported_refs, self._imported_refs\n\ndef record_id_rename(old_id, new_id):\n  \"\"\"\n  Register a new translation\n  \"\"\"\n  handle_transitivity = True\n  _IDS.record_rename(old_id, new_id, handle_transitivity)\n\n# Internal globals\n_IDS = _IDs()\n_SKIPPED_COMMITS = set()\nBLOB_HASH_TO_NEW_ID = {}\nBLOB_NEW_ID_TO_HASH = {}\nsdr_next_steps = _(\"\"\"\nNEXT STEPS FOR YOUR SENSITIVE DATA REMOVAL:\n  * If you are doing your rewrite in multiple steps, ignore these next steps\n    until you have completed all your invocations of git-filter-repo.\n  * See the \"Sensitive Data Removal\" subsection of the \"DISCUSSION\" section\n    of the manual for more details about any of the steps below.\n  * Inspect this repository and verify that the sensitive data is indeed\n    completely removed from all commits.\n  * Force push the rewritten history to the server:\n      %s\n  * Contact the server admins for additional steps they need to take; the\n    First Changed Commit(s)%s may come in handy here.\n  * Have other colleagues with a clone either discard their clone and reclone\n    OR follow the detailed steps in the manual to repeatedly rebase and\n    purge the sensitive data from their copy.  Again, the First Changed\n    Commit(s)%s may come in handy.\n  * See the \"Prevent repeats and avoid future sensitive data spills\" section\n    of the manual.\n\"\"\"[1:])\n\nclass SubprocessWrapper(object):\n  @staticmethod\n  def decodify(args):\n    if type(args) == str:\n      return args\n    else:\n      assert type(args) == list\n      return [decode(x) if type(x)==bytes else x for x in args]\n\n  @staticmethod\n  def call(*args, **kwargs):\n    if 'cwd' in kwargs:\n      kwargs['cwd'] = decode(kwargs['cwd'])\n    return subprocess.call(SubprocessWrapper.decodify(*args), **kwargs)\n\n  @staticmethod\n  def check_output(*args, **kwargs):\n    if 'cwd' in kwargs:\n      kwargs['cwd'] = decode(kwargs['cwd'])\n    return subprocess.check_output(SubprocessWrapper.decodify(*args), **kwargs)\n\n  @staticmethod\n  def check_call(*args, **kwargs): # pragma: no cover  # used by filter-lamely\n    if 'cwd' in kwargs:\n      kwargs['cwd'] = decode(kwargs['cwd'])\n    return subprocess.check_call(SubprocessWrapper.decodify(*args), **kwargs)\n\n  @staticmethod\n  def Popen(*args, **kwargs):\n    if 'cwd' in kwargs:\n      kwargs['cwd'] = decode(kwargs['cwd'])\n    return subprocess.Popen(SubprocessWrapper.decodify(*args), **kwargs)\n\nsubproc = subprocess\nif platform.system() == 'Windows' or 'PRETEND_UNICODE_ARGS' in os.environ:\n  subproc = SubprocessWrapper\n\nclass GitUtils(object):\n  @staticmethod\n  def get_commit_count(repo, *args):\n    \"\"\"\n    Return the number of commits that have been made on repo.\n    \"\"\"\n    if not args:\n      args = ['--all']\n    if len(args) == 1 and isinstance(args[0], list):\n      args = args[0]\n    p = subproc.Popen([\"git\", \"rev-list\", \"--count\"] + args,\n                      stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                      cwd=repo)\n    if p.wait() != 0:\n      raise SystemExit(_(\"%s does not appear to be a valid git repository\")\n                       % decode(repo))\n    return int(p.stdout.read())\n\n  @staticmethod\n  def get_total_objects(repo):\n    \"\"\"\n    Return the number of objects (both packed and unpacked)\n    \"\"\"\n    p1 = subproc.Popen([\"git\", \"count-objects\", \"-v\"],\n                          stdout=subprocess.PIPE, cwd=repo)\n    lines = p1.stdout.read().splitlines()\n    # Return unpacked objects + packed-objects\n    return int(lines[0].split()[1]) + int(lines[2].split()[1])\n\n  @staticmethod\n  def is_repository_bare(repo_working_dir):\n    out = subproc.check_output('git rev-parse --is-bare-repository'.split(),\n                               cwd=repo_working_dir)\n    return (out.strip() == b'true')\n\n  @staticmethod\n  def determine_git_dir(repo_working_dir):\n    d = subproc.check_output('git rev-parse --git-dir'.split(),\n                             cwd=repo_working_dir).strip()\n    if repo_working_dir==b'.' or d.startswith(b'/'):\n      return d\n    return os.path.join(repo_working_dir, d)\n\n  @staticmethod\n  def get_refs(repo_working_dir):\n    try:\n      output = subproc.check_output('git show-ref'.split(),\n                                    cwd=repo_working_dir)\n    except subprocess.CalledProcessError as e:\n      # If error code is 1, there just aren't any refs; i.e. new repo.\n      # If error code is other than 1, some other error (e.g. not a git repo)\n      if e.returncode != 1:\n        raise SystemExit('fatal: {}'.format(e))\n      output = ''\n    return dict(reversed(x.split()) for x in output.splitlines())\n\n  @staticmethod\n  def get_config_settings(repo_working_dir):\n    output = ''\n    try:\n      output = subproc.check_output('git config --list'.split(),\n                                    cwd=repo_working_dir)\n    except subprocess.CalledProcessError as e: # pragma: no cover\n      raise SystemExit('fatal: {}'.format(e))\n\n    # FIXME: Ignores multi-valued keys, just let them overwrite for now\n    return dict(line.split(b'=', maxsplit=1)\n                for line in output.strip().split(b\"\\n\"))\n\n  @staticmethod\n  def get_blob_sizes(quiet = False):\n    blob_size_progress = ProgressWriter()\n    num_blobs = 0\n    processed_blobs_msg = _(\"Processed %d blob sizes\")\n\n    # Get sizes of blobs by sha1\n    cmd = '--batch-check=%(objectname) %(objecttype) ' + \\\n          '%(objectsize) %(objectsize:disk)'\n    cf = subproc.Popen(['git', 'cat-file', '--batch-all-objects', cmd],\n                       bufsize = -1,\n                       stdout = subprocess.PIPE)\n    unpacked_size = {}\n    packed_size = {}\n    for line in cf.stdout:\n      try:\n        sha, objtype, objsize, objdisksize = line.split()\n        objsize, objdisksize = int(objsize), int(objdisksize)\n        if objtype == b'blob':\n          unpacked_size[sha] = objsize\n          packed_size[sha] = objdisksize\n          num_blobs += 1\n      except ValueError: # pragma: no cover\n        sys.stderr.write(_(\"Error: unexpected `git cat-file` output: \\\"%s\\\"\\n\") % line)\n      if not quiet:\n        blob_size_progress.show(processed_blobs_msg % num_blobs)\n    cf.wait()\n    if not quiet:\n      blob_size_progress.finish()\n    return unpacked_size, packed_size\n\n  @staticmethod\n  def get_file_changes(repo, parent_hash, commit_hash):\n    \"\"\"\n    Return a FileChanges list with the differences between parent_hash\n    and commit_hash\n    \"\"\"\n    file_changes = []\n\n    cmd = [\"git\", \"diff-tree\", \"-r\", parent_hash, commit_hash]\n    output = subproc.check_output(cmd, cwd=repo)\n    for line in output.splitlines():\n      fileinfo, path = line.split(b'\\t', 1)\n      if path.startswith(b'\"'):\n        path = PathQuoting.dequote(path)\n      oldmode, mode, oldhash, newhash, changetype = fileinfo.split()\n      if changetype == b'D':\n        file_changes.append(FileChange(b'D', path))\n      elif changetype in (b'A', b'M', b'T'):\n        identifier = BLOB_HASH_TO_NEW_ID.get(newhash, newhash)\n        file_changes.append(FileChange(b'M', path, identifier, mode))\n      else: # pragma: no cover\n        raise SystemExit(\"Unknown change type for line {}\".format(line))\n\n    return file_changes\n\n  @staticmethod\n  def print_my_version():\n    with open(__file__, 'br') as f:\n      contents = f.read()\n    # If people replaced @@LOCALEDIR@@ string to point at their local\n    # directory, undo it so we can get original source version.\n    contents = re.sub(br'\\A#\\!.*',\n                      br'#!/usr/bin/env python3', contents)\n    contents = re.sub(br'(\\(\"GIT_TEXTDOMAINDIR\"\\) or \").*\"',\n                      br'\\1@@LOCALEDIR@@\"', contents)\n\n    cmd = 'git hash-object --stdin'.split()\n    version = subproc.check_output(cmd, input=contents).strip()\n    print(decode(version[0:12]))\n\nclass FilteringOptions(object):\n  default_replace_text = b'***REMOVED***'\n  class AppendFilter(argparse.Action):\n    def __call__(self, parser, namespace, values, option_string=None):\n      user_path = values\n      suffix = option_string[len('--path-'):] or 'match'\n      if suffix.startswith('rename'):\n        mod_type = 'rename'\n        match_type = option_string[len('--path-rename-'):] or 'match'\n        values = values.split(b':')\n        if len(values) != 2:\n          raise SystemExit(_(\"Error: --path-rename expects one colon in its\"\n                             \" argument: <old_name:new_name>.\"))\n        if values[0] and values[1] and not (\n           values[0].endswith(b'/') == values[1].endswith(b'/')):\n          raise SystemExit(_(\"Error: With --path-rename, if OLD_NAME and \"\n                             \"NEW_NAME are both non-empty and either ends \"\n                             \"with a slash then both must.\"))\n        if any(v.startswith(b'/') for v in values):\n          raise SystemExit(_(\"Error: Pathnames cannot begin with a '/'\"))\n        components = values[0].split(b'/') + values[1].split(b'/')\n      else:\n        mod_type = 'filter'\n        match_type = suffix\n        components = values.split(b'/')\n        if values.startswith(b'/'):\n          raise SystemExit(_(\"Error: Pathnames cannot begin with a '/'\"))\n      for illegal_path in [b'.', b'..']:\n        if illegal_path in components:\n          raise SystemExit(_(\"Error: Invalid path component '%s' found in '%s'\")\n                           % (decode(illegal_path), decode(user_path)))\n      if match_type == 'regex':\n        values = re.compile(values)\n      items = getattr(namespace, self.dest, []) or []\n      items.append((mod_type, match_type, values))\n      if (match_type, mod_type) == ('glob', 'filter'):\n        if not values.endswith(b'*'):\n          extension = b'*' if values.endswith(b'/') else b'/*'\n          items.append((mod_type, match_type, values+extension))\n      setattr(namespace, self.dest, items)\n\n  class HelperFilter(argparse.Action):\n    def __call__(self, parser, namespace, values, option_string=None):\n      af = FilteringOptions.AppendFilter(dest='path_changes',\n                                         option_strings=None)\n      dirname = values if values[-1:] == b'/' else values+b'/'\n      if option_string == '--subdirectory-filter':\n        af(parser, namespace, dirname,     '--path-match')\n        af(parser, namespace, dirname+b':', '--path-rename')\n      elif option_string == '--to-subdirectory-filter':\n        af(parser, namespace, b':'+dirname, '--path-rename')\n      else:\n        raise SystemExit(_(\"Error: HelperFilter given invalid option_string: %s\")\n                         % option_string) # pragma: no cover\n\n  class FileWithPathsFilter(argparse.Action):\n    def __call__(self, parser, namespace, values, option_string=None):\n      if not namespace.path_changes:\n        namespace.path_changes = []\n      namespace.path_changes += FilteringOptions.get_paths_from_file(values)\n\n  @staticmethod\n  def create_arg_parser():\n    # Include usage in the summary, so we can put the description first\n    summary = _('''Rewrite (or analyze) repository history\n\n    git-filter-repo destructively rewrites history (unless --analyze or\n    --dry-run are given) according to specified rules.  It refuses to do any\n    rewriting unless either run from a clean fresh clone, or --force was\n    given.\n\n    Basic Usage:\n      git-filter-repo --analyze\n      git-filter-repo [FILTER/RENAME/CONTROL OPTIONS]\n\n    See EXAMPLES section for details.\n    ''').rstrip()\n\n    # Provide a long helpful examples section\n    example_text = _('''CALLBACKS\n\n    Most callback functions are of the same general format.  For a command line\n    argument like\n      --foo-callback 'BODY'\n\n    the following code will be compiled and called:\n      def foo_callback(foo):\n        BODY\n\n    The exception on callbacks is the --file-info-callback, which will be\n    discussed further below.\n\n    Given the callback style, we can thus make a simple callback to replace\n    'Jon' with 'John' in author/committer/tagger names:\n      git filter-repo --name-callback 'return name.replace(b\"Jon\", b\"John\")'\n\n    To remove all 'Tested-by' tags in commit (or tag) messages:\n      git filter-repo --message-callback 'return re.sub(br\"\\\\nTested-by:.*\", \"\", message)'\n\n    To remove all .DS_Store files:\n      git filter-repo --filename-callback 'return None if os.path.basename(filename) == b\".DS_Store\" else filename'\n\n    Note that if BODY resolves to a filename, then the contents of that file\n    will be used as the BODY in the callback function.\n\n    The --file-info-callback has a more involved function callback; for it the\n    following code will be compiled and called:\n      def file_info_callback(filename, mode, blob_id, value):\n        BODY\n\n    It is designed to be used in cases where filtering depends on both\n    filename and contents (and maybe mode).  It is called for file changes\n    other than deletions (since deletions have no file contents to operate\n    on).  This callback is expected to return a tuple of (filename, mode,\n    blob_id).  It can make use of the following functions from the value\n    instance:\n      value.get_contents_by_identifier(blob_id) -> contents (bytestring)\n      value.get_size_by_identifier(blob_id) -> size_of_blob (int)\n      value.insert_file_with_contents(contents) -> blob_id\n      value.is_binary(contents) -> bool\n      value.apply_replace_text(contents) -> new_contents (bytestring)\n    and can read/write the following data member from the value instance:\n      value.data (dict)\n\n    The filename can be used for renaming the file similar to\n    --filename-callback (or None to drop the change), and mode is one\n    of b'100644', b'100755', b'120000', or b'160000'.\n\n    For more detailed examples and explanations AND caveats, see\n      https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html#CALLBACKS\n\nEXAMPLES\n\n    To get a bunch of reports mentioning renames that have occurred in\n    your repo and listing sizes of objects aggregated by any of path,\n    directory, extension, or blob-id:\n      git filter-repo --analyze\n\n    (These reports can help you choose how to filter your repo; it can\n    be useful to re-run this command after filtering to regenerate the\n    report and verify the changes look correct.)\n\n    To extract the history that touched just 'guides' and 'tools/releases':\n      git filter-repo --path guides/ --path tools/releases\n\n    To remove foo.zip and bar/baz/zips from every revision in history:\n      git filter-repo --path foo.zip --path bar/baz/zips/ --invert-paths\n\n    To replace the text 'password' with 'p455w0rd':\n      git filter-repo --replace-text <(echo \"password==>p455w0rd\")\n\n    To use the current version of the .mailmap file to update authors,\n    committers, and taggers throughout history and make it permanent:\n      git filter-repo --use-mailmap\n\n    To extract the history of 'src/', rename all files to have a new leading\n    directory 'my-module' (e.g. src/foo.java -> my-module/src/foo.java), and\n    add a 'my-module-' prefix to all tags:\n      git filter-repo --path src/ --to-subdirectory-filter my-module --tag-rename '':'my-module-'\n\n    For more detailed examples and explanations, see\n      https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html#EXAMPLES''')\n\n    # Create the basic parser\n    parser = argparse.ArgumentParser(description=summary,\n                                     usage = argparse.SUPPRESS,\n                                     add_help = False,\n                                     epilog = example_text,\n                                     formatter_class=argparse.RawDescriptionHelpFormatter)\n\n    analyze = parser.add_argument_group(title=_(\"Analysis\"))\n    analyze.add_argument('--analyze', action='store_true',\n        help=_(\"Analyze repository history and create a report that may be \"\n               \"useful in determining what to filter in a subsequent run. \"\n               \"Will not modify your repo.\"))\n    analyze.add_argument('--report-dir',\n        metavar='DIR_OR_FILE',\n        type=os.fsencode,\n        dest='report_dir',\n        help=_(\"Directory to write report, defaults to GIT_DIR/filter_repo/analysis,\"\n               \"refuses to run if exists, --force delete existing dir first.\"))\n\n    path = parser.add_argument_group(title=_(\"Filtering based on paths \"\n                                             \"(see also --filename-callback)\"),\n                                     description=textwrap.dedent(_(\"\"\"\n           These options specify the paths to select.  Note that much like git\n           itself, renames are NOT followed so you may need to specify multiple\n           paths, e.g. `--path olddir/ --path newdir/`\n           \"\"\"[1:])))\n\n    path.add_argument('--invert-paths', action='store_false', dest='inclusive',\n        help=_(\"Invert the selection of files from the specified \"\n               \"--path-{match,glob,regex} options below, i.e. only select \"\n               \"files matching none of those options.\"))\n\n    path.add_argument('--path-match', '--path', metavar='DIR_OR_FILE',\n        type=os.fsencode,\n        action=FilteringOptions.AppendFilter, dest='path_changes',\n        help=_(\"Exact paths (files or directories) to include in filtered \"\n               \"history.  Multiple --path options can be specified to get \"\n               \"a union of paths.\"))\n    path.add_argument('--path-glob', metavar='GLOB', type=os.fsencode,\n        action=FilteringOptions.AppendFilter, dest='path_changes',\n        help=_(\"Glob of paths to include in filtered history. Multiple \"\n               \"--path-glob options can be specified to get a union of \"\n               \"paths.\"))\n    path.add_argument('--path-regex', metavar='REGEX', type=os.fsencode,\n        action=FilteringOptions.AppendFilter, dest='path_changes',\n        help=_(\"Regex of paths to include in filtered history. Multiple \"\n               \"--path-regex options can be specified to get a union of \"\n               \"paths\"))\n    path.add_argument('--use-base-name', action='store_true',\n        help=_(\"Match on file base name instead of full path from the top \"\n               \"of the repo.  Incompatible with --path-rename, and \"\n               \"incompatible with matching against directory names.\"))\n\n    rename = parser.add_argument_group(title=_(\"Renaming based on paths \"\n                                             \"(see also --filename-callback)\"))\n    rename.add_argument('--path-rename', '--path-rename-match',\n        metavar='OLD_NAME:NEW_NAME', dest='path_changes', type=os.fsencode,\n        action=FilteringOptions.AppendFilter,\n        help=_(\"Path to rename; if filename or directory matches OLD_NAME \"\n               \"rename to NEW_NAME.  Multiple --path-rename options can be \"\n               \"specified.  NOTE: If you combine filtering options with \"\n               \"renaming ones, do not rely on a rename argument to select \"\n               \"paths; you also need a filter to select them.\"))\n\n    helpers = parser.add_argument_group(title=_(\"Path shortcuts\"))\n    helpers.add_argument('--paths', help=argparse.SUPPRESS, metavar='IGNORE')\n    helpers.add_argument('--paths-from-file', metavar='FILENAME',\n        type=os.fsencode,\n        action=FilteringOptions.FileWithPathsFilter, dest='path_changes',\n        help=_(\"Specify several path filtering and renaming directives, one \"\n               \"per line.  Lines with '==>' in them specify path renames, \"\n               \"and lines can begin with 'literal:' (the default), 'glob:', \"\n               \"or 'regex:' to specify different matching styles.  Blank \"\n               \"lines and lines starting with a '#' are ignored.\"))\n    helpers.add_argument('--subdirectory-filter', metavar='DIRECTORY',\n        action=FilteringOptions.HelperFilter, type=os.fsencode,\n        help=_(\"Only look at history that touches the given subdirectory \"\n               \"and treat that directory as the project root.  Equivalent \"\n               \"to using '--path DIRECTORY/ --path-rename DIRECTORY/:'\"))\n    helpers.add_argument('--to-subdirectory-filter', metavar='DIRECTORY',\n        action=FilteringOptions.HelperFilter, type=os.fsencode,\n        help=_(\"Treat the project root as if it were under DIRECTORY. \"\n               \"Equivalent to using '--path-rename :DIRECTORY/'\"))\n\n    contents = parser.add_argument_group(title=_(\"Content editing filters \"\n                                                 \"(see also --blob-callback)\"))\n    contents.add_argument('--replace-text', metavar='EXPRESSIONS_FILE',\n        help=_(\"A file with expressions that, if found, will be replaced. \"\n               \"By default, each expression is treated as literal text, \"\n               \"but 'regex:' and 'glob:' prefixes are supported.  You can \"\n               \"end the line with '==>' and some replacement text to \"\n               \"choose a replacement choice other than the default of '{}'.\"\n               .format(decode(FilteringOptions.default_replace_text))))\n    contents.add_argument('--strip-blobs-bigger-than', metavar='SIZE',\n                          dest='max_blob_size', default=0,\n        help=_(\"Strip blobs (files) bigger than specified size (e.g. '5M', \"\n               \"'2G', etc)\"))\n    contents.add_argument('--strip-blobs-with-ids', metavar='BLOB-ID-FILENAME',\n        help=_(\"Read git object ids from each line of the given file, and \"\n               \"strip all of them from history\"))\n\n    refrename = parser.add_argument_group(title=_(\"Renaming of refs \"\n                                              \"(see also --refname-callback)\"))\n    refrename.add_argument('--tag-rename', metavar='OLD:NEW', type=os.fsencode,\n        help=_(\"Rename tags starting with OLD to start with NEW.  For \"\n               \"example, --tag-rename foo:bar will rename tag foo-1.2.3 \"\n               \"to bar-1.2.3; either OLD or NEW can be empty.\"))\n\n    messages = parser.add_argument_group(title=_(\"Filtering of commit messages \"\n                                               \"(see also --message-callback)\"))\n    messages.add_argument('--replace-message', metavar='EXPRESSIONS_FILE',\n        help=_(\"A file with expressions that, if found in commit or tag \"\n               \"messages, will be replaced. This file uses the same syntax \"\n               \"as --replace-text.\"))\n    messages.add_argument('--preserve-commit-hashes', action='store_true',\n        help=_(\"By default, since commits are rewritten and thus gain new \"\n               \"hashes, references to old commit hashes in commit messages \"\n               \"are replaced with new commit hashes (abbreviated to the same \"\n               \"length as the old reference).  Use this flag to turn off \"\n               \"updating commit hashes in commit messages.\"))\n    messages.add_argument('--preserve-commit-encoding', action='store_true',\n        help=_(\"Do not reencode commit messages into UTF-8.  By default, if \"\n               \"the commit object specifies an encoding for the commit \"\n               \"message, the message is re-encoded into UTF-8.\"))\n\n    people = parser.add_argument_group(title=_(\"Filtering of names & emails \"\n                                               \"(see also --name-callback \"\n                                               \"and --email-callback)\"))\n    people.add_argument('--mailmap', dest='mailmap', metavar='FILENAME',\n        type=os.fsencode,\n        help=_(\"Use specified mailmap file (see git-shortlog(1) for \"\n               \"details on the format) when rewriting author, committer, \"\n               \"and tagger names and emails.  If the specified file is \"\n               \"part of git history, historical versions of the file will \"\n               \"be ignored; only the current contents are consulted.\"))\n    people.add_argument('--use-mailmap', dest='mailmap',\n        action='store_const', const=b'.mailmap',\n        help=_(\"Same as: '--mailmap .mailmap' \"))\n\n    parents = parser.add_argument_group(title=_(\"Parent rewriting\"))\n    parents.add_argument('--replace-refs', default=None,\n                         choices=['delete-no-add', 'delete-and-add',\n                                  'update-no-add', 'update-or-add',\n                                  'update-and-add', 'old-default'],\n        help=_(\"How to handle replace refs (see git-replace(1)).  Replace \"\n               \"refs can be added during the history rewrite as a way to \"\n               \"allow users to pass old commit IDs (from before \"\n               \"git-filter-repo was run) to git commands and have git know \"\n               \"how to translate those old commit IDs to the new \"\n               \"(post-rewrite) commit IDs.  Also, replace refs that existed \"\n               \"before the rewrite can either be deleted or updated.  The \"\n               \"choices to pass to --replace-refs thus need to specify both \"\n               \"what to do with existing refs and what to do with commit \"\n               \"rewrites.  Thus 'update-and-add' means to update existing \"\n               \"replace refs, and for any commit rewrite (even if already \"\n               \"pointed at by a replace ref) add a new refs/replace/ reference \"\n               \"to map from the old commit ID to the new commit ID.  The \"\n               \"default is update-no-add, meaning update existing replace refs \"\n               \"but do not add any new ones.  There is also a special \"\n               \"'old-default' option for picking the default used in versions \"\n               \"prior to git-filter-repo-2.45, namely 'update-and-add' upon \"\n               \"the first run of git-filter-repo in a repository and \"\n               \"'update-or-add' if running git-filter-repo again on a \"\n               \"repository.\"))\n    parents.add_argument('--prune-empty', default='auto',\n                         choices=['always', 'auto', 'never'],\n        help=_(\"Whether to prune empty commits.  'auto' (the default) means \"\n               \"only prune commits which become empty (not commits which were \"\n               \"empty in the original repo, unless their parent was pruned). \"\n               \"When the parent of a commit is pruned, the first non-pruned \"\n               \"ancestor becomes the new parent.\"))\n    parents.add_argument('--prune-degenerate', default='auto',\n                         choices=['always', 'auto', 'never'],\n        help=_(\"Since merge commits are needed for history topology, they \"\n               \"are typically exempt from pruning.  However, they can become \"\n               \"degenerate with the pruning of other commits (having fewer \"\n               \"than two parents, having one commit serve as both parents, or \"\n               \"having one parent as the ancestor of the other.)  If such \"\n               \"merge commits have no file changes, they can be pruned.  The \"\n               \"default ('auto') is to only prune empty merge commits which \"\n               \"become degenerate (not which started as such).\"))\n    parents.add_argument('--no-ff', action='store_true',\n        help=_(\"Even if the first parent is or becomes an ancestor of another \"\n               \"parent, do not prune it.  This modifies how \"\n               \"--prune-degenerate behaves, and may be useful in projects who \"\n               \"always use merge --no-ff.\"))\n\n    callback = parser.add_argument_group(title=_(\"Generic callback code snippets\"))\n    callback.add_argument('--filename-callback', metavar=\"FUNCTION_BODY_OR_FILE\",\n        help=_(\"Python code body for processing filenames; see CALLBACKS \"\n               \"sections below.\"))\n    callback.add_argument('--file-info-callback', metavar=\"FUNCTION_BODY_OR_FILE\",\n        help=_(\"Python code body for processing file and metadata; see \"\n               \"CALLBACKS sections below.\"))\n    callback.add_argument('--message-callback', metavar=\"FUNCTION_BODY_OR_FILE\",\n        help=_(\"Python code body for processing messages (both commit \"\n               \"messages and tag messages); see CALLBACKS section below.\"))\n    callback.add_argument('--name-callback', metavar=\"FUNCTION_BODY_OR_FILE\",\n        help=_(\"Python code body for processing names of people; see \"\n               \"CALLBACKS section below.\"))\n    callback.add_argument('--email-callback', metavar=\"FUNCTION_BODY_OR_FILE\",\n        help=_(\"Python code body for processing emails addresses; see \"\n               \"CALLBACKS section below.\"))\n    callback.add_argument('--refname-callback', metavar=\"FUNCTION_BODY_OR_FILE\",\n        help=_(\"Python code body for processing refnames; see CALLBACKS \"\n               \"section below.\"))\n\n    callback.add_argument('--blob-callback', metavar=\"FUNCTION_BODY_OR_FILE\",\n        help=_(\"Python code body for processing blob objects; see \"\n               \"CALLBACKS section below.\"))\n    callback.add_argument('--commit-callback', metavar=\"FUNCTION_BODY_OR_FILE\",\n        help=_(\"Python code body for processing commit objects; see \"\n               \"CALLBACKS section below.\"))\n    callback.add_argument('--tag-callback', metavar=\"FUNCTION_BODY_OR_FILE\",\n        help=_(\"Python code body for processing tag objects.  Note that \"\n               \"lightweight tags have no tag object and are thus not \"\n               \"handled by this callback. See CALLBACKS section below.\"))\n    callback.add_argument('--reset-callback', metavar=\"FUNCTION_BODY_OR_FILE\",\n        help=_(\"Python code body for processing reset objects; see \"\n               \"CALLBACKS section below.\"))\n\n    sdr = parser.add_argument_group(title=_(\"Sensitive Data Removal Handling\"))\n    sdr.add_argument('--sensitive-data-removal', '--sdr', action='store_true',\n        help=_(\"This rewrite is intended to remove sensitive data from a \"\n               \"repository.  Gather extra information from the rewrite needed \"\n               \"to provide additional instructions on how to clean up other \"\n               \"copies.\"))\n    sdr.add_argument('--no-fetch', action='store_true',\n        help=_(\"By default, --sensitive-data-removal will trigger a \"\n               \"mirror-like fetch of all refs from origin, discarding local \"\n               \"changes, but ensuring that _all_ fetchable refs that hold on \"\n               \"to the sensitve data are rewritten.  This flag removes that \"\n               \"fetch, risking that other refs continue holding on to the \"\n               \"sensitive data.  This option is implied by --partial or any \"\n               \"flag that implies --partial.\"))\n\n    desc = _(\n      \"Specifying alternate source or target locations implies --partial,\\n\"\n      \"except that the normal default for --replace-refs is used.  However,\\n\"\n      \"unlike normal uses of --partial, this doesn't risk mixing old and new\\n\"\n      \"history since the old and new histories are in different repositories.\")\n    location = parser.add_argument_group(title=_(\"Location to filter from/to\"),\n                                         description=desc)\n    location.add_argument('--source', type=os.fsencode,\n                          help=_(\"Git repository to read from\"))\n    location.add_argument('--target', type=os.fsencode,\n        help=_(\"Git repository to overwrite with filtered history\"))\n\n    order = parser.add_argument_group(title=_(\"Ordering of commits\"))\n    order.add_argument('--date-order', action='store_true',\n        help=_(\"Processes commits in commit timestamp order.\"))\n\n    misc = parser.add_argument_group(title=_(\"Miscellaneous options\"))\n    misc.add_argument('--help', '-h', action='store_true',\n        help=_(\"Show this help message and exit.\"))\n    misc.add_argument('--version', action='store_true',\n        help=_(\"Display filter-repo's version and exit.\"))\n    misc.add_argument('--proceed', action='store_true',\n        help=_(\"Avoid triggering the no-arguments-specified check.\"))\n    misc.add_argument('--force', '-f', action='store_true',\n        help=_(\"Rewrite repository history even if the current repo does not \"\n               \"look like a fresh clone.  History rewriting is irreversible \"\n               \"(and includes immediate pruning of reflogs and old objects), \"\n               \"so be cautious about using this flag.\"))\n    misc.add_argument('--partial', action='store_true',\n        help=_(\"Do a partial history rewrite, resulting in the mixture of \"\n               \"old and new history.  This disables rewriting \"\n               \"refs/remotes/origin/* to refs/heads/*, disables removing \"\n               \"of the 'origin' remote, disables removing unexported refs, \"\n               \"disables expiring the reflog, and disables the automatic \"\n               \"post-filter gc.  Also, this modifies --tag-rename and \"\n               \"--refname-callback options such that instead of replacing \"\n               \"old refs with new refnames, it will instead create new \"\n               \"refs and keep the old ones around.  Use with caution.\"))\n    misc.add_argument('--no-gc', action='store_true',\n        help=_(\"Do not run 'git gc' after filtering.\"))\n    # WARNING: --refs presents a problem with become-degenerate pruning:\n    #   * Excluding a commit also excludes its ancestors so when some other\n    #     commit has an excluded ancestor as a parent we have no way of\n    #     knowing what it is an ancestor of without doing a special\n    #     full-graph walk.\n    misc.add_argument('--refs', nargs='+',\n        help=_(\"Limit history rewriting to the specified refs.  Implies \"\n               \"--partial.  In addition to the normal caveats of --partial \"\n               \"(mixing old and new history, no automatic remapping of \"\n               \"refs/remotes/origin/* to refs/heads/*, etc.), this also may \"\n               \"cause problems for pruning of degenerate empty merge \"\n               \"commits when negative revisions are specified.\"))\n\n    misc.add_argument('--dry-run', action='store_true',\n        help=_(\"Do not change the repository.  Run `git fast-export` and \"\n               \"filter its output, and save both the original and the \"\n               \"filtered version for comparison.  This also disables \"\n               \"rewriting commit messages due to not knowing new commit \"\n               \"IDs and disables filtering of some empty commits due to \"\n               \"inability to query the fast-import backend.\" ))\n    misc.add_argument('--debug', action='store_true',\n        help=_(\"Print additional information about operations being \"\n               \"performed and commands being run.  When used together \"\n               \"with --dry-run, also show extra information about what \"\n               \"would be run.\"))\n    # WARNING: --state-branch has some problems:\n    #   * It does not work well with manually inserted objects (user creating\n    #     Blob() or Commit() or Tag() objects and calling\n    #     RepoFilter.insert(obj) on them).\n    #   * It does not work well with multiple source or multiple target repos\n    #   * It doesn't work so well with pruning become-empty commits (though\n    #     --refs doesn't work so well with it either)\n    # These are probably fixable, given some work (e.g. re-importing the\n    # graph at the beginning to get the AncestryGraph right, doing our own\n    # export of marks instead of using fast-export --export-marks, etc.), but\n    # for now just hide the option.\n    misc.add_argument('--state-branch',\n        #help=_(\"Enable incremental filtering by saving the mapping of old \"\n        #       \"to new objects to the specified branch upon exit, and\"\n        #       \"loading that mapping from that branch (if it exists) \"\n        #       \"upon startup.\"))\n        help=argparse.SUPPRESS)\n    misc.add_argument('--stdin', action='store_true',\n        help=_(\"Instead of running `git fast-export` and filtering its \"\n               \"output, filter the fast-export stream from stdin.    The \"\n               \"stdin must be in the expected input format (e.g. it needs \"\n               \"to include original-oid directives).\"))\n    misc.add_argument('--quiet', action='store_true',\n        help=_(\"Pass --quiet to other git commands called\"))\n    return parser\n\n  @staticmethod\n  def sanity_check_args(args):\n    if args.analyze and args.path_changes:\n      raise SystemExit(_(\"Error: --analyze is incompatible with --path* flags; \"\n                         \"it's a read-only operation.\"))\n    if args.analyze and args.stdin:\n      raise SystemExit(_(\"Error: --analyze is incompatible with --stdin.\"))\n    # If no path_changes are found, initialize with empty list but mark as\n    # not inclusive so that all files match\n    if args.path_changes == None:\n      args.path_changes = []\n      args.inclusive = False\n    else:\n      # Similarly, if we have no filtering paths, then no path should be\n      # filtered out.  Based on how newname() works, the easiest way to\n      # achieve that is setting args.inclusive to False.\n      if not any(x[0] == 'filter' for x in args.path_changes):\n        args.inclusive = False\n      # Also check for incompatible --use-base-name and --path-rename flags.\n      if args.use_base_name:\n        if any(x[0] == 'rename' for x in args.path_changes):\n          raise SystemExit(_(\"Error: --use-base-name and --path-rename are \"\n                             \"incompatible.\"))\n    # Also throw some sanity checks on git version here;\n    # PERF: remove these checks once new enough git versions are common\n    p = subproc.Popen('git fast-export -h'.split(),\n                      stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    output = p.stdout.read()\n    if b'--anonymize-map' not in output: # pragma: no cover\n      global date_format_permissive\n      date_format_permissive = False\n    if not any(x in output for x in [b'--mark-tags',b'--[no-]mark-tags']): # pragma: no cover\n      global write_marks\n      write_marks = False\n      if args.state_branch:\n        # We need a version of git-fast-export with --mark-tags\n        raise SystemExit(_(\"Error: need git >= 2.24.0\"))\n    if not any(x in output for x in [b'--reencode',  b'--[no-]reencode']): # pragma: no cover\n      if args.preserve_commit_encoding:\n        # We need a version of git-fast-export with --reencode\n        raise SystemExit(_(\"Error: need git >= 2.23.0\"))\n      else:\n        # Set args.preserve_commit_encoding to None which we'll check for later\n        # to avoid passing --reencode=yes to fast-export (that option was the\n        # default prior to git-2.23)\n        args.preserve_commit_encoding = None\n      # If we don't have fast-exoprt --reencode, we may also be missing\n      # diff-tree --combined-all-paths, which is even more important...\n      p = subproc.Popen('git diff-tree -h'.split(),\n                        stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n      output = p.stdout.read()\n      if b'--combined-all-paths' not in output:\n        # We need a version of git-diff-tree with --combined-all-paths\n        raise SystemExit(_(\"Error: need git >= 2.22.0\"))\n    # End of sanity checks on git version\n    if args.max_blob_size:\n      suffix = args.max_blob_size[-1]\n      if suffix not in '1234567890':\n        mult = {'K': 1024, 'M': 1024**2, 'G': 1024**3}\n        if suffix not in mult:\n          raise SystemExit(_(\"Error: could not parse --strip-blobs-bigger-than\"\n                             \" argument %s\")\n                           % args.max_blob_size)\n        args.max_blob_size = int(args.max_blob_size[0:-1]) * mult[suffix]\n      else:\n        args.max_blob_size = int(args.max_blob_size)\n    if args.file_info_callback and (\n        args.stdin or args.blob_callback or args.filename_callback):\n      raise SystemExit(_(\"Error: --file-info-callback is incompatible with \"\n                         \"--stdin, --blob-callback,\\nand --filename-callback.\"))\n\n  @staticmethod\n  def get_replace_text(filename):\n    replace_literals = []\n    replace_regexes = []\n    with open(filename, 'br') as f:\n      for line in f:\n        line = line.rstrip(b'\\r\\n')\n\n        # Determine the replacement\n        replacement = FilteringOptions.default_replace_text\n        if b'==>' in line:\n          line, replacement = line.rsplit(b'==>', 1)\n\n        # See if we need to match via regex\n        regex = None\n        if line.startswith(b'regex:'):\n          regex = line[6:]\n        elif line.startswith(b'glob:'):\n          regex = glob_to_regex(line[5:])\n        if regex:\n          replace_regexes.append((re.compile(regex), replacement))\n        else:\n          # Otherwise, find the literal we need to replace\n          if line.startswith(b'literal:'):\n            line = line[8:]\n          if not line:\n            continue\n          replace_literals.append((line, replacement))\n    return {'literals': replace_literals, 'regexes':  replace_regexes}\n\n  @staticmethod\n  def get_paths_from_file(filename):\n    new_path_changes = []\n    with open(filename, 'br') as f:\n      for line in f:\n        line = line.rstrip(b'\\r\\n')\n\n        # Skip blank lines\n        if not line:\n          continue\n        # Skip comment lines\n        if line.startswith(b'#'):\n          continue\n\n        # Determine the replacement\n        match_type, repl = 'literal', None\n        if b'==>' in line:\n          line, repl = line.rsplit(b'==>', 1)\n\n        # See if we need to match via regex\n        match_type = 'match' # a.k.a. 'literal'\n        if line.startswith(b'regex:'):\n          match_type = 'regex'\n          match = re.compile(line[6:])\n        elif line.startswith(b'glob:'):\n          match_type = 'glob'\n          match = line[5:]\n          if repl:\n            raise SystemExit(_(\"Error: In %s, 'glob:' and '==>' are incompatible (renaming globs makes no sense)\" % decode(filename)))\n        else:\n          if line.startswith(b'literal:'):\n            match = line[8:]\n          else:\n            match = line\n          if repl is not None:\n            if match and repl and match.endswith(b'/') != repl.endswith(b'/'):\n              raise SystemExit(_(\"Error: When rename directories, if OLDNAME \"\n                                 \"and NEW_NAME are both non-empty and either \"\n                                 \"ends with a slash then both must.\"))\n\n        # Record the filter or rename\n        if repl is not None:\n          new_path_changes.append(['rename', match_type, (match, repl)])\n        else:\n          new_path_changes.append(['filter', match_type, match])\n          if match_type == 'glob' and not match.endswith(b'*'):\n            extension = b'*' if match.endswith(b'/') else b'/*'\n            new_path_changes.append(['filter', match_type, match+extension])\n      return new_path_changes\n\n  @staticmethod\n  def default_options():\n    return FilteringOptions.parse_args([], error_on_empty = False)\n\n  @staticmethod\n  def parse_args(input_args, error_on_empty = True):\n    parser = FilteringOptions.create_arg_parser()\n    if not input_args and error_on_empty:\n      parser.print_usage()\n      raise SystemExit(_(\"No arguments specified.\"))\n    args = parser.parse_args(input_args)\n    if args.help:\n      parser.print_help()\n      raise SystemExit()\n    if args.paths:\n      raise SystemExit(\"Error: Option `--paths` unrecognized; did you mean --path or --paths-from-file?\")\n    if args.version:\n      GitUtils.print_my_version()\n      raise SystemExit()\n    FilteringOptions.sanity_check_args(args)\n    if args.mailmap:\n      args.mailmap = MailmapInfo(args.mailmap)\n    if args.replace_text:\n      args.replace_text = FilteringOptions.get_replace_text(args.replace_text)\n    if args.replace_message:\n      args.replace_message = FilteringOptions.get_replace_text(args.replace_message)\n    if args.strip_blobs_with_ids:\n      with open(args.strip_blobs_with_ids, 'br') as f:\n        args.strip_blobs_with_ids = set(f.read().split())\n    else:\n      args.strip_blobs_with_ids = set()\n    if (args.partial or args.refs) and not args.replace_refs:\n      args.replace_refs = 'update-no-add'\n    args.repack = not (args.partial or args.refs or args.no_gc)\n    if args.refs or args.source or args.target:\n      args.partial = True\n    if args.partial:\n      args.no_fetch = True\n    if not args.refs:\n      args.refs = ['--all']\n    return args\n\nclass RepoAnalyze(object):\n\n  # First, several helper functions for analyze_commit()\n\n  @staticmethod\n  def equiv_class(stats, filename):\n    return stats['equivalence'].get(filename, (filename,))\n\n  @staticmethod\n  def setup_equivalence_for_rename(stats, oldname, newname):\n    # if A is renamed to B and B is renamed to C, then the user thinks of\n    # A, B, and C as all being different names for the same 'file'.  We record\n    # this as an equivalence class:\n    #   stats['equivalence'][name] = (A,B,C)\n    # for name being each of A, B, and C.\n    old_tuple = stats['equivalence'].get(oldname, ())\n    if newname in old_tuple:\n      return\n    elif old_tuple:\n      new_tuple = tuple(list(old_tuple)+[newname])\n    else:\n      new_tuple = (oldname, newname)\n    for f in new_tuple:\n      stats['equivalence'][f] = new_tuple\n\n  @staticmethod\n  def setup_or_update_rename_history(stats, commit, oldname, newname):\n    rename_commits = stats['rename_history'].get(oldname, set())\n    rename_commits.add(commit)\n    stats['rename_history'][oldname] = rename_commits\n\n  @staticmethod\n  def handle_renames(stats, commit, change_types, filenames):\n    for index, change_type in enumerate(change_types):\n      if change_type == ord(b'R'):\n        oldname, newname = filenames[index], filenames[-1]\n        RepoAnalyze.setup_equivalence_for_rename(stats, oldname, newname)\n        RepoAnalyze.setup_or_update_rename_history(stats, commit,\n                                                   oldname, newname)\n\n  @staticmethod\n  def handle_file(stats, graph, commit, modes, shas, filenames):\n    mode, sha, filename = modes[-1], shas[-1], filenames[-1]\n\n    # Figure out kind of deletions to undo for this file, and update lists\n    # of all-names-by-sha and all-filenames\n    delmode = 'tree_deletions'\n    if mode != b'040000':\n      delmode = 'file_deletions'\n      stats['names'][sha].add(filename)\n      stats['allnames'].add(filename)\n\n    # If the file (or equivalence class of files) was recorded as deleted,\n    # clearly it isn't anymore\n    equiv = RepoAnalyze.equiv_class(stats, filename)\n    for f in equiv:\n      stats[delmode].pop(f, None)\n\n    # If we get a modify/add for a path that was renamed, we may need to break\n    # the equivalence class.  However, if the modify/add was on a branch that\n    # doesn't have the rename in its history, we are still okay.\n    need_to_break_equivalence = False\n    if equiv[-1] != filename:\n      for rename_commit in stats['rename_history'][filename]:\n        if graph.is_ancestor(rename_commit, commit):\n          need_to_break_equivalence = True\n\n    if need_to_break_equivalence:\n      for f in equiv:\n        if f in stats['equivalence']:\n          del stats['equivalence'][f]\n\n  @staticmethod\n  def analyze_commit(stats, graph, commit, parents, date, file_changes):\n    graph.add_commit_and_parents(commit, parents)\n    for change in file_changes:\n      modes, shas, change_types, filenames = change\n      if len(parents) == 1 and change_types.startswith(b'R'):\n        change_types = b'R'  # remove the rename score; we don't care\n      if modes[-1] == b'160000':\n        continue\n      elif modes[-1] == b'000000':\n        # Track when files/directories are deleted\n        for f in RepoAnalyze.equiv_class(stats, filenames[-1]):\n          if any(x == b'040000' for x in modes[0:-1]):\n            stats['tree_deletions'][f] = date\n          else:\n            stats['file_deletions'][f] = date\n      elif change_types.strip(b'AMT') == b'':\n        RepoAnalyze.handle_file(stats, graph, commit, modes, shas, filenames)\n      elif modes[-1] == b'040000' and change_types.strip(b'RAM') == b'':\n        RepoAnalyze.handle_file(stats, graph, commit, modes, shas, filenames)\n      elif change_types.strip(b'RAMT') == b'':\n        RepoAnalyze.handle_file(stats, graph, commit, modes, shas, filenames)\n        RepoAnalyze.handle_renames(stats, commit, change_types, filenames)\n      else:\n        raise SystemExit(_(\"Unhandled change type(s): %(change_type)s \"\n                           \"(in commit %(commit)s)\")\n                         % ({'change_type': change_types, 'commit': commit})\n                         ) # pragma: no cover\n\n  @staticmethod\n  def gather_data(args):\n    unpacked_size, packed_size = GitUtils.get_blob_sizes()\n    stats = {'names': collections.defaultdict(set),\n             'allnames' : set(),\n             'file_deletions': {},\n             'tree_deletions': {},\n             'equivalence': {},\n             'rename_history': collections.defaultdict(set),\n             'unpacked_size': unpacked_size,\n             'packed_size': packed_size,\n             'num_commits': 0}\n\n    # Setup the rev-list/diff-tree process\n    processed_commits_msg = _(\"Processed %d commits\")\n    commit_parse_progress = ProgressWriter()\n    num_commits = 0\n    cmd = ('git rev-list --topo-order --reverse {}'.format(' '.join(args.refs)) +\n           ' | git diff-tree --stdin --always --root --format=%H%n%P%n%cd' +\n           ' --date=short -M -t -c --raw --combined-all-paths')\n    dtp = subproc.Popen(cmd, shell=True, bufsize=-1, stdout=subprocess.PIPE)\n    f = dtp.stdout\n    line = f.readline()\n    if not line:\n      raise SystemExit(_(\"Nothing to analyze; repository is empty.\"))\n    cont = bool(line)\n    graph = AncestryGraph()\n    while cont:\n      commit = line.rstrip()\n      parents = f.readline().split()\n      date = f.readline().rstrip()\n\n      # We expect a blank line next; if we get a non-blank line then\n      # this commit modified no files and we need to move on to the next.\n      # If there is no line, we've reached end-of-input.\n      line = f.readline()\n      if not line:\n        cont = False\n      line = line.rstrip()\n\n      # If we haven't reached end of input, and we got a blank line meaning\n      # a commit that has modified files, then get the file changes associated\n      # with this commit.\n      file_changes = []\n      if cont and not line:\n        cont = False\n        for line in f:\n          if not line.startswith(b':'):\n            cont = True\n            break\n          n = 1+max(1, len(parents))\n          assert line.startswith(b':'*(n-1))\n          relevant = line[n-1:-1]\n          splits = relevant.split(None, n)\n          modes = splits[0:n]\n          splits = splits[n].split(None, n)\n          shas = splits[0:n]\n          splits = splits[n].split(b'\\t')\n          change_types = splits[0]\n          filenames = [PathQuoting.dequote(x) for x in splits[1:]]\n          file_changes.append([modes, shas, change_types, filenames])\n\n      # If someone is trying to analyze a subset of the history, make sure\n      # to avoid dying on commits with parents that we haven't seen before\n      if args.refs:\n        graph.record_external_commits([p for p in parents\n                                       if not p in graph.value])\n\n      # Analyze this commit and update progress\n      RepoAnalyze.analyze_commit(stats, graph, commit, parents, date,\n                                 file_changes)\n      num_commits += 1\n      commit_parse_progress.show(processed_commits_msg % num_commits)\n\n    # Show the final commits processed message and record the number of commits\n    commit_parse_progress.finish()\n    stats['num_commits'] = num_commits\n\n    # Close the output, ensure rev-list|diff-tree pipeline completed successfully\n    dtp.stdout.close()\n    if dtp.wait():\n      raise SystemExit(_(\"Error: rev-list|diff-tree pipeline failed; see above.\")) # pragma: no cover\n\n    return stats\n\n  @staticmethod\n  def write_report(reportdir, stats):\n    def datestr(datetimestr):\n      return datetimestr if datetimestr else _('<present>').encode()\n\n    def dirnames(path):\n      while True:\n        path = os.path.dirname(path)\n        yield path\n        if path == b'':\n          break\n\n    # Compute aggregate size information for paths, extensions, and dirs\n    total_size = {'packed': 0, 'unpacked': 0}\n    path_size = {'packed': collections.defaultdict(int),\n                 'unpacked': collections.defaultdict(int)}\n    ext_size = {'packed': collections.defaultdict(int),\n                'unpacked': collections.defaultdict(int)}\n    dir_size = {'packed': collections.defaultdict(int),\n                'unpacked': collections.defaultdict(int)}\n    for sha in stats['names']:\n      size = {'packed': stats['packed_size'][sha],\n              'unpacked': stats['unpacked_size'][sha]}\n      for which in ('packed', 'unpacked'):\n        for name in stats['names'][sha]:\n          total_size[which] += size[which]\n          path_size[which][name] += size[which]\n          basename, ext = os.path.splitext(name)\n          ext_size[which][ext] += size[which]\n          for dirname in dirnames(name):\n            dir_size[which][dirname] += size[which]\n\n    # Determine if and when extensions and directories were deleted\n    ext_deleted_data = {}\n    for name in stats['allnames']:\n      when = stats['file_deletions'].get(name, None)\n\n      # Update the extension\n      basename, ext = os.path.splitext(name)\n      if when is None:\n        ext_deleted_data[ext] = None\n      elif ext in ext_deleted_data:\n        if ext_deleted_data[ext] is not None:\n          ext_deleted_data[ext] = max(ext_deleted_data[ext], when)\n      else:\n        ext_deleted_data[ext] = when\n\n    dir_deleted_data = {}\n    for name in dir_size['packed']:\n      dir_deleted_data[name] = stats['tree_deletions'].get(name, None)\n\n    with open(os.path.join(reportdir, b\"README\"), 'bw') as f:\n      # Give a basic overview of this file\n      f.write(b\"== %s ==\\n\" % _(\"Overall Statistics\").encode())\n      f.write((\"  %s: %d\\n\" % (_(\"Number of commits\"),\n                               stats['num_commits'])).encode())\n      f.write((\"  %s: %d\\n\" % (_(\"Number of filenames\"),\n                               len(path_size['packed']))).encode())\n      f.write((\"  %s: %d\\n\" % (_(\"Number of directories\"),\n                               len(dir_size['packed']))).encode())\n      f.write((\"  %s: %d\\n\" % (_(\"Number of file extensions\"),\n                               len(ext_size['packed']))).encode())\n      f.write(b\"\\n\")\n      f.write((\"  %s: %d\\n\" % (_(\"Total unpacked size (bytes)\"),\n                               total_size['unpacked'])).encode())\n      f.write((\"  %s: %d\\n\" % (_(\"Total packed size (bytes)\"),\n                               total_size['packed'])).encode())\n      f.write(b\"\\n\")\n\n      # Mention issues with the report\n      f.write((\"== %s ==\\n\" % _(\"Caveats\")).encode())\n      f.write((\"=== %s ===\\n\" % _(\"Sizes\")).encode())\n      f.write(textwrap.dedent(_(\"\"\"\n        Packed size represents what size your repository would be if no\n        trees, commits, tags, or other metadata were included (though it may\n        fail to represent de-duplication; see below).  It also represents the\n        current packing, which may be suboptimal if you haven't gc'ed for a\n        while.\n\n        Unpacked size represents what size your repository would be if no\n        trees, commits, tags, or other metadata were included AND if no\n        files were packed; i.e., without delta-ing or compression.\n\n        Both unpacked and packed sizes can be slightly misleading.  Deleting\n        a blob from history not save as much space as the unpacked size,\n        because it is obviously normally stored in packed form.  Also,\n        deleting a blob from history may not save as much space as its packed\n        size either, because another blob could be stored as a delta against\n        that blob, so when you remove one blob another blob's packed size may\n        grow.\n\n        Also, the sum of the packed sizes can add up to more than the\n        repository size; if the same contents appeared in the repository in\n        multiple places, git will automatically de-dupe and store only one\n        copy, while the way sizes are added in this analysis adds the size\n        for each file path that has those contents.  Further, if a file is\n        ever reverted to a previous version's contents, the previous\n        version's size will be counted multiple times in this analysis, even\n        though git will only store it once.\n        \"\"\")[1:]).encode())\n      f.write(b\"\\n\")\n      f.write((\"=== %s ===\\n\" % _(\"Deletions\")).encode())\n      f.write(textwrap.dedent(_(\"\"\"\n        Whether a file is deleted is not a binary quality, since it can be\n        deleted on some branches but still exist in others.  Also, it might\n        exist in an old tag, but have been deleted in versions newer than\n        that.  More thorough tracking could be done, including looking at\n        merge commits where one side of history deleted and the other modified,\n        in order to give a more holistic picture of deletions.  However, that\n        algorithm would not only be more complex to implement, it'd also be\n        quite difficult to present and interpret by users.  Since --analyze\n        is just about getting a high-level rough picture of history, it instead\n        implements the simplistic rule that is good enough for 98% of cases:\n          A file is marked as deleted if the last commit in the fast-export\n          stream that mentions the file lists it as deleted.\n        This makes it dependent on topological ordering, but generally gives\n        the \"right\" answer.\n        \"\"\")[1:]).encode())\n      f.write(b\"\\n\")\n      f.write((\"=== %s ===\\n\" % _(\"Renames\")).encode())\n      f.write(textwrap.dedent(_(\"\"\"\n        Renames share the same non-binary nature that deletions do, plus\n        additional challenges:\n          * If the renamed file is renamed again, instead of just two names for\n            a path you can have three or more.\n          * Rename pairs of the form (oldname, newname) that we consider to be\n            different names of the \"same file\" might only be valid over certain\n            commit ranges.  For example, if a new commit reintroduces a file\n            named oldname, then new versions of oldname aren't the \"same file\"\n            anymore.  We could try to portray this to the user, but it's easier\n            for the user to just break the pairing and only report unbroken\n            rename pairings to the user.\n          * The ability for users to rename files differently in different\n            branches means that our chains of renames will not necessarily be\n            linear but may branch out.\n        \"\"\")[1:]).encode())\n      f.write(b\"\\n\")\n\n    # Equivalence classes for names, so if folks only want to keep a\n    # certain set of paths, they know the old names they want to include\n    # too.\n    with open(os.path.join(reportdir, b\"renames.txt\"), 'bw') as f:\n      seen = set()\n      for pathname,equiv_group in sorted(stats['equivalence'].items(),\n                                         key=lambda x:(x[1], x[0])):\n        if equiv_group in seen:\n          continue\n        seen.add(equiv_group)\n        f.write((\"{} ->\\n    \".format(decode(equiv_group[0])) +\n                     \"\\n    \".join(decode(x) for x in equiv_group[1:]) +\n                 \"\\n\").encode())\n\n    # List directories in reverse sorted order of unpacked size\n    with open(os.path.join(reportdir, b\"directories-deleted-sizes.txt\"), 'bw') as f:\n      msg = \"=== %s ===\\n\" % _(\"Deleted directories by reverse size\")\n      f.write(msg.encode())\n      msg = _(\"Format: unpacked size, packed size, date deleted, directory name\\n\")\n      f.write(msg.encode())\n      for dirname, size in sorted(dir_size['packed'].items(),\n                                  key=lambda x:(x[1],x[0]), reverse=True):\n        if (dir_deleted_data[dirname]):\n          f.write(b\"  %10d %10d %-10s %s\\n\" % (dir_size['unpacked'][dirname],\n                                              size,\n                                              datestr(dir_deleted_data[dirname]),\n                                              dirname or _('<toplevel>').encode()))\n\n    with open(os.path.join(reportdir, b\"directories-all-sizes.txt\"), 'bw') as f:\n      f.write((\"=== %s ===\\n\" % _(\"All directories by reverse size\")).encode())\n      msg = _(\"Format: unpacked size, packed size, date deleted, directory name\\n\")\n      f.write(msg.encode())\n      for dirname, size in sorted(dir_size['packed'].items(),\n                                  key=lambda x:(x[1],x[0]), reverse=True):\n        f.write(b\"  %10d %10d %-10s %s\\n\" % (dir_size['unpacked'][dirname],\n                                            size,\n                                            datestr(dir_deleted_data[dirname]),\n                                            dirname or _(\"<toplevel>\").encode()))\n\n    # List extensions in reverse sorted order of unpacked size\n    with open(os.path.join(reportdir, b\"extensions-deleted-sizes.txt\"), 'bw') as f:\n      msg = \"=== %s ===\\n\" % _(\"Deleted extensions by reverse size\")\n      f.write(msg.encode())\n      msg = _(\"Format: unpacked size, packed size, date deleted, extension name\\n\")\n      f.write(msg.encode())\n      for extname, size in sorted(ext_size['packed'].items(),\n                                  key=lambda x:(x[1],x[0]), reverse=True):\n        if (ext_deleted_data[extname]):\n          f.write(b\"  %10d %10d %-10s %s\\n\" % (ext_size['unpacked'][extname],\n                                              size,\n                                              datestr(ext_deleted_data[extname]),\n                                              extname or _('<no extension>').encode()))\n\n    with open(os.path.join(reportdir, b\"extensions-all-sizes.txt\"), 'bw') as f:\n      f.write((\"=== %s ===\\n\" % _(\"All extensions by reverse size\")).encode())\n      msg = _(\"Format: unpacked size, packed size, date deleted, extension name\\n\")\n      f.write(msg.encode())\n      for extname, size in sorted(ext_size['packed'].items(),\n                                  key=lambda x:(x[1],x[0]), reverse=True):\n        f.write(b\"  %10d %10d %-10s %s\\n\" % (ext_size['unpacked'][extname],\n                                            size,\n                                            datestr(ext_deleted_data[extname]),\n                                            extname or _('<no extension>').encode()))\n\n    # List files in reverse sorted order of unpacked size\n    with open(os.path.join(reportdir, b\"path-deleted-sizes.txt\"), 'bw') as f:\n      msg = \"=== %s ===\\n\" % _(\"Deleted paths by reverse accumulated size\")\n      f.write(msg.encode())\n      msg = _(\"Format: unpacked size, packed size, date deleted, path name(s)\\n\")\n      f.write(msg.encode())\n      for pathname, size in sorted(path_size['packed'].items(),\n                                   key=lambda x:(x[1],x[0]), reverse=True):\n        when = stats['file_deletions'].get(pathname, None)\n        if when:\n          f.write(b\"  %10d %10d %-10s %s\\n\" % (path_size['unpacked'][pathname],\n                                              size,\n                                              datestr(when),\n                                              pathname))\n\n    with open(os.path.join(reportdir, b\"path-all-sizes.txt\"), 'bw') as f:\n      msg = \"=== %s ===\\n\" % _(\"All paths by reverse accumulated size\")\n      f.write(msg.encode())\n      msg = _(\"Format: unpacked size, packed size, date deleted, path name\\n\")\n      f.write(msg.encode())\n      for pathname, size in sorted(path_size['packed'].items(),\n                                   key=lambda x:(x[1],x[0]), reverse=True):\n        when = stats['file_deletions'].get(pathname, None)\n        f.write(b\"  %10d %10d %-10s %s\\n\" % (path_size['unpacked'][pathname],\n                                            size,\n                                            datestr(when),\n                                            pathname))\n\n    # List of filenames and sizes in descending order\n    with open(os.path.join(reportdir, b\"blob-shas-and-paths.txt\"), 'bw') as f:\n      f.write((\"=== %s ===\\n\" % _(\"Files by sha and associated pathnames in reverse size\")).encode())\n      f.write(_(\"Format: sha, unpacked size, packed size, filename(s) object stored as\\n\").encode())\n      for sha, size in sorted(stats['packed_size'].items(),\n                              key=lambda x:(x[1],x[0]), reverse=True):\n        if sha not in stats['names']:\n          # Some objects in the repository might not be referenced, or not\n          # referenced by the branches/tags the user cares about; skip them.\n          continue\n        names_with_sha = stats['names'][sha]\n        if len(names_with_sha) == 1:\n          names_with_sha = names_with_sha.pop()\n        else:\n          names_with_sha = b'[' + b', '.join(sorted(names_with_sha)) + b']'\n        f.write(b\"  %s %10d %10d %s\\n\" % (sha,\n                                          stats['unpacked_size'][sha],\n                                          size,\n                                          names_with_sha))\n\n  @staticmethod\n  def run(args):\n    if args.report_dir:\n      reportdir = args.report_dir\n    else:\n      git_dir = GitUtils.determine_git_dir(b'.')\n\n    # Create the report directory as necessary\n      results_tmp_dir = os.path.join(git_dir, b'filter-repo')\n      if not os.path.isdir(results_tmp_dir):\n        os.mkdir(results_tmp_dir)\n      reportdir = os.path.join(results_tmp_dir, b\"analysis\")\n\n    if os.path.isdir(reportdir):\n      if args.force:\n        sys.stdout.write(_(\"Warning: Removing recursively: \\\"%s\\\"\") % decode(reportdir))\n        shutil.rmtree(reportdir)\n      else:\n        sys.stdout.write(_(\"Error: dir already exists (use --force to delete): \\\"%s\\\"\\n\") % decode(reportdir))\n        sys.exit(1)\n\n    os.mkdir(reportdir)\n\n    # Gather the data we need\n    stats = RepoAnalyze.gather_data(args)\n\n    # Write the reports\n    sys.stdout.write(_(\"Writing reports to %s...\") % decode(reportdir))\n    sys.stdout.flush()\n    RepoAnalyze.write_report(reportdir, stats)\n    sys.stdout.write(_(\"done.\\n\"))\n\nclass FileInfoValueHelper:\n  def __init__(self, replace_text, insert_blob_func, source_working_dir):\n    self.data = {}\n    self._replace_text = replace_text\n    self._insert_blob_func = insert_blob_func\n    cmd = ['git', 'cat-file', '--batch-command']\n    self._cat_file_process = subproc.Popen(cmd,\n                                           stdin = subprocess.PIPE,\n                                           stdout = subprocess.PIPE,\n                                           cwd = source_working_dir)\n\n  def finalize(self):\n    self._cat_file_process.stdin.close()\n    self._cat_file_process.wait()\n\n  def get_contents_by_identifier(self, blobhash):\n    self._cat_file_process.stdin.write(b'contents '+blobhash+b'\\n')\n    self._cat_file_process.stdin.flush()\n    line = self._cat_file_process.stdout.readline()\n    try:\n      (oid, oidtype, size) = line.split()\n    except ValueError:\n      assert(line == blobhash+b\" missing\\n\")\n      return None\n    size = int(size) # Convert e.g. b'6283' to 6283\n    assert(oidtype == b'blob')\n    contents_plus_newline = self._cat_file_process.stdout.read(size+1)\n    return contents_plus_newline[:-1] # return all but the newline\n\n  def get_size_by_identifier(self, blobhash):\n    self._cat_file_process.stdin.write(b'info '+blobhash+b'\\n')\n    self._cat_file_process.stdin.flush()\n    line = self._cat_file_process.stdout.readline()\n    (oid, oidtype, size) = line.split()\n    size = int(size) # Convert e.g. b'6283' to 6283\n    assert(oidtype == b'blob')\n    return size\n\n  def insert_file_with_contents(self, contents):\n    blob = Blob(contents)\n    self._insert_blob_func(blob)\n    return blob.id\n\n  def is_binary(self, contents):\n    return b\"\\0\" in contents[0:8192]\n\n  def apply_replace_text(self, contents):\n    new_contents = contents\n    for literal, replacement in self._replace_text['literals']:\n      new_contents = new_contents.replace(literal, replacement)\n    for regex,   replacement in self._replace_text['regexes']:\n      new_contents = regex.sub(replacement, new_contents)\n    return new_contents\n\nclass LFSObjectTracker:\n  class LFSObjs:\n    def __init__(self):\n      self.id_to_object_map = {}\n      self.objects = set()\n\n  def __init__(self, file_info, check_sources, check_targets):\n    self.source_objects = LFSObjectTracker.LFSObjs()\n    self.target_objects = LFSObjectTracker.LFSObjs()\n    self.hash_to_object_map = {}\n    self.file_info = file_info\n    self.check_sources = check_sources\n    self.check_targets = check_targets\n    self.objects_orphaned = False\n\n  def _get_lfs_values(self, contents):\n    values = {}\n    if len(contents) > 1024:\n      return {}\n    for line in contents.splitlines():\n      try:\n        (key, value) = line.split(b' ', 1)\n      except ValueError:\n        return {}\n      if not values and key != b'version':\n        return values\n      values[key] = value\n    return values\n\n  def check_blob_data(self, contents, fast_export_id, source):\n    if source and not self.check_sources:\n      return\n    mymap = self.source_objects if source else self.target_objects\n    lfs_object_id = self._get_lfs_values(contents).get(b'oid')\n    if lfs_object_id:\n      mymap.id_to_object_map[fast_export_id] = lfs_object_id\n\n  def check_file_change_data(self, git_id, source):\n    if source and not self.check_sources:\n      return\n    mymap = self.source_objects if source else self.target_objects\n    if isinstance(git_id, int):\n      lfs_object_id = mymap.id_to_object_map.get(git_id)\n      if lfs_object_id:\n        mymap.objects.add(lfs_object_id)\n    else:\n      if git_id in self.hash_to_object_map:\n        mymap.objects.add(self.hash_to_object_map[git_id])\n        return\n      size = self.file_info.get_size_by_identifier(git_id)\n      if size >= 1024:\n        return\n      contents = self.file_info.get_contents_by_identifier(git_id)\n      lfs_object_id = self._get_lfs_values(contents).get(b'oid')\n      if lfs_object_id:\n        self.hash_to_object_map[git_id] = lfs_object_id\n        mymap.objects.add(lfs_object_id)\n\n  def check_output_object(self, obj):\n    if not self.check_targets:\n      return\n    if type(obj) == Blob:\n      self.check_blob_data(obj.data, obj.id, False)\n    elif type(obj) == Commit:\n      for change in obj.file_changes:\n        if change.type != b'M':\n          continue\n        self.check_file_change_data(change.blob_id, False)\n\n  def find_all_lfs_objects_in_repo(self, repo, source):\n    if not source:\n      self.file_info = FileInfoValueHelper(None, None, repo)\n    p = subproc.Popen([\"git\", \"rev-list\", \"--objects\", \"--all\"],\n                      stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                      cwd=repo)\n    for line in p.stdout.readlines():\n      try:\n        (git_oid, filename) = line.split()\n      except ValueError:\n        # Commit and tree objects only have oid\n        continue\n\n      mymap = self.source_objects if source else self.target_objects\n      size = self.file_info.get_size_by_identifier(git_oid)\n      if size >= 1024:\n        continue\n      contents = self.file_info.get_contents_by_identifier(git_oid)\n      lfs_object_id = self._get_lfs_values(contents).get(b'oid')\n      if lfs_object_id:\n        mymap.objects.add(lfs_object_id)\n    if not source:\n      self.file_info.finalize()\n\nclass InputFileBackup:\n  def __init__(self, input_file, output_file):\n    self.input_file  = input_file\n    self.output_file = output_file\n\n  def close(self):\n    self.input_file.close()\n    self.output_file.close()\n\n  def read(self, size):\n    output = self.input_file.read(size)\n    self.output_file.write(output)\n    return output\n\n  def readline(self):\n    line = self.input_file.readline()\n    self.output_file.write(line)\n    return line\n\nclass DualFileWriter:\n  def __init__(self, file1, file2):\n    self.file1 = file1\n    self.file2 = file2\n\n  def write(self, *args):\n    self.file1.write(*args)\n    self.file2.write(*args)\n\n  def flush(self):\n    self.file1.flush()\n    self.file2.flush()\n\n  def close(self):\n    self.file1.close()\n    self.file2.close()\n\nclass RepoFilter(object):\n  def __init__(self,\n               args,\n               filename_callback = None,\n               message_callback = None,\n               name_callback = None,\n               email_callback = None,\n               refname_callback = None,\n               blob_callback = None,\n               commit_callback = None,\n               tag_callback = None,\n               reset_callback = None,\n               done_callback = None,\n               file_info_callback = None):\n\n    self._args = args\n\n    # Repo we are exporting\n    self._repo_working_dir = None\n\n    # Store callbacks for acting on objects printed by FastExport\n    self._blob_callback        = blob_callback\n    self._commit_callback      = commit_callback\n    self._tag_callback         = tag_callback\n    self._reset_callback       = reset_callback\n    self._done_callback        = done_callback\n\n    # Store callbacks for acting on slices of FastExport objects\n    self._filename_callback    = filename_callback  # filenames from commits\n    self._message_callback     = message_callback   # commit OR tag message\n    self._name_callback        = name_callback      # author, committer, tagger\n    self._email_callback       = email_callback     # author, committer, tagger\n    self._refname_callback     = refname_callback   # from commit/tag/reset\n    self._file_info_callback   = file_info_callback # various file info\n    self._handle_arg_callbacks()\n\n    # Helpers for callbacks\n    self._file_info_value = None\n\n    # Defaults for input\n    self._input = None\n    self._fep = None  # Fast Export Process\n    self._fe_orig = None  # Path to where original fast-export output stored\n    self._fe_filt = None  # Path to where filtered fast-export output stored\n    self._parser = None # FastExportParser object we are working with\n\n    # Defaults for output\n    self._output = None\n    self._fip = None  # Fast Import Process\n    self._import_pipes = None\n    self._managed_output = True\n\n    # A tuple of (depth, list-of-ancestors).  Commits and ancestors are\n    # identified by their id (their 'mark' in fast-export or fast-import\n    # speak).  The depth of a commit is one more than the max depth of any\n    # of its ancestors.\n    self._graph = AncestryGraph()\n    # Another one, for ancestry of commits in the original repo\n    self._orig_graph = AncestryGraph()\n\n    # Names of files that were tweaked in any commit; such paths could lead\n    # to subsequent commits being empty\n    self._files_tweaked = set()\n\n    # A set of commit hash pairs (oldhash, newhash) which used to be merge\n    # commits but due to filtering were turned into non-merge commits.\n    # The commits probably have suboptimal commit messages (e.g. \"Merge branch\n    # next into master\").\n    self._commits_no_longer_merges = []\n\n    # A dict of original_ids to new_ids; filtering commits means getting\n    # new commit hash (sha1sums), and we record the mapping both for\n    # diagnostic purposes and so we can rewrite commit messages.  Note that\n    # the new_id can be None rather than a commit hash if the original\n    # commit became empty and was pruned or was otherwise dropped.\n    self._commit_renames = {}\n\n    # A set of original_ids (i.e. original hashes) for which we have not yet\n    # gotten the new hashses; the value is always the corresponding fast-export\n    # id (i.e. commit.id)\n    self._pending_renames = collections.OrderedDict()\n\n    # A dict of commit_hash[0:7] -> set(commit_hashes with that prefix).\n    #\n    # It's common for commit messages to refer to commits by abbreviated\n    # commit hashes, as short as 7 characters.  To facilitate translating\n    # such short hashes, we have a mapping of prefixes to full old hashes.\n    self._commit_short_old_hashes = collections.defaultdict(set)\n\n    # A set of commit hash references appearing in commit messages which\n    # mapped to a valid commit that was removed entirely in the filtering\n    # process.  The commit message will continue to reference the\n    # now-missing commit hash, since there was nothing to map it to.\n    self._commits_referenced_but_removed = set()\n\n    # Other vars related to metadata tracking\n    self._already_ran = False\n    self._changed_refs = set()\n    self._lfs_object_tracker = None\n\n    # Progress handling (number of commits parsed, etc.)\n    self._progress_writer = ProgressWriter()\n    self._num_commits = 0\n\n    # Size of blobs in the repo\n    self._unpacked_size = {}\n\n    # Other vars\n    self._sanity_checks_handled = False\n    self._finalize_handled = False\n    self._orig_refs = None\n    self._config_settings = {}\n    self._newnames = {}\n    self._stash = None\n\n    # Cache a few message translations for performance reasons\n    self._parsed_message = _(\"Parsed %d commits\")\n\n    # Compile some regexes and cache those\n    self._hash_re = re.compile(br'(\\b[0-9a-f]{7,40}\\b)')\n\n  def _handle_arg_callbacks(self):\n    def make_callback(args, bdy):\n      callback_globals = {g: globals()[g] for g in public_globals}\n      callback_locals = {}\n      if type(args) == str:\n        args = (args, '_do_not_use_this_var = None')\n      exec('def callback({}):\\n'.format(', '.join(args))+\n           '  '+'\\n  '.join(bdy.splitlines()), callback_globals, callback_locals)\n      return callback_locals['callback']\n    def handle(which, args=None):\n      which_under = which.replace('-','_')\n      if not args:\n        args = which\n      callback_field = '_{}_callback'.format(which_under)\n      code_string = getattr(self._args, which_under+'_callback')\n      if code_string:\n        if os.path.exists(code_string):\n          with open(code_string, 'r', encoding='utf-8') as f:\n            code_string = f.read()\n        if getattr(self, callback_field):\n          raise SystemExit(_(\"Error: Cannot pass a %s_callback to RepoFilter \"\n                             \"AND pass --%s-callback\"\n                           % (which_under, which)))\n        if 'return ' not in code_string and \\\n           which not in ('blob', 'commit', 'tag', 'reset'):\n          raise SystemExit(_(\"Error: --%s-callback should have a return statement\")\n                           % which)\n        setattr(self, callback_field, make_callback(args, code_string))\n    handle('filename')\n    handle('message')\n    handle('name')\n    handle('email')\n    handle('refname')\n    handle('blob')\n    handle('commit')\n    handle('tag')\n    handle('reset')\n    handle('file-info', ('filename', 'mode', 'blob_id', 'value'))\n\n  def _run_sanity_checks(self):\n    self._sanity_checks_handled = True\n    if not self._managed_output:\n      if not self._args.replace_refs:\n        # If not _managed_output we don't want to make extra changes to the\n        # repo, so set default to no-op 'update-no-add'\n        self._args.replace_refs = 'update-no-add'\n      return\n\n    if self._args.debug:\n      print(\"[DEBUG] Passed arguments:\\n{}\".format(self._args))\n\n    # Determine basic repository information\n    target_working_dir = self._args.target or b'.'\n    self._orig_refs = GitUtils.get_refs(target_working_dir)\n    is_bare = GitUtils.is_repository_bare(target_working_dir)\n    self._config_settings = GitUtils.get_config_settings(target_working_dir)\n\n    # Determine if this is second or later run of filter-repo\n    tmp_dir = self.results_tmp_dir(create_if_missing=False)\n    ran_path = os.path.join(tmp_dir, b'already_ran')\n    self._already_ran = os.path.isfile(ran_path)\n    if self._already_ran:\n      current_time = time.time()\n      file_mod_time = os.path.getmtime(ran_path)\n      file_age = current_time - file_mod_time\n      if file_age > 86400: # file older than a day\n        msg = (f\"The previous run is older than a day ({decode(ran_path)} already exists).\\n\"\n               f\"See \\\"Already Ran\\\" section in the manual for more information.\\n\"\n               f\"Treat this run as a continuation of filtering in the previous run (Y/N)? \")\n        response = input(msg)\n\n        if response.lower() != 'y':\n          os.remove(ran_path)\n          self._already_ran = False\n\n    # Interaction between --already-ran and --sensitive_data_removal\n    msg = textwrap.dedent(_(\"\"\"\\\n      Error: Cannot specify --sensitive-data-removal on a follow-up invocation\n             of git-filter-repo unless it was specified in previously runs.\"\"\"))\n    if self._already_ran:\n      sdr_path = os.path.join(tmp_dir, b'sensitive_data_removal')\n      sdr_previously = os.path.isfile(sdr_path)\n      if not sdr_previously and self._args.sensitive_data_removal:\n        raise SystemExit(msg)\n      # Treat this as a --sensitive-data-removal run if a previous run was,\n      # even if it wasn't specified this time\n      self._args.sensitive_data_removal = sdr_previously\n\n    # Have to check sensitive_data_removal interactions here instead of\n    # sanity_check_args because of the above interaction with already_ran stuff\n    if self._args.sensitive_data_removal:\n      if self._args.stdin:\n        msg = _(\"Error: sensitive data removal is incompatible with --stdin\")\n        raise SystemExit(msg)\n      if self._args.source or self._args.target:\n        msg = _(\"Error: sensitive data removal is incompatible with --source and --target\")\n        raise SystemExit(msg)\n\n    # Default for --replace-refs\n    if not self._args.replace_refs:\n      self._args.replace_refs = 'delete-no-add'\n    if self._args.replace_refs == 'old-default':\n      self._args.replace_refs = ('update-or-add' if self._already_ran\n                                 else 'update-and-add')\n\n    # Do sanity checks from the correct directory\n    if not self._args.force and not self._already_ran:\n      cwd = os.getcwd()\n      os.chdir(target_working_dir)\n      RepoFilter.sanity_check(self._orig_refs, is_bare, self._config_settings)\n      os.chdir(cwd)\n\n  def _setup_lfs_orphaning_checks(self):\n    # Do a couple checks to see if we want to do lfs orphaning checks\n    if not self._args.sensitive_data_removal:\n      return\n    metadata_dir = self.results_tmp_dir()\n    lfs_objects_file = os.path.join(metadata_dir, b'original_lfs_objects')\n    if self._already_ran:\n      # Check if we did lfs filtering in the previous run\n      if not os.path.isfile(lfs_objects_file):\n        return\n\n    # Set up self._file_info_value so we can query git for stuff\n    source_working_dir = self._args.source or b'.'\n    self._file_info_value = FileInfoValueHelper(self._args.replace_text,\n                                                self.insert,\n                                                source_working_dir)\n\n    # One more check to see if we want to do lfs orphaning checks\n    if not self._already_ran:\n      # Check if lfs filtering is active in HEAD's .gitattributes file\n      a = self._file_info_value.get_contents_by_identifier(b\"HEAD:.gitattributes\")\n      if not a or not re.search(rb'\\bfilter=lfs\\b', a):\n        return\n\n    # Set up the object tracker\n    check_sources = not self._already_ran and not self._args.partial\n    check_targets = not self._args.partial\n    self._lfs_object_tracker = LFSObjectTracker(self._file_info_value,\n                                                check_sources,\n                                                check_targets)\n    self._parser._lfs_object_tracker = self._lfs_object_tracker # kinda gross\n\n    # Get initial objects\n    if self._already_ran:\n      with open(lfs_objects_file, 'br') as f:\n        for line in f:\n          self._lfs_object_tracker.source_objects.objects.add(line.strip())\n    elif self._args.partial:\n      source = True\n      self._lfs_object_tracker.find_all_lfs_objects_in_repo(source_working_dir,\n                                                            source)\n\n  @staticmethod\n  def loose_objects_are_replace_refs(git_dir, refs, num_loose_objects):\n    replace_objects = set()\n    for refname, rev in refs.items():\n      if not refname.startswith(b'refs/replace/'):\n        continue\n      replace_objects.add(rev)\n\n    validobj_re = re.compile(rb'^[0-9a-f]{40}$')\n    object_dir=os.path.join(git_dir, b'objects')\n    for root, dirs, files in os.walk(object_dir):\n      for filename in files:\n        objname = os.path.basename(root)+filename\n        if objname not in replace_objects and validobj_re.match(objname):\n          return False\n\n    return True\n\n  @staticmethod\n  def sanity_check(refs, is_bare, config_settings):\n    def abort(reason):\n      dirname = config_settings.get(b'remote.origin.url', b'')\n      msg = \"\"\n      if dirname and os.path.isdir(dirname):\n        msg = _(\"Note: when cloning local repositories, you need to pass\\n\"\n                \"      --no-local to git clone to avoid this issue.\\n\")\n      raise SystemExit(\n        _(\"Aborting: Refusing to destructively overwrite repo history since\\n\"\n          \"this does not look like a fresh clone.\\n\"\n          \"  (%s)\\n%s\"\n          \"Please operate on a fresh clone instead.  If you want to proceed\\n\"\n          \"anyway, use --force.\") % (reason, msg))\n\n    # Avoid letting people running with weird setups and overwriting GIT_DIR\n    # elsewhere\n    git_dir = GitUtils.determine_git_dir(b'.')\n    if is_bare and git_dir != b'.':\n      abort(_(\"GIT_DIR must be .\"))\n    elif not is_bare and git_dir != b'.git':\n      abort(_(\"GIT_DIR must be .git\"))\n\n    # Check for refname collisions\n    if config_settings.get(b'core.ignorecase', b'false') == b'true':\n      collisions = collections.defaultdict(list)\n      for ref in refs:\n        collisions[ref.lower()].append(ref)\n      msg = \"\"\n      for ref in collisions:\n        if len(collisions[ref]) >= 2:\n          msg += \"    \" + decode(b\", \".join(collisions[ref])) + \"\\n\"\n      if msg:\n        raise SystemExit(\n          _(\"Aborting: Cannot rewrite history on a case insensitive\\n\"\n            \"filesystem since you have refs that differ in case only:\\n\"\n            \"%s\") % msg)\n    if config_settings.get(b'core.precomposeunicode', b'false') == b'true':\n      import unicodedata # Mac users need to have python-3.8\n      collisions = collections.defaultdict(list)\n      for ref in refs:\n        strref = decode(ref)\n        collisions[unicodedata.normalize('NFC', strref)].append(strref)\n      msg = \"\"\n      for ref in collisions:\n        if len(collisions[ref]) >= 2:\n          msg += \"    \" + \", \".join(collisions[ref]) + \"\\n\"\n      if msg:\n        raise SystemExit(\n          _(\"Aborting: Cannot rewrite history on a character normalizing\\n\"\n            \"filesystem since you have refs that differ in normalization:\\n\"\n            \"%s\") % msg)\n\n    # Make sure repo is fully packed, just like a fresh clone would be.\n    # Note that transfer.unpackLimit defaults to 100, meaning that a\n    # repository with no packs and less than 100 objects should be considered\n    # fully packed.\n    output = subproc.check_output('git count-objects -v'.split())\n    stats = dict(x.split(b': ') for x in output.splitlines())\n    num_packs = int(stats[b'packs'])\n    num_loose_objects = int(stats[b'count'])\n    if num_packs > 1 or \\\n       num_loose_objects >= 100 or \\\n       (num_packs == 1 and num_loose_objects > 0 and\n        not RepoFilter.loose_objects_are_replace_refs(git_dir, refs,\n                                                      num_loose_objects)):\n      abort(_(\"expected freshly packed repo\"))\n\n    # Make sure there is precisely one remote, named \"origin\"...or that this\n    # is a new bare repo with no packs and no remotes\n    output = subproc.check_output('git remote'.split()).strip()\n    if not (output == b\"origin\" or (num_packs == 0 and not output)):\n      abort(_(\"expected one remote, origin\"))\n\n    # Make sure that all reflogs have precisely one entry\n    reflog_dir=os.path.join(git_dir, b'logs')\n    for root, dirs, files in os.walk(reflog_dir):\n      for filename in files:\n        pathname = os.path.join(root, filename)\n        with open(pathname, 'br') as f:\n          if len(f.read().splitlines()) > 1:\n            shortpath = pathname[len(reflog_dir)+1:]\n            abort(_(\"expected at most one entry in the reflog for %s\") %\n                  decode(shortpath))\n\n    # Make sure there are no stashed changes\n    if b'refs/stash' in refs:\n      abort(_(\"has stashed changes\"))\n\n    # Do extra checks in non-bare repos\n    if not is_bare:\n      # Avoid uncommitted, unstaged, or untracked changes\n      if subproc.call('git diff --staged --quiet'.split()):\n        abort(_(\"you have uncommitted changes\"))\n      if subproc.call('git diff --quiet'.split()):\n        abort(_(\"you have unstaged changes\"))\n      untracked_output = subproc.check_output('git ls-files -o'.split())\n      if len(untracked_output) > 0:\n        uf = untracked_output.rstrip(b'\\n').split(b'\\n')\n        # Since running git-filter-repo can result in files being written to\n        # __pycache__ (depending on python version, env vars, etc.), let's\n        # ignore those as far as \"clean clone\" is concerned.\n        relevant_uf = [x for x in uf\n                       if not x.startswith(b'__pycache__/git_filter_repo.')]\n        if len(relevant_uf) > 0:\n          abort(_(\"you have untracked changes\"))\n\n      # Avoid unpushed changes\n      for refname, rev in refs.items():\n        if not refname.startswith(b'refs/heads/'):\n          continue\n        origin_ref = refname.replace(b'refs/heads/', b'refs/remotes/origin/')\n        if origin_ref not in refs:\n          abort(_('%s exists, but %s not found') % (decode(refname),\n                                                    decode(origin_ref)))\n        if rev != refs[origin_ref]:\n          abort(_('%s does not match %s') % (decode(refname),\n                                             decode(origin_ref)))\n\n      # Make sure there is only one worktree\n      output = subproc.check_output('git worktree list'.split())\n      if len(output.splitlines()) > 1:\n        abort(_('you have multiple worktrees'))\n\n  def cleanup(self, repo, repack, reset,\n              run_quietly=False, show_debuginfo=False):\n    ''' cleanup repo; if repack then expire reflogs and do a gc --prune=now.\n        if reset then do a reset --hard.  Optionally also curb output if\n        run_quietly is True, or go the opposite direction and show extra\n        output if show_debuginfo is True. '''\n    assert not (run_quietly and show_debuginfo)\n\n    if (repack and not run_quietly and not show_debuginfo):\n      print(_(\"Repacking your repo and cleaning out old unneeded objects\"))\n    quiet_flags = '--quiet' if run_quietly else ''\n    cleanup_cmds = []\n    if repack:\n      cleanup_cmds = ['git reflog expire --expire=now --all'.split(),\n                      'git gc {} --prune=now'.format(quiet_flags).split()]\n    if reset:\n      cleanup_cmds.insert(0, 'git reset {} --hard'.format(quiet_flags).split())\n    location_info = ' (in {})'.format(decode(repo)) if repo != b'.' else ''\n    for cmd in cleanup_cmds:\n      if show_debuginfo:\n        print(\"[DEBUG] Running{}: {}\".format(location_info, ' '.join(cmd)))\n      ret = subproc.call(cmd, cwd=repo)\n      if ret != 0:\n        raise SystemExit(\"fatal: running '%s' failed!\" % ' '.join(cmd))\n      if cmd[0:3] == 'git reflog expire'.split():\n        self._write_stash()\n\n  def _get_rename(self, old_hash):\n    # If we already know the rename, just return it\n    new_hash = self._commit_renames.get(old_hash, None)\n    if new_hash:\n      return new_hash\n\n    # If it's not in the remaining pending renames, we don't know it\n    if old_hash is not None and old_hash not in self._pending_renames:\n      return None\n\n    # Read through the pending renames until we find it or we've read them all,\n    # and return whatever we might find\n    self._flush_renames(old_hash)\n    return self._commit_renames.get(old_hash, None)\n\n  def _flush_renames(self, old_hash=None, limit=0):\n    # Parse through self._pending_renames until we have read enough.  We have\n    # read enough if:\n    #   self._pending_renames is empty\n    #   old_hash != None and we found a rename for old_hash\n    #   limit > 0 and len(self._pending_renames) started less than 2*limit\n    #   limit > 0 and len(self._pending_renames) < limit\n    if limit and len(self._pending_renames) < 2 * limit:\n      return\n    fi_input, fi_output = self._import_pipes\n    while self._pending_renames:\n      orig_hash, new_fast_export_id = self._pending_renames.popitem(last=False)\n      new_hash = fi_output.readline().rstrip()\n      self._commit_renames[orig_hash] = new_hash\n      self._graph.record_hash(new_fast_export_id, new_hash)\n      if old_hash == orig_hash:\n        return\n      if limit and len(self._pending_renames) < limit:\n        return\n\n  def _translate_commit_hash(self, matchobj_or_oldhash):\n    old_hash = matchobj_or_oldhash\n    if not isinstance(matchobj_or_oldhash, bytes):\n      old_hash = matchobj_or_oldhash.group(1)\n    orig_len = len(old_hash)\n    new_hash = self._get_rename(old_hash)\n    if new_hash is None:\n      if old_hash[0:7] not in self._commit_short_old_hashes:\n        self._commits_referenced_but_removed.add(old_hash)\n        return old_hash\n      possibilities = self._commit_short_old_hashes[old_hash[0:7]]\n      matches = [x for x in possibilities\n                 if x[0:orig_len] == old_hash]\n      if len(matches) != 1:\n        self._commits_referenced_but_removed.add(old_hash)\n        return old_hash\n      old_hash = matches[0]\n      new_hash = self._get_rename(old_hash)\n\n    assert new_hash is not None\n    return new_hash[0:orig_len]\n\n  def _maybe_trim_extra_parents(self, orig_parents, parents):\n    '''Due to pruning of empty commits, some parents could be non-existent\n       (None) or otherwise redundant.  Remove the non-existent parents, and\n       remove redundant parents ***SO LONG AS*** that doesn't transform a\n       merge commit into a non-merge commit.\n\n       Returns a tuple:\n         (parents, new_first_parent_if_would_become_non_merge)'''\n\n    always_prune = (self._args.prune_degenerate == 'always')\n\n    # Pruning of empty commits means multiple things:\n    #   * An original parent of this commit may have been pruned causing the\n    #     need to rewrite the reported parent to the nearest ancestor.  We\n    #     want to know when we're dealing with such a parent.\n    #   * Further, there may be no \"nearest ancestor\" if the entire history\n    #     of that parent was also pruned.  (Detectable by the parent being\n    #     'None')\n    # Remove all parents rewritten to None, and keep track of which parents\n    # were rewritten to an ancestor.\n    tmp = zip(parents,\n              orig_parents,\n              [(x in _SKIPPED_COMMITS or always_prune) for x in orig_parents])\n    tmp2 = [x for x in tmp if x[0] is not None]\n    if not tmp2:\n      # All ancestors have been pruned; we have no parents.\n      return [], None\n    parents, orig_parents, is_rewritten = [list(x) for x in zip(*tmp2)]\n\n    # We can't have redundant parents if we don't have at least 2 parents\n    if len(parents) < 2:\n      return parents, None\n\n    # Don't remove redundant parents if user doesn't want us to\n    if self._args.prune_degenerate == 'never':\n      return parents, None\n\n    # Remove duplicate parents (if both sides of history have lots of commits\n    # which become empty due to pruning, the most recent ancestor on both\n    # sides may be the same commit), except only remove parents that have\n    # been rewritten due to previous empty pruning.\n    seen = set()\n    seen_add = seen.add\n    # Deleting duplicate rewritten parents means keeping parents if either\n    # they have not been seen or they are ones that have not been rewritten.\n    parents_copy = parents\n    uniq = [[p, orig_parents[i], is_rewritten[i]] for i, p in enumerate(parents)\n            if not (p in seen or seen_add(p)) or not is_rewritten[i]]\n    parents, orig_parents, is_rewritten = [list(x) for x in zip(*uniq)]\n    if len(parents) < 2:\n      return parents_copy, parents[0]\n\n    # Flatten unnecessary merges.  (If one side of history is entirely\n    # empty commits that were pruned, we may end up attempting to\n    # merge a commit with its ancestor.  Remove parents that are an\n    # ancestor of another parent.)\n    num_parents = len(parents)\n    to_remove = []\n    for cur in range(num_parents):\n      if not is_rewritten[cur]:\n        continue\n      for other in range(num_parents):\n        if cur == other:\n          continue\n        if not self._graph.is_ancestor(parents[cur], parents[other]):\n          continue\n        # parents[cur] is an ancestor of parents[other], so parents[cur]\n        # seems redundant.  However, if it was intentionally redundant\n        # (e.g. a no-ff merge) in the original, then we want to keep it.\n        if not always_prune and \\\n           self._orig_graph.is_ancestor(orig_parents[cur],\n                                        orig_parents[other]):\n          continue\n        # Some folks want their history to have all first parents be merge\n        # commits (except for any root commits), and always do a merge --no-ff.\n        # For such folks, don't remove the first parent even if it's an\n        # ancestor of other commits.\n        if self._args.no_ff and cur == 0:\n          continue\n        # Okay so the cur-th parent is an ancestor of the other-th parent,\n        # and it wasn't that way in the original repository; mark the\n        # cur-th parent as removable.\n        to_remove.append(cur)\n        break # cur removed, so skip rest of others -- i.e. check cur+=1\n    for x in reversed(to_remove):\n      parents.pop(x)\n    if len(parents) < 2:\n      return parents_copy, parents[0]\n\n    return parents, None\n\n  def _prunable(self, commit, new_1st_parent, had_file_changes, orig_parents):\n    parents = commit.parents\n\n    if self._args.prune_empty == 'never':\n      return False\n    always_prune = (self._args.prune_empty == 'always')\n\n    # For merge commits, unless there are prunable (redundant) parents, we\n    # do not want to prune\n    if len(parents) >= 2 and not new_1st_parent:\n      return False\n\n    if len(parents) < 2:\n      # Special logic for commits that started empty...\n      if not had_file_changes and not always_prune:\n        had_parents_pruned = (len(parents) < len(orig_parents) or\n                              (len(orig_parents) == 1 and\n                               orig_parents[0] in _SKIPPED_COMMITS))\n        # If the commit remains empty and had parents which were pruned,\n        # then prune this commit; otherwise, retain it\n        return (not commit.file_changes and had_parents_pruned)\n\n      # We can only get here if the commit didn't start empty, so if it's\n      # empty now, it obviously became empty\n      if not commit.file_changes:\n        return True\n\n    # If there are no parents of this commit and we didn't match the case\n    # above, then this commit cannot be pruned.  Since we have no parent(s)\n    # to compare to, abort now to prevent future checks from failing.\n    if not parents:\n      return False\n\n    # Similarly, we cannot handle the hard cases if we don't have a pipe\n    # to communicate with fast-import\n    if not self._import_pipes:\n      return False\n\n    # If there have not been renames/remappings of IDs (due to insertion of\n    # new blobs), then we can sometimes know things aren't prunable with a\n    # simple check\n    if not _IDS.has_renames():\n      # non-merge commits can only be empty if blob/file-change editing caused\n      # all file changes in the commit to have the same file contents as\n      # the parent.\n      changed_files = set(change.filename for change in commit.file_changes)\n      if len(orig_parents) < 2 and changed_files - self._files_tweaked:\n        return False\n\n    # Finally, the hard case: due to either blob rewriting, or due to pruning\n    # of empty commits wiping out the first parent history back to the merge\n    # base, the list of file_changes we have may not actually differ from our\n    # (new) first parent's version of the files, i.e. this would actually be\n    # an empty commit.  Check by comparing the contents of this commit to its\n    # (remaining) parent.\n    #\n    # NOTE on why this works, for the case of original first parent history\n    # having been pruned away due to being empty:\n    #     The first parent history having been pruned away due to being\n    #     empty implies the original first parent would have a tree (after\n    #     filtering) that matched the merge base's tree.  Since\n    #     file_changes has the changes needed to go from what would have\n    #     been the first parent to our new commit, and what would have been\n    #     our first parent has a tree that matches the merge base, then if\n    #     the new first parent has a tree matching the versions of files in\n    #     file_changes, then this new commit is empty and thus prunable.\n    fi_input, fi_output = self._import_pipes\n    self._flush_renames()  # Avoid fi_output having other stuff present\n    # Optimization note: we could have two loops over file_changes, the\n    # first doing all the self._output.write() calls, and the second doing\n    # the rest.  But I'm worried about fast-import blocking on fi_output\n    # buffers filling up so I instead read from it as I go.\n    for change in commit.file_changes:\n      parent = new_1st_parent or commit.parents[0] # exists due to above checks\n      quoted_filename = PathQuoting.enquote(change.filename)\n      if isinstance(parent, int):\n        self._output.write(b\"ls :%d %s\\n\" % (parent, quoted_filename))\n      else:\n        self._output.write(b\"ls %s %s\\n\" % (parent, quoted_filename))\n      self._output.flush()\n      parent_version = fi_output.readline().split()\n      if change.type == b'D':\n        if parent_version != [b'missing', quoted_filename]:\n          return False\n      else:\n        blob_sha = change.blob_id\n        if isinstance(change.blob_id, int):\n          self._output.write(b\"get-mark :%d\\n\" % change.blob_id)\n          self._output.flush()\n          blob_sha = fi_output.readline().rstrip()\n        if parent_version != [change.mode, b'blob', blob_sha, quoted_filename]:\n          return False\n\n    return True\n\n  def _record_remapping(self, commit, orig_parents):\n    new_id = None\n    # Record the mapping of old commit hash to new one\n    if commit.original_id and self._import_pipes:\n      fi_input, fi_output = self._import_pipes\n      self._output.write(b\"get-mark :%d\\n\" % commit.id)\n      self._output.flush()\n      orig_id = commit.original_id\n      self._commit_short_old_hashes[orig_id[0:7]].add(orig_id)\n      # Note that we have queued up an id for later reading; flush a\n      # few of the older ones if we have too many queued up\n      self._pending_renames[orig_id] = commit.id\n      self._flush_renames(None, limit=40)\n    # Also, record if this was a merge commit that turned into a non-merge\n    # commit.\n    if len(orig_parents) >= 2 and len(commit.parents) < 2:\n      self._commits_no_longer_merges.append((commit.original_id, new_id))\n\n  def callback_metadata(self, extra_items = dict()):\n    return {'commit_rename_func': self._translate_commit_hash,\n            'ancestry_graph': self._graph,\n            'original_ancestry_graph': self._orig_graph,\n            **extra_items}\n\n  def _tweak_blob(self, blob):\n    if self._args.max_blob_size and len(blob.data) > self._args.max_blob_size:\n      blob.skip()\n\n    if blob.original_id in self._args.strip_blobs_with_ids:\n      blob.skip()\n\n    if ( self._args.replace_text\n        and not self._file_info_callback\n        # not (if blob contains zero byte in the first 8Kb, that is, if blob is binary data)\n        and not b\"\\0\" in blob.data[0:8192]\n    ):\n      for literal, replacement in self._args.replace_text['literals']:\n        blob.data = blob.data.replace(literal, replacement)\n      for regex,   replacement in self._args.replace_text['regexes']:\n        blob.data = regex.sub(replacement, blob.data)\n\n    if self._blob_callback:\n      self._blob_callback(blob, self.callback_metadata())\n\n    self._insert_into_stream(blob)\n\n  def _filter_files(self, commit):\n    def filename_matches(path_expression, pathname):\n      ''' Returns whether path_expression matches pathname or a leading\n          directory thereof, allowing path_expression to not have a trailing\n          slash even if it is meant to match a leading directory. '''\n      if path_expression == b'':\n        return True\n      n = len(path_expression)\n      if (pathname.startswith(path_expression) and\n          (path_expression[n-1:n] == b'/' or\n           len(pathname) == n or\n           pathname[n:n+1] == b'/')):\n        return True\n      return False\n\n    def newname(path_changes, pathname, use_base_name, filtering_is_inclusive):\n      ''' Applies filtering and rename changes from path_changes to pathname,\n          returning any of None (file isn't wanted), original filename (file\n          is wanted with original name), or new filename. '''\n      wanted = False\n      full_pathname = pathname\n      if use_base_name:\n        pathname = os.path.basename(pathname)\n      for (mod_type, match_type, path_exp) in path_changes:\n        if mod_type == 'filter' and not wanted:\n          assert match_type in ('match', 'glob', 'regex')\n          if match_type == 'match' and filename_matches(path_exp, pathname):\n            wanted = True\n          if match_type == 'glob' and fnmatch.fnmatch(pathname, path_exp):\n            wanted = True\n          if match_type == 'regex' and path_exp.search(pathname):\n            wanted = True\n        elif mod_type == 'rename':\n          match, repl = path_exp\n          assert match_type in ('match','regex') # glob was translated to regex\n          if match_type == 'match' and filename_matches(match, full_pathname):\n            full_pathname = full_pathname.replace(match, repl, 1)\n            pathname = full_pathname # rename incompatible with use_base_name\n          if match_type == 'regex':\n            full_pathname = match.sub(repl, full_pathname)\n            pathname = full_pathname # rename incompatible with use_base_name\n      return full_pathname if (wanted == filtering_is_inclusive) else None\n\n    args = self._args\n    new_file_changes = {}  # Assumes no renames or copies, otherwise collisions\n    for change in commit.file_changes:\n      # NEEDSWORK: _If_ we ever want to pass `--full-tree` to fast-export and\n      # parse that output, we'll need to modify this block; `--full-tree`\n      # issues a deleteall directive which has no filename, and thus this\n      # block would normally strip it.  Of course, FileChange() and\n      # _parse_optional_filechange() would need updates too.\n      if change.type == b'DELETEALL':\n        new_file_changes[b''] = change\n        continue\n      if change.filename in self._newnames:\n        change.filename = self._newnames[change.filename]\n      else:\n        original_filename = change.filename\n        change.filename = newname(args.path_changes, change.filename,\n                                  args.use_base_name, args.inclusive)\n        if self._filename_callback:\n          change.filename = self._filename_callback(change.filename)\n        self._newnames[original_filename] = change.filename\n      if not change.filename:\n        continue # Filtering criteria excluded this file; move on to next one\n      if change.filename in new_file_changes:\n        # Getting here means that path renaming is in effect, and caused one\n        # path to collide with another.  That's usually bad, but can be okay\n        # under two circumstances:\n        #   1) Sometimes people have a file named OLDFILE in old revisions of\n        #      history, and they rename to NEWFILE, and would like to rewrite\n        #      history so that all revisions refer to it as NEWFILE.  As such,\n        #      we can allow a collision when (at least) one of the two paths\n        #      is a deletion.  Note that if OLDFILE and NEWFILE are unrelated\n        #      this also allows the rewrite to continue, which makes sense\n        #      since OLDFILE is no longer in the way.\n        #   2) If OLDFILE and NEWFILE are exactly equal, then writing them\n        #      both to the same location poses no problem; we only need one\n        #      file.  (This could come up if someone copied a file in some\n        #      commit, then later either deleted the file or kept it exactly\n        #      in sync with the original with any changes, and then decides\n        #      they want to rewrite history to only have one of the two files)\n        colliding_change = new_file_changes[change.filename]\n        if change.type == b'D':\n          # We can just throw this one away and keep the other\n          continue\n        elif change.type == b'M' and (\n            change.mode == colliding_change.mode and\n            change.blob_id == colliding_change.blob_id):\n          # The two are identical, so we can throw this one away and keep other\n          continue\n        elif new_file_changes[change.filename].type != b'D':\n          raise SystemExit(_(\"File renaming caused colliding pathnames!\\n\") +\n                           _(\"  Commit: {}\\n\").format(commit.original_id) +\n                           _(\"  Filename: {}\").format(change.filename))\n      # Strip files that are too large\n      if self._args.max_blob_size and \\\n         self._unpacked_size.get(change.blob_id, 0) > self._args.max_blob_size:\n        continue\n      if self._args.strip_blobs_with_ids and \\\n         change.blob_id in self._args.strip_blobs_with_ids:\n        continue\n      # Otherwise, record the change\n      new_file_changes[change.filename] = change\n    commit.file_changes = [v for k,v in sorted(new_file_changes.items())]\n\n  def _tweak_commit(self, commit, aux_info):\n    if self._args.replace_message:\n      for literal, replacement in self._args.replace_message['literals']:\n        commit.message = commit.message.replace(literal, replacement)\n      for regex,   replacement in self._args.replace_message['regexes']:\n        commit.message = regex.sub(replacement, commit.message)\n    if self._message_callback:\n      commit.message = self._message_callback(commit.message)\n\n    # Change the commit message according to callback\n    if not self._args.preserve_commit_hashes:\n      commit.message = self._hash_re.sub(self._translate_commit_hash,\n                                         commit.message)\n\n    # Change the author & committer according to mailmap rules\n    args = self._args\n    if args.mailmap:\n      commit.author_name, commit.author_email = \\\n          args.mailmap.translate(commit.author_name, commit.author_email)\n      commit.committer_name, commit.committer_email = \\\n          args.mailmap.translate(commit.committer_name, commit.committer_email)\n    # Change author & committer according to callbacks\n    if self._name_callback:\n      commit.author_name = self._name_callback(commit.author_name)\n      commit.committer_name = self._name_callback(commit.committer_name)\n    if self._email_callback:\n      commit.author_email = self._email_callback(commit.author_email)\n      commit.committer_email = self._email_callback(commit.committer_email)\n\n    # Sometimes the 'branch' given is a tag; if so, rename it as requested so\n    # we don't get any old tagnames\n    if self._args.tag_rename:\n      commit.branch = RepoFilter._do_tag_rename(args.tag_rename, commit.branch)\n    if self._refname_callback:\n      commit.branch = self._refname_callback(commit.branch)\n\n    # Filter or rename the list of file changes\n    orig_file_changes = set(commit.file_changes)\n    self._filter_files(commit)\n\n    # Record ancestry graph\n    parents, orig_parents = commit.parents, aux_info['orig_parents']\n    if self._args.state_branch:\n      external_parents = parents\n    else:\n      external_parents = [p for p in parents if not isinstance(p, int)]\n    # The use of 'reversed' is intentional here; there is a risk that we have\n    # duplicates in parents, and we want to map from parents to the first\n    # entry we find in orig_parents in such cases.\n    parent_reverse_dict = dict(zip(reversed(parents), reversed(orig_parents)))\n\n    self._graph.record_external_commits(external_parents)\n    self._orig_graph.record_external_commits(external_parents)\n    self._graph.add_commit_and_parents(commit.id, parents) # new githash unknown\n    self._orig_graph.add_commit_and_parents(commit.old_id, orig_parents,\n                                            commit.original_id)\n\n    # Prune parents (due to pruning of empty commits) if relevant, note that\n    # new_1st_parent is None unless this was a merge commit that is becoming\n    # a non-merge\n    prev_1st_parent = parents[0] if parents else None\n    parents, new_1st_parent = self._maybe_trim_extra_parents(orig_parents,\n                                                             parents)\n    commit.parents = parents\n\n    # If parents were pruned, then we need our file changes to be relative\n    # to the new first parent\n    #\n    # Notes:\n    #   * new_1st_parent and new_1st_parent != parents[0] uniquely happens for example when:\n    #       working on merge, selecting subset of files and merge base still\n    #       valid while first parent history doesn't touch any of those paths,\n    #       but second parent history does.  prev_1st_parent had already been\n    #       rewritten to the non-None first ancestor and it remains valid.\n    #       self._maybe_trim_extra_parents() avoids removing this first parent\n    #       because it'd make the commit a non-merge.  However, if there are\n    #       no file_changes of note, we'll drop this commit and mark\n    #       new_1st_parent as the new replacement.  To correctly determine if\n    #       there are no file_changes of note, we need to have the list of\n    #       file_changes relative to new_1st_parent.\n    #       (See t9390#3, \"basic -> basic-ten using '--path ten'\")\n    #   * prev_1st_parent != parents[0] happens for example when:\n    #       similar to above, but the merge base is no longer valid and was\n    #       pruned away as well.  Then parents started as e.g. [None, $num],\n    #       and both prev_1st_parent and new_1st_parent are None, while parents\n    #       after self._maybe_trim_extra_parents() becomes just [$num].\n    #       (See t9390#67, \"degenerate merge with non-matching filename\".)\n    #       Since $num was originally a second parent, we need to rewrite\n    #       file changes to be relative to parents[0].\n    #   * TODO: We should be getting the changes relative to the new first\n    #     parent even if self._fep is None, BUT we can't.  Our method of\n    #     getting the changes right now is an external git diff invocation,\n    #     which we can't do if we just have a fast export stream.  We can't\n    #     really work around it by querying the fast-import stream either,\n    #     because the 'ls' directive only allows us to list info about\n    #     specific paths, but we need to find out which paths exist in two\n    #     commits and then query them.  We could maybe force checkpointing in\n    #     fast-import, then doing a diff from what'll be the new first parent\n    #     back to prev_1st_parent (which may be None, i.e. empty tree), using\n    #     the fact that in A->{B,C}->D, where D is merge of B & C, the diff\n    #     from C->D == C->A + A->B + B->D, and in these cases A==B, so it\n    #     simplifies to C->D == C->A + B->D, and C is our new 1st parent\n    #     commit, A is prev_1st_commit, and B->D is commit.file_changes that\n    #     we already have.  However, checkpointing the fast-import process\n    #     and figuring out how long to wait before we can run our diff just\n    #     seems excessive. For now, just punt and assume the merge wasn't\n    #     \"evil\" (i.e. that it's remerge-diff is empty, as is true for most\n    #     merges).  If the merge isn't evil, no further steps are necessary.\n    if parents and self._fep and (\n        prev_1st_parent != parents[0] or\n        new_1st_parent and new_1st_parent != parents[0]):\n      # Get the id from the original fast export stream corresponding to the\n      # new 1st parent.  As noted above, that new 1st parent might be\n      # new_1st_parent, or if that is None, it'll be parents[0].\n      will_be_1st = new_1st_parent or parents[0]\n      old_id = parent_reverse_dict[will_be_1st]\n      # Now, translate that to a hash\n      will_be_1st_commit_hash = self._orig_graph.map_to_hash(old_id)\n      # Get the changes from what is going to be the new 1st parent to this\n      # merge commit.  Note that since we are going from the new 1st parent\n      # to the merge commit, we can just replace the existing\n      # commit.file_changes rather than getting something we need to combine\n      # with the existing commit.file_changes.  Also, we can just replace\n      # because prev_1st_parent is an ancestor of will_be_1st_commit_hash\n      # (or prev_1st_parent is None and first parent history is gone), so\n      # even if we retain prev_1st_parent and do not prune it, the changes\n      # will still work given the snapshot-based way fast-export/fast-import\n      # work.\n      commit.file_changes = GitUtils.get_file_changes(self._repo_working_dir,\n                                                      will_be_1st_commit_hash,\n                                                      commit.original_id)\n\n      # Save these and filter them\n      orig_file_changes = set(commit.file_changes)\n      self._filter_files(commit)\n\n    # Process the --file-info-callback\n    if self._file_info_callback:\n      if self._file_info_value is None:\n        source_working_dir = self._args.source or b'.'\n        self._file_info_value = FileInfoValueHelper(self._args.replace_text,\n                                                    self.insert,\n                                                    source_working_dir)\n      new_file_changes = []\n      for change in commit.file_changes:\n        if change.type != b'D':\n          assert(change.type == b'M')\n          (filename, mode, blob_id) = \\\n            self._file_info_callback(change.filename,\n                                     change.mode,\n                                     change.blob_id,\n                                     self._file_info_value)\n          if mode is None:\n            # TODO: Should deletion of the file even be a feature?  Might\n            # want to remove this branch of the if-elif-else.\n            assert(filename is not None)\n            assert(blob_id is not None)\n            new_change = FileChange(b'D', filename)\n          elif filename is None:\n            continue # Drop the FileChange from this commit\n          else:\n            new_change = FileChange(b'M', filename, blob_id, mode)\n        else:\n          new_change = change  # use change as-is for deletions\n        new_file_changes.append(new_change)\n      commit.file_changes = new_file_changes\n\n    # Call the user-defined callback, if any\n    if self._commit_callback:\n      self._commit_callback(commit, self.callback_metadata(aux_info))\n\n    # Find out which files were modified by the callbacks.  Such paths could\n    # lead to subsequent commits being empty (e.g. if removing a line containing\n    # a password from every version of a file that had the password, and some\n    # later commit did nothing more than remove that line)\n    final_file_changes = set(commit.file_changes)\n    if self._args.replace_text or self._blob_callback:\n      differences = orig_file_changes.union(final_file_changes)\n    else:\n      differences = orig_file_changes.symmetric_difference(final_file_changes)\n    self._files_tweaked.update(x.filename for x in differences)\n\n    # Now print the resulting commit, or if prunable skip it\n    if not commit.dumped:\n      if not self._prunable(commit, new_1st_parent,\n                            aux_info['had_file_changes'], orig_parents):\n        self._insert_into_stream(commit)\n        self._record_remapping(commit, orig_parents)\n      else:\n        rewrite_to = new_1st_parent or commit.first_parent()\n        commit.skip(new_id = rewrite_to)\n        if self._args.state_branch:\n          alias = Alias(commit.old_id or commit.id, rewrite_to or deleted_hash)\n          self._insert_into_stream(alias)\n        if commit.branch.startswith(b'refs/') or commit.branch == b'HEAD':\n          # The special check above is because when direct revisions are passed\n          # along to fast-export (such as with stashes), there is a chance the\n          # revision is rewritten to nothing.  In such cases, we don't want to\n          # point an invalid ref that just names a revision to some other point.\n          reset = Reset(commit.branch, rewrite_to or deleted_hash)\n          self._insert_into_stream(reset)\n        self._commit_renames[commit.original_id] = None\n\n    # Show progress\n    self._num_commits += 1\n    if not self._args.quiet:\n      self._progress_writer.show(self._parsed_message % self._num_commits)\n\n  @staticmethod\n  def _do_tag_rename(rename_pair, tagname):\n    old, new = rename_pair.split(b':', 1)\n    old, new = b'refs/tags/'+old, b'refs/tags/'+new\n    if tagname.startswith(old):\n      return tagname.replace(old, new, 1)\n    return tagname\n\n  def _tweak_tag(self, tag):\n    # Tweak the tag message according to callbacks\n    if self._args.replace_message:\n      for literal, replacement in self._args.replace_message['literals']:\n        tag.message = tag.message.replace(literal, replacement)\n      for regex,   replacement in self._args.replace_message['regexes']:\n        tag.message = regex.sub(replacement, tag.message)\n    if self._message_callback:\n      tag.message = self._message_callback(tag.message)\n\n    # Tweak the tag name according to tag-name-related callbacks\n    tag_prefix = b'refs/tags/'\n    fullref = tag_prefix+tag.ref\n    if self._args.tag_rename:\n      fullref = RepoFilter._do_tag_rename(self._args.tag_rename, fullref)\n    if self._refname_callback:\n      fullref = self._refname_callback(fullref)\n      if not fullref.startswith(tag_prefix):\n        msg = \"Error: fast-import requires tags to be in refs/tags/ namespace.\"\n        msg += \"\\n       {} renamed to {}\".format(tag_prefix+tag.ref, fullref)\n        raise SystemExit(msg)\n    tag.ref = fullref[len(tag_prefix):]\n\n    # Tweak the tagger according to callbacks\n    if self._args.mailmap:\n      tag.tagger_name, tag.tagger_email = \\\n          self._args.mailmap.translate(tag.tagger_name, tag.tagger_email)\n    if self._name_callback:\n      tag.tagger_name = self._name_callback(tag.tagger_name)\n    if self._email_callback:\n      tag.tagger_email = self._email_callback(tag.tagger_email)\n\n    # Call general purpose tag callback\n    if self._tag_callback:\n      self._tag_callback(tag, self.callback_metadata())\n\n  def _tweak_reset(self, reset):\n    if self._args.tag_rename:\n      reset.ref = RepoFilter._do_tag_rename(self._args.tag_rename, reset.ref)\n    if self._refname_callback:\n      reset.ref = self._refname_callback(reset.ref)\n    if self._reset_callback:\n      self._reset_callback(reset, self.callback_metadata())\n\n  def results_tmp_dir(self, create_if_missing=True):\n    target_working_dir = self._args.target or b'.'\n    git_dir = GitUtils.determine_git_dir(target_working_dir)\n    d = os.path.join(git_dir, b'filter-repo')\n    if create_if_missing and not os.path.isdir(d):\n      os.mkdir(d)\n    return d\n\n  def _load_marks_file(self, marks_basename):\n    full_branch = 'refs/heads/{}'.format(self._args.state_branch)\n    marks_file = os.path.join(self.results_tmp_dir(), marks_basename)\n    working_dir = self._args.target or b'.'\n    cmd = ['git', '-C', working_dir, 'show-ref', full_branch]\n    contents = b''\n    if subproc.call(cmd, stdout=subprocess.DEVNULL) == 0:\n      cmd = ['git', '-C', working_dir, 'show',\n             '%s:%s' % (full_branch, decode(marks_basename))]\n      try:\n        contents = subproc.check_output(cmd)\n      except subprocess.CalledProcessError as e: # pragma: no cover\n        raise SystemExit(_(\"Failed loading %s from %s\") %\n                         (decode(marks_basename), full_branch))\n    if contents:\n      biggest_id = max(int(x.split()[0][1:]) for x in contents.splitlines())\n      _IDS._next_id = max(_IDS._next_id, biggest_id+1)\n    with open(marks_file, 'bw') as f:\n      f.write(contents)\n    return marks_file\n\n  def _save_marks_files(self):\n    basenames = [b'source-marks', b'target-marks']\n    working_dir = self._args.target or b'.'\n\n    # Check whether the branch exists\n    parent = []\n    full_branch = 'refs/heads/{}'.format(self._args.state_branch)\n    cmd = ['git', '-C', working_dir, 'show-ref', full_branch]\n    if subproc.call(cmd, stdout=subprocess.DEVNULL) == 0:\n      parent = ['-p', full_branch]\n\n    # Run 'git hash-object $MARKS_FILE' for each marks file, save result\n    blob_hashes = {}\n    for marks_basename in basenames:\n      marks_file = os.path.join(self.results_tmp_dir(), marks_basename)\n      if not os.path.isfile(marks_file): # pragma: no cover\n        raise SystemExit(_(\"Failed to find %s to save to %s\")\n                         % (marks_file, self._args.state_branch))\n      cmd = ['git', '-C', working_dir, 'hash-object', '-w', marks_file]\n      blob_hashes[marks_basename] = subproc.check_output(cmd).strip()\n\n    # Run 'git mktree' to create a tree out of it\n    p = subproc.Popen(['git', '-C', working_dir, 'mktree'],\n                      stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n    for b in basenames:\n      p.stdin.write(b'100644 blob %s\\t%s\\n' % (blob_hashes[b], b))\n    p.stdin.close()\n    p.wait()\n    tree = p.stdout.read().strip()\n\n    # Create the new commit\n    cmd = (['git', '-C', working_dir, 'commit-tree', '-m', 'New mark files',\n            tree] + parent)\n    commit = subproc.check_output(cmd).strip()\n    subproc.call(['git', '-C', working_dir, 'update-ref', full_branch, commit])\n\n  def importer_only(self):\n    self._run_sanity_checks()\n    self._setup_output()\n\n  def set_output(self, outputRepoFilter):\n    assert outputRepoFilter._output\n\n    # set_output implies this RepoFilter is doing exporting, though may not\n    # be the only one.\n    self._setup_input(use_done_feature = False)\n\n    # Set our output management up to pipe to outputRepoFilter's locations\n    self._managed_output = False\n    self._output = outputRepoFilter._output\n    self._import_pipes = outputRepoFilter._import_pipes\n\n    # Handle sanity checks, though currently none needed for export-only cases\n    self._run_sanity_checks()\n\n  def _read_stash(self):\n    if self._stash:\n      return\n    if self._orig_refs and b'refs/stash' in self._orig_refs and \\\n       self._args.refs == ['--all']:\n      repo_working_dir = self._args.source or b'.'\n      git_dir = GitUtils.determine_git_dir(repo_working_dir)\n      stash = os.path.join(git_dir, b'logs', b'refs', b'stash')\n      if os.path.exists(stash):\n        self._stash = []\n        with open(stash, 'br') as f:\n          for line in f:\n            (oldhash, newhash, rest) = line.split(None, 2)\n            self._stash.append((newhash, rest))\n        self._args.refs.extend([x[0] for x in self._stash])\n\n  def _write_stash(self):\n    last = deleted_hash\n    if self._stash:\n      target_working_dir = self._args.target or b'.'\n      git_dir = GitUtils.determine_git_dir(target_working_dir)\n      stash = os.path.join(git_dir, b'logs', b'refs', b'stash')\n      with open(stash, 'bw') as f:\n        for (hash, rest) in self._stash:\n          new_hash = self._get_rename(hash)\n          if new_hash is None:\n            continue\n          f.write(b' '.join([last, new_hash, rest]) + b'\\n')\n          last = new_hash\n      print(_(\"Rewrote the stash.\"))\n\n  def _setup_input(self, use_done_feature):\n    if self._args.stdin:\n      self._input = sys.stdin.detach()\n      sys.stdin = None # Make sure no one tries to accidentally use it\n      self._fe_orig = None\n    else:\n      self._read_stash()\n      skip_blobs = (self._blob_callback is None and\n                    (self._args.replace_text is None or\n                     self._file_info_callback is not None) and\n                    self._args.source == self._args.target)\n      extra_flags = []\n      if skip_blobs:\n        extra_flags.append('--no-data')\n        if self._args.max_blob_size:\n          self._unpacked_size, packed_size = GitUtils.get_blob_sizes()\n      if use_done_feature:\n        extra_flags.append('--use-done-feature')\n      if write_marks:\n        extra_flags.append(b'--mark-tags')\n      if self._args.state_branch:\n        assert(write_marks)\n        source_marks_file = self._load_marks_file(b'source-marks')\n        extra_flags.extend([b'--export-marks='+source_marks_file,\n                            b'--import-marks='+source_marks_file])\n      if self._args.preserve_commit_encoding is not None: # pragma: no cover\n        reencode = 'no' if self._args.preserve_commit_encoding else 'yes'\n        extra_flags.append('--reencode='+reencode)\n      if self._args.date_order:\n        extra_flags.append('--date-order')\n      location = ['-C', self._args.source] if self._args.source else []\n      fep_cmd = ['git'] + location + ['fast-export', '--show-original-ids',\n                 '--signed-tags=strip', '--tag-of-filtered-object=rewrite',\n                 '--fake-missing-tagger', '--reference-excluded-parents'\n                 ] + extra_flags + self._args.refs\n      self._fep = subproc.Popen(fep_cmd, bufsize=-1, stdout=subprocess.PIPE)\n      self._input = self._fep.stdout\n      if self._args.dry_run or self._args.debug:\n        self._fe_orig = os.path.join(self.results_tmp_dir(),\n                                     b'fast-export.original')\n        output = open(self._fe_orig, 'bw')\n        self._input = InputFileBackup(self._input, output)\n        if self._args.debug:\n          tmp = [decode(x) if isinstance(x, bytes) else x for x in fep_cmd]\n          print(\"[DEBUG] Running: {}\".format(' '.join(tmp)))\n          print(\"  (saving a copy of the output at {})\"\n                .format(decode(self._fe_orig)))\n\n  def _setup_output(self):\n    if not self._args.dry_run:\n      location = ['-C', self._args.target] if self._args.target else []\n      fip_cmd = ['git'] + location + ['-c', 'core.ignorecase=false',\n                                      'fast-import', '--force', '--quiet']\n      if date_format_permissive:\n        fip_cmd.append('--date-format=raw-permissive')\n      if self._args.state_branch:\n        target_marks_file = self._load_marks_file(b'target-marks')\n        fip_cmd.extend([b'--export-marks='+target_marks_file,\n                        b'--import-marks='+target_marks_file])\n      self._fip = subproc.Popen(fip_cmd, bufsize=-1,\n                                stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n      self._import_pipes = (self._fip.stdin, self._fip.stdout)\n    if self._args.dry_run or self._args.debug:\n      self._fe_filt = os.path.join(self.results_tmp_dir(),\n                                   b'fast-export.filtered')\n      self._output = open(self._fe_filt, 'bw')\n    else:\n      self._output = self._fip.stdin\n    if self._args.debug and not self._args.dry_run:\n      self._output = DualFileWriter(self._fip.stdin, self._output)\n      tmp = [decode(x) if isinstance(x, bytes) else x for x in fip_cmd]\n      print(\"[DEBUG] Running: {}\".format(' '.join(tmp)))\n      print(\"  (using the following file as input: {})\"\n            .format(decode(self._fe_filt)))\n\n  def _migrate_origin_to_heads(self):\n    source_working_dir = self._args.source or b'.'\n    target_working_dir = self._args.target or b'.'\n    refs_to_migrate = set(x for x in self._orig_refs\n                          if x.startswith(b'refs/remotes/origin/'))\n    refs_to_warn_about = set()\n    if refs_to_migrate:\n      if self._args.debug:\n        print(\"[DEBUG] Migrating refs/remotes/origin/* -> refs/heads/*\")\n      p = subproc.Popen('git update-ref --no-deref --stdin'.split(),\n                        stdin=subprocess.PIPE, cwd=source_working_dir)\n      for ref in refs_to_migrate:\n        if ref == b'refs/remotes/origin/HEAD':\n          p.stdin.write(b'delete %s %s\\n' % (ref, self._orig_refs[ref]))\n          del self._orig_refs[ref]\n          continue\n        newref = ref.replace(b'refs/remotes/origin/', b'refs/heads/')\n        if newref not in self._orig_refs:\n          p.stdin.write(b'create %s %s\\n' % (newref, self._orig_refs[ref]))\n          self._orig_refs[newref] = self._orig_refs[ref]\n        elif self._orig_refs[ref] != self._orig_refs[newref]:\n          refs_to_warn_about.add(newref)\n        p.stdin.write(b'delete %s %s\\n' % (ref, self._orig_refs[ref]))\n        del self._orig_refs[ref]\n      p.stdin.close()\n      if p.wait(): # pragma: no cover\n        msg = _(\"git update-ref failed; see above\")\n        raise SystemExit(msg)\n\n    if b'remote.origin.url' not in self._config_settings:\n      return\n\n    # For sensitive data removals, fetch ALL refs.  Non-mirror clones normally\n    # only grab branches and tags, but other refs may hold on to the sensitive\n    # data as well.\n    if self._args.sensitive_data_removal and \\\n       not self._args.no_fetch and \\\n       not self._already_ran and \\\n       self._config_settings.get(b'remote.origin.mirror', b'false') != b'true':\n\n      if refs_to_warn_about:\n        msg = (\"Warning: You have refs modified from upstream:\\n             \" +\n               \"\\n            \".join([decode(x) for x in refs_to_warn_about]) +\n               \"\\n\" +\n               \"         We want to forcibly fetch from upstream to ensure\\n\" +\n               \"         that all relevent refs are rewritten, but this will\\n\" +\n               \"         discard your local changes before starting the\\n\" +\n               \"         rewrite.  Proceed with fetch (Y/N)?\")\n        response = input(msg)\n\n        if response.lower() != 'y':\n          self._args.no_fetch = True\n          # Don't do the fetch, and don't remove the origin remote\n          return\n\n      cmd = 'git fetch -q --prune --update-head-ok --refmap \"\" origin +refs/*:refs/*'\n      m = _(\"NOTICE: Fetching all refs from origin to make sure we rewrite\\n\"\n            \"        all history that may reference the sensitive data, via\\n\"\n            \"      \"+cmd)\n      print(m)\n      ret = subproc.call([arg if arg != '\"\"' else '' for arg in cmd.split()],\n                         cwd=source_working_dir)\n      if ret != 0: # pragma: no cover\n        m = _(\"WARNING: Fetching all refs from origin failed\")\n        print(m)\n    if self._args.sensitive_data_removal:\n      return\n\n    # Now remove the origin remote\n    url = self._config_settings[b'remote.origin.url'].decode(errors='replace')\n    m = _(\"NOTICE: Removing 'origin' remote; see 'Why is my origin removed?'\\n\"\n          \"        in the manual if you want to push back there.\\n\"\n          \"        (was %s)\") % url\n    print(m)\n    subproc.call('git remote rm origin'.split(), cwd=target_working_dir)\n\n  def _final_commands(self):\n    self._finalize_handled = True\n    self._done_callback and self._done_callback()\n\n    if self._file_info_value:\n      self._file_info_value.finalize()\n    if not self._args.quiet:\n      self._progress_writer.finish()\n\n  def _ref_update(self, target_working_dir):\n    # Start the update-ref process\n    p = subproc.Popen('git update-ref --no-deref --stdin'.split(),\n                      stdin=subprocess.PIPE,\n                      cwd=target_working_dir)\n\n    # Remove replace_refs from _orig_refs\n    replace_refs = {k:v for k, v in self._orig_refs.items()\n                    if k.startswith(b'refs/replace/')}\n    reverse_replace_refs = collections.defaultdict(list)\n    for k,v in replace_refs.items():\n      reverse_replace_refs[v].append(k)\n    all(map(self._orig_refs.pop, replace_refs))\n\n    # Remove unused refs\n    exported_refs, imported_refs = self.get_exported_and_imported_refs()\n    refs_to_nuke = exported_refs - imported_refs\n    # Because revisions can be passed to fast-export which handles them as\n    # though they were refs, we might have bad \"refs\" to nuke; strip them out.\n    refs_to_nuke = [x for x in refs_to_nuke\n                    if x.startswith(b'refs/') or x == b'HEAD']\n    if self._args.partial:\n      refs_to_nuke = set()\n    if refs_to_nuke and self._args.debug:\n      print(\"[DEBUG] Deleting the following refs:\\n  \"+\n            decode(b\"\\n  \".join(sorted(refs_to_nuke))))\n    p.stdin.write(b''.join([b\"delete %s\\n\" % x\n                           for x in refs_to_nuke]))\n\n    # Delete or update and add replace_refs; note that fast-export automatically\n    # handles 'update-no-add', we only need to take action for the other four\n    # choices for replace_refs.\n    self._flush_renames()\n    actual_renames = {k:v for k,v in self._commit_renames.items() if k != v}\n    if self._args.replace_refs in ['delete-no-add', 'delete-and-add']:\n      # Delete old replace refs, if unwanted\n      replace_refs_to_nuke = set(replace_refs)\n      if self._args.replace_refs == 'delete-and-add':\n        # git-update-ref won't allow us to update a ref twice, so be careful\n        # to avoid deleting refs we'll later update\n        replace_refs_to_nuke = replace_refs_to_nuke.difference(\n                                 [b'refs/replace/'+x for x in actual_renames])\n      p.stdin.write(b''.join([b\"delete %s\\n\" % x\n                             for x in replace_refs_to_nuke]))\n    if self._args.replace_refs in ['delete-and-add', 'update-or-add',\n                                   'update-and-add']:\n      # Add new replace refs\n      update_only = (self._args.replace_refs == 'update-or-add')\n      p.stdin.write(b''.join([b\"update refs/replace/%s %s\\n\" % (old, new)\n                              for old,new in actual_renames.items()\n                              if new and not (update_only and\n                                              old in reverse_replace_refs)]))\n\n    # Complete the update-ref process\n    p.stdin.close()\n    if p.wait():\n      raise SystemExit(_(\"git update-ref failed; see above\")) # pragma: no cover\n\n  def _remap_to(self, oldish_hash):\n    '''\n    Given an oldish_hash (from the beginning of the current run), return:\n       IF oldish_hash is NOT pruned:\n         the hash of the rewrite of oldish_hash\n       otherwise:\n         the hash of the rewrite of the first unpruned ancestor of oldish_hash\n    '''\n    old_id = self._orig_graph._hash_to_id[oldish_hash]\n    new_id = _IDS.translate(old_id)\n    new_hash = self._graph.git_hash[new_id] if new_id else deleted_hash\n    return new_hash\n\n  def _compute_metadata(self, metadata_dir, orig_refs):\n    #\n    # First, handle commit_renames\n    #\n    old_commit_renames = dict()\n    if not self._already_ran:\n      commit_renames = {old: new\n                        for old, new in self._commit_renames.items()\n                       }\n    else:\n      # Read commit-map into old_commit_renames\n      with open(os.path.join(metadata_dir, b'commit-map'), 'br') as f:\n        f.readline() # Skip the header line\n        for line in f:\n          (old,new) = line.split()\n          old_commit_renames[old] = new\n      # Use A->B mappings in old_commit_renames, and B->C mappings in\n      # self._commit_renames to yield A->C mappings in commit_renames\n      commit_renames = {old: self._commit_renames.get(newish, newish)\n                        for old, newish in old_commit_renames.items()}\n      # If there are any B->C mappings in self._commit_renames for which\n      # there was no A->B mapping in old_commit_renames, then add the\n      # B->C mapping to commit_renames too.\n      seen = set(old_commit_renames.values())\n      commit_renames.update({old: new\n                             for old, new in self._commit_renames.items()\n                             if old not in seen})\n\n    #\n    # Second, handle ref_maps\n    #\n    exported_refs, imported_refs = self.get_exported_and_imported_refs()\n\n    old_commit_unrenames = dict()\n    if not self._already_ran:\n      old_ref_map = dict((refname, (old_hash, deleted_hash))\n                         for refname, old_hash in orig_refs.items()\n                         if refname in exported_refs)\n    else:\n      # old_commit_renames talk about how commits were renamed in the original\n      # run.  Let's reverse it to find out how to get from the intermediate\n      # commit name, back to the original.  Because everything in orig_refs\n      # right now refers to the intermediate commits after the first run(s),\n      # and we need to map them back to what they were before any changes.\n      old_commit_unrenames = dict((v,k) for (k,v) in old_commit_renames.items())\n\n      old_ref_map = {}\n      # Populate old_ref_map from the 'ref-map' file\n      with open(os.path.join(metadata_dir, b'ref-map'), 'br') as f:\n        f.readline() # Skip the header line\n        for line in f:\n          (old,intermediate,ref) = line.split()\n          old_ref_map[ref] = (old, intermediate)\n      # Append to old_ref_map items from orig_refs that were exported, but\n      # get the actual original commit name\n      for refname, old_hash in orig_refs.items():\n        if refname in old_ref_map:\n          continue\n        if refname not in exported_refs:\n          continue\n        # Compute older_hash\n        original_hash = old_commit_unrenames.get(old_hash, old_hash)\n        old_ref_map[refname] = (original_hash, deleted_hash)\n\n    new_refs = {}\n    new_refs_initialized = False\n    ref_maps = {}\n    self._orig_graph._ensure_reverse_maps_populated()\n    for refname, pair in old_ref_map.items():\n      old_hash, hash_ref_becomes_if_not_imported_in_this_run = pair\n      if refname not in imported_refs:\n        new_hash = hash_ref_becomes_if_not_imported_in_this_run\n      elif old_hash in commit_renames:\n        intermediate = old_commit_renames.get(old_hash,old_hash)\n        if intermediate in self._commit_renames:\n          new_hash = self._remap_to(intermediate)\n        else:\n          new_hash = intermediate\n      else: # Must be either an annotated tag, or a ref whose tip was pruned\n        if not new_refs_initialized:\n          target_working_dir = self._args.target or b'.'\n          new_refs = GitUtils.get_refs(target_working_dir)\n        if refname in new_refs:\n          new_hash = new_refs[refname]\n        else:\n          new_hash = deleted_hash\n      ref_maps[refname] = (old_hash, new_hash)\n    if self._args.source or self._args.target:\n      if not new_refs_initialized:\n        target_working_dir = self._args.target or b'.'\n        new_refs = GitUtils.get_refs(target_working_dir)\n      for ref, new_hash in new_refs.items():\n        if ref not in orig_refs and not ref.startswith(b'refs/replace/'):\n          old_hash = b'0'*len(new_hash)\n          ref_maps[ref] = (old_hash, new_hash)\n\n    #\n    # Third, handle first_changes\n    #\n\n    old_first_changes = dict()\n    if self._already_ran:\n      # Read first_changes into old_first_changes\n      with open(os.path.join(metadata_dir, b'first-changed-commits'), 'br') as f:\n        for line in f:\n          changed_commit, undeleted_self_or_ancestor = line.strip().split()\n          old_first_changes[changed_commit] = undeleted_self_or_ancestor\n    # We need to find the commits that were modified whose parents were not.\n    # To be able to find parents, we need the commit names as of the beginning\n    # of this run, and then when we are done, we need to map them back to the\n    # name of the commits from before any git-filter-repo runs.\n    #\n    # We are excluding here any commits deleted in previous git-filter-repo\n    # runs\n    undo_old_commit_renames = dict((v,k) for (k,v) in old_commit_renames.items()\n                                   if v != deleted_hash)\n    # Get a list of all commits that were changed, as of the beginning of\n    # this latest run.\n    changed_commits = {new\n                       for (old,new) in old_commit_renames.items()\n                       if old != new and new != deleted_hash} | \\\n                      {old\n                       for (old,new) in self._commit_renames.items()\n                       if old != new}\n    special_changed_commits = {old\n                               for (old,new) in old_commit_renames.items()\n                               if new == deleted_hash}\n    first_changes = dict()\n    for (old,new) in self._commit_renames.items():\n      if old == new:\n        # old wasn't modified, can't be first change if not even a change\n        continue\n      if old_commit_unrenames.get(old,old) != old:\n        # old was already modified in previous run; while it might represent\n        # something that is still a first change, we'll handle that as we\n        # loop over old_first_changes below\n        continue\n      if any(parent in changed_commits\n             for parent in self._orig_graph.get_parent_hashes(old)):\n        # a parent of old was modified, so old is not a first change\n        continue\n      # At this point, old IS a first change.  We need to find out what new\n      # commit it maps to, or if it doesn't map to one, what new commit was\n      # its most recent ancestor that wasn't pruned.\n      if new is None:\n        new = self._remap_to(old)\n      first_changes[old] = (new if new is not None else deleted_hash)\n    for (old,undeleted_self_or_ancestor) in old_first_changes.items():\n      if undeleted_self_or_ancestor == deleted_hash:\n        # old represents a commit that was pruned and whose entire ancestry\n        # was pruned.  So, old is still a first change\n        first_changes[old] = undeleted_self_or_ancestor\n        continue\n      intermediate = old_commit_renames.get(old, old)\n      usoa = undeleted_self_or_ancestor\n      new_ancestor = self._commit_renames.get(usoa, usoa)\n      if intermediate == deleted_hash:\n        # old was pruned in previous rewrite\n        if usoa != new_ancestor:\n          # old's ancestor got rewritten in this filtering run; we can drop\n          # this one from first_changes.\n          continue\n        # Getting here means old was a first change and old was pruned in a\n        # previous run, and its ancestors that survived were non rewritten in\n        # this run, so old remains a first change\n        first_changes[old] = new_ancestor # or usoa, since new_ancestor == usoa\n        continue\n      assert(usoa == intermediate) # old wasn't pruned => usoa == intermediate\n\n      # Check whether parents of intermediate were rewritten.  Note that\n      # intermediate in self._commit_renames only means that intermediate was\n      # processed by the latest filtering (not necessarily that it changed),\n      # but we need to know that before we can check for parent hashes having\n      # changed.\n      if intermediate not in self._commit_renames:\n        # This commit was not processed by this run, so it remains a first\n        # change\n        first_changes[old] = usoa\n        continue\n      if any(parent in changed_commits\n             for parent in self._orig_graph.get_parent_hashes(intermediate)):\n        # An ancestor was modified by this run, so it is no longer a first\n        # change; continue to the next one.\n        continue\n      # This change is a first_change; find the new commit its usoa maps to\n      new = self._remap_to(intermediate)\n      assert(new is not None)\n      first_changes[old] = new\n\n    return commit_renames, ref_maps, first_changes\n\n  def _handle_lfs_metadata(self, metadata_dir):\n    if self._lfs_object_tracker is None:\n      print(\"NOTE: LFS object orphaning not checked (LFS not in use)\")\n      return\n\n    if self._args.partial:\n      target_working_dir = self._args.target or b'.'\n      source = False\n      self._lfs_object_tracker.find_all_lfs_objects_in_repo(target_working_dir,\n                                                            source)\n\n    with open(os.path.join(metadata_dir, b'original_lfs_objects'), 'bw') as f:\n      for obj in sorted(self._lfs_object_tracker.source_objects.objects):\n        f.write(obj+b\"\\n\")\n\n    orphaned_lfs_path = os.path.join(metadata_dir, b'orphaned_lfs_objects')\n    msg = textwrap.dedent(_(f\"\"\"\\\n      NOTE: There were LFS Objects Orphaned by this rewrite recorded in\n            {decode(orphaned_lfs_path)}.\"\"\"))\n    with open(orphaned_lfs_path, 'bw') as f:\n      differences = self._lfs_object_tracker.source_objects.objects - \\\n                    self._lfs_object_tracker.target_objects.objects\n      for obj in sorted(differences):\n        f.write(obj+b\"\\n\")\n      if differences:\n        self._lfs_object_tracker.objects_orphaned = True\n        print(msg)\n\n  def _record_metadata(self, metadata_dir, orig_refs):\n    self._flush_renames()\n    commit_renames, ref_maps, first_changes = \\\n      self._compute_metadata(metadata_dir, orig_refs)\n\n    if self._args.sensitive_data_removal:\n      changed_commits = sum(k!=v for (k,v) in commit_renames.items())\n      print(f\"You rewrote {changed_commits} (of {len(commit_renames)}) commits.\")\n      print(\"\") # Add a blank line before important rewrite information\n      print(f\"NOTE: First Changed Commit(s) is/are:\\n  \"\n            + decode(b\"\\n  \".join(x for x in first_changes)))\n\n      with open(os.path.join(metadata_dir, b'sensitive_data_removal'), 'bw') as f:\n        pass # Write nothing; we only need the file created\n\n      self._handle_lfs_metadata(metadata_dir)\n      print(\"\") # Add a blank line after important rewrite information\n\n    with open(os.path.join(metadata_dir, b'commit-map'), 'bw') as f:\n      f.write((\"%-40s %s\\n\" % (_(\"old\"), _(\"new\"))).encode())\n      for (old,new) in sorted(commit_renames.items()):\n        msg = b'%s %s\\n' % (old, new if new != None else deleted_hash)\n        f.write(msg)\n\n    with open(os.path.join(metadata_dir, b'ref-map'), 'bw') as f:\n      f.write((\"%-40s %-40s %s\\n\" % (_(\"old\"), _(\"new\"), _(\"ref\"))).encode())\n      for refname, hash_pair in sorted(ref_maps.items()):\n        (old_hash, new_hash) = hash_pair\n        f.write(b'%s %s %s\\n' % (old_hash, new_hash, refname))\n        if old_hash != new_hash:\n          self._changed_refs.add(refname)\n\n    with open(os.path.join(metadata_dir, b'changed-refs'), 'bw') as f:\n      for refname in sorted(self._changed_refs):\n        f.write(b'%s\\n' % refname)\n\n    with open(os.path.join(metadata_dir, b'first-changed-commits'), 'bw') as f:\n      for commit, undeleted_self_or_ancestor in sorted(first_changes.items()):\n        f.write(b'%s %s\\n' % (commit, undeleted_self_or_ancestor))\n\n    with open(os.path.join(metadata_dir, b'suboptimal-issues'), 'bw') as f:\n      issues_found = False\n      if self._commits_no_longer_merges:\n        issues_found = True\n\n        f.write(textwrap.dedent(_('''\n          The following commits used to be merge commits but due to filtering\n          are now regular commits; they likely have suboptimal commit messages\n          (e.g. \"Merge branch next into master\").  Original commit hash on the\n          left, commit hash after filtering/rewriting on the right:\n          ''')[1:]).encode())\n        for oldhash, newhash in self._commits_no_longer_merges:\n          f.write('  {} {}\\n'.format(oldhash, newhash).encode())\n        f.write(b'\\n')\n\n      if self._commits_referenced_but_removed:\n        issues_found = True\n        f.write(textwrap.dedent(_('''\n          The following commits were filtered out, but referenced in another\n          commit message.  The reference to the now-nonexistent commit hash\n          (or a substring thereof) was left as-is in any commit messages:\n          ''')[1:]).encode())\n        for bad_commit_reference in self._commits_referenced_but_removed:\n          f.write('  {}\\n'.format(bad_commit_reference).encode())\n        f.write(b'\\n')\n\n      if not issues_found:\n        f.write(_(\"No filtering problems encountered.\\n\").encode())\n\n    with open(os.path.join(metadata_dir, b'already_ran'), 'bw') as f:\n       f.write(_(\"This file exists to allow you to filter again without --force,\\n\"\n                 \"and to specify that metadata files should be updated instead\\n\"\n                 \"of rewritten\").encode())\n\n  def finish(self):\n    ''' Alternative to run() when there is no input of our own to parse,\n        meaning that run only really needs to close the handle to fast-import\n        and let it finish, thus making a call to \"run\" feel like a misnomer. '''\n    assert not self._input\n    assert self._managed_output\n    self.run()\n\n  def insert(self, obj, direct_insertion = False):\n    if not direct_insertion:\n      if type(obj) == Blob:\n        self._tweak_blob(obj)\n      elif type(obj) == Commit:\n        aux_info = {'orig_parents': obj.parents,\n                    'had_file_changes': bool(obj.file_changes)}\n        self._tweak_commit(obj, aux_info)\n      elif type(obj) == Reset:\n        self._tweak_reset(obj)\n      elif type(obj) == Tag:\n        self._tweak_tag(obj)\n    self._insert_into_stream(obj)\n\n  def _insert_into_stream(self, obj):\n    if not obj.dumped:\n      if self._lfs_object_tracker:\n        self._lfs_object_tracker.check_output_object(obj)\n      if self._parser:\n        self._parser.insert(obj)\n      else:\n        obj.dump(self._output)\n\n  def get_exported_and_imported_refs(self):\n    return self._parser.get_exported_and_imported_refs()\n\n  def run(self):\n    start = time.time()\n    if not self._input and not self._output:\n      self._run_sanity_checks()\n      if not self._args.dry_run and not self._args.partial:\n        self._read_stash()\n        self._migrate_origin_to_heads()\n      self._setup_input(use_done_feature = True)\n      self._setup_output()\n    assert self._sanity_checks_handled\n\n    if self._input:\n      # Create and run the filter\n      self._repo_working_dir = self._args.source or b'.'\n      self._parser = FastExportParser(blob_callback   = self._tweak_blob,\n                                      commit_callback = self._tweak_commit,\n                                      tag_callback    = self._tweak_tag,\n                                      reset_callback  = self._tweak_reset,\n                                      done_callback   = self._final_commands)\n      self._setup_lfs_orphaning_checks()\n      self._parser.run(self._input, self._output)\n      if not self._finalize_handled:\n        self._final_commands()\n\n      # Make sure fast-export completed successfully\n      if not self._args.stdin and self._fep.wait():\n        raise SystemExit(_(\"Error: fast-export failed; see above.\")) # pragma: no cover\n      self._input.close()\n\n    # If we're not the manager of self._output, we should avoid post-run cleanup\n    if not self._managed_output:\n      return\n\n    # Close the output and ensure fast-import successfully completes\n    self._output.close()\n    if not self._args.dry_run and self._fip.wait():\n      raise SystemExit(_(\"Error: fast-import failed; see above.\")) # pragma: no cover\n\n    # With fast-export and fast-import complete, update state if requested\n    if self._args.state_branch:\n      self._save_marks_files()\n\n    # Notify user how long it took, before doing a gc and such\n    msg = \"New history written in {:.2f} seconds...\"\n    if self._args.repack:\n      msg = \"New history written in {:.2f} seconds; now repacking/cleaning...\"\n    print(msg.format(time.time()-start))\n\n    # Exit early, if requested\n    if self._args.dry_run:\n      print(_(\"NOTE: Not running fast-import or cleaning up; --dry-run passed.\"))\n      if self._fe_orig:\n        print(_(\"      Requested filtering can be seen by comparing:\"))\n        print(\"        \" + decode(self._fe_orig))\n      else:\n        print(_(\"      Requested filtering can be seen at:\"))\n      print(\"        \" + decode(self._fe_filt))\n      return\n\n    target_working_dir = self._args.target or b'.'\n    if self._input:\n      self._ref_update(target_working_dir)\n\n      # Write out data about run\n      self._record_metadata(self.results_tmp_dir(), self._orig_refs)\n\n    # Final cleanup:\n    #   If we need a repack, then nuke the reflogs and repack.\n    #   If we need a reset, do a reset --hard\n    reset = not GitUtils.is_repository_bare(target_working_dir)\n    self.cleanup(target_working_dir, self._args.repack, reset,\n                 run_quietly=self._args.quiet,\n                 show_debuginfo=self._args.debug)\n\n    # Let user know how long it took\n    print(_(\"Completely finished after {:.2f} seconds.\")\n          .format(time.time()-start))\n\n    # Give post-rewrite instructions for cleaning up other copies for SDR\n    if self._args.sensitive_data_removal:\n      lfs_note = \"\"\n      if self._lfs_object_tracker and \\\n         self._lfs_object_tracker.objects_orphaned == True:\n        lfs_note = _(\" and LFS Objects Orphaned\")\n      push_command = \"git push --force --mirror origin\"\n      if self._args.no_fetch:\n        if self._args.partial:\n          push_command = \"git push --force origin \" + \\\n                     \" \".join(sorted([decode(x) for x in self._changed_refs]))\n        else:\n          push_command = \"git push --all --tags origin\"\n      print(\"\")\n      print(sdr_next_steps % (push_command, lfs_note, lfs_note))\n\ndef main():\n  setup_gettext()\n  args = FilteringOptions.parse_args(sys.argv[1:])\n  if args.analyze:\n    RepoAnalyze.run(args)\n  else:\n    filter = RepoFilter(args)\n    filter.run()\n\nif __name__ == '__main__':\n  main()\n"
        },
        {
          "name": "git_filter_repo.py",
          "type": "blob",
          "size": 0.0146484375,
          "content": "git-filter-repo"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 1.3837890625,
          "content": "[project]\nname = \"git-filter-repo\"\ndescription = \"Quickly rewrite git repository history\"\nauthors = [\n    {name = \"Elijah Newren\", email = \"newren@gmail.com\"}\n]\nreadme = \"README.md\"\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Operating System :: OS Independent\",\n    \"Programming Language :: Python\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3.6\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: Implementation :: CPython\",\n    \"Programming Language :: Python :: Implementation :: PyPy\",\n]\nlicense.text = \"MIT\"\nrequires-python = \">= 3.6\"\ndynamic = [\"version\"]\n\n[project.urls]\nHomepage = \"https://github.com/newren/git-filter-repo\"\nIssues = \"https://github.com/newren/git-filter-repo/issues/\"\nSource = \"https://github.com/newren/git-filter-repo\"\n\n[project.scripts]\ngit-filter-repo = \"git_filter_repo:main\"\n\n[build-system]\nrequires = [\"setuptools>=61\", \"setuptools_scm>=8.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools]\npy-modules = [\"git_filter_repo\"]\n\n[tool.setuptools_scm]\n# This section intentionally left blank\n"
        },
        {
          "name": "t",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}