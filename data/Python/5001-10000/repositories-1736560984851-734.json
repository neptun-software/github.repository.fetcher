{
  "metadata": {
    "timestamp": 1736560984851,
    "page": 734,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ibab/tensorflow-wavenet",
      "stars": 5427,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.02734375,
          "content": "logdir/\nVCTK-Corpus/\n*.pyc\n\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.203125,
          "content": "language: python\nsudo: required\ndist: trusty\nmatrix:\n    include:\n        - python: 2.7\n        - python: 3.5\ninstall:\n    - source ci/install.sh\nscript:\n    - bash ci/test.sh\nnotifications:\n    email: false\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0556640625,
          "content": "The MIT License (MIT) Copyright (c) 2016 Igor Babuschkin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.0458984375,
          "content": "# A TensorFlow implementation of DeepMind's WaveNet paper\n\n[![Build Status](https://travis-ci.org/ibab/tensorflow-wavenet.svg?branch=master)](https://travis-ci.org/ibab/tensorflow-wavenet)\n\nThis is a TensorFlow implementation of the [WaveNet generative neural\nnetwork architecture](https://deepmind.com/blog/wavenet-generative-model-raw-audio/) for audio generation.\n\n<table style=\"border-collapse: collapse\">\n<tr>\n<td>\n<p>\nThe WaveNet neural network architecture directly generates a raw audio waveform,\nshowing excellent results in text-to-speech and general audio generation (see the\nDeepMind blog post and paper for details).\n</p>\n<p>\nThe network models the conditional probability to generate the next\nsample in the audio waveform, given all previous samples and possibly\nadditional parameters.\n</p>\n<p>\nAfter an audio preprocessing step, the input waveform is quantized to a fixed integer range.\nThe integer amplitudes are then one-hot encoded to produce a tensor of shape <code>(num_samples, num_channels)</code>.\n</p>\n<p>\nA convolutional layer that only accesses the current and previous inputs then reduces the channel dimension.\n</p>\n<p>\nThe core of the network is constructed as a stack of <em>causal dilated layers</em>, each of which is a\ndilated convolution (convolution with holes), which only accesses the current and past audio samples.\n</p>\n<p>\nThe outputs of all layers are combined and extended back to the original number\nof channels by a series of dense postprocessing layers, followed by a softmax\nfunction to transform the outputs into a categorical distribution.\n</p>\n<p>\nThe loss function is the cross-entropy between the output for each timestep and the input at the next timestep.\n</p>\n<p>\nIn this repository, the network implementation can be found in <a href=\"./wavenet/model.py\">model.py</a>.\n</p>\n</td>\n<td width=\"300\">\n<img src=\"images/network.png\" width=\"300\"></img>\n</td>\n</tr>\n</table>\n\n## Requirements\n\nTensorFlow needs to be installed before running the training script.\nCode is tested on TensorFlow version 1.0.1 for Python 2.7 and Python 3.5.\n\nIn addition, [librosa](https://github.com/librosa/librosa) must be installed for reading and writing audio.\n\nTo install the required python packages, run\n```bash\npip install -r requirements.txt\n```\n\nFor GPU support, use\n```bash\npip install -r requirements_gpu.txt\n```\n\n## Training the network\n\nYou can use any corpus containing `.wav` files.\nWe've mainly used the [VCTK corpus](http://homepages.inf.ed.ac.uk/jyamagis/page3/page58/page58.html) (around 10.4GB, [Alternative host](http://www.udialogue.org/download/cstr-vctk-corpus.html)) so far.\n\nIn order to train the network, execute\n```bash\npython train.py --data_dir=corpus\n```\nto train the network, where `corpus` is a directory containing `.wav` files.\nThe script will recursively collect all `.wav` files in the directory.\n\nYou can see documentation on each of the training settings by running\n```bash\npython train.py --help\n```\n\nYou can find the configuration of the model parameters in [`wavenet_params.json`](./wavenet_params.json).\nThese need to stay the same between training and generation.\n\n### Global Conditioning\nGlobal conditioning refers to modifying the model such that the id of a set of mutually-exclusive categories is specified during training and generation of .wav file.\nIn the case of the VCTK, this id is the integer id of the speaker, of which there are over a hundred.\nThis allows (indeed requires) that a speaker id be specified at time of generation to select which of the speakers it should mimic. For more details see the paper or source code.\n\n### Training with Global Conditioning\nThe instructions above for training refer to training without global conditioning. To train with global conditioning, specify command-line arguments as follows:\n```\npython train.py --data_dir=corpus --gc_channels=32\n```\nThe --gc_channels argument does two things:\n* It tells the train.py script that\nit should build a model that includes global conditioning.\n* It specifies the\nsize of the embedding vector that is looked up based on the id of the speaker.\n\nThe global conditioning logic in train.py and audio_reader.py is \"hard-wired\" to the VCTK corpus at the moment in that it expects to be able to determine the speaker id from the pattern of file naming used in VCTK, but can be easily be modified.\n\n## Generating audio\n\n[Example output](https://soundcloud.com/user-731806733/tensorflow-wavenet-500-msec-88k-train-steps)\ngenerated by @jyegerlehner based on speaker 280 from the VCTK corpus.\n\nYou can use the `generate.py` script to generate audio using a previously trained model.\n\n### Generating without Global Conditioning\nRun\n```\npython generate.py --samples 16000 logdir/train/2017-02-13T16-45-34/model.ckpt-80000\n```\nwhere `logdir/train/2017-02-13T16-45-34/model.ckpt-80000` needs to be a path to previously saved model (without extension).\nThe `--samples` parameter specifies how many audio samples you would like to generate (16000 corresponds to 1 second by default).\n\nThe generated waveform can be played back using TensorBoard, or stored as a\n`.wav` file by using the `--wav_out_path` parameter:\n```\npython generate.py --wav_out_path=generated.wav --samples 16000 logdir/train/2017-02-13T16-45-34/model.ckpt-80000\n```\n\nPassing `--save_every` in addition to `--wav_out_path` will save the in-progress wav file every n samples.\n```\npython generate.py --wav_out_path=generated.wav --save_every 2000 --samples 16000 logdir/train/2017-02-13T16-45-34/model.ckpt-80000\n```\n\nFast generation is enabled by default.\nIt uses the implementation from the [Fast Wavenet](https://github.com/tomlepaine/fast-wavenet) repository.\nYou can follow the link for an explanation of how it works.\nThis reduces the time needed to generate samples to a few minutes.\n\nTo disable fast generation:\n```\npython generate.py --samples 16000 logdir/train/2017-02-13T16-45-34/model.ckpt-80000 --fast_generation=false\n```\n\n### Generating with Global Conditioning\nGenerate from a model incorporating global conditioning as follows:\n```\npython generate.py --samples 16000  --wav_out_path speaker311.wav --gc_channels=32 --gc_cardinality=377 --gc_id=311 logdir/train/2017-02-13T16-45-34/model.ckpt-80000\n```\nWhere:\n\n`--gc_channels=32` specifies 32 is the size of the embedding vector, and\nmust match what was specified when training.\n\n`--gc_cardinality=377` is required\nas 376 is the largest id of a speaker in the VCTK corpus. If some other corpus\nis used, then this number should match what is automatically determined and\nprinted out by the train.py script at training time.\n\n`--gc_id=311` specifies the id of speaker, speaker 311, for which a sample is\nto be generated.\n\n## Running tests\n\nInstall the test requirements\n```\npip install -r requirements_test.txt\n```\n\nRun the test suite\n```\n./ci/test.sh\n```\n\n## Missing features\n\nCurrently there is no local conditioning on extra information which would allow\ncontext stacks or controlling what speech is generated.\n\n\n## Related projects\n\n- [tex-wavenet](https://github.com/Zeta36/tensorflow-tex-wavenet), a WaveNet for text generation.\n- [image-wavenet](https://github.com/Zeta36/tensorflow-image-wavenet), a WaveNet for image generation.\n"
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "generate.py",
          "type": "blob",
          "size": 9.9296875,
          "content": "from __future__ import division\nfrom __future__ import print_function\n\nimport argparse\nfrom datetime import datetime\nimport json\nimport os\n\nimport librosa\nimport numpy as np\nimport tensorflow as tf\n\nfrom wavenet import WaveNetModel, mu_law_decode, mu_law_encode, audio_reader\n\nSAMPLES = 16000\nTEMPERATURE = 1.0\nLOGDIR = './logdir'\nWAVENET_PARAMS = './wavenet_params.json'\nSAVE_EVERY = None\nSILENCE_THRESHOLD = 0.1\n\n\ndef get_arguments():\n    def _str_to_bool(s):\n        \"\"\"Convert string to bool (in argparse context).\"\"\"\n        if s.lower() not in ['true', 'false']:\n            raise ValueError('Argument needs to be a '\n                             'boolean, got {}'.format(s))\n        return {'true': True, 'false': False}[s.lower()]\n\n    def _ensure_positive_float(f):\n        \"\"\"Ensure argument is a positive float.\"\"\"\n        if float(f) < 0:\n            raise argparse.ArgumentTypeError(\n                    'Argument must be greater than zero')\n        return float(f)\n\n    parser = argparse.ArgumentParser(description='WaveNet generation script')\n    parser.add_argument(\n        'checkpoint', type=str, help='Which model checkpoint to generate from')\n    parser.add_argument(\n        '--samples',\n        type=int,\n        default=SAMPLES,\n        help='How many waveform samples to generate')\n    parser.add_argument(\n        '--temperature',\n        type=_ensure_positive_float,\n        default=TEMPERATURE,\n        help='Sampling temperature')\n    parser.add_argument(\n        '--logdir',\n        type=str,\n        default=LOGDIR,\n        help='Directory in which to store the logging '\n        'information for TensorBoard.')\n    parser.add_argument(\n        '--wavenet_params',\n        type=str,\n        default=WAVENET_PARAMS,\n        help='JSON file with the network parameters')\n    parser.add_argument(\n        '--wav_out_path',\n        type=str,\n        default=None,\n        help='Path to output wav file')\n    parser.add_argument(\n        '--save_every',\n        type=int,\n        default=SAVE_EVERY,\n        help='How many samples before saving in-progress wav')\n    parser.add_argument(\n        '--fast_generation',\n        type=_str_to_bool,\n        default=True,\n        help='Use fast generation')\n    parser.add_argument(\n        '--wav_seed',\n        type=str,\n        default=None,\n        help='The wav file to start generation from')\n    parser.add_argument(\n        '--gc_channels',\n        type=int,\n        default=None,\n        help='Number of global condition embedding channels. Omit if no '\n             'global conditioning.')\n    parser.add_argument(\n        '--gc_cardinality',\n        type=int,\n        default=None,\n        help='Number of categories upon which we globally condition.')\n    parser.add_argument(\n        '--gc_id',\n        type=int,\n        default=None,\n        help='ID of category to generate, if globally conditioned.')\n    arguments = parser.parse_args()\n    if arguments.gc_channels is not None:\n        if arguments.gc_cardinality is None:\n            raise ValueError(\"Globally conditioning but gc_cardinality not \"\n                             \"specified. Use --gc_cardinality=377 for full \"\n                             \"VCTK corpus.\")\n\n        if arguments.gc_id is None:\n            raise ValueError(\"Globally conditioning, but global condition was \"\n                              \"not specified. Use --gc_id to specify global \"\n                              \"condition.\")\n\n    return arguments\n\n\ndef write_wav(waveform, sample_rate, filename):\n    y = np.array(waveform)\n    librosa.output.write_wav(filename, y, sample_rate)\n    print('Updated wav file at {}'.format(filename))\n\n\ndef create_seed(filename,\n                sample_rate,\n                quantization_channels,\n                window_size,\n                silence_threshold=SILENCE_THRESHOLD):\n    audio, _ = librosa.load(filename, sr=sample_rate, mono=True)\n    audio = audio_reader.trim_silence(audio, silence_threshold)\n\n    quantized = mu_law_encode(audio, quantization_channels)\n    cut_index = tf.cond(tf.size(quantized) < tf.constant(window_size),\n                        lambda: tf.size(quantized),\n                        lambda: tf.constant(window_size))\n\n    return quantized[:cut_index]\n\n\ndef main():\n    args = get_arguments()\n    started_datestring = \"{0:%Y-%m-%dT%H-%M-%S}\".format(datetime.now())\n    logdir = os.path.join(args.logdir, 'generate', started_datestring)\n    with open(args.wavenet_params, 'r') as config_file:\n        wavenet_params = json.load(config_file)\n\n    sess = tf.Session()\n\n    net = WaveNetModel(\n        batch_size=1,\n        dilations=wavenet_params['dilations'],\n        filter_width=wavenet_params['filter_width'],\n        residual_channels=wavenet_params['residual_channels'],\n        dilation_channels=wavenet_params['dilation_channels'],\n        quantization_channels=wavenet_params['quantization_channels'],\n        skip_channels=wavenet_params['skip_channels'],\n        use_biases=wavenet_params['use_biases'],\n        scalar_input=wavenet_params['scalar_input'],\n        initial_filter_width=wavenet_params['initial_filter_width'],\n        global_condition_channels=args.gc_channels,\n        global_condition_cardinality=args.gc_cardinality)\n\n    samples = tf.placeholder(tf.int32)\n\n    if args.fast_generation:\n        next_sample = net.predict_proba_incremental(samples, args.gc_id)\n    else:\n        next_sample = net.predict_proba(samples, args.gc_id)\n\n    if args.fast_generation:\n        sess.run(tf.global_variables_initializer())\n        sess.run(net.init_ops)\n\n    variables_to_restore = {\n        var.name[:-2]: var for var in tf.global_variables()\n        if not ('state_buffer' in var.name or 'pointer' in var.name)}\n    saver = tf.train.Saver(variables_to_restore)\n\n    print('Restoring model from {}'.format(args.checkpoint))\n    saver.restore(sess, args.checkpoint)\n\n    decode = mu_law_decode(samples, wavenet_params['quantization_channels'])\n\n    quantization_channels = wavenet_params['quantization_channels']\n    if args.wav_seed:\n        seed = create_seed(args.wav_seed,\n                           wavenet_params['sample_rate'],\n                           quantization_channels,\n                           net.receptive_field)\n        waveform = sess.run(seed).tolist()\n    else:\n        # Silence with a single random sample at the end.\n        waveform = [quantization_channels / 2] * (net.receptive_field - 1)\n        waveform.append(np.random.randint(quantization_channels))\n\n    if args.fast_generation and args.wav_seed:\n        # When using the incremental generation, we need to\n        # feed in all priming samples one by one before starting the\n        # actual generation.\n        # TODO This could be done much more efficiently by passing the waveform\n        # to the incremental generator as an optional argument, which would be\n        # used to fill the queues initially.\n        outputs = [next_sample]\n        outputs.extend(net.push_ops)\n\n        print('Priming generation...')\n        for i, x in enumerate(waveform[-net.receptive_field: -1]):\n            if i % 100 == 0:\n                print('Priming sample {}'.format(i))\n            sess.run(outputs, feed_dict={samples: x})\n        print('Done.')\n\n    last_sample_timestamp = datetime.now()\n    for step in range(args.samples):\n        if args.fast_generation:\n            outputs = [next_sample]\n            outputs.extend(net.push_ops)\n            window = waveform[-1]\n        else:\n            if len(waveform) > net.receptive_field:\n                window = waveform[-net.receptive_field:]\n            else:\n                window = waveform\n            outputs = [next_sample]\n\n        # Run the WaveNet to predict the next sample.\n        prediction = sess.run(outputs, feed_dict={samples: window})[0]\n\n        # Scale prediction distribution using temperature.\n        np.seterr(divide='ignore')\n        scaled_prediction = np.log(prediction) / args.temperature\n        scaled_prediction = (scaled_prediction -\n                             np.logaddexp.reduce(scaled_prediction))\n        scaled_prediction = np.exp(scaled_prediction)\n        np.seterr(divide='warn')\n\n        # Prediction distribution at temperature=1.0 should be unchanged after\n        # scaling.\n        if args.temperature == 1.0:\n            np.testing.assert_allclose(\n                    prediction, scaled_prediction, atol=1e-5,\n                    err_msg='Prediction scaling at temperature=1.0 '\n                            'is not working as intended.')\n\n        sample = np.random.choice(\n            np.arange(quantization_channels), p=scaled_prediction)\n        waveform.append(sample)\n\n        # Show progress only once per second.\n        current_sample_timestamp = datetime.now()\n        time_since_print = current_sample_timestamp - last_sample_timestamp\n        if time_since_print.total_seconds() > 1.:\n            print('Sample {:3<d}/{:3<d}'.format(step + 1, args.samples),\n                  end='\\r')\n            last_sample_timestamp = current_sample_timestamp\n\n        # If we have partial writing, save the result so far.\n        if (args.wav_out_path and args.save_every and\n                (step + 1) % args.save_every == 0):\n            out = sess.run(decode, feed_dict={samples: waveform})\n            write_wav(out, wavenet_params['sample_rate'], args.wav_out_path)\n\n    # Introduce a newline to clear the carriage return from the progress.\n    print()\n\n    # Save the result as an audio summary.\n    datestring = str(datetime.now()).replace(' ', 'T')\n    writer = tf.summary.FileWriter(logdir)\n    tf.summary.audio('generated', decode, wavenet_params['sample_rate'])\n    summaries = tf.summary.merge_all()\n    summary_out = sess.run(summaries,\n                           feed_dict={samples: np.reshape(waveform, [-1, 1])})\n    writer.add_summary(summary_out)\n\n    # Save the result as a wav file.\n    if args.wav_out_path:\n        out = sess.run(decode, feed_dict={samples: waveform})\n        write_wav(out, wavenet_params['sample_rate'], args.wav_out_path)\n\n    print('Finished generating. The result can be viewed in TensorBoard.')\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0302734375,
          "content": "librosa>=0.5\ntensorflow>=1.0.0\n"
        },
        {
          "name": "requirements_gpu.txt",
          "type": "blob",
          "size": 0.0341796875,
          "content": "librosa>=0.5\ntensorflow-gpu>=1.0.0\n"
        },
        {
          "name": "requirements_test.txt",
          "type": "blob",
          "size": 0.1328125,
          "content": "# Pull in the packages required to run the project\n-r requirements.txt\n\n# Testing-specific package requirements\npep8>=1.7.0\nnose>=1.3.7\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "train.py",
          "type": "blob",
          "size": 13.9140625,
          "content": "\"\"\"Training script for the WaveNet network on the VCTK corpus.\n\nThis script trains a network with the WaveNet using data from the VCTK corpus,\nwhich can be freely downloaded at the following site (~10 GB):\nhttp://homepages.inf.ed.ac.uk/jyamagis/page3/page58/page58.html\n\"\"\"\n\nfrom __future__ import print_function\n\nimport argparse\nfrom datetime import datetime\nimport json\nimport os\nimport sys\nimport time\n\nimport tensorflow as tf\nfrom tensorflow.python.client import timeline\n\nfrom wavenet import WaveNetModel, AudioReader, optimizer_factory\n\nBATCH_SIZE = 1\nDATA_DIRECTORY = './VCTK-Corpus'\nLOGDIR_ROOT = './logdir'\nCHECKPOINT_EVERY = 50\nNUM_STEPS = int(1e5)\nLEARNING_RATE = 1e-3\nWAVENET_PARAMS = './wavenet_params.json'\nSTARTED_DATESTRING = \"{0:%Y-%m-%dT%H-%M-%S}\".format(datetime.now())\nSAMPLE_SIZE = 100000\nL2_REGULARIZATION_STRENGTH = 0\nSILENCE_THRESHOLD = 0.3\nEPSILON = 0.001\nMOMENTUM = 0.9\nMAX_TO_KEEP = 5\nMETADATA = False\n\n\ndef get_arguments():\n    def _str_to_bool(s):\n        \"\"\"Convert string to bool (in argparse context).\"\"\"\n        if s.lower() not in ['true', 'false']:\n            raise ValueError('Argument needs to be a '\n                             'boolean, got {}'.format(s))\n        return {'true': True, 'false': False}[s.lower()]\n\n    parser = argparse.ArgumentParser(description='WaveNet example network')\n    parser.add_argument('--batch_size', type=int, default=BATCH_SIZE,\n                        help='How many wav files to process at once. Default: ' + str(BATCH_SIZE) + '.')\n    parser.add_argument('--data_dir', type=str, default=DATA_DIRECTORY,\n                        help='The directory containing the VCTK corpus.')\n    parser.add_argument('--store_metadata', type=bool, default=METADATA,\n                        help='Whether to store advanced debugging information '\n                        '(execution time, memory consumption) for use with '\n                        'TensorBoard. Default: ' + str(METADATA) + '.')\n    parser.add_argument('--logdir', type=str, default=None,\n                        help='Directory in which to store the logging '\n                        'information for TensorBoard. '\n                        'If the model already exists, it will restore '\n                        'the state and will continue training. '\n                        'Cannot use with --logdir_root and --restore_from.')\n    parser.add_argument('--logdir_root', type=str, default=None,\n                        help='Root directory to place the logging '\n                        'output and generated model. These are stored '\n                        'under the dated subdirectory of --logdir_root. '\n                        'Cannot use with --logdir.')\n    parser.add_argument('--restore_from', type=str, default=None,\n                        help='Directory in which to restore the model from. '\n                        'This creates the new model under the dated directory '\n                        'in --logdir_root. '\n                        'Cannot use with --logdir.')\n    parser.add_argument('--checkpoint_every', type=int,\n                        default=CHECKPOINT_EVERY,\n                        help='How many steps to save each checkpoint after. Default: ' + str(CHECKPOINT_EVERY) + '.')\n    parser.add_argument('--num_steps', type=int, default=NUM_STEPS,\n                        help='Number of training steps. Default: ' + str(NUM_STEPS) + '.')\n    parser.add_argument('--learning_rate', type=float, default=LEARNING_RATE,\n                        help='Learning rate for training. Default: ' + str(LEARNING_RATE) + '.')\n    parser.add_argument('--wavenet_params', type=str, default=WAVENET_PARAMS,\n                        help='JSON file with the network parameters. Default: ' + WAVENET_PARAMS + '.')\n    parser.add_argument('--sample_size', type=int, default=SAMPLE_SIZE,\n                        help='Concatenate and cut audio samples to this many '\n                        'samples. Default: ' + str(SAMPLE_SIZE) + '.')\n    parser.add_argument('--l2_regularization_strength', type=float,\n                        default=L2_REGULARIZATION_STRENGTH,\n                        help='Coefficient in the L2 regularization. '\n                        'Default: False')\n    parser.add_argument('--silence_threshold', type=float,\n                        default=SILENCE_THRESHOLD,\n                        help='Volume threshold below which to trim the start '\n                        'and the end from the training set samples. Default: ' + str(SILENCE_THRESHOLD) + '.')\n    parser.add_argument('--optimizer', type=str, default='adam',\n                        choices=optimizer_factory.keys(),\n                        help='Select the optimizer specified by this option. Default: adam.')\n    parser.add_argument('--momentum', type=float,\n                        default=MOMENTUM, help='Specify the momentum to be '\n                        'used by sgd or rmsprop optimizer. Ignored by the '\n                        'adam optimizer. Default: ' + str(MOMENTUM) + '.')\n    parser.add_argument('--histograms', type=_str_to_bool, default=False,\n                        help='Whether to store histogram summaries. Default: False')\n    parser.add_argument('--gc_channels', type=int, default=None,\n                        help='Number of global condition channels. Default: None. Expecting: Int')\n    parser.add_argument('--max_checkpoints', type=int, default=MAX_TO_KEEP,\n                        help='Maximum amount of checkpoints that will be kept alive. Default: '\n                             + str(MAX_TO_KEEP) + '.')\n    return parser.parse_args()\n\n\ndef save(saver, sess, logdir, step):\n    model_name = 'model.ckpt'\n    checkpoint_path = os.path.join(logdir, model_name)\n    print('Storing checkpoint to {} ...'.format(logdir), end=\"\")\n    sys.stdout.flush()\n\n    if not os.path.exists(logdir):\n        os.makedirs(logdir)\n\n    saver.save(sess, checkpoint_path, global_step=step)\n    print(' Done.')\n\n\ndef load(saver, sess, logdir):\n    print(\"Trying to restore saved checkpoints from {} ...\".format(logdir),\n          end=\"\")\n\n    ckpt = tf.train.get_checkpoint_state(logdir)\n    if ckpt:\n        print(\"  Checkpoint found: {}\".format(ckpt.model_checkpoint_path))\n        global_step = int(ckpt.model_checkpoint_path\n                          .split('/')[-1]\n                          .split('-')[-1])\n        print(\"  Global step was: {}\".format(global_step))\n        print(\"  Restoring...\", end=\"\")\n        saver.restore(sess, ckpt.model_checkpoint_path)\n        print(\" Done.\")\n        return global_step\n    else:\n        print(\" No checkpoint found.\")\n        return None\n\n\ndef get_default_logdir(logdir_root):\n    logdir = os.path.join(logdir_root, 'train', STARTED_DATESTRING)\n    return logdir\n\n\ndef validate_directories(args):\n    \"\"\"Validate and arrange directory related arguments.\"\"\"\n\n    # Validation\n    if args.logdir and args.logdir_root:\n        raise ValueError(\"--logdir and --logdir_root cannot be \"\n                         \"specified at the same time.\")\n\n    if args.logdir and args.restore_from:\n        raise ValueError(\n            \"--logdir and --restore_from cannot be specified at the same \"\n            \"time. This is to keep your previous model from unexpected \"\n            \"overwrites.\\n\"\n            \"Use --logdir_root to specify the root of the directory which \"\n            \"will be automatically created with current date and time, or use \"\n            \"only --logdir to just continue the training from the last \"\n            \"checkpoint.\")\n\n    # Arrangement\n    logdir_root = args.logdir_root\n    if logdir_root is None:\n        logdir_root = LOGDIR_ROOT\n\n    logdir = args.logdir\n    if logdir is None:\n        logdir = get_default_logdir(logdir_root)\n        print('Using default logdir: {}'.format(logdir))\n\n    restore_from = args.restore_from\n    if restore_from is None:\n        # args.logdir and args.restore_from are exclusive,\n        # so it is guaranteed the logdir here is newly created.\n        restore_from = logdir\n\n    return {\n        'logdir': logdir,\n        'logdir_root': args.logdir_root,\n        'restore_from': restore_from\n    }\n\n\ndef main():\n    args = get_arguments()\n\n    try:\n        directories = validate_directories(args)\n    except ValueError as e:\n        print(\"Some arguments are wrong:\")\n        print(str(e))\n        return\n\n    logdir = directories['logdir']\n    restore_from = directories['restore_from']\n\n    # Even if we restored the model, we will treat it as new training\n    # if the trained model is written into an arbitrary location.\n    is_overwritten_training = logdir != restore_from\n\n    with open(args.wavenet_params, 'r') as f:\n        wavenet_params = json.load(f)\n\n    # Create coordinator.\n    coord = tf.train.Coordinator()\n\n    # Load raw waveform from VCTK corpus.\n    with tf.name_scope('create_inputs'):\n        # Allow silence trimming to be skipped by specifying a threshold near\n        # zero.\n        silence_threshold = args.silence_threshold if args.silence_threshold > \\\n                                                      EPSILON else None\n        gc_enabled = args.gc_channels is not None\n        reader = AudioReader(\n            args.data_dir,\n            coord,\n            sample_rate=wavenet_params['sample_rate'],\n            gc_enabled=gc_enabled,\n            receptive_field=WaveNetModel.calculate_receptive_field(wavenet_params[\"filter_width\"],\n                                                                   wavenet_params[\"dilations\"],\n                                                                   wavenet_params[\"scalar_input\"],\n                                                                   wavenet_params[\"initial_filter_width\"]),\n            sample_size=args.sample_size,\n            silence_threshold=silence_threshold)\n        audio_batch = reader.dequeue(args.batch_size)\n        if gc_enabled:\n            gc_id_batch = reader.dequeue_gc(args.batch_size)\n        else:\n            gc_id_batch = None\n\n    # Create network.\n    net = WaveNetModel(\n        batch_size=args.batch_size,\n        dilations=wavenet_params[\"dilations\"],\n        filter_width=wavenet_params[\"filter_width\"],\n        residual_channels=wavenet_params[\"residual_channels\"],\n        dilation_channels=wavenet_params[\"dilation_channels\"],\n        skip_channels=wavenet_params[\"skip_channels\"],\n        quantization_channels=wavenet_params[\"quantization_channels\"],\n        use_biases=wavenet_params[\"use_biases\"],\n        scalar_input=wavenet_params[\"scalar_input\"],\n        initial_filter_width=wavenet_params[\"initial_filter_width\"],\n        histograms=args.histograms,\n        global_condition_channels=args.gc_channels,\n        global_condition_cardinality=reader.gc_category_cardinality)\n\n    if args.l2_regularization_strength == 0:\n        args.l2_regularization_strength = None\n    loss = net.loss(input_batch=audio_batch,\n                    global_condition_batch=gc_id_batch,\n                    l2_regularization_strength=args.l2_regularization_strength)\n    optimizer = optimizer_factory[args.optimizer](\n                    learning_rate=args.learning_rate,\n                    momentum=args.momentum)\n    trainable = tf.trainable_variables()\n    optim = optimizer.minimize(loss, var_list=trainable)\n\n    # Set up logging for TensorBoard.\n    writer = tf.summary.FileWriter(logdir)\n    writer.add_graph(tf.get_default_graph())\n    run_metadata = tf.RunMetadata()\n    summaries = tf.summary.merge_all()\n\n    # Set up session\n    sess = tf.Session(config=tf.ConfigProto(log_device_placement=False))\n    init = tf.global_variables_initializer()\n    sess.run(init)\n\n    # Saver for storing checkpoints of the model.\n    saver = tf.train.Saver(var_list=tf.trainable_variables(), max_to_keep=args.max_checkpoints)\n\n    try:\n        saved_global_step = load(saver, sess, restore_from)\n        if is_overwritten_training or saved_global_step is None:\n            # The first training step will be saved_global_step + 1,\n            # therefore we put -1 here for new or overwritten trainings.\n            saved_global_step = -1\n\n    except:\n        print(\"Something went wrong while restoring checkpoint. \"\n              \"We will terminate training to avoid accidentally overwriting \"\n              \"the previous model.\")\n        raise\n\n    threads = tf.train.start_queue_runners(sess=sess, coord=coord)\n    reader.start_threads(sess)\n\n    step = None\n    last_saved_step = saved_global_step\n    try:\n        for step in range(saved_global_step + 1, args.num_steps):\n            start_time = time.time()\n            if args.store_metadata and step % 50 == 0:\n                # Slow run that stores extra information for debugging.\n                print('Storing metadata')\n                run_options = tf.RunOptions(\n                    trace_level=tf.RunOptions.FULL_TRACE)\n                summary, loss_value, _ = sess.run(\n                    [summaries, loss, optim],\n                    options=run_options,\n                    run_metadata=run_metadata)\n                writer.add_summary(summary, step)\n                writer.add_run_metadata(run_metadata,\n                                        'step_{:04d}'.format(step))\n                tl = timeline.Timeline(run_metadata.step_stats)\n                timeline_path = os.path.join(logdir, 'timeline.trace')\n                with open(timeline_path, 'w') as f:\n                    f.write(tl.generate_chrome_trace_format(show_memory=True))\n            else:\n                summary, loss_value, _ = sess.run([summaries, loss, optim])\n                writer.add_summary(summary, step)\n\n            duration = time.time() - start_time\n            print('step {:d} - loss = {:.3f}, ({:.3f} sec/step)'\n                  .format(step, loss_value, duration))\n\n            if step % args.checkpoint_every == 0:\n                save(saver, sess, logdir, step)\n                last_saved_step = step\n\n    except KeyboardInterrupt:\n        # Introduce a line break after ^C is displayed so save message\n        # is on its own line.\n        print()\n    finally:\n        if step > last_saved_step:\n            save(saver, sess, logdir, step)\n        coord.request_stop()\n        coord.join(threads)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "wavenet",
          "type": "tree",
          "content": null
        },
        {
          "name": "wavenet_params.json",
          "type": "blob",
          "size": 0.5263671875,
          "content": "{\n    \"filter_width\": 2,\n    \"sample_rate\": 16000,\n    \"dilations\": [1, 2, 4, 8, 16, 32, 64, 128, 256, 512,\n                  1, 2, 4, 8, 16, 32, 64, 128, 256, 512,\n                  1, 2, 4, 8, 16, 32, 64, 128, 256, 512,\n                  1, 2, 4, 8, 16, 32, 64, 128, 256, 512,\n                  1, 2, 4, 8, 16, 32, 64, 128, 256, 512],\n    \"residual_channels\": 32,\n    \"dilation_channels\": 32,\n    \"quantization_channels\": 256,\n    \"skip_channels\": 512,\n    \"use_biases\": true,\n    \"scalar_input\": false,\n    \"initial_filter_width\": 32\n}\n"
        }
      ]
    }
  ]
}