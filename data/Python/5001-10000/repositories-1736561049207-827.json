{
  "metadata": {
    "timestamp": 1736561049207,
    "page": 827,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "yl4579/StyleTTS2",
      "stars": 5120,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01171875,
          "content": "__pycache__\n"
        },
        {
          "name": "Colab",
          "type": "tree",
          "content": null
        },
        {
          "name": "Configs",
          "type": "tree",
          "content": null
        },
        {
          "name": "Data",
          "type": "tree",
          "content": null
        },
        {
          "name": "Demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0498046875,
          "content": "MIT License\n\nCopyright (c) 2023 Aaron (Yinghao) Li\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Modules",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.8349609375,
          "content": "# StyleTTS 2: Towards Human-Level Text-to-Speech through Style Diffusion and Adversarial Training with Large Speech Language Models\n\n### Yinghao Aaron Li, Cong Han, Vinay S. Raghavan, Gavin Mischler, Nima Mesgarani\n\n> In this paper, we present StyleTTS 2, a text-to-speech (TTS) model that leverages style diffusion and adversarial training with large speech language models (SLMs) to achieve human-level TTS synthesis. StyleTTS 2 differs from its predecessor by modeling styles as a latent random variable through diffusion models to generate the most suitable style for the text without requiring reference speech, achieving efficient latent diffusion while benefiting from the diverse speech synthesis offered by diffusion models. Furthermore, we employ large pre-trained SLMs, such as WavLM, as discriminators with our novel differentiable duration modeling for end-to-end training, resulting in improved speech naturalness. StyleTTS 2 surpasses human recordings on the single-speaker LJSpeech dataset and matches it on the multispeaker VCTK dataset as judged by native English speakers. Moreover, when trained on the LibriTTS dataset, our model outperforms previous publicly available models for zero-shot speaker adaptation. This work achieves the first human-level TTS synthesis on both single and multispeaker datasets, showcasing the potential of style diffusion and adversarial training with large SLMs.\n\nPaper: [https://arxiv.org/abs/2306.07691](https://arxiv.org/abs/2306.07691)\n\nAudio samples: [https://styletts2.github.io/](https://styletts2.github.io/)\n\nOnline demo: [Hugging Face](https://huggingface.co/spaces/styletts2/styletts2) (thank [@fakerybakery](https://github.com/fakerybakery) for the wonderful online demo)\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/yl4579/StyleTTS2/blob/main/) [![Discord](https://img.shields.io/discord/1197679063150637117?logo=discord&logoColor=white&label=Join%20our%20Community)](https://discord.gg/ha8sxdG2K4)\n\n## TODO\n- [x] Training and inference demo code for single-speaker models (LJSpeech)\n- [x] Test training code for multi-speaker models (VCTK and LibriTTS)\n- [x] Finish demo code for multispeaker model and upload pre-trained models\n- [x] Add a finetuning script for new speakers with base pre-trained multispeaker models\n- [ ] Fix DDP (accelerator) for `train_second.py` **(I have tried everything I could to fix this but had no success, so if you are willing to help, please see [#7](https://github.com/yl4579/StyleTTS2/issues/7))**\n\n## Pre-requisites\n1. Python >= 3.7\n2. Clone this repository:\n```bash\ngit clone https://github.com/yl4579/StyleTTS2.git\ncd StyleTTS2\n```\n3. Install python requirements: \n```bash\npip install -r requirements.txt\n```\nOn Windows add:\n```bash\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118 -U\n```\nAlso install phonemizer and espeak if you want to run the demo:\n```bash\npip install phonemizer\nsudo apt-get install espeak-ng\n```\n4. Download and extract the [LJSpeech dataset](https://keithito.com/LJ-Speech-Dataset/), unzip to the data folder and upsample the data to 24 kHz. The text aligner and pitch extractor are pre-trained on 24 kHz data, but you can easily change the preprocessing and re-train them using your own preprocessing. \nFor LibriTTS, you will need to combine train-clean-360 with train-clean-100 and rename the folder train-clean-460 (see [val_list_libritts.txt](https://github.com/yl4579/StyleTTS/blob/main/Data/val_list_libritts.txt) as an example).\n\n## Training\nFirst stage training:\n```bash\naccelerate launch train_first.py --config_path ./Configs/config.yml\n```\nSecond stage training **(DDP version not working, so the current version uses DP, again see [#7](https://github.com/yl4579/StyleTTS2/issues/7) if you want to help)**:\n```bash\npython train_second.py --config_path ./Configs/config.yml\n```\nYou can run both consecutively and it will train both the first and second stages. The model will be saved in the format \"epoch_1st_%05d.pth\" and \"epoch_2nd_%05d.pth\". Checkpoints and Tensorboard logs will be saved at `log_dir`. \n\nThe data list format needs to be `filename.wav|transcription|speaker`, see [val_list.txt](https://github.com/yl4579/StyleTTS2/blob/main/Data/val_list.txt) as an example. The speaker labels are needed for multi-speaker models because we need to sample reference audio for style diffusion model training. \n\n### Important Configurations\nIn [config.yml](https://github.com/yl4579/StyleTTS2/blob/main/Configs/config.yml), there are a few important configurations to take care of:\n- `OOD_data`: The path for out-of-distribution texts for SLM adversarial training. The format should be `text|anything`.\n- `min_length`: Minimum length of OOD texts for training. This is to make sure the synthesized speech has a minimum length.\n- `max_len`: Maximum length of audio for training. The unit is frame. Since the default hop size is 300, one frame is approximately `300 / 24000` (0.0125) second. Lowering this if you encounter the out-of-memory issue. \n- `multispeaker`: Set to true if you want to train a multispeaker model. This is needed because the architecture of the denoiser is different for single and multispeaker models.\n- `batch_percentage`: This is to make sure during SLM adversarial training there are no out-of-memory (OOM) issues. If you encounter OOM problem, please set a lower number for this. \n\n### Pre-trained modules\nIn [Utils](https://github.com/yl4579/StyleTTS2/tree/main/Utils) folder, there are three pre-trained models: \n- **[ASR](https://github.com/yl4579/StyleTTS2/tree/main/Utils/ASR) folder**: It contains the pre-trained text aligner, which was pre-trained on English (LibriTTS), Japanese (JVS), and Chinese (AiShell) corpus. It works well for most other languages without fine-tuning, but you can always train your own text aligner with the code here: [yl4579/AuxiliaryASR](https://github.com/yl4579/AuxiliaryASR).\n- **[JDC](https://github.com/yl4579/StyleTTS2/tree/main/Utils/JDC) folder**: It contains the pre-trained pitch extractor, which was pre-trained on English (LibriTTS) corpus only. However, it works well for other languages too because F0 is independent of language. If you want to train on singing corpus, it is recommended to train a new pitch extractor with the code here: [yl4579/PitchExtractor](https://github.com/yl4579/PitchExtractor).\n- **[PLBERT](https://github.com/yl4579/StyleTTS2/tree/main/Utils/PLBERT) folder**: It contains the pre-trained [PL-BERT](https://arxiv.org/abs/2301.08810) model, which was pre-trained on English (Wikipedia) corpus only. It probably does not work very well on other languages, so you will need to train a different PL-BERT for different languages using the repo here: [yl4579/PL-BERT](https://github.com/yl4579/PL-BERT). You can also use the [multilingual PL-BERT](https://huggingface.co/papercup-ai/multilingual-pl-bert) which supports 14 languages. \n\n### Common Issues\n- **Loss becomes NaN**: If it is the first stage, please make sure you do not use mixed precision, as it can cause loss becoming NaN for some particular datasets when the batch size is not set properly (need to be more than 16 to work well). For the second stage, please also experiment with different batch sizes, with higher batch sizes being more likely to cause NaN loss values. We recommend the batch size to be 16. You can refer to issues [#10](https://github.com/yl4579/StyleTTS2/issues/10) and [#11](https://github.com/yl4579/StyleTTS2/issues/11) for more details.\n- **Out of memory**: Please either use lower `batch_size` or `max_len`. You may refer to issue [#10](https://github.com/yl4579/StyleTTS2/issues/10) for more information.\n- **Non-English dataset**: You can train on any language you want, but you will need to use a pre-trained PL-BERT model for that language. We have a pre-trained [multilingual PL-BERT](https://huggingface.co/papercup-ai/multilingual-pl-bert) that supports 14 languages. You may refer to [yl4579/StyleTTS#10](https://github.com/yl4579/StyleTTS/issues/10) and [#70](https://github.com/yl4579/StyleTTS2/issues/70) for some examples to train on Chinese datasets. \n\n## Finetuning\nThe script is modified from `train_second.py` which uses DP, as DDP does not work for `train_second.py`. Please see the bold section above if you are willing to help with this problem. \n```bash\npython train_finetune.py --config_path ./Configs/config_ft.yml\n```\nPlease make sure you have the LibriTTS checkpoint downloaded and unzipped under the folder. The default configuration `config_ft.yml` finetunes on LJSpeech with 1 hour of speech data (around 1k samples) for 50 epochs. This took about 4 hours to finish on four NVidia A100. The quality is slightly worse (similar to NaturalSpeech on LJSpeech) than LJSpeech model trained from scratch with 24 hours of speech data, which took around 2.5 days to finish on four A100. The samples can be found at [#65 (comment)](https://github.com/yl4579/StyleTTS2/discussions/65#discussioncomment-7668393). \n\nIf you are using a **single GPU** (because the script doesn't work with DDP) and want to save training speed and VRAM, you can do (thank [@korakoe](https://github.com/korakoe) for making the script at [#100](https://github.com/yl4579/StyleTTS2/pull/100)):\n```bash\naccelerate launch --mixed_precision=fp16 --num_processes=1 train_finetune_accelerate.py --config_path ./Configs/config_ft.yml\n```\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/yl4579/StyleTTS2/blob/main/Colab/StyleTTS2_Finetune_Demo.ipynb)\n\n### Common Issues\n[@Kreevoz](https://github.com/Kreevoz) has made detailed notes on common issues in finetuning, with suggestions in maximizing audio quality: [#81](https://github.com/yl4579/StyleTTS2/discussions/81). Some of these also apply to training from scratch. [@IIEleven11](https://github.com/IIEleven11) has also made a guideline for fine-tuning: [#128](https://github.com/yl4579/StyleTTS2/discussions/128).\n\n- **Out of memory after `joint_epoch`**: This is likely because your GPU RAM is not big enough for SLM adversarial training run. You may skip that but the quality could be worse. Setting `joint_epoch` a larger number than `epochs` could skip the SLM advesariral training.\n\n## Inference\nPlease refer to [Inference_LJSpeech.ipynb](https://github.com/yl4579/StyleTTS2/blob/main/Demo/Inference_LJSpeech.ipynb) (single-speaker) and [Inference_LibriTTS.ipynb](https://github.com/yl4579/StyleTTS2/blob/main/Demo/Inference_LibriTTS.ipynb) (multi-speaker) for details. For LibriTTS, you will also need to download [reference_audio.zip](https://huggingface.co/yl4579/StyleTTS2-LibriTTS/resolve/main/reference_audio.zip) and unzip it under the `demo` before running the demo. \n\n- The pretrained StyleTTS 2 on LJSpeech corpus in 24 kHz can be downloaded at [https://huggingface.co/yl4579/StyleTTS2-LJSpeech/tree/main](https://huggingface.co/yl4579/StyleTTS2-LJSpeech/tree/main).\n\n  [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/yl4579/StyleTTS2/blob/main/Colab/StyleTTS2_Demo_LJSpeech.ipynb)\n\n- The pretrained StyleTTS 2 model on LibriTTS can be downloaded at [https://huggingface.co/yl4579/StyleTTS2-LibriTTS/tree/main](https://huggingface.co/yl4579/StyleTTS2-LibriTTS/tree/main). \n\n  [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/yl4579/StyleTTS2/blob/main/Colab/StyleTTS2_Demo_LibriTTS.ipynb)\n\n\nYou can import StyleTTS 2 and run it in your own code. However, the inference depends on a GPL-licensed package, so it is not included directly in this repository. A [GPL-licensed fork](https://github.com/NeuralVox/StyleTTS2) has an importable script, as well as an experimental streaming API, etc. A [fully MIT-licensed package](https://pypi.org/project/styletts2/) that uses gruut (albeit lower quality due to mismatch between phonemizer and gruut) is also available.  \n\n***Before using these pre-trained models, you agree to inform the listeners that the speech samples are synthesized by the pre-trained models, unless you have the permission to use the voice you synthesize. That is, you agree to only use voices whose speakers grant the permission to have their voice cloned, either directly or by license before making synthesized voices public, or you have to publicly announce that these voices are synthesized if you do not have the permission to use these voices.*** \n\n### Common Issues\n- **High-pitched background noise**: This is caused by numerical float differences in older GPUs. For more details, please refer to issue [#13](https://github.com/yl4579/StyleTTS2/issues/13). Basically, you will need to use more modern GPUs or do inference on CPUs.\n- **Pre-trained model license**: You only need to abide by the above rules if you use **the pre-trained models** and the voices are **NOT** in the training set, i.e., your reference speakers are not from any open access dataset. For more details of rules to use the pre-trained models, please see [#37](https://github.com/yl4579/StyleTTS2/issues/37).\n\n## References\n- [archinetai/audio-diffusion-pytorch](https://github.com/archinetai/audio-diffusion-pytorch)\n- [jik876/hifi-gan](https://github.com/jik876/hifi-gan)\n- [rishikksh20/iSTFTNet-pytorch](https://github.com/rishikksh20/iSTFTNet-pytorch)\n- [nii-yamagishilab/project-NN-Pytorch-scripts/project/01-nsf](https://github.com/nii-yamagishilab/project-NN-Pytorch-scripts/tree/master/project/01-nsf)\n\n## License\n\nCode: MIT License\n\nPre-Trained Models: Before using these pre-trained models, you agree to inform the listeners that the speech samples are synthesized by the pre-trained models, unless you have the permission to use the voice you synthesize. That is, you agree to only use voices whose speakers grant the permission to have their voice cloned, either directly or by license before making synthesized voices public, or you have to publicly announce that these voices are synthesized if you do not have the permission to use these voices.\n"
        },
        {
          "name": "Utils",
          "type": "tree",
          "content": null
        },
        {
          "name": "losses.py",
          "type": "blob",
          "size": 8.9658203125,
          "content": "import torch\nfrom torch import nn\nimport torch.nn.functional as F\nimport torchaudio\nfrom transformers import AutoModel\n\nclass SpectralConvergengeLoss(torch.nn.Module):\n    \"\"\"Spectral convergence loss module.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initilize spectral convergence loss module.\"\"\"\n        super(SpectralConvergengeLoss, self).__init__()\n\n    def forward(self, x_mag, y_mag):\n        \"\"\"Calculate forward propagation.\n        Args:\n            x_mag (Tensor): Magnitude spectrogram of predicted signal (B, #frames, #freq_bins).\n            y_mag (Tensor): Magnitude spectrogram of groundtruth signal (B, #frames, #freq_bins).\n        Returns:\n            Tensor: Spectral convergence loss value.\n        \"\"\"\n        return torch.norm(y_mag - x_mag, p=1) / torch.norm(y_mag, p=1)\n\nclass STFTLoss(torch.nn.Module):\n    \"\"\"STFT loss module.\"\"\"\n\n    def __init__(self, fft_size=1024, shift_size=120, win_length=600, window=torch.hann_window):\n        \"\"\"Initialize STFT loss module.\"\"\"\n        super(STFTLoss, self).__init__()\n        self.fft_size = fft_size\n        self.shift_size = shift_size\n        self.win_length = win_length\n        self.to_mel = torchaudio.transforms.MelSpectrogram(sample_rate=24000, n_fft=fft_size, win_length=win_length, hop_length=shift_size, window_fn=window)\n\n        self.spectral_convergenge_loss = SpectralConvergengeLoss()\n\n    def forward(self, x, y):\n        \"\"\"Calculate forward propagation.\n        Args:\n            x (Tensor): Predicted signal (B, T).\n            y (Tensor): Groundtruth signal (B, T).\n        Returns:\n            Tensor: Spectral convergence loss value.\n            Tensor: Log STFT magnitude loss value.\n        \"\"\"\n        x_mag = self.to_mel(x)\n        mean, std = -4, 4\n        x_mag = (torch.log(1e-5 + x_mag) - mean) / std\n        \n        y_mag = self.to_mel(y)\n        mean, std = -4, 4\n        y_mag = (torch.log(1e-5 + y_mag) - mean) / std\n        \n        sc_loss = self.spectral_convergenge_loss(x_mag, y_mag)    \n        return sc_loss\n\n\nclass MultiResolutionSTFTLoss(torch.nn.Module):\n    \"\"\"Multi resolution STFT loss module.\"\"\"\n\n    def __init__(self,\n                 fft_sizes=[1024, 2048, 512],\n                 hop_sizes=[120, 240, 50],\n                 win_lengths=[600, 1200, 240],\n                 window=torch.hann_window):\n        \"\"\"Initialize Multi resolution STFT loss module.\n        Args:\n            fft_sizes (list): List of FFT sizes.\n            hop_sizes (list): List of hop sizes.\n            win_lengths (list): List of window lengths.\n            window (str): Window function type.\n        \"\"\"\n        super(MultiResolutionSTFTLoss, self).__init__()\n        assert len(fft_sizes) == len(hop_sizes) == len(win_lengths)\n        self.stft_losses = torch.nn.ModuleList()\n        for fs, ss, wl in zip(fft_sizes, hop_sizes, win_lengths):\n            self.stft_losses += [STFTLoss(fs, ss, wl, window)]\n\n    def forward(self, x, y):\n        \"\"\"Calculate forward propagation.\n        Args:\n            x (Tensor): Predicted signal (B, T).\n            y (Tensor): Groundtruth signal (B, T).\n        Returns:\n            Tensor: Multi resolution spectral convergence loss value.\n            Tensor: Multi resolution log STFT magnitude loss value.\n        \"\"\"\n        sc_loss = 0.0\n        for f in self.stft_losses:\n            sc_l = f(x, y)\n            sc_loss += sc_l\n        sc_loss /= len(self.stft_losses)\n\n        return sc_loss\n    \n    \ndef feature_loss(fmap_r, fmap_g):\n    loss = 0\n    for dr, dg in zip(fmap_r, fmap_g):\n        for rl, gl in zip(dr, dg):\n            loss += torch.mean(torch.abs(rl - gl))\n\n    return loss*2\n\n\ndef discriminator_loss(disc_real_outputs, disc_generated_outputs):\n    loss = 0\n    r_losses = []\n    g_losses = []\n    for dr, dg in zip(disc_real_outputs, disc_generated_outputs):\n        r_loss = torch.mean((1-dr)**2)\n        g_loss = torch.mean(dg**2)\n        loss += (r_loss + g_loss)\n        r_losses.append(r_loss.item())\n        g_losses.append(g_loss.item())\n\n    return loss, r_losses, g_losses\n\n\ndef generator_loss(disc_outputs):\n    loss = 0\n    gen_losses = []\n    for dg in disc_outputs:\n        l = torch.mean((1-dg)**2)\n        gen_losses.append(l)\n        loss += l\n\n    return loss, gen_losses\n\n\"\"\" https://dl.acm.org/doi/abs/10.1145/3573834.3574506 \"\"\"\ndef discriminator_TPRLS_loss(disc_real_outputs, disc_generated_outputs):\n    loss = 0\n    for dr, dg in zip(disc_real_outputs, disc_generated_outputs):\n        tau = 0.04\n        m_DG = torch.median((dr-dg))\n        L_rel = torch.mean((((dr - dg) - m_DG)**2)[dr < dg + m_DG])\n        loss += tau - F.relu(tau - L_rel)\n    return loss\n\ndef generator_TPRLS_loss(disc_real_outputs, disc_generated_outputs):\n    loss = 0\n    for dg, dr in zip(disc_real_outputs, disc_generated_outputs):\n        tau = 0.04\n        m_DG = torch.median((dr-dg))\n        L_rel = torch.mean((((dr - dg) - m_DG)**2)[dr < dg + m_DG])\n        loss += tau - F.relu(tau - L_rel)\n    return loss\n\nclass GeneratorLoss(torch.nn.Module):\n\n    def __init__(self, mpd, msd):\n        super(GeneratorLoss, self).__init__()\n        self.mpd = mpd\n        self.msd = msd\n        \n    def forward(self, y, y_hat):\n        y_df_hat_r, y_df_hat_g, fmap_f_r, fmap_f_g = self.mpd(y, y_hat)\n        y_ds_hat_r, y_ds_hat_g, fmap_s_r, fmap_s_g = self.msd(y, y_hat)\n        loss_fm_f = feature_loss(fmap_f_r, fmap_f_g)\n        loss_fm_s = feature_loss(fmap_s_r, fmap_s_g)\n        loss_gen_f, losses_gen_f = generator_loss(y_df_hat_g)\n        loss_gen_s, losses_gen_s = generator_loss(y_ds_hat_g)\n\n        loss_rel = generator_TPRLS_loss(y_df_hat_r, y_df_hat_g) + generator_TPRLS_loss(y_ds_hat_r, y_ds_hat_g)\n        \n        loss_gen_all = loss_gen_s + loss_gen_f + loss_fm_s + loss_fm_f + loss_rel\n        \n        return loss_gen_all.mean()\n    \nclass DiscriminatorLoss(torch.nn.Module):\n\n    def __init__(self, mpd, msd):\n        super(DiscriminatorLoss, self).__init__()\n        self.mpd = mpd\n        self.msd = msd\n        \n    def forward(self, y, y_hat):\n        # MPD\n        y_df_hat_r, y_df_hat_g, _, _ = self.mpd(y, y_hat)\n        loss_disc_f, losses_disc_f_r, losses_disc_f_g = discriminator_loss(y_df_hat_r, y_df_hat_g)\n        # MSD\n        y_ds_hat_r, y_ds_hat_g, _, _ = self.msd(y, y_hat)\n        loss_disc_s, losses_disc_s_r, losses_disc_s_g = discriminator_loss(y_ds_hat_r, y_ds_hat_g)\n        \n        loss_rel = discriminator_TPRLS_loss(y_df_hat_r, y_df_hat_g) + discriminator_TPRLS_loss(y_ds_hat_r, y_ds_hat_g)\n\n\n        d_loss = loss_disc_s + loss_disc_f + loss_rel\n        \n        return d_loss.mean()\n   \n    \nclass WavLMLoss(torch.nn.Module):\n\n    def __init__(self, model, wd, model_sr, slm_sr=16000):\n        super(WavLMLoss, self).__init__()\n        self.wavlm = AutoModel.from_pretrained(model)\n        self.wd = wd\n        self.resample = torchaudio.transforms.Resample(model_sr, slm_sr)\n     \n    def forward(self, wav, y_rec):\n        with torch.no_grad():\n            wav_16 = self.resample(wav)\n            wav_embeddings = self.wavlm(input_values=wav_16, output_hidden_states=True).hidden_states\n        y_rec_16 = self.resample(y_rec)\n        y_rec_embeddings = self.wavlm(input_values=y_rec_16.squeeze(), output_hidden_states=True).hidden_states\n\n        floss = 0\n        for er, eg in zip(wav_embeddings, y_rec_embeddings):\n            floss += torch.mean(torch.abs(er - eg))\n        \n        return floss.mean()\n    \n    def generator(self, y_rec):\n        y_rec_16 = self.resample(y_rec)\n        y_rec_embeddings = self.wavlm(input_values=y_rec_16, output_hidden_states=True).hidden_states\n        y_rec_embeddings = torch.stack(y_rec_embeddings, dim=1).transpose(-1, -2).flatten(start_dim=1, end_dim=2)\n        y_df_hat_g = self.wd(y_rec_embeddings)\n        loss_gen = torch.mean((1-y_df_hat_g)**2)\n        \n        return loss_gen\n    \n    def discriminator(self, wav, y_rec):\n        with torch.no_grad():\n            wav_16 = self.resample(wav)\n            wav_embeddings = self.wavlm(input_values=wav_16, output_hidden_states=True).hidden_states\n            y_rec_16 = self.resample(y_rec)\n            y_rec_embeddings = self.wavlm(input_values=y_rec_16, output_hidden_states=True).hidden_states\n\n            y_embeddings = torch.stack(wav_embeddings, dim=1).transpose(-1, -2).flatten(start_dim=1, end_dim=2)\n            y_rec_embeddings = torch.stack(y_rec_embeddings, dim=1).transpose(-1, -2).flatten(start_dim=1, end_dim=2)\n\n        y_d_rs = self.wd(y_embeddings)\n        y_d_gs = self.wd(y_rec_embeddings)\n        \n        y_df_hat_r, y_df_hat_g = y_d_rs, y_d_gs\n        \n        r_loss = torch.mean((1-y_df_hat_r)**2)\n        g_loss = torch.mean((y_df_hat_g)**2)\n        \n        loss_disc_f = r_loss + g_loss\n                        \n        return loss_disc_f.mean()\n\n    def discriminator_forward(self, wav):\n        with torch.no_grad():\n            wav_16 = self.resample(wav)\n            wav_embeddings = self.wavlm(input_values=wav_16, output_hidden_states=True).hidden_states\n            y_embeddings = torch.stack(wav_embeddings, dim=1).transpose(-1, -2).flatten(start_dim=1, end_dim=2)\n\n        y_d_rs = self.wd(y_embeddings)\n        \n        return y_d_rs"
        },
        {
          "name": "meldataset.py",
          "type": "blob",
          "size": 8.267578125,
          "content": "#coding: utf-8\nimport os\nimport os.path as osp\nimport time\nimport random\nimport numpy as np\nimport random\nimport soundfile as sf\nimport librosa\n\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nimport torchaudio\nfrom torch.utils.data import DataLoader\n\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\nimport pandas as pd\n\n_pad = \"$\"\n_punctuation = ';:,.!?¡¿—…\"«»“” '\n_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n_letters_ipa = \"ɑɐɒæɓʙβɔɕçɗɖðʤəɘɚɛɜɝɞɟʄɡɠɢʛɦɧħɥʜɨɪʝɭɬɫɮʟɱɯɰŋɳɲɴøɵɸθœɶʘɹɺɾɻʀʁɽʂʃʈʧʉʊʋⱱʌɣɤʍχʎʏʑʐʒʔʡʕʢǀǁǂǃˈˌːˑʼʴʰʱʲʷˠˤ˞↓↑→↗↘'̩'ᵻ\"\n\n# Export all symbols:\nsymbols = [_pad] + list(_punctuation) + list(_letters) + list(_letters_ipa)\n\ndicts = {}\nfor i in range(len((symbols))):\n    dicts[symbols[i]] = i\n\nclass TextCleaner:\n    def __init__(self, dummy=None):\n        self.word_index_dictionary = dicts\n    def __call__(self, text):\n        indexes = []\n        for char in text:\n            try:\n                indexes.append(self.word_index_dictionary[char])\n            except KeyError:\n                print(text)\n        return indexes\n\nnp.random.seed(1)\nrandom.seed(1)\nSPECT_PARAMS = {\n    \"n_fft\": 2048,\n    \"win_length\": 1200,\n    \"hop_length\": 300\n}\nMEL_PARAMS = {\n    \"n_mels\": 80,\n}\n\nto_mel = torchaudio.transforms.MelSpectrogram(\n    n_mels=80, n_fft=2048, win_length=1200, hop_length=300)\nmean, std = -4, 4\n\ndef preprocess(wave):\n    wave_tensor = torch.from_numpy(wave).float()\n    mel_tensor = to_mel(wave_tensor)\n    mel_tensor = (torch.log(1e-5 + mel_tensor.unsqueeze(0)) - mean) / std\n    return mel_tensor\n\nclass FilePathDataset(torch.utils.data.Dataset):\n    def __init__(self,\n                 data_list,\n                 root_path,\n                 sr=24000,\n                 data_augmentation=False,\n                 validation=False,\n                 OOD_data=\"Data/OOD_texts.txt\",\n                 min_length=50,\n                 ):\n\n        spect_params = SPECT_PARAMS\n        mel_params = MEL_PARAMS\n\n        _data_list = [l.strip().split('|') for l in data_list]\n        self.data_list = [data if len(data) == 3 else (*data, 0) for data in _data_list]\n        self.text_cleaner = TextCleaner()\n        self.sr = sr\n\n        self.df = pd.DataFrame(self.data_list)\n\n        self.to_melspec = torchaudio.transforms.MelSpectrogram(**MEL_PARAMS)\n\n        self.mean, self.std = -4, 4\n        self.data_augmentation = data_augmentation and (not validation)\n        self.max_mel_length = 192\n        \n        self.min_length = min_length\n        with open(OOD_data, 'r', encoding='utf-8') as f:\n            tl = f.readlines()\n        idx = 1 if '.wav' in tl[0].split('|')[0] else 0\n        self.ptexts = [t.split('|')[idx] for t in tl]\n        \n        self.root_path = root_path\n\n    def __len__(self):\n        return len(self.data_list)\n\n    def __getitem__(self, idx):        \n        data = self.data_list[idx]\n        path = data[0]\n        \n        wave, text_tensor, speaker_id = self._load_tensor(data)\n        \n        mel_tensor = preprocess(wave).squeeze()\n        \n        acoustic_feature = mel_tensor.squeeze()\n        length_feature = acoustic_feature.size(1)\n        acoustic_feature = acoustic_feature[:, :(length_feature - length_feature % 2)]\n        \n        # get reference sample\n        ref_data = (self.df[self.df[2] == str(speaker_id)]).sample(n=1).iloc[0].tolist()\n        ref_mel_tensor, ref_label = self._load_data(ref_data[:3])\n        \n        # get OOD text\n        \n        ps = \"\"\n        \n        while len(ps) < self.min_length:\n            rand_idx = np.random.randint(0, len(self.ptexts) - 1)\n            ps = self.ptexts[rand_idx]\n            \n            text = self.text_cleaner(ps)\n            text.insert(0, 0)\n            text.append(0)\n\n            ref_text = torch.LongTensor(text)\n        \n        return speaker_id, acoustic_feature, text_tensor, ref_text, ref_mel_tensor, ref_label, path, wave\n\n    def _load_tensor(self, data):\n        wave_path, text, speaker_id = data\n        speaker_id = int(speaker_id)\n        wave, sr = sf.read(osp.join(self.root_path, wave_path))\n        if wave.shape[-1] == 2:\n            wave = wave[:, 0].squeeze()\n        if sr != 24000:\n            wave = librosa.resample(wave, orig_sr=sr, target_sr=24000)\n            print(wave_path, sr)\n            \n        wave = np.concatenate([np.zeros([5000]), wave, np.zeros([5000])], axis=0)\n        \n        text = self.text_cleaner(text)\n        \n        text.insert(0, 0)\n        text.append(0)\n        \n        text = torch.LongTensor(text)\n\n        return wave, text, speaker_id\n\n    def _load_data(self, data):\n        wave, text_tensor, speaker_id = self._load_tensor(data)\n        mel_tensor = preprocess(wave).squeeze()\n\n        mel_length = mel_tensor.size(1)\n        if mel_length > self.max_mel_length:\n            random_start = np.random.randint(0, mel_length - self.max_mel_length)\n            mel_tensor = mel_tensor[:, random_start:random_start + self.max_mel_length]\n\n        return mel_tensor, speaker_id\n\n\nclass Collater(object):\n    \"\"\"\n    Args:\n      adaptive_batch_size (bool): if true, decrease batch size when long data comes.\n    \"\"\"\n\n    def __init__(self, return_wave=False):\n        self.text_pad_index = 0\n        self.min_mel_length = 192\n        self.max_mel_length = 192\n        self.return_wave = return_wave\n        \n\n    def __call__(self, batch):\n        # batch[0] = wave, mel, text, f0, speakerid\n        batch_size = len(batch)\n\n        # sort by mel length\n        lengths = [b[1].shape[1] for b in batch]\n        batch_indexes = np.argsort(lengths)[::-1]\n        batch = [batch[bid] for bid in batch_indexes]\n\n        nmels = batch[0][1].size(0)\n        max_mel_length = max([b[1].shape[1] for b in batch])\n        max_text_length = max([b[2].shape[0] for b in batch])\n        max_rtext_length = max([b[3].shape[0] for b in batch])\n\n        labels = torch.zeros((batch_size)).long()\n        mels = torch.zeros((batch_size, nmels, max_mel_length)).float()\n        texts = torch.zeros((batch_size, max_text_length)).long()\n        ref_texts = torch.zeros((batch_size, max_rtext_length)).long()\n\n        input_lengths = torch.zeros(batch_size).long()\n        ref_lengths = torch.zeros(batch_size).long()\n        output_lengths = torch.zeros(batch_size).long()\n        ref_mels = torch.zeros((batch_size, nmels, self.max_mel_length)).float()\n        ref_labels = torch.zeros((batch_size)).long()\n        paths = ['' for _ in range(batch_size)]\n        waves = [None for _ in range(batch_size)]\n        \n        for bid, (label, mel, text, ref_text, ref_mel, ref_label, path, wave) in enumerate(batch):\n            mel_size = mel.size(1)\n            text_size = text.size(0)\n            rtext_size = ref_text.size(0)\n            labels[bid] = label\n            mels[bid, :, :mel_size] = mel\n            texts[bid, :text_size] = text\n            ref_texts[bid, :rtext_size] = ref_text\n            input_lengths[bid] = text_size\n            ref_lengths[bid] = rtext_size\n            output_lengths[bid] = mel_size\n            paths[bid] = path\n            ref_mel_size = ref_mel.size(1)\n            ref_mels[bid, :, :ref_mel_size] = ref_mel\n            \n            ref_labels[bid] = ref_label\n            waves[bid] = wave\n\n        return waves, texts, input_lengths, ref_texts, ref_lengths, mels, output_lengths, ref_mels\n\n\n\ndef build_dataloader(path_list,\n                     root_path,\n                     validation=False,\n                     OOD_data=\"Data/OOD_texts.txt\",\n                     min_length=50,\n                     batch_size=4,\n                     num_workers=1,\n                     device='cpu',\n                     collate_config={},\n                     dataset_config={}):\n    \n    dataset = FilePathDataset(path_list, root_path, OOD_data=OOD_data, min_length=min_length, validation=validation, **dataset_config)\n    collate_fn = Collater(**collate_config)\n    data_loader = DataLoader(dataset,\n                             batch_size=batch_size,\n                             shuffle=(not validation),\n                             num_workers=num_workers,\n                             drop_last=(not validation),\n                             collate_fn=collate_fn,\n                             pin_memory=(device != 'cpu'))\n\n    return data_loader\n\n"
        },
        {
          "name": "models.py",
          "type": "blob",
          "size": 25.50390625,
          "content": "#coding:utf-8\n\nimport os\nimport os.path as osp\n\nimport copy\nimport math\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.nn.utils import weight_norm, remove_weight_norm, spectral_norm\n\nfrom Utils.ASR.models import ASRCNN\nfrom Utils.JDC.model import JDCNet\n\nfrom Modules.diffusion.sampler import KDiffusion, LogNormalDistribution\nfrom Modules.diffusion.modules import Transformer1d, StyleTransformer1d\nfrom Modules.diffusion.diffusion import AudioDiffusionConditional\n\nfrom Modules.discriminators import MultiPeriodDiscriminator, MultiResSpecDiscriminator, WavLMDiscriminator\n\nfrom munch import Munch\nimport yaml\n\nclass LearnedDownSample(nn.Module):\n    def __init__(self, layer_type, dim_in):\n        super().__init__()\n        self.layer_type = layer_type\n\n        if self.layer_type == 'none':\n            self.conv = nn.Identity()\n        elif self.layer_type == 'timepreserve':\n            self.conv = spectral_norm(nn.Conv2d(dim_in, dim_in, kernel_size=(3, 1), stride=(2, 1), groups=dim_in, padding=(1, 0)))\n        elif self.layer_type == 'half':\n            self.conv = spectral_norm(nn.Conv2d(dim_in, dim_in, kernel_size=(3, 3), stride=(2, 2), groups=dim_in, padding=1))\n        else:\n            raise RuntimeError('Got unexpected donwsampletype %s, expected is [none, timepreserve, half]' % self.layer_type)\n            \n    def forward(self, x):\n        return self.conv(x)\n\nclass LearnedUpSample(nn.Module):\n    def __init__(self, layer_type, dim_in):\n        super().__init__()\n        self.layer_type = layer_type\n        \n        if self.layer_type == 'none':\n            self.conv = nn.Identity()\n        elif self.layer_type == 'timepreserve':\n            self.conv = nn.ConvTranspose2d(dim_in, dim_in, kernel_size=(3, 1), stride=(2, 1), groups=dim_in, output_padding=(1, 0), padding=(1, 0))\n        elif self.layer_type == 'half':\n            self.conv = nn.ConvTranspose2d(dim_in, dim_in, kernel_size=(3, 3), stride=(2, 2), groups=dim_in, output_padding=1, padding=1)\n        else:\n            raise RuntimeError('Got unexpected upsampletype %s, expected is [none, timepreserve, half]' % self.layer_type)\n\n\n    def forward(self, x):\n        return self.conv(x)\n\nclass DownSample(nn.Module):\n    def __init__(self, layer_type):\n        super().__init__()\n        self.layer_type = layer_type\n\n    def forward(self, x):\n        if self.layer_type == 'none':\n            return x\n        elif self.layer_type == 'timepreserve':\n            return F.avg_pool2d(x, (2, 1))\n        elif self.layer_type == 'half':\n            if x.shape[-1] % 2 != 0:\n                x = torch.cat([x, x[..., -1].unsqueeze(-1)], dim=-1)\n            return F.avg_pool2d(x, 2)\n        else:\n            raise RuntimeError('Got unexpected donwsampletype %s, expected is [none, timepreserve, half]' % self.layer_type)\n\n\nclass UpSample(nn.Module):\n    def __init__(self, layer_type):\n        super().__init__()\n        self.layer_type = layer_type\n\n    def forward(self, x):\n        if self.layer_type == 'none':\n            return x\n        elif self.layer_type == 'timepreserve':\n            return F.interpolate(x, scale_factor=(2, 1), mode='nearest')\n        elif self.layer_type == 'half':\n            return F.interpolate(x, scale_factor=2, mode='nearest')\n        else:\n            raise RuntimeError('Got unexpected upsampletype %s, expected is [none, timepreserve, half]' % self.layer_type)\n\n\nclass ResBlk(nn.Module):\n    def __init__(self, dim_in, dim_out, actv=nn.LeakyReLU(0.2),\n                 normalize=False, downsample='none'):\n        super().__init__()\n        self.actv = actv\n        self.normalize = normalize\n        self.downsample = DownSample(downsample)\n        self.downsample_res = LearnedDownSample(downsample, dim_in)\n        self.learned_sc = dim_in != dim_out\n        self._build_weights(dim_in, dim_out)\n\n    def _build_weights(self, dim_in, dim_out):\n        self.conv1 = spectral_norm(nn.Conv2d(dim_in, dim_in, 3, 1, 1))\n        self.conv2 = spectral_norm(nn.Conv2d(dim_in, dim_out, 3, 1, 1))\n        if self.normalize:\n            self.norm1 = nn.InstanceNorm2d(dim_in, affine=True)\n            self.norm2 = nn.InstanceNorm2d(dim_in, affine=True)\n        if self.learned_sc:\n            self.conv1x1 = spectral_norm(nn.Conv2d(dim_in, dim_out, 1, 1, 0, bias=False))\n\n    def _shortcut(self, x):\n        if self.learned_sc:\n            x = self.conv1x1(x)\n        if self.downsample:\n            x = self.downsample(x)\n        return x\n\n    def _residual(self, x):\n        if self.normalize:\n            x = self.norm1(x)\n        x = self.actv(x)\n        x = self.conv1(x)\n        x = self.downsample_res(x)\n        if self.normalize:\n            x = self.norm2(x)\n        x = self.actv(x)\n        x = self.conv2(x)\n        return x\n\n    def forward(self, x):\n        x = self._shortcut(x) + self._residual(x)\n        return x / math.sqrt(2)  # unit variance\n\nclass StyleEncoder(nn.Module):\n    def __init__(self, dim_in=48, style_dim=48, max_conv_dim=384):\n        super().__init__()\n        blocks = []\n        blocks += [spectral_norm(nn.Conv2d(1, dim_in, 3, 1, 1))]\n\n        repeat_num = 4\n        for _ in range(repeat_num):\n            dim_out = min(dim_in*2, max_conv_dim)\n            blocks += [ResBlk(dim_in, dim_out, downsample='half')]\n            dim_in = dim_out\n\n        blocks += [nn.LeakyReLU(0.2)]\n        blocks += [spectral_norm(nn.Conv2d(dim_out, dim_out, 5, 1, 0))]\n        blocks += [nn.AdaptiveAvgPool2d(1)]\n        blocks += [nn.LeakyReLU(0.2)]\n        self.shared = nn.Sequential(*blocks)\n\n        self.unshared = nn.Linear(dim_out, style_dim)\n\n    def forward(self, x):\n        h = self.shared(x)\n        h = h.view(h.size(0), -1)\n        s = self.unshared(h)\n    \n        return s\n\nclass LinearNorm(torch.nn.Module):\n    def __init__(self, in_dim, out_dim, bias=True, w_init_gain='linear'):\n        super(LinearNorm, self).__init__()\n        self.linear_layer = torch.nn.Linear(in_dim, out_dim, bias=bias)\n\n        torch.nn.init.xavier_uniform_(\n            self.linear_layer.weight,\n            gain=torch.nn.init.calculate_gain(w_init_gain))\n\n    def forward(self, x):\n        return self.linear_layer(x)\n\nclass Discriminator2d(nn.Module):\n    def __init__(self, dim_in=48, num_domains=1, max_conv_dim=384, repeat_num=4):\n        super().__init__()\n        blocks = []\n        blocks += [spectral_norm(nn.Conv2d(1, dim_in, 3, 1, 1))]\n\n        for lid in range(repeat_num):\n            dim_out = min(dim_in*2, max_conv_dim)\n            blocks += [ResBlk(dim_in, dim_out, downsample='half')]\n            dim_in = dim_out\n\n        blocks += [nn.LeakyReLU(0.2)]\n        blocks += [spectral_norm(nn.Conv2d(dim_out, dim_out, 5, 1, 0))]\n        blocks += [nn.LeakyReLU(0.2)]\n        blocks += [nn.AdaptiveAvgPool2d(1)]\n        blocks += [spectral_norm(nn.Conv2d(dim_out, num_domains, 1, 1, 0))]\n        self.main = nn.Sequential(*blocks)\n\n    def get_feature(self, x):\n        features = []\n        for l in self.main:\n            x = l(x)\n            features.append(x) \n        out = features[-1]\n        out = out.view(out.size(0), -1)  # (batch, num_domains)\n        return out, features\n\n    def forward(self, x):\n        out, features = self.get_feature(x)\n        out = out.squeeze()  # (batch)\n        return out, features\n\nclass ResBlk1d(nn.Module):\n    def __init__(self, dim_in, dim_out, actv=nn.LeakyReLU(0.2),\n                 normalize=False, downsample='none', dropout_p=0.2):\n        super().__init__()\n        self.actv = actv\n        self.normalize = normalize\n        self.downsample_type = downsample\n        self.learned_sc = dim_in != dim_out\n        self._build_weights(dim_in, dim_out)\n        self.dropout_p = dropout_p\n        \n        if self.downsample_type == 'none':\n            self.pool = nn.Identity()\n        else:\n            self.pool = weight_norm(nn.Conv1d(dim_in, dim_in, kernel_size=3, stride=2, groups=dim_in, padding=1))\n\n    def _build_weights(self, dim_in, dim_out):\n        self.conv1 = weight_norm(nn.Conv1d(dim_in, dim_in, 3, 1, 1))\n        self.conv2 = weight_norm(nn.Conv1d(dim_in, dim_out, 3, 1, 1))\n        if self.normalize:\n            self.norm1 = nn.InstanceNorm1d(dim_in, affine=True)\n            self.norm2 = nn.InstanceNorm1d(dim_in, affine=True)\n        if self.learned_sc:\n            self.conv1x1 = weight_norm(nn.Conv1d(dim_in, dim_out, 1, 1, 0, bias=False))\n\n    def downsample(self, x):\n        if self.downsample_type == 'none':\n            return x\n        else:\n            if x.shape[-1] % 2 != 0:\n                x = torch.cat([x, x[..., -1].unsqueeze(-1)], dim=-1)\n            return F.avg_pool1d(x, 2)\n\n    def _shortcut(self, x):\n        if self.learned_sc:\n            x = self.conv1x1(x)\n        x = self.downsample(x)\n        return x\n\n    def _residual(self, x):\n        if self.normalize:\n            x = self.norm1(x)\n        x = self.actv(x)\n        x = F.dropout(x, p=self.dropout_p, training=self.training)\n        \n        x = self.conv1(x)\n        x = self.pool(x)\n        if self.normalize:\n            x = self.norm2(x)\n            \n        x = self.actv(x)\n        x = F.dropout(x, p=self.dropout_p, training=self.training)\n        \n        x = self.conv2(x)\n        return x\n\n    def forward(self, x):\n        x = self._shortcut(x) + self._residual(x)\n        return x / math.sqrt(2)  # unit variance\n\nclass LayerNorm(nn.Module):\n    def __init__(self, channels, eps=1e-5):\n        super().__init__()\n        self.channels = channels\n        self.eps = eps\n\n        self.gamma = nn.Parameter(torch.ones(channels))\n        self.beta = nn.Parameter(torch.zeros(channels))\n\n    def forward(self, x):\n        x = x.transpose(1, -1)\n        x = F.layer_norm(x, (self.channels,), self.gamma, self.beta, self.eps)\n        return x.transpose(1, -1)\n    \nclass TextEncoder(nn.Module):\n    def __init__(self, channels, kernel_size, depth, n_symbols, actv=nn.LeakyReLU(0.2)):\n        super().__init__()\n        self.embedding = nn.Embedding(n_symbols, channels)\n\n        padding = (kernel_size - 1) // 2\n        self.cnn = nn.ModuleList()\n        for _ in range(depth):\n            self.cnn.append(nn.Sequential(\n                weight_norm(nn.Conv1d(channels, channels, kernel_size=kernel_size, padding=padding)),\n                LayerNorm(channels),\n                actv,\n                nn.Dropout(0.2),\n            ))\n        # self.cnn = nn.Sequential(*self.cnn)\n\n        self.lstm = nn.LSTM(channels, channels//2, 1, batch_first=True, bidirectional=True)\n\n    def forward(self, x, input_lengths, m):\n        x = self.embedding(x)  # [B, T, emb]\n        x = x.transpose(1, 2)  # [B, emb, T]\n        m = m.to(input_lengths.device).unsqueeze(1)\n        x.masked_fill_(m, 0.0)\n        \n        for c in self.cnn:\n            x = c(x)\n            x.masked_fill_(m, 0.0)\n            \n        x = x.transpose(1, 2)  # [B, T, chn]\n\n        input_lengths = input_lengths.cpu().numpy()\n        x = nn.utils.rnn.pack_padded_sequence(\n            x, input_lengths, batch_first=True, enforce_sorted=False)\n\n        self.lstm.flatten_parameters()\n        x, _ = self.lstm(x)\n        x, _ = nn.utils.rnn.pad_packed_sequence(\n            x, batch_first=True)\n                \n        x = x.transpose(-1, -2)\n        x_pad = torch.zeros([x.shape[0], x.shape[1], m.shape[-1]])\n\n        x_pad[:, :, :x.shape[-1]] = x\n        x = x_pad.to(x.device)\n        \n        x.masked_fill_(m, 0.0)\n        \n        return x\n\n    def inference(self, x):\n        x = self.embedding(x)\n        x = x.transpose(1, 2)\n        x = self.cnn(x)\n        x = x.transpose(1, 2)\n        self.lstm.flatten_parameters()\n        x, _ = self.lstm(x)\n        return x\n    \n    def length_to_mask(self, lengths):\n        mask = torch.arange(lengths.max()).unsqueeze(0).expand(lengths.shape[0], -1).type_as(lengths)\n        mask = torch.gt(mask+1, lengths.unsqueeze(1))\n        return mask\n\n\n\nclass AdaIN1d(nn.Module):\n    def __init__(self, style_dim, num_features):\n        super().__init__()\n        self.norm = nn.InstanceNorm1d(num_features, affine=False)\n        self.fc = nn.Linear(style_dim, num_features*2)\n\n    def forward(self, x, s):\n        h = self.fc(s)\n        h = h.view(h.size(0), h.size(1), 1)\n        gamma, beta = torch.chunk(h, chunks=2, dim=1)\n        return (1 + gamma) * self.norm(x) + beta\n\nclass UpSample1d(nn.Module):\n    def __init__(self, layer_type):\n        super().__init__()\n        self.layer_type = layer_type\n\n    def forward(self, x):\n        if self.layer_type == 'none':\n            return x\n        else:\n            return F.interpolate(x, scale_factor=2, mode='nearest')\n\nclass AdainResBlk1d(nn.Module):\n    def __init__(self, dim_in, dim_out, style_dim=64, actv=nn.LeakyReLU(0.2),\n                 upsample='none', dropout_p=0.0):\n        super().__init__()\n        self.actv = actv\n        self.upsample_type = upsample\n        self.upsample = UpSample1d(upsample)\n        self.learned_sc = dim_in != dim_out\n        self._build_weights(dim_in, dim_out, style_dim)\n        self.dropout = nn.Dropout(dropout_p)\n        \n        if upsample == 'none':\n            self.pool = nn.Identity()\n        else:\n            self.pool = weight_norm(nn.ConvTranspose1d(dim_in, dim_in, kernel_size=3, stride=2, groups=dim_in, padding=1, output_padding=1))\n        \n        \n    def _build_weights(self, dim_in, dim_out, style_dim):\n        self.conv1 = weight_norm(nn.Conv1d(dim_in, dim_out, 3, 1, 1))\n        self.conv2 = weight_norm(nn.Conv1d(dim_out, dim_out, 3, 1, 1))\n        self.norm1 = AdaIN1d(style_dim, dim_in)\n        self.norm2 = AdaIN1d(style_dim, dim_out)\n        if self.learned_sc:\n            self.conv1x1 = weight_norm(nn.Conv1d(dim_in, dim_out, 1, 1, 0, bias=False))\n\n    def _shortcut(self, x):\n        x = self.upsample(x)\n        if self.learned_sc:\n            x = self.conv1x1(x)\n        return x\n\n    def _residual(self, x, s):\n        x = self.norm1(x, s)\n        x = self.actv(x)\n        x = self.pool(x)\n        x = self.conv1(self.dropout(x))\n        x = self.norm2(x, s)\n        x = self.actv(x)\n        x = self.conv2(self.dropout(x))\n        return x\n\n    def forward(self, x, s):\n        out = self._residual(x, s)\n        out = (out + self._shortcut(x)) / math.sqrt(2)\n        return out\n    \nclass AdaLayerNorm(nn.Module):\n    def __init__(self, style_dim, channels, eps=1e-5):\n        super().__init__()\n        self.channels = channels\n        self.eps = eps\n\n        self.fc = nn.Linear(style_dim, channels*2)\n\n    def forward(self, x, s):\n        x = x.transpose(-1, -2)\n        x = x.transpose(1, -1)\n                \n        h = self.fc(s)\n        h = h.view(h.size(0), h.size(1), 1)\n        gamma, beta = torch.chunk(h, chunks=2, dim=1)\n        gamma, beta = gamma.transpose(1, -1), beta.transpose(1, -1)\n        \n        \n        x = F.layer_norm(x, (self.channels,), eps=self.eps)\n        x = (1 + gamma) * x + beta\n        return x.transpose(1, -1).transpose(-1, -2)\n\nclass ProsodyPredictor(nn.Module):\n\n    def __init__(self, style_dim, d_hid, nlayers, max_dur=50, dropout=0.1):\n        super().__init__() \n        \n        self.text_encoder = DurationEncoder(sty_dim=style_dim, \n                                            d_model=d_hid,\n                                            nlayers=nlayers, \n                                            dropout=dropout)\n\n        self.lstm = nn.LSTM(d_hid + style_dim, d_hid // 2, 1, batch_first=True, bidirectional=True)\n        self.duration_proj = LinearNorm(d_hid, max_dur)\n        \n        self.shared = nn.LSTM(d_hid + style_dim, d_hid // 2, 1, batch_first=True, bidirectional=True)\n        self.F0 = nn.ModuleList()\n        self.F0.append(AdainResBlk1d(d_hid, d_hid, style_dim, dropout_p=dropout))\n        self.F0.append(AdainResBlk1d(d_hid, d_hid // 2, style_dim, upsample=True, dropout_p=dropout))\n        self.F0.append(AdainResBlk1d(d_hid // 2, d_hid // 2, style_dim, dropout_p=dropout))\n\n        self.N = nn.ModuleList()\n        self.N.append(AdainResBlk1d(d_hid, d_hid, style_dim, dropout_p=dropout))\n        self.N.append(AdainResBlk1d(d_hid, d_hid // 2, style_dim, upsample=True, dropout_p=dropout))\n        self.N.append(AdainResBlk1d(d_hid // 2, d_hid // 2, style_dim, dropout_p=dropout))\n        \n        self.F0_proj = nn.Conv1d(d_hid // 2, 1, 1, 1, 0)\n        self.N_proj = nn.Conv1d(d_hid // 2, 1, 1, 1, 0)\n\n\n    def forward(self, texts, style, text_lengths, alignment, m):\n        d = self.text_encoder(texts, style, text_lengths, m)\n        \n        batch_size = d.shape[0]\n        text_size = d.shape[1]\n        \n        # predict duration\n        input_lengths = text_lengths.cpu().numpy()\n        x = nn.utils.rnn.pack_padded_sequence(\n            d, input_lengths, batch_first=True, enforce_sorted=False)\n        \n        m = m.to(text_lengths.device).unsqueeze(1)\n        \n        self.lstm.flatten_parameters()\n        x, _ = self.lstm(x)\n        x, _ = nn.utils.rnn.pad_packed_sequence(\n            x, batch_first=True)\n        \n        x_pad = torch.zeros([x.shape[0], m.shape[-1], x.shape[-1]])\n\n        x_pad[:, :x.shape[1], :] = x\n        x = x_pad.to(x.device)\n                \n        duration = self.duration_proj(nn.functional.dropout(x, 0.5, training=self.training))\n        \n        en = (d.transpose(-1, -2) @ alignment)\n\n        return duration.squeeze(-1), en\n    \n    def F0Ntrain(self, x, s):\n        x, _ = self.shared(x.transpose(-1, -2))\n        \n        F0 = x.transpose(-1, -2)\n        for block in self.F0:\n            F0 = block(F0, s)\n        F0 = self.F0_proj(F0)\n\n        N = x.transpose(-1, -2)\n        for block in self.N:\n            N = block(N, s)\n        N = self.N_proj(N)\n        \n        return F0.squeeze(1), N.squeeze(1)\n    \n    def length_to_mask(self, lengths):\n        mask = torch.arange(lengths.max()).unsqueeze(0).expand(lengths.shape[0], -1).type_as(lengths)\n        mask = torch.gt(mask+1, lengths.unsqueeze(1))\n        return mask\n    \nclass DurationEncoder(nn.Module):\n\n    def __init__(self, sty_dim, d_model, nlayers, dropout=0.1):\n        super().__init__()\n        self.lstms = nn.ModuleList()\n        for _ in range(nlayers):\n            self.lstms.append(nn.LSTM(d_model + sty_dim, \n                                 d_model // 2, \n                                 num_layers=1, \n                                 batch_first=True, \n                                 bidirectional=True, \n                                 dropout=dropout))\n            self.lstms.append(AdaLayerNorm(sty_dim, d_model))\n        \n        \n        self.dropout = dropout\n        self.d_model = d_model\n        self.sty_dim = sty_dim\n\n    def forward(self, x, style, text_lengths, m):\n        masks = m.to(text_lengths.device)\n        \n        x = x.permute(2, 0, 1)\n        s = style.expand(x.shape[0], x.shape[1], -1)\n        x = torch.cat([x, s], axis=-1)\n        x.masked_fill_(masks.unsqueeze(-1).transpose(0, 1), 0.0)\n                \n        x = x.transpose(0, 1)\n        input_lengths = text_lengths.cpu().numpy()\n        x = x.transpose(-1, -2)\n        \n        for block in self.lstms:\n            if isinstance(block, AdaLayerNorm):\n                x = block(x.transpose(-1, -2), style).transpose(-1, -2)\n                x = torch.cat([x, s.permute(1, -1, 0)], axis=1)\n                x.masked_fill_(masks.unsqueeze(-1).transpose(-1, -2), 0.0)\n            else:\n                x = x.transpose(-1, -2)\n                x = nn.utils.rnn.pack_padded_sequence(\n                    x, input_lengths, batch_first=True, enforce_sorted=False)\n                block.flatten_parameters()\n                x, _ = block(x)\n                x, _ = nn.utils.rnn.pad_packed_sequence(\n                    x, batch_first=True)\n                x = F.dropout(x, p=self.dropout, training=self.training)\n                x = x.transpose(-1, -2)\n                \n                x_pad = torch.zeros([x.shape[0], x.shape[1], m.shape[-1]])\n\n                x_pad[:, :, :x.shape[-1]] = x\n                x = x_pad.to(x.device)\n        \n        return x.transpose(-1, -2)\n    \n    def inference(self, x, style):\n        x = self.embedding(x.transpose(-1, -2)) * math.sqrt(self.d_model)\n        style = style.expand(x.shape[0], x.shape[1], -1)\n        x = torch.cat([x, style], axis=-1)\n        src = self.pos_encoder(x)\n        output = self.transformer_encoder(src).transpose(0, 1)\n        return output\n    \n    def length_to_mask(self, lengths):\n        mask = torch.arange(lengths.max()).unsqueeze(0).expand(lengths.shape[0], -1).type_as(lengths)\n        mask = torch.gt(mask+1, lengths.unsqueeze(1))\n        return mask\n    \ndef load_F0_models(path):\n    # load F0 model\n\n    F0_model = JDCNet(num_class=1, seq_len=192)\n    params = torch.load(path, map_location='cpu')['net']\n    F0_model.load_state_dict(params)\n    _ = F0_model.train()\n    \n    return F0_model\n\ndef load_ASR_models(ASR_MODEL_PATH, ASR_MODEL_CONFIG):\n    # load ASR model\n    def _load_config(path):\n        with open(path) as f:\n            config = yaml.safe_load(f)\n        model_config = config['model_params']\n        return model_config\n\n    def _load_model(model_config, model_path):\n        model = ASRCNN(**model_config)\n        params = torch.load(model_path, map_location='cpu')['model']\n        model.load_state_dict(params)\n        return model\n\n    asr_model_config = _load_config(ASR_MODEL_CONFIG)\n    asr_model = _load_model(asr_model_config, ASR_MODEL_PATH)\n    _ = asr_model.train()\n\n    return asr_model\n\ndef build_model(args, text_aligner, pitch_extractor, bert):\n    assert args.decoder.type in ['istftnet', 'hifigan'], 'Decoder type unknown'\n    \n    if args.decoder.type == \"istftnet\":\n        from Modules.istftnet import Decoder\n        decoder = Decoder(dim_in=args.hidden_dim, style_dim=args.style_dim, dim_out=args.n_mels,\n                resblock_kernel_sizes = args.decoder.resblock_kernel_sizes,\n                upsample_rates = args.decoder.upsample_rates,\n                upsample_initial_channel=args.decoder.upsample_initial_channel,\n                resblock_dilation_sizes=args.decoder.resblock_dilation_sizes,\n                upsample_kernel_sizes=args.decoder.upsample_kernel_sizes, \n                gen_istft_n_fft=args.decoder.gen_istft_n_fft, gen_istft_hop_size=args.decoder.gen_istft_hop_size) \n    else:\n        from Modules.hifigan import Decoder\n        decoder = Decoder(dim_in=args.hidden_dim, style_dim=args.style_dim, dim_out=args.n_mels,\n                resblock_kernel_sizes = args.decoder.resblock_kernel_sizes,\n                upsample_rates = args.decoder.upsample_rates,\n                upsample_initial_channel=args.decoder.upsample_initial_channel,\n                resblock_dilation_sizes=args.decoder.resblock_dilation_sizes,\n                upsample_kernel_sizes=args.decoder.upsample_kernel_sizes) \n        \n    text_encoder = TextEncoder(channels=args.hidden_dim, kernel_size=5, depth=args.n_layer, n_symbols=args.n_token)\n    \n    predictor = ProsodyPredictor(style_dim=args.style_dim, d_hid=args.hidden_dim, nlayers=args.n_layer, max_dur=args.max_dur, dropout=args.dropout)\n    \n    style_encoder = StyleEncoder(dim_in=args.dim_in, style_dim=args.style_dim, max_conv_dim=args.hidden_dim) # acoustic style encoder\n    predictor_encoder = StyleEncoder(dim_in=args.dim_in, style_dim=args.style_dim, max_conv_dim=args.hidden_dim) # prosodic style encoder\n        \n    # define diffusion model\n    if args.multispeaker:\n        transformer = StyleTransformer1d(channels=args.style_dim*2, \n                                    context_embedding_features=bert.config.hidden_size,\n                                    context_features=args.style_dim*2, \n                                    **args.diffusion.transformer)\n    else:\n        transformer = Transformer1d(channels=args.style_dim*2, \n                                    context_embedding_features=bert.config.hidden_size,\n                                    **args.diffusion.transformer)\n    \n    diffusion = AudioDiffusionConditional(\n        in_channels=1,\n        embedding_max_length=bert.config.max_position_embeddings,\n        embedding_features=bert.config.hidden_size,\n        embedding_mask_proba=args.diffusion.embedding_mask_proba, # Conditional dropout of batch elements,\n        channels=args.style_dim*2,\n        context_features=args.style_dim*2,\n    )\n    \n    diffusion.diffusion = KDiffusion(\n        net=diffusion.unet,\n        sigma_distribution=LogNormalDistribution(mean = args.diffusion.dist.mean, std = args.diffusion.dist.std),\n        sigma_data=args.diffusion.dist.sigma_data, # a placeholder, will be changed dynamically when start training diffusion model\n        dynamic_threshold=0.0 \n    )\n    diffusion.diffusion.net = transformer\n    diffusion.unet = transformer\n\n    \n    nets = Munch(\n            bert=bert,\n            bert_encoder=nn.Linear(bert.config.hidden_size, args.hidden_dim),\n\n            predictor=predictor,\n            decoder=decoder,\n            text_encoder=text_encoder,\n\n            predictor_encoder=predictor_encoder,\n            style_encoder=style_encoder,\n            diffusion=diffusion,\n\n            text_aligner = text_aligner,\n            pitch_extractor=pitch_extractor,\n\n            mpd = MultiPeriodDiscriminator(),\n            msd = MultiResSpecDiscriminator(),\n        \n            # slm discriminator head\n            wd = WavLMDiscriminator(args.slm.hidden, args.slm.nlayers, args.slm.initial_channel),\n       )\n    \n    return nets\n\ndef load_checkpoint(model, optimizer, path, load_only_params=True, ignore_modules=[]):\n    state = torch.load(path, map_location='cpu')\n    params = state['net']\n    for key in model:\n        if key in params and key not in ignore_modules:\n            print('%s loaded' % key)\n            model[key].load_state_dict(params[key], strict=False)\n    _ = [model[key].eval() for key in model]\n    \n    if not load_only_params:\n        epoch = state[\"epoch\"]\n        iters = state[\"iters\"]\n        optimizer.load_state_dict(state[\"optimizer\"])\n    else:\n        epoch = 0\n        iters = 0\n        \n    return model, optimizer, epoch, iters\n"
        },
        {
          "name": "optimizers.py",
          "type": "blob",
          "size": 2.38671875,
          "content": "#coding:utf-8\nimport os, sys\nimport os.path as osp\nimport numpy as np\nimport torch\nfrom torch import nn\nfrom torch.optim import Optimizer\nfrom functools import reduce\nfrom torch.optim import AdamW\n\nclass MultiOptimizer:\n    def __init__(self, optimizers={}, schedulers={}):\n        self.optimizers = optimizers\n        self.schedulers = schedulers\n        self.keys = list(optimizers.keys())\n        self.param_groups = reduce(lambda x,y: x+y, [v.param_groups for v in self.optimizers.values()])\n\n    def state_dict(self):\n        state_dicts = [(key, self.optimizers[key].state_dict())\\\n                       for key in self.keys]\n        return state_dicts\n\n    def load_state_dict(self, state_dict):\n        for key, val in state_dict:\n            try:\n                self.optimizers[key].load_state_dict(val)\n            except:\n                print(\"Unloaded %s\" % key)\n\n    def step(self, key=None, scaler=None):\n        keys = [key] if key is not None else self.keys\n        _ = [self._step(key, scaler) for key in keys]\n\n    def _step(self, key, scaler=None):\n        if scaler is not None:\n            scaler.step(self.optimizers[key])\n            scaler.update()\n        else:\n            self.optimizers[key].step()\n\n    def zero_grad(self, key=None):\n        if key is not None:\n            self.optimizers[key].zero_grad()\n        else:\n            _ = [self.optimizers[key].zero_grad() for key in self.keys]\n\n    def scheduler(self, *args, key=None):\n        if key is not None:\n            self.schedulers[key].step(*args)\n        else:\n            _ = [self.schedulers[key].step(*args) for key in self.keys]\n\ndef define_scheduler(optimizer, params):\n    scheduler = torch.optim.lr_scheduler.OneCycleLR(\n        optimizer,\n        max_lr=params.get('max_lr', 2e-4),\n        epochs=params.get('epochs', 200),\n        steps_per_epoch=params.get('steps_per_epoch', 1000),\n        pct_start=params.get('pct_start', 0.0),\n        div_factor=1,\n        final_div_factor=1)\n\n    return scheduler\n\ndef build_optimizer(parameters_dict, scheduler_params_dict, lr):\n    optim = dict([(key, AdamW(params, lr=lr, weight_decay=1e-4, betas=(0.0, 0.99), eps=1e-9))\n                   for key, params in parameters_dict.items()])\n\n    schedulers = dict([(key, define_scheduler(opt, scheduler_params_dict[key])) \\\n                       for key, opt in optim.items()])\n\n    multi_optim = MultiOptimizer(optim, schedulers)\n    return multi_optim"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.2080078125,
          "content": "SoundFile\r\ntorchaudio\r\nmunch\r\ntorch\r\npydub\r\npyyaml\r\nlibrosa\r\nnltk\r\nmatplotlib\r\naccelerate\r\ntransformers\r\neinops\r\neinops-exts\r\ntqdm\r\ntyping\r\ntyping-extensions\r\ngit+https://github.com/resemble-ai/monotonic_align.git"
        },
        {
          "name": "text_utils.py",
          "type": "blob",
          "size": 0.9326171875,
          "content": "# IPA Phonemizer: https://github.com/bootphon/phonemizer\n\n_pad = \"$\"\n_punctuation = ';:,.!?¡¿—…\"«»“” '\n_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n_letters_ipa = \"ɑɐɒæɓʙβɔɕçɗɖðʤəɘɚɛɜɝɞɟʄɡɠɢʛɦɧħɥʜɨɪʝɭɬɫɮʟɱɯɰŋɳɲɴøɵɸθœɶʘɹɺɾɻʀʁɽʂʃʈʧʉʊʋⱱʌɣɤʍχʎʏʑʐʒʔʡʕʢǀǁǂǃˈˌːˑʼʴʰʱʲʷˠˤ˞↓↑→↗↘'̩'ᵻ\"\n\n# Export all symbols:\nsymbols = [_pad] + list(_punctuation) + list(_letters) + list(_letters_ipa)\n\ndicts = {}\nfor i in range(len((symbols))):\n    dicts[symbols[i]] = i\n\nclass TextCleaner:\n    def __init__(self, dummy=None):\n        self.word_index_dictionary = dicts\n        print(len(dicts))\n    def __call__(self, text):\n        indexes = []\n        for char in text:\n            try:\n                indexes.append(self.word_index_dictionary[char])\n            except KeyError:\n                print(text)\n        return indexes\n"
        },
        {
          "name": "train_finetune.py",
          "type": "blob",
          "size": 29.275390625,
          "content": "# load packages\nimport random\nimport yaml\nimport time\nfrom munch import Munch\nimport numpy as np\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nimport torchaudio\nimport librosa\nimport click\nimport shutil\nimport warnings\nwarnings.simplefilter('ignore')\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom meldataset import build_dataloader\n\nfrom Utils.ASR.models import ASRCNN\nfrom Utils.JDC.model import JDCNet\nfrom Utils.PLBERT.util import load_plbert\n\nfrom models import *\nfrom losses import *\nfrom utils import *\n\nfrom Modules.slmadv import SLMAdversarialLoss\nfrom Modules.diffusion.sampler import DiffusionSampler, ADPM2Sampler, KarrasSchedule\n\nfrom optimizers import build_optimizer\n\n# simple fix for dataparallel that allows access to class attributes\nclass MyDataParallel(torch.nn.DataParallel):\n    def __getattr__(self, name):\n        try:\n            return super().__getattr__(name)\n        except AttributeError:\n            return getattr(self.module, name)\n        \nimport logging\nfrom logging import StreamHandler\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nhandler = StreamHandler()\nhandler.setLevel(logging.DEBUG)\nlogger.addHandler(handler)\n\n\n@click.command()\n@click.option('-p', '--config_path', default='Configs/config_ft.yml', type=str)\ndef main(config_path):\n    config = yaml.safe_load(open(config_path))\n    \n    log_dir = config['log_dir']\n    if not osp.exists(log_dir): os.makedirs(log_dir, exist_ok=True)\n    shutil.copy(config_path, osp.join(log_dir, osp.basename(config_path)))\n    writer = SummaryWriter(log_dir + \"/tensorboard\")\n\n    # write logs\n    file_handler = logging.FileHandler(osp.join(log_dir, 'train.log'))\n    file_handler.setLevel(logging.DEBUG)\n    file_handler.setFormatter(logging.Formatter('%(levelname)s:%(asctime)s: %(message)s'))\n    logger.addHandler(file_handler)\n\n    \n    batch_size = config.get('batch_size', 10)\n\n    epochs = config.get('epochs', 200)\n    save_freq = config.get('save_freq', 2)\n    log_interval = config.get('log_interval', 10)\n    saving_epoch = config.get('save_freq', 2)\n\n    data_params = config.get('data_params', None)\n    sr = config['preprocess_params'].get('sr', 24000)\n    train_path = data_params['train_data']\n    val_path = data_params['val_data']\n    root_path = data_params['root_path']\n    min_length = data_params['min_length']\n    OOD_data = data_params['OOD_data']\n\n    max_len = config.get('max_len', 200)\n    \n    loss_params = Munch(config['loss_params'])\n    diff_epoch = loss_params.diff_epoch\n    joint_epoch = loss_params.joint_epoch\n    \n    optimizer_params = Munch(config['optimizer_params'])\n    \n    train_list, val_list = get_data_path_list(train_path, val_path)\n    device = 'cuda'\n\n    train_dataloader = build_dataloader(train_list,\n                                        root_path,\n                                        OOD_data=OOD_data,\n                                        min_length=min_length,\n                                        batch_size=batch_size,\n                                        num_workers=2,\n                                        dataset_config={},\n                                        device=device)\n\n    val_dataloader = build_dataloader(val_list,\n                                      root_path,\n                                      OOD_data=OOD_data,\n                                      min_length=min_length,\n                                      batch_size=batch_size,\n                                      validation=True,\n                                      num_workers=0,\n                                      device=device,\n                                      dataset_config={})\n    \n    # load pretrained ASR model\n    ASR_config = config.get('ASR_config', False)\n    ASR_path = config.get('ASR_path', False)\n    text_aligner = load_ASR_models(ASR_path, ASR_config)\n    \n    # load pretrained F0 model\n    F0_path = config.get('F0_path', False)\n    pitch_extractor = load_F0_models(F0_path)\n    \n    # load PL-BERT model\n    BERT_path = config.get('PLBERT_dir', False)\n    plbert = load_plbert(BERT_path)\n    \n    # build model\n    model_params = recursive_munch(config['model_params'])\n    multispeaker = model_params.multispeaker\n    model = build_model(model_params, text_aligner, pitch_extractor, plbert)\n    _ = [model[key].to(device) for key in model]\n    \n    # DP\n    for key in model:\n        if key != \"mpd\" and key != \"msd\" and key != \"wd\":\n            model[key] = MyDataParallel(model[key])\n            \n    start_epoch = 0\n    iters = 0\n\n    load_pretrained = config.get('pretrained_model', '') != '' and config.get('second_stage_load_pretrained', False)\n    \n    if not load_pretrained:\n        if config.get('first_stage_path', '') != '':\n            first_stage_path = osp.join(log_dir, config.get('first_stage_path', 'first_stage.pth'))\n            print('Loading the first stage model at %s ...' % first_stage_path)\n            model, _, start_epoch, iters = load_checkpoint(model, \n                None, \n                first_stage_path,\n                load_only_params=True,\n                ignore_modules=['bert', 'bert_encoder', 'predictor', 'predictor_encoder', 'msd', 'mpd', 'wd', 'diffusion']) # keep starting epoch for tensorboard log\n\n            # these epochs should be counted from the start epoch\n            diff_epoch += start_epoch\n            joint_epoch += start_epoch\n            epochs += start_epoch\n            \n            model.predictor_encoder = copy.deepcopy(model.style_encoder)\n        else:\n            raise ValueError('You need to specify the path to the first stage model.') \n\n    gl = GeneratorLoss(model.mpd, model.msd).to(device)\n    dl = DiscriminatorLoss(model.mpd, model.msd).to(device)\n    wl = WavLMLoss(model_params.slm.model, \n                   model.wd, \n                   sr, \n                   model_params.slm.sr).to(device)\n\n    gl = MyDataParallel(gl)\n    dl = MyDataParallel(dl)\n    wl = MyDataParallel(wl)\n    \n    sampler = DiffusionSampler(\n        model.diffusion.diffusion,\n        sampler=ADPM2Sampler(),\n        sigma_schedule=KarrasSchedule(sigma_min=0.0001, sigma_max=3.0, rho=9.0), # empirical parameters\n        clamp=False\n    )\n    \n    scheduler_params = {\n        \"max_lr\": optimizer_params.lr,\n        \"pct_start\": float(0),\n        \"epochs\": epochs,\n        \"steps_per_epoch\": len(train_dataloader),\n    }\n    scheduler_params_dict= {key: scheduler_params.copy() for key in model}\n    scheduler_params_dict['bert']['max_lr'] = optimizer_params.bert_lr * 2\n    scheduler_params_dict['decoder']['max_lr'] = optimizer_params.ft_lr * 2\n    scheduler_params_dict['style_encoder']['max_lr'] = optimizer_params.ft_lr * 2\n    \n    optimizer = build_optimizer({key: model[key].parameters() for key in model},\n                                          scheduler_params_dict=scheduler_params_dict, lr=optimizer_params.lr)\n    \n    # adjust BERT learning rate\n    for g in optimizer.optimizers['bert'].param_groups:\n        g['betas'] = (0.9, 0.99)\n        g['lr'] = optimizer_params.bert_lr\n        g['initial_lr'] = optimizer_params.bert_lr\n        g['min_lr'] = 0\n        g['weight_decay'] = 0.01\n        \n    # adjust acoustic module learning rate\n    for module in [\"decoder\", \"style_encoder\"]:\n        for g in optimizer.optimizers[module].param_groups:\n            g['betas'] = (0.0, 0.99)\n            g['lr'] = optimizer_params.ft_lr\n            g['initial_lr'] = optimizer_params.ft_lr\n            g['min_lr'] = 0\n            g['weight_decay'] = 1e-4\n        \n    # load models if there is a model\n    if load_pretrained:\n        model, optimizer, start_epoch, iters = load_checkpoint(model,  optimizer, config['pretrained_model'],\n                                    load_only_params=config.get('load_only_params', True))\n        \n    n_down = model.text_aligner.n_down\n\n    best_loss = float('inf')  # best test loss\n    loss_train_record = list([])\n    loss_test_record = list([])\n    iters = 0\n    \n    criterion = nn.L1Loss() # F0 loss (regression)\n    torch.cuda.empty_cache()\n    \n    stft_loss = MultiResolutionSTFTLoss().to(device)\n    \n    print('BERT', optimizer.optimizers['bert'])\n    print('decoder', optimizer.optimizers['decoder'])\n\n    start_ds = False\n    \n    running_std = []\n    \n    slmadv_params = Munch(config['slmadv_params'])\n    slmadv = SLMAdversarialLoss(model, wl, sampler, \n                                slmadv_params.min_len, \n                                slmadv_params.max_len,\n                                batch_percentage=slmadv_params.batch_percentage,\n                                skip_update=slmadv_params.iter, \n                                sig=slmadv_params.sig\n                               )\n    \n    \n    for epoch in range(start_epoch, epochs):\n        running_loss = 0\n        start_time = time.time()\n\n        _ = [model[key].eval() for key in model]\n        \n        model.text_aligner.train()\n        model.text_encoder.train()\n        \n        model.predictor.train()\n        model.bert_encoder.train()\n        model.bert.train()\n        model.msd.train()\n        model.mpd.train()\n\n        for i, batch in enumerate(train_dataloader):\n            waves = batch[0]\n            batch = [b.to(device) for b in batch[1:]]\n            texts, input_lengths, ref_texts, ref_lengths, mels, mel_input_length, ref_mels = batch\n            with torch.no_grad():\n                mask = length_to_mask(mel_input_length // (2 ** n_down)).to(device)\n                mel_mask = length_to_mask(mel_input_length).to(device)\n                text_mask = length_to_mask(input_lengths).to(texts.device)\n\n                # compute reference styles\n                if multispeaker and epoch >= diff_epoch:\n                    ref_ss = model.style_encoder(ref_mels.unsqueeze(1))\n                    ref_sp = model.predictor_encoder(ref_mels.unsqueeze(1))\n                    ref = torch.cat([ref_ss, ref_sp], dim=1)\n                \n            try:\n                ppgs, s2s_pred, s2s_attn = model.text_aligner(mels, mask, texts)\n                s2s_attn = s2s_attn.transpose(-1, -2)\n                s2s_attn = s2s_attn[..., 1:]\n                s2s_attn = s2s_attn.transpose(-1, -2)\n            except:\n                continue\n\n            mask_ST = mask_from_lens(s2s_attn, input_lengths, mel_input_length // (2 ** n_down))\n            s2s_attn_mono = maximum_path(s2s_attn, mask_ST)\n\n            # encode\n            t_en = model.text_encoder(texts, input_lengths, text_mask)\n            \n            # 50% of chance of using monotonic version\n            if bool(random.getrandbits(1)):\n                asr = (t_en @ s2s_attn)\n            else:\n                asr = (t_en @ s2s_attn_mono)\n\n            d_gt = s2s_attn_mono.sum(axis=-1).detach()\n\n            # compute the style of the entire utterance\n            # this operation cannot be done in batch because of the avgpool layer (may need to work on masked avgpool)\n            ss = []\n            gs = []\n            for bib in range(len(mel_input_length)):\n                mel_length = int(mel_input_length[bib].item())\n                mel = mels[bib, :, :mel_input_length[bib]]\n                s = model.predictor_encoder(mel.unsqueeze(0).unsqueeze(1))\n                ss.append(s)\n                s = model.style_encoder(mel.unsqueeze(0).unsqueeze(1))\n                gs.append(s)\n\n            s_dur = torch.stack(ss).squeeze()  # global prosodic styles\n            gs = torch.stack(gs).squeeze() # global acoustic styles\n            s_trg = torch.cat([gs, s_dur], dim=-1).detach() # ground truth for denoiser\n\n            bert_dur = model.bert(texts, attention_mask=(~text_mask).int())\n            d_en = model.bert_encoder(bert_dur).transpose(-1, -2) \n            \n            # denoiser training\n            if epoch >= diff_epoch:\n                num_steps = np.random.randint(3, 5)\n                \n                if model_params.diffusion.dist.estimate_sigma_data:\n                    model.diffusion.module.diffusion.sigma_data = s_trg.std(axis=-1).mean().item() # batch-wise std estimation\n                    running_std.append(model.diffusion.module.diffusion.sigma_data)\n                    \n                if multispeaker:\n                    s_preds = sampler(noise = torch.randn_like(s_trg).unsqueeze(1).to(device), \n                          embedding=bert_dur,\n                          embedding_scale=1,\n                                   features=ref, # reference from the same speaker as the embedding\n                             embedding_mask_proba=0.1,\n                             num_steps=num_steps).squeeze(1)\n                    loss_diff = model.diffusion(s_trg.unsqueeze(1), embedding=bert_dur, features=ref).mean() # EDM loss\n                    loss_sty = F.l1_loss(s_preds, s_trg.detach()) # style reconstruction loss\n                else:\n                    s_preds = sampler(noise = torch.randn_like(s_trg).unsqueeze(1).to(device), \n                          embedding=bert_dur,\n                          embedding_scale=1,\n                             embedding_mask_proba=0.1,\n                             num_steps=num_steps).squeeze(1)                    \n                    loss_diff = model.diffusion.module.diffusion(s_trg.unsqueeze(1), embedding=bert_dur).mean() # EDM loss\n                    loss_sty = F.l1_loss(s_preds, s_trg.detach()) # style reconstruction loss\n            else:\n                loss_sty = 0\n                loss_diff = 0\n\n                \n            s_loss = 0\n            \n\n            d, p = model.predictor(d_en, s_dur, \n                                                    input_lengths, \n                                                    s2s_attn_mono, \n                                                    text_mask)\n                \n            mel_len_st = int(mel_input_length.min().item() / 2 - 1)\n            mel_len = min(int(mel_input_length.min().item() / 2 - 1), max_len // 2)\n            en = []\n            gt = []\n            p_en = []\n            wav = []\n            st = []\n            \n            for bib in range(len(mel_input_length)):\n                mel_length = int(mel_input_length[bib].item() / 2)\n\n                random_start = np.random.randint(0, mel_length - mel_len)\n                en.append(asr[bib, :, random_start:random_start+mel_len])\n                p_en.append(p[bib, :, random_start:random_start+mel_len])\n                gt.append(mels[bib, :, (random_start * 2):((random_start+mel_len) * 2)])\n                \n                y = waves[bib][(random_start * 2) * 300:((random_start+mel_len) * 2) * 300]\n                wav.append(torch.from_numpy(y).to(device))\n                \n                # style reference (better to be different from the GT)\n                random_start = np.random.randint(0, mel_length - mel_len_st)\n                st.append(mels[bib, :, (random_start * 2):((random_start+mel_len_st) * 2)])\n                \n            wav = torch.stack(wav).float().detach()\n\n            en = torch.stack(en)\n            p_en = torch.stack(p_en)\n            gt = torch.stack(gt).detach()\n            st = torch.stack(st).detach()\n            \n            \n            if gt.size(-1) < 80:\n                continue\n            \n            s = model.style_encoder(gt.unsqueeze(1))           \n            s_dur = model.predictor_encoder(gt.unsqueeze(1))\n                \n            with torch.no_grad():\n                F0_real, _, F0 = model.pitch_extractor(gt.unsqueeze(1))\n                F0 = F0.reshape(F0.shape[0], F0.shape[1] * 2, F0.shape[2], 1).squeeze()\n\n                N_real = log_norm(gt.unsqueeze(1)).squeeze(1)\n                \n                y_rec_gt = wav.unsqueeze(1)\n                y_rec_gt_pred = model.decoder(en, F0_real, N_real, s)\n\n                wav = y_rec_gt\n\n            F0_fake, N_fake = model.predictor.F0Ntrain(p_en, s_dur)\n\n            y_rec = model.decoder(en, F0_fake, N_fake, s)\n\n            loss_F0_rec =  (F.smooth_l1_loss(F0_real, F0_fake)) / 10\n            loss_norm_rec = F.smooth_l1_loss(N_real, N_fake)\n\n            optimizer.zero_grad()\n            d_loss = dl(wav.detach(), y_rec.detach()).mean()\n            d_loss.backward()\n            optimizer.step('msd')\n            optimizer.step('mpd')\n\n            # generator loss\n            optimizer.zero_grad()\n\n            loss_mel = stft_loss(y_rec, wav)\n            loss_gen_all = gl(wav, y_rec).mean()\n            loss_lm = wl(wav.detach().squeeze(), y_rec.squeeze()).mean()\n\n            loss_ce = 0\n            loss_dur = 0\n            for _s2s_pred, _text_input, _text_length in zip(d, (d_gt), input_lengths):\n                _s2s_pred = _s2s_pred[:_text_length, :]\n                _text_input = _text_input[:_text_length].long()\n                _s2s_trg = torch.zeros_like(_s2s_pred)\n                for p in range(_s2s_trg.shape[0]):\n                    _s2s_trg[p, :_text_input[p]] = 1\n                _dur_pred = torch.sigmoid(_s2s_pred).sum(axis=1)\n\n                loss_dur += F.l1_loss(_dur_pred[1:_text_length-1], \n                                       _text_input[1:_text_length-1])\n                loss_ce += F.binary_cross_entropy_with_logits(_s2s_pred.flatten(), _s2s_trg.flatten())\n\n            loss_ce /= texts.size(0)\n            loss_dur /= texts.size(0)\n            \n            loss_s2s = 0\n            for _s2s_pred, _text_input, _text_length in zip(s2s_pred, texts, input_lengths):\n                loss_s2s += F.cross_entropy(_s2s_pred[:_text_length], _text_input[:_text_length])\n            loss_s2s /= texts.size(0)\n\n            loss_mono = F.l1_loss(s2s_attn, s2s_attn_mono) * 10\n\n            g_loss = loss_params.lambda_mel * loss_mel + \\\n                     loss_params.lambda_F0 * loss_F0_rec + \\\n                     loss_params.lambda_ce * loss_ce + \\\n                     loss_params.lambda_norm * loss_norm_rec + \\\n                     loss_params.lambda_dur * loss_dur + \\\n                     loss_params.lambda_gen * loss_gen_all + \\\n                     loss_params.lambda_slm * loss_lm + \\\n                     loss_params.lambda_sty * loss_sty + \\\n                     loss_params.lambda_diff * loss_diff + \\\n                    loss_params.lambda_mono * loss_mono + \\\n                    loss_params.lambda_s2s * loss_s2s\n            \n            running_loss += loss_mel.item()\n            g_loss.backward()\n            if torch.isnan(g_loss):\n                from IPython.core.debugger import set_trace\n                set_trace()\n\n            optimizer.step('bert_encoder')\n            optimizer.step('bert')\n            optimizer.step('predictor')\n            optimizer.step('predictor_encoder')\n            optimizer.step('style_encoder')\n            optimizer.step('decoder')\n            \n            optimizer.step('text_encoder')\n            optimizer.step('text_aligner')\n            \n            if epoch >= diff_epoch:\n                optimizer.step('diffusion')\n\n            d_loss_slm, loss_gen_lm = 0, 0\n            if epoch >= joint_epoch:\n                # randomly pick whether to use in-distribution text\n                if np.random.rand() < 0.5:\n                    use_ind = True\n                else:\n                    use_ind = False\n\n                if use_ind:\n                    ref_lengths = input_lengths\n                    ref_texts = texts\n                    \n                slm_out = slmadv(i, \n                                 y_rec_gt, \n                                 y_rec_gt_pred, \n                                 waves, \n                                 mel_input_length,\n                                 ref_texts, \n                                 ref_lengths, use_ind, s_trg.detach(), ref if multispeaker else None)\n\n                if slm_out is not None:\n                    d_loss_slm, loss_gen_lm, y_pred = slm_out\n\n                    # SLM generator loss\n                    optimizer.zero_grad()\n                    loss_gen_lm.backward()\n\n                    # compute the gradient norm\n                    total_norm = {}\n                    for key in model.keys():\n                        total_norm[key] = 0\n                        parameters = [p for p in model[key].parameters() if p.grad is not None and p.requires_grad]\n                        for p in parameters:\n                            param_norm = p.grad.detach().data.norm(2)\n                            total_norm[key] += param_norm.item() ** 2\n                        total_norm[key] = total_norm[key] ** 0.5\n\n                    # gradient scaling\n                    if total_norm['predictor'] > slmadv_params.thresh:\n                        for key in model.keys():\n                            for p in model[key].parameters():\n                                if p.grad is not None:\n                                    p.grad *= (1 / total_norm['predictor'])\n\n                    for p in model.predictor.duration_proj.parameters():\n                        if p.grad is not None:\n                            p.grad *= slmadv_params.scale\n\n                    for p in model.predictor.lstm.parameters():\n                        if p.grad is not None:\n                            p.grad *= slmadv_params.scale\n\n                    for p in model.diffusion.parameters():\n                        if p.grad is not None:\n                            p.grad *= slmadv_params.scale\n                    \n                    optimizer.step('bert_encoder')\n                    optimizer.step('bert')\n                    optimizer.step('predictor')\n                    optimizer.step('diffusion')\n\n                    # SLM discriminator loss\n                    if d_loss_slm != 0:\n                        optimizer.zero_grad()\n                        d_loss_slm.backward(retain_graph=True)\n                        optimizer.step('wd')\n\n            iters = iters + 1\n            \n            if (i+1)%log_interval == 0:\n                logger.info ('Epoch [%d/%d], Step [%d/%d], Loss: %.5f, Disc Loss: %.5f, Dur Loss: %.5f, CE Loss: %.5f, Norm Loss: %.5f, F0 Loss: %.5f, LM Loss: %.5f, Gen Loss: %.5f, Sty Loss: %.5f, Diff Loss: %.5f, DiscLM Loss: %.5f, GenLM Loss: %.5f, SLoss: %.5f, S2S Loss: %.5f, Mono Loss: %.5f'\n                    %(epoch+1, epochs, i+1, len(train_list)//batch_size, running_loss / log_interval, d_loss, loss_dur, loss_ce, loss_norm_rec, loss_F0_rec, loss_lm, loss_gen_all, loss_sty, loss_diff, d_loss_slm, loss_gen_lm, s_loss, loss_s2s, loss_mono))\n                \n                writer.add_scalar('train/mel_loss', running_loss / log_interval, iters)\n                writer.add_scalar('train/gen_loss', loss_gen_all, iters)\n                writer.add_scalar('train/d_loss', d_loss, iters)\n                writer.add_scalar('train/ce_loss', loss_ce, iters)\n                writer.add_scalar('train/dur_loss', loss_dur, iters)\n                writer.add_scalar('train/slm_loss', loss_lm, iters)\n                writer.add_scalar('train/norm_loss', loss_norm_rec, iters)\n                writer.add_scalar('train/F0_loss', loss_F0_rec, iters)\n                writer.add_scalar('train/sty_loss', loss_sty, iters)\n                writer.add_scalar('train/diff_loss', loss_diff, iters)\n                writer.add_scalar('train/d_loss_slm', d_loss_slm, iters)\n                writer.add_scalar('train/gen_loss_slm', loss_gen_lm, iters)\n                \n                running_loss = 0\n                \n                print('Time elasped:', time.time()-start_time)\n            \n        loss_test = 0\n        loss_align = 0\n        loss_f = 0\n        _ = [model[key].eval() for key in model]\n\n        with torch.no_grad():\n            iters_test = 0\n            for batch_idx, batch in enumerate(val_dataloader):\n                optimizer.zero_grad()\n\n                try:\n                    waves = batch[0]\n                    batch = [b.to(device) for b in batch[1:]]\n                    texts, input_lengths, ref_texts, ref_lengths, mels, mel_input_length, ref_mels = batch\n                    with torch.no_grad():\n                        mask = length_to_mask(mel_input_length // (2 ** n_down)).to('cuda')\n                        text_mask = length_to_mask(input_lengths).to(texts.device)\n\n                        _, _, s2s_attn = model.text_aligner(mels, mask, texts)\n                        s2s_attn = s2s_attn.transpose(-1, -2)\n                        s2s_attn = s2s_attn[..., 1:]\n                        s2s_attn = s2s_attn.transpose(-1, -2)\n\n                        mask_ST = mask_from_lens(s2s_attn, input_lengths, mel_input_length // (2 ** n_down))\n                        s2s_attn_mono = maximum_path(s2s_attn, mask_ST)\n\n                        # encode\n                        t_en = model.text_encoder(texts, input_lengths, text_mask)\n                        asr = (t_en @ s2s_attn_mono)\n\n                        d_gt = s2s_attn_mono.sum(axis=-1).detach()\n\n                    ss = []\n                    gs = []\n\n                    for bib in range(len(mel_input_length)):\n                        mel_length = int(mel_input_length[bib].item())\n                        mel = mels[bib, :, :mel_input_length[bib]]\n                        s = model.predictor_encoder(mel.unsqueeze(0).unsqueeze(1))\n                        ss.append(s)\n                        s = model.style_encoder(mel.unsqueeze(0).unsqueeze(1))\n                        gs.append(s)\n\n                    s = torch.stack(ss).squeeze()\n                    gs = torch.stack(gs).squeeze()\n                    s_trg = torch.cat([s, gs], dim=-1).detach()\n\n                    bert_dur = model.bert(texts, attention_mask=(~text_mask).int())\n                    d_en = model.bert_encoder(bert_dur).transpose(-1, -2) \n                    d, p = model.predictor(d_en, s, \n                                                        input_lengths, \n                                                        s2s_attn_mono, \n                                                        text_mask)\n                    # get clips\n                    mel_len = int(mel_input_length.min().item() / 2 - 1)\n                    en = []\n                    gt = []\n\n                    p_en = []\n                    wav = []\n\n                    for bib in range(len(mel_input_length)):\n                        mel_length = int(mel_input_length[bib].item() / 2)\n\n                        random_start = np.random.randint(0, mel_length - mel_len)\n                        en.append(asr[bib, :, random_start:random_start+mel_len])\n                        p_en.append(p[bib, :, random_start:random_start+mel_len])\n\n                        gt.append(mels[bib, :, (random_start * 2):((random_start+mel_len) * 2)])\n                        y = waves[bib][(random_start * 2) * 300:((random_start+mel_len) * 2) * 300]\n                        wav.append(torch.from_numpy(y).to(device))\n\n                    wav = torch.stack(wav).float().detach()\n\n                    en = torch.stack(en)\n                    p_en = torch.stack(p_en)\n                    gt = torch.stack(gt).detach()\n                    s = model.predictor_encoder(gt.unsqueeze(1))\n\n                    F0_fake, N_fake = model.predictor.F0Ntrain(p_en, s)\n\n                    loss_dur = 0\n                    for _s2s_pred, _text_input, _text_length in zip(d, (d_gt), input_lengths):\n                        _s2s_pred = _s2s_pred[:_text_length, :]\n                        _text_input = _text_input[:_text_length].long()\n                        _s2s_trg = torch.zeros_like(_s2s_pred)\n                        for bib in range(_s2s_trg.shape[0]):\n                            _s2s_trg[bib, :_text_input[bib]] = 1\n                        _dur_pred = torch.sigmoid(_s2s_pred).sum(axis=1)\n                        loss_dur += F.l1_loss(_dur_pred[1:_text_length-1], \n                                               _text_input[1:_text_length-1])\n\n                    loss_dur /= texts.size(0)\n\n                    s = model.style_encoder(gt.unsqueeze(1))\n\n                    y_rec = model.decoder(en, F0_fake, N_fake, s)\n                    loss_mel = stft_loss(y_rec.squeeze(), wav.detach())\n\n                    F0_real, _, F0 = model.pitch_extractor(gt.unsqueeze(1)) \n\n                    loss_F0 = F.l1_loss(F0_real, F0_fake) / 10\n\n                    loss_test += (loss_mel).mean()\n                    loss_align += (loss_dur).mean()\n                    loss_f += (loss_F0).mean()\n\n                    iters_test += 1\n                except:\n                    continue\n\n        print('Epochs:', epoch + 1)\n        logger.info('Validation loss: %.3f, Dur loss: %.3f, F0 loss: %.3f' % (loss_test / iters_test, loss_align / iters_test, loss_f / iters_test) + '\\n\\n\\n')\n        print('\\n\\n\\n')\n        writer.add_scalar('eval/mel_loss', loss_test / iters_test, epoch + 1)\n        writer.add_scalar('eval/dur_loss', loss_test / iters_test, epoch + 1)\n        writer.add_scalar('eval/F0_loss', loss_f / iters_test, epoch + 1)\n        \n        \n        if (epoch + 1) % save_freq == 0 :\n            if (loss_test / iters_test) < best_loss:\n                best_loss = loss_test / iters_test\n            print('Saving..')\n            state = {\n                'net':  {key: model[key].state_dict() for key in model}, \n                'optimizer': optimizer.state_dict(),\n                'iters': iters,\n                'val_loss': loss_test / iters_test,\n                'epoch': epoch,\n            }\n            save_path = osp.join(log_dir, 'epoch_2nd_%05d.pth' % epoch)\n            torch.save(state, save_path)\n\n            # if estimate sigma, save the estimated simga\n            if model_params.diffusion.dist.estimate_sigma_data:\n                config['model_params']['diffusion']['dist']['sigma_data'] = float(np.mean(running_std))\n\n                with open(osp.join(log_dir, osp.basename(config_path)), 'w') as outfile:\n                    yaml.dump(config, outfile, default_flow_style=True)\n\n                            \nif __name__==\"__main__\":\n    main()\n"
        },
        {
          "name": "train_finetune_accelerate.py",
          "type": "blob",
          "size": 29.4775390625,
          "content": "# load packages\nimport random\nimport yaml\nimport time\nfrom munch import Munch\nimport numpy as np\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nimport torchaudio\nimport librosa\nimport click\nimport shutil\nimport warnings\nwarnings.simplefilter('ignore')\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom meldataset import build_dataloader\n\nfrom Utils.ASR.models import ASRCNN\nfrom Utils.JDC.model import JDCNet\nfrom Utils.PLBERT.util import load_plbert\n\nfrom models import *\nfrom losses import *\nfrom utils import *\n\nfrom Modules.slmadv import SLMAdversarialLoss\nfrom Modules.diffusion.sampler import DiffusionSampler, ADPM2Sampler, KarrasSchedule\n\nfrom optimizers import build_optimizer\n\nfrom accelerate import Accelerator\n\naccelerator = Accelerator()\n\n# simple fix for dataparallel that allows access to class attributes\nclass MyDataParallel(torch.nn.DataParallel):\n    def __getattr__(self, name):\n        try:\n            return super().__getattr__(name)\n        except AttributeError:\n            return getattr(self.module, name)\n        \nimport logging\nfrom logging import StreamHandler\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nhandler = StreamHandler()\nhandler.setLevel(logging.DEBUG)\nlogger.addHandler(handler)\n\n\n@click.command()\n@click.option('-p', '--config_path', default='Configs/config_ft.yml', type=str)\ndef main(config_path):\n    config = yaml.safe_load(open(config_path))\n    \n    log_dir = config['log_dir']\n    if not osp.exists(log_dir): os.makedirs(log_dir, exist_ok=True)\n    shutil.copy(config_path, osp.join(log_dir, osp.basename(config_path)))\n    writer = SummaryWriter(log_dir + \"/tensorboard\")\n\n    # write logs\n    file_handler = logging.FileHandler(osp.join(log_dir, 'train.log'))\n    file_handler.setLevel(logging.DEBUG)\n    file_handler.setFormatter(logging.Formatter('%(levelname)s:%(asctime)s: %(message)s'))\n    logger.addHandler(file_handler)\n\n    \n    batch_size = config.get('batch_size', 10)\n\n    epochs = config.get('epochs', 200)\n    save_freq = config.get('save_freq', 2)\n    log_interval = config.get('log_interval', 10)\n    saving_epoch = config.get('save_freq', 2)\n\n    data_params = config.get('data_params', None)\n    sr = config['preprocess_params'].get('sr', 24000)\n    train_path = data_params['train_data']\n    val_path = data_params['val_data']\n    root_path = data_params['root_path']\n    min_length = data_params['min_length']\n    OOD_data = data_params['OOD_data']\n\n    max_len = config.get('max_len', 200)\n    \n    loss_params = Munch(config['loss_params'])\n    diff_epoch = loss_params.diff_epoch\n    joint_epoch = loss_params.joint_epoch\n    \n    optimizer_params = Munch(config['optimizer_params'])\n    \n    train_list, val_list = get_data_path_list(train_path, val_path)\n    device = accelerator.device\n\n    train_dataloader = build_dataloader(train_list,\n                                        root_path,\n                                        OOD_data=OOD_data,\n                                        min_length=min_length,\n                                        batch_size=batch_size,\n                                        num_workers=2,\n                                        dataset_config={},\n                                        device=device)\n\n    val_dataloader = build_dataloader(val_list,\n                                      root_path,\n                                      OOD_data=OOD_data,\n                                      min_length=min_length,\n                                      batch_size=batch_size,\n                                      validation=True,\n                                      num_workers=0,\n                                      device=device,\n                                      dataset_config={})\n    \n    # load pretrained ASR model\n    ASR_config = config.get('ASR_config', False)\n    ASR_path = config.get('ASR_path', False)\n    text_aligner = load_ASR_models(ASR_path, ASR_config)\n    \n    # load pretrained F0 model\n    F0_path = config.get('F0_path', False)\n    pitch_extractor = load_F0_models(F0_path)\n    \n    # load PL-BERT model\n    BERT_path = config.get('PLBERT_dir', False)\n    plbert = load_plbert(BERT_path)\n    \n    # build model\n    model_params = recursive_munch(config['model_params'])\n    multispeaker = model_params.multispeaker\n    model = build_model(model_params, text_aligner, pitch_extractor, plbert)\n    _ = [model[key].to(device) for key in model]\n    \n    # DP\n    for key in model:\n        if key != \"mpd\" and key != \"msd\" and key != \"wd\":\n            model[key] = MyDataParallel(model[key])\n            \n    start_epoch = 0\n    iters = 0\n\n    load_pretrained = config.get('pretrained_model', '') != '' and config.get('second_stage_load_pretrained', False)\n    \n    if not load_pretrained:\n        if config.get('first_stage_path', '') != '':\n            first_stage_path = osp.join(log_dir, config.get('first_stage_path', 'first_stage.pth'))\n            print('Loading the first stage model at %s ...' % first_stage_path)\n            model, _, start_epoch, iters = load_checkpoint(model, \n                None, \n                first_stage_path,\n                load_only_params=True,\n                ignore_modules=['bert', 'bert_encoder', 'predictor', 'predictor_encoder', 'msd', 'mpd', 'wd', 'diffusion']) # keep starting epoch for tensorboard log\n\n            # these epochs should be counted from the start epoch\n            diff_epoch += start_epoch\n            joint_epoch += start_epoch\n            epochs += start_epoch\n            \n            model.predictor_encoder = copy.deepcopy(model.style_encoder)\n        else:\n            raise ValueError('You need to specify the path to the first stage model.') \n\n    gl = GeneratorLoss(model.mpd, model.msd).to(device)\n    dl = DiscriminatorLoss(model.mpd, model.msd).to(device)\n    wl = WavLMLoss(model_params.slm.model, \n                   model.wd, \n                   sr, \n                   model_params.slm.sr).to(device)\n\n    gl = MyDataParallel(gl)\n    dl = MyDataParallel(dl)\n    wl = MyDataParallel(wl)\n    \n    sampler = DiffusionSampler(\n        model.diffusion.diffusion,\n        sampler=ADPM2Sampler(),\n        sigma_schedule=KarrasSchedule(sigma_min=0.0001, sigma_max=3.0, rho=9.0), # empirical parameters\n        clamp=False\n    )\n    \n    scheduler_params = {\n        \"max_lr\": optimizer_params.lr,\n        \"pct_start\": float(0),\n        \"epochs\": epochs,\n        \"steps_per_epoch\": len(train_dataloader),\n    }\n    scheduler_params_dict= {key: scheduler_params.copy() for key in model}\n    scheduler_params_dict['bert']['max_lr'] = optimizer_params.bert_lr * 2\n    scheduler_params_dict['decoder']['max_lr'] = optimizer_params.ft_lr * 2\n    scheduler_params_dict['style_encoder']['max_lr'] = optimizer_params.ft_lr * 2\n    \n    optimizer = build_optimizer({key: model[key].parameters() for key in model},\n                                          scheduler_params_dict=scheduler_params_dict, lr=optimizer_params.lr)\n    \n    # adjust BERT learning rate\n    for g in optimizer.optimizers['bert'].param_groups:\n        g['betas'] = (0.9, 0.99)\n        g['lr'] = optimizer_params.bert_lr\n        g['initial_lr'] = optimizer_params.bert_lr\n        g['min_lr'] = 0\n        g['weight_decay'] = 0.01\n        \n    # adjust acoustic module learning rate\n    for module in [\"decoder\", \"style_encoder\"]:\n        for g in optimizer.optimizers[module].param_groups:\n            g['betas'] = (0.0, 0.99)\n            g['lr'] = optimizer_params.ft_lr\n            g['initial_lr'] = optimizer_params.ft_lr\n            g['min_lr'] = 0\n            g['weight_decay'] = 1e-4\n        \n    # load models if there is a model\n    if load_pretrained:\n        model, optimizer, start_epoch, iters = load_checkpoint(model,  optimizer, config['pretrained_model'],\n                                    load_only_params=config.get('load_only_params', True))\n        \n    n_down = model.text_aligner.n_down\n\n    best_loss = float('inf')  # best test loss\n    loss_train_record = list([])\n    loss_test_record = list([])\n    iters = 0\n    \n    criterion = nn.L1Loss() # F0 loss (regression)\n    torch.cuda.empty_cache()\n    \n    stft_loss = MultiResolutionSTFTLoss().to(device)\n    \n    print('BERT', optimizer.optimizers['bert'])\n    print('decoder', optimizer.optimizers['decoder'])\n\n    start_ds = False\n    \n    running_std = []\n    \n    slmadv_params = Munch(config['slmadv_params'])\n    slmadv = SLMAdversarialLoss(model, wl, sampler, \n                                slmadv_params.min_len, \n                                slmadv_params.max_len,\n                                batch_percentage=slmadv_params.batch_percentage,\n                                skip_update=slmadv_params.iter, \n                                sig=slmadv_params.sig\n                               )\n\n    model, optimizer, train_dataloader = accelerator.prepare(\n        model, optimizer, train_dataloader\n    )\n\n    for epoch in range(start_epoch, epochs):\n        running_loss = 0\n        start_time = time.time()\n\n        _ = [model[key].eval() for key in model]\n        \n        model.text_aligner.train()\n        model.text_encoder.train()\n        \n        model.predictor.train()\n        model.bert_encoder.train()\n        model.bert.train()\n        model.msd.train()\n        model.mpd.train()\n\n        for i, batch in enumerate(train_dataloader):\n            waves = batch[0]\n            batch = [b.to(device) for b in batch[1:]]\n            texts, input_lengths, ref_texts, ref_lengths, mels, mel_input_length, ref_mels = batch\n            with torch.no_grad():\n                mask = length_to_mask(mel_input_length // (2 ** n_down)).to(device)\n                mel_mask = length_to_mask(mel_input_length).to(device)\n                text_mask = length_to_mask(input_lengths).to(texts.device)\n\n                # compute reference styles\n                if multispeaker and epoch >= diff_epoch:\n                    ref_ss = model.style_encoder(ref_mels.unsqueeze(1))\n                    ref_sp = model.predictor_encoder(ref_mels.unsqueeze(1))\n                    ref = torch.cat([ref_ss, ref_sp], dim=1)\n                \n            try:\n                ppgs, s2s_pred, s2s_attn = model.text_aligner(mels, mask, texts)\n                s2s_attn = s2s_attn.transpose(-1, -2)\n                s2s_attn = s2s_attn[..., 1:]\n                s2s_attn = s2s_attn.transpose(-1, -2)\n            except:\n                continue\n\n            mask_ST = mask_from_lens(s2s_attn, input_lengths, mel_input_length // (2 ** n_down))\n            s2s_attn_mono = maximum_path(s2s_attn, mask_ST)\n\n            # encode\n            t_en = model.text_encoder(texts, input_lengths, text_mask)\n            \n            # 50% of chance of using monotonic version\n            if bool(random.getrandbits(1)):\n                asr = (t_en @ s2s_attn)\n            else:\n                asr = (t_en @ s2s_attn_mono)\n\n            d_gt = s2s_attn_mono.sum(axis=-1).detach()\n\n            # compute the style of the entire utterance\n            # this operation cannot be done in batch because of the avgpool layer (may need to work on masked avgpool)\n            ss = []\n            gs = []\n            for bib in range(len(mel_input_length)):\n                mel_length = int(mel_input_length[bib].item())\n                mel = mels[bib, :, :mel_input_length[bib]]\n                s = model.predictor_encoder(mel.unsqueeze(0).unsqueeze(1))\n                ss.append(s)\n                s = model.style_encoder(mel.unsqueeze(0).unsqueeze(1))\n                gs.append(s)\n\n            s_dur = torch.stack(ss).squeeze()  # global prosodic styles\n            gs = torch.stack(gs).squeeze() # global acoustic styles\n            s_trg = torch.cat([gs, s_dur], dim=-1).detach() # ground truth for denoiser\n\n            bert_dur = model.bert(texts, attention_mask=(~text_mask).int())\n            d_en = model.bert_encoder(bert_dur).transpose(-1, -2) \n            \n            # denoiser training\n            if epoch >= diff_epoch:\n                num_steps = np.random.randint(3, 5)\n                \n                if model_params.diffusion.dist.estimate_sigma_data:\n                    model.diffusion.module.diffusion.sigma_data = s_trg.std(axis=-1).mean().item() # batch-wise std estimation\n                    running_std.append(model.diffusion.module.diffusion.sigma_data)\n                    \n                if multispeaker:\n                    s_preds = sampler(noise = torch.randn_like(s_trg).unsqueeze(1).to(device), \n                          embedding=bert_dur,\n                          embedding_scale=1,\n                                   features=ref, # reference from the same speaker as the embedding\n                             embedding_mask_proba=0.1,\n                             num_steps=num_steps).squeeze(1)\n                    loss_diff = model.diffusion(s_trg.unsqueeze(1), embedding=bert_dur, features=ref).mean() # EDM loss\n                    loss_sty = F.l1_loss(s_preds, s_trg.detach()) # style reconstruction loss\n                else:\n                    s_preds = sampler(noise = torch.randn_like(s_trg).unsqueeze(1).to(device), \n                          embedding=bert_dur,\n                          embedding_scale=1,\n                             embedding_mask_proba=0.1,\n                             num_steps=num_steps).squeeze(1)                    \n                    loss_diff = model.diffusion.module.diffusion(s_trg.unsqueeze(1), embedding=bert_dur).mean() # EDM loss\n                    loss_sty = F.l1_loss(s_preds, s_trg.detach()) # style reconstruction loss\n            else:\n                loss_sty = 0\n                loss_diff = 0\n\n                \n            s_loss = 0\n            \n\n            d, p = model.predictor(d_en, s_dur, \n                                                    input_lengths, \n                                                    s2s_attn_mono, \n                                                    text_mask)\n                \n            mel_len_st = int(mel_input_length.min().item() / 2 - 1)\n            mel_len = min(int(mel_input_length.min().item() / 2 - 1), max_len // 2)\n            en = []\n            gt = []\n            p_en = []\n            wav = []\n            st = []\n            \n            for bib in range(len(mel_input_length)):\n                mel_length = int(mel_input_length[bib].item() / 2)\n\n                random_start = np.random.randint(0, mel_length - mel_len)\n                en.append(asr[bib, :, random_start:random_start+mel_len])\n                p_en.append(p[bib, :, random_start:random_start+mel_len])\n                gt.append(mels[bib, :, (random_start * 2):((random_start+mel_len) * 2)])\n                \n                y = waves[bib][(random_start * 2) * 300:((random_start+mel_len) * 2) * 300]\n                wav.append(torch.from_numpy(y).to(device))\n                \n                # style reference (better to be different from the GT)\n                random_start = np.random.randint(0, mel_length - mel_len_st)\n                st.append(mels[bib, :, (random_start * 2):((random_start+mel_len_st) * 2)])\n                \n            wav = torch.stack(wav).float().detach()\n\n            en = torch.stack(en)\n            p_en = torch.stack(p_en)\n            gt = torch.stack(gt).detach()\n            st = torch.stack(st).detach()\n            \n            \n            if gt.size(-1) < 80:\n                continue\n            \n            s = model.style_encoder(gt.unsqueeze(1))           \n            s_dur = model.predictor_encoder(gt.unsqueeze(1))\n                \n            with torch.no_grad():\n                F0_real, _, F0 = model.pitch_extractor(gt.unsqueeze(1))\n                F0 = F0.reshape(F0.shape[0], F0.shape[1] * 2, F0.shape[2], 1).squeeze()\n\n                N_real = log_norm(gt.unsqueeze(1)).squeeze(1)\n                \n                y_rec_gt = wav.unsqueeze(1)\n                y_rec_gt_pred = model.decoder(en, F0_real, N_real, s)\n\n                wav = y_rec_gt\n\n            F0_fake, N_fake = model.predictor.F0Ntrain(p_en, s_dur)\n\n            y_rec = model.decoder(en, F0_fake, N_fake, s)\n\n            loss_F0_rec =  (F.smooth_l1_loss(F0_real, F0_fake)) / 10\n            loss_norm_rec = F.smooth_l1_loss(N_real, N_fake)\n\n            optimizer.zero_grad()\n            d_loss = dl(wav.detach(), y_rec.detach()).mean()\n            accelerator.backward(d_loss)\n            optimizer.step('msd')\n            optimizer.step('mpd')\n\n            # generator loss\n            optimizer.zero_grad()\n\n            loss_mel = stft_loss(y_rec, wav)\n            loss_gen_all = gl(wav, y_rec).mean()\n            loss_lm = wl(wav.detach().squeeze(), y_rec.squeeze()).mean()\n\n            loss_ce = 0\n            loss_dur = 0\n            for _s2s_pred, _text_input, _text_length in zip(d, (d_gt), input_lengths):\n                _s2s_pred = _s2s_pred[:_text_length, :]\n                _text_input = _text_input[:_text_length].long()\n                _s2s_trg = torch.zeros_like(_s2s_pred)\n                for p in range(_s2s_trg.shape[0]):\n                    _s2s_trg[p, :_text_input[p]] = 1\n                _dur_pred = torch.sigmoid(_s2s_pred).sum(axis=1)\n\n                loss_dur += F.l1_loss(_dur_pred[1:_text_length-1], \n                                       _text_input[1:_text_length-1])\n                loss_ce += F.binary_cross_entropy_with_logits(_s2s_pred.flatten(), _s2s_trg.flatten())\n\n            loss_ce /= texts.size(0)\n            loss_dur /= texts.size(0)\n            \n            loss_s2s = 0\n            for _s2s_pred, _text_input, _text_length in zip(s2s_pred, texts, input_lengths):\n                loss_s2s += F.cross_entropy(_s2s_pred[:_text_length], _text_input[:_text_length])\n            loss_s2s /= texts.size(0)\n\n            loss_mono = F.l1_loss(s2s_attn, s2s_attn_mono) * 10\n\n            g_loss = loss_params.lambda_mel * loss_mel + \\\n                     loss_params.lambda_F0 * loss_F0_rec + \\\n                     loss_params.lambda_ce * loss_ce + \\\n                     loss_params.lambda_norm * loss_norm_rec + \\\n                     loss_params.lambda_dur * loss_dur + \\\n                     loss_params.lambda_gen * loss_gen_all + \\\n                     loss_params.lambda_slm * loss_lm + \\\n                     loss_params.lambda_sty * loss_sty + \\\n                     loss_params.lambda_diff * loss_diff + \\\n                    loss_params.lambda_mono * loss_mono + \\\n                    loss_params.lambda_s2s * loss_s2s\n            \n            running_loss += loss_mel.item()\n            accelerator.backward(g_loss)\n            if torch.isnan(g_loss):\n                from IPython.core.debugger import set_trace\n                set_trace()\n\n            optimizer.step('bert_encoder')\n            optimizer.step('bert')\n            optimizer.step('predictor')\n            optimizer.step('predictor_encoder')\n            optimizer.step('style_encoder')\n            optimizer.step('decoder')\n            \n            optimizer.step('text_encoder')\n            optimizer.step('text_aligner')\n            \n            if epoch >= diff_epoch:\n                optimizer.step('diffusion')\n\n            d_loss_slm, loss_gen_lm = 0, 0\n            if epoch >= joint_epoch:\n                # randomly pick whether to use in-distribution text\n                if np.random.rand() < 0.5:\n                    use_ind = True\n                else:\n                    use_ind = False\n\n                if use_ind:\n                    ref_lengths = input_lengths\n                    ref_texts = texts\n                    \n                slm_out = slmadv(i, \n                                 y_rec_gt, \n                                 y_rec_gt_pred, \n                                 waves, \n                                 mel_input_length,\n                                 ref_texts, \n                                 ref_lengths, use_ind, s_trg.detach(), ref if multispeaker else None)\n\n                if slm_out is not None:\n                    d_loss_slm, loss_gen_lm, y_pred = slm_out\n\n                    # SLM generator loss\n                    optimizer.zero_grad()\n                    accelerator.backward(loss_gen_lm)\n\n                    # compute the gradient norm\n                    total_norm = {}\n                    for key in model.keys():\n                        total_norm[key] = 0\n                        parameters = [p for p in model[key].parameters() if p.grad is not None and p.requires_grad]\n                        for p in parameters:\n                            param_norm = p.grad.detach().data.norm(2)\n                            total_norm[key] += param_norm.item() ** 2\n                        total_norm[key] = total_norm[key] ** 0.5\n\n                    # gradient scaling\n                    if total_norm['predictor'] > slmadv_params.thresh:\n                        for key in model.keys():\n                            for p in model[key].parameters():\n                                if p.grad is not None:\n                                    p.grad *= (1 / total_norm['predictor'])\n\n                    for p in model.predictor.duration_proj.parameters():\n                        if p.grad is not None:\n                            p.grad *= slmadv_params.scale\n\n                    for p in model.predictor.lstm.parameters():\n                        if p.grad is not None:\n                            p.grad *= slmadv_params.scale\n\n                    for p in model.diffusion.parameters():\n                        if p.grad is not None:\n                            p.grad *= slmadv_params.scale\n                    \n                    optimizer.step('bert_encoder')\n                    optimizer.step('bert')\n                    optimizer.step('predictor')\n                    optimizer.step('diffusion')\n\n                    # SLM discriminator loss\n                    if d_loss_slm != 0:\n                        optimizer.zero_grad()\n                        accelerator.backward(d_loss_slm)\n                        optimizer.step('wd')\n\n            iters = iters + 1\n            \n            if (i+1)%log_interval == 0:\n                logger.info ('Epoch [%d/%d], Step [%d/%d], Loss: %.5f, Disc Loss: %.5f, Dur Loss: %.5f, CE Loss: %.5f, Norm Loss: %.5f, F0 Loss: %.5f, LM Loss: %.5f, Gen Loss: %.5f, Sty Loss: %.5f, Diff Loss: %.5f, DiscLM Loss: %.5f, GenLM Loss: %.5f, SLoss: %.5f, S2S Loss: %.5f, Mono Loss: %.5f'\n                    %(epoch+1, epochs, i+1, len(train_list)//batch_size, running_loss / log_interval, d_loss, loss_dur, loss_ce, loss_norm_rec, loss_F0_rec, loss_lm, loss_gen_all, loss_sty, loss_diff, d_loss_slm, loss_gen_lm, s_loss, loss_s2s, loss_mono))\n                \n                writer.add_scalar('train/mel_loss', running_loss / log_interval, iters)\n                writer.add_scalar('train/gen_loss', loss_gen_all, iters)\n                writer.add_scalar('train/d_loss', d_loss, iters)\n                writer.add_scalar('train/ce_loss', loss_ce, iters)\n                writer.add_scalar('train/dur_loss', loss_dur, iters)\n                writer.add_scalar('train/slm_loss', loss_lm, iters)\n                writer.add_scalar('train/norm_loss', loss_norm_rec, iters)\n                writer.add_scalar('train/F0_loss', loss_F0_rec, iters)\n                writer.add_scalar('train/sty_loss', loss_sty, iters)\n                writer.add_scalar('train/diff_loss', loss_diff, iters)\n                writer.add_scalar('train/d_loss_slm', d_loss_slm, iters)\n                writer.add_scalar('train/gen_loss_slm', loss_gen_lm, iters)\n                \n                running_loss = 0\n                \n                print('Time elasped:', time.time()-start_time)\n            \n        loss_test = 0\n        loss_align = 0\n        loss_f = 0\n        _ = [model[key].eval() for key in model]\n\n        with torch.no_grad():\n            iters_test = 0\n            for batch_idx, batch in enumerate(val_dataloader):\n                optimizer.zero_grad()\n\n                try:\n                    waves = batch[0]\n                    batch = [b.to(device) for b in batch[1:]]\n                    texts, input_lengths, ref_texts, ref_lengths, mels, mel_input_length, ref_mels = batch\n                    with torch.no_grad():\n                        mask = length_to_mask(mel_input_length // (2 ** n_down)).to('cuda')\n                        text_mask = length_to_mask(input_lengths).to(texts.device)\n\n                        _, _, s2s_attn = model.text_aligner(mels, mask, texts)\n                        s2s_attn = s2s_attn.transpose(-1, -2)\n                        s2s_attn = s2s_attn[..., 1:]\n                        s2s_attn = s2s_attn.transpose(-1, -2)\n\n                        mask_ST = mask_from_lens(s2s_attn, input_lengths, mel_input_length // (2 ** n_down))\n                        s2s_attn_mono = maximum_path(s2s_attn, mask_ST)\n\n                        # encode\n                        t_en = model.text_encoder(texts, input_lengths, text_mask)\n                        asr = (t_en @ s2s_attn_mono)\n\n                        d_gt = s2s_attn_mono.sum(axis=-1).detach()\n\n                    ss = []\n                    gs = []\n\n                    for bib in range(len(mel_input_length)):\n                        mel_length = int(mel_input_length[bib].item())\n                        mel = mels[bib, :, :mel_input_length[bib]]\n                        s = model.predictor_encoder(mel.unsqueeze(0).unsqueeze(1))\n                        ss.append(s)\n                        s = model.style_encoder(mel.unsqueeze(0).unsqueeze(1))\n                        gs.append(s)\n\n                    s = torch.stack(ss).squeeze()\n                    gs = torch.stack(gs).squeeze()\n                    s_trg = torch.cat([s, gs], dim=-1).detach()\n\n                    bert_dur = model.bert(texts, attention_mask=(~text_mask).int())\n                    d_en = model.bert_encoder(bert_dur).transpose(-1, -2) \n                    d, p = model.predictor(d_en, s, \n                                                        input_lengths, \n                                                        s2s_attn_mono, \n                                                        text_mask)\n                    # get clips\n                    mel_len = int(mel_input_length.min().item() / 2 - 1)\n                    en = []\n                    gt = []\n\n                    p_en = []\n                    wav = []\n\n                    for bib in range(len(mel_input_length)):\n                        mel_length = int(mel_input_length[bib].item() / 2)\n\n                        random_start = np.random.randint(0, mel_length - mel_len)\n                        en.append(asr[bib, :, random_start:random_start+mel_len])\n                        p_en.append(p[bib, :, random_start:random_start+mel_len])\n\n                        gt.append(mels[bib, :, (random_start * 2):((random_start+mel_len) * 2)])\n                        y = waves[bib][(random_start * 2) * 300:((random_start+mel_len) * 2) * 300]\n                        wav.append(torch.from_numpy(y).to(device))\n\n                    wav = torch.stack(wav).float().detach()\n\n                    en = torch.stack(en)\n                    p_en = torch.stack(p_en)\n                    gt = torch.stack(gt).detach()\n                    s = model.predictor_encoder(gt.unsqueeze(1))\n\n                    F0_fake, N_fake = model.predictor.F0Ntrain(p_en, s)\n\n                    loss_dur = 0\n                    for _s2s_pred, _text_input, _text_length in zip(d, (d_gt), input_lengths):\n                        _s2s_pred = _s2s_pred[:_text_length, :]\n                        _text_input = _text_input[:_text_length].long()\n                        _s2s_trg = torch.zeros_like(_s2s_pred)\n                        for bib in range(_s2s_trg.shape[0]):\n                            _s2s_trg[bib, :_text_input[bib]] = 1\n                        _dur_pred = torch.sigmoid(_s2s_pred).sum(axis=1)\n                        loss_dur += F.l1_loss(_dur_pred[1:_text_length-1], \n                                               _text_input[1:_text_length-1])\n\n                    loss_dur /= texts.size(0)\n\n                    s = model.style_encoder(gt.unsqueeze(1))\n\n                    y_rec = model.decoder(en, F0_fake, N_fake, s)\n                    loss_mel = stft_loss(y_rec.squeeze(), wav.detach())\n\n                    F0_real, _, F0 = model.pitch_extractor(gt.unsqueeze(1)) \n\n                    loss_F0 = F.l1_loss(F0_real, F0_fake) / 10\n\n                    loss_test += (loss_mel).mean()\n                    loss_align += (loss_dur).mean()\n                    loss_f += (loss_F0).mean()\n\n                    iters_test += 1\n                except:\n                    continue\n\n        print('Epochs:', epoch + 1)\n        logger.info('Validation loss: %.3f, Dur loss: %.3f, F0 loss: %.3f' % (loss_test / iters_test, loss_align / iters_test, loss_f / iters_test) + '\\n\\n\\n')\n        print('\\n\\n\\n')\n        writer.add_scalar('eval/mel_loss', loss_test / iters_test, epoch + 1)\n        writer.add_scalar('eval/dur_loss', loss_test / iters_test, epoch + 1)\n        writer.add_scalar('eval/F0_loss', loss_f / iters_test, epoch + 1)\n        \n        \n        if (epoch + 1) % save_freq == 0 :\n            if (loss_test / iters_test) < best_loss:\n                best_loss = loss_test / iters_test\n            print('Saving..')\n            state = {\n                'net':  {key: model[key].state_dict() for key in model}, \n                'optimizer': optimizer.state_dict(),\n                'iters': iters,\n                'val_loss': loss_test / iters_test,\n                'epoch': epoch,\n            }\n            save_path = osp.join(log_dir, 'epoch_2nd_%05d.pth' % epoch)\n            torch.save(state, save_path)\n\n            # if estimate sigma, save the estimated simga\n            if model_params.diffusion.dist.estimate_sigma_data:\n                config['model_params']['diffusion']['dist']['sigma_data'] = float(np.mean(running_std))\n\n                with open(osp.join(log_dir, osp.basename(config_path)), 'w') as outfile:\n                    yaml.dump(config, outfile, default_flow_style=True)\n\n                            \nif __name__==\"__main__\":\n    main()\n"
        },
        {
          "name": "train_first.py",
          "type": "blob",
          "size": 17.7978515625,
          "content": "import os\nimport os.path as osp\nimport re\nimport sys\nimport yaml\nimport shutil\nimport numpy as np\nimport torch\nimport click\nimport warnings\nwarnings.simplefilter('ignore')\n\n# load packages\nimport random\nimport yaml\nfrom munch import Munch\nimport numpy as np\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nimport torchaudio\nimport librosa\n\nfrom models import *\nfrom meldataset import build_dataloader\nfrom utils import *\nfrom losses import *\nfrom optimizers import build_optimizer\nimport time\n\nfrom accelerate import Accelerator\nfrom accelerate.utils import LoggerType\nfrom accelerate import DistributedDataParallelKwargs\n\nfrom torch.utils.tensorboard import SummaryWriter\n\nimport logging\nfrom accelerate.logging import get_logger\nlogger = get_logger(__name__, log_level=\"DEBUG\")\n\n@click.command()\n@click.option('-p', '--config_path', default='Configs/config.yml', type=str)\ndef main(config_path):\n    config = yaml.safe_load(open(config_path))\n\n    log_dir = config['log_dir']\n    if not osp.exists(log_dir): os.makedirs(log_dir, exist_ok=True)\n    shutil.copy(config_path, osp.join(log_dir, osp.basename(config_path)))\n    ddp_kwargs = DistributedDataParallelKwargs(find_unused_parameters=True)\n    accelerator = Accelerator(project_dir=log_dir, split_batches=True, kwargs_handlers=[ddp_kwargs])    \n    if accelerator.is_main_process:\n        writer = SummaryWriter(log_dir + \"/tensorboard\")\n\n    # write logs\n    file_handler = logging.FileHandler(osp.join(log_dir, 'train.log'))\n    file_handler.setLevel(logging.DEBUG)\n    file_handler.setFormatter(logging.Formatter('%(levelname)s:%(asctime)s: %(message)s'))\n    logger.logger.addHandler(file_handler)\n    \n    batch_size = config.get('batch_size', 10)\n    device = accelerator.device\n    \n    epochs = config.get('epochs_1st', 200)\n    save_freq = config.get('save_freq', 2)\n    log_interval = config.get('log_interval', 10)\n    saving_epoch = config.get('save_freq', 2)\n    \n    data_params = config.get('data_params', None)\n    sr = config['preprocess_params'].get('sr', 24000)\n    train_path = data_params['train_data']\n    val_path = data_params['val_data']\n    root_path = data_params['root_path']\n    min_length = data_params['min_length']\n    OOD_data = data_params['OOD_data']\n    \n    max_len = config.get('max_len', 200)\n    \n    # load data\n    train_list, val_list = get_data_path_list(train_path, val_path)\n\n    train_dataloader = build_dataloader(train_list,\n                                        root_path,\n                                        OOD_data=OOD_data,\n                                        min_length=min_length,\n                                        batch_size=batch_size,\n                                        num_workers=2,\n                                        dataset_config={},\n                                        device=device)\n\n    val_dataloader = build_dataloader(val_list,\n                                      root_path,\n                                      OOD_data=OOD_data,\n                                      min_length=min_length,\n                                      batch_size=batch_size,\n                                      validation=True,\n                                      num_workers=0,\n                                      device=device,\n                                      dataset_config={})\n    \n    with accelerator.main_process_first():\n        # load pretrained ASR model\n        ASR_config = config.get('ASR_config', False)\n        ASR_path = config.get('ASR_path', False)\n        text_aligner = load_ASR_models(ASR_path, ASR_config)\n\n        # load pretrained F0 model\n        F0_path = config.get('F0_path', False)\n        pitch_extractor = load_F0_models(F0_path)\n\n        # load BERT model\n        from Utils.PLBERT.util import load_plbert\n        BERT_path = config.get('PLBERT_dir', False)\n        plbert = load_plbert(BERT_path)\n\n    scheduler_params = {\n        \"max_lr\": float(config['optimizer_params'].get('lr', 1e-4)),\n        \"pct_start\": float(config['optimizer_params'].get('pct_start', 0.0)),\n        \"epochs\": epochs,\n        \"steps_per_epoch\": len(train_dataloader),\n    }\n    \n    model_params = recursive_munch(config['model_params'])\n    multispeaker = model_params.multispeaker\n    model = build_model(model_params, text_aligner, pitch_extractor, plbert)\n\n    best_loss = float('inf')  # best test loss\n    loss_train_record = list([])\n    loss_test_record = list([])\n\n    loss_params = Munch(config['loss_params'])\n    TMA_epoch = loss_params.TMA_epoch\n    \n    for k in model:\n        model[k] = accelerator.prepare(model[k])\n    \n    train_dataloader, val_dataloader = accelerator.prepare(\n        train_dataloader, val_dataloader\n    )\n    \n    _ = [model[key].to(device) for key in model]\n\n    # initialize optimizers after preparing models for compatibility with FSDP\n    optimizer = build_optimizer({key: model[key].parameters() for key in model},\n                                  scheduler_params_dict= {key: scheduler_params.copy() for key in model},\n                               lr=float(config['optimizer_params'].get('lr', 1e-4)))\n    \n    for k, v in optimizer.optimizers.items():\n        optimizer.optimizers[k] = accelerator.prepare(optimizer.optimizers[k])\n        optimizer.schedulers[k] = accelerator.prepare(optimizer.schedulers[k])\n    \n    with accelerator.main_process_first():\n        if config.get('pretrained_model', '') != '':\n            model, optimizer, start_epoch, iters = load_checkpoint(model,  optimizer, config['pretrained_model'],\n                                        load_only_params=config.get('load_only_params', True))\n        else:\n            start_epoch = 0\n            iters = 0\n    \n    # in case not distributed\n    try:\n        n_down = model.text_aligner.module.n_down\n    except:\n        n_down = model.text_aligner.n_down\n    \n    # wrapped losses for compatibility with mixed precision\n    stft_loss = MultiResolutionSTFTLoss().to(device)\n    gl = GeneratorLoss(model.mpd, model.msd).to(device)\n    dl = DiscriminatorLoss(model.mpd, model.msd).to(device)\n    wl = WavLMLoss(model_params.slm.model, \n                   model.wd, \n                   sr, \n                   model_params.slm.sr).to(device)\n\n    for epoch in range(start_epoch, epochs):\n        running_loss = 0\n        start_time = time.time()\n\n        _ = [model[key].train() for key in model]\n\n        for i, batch in enumerate(train_dataloader):\n            waves = batch[0]\n            batch = [b.to(device) for b in batch[1:]]\n            texts, input_lengths, _, _, mels, mel_input_length, _ = batch\n            \n            with torch.no_grad():\n                mask = length_to_mask(mel_input_length // (2 ** n_down)).to('cuda')\n                text_mask = length_to_mask(input_lengths).to(texts.device)\n\n            ppgs, s2s_pred, s2s_attn = model.text_aligner(mels, mask, texts)\n\n            s2s_attn = s2s_attn.transpose(-1, -2)\n            s2s_attn = s2s_attn[..., 1:]\n            s2s_attn = s2s_attn.transpose(-1, -2)\n\n            with torch.no_grad():\n                attn_mask = (~mask).unsqueeze(-1).expand(mask.shape[0], mask.shape[1], text_mask.shape[-1]).float().transpose(-1, -2)\n                attn_mask = attn_mask.float() * (~text_mask).unsqueeze(-1).expand(text_mask.shape[0], text_mask.shape[1], mask.shape[-1]).float()\n                attn_mask = (attn_mask < 1)\n\n            s2s_attn.masked_fill_(attn_mask, 0.0)\n                        \n            with torch.no_grad():\n                mask_ST = mask_from_lens(s2s_attn, input_lengths, mel_input_length // (2 ** n_down))\n                s2s_attn_mono = maximum_path(s2s_attn, mask_ST)\n\n            # encode\n            t_en = model.text_encoder(texts, input_lengths, text_mask)\n\n            # 50% of chance of using monotonic version\n            if bool(random.getrandbits(1)):\n                asr = (t_en @ s2s_attn)\n            else:\n                asr = (t_en @ s2s_attn_mono)\n    \n            # get clips\n            mel_input_length_all = accelerator.gather(mel_input_length) # for balanced load\n            mel_len = min([int(mel_input_length_all.min().item() / 2 - 1), max_len // 2])\n            mel_len_st = int(mel_input_length.min().item() / 2 - 1)\n        \n            en = []\n            gt = []\n            wav = []\n            st = []\n            \n            for bib in range(len(mel_input_length)):\n                mel_length = int(mel_input_length[bib].item() / 2)\n\n                random_start = np.random.randint(0, mel_length - mel_len)\n                en.append(asr[bib, :, random_start:random_start+mel_len])\n                gt.append(mels[bib, :, (random_start * 2):((random_start+mel_len) * 2)])\n\n                y = waves[bib][(random_start * 2) * 300:((random_start+mel_len) * 2) * 300]\n                wav.append(torch.from_numpy(y).to(device))\n                \n                # style reference (better to be different from the GT)\n                random_start = np.random.randint(0, mel_length - mel_len_st)\n                st.append(mels[bib, :, (random_start * 2):((random_start+mel_len_st) * 2)])\n\n            en = torch.stack(en)\n            gt = torch.stack(gt).detach()\n            st = torch.stack(st).detach()\n\n            wav = torch.stack(wav).float().detach()\n\n            # clip too short to be used by the style encoder\n            if gt.shape[-1] < 80:\n                continue\n                \n            with torch.no_grad():    \n                real_norm = log_norm(gt.unsqueeze(1)).squeeze(1).detach()\n                F0_real, _, _ = model.pitch_extractor(gt.unsqueeze(1))\n                \n            s = model.style_encoder(st.unsqueeze(1) if multispeaker else gt.unsqueeze(1))\n            \n            y_rec = model.decoder(en, F0_real, real_norm, s)\n            \n            # discriminator loss\n            \n            if epoch >= TMA_epoch:\n                optimizer.zero_grad()\n                d_loss = dl(wav.detach().unsqueeze(1).float(), y_rec.detach()).mean()\n                accelerator.backward(d_loss)\n                optimizer.step('msd')\n                optimizer.step('mpd')\n            else:\n                d_loss = 0\n\n            # generator loss\n            optimizer.zero_grad()\n            loss_mel = stft_loss(y_rec.squeeze(), wav.detach())\n            \n            if epoch >= TMA_epoch: # start TMA training\n                loss_s2s = 0\n                for _s2s_pred, _text_input, _text_length in zip(s2s_pred, texts, input_lengths):\n                    loss_s2s += F.cross_entropy(_s2s_pred[:_text_length], _text_input[:_text_length])\n                loss_s2s /= texts.size(0)\n\n                loss_mono = F.l1_loss(s2s_attn, s2s_attn_mono) * 10\n                    \n                loss_gen_all = gl(wav.detach().unsqueeze(1).float(), y_rec).mean()\n                loss_slm = wl(wav.detach(), y_rec).mean()\n                \n                g_loss = loss_params.lambda_mel * loss_mel + \\\n                loss_params.lambda_mono * loss_mono + \\\n                loss_params.lambda_s2s * loss_s2s + \\\n                loss_params.lambda_gen * loss_gen_all + \\\n                loss_params.lambda_slm * loss_slm\n\n            else:\n                loss_s2s = 0\n                loss_mono = 0\n                loss_gen_all = 0\n                loss_slm = 0\n                g_loss = loss_mel\n            \n            running_loss += accelerator.gather(loss_mel).mean().item()\n\n            accelerator.backward(g_loss)\n            \n            optimizer.step('text_encoder')\n            optimizer.step('style_encoder')\n            optimizer.step('decoder')\n            \n            if epoch >= TMA_epoch: \n                optimizer.step('text_aligner')\n                optimizer.step('pitch_extractor')\n            \n            iters = iters + 1\n            \n            if (i+1)%log_interval == 0 and accelerator.is_main_process:\n                log_print ('Epoch [%d/%d], Step [%d/%d], Mel Loss: %.5f, Gen Loss: %.5f, Disc Loss: %.5f, Mono Loss: %.5f, S2S Loss: %.5f, SLM Loss: %.5f'\n                        %(epoch+1, epochs, i+1, len(train_list)//batch_size, running_loss / log_interval, loss_gen_all, d_loss, loss_mono, loss_s2s, loss_slm), logger)\n                \n                writer.add_scalar('train/mel_loss', running_loss / log_interval, iters)\n                writer.add_scalar('train/gen_loss', loss_gen_all, iters)\n                writer.add_scalar('train/d_loss', d_loss, iters)\n                writer.add_scalar('train/mono_loss', loss_mono, iters)\n                writer.add_scalar('train/s2s_loss', loss_s2s, iters)\n                writer.add_scalar('train/slm_loss', loss_slm, iters)\n\n                running_loss = 0\n                \n                print('Time elasped:', time.time()-start_time)\n                                \n        loss_test = 0\n\n        _ = [model[key].eval() for key in model]\n\n        with torch.no_grad():\n            iters_test = 0\n            for batch_idx, batch in enumerate(val_dataloader):\n                optimizer.zero_grad()\n\n                waves = batch[0]\n                batch = [b.to(device) for b in batch[1:]]\n                texts, input_lengths, _, _, mels, mel_input_length, _ = batch\n\n                with torch.no_grad():\n                    mask = length_to_mask(mel_input_length // (2 ** n_down)).to('cuda')\n                    ppgs, s2s_pred, s2s_attn = model.text_aligner(mels, mask, texts)\n\n                    s2s_attn = s2s_attn.transpose(-1, -2)\n                    s2s_attn = s2s_attn[..., 1:]\n                    s2s_attn = s2s_attn.transpose(-1, -2)\n\n                    text_mask = length_to_mask(input_lengths).to(texts.device)\n                    attn_mask = (~mask).unsqueeze(-1).expand(mask.shape[0], mask.shape[1], text_mask.shape[-1]).float().transpose(-1, -2)\n                    attn_mask = attn_mask.float() * (~text_mask).unsqueeze(-1).expand(text_mask.shape[0], text_mask.shape[1], mask.shape[-1]).float()\n                    attn_mask = (attn_mask < 1)\n                    s2s_attn.masked_fill_(attn_mask, 0.0)\n\n                # encode\n                t_en = model.text_encoder(texts, input_lengths, text_mask)\n                \n                asr = (t_en @ s2s_attn)\n\n                # get clips\n                mel_input_length_all = accelerator.gather(mel_input_length) # for balanced load\n                mel_len = min([int(mel_input_length.min().item() / 2 - 1), max_len // 2])\n                \n                en = []\n                gt = []\n                wav = []\n                for bib in range(len(mel_input_length)):\n                    mel_length = int(mel_input_length[bib].item() / 2)\n\n                    random_start = np.random.randint(0, mel_length - mel_len)\n                    en.append(asr[bib, :, random_start:random_start+mel_len])\n                    gt.append(mels[bib, :, (random_start * 2):((random_start+mel_len) * 2)])\n                    y = waves[bib][(random_start * 2) * 300:((random_start+mel_len) * 2) * 300]\n                    wav.append(torch.from_numpy(y).to('cuda'))\n\n                wav = torch.stack(wav).float().detach()\n\n                en = torch.stack(en)\n                gt = torch.stack(gt).detach()\n\n                F0_real, _, F0 = model.pitch_extractor(gt.unsqueeze(1))\n                s = model.style_encoder(gt.unsqueeze(1))\n                real_norm = log_norm(gt.unsqueeze(1)).squeeze(1)\n                y_rec = model.decoder(en, F0_real, real_norm, s)\n\n                loss_mel = stft_loss(y_rec.squeeze(), wav.detach())\n\n                loss_test += accelerator.gather(loss_mel).mean().item()\n                iters_test += 1\n\n        if accelerator.is_main_process:\n            print('Epochs:', epoch + 1)\n            log_print('Validation loss: %.3f' % (loss_test / iters_test) + '\\n\\n\\n\\n', logger)\n            print('\\n\\n\\n')\n            writer.add_scalar('eval/mel_loss', loss_test / iters_test, epoch + 1)\n            attn_image = get_image(s2s_attn[0].cpu().numpy().squeeze())\n            writer.add_figure('eval/attn', attn_image, epoch)\n            \n            with torch.no_grad():\n                for bib in range(len(asr)):\n                    mel_length = int(mel_input_length[bib].item())\n                    gt = mels[bib, :, :mel_length].unsqueeze(0)\n                    en = asr[bib, :, :mel_length // 2].unsqueeze(0)\n                                        \n                    F0_real, _, _ = model.pitch_extractor(gt.unsqueeze(1))\n                    F0_real = F0_real.unsqueeze(0)\n                    s = model.style_encoder(gt.unsqueeze(1))\n                    real_norm = log_norm(gt.unsqueeze(1)).squeeze(1)\n                    \n                    y_rec = model.decoder(en, F0_real, real_norm, s)\n                    \n                    writer.add_audio('eval/y' + str(bib), y_rec.cpu().numpy().squeeze(), epoch, sample_rate=sr)\n                    if epoch == 0:\n                        writer.add_audio('gt/y' + str(bib), waves[bib].squeeze(), epoch, sample_rate=sr)\n                    \n                    if bib >= 6:\n                        break\n\n            if epoch % saving_epoch == 0:\n                if (loss_test / iters_test) < best_loss:\n                    best_loss = loss_test / iters_test\n                print('Saving..')\n                state = {\n                    'net':  {key: model[key].state_dict() for key in model}, \n                    'optimizer': optimizer.state_dict(),\n                    'iters': iters,\n                    'val_loss': loss_test / iters_test,\n                    'epoch': epoch,\n                }\n                save_path = osp.join(log_dir, 'epoch_1st_%05d.pth' % epoch)\n                torch.save(state, save_path)\n                                \n    if accelerator.is_main_process:\n        print('Saving..')\n        state = {\n            'net':  {key: model[key].state_dict() for key in model}, \n            'optimizer': optimizer.state_dict(),\n            'iters': iters,\n            'val_loss': loss_test / iters_test,\n            'epoch': epoch,\n        }\n        save_path = osp.join(log_dir, config.get('first_stage_path', 'first_stage.pth'))\n        torch.save(state, save_path)\n\n        \n    \nif __name__==\"__main__\":\n    main()\n"
        },
        {
          "name": "train_second.py",
          "type": "blob",
          "size": 33.1962890625,
          "content": "# load packages\nimport random\nimport yaml\nimport time\nfrom munch import Munch\nimport numpy as np\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nimport torchaudio\nimport librosa\nimport click\nimport shutil\nimport traceback\nimport warnings\nwarnings.simplefilter('ignore')\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom meldataset import build_dataloader\n\nfrom Utils.ASR.models import ASRCNN\nfrom Utils.JDC.model import JDCNet\nfrom Utils.PLBERT.util import load_plbert\n\nfrom models import *\nfrom losses import *\nfrom utils import *\n\nfrom Modules.slmadv import SLMAdversarialLoss\nfrom Modules.diffusion.sampler import DiffusionSampler, ADPM2Sampler, KarrasSchedule\n\nfrom optimizers import build_optimizer\n\n# simple fix for dataparallel that allows access to class attributes\nclass MyDataParallel(torch.nn.DataParallel):\n    def __getattr__(self, name):\n        try:\n            return super().__getattr__(name)\n        except AttributeError:\n            return getattr(self.module, name)\n        \nimport logging\nfrom logging import StreamHandler\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nhandler = StreamHandler()\nhandler.setLevel(logging.DEBUG)\nlogger.addHandler(handler)\n\n\n@click.command()\n@click.option('-p', '--config_path', default='Configs/config.yml', type=str)\ndef main(config_path):\n    config = yaml.safe_load(open(config_path))\n    \n    log_dir = config['log_dir']\n    if not osp.exists(log_dir): os.makedirs(log_dir, exist_ok=True)\n    shutil.copy(config_path, osp.join(log_dir, osp.basename(config_path)))\n    writer = SummaryWriter(log_dir + \"/tensorboard\")\n\n    # write logs\n    file_handler = logging.FileHandler(osp.join(log_dir, 'train.log'))\n    file_handler.setLevel(logging.DEBUG)\n    file_handler.setFormatter(logging.Formatter('%(levelname)s:%(asctime)s: %(message)s'))\n    logger.addHandler(file_handler)\n\n    \n    batch_size = config.get('batch_size', 10)\n\n    epochs = config.get('epochs_2nd', 200)\n    save_freq = config.get('save_freq', 2)\n    log_interval = config.get('log_interval', 10)\n    saving_epoch = config.get('save_freq', 2)\n\n    data_params = config.get('data_params', None)\n    sr = config['preprocess_params'].get('sr', 24000)\n    train_path = data_params['train_data']\n    val_path = data_params['val_data']\n    root_path = data_params['root_path']\n    min_length = data_params['min_length']\n    OOD_data = data_params['OOD_data']\n\n    max_len = config.get('max_len', 200)\n    \n    loss_params = Munch(config['loss_params'])\n    diff_epoch = loss_params.diff_epoch\n    joint_epoch = loss_params.joint_epoch\n    \n    optimizer_params = Munch(config['optimizer_params'])\n    \n    train_list, val_list = get_data_path_list(train_path, val_path)\n    device = 'cuda'\n\n    train_dataloader = build_dataloader(train_list,\n                                        root_path,\n                                        OOD_data=OOD_data,\n                                        min_length=min_length,\n                                        batch_size=batch_size,\n                                        num_workers=2,\n                                        dataset_config={},\n                                        device=device)\n\n    val_dataloader = build_dataloader(val_list,\n                                      root_path,\n                                      OOD_data=OOD_data,\n                                      min_length=min_length,\n                                      batch_size=batch_size,\n                                      validation=True,\n                                      num_workers=0,\n                                      device=device,\n                                      dataset_config={})\n    \n    # load pretrained ASR model\n    ASR_config = config.get('ASR_config', False)\n    ASR_path = config.get('ASR_path', False)\n    text_aligner = load_ASR_models(ASR_path, ASR_config)\n    \n    # load pretrained F0 model\n    F0_path = config.get('F0_path', False)\n    pitch_extractor = load_F0_models(F0_path)\n    \n    # load PL-BERT model\n    BERT_path = config.get('PLBERT_dir', False)\n    plbert = load_plbert(BERT_path)\n    \n    # build model\n    model_params = recursive_munch(config['model_params'])\n    multispeaker = model_params.multispeaker\n    model = build_model(model_params, text_aligner, pitch_extractor, plbert)\n    _ = [model[key].to(device) for key in model]\n    \n    # DP\n    for key in model:\n        if key != \"mpd\" and key != \"msd\" and key != \"wd\":\n            model[key] = MyDataParallel(model[key])\n            \n    start_epoch = 0\n    iters = 0\n\n    load_pretrained = config.get('pretrained_model', '') != '' and config.get('second_stage_load_pretrained', False)\n    \n    if not load_pretrained:\n        if config.get('first_stage_path', '') != '':\n            first_stage_path = osp.join(log_dir, config.get('first_stage_path', 'first_stage.pth'))\n            print('Loading the first stage model at %s ...' % first_stage_path)\n            model, _, start_epoch, iters = load_checkpoint(model, \n                None, \n                first_stage_path,\n                load_only_params=True,\n                ignore_modules=['bert', 'bert_encoder', 'predictor', 'predictor_encoder', 'msd', 'mpd', 'wd', 'diffusion']) # keep starting epoch for tensorboard log\n\n            # these epochs should be counted from the start epoch\n            diff_epoch += start_epoch\n            joint_epoch += start_epoch\n            epochs += start_epoch\n            \n            model.predictor_encoder = copy.deepcopy(model.style_encoder)\n        else:\n            raise ValueError('You need to specify the path to the first stage model.') \n\n    gl = GeneratorLoss(model.mpd, model.msd).to(device)\n    dl = DiscriminatorLoss(model.mpd, model.msd).to(device)\n    wl = WavLMLoss(model_params.slm.model, \n                   model.wd, \n                   sr, \n                   model_params.slm.sr).to(device)\n\n    gl = MyDataParallel(gl)\n    dl = MyDataParallel(dl)\n    wl = MyDataParallel(wl)\n    \n    sampler = DiffusionSampler(\n        model.diffusion.diffusion,\n        sampler=ADPM2Sampler(),\n        sigma_schedule=KarrasSchedule(sigma_min=0.0001, sigma_max=3.0, rho=9.0), # empirical parameters\n        clamp=False\n    )\n    \n    scheduler_params = {\n        \"max_lr\": optimizer_params.lr,\n        \"pct_start\": float(0),\n        \"epochs\": epochs,\n        \"steps_per_epoch\": len(train_dataloader),\n    }\n    scheduler_params_dict= {key: scheduler_params.copy() for key in model}\n    scheduler_params_dict['bert']['max_lr'] = optimizer_params.bert_lr * 2\n    scheduler_params_dict['decoder']['max_lr'] = optimizer_params.ft_lr * 2\n    scheduler_params_dict['style_encoder']['max_lr'] = optimizer_params.ft_lr * 2\n    \n    optimizer = build_optimizer({key: model[key].parameters() for key in model},\n                                          scheduler_params_dict=scheduler_params_dict, lr=optimizer_params.lr)\n    \n    # adjust BERT learning rate\n    for g in optimizer.optimizers['bert'].param_groups:\n        g['betas'] = (0.9, 0.99)\n        g['lr'] = optimizer_params.bert_lr\n        g['initial_lr'] = optimizer_params.bert_lr\n        g['min_lr'] = 0\n        g['weight_decay'] = 0.01\n        \n    # adjust acoustic module learning rate\n    for module in [\"decoder\", \"style_encoder\"]:\n        for g in optimizer.optimizers[module].param_groups:\n            g['betas'] = (0.0, 0.99)\n            g['lr'] = optimizer_params.ft_lr\n            g['initial_lr'] = optimizer_params.ft_lr\n            g['min_lr'] = 0\n            g['weight_decay'] = 1e-4\n        \n    # load models if there is a model\n    if load_pretrained:\n        model, optimizer, start_epoch, iters = load_checkpoint(model,  optimizer, config['pretrained_model'],\n                                    load_only_params=config.get('load_only_params', True))\n        \n    n_down = model.text_aligner.n_down\n\n    best_loss = float('inf')  # best test loss\n    loss_train_record = list([])\n    loss_test_record = list([])\n    iters = 0\n    \n    criterion = nn.L1Loss() # F0 loss (regression)\n    torch.cuda.empty_cache()\n    \n    stft_loss = MultiResolutionSTFTLoss().to(device)\n    \n    print('BERT', optimizer.optimizers['bert'])\n    print('decoder', optimizer.optimizers['decoder'])\n\n    start_ds = False\n    \n    running_std = []\n    \n    slmadv_params = Munch(config['slmadv_params'])\n    slmadv = SLMAdversarialLoss(model, wl, sampler, \n                                slmadv_params.min_len, \n                                slmadv_params.max_len,\n                                batch_percentage=slmadv_params.batch_percentage,\n                                skip_update=slmadv_params.iter, \n                                sig=slmadv_params.sig\n                               )\n\n\n    for epoch in range(start_epoch, epochs):\n        running_loss = 0\n        start_time = time.time()\n\n        _ = [model[key].eval() for key in model]\n\n        model.predictor.train()\n        model.bert_encoder.train()\n        model.bert.train()\n        model.msd.train()\n        model.mpd.train()\n\n\n        if epoch >= diff_epoch:\n            start_ds = True\n\n        for i, batch in enumerate(train_dataloader):\n            waves = batch[0]\n            batch = [b.to(device) for b in batch[1:]]\n            texts, input_lengths, ref_texts, ref_lengths, mels, mel_input_length, ref_mels = batch\n\n            with torch.no_grad():\n                mask = length_to_mask(mel_input_length // (2 ** n_down)).to(device)\n                mel_mask = length_to_mask(mel_input_length).to(device)\n                text_mask = length_to_mask(input_lengths).to(texts.device)\n\n                try:\n                    _, _, s2s_attn = model.text_aligner(mels, mask, texts)\n                    s2s_attn = s2s_attn.transpose(-1, -2)\n                    s2s_attn = s2s_attn[..., 1:]\n                    s2s_attn = s2s_attn.transpose(-1, -2)\n                except:\n                    continue\n\n                mask_ST = mask_from_lens(s2s_attn, input_lengths, mel_input_length // (2 ** n_down))\n                s2s_attn_mono = maximum_path(s2s_attn, mask_ST)\n\n                # encode\n                t_en = model.text_encoder(texts, input_lengths, text_mask)\n                asr = (t_en @ s2s_attn_mono)\n\n                d_gt = s2s_attn_mono.sum(axis=-1).detach()\n                \n                # compute reference styles\n                if multispeaker and epoch >= diff_epoch:\n                    ref_ss = model.style_encoder(ref_mels.unsqueeze(1))\n                    ref_sp = model.predictor_encoder(ref_mels.unsqueeze(1))\n                    ref = torch.cat([ref_ss, ref_sp], dim=1)\n\n            # compute the style of the entire utterance\n            # this operation cannot be done in batch because of the avgpool layer (may need to work on masked avgpool)\n            ss = []\n            gs = []\n            for bib in range(len(mel_input_length)):\n                mel_length = int(mel_input_length[bib].item())\n                mel = mels[bib, :, :mel_input_length[bib]]\n                s = model.predictor_encoder(mel.unsqueeze(0).unsqueeze(1))\n                ss.append(s)\n                s = model.style_encoder(mel.unsqueeze(0).unsqueeze(1))\n                gs.append(s)\n\n            s_dur = torch.stack(ss).squeeze()  # global prosodic styles\n            gs = torch.stack(gs).squeeze() # global acoustic styles\n            s_trg = torch.cat([gs, s_dur], dim=-1).detach() # ground truth for denoiser\n\n            bert_dur = model.bert(texts, attention_mask=(~text_mask).int())\n            d_en = model.bert_encoder(bert_dur).transpose(-1, -2) \n            \n            # denoiser training\n            if epoch >= diff_epoch:\n                num_steps = np.random.randint(3, 5)\n                \n                if model_params.diffusion.dist.estimate_sigma_data:\n                    model.diffusion.module.diffusion.sigma_data = s_trg.std(axis=-1).mean().item() # batch-wise std estimation\n                    running_std.append(model.diffusion.module.diffusion.sigma_data)\n                    \n                if multispeaker:\n                    s_preds = sampler(noise = torch.randn_like(s_trg).unsqueeze(1).to(device), \n                          embedding=bert_dur,\n                          embedding_scale=1,\n                                   features=ref, # reference from the same speaker as the embedding\n                             embedding_mask_proba=0.1,\n                             num_steps=num_steps).squeeze(1)\n                    loss_diff = model.diffusion(s_trg.unsqueeze(1), embedding=bert_dur, features=ref).mean() # EDM loss\n                    loss_sty = F.l1_loss(s_preds, s_trg.detach()) # style reconstruction loss\n                else:\n                    s_preds = sampler(noise = torch.randn_like(s_trg).unsqueeze(1).to(device), \n                          embedding=bert_dur,\n                          embedding_scale=1,\n                             embedding_mask_proba=0.1,\n                             num_steps=num_steps).squeeze(1)                    \n                    loss_diff = model.diffusion.module.diffusion(s_trg.unsqueeze(1), embedding=bert_dur).mean() # EDM loss\n                    loss_sty = F.l1_loss(s_preds, s_trg.detach()) # style reconstruction loss\n            else:\n                loss_sty = 0\n                loss_diff = 0\n\n            d, p = model.predictor(d_en, s_dur, \n                                                    input_lengths, \n                                                    s2s_attn_mono, \n                                                    text_mask)\n            \n            mel_len = min(int(mel_input_length.min().item() / 2 - 1), max_len // 2)\n            mel_len_st = int(mel_input_length.min().item() / 2 - 1)\n            en = []\n            gt = []\n            st = []\n            p_en = []\n            wav = []\n\n            for bib in range(len(mel_input_length)):\n                mel_length = int(mel_input_length[bib].item() / 2)\n\n                random_start = np.random.randint(0, mel_length - mel_len)\n                en.append(asr[bib, :, random_start:random_start+mel_len])\n                p_en.append(p[bib, :, random_start:random_start+mel_len])\n                gt.append(mels[bib, :, (random_start * 2):((random_start+mel_len) * 2)])\n                \n                y = waves[bib][(random_start * 2) * 300:((random_start+mel_len) * 2) * 300]\n                wav.append(torch.from_numpy(y).to(device))\n\n                # style reference (better to be different from the GT)\n                random_start = np.random.randint(0, mel_length - mel_len_st)\n                st.append(mels[bib, :, (random_start * 2):((random_start+mel_len_st) * 2)])\n                \n            wav = torch.stack(wav).float().detach()\n\n            en = torch.stack(en)\n            p_en = torch.stack(p_en)\n            gt = torch.stack(gt).detach()\n            st = torch.stack(st).detach()\n            \n            if gt.size(-1) < 80:\n                continue\n\n            s_dur = model.predictor_encoder(st.unsqueeze(1) if multispeaker else gt.unsqueeze(1))\n            s = model.style_encoder(st.unsqueeze(1) if multispeaker else gt.unsqueeze(1))\n            \n            with torch.no_grad():\n                F0_real, _, F0 = model.pitch_extractor(gt.unsqueeze(1))\n                F0 = F0.reshape(F0.shape[0], F0.shape[1] * 2, F0.shape[2], 1).squeeze()\n\n                asr_real = model.text_aligner.get_feature(gt)\n\n                N_real = log_norm(gt.unsqueeze(1)).squeeze(1)\n                \n                y_rec_gt = wav.unsqueeze(1)\n                y_rec_gt_pred = model.decoder(en, F0_real, N_real, s)\n\n                if epoch >= joint_epoch:\n                    # ground truth from recording\n                    wav = y_rec_gt # use recording since decoder is tuned\n                else:\n                    # ground truth from reconstruction\n                    wav = y_rec_gt_pred # use reconstruction since decoder is fixed\n\n            F0_fake, N_fake = model.predictor.F0Ntrain(p_en, s_dur)\n\n            y_rec = model.decoder(en, F0_fake, N_fake, s)\n\n            loss_F0_rec =  (F.smooth_l1_loss(F0_real, F0_fake)) / 10\n            loss_norm_rec = F.smooth_l1_loss(N_real, N_fake)\n\n            if start_ds:\n                optimizer.zero_grad()\n                d_loss = dl(wav.detach(), y_rec.detach()).mean()\n                d_loss.backward()\n                optimizer.step('msd')\n                optimizer.step('mpd')\n            else:\n                d_loss = 0\n\n            # generator loss\n            optimizer.zero_grad()\n\n            loss_mel = stft_loss(y_rec, wav)\n            if start_ds:\n                loss_gen_all = gl(wav, y_rec).mean()\n            else:\n                loss_gen_all = 0\n            loss_lm = wl(wav.detach().squeeze(), y_rec.squeeze()).mean()\n\n            loss_ce = 0\n            loss_dur = 0\n            for _s2s_pred, _text_input, _text_length in zip(d, (d_gt), input_lengths):\n                _s2s_pred = _s2s_pred[:_text_length, :]\n                _text_input = _text_input[:_text_length].long()\n                _s2s_trg = torch.zeros_like(_s2s_pred)\n                for p in range(_s2s_trg.shape[0]):\n                    _s2s_trg[p, :_text_input[p]] = 1\n                _dur_pred = torch.sigmoid(_s2s_pred).sum(axis=1)\n\n                loss_dur += F.l1_loss(_dur_pred[1:_text_length-1], \n                                       _text_input[1:_text_length-1])\n                loss_ce += F.binary_cross_entropy_with_logits(_s2s_pred.flatten(), _s2s_trg.flatten())\n\n            loss_ce /= texts.size(0)\n            loss_dur /= texts.size(0)\n\n            g_loss = loss_params.lambda_mel * loss_mel + \\\n                     loss_params.lambda_F0 * loss_F0_rec + \\\n                     loss_params.lambda_ce * loss_ce + \\\n                     loss_params.lambda_norm * loss_norm_rec + \\\n                     loss_params.lambda_dur * loss_dur + \\\n                     loss_params.lambda_gen * loss_gen_all + \\\n                     loss_params.lambda_slm * loss_lm + \\\n                     loss_params.lambda_sty * loss_sty + \\\n                     loss_params.lambda_diff * loss_diff\n\n            running_loss += loss_mel.item()\n            g_loss.backward()\n            if torch.isnan(g_loss):\n                from IPython.core.debugger import set_trace\n                set_trace()\n\n            optimizer.step('bert_encoder')\n            optimizer.step('bert')\n            optimizer.step('predictor')\n            optimizer.step('predictor_encoder')\n            \n            if epoch >= diff_epoch:\n                optimizer.step('diffusion')\n            \n            if epoch >= joint_epoch:\n                optimizer.step('style_encoder')\n                optimizer.step('decoder')\n        \n                # randomly pick whether to use in-distribution text\n                if np.random.rand() < 0.5:\n                    use_ind = True\n                else:\n                    use_ind = False\n\n                if use_ind:\n                    ref_lengths = input_lengths\n                    ref_texts = texts\n                    \n                slm_out = slmadv(i, \n                                 y_rec_gt, \n                                 y_rec_gt_pred, \n                                 waves, \n                                 mel_input_length,\n                                 ref_texts, \n                                 ref_lengths, use_ind, s_trg.detach(), ref if multispeaker else None)\n\n                if slm_out is None:\n                    continue\n                    \n                d_loss_slm, loss_gen_lm, y_pred = slm_out\n                \n                # SLM generator loss\n                optimizer.zero_grad()\n                loss_gen_lm.backward()\n\n                # compute the gradient norm\n                total_norm = {}\n                for key in model.keys():\n                    total_norm[key] = 0\n                    parameters = [p for p in model[key].parameters() if p.grad is not None and p.requires_grad]\n                    for p in parameters:\n                        param_norm = p.grad.detach().data.norm(2)\n                        total_norm[key] += param_norm.item() ** 2\n                    total_norm[key] = total_norm[key] ** 0.5\n\n                # gradient scaling\n                if total_norm['predictor'] > slmadv_params.thresh:\n                    for key in model.keys():\n                        for p in model[key].parameters():\n                            if p.grad is not None:\n                                p.grad *= (1 / total_norm['predictor']) \n\n                for p in model.predictor.duration_proj.parameters():\n                    if p.grad is not None:\n                        p.grad *= slmadv_params.scale\n\n                for p in model.predictor.lstm.parameters():\n                    if p.grad is not None:\n                        p.grad *= slmadv_params.scale\n\n                for p in model.diffusion.parameters():\n                    if p.grad is not None:\n                        p.grad *= slmadv_params.scale\n\n                optimizer.step('bert_encoder')\n                optimizer.step('bert')\n                optimizer.step('predictor')\n                optimizer.step('diffusion')\n\n                # SLM discriminator loss\n                if d_loss_slm != 0:\n                    optimizer.zero_grad()\n                    d_loss_slm.backward(retain_graph=True)\n                    optimizer.step('wd')\n\n            else:\n                d_loss_slm, loss_gen_lm = 0, 0\n                \n            iters = iters + 1\n            \n            if (i+1)%log_interval == 0:\n                logger.info ('Epoch [%d/%d], Step [%d/%d], Loss: %.5f, Disc Loss: %.5f, Dur Loss: %.5f, CE Loss: %.5f, Norm Loss: %.5f, F0 Loss: %.5f, LM Loss: %.5f, Gen Loss: %.5f, Sty Loss: %.5f, Diff Loss: %.5f, DiscLM Loss: %.5f, GenLM Loss: %.5f'\n                    %(epoch+1, epochs, i+1, len(train_list)//batch_size, running_loss / log_interval, d_loss, loss_dur, loss_ce, loss_norm_rec, loss_F0_rec, loss_lm, loss_gen_all, loss_sty, loss_diff, d_loss_slm, loss_gen_lm))\n                \n                writer.add_scalar('train/mel_loss', running_loss / log_interval, iters)\n                writer.add_scalar('train/gen_loss', loss_gen_all, iters)\n                writer.add_scalar('train/d_loss', d_loss, iters)\n                writer.add_scalar('train/ce_loss', loss_ce, iters)\n                writer.add_scalar('train/dur_loss', loss_dur, iters)\n                writer.add_scalar('train/slm_loss', loss_lm, iters)\n                writer.add_scalar('train/norm_loss', loss_norm_rec, iters)\n                writer.add_scalar('train/F0_loss', loss_F0_rec, iters)\n                writer.add_scalar('train/sty_loss', loss_sty, iters)\n                writer.add_scalar('train/diff_loss', loss_diff, iters)\n                writer.add_scalar('train/d_loss_slm', d_loss_slm, iters)\n                writer.add_scalar('train/gen_loss_slm', loss_gen_lm, iters)\n                \n                running_loss = 0\n                \n                print('Time elasped:', time.time()-start_time)\n                \n        loss_test = 0\n        loss_align = 0\n        loss_f = 0\n        _ = [model[key].eval() for key in model]\n\n        with torch.no_grad():\n            iters_test = 0\n            for batch_idx, batch in enumerate(val_dataloader):\n                optimizer.zero_grad()\n                \n                try:\n                    waves = batch[0]\n                    batch = [b.to(device) for b in batch[1:]]\n                    texts, input_lengths, ref_texts, ref_lengths, mels, mel_input_length, ref_mels = batch\n                    with torch.no_grad():\n                        mask = length_to_mask(mel_input_length // (2 ** n_down)).to('cuda')\n                        text_mask = length_to_mask(input_lengths).to(texts.device)\n\n                        _, _, s2s_attn = model.text_aligner(mels, mask, texts)\n                        s2s_attn = s2s_attn.transpose(-1, -2)\n                        s2s_attn = s2s_attn[..., 1:]\n                        s2s_attn = s2s_attn.transpose(-1, -2)\n\n                        mask_ST = mask_from_lens(s2s_attn, input_lengths, mel_input_length // (2 ** n_down))\n                        s2s_attn_mono = maximum_path(s2s_attn, mask_ST)\n\n                        # encode\n                        t_en = model.text_encoder(texts, input_lengths, text_mask)\n                        asr = (t_en @ s2s_attn_mono)\n\n                        d_gt = s2s_attn_mono.sum(axis=-1).detach()\n\n                    ss = []\n                    gs = []\n\n                    for bib in range(len(mel_input_length)):\n                        mel_length = int(mel_input_length[bib].item())\n                        mel = mels[bib, :, :mel_input_length[bib]]\n                        s = model.predictor_encoder(mel.unsqueeze(0).unsqueeze(1))\n                        ss.append(s)\n                        s = model.style_encoder(mel.unsqueeze(0).unsqueeze(1))\n                        gs.append(s)\n\n                    s = torch.stack(ss).squeeze()\n                    gs = torch.stack(gs).squeeze()\n                    s_trg = torch.cat([s, gs], dim=-1).detach()\n\n                    bert_dur = model.bert(texts, attention_mask=(~text_mask).int())\n                    d_en = model.bert_encoder(bert_dur).transpose(-1, -2) \n                    d, p = model.predictor(d_en, s, \n                                                        input_lengths, \n                                                        s2s_attn_mono, \n                                                        text_mask)\n                    # get clips\n                    mel_len = int(mel_input_length.min().item() / 2 - 1)\n                    en = []\n                    gt = []\n                    p_en = []\n                    wav = []\n\n                    for bib in range(len(mel_input_length)):\n                        mel_length = int(mel_input_length[bib].item() / 2)\n\n                        random_start = np.random.randint(0, mel_length - mel_len)\n                        en.append(asr[bib, :, random_start:random_start+mel_len])\n                        p_en.append(p[bib, :, random_start:random_start+mel_len])\n\n                        gt.append(mels[bib, :, (random_start * 2):((random_start+mel_len) * 2)])\n\n                        y = waves[bib][(random_start * 2) * 300:((random_start+mel_len) * 2) * 300]\n                        wav.append(torch.from_numpy(y).to(device))\n\n                    wav = torch.stack(wav).float().detach()\n\n                    en = torch.stack(en)\n                    p_en = torch.stack(p_en)\n                    gt = torch.stack(gt).detach()\n\n                    s = model.predictor_encoder(gt.unsqueeze(1))\n\n                    F0_fake, N_fake = model.predictor.F0Ntrain(p_en, s)\n\n                    loss_dur = 0\n                    for _s2s_pred, _text_input, _text_length in zip(d, (d_gt), input_lengths):\n                        _s2s_pred = _s2s_pred[:_text_length, :]\n                        _text_input = _text_input[:_text_length].long()\n                        _s2s_trg = torch.zeros_like(_s2s_pred)\n                        for bib in range(_s2s_trg.shape[0]):\n                            _s2s_trg[bib, :_text_input[bib]] = 1\n                        _dur_pred = torch.sigmoid(_s2s_pred).sum(axis=1)\n                        loss_dur += F.l1_loss(_dur_pred[1:_text_length-1], \n                                               _text_input[1:_text_length-1])\n\n                    loss_dur /= texts.size(0)\n\n                    s = model.style_encoder(gt.unsqueeze(1))\n\n                    y_rec = model.decoder(en, F0_fake, N_fake, s)\n                    loss_mel = stft_loss(y_rec.squeeze(), wav.detach())\n\n                    F0_real, _, F0 = model.pitch_extractor(gt.unsqueeze(1)) \n\n                    loss_F0 = F.l1_loss(F0_real, F0_fake) / 10\n\n                    loss_test += (loss_mel).mean()\n                    loss_align += (loss_dur).mean()\n                    loss_f += (loss_F0).mean()\n\n                    iters_test += 1\n                except Exception as e:\n                    print(f\"run into exception\", e)\n                    traceback.print_exc()\n                    continue\n\n        print('Epochs:', epoch + 1)\n        logger.info('Validation loss: %.3f, Dur loss: %.3f, F0 loss: %.3f' % (loss_test / iters_test, loss_align / iters_test, loss_f / iters_test) + '\\n\\n\\n')\n        print('\\n\\n\\n')\n        writer.add_scalar('eval/mel_loss', loss_test / iters_test, epoch + 1)\n        writer.add_scalar('eval/dur_loss', loss_align / iters_test, epoch + 1)\n        writer.add_scalar('eval/F0_loss', loss_f / iters_test, epoch + 1)\n        \n        if epoch < joint_epoch:\n            # generating reconstruction examples with GT duration\n            \n            with torch.no_grad():\n                for bib in range(len(asr)):\n                    mel_length = int(mel_input_length[bib].item())\n                    gt = mels[bib, :, :mel_length].unsqueeze(0)\n                    en = asr[bib, :, :mel_length // 2].unsqueeze(0)\n\n                    F0_real, _, _ = model.pitch_extractor(gt.unsqueeze(1))\n                    F0_real = F0_real.unsqueeze(0)\n                    s = model.style_encoder(gt.unsqueeze(1))\n                    real_norm = log_norm(gt.unsqueeze(1)).squeeze(1)\n\n                    y_rec = model.decoder(en, F0_real, real_norm, s)\n\n                    writer.add_audio('eval/y' + str(bib), y_rec.cpu().numpy().squeeze(), epoch, sample_rate=sr)\n\n                    s_dur = model.predictor_encoder(gt.unsqueeze(1))\n                    p_en = p[bib, :, :mel_length // 2].unsqueeze(0)\n\n                    F0_fake, N_fake = model.predictor.F0Ntrain(p_en, s_dur)\n\n                    y_pred = model.decoder(en, F0_fake, N_fake, s)\n\n                    writer.add_audio('pred/y' + str(bib), y_pred.cpu().numpy().squeeze(), epoch, sample_rate=sr)\n\n                    if epoch == 0:\n                        writer.add_audio('gt/y' + str(bib), waves[bib].squeeze(), epoch, sample_rate=sr)\n\n                    if bib >= 5:\n                        break\n        else:\n            # generating sampled speech from text directly\n            with torch.no_grad():\n                # compute reference styles\n                if multispeaker and epoch >= diff_epoch:\n                    ref_ss = model.style_encoder(ref_mels.unsqueeze(1))\n                    ref_sp = model.predictor_encoder(ref_mels.unsqueeze(1))\n                    ref_s = torch.cat([ref_ss, ref_sp], dim=1)\n                    \n                for bib in range(len(d_en)):\n                    if multispeaker:\n                        s_pred = sampler(noise = torch.randn((1, 256)).unsqueeze(1).to(texts.device), \n                              embedding=bert_dur[bib].unsqueeze(0),\n                              embedding_scale=1,\n                                features=ref_s[bib].unsqueeze(0), # reference from the same speaker as the embedding\n                                 num_steps=5).squeeze(1)\n                    else:\n                        s_pred = sampler(noise = torch.randn((1, 256)).unsqueeze(1).to(texts.device), \n                              embedding=bert_dur[bib].unsqueeze(0),\n                              embedding_scale=1,\n                                 num_steps=5).squeeze(1)\n\n                    s = s_pred[:, 128:]\n                    ref = s_pred[:, :128]\n\n                    d = model.predictor.text_encoder(d_en[bib, :, :input_lengths[bib]].unsqueeze(0), \n                                                     s, input_lengths[bib, ...].unsqueeze(0), text_mask[bib, :input_lengths[bib]].unsqueeze(0))\n\n                    x, _ = model.predictor.lstm(d)\n                    duration = model.predictor.duration_proj(x)\n\n                    duration = torch.sigmoid(duration).sum(axis=-1)\n                    pred_dur = torch.round(duration.squeeze()).clamp(min=1)\n\n                    pred_dur[-1] += 5\n\n                    pred_aln_trg = torch.zeros(input_lengths[bib], int(pred_dur.sum().data))\n                    c_frame = 0\n                    for i in range(pred_aln_trg.size(0)):\n                        pred_aln_trg[i, c_frame:c_frame + int(pred_dur[i].data)] = 1\n                        c_frame += int(pred_dur[i].data)\n\n                    # encode prosody\n                    en = (d.transpose(-1, -2) @ pred_aln_trg.unsqueeze(0).to(texts.device))\n                    F0_pred, N_pred = model.predictor.F0Ntrain(en, s)\n                    out = model.decoder((t_en[bib, :, :input_lengths[bib]].unsqueeze(0) @ pred_aln_trg.unsqueeze(0).to(texts.device)), \n                                            F0_pred, N_pred, ref.squeeze().unsqueeze(0))\n\n                    writer.add_audio('pred/y' + str(bib), out.cpu().numpy().squeeze(), epoch, sample_rate=sr)\n\n                    if bib >= 5:\n                        break\n                            \n        if epoch % saving_epoch == 0:\n            if (loss_test / iters_test) < best_loss:\n                best_loss = loss_test / iters_test\n            print('Saving..')\n            state = {\n                'net':  {key: model[key].state_dict() for key in model}, \n                'optimizer': optimizer.state_dict(),\n                'iters': iters,\n                'val_loss': loss_test / iters_test,\n                'epoch': epoch,\n            }\n            save_path = osp.join(log_dir, 'epoch_2nd_%05d.pth' % epoch)\n            torch.save(state, save_path)\n            \n            # if estimate sigma, save the estimated simga\n            if model_params.diffusion.dist.estimate_sigma_data:\n                config['model_params']['diffusion']['dist']['sigma_data'] = float(np.mean(running_std))\n                \n                with open(osp.join(log_dir, osp.basename(config_path)), 'w') as outfile:\n                    yaml.dump(config, outfile, default_flow_style=True)\n        \nif __name__==\"__main__\":\n    main()\n"
        },
        {
          "name": "utils.py",
          "type": "blob",
          "size": 2.1630859375,
          "content": "from monotonic_align import maximum_path\nfrom monotonic_align import mask_from_lens\nfrom monotonic_align.core import maximum_path_c\nimport numpy as np\nimport torch\nimport copy\nfrom torch import nn\nimport torch.nn.functional as F\nimport torchaudio\nimport librosa\nimport matplotlib.pyplot as plt\nfrom munch import Munch\n\ndef maximum_path(neg_cent, mask):\n  \"\"\" Cython optimized version.\n  neg_cent: [b, t_t, t_s]\n  mask: [b, t_t, t_s]\n  \"\"\"\n  device = neg_cent.device\n  dtype = neg_cent.dtype\n  neg_cent =  np.ascontiguousarray(neg_cent.data.cpu().numpy().astype(np.float32))\n  path =  np.ascontiguousarray(np.zeros(neg_cent.shape, dtype=np.int32))\n\n  t_t_max = np.ascontiguousarray(mask.sum(1)[:, 0].data.cpu().numpy().astype(np.int32))\n  t_s_max = np.ascontiguousarray(mask.sum(2)[:, 0].data.cpu().numpy().astype(np.int32))\n  maximum_path_c(path, neg_cent, t_t_max, t_s_max)\n  return torch.from_numpy(path).to(device=device, dtype=dtype)\n\ndef get_data_path_list(train_path=None, val_path=None):\n    if train_path is None:\n        train_path = \"Data/train_list.txt\"\n    if val_path is None:\n        val_path = \"Data/val_list.txt\"\n\n    with open(train_path, 'r', encoding='utf-8', errors='ignore') as f:\n        train_list = f.readlines()\n    with open(val_path, 'r', encoding='utf-8', errors='ignore') as f:\n        val_list = f.readlines()\n\n    return train_list, val_list\n\ndef length_to_mask(lengths):\n    mask = torch.arange(lengths.max()).unsqueeze(0).expand(lengths.shape[0], -1).type_as(lengths)\n    mask = torch.gt(mask+1, lengths.unsqueeze(1))\n    return mask\n\n# for norm consistency loss\ndef log_norm(x, mean=-4, std=4, dim=2):\n    \"\"\"\n    normalized log mel -> mel -> norm -> log(norm)\n    \"\"\"\n    x = torch.log(torch.exp(x * std + mean).norm(dim=dim))\n    return x\n\ndef get_image(arrs):\n    plt.switch_backend('agg')\n    fig = plt.figure()\n    ax = plt.gca()\n    ax.imshow(arrs)\n\n    return fig\n\ndef recursive_munch(d):\n    if isinstance(d, dict):\n        return Munch((k, recursive_munch(v)) for k, v in d.items())\n    elif isinstance(d, list):\n        return [recursive_munch(v) for v in d]\n    else:\n        return d\n    \ndef log_print(message, logger):\n    logger.info(message)\n    print(message)\n    "
        }
      ]
    }
  ]
}