{
  "metadata": {
    "timestamp": 1736560887174,
    "page": 610,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "yahoo/open_nsfw",
      "stars": 5894,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.236328125,
          "content": "\nCopyright 2016, Yahoo Inc.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.6611328125,
          "content": "# Open nsfw model\nThis repo contains code for running Not Suitable for Work (NSFW) classification deep neural network Caffe models. Please refer our [blog](https://yahooeng.tumblr.com/post/151148689421/open-sourcing-a-deep-learning-solution-for) post which describes this work and experiments in more detail.\n\n#### Not suitable for work classifier\nDetecting offensive / adult images is an important problem which researchers have tackled for decades. With the evolution of computer vision and deep learning the algorithms have matured and we are now able to classify an image as not suitable for work with greater precision.\n\nDefining NSFW material is subjective and the task of identifying these images is non-trivial. Moreover, what may be objectionable in one context can be suitable in another. For this reason, the model we describe below focuses only on one type of NSFW content: pornographic images. The identification of NSFW sketches, cartoons, text, images of graphic violence, or other types of unsuitable content is not addressed with this model.\n\nSince images and user generated content dominate the internet today, filtering nudity and other not suitable for work images becomes an important problem. In this repository we opensource a Caffe deep neural network for preliminary filtering of NSFW images. \n\n![Demo Image](https://66.media.tumblr.com/a24135a56ecf20d7efb81dda0f4ccbac/tumblr_inline_oebl0iNWRM1rilvr1_500.png \"\")\n\n\n#### Usage\n\n* The network takes in an image and gives output a probability (score between 0-1) which can be used to filter not suitable for work images. Scores < 0.2 indicate that the image is likely to be safe with high probability. Scores > 0.8 indicate that the image is highly probable to be NSFW. Scores in middle range may be binned for different NSFW levels. \n* Depending on the dataset, usecase and types of images, we advise developers to choose suitable thresholds. Due to difficult nature of problem, there will be errors, which depend on use-cases / definition / tolerance of NSFW.  Ideally developers should create an evaluation set according to the definition of what is safe for their application, then fit a [ROC](https://en.wikipedia.org/wiki/Receiver_operating_characteristic) curve to choose a suitable threshold if they are using the model as it is. \n* ***Results can be improved by [fine-tuning](http://caffe.berkeleyvision.org/gathered/examples/finetune_flickr_style.html)*** the model for your dataset/ use case / definition of NSFW. We do not provide any guarantees of accuracy of results. Please read the disclaimer below.\n* Using human moderation for edge cases in combination with the machine learned solution will help improve performance.\n\n#### Description of model\nWe trained the model on the dataset with NSFW images as positive and SFW(suitable for work) images as negative. These images were editorially labelled. We cannot release the dataset or other details due to the nature of the data. \n\nWe use [CaffeOnSpark](https://github.com/yahoo/CaffeOnSpark) which is a wonderful framework for distributed learning that brings deep learning to Hadoop and Spark clusters for training models for our experiments. Big thanks to the CaffeOnSpark team!\n\nThe deep model was first pretrained on ImageNet 1000 class dataset. Then we finetuned the weights on the NSFW dataset.\nWe used the thin resnet 50 1by2 architecture as the pretrained network. The model was generated using [pynetbuilder](https://github.com/jay-mahadeokar/pynetbuilder) tool and replicates the [residual network](https://arxiv.org/pdf/1512.03385v1.pdf) paper's 50 layer network (with half number of filters in each layer).  You can find more details on how the model was generated and trained [here](https://github.com/jay-mahadeokar/pynetbuilder/tree/master/models/imagenet)\n\nPlease note that deeper networks, or networks with more filters can improve accuracy. We train the model using a thin residual network architecture, since it provides good tradeoff in terms of accuracy, and the model is light-weight in terms of runtime (or flops) and memory (or number of parameters).\n\n#### Docker Quickstart\nThis Docker quickstart guide can be used for evaluating the model quickly with minimal dependency installation.\n\nInstall Docker Engine\n- [Windows Installation](https://docs.docker.com/docker-for-windows/install/)\n- [Mac OSX Installation](https://docs.docker.com/docker-for-mac/install/)\n- [Ubuntu Installation](https://docs.docker.com/engine/installation/linux/ubuntu/)\n\nBuild a caffe docker image (CPU) \n```\ndocker build -t caffe:cpu https://raw.githubusercontent.com/BVLC/caffe/master/docker/cpu/Dockerfile\n```\n\nCheck the caffe installation\n```\ndocker run caffe:cpu caffe --version\ncaffe version 1.0.0-rc3\n```\n\nRun the docker image with a volume mapped to your `open_nsfw` repository. Your `test_image.jpg` should be located in this same directory.\n```\ncd open_nsfw\ndocker run --volume=$(pwd):/workspace caffe:cpu \\\npython ./classify_nsfw.py \\\n--model_def nsfw_model/deploy.prototxt \\\n--pretrained_model nsfw_model/resnet_50_1by2_nsfw.caffemodel \\\ntest_image.jpg\n```\n\nWe will get the NSFW score returned:\n```\nNSFW score:   0.14057905972\n``` \n#### Running the model\nTo run this model, please install [Caffe](https://github.com/BVLC/caffe) and its python extension and make sure pycaffe is available in your PYTHONPATH.\n\nWe can use the [classify.py](https://github.com/BVLC/caffe/blob/master/python/classify.py) script to run the NSFW model. For convenience, we have provided the script in this repo as well, and it prints the NSFW score. \n\n ```\n python ./classify_nsfw.py \\\n --model_def nsfw_model/deploy.prototxt \\\n --pretrained_model nsfw_model/resnet_50_1by2_nsfw.caffemodel \\\n INPUT_IMAGE_PATH \n ```\n \n#### ***Disclaimer***\nThe definition of NSFW is subjective and contextual. This model is a general purpose reference model, which can be used for the preliminary filtering of pornographic images. We do not provide guarantees of accuracy of output, rather we make this available for developers to explore and enhance as an open source project. Results can be improved by [fine-tuning](http://caffe.berkeleyvision.org/gathered/examples/finetune_flickr_style.html) the model for your dataset.\n\n#### License\nCode licensed under the [BSD 2 clause license] (https://github.com/BVLC/caffe/blob/master/LICENSE). See LICENSE file for terms.\n\n#### Contact\nThe model was trained by [Jay Mahadeokar](https://github.com/jay-mahadeokar/),  in collaboration with [Sachin Farfade](https://github.com/sachinfarfade/) , [Amar Ramesh Kamat](https://github.com/amar-kamat), [Armin Kappeler](https://github.com/akappeler) and others. Special thanks to Gerry Pesavento for taking the initiative for open-sourcing this model. If you have any queries, please raise an issue and we will get back ASAP.\n\n"
        },
        {
          "name": "classify_nsfw.py",
          "type": "blob",
          "size": 4.0625,
          "content": "#!/usr/bin/env python\n\"\"\"\nCopyright 2016 Yahoo Inc.\nLicensed under the terms of the 2 clause BSD license. \nPlease see LICENSE file in the project root for terms.\n\"\"\"\n\nimport numpy as np\nimport os\nimport sys\nimport argparse\nimport glob\nimport time\nfrom PIL import Image\nfrom StringIO import StringIO\nimport caffe\n\n\ndef resize_image(data, sz=(256, 256)):\n    \"\"\"\n    Resize image. Please use this resize logic for best results instead of the \n    caffe, since it was used to generate training dataset \n    :param str data:\n        The image data\n    :param sz tuple:\n        The resized image dimensions\n    :returns bytearray:\n        A byte array with the resized image\n    \"\"\"\n    img_data = str(data)\n    im = Image.open(StringIO(img_data))\n    if im.mode != \"RGB\":\n        im = im.convert('RGB')\n    imr = im.resize(sz, resample=Image.BILINEAR)\n    fh_im = StringIO()\n    imr.save(fh_im, format='JPEG')\n    fh_im.seek(0)\n    return bytearray(fh_im.read())\n\ndef caffe_preprocess_and_compute(pimg, caffe_transformer=None, caffe_net=None,\n    output_layers=None):\n    \"\"\"\n    Run a Caffe network on an input image after preprocessing it to prepare\n    it for Caffe.\n    :param PIL.Image pimg:\n        PIL image to be input into Caffe.\n    :param caffe.Net caffe_net:\n        A Caffe network with which to process pimg afrer preprocessing.\n    :param list output_layers:\n        A list of the names of the layers from caffe_net whose outputs are to\n        to be returned.  If this is None, the default outputs for the network\n        are returned.\n    :return:\n        Returns the requested outputs from the Caffe net.\n    \"\"\"\n    if caffe_net is not None:\n\n        # Grab the default output names if none were requested specifically.\n        if output_layers is None:\n            output_layers = caffe_net.outputs\n\n        img_data_rs = resize_image(pimg, sz=(256, 256))\n        image = caffe.io.load_image(StringIO(img_data_rs))\n\n        H, W, _ = image.shape\n        _, _, h, w = caffe_net.blobs['data'].data.shape\n        h_off = max((H - h) / 2, 0)\n        w_off = max((W - w) / 2, 0)\n        crop = image[h_off:h_off + h, w_off:w_off + w, :]\n        transformed_image = caffe_transformer.preprocess('data', crop)\n        transformed_image.shape = (1,) + transformed_image.shape\n\n        input_name = caffe_net.inputs[0]\n        all_outputs = caffe_net.forward_all(blobs=output_layers,\n                    **{input_name: transformed_image})\n\n        outputs = all_outputs[output_layers[0]][0].astype(float)\n        return outputs\n    else:\n        return []\n\n\ndef main(argv):\n    pycaffe_dir = os.path.dirname(__file__)\n\n    parser = argparse.ArgumentParser()\n    # Required arguments: input file.\n    parser.add_argument(\n        \"input_file\",\n        help=\"Path to the input image file\"\n    )\n\n    # Optional arguments.\n    parser.add_argument(\n        \"--model_def\",\n        help=\"Model definition file.\"\n    )\n    parser.add_argument(\n        \"--pretrained_model\",\n        help=\"Trained model weights file.\"\n    )\n\n    args = parser.parse_args()\n    image_data = open(args.input_file).read()\n\n    # Pre-load caffe model.\n    nsfw_net = caffe.Net(args.model_def,  # pylint: disable=invalid-name\n        args.pretrained_model, caffe.TEST)\n\n    # Load transformer\n    # Note that the parameters are hard-coded for best results\n    caffe_transformer = caffe.io.Transformer({'data': nsfw_net.blobs['data'].data.shape})\n    caffe_transformer.set_transpose('data', (2, 0, 1))  # move image channels to outermost\n    caffe_transformer.set_mean('data', np.array([104, 117, 123]))  # subtract the dataset-mean value in each channel\n    caffe_transformer.set_raw_scale('data', 255)  # rescale from [0, 1] to [0, 255]\n    caffe_transformer.set_channel_swap('data', (2, 1, 0))  # swap channels from RGB to BGR\n\n    # Classify.\n    scores = caffe_preprocess_and_compute(image_data, caffe_transformer=caffe_transformer, caffe_net=nsfw_net, output_layers=['prob'])\n\n    # Scores is the array containing SFW / NSFW image probabilities\n    # scores[1] indicates the NSFW probability\n    print \"NSFW score:  \" , scores[1]\n\n\n\nif __name__ == '__main__':\n    main(sys.argv)"
        },
        {
          "name": "nsfw_model",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}