{
  "metadata": {
    "timestamp": 1736560724318,
    "page": 396,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vt-vl-lab/3d-photo-inpainting",
      "stars": 6935,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.287109375,
          "content": "#ignore all kind of files\n*.*\n#except php files\n!*.py\n!*.yml\n!*.txt\n!*.md\n!*LICENSE\n!image/moon.jpg\n!depth/moon.npy\n!depth/moon.png\n!video/moon_swing.mp4\n!video/moon_zoom-in.mp4\n!video/moon_dolly-zoom-in.mp4\n!video/moon_straight-line.mp4\n!video/moon.mp4\n!video/moon_circle.mp4\n!misc/moon_40.gif"
        },
        {
          "name": "DOCUMENTATION.md",
          "type": "blob",
          "size": 6.1796875,
          "content": "# Documentation\n\n## Python scripts\n\nThese files are for our monocular 3D Tracking pipeline:\n\n`main.py` Execute 3D photo inpainting\n\n`mesh.py` Functions about context-aware depth inpainting\n\n`mesh_tools.py` Some common functions used in `mesh.py`\n\n`utils.py` Some common functions used in image preprocessing, data loading\n\n`networks.py` Network architectures of inpainting model\n\n\nMiDaS/\n\n`run.py` Execute depth estimation\n\n`monodepth_net.py` Network architecture of depth estimation model\n\n`MiDaS_utils.py` Some common functions in depth estimation\n\n\n## Configuration\n\n```bash\nargument.yml\n```\n\n- `depth_edge_model_ckpt: checkpoints/EdgeModel.pth`\n    - Pretrained model of depth-edge inpainting\n- `depth_feat_model_ckpt: checkpoints/DepthModel.pth`\n    - Pretrained model of depth inpainting\n- `rgb_feat_model_ckpt: checkpoints/ColorModel.pth`\n    - Pretrained model of color inpainting\n- `MiDaS_model_ckpt: MiDaS/model.pt`\n    - Pretrained model of depth estimation\n- `use_boostmonodepth: True`\n    - Use [BoostMonocularDepth](https://github.com/compphoto/BoostingMonocularDepth) to get sharper monocular depth estimation\n- `fps: 40`\n    - Frame per second of output rendered video\n- `num_frames: 240`\n    - Total number of frames in output rendered video\n- `x_shift_range: [-0.03, -0.03, -0.03]`\n    - The translations on x-axis of output rendered videos.\n    - This parameter is a list. Each element corresponds to a specific camera motion.\n- `y_shift_range: [-0.00, -0.00, -0.03]`\n    - The translations on y-axis of output rendered videos.\n    - This parameter is a list. Each element corresponds to a specific camera motion.\n- `z_shift_range: [-0.07, -0.07, -0.07]`\n    - The translations on z-axis of output rendered videos.\n    - This parameter is a list. Each element corresponds to a specific camera motion.\n- `traj_types: ['straight-line', 'circle', 'circle']`\n    - The type of camera trajectory.\n    - This parameter is a list.\n    - Currently, we only privode `straight-line` and `circle`.\n-  `video_postfix: ['zoom-in', 'swing', 'circle']`\n    - The postfix of video.\n    - This parameter is a list.\n- Note that the number of elements in `x_shift_range`,  `y_shift_range`, `z_shift_range`, `traj_types` and `video_postfix` should be equal.\n- `specific: '' `\n    - The specific image name, use this to specify the image to be executed. By default, all the image in the folder will    be executed.\n- `longer_side_len: 960`\n    - The length of larger dimension in output resolution.\n- `src_folder: image`\n    - Input image directory. \n- `depth_folder: depth`\n    - Estimated depth directory.\n- `mesh_folder: mesh`\n    - Output 3-D mesh directory.\n- `video_folder: video`\n    - Output rendered video directory\n- `load_ply: False`\n    - Action to load existed mesh (.ply) file\n- `save_ply: True`\n    - Action to store the output mesh (.ply) file\n    - Disable this option `save_ply: False` to reduce the computational time.\n- `inference_video: True`\n    - Action to rendered the output video\n- `gpu_ids: 0`\n    - The ID of working GPU. Leave it blank or negative to use CPU.\n- `offscreen_rendering: True`\n    - If you're executing the process in a remote server (via ssh), please switch on this flag. \n    - Sometimes, using off-screen rendering result in longer execution time.\n- `img_format: '.jpg'`\n    - Input image format.\n- `depth_format: '.npy'`\n    - Input depth (disparity) format. Use NumPy array file as default.\n    - If the user wants to edit the depth (disparity) map manually, we provide `.png` format depth (disparity) map.\n        - Remember to switch this parameter from `.npy` to `.png` when using depth (disparity) map with `.png` format.\n- `require_midas: True`\n    - Set it to `True` if the user wants to use depth map estimated by `MiDaS`.\n    - Set it to `False` if the user wants to use manually edited depth map.\n    - If the user wants to edit the depth (disparity) map manually, we provide `.png` format depth (disparity) map.\n        - Remember to switch this parameter from `True` to `False` when using manually edited depth map.\n- `depth_threshold: 0.04`\n    - A threshold in disparity, adjacent two pixels are discontinuity pixels \n      if the difference between them excceed this number.\n- `ext_edge_threshold: 0.002`\n    - The threshold to define inpainted depth edge. A pixel in inpainted edge \n      map belongs to extended depth edge if the value of that pixel exceeds this number,\n- `sparse_iter: 5`\n    - Total iteration numbers of bilateral median filter\n- `filter_size: [7, 7, 5, 5, 5]`\n    - Window size of bilateral median filter in each iteration.\n- `sigma_s: 4.0`\n    - Intensity term of bilateral median filter\n- `sigma_r: 0.5`\n    - Spatial term of bilateral median filter\n- `redundant_number: 12`\n    - The number defines short segments. If a depth edge is shorter than this number, \n      it is a short segment and removed.\n- `background_thickness: 70`\n    - The thickness of synthesis area.\n- `context_thickness: 140`\n    - The thickness of context area.\n- `background_thickness_2: 70`\n    - The thickness of synthesis area when inpaint second time.\n- `context_thickness_2: 70`\n    - The thickness of context area when inpaint second time.\n- `discount_factor: 1.00`\n- `log_depth: True`\n    - The scale of depth inpainting. If true, performing inpainting in log scale. \n      Otherwise, performing in linear scale.\n- `largest_size: 512`\n    - The largest size of inpainted image patch.\n- `depth_edge_dilate: 10`\n    - The thickness of dilated synthesis area.\n- `depth_edge_dilate_2: 5`\n    - The thickness of dilated synthesis area when inpaint second time.\n- `extrapolate_border: True`\n    - Action to extrapolate out-side the border.\n- `extrapolation_thickness: 60`\n    - The thickness of extrapolated area.\n- `repeat_inpaint_edge: True`\n    - Action to apply depth edge inpainting model repeatedly. Sometimes inpainting depth \n      edge once results in short inpinated edge, apply depth edge inpainting repeatedly \n      could help you prolong the inpainted depth edge. \n- `crop_border: [0.03, 0.03, 0.05, 0.03]`\n    - The fraction of pixels to crop out around the borders `[top, left, bottom, right]`.\n- `anti_flickering: True`\n    - Action to avoid flickering effect in the output video. \n    - This may result in longer computational time in rendering phase.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 2.3271484375,
          "content": "\nMIT License\n\nCopyright (c) 2020 Virginia Tech Vision and Learning Lab\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------------------ LICENSE FOR MiDaS --------------------\n\nMIT License\n\nCopyright (c) 2019 Intel ISL (Intel Intelligent Systems Lab)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n--------------------------- LICENSE FOR EdgeConnect --------------------------------\n\nAttribution-NonCommercial 4.0 International"
        },
        {
          "name": "MiDaS",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.3466796875,
          "content": "# [CVPR 2020] 3D Photography using Context-aware Layered Depth Inpainting\n\n[![Open 3DPhotoInpainting in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1706ToQrkIZshRSJSHvZ1RuCiM__YX3Bz)\n\n### [[Paper](https://arxiv.org/abs/2004.04727)] [[Project Website](https://shihmengli.github.io/3D-Photo-Inpainting/)] [[Google Colab](https://colab.research.google.com/drive/1706ToQrkIZshRSJSHvZ1RuCiM__YX3Bz)]\n\n<p align='center'>\n<img src='https://filebox.ece.vt.edu/~jbhuang/project/3DPhoto/3DPhoto_teaser.jpg' width='900'/>\n</p>\n\nWe propose a method for converting a single RGB-D input image into a 3D photo, i.e., a multi-layer representation for novel view synthesis that contains hallucinated color and depth structures in regions occluded in the original view. We use a Layered Depth Image with explicit pixel connectivity as underlying representation, and present a learning-based inpainting model that iteratively synthesizes new local color-and-depth content into the occluded region in a spatial context-aware manner. The resulting 3D photos can be efficiently rendered with motion parallax using standard graphics engines. We validate the effectiveness of our method on a wide range of challenging everyday scenes and show fewer artifacts when compared with the state-of-the-arts.\n<br/>\n\n**3D Photography using Context-aware Layered Depth Inpainting**\n<br/>\n[Meng-Li Shih](https://shihmengli.github.io/), \n[Shih-Yang Su](https://lemonatsu.github.io/), \n[Johannes Kopf](https://johanneskopf.de/), and\n[Jia-Bin Huang](https://filebox.ece.vt.edu/~jbhuang/)\n<br/>\nIn IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2020.\n\n\n## Prerequisites\n\n- Linux (tested on Ubuntu 18.04.4 LTS)\n- Anaconda\n- Python 3.7 (tested on 3.7.4)\n- PyTorch 1.4.0 (tested on 1.4.0 for execution)\n\nand the Python dependencies listed in [requirements.txt](requirements.txt)\n- To get started, please run the following commands:\n    ```bash\n    conda create -n 3DP python=3.7 anaconda\n    conda activate 3DP\n    pip install -r requirements.txt\n    conda install pytorch==1.4.0 torchvision==0.5.0 cudatoolkit==10.1.243 -c pytorch\n    ```\n- Next, please download the model weight using the following command:\n    ```bash\n    chmod +x download.sh\n    ./download.sh\n    ```    \n\n## Quick start\nPlease follow the instructions in this section. \nThis should allow to execute our results.\nFor more detailed instructions, please refer to [`DOCUMENTATION.md`](DOCUMENTATION.md).\n\n## Execute\n1. Put ```.jpg``` files (e.g., test.jpg) into the ```image``` folder. \n    - E.g., `image/moon.jpg`\n2. Run the following command\n    ```bash\n    python main.py --config argument.yml\n    ```\n    - Note: The 3D photo generation process usually takes about 2-3 minutes depending on the available computing resources.\n3. The results are stored in the following directories:\n    - Corresponding depth map estimated by [MiDaS](https://github.com/intel-isl/MiDaS.git) \n        - E.g. ```depth/moon.npy```, ```depth/moon.png```\n        - User could edit ```depth/moon.png``` manually. \n            - Remember to set the following two flags as listed below if user wants to use manually edited ```depth/moon.png``` as input for 3D Photo.\n                - `depth_format: '.png'`\n                - `require_midas: False`\n    - Inpainted 3D mesh (Optional: User need to switch on the flag `save_ply`)\n        - E.g. ```mesh/moon.ply```\n    - Rendered videos with zoom-in motion\n        - E.g. ```video/moon_zoom-in.mp4```\n    - Rendered videos with swing motion\n        - E.g. ```video/moon_swing.mp4```\n    - Rendered videos with circle motion\n        - E.g. ```video/moon_circle.mp4```         \n    - Rendered videos with dolly zoom-in effect\n        - E.g. ```video/moon_dolly-zoom-in.mp4```\n        - Note: We assume that the object of focus is located at the center of the image.\n4. (Optional) If you want to change the default configuration. Please read [`DOCUMENTATION.md`](DOCUMENTATION.md) and modified ```argument.yml```.\n\n\n## License\nThis work is licensed under MIT License. See [LICENSE](LICENSE) for details. \n\nIf you find our code/models useful, please consider citing our paper:\n```\n@inproceedings{Shih3DP20,\n  author = {Shih, Meng-Li and Su, Shih-Yang and Kopf, Johannes and Huang, Jia-Bin},\n  title = {3D Photography using Context-aware Layered Depth Inpainting},\n  booktitle = {IEEE Conference on Computer Vision and Pattern Recognition (CVPR)},\n  year = {2020}\n}\n```\n\n## Acknowledgments\n- We thank Pratul Srinivasan for providing clarification of the method [Srinivasan et al. CVPR 2019](https://people.eecs.berkeley.edu/~pratul/publication/mpi_extrapolation/).\n- We thank the author of [Zhou et al. 2018](https://people.eecs.berkeley.edu/~tinghuiz/projects/mpi/), [Choi et al. 2019](https://github.com/NVlabs/extreme-view-synth/), [Mildenhall et al. 2019](https://github.com/Fyusion/LLFF), [Srinivasan et al. 2019](https://github.com/google-research/google-research/tree/ac9b04e1dbdac468fda53e798a326fe9124e49fe/mpi_extrapolation), [Wiles et al. 2020](http://www.robots.ox.ac.uk/~ow/synsin.html), [Niklaus et al. 2019](https://github.com/sniklaus/3d-ken-burns) for providing their implementations online.\n- Our code builds upon [EdgeConnect](https://github.com/knazeri/edge-connect), [MiDaS](https://github.com/intel-isl/MiDaS.git) and [pytorch-inpainting-with-partial-conv](https://github.com/naoto0804/pytorch-inpainting-with-partial-conv)\n"
        },
        {
          "name": "argument.yml",
          "type": "blob",
          "size": 1.216796875,
          "content": "depth_edge_model_ckpt: checkpoints/edge-model.pth\ndepth_feat_model_ckpt: checkpoints/depth-model.pth\nrgb_feat_model_ckpt: checkpoints/color-model.pth\nMiDaS_model_ckpt: MiDaS/model.pt\nuse_boostmonodepth: True\nfps: 40\nnum_frames: 240\nx_shift_range: [0.00, 0.00, -0.015, -0.015]\ny_shift_range: [0.00, 0.00, -0.015, -0.00]\nz_shift_range: [-0.05, -0.05, -0.05, -0.05]\ntraj_types: ['double-straight-line', 'double-straight-line', 'circle', 'circle']\nvideo_postfix: ['dolly-zoom-in', 'zoom-in', 'circle', 'swing']\nspecific: ''\nlonger_side_len: 960\nsrc_folder: image\ndepth_folder: depth\nmesh_folder: mesh\nvideo_folder: video\nload_ply: False\nsave_ply: True\ninference_video: True\ngpu_ids: 0\noffscreen_rendering: False\nimg_format: '.jpg'\ndepth_format: '.npy'\nrequire_midas: True\ndepth_threshold: 0.04\next_edge_threshold: 0.002\nsparse_iter: 5\nfilter_size: [7, 7, 5, 5, 5]\nsigma_s: 4.0\nsigma_r: 0.5\nredundant_number: 12\nbackground_thickness: 70\ncontext_thickness: 140\nbackground_thickness_2: 70\ncontext_thickness_2: 70\ndiscount_factor: 1.00\nlog_depth: True\nlargest_size: 512\ndepth_edge_dilate: 10\ndepth_edge_dilate_2: 5\nextrapolate_border: True\nextrapolation_thickness: 60\nrepeat_inpaint_edge: True\ncrop_border: [0.03, 0.03, 0.05, 0.03]\nanti_flickering: True\n"
        },
        {
          "name": "bilateral_filtering.py",
          "type": "blob",
          "size": 9.259765625,
          "content": "import numpy as np\nfrom functools import reduce\n\ndef sparse_bilateral_filtering(\n    depth, image, config, HR=False, mask=None, gsHR=True, edge_id=None, num_iter=None, num_gs_iter=None, spdb=False\n):\n    \"\"\"\n    config:\n    - filter_size\n    \"\"\"\n    import time\n\n    save_images = []\n    save_depths = []\n    save_discontinuities = []\n    vis_depth = depth.copy()\n    backup_vis_depth = vis_depth.copy()\n\n    depth_max = vis_depth.max()\n    depth_min = vis_depth.min()\n    vis_image = image.copy()\n    for i in range(num_iter):\n        if isinstance(config[\"filter_size\"], list):\n            window_size = config[\"filter_size\"][i]\n        else:\n            window_size = config[\"filter_size\"]\n        vis_image = image.copy()\n        save_images.append(vis_image)\n        save_depths.append(vis_depth)\n        u_over, b_over, l_over, r_over = vis_depth_discontinuity(vis_depth, config, mask=mask)\n        vis_image[u_over > 0] = np.array([0, 0, 0])\n        vis_image[b_over > 0] = np.array([0, 0, 0])\n        vis_image[l_over > 0] = np.array([0, 0, 0])\n        vis_image[r_over > 0] = np.array([0, 0, 0])\n\n        discontinuity_map = (u_over + b_over + l_over + r_over).clip(0.0, 1.0)\n        discontinuity_map[depth == 0] = 1\n        save_discontinuities.append(discontinuity_map)\n        if mask is not None:\n            discontinuity_map[mask == 0] = 0\n        vis_depth = bilateral_filter(\n            vis_depth, config, discontinuity_map=discontinuity_map, HR=HR, mask=mask, window_size=window_size\n        )\n\n    return save_images, save_depths\n\n\ndef vis_depth_discontinuity(depth, config, vis_diff=False, label=False, mask=None):\n    \"\"\"\n    config:\n    - \n    \"\"\"\n    if label == False:\n        disp = 1./depth\n        u_diff = (disp[1:, :] - disp[:-1, :])[:-1, 1:-1]\n        b_diff = (disp[:-1, :] - disp[1:, :])[1:, 1:-1]\n        l_diff = (disp[:, 1:] - disp[:, :-1])[1:-1, :-1]\n        r_diff = (disp[:, :-1] - disp[:, 1:])[1:-1, 1:]\n        if mask is not None:\n            u_mask = (mask[1:, :] * mask[:-1, :])[:-1, 1:-1]\n            b_mask = (mask[:-1, :] * mask[1:, :])[1:, 1:-1]\n            l_mask = (mask[:, 1:] * mask[:, :-1])[1:-1, :-1]\n            r_mask = (mask[:, :-1] * mask[:, 1:])[1:-1, 1:]\n            u_diff = u_diff * u_mask\n            b_diff = b_diff * b_mask\n            l_diff = l_diff * l_mask\n            r_diff = r_diff * r_mask\n        u_over = (np.abs(u_diff) > config['depth_threshold']).astype(np.float32)\n        b_over = (np.abs(b_diff) > config['depth_threshold']).astype(np.float32)\n        l_over = (np.abs(l_diff) > config['depth_threshold']).astype(np.float32)\n        r_over = (np.abs(r_diff) > config['depth_threshold']).astype(np.float32)\n    else:\n        disp = depth\n        u_diff = (disp[1:, :] * disp[:-1, :])[:-1, 1:-1]\n        b_diff = (disp[:-1, :] * disp[1:, :])[1:, 1:-1]\n        l_diff = (disp[:, 1:] * disp[:, :-1])[1:-1, :-1]\n        r_diff = (disp[:, :-1] * disp[:, 1:])[1:-1, 1:]\n        if mask is not None:\n            u_mask = (mask[1:, :] * mask[:-1, :])[:-1, 1:-1]\n            b_mask = (mask[:-1, :] * mask[1:, :])[1:, 1:-1]\n            l_mask = (mask[:, 1:] * mask[:, :-1])[1:-1, :-1]\n            r_mask = (mask[:, :-1] * mask[:, 1:])[1:-1, 1:]\n            u_diff = u_diff * u_mask\n            b_diff = b_diff * b_mask\n            l_diff = l_diff * l_mask\n            r_diff = r_diff * r_mask\n        u_over = (np.abs(u_diff) > 0).astype(np.float32)\n        b_over = (np.abs(b_diff) > 0).astype(np.float32)\n        l_over = (np.abs(l_diff) > 0).astype(np.float32)\n        r_over = (np.abs(r_diff) > 0).astype(np.float32)\n    u_over = np.pad(u_over, 1, mode='constant')\n    b_over = np.pad(b_over, 1, mode='constant')\n    l_over = np.pad(l_over, 1, mode='constant')\n    r_over = np.pad(r_over, 1, mode='constant')\n    u_diff = np.pad(u_diff, 1, mode='constant')\n    b_diff = np.pad(b_diff, 1, mode='constant')\n    l_diff = np.pad(l_diff, 1, mode='constant')\n    r_diff = np.pad(r_diff, 1, mode='constant')\n\n    if vis_diff:\n        return [u_over, b_over, l_over, r_over], [u_diff, b_diff, l_diff, r_diff]\n    else:\n        return [u_over, b_over, l_over, r_over]\n\ndef bilateral_filter(depth, config, discontinuity_map=None, HR=False, mask=None, window_size=False):\n    sort_time = 0\n    replace_time = 0\n    filter_time = 0\n    init_time = 0\n    filtering_time = 0\n    sigma_s = config['sigma_s']\n    sigma_r = config['sigma_r']\n    if window_size == False:\n        window_size = config['filter_size']\n    midpt = window_size//2\n    ax = np.arange(-midpt, midpt+1.)\n    xx, yy = np.meshgrid(ax, ax)\n    if discontinuity_map is not None:\n        spatial_term = np.exp(-(xx**2 + yy**2) / (2. * sigma_s**2))\n\n    # padding\n    depth = depth[1:-1, 1:-1]\n    depth = np.pad(depth, ((1,1), (1,1)), 'edge')\n    pad_depth = np.pad(depth, (midpt,midpt), 'edge')\n    if discontinuity_map is not None:\n        discontinuity_map = discontinuity_map[1:-1, 1:-1]\n        discontinuity_map = np.pad(discontinuity_map, ((1,1), (1,1)), 'edge')\n        pad_discontinuity_map = np.pad(discontinuity_map, (midpt,midpt), 'edge')\n        pad_discontinuity_hole = 1 - pad_discontinuity_map\n    # filtering\n    output = depth.copy()\n    pad_depth_patches = rolling_window(pad_depth, [window_size, window_size], [1,1])\n    if discontinuity_map is not None:\n        pad_discontinuity_patches = rolling_window(pad_discontinuity_map, [window_size, window_size], [1,1])\n        pad_discontinuity_hole_patches = rolling_window(pad_discontinuity_hole, [window_size, window_size], [1,1])\n\n    if mask is not None:\n        pad_mask = np.pad(mask, (midpt,midpt), 'constant')\n        pad_mask_patches = rolling_window(pad_mask, [window_size, window_size], [1,1])\n    from itertools import product\n    if discontinuity_map is not None:\n        pH, pW = pad_depth_patches.shape[:2]\n        for pi in range(pH):\n            for pj in range(pW):\n                if mask is not None and mask[pi, pj] == 0:\n                    continue\n                if discontinuity_map is not None:\n                    if bool(pad_discontinuity_patches[pi, pj].any()) is False:\n                        continue\n                    discontinuity_patch = pad_discontinuity_patches[pi, pj]\n                    discontinuity_holes = pad_discontinuity_hole_patches[pi, pj]\n                depth_patch = pad_depth_patches[pi, pj]\n                depth_order = depth_patch.ravel().argsort()\n                patch_midpt = depth_patch[window_size//2, window_size//2]\n                if discontinuity_map is not None:\n                    coef = discontinuity_holes.astype(np.float32)\n                    if mask is not None:\n                        coef = coef * pad_mask_patches[pi, pj]\n                else:\n                    range_term = np.exp(-(depth_patch-patch_midpt)**2 / (2. * sigma_r**2))\n                    coef = spatial_term * range_term\n                if coef.max() == 0:\n                    output[pi, pj] = patch_midpt\n                    continue\n                if discontinuity_map is not None and (coef.max() == 0):\n                    output[pi, pj] = patch_midpt\n                else:\n                    coef = coef/(coef.sum())\n                    coef_order = coef.ravel()[depth_order]\n                    cum_coef = np.cumsum(coef_order)\n                    ind = np.digitize(0.5, cum_coef)\n                    output[pi, pj] = depth_patch.ravel()[depth_order][ind]\n    else:\n        pH, pW = pad_depth_patches.shape[:2]\n        for pi in range(pH):\n            for pj in range(pW):\n                if discontinuity_map is not None:\n                    if pad_discontinuity_patches[pi, pj][window_size//2, window_size//2] == 1:\n                        continue\n                    discontinuity_patch = pad_discontinuity_patches[pi, pj]\n                    discontinuity_holes = (1. - discontinuity_patch)\n                depth_patch = pad_depth_patches[pi, pj]\n                depth_order = depth_patch.ravel().argsort()\n                patch_midpt = depth_patch[window_size//2, window_size//2]\n                range_term = np.exp(-(depth_patch-patch_midpt)**2 / (2. * sigma_r**2))\n                if discontinuity_map is not None:\n                    coef = spatial_term * range_term * discontinuity_holes\n                else:\n                    coef = spatial_term * range_term\n                if coef.sum() == 0:\n                    output[pi, pj] = patch_midpt\n                    continue\n                if discontinuity_map is not None and (coef.sum() == 0):\n                    output[pi, pj] = patch_midpt\n                else:\n                    coef = coef/(coef.sum())\n                    coef_order = coef.ravel()[depth_order]\n                    cum_coef = np.cumsum(coef_order)\n                    ind = np.digitize(0.5, cum_coef)\n                    output[pi, pj] = depth_patch.ravel()[depth_order][ind]\n\n    return output\n\ndef rolling_window(a, window, strides):\n    assert len(a.shape)==len(window)==len(strides), \"\\'a\\', \\'window\\', \\'strides\\' dimension mismatch\"\n    shape_fn = lambda i,w,s: (a.shape[i]-w)//s + 1\n    shape = [shape_fn(i,w,s) for i,(w,s) in enumerate(zip(window, strides))] + list(window)\n    def acc_shape(i):\n        if i+1>=len(a.shape):\n            return 1\n        else:\n            return reduce(lambda x,y:x*y, a.shape[i+1:])\n    _strides = [acc_shape(i)*s*a.itemsize for i,s in enumerate(strides)] + list(a.strides)\n\n    return np.lib.stride_tricks.as_strided(a, shape=shape, strides=_strides)\n"
        },
        {
          "name": "boostmonodepth_utils.py",
          "type": "blob",
          "size": 2.2744140625,
          "content": "import os\nimport cv2\nimport glob\nimport numpy as np\nimport imageio\nfrom MiDaS.MiDaS_utils import write_depth\n\nBOOST_BASE = 'BoostingMonocularDepth'\n\nBOOST_INPUTS = 'inputs'\nBOOST_OUTPUTS = 'outputs'\n\ndef run_boostmonodepth(img_names, src_folder, depth_folder):\n\n    if not isinstance(img_names, list):\n        img_names = [img_names]\n\n    # remove irrelevant files first\n    clean_folder(os.path.join(BOOST_BASE, BOOST_INPUTS))\n    clean_folder(os.path.join(BOOST_BASE, BOOST_OUTPUTS))\n\n    tgt_names = []\n    for img_name in img_names:\n        base_name = os.path.basename(img_name)\n        tgt_name = os.path.join(BOOST_BASE, BOOST_INPUTS, base_name)\n        os.system(f'cp {img_name} {tgt_name}')\n\n        # keep only the file name here.\n        # they save all depth as .png file\n        tgt_names.append(os.path.basename(tgt_name).replace('.jpg', '.png'))\n\n    os.system(f'cd {BOOST_BASE} && python run.py --Final --data_dir {BOOST_INPUTS}/  --output_dir {BOOST_OUTPUTS} --depthNet 0')\n\n    for i, (img_name, tgt_name) in enumerate(zip(img_names, tgt_names)):\n        img = imageio.imread(img_name)\n        H, W = img.shape[:2]\n        scale = 640. / max(H, W)\n\n        # resize and save depth\n        target_height, target_width = int(round(H * scale)), int(round(W * scale))\n        depth = imageio.imread(os.path.join(BOOST_BASE, BOOST_OUTPUTS, tgt_name))\n        depth = np.array(depth).astype(np.float32)\n        depth = resize_depth(depth, target_width, target_height)\n        np.save(os.path.join(depth_folder, tgt_name.replace('.png', '.npy')), depth / 32768. - 1.)\n        write_depth(os.path.join(depth_folder, tgt_name.replace('.png', '')), depth)\n\ndef clean_folder(folder, img_exts=['.png', '.jpg', '.npy']):\n\n    for img_ext in img_exts:\n        paths_to_check = os.path.join(folder, f'*{img_ext}')\n        if len(glob.glob(paths_to_check)) == 0:\n            continue\n        print(paths_to_check)\n        os.system(f'rm {paths_to_check}')\n\ndef resize_depth(depth, width, height):\n    \"\"\"Resize numpy (or image read by imageio) depth map\n\n    Args:\n        depth (numpy): depth\n        width (int): image width\n        height (int): image height\n\n    Returns:\n        array: processed depth\n    \"\"\"\n    depth = cv2.blur(depth, (3, 3))\n    return cv2.resize(depth, (width, height), interpolation=cv2.INTER_AREA)\n"
        },
        {
          "name": "depth",
          "type": "tree",
          "content": null
        },
        {
          "name": "download.sh",
          "type": "blob",
          "size": 1.068359375,
          "content": "#!/bin/sh\nfb_status=$(wget --spider -S https://filebox.ece.vt.edu/ 2>&1 | grep  \"HTTP/1.1 200 OK\")\n\nmkdir checkpoints\n\necho \"downloading from filebox ...\"\nwget https://filebox.ece.vt.edu/~jbhuang/project/3DPhoto/model/color-model.pth\nwget https://filebox.ece.vt.edu/~jbhuang/project/3DPhoto/model/depth-model.pth\nwget https://filebox.ece.vt.edu/~jbhuang/project/3DPhoto/model/edge-model.pth\nwget https://filebox.ece.vt.edu/~jbhuang/project/3DPhoto/model/model.pt\n\nmv color-model.pth checkpoints/.\nmv depth-model.pth checkpoints/.\nmv edge-model.pth checkpoints/.\nmv model.pt MiDaS/.\n\necho \"cloning from BoostingMonocularDepth ...\"\ngit clone https://github.com/compphoto/BoostingMonocularDepth.git\nmkdir -p BoostingMonocularDepth/pix2pix/checkpoints/mergemodel/\n\necho \"downloading mergenet weights ...\"\nwget https://filebox.ece.vt.edu/~jbhuang/project/3DPhoto/model/latest_net_G.pth\nmv latest_net_G.pth BoostingMonocularDepth/pix2pix/checkpoints/mergemodel/\nwget https://github.com/intel-isl/MiDaS/releases/download/v2/model-f46da743.pt\nmv model-f46da743.pt BoostingMonocularDepth/midas/model.pt\n"
        },
        {
          "name": "image",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.py",
          "type": "blob",
          "size": 6.5771484375,
          "content": "import numpy as np\nimport argparse\nimport glob\nimport os\nfrom functools import partial\nimport vispy\nimport scipy.misc as misc\nfrom tqdm import tqdm\nimport yaml\nimport time\nimport sys\nfrom mesh import write_ply, read_ply, output_3d_photo\nfrom utils import get_MiDaS_samples, read_MiDaS_depth\nimport torch\nimport cv2\nfrom skimage.transform import resize\nimport imageio\nimport copy\nfrom networks import Inpaint_Color_Net, Inpaint_Depth_Net, Inpaint_Edge_Net\nfrom MiDaS.run import run_depth\nfrom boostmonodepth_utils import run_boostmonodepth\nfrom MiDaS.monodepth_net import MonoDepthNet\nimport MiDaS.MiDaS_utils as MiDaS_utils\nfrom bilateral_filtering import sparse_bilateral_filtering\n\nparser = argparse.ArgumentParser()\nparser.add_argument('--config', type=str, default='argument.yml',help='Configure of post processing')\nargs = parser.parse_args()\nconfig = yaml.load(open(args.config, 'r'))\nif config['offscreen_rendering'] is True:\n    vispy.use(app='egl')\nos.makedirs(config['mesh_folder'], exist_ok=True)\nos.makedirs(config['video_folder'], exist_ok=True)\nos.makedirs(config['depth_folder'], exist_ok=True)\nsample_list = get_MiDaS_samples(config['src_folder'], config['depth_folder'], config, config['specific'])\nnormal_canvas, all_canvas = None, None\n\nif isinstance(config[\"gpu_ids\"], int) and (config[\"gpu_ids\"] >= 0):\n    device = config[\"gpu_ids\"]\nelse:\n    device = \"cpu\"\n\nprint(f\"running on device {device}\")\n\nfor idx in tqdm(range(len(sample_list))):\n    depth = None\n    sample = sample_list[idx]\n    print(\"Current Source ==> \", sample['src_pair_name'])\n    mesh_fi = os.path.join(config['mesh_folder'], sample['src_pair_name'] +'.ply')\n    image = imageio.imread(sample['ref_img_fi'])\n\n    print(f\"Running depth extraction at {time.time()}\")\n    if config['use_boostmonodepth'] is True:\n        run_boostmonodepth(sample['ref_img_fi'], config['src_folder'], config['depth_folder'])\n    elif config['require_midas'] is True:\n        run_depth([sample['ref_img_fi']], config['src_folder'], config['depth_folder'],\n                  config['MiDaS_model_ckpt'], MonoDepthNet, MiDaS_utils, target_w=640)\n\n    if 'npy' in config['depth_format']:\n        config['output_h'], config['output_w'] = np.load(sample['depth_fi']).shape[:2]\n    else:\n        config['output_h'], config['output_w'] = imageio.imread(sample['depth_fi']).shape[:2]\n    frac = config['longer_side_len'] / max(config['output_h'], config['output_w'])\n    config['output_h'], config['output_w'] = int(config['output_h'] * frac), int(config['output_w'] * frac)\n    config['original_h'], config['original_w'] = config['output_h'], config['output_w']\n    if image.ndim == 2:\n        image = image[..., None].repeat(3, -1)\n    if np.sum(np.abs(image[..., 0] - image[..., 1])) == 0 and np.sum(np.abs(image[..., 1] - image[..., 2])) == 0:\n        config['gray_image'] = True\n    else:\n        config['gray_image'] = False\n    image = cv2.resize(image, (config['output_w'], config['output_h']), interpolation=cv2.INTER_AREA)\n    depth = read_MiDaS_depth(sample['depth_fi'], 3.0, config['output_h'], config['output_w'])\n    mean_loc_depth = depth[depth.shape[0]//2, depth.shape[1]//2]\n    if not(config['load_ply'] is True and os.path.exists(mesh_fi)):\n        vis_photos, vis_depths = sparse_bilateral_filtering(depth.copy(), image.copy(), config, num_iter=config['sparse_iter'], spdb=False)\n        depth = vis_depths[-1]\n        model = None\n        torch.cuda.empty_cache()\n        print(\"Start Running 3D_Photo ...\")\n        print(f\"Loading edge model at {time.time()}\")\n        depth_edge_model = Inpaint_Edge_Net(init_weights=True)\n        depth_edge_weight = torch.load(config['depth_edge_model_ckpt'],\n                                       map_location=torch.device(device))\n        depth_edge_model.load_state_dict(depth_edge_weight)\n        depth_edge_model = depth_edge_model.to(device)\n        depth_edge_model.eval()\n\n        print(f\"Loading depth model at {time.time()}\")\n        depth_feat_model = Inpaint_Depth_Net()\n        depth_feat_weight = torch.load(config['depth_feat_model_ckpt'],\n                                       map_location=torch.device(device))\n        depth_feat_model.load_state_dict(depth_feat_weight, strict=True)\n        depth_feat_model = depth_feat_model.to(device)\n        depth_feat_model.eval()\n        depth_feat_model = depth_feat_model.to(device)\n        print(f\"Loading rgb model at {time.time()}\")\n        rgb_model = Inpaint_Color_Net()\n        rgb_feat_weight = torch.load(config['rgb_feat_model_ckpt'],\n                                     map_location=torch.device(device))\n        rgb_model.load_state_dict(rgb_feat_weight)\n        rgb_model.eval()\n        rgb_model = rgb_model.to(device)\n        graph = None\n\n\n        print(f\"Writing depth ply (and basically doing everything) at {time.time()}\")\n        rt_info = write_ply(image,\n                              depth,\n                              sample['int_mtx'],\n                              mesh_fi,\n                              config,\n                              rgb_model,\n                              depth_edge_model,\n                              depth_edge_model,\n                              depth_feat_model)\n\n        if rt_info is False:\n            continue\n        rgb_model = None\n        color_feat_model = None\n        depth_edge_model = None\n        depth_feat_model = None\n        torch.cuda.empty_cache()\n    if config['save_ply'] is True or config['load_ply'] is True:\n        verts, colors, faces, Height, Width, hFov, vFov = read_ply(mesh_fi)\n    else:\n        verts, colors, faces, Height, Width, hFov, vFov = rt_info\n\n\n    print(f\"Making video at {time.time()}\")\n    videos_poses, video_basename = copy.deepcopy(sample['tgts_poses']), sample['tgt_name']\n    top = (config.get('original_h') // 2 - sample['int_mtx'][1, 2] * config['output_h'])\n    left = (config.get('original_w') // 2 - sample['int_mtx'][0, 2] * config['output_w'])\n    down, right = top + config['output_h'], left + config['output_w']\n    border = [int(xx) for xx in [top, down, left, right]]\n    normal_canvas, all_canvas = output_3d_photo(verts.copy(), colors.copy(), faces.copy(), copy.deepcopy(Height), copy.deepcopy(Width), copy.deepcopy(hFov), copy.deepcopy(vFov),\n                        copy.deepcopy(sample['tgt_pose']), sample['video_postfix'], copy.deepcopy(sample['ref_pose']), copy.deepcopy(config['video_folder']),\n                        image.copy(), copy.deepcopy(sample['int_mtx']), config, image,\n                        videos_poses, video_basename, config.get('original_h'), config.get('original_w'), border=border, depth=depth, normal_canvas=normal_canvas, all_canvas=all_canvas,\n                        mean_loc_depth=mean_loc_depth)\n"
        },
        {
          "name": "mesh.py",
          "type": "blob",
          "size": 134.3857421875,
          "content": "import os\nimport numpy as np\ntry:\n    import cynetworkx as netx\nexcept ImportError:\n    import networkx as netx\nimport matplotlib.pyplot as plt\nfrom functools import partial\nfrom vispy import scene, io\nfrom vispy.scene import visuals\nfrom vispy.visuals.filters import Alpha\nimport cv2\nfrom moviepy.editor import ImageSequenceClip\nfrom skimage.transform import resize\nimport time\nimport copy\nimport torch\nimport os\nfrom utils import path_planning, open_small_mask, clean_far_edge, refine_depth_around_edge\nfrom utils import refine_color_around_edge, filter_irrelevant_edge_new, require_depth_edge, clean_far_edge_new\nfrom utils import create_placeholder, refresh_node, find_largest_rect\nfrom mesh_tools import get_depth_from_maps, get_map_from_ccs, get_edge_from_nodes, get_depth_from_nodes, get_rgb_from_nodes, crop_maps_by_size, convert2tensor, recursive_add_edge, update_info, filter_edge, relabel_node, depth_inpainting\nfrom mesh_tools import refresh_bord_depth, enlarge_border, fill_dummy_bord, extrapolate, fill_missing_node, incomplete_node, get_valid_size, dilate_valid_size, size_operation\nimport transforms3d\nimport random\nfrom functools import reduce\n\ndef create_mesh(depth, image, int_mtx, config):\n    H, W, C = image.shape\n    ext_H, ext_W = H + 2 * config['extrapolation_thickness'], W + 2 * config['extrapolation_thickness']\n    LDI = netx.Graph(H=ext_H, W=ext_W, noext_H=H, noext_W=W, cam_param=int_mtx)\n    xy2depth = {}\n    int_mtx_pix = int_mtx * np.array([[W], [H], [1.]])\n    LDI.graph['cam_param_pix'], LDI.graph['cam_param_pix_inv'] = int_mtx_pix, np.linalg.inv(int_mtx_pix)\n    disp = 1. / (-depth)\n    LDI.graph['hoffset'], LDI.graph['woffset'] = config['extrapolation_thickness'], config['extrapolation_thickness']\n    LDI.graph['bord_up'], LDI.graph['bord_down'] = LDI.graph['hoffset'] + 0, LDI.graph['hoffset'] + H\n    LDI.graph['bord_left'], LDI.graph['bord_right'] = LDI.graph['woffset'] + 0, LDI.graph['woffset'] + W\n    for idx in range(H):\n        for idy in range(W):\n            x, y = idx + LDI.graph['hoffset'], idy + LDI.graph['woffset']\n            LDI.add_node((x, y, -depth[idx, idy]),\n                         color=image[idx, idy],\n                         disp=disp[idx, idy],\n                         synthesis=False,\n                         cc_id=set())\n            xy2depth[(x, y)] = [-depth[idx, idy]]\n    for x, y, d in LDI.nodes:\n        two_nes = [ne for ne in [(x+1, y), (x, y+1)] if ne[0] < LDI.graph['bord_down'] and ne[1] < LDI.graph['bord_right']]\n        [LDI.add_edge((ne[0], ne[1], xy2depth[ne][0]), (x, y, d)) for ne in two_nes]\n    LDI = calculate_fov(LDI)\n    image = np.pad(image,\n                    pad_width=((config['extrapolation_thickness'], config['extrapolation_thickness']),\n                               (config['extrapolation_thickness'], config['extrapolation_thickness']),\n                               (0, 0)),\n                    mode='constant')\n    depth = np.pad(depth,\n                    pad_width=((config['extrapolation_thickness'], config['extrapolation_thickness']),\n                               (config['extrapolation_thickness'], config['extrapolation_thickness'])),\n                    mode='constant')\n\n    return LDI, xy2depth, image, depth\n\n\ndef tear_edges(mesh, threshold = 0.00025, xy2depth=None):\n    remove_edge_list = []\n    remove_horizon, remove_vertical = np.zeros((2, mesh.graph['H'], mesh.graph['W']))\n    mesh_nodes = mesh.nodes\n    for edge in mesh.edges:\n        if abs(mesh_nodes[edge[0]]['disp'] - mesh_nodes[edge[1]]['disp']) > threshold:\n            remove_edge_list.append((edge[0], edge[1]))\n\n            near, far = edge if abs(edge[0][2]) < abs(edge[1][2]) else edge[::-1]\n\n            mesh_nodes[far]['near'] = [] if mesh_nodes[far].get('near') is None else mesh_nodes[far]['near'].append(near)\n            mesh_nodes[near]['far'] = [] if mesh_nodes[near].get('far') is None else mesh_nodes[near]['far'].append(far)\n\n            if near[0] == far[0]:\n                remove_horizon[near[0], np.minimum(near[1], far[1])] = 1\n            elif near[1] == far[1]:\n                remove_vertical[np.minimum(near[0], far[0]), near[1]] = 1\n    mesh.remove_edges_from(remove_edge_list)\n\n    remove_edge_list = []\n\n    dang_horizon = np.where(np.roll(remove_horizon, 1, 0) + np.roll(remove_horizon, -1, 0) - remove_horizon == 2)\n    dang_vertical = np.where(np.roll(remove_vertical, 1, 1) + np.roll(remove_vertical, -1, 1) - remove_vertical == 2)\n\n    horizon_condition = lambda x, y: mesh.graph['bord_up'] + 1 <= x < mesh.graph['bord_down'] - 1\n    vertical_condition = lambda x, y: mesh.graph['bord_left'] + 1 <= y < mesh.graph['bord_right'] - 1\n\n    prjto3d = lambda x, y: (x, y, xy2depth[(x, y)][0])\n\n    node_existence = lambda x, y: mesh.has_node(prjto3d(x, y))\n\n    for x, y in zip(dang_horizon[0], dang_horizon[1]):\n        if horizon_condition(x, y) and node_existence(x, y) and node_existence(x, y+1):\n            remove_edge_list.append((prjto3d(x, y), prjto3d(x, y+1)))\n    for x, y in zip(dang_vertical[0], dang_vertical[1]):\n        if vertical_condition(x, y) and node_existence(x, y) and node_existence(x+1, y):\n            remove_edge_list.append((prjto3d(x, y), prjto3d(x+1, y)))\n    mesh.remove_edges_from(remove_edge_list)\n\n    return mesh\n\ndef calculate_fov(mesh):\n    k = mesh.graph['cam_param']\n    mesh.graph['hFov'] = 2 * np.arctan(1. / (2*k[0, 0]))\n    mesh.graph['vFov'] = 2 * np.arctan(1. / (2*k[1, 1]))\n    mesh.graph['aspect'] = mesh.graph['noext_H'] / mesh.graph['noext_W']\n\n    return mesh\n\ndef calculate_fov_FB(mesh):\n    mesh.graph['aspect'] = mesh.graph['H'] / mesh.graph['W']\n    if mesh.graph['H'] > mesh.graph['W']:\n        mesh.graph['hFov'] = 0.508015513\n        half_short = np.tan(mesh.graph['hFov']/2.0)\n        half_long = half_short * mesh.graph['aspect']\n        mesh.graph['vFov'] = 2.0 * np.arctan(half_long)\n    else:\n        mesh.graph['vFov'] = 0.508015513\n        half_short = np.tan(mesh.graph['vFov']/2.0)\n        half_long = half_short / mesh.graph['aspect']\n        mesh.graph['hFov'] = 2.0 * np.arctan(half_long)\n\n    return mesh\n\ndef reproject_3d_int_detail(sx, sy, z, k_00, k_02, k_11, k_12, w_offset, h_offset):\n    abs_z = abs(z)\n    return [abs_z * ((sy+0.5-w_offset) * k_00 + k_02), abs_z * ((sx+0.5-h_offset) * k_11 + k_12), abs_z]\n\ndef reproject_3d_int_detail_FB(sx, sy, z, w_offset, h_offset, mesh):\n    if mesh.graph.get('tan_hFov') is None:\n        mesh.graph['tan_hFov'] = np.tan(mesh.graph['hFov'] / 2.)\n    if mesh.graph.get('tan_vFov') is None:\n        mesh.graph['tan_vFov'] = np.tan(mesh.graph['vFov'] / 2.)\n\n    ray = np.array([(-1. + 2. * ((sy+0.5-w_offset)/(mesh.graph['W'] - 1))) * mesh.graph['tan_hFov'],\n                    (1. - 2. * (sx+0.5-h_offset)/(mesh.graph['H'] - 1)) * mesh.graph['tan_vFov'],\n                    -1])\n    point_3d = ray * np.abs(z)\n\n    return point_3d\n\n\ndef reproject_3d_int(sx, sy, z, mesh):\n    k = mesh.graph['cam_param_pix_inv'].copy()\n    if k[0, 2] > 0:\n        k = np.linalg.inv(k)\n    ray = np.dot(k, np.array([sy-mesh.graph['woffset'], sx-mesh.graph['hoffset'], 1]).reshape(3, 1))\n\n    point_3d = ray * np.abs(z)\n    point_3d = point_3d.flatten()\n\n    return point_3d\n\ndef generate_init_node(mesh, config, min_node_in_cc):\n    mesh_nodes = mesh.nodes\n\n    info_on_pix = {}\n\n    ccs = sorted(netx.connected_components(mesh), key = len, reverse=True)\n    remove_nodes = []\n\n    for cc in ccs:\n\n        remove_flag = True if len(cc) < min_node_in_cc else False\n        if remove_flag is False:\n            for (nx, ny, nd) in cc:\n                info_on_pix[(nx, ny)] = [{'depth':nd,\n                                          'color':mesh_nodes[(nx, ny, nd)]['color'],\n                                          'synthesis':False,\n                                          'disp':mesh_nodes[(nx, ny, nd)]['disp']}]\n        else:\n            [remove_nodes.append((nx, ny, nd)) for (nx, ny, nd) in cc]\n\n    for node in remove_nodes:\n        far_nodes = [] if mesh_nodes[node].get('far') is None else mesh_nodes[node]['far']\n        for far_node in far_nodes:\n            if mesh.has_node(far_node) and mesh_nodes[far_node].get('near') is not None and node in mesh_nodes[far_node]['near']:\n                mesh_nodes[far_node]['near'].remove(node)\n        near_nodes = [] if mesh_nodes[node].get('near') is None else mesh_nodes[node]['near']\n        for near_node in near_nodes:\n            if mesh.has_node(near_node) and mesh_nodes[near_node].get('far') is not None and node in mesh_nodes[near_node]['far']:\n                mesh_nodes[near_node]['far'].remove(node)\n\n    [mesh.remove_node(node) for node in remove_nodes]\n\n    return mesh, info_on_pix\n\ndef get_neighbors(mesh, node):\n    return [*mesh.neighbors(node)]\n\ndef generate_face(mesh, info_on_pix, config):\n    H, W = mesh.graph['H'], mesh.graph['W']\n    str_faces = []\n    num_node = len(mesh.nodes)\n    ply_flag = config.get('save_ply')\n    def out_fmt(input, cur_id_b, cur_id_self, cur_id_a, ply_flag):\n        if ply_flag is True:\n            input.append(' '.join(['3', cur_id_b, cur_id_self, cur_id_a]) + '\\n')\n        else:\n            input.append([cur_id_b, cur_id_self, cur_id_a])\n    mesh_nodes = mesh.nodes\n    for node in mesh_nodes:\n        cur_id_self = mesh_nodes[node]['cur_id']\n        ne_nodes = get_neighbors(mesh, node)\n        four_dir_nes = {'up': [], 'left': [],\n                        'down': [], 'right': []}\n        for ne_node in ne_nodes:\n            store_tuple = [ne_node, mesh_nodes[ne_node]['cur_id']]\n            if ne_node[0] == node[0]:\n                if ne_node[1] == ne_node[1] - 1:\n                    four_dir_nes['left'].append(store_tuple)\n                else:\n                    four_dir_nes['right'].append(store_tuple)\n            else:\n                if ne_node[0] == ne_node[0] - 1:\n                    four_dir_nes['up'].append(store_tuple)\n                else:\n                    four_dir_nes['down'].append(store_tuple)\n        for node_a, cur_id_a in four_dir_nes['up']:\n            for node_b, cur_id_b in four_dir_nes['right']:\n                out_fmt(str_faces, cur_id_b, cur_id_self, cur_id_a, ply_flag)\n        for node_a, cur_id_a in four_dir_nes['right']:\n            for node_b, cur_id_b in four_dir_nes['down']:\n                out_fmt(str_faces, cur_id_b, cur_id_self, cur_id_a, ply_flag)\n        for node_a, cur_id_a in four_dir_nes['down']:\n            for node_b, cur_id_b in four_dir_nes['left']:\n                out_fmt(str_faces, cur_id_b, cur_id_self, cur_id_a, ply_flag)\n        for node_a, cur_id_a in four_dir_nes['left']:\n            for node_b, cur_id_b in four_dir_nes['up']:\n                out_fmt(str_faces, cur_id_b, cur_id_self, cur_id_a, ply_flag)\n\n    return str_faces\n\ndef reassign_floating_island(mesh, info_on_pix, image, depth):\n    H, W = mesh.graph['H'], mesh.graph['W'],\n    mesh_nodes = mesh.nodes\n    bord_up, bord_down = mesh.graph['bord_up'], mesh.graph['bord_down']\n    bord_left, bord_right = mesh.graph['bord_left'], mesh.graph['bord_right']\n    W = mesh.graph['W']\n    lost_map = np.zeros((H, W))\n\n    '''\n    (5) is_inside(x, y, xmin, xmax, ymin, ymax) : Check if a pixel(x, y) is inside the border.\n    (6) get_cross_nes(x, y) : Get the four cross neighbors of pixel(x, y).\n    '''\n    key_exist = lambda d, k: k in d\n    is_inside = lambda x, y, xmin, xmax, ymin, ymax: xmin <= x < xmax and ymin <= y < ymax\n    get_cross_nes = lambda x, y: [(x + 1, y), (x - 1, y), (x, y - 1), (x, y + 1)]\n    '''\n    (A) Highlight the pixels on isolated floating island.\n    (B) Number those isolated floating islands with connected component analysis.\n    (C) For each isolated island:\n        (1) Find its longest surrounded depth edge.\n        (2) Propogate depth from that depth edge to the pixels on the isolated island.\n        (3) Build the connection between the depth edge and that isolated island.\n    '''\n    for x in range(H):\n        for y in range(W):\n            if is_inside(x, y, bord_up, bord_down, bord_left, bord_right) and not(key_exist(info_on_pix, (x, y))):\n                lost_map[x, y] = 1\n    _, label_lost_map = cv2.connectedComponents(lost_map.astype(np.uint8), connectivity=4)\n    mask = np.zeros((H, W))\n    mask[bord_up:bord_down, bord_left:bord_right] = 1\n    label_lost_map = (label_lost_map * mask).astype(np.int)\n\n    for i in range(1, label_lost_map.max()+1):\n        lost_xs, lost_ys = np.where(label_lost_map == i)\n        surr_edge_ids = {}\n        for lost_x, lost_y in zip(lost_xs, lost_ys):\n            if (lost_x, lost_y) == (295, 389) or (lost_x, lost_y) == (296, 389):\n                import pdb; pdb.set_trace()\n            for ne in get_cross_nes(lost_x, lost_y):\n                if key_exist(info_on_pix, ne):\n                    for info in info_on_pix[ne]:\n                        ne_node = (ne[0], ne[1], info['depth'])\n                        if key_exist(mesh_nodes[ne_node], 'edge_id'):\n                            edge_id = mesh_nodes[ne_node]['edge_id']\n                            surr_edge_ids[edge_id] = surr_edge_ids[edge_id] + [ne_node] if \\\n                                                key_exist(surr_edge_ids, edge_id) else [ne_node]\n        if len(surr_edge_ids) == 0:\n            continue\n        edge_id, edge_nodes = sorted([*surr_edge_ids.items()], key=lambda x: len(x[1]), reverse=True)[0]\n        edge_depth_map = np.zeros((H, W))\n        for node in edge_nodes:\n            edge_depth_map[node[0], node[1]] = node[2]\n        lost_xs, lost_ys = np.where(label_lost_map == i)\n        while lost_xs.shape[0] > 0:\n            lost_xs, lost_ys = np.where(label_lost_map == i)\n            for lost_x, lost_y in zip(lost_xs, lost_ys):\n                propagated_depth = []\n                real_nes = []\n                for ne in get_cross_nes(lost_x, lost_y):\n                    if not(is_inside(ne[0], ne[1], bord_up, bord_down, bord_left, bord_right)) or \\\n                       edge_depth_map[ne[0], ne[1]] == 0:\n                        continue\n                    propagated_depth.append(edge_depth_map[ne[0], ne[1]])\n                    real_nes.append(ne)\n                if len(real_nes) == 0:\n                    continue\n                reassign_depth = np.mean(propagated_depth)\n                label_lost_map[lost_x, lost_y] = 0\n                edge_depth_map[lost_x, lost_y] = reassign_depth\n                depth[lost_x, lost_y] = -reassign_depth\n                mesh.add_node((lost_x, lost_y, reassign_depth), color=image[lost_x, lost_y],\n                                                            synthesis=False,\n                                                            disp=1./reassign_depth,\n                                                            cc_id=set())\n                info_on_pix[(lost_x, lost_y)] = [{'depth':reassign_depth,\n                                                  'color':image[lost_x, lost_y],\n                                                  'synthesis':False,\n                                                  'disp':1./reassign_depth}]\n                new_connections = [((lost_x, lost_y, reassign_depth),\n                                    (ne[0], ne[1], edge_depth_map[ne[0], ne[1]])) for ne in real_nes]\n                mesh.add_edges_from(new_connections)\n\n    return mesh, info_on_pix, depth\n\ndef remove_node_feat(mesh, *feats):\n    mesh_nodes = mesh.nodes\n    for node in mesh_nodes:\n        for feat in feats:\n            mesh_nodes[node][feat] = None\n\n    return mesh\n\ndef update_status(mesh, info_on_pix, depth=None):\n    '''\n    (2) clear_node_feat(G, *fts) : Clear all the node feature on graph G.\n    (6) get_cross_nes(x, y) : Get the four cross neighbors of pixel(x, y).\n    '''\n    key_exist = lambda d, k: d.get(k) is not None\n    is_inside = lambda x, y, xmin, xmax, ymin, ymax: xmin <= x < xmax and ymin <= y < ymax\n    get_cross_nes = lambda x, y: [(x + 1, y), (x - 1, y), (x, y - 1), (x, y + 1)]\n    append_element = lambda d, k, x: d[k] + [x] if key_exist(d, k) else [x]\n\n    def clear_node_feat(G, fts):\n        le_nodes = G.nodes\n        for k in le_nodes:\n            v = le_nodes[k]\n            for ft in fts:\n                if ft in v:\n                    v[ft] = None\n\n    clear_node_feat(mesh, ['edge_id', 'far', 'near'])\n    bord_up, bord_down = mesh.graph['bord_up'], mesh.graph['bord_down']\n    bord_left, bord_right = mesh.graph['bord_left'], mesh.graph['bord_right']\n\n    le_nodes = mesh.nodes\n\n    for node_key in le_nodes:\n        if mesh.neighbors(node_key).__length_hint__() == 4:\n            continue\n        four_nes = [xx for xx in get_cross_nes(node_key[0], node_key[1]) if\n                    is_inside(xx[0], xx[1], bord_up, bord_down, bord_left, bord_right) and\n                    xx in info_on_pix]\n        [four_nes.remove((ne_node[0], ne_node[1])) for ne_node in mesh.neighbors(node_key)]\n        for ne in four_nes:\n            for info in info_on_pix[ne]:\n                assert mesh.has_node((ne[0], ne[1], info['depth'])), \"No node_key\"\n                ind_node = le_nodes[node_key]\n                if abs(node_key[2]) > abs(info['depth']):\n                    ind_node['near'] = append_element(ind_node, 'near', (ne[0], ne[1], info['depth']))\n                else:\n                    ind_node['far'] = append_element(ind_node, 'far', (ne[0], ne[1], info['depth']))\n    if depth is not None:\n        for key, value in info_on_pix.items():\n            if depth[key[0], key[1]] != abs(value[0]['depth']):\n                value[0]['disp'] = 1. / value[0]['depth']\n                depth[key[0], key[1]] = abs(value[0]['depth'])\n\n        return mesh, depth, info_on_pix\n    else:\n        return mesh\n\ndef group_edges(LDI, config, image, remove_conflict_ordinal, spdb=False):\n\n    '''\n    (1) add_new_node(G, node) : add \"node\" to graph \"G\"\n    (2) add_new_edge(G, node_a, node_b) : add edge \"node_a--node_b\" to graph \"G\"\n    (3) exceed_thre(x, y, thre) : Check if difference between \"x\" and \"y\" exceed threshold \"thre\"\n    (4) key_exist(d, k) : Check if key \"k' exists in dictionary \"d\"\n    (5) comm_opp_bg(G, x, y) : Check if node \"x\" and \"y\" in graph \"G\" treat the same opposite node as background\n    (6) comm_opp_fg(G, x, y) : Check if node \"x\" and \"y\" in graph \"G\" treat the same opposite node as foreground\n    '''\n    add_new_node = lambda G, node: None if G.has_node(node) else G.add_node(node)\n    add_new_edge = lambda G, node_a, node_b: None if G.has_edge(node_a, node_b) else G.add_edge(node_a, node_b)\n    exceed_thre = lambda x, y, thre: (abs(x) - abs(y)) > thre\n    key_exist = lambda d, k: d.get(k) is not None\n    comm_opp_bg = lambda G, x, y: key_exist(G.nodes[x], 'far') and key_exist(G.nodes[y], 'far') and \\\n                                    not(set(G.nodes[x]['far']).isdisjoint(set(G.nodes[y]['far'])))\n    comm_opp_fg = lambda G, x, y: key_exist(G.nodes[x], 'near') and key_exist(G.nodes[y], 'near') and \\\n                                    not(set(G.nodes[x]['near']).isdisjoint(set(G.nodes[y]['near'])))\n    discont_graph = netx.Graph()\n    '''\n    (A) Skip the pixel at image boundary, we don't want to deal with them.\n    (B) Identify discontinuity by the number of its neighbor(degree).\n        If the degree < 4(up/right/buttom/left). We will go through following steps:\n        (1) Add the discontinuity pixel \"node\" to graph \"discont_graph\".\n        (2) Find \"node\"'s cross neighbor(up/right/buttom/left) \"ne_node\".\n            - If the cross neighbor \"ne_node\" is a discontinuity pixel(degree(\"ne_node\") < 4),\n                (a) add it to graph \"discont_graph\" and build the connection between \"ne_node\" and \"node\".\n                (b) label its cross neighbor as invalid pixels \"inval_diag_candi\" to avoid building\n                    connection between original discontinuity pixel \"node\" and \"inval_diag_candi\".\n            - Otherwise, find \"ne_node\"'s cross neighbors, called diagonal candidate \"diag_candi\".\n                - The \"diag_candi\" is diagonal to the original discontinuity pixel \"node\".\n                - If \"diag_candi\" exists, go to step(3).\n        (3) A diagonal candidate \"diag_candi\" will be :\n            - added to the \"discont_graph\" if its degree < 4.\n            - connected to the original discontinuity pixel \"node\" if it satisfied either\n                one of following criterion:\n                (a) the difference of disparity between \"diag_candi\" and \"node\" is smaller than default threshold.\n                (b) the \"diag_candi\" and \"node\" face the same opposite pixel. (See. function \"tear_edges\")\n                (c) Both of \"diag_candi\" and \"node\" must_connect to each other. (See. function \"combine_end_node\")\n    (C) Aggregate each connected part in \"discont_graph\" into \"discont_ccs\" (A.K.A. depth edge).\n    '''\n    for node in LDI.nodes:\n        if not(LDI.graph['bord_up'] + 1 <= node[0] <= LDI.graph['bord_down'] - 2 and \\\n               LDI.graph['bord_left'] + 1 <= node[1] <= LDI.graph['bord_right'] - 2):\n            continue\n        neighbors = [*LDI.neighbors(node)]\n        if len(neighbors) < 4:\n            add_new_node(discont_graph, node)\n            diag_candi_anc, inval_diag_candi, discont_nes = set(), set(), set()\n            for ne_node in neighbors:\n                if len([*LDI.neighbors(ne_node)]) < 4:\n                    add_new_node(discont_graph, ne_node)\n                    add_new_edge(discont_graph, ne_node, node)\n                    discont_nes.add(ne_node)\n                else:\n                    diag_candi_anc.add(ne_node)\n            inval_diag_candi = set([inval_diagonal for ne_node in discont_nes for inval_diagonal in LDI.neighbors(ne_node) if \\\n                                     abs(inval_diagonal[0] - node[0]) < 2 and abs(inval_diagonal[1] - node[1]) < 2])\n            for ne_node in diag_candi_anc:\n                if ne_node[0] == node[0]:\n                    diagonal_xys = [[ne_node[0] + 1, ne_node[1]], [ne_node[0] - 1, ne_node[1]]]\n                elif ne_node[1] == node[1]:\n                    diagonal_xys = [[ne_node[0], ne_node[1] + 1], [ne_node[0], ne_node[1] - 1]]\n                for diag_candi in LDI.neighbors(ne_node):\n                    if [diag_candi[0], diag_candi[1]] in diagonal_xys and LDI.degree(diag_candi) < 4:\n                        if diag_candi not in inval_diag_candi:\n                            if not exceed_thre(1./node[2], 1./diag_candi[2], config['depth_threshold']) or \\\n                               (comm_opp_bg(LDI, diag_candi, node) and comm_opp_fg(LDI, diag_candi, node)):\n                                add_new_node(discont_graph, diag_candi)\n                                add_new_edge(discont_graph, diag_candi, node)\n                        if key_exist(LDI.nodes[diag_candi], 'must_connect') and node in LDI.nodes[diag_candi]['must_connect'] and \\\n                            key_exist(LDI.nodes[node], 'must_connect') and diag_candi in LDI.nodes[node]['must_connect']:\n                            add_new_node(discont_graph, diag_candi)\n                            add_new_edge(discont_graph, diag_candi, node)\n    if spdb == True:\n        import pdb; pdb.set_trace()\n    discont_ccs = [*netx.connected_components(discont_graph)]\n    '''\n    In some corner case, a depth edge \"discont_cc\" will contain both\n    foreground(FG) and background(BG) pixels. This violate the assumption that\n    a depth edge can only composite by one type of pixel(FG or BG).\n    We need to further divide this depth edge into several sub-part so that the\n    assumption is satisfied.\n    (A) A depth edge is invalid if both of its \"far_flag\"(BG) and\n        \"near_flag\"(FG) are True.\n    (B) If the depth edge is invalid, we need to do:\n        (1) Find the role(\"oridinal\") of each pixel on the depth edge.\n            \"-1\" --> Its opposite pixels has smaller depth(near) than it.\n                     It is a backgorund pixel.\n            \"+1\" --> Its opposite pixels has larger depth(far) than it.\n                     It is a foregorund pixel.\n            \"0\"  --> Some of opposite pixels has larger depth(far) than it,\n                     and some has smaller pixel than it.\n                     It is an ambiguous pixel.\n        (2) For each pixel \"discont_node\", check if its neigbhors' roles are consistent.\n            - If not, break the connection between the neighbor \"ne_node\" that has a role\n              different from \"discont_node\".\n            - If yes, remove all the role that are inconsistent to its neighbors \"ne_node\".\n        (3) Connected component analysis to re-identified those divided depth edge.\n    (C) Aggregate each connected part in \"discont_graph\" into \"discont_ccs\" (A.K.A. depth edge).\n    '''\n    if remove_conflict_ordinal:\n        new_discont_ccs = []\n        num_new_cc = 0\n        for edge_id, discont_cc in enumerate(discont_ccs):\n            near_flag = False\n            far_flag = False\n            for discont_node in discont_cc:\n                near_flag = True if key_exist(LDI.nodes[discont_node], 'far') else near_flag\n                far_flag = True if key_exist(LDI.nodes[discont_node], 'near') else far_flag\n                if far_flag and near_flag:\n                    break\n            if far_flag and near_flag:\n                for discont_node in discont_cc:\n                    discont_graph.nodes[discont_node]['ordinal'] = \\\n                        np.array([key_exist(LDI.nodes[discont_node], 'far'),\n                                  key_exist(LDI.nodes[discont_node], 'near')]) * \\\n                        np.array([-1, 1])\n                    discont_graph.nodes[discont_node]['ordinal'] = \\\n                        np.sum(discont_graph.nodes[discont_node]['ordinal'])\n                remove_nodes, remove_edges = [], []\n                for discont_node in discont_cc:\n                    ordinal_relation = np.sum([discont_graph.nodes[xx]['ordinal'] \\\n                                               for xx in discont_graph.neighbors(discont_node)])\n                    near_side = discont_graph.nodes[discont_node]['ordinal'] <= 0\n                    if abs(ordinal_relation) < len([*discont_graph.neighbors(discont_node)]):\n                        remove_nodes.append(discont_node)\n                        for ne_node in discont_graph.neighbors(discont_node):\n                            remove_flag = (near_side and not(key_exist(LDI.nodes[ne_node], 'far'))) or \\\n                                          (not near_side and not(key_exist(LDI.nodes[ne_node], 'near')))\n                            remove_edges += [(discont_node, ne_node)] if remove_flag else []\n                    else:\n                        if near_side and key_exist(LDI.nodes[discont_node], 'near'):\n                            LDI.nodes[discont_node].pop('near')\n                        elif not(near_side) and key_exist(LDI.nodes[discont_node], 'far'):\n                            LDI.nodes[discont_node].pop('far')\n                discont_graph.remove_edges_from(remove_edges)\n                sub_mesh = discont_graph.subgraph(list(discont_cc)).copy()\n                sub_discont_ccs = [*netx.connected_components(sub_mesh)]\n                is_redun_near = lambda xx: len(xx) == 1 and xx[0] in remove_nodes and key_exist(LDI.nodes[xx[0]], 'far')\n                for sub_discont_cc in sub_discont_ccs:\n                    if is_redun_near(list(sub_discont_cc)):\n                        LDI.nodes[list(sub_discont_cc)[0]].pop('far')\n                    new_discont_ccs.append(sub_discont_cc)\n            else:\n                new_discont_ccs.append(discont_cc)\n        discont_ccs = new_discont_ccs\n        new_discont_ccs = None\n    if spdb == True:\n        import pdb; pdb.set_trace()\n\n    for edge_id, edge_cc in enumerate(discont_ccs):\n        for node in edge_cc:\n            LDI.nodes[node]['edge_id'] = edge_id\n\n    return discont_ccs, LDI, discont_graph\n\ndef combine_end_node(mesh, edge_mesh, edge_ccs, depth):\n    import collections\n    mesh_nodes = mesh.nodes\n    connect_dict = dict()\n    for valid_edge_id, valid_edge_cc in enumerate(edge_ccs):\n        connect_info = []\n        for valid_edge_node in valid_edge_cc:\n            single_connect = set()\n            for ne_node in mesh.neighbors(valid_edge_node):\n                if mesh_nodes[ne_node].get('far') is not None:\n                    for fn in mesh_nodes[ne_node].get('far'):\n                        if mesh.has_node(fn) and mesh_nodes[fn].get('edge_id') is not None:\n                            single_connect.add(mesh_nodes[fn]['edge_id'])\n                if mesh_nodes[ne_node].get('near') is not None:\n                    for fn in mesh_nodes[ne_node].get('near'):\n                        if mesh.has_node(fn) and mesh_nodes[fn].get('edge_id') is not None:\n                            single_connect.add(mesh_nodes[fn]['edge_id'])\n            connect_info.extend([*single_connect])\n        connect_dict[valid_edge_id] = collections.Counter(connect_info)\n\n    end_maps = np.zeros((mesh.graph['H'], mesh.graph['W']))\n    edge_maps = np.zeros((mesh.graph['H'], mesh.graph['W'])) - 1\n    for valid_edge_id, valid_edge_cc in enumerate(edge_ccs):\n        for valid_edge_node in valid_edge_cc:\n            edge_maps[valid_edge_node[0], valid_edge_node[1]] = valid_edge_id\n            if len([*edge_mesh.neighbors(valid_edge_node)]) == 1:\n                num_ne = 1\n                if num_ne == 1:\n                    end_maps[valid_edge_node[0], valid_edge_node[1]] = valid_edge_node[2]\n    nxs, nys = np.where(end_maps != 0)\n    invalid_nodes = set()\n    for nx, ny in zip(nxs, nys):\n        if mesh.has_node((nx, ny, end_maps[nx, ny])) is False:\n            invalid_nodes.add((nx, ny))\n            continue\n        four_nes = [xx for xx in [(nx - 1, ny), (nx + 1, ny), (nx, ny - 1), (nx, ny + 1)] \\\n                        if 0 <= xx[0] < mesh.graph['H'] and 0 <= xx[1] < mesh.graph['W'] and \\\n                        end_maps[xx[0], xx[1]] != 0]\n        mesh_nes = [*mesh.neighbors((nx, ny, end_maps[nx, ny]))]\n        remove_num = 0\n        for fne in four_nes:\n            if (fne[0], fne[1], end_maps[fne[0], fne[1]]) in mesh_nes:\n                remove_num += 1\n        if remove_num == len(four_nes):\n            invalid_nodes.add((nx, ny))\n    for invalid_node in invalid_nodes:\n        end_maps[invalid_node[0], invalid_node[1]] = 0\n\n    nxs, nys = np.where(end_maps != 0)\n    invalid_nodes = set()\n    for nx, ny in zip(nxs, nys):\n        if mesh_nodes[(nx, ny, end_maps[nx, ny])].get('edge_id') is None:\n            continue\n        else:\n            self_id = mesh_nodes[(nx, ny, end_maps[nx, ny])].get('edge_id')\n            self_connect = connect_dict[self_id] if connect_dict.get(self_id) is not None else dict()\n        four_nes = [xx for xx in [(nx - 1, ny), (nx + 1, ny), (nx, ny - 1), (nx, ny + 1)] \\\n                        if 0 <= xx[0] < mesh.graph['H'] and 0 <= xx[1] < mesh.graph['W'] and \\\n                        end_maps[xx[0], xx[1]] != 0]\n        for fne in four_nes:\n            if mesh_nodes[(fne[0], fne[1], end_maps[fne[0], fne[1]])].get('edge_id') is None:\n                continue\n            else:\n                ne_id = mesh_nodes[(fne[0], fne[1], end_maps[fne[0], fne[1]])]['edge_id']\n                if self_connect.get(ne_id) is None or self_connect.get(ne_id) == 1:\n                    continue\n                else:\n                    invalid_nodes.add((nx, ny))\n    for invalid_node in invalid_nodes:\n        end_maps[invalid_node[0], invalid_node[1]] = 0\n    nxs, nys = np.where(end_maps != 0)\n    invalid_nodes = set()\n    for nx, ny in zip(nxs, nys):\n        four_nes = [xx for xx in [(nx - 1, ny), (nx + 1, ny), (nx, ny - 1), (nx, ny + 1)] \\\n                        if 0 <= xx[0] < mesh.graph['H'] and 0 <= xx[1] < mesh.graph['W'] and \\\n                        end_maps[xx[0], xx[1]] != 0]\n        for fne in four_nes:\n            if mesh.has_node((fne[0], fne[1], end_maps[fne[0], fne[1]])):\n                node_a, node_b = (fne[0], fne[1], end_maps[fne[0], fne[1]]), (nx, ny, end_maps[nx, ny])\n                mesh.add_edge(node_a, node_b)\n                mesh_nodes[node_b]['must_connect'] = set() if mesh_nodes[node_b].get('must_connect') is None else mesh_nodes[node_b]['must_connect']\n                mesh_nodes[node_b]['must_connect'].add(node_a)\n                mesh_nodes[node_b]['must_connect'] |= set([xx for xx in [*edge_mesh.neighbors(node_a)] if \\\n                                                            (xx[0] - node_b[0]) < 2 and (xx[1] - node_b[1]) < 2])\n                mesh_nodes[node_a]['must_connect'] = set() if mesh_nodes[node_a].get('must_connect') is None else mesh_nodes[node_a]['must_connect']\n                mesh_nodes[node_a]['must_connect'].add(node_b)\n                mesh_nodes[node_a]['must_connect'] |= set([xx for xx in [*edge_mesh.neighbors(node_b)] if \\\n                                                            (xx[0] - node_a[0]) < 2 and (xx[1] - node_a[1]) < 2])\n                invalid_nodes.add((nx, ny))\n    for invalid_node in invalid_nodes:\n        end_maps[invalid_node[0], invalid_node[1]] = 0\n\n    return mesh\n\ndef remove_redundant_edge(mesh, edge_mesh, edge_ccs, info_on_pix, config, redundant_number=1000, invalid=False, spdb=False):\n    point_to_amount = {}\n    point_to_id = {}\n    end_maps = np.zeros((mesh.graph['H'], mesh.graph['W'])) - 1\n    for valid_edge_id, valid_edge_cc in enumerate(edge_ccs):\n        for valid_edge_node in valid_edge_cc:\n            point_to_amount[valid_edge_node] = len(valid_edge_cc)\n            point_to_id[valid_edge_node] = valid_edge_id\n            if edge_mesh.has_node(valid_edge_node) is True:\n                if len([*edge_mesh.neighbors(valid_edge_node)]) == 1:\n                    end_maps[valid_edge_node[0], valid_edge_node[1]] = valid_edge_id\n    nxs, nys = np.where(end_maps > -1)\n    point_to_adjoint = {}\n    for nx, ny in zip(nxs, nys):\n        adjoint_edges = set([end_maps[x, y] for x, y in [(nx + 1, ny), (nx - 1, ny), (nx, ny + 1), (nx, ny - 1)] if end_maps[x, y] != -1])\n        point_to_adjoint[end_maps[nx, ny]] = (point_to_adjoint[end_maps[nx, ny]] | adjoint_edges) if point_to_adjoint.get(end_maps[nx, ny]) is not None else adjoint_edges\n    valid_edge_ccs = filter_edge(mesh, edge_ccs, config, invalid=invalid)\n    edge_canvas = np.zeros((mesh.graph['H'], mesh.graph['W'])) - 1\n    for valid_edge_id, valid_edge_cc in enumerate(valid_edge_ccs):\n        for valid_edge_node in valid_edge_cc:\n            edge_canvas[valid_edge_node[0], valid_edge_node[1]] = valid_edge_id\n    if spdb is True:\n        plt.imshow(edge_canvas); plt.show()\n        import pdb; pdb.set_trace()\n    for valid_edge_id, valid_edge_cc in enumerate(valid_edge_ccs):\n        end_number = 0\n        four_end_number = 0\n        eight_end_number = 0\n        db_eight_end_number = 0\n        if len(valid_edge_cc) > redundant_number:\n            continue\n        for valid_edge_node in valid_edge_cc:\n            if len([*edge_mesh.neighbors(valid_edge_node)]) == 3:\n                break\n            elif len([*edge_mesh.neighbors(valid_edge_node)]) == 1:\n                hx, hy, hz = valid_edge_node\n                if invalid is False:\n                    eight_nes = [(x, y) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1),\n                                                     (hx + 1, hy + 1), (hx - 1, hy - 1), (hx - 1, hy + 1), (hx + 1, hy - 1)] \\\n                                            if info_on_pix.get((x, y)) is not None and edge_canvas[x, y] != -1 and edge_canvas[x, y] != valid_edge_id]\n                    if len(eight_nes) == 0:\n                        end_number += 1\n                if invalid is True:\n                    four_nes = []; eight_nes = []; db_eight_nes = []\n                    four_nes = [(x, y) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1)] \\\n                                            if info_on_pix.get((x, y)) is not None and edge_canvas[x, y] != -1 and edge_canvas[x, y] != valid_edge_id]\n                    eight_nes = [(x, y) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1), \\\n                                                    (hx + 1, hy + 1), (hx - 1, hy - 1), (hx - 1, hy + 1), (hx + 1, hy - 1)] \\\n                                            if info_on_pix.get((x, y)) is not None and edge_canvas[x, y] != -1 and edge_canvas[x, y] != valid_edge_id]\n                    db_eight_nes = [(x, y) for x in range(hx - 2, hx + 3) for y in range(hy - 2, hy + 3) \\\n                                    if info_on_pix.get((x, y)) is not None and edge_canvas[x, y] != -1 and edge_canvas[x, y] != valid_edge_id and (x, y) != (hx, hy)]\n                    if len(four_nes) == 0 or len(eight_nes) == 0:\n                        end_number += 1\n                        if len(four_nes) == 0:\n                            four_end_number += 1\n                        if len(eight_nes) == 0:\n                            eight_end_number += 1\n                        if len(db_eight_nes) == 0:\n                            db_eight_end_number += 1\n            elif len([*edge_mesh.neighbors(valid_edge_node)]) == 0:\n                hx, hy, hz = valid_edge_node\n                four_nes = [(x, y, info_on_pix[(x, y)][0]['depth']) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1)] \\\n                                if info_on_pix.get((x, y)) is not None and \\\n                                    mesh.has_edge(valid_edge_node, (x, y, info_on_pix[(x, y)][0]['depth'])) is False]\n                for ne in four_nes:\n                    try:\n                        if invalid is True or (point_to_amount.get(ne) is None or point_to_amount[ne] < redundant_number) or \\\n                            point_to_id[ne] in point_to_adjoint.get(point_to_id[valid_edge_node], set()):\n                            mesh.add_edge(valid_edge_node, ne)\n                    except:\n                        import pdb; pdb.set_trace()\n        if (invalid is not True and end_number >= 1) or (invalid is True and end_number >= 2 and eight_end_number >= 1 and db_eight_end_number >= 1):\n            for valid_edge_node in valid_edge_cc:\n                hx, hy, _ = valid_edge_node\n                four_nes = [(x, y, info_on_pix[(x, y)][0]['depth']) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1)] \\\n                                if info_on_pix.get((x, y)) is not None and \\\n                                    mesh.has_edge(valid_edge_node, (x, y, info_on_pix[(x, y)][0]['depth'])) is False and \\\n                                    (edge_canvas[x, y] == -1 or edge_canvas[x, y] == valid_edge_id)]\n                for ne in four_nes:\n                    if invalid is True or (point_to_amount.get(ne) is None or point_to_amount[ne] < redundant_number) or \\\n                        point_to_id[ne] in point_to_adjoint.get(point_to_id[valid_edge_node], set()):\n                        mesh.add_edge(valid_edge_node, ne)\n\n    return mesh\n\ndef judge_dangle(mark, mesh, node):\n    if not (1 <= node[0] < mesh.graph['H']-1) or not(1 <= node[1] < mesh.graph['W']-1):\n        return mark\n    mesh_neighbors = [*mesh.neighbors(node)]\n    mesh_neighbors = [xx for xx in mesh_neighbors if 0 < xx[0] < mesh.graph['H'] - 1 and 0 < xx[1] < mesh.graph['W'] - 1]\n    if len(mesh_neighbors) >= 3:\n        return mark\n    elif len(mesh_neighbors) <= 1:\n        mark[node[0], node[1]] = (len(mesh_neighbors) + 1)\n    else:\n        dan_ne_node_a = mesh_neighbors[0]\n        dan_ne_node_b = mesh_neighbors[1]\n        if abs(dan_ne_node_a[0] - dan_ne_node_b[0]) > 1 or \\\n            abs(dan_ne_node_a[1] - dan_ne_node_b[1]) > 1:\n            mark[node[0], node[1]] = 3\n\n    return mark\n\ndef remove_dangling(mesh, edge_ccs, edge_mesh, info_on_pix, image, depth, config):\n\n    tmp_edge_ccs = copy.deepcopy(edge_ccs)\n    for edge_cc_id, valid_edge_cc in enumerate(tmp_edge_ccs):\n        if len(valid_edge_cc) > 1 or len(valid_edge_cc) == 0:\n            continue\n        single_edge_node = [*valid_edge_cc][0]\n        hx, hy, hz = single_edge_node\n        eight_nes = set([(x, y, info_on_pix[(x, y)][0]['depth']) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1),\n                         (hx + 1, hy + 1), (hx - 1, hy - 1), (hx - 1, hy + 1), (hx + 1, hy - 1)] \\\n                         if info_on_pix.get((x, y)) is not None])\n        four_nes = [(x, y, info_on_pix[(x, y)][0]['depth']) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1)] \\\n                    if info_on_pix.get((x, y)) is not None]\n        sub_mesh = mesh.subgraph(eight_nes).copy()\n        ccs = netx.connected_components(sub_mesh)\n        four_ccs = []\n        for cc_id, _cc in enumerate(ccs):\n            four_ccs.append(set())\n            for cc_node in _cc:\n                if abs(cc_node[0] - hx) + abs(cc_node[1] - hy) < 2:\n                    four_ccs[cc_id].add(cc_node)\n        largest_cc = sorted(four_ccs, key=lambda x: (len(x), -np.sum([abs(xx[2] - hz) for xx in x])))[-1]\n        if len(largest_cc) < 2:\n            for ne in four_nes:\n                mesh.add_edge(single_edge_node, ne)\n        else:\n            mesh.remove_edges_from([(single_edge_node, ne) for ne in mesh.neighbors(single_edge_node)])\n            new_depth = np.mean([xx[2] for xx in largest_cc])\n            info_on_pix[(hx, hy)][0]['depth'] = new_depth\n            info_on_pix[(hx, hy)][0]['disp'] = 1./new_depth\n            new_node = (hx, hy, new_depth)\n            mesh = refresh_node(single_edge_node, mesh.node[single_edge_node], new_node, dict(), mesh)\n            edge_ccs[edge_cc_id] = set([new_node])\n            for ne in largest_cc:\n                mesh.add_edge(new_node, ne)\n\n    mark = np.zeros((mesh.graph['H'], mesh.graph['W']))\n    for edge_idx, edge_cc in enumerate(edge_ccs):\n        for edge_node in edge_cc:\n            if not (mesh.graph['bord_up'] <= edge_node[0] < mesh.graph['bord_down']-1) or \\\n               not (mesh.graph['bord_left'] <= edge_node[1] < mesh.graph['bord_right']-1):\n                continue\n            mesh_neighbors = [*mesh.neighbors(edge_node)]\n            mesh_neighbors = [xx for xx in mesh_neighbors \\\n                                if mesh.graph['bord_up'] < xx[0] < mesh.graph['bord_down'] - 1 and \\\n                                   mesh.graph['bord_left'] < xx[1] < mesh.graph['bord_right'] - 1]\n            if len([*mesh.neighbors(edge_node)]) >= 3:\n                continue\n            elif len([*mesh.neighbors(edge_node)]) <= 1:\n                mark[edge_node[0], edge_node[1]] += (len([*mesh.neighbors(edge_node)]) + 1)\n            else:\n                dan_ne_node_a = [*mesh.neighbors(edge_node)][0]\n                dan_ne_node_b = [*mesh.neighbors(edge_node)][1]\n                if abs(dan_ne_node_a[0] - dan_ne_node_b[0]) > 1 or \\\n                    abs(dan_ne_node_a[1] - dan_ne_node_b[1]) > 1:\n                    mark[edge_node[0], edge_node[1]] += 3\n    mxs, mys = np.where(mark == 1)\n    conn_0_nodes = [(x[0], x[1], info_on_pix[(x[0], x[1])][0]['depth']) for x in zip(mxs, mys) \\\n                        if mesh.has_node((x[0], x[1], info_on_pix[(x[0], x[1])][0]['depth']))]\n    mxs, mys = np.where(mark == 2)\n    conn_1_nodes = [(x[0], x[1], info_on_pix[(x[0], x[1])][0]['depth']) for x in zip(mxs, mys) \\\n                        if mesh.has_node((x[0], x[1], info_on_pix[(x[0], x[1])][0]['depth']))]\n    for node in conn_0_nodes:\n        hx, hy = node[0], node[1]\n        four_nes = [(x, y, info_on_pix[(x, y)][0]['depth']) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1)] \\\n                     if info_on_pix.get((x, y)) is not None]\n        re_depth = {'value' : 0, 'count': 0}\n        for ne in four_nes:\n            mesh.add_edge(node, ne)\n            re_depth['value'] += cc_node[2]\n            re_depth['count'] += 1.\n        re_depth = re_depth['value'] / re_depth['count']\n        mapping_dict = {node: (node[0], node[1], re_depth)}\n        info_on_pix, mesh, edge_mesh = update_info(mapping_dict, info_on_pix, mesh, edge_mesh)\n        depth[node[0], node[1]] = abs(re_depth)\n        mark[node[0], node[1]] = 0\n    for node in conn_1_nodes:\n        hx, hy = node[0], node[1]\n        eight_nes = set([(x, y, info_on_pix[(x, y)][0]['depth']) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1),\n                                                                           (hx + 1, hy + 1), (hx - 1, hy - 1), (hx - 1, hy + 1), (hx + 1, hy - 1)] \\\n                        if info_on_pix.get((x, y)) is not None])\n        self_nes = set([ne2 for ne1 in mesh.neighbors(node) for ne2 in mesh.neighbors(ne1) if ne2 in eight_nes])\n        eight_nes = [*(eight_nes - self_nes)]\n        sub_mesh = mesh.subgraph(eight_nes).copy()\n        ccs = netx.connected_components(sub_mesh)\n        largest_cc = sorted(ccs, key=lambda x: (len(x), -np.sum([abs(xx[0] - node[0]) + abs(xx[1] - node[1]) for xx in x])))[-1]\n\n        mesh.remove_edges_from([(xx, node) for xx in mesh.neighbors(node)])\n        re_depth = {'value' : 0, 'count': 0}\n        for cc_node in largest_cc:\n            if cc_node[0] == node[0] and cc_node[1] == node[1]:\n                continue\n            re_depth['value'] += cc_node[2]\n            re_depth['count'] += 1.\n            if abs(cc_node[0] - node[0]) + abs(cc_node[1] - node[1]) < 2:\n                mesh.add_edge(cc_node, node)\n        try:\n            re_depth = re_depth['value'] / re_depth['count']\n        except:\n            re_depth = node[2]\n        renode = (node[0], node[1], re_depth)\n        mapping_dict = {node: renode}\n        info_on_pix, mesh, edge_mesh = update_info(mapping_dict, info_on_pix, mesh, edge_mesh)\n        depth[node[0], node[1]] = abs(re_depth)\n        mark[node[0], node[1]] = 0\n        edge_mesh, mesh, mark, info_on_pix = recursive_add_edge(edge_mesh, mesh, info_on_pix, renode, mark)\n    mxs, mys = np.where(mark == 3)\n    conn_2_nodes = [(x[0], x[1], info_on_pix[(x[0], x[1])][0]['depth']) for x in zip(mxs, mys) \\\n                        if mesh.has_node((x[0], x[1], info_on_pix[(x[0], x[1])][0]['depth'])) and \\\n                            mesh.degree((x[0], x[1], info_on_pix[(x[0], x[1])][0]['depth'])) == 2]\n    sub_mesh = mesh.subgraph(conn_2_nodes).copy()\n    ccs = netx.connected_components(sub_mesh)\n    for cc in ccs:\n        candidate_nodes = [xx for xx in cc if sub_mesh.degree(xx) == 1]\n        for node in candidate_nodes:\n            if mesh.has_node(node) is False:\n                continue\n            ne_node = [xx for xx in mesh.neighbors(node) if xx not in cc][0]\n            hx, hy = node[0], node[1]\n            eight_nes = set([(x, y, info_on_pix[(x, y)][0]['depth']) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1),\n                                                                            (hx + 1, hy + 1), (hx - 1, hy - 1), (hx - 1, hy + 1), (hx + 1, hy - 1)] \\\n                              if info_on_pix.get((x, y)) is not None and (x, y, info_on_pix[(x, y)][0]['depth']) not in cc])\n            ne_sub_mesh = mesh.subgraph(eight_nes).copy()\n            ne_ccs = netx.connected_components(ne_sub_mesh)\n            try:\n                ne_cc = [ne_cc for ne_cc in ne_ccs if ne_node in ne_cc][0]\n            except:\n                import pdb; pdb.set_trace()\n            largest_cc = [xx for xx in ne_cc if abs(xx[0] - node[0]) + abs(xx[1] - node[1]) == 1]\n            mesh.remove_edges_from([(xx, node) for xx in mesh.neighbors(node)])\n            re_depth = {'value' : 0, 'count': 0}\n            for cc_node in largest_cc:\n                re_depth['value'] += cc_node[2]\n                re_depth['count'] += 1.\n                mesh.add_edge(cc_node, node)\n            try:\n                re_depth = re_depth['value'] / re_depth['count']\n            except:\n                re_depth = node[2]\n            renode = (node[0], node[1], re_depth)\n            mapping_dict = {node: renode}\n            info_on_pix, mesh, edge_mesh = update_info(mapping_dict, info_on_pix, mesh, edge_mesh)\n            depth[node[0], node[1]] = abs(re_depth)\n            mark[node[0], node[1]] = 0\n            edge_mesh, mesh, mark, info_on_pix = recursive_add_edge(edge_mesh, mesh, info_on_pix, renode, mark)\n            break\n        if len(cc) == 1:\n            node = [node for node in cc][0]\n            hx, hy = node[0], node[1]\n            nine_nes = set([(x, y, info_on_pix[(x, y)][0]['depth']) for x, y in [(hx, hy), (hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1),\n                                                                                  (hx + 1, hy + 1), (hx - 1, hy - 1), (hx - 1, hy + 1), (hx + 1, hy - 1)] \\\n                                if info_on_pix.get((x, y)) is not None and mesh.has_node((x, y, info_on_pix[(x, y)][0]['depth']))])\n            ne_sub_mesh = mesh.subgraph(nine_nes).copy()\n            ne_ccs = netx.connected_components(ne_sub_mesh)\n            for ne_cc in ne_ccs:\n                if node in ne_cc:\n                    re_depth = {'value' : 0, 'count': 0}\n                    for ne in ne_cc:\n                        if abs(ne[0] - node[0]) + abs(ne[1] - node[1]) == 1:\n                            mesh.add_edge(node, ne)\n                            re_depth['value'] += ne[2]\n                            re_depth['count'] += 1.\n                    re_depth = re_depth['value'] / re_depth['count']\n                    mapping_dict = {node: (node[0], node[1], re_depth)}\n                    info_on_pix, mesh, edge_mesh = update_info(mapping_dict, info_on_pix, mesh, edge_mesh)\n                    depth[node[0], node[1]] = abs(re_depth)\n                    mark[node[0], node[1]] = 0\n\n\n    return mesh, info_on_pix, edge_mesh, depth, mark\n\ndef context_and_holes(mesh, edge_ccs, config, specific_edge_id, specific_edge_loc, depth_feat_model,\n                      connect_points_ccs=None, inpaint_iter=0, filter_edge=False, vis_edge_id=None):\n    edge_maps = np.zeros((mesh.graph['H'], mesh.graph['W'])) - 1\n    mask_info = {}\n    for edge_id, edge_cc in enumerate(edge_ccs):\n        for edge_node in edge_cc:\n            edge_maps[edge_node[0], edge_node[1]] = edge_id\n\n    context_ccs = [set() for x in range(len(edge_ccs))]\n    extend_context_ccs = [set() for x in range(len(edge_ccs))]\n    extend_erode_context_ccs = [set() for x in range(len(edge_ccs))]\n    extend_edge_ccs = [set() for x in range(len(edge_ccs))]\n    accomp_extend_context_ccs = [set() for x in range(len(edge_ccs))]\n    erode_context_ccs = [set() for x in range(len(edge_ccs))]\n    broken_mask_ccs = [set() for x in range(len(edge_ccs))]\n    invalid_extend_edge_ccs = [set() for x in range(len(edge_ccs))]\n    intouched_ccs = [set() for x in range(len(edge_ccs))]\n    redundant_ccs = [set() for x in range(len(edge_ccs))]\n    if inpaint_iter == 0:\n        background_thickness = config['background_thickness']\n        context_thickness = config['context_thickness']\n    else:\n        background_thickness = config['background_thickness_2']\n        context_thickness = config['context_thickness_2']\n\n    mesh_nodes = mesh.nodes\n    for edge_id, edge_cc in enumerate(edge_ccs):\n        if context_thickness == 0 or (len(specific_edge_id) > 0 and edge_id not in specific_edge_id):\n            continue\n        edge_group = {}\n        for edge_node in edge_cc:\n            far_nodes = mesh_nodes[edge_node].get('far')\n            if far_nodes is None:\n                continue\n            for far_node in far_nodes:\n                if far_node in edge_cc:\n                    continue\n                context_ccs[edge_id].add(far_node)\n                if mesh_nodes[far_node].get('edge_id') is not None:\n                    if edge_group.get(mesh_nodes[far_node]['edge_id']) is None:\n                        edge_group[mesh_nodes[far_node]['edge_id']] = set()\n                    edge_group[mesh_nodes[far_node]['edge_id']].add(far_node)\n        if len(edge_cc) > 2:\n            for edge_key in [*edge_group.keys()]:\n                if len(edge_group[edge_key]) == 1:\n                    context_ccs[edge_id].remove([*edge_group[edge_key]][0])\n    for edge_id, edge_cc in enumerate(edge_ccs):\n        if inpaint_iter != 0:\n            continue\n        tmp_intouched_nodes = set()\n        for edge_node in edge_cc:\n            raw_intouched_nodes = set(mesh_nodes[edge_node].get('near')) if mesh_nodes[edge_node].get('near') is not None else set()\n            tmp_intouched_nodes |= set([xx for xx in raw_intouched_nodes if mesh_nodes[xx].get('edge_id') is not None and \\\n                                                                         len(context_ccs[mesh_nodes[xx].get('edge_id')]) > 0])\n        intouched_ccs[edge_id] |= tmp_intouched_nodes\n        tmp_intouched_nodes = None\n    mask_ccs = copy.deepcopy(edge_ccs)\n    forbidden_len = 3\n    forbidden_map = np.ones((mesh.graph['H'] - forbidden_len, mesh.graph['W'] - forbidden_len))\n    forbidden_map = np.pad(forbidden_map, ((forbidden_len, forbidden_len), (forbidden_len, forbidden_len)), mode='constant').astype(np.bool)\n    cur_tmp_mask_map = np.zeros_like(forbidden_map).astype(np.bool)\n    passive_background = 10 if 10 is not None else background_thickness\n    passive_context = 1 if 1 is not None else context_thickness\n\n    for edge_id, edge_cc in enumerate(edge_ccs):\n        cur_mask_cc = None; cur_mask_cc = []\n        cur_context_cc = None; cur_context_cc = []\n        cur_accomp_near_cc = None; cur_accomp_near_cc = []\n        cur_invalid_extend_edge_cc = None; cur_invalid_extend_edge_cc = []\n        cur_comp_far_cc = None; cur_comp_far_cc = []\n        tmp_erode = []\n        if len(context_ccs[edge_id]) == 0 or (len(specific_edge_id) > 0 and edge_id not in specific_edge_id):\n            continue\n        for i in range(max(background_thickness, context_thickness)):\n            cur_tmp_mask_map.fill(False)\n            if i == 0:\n                tmp_mask_nodes = copy.deepcopy(mask_ccs[edge_id])\n                tmp_intersect_nodes = []\n                tmp_intersect_context_nodes = []\n                mask_map = np.zeros((mesh.graph['H'], mesh.graph['W']), dtype=np.bool)\n                context_depth = np.zeros((mesh.graph['H'], mesh.graph['W']))\n                comp_cnt_depth = np.zeros((mesh.graph['H'], mesh.graph['W']))\n                connect_map = np.zeros((mesh.graph['H'], mesh.graph['W']))\n                for node in tmp_mask_nodes:\n                    mask_map[node[0], node[1]] = True\n                    depth_count = 0\n                    if mesh_nodes[node].get('far') is not None:\n                        for comp_cnt_node in mesh_nodes[node]['far']:\n                            comp_cnt_depth[node[0], node[1]] += abs(comp_cnt_node[2])\n                            depth_count += 1\n                    if depth_count > 0:\n                        comp_cnt_depth[node[0], node[1]] = comp_cnt_depth[node[0], node[1]] / depth_count\n                    connect_node = []\n                    if mesh_nodes[node].get('connect_point_id') is not None:\n                        connect_node.append(mesh_nodes[node]['connect_point_id'])\n                    connect_point_id = np.bincount(connect_node).argmax() if len(connect_node) > 0 else -1\n                    if connect_point_id > -1 and connect_points_ccs is not None:\n                        for xx in connect_points_ccs[connect_point_id]:\n                            if connect_map[xx[0], xx[1]] == 0:\n                                connect_map[xx[0], xx[1]] = xx[2]\n                    if mesh_nodes[node].get('connect_point_exception') is not None:\n                        for xx in mesh_nodes[node]['connect_point_exception']:\n                            if connect_map[xx[0], xx[1]] == 0:\n                                connect_map[xx[0], xx[1]] = xx[2]\n                tmp_context_nodes = [*context_ccs[edge_id]]\n                tmp_erode.append([*context_ccs[edge_id]])\n                context_map = np.zeros((mesh.graph['H'], mesh.graph['W']), dtype=np.bool)\n                if (context_map.astype(np.uint8) * mask_map.astype(np.uint8)).max() > 0:\n                    import pdb; pdb.set_trace()\n                for node in tmp_context_nodes:\n                    context_map[node[0], node[1]] = True\n                    context_depth[node[0], node[1]] = node[2]\n                context_map[mask_map == True] = False\n                if (context_map.astype(np.uint8) * mask_map.astype(np.uint8)).max() > 0:\n                    import pdb; pdb.set_trace()\n                tmp_intouched_nodes = [*intouched_ccs[edge_id]]\n                intouched_map = np.zeros((mesh.graph['H'], mesh.graph['W']), dtype=np.bool)\n                for node in tmp_intouched_nodes: intouched_map[node[0], node[1]] = True\n                intouched_map[mask_map == True] = False\n                tmp_redundant_nodes = set()\n                tmp_noncont_nodes = set()\n                noncont_map = np.zeros((mesh.graph['H'], mesh.graph['W']), dtype=np.bool)\n                intersect_map = np.zeros((mesh.graph['H'], mesh.graph['W']), dtype=np.bool)\n                intersect_context_map = np.zeros((mesh.graph['H'], mesh.graph['W']), dtype=np.bool)\n            if i > passive_background and inpaint_iter == 0:\n                new_tmp_intersect_nodes = None\n                new_tmp_intersect_nodes = []\n                for node in tmp_intersect_nodes:\n                    nes = mesh.neighbors(node)\n                    for ne in nes:\n                        if bool(context_map[ne[0], ne[1]]) is False and \\\n                        bool(mask_map[ne[0], ne[1]]) is False and \\\n                        bool(forbidden_map[ne[0], ne[1]]) is True and \\\n                        bool(intouched_map[ne[0], ne[1]]) is False and\\\n                        bool(intersect_map[ne[0], ne[1]]) is False and\\\n                        bool(intersect_context_map[ne[0], ne[1]]) is False:\n                            break_flag = False\n                            if (i - passive_background) % 2 == 0 and (i - passive_background) % 8 != 0:\n                                four_nes = [xx for xx in[[ne[0] - 1, ne[1]], [ne[0] + 1, ne[1]], [ne[0], ne[1] - 1], [ne[0], ne[1] + 1]] \\\n                                                if 0 <= xx[0] < mesh.graph['H'] and 0 <= xx[1] < mesh.graph['W']]\n                                for fne in four_nes:\n                                    if bool(mask_map[fne[0], fne[1]]) is True:\n                                        break_flag = True\n                                        break\n                                if break_flag is True:\n                                    continue\n                            intersect_map[ne[0], ne[1]] = True\n                            new_tmp_intersect_nodes.append(ne)\n                tmp_intersect_nodes = None\n                tmp_intersect_nodes = new_tmp_intersect_nodes\n\n            if i > passive_context and inpaint_iter == 1:\n                new_tmp_intersect_context_nodes = None\n                new_tmp_intersect_context_nodes = []\n                for node in tmp_intersect_context_nodes:\n                    nes = mesh.neighbors(node)\n                    for ne in nes:\n                        if bool(context_map[ne[0], ne[1]]) is False and \\\n                        bool(mask_map[ne[0], ne[1]]) is False and \\\n                        bool(forbidden_map[ne[0], ne[1]]) is True and \\\n                        bool(intouched_map[ne[0], ne[1]]) is False and\\\n                        bool(intersect_map[ne[0], ne[1]]) is False and \\\n                        bool(intersect_context_map[ne[0], ne[1]]) is False:\n                            intersect_context_map[ne[0], ne[1]] = True\n                            new_tmp_intersect_context_nodes.append(ne)\n                tmp_intersect_context_nodes = None\n                tmp_intersect_context_nodes = new_tmp_intersect_context_nodes\n\n            new_tmp_mask_nodes = None\n            new_tmp_mask_nodes = []\n            for node in tmp_mask_nodes:\n                four_nes = {xx:[] for xx in [(node[0] - 1, node[1]), (node[0] + 1, node[1]), (node[0], node[1] - 1), (node[0], node[1] + 1)] if \\\n                            0 <= xx[0] < connect_map.shape[0] and 0 <= xx[1] < connect_map.shape[1]}\n                if inpaint_iter > 0:\n                    for ne in four_nes.keys():\n                        if connect_map[ne[0], ne[1]] == True:\n                            tmp_context_nodes.append((ne[0], ne[1], connect_map[ne[0], ne[1]]))\n                            context_map[ne[0], ne[1]] = True\n                nes = mesh.neighbors(node)\n                if inpaint_iter > 0:\n                    for ne in nes: four_nes[(ne[0], ne[1])].append(ne[2])\n                    nes = []\n                    for kfne, vfnes in four_nes.items(): vfnes.sort(key = lambda xx: abs(xx), reverse=True)\n                    for kfne, vfnes in four_nes.items():\n                        for vfne in vfnes: nes.append((kfne[0], kfne[1], vfne))\n                for ne in nes:\n                    if bool(context_map[ne[0], ne[1]]) is False and \\\n                       bool(mask_map[ne[0], ne[1]]) is False and \\\n                       bool(forbidden_map[ne[0], ne[1]]) is True and \\\n                       bool(intouched_map[ne[0], ne[1]]) is False and \\\n                       bool(intersect_map[ne[0], ne[1]]) is False and \\\n                       bool(intersect_context_map[ne[0], ne[1]]) is False:\n                        if i == passive_background and inpaint_iter == 0:\n                            if np.any(context_map[max(ne[0] - 1, 0):min(ne[0] + 2, mesh.graph['H']), max(ne[1] - 1, 0):min(ne[1] + 2, mesh.graph['W'])]) == True:\n                                intersect_map[ne[0], ne[1]] = True\n                                tmp_intersect_nodes.append(ne)\n                                continue\n                        if i < background_thickness:\n                            if inpaint_iter == 0:\n                                cur_mask_cc.append(ne)\n                            elif mesh_nodes[ne].get('inpaint_id') == 1:\n                                cur_mask_cc.append(ne)\n                            else:\n                                continue\n                            mask_ccs[edge_id].add(ne)\n                            if inpaint_iter == 0:\n                                if comp_cnt_depth[node[0], node[1]] > 0 and comp_cnt_depth[ne[0], ne[1]] == 0:\n                                    comp_cnt_depth[ne[0], ne[1]] = comp_cnt_depth[node[0], node[1]]\n                                if mesh_nodes[ne].get('far') is not None:\n                                    for comp_far_node in mesh_nodes[ne]['far']:\n                                        cur_comp_far_cc.append(comp_far_node)\n                                        cur_accomp_near_cc.append(ne)\n                                        cur_invalid_extend_edge_cc.append(comp_far_node)\n                                if mesh_nodes[ne].get('edge_id') is not None and \\\n                                    len(context_ccs[mesh_nodes[ne].get('edge_id')]) > 0:\n                                    intouched_fars = set(mesh_nodes[ne].get('far')) if mesh_nodes[ne].get('far') is not None else set()\n                                    accum_intouched_fars = set(intouched_fars)\n                                    for intouched_far in intouched_fars:\n                                        accum_intouched_fars |= set([*mesh.neighbors(intouched_far)])\n                                    for intouched_far in accum_intouched_fars:\n                                        if bool(mask_map[intouched_far[0], intouched_far[1]]) is True or \\\n                                        bool(context_map[intouched_far[0], intouched_far[1]]) is True:\n                                            continue\n                                        tmp_redundant_nodes.add(intouched_far)\n                                        intouched_map[intouched_far[0], intouched_far[1]] = True\n                                if mesh_nodes[ne].get('near') is not None:\n                                    intouched_nears = set(mesh_nodes[ne].get('near'))\n                                    for intouched_near in intouched_nears:\n                                        if bool(mask_map[intouched_near[0], intouched_near[1]]) is True or \\\n                                        bool(context_map[intouched_near[0], intouched_near[1]]) is True:\n                                            continue\n                                        tmp_redundant_nodes.add(intouched_near)\n                                        intouched_map[intouched_near[0], intouched_near[1]] = True\n                        if not (mesh_nodes[ne].get('inpaint_id') != 1 and inpaint_iter == 1):\n                            new_tmp_mask_nodes.append(ne)\n                            mask_map[ne[0], ne[1]] = True\n            tmp_mask_nodes = new_tmp_mask_nodes\n\n            new_tmp_context_nodes = None\n            new_tmp_context_nodes = []\n            for node in tmp_context_nodes:\n                nes = mesh.neighbors(node)\n                if inpaint_iter > 0:\n                    four_nes = {(node[0] - 1, node[1]):[], (node[0] + 1, node[1]):[], (node[0], node[1] - 1):[], (node[0], node[1] + 1):[]}\n                    for ne in nes: four_nes[(ne[0], ne[1])].append(ne[2])\n                    nes = []\n                    for kfne, vfnes in four_nes.items(): vfnes.sort(key = lambda xx: abs(xx), reverse=True)\n                    for kfne, vfnes in four_nes.items():\n                        for vfne in vfnes: nes.append((kfne[0], kfne[1], vfne))\n                for ne in nes:\n                    mask_flag = (bool(mask_map[ne[0], ne[1]]) is False)\n                    if bool(context_map[ne[0], ne[1]]) is False and mask_flag and \\\n                       bool(forbidden_map[ne[0], ne[1]]) is True and bool(noncont_map[ne[0], ne[1]]) is False and \\\n                       bool(intersect_context_map[ne[0], ne[1]]) is False:\n                        if i == passive_context and inpaint_iter == 1:\n                            mnes = mesh.neighbors(ne)\n                            if any([mask_map[mne[0], mne[1]] == True for mne in mnes]) is True:\n                                intersect_context_map[ne[0], ne[1]] = True\n                                tmp_intersect_context_nodes.append(ne)\n                                continue\n                        if False and mesh_nodes[ne].get('near') is not None and mesh_nodes[ne].get('edge_id') != edge_id:\n                            noncont_nears = set(mesh_nodes[ne].get('near'))\n                            for noncont_near in noncont_nears:\n                                if bool(context_map[noncont_near[0], noncont_near[1]]) is False:\n                                    tmp_noncont_nodes.add(noncont_near)\n                                    noncont_map[noncont_near[0], noncont_near[1]] = True\n                        new_tmp_context_nodes.append(ne)\n                        context_map[ne[0], ne[1]] = True\n                        context_depth[ne[0], ne[1]] = ne[2]\n            cur_context_cc.extend(new_tmp_context_nodes)\n            tmp_erode.append(new_tmp_context_nodes)\n            tmp_context_nodes = None\n            tmp_context_nodes = new_tmp_context_nodes\n            new_tmp_intouched_nodes = None; new_tmp_intouched_nodes = []\n\n            for node in tmp_intouched_nodes:\n                if bool(context_map[node[0], node[1]]) is True or bool(mask_map[node[0], node[1]]) is True:\n                    continue\n                nes = mesh.neighbors(node)\n\n                for ne in nes:\n                    if bool(context_map[ne[0], ne[1]]) is False and \\\n                       bool(mask_map[ne[0], ne[1]]) is False and \\\n                       bool(intouched_map[ne[0], ne[1]]) is False and \\\n                       bool(forbidden_map[ne[0], ne[1]]) is True:\n                        new_tmp_intouched_nodes.append(ne)\n                        intouched_map[ne[0], ne[1]] = True\n            tmp_intouched_nodes = None\n            tmp_intouched_nodes = set(new_tmp_intouched_nodes)\n            new_tmp_redundant_nodes = None; new_tmp_redundant_nodes = []\n            for node in tmp_redundant_nodes:\n                if bool(context_map[node[0], node[1]]) is True or \\\n                   bool(mask_map[node[0], node[1]]) is True:\n                    continue\n                nes = mesh.neighbors(node)\n\n                for ne in nes:\n                    if bool(context_map[ne[0], ne[1]]) is False and \\\n                       bool(mask_map[ne[0], ne[1]]) is False and \\\n                       bool(intouched_map[ne[0], ne[1]]) is False and \\\n                       bool(forbidden_map[ne[0], ne[1]]) is True:\n                        new_tmp_redundant_nodes.append(ne)\n                        intouched_map[ne[0], ne[1]] = True\n            tmp_redundant_nodes = None\n            tmp_redundant_nodes = set(new_tmp_redundant_nodes)\n            new_tmp_noncont_nodes = None; new_tmp_noncont_nodes = []\n            for node in tmp_noncont_nodes:\n                if bool(context_map[node[0], node[1]]) is True or \\\n                   bool(mask_map[node[0], node[1]]) is True:\n                    continue\n                nes = mesh.neighbors(node)\n                rmv_flag = False\n                for ne in nes:\n                    if bool(context_map[ne[0], ne[1]]) is False and \\\n                       bool(mask_map[ne[0], ne[1]]) is False and \\\n                       bool(noncont_map[ne[0], ne[1]]) is False and \\\n                       bool(forbidden_map[ne[0], ne[1]]) is True:\n                        patch_context_map = context_map[max(ne[0] - 1, 0):min(ne[0] + 2, context_map.shape[0]),\n                                                        max(ne[1] - 1, 0):min(ne[1] + 2, context_map.shape[1])]\n                        if bool(np.any(patch_context_map)) is True:\n                            new_tmp_noncont_nodes.append(ne)\n                            noncont_map[ne[0], ne[1]] = True\n            tmp_noncont_nodes = None\n            tmp_noncont_nodes = set(new_tmp_noncont_nodes)\n        if inpaint_iter == 0:\n            depth_dict = get_depth_from_maps(context_map, mask_map, context_depth, mesh.graph['H'], mesh.graph['W'], log_depth=config['log_depth'])\n            mask_size = get_valid_size(depth_dict['mask'])\n            mask_size = dilate_valid_size(mask_size, depth_dict['mask'], dilate=[20, 20])\n            context_size = get_valid_size(depth_dict['context'])\n            context_size = dilate_valid_size(context_size, depth_dict['context'], dilate=[20, 20])\n            union_size = size_operation(mask_size, context_size, operation='+')\n            depth_dict = depth_inpainting(None, None, None, None, mesh, config, union_size, depth_feat_model, None, given_depth_dict=depth_dict, spdb=False)\n            near_depth_map, raw_near_depth_map = np.zeros((mesh.graph['H'], mesh.graph['W'])), np.zeros((mesh.graph['H'], mesh.graph['W']))\n            filtered_comp_far_cc, filtered_accomp_near_cc = set(), set()\n            for node in cur_accomp_near_cc:\n                near_depth_map[node[0], node[1]] = depth_dict['output'][node[0], node[1]]\n                raw_near_depth_map[node[0], node[1]] = node[2]\n            for node in cur_comp_far_cc:\n                four_nes = [xx for xx in [(node[0] - 1, node[1]), (node[0] + 1, node[1]), (node[0], node[1] - 1), (node[0], node[1] + 1)] \\\n                            if 0 <= xx[0] < mesh.graph['H'] and 0 <= xx[1] < mesh.graph['W'] and \\\n                            near_depth_map[xx[0], xx[1]] != 0 and \\\n                            abs(near_depth_map[xx[0], xx[1]]) < abs(node[2])]\n                if len(four_nes) > 0:\n                    filtered_comp_far_cc.add(node)\n                for ne in four_nes:\n                    filtered_accomp_near_cc.add((ne[0], ne[1], -abs(raw_near_depth_map[ne[0], ne[1]])))\n            cur_comp_far_cc, cur_accomp_near_cc = filtered_comp_far_cc, filtered_accomp_near_cc\n        mask_ccs[edge_id] |= set(cur_mask_cc)\n        context_ccs[edge_id] |= set(cur_context_cc)\n        accomp_extend_context_ccs[edge_id] |= set(cur_accomp_near_cc).intersection(cur_mask_cc)\n        extend_edge_ccs[edge_id] |= set(cur_accomp_near_cc).intersection(cur_mask_cc)\n        extend_context_ccs[edge_id] |= set(cur_comp_far_cc)\n        invalid_extend_edge_ccs[edge_id] |= set(cur_invalid_extend_edge_cc)\n        erode_size = [0]\n        for tmp in tmp_erode:\n            erode_size.append(len(tmp))\n            if len(erode_size) > 1:\n                erode_size[-1] += erode_size[-2]\n        if inpaint_iter == 0:\n            tmp_width = config['depth_edge_dilate']\n        else:\n            tmp_width = 0\n        while float(erode_size[tmp_width]) / (erode_size[-1] + 1e-6) > 0.3:\n            tmp_width = tmp_width - 1\n        try:\n            if tmp_width == 0:\n                erode_context_ccs[edge_id] = set([])\n            else:\n                erode_context_ccs[edge_id] = set(reduce(lambda x, y : x + y, [] + tmp_erode[:tmp_width]))\n        except:\n            import pdb; pdb.set_trace()\n        erode_context_cc = copy.deepcopy(erode_context_ccs[edge_id])\n        for erode_context_node in erode_context_cc:\n            if (inpaint_iter != 0 and (mesh_nodes[erode_context_node].get('inpaint_id') is None or\n                                        mesh_nodes[erode_context_node].get('inpaint_id') == 0)):\n                erode_context_ccs[edge_id].remove(erode_context_node)\n            else:\n                context_ccs[edge_id].remove(erode_context_node)\n        context_map = np.zeros((mesh.graph['H'], mesh.graph['W']))\n        for context_node in context_ccs[edge_id]:\n            context_map[context_node[0], context_node[1]] = 1\n        extend_context_ccs[edge_id] = extend_context_ccs[edge_id] - mask_ccs[edge_id] - accomp_extend_context_ccs[edge_id]\n    if inpaint_iter == 0:\n        all_ecnt_cc = set()\n        for ecnt_id, ecnt_cc in enumerate(extend_context_ccs):\n            constraint_context_ids = set()\n            constraint_context_cc = set()\n            constraint_erode_context_cc = set()\n            tmp_mask_cc = set()\n            accum_context_cc = None; accum_context_cc = []\n            for ecnt_node in accomp_extend_context_ccs[ecnt_id]:\n                if edge_maps[ecnt_node[0], ecnt_node[1]] > -1:\n                    constraint_context_ids.add(int(round(edge_maps[ecnt_node[0], ecnt_node[1]])))\n            constraint_erode_context_cc = erode_context_ccs[ecnt_id]\n            for constraint_context_id in constraint_context_ids:\n                constraint_context_cc = constraint_context_cc | context_ccs[constraint_context_id] | erode_context_ccs[constraint_context_id]\n                constraint_erode_context_cc = constraint_erode_context_cc | erode_context_ccs[constraint_context_id]\n            for i in range(background_thickness):\n                if i == 0:\n                    tmp_context_nodes = copy.deepcopy(ecnt_cc)\n                    tmp_invalid_context_nodes = copy.deepcopy(invalid_extend_edge_ccs[ecnt_id])\n                    tmp_mask_nodes = copy.deepcopy(accomp_extend_context_ccs[ecnt_id])\n                    tmp_context_map = np.zeros((mesh.graph['H'], mesh.graph['W'])).astype(np.bool)\n                    tmp_mask_map = np.zeros((mesh.graph['H'], mesh.graph['W'])).astype(np.bool)\n                    tmp_invalid_context_map = np.zeros((mesh.graph['H'], mesh.graph['W'])).astype(np.bool)\n                    for node in tmp_mask_nodes:\n                        tmp_mask_map[node[0], node[1]] = True\n                    for node in context_ccs[ecnt_id]:\n                        tmp_context_map[node[0], node[1]] = True\n                    for node in erode_context_ccs[ecnt_id]:\n                        tmp_context_map[node[0], node[1]] = True\n                    for node in extend_context_ccs[ecnt_id]:\n                        tmp_context_map[node[0], node[1]] = True\n                    for node in invalid_extend_edge_ccs[ecnt_id]:\n                        tmp_invalid_context_map[node[0], node[1]] = True\n                    init_invalid_context_map = tmp_invalid_context_map.copy()\n                    init_context_map = tmp\n                    if (tmp_mask_map.astype(np.uint8) * tmp_context_map.astype(np.uint8)).max() > 0:\n                        import pdb; pdb.set_trace()\n                    if vis_edge_id is not None and ecnt_id == vis_edge_id:\n                        f, ((ax1, ax2)) = plt.subplots(1, 2, sharex=True, sharey=True)\n                        ax1.imshow(tmp_context_map * 1); ax2.imshow(init_invalid_context_map * 1 + tmp_context_map * 2)\n                        plt.show()\n                        import pdb; pdb.set_trace()\n                else:\n                    tmp_context_nodes = new_tmp_context_nodes\n                    new_tmp_context_nodes = None\n                    tmp_mask_nodes = new_tmp_mask_nodes\n                    new_tmp_mask_nodes = None\n                    tmp_invalid_context_nodes = new_tmp_invalid_context_nodes\n                    new_tmp_invalid_context_nodes = None\n                new_tmp_context_nodes = None\n                new_tmp_context_nodes = []\n                new_tmp_invalid_context_nodes = None\n                new_tmp_invalid_context_nodes = []\n                new_tmp_mask_nodes = set([])\n                for node in tmp_context_nodes:\n                    for ne in mesh.neighbors(node):\n                        if ne in constraint_context_cc and \\\n                            bool(tmp_mask_map[ne[0], ne[1]]) is False and \\\n                            bool(tmp_context_map[ne[0], ne[1]]) is False and \\\n                            bool(forbidden_map[ne[0], ne[1]]) is True:\n                            new_tmp_context_nodes.append(ne)\n                            tmp_context_map[ne[0], ne[1]] = True\n                accum_context_cc.extend(new_tmp_context_nodes)\n                for node in tmp_invalid_context_nodes:\n                    for ne in mesh.neighbors(node):\n                        if bool(tmp_mask_map[ne[0], ne[1]]) is False and \\\n                           bool(tmp_context_map[ne[0], ne[1]]) is False and \\\n                           bool(tmp_invalid_context_map[ne[0], ne[1]]) is False and \\\n                           bool(forbidden_map[ne[0], ne[1]]) is True:\n                            tmp_invalid_context_map[ne[0], ne[1]] = True\n                            new_tmp_invalid_context_nodes.append(ne)\n                for node in tmp_mask_nodes:\n                    for ne in mesh.neighbors(node):\n                        if bool(tmp_mask_map[ne[0], ne[1]]) is False and \\\n                           bool(tmp_context_map[ne[0], ne[1]]) is False and \\\n                           bool(tmp_invalid_context_map[ne[0], ne[1]]) is False and \\\n                           bool(forbidden_map[ne[0], ne[1]]) is True:\n                            new_tmp_mask_nodes.add(ne)\n                            tmp_mask_map[ne[0], ne[1]] = True\n            init_invalid_context_map[tmp_context_map] = False\n            _, tmp_label_map = cv2.connectedComponents((init_invalid_context_map | tmp_context_map).astype(np.uint8), connectivity=8)\n            tmp_label_ids = set(np.unique(tmp_label_map[init_invalid_context_map]))\n            if (tmp_mask_map.astype(np.uint8) * tmp_context_map.astype(np.uint8)).max() > 0:\n                import pdb; pdb.set_trace()\n            if vis_edge_id is not None and ecnt_id == vis_edge_id:\n                f, ((ax1, ax2)) = plt.subplots(1, 2, sharex=True, sharey=True)\n                ax1.imshow(tmp_label_map); ax2.imshow(init_invalid_context_map * 1 + tmp_context_map * 2)\n                plt.show()\n                import pdb; pdb.set_trace()\n            extend_context_ccs[ecnt_id] |= set(accum_context_cc)\n            extend_context_ccs[ecnt_id] = extend_context_ccs[ecnt_id] - mask_ccs[ecnt_id]\n            extend_erode_context_ccs[ecnt_id] = extend_context_ccs[ecnt_id] & constraint_erode_context_cc\n            extend_context_ccs[ecnt_id] = extend_context_ccs[ecnt_id] - extend_erode_context_ccs[ecnt_id] - erode_context_ccs[ecnt_id]\n            tmp_context_cc = context_ccs[ecnt_id] - extend_erode_context_ccs[ecnt_id] - erode_context_ccs[ecnt_id]\n            if len(tmp_context_cc) > 0:\n                context_ccs[ecnt_id] = tmp_context_cc\n            tmp_mask_cc = tmp_mask_cc - context_ccs[ecnt_id] - erode_context_ccs[ecnt_id]\n            mask_ccs[ecnt_id] = mask_ccs[ecnt_id] | tmp_mask_cc\n\n    return context_ccs, mask_ccs, broken_mask_ccs, edge_ccs, erode_context_ccs, invalid_extend_edge_ccs, edge_maps, extend_context_ccs, extend_edge_ccs, extend_erode_context_ccs\n\ndef DL_inpaint_edge(mesh,\n                    info_on_pix,\n                    config,\n                    image,\n                    depth,\n                    context_ccs,\n                    erode_context_ccs,\n                    extend_context_ccs,\n                    extend_erode_context_ccs,\n                    mask_ccs,\n                    broken_mask_ccs,\n                    edge_ccs,\n                    extend_edge_ccs,\n                    init_mask_connect,\n                    edge_maps,\n                    rgb_model=None,\n                    depth_edge_model=None,\n                    depth_edge_model_init=None,\n                    depth_feat_model=None,\n                    specific_edge_id=-1,\n                    specific_edge_loc=None,\n                    inpaint_iter=0):\n\n    if isinstance(config[\"gpu_ids\"], int) and (config[\"gpu_ids\"] >= 0):\n        device = config[\"gpu_ids\"]\n    else:\n        device = \"cpu\"\n\n    edge_map = np.zeros_like(depth)\n    new_edge_ccs = [set() for _ in range(len(edge_ccs))]\n    edge_maps_with_id = edge_maps\n    edge_condition = lambda x, m: m.nodes[x].get('far') is not None and len(m.nodes[x].get('far')) > 0\n    edge_map = get_map_from_ccs(edge_ccs, mesh.graph['H'], mesh.graph['W'], mesh, edge_condition)\n    np_depth, np_image = depth.copy(), image.copy()\n    image_c = image.shape[-1]\n    image = torch.FloatTensor(image.transpose(2, 0, 1)).unsqueeze(0).to(device)\n    if depth.ndim < 3:\n        depth = depth[..., None]\n    depth = torch.FloatTensor(depth.transpose(2, 0, 1)).unsqueeze(0).to(device)\n    mesh.graph['max_edge_id'] = len(edge_ccs)\n    connnect_points_ccs = [set() for _ in range(len(edge_ccs))]\n    gp_time, tmp_mesh_time, bilateral_time = 0, 0, 0\n    edges_infos = dict()\n    edges_in_mask = [set() for _ in range(len(edge_ccs))]\n    tmp_specific_edge_id = []\n    for edge_id, (context_cc, mask_cc, erode_context_cc, extend_context_cc, edge_cc) in enumerate(zip(context_ccs, mask_ccs, erode_context_ccs, extend_context_ccs, edge_ccs)):\n        if len(specific_edge_id) > 0:\n            if edge_id not in specific_edge_id:\n                continue\n        if len(context_cc) < 1 or len(mask_cc) < 1:\n            continue\n        edge_dict = get_edge_from_nodes(context_cc | extend_context_cc, erode_context_cc | extend_erode_context_ccs[edge_id], mask_cc, edge_cc, extend_edge_ccs[edge_id],\n                                        mesh.graph['H'], mesh.graph['W'], mesh)\n        edge_dict['edge'], end_depth_maps, _ = \\\n            filter_irrelevant_edge_new(edge_dict['self_edge'], edge_dict['comp_edge'],\n                                    edge_map,\n                                    edge_maps_with_id,\n                                    edge_id,\n                                    edge_dict['context'],\n                                    edge_dict['depth'], mesh, context_cc | erode_context_cc | extend_context_cc | extend_erode_context_ccs[edge_id], spdb=False)\n        if specific_edge_loc is not None and \\\n            (specific_edge_loc is not None and edge_dict['mask'][specific_edge_loc[0], specific_edge_loc[1]] == 0):\n            continue\n        mask_size = get_valid_size(edge_dict['mask'])\n        mask_size = dilate_valid_size(mask_size, edge_dict['mask'], dilate=[20, 20])\n        context_size = get_valid_size(edge_dict['context'])\n        context_size = dilate_valid_size(context_size, edge_dict['context'], dilate=[20, 20])\n        union_size = size_operation(mask_size, context_size, operation='+')\n        patch_edge_dict = dict()\n        patch_edge_dict['mask'], patch_edge_dict['context'], patch_edge_dict['rgb'], \\\n            patch_edge_dict['disp'], patch_edge_dict['edge'] = \\\n            crop_maps_by_size(union_size, edge_dict['mask'], edge_dict['context'],\n                                edge_dict['rgb'], edge_dict['disp'], edge_dict['edge'])\n        x_anchor, y_anchor = [union_size['x_min'], union_size['x_max']], [union_size['y_min'], union_size['y_max']]\n        tensor_edge_dict = convert2tensor(patch_edge_dict)\n        input_edge_feat = torch.cat((tensor_edge_dict['rgb'],\n                                        tensor_edge_dict['disp'],\n                                        tensor_edge_dict['edge'],\n                                        1 - tensor_edge_dict['context'],\n                                        tensor_edge_dict['mask']), dim=1)\n        if require_depth_edge(patch_edge_dict['edge'], patch_edge_dict['mask']) and inpaint_iter == 0:\n            with torch.no_grad():\n                depth_edge_output = depth_edge_model.forward_3P(tensor_edge_dict['mask'],\n                                                                tensor_edge_dict['context'],\n                                                                tensor_edge_dict['rgb'],\n                                                                tensor_edge_dict['disp'],\n                                                                tensor_edge_dict['edge'],\n                                                                unit_length=128,\n                                                                cuda=device)\n                depth_edge_output = depth_edge_output.cpu()\n            tensor_edge_dict['output'] = (depth_edge_output> config['ext_edge_threshold']).float() * tensor_edge_dict['mask'] + tensor_edge_dict['edge']\n        else:\n            tensor_edge_dict['output'] = tensor_edge_dict['edge']\n            depth_edge_output = tensor_edge_dict['edge'] + 0\n        patch_edge_dict['output'] = tensor_edge_dict['output'].squeeze().data.cpu().numpy()\n        edge_dict['output'] = np.zeros((mesh.graph['H'], mesh.graph['W']))\n        edge_dict['output'][union_size['x_min']:union_size['x_max'], union_size['y_min']:union_size['y_max']] = \\\n            patch_edge_dict['output']\n        if require_depth_edge(patch_edge_dict['edge'], patch_edge_dict['mask']) and inpaint_iter == 0:\n            if ((depth_edge_output> config['ext_edge_threshold']).float() * tensor_edge_dict['mask']).max() > 0:\n                try:\n                    edge_dict['fpath_map'], edge_dict['npath_map'], break_flag, npaths, fpaths, invalid_edge_id = \\\n                        clean_far_edge_new(edge_dict['output'], end_depth_maps, edge_dict['mask'], edge_dict['context'], mesh, info_on_pix, edge_dict['self_edge'], inpaint_iter, config)\n                except:\n                    import pdb; pdb.set_trace()\n                pre_npath_map = edge_dict['npath_map'].copy()\n                if config.get('repeat_inpaint_edge') is True:\n                    for _ in range(2):\n                        tmp_input_edge = ((edge_dict['npath_map'] > -1) + edge_dict['edge']).clip(0, 1)\n                        patch_tmp_input_edge = crop_maps_by_size(union_size, tmp_input_edge)[0]\n                        tensor_input_edge = torch.FloatTensor(patch_tmp_input_edge)[None, None, ...]\n                        depth_edge_output = depth_edge_model.forward_3P(tensor_edge_dict['mask'],\n                                                    tensor_edge_dict['context'],\n                                                    tensor_edge_dict['rgb'],\n                                                    tensor_edge_dict['disp'],\n                                                    tensor_input_edge,\n                                                    unit_length=128,\n                                                    cuda=device)\n                        depth_edge_output = depth_edge_output.cpu()\n                        depth_edge_output = (depth_edge_output> config['ext_edge_threshold']).float() * tensor_edge_dict['mask'] + tensor_edge_dict['edge']\n                        depth_edge_output = depth_edge_output.squeeze().data.cpu().numpy()\n                        full_depth_edge_output = np.zeros((mesh.graph['H'], mesh.graph['W']))\n                        full_depth_edge_output[union_size['x_min']:union_size['x_max'], union_size['y_min']:union_size['y_max']] = \\\n                            depth_edge_output\n                        edge_dict['fpath_map'], edge_dict['npath_map'], break_flag, npaths, fpaths, invalid_edge_id = \\\n                            clean_far_edge_new(full_depth_edge_output, end_depth_maps, edge_dict['mask'], edge_dict['context'], mesh, info_on_pix, edge_dict['self_edge'], inpaint_iter, config)\n                for nid in npaths.keys():\n                    npath, fpath = npaths[nid], fpaths[nid]\n                    start_mx, start_my, end_mx, end_my = -1, -1, -1, -1\n                    if end_depth_maps[npath[0][0], npath[0][1]] != 0:\n                        start_mx, start_my = npath[0][0], npath[0][1]\n                    if end_depth_maps[npath[-1][0], npath[-1][1]] != 0:\n                        end_mx, end_my = npath[-1][0], npath[-1][1]\n                    if start_mx == -1:\n                        import pdb; pdb.set_trace()\n                    valid_end_pt = () if end_mx == -1 else (end_mx, end_my, info_on_pix[(end_mx, end_my)][0]['depth'])\n                    new_edge_info = dict(fpath=fpath,\n                                         npath=npath,\n                                         cont_end_pts=valid_end_pt,\n                                         mask_id=edge_id,\n                                         comp_edge_id=nid,\n                                         depth=end_depth_maps[start_mx, start_my])\n                    if edges_infos.get((start_mx, start_my)) is None:\n                        edges_infos[(start_mx, start_my)] = []\n                    edges_infos[(start_mx, start_my)].append(new_edge_info)\n                    edges_in_mask[edge_id].add((start_mx, start_my))\n                    if len(valid_end_pt) > 0:\n                        new_edge_info = dict(fpath=fpath[::-1],\n                                             npath=npath[::-1],\n                                             cont_end_pts=(start_mx, start_my, info_on_pix[(start_mx, start_my)][0]['depth']),\n                                             mask_id=edge_id,\n                                             comp_edge_id=nid,\n                                             depth=end_depth_maps[end_mx, end_my])\n                        if edges_infos.get((end_mx, end_my)) is None:\n                            edges_infos[(end_mx, end_my)] = []\n                        edges_infos[(end_mx, end_my)].append(new_edge_info)\n                        edges_in_mask[edge_id].add((end_mx, end_my))\n    for edge_id, (context_cc, mask_cc, erode_context_cc, extend_context_cc, edge_cc) in enumerate(zip(context_ccs, mask_ccs, erode_context_ccs, extend_context_ccs, edge_ccs)):\n        if len(specific_edge_id) > 0:\n            if edge_id not in specific_edge_id:\n                continue\n        if len(context_cc) < 1 or len(mask_cc) < 1:\n            continue\n        edge_dict = get_edge_from_nodes(context_cc | extend_context_cc, erode_context_cc | extend_erode_context_ccs[edge_id], mask_cc, edge_cc, extend_edge_ccs[edge_id],\n                                        mesh.graph['H'], mesh.graph['W'], mesh)\n        if specific_edge_loc is not None and \\\n            (specific_edge_loc is not None and edge_dict['mask'][specific_edge_loc[0], specific_edge_loc[1]] == 0):\n            continue\n        else:\n            tmp_specific_edge_id.append(edge_id)\n        edge_dict['edge'], end_depth_maps, _ = \\\n            filter_irrelevant_edge_new(edge_dict['self_edge'], edge_dict['comp_edge'],\n                                    edge_map,\n                                    edge_maps_with_id,\n                                    edge_id,\n                                    edge_dict['context'],\n                                    edge_dict['depth'], mesh, context_cc | erode_context_cc | extend_context_cc | extend_erode_context_ccs[edge_id], spdb=False)\n        discard_map = np.zeros_like(edge_dict['edge'])\n        mask_size = get_valid_size(edge_dict['mask'])\n        mask_size = dilate_valid_size(mask_size, edge_dict['mask'], dilate=[20, 20])\n        context_size = get_valid_size(edge_dict['context'])\n        context_size = dilate_valid_size(context_size, edge_dict['context'], dilate=[20, 20])\n        union_size = size_operation(mask_size, context_size, operation='+')\n        patch_edge_dict = dict()\n        patch_edge_dict['mask'], patch_edge_dict['context'], patch_edge_dict['rgb'], \\\n            patch_edge_dict['disp'], patch_edge_dict['edge'] = \\\n            crop_maps_by_size(union_size, edge_dict['mask'], edge_dict['context'],\n                                edge_dict['rgb'], edge_dict['disp'], edge_dict['edge'])\n        x_anchor, y_anchor = [union_size['x_min'], union_size['x_max']], [union_size['y_min'], union_size['y_max']]\n        tensor_edge_dict = convert2tensor(patch_edge_dict)\n        input_edge_feat = torch.cat((tensor_edge_dict['rgb'],\n                                        tensor_edge_dict['disp'],\n                                        tensor_edge_dict['edge'],\n                                        1 - tensor_edge_dict['context'],\n                                        tensor_edge_dict['mask']), dim=1)\n        edge_dict['output'] = edge_dict['edge'].copy()\n\n        if require_depth_edge(patch_edge_dict['edge'], patch_edge_dict['mask']) and inpaint_iter == 0:\n            edge_dict['fpath_map'], edge_dict['npath_map'] = edge_dict['fpath_map'] * 0 - 1, edge_dict['npath_map'] * 0 - 1\n            end_pts = edges_in_mask[edge_id]\n            for end_pt in end_pts:\n                cur_edge_infos = edges_infos[(end_pt[0], end_pt[1])]\n                cur_info = [xx for xx in cur_edge_infos if xx['mask_id'] == edge_id][0]\n                other_infos = [xx for xx in cur_edge_infos if xx['mask_id'] != edge_id and len(xx['cont_end_pts']) > 0]\n                if len(cur_info['cont_end_pts']) > 0 or (len(cur_info['cont_end_pts']) == 0 and len(other_infos) == 0):\n                    for fnode in cur_info['fpath']:\n                        edge_dict['fpath_map'][fnode[0], fnode[1]] = cur_info['comp_edge_id']\n                    for fnode in cur_info['npath']:\n                        edge_dict['npath_map'][fnode[0], fnode[1]] = cur_info['comp_edge_id']\n            fnmap = edge_dict['fpath_map'] * 1\n            fnmap[edge_dict['npath_map'] != -1] = edge_dict['npath_map'][edge_dict['npath_map'] != -1]\n            for end_pt in end_pts:\n                cur_edge_infos = edges_infos[(end_pt[0], end_pt[1])]\n                cur_info = [xx for xx in cur_edge_infos if xx['mask_id'] == edge_id][0]\n                cur_depth = cur_info['depth']\n                other_infos = [xx for xx in cur_edge_infos if xx['mask_id'] != edge_id and len(xx['cont_end_pts']) > 0]\n                comp_edge_id = cur_info['comp_edge_id']\n                if len(cur_info['cont_end_pts']) == 0 and len(other_infos) > 0:\n                    other_infos = sorted(other_infos, key=lambda aa: abs(abs(aa['cont_end_pts'][2]) - abs(cur_depth)))\n                    for other_info in other_infos:\n                        tmp_fmap, tmp_nmap = np.zeros((mesh.graph['H'], mesh.graph['W'])) - 1, np.zeros((mesh.graph['H'], mesh.graph['W'])) - 1\n                        for fnode in other_info['fpath']:\n                            if fnmap[fnode[0], fnode[1]] != -1:\n                                tmp_fmap = tmp_fmap * 0 - 1\n                                break\n                            else:\n                                tmp_fmap[fnode[0], fnode[1]] = comp_edge_id\n                        if fnmap[fnode[0], fnode[1]] != -1:\n                            continue\n                        for fnode in other_info['npath']:\n                            if fnmap[fnode[0], fnode[1]] != -1:\n                                tmp_nmap = tmp_nmap * 0 - 1\n                                break\n                            else:\n                                tmp_nmap[fnode[0], fnode[1]] = comp_edge_id\n                        if fnmap[fnode[0], fnode[1]] != -1:\n                            continue\n                        break\n                    if min(tmp_fmap.max(), tmp_nmap.max()) != -1:\n                        edge_dict['fpath_map'] = tmp_fmap\n                        edge_dict['fpath_map'][edge_dict['valid_area'] == 0] = -1\n                        edge_dict['npath_map'] = tmp_nmap\n                        edge_dict['npath_map'][edge_dict['valid_area'] == 0] = -1\n                        discard_map = ((tmp_nmap != -1).astype(np.uint8) + (tmp_fmap != -1).astype(np.uint8)) * edge_dict['mask']\n                    else:\n                        for fnode in cur_info['fpath']:\n                            edge_dict['fpath_map'][fnode[0], fnode[1]] = cur_info['comp_edge_id']\n                        for fnode in cur_info['npath']:\n                            edge_dict['npath_map'][fnode[0], fnode[1]] = cur_info['comp_edge_id']\n            if edge_dict['npath_map'].min() == 0 or edge_dict['fpath_map'].min() == 0:\n                import pdb; pdb.set_trace()\n            edge_dict['output'] = (edge_dict['npath_map'] > -1) * edge_dict['mask'] + edge_dict['context'] * edge_dict['edge']\n        mesh, _, _, _ = create_placeholder(edge_dict['context'], edge_dict['mask'],\n                                  edge_dict['depth'], edge_dict['fpath_map'],\n                                  edge_dict['npath_map'], mesh, inpaint_iter,\n                                  edge_ccs,\n                                  extend_edge_ccs[edge_id],\n                                  edge_maps_with_id,\n                                  edge_id)\n\n        dxs, dys = np.where(discard_map != 0)\n        for dx, dy in zip(dxs, dys):\n            mesh.nodes[(dx, dy)]['inpaint_twice'] = False\n        depth_dict = depth_inpainting(context_cc, extend_context_cc, erode_context_cc | extend_erode_context_ccs[edge_id], mask_cc, mesh, config, union_size, depth_feat_model, edge_dict['output'])\n        refine_depth_output = depth_dict['output']*depth_dict['mask']\n        for near_id in np.unique(edge_dict['npath_map'])[1:]:\n            refine_depth_output = refine_depth_around_edge(refine_depth_output.copy(),\n                                                            (edge_dict['fpath_map'] == near_id).astype(np.uint8) * edge_dict['mask'],\n                                                            (edge_dict['fpath_map'] == near_id).astype(np.uint8),\n                                                            (edge_dict['npath_map'] == near_id).astype(np.uint8) * edge_dict['mask'],\n                                                            depth_dict['mask'].copy(),\n                                                            depth_dict['output'] * depth_dict['context'],\n                                                            config)\n        depth_dict['output'][depth_dict['mask'] > 0] = refine_depth_output[depth_dict['mask'] > 0]\n        rgb_dict = get_rgb_from_nodes(context_cc | extend_context_cc,\n                                      erode_context_cc | extend_erode_context_ccs[edge_id], mask_cc, mesh.graph['H'], mesh.graph['W'], mesh)\n        if np.all(rgb_dict['mask'] == edge_dict['mask']) is False:\n            import pdb; pdb.set_trace()\n        rgb_dict['edge'] = edge_dict['output']\n        patch_rgb_dict = dict()\n        patch_rgb_dict['mask'], patch_rgb_dict['context'], patch_rgb_dict['rgb'], \\\n            patch_rgb_dict['edge'] = crop_maps_by_size(union_size, rgb_dict['mask'],\n                                                        rgb_dict['context'], rgb_dict['rgb'],\n                                                        rgb_dict['edge'])\n        tensor_rgb_dict = convert2tensor(patch_rgb_dict)\n        resize_rgb_dict = {k: v.clone() for k, v in tensor_rgb_dict.items()}\n        max_hw = np.array([*patch_rgb_dict['mask'].shape[-2:]]).max()\n        init_frac = config['largest_size'] / (np.array([*patch_rgb_dict['mask'].shape[-2:]]).prod() ** 0.5)\n        resize_hw = [patch_rgb_dict['mask'].shape[-2] * init_frac, patch_rgb_dict['mask'].shape[-1] * init_frac]\n        resize_max_hw = max(resize_hw)\n        frac = (np.floor(resize_max_hw / 128.) * 128.) / max_hw\n        if frac < 1:\n            resize_mark = torch.nn.functional.interpolate(torch.cat((resize_rgb_dict['mask'],\n                                                            resize_rgb_dict['context']),\n                                                            dim=1),\n                                                            scale_factor=frac,\n                                                            mode='area')\n            resize_rgb_dict['mask'] = (resize_mark[:, 0:1] > 0).float()\n            resize_rgb_dict['context'] = (resize_mark[:, 1:2] == 1).float()\n            resize_rgb_dict['context'][resize_rgb_dict['mask'] > 0] = 0\n            resize_rgb_dict['rgb'] = torch.nn.functional.interpolate(resize_rgb_dict['rgb'],\n                                                                        scale_factor=frac,\n                                                                        mode='area')\n            resize_rgb_dict['rgb'] = resize_rgb_dict['rgb'] * resize_rgb_dict['context']\n            resize_rgb_dict['edge'] = torch.nn.functional.interpolate(resize_rgb_dict['edge'],\n                                                                        scale_factor=frac,\n                                                                        mode='area')\n            resize_rgb_dict['edge'] = (resize_rgb_dict['edge'] > 0).float() * 0\n            resize_rgb_dict['edge'] = resize_rgb_dict['edge'] * (resize_rgb_dict['context'] + resize_rgb_dict['mask'])\n        rgb_input_feat = torch.cat((resize_rgb_dict['rgb'], resize_rgb_dict['edge']), dim=1)\n        rgb_input_feat[:, 3] = 1 - rgb_input_feat[:, 3]\n        resize_mask = open_small_mask(resize_rgb_dict['mask'], resize_rgb_dict['context'], 3, 41)\n        specified_hole = resize_mask\n        with torch.no_grad():\n            rgb_output = rgb_model.forward_3P(specified_hole,\n                                            resize_rgb_dict['context'],\n                                            resize_rgb_dict['rgb'],\n                                            resize_rgb_dict['edge'],\n                                            unit_length=128,\n                                            cuda=device)\n            rgb_output = rgb_output.cpu()\n            if config.get('gray_image') is True:\n                rgb_output = rgb_output.mean(1, keepdim=True).repeat((1,3,1,1))\n            rgb_output = rgb_output.cpu()\n        resize_rgb_dict['output'] = rgb_output * resize_rgb_dict['mask'] + resize_rgb_dict['rgb']\n        tensor_rgb_dict['output'] = resize_rgb_dict['output']\n        if frac < 1:\n            tensor_rgb_dict['output'] = torch.nn.functional.interpolate(tensor_rgb_dict['output'],\n                                                                        size=tensor_rgb_dict['mask'].shape[-2:],\n                                                                        mode='bicubic')\n            tensor_rgb_dict['output'] = tensor_rgb_dict['output'] * \\\n                                         tensor_rgb_dict['mask'] + (tensor_rgb_dict['rgb'] * tensor_rgb_dict['context'])\n        patch_rgb_dict['output'] = tensor_rgb_dict['output'].data.cpu().numpy().squeeze().transpose(1,2,0)\n        rgb_dict['output'] = np.zeros((mesh.graph['H'], mesh.graph['W'], 3))\n        rgb_dict['output'][union_size['x_min']:union_size['x_max'], union_size['y_min']:union_size['y_max']] = \\\n            patch_rgb_dict['output']\n\n        if require_depth_edge(patch_edge_dict['edge'], patch_edge_dict['mask']) or inpaint_iter > 0:\n            edge_occlusion = True\n        else:\n            edge_occlusion = False\n        for node in erode_context_cc:\n            if rgb_dict['mask'][node[0], node[1]] > 0:\n                for info in info_on_pix[(node[0], node[1])]:\n                    if abs(info['depth']) == abs(node[2]):\n                        info['update_color'] = (rgb_dict['output'][node[0], node[1]] * 255).astype(np.uint8)\n        if frac < 1.:\n            depth_edge_dilate_2_color_flag = False\n        else:\n            depth_edge_dilate_2_color_flag = True\n        hxs, hys = np.where((rgb_dict['mask'] > 0) & (rgb_dict['erode'] == 0))\n        for hx, hy in zip(hxs, hys):\n            real_depth = None\n            if abs(depth_dict['output'][hx, hy]) <= abs(np_depth[hx, hy]):\n                depth_dict['output'][hx, hy] = np_depth[hx, hy] + 0.01\n            node = (hx, hy, -depth_dict['output'][hx, hy])\n            if info_on_pix.get((node[0], node[1])) is not None:\n                for info in info_on_pix.get((node[0], node[1])):\n                    if info.get('inpaint_id') is None or abs(info['inpaint_id'] < mesh.nodes[(hx, hy)]['inpaint_id']):\n                        pre_depth = info['depth'] if info.get('real_depth') is None else info['real_depth']\n                        if abs(node[2]) < abs(pre_depth):\n                            node = (node[0], node[1], -(abs(pre_depth) + 0.001))\n            if mesh.has_node(node):\n                real_depth = node[2]\n            while True:\n                if mesh.has_node(node):\n                    node = (node[0], node[1], -(abs(node[2]) + 0.001))\n                else:\n                    break\n            if real_depth == node[2]:\n                real_depth = None\n            cur_disp = 1./node[2]\n            if not(mesh.has_node(node)):\n                if not mesh.has_node((node[0], node[1])):\n                    print(\"2D node not found.\")\n                    import pdb; pdb.set_trace()\n                if inpaint_iter == 1:\n                    paint = (rgb_dict['output'][hx, hy] * 255).astype(np.uint8)\n                else:\n                    paint = (rgb_dict['output'][hx, hy] * 255).astype(np.uint8)\n                ndict = dict(color=paint,\n                                synthesis=True,\n                                disp=cur_disp,\n                                cc_id=set([edge_id]),\n                                overlap_number=1.0,\n                                refine_depth=False,\n                                edge_occlusion=edge_occlusion,\n                                depth_edge_dilate_2_color_flag=depth_edge_dilate_2_color_flag,\n                                real_depth=real_depth)\n                mesh, _, _ = refresh_node((node[0], node[1]), mesh.nodes[(node[0], node[1])], node, ndict, mesh, stime=True)\n                if inpaint_iter == 0 and mesh.degree(node) < 4:\n                    connnect_points_ccs[edge_id].add(node)\n            if info_on_pix.get((hx, hy)) is None:\n                info_on_pix[(hx, hy)] = []\n            new_info = {'depth':node[2],\n                        'color': paint,\n                        'synthesis':True,\n                        'disp':cur_disp,\n                        'cc_id':set([edge_id]),\n                        'inpaint_id':inpaint_iter + 1,\n                        'edge_occlusion':edge_occlusion,\n                        'overlap_number':1.0,\n                        'real_depth': real_depth}\n            info_on_pix[(hx, hy)].append(new_info)\n    specific_edge_id = tmp_specific_edge_id\n    for erode_id, erode_context_cc in enumerate(erode_context_ccs):\n        if len(specific_edge_id) > 0 and erode_id not in specific_edge_id:\n            continue\n        for erode_node in erode_context_cc:\n            for info in info_on_pix[(erode_node[0], erode_node[1])]:\n                if info['depth'] == erode_node[2]:\n                    info['color'] = info['update_color']\n                    mesh.nodes[erode_node]['color'] = info['update_color']\n                    np_image[(erode_node[0], erode_node[1])] = info['update_color']\n    new_edge_ccs = [set() for _ in range(mesh.graph['max_edge_id'] + 1)]\n    for node in mesh.nodes:\n        if len(node) == 2:\n            mesh.remove_node(node)\n            continue\n        if mesh.nodes[node].get('edge_id') is not None and mesh.nodes[node].get('inpaint_id') == inpaint_iter + 1:\n            if mesh.nodes[node].get('inpaint_twice') is False:\n                continue\n            try:\n                new_edge_ccs[mesh.nodes[node].get('edge_id')].add(node)\n            except:\n                import pdb; pdb.set_trace()\n    specific_mask_nodes = None\n    if inpaint_iter == 0:\n        mesh, info_on_pix = refine_color_around_edge(mesh, info_on_pix, new_edge_ccs, config, False)\n\n    return mesh, info_on_pix, specific_mask_nodes, new_edge_ccs, connnect_points_ccs, np_image\n\n\ndef write_ply(image,\n              depth,\n              int_mtx,\n              ply_name,\n              config,\n              rgb_model,\n              depth_edge_model,\n              depth_edge_model_init,\n              depth_feat_model):\n    depth = depth.astype(np.float64)\n    input_mesh, xy2depth, image, depth = create_mesh(depth, image, int_mtx, config)\n\n    H, W = input_mesh.graph['H'], input_mesh.graph['W']\n    input_mesh = tear_edges(input_mesh, config['depth_threshold'], xy2depth)\n    input_mesh, info_on_pix = generate_init_node(input_mesh, config, min_node_in_cc=200)\n    edge_ccs, input_mesh, edge_mesh = group_edges(input_mesh, config, image, remove_conflict_ordinal=False)\n    edge_canvas = np.zeros((H, W)) - 1\n\n    input_mesh, info_on_pix, depth = reassign_floating_island(input_mesh, info_on_pix, image, depth)\n    input_mesh = update_status(input_mesh, info_on_pix)\n    specific_edge_id = []\n    edge_ccs, input_mesh, edge_mesh = group_edges(input_mesh, config, image, remove_conflict_ordinal=True)\n    pre_depth = depth.copy()\n    input_mesh, info_on_pix, edge_mesh, depth, aft_mark = remove_dangling(input_mesh, edge_ccs, edge_mesh, info_on_pix, image, depth, config)\n\n    input_mesh, depth, info_on_pix = update_status(input_mesh, info_on_pix, depth)\n    edge_ccs, input_mesh, edge_mesh = group_edges(input_mesh, config, image, remove_conflict_ordinal=True)\n    edge_canvas = np.zeros((H, W)) - 1\n\n    mesh, info_on_pix, depth = fill_missing_node(input_mesh, info_on_pix, image, depth)\n    if config['extrapolate_border'] is True:\n        pre_depth = depth.copy()\n        input_mesh, info_on_pix, depth = refresh_bord_depth(input_mesh, info_on_pix, image, depth)\n        input_mesh = remove_node_feat(input_mesh, 'edge_id')\n        aft_depth = depth.copy()\n        input_mesh, info_on_pix, depth, image = enlarge_border(input_mesh, info_on_pix, depth, image, config)\n        noext_H, noext_W = H, W\n        H, W = image.shape[:2]\n        input_mesh, info_on_pix = fill_dummy_bord(input_mesh, info_on_pix, image, depth, config)\n        edge_ccs, input_mesh, edge_mesh = \\\n            group_edges(input_mesh, config, image, remove_conflict_ordinal=True)\n        input_mesh = combine_end_node(input_mesh, edge_mesh, edge_ccs, depth)\n        input_mesh, depth, info_on_pix = update_status(input_mesh, info_on_pix, depth)\n        edge_ccs, input_mesh, edge_mesh = \\\n            group_edges(input_mesh, config, image, remove_conflict_ordinal=True, spdb=False)\n        input_mesh = remove_redundant_edge(input_mesh, edge_mesh, edge_ccs, info_on_pix, config, redundant_number=config['redundant_number'], spdb=False)\n        input_mesh, depth, info_on_pix = update_status(input_mesh, info_on_pix, depth)\n        edge_ccs, input_mesh, edge_mesh = group_edges(input_mesh, config, image, remove_conflict_ordinal=True)\n        input_mesh = combine_end_node(input_mesh, edge_mesh, edge_ccs, depth)\n        input_mesh = remove_redundant_edge(input_mesh, edge_mesh, edge_ccs, info_on_pix, config, redundant_number=config['redundant_number'], invalid=True, spdb=False)\n        input_mesh, depth, info_on_pix = update_status(input_mesh, info_on_pix, depth)\n        edge_ccs, input_mesh, edge_mesh = group_edges(input_mesh, config, image, remove_conflict_ordinal=True)\n        input_mesh = combine_end_node(input_mesh, edge_mesh, edge_ccs, depth)\n        input_mesh, depth, info_on_pix = update_status(input_mesh, info_on_pix, depth)\n        edge_ccs, input_mesh, edge_mesh = group_edges(input_mesh, config, image, remove_conflict_ordinal=True)\n        edge_condition = lambda x, m: m.nodes[x].get('far') is not None and len(m.nodes[x].get('far')) > 0\n        edge_map = get_map_from_ccs(edge_ccs, input_mesh.graph['H'], input_mesh.graph['W'], input_mesh, edge_condition)\n        other_edge_with_id = get_map_from_ccs(edge_ccs, input_mesh.graph['H'], input_mesh.graph['W'], real_id=True)\n        info_on_pix, input_mesh, image, depth, edge_ccs = extrapolate(input_mesh, info_on_pix, image, depth, other_edge_with_id, edge_map, edge_ccs,\n                                                depth_edge_model, depth_feat_model, rgb_model, config, direc=\"up\")\n        info_on_pix, input_mesh, image, depth, edge_ccs = extrapolate(input_mesh, info_on_pix, image, depth, other_edge_with_id, edge_map, edge_ccs,\n                                                depth_edge_model, depth_feat_model, rgb_model, config, direc=\"left\")\n        info_on_pix, input_mesh, image, depth, edge_ccs = extrapolate(input_mesh, info_on_pix, image, depth, other_edge_with_id, edge_map, edge_ccs,\n                                                depth_edge_model, depth_feat_model, rgb_model, config, direc=\"down\")\n        info_on_pix, input_mesh, image, depth, edge_ccs = extrapolate(input_mesh, info_on_pix, image, depth, other_edge_with_id, edge_map, edge_ccs,\n                                                depth_edge_model, depth_feat_model, rgb_model, config, direc=\"right\")\n        info_on_pix, input_mesh, image, depth, edge_ccs = extrapolate(input_mesh, info_on_pix, image, depth, other_edge_with_id, edge_map, edge_ccs,\n                                                depth_edge_model, depth_feat_model, rgb_model, config, direc=\"right-up\")\n        info_on_pix, input_mesh, image, depth, edge_ccs = extrapolate(input_mesh, info_on_pix, image, depth, other_edge_with_id, edge_map, edge_ccs,\n                                                depth_edge_model, depth_feat_model, rgb_model, config, direc=\"right-down\")\n        info_on_pix, input_mesh, image, depth, edge_ccs = extrapolate(input_mesh, info_on_pix, image, depth, other_edge_with_id, edge_map, edge_ccs,\n                                                depth_edge_model, depth_feat_model, rgb_model, config, direc=\"left-up\")\n        info_on_pix, input_mesh, image, depth, edge_ccs = extrapolate(input_mesh, info_on_pix, image, depth, other_edge_with_id, edge_map, edge_ccs,\n                                                depth_edge_model, depth_feat_model, rgb_model, config, direc=\"left-down\")\n    specific_edge_loc = None\n    specific_edge_id = []\n    vis_edge_id = None\n    context_ccs, mask_ccs, broken_mask_ccs, edge_ccs, erode_context_ccs, \\\n        init_mask_connect, edge_maps, extend_context_ccs, extend_edge_ccs, extend_erode_context_ccs = \\\n                                                                                context_and_holes(input_mesh,\n                                                                                            edge_ccs,\n                                                                                            config,\n                                                                                            specific_edge_id,\n                                                                                            specific_edge_loc,\n                                                                                            depth_feat_model,\n                                                                                            inpaint_iter=0,\n                                                                                            vis_edge_id=vis_edge_id)\n    edge_canvas = np.zeros((H, W))\n    mask = np.zeros((H, W))\n    context = np.zeros((H, W))\n    vis_edge_ccs = filter_edge(input_mesh, edge_ccs, config)\n    edge_canvas = np.zeros((input_mesh.graph['H'], input_mesh.graph['W'])) - 1\n    specific_edge_loc = None\n    FG_edge_maps = edge_maps.copy()\n    edge_canvas = np.zeros((input_mesh.graph['H'], input_mesh.graph['W'])) - 1\n    # for cc_id, cc in enumerate(edge_ccs):\n    #     for node in cc:\n    #         edge_canvas[node[0], node[1]] = cc_id\n    # f, ((ax0, ax1, ax2)) = plt.subplots(1, 3, sharex=True, sharey=True); ax0.imshow(1./depth); ax1.imshow(image); ax2.imshow(edge_canvas); plt.show()\n    input_mesh, info_on_pix, specific_edge_nodes, new_edge_ccs, connect_points_ccs, image = DL_inpaint_edge(input_mesh,\n                                                                                                            info_on_pix,\n                                                                                                            config,\n                                                                                                            image,\n                                                                                                            depth,\n                                                                                                            context_ccs,\n                                                                                                            erode_context_ccs,\n                                                                                                            extend_context_ccs,\n                                                                                                            extend_erode_context_ccs,\n                                                                                                            mask_ccs,\n                                                                                                            broken_mask_ccs,\n                                                                                                            edge_ccs,\n                                                                                                            extend_edge_ccs,\n                                                                                                            init_mask_connect,\n                                                                                                            edge_maps,\n                                                                                                            rgb_model,\n                                                                                                            depth_edge_model,\n                                                                                                            depth_edge_model_init,\n                                                                                                            depth_feat_model,\n                                                                                                            specific_edge_id,\n                                                                                                            specific_edge_loc,\n                                                                                                            inpaint_iter=0)\n    specific_edge_id = []\n    edge_canvas = np.zeros((input_mesh.graph['H'], input_mesh.graph['W']))\n    connect_points_ccs = [set() for _ in connect_points_ccs]\n    context_ccs, mask_ccs, broken_mask_ccs, edge_ccs, erode_context_ccs, init_mask_connect, \\\n        edge_maps, extend_context_ccs, extend_edge_ccs, extend_erode_context_ccs = \\\n            context_and_holes(input_mesh, new_edge_ccs, config, specific_edge_id, specific_edge_loc, depth_feat_model, connect_points_ccs, inpaint_iter=1)\n    mask_canvas = np.zeros((input_mesh.graph['H'], input_mesh.graph['W']))\n    context_canvas = np.zeros((input_mesh.graph['H'], input_mesh.graph['W']))\n    erode_context_ccs_canvas = np.zeros((input_mesh.graph['H'], input_mesh.graph['W']))\n    edge_canvas = np.zeros((input_mesh.graph['H'], input_mesh.graph['W']))\n    # edge_canvas = np.zeros((input_mesh.graph['H'], input_mesh.graph['W'])) - 1\n    # for cc_id, cc in enumerate(edge_ccs):\n    #     for node in cc:\n    #         edge_canvas[node[0], node[1]] = cc_id\n    specific_edge_id = []\n    input_mesh, info_on_pix, specific_edge_nodes, new_edge_ccs, _, image = DL_inpaint_edge(input_mesh,\n                                                                                    info_on_pix,\n                                                                                    config,\n                                                                                    image,\n                                                                                    depth,\n                                                                                    context_ccs,\n                                                                                    erode_context_ccs,\n                                                                                    extend_context_ccs,\n                                                                                    extend_erode_context_ccs,\n                                                                                    mask_ccs,\n                                                                                    broken_mask_ccs,\n                                                                                    edge_ccs,\n                                                                                    extend_edge_ccs,\n                                                                                    init_mask_connect,\n                                                                                    edge_maps,\n                                                                                    rgb_model,\n                                                                                    depth_edge_model,\n                                                                                    depth_edge_model_init,\n                                                                                    depth_feat_model,\n                                                                                    specific_edge_id,\n                                                                                    specific_edge_loc,\n                                                                                    inpaint_iter=1)\n    vertex_id = 0\n    input_mesh.graph['H'], input_mesh.graph['W'] = input_mesh.graph['noext_H'], input_mesh.graph['noext_W']\n    background_canvas = np.zeros((input_mesh.graph['H'],\n                                  input_mesh.graph['W'],\n                                  3))\n    ply_flag = config.get('save_ply')\n    if ply_flag is True:\n        node_str_list = []\n    else:\n        node_str_color = []\n        node_str_point = []\n    out_fmt = lambda x, x_flag: str(x) if x_flag is True else x\n    point_time = 0\n    hlight_time = 0\n    cur_id_time = 0\n    node_str_time = 0\n    generate_face_time = 0\n    point_list = []\n    k_00, k_02, k_11, k_12 = \\\n        input_mesh.graph['cam_param_pix_inv'][0, 0], input_mesh.graph['cam_param_pix_inv'][0, 2], \\\n        input_mesh.graph['cam_param_pix_inv'][1, 1], input_mesh.graph['cam_param_pix_inv'][1, 2]\n    w_offset = input_mesh.graph['woffset']\n    h_offset = input_mesh.graph['hoffset']\n    for pix_xy, pix_list in info_on_pix.items():\n        for pix_idx, pix_info in enumerate(pix_list):\n            pix_depth = pix_info['depth'] if pix_info.get('real_depth') is None else pix_info['real_depth']\n            str_pt = [out_fmt(x, ply_flag) for x in reproject_3d_int_detail(pix_xy[0], pix_xy[1], pix_depth,\n                      k_00, k_02, k_11, k_12, w_offset, h_offset)]\n            if input_mesh.has_node((pix_xy[0], pix_xy[1], pix_info['depth'])) is False:\n                return False\n                continue\n            if pix_info.get('overlap_number') is not None:\n                str_color = [out_fmt(x, ply_flag) for x in (pix_info['color']/pix_info['overlap_number']).astype(np.uint8).tolist()]\n            else:\n                str_color = [out_fmt(x, ply_flag) for x in pix_info['color'].tolist()]\n            if pix_info.get('edge_occlusion') is True:\n                str_color.append(out_fmt(4, ply_flag))\n            else:\n                if pix_info.get('inpaint_id') is None:\n                    str_color.append(out_fmt(1, ply_flag))\n                else:\n                    str_color.append(out_fmt(pix_info.get('inpaint_id') + 1, ply_flag))\n            if pix_info.get('modified_border') is True or pix_info.get('ext_pixel') is True:\n                if len(str_color) == 4:\n                    str_color[-1] = out_fmt(5, ply_flag)\n                else:\n                    str_color.append(out_fmt(5, ply_flag))\n            pix_info['cur_id'] = vertex_id\n            input_mesh.nodes[(pix_xy[0], pix_xy[1], pix_info['depth'])]['cur_id'] = out_fmt(vertex_id, ply_flag)\n            vertex_id += 1\n            if ply_flag is True:\n                node_str_list.append(' '.join(str_pt) + ' ' + ' '.join(str_color) + '\\n')\n            else:\n                node_str_color.append(str_color)\n                node_str_point.append(str_pt)\n    str_faces = generate_face(input_mesh, info_on_pix, config)\n    if config['save_ply'] is True:\n        print(\"Writing mesh file %s ...\" % ply_name)\n        with open(ply_name, 'w') as ply_fi:\n            ply_fi.write('ply\\n' + 'format ascii 1.0\\n')\n            ply_fi.write('comment H ' + str(int(input_mesh.graph['H'])) + '\\n')\n            ply_fi.write('comment W ' + str(int(input_mesh.graph['W'])) + '\\n')\n            ply_fi.write('comment hFov ' + str(float(input_mesh.graph['hFov'])) + '\\n')\n            ply_fi.write('comment vFov ' + str(float(input_mesh.graph['vFov'])) + '\\n')\n            ply_fi.write('element vertex ' + str(len(node_str_list)) + '\\n')\n            ply_fi.write('property float x\\n' + \\\n                         'property float y\\n' + \\\n                         'property float z\\n' + \\\n                         'property uchar red\\n' + \\\n                         'property uchar green\\n' + \\\n                         'property uchar blue\\n' + \\\n                         'property uchar alpha\\n')\n            ply_fi.write('element face ' + str(len(str_faces)) + '\\n')\n            ply_fi.write('property list uchar int vertex_index\\n')\n            ply_fi.write('end_header\\n')\n            ply_fi.writelines(node_str_list)\n            ply_fi.writelines(str_faces)\n        ply_fi.close()\n        return input_mesh\n    else:\n        H = int(input_mesh.graph['H'])\n        W = int(input_mesh.graph['W'])\n        hFov = input_mesh.graph['hFov']\n        vFov = input_mesh.graph['vFov']\n        node_str_color = np.array(node_str_color).astype(np.float32)\n        node_str_color[..., :3] = node_str_color[..., :3] / 255.\n        node_str_point = np.array(node_str_point)\n        str_faces = np.array(str_faces)\n\n        return node_str_point, node_str_color, str_faces, H, W, hFov, vFov\n\ndef read_ply(mesh_fi):\n    ply_fi = open(mesh_fi, 'r')\n    Height = None\n    Width = None\n    hFov = None\n    vFov = None\n    while True:\n        line = ply_fi.readline().split('\\n')[0]\n        if line.startswith('element vertex'):\n            num_vertex = int(line.split(' ')[-1])\n        elif line.startswith('element face'):\n            num_face = int(line.split(' ')[-1])\n        elif line.startswith('comment'):\n            if line.split(' ')[1] == 'H':\n                Height = int(line.split(' ')[-1].split('\\n')[0])\n            if line.split(' ')[1] == 'W':\n                Width = int(line.split(' ')[-1].split('\\n')[0])\n            if line.split(' ')[1] == 'hFov':\n                hFov = float(line.split(' ')[-1].split('\\n')[0])\n            if line.split(' ')[1] == 'vFov':\n                vFov = float(line.split(' ')[-1].split('\\n')[0])\n        elif line.startswith('end_header'):\n            break\n    contents = ply_fi.readlines()\n    vertex_infos = contents[:num_vertex]\n    face_infos = contents[num_vertex:]\n    verts = []\n    colors = []\n    faces = []\n    for v_info in vertex_infos:\n        str_info = [float(v) for v in v_info.split('\\n')[0].split(' ')]\n        if len(str_info) == 6:\n            vx, vy, vz, r, g, b = str_info\n        else:\n            vx, vy, vz, r, g, b, hi = str_info\n        verts.append([vx, vy, vz])\n        colors.append([r, g, b, hi])\n    verts = np.array(verts)\n    try:\n        colors = np.array(colors)\n        colors[..., :3] = colors[..., :3]/255.\n    except:\n        import pdb\n        pdb.set_trace()\n\n    for f_info in face_infos:\n        _, v1, v2, v3 = [int(f) for f in f_info.split('\\n')[0].split(' ')]\n        faces.append([v1, v2, v3])\n    faces = np.array(faces)\n\n\n    return verts, colors, faces, Height, Width, hFov, vFov\n\n\nclass Canvas_view():\n    def __init__(self,\n                 fov,\n                 verts,\n                 faces,\n                 colors,\n                 canvas_size,\n                 factor=1,\n                 bgcolor='gray',\n                 proj='perspective',\n                 ):\n        self.canvas = scene.SceneCanvas(bgcolor=bgcolor, size=(canvas_size*factor, canvas_size*factor))\n        self.view = self.canvas.central_widget.add_view()\n        self.view.camera = 'perspective'\n        self.view.camera.fov = fov\n        self.mesh = visuals.Mesh(shading=None)\n        self.mesh.attach(Alpha(1.0))\n        self.view.add(self.mesh)\n        self.tr = self.view.camera.transform\n        self.mesh.set_data(vertices=verts, faces=faces, vertex_colors=colors[:, :3])\n        self.translate([0,0,0])\n        self.rotate(axis=[1,0,0], angle=180)\n        self.view_changed()\n\n    def translate(self, trans=[0,0,0]):\n        self.tr.translate(trans)\n\n    def rotate(self, axis=[1,0,0], angle=0):\n        self.tr.rotate(axis=axis, angle=angle)\n\n    def view_changed(self):\n        self.view.camera.view_changed()\n\n    def render(self):\n        return self.canvas.render()\n\n    def reinit_mesh(self, verts, faces, colors):\n        self.mesh.set_data(vertices=verts, faces=faces, vertex_colors=colors[:, :3])\n\n    def reinit_camera(self, fov):\n        self.view.camera.fov = fov\n        self.view.camera.view_changed()\n\n\ndef output_3d_photo(verts, colors, faces, Height, Width, hFov, vFov, tgt_poses, video_traj_types, ref_pose,\n                    output_dir, ref_image, int_mtx, config, image, videos_poses, video_basename, original_H=None, original_W=None,\n                    border=None, depth=None, normal_canvas=None, all_canvas=None, mean_loc_depth=None):\n\n    cam_mesh = netx.Graph()\n    cam_mesh.graph['H'] = Height\n    cam_mesh.graph['W'] = Width\n    cam_mesh.graph['original_H'] = original_H\n    cam_mesh.graph['original_W'] = original_W\n    int_mtx_real_x = int_mtx[0] * Width\n    int_mtx_real_y = int_mtx[1] * Height\n    cam_mesh.graph['hFov'] = 2 * np.arctan((1. / 2.) * ((cam_mesh.graph['original_W']) / int_mtx_real_x[0]))\n    cam_mesh.graph['vFov'] = 2 * np.arctan((1. / 2.) * ((cam_mesh.graph['original_H']) / int_mtx_real_y[1]))\n    colors = colors[..., :3]\n\n    fov_in_rad = max(cam_mesh.graph['vFov'], cam_mesh.graph['hFov'])\n    fov = (fov_in_rad * 180 / np.pi)\n    print(\"fov: \" + str(fov))\n    init_factor = 1\n    if config.get('anti_flickering') is True:\n        init_factor = 3\n    if (cam_mesh.graph['original_H'] is not None) and (cam_mesh.graph['original_W'] is not None):\n        canvas_w = cam_mesh.graph['original_W']\n        canvas_h = cam_mesh.graph['original_H']\n    else:\n        canvas_w = cam_mesh.graph['W']\n        canvas_h = cam_mesh.graph['H']\n    canvas_size = max(canvas_h, canvas_w)\n    if normal_canvas is None:\n        normal_canvas = Canvas_view(fov,\n                                    verts,\n                                    faces,\n                                    colors,\n                                    canvas_size=canvas_size,\n                                    factor=init_factor,\n                                    bgcolor='gray',\n                                    proj='perspective')\n    else:\n        normal_canvas.reinit_mesh(verts, faces, colors)\n        normal_canvas.reinit_camera(fov)\n    img = normal_canvas.render()\n    backup_img, backup_all_img, all_img_wo_bound = img.copy(), img.copy() * 0, img.copy() * 0\n    img = cv2.resize(img, (int(img.shape[1] / init_factor), int(img.shape[0] / init_factor)), interpolation=cv2.INTER_AREA)\n    if border is None:\n        border = [0, img.shape[0], 0, img.shape[1]]\n    H, W = cam_mesh.graph['H'], cam_mesh.graph['W']\n    if (cam_mesh.graph['original_H'] is not None) and (cam_mesh.graph['original_W'] is not None):\n        aspect_ratio = cam_mesh.graph['original_H'] / cam_mesh.graph['original_W']\n    else:\n        aspect_ratio = cam_mesh.graph['H'] / cam_mesh.graph['W']\n    if aspect_ratio > 1:\n        img_h_len = cam_mesh.graph['H'] if cam_mesh.graph.get('original_H') is None else cam_mesh.graph['original_H']\n        img_w_len = img_h_len / aspect_ratio\n        anchor = [0,\n                  img.shape[0],\n                  int(max(0, int((img.shape[1])//2 - img_w_len//2))),\n                  int(min(int((img.shape[1])//2 + img_w_len//2), (img.shape[1])-1))]\n    elif aspect_ratio <= 1:\n        img_w_len = cam_mesh.graph['W'] if cam_mesh.graph.get('original_W') is None else cam_mesh.graph['original_W']\n        img_h_len = img_w_len * aspect_ratio\n        anchor = [int(max(0, int((img.shape[0])//2 - img_h_len//2))),\n                  int(min(int((img.shape[0])//2 + img_h_len//2), (img.shape[0])-1)),\n                  0,\n                  img.shape[1]]\n    anchor = np.array(anchor)\n    plane_width = np.tan(fov_in_rad/2.) * np.abs(mean_loc_depth)\n    for video_pose, video_traj_type in zip(videos_poses, video_traj_types):\n        stereos = []\n        tops = []; buttoms = []; lefts = []; rights = []\n        for tp_id, tp in enumerate(video_pose):\n            rel_pose = np.linalg.inv(np.dot(tp, np.linalg.inv(ref_pose)))\n            axis, angle = transforms3d.axangles.mat2axangle(rel_pose[0:3, 0:3])\n            normal_canvas.rotate(axis=axis, angle=(angle*180)/np.pi)\n            normal_canvas.translate(rel_pose[:3,3])\n            new_mean_loc_depth = mean_loc_depth - float(rel_pose[2, 3])\n            if 'dolly' in video_traj_type:\n                new_fov = float((np.arctan2(plane_width, np.array([np.abs(new_mean_loc_depth)])) * 180. / np.pi) * 2)\n                normal_canvas.reinit_camera(new_fov)\n            else:\n                normal_canvas.reinit_camera(fov)\n            normal_canvas.view_changed()\n            img = normal_canvas.render()\n            img = cv2.GaussianBlur(img,(int(init_factor//2 * 2 + 1), int(init_factor//2 * 2 + 1)), 0)\n            img = cv2.resize(img, (int(img.shape[1] / init_factor), int(img.shape[0] / init_factor)), interpolation=cv2.INTER_AREA)\n            img = img[anchor[0]:anchor[1], anchor[2]:anchor[3]]\n            img = img[int(border[0]):int(border[1]), int(border[2]):int(border[3])]\n\n            if any(np.array(config['crop_border']) > 0.0):\n                H_c, W_c, _ = img.shape\n                o_t = int(H_c * config['crop_border'][0])\n                o_l = int(W_c * config['crop_border'][1])\n                o_b = int(H_c * config['crop_border'][2])\n                o_r = int(W_c * config['crop_border'][3])\n                img = img[o_t:H_c-o_b, o_l:W_c-o_r]\n                img = cv2.resize(img, (W_c, H_c), interpolation=cv2.INTER_CUBIC)\n\n            \"\"\"\n            img = cv2.resize(img, (int(img.shape[1] / init_factor), int(img.shape[0] / init_factor)), interpolation=cv2.INTER_CUBIC)\n            img = img[anchor[0]:anchor[1], anchor[2]:anchor[3]]\n            img = img[int(border[0]):int(border[1]), int(border[2]):int(border[3])]\n\n            if config['crop_border'] is True:\n                top, buttom, left, right = find_largest_rect(img, bg_color=(128, 128, 128))\n                tops.append(top); buttoms.append(buttom); lefts.append(left); rights.append(right)\n            \"\"\"\n            stereos.append(img[..., :3])\n            normal_canvas.translate(-rel_pose[:3,3])\n            normal_canvas.rotate(axis=axis, angle=-(angle*180)/np.pi)\n            normal_canvas.view_changed()\n        \"\"\"\n        if config['crop_border'] is True:\n            atop, abuttom = min(max(tops), img.shape[0]//2 - 10), max(min(buttoms), img.shape[0]//2 + 10)\n            aleft, aright = min(max(lefts), img.shape[1]//2 - 10), max(min(rights), img.shape[1]//2 + 10)\n            atop -= atop % 2; abuttom -= abuttom % 2; aleft -= aleft % 2; aright -= aright % 2\n        else:\n            atop = 0; abuttom = img.shape[0] - img.shape[0] % 2; aleft = 0; aright = img.shape[1] - img.shape[1] % 2\n        \"\"\"\n        atop = 0; abuttom = img.shape[0] - img.shape[0] % 2; aleft = 0; aright = img.shape[1] - img.shape[1] % 2\n        crop_stereos = []\n        for stereo in stereos:\n            crop_stereos.append((stereo[atop:abuttom, aleft:aright, :3] * 1).astype(np.uint8))\n            stereos = crop_stereos\n        clip = ImageSequenceClip(stereos, fps=config['fps'])\n        if isinstance(video_basename, list):\n            video_basename = video_basename[0]\n        clip.write_videofile(os.path.join(output_dir, video_basename + '_' + video_traj_type + '.mp4'), fps=config['fps'])\n\n\n\n    return normal_canvas, all_canvas\n"
        },
        {
          "name": "mesh_tools.py",
          "type": "blob",
          "size": 55.3017578125,
          "content": "import os\nimport numpy as np\ntry:\n    import cynetworkx as netx\nexcept ImportError:\n    import networkx as netx\n\nimport json\nimport scipy.misc as misc\n#import OpenEXR\nimport scipy.signal as signal\nimport matplotlib.pyplot as plt\nimport cv2\nimport scipy.misc as misc\nfrom skimage import io\nfrom functools import partial\nfrom vispy import scene, io\nfrom vispy.scene import visuals\nfrom functools import reduce\n# from moviepy.editor import ImageSequenceClip\nimport scipy.misc as misc\nfrom vispy.visuals.filters import Alpha\nimport cv2\nfrom skimage.transform import resize\nimport copy\nimport torch\nimport os\nfrom utils import refine_depth_around_edge, smooth_cntsyn_gap\nfrom utils import require_depth_edge, filter_irrelevant_edge_new, open_small_mask\nfrom skimage.feature import canny\nfrom scipy import ndimage\nimport time\nimport transforms3d\n\ndef relabel_node(mesh, nodes, cur_node, new_node):\n    if cur_node == new_node:\n        return mesh\n    mesh.add_node(new_node)\n    for key, value in nodes[cur_node].items():\n        nodes[new_node][key] = value\n    for ne in mesh.neighbors(cur_node):\n        mesh.add_edge(new_node, ne)\n    mesh.remove_node(cur_node)\n\n    return mesh\n\ndef filter_edge(mesh, edge_ccs, config, invalid=False):\n    context_ccs = [set() for _ in edge_ccs]\n    mesh_nodes = mesh.nodes\n    for edge_id, edge_cc in enumerate(edge_ccs):\n        if config['context_thickness'] == 0:\n            continue\n        edge_group = {}\n        for edge_node in edge_cc:\n            far_nodes = mesh_nodes[edge_node].get('far')\n            if far_nodes is None:\n                continue\n            for far_node in far_nodes:\n                context_ccs[edge_id].add(far_node)\n                if mesh_nodes[far_node].get('edge_id') is not None:\n                    if edge_group.get(mesh_nodes[far_node]['edge_id']) is None:\n                        edge_group[mesh_nodes[far_node]['edge_id']] = set()\n                    edge_group[mesh_nodes[far_node]['edge_id']].add(far_node)\n        if len(edge_cc) > 2:\n            for edge_key in [*edge_group.keys()]:\n                if len(edge_group[edge_key]) == 1:\n                    context_ccs[edge_id].remove([*edge_group[edge_key]][0])\n    valid_edge_ccs = []\n    for xidx, yy in enumerate(edge_ccs):\n        if invalid is not True and len(context_ccs[xidx]) > 0:\n            # if len(context_ccs[xidx]) > 0:\n            valid_edge_ccs.append(yy)\n        elif invalid is True and len(context_ccs[xidx]) == 0:\n            valid_edge_ccs.append(yy)\n        else:\n            valid_edge_ccs.append(set())\n    # valid_edge_ccs = [yy for xidx, yy in enumerate(edge_ccs) if len(context_ccs[xidx]) > 0]\n\n    return valid_edge_ccs\n\ndef extrapolate(global_mesh,\n                info_on_pix,\n                image,\n                depth,\n                other_edge_with_id,\n                edge_map,\n                edge_ccs,\n                depth_edge_model,\n                depth_feat_model,\n                rgb_feat_model,\n                config,\n                direc='right-up'):\n    h_off, w_off = global_mesh.graph['hoffset'], global_mesh.graph['woffset']\n    noext_H, noext_W = global_mesh.graph['noext_H'], global_mesh.graph['noext_W']\n\n    if \"up\" in direc.lower() and \"-\" not in direc.lower():\n        all_anchor = [0, h_off + config['context_thickness'], w_off, w_off + noext_W]\n        global_shift = [all_anchor[0], all_anchor[2]]\n        mask_anchor = [0, h_off, w_off, w_off + noext_W]\n        context_anchor = [h_off, h_off + config['context_thickness'], w_off, w_off + noext_W]\n        valid_line_anchor = [h_off, h_off + 1, w_off, w_off + noext_W]\n        valid_anchor = [min(mask_anchor[0], context_anchor[0]), max(mask_anchor[1], context_anchor[1]),\n                        min(mask_anchor[2], context_anchor[2]), max(mask_anchor[3], context_anchor[3])]\n    elif \"down\" in direc.lower() and \"-\" not in direc.lower():\n        all_anchor = [h_off + noext_H - config['context_thickness'], 2 * h_off + noext_H, w_off, w_off + noext_W]\n        global_shift = [all_anchor[0], all_anchor[2]]\n        mask_anchor = [h_off + noext_H, 2 * h_off + noext_H, w_off, w_off + noext_W]\n        context_anchor = [h_off + noext_H - config['context_thickness'], h_off + noext_H, w_off, w_off + noext_W]\n        valid_line_anchor = [h_off + noext_H - 1, h_off + noext_H, w_off, w_off + noext_W]\n        valid_anchor = [min(mask_anchor[0], context_anchor[0]), max(mask_anchor[1], context_anchor[1]),\n                        min(mask_anchor[2], context_anchor[2]), max(mask_anchor[3], context_anchor[3])]\n    elif \"left\" in direc.lower() and \"-\" not in direc.lower():\n        all_anchor = [h_off, h_off + noext_H, 0, w_off + config['context_thickness']]\n        global_shift = [all_anchor[0], all_anchor[2]]\n        mask_anchor = [h_off, h_off + noext_H, 0, w_off]\n        context_anchor = [h_off, h_off + noext_H, w_off, w_off + config['context_thickness']]\n        valid_line_anchor = [h_off, h_off + noext_H, w_off, w_off + 1]\n        valid_anchor = [min(mask_anchor[0], context_anchor[0]), max(mask_anchor[1], context_anchor[1]),\n                        min(mask_anchor[2], context_anchor[2]), max(mask_anchor[3], context_anchor[3])]\n    elif \"right\" in direc.lower() and \"-\" not in direc.lower():\n        all_anchor = [h_off, h_off + noext_H, w_off + noext_W - config['context_thickness'], 2 * w_off + noext_W]\n        global_shift = [all_anchor[0], all_anchor[2]]\n        mask_anchor = [h_off, h_off + noext_H, w_off + noext_W, 2 * w_off + noext_W]\n        context_anchor = [h_off, h_off + noext_H, w_off + noext_W - config['context_thickness'], w_off + noext_W]\n        valid_line_anchor = [h_off, h_off + noext_H, w_off + noext_W - 1, w_off + noext_W]\n        valid_anchor = [min(mask_anchor[0], context_anchor[0]), max(mask_anchor[1], context_anchor[1]),\n                        min(mask_anchor[2], context_anchor[2]), max(mask_anchor[3], context_anchor[3])]\n    elif \"left\" in direc.lower() and \"up\" in direc.lower() and \"-\" in direc.lower():\n        all_anchor = [0, h_off + config['context_thickness'], 0, w_off + config['context_thickness']]\n        global_shift = [all_anchor[0], all_anchor[2]]\n        mask_anchor = [0, h_off, 0, w_off]\n        context_anchor = \"inv-mask\"\n        valid_line_anchor = None\n        valid_anchor = all_anchor\n    elif \"left\" in direc.lower() and \"down\" in direc.lower() and \"-\" in direc.lower():\n        all_anchor = [h_off + noext_H - config['context_thickness'], 2 * h_off + noext_H, 0, w_off + config['context_thickness']]\n        global_shift = [all_anchor[0], all_anchor[2]]\n        mask_anchor = [h_off + noext_H, 2 * h_off + noext_H, 0, w_off]\n        context_anchor = \"inv-mask\"\n        valid_line_anchor = None\n        valid_anchor = all_anchor\n    elif \"right\" in direc.lower() and \"up\" in direc.lower() and \"-\" in direc.lower():\n        all_anchor = [0, h_off + config['context_thickness'], w_off + noext_W - config['context_thickness'], 2 * w_off + noext_W]\n        global_shift = [all_anchor[0], all_anchor[2]]\n        mask_anchor = [0, h_off, w_off + noext_W, 2 * w_off + noext_W]\n        context_anchor = \"inv-mask\"\n        valid_line_anchor = None\n        valid_anchor = all_anchor\n    elif \"right\" in direc.lower() and \"down\" in direc.lower() and \"-\" in direc.lower():\n        all_anchor = [h_off + noext_H - config['context_thickness'], 2 * h_off + noext_H, w_off + noext_W - config['context_thickness'], 2 * w_off + noext_W]\n        global_shift = [all_anchor[0], all_anchor[2]]\n        mask_anchor = [h_off + noext_H, 2 * h_off + noext_H, w_off + noext_W, 2 * w_off + noext_W]\n        context_anchor = \"inv-mask\"\n        valid_line_anchor = None\n        valid_anchor = all_anchor\n\n    global_mask = np.zeros_like(depth)\n    global_mask[mask_anchor[0]:mask_anchor[1],mask_anchor[2]:mask_anchor[3]] = 1\n    mask = global_mask[valid_anchor[0]:valid_anchor[1], valid_anchor[2]:valid_anchor[3]] * 1\n    context = 1 - mask\n    global_context = np.zeros_like(depth)\n    global_context[all_anchor[0]:all_anchor[1],all_anchor[2]:all_anchor[3]] = context\n    # context = global_context[valid_anchor[0]:valid_anchor[1], valid_anchor[2]:valid_anchor[3]] * 1\n\n\n\n    valid_area = mask + context\n    input_rgb = image[valid_anchor[0]:valid_anchor[1], valid_anchor[2]:valid_anchor[3]] / 255. * context[..., None]\n    input_depth = depth[valid_anchor[0]:valid_anchor[1], valid_anchor[2]:valid_anchor[3]] * context\n    log_depth = np.log(input_depth + 1e-8)\n    log_depth[mask > 0] = 0\n    input_mean_depth = np.mean(log_depth[context > 0])\n    input_zero_mean_depth = (log_depth - input_mean_depth) * context\n    input_disp = 1./np.abs(input_depth)\n    input_disp[mask > 0] = 0\n    input_disp = input_disp / input_disp.max()\n    valid_line = np.zeros_like(depth)\n    if valid_line_anchor is not None:\n        valid_line[valid_line_anchor[0]:valid_line_anchor[1], valid_line_anchor[2]:valid_line_anchor[3]] = 1\n    valid_line = valid_line[all_anchor[0]:all_anchor[1], all_anchor[2]:all_anchor[3]]\n    # f, ((ax1, ax2)) = plt.subplots(1, 2, sharex=True, sharey=True); ax1.imshow(global_context * 1 + global_mask * 2); ax2.imshow(image); plt.show()\n    # f, ((ax1, ax2, ax3)) = plt.subplots(1, 3, sharex=True, sharey=True); ax1.imshow(context * 1 + mask * 2); ax2.imshow(input_rgb); ax3.imshow(valid_line); plt.show()\n    # import pdb; pdb.set_trace()\n    # return\n    input_edge_map = edge_map[all_anchor[0]:all_anchor[1], all_anchor[2]:all_anchor[3]] * context\n    input_other_edge_with_id = other_edge_with_id[all_anchor[0]:all_anchor[1], all_anchor[2]:all_anchor[3]]\n    end_depth_maps = ((valid_line * input_edge_map) > 0) * input_depth\n\n\n    if isinstance(config[\"gpu_ids\"], int) and (config[\"gpu_ids\"] >= 0):\n        device = config[\"gpu_ids\"]\n    else:\n        device = \"cpu\"\n\n    valid_edge_ids = sorted(list(input_other_edge_with_id[(valid_line * input_edge_map) > 0]))\n    valid_edge_ids = valid_edge_ids[1:] if (len(valid_edge_ids) > 0 and valid_edge_ids[0] == -1) else valid_edge_ids\n    edge = reduce(lambda x, y: (x + (input_other_edge_with_id == y).astype(np.uint8)).clip(0, 1), [np.zeros_like(mask)] + list(valid_edge_ids))\n    t_edge = torch.FloatTensor(edge).to(device)[None, None, ...]\n    t_rgb = torch.FloatTensor(input_rgb).to(device).permute(2,0,1).unsqueeze(0)\n    t_mask = torch.FloatTensor(mask).to(device)[None, None, ...]\n    t_context = torch.FloatTensor(context).to(device)[None, None, ...]\n    t_disp = torch.FloatTensor(input_disp).to(device)[None, None, ...]\n    t_depth_zero_mean_depth = torch.FloatTensor(input_zero_mean_depth).to(device)[None, None, ...]\n\n    depth_edge_output = depth_edge_model.forward_3P(t_mask, t_context, t_rgb, t_disp, t_edge, unit_length=128,\n                                                    cuda=device)\n    t_output_edge = (depth_edge_output> config['ext_edge_threshold']).float() * t_mask + t_edge\n    output_raw_edge = t_output_edge.data.cpu().numpy().squeeze()\n    # import pdb; pdb.set_trace()\n    mesh = netx.Graph()\n    hxs, hys = np.where(output_raw_edge * mask > 0)\n    valid_map = mask + context\n    for hx, hy in zip(hxs, hys):\n        node = (hx, hy)\n        mesh.add_node((hx, hy))\n        eight_nes = [ne for ne in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1), \\\n                                   (hx + 1, hy + 1), (hx - 1, hy - 1), (hx - 1, hy + 1), (hx + 1, hy - 1)]\\\n                        if 0 <= ne[0] < output_raw_edge.shape[0] and 0 <= ne[1] < output_raw_edge.shape[1] and 0 < output_raw_edge[ne[0], ne[1]]]\n        for ne in eight_nes:\n            mesh.add_edge(node, ne, length=np.hypot(ne[0] - hx, ne[1] - hy))\n            if end_depth_maps[ne[0], ne[1]] != 0:\n                mesh.nodes[ne[0], ne[1]]['cnt'] = True\n                mesh.nodes[ne[0], ne[1]]['depth'] = end_depth_maps[ne[0], ne[1]]\n    ccs = [*netx.connected_components(mesh)]\n    end_pts = []\n    for cc in ccs:\n        end_pts.append(set())\n        for node in cc:\n            if mesh.nodes[node].get('cnt') is not None:\n                end_pts[-1].add((node[0], node[1], mesh.nodes[node]['depth']))\n    fpath_map = np.zeros_like(output_raw_edge) - 1\n    npath_map = np.zeros_like(output_raw_edge) - 1\n    for end_pt, cc in zip(end_pts, ccs):\n        sorted_end_pt = []\n        if len(end_pt) >= 2:\n            continue\n        if len(end_pt) == 0:\n            continue\n        if len(end_pt) == 1:\n            sub_mesh = mesh.subgraph(list(cc)).copy()\n            pnodes = netx.periphery(sub_mesh)\n            ends = [*end_pt]\n            edge_id = global_mesh.nodes[(ends[0][0] + all_anchor[0], ends[0][1] + all_anchor[2], -ends[0][2])]['edge_id']\n            pnodes = sorted(pnodes,\n                            key=lambda x: np.hypot((x[0] - ends[0][0]), (x[1] - ends[0][1])),\n                            reverse=True)[0]\n            npath = [*netx.shortest_path(sub_mesh, (ends[0][0], ends[0][1]), pnodes, weight='length')]\n            for np_node in npath:\n                npath_map[np_node[0], np_node[1]] = edge_id\n            fpath = []\n            if global_mesh.nodes[(ends[0][0] + all_anchor[0], ends[0][1] + all_anchor[2], -ends[0][2])].get('far') is None:\n                print(\"None far\")\n                import pdb; pdb.set_trace()\n            else:\n                fnodes = global_mesh.nodes[(ends[0][0] + all_anchor[0], ends[0][1] + all_anchor[2], -ends[0][2])].get('far')\n                fnodes = [(xx[0] - all_anchor[0], xx[1] - all_anchor[2], xx[2]) for xx in fnodes]\n                dmask = mask + 0\n                did = 0\n                while True:\n                    did += 1\n                    dmask = cv2.dilate(dmask, np.ones((3, 3)), iterations=1)\n                    if did > 3:\n                        break\n                    # ffnode = [fnode for fnode in fnodes if (dmask[fnode[0], fnode[1]] > 0)]\n                    ffnode = [fnode for fnode in fnodes if (dmask[fnode[0], fnode[1]] > 0 and mask[fnode[0], fnode[1]] == 0)]\n                    if len(ffnode) > 0:\n                        fnode = ffnode[0]\n                        break\n                if len(ffnode) == 0:\n                    continue\n                fpath.append((fnode[0], fnode[1]))\n                for step in range(0, len(npath) - 1):\n                    parr = (npath[step + 1][0] - npath[step][0], npath[step + 1][1] - npath[step][1])\n                    new_loc = (fpath[-1][0] + parr[0], fpath[-1][1] + parr[1])\n                    new_loc_nes = [xx for xx in [(new_loc[0] + 1, new_loc[1]), (new_loc[0] - 1, new_loc[1]),\n                                                (new_loc[0], new_loc[1] + 1), (new_loc[0], new_loc[1] - 1)]\\\n                                        if xx[0] >= 0 and xx[0] < fpath_map.shape[0] and xx[1] >= 0 and xx[1] < fpath_map.shape[1]]\n                    if np.sum([fpath_map[nlne[0], nlne[1]] for nlne in new_loc_nes]) != -4:\n                        break\n                    if npath_map[new_loc[0], new_loc[1]] != -1:\n                        if npath_map[new_loc[0], new_loc[1]] != edge_id:\n                            break\n                        else:\n                            continue\n                    if valid_area[new_loc[0], new_loc[1]] == 0:\n                        break\n                    new_loc_nes_eight = [xx for xx in [(new_loc[0] + 1, new_loc[1]), (new_loc[0] - 1, new_loc[1]),\n                                                        (new_loc[0], new_loc[1] + 1), (new_loc[0], new_loc[1] - 1),\n                                                        (new_loc[0] + 1, new_loc[1] + 1), (new_loc[0] + 1, new_loc[1] - 1),\n                                                        (new_loc[0] - 1, new_loc[1] - 1), (new_loc[0] - 1, new_loc[1] + 1)]\\\n                                        if xx[0] >= 0 and xx[0] < fpath_map.shape[0] and xx[1] >= 0 and xx[1] < fpath_map.shape[1]]\n                    if np.sum([int(npath_map[nlne[0], nlne[1]] == edge_id) for nlne in new_loc_nes_eight]) == 0:\n                        break\n                    fpath.append((fpath[-1][0] + parr[0], fpath[-1][1] + parr[1]))\n                if step != len(npath) - 2:\n                    for xx in npath[step+1:]:\n                        if npath_map[xx[0], xx[1]] == edge_id:\n                            npath_map[xx[0], xx[1]] = -1\n            if len(fpath) > 0:\n                for fp_node in fpath:\n                    fpath_map[fp_node[0], fp_node[1]] = edge_id\n    # import pdb; pdb.set_trace()\n    far_edge = (fpath_map > -1).astype(np.uint8)\n    update_edge = (npath_map > -1) * mask + edge\n    t_update_edge = torch.FloatTensor(update_edge).to(device)[None, None, ...]\n    depth_output = depth_feat_model.forward_3P(t_mask, t_context, t_depth_zero_mean_depth, t_update_edge, unit_length=128,\n                                               cuda=device)\n    depth_output = depth_output.cpu().data.numpy().squeeze()\n    depth_output = np.exp(depth_output + input_mean_depth) * mask # + input_depth * context\n    # if \"right\" in direc.lower() and \"-\" not in direc.lower():\n    #     plt.imshow(depth_output); plt.show()\n    #     import pdb; pdb.set_trace()\n    #     f, ((ax1, ax2)) = plt.subplots(1, 2, sharex=True, sharey=True); ax1.imshow(depth_output); ax2.imshow(npath_map + fpath_map); plt.show()\n    for near_id in np.unique(npath_map[npath_map > -1]):\n        depth_output = refine_depth_around_edge(depth_output.copy(),\n                                                (fpath_map == near_id).astype(np.uint8) * mask, # far_edge_map_in_mask,\n                                                (fpath_map == near_id).astype(np.uint8), # far_edge_map,\n                                                (npath_map == near_id).astype(np.uint8) * mask,\n                                                mask.copy(),\n                                                np.zeros_like(mask),\n                                                config)\n    # if \"right\" in direc.lower() and \"-\" not in direc.lower():\n    #     plt.imshow(depth_output); plt.show()\n    #     import pdb; pdb.set_trace()\n    #     f, ((ax1, ax2)) = plt.subplots(1, 2, sharex=True, sharey=True); ax1.imshow(depth_output); ax2.imshow(npath_map + fpath_map); plt.show()\n    rgb_output = rgb_feat_model.forward_3P(t_mask, t_context, t_rgb, t_update_edge, unit_length=128,\n                                           cuda=device)\n\n    # rgb_output = rgb_feat_model.forward_3P(t_mask, t_context, t_rgb, t_update_edge, unit_length=128, cuda=config['gpu_ids'])\n    if config.get('gray_image') is True:\n        rgb_output = rgb_output.mean(1, keepdim=True).repeat((1,3,1,1))\n    rgb_output = ((rgb_output.squeeze().data.cpu().permute(1,2,0).numpy() * mask[..., None] + input_rgb) * 255).astype(np.uint8)\n    image[all_anchor[0]:all_anchor[1], all_anchor[2]:all_anchor[3]][mask > 0] = rgb_output[mask > 0] # np.array([255,0,0]) # rgb_output[mask > 0]\n    depth[all_anchor[0]:all_anchor[1], all_anchor[2]:all_anchor[3]][mask > 0] = depth_output[mask > 0]\n    # nxs, nys = np.where(mask > -1)\n    # for nx, ny in zip(nxs, nys):\n    #     info_on_pix[(nx, ny)][0]['color'] = rgb_output[]\n\n\n    nxs, nys = np.where((npath_map > -1))\n    for nx, ny in zip(nxs, nys):\n        n_id = npath_map[nx, ny]\n        four_nes = [xx for xx in [(nx + 1, ny), (nx - 1, ny), (nx, ny + 1), (nx, ny - 1)]\\\n                        if 0 <= xx[0] < fpath_map.shape[0] and 0 <= xx[1] < fpath_map.shape[1]]\n        for nex, ney in four_nes:\n            if fpath_map[nex, ney] == n_id:\n                na, nb = (nx + all_anchor[0], ny + all_anchor[2], info_on_pix[(nx + all_anchor[0], ny + all_anchor[2])][0]['depth']), \\\n                        (nex + all_anchor[0], ney + all_anchor[2], info_on_pix[(nex + all_anchor[0], ney + all_anchor[2])][0]['depth'])\n                if global_mesh.has_edge(na, nb):\n                    global_mesh.remove_edge(na, nb)\n    nxs, nys = np.where((fpath_map > -1))\n    for nx, ny in zip(nxs, nys):\n        n_id = fpath_map[nx, ny]\n        four_nes = [xx for xx in [(nx + 1, ny), (nx - 1, ny), (nx, ny + 1), (nx, ny - 1)]\\\n                        if 0 <= xx[0] < npath_map.shape[0] and 0 <= xx[1] < npath_map.shape[1]]\n        for nex, ney in four_nes:\n            if npath_map[nex, ney] == n_id:\n                na, nb = (nx + all_anchor[0], ny + all_anchor[2], info_on_pix[(nx + all_anchor[0], ny + all_anchor[2])][0]['depth']), \\\n                        (nex + all_anchor[0], ney + all_anchor[2], info_on_pix[(nex + all_anchor[0], ney + all_anchor[2])][0]['depth'])\n                if global_mesh.has_edge(na, nb):\n                    global_mesh.remove_edge(na, nb)\n    nxs, nys = np.where(mask > 0)\n    for x, y in zip(nxs, nys):\n        x = x + all_anchor[0]\n        y = y + all_anchor[2]\n        cur_node = (x, y, 0)\n        new_node = (x, y, -abs(depth[x, y]))\n        disp = 1. / -abs(depth[x, y])\n        mapping_dict = {cur_node: new_node}\n        info_on_pix, global_mesh = update_info(mapping_dict, info_on_pix, global_mesh)\n        global_mesh.nodes[new_node]['color'] = image[x, y]\n        global_mesh.nodes[new_node]['old_color'] = image[x, y]\n        global_mesh.nodes[new_node]['disp'] = disp\n        info_on_pix[(x, y)][0]['depth'] = -abs(depth[x, y])\n        info_on_pix[(x, y)][0]['disp'] = disp\n        info_on_pix[(x, y)][0]['color'] = image[x, y]\n\n\n    nxs, nys = np.where((npath_map > -1))\n    for nx, ny in zip(nxs, nys):\n        self_node = (nx + all_anchor[0], ny + all_anchor[2], info_on_pix[(nx + all_anchor[0], ny + all_anchor[2])][0]['depth'])\n        if global_mesh.has_node(self_node) is False:\n            break\n        n_id = int(round(npath_map[nx, ny]))\n        four_nes = [xx for xx in [(nx + 1, ny), (nx - 1, ny), (nx, ny + 1), (nx, ny - 1)]\\\n                        if 0 <= xx[0] < fpath_map.shape[0] and 0 <= xx[1] < fpath_map.shape[1]]\n        for nex, ney in four_nes:\n            ne_node = (nex + all_anchor[0], ney + all_anchor[2], info_on_pix[(nex + all_anchor[0], ney + all_anchor[2])][0]['depth'])\n            if global_mesh.has_node(ne_node) is False:\n                continue\n            if fpath_map[nex, ney] == n_id:\n                if global_mesh.nodes[self_node].get('edge_id') is None:\n                    global_mesh.nodes[self_node]['edge_id'] = n_id\n                    edge_ccs[n_id].add(self_node)\n                    info_on_pix[(self_node[0], self_node[1])][0]['edge_id'] = n_id\n                if global_mesh.has_edge(self_node, ne_node) is True:\n                    global_mesh.remove_edge(self_node, ne_node)\n                if global_mesh.nodes[self_node].get('far') is None:\n                    global_mesh.nodes[self_node]['far'] = []\n                global_mesh.nodes[self_node]['far'].append(ne_node)\n\n    global_fpath_map = np.zeros_like(other_edge_with_id) - 1\n    global_fpath_map[all_anchor[0]:all_anchor[1], all_anchor[2]:all_anchor[3]] = fpath_map\n    fpath_ids = np.unique(global_fpath_map)\n    fpath_ids = fpath_ids[1:] if fpath_ids.shape[0] > 0 and fpath_ids[0] == -1 else []\n    fpath_real_id_map = np.zeros_like(global_fpath_map) - 1\n    for fpath_id in fpath_ids:\n        fpath_real_id = np.unique(((global_fpath_map == fpath_id).astype(np.int) * (other_edge_with_id + 1)) - 1)\n        fpath_real_id = fpath_real_id[1:] if fpath_real_id.shape[0] > 0 and fpath_real_id[0] == -1 else []\n        fpath_real_id = fpath_real_id.astype(np.int)\n        fpath_real_id = np.bincount(fpath_real_id).argmax()\n        fpath_real_id_map[global_fpath_map == fpath_id] = fpath_real_id\n    nxs, nys = np.where((fpath_map > -1))\n    for nx, ny in zip(nxs, nys):\n        self_node = (nx + all_anchor[0], ny + all_anchor[2], info_on_pix[(nx + all_anchor[0], ny + all_anchor[2])][0]['depth'])\n        n_id = fpath_map[nx, ny]\n        four_nes = [xx for xx in [(nx + 1, ny), (nx - 1, ny), (nx, ny + 1), (nx, ny - 1)]\\\n                        if 0 <= xx[0] < npath_map.shape[0] and 0 <= xx[1] < npath_map.shape[1]]\n        for nex, ney in four_nes:\n            ne_node = (nex + all_anchor[0], ney + all_anchor[2], info_on_pix[(nex + all_anchor[0], ney + all_anchor[2])][0]['depth'])\n            if global_mesh.has_node(ne_node) is False:\n                continue\n            if npath_map[nex, ney] == n_id or global_mesh.nodes[ne_node].get('edge_id') == n_id:\n                if global_mesh.has_edge(self_node, ne_node) is True:\n                    global_mesh.remove_edge(self_node, ne_node)\n                if global_mesh.nodes[self_node].get('near') is None:\n                    global_mesh.nodes[self_node]['near'] = []\n                if global_mesh.nodes[self_node].get('edge_id') is None:\n                    f_id = int(round(fpath_real_id_map[self_node[0], self_node[1]]))\n                    global_mesh.nodes[self_node]['edge_id'] = f_id\n                    info_on_pix[(self_node[0], self_node[1])][0]['edge_id'] = f_id\n                    edge_ccs[f_id].add(self_node)\n                global_mesh.nodes[self_node]['near'].append(ne_node)\n\n    return info_on_pix, global_mesh, image, depth, edge_ccs\n    # for edge_cc in edge_ccs:\n    #     for edge_node in edge_cc:\n    #         edge_ccs\n    # context_ccs, mask_ccs, broken_mask_ccs, edge_ccs, erode_context_ccs, init_mask_connect, edge_maps, extend_context_ccs, extend_edge_ccs\n\ndef get_valid_size(imap):\n    x_max = np.where(imap.sum(1).squeeze() > 0)[0].max() + 1\n    x_min = np.where(imap.sum(1).squeeze() > 0)[0].min()\n    y_max = np.where(imap.sum(0).squeeze() > 0)[0].max() + 1\n    y_min = np.where(imap.sum(0).squeeze() > 0)[0].min()\n    size_dict = {'x_max':x_max, 'y_max':y_max, 'x_min':x_min, 'y_min':y_min}\n\n    return size_dict\n\ndef dilate_valid_size(isize_dict, imap, dilate=[0, 0]):\n    osize_dict = copy.deepcopy(isize_dict)\n    osize_dict['x_min'] = max(0, osize_dict['x_min'] - dilate[0])\n    osize_dict['x_max'] = min(imap.shape[0], osize_dict['x_max'] + dilate[0])\n    osize_dict['y_min'] = max(0, osize_dict['y_min'] - dilate[0])\n    osize_dict['y_max'] = min(imap.shape[1], osize_dict['y_max'] + dilate[1])\n\n    return osize_dict\n\ndef size_operation(size_a, size_b, operation):\n    assert operation == '+' or operation == '-', \"Operation must be '+' (union) or '-' (exclude)\"\n    osize = {}\n    if operation == '+':\n        osize['x_min'] = min(size_a['x_min'], size_b['x_min'])\n        osize['y_min'] = min(size_a['y_min'], size_b['y_min'])\n        osize['x_max'] = max(size_a['x_max'], size_b['x_max'])\n        osize['y_max'] = max(size_a['y_max'], size_b['y_max'])\n    assert operation != '-', \"Operation '-' is undefined !\"\n\n    return osize\n\ndef fill_dummy_bord(mesh, info_on_pix, image, depth, config):\n    context = np.zeros_like(depth).astype(np.uint8)\n    context[mesh.graph['hoffset']:mesh.graph['hoffset'] + mesh.graph['noext_H'],\n            mesh.graph['woffset']:mesh.graph['woffset'] + mesh.graph['noext_W']] = 1\n    mask = 1 - context\n    xs, ys = np.where(mask > 0)\n    depth = depth * context\n    image = image * context[..., None]\n    cur_depth = 0\n    cur_disp = 0\n    color = [0, 0, 0]\n    for x, y in zip(xs, ys):\n        cur_node = (x, y, cur_depth)\n        mesh.add_node(cur_node, color=color,\n                        synthesis=False,\n                        disp=cur_disp,\n                        cc_id=set(),\n                        ext_pixel=True)\n        info_on_pix[(x, y)] = [{'depth':cur_depth,\n                    'color':mesh.nodes[(x, y, cur_depth)]['color'],\n                    'synthesis':False,\n                    'disp':mesh.nodes[cur_node]['disp'],\n                    'ext_pixel':True}]\n        # for x, y in zip(xs, ys):\n        four_nes = [(xx, yy) for xx, yy in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)] if\\\n                    0 <= x < mesh.graph['H'] and 0 <= y < mesh.graph['W'] and info_on_pix.get((xx, yy)) is not None]\n        for ne in four_nes:\n            # if (ne[0] - x) + (ne[1] - y) == 1 and info_on_pix.get((ne[0], ne[1])) is not None:\n            mesh.add_edge(cur_node, (ne[0], ne[1], info_on_pix[(ne[0], ne[1])][0]['depth']))\n\n    return mesh, info_on_pix\n\n\ndef enlarge_border(mesh, info_on_pix, depth, image, config):\n    mesh.graph['hoffset'], mesh.graph['woffset'] = config['extrapolation_thickness'], config['extrapolation_thickness']\n    mesh.graph['bord_up'], mesh.graph['bord_left'], mesh.graph['bord_down'], mesh.graph['bord_right'] = \\\n        0, 0, mesh.graph['H'], mesh.graph['W']\n    # new_image = np.pad(image,\n    #                    pad_width=((config['extrapolation_thickness'], config['extrapolation_thickness']),\n    #                               (config['extrapolation_thickness'], config['extrapolation_thickness']), (0, 0)),\n    #                    mode='constant')\n    # new_depth = np.pad(depth,\n    #                    pad_width=((config['extrapolation_thickness'], config['extrapolation_thickness']),\n    #                               (config['extrapolation_thickness'], config['extrapolation_thickness'])),\n    #                    mode='constant')\n\n    return mesh, info_on_pix, depth, image\n\ndef fill_missing_node(mesh, info_on_pix, image, depth):\n    for x in range(mesh.graph['bord_up'], mesh.graph['bord_down']):\n        for y in range(mesh.graph['bord_left'], mesh.graph['bord_right']):\n            if info_on_pix.get((x, y)) is None:\n                print(\"fill missing node = \", x, y)\n                import pdb; pdb.set_trace()\n                re_depth, re_count = 0, 0\n                for ne in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n                    if info_on_pix.get(ne) is not None:\n                        re_depth += info_on_pix[ne][0]['depth']\n                        re_count += 1\n                if re_count == 0:\n                    re_depth = -abs(depth[x, y])\n                else:\n                    re_depth = re_depth / re_count\n                depth[x, y] = abs(re_depth)\n                info_on_pix[(x, y)] = [{'depth':re_depth,\n                                            'color':image[x, y],\n                                            'synthesis':False,\n                                            'disp':1./re_depth}]\n                mesh.add_node((x, y, re_depth), color=image[x, y],\n                                                synthesis=False,\n                                                disp=1./re_depth,\n                                                cc_id=set())\n    return mesh, info_on_pix, depth\n\n\n\ndef refresh_bord_depth(mesh, info_on_pix, image, depth):\n    H, W = mesh.graph['H'], mesh.graph['W']\n    corner_nodes = [(mesh.graph['bord_up'], mesh.graph['bord_left']),\n                    (mesh.graph['bord_up'], mesh.graph['bord_right'] - 1),\n                    (mesh.graph['bord_down'] - 1, mesh.graph['bord_left']),\n                    (mesh.graph['bord_down'] - 1, mesh.graph['bord_right'] - 1)]\n                    # (0, W - 1), (H - 1, 0), (H - 1, W - 1)]\n    bord_nodes = []\n    bord_nodes += [(mesh.graph['bord_up'], xx) for xx in range(mesh.graph['bord_left'] + 1, mesh.graph['bord_right'] - 1)]\n    bord_nodes += [(mesh.graph['bord_down'] - 1, xx) for xx in range(mesh.graph['bord_left'] + 1, mesh.graph['bord_right'] - 1)]\n    bord_nodes += [(xx, mesh.graph['bord_left']) for xx in range(mesh.graph['bord_up'] + 1, mesh.graph['bord_down'] - 1)]\n    bord_nodes += [(xx, mesh.graph['bord_right'] - 1) for xx in range(mesh.graph['bord_up'] + 1, mesh.graph['bord_down'] - 1)]\n    for xy in bord_nodes:\n        tgt_loc = None\n        if xy[0] == mesh.graph['bord_up']:\n            tgt_loc = (xy[0] + 1, xy[1])# (1, xy[1])\n        elif xy[0] == mesh.graph['bord_down'] - 1:\n            tgt_loc = (xy[0] - 1, xy[1]) # (H - 2, xy[1])\n        elif xy[1] == mesh.graph['bord_left']:\n            tgt_loc = (xy[0], xy[1] + 1)\n        elif xy[1] == mesh.graph['bord_right'] - 1:\n            tgt_loc = (xy[0], xy[1] - 1)\n        if tgt_loc is not None:\n            ne_infos = info_on_pix.get(tgt_loc)\n            if ne_infos is None:\n                import pdb; pdb.set_trace()\n            # if ne_infos is not None and len(ne_infos) == 1:\n            tgt_depth = ne_infos[0]['depth']\n            tgt_disp = ne_infos[0]['disp']\n            new_node = (xy[0], xy[1], tgt_depth)\n            src_node = (tgt_loc[0], tgt_loc[1], tgt_depth)\n            tgt_nes_loc = [(xx[0], xx[1]) \\\n                            for xx in mesh.neighbors(src_node)]\n            tgt_nes_loc = [(xx[0] - tgt_loc[0] + xy[0], xx[1] - tgt_loc[1] + xy[1]) for xx in tgt_nes_loc \\\n                            if abs(xx[0] - xy[0]) == 1 and abs(xx[1] - xy[1]) == 1]\n            tgt_nes_loc = [xx for xx in tgt_nes_loc if info_on_pix.get(xx) is not None]\n            tgt_nes_loc.append(tgt_loc)\n            # if (xy[0], xy[1]) == (559, 60):\n            #     import pdb; pdb.set_trace()\n            if info_on_pix.get(xy) is not None and len(info_on_pix.get(xy)) > 0:\n                old_depth = info_on_pix[xy][0].get('depth')\n                old_node = (xy[0], xy[1], old_depth)\n                mesh.remove_edges_from([(old_ne, old_node) for old_ne in mesh.neighbors(old_node)])\n                mesh.add_edges_from([((zz[0], zz[1], info_on_pix[zz][0]['depth']), old_node) for zz in tgt_nes_loc])\n                mapping_dict = {old_node: new_node}\n                # if old_node[2] == new_node[2]:\n                #     print(\"mapping_dict = \", mapping_dict)\n                info_on_pix, mesh = update_info(mapping_dict, info_on_pix, mesh)\n            else:\n                info_on_pix[xy] = []\n                info_on_pix[xy][0] = info_on_pix[tgt_loc][0]\n                info_on_pix['color'] = image[xy[0], xy[1]]\n                info_on_pix['old_color'] = image[xy[0], xy[1]]\n                mesh.add_node(new_node)\n                mesh.add_edges_from([((zz[0], zz[1], info_on_pix[zz][0]['depth']), new_node) for zz in tgt_nes_loc])\n            mesh.nodes[new_node]['far'] = None\n            mesh.nodes[new_node]['near'] = None\n            if mesh.nodes[src_node].get('far') is not None:\n                redundant_nodes = [ne for ne in mesh.nodes[src_node]['far'] if (ne[0], ne[1]) == xy]\n                [mesh.nodes[src_node]['far'].remove(aa) for aa in redundant_nodes]\n            if mesh.nodes[src_node].get('near') is not None:\n                redundant_nodes = [ne for ne in mesh.nodes[src_node]['near'] if (ne[0], ne[1]) == xy]\n                [mesh.nodes[src_node]['near'].remove(aa) for aa in redundant_nodes]\n    for xy in corner_nodes:\n        hx, hy = xy\n        four_nes = [xx for xx in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1)] if \\\n                        mesh.graph['bord_up'] <= xx[0] < mesh.graph['bord_down'] and \\\n                            mesh.graph['bord_left'] <= xx[1] < mesh.graph['bord_right']]\n        ne_nodes = []\n        ne_depths = []\n        for ne_loc in four_nes:\n            if info_on_pix.get(ne_loc) is not None:\n                ne_depths.append(info_on_pix[ne_loc][0]['depth'])\n                ne_nodes.append((ne_loc[0], ne_loc[1], info_on_pix[ne_loc][0]['depth']))\n        new_node = (xy[0], xy[1], float(np.mean(ne_depths)))\n        if info_on_pix.get(xy) is not None and len(info_on_pix.get(xy)) > 0:\n            old_depth = info_on_pix[xy][0].get('depth')\n            old_node = (xy[0], xy[1], old_depth)\n            mesh.remove_edges_from([(old_ne, old_node) for old_ne in mesh.neighbors(old_node)])\n            mesh.add_edges_from([(zz, old_node) for zz in ne_nodes])\n            mapping_dict = {old_node: new_node}\n            info_on_pix, mesh = update_info(mapping_dict, info_on_pix, mesh)\n        else:\n            info_on_pix[xy] = []\n            info_on_pix[xy][0] = info_on_pix[ne_loc[-1]][0]\n            info_on_pix['color'] = image[xy[0], xy[1]]\n            info_on_pix['old_color'] = image[xy[0], xy[1]]\n            mesh.add_node(new_node)\n            mesh.add_edges_from([(zz, new_node) for zz in ne_nodes])\n        mesh.nodes[new_node]['far'] = None\n        mesh.nodes[new_node]['near'] = None\n    for xy in bord_nodes + corner_nodes:\n        # if (xy[0], xy[1]) == (559, 60):\n        #     import pdb; pdb.set_trace()\n        depth[xy[0], xy[1]] = abs(info_on_pix[xy][0]['depth'])\n    for xy in bord_nodes:\n        cur_node = (xy[0], xy[1], info_on_pix[xy][0]['depth'])\n        nes = mesh.neighbors(cur_node)\n        four_nes = set([(xy[0] + 1, xy[1]), (xy[0] - 1, xy[1]), (xy[0], xy[1] + 1), (xy[0], xy[1] - 1)]) - \\\n                   set([(ne[0], ne[1]) for ne in nes])\n        four_nes = [ne for ne in four_nes if mesh.graph['bord_up'] <= ne[0] < mesh.graph['bord_down'] and \\\n                                             mesh.graph['bord_left'] <= ne[1] < mesh.graph['bord_right']]\n        four_nes = [(ne[0], ne[1], info_on_pix[(ne[0], ne[1])][0]['depth']) for ne in four_nes]\n        mesh.nodes[cur_node]['far'] = []\n        mesh.nodes[cur_node]['near'] = []\n        for ne in four_nes:\n            if abs(ne[2]) >= abs(cur_node[2]):\n                mesh.nodes[cur_node]['far'].append(ne)\n            else:\n                mesh.nodes[cur_node]['near'].append(ne)\n\n    return mesh, info_on_pix, depth\n\ndef get_union_size(mesh, dilate, *alls_cc):\n    all_cc = reduce(lambda x, y: x | y, [set()] + [*alls_cc])\n    min_x, min_y, max_x, max_y = mesh.graph['H'], mesh.graph['W'], 0, 0\n    H, W = mesh.graph['H'], mesh.graph['W']\n    for node in all_cc:\n        if node[0] < min_x:\n            min_x = node[0]\n        if node[0] > max_x:\n            max_x = node[0]\n        if node[1] < min_y:\n            min_y = node[1]\n        if node[1] > max_y:\n            max_y = node[1]\n    max_x = max_x + 1\n    max_y = max_y + 1\n    # mask_size = dilate_valid_size(mask_size, edge_dict['mask'], dilate=[20, 20])\n    osize_dict = dict()\n    osize_dict['x_min'] = max(0, min_x - dilate[0])\n    osize_dict['x_max'] = min(H, max_x + dilate[0])\n    osize_dict['y_min'] = max(0, min_y - dilate[1])\n    osize_dict['y_max'] = min(W, max_y + dilate[1])\n\n    return osize_dict\n\ndef incomplete_node(mesh, edge_maps, info_on_pix):\n    vis_map = np.zeros((mesh.graph['H'], mesh.graph['W']))\n\n    for node in mesh.nodes:\n        if mesh.nodes[node].get('synthesis') is not True:\n            connect_all_flag = False\n            nes = [xx for xx in mesh.neighbors(node) if mesh.nodes[xx].get('synthesis') is not True]\n            if len(nes) < 3 and 0 < node[0] < mesh.graph['H'] - 1 and 0 < node[1] < mesh.graph['W'] - 1:\n                if len(nes) <= 1:\n                    connect_all_flag = True\n                else:\n                    dan_ne_node_a = nes[0]\n                    dan_ne_node_b = nes[1]\n                    if abs(dan_ne_node_a[0] - dan_ne_node_b[0]) > 1 or \\\n                        abs(dan_ne_node_a[1] - dan_ne_node_b[1]) > 1:\n                        connect_all_flag = True\n            if connect_all_flag == True:\n                vis_map[node[0], node[1]] = len(nes)\n                four_nes = [(node[0] - 1, node[1]), (node[0] + 1, node[1]), (node[0], node[1] - 1), (node[0], node[1] + 1)]\n                for ne in four_nes:\n                    for info in info_on_pix[(ne[0], ne[1])]:\n                        ne_node = (ne[0], ne[1], info['depth'])\n                        if info.get('synthesis') is not True and mesh.has_node(ne_node):\n                            mesh.add_edge(node, ne_node)\n                            break\n\n    return mesh\n\ndef edge_inpainting(edge_id, context_cc, erode_context_cc, mask_cc, edge_cc, extend_edge_cc,\n                    mesh, edge_map, edge_maps_with_id, config, union_size, depth_edge_model, inpaint_iter):\n    edge_dict = get_edge_from_nodes(context_cc, erode_context_cc, mask_cc, edge_cc, extend_edge_cc,\n                                        mesh.graph['H'], mesh.graph['W'], mesh)\n    edge_dict['edge'], end_depth_maps, _ = \\\n        filter_irrelevant_edge_new(edge_dict['self_edge'] + edge_dict['comp_edge'],\n                                edge_map,\n                                edge_maps_with_id,\n                                edge_id,\n                                edge_dict['context'],\n                                edge_dict['depth'], mesh, context_cc | erode_context_cc, spdb=True)\n    patch_edge_dict = dict()\n    patch_edge_dict['mask'], patch_edge_dict['context'], patch_edge_dict['rgb'], \\\n        patch_edge_dict['disp'], patch_edge_dict['edge'] = \\\n        crop_maps_by_size(union_size, edge_dict['mask'], edge_dict['context'],\n                            edge_dict['rgb'], edge_dict['disp'], edge_dict['edge'])\n    tensor_edge_dict = convert2tensor(patch_edge_dict)\n    if require_depth_edge(patch_edge_dict['edge'], patch_edge_dict['mask']) and inpaint_iter == 0:\n        with torch.no_grad():\n            device = config[\"gpu_ids\"] if isinstance(config[\"gpu_ids\"], int) and config[\"gpu_ids\"] >= 0 else \"cpu\"\n            depth_edge_output = depth_edge_model.forward_3P(tensor_edge_dict['mask'],\n                                                            tensor_edge_dict['context'],\n                                                            tensor_edge_dict['rgb'],\n                                                            tensor_edge_dict['disp'],\n                                                            tensor_edge_dict['edge'],\n                                                            unit_length=128,\n                                                            cuda=device)\n            depth_edge_output = depth_edge_output.cpu()\n        tensor_edge_dict['output'] = (depth_edge_output > config['ext_edge_threshold']).float() * tensor_edge_dict['mask'] + tensor_edge_dict['edge']\n    else:\n        tensor_edge_dict['output'] = tensor_edge_dict['edge']\n        depth_edge_output = tensor_edge_dict['edge'] + 0\n    patch_edge_dict['output'] = tensor_edge_dict['output'].squeeze().data.cpu().numpy()\n    edge_dict['output'] = np.zeros((mesh.graph['H'], mesh.graph['W']))\n    edge_dict['output'][union_size['x_min']:union_size['x_max'], union_size['y_min']:union_size['y_max']] = \\\n        patch_edge_dict['output']\n\n    return edge_dict, end_depth_maps\n\ndef depth_inpainting(context_cc, extend_context_cc, erode_context_cc, mask_cc, mesh, config, union_size, depth_feat_model, edge_output, given_depth_dict=False, spdb=False):\n    if given_depth_dict is False:\n        depth_dict = get_depth_from_nodes(context_cc | extend_context_cc, erode_context_cc, mask_cc, mesh.graph['H'], mesh.graph['W'], mesh, config['log_depth'])\n        if edge_output is not None:\n            depth_dict['edge'] = edge_output\n    else:\n        depth_dict = given_depth_dict\n    patch_depth_dict = dict()\n    patch_depth_dict['mask'], patch_depth_dict['context'], patch_depth_dict['depth'], \\\n        patch_depth_dict['zero_mean_depth'], patch_depth_dict['edge'] = \\\n            crop_maps_by_size(union_size, depth_dict['mask'], depth_dict['context'],\n                                depth_dict['real_depth'], depth_dict['zero_mean_depth'], depth_dict['edge'])\n    tensor_depth_dict = convert2tensor(patch_depth_dict)\n    resize_mask = open_small_mask(tensor_depth_dict['mask'], tensor_depth_dict['context'], 3, 41)\n    with torch.no_grad():\n        device = config[\"gpu_ids\"] if isinstance(config[\"gpu_ids\"], int) and config[\"gpu_ids\"] >= 0 else \"cpu\"\n        depth_output = depth_feat_model.forward_3P(resize_mask,\n                                                    tensor_depth_dict['context'],\n                                                    tensor_depth_dict['zero_mean_depth'],\n                                                    tensor_depth_dict['edge'],\n                                                    unit_length=128,\n                                                    cuda=device)\n        depth_output = depth_output.cpu()\n    tensor_depth_dict['output'] = torch.exp(depth_output + depth_dict['mean_depth']) * \\\n                                            tensor_depth_dict['mask'] + tensor_depth_dict['depth']\n    patch_depth_dict['output'] = tensor_depth_dict['output'].data.cpu().numpy().squeeze()\n    depth_dict['output'] = np.zeros((mesh.graph['H'], mesh.graph['W']))\n    depth_dict['output'][union_size['x_min']:union_size['x_max'], union_size['y_min']:union_size['y_max']] = \\\n        patch_depth_dict['output']\n    depth_output = depth_dict['output'] * depth_dict['mask'] + depth_dict['depth'] * depth_dict['context']\n    depth_output = smooth_cntsyn_gap(depth_dict['output'].copy() * depth_dict['mask'] + depth_dict['depth'] * depth_dict['context'],\n                                    depth_dict['mask'], depth_dict['context'],\n                                    init_mask_region=depth_dict['mask'])\n    if spdb is True:\n        f, ((ax1, ax2)) = plt.subplots(1, 2, sharex=True, sharey=True);\n        ax1.imshow(depth_output * depth_dict['mask'] + depth_dict['depth']); ax2.imshow(depth_dict['output'] * depth_dict['mask'] + depth_dict['depth']); plt.show()\n        import pdb; pdb.set_trace()\n    depth_dict['output'] = depth_output * depth_dict['mask'] + depth_dict['depth'] * depth_dict['context']\n\n    return depth_dict\n\ndef update_info(mapping_dict, info_on_pix, *meshes):\n    rt_meshes = []\n    for mesh in meshes:\n        rt_meshes.append(relabel_node(mesh, mesh.nodes, [*mapping_dict.keys()][0], [*mapping_dict.values()][0]))\n    x, y, _ = [*mapping_dict.keys()][0]\n    info_on_pix[(x, y)][0]['depth'] = [*mapping_dict.values()][0][2]\n\n    return [info_on_pix] + rt_meshes\n\ndef build_connection(mesh, cur_node, dst_node):\n    if (abs(cur_node[0] - dst_node[0]) + abs(cur_node[1] - dst_node[1])) < 2:\n        mesh.add_edge(cur_node, dst_node)\n    if abs(cur_node[0] - dst_node[0]) > 1 or abs(cur_node[1] - dst_node[1]) > 1:\n        return mesh\n    ne_nodes = [*mesh.neighbors(cur_node)].copy()\n    for ne_node in ne_nodes:\n        if mesh.has_edge(ne_node, dst_node) or ne_node == dst_node:\n            continue\n        else:\n            mesh = build_connection(mesh, ne_node, dst_node)\n\n    return mesh\n\ndef recursive_add_edge(edge_mesh, mesh, info_on_pix, cur_node, mark):\n    ne_nodes = [(x[0], x[1]) for x in edge_mesh.neighbors(cur_node)]\n    for node_xy in ne_nodes:\n        node = (node_xy[0], node_xy[1], info_on_pix[node_xy][0]['depth'])\n        if mark[node[0], node[1]] != 3:\n            continue\n        else:\n            mark[node[0], node[1]] = 0\n            mesh.remove_edges_from([(xx, node) for xx in mesh.neighbors(node)])\n            mesh = build_connection(mesh, cur_node, node)\n            re_info = dict(depth=0, count=0)\n            for re_ne in mesh.neighbors(node):\n                re_info['depth'] += re_ne[2]\n                re_info['count'] += 1.\n            try:\n                re_depth = re_info['depth'] / re_info['count']\n            except:\n                re_depth = node[2]\n            re_node = (node_xy[0], node_xy[1], re_depth)\n            mapping_dict = {node: re_node}\n            info_on_pix, edge_mesh, mesh = update_info(mapping_dict, info_on_pix, edge_mesh, mesh)\n\n            edge_mesh, mesh, mark, info_on_pix = recursive_add_edge(edge_mesh, mesh, info_on_pix, re_node, mark)\n\n    return edge_mesh, mesh, mark, info_on_pix\n\ndef resize_for_edge(tensor_dict, largest_size):\n    resize_dict = {k: v.clone() for k, v in tensor_dict.items()}\n    frac = largest_size / np.array([*resize_dict['edge'].shape[-2:]]).max()\n    if frac < 1:\n        resize_mark = torch.nn.functional.interpolate(torch.cat((resize_dict['mask'],\n                                                        resize_dict['context']),\n                                                        dim=1),\n                                                        scale_factor=frac,\n                                                        mode='bilinear')\n        resize_dict['mask'] = (resize_mark[:, 0:1] > 0).float()\n        resize_dict['context'] = (resize_mark[:, 1:2] == 1).float()\n        resize_dict['context'][resize_dict['mask'] > 0] = 0\n        resize_dict['edge'] = torch.nn.functional.interpolate(resize_dict['edge'],\n                                                                scale_factor=frac,\n                                                                mode='bilinear')\n        resize_dict['edge'] = (resize_dict['edge'] > 0).float()\n        resize_dict['edge'] = resize_dict['edge'] * resize_dict['context']\n        resize_dict['disp'] = torch.nn.functional.interpolate(resize_dict['disp'],\n                                                                scale_factor=frac,\n                                                                mode='nearest')\n        resize_dict['disp'] = resize_dict['disp'] * resize_dict['context']\n        resize_dict['rgb'] = torch.nn.functional.interpolate(resize_dict['rgb'],\n                                                                    scale_factor=frac,\n                                                                    mode='bilinear')\n        resize_dict['rgb'] = resize_dict['rgb'] * resize_dict['context']\n    return resize_dict\n\ndef get_map_from_nodes(nodes, height, width):\n    omap = np.zeros((height, width))\n    for n in nodes:\n        omap[n[0], n[1]] = 1\n\n    return omap\n\ndef get_map_from_ccs(ccs, height, width, condition_input=None, condition=None, real_id=False, id_shift=0):\n    if condition is None:\n        condition = lambda x, condition_input: True\n\n    if real_id is True:\n        omap = np.zeros((height, width)) + (-1) + id_shift\n    else:\n        omap = np.zeros((height, width))\n    for cc_id, cc in enumerate(ccs):\n        for n in cc:\n            if condition(n, condition_input):\n                if real_id is True:\n                    omap[n[0], n[1]] = cc_id + id_shift\n                else:\n                    omap[n[0], n[1]] = 1\n    return omap\n\ndef revise_map_by_nodes(nodes, imap, operation, limit_constr=None):\n    assert operation == '+' or operation == '-', \"Operation must be '+' (union) or '-' (exclude)\"\n    omap = copy.deepcopy(imap)\n    revise_flag = True\n    if operation == '+':\n        for n in nodes:\n            omap[n[0], n[1]] = 1\n        if limit_constr is not None and omap.sum() > limit_constr:\n            omap = imap\n            revise_flag = False\n    elif operation == '-':\n        for n in nodes:\n            omap[n[0], n[1]] = 0\n        if limit_constr is not None and omap.sum() < limit_constr:\n            omap = imap\n            revise_flag = False\n\n    return omap, revise_flag\n\ndef repaint_info(mesh, cc, x_anchor, y_anchor, source_type):\n    if source_type == 'rgb':\n        feat = np.zeros((3, x_anchor[1] - x_anchor[0], y_anchor[1] - y_anchor[0]))\n    else:\n        feat = np.zeros((1, x_anchor[1] - x_anchor[0], y_anchor[1] - y_anchor[0]))\n    for node in cc:\n        if source_type == 'rgb':\n            feat[:, node[0] - x_anchor[0], node[1] - y_anchor[0]] = np.array(mesh.nodes[node]['color']) / 255.\n        elif source_type == 'd':\n            feat[:, node[0] - x_anchor[0], node[1] - y_anchor[0]] = abs(node[2])\n\n    return feat\n\ndef get_context_from_nodes(mesh, cc, H, W, source_type=''):\n    if 'rgb' in source_type or 'color' in source_type:\n        feat = np.zeros((H, W, 3))\n    else:\n        feat = np.zeros((H, W))\n    context = np.zeros((H, W))\n    for node in cc:\n        if 'rgb' in source_type or 'color' in source_type:\n            feat[node[0], node[1]] = np.array(mesh.nodes[node]['color']) / 255.\n            context[node[0], node[1]] = 1\n        else:\n            feat[node[0], node[1]] = abs(node[2])\n\n    return feat, context\n\ndef get_mask_from_nodes(mesh, cc, H, W):\n    mask = np.zeros((H, W))\n    for node in cc:\n        mask[node[0], node[1]] = abs(node[2])\n\n    return mask\n\n\ndef get_edge_from_nodes(context_cc, erode_context_cc, mask_cc, edge_cc, extend_edge_cc, H, W, mesh):\n    context = np.zeros((H, W))\n    mask = np.zeros((H, W))\n    rgb = np.zeros((H, W, 3))\n    disp = np.zeros((H, W))\n    depth = np.zeros((H, W))\n    real_depth = np.zeros((H, W))\n    edge = np.zeros((H, W))\n    comp_edge = np.zeros((H, W))\n    fpath_map = np.zeros((H, W)) - 1\n    npath_map = np.zeros((H, W)) - 1\n    near_depth = np.zeros((H, W))\n    for node in context_cc:\n        rgb[node[0], node[1]] = np.array(mesh.nodes[node]['color'])\n        disp[node[0], node[1]] = mesh.nodes[node]['disp']\n        depth[node[0], node[1]] = node[2]\n        context[node[0], node[1]] = 1\n    for node in erode_context_cc:\n        rgb[node[0], node[1]] = np.array(mesh.nodes[node]['color'])\n        disp[node[0], node[1]] = mesh.nodes[node]['disp']\n        depth[node[0], node[1]] = node[2]\n        context[node[0], node[1]] = 1\n    rgb = rgb / 255.\n    disp = np.abs(disp)\n    disp = disp / disp.max()\n    real_depth = depth.copy()\n    for node in context_cc:\n        if mesh.nodes[node].get('real_depth') is not None:\n            real_depth[node[0], node[1]] = mesh.nodes[node]['real_depth']\n    for node in erode_context_cc:\n        if mesh.nodes[node].get('real_depth') is not None:\n            real_depth[node[0], node[1]] = mesh.nodes[node]['real_depth']\n    for node in mask_cc:\n        mask[node[0], node[1]] = 1\n        near_depth[node[0], node[1]] = node[2]\n    for node in edge_cc:\n        edge[node[0], node[1]] = 1\n    for node in extend_edge_cc:\n        comp_edge[node[0], node[1]] = 1\n    rt_dict = {'rgb': rgb, 'disp': disp, 'depth': depth, 'real_depth': real_depth, 'self_edge': edge, 'context': context,\n               'mask': mask, 'fpath_map': fpath_map, 'npath_map': npath_map, 'comp_edge': comp_edge, 'valid_area': context + mask,\n               'near_depth': near_depth}\n\n    return rt_dict\n\ndef get_depth_from_maps(context_map, mask_map, depth_map, H, W, log_depth=False):\n    context = context_map.astype(np.uint8)\n    mask = mask_map.astype(np.uint8).copy()\n    depth = np.abs(depth_map)\n    real_depth = depth.copy()\n    zero_mean_depth = np.zeros((H, W))\n\n    if log_depth is True:\n        log_depth = np.log(real_depth + 1e-8) * context\n        mean_depth = np.mean(log_depth[context > 0])\n        zero_mean_depth = (log_depth - mean_depth) * context\n    else:\n        zero_mean_depth = real_depth\n        mean_depth = 0\n    edge = np.zeros_like(depth)\n\n    rt_dict = {'depth': depth, 'real_depth': real_depth, 'context': context, 'mask': mask,\n               'mean_depth': mean_depth, 'zero_mean_depth': zero_mean_depth, 'edge': edge}\n\n    return rt_dict\n\ndef get_depth_from_nodes(context_cc, erode_context_cc, mask_cc, H, W, mesh, log_depth=False):\n    context = np.zeros((H, W))\n    mask = np.zeros((H, W))\n    depth = np.zeros((H, W))\n    real_depth = np.zeros((H, W))\n    zero_mean_depth = np.zeros((H, W))\n    for node in context_cc:\n        depth[node[0], node[1]] = node[2]\n        context[node[0], node[1]] = 1\n    for node in erode_context_cc:\n        depth[node[0], node[1]] = node[2]\n        context[node[0], node[1]] = 1\n    depth = np.abs(depth)\n    real_depth = depth.copy()\n    for node in context_cc:\n        if mesh.nodes[node].get('real_depth') is not None:\n            real_depth[node[0], node[1]] = mesh.nodes[node]['real_depth']\n    for node in erode_context_cc:\n        if mesh.nodes[node].get('real_depth') is not None:\n            real_depth[node[0], node[1]] = mesh.nodes[node]['real_depth']\n    real_depth = np.abs(real_depth)\n    for node in mask_cc:\n        mask[node[0], node[1]] = 1\n    if log_depth is True:\n        log_depth = np.log(real_depth + 1e-8) * context\n        mean_depth = np.mean(log_depth[context > 0])\n        zero_mean_depth = (log_depth - mean_depth) * context\n    else:\n        zero_mean_depth = real_depth\n        mean_depth = 0\n\n    rt_dict = {'depth': depth, 'real_depth': real_depth, 'context': context, 'mask': mask,\n               'mean_depth': mean_depth, 'zero_mean_depth': zero_mean_depth}\n\n    return rt_dict\n\ndef get_rgb_from_nodes(context_cc, erode_context_cc, mask_cc, H, W, mesh):\n    context = np.zeros((H, W))\n    mask = np.zeros((H, W))\n    rgb = np.zeros((H, W, 3))\n    erode_context = np.zeros((H, W))\n    for node in context_cc:\n        rgb[node[0], node[1]] = np.array(mesh.nodes[node]['color'])\n        context[node[0], node[1]] = 1\n    rgb = rgb / 255.\n    for node in mask_cc:\n        mask[node[0], node[1]] = 1\n    for node in erode_context_cc:\n        erode_context[node[0], node[1]] = 1\n        mask[node[0], node[1]] = 1\n    rt_dict = {'rgb': rgb, 'context': context, 'mask': mask,\n               'erode': erode_context}\n\n    return rt_dict\n\ndef crop_maps_by_size(size, *imaps):\n    omaps = []\n    for imap in imaps:\n        omaps.append(imap[size['x_min']:size['x_max'], size['y_min']:size['y_max']].copy())\n\n    return omaps\n\ndef convert2tensor(input_dict):\n    rt_dict = {}\n    for key, value in input_dict.items():\n        if 'rgb' in key or 'color' in key:\n            rt_dict[key] = torch.FloatTensor(value).permute(2, 0, 1)[None, ...]\n        else:\n            rt_dict[key] = torch.FloatTensor(value)[None, None, ...]\n\n    return rt_dict\n"
        },
        {
          "name": "networks.py",
          "type": "blob",
          "size": 21.53515625,
          "content": "import torch\nimport torch.nn as nn\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport torch.nn.functional as F\n\n\nclass BaseNetwork(nn.Module):\n    def __init__(self):\n        super(BaseNetwork, self).__init__()\n\n    def init_weights(self, init_type='normal', gain=0.02):\n        '''\n        initialize network's weights\n        init_type: normal | xavier | kaiming | orthogonal\n        https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/blob/9451e70673400885567d08a9e97ade2524c700d0/models/networks.py#L39\n        '''\n\n        def init_func(m):\n            classname = m.__class__.__name__\n            if hasattr(m, 'weight') and (classname.find('Conv') != -1 or classname.find('Linear') != -1):\n                if init_type == 'normal':\n                    nn.init.normal_(m.weight.data, 0.0, gain)\n                elif init_type == 'xavier':\n                    nn.init.xavier_normal_(m.weight.data, gain=gain)\n                elif init_type == 'kaiming':\n                    nn.init.kaiming_normal_(m.weight.data, a=0, mode='fan_in')\n                elif init_type == 'orthogonal':\n                    nn.init.orthogonal_(m.weight.data, gain=gain)\n\n                if hasattr(m, 'bias') and m.bias is not None:\n                    nn.init.constant_(m.bias.data, 0.0)\n\n            elif classname.find('BatchNorm2d') != -1:\n                nn.init.normal_(m.weight.data, 1.0, gain)\n                nn.init.constant_(m.bias.data, 0.0)\n\n        self.apply(init_func)\n\ndef weights_init(init_type='gaussian'):\n    def init_fun(m):\n        classname = m.__class__.__name__\n        if (classname.find('Conv') == 0 or classname.find(\n                'Linear') == 0) and hasattr(m, 'weight'):\n            if init_type == 'gaussian':\n                nn.init.normal_(m.weight, 0.0, 0.02)\n            elif init_type == 'xavier':\n                nn.init.xavier_normal_(m.weight, gain=math.sqrt(2))\n            elif init_type == 'kaiming':\n                nn.init.kaiming_normal_(m.weight, a=0, mode='fan_in')\n            elif init_type == 'orthogonal':\n                nn.init.orthogonal_(m.weight, gain=math.sqrt(2))\n            elif init_type == 'default':\n                pass\n            else:\n                assert 0, \"Unsupported initialization: {}\".format(init_type)\n            if hasattr(m, 'bias') and m.bias is not None:\n                nn.init.constant_(m.bias, 0.0)\n\n    return init_fun\n\nclass PartialConv(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride=1,\n                 padding=0, dilation=1, groups=1, bias=True):\n        super().__init__()\n        self.input_conv = nn.Conv2d(in_channels, out_channels, kernel_size,\n                                    stride, padding, dilation, groups, bias)\n        self.mask_conv = nn.Conv2d(in_channels, out_channels, kernel_size,\n                                   stride, padding, dilation, groups, False)\n        self.input_conv.apply(weights_init('kaiming'))\n        self.slide_winsize = in_channels * kernel_size * kernel_size\n\n        torch.nn.init.constant_(self.mask_conv.weight, 1.0)\n\n        # mask is not updated\n        for param in self.mask_conv.parameters():\n            param.requires_grad = False\n\n    def forward(self, input, mask):\n        # http://masc.cs.gmu.edu/wiki/partialconv\n        # C(X) = W^T * X + b, C(0) = b, D(M) = 1 * M + 0 = sum(M)\n        # W^T* (M .* X) / sum(M) + b = [C(M .* X) – C(0)] / D(M) + C(0)\n        output = self.input_conv(input * mask)\n        if self.input_conv.bias is not None:\n            output_bias = self.input_conv.bias.view(1, -1, 1, 1).expand_as(\n                output)\n        else:\n            output_bias = torch.zeros_like(output)\n\n        with torch.no_grad():\n            output_mask = self.mask_conv(mask)\n\n        no_update_holes = output_mask == 0\n\n        mask_sum = output_mask.masked_fill_(no_update_holes, 1.0)\n\n        output_pre = ((output - output_bias) * self.slide_winsize) / mask_sum + output_bias\n        output = output_pre.masked_fill_(no_update_holes, 0.0)\n\n        new_mask = torch.ones_like(output)\n        new_mask = new_mask.masked_fill_(no_update_holes, 0.0)\n\n        return output, new_mask\n\n\nclass PCBActiv(nn.Module):\n    def __init__(self, in_ch, out_ch, bn=True, sample='none-3', activ='relu',\n                 conv_bias=False):\n        super().__init__()\n        if sample == 'down-5':\n            self.conv = PartialConv(in_ch, out_ch, 5, 2, 2, bias=conv_bias)\n        elif sample == 'down-7':\n            self.conv = PartialConv(in_ch, out_ch, 7, 2, 3, bias=conv_bias)\n        elif sample == 'down-3':\n            self.conv = PartialConv(in_ch, out_ch, 3, 2, 1, bias=conv_bias)\n        else:\n            self.conv = PartialConv(in_ch, out_ch, 3, 1, 1, bias=conv_bias)\n\n        if bn:\n            self.bn = nn.BatchNorm2d(out_ch)\n        if activ == 'relu':\n            self.activation = nn.ReLU()\n        elif activ == 'leaky':\n            self.activation = nn.LeakyReLU(negative_slope=0.2)\n\n    def forward(self, input, input_mask):\n        h, h_mask = self.conv(input, input_mask)\n        if hasattr(self, 'bn'):\n            h = self.bn(h)\n        if hasattr(self, 'activation'):\n            h = self.activation(h)\n        return h, h_mask\n\nclass Inpaint_Depth_Net(nn.Module):\n    def __init__(self, layer_size=7, upsampling_mode='nearest'):\n        super().__init__()\n        in_channels = 4\n        out_channels = 1\n        self.freeze_enc_bn = False\n        self.upsampling_mode = upsampling_mode\n        self.layer_size = layer_size\n        self.enc_1 = PCBActiv(in_channels, 64, bn=False, sample='down-7', conv_bias=True)\n        self.enc_2 = PCBActiv(64, 128, sample='down-5', conv_bias=True)\n        self.enc_3 = PCBActiv(128, 256, sample='down-5')\n        self.enc_4 = PCBActiv(256, 512, sample='down-3')\n        for i in range(4, self.layer_size):\n            name = 'enc_{:d}'.format(i + 1)\n            setattr(self, name, PCBActiv(512, 512, sample='down-3'))\n\n        for i in range(4, self.layer_size):\n            name = 'dec_{:d}'.format(i + 1)\n            setattr(self, name, PCBActiv(512 + 512, 512, activ='leaky'))\n        self.dec_4 = PCBActiv(512 + 256, 256, activ='leaky')\n        self.dec_3 = PCBActiv(256 + 128, 128, activ='leaky')\n        self.dec_2 = PCBActiv(128 + 64, 64, activ='leaky')\n        self.dec_1 = PCBActiv(64 + in_channels, out_channels,\n                              bn=False, activ=None, conv_bias=True)\n    def add_border(self, input, mask_flag, PCONV=True):\n        with torch.no_grad():\n            h = input.shape[-2]\n            w = input.shape[-1]\n            require_len_unit = 2 ** self.layer_size\n            residual_h = int(np.ceil(h / float(require_len_unit)) * require_len_unit - h) # + 2*require_len_unit\n            residual_w = int(np.ceil(w / float(require_len_unit)) * require_len_unit - w) # + 2*require_len_unit\n            enlarge_input = torch.zeros((input.shape[0], input.shape[1], h + residual_h, w + residual_w)).to(input.device)\n            if mask_flag:\n                if PCONV is False:\n                    enlarge_input += 1.0\n                enlarge_input = enlarge_input.clamp(0.0, 1.0)\n            else:\n                enlarge_input[:, 2, ...] = 0.0\n            anchor_h = residual_h//2\n            anchor_w = residual_w//2\n            enlarge_input[..., anchor_h:anchor_h+h, anchor_w:anchor_w+w] = input\n\n        return enlarge_input, [anchor_h, anchor_h+h, anchor_w, anchor_w+w]\n\n    def forward_3P(self, mask, context, depth, edge, unit_length=128, cuda=None):\n        with torch.no_grad():\n            input = torch.cat((depth, edge, context, mask), dim=1)\n            n, c, h, w = input.shape\n            residual_h = int(np.ceil(h / float(unit_length)) * unit_length - h)\n            residual_w = int(np.ceil(w / float(unit_length)) * unit_length - w)\n            anchor_h = residual_h//2\n            anchor_w = residual_w//2\n            enlarge_input = torch.zeros((n, c, h + residual_h, w + residual_w)).to(cuda)\n            enlarge_input[..., anchor_h:anchor_h+h, anchor_w:anchor_w+w] = input\n            # enlarge_input[:, 3] = 1. - enlarge_input[:, 3]\n            depth_output = self.forward(enlarge_input)\n            depth_output = depth_output[..., anchor_h:anchor_h+h, anchor_w:anchor_w+w]\n            # import pdb; pdb.set_trace()\n\n        return depth_output\n\n    def forward(self, input_feat, refine_border=False, sample=False, PCONV=True):\n        input = input_feat\n        input_mask = (input_feat[:, -2:-1] + input_feat[:, -1:]).clamp(0, 1).repeat(1, input.shape[1], 1, 1)\n\n        vis_input = input.cpu().data.numpy()\n        vis_input_mask = input_mask.cpu().data.numpy()\n        H, W = input.shape[-2:]\n        if refine_border is True:\n            input, anchor = self.add_border(input, mask_flag=False)\n            input_mask, anchor = self.add_border(input_mask, mask_flag=True, PCONV=PCONV)\n        h_dict = {}  # for the output of enc_N\n        h_mask_dict = {}  # for the output of enc_N\n        h_dict['h_0'], h_mask_dict['h_0'] = input, input_mask\n\n        h_key_prev = 'h_0'\n        for i in range(1, self.layer_size + 1):\n            l_key = 'enc_{:d}'.format(i)\n            h_key = 'h_{:d}'.format(i)\n            h_dict[h_key], h_mask_dict[h_key] = getattr(self, l_key)(\n                h_dict[h_key_prev], h_mask_dict[h_key_prev])\n            h_key_prev = h_key\n\n        h_key = 'h_{:d}'.format(self.layer_size)\n        h, h_mask = h_dict[h_key], h_mask_dict[h_key]\n\n        for i in range(self.layer_size, 0, -1):\n            enc_h_key = 'h_{:d}'.format(i - 1)\n            dec_l_key = 'dec_{:d}'.format(i)\n\n            h = F.interpolate(h, scale_factor=2, mode=self.upsampling_mode)\n            h_mask = F.interpolate(h_mask, scale_factor=2, mode='nearest')\n\n            h = torch.cat([h, h_dict[enc_h_key]], dim=1)\n            h_mask = torch.cat([h_mask, h_mask_dict[enc_h_key]], dim=1)\n            h, h_mask = getattr(self, dec_l_key)(h, h_mask)\n        output = h\n        if refine_border is True:\n            h_mask = h_mask[..., anchor[0]:anchor[1], anchor[2]:anchor[3]]\n            output = output[..., anchor[0]:anchor[1], anchor[2]:anchor[3]]\n\n        return output\n\nclass Inpaint_Edge_Net(BaseNetwork):\n    def __init__(self, residual_blocks=8, init_weights=True):\n        super(Inpaint_Edge_Net, self).__init__()\n        in_channels = 7\n        out_channels = 1\n        self.encoder = []\n        # 0\n        self.encoder_0 = nn.Sequential(\n                            nn.ReflectionPad2d(3),\n                            spectral_norm(nn.Conv2d(in_channels=in_channels, out_channels=64, kernel_size=7, padding=0), True),\n                            nn.InstanceNorm2d(64, track_running_stats=False),\n                            nn.ReLU(True))\n        # 1\n        self.encoder_1 = nn.Sequential(\n                            spectral_norm(nn.Conv2d(in_channels=64, out_channels=128, kernel_size=4, stride=2, padding=1), True),\n                            nn.InstanceNorm2d(128, track_running_stats=False),\n                            nn.ReLU(True))\n        # 2\n        self.encoder_2 = nn.Sequential(\n                            spectral_norm(nn.Conv2d(in_channels=128, out_channels=256, kernel_size=4, stride=2, padding=1), True),\n                            nn.InstanceNorm2d(256, track_running_stats=False),\n                            nn.ReLU(True))\n        # 3\n        blocks = []\n        for _ in range(residual_blocks):\n            block = ResnetBlock(256, 2)\n            blocks.append(block)\n\n        self.middle = nn.Sequential(*blocks)\n        # + 3\n        self.decoder_0 = nn.Sequential(\n                            spectral_norm(nn.ConvTranspose2d(in_channels=256+256, out_channels=128, kernel_size=4, stride=2, padding=1), True),\n                            nn.InstanceNorm2d(128, track_running_stats=False),\n                            nn.ReLU(True))\n        # + 2\n        self.decoder_1 = nn.Sequential(\n                            spectral_norm(nn.ConvTranspose2d(in_channels=128+128, out_channels=64, kernel_size=4, stride=2, padding=1), True),\n                            nn.InstanceNorm2d(64, track_running_stats=False),\n                            nn.ReLU(True))\n        # + 1\n        self.decoder_2 = nn.Sequential(\n                            nn.ReflectionPad2d(3),\n                            nn.Conv2d(in_channels=64+64, out_channels=out_channels, kernel_size=7, padding=0),\n                            )\n\n        if init_weights:\n            self.init_weights()\n\n    def add_border(self, input, channel_pad_1=None):\n        h = input.shape[-2]\n        w = input.shape[-1]\n        require_len_unit = 16\n        residual_h = int(np.ceil(h / float(require_len_unit)) * require_len_unit - h) # + 2*require_len_unit\n        residual_w = int(np.ceil(w / float(require_len_unit)) * require_len_unit - w) # + 2*require_len_unit\n        enlarge_input = torch.zeros((input.shape[0], input.shape[1], h + residual_h, w + residual_w)).to(input.device)\n        if channel_pad_1 is not None:\n            for channel in channel_pad_1:\n                enlarge_input[:, channel] = 1\n        anchor_h = residual_h//2\n        anchor_w = residual_w//2\n        enlarge_input[..., anchor_h:anchor_h+h, anchor_w:anchor_w+w] = input\n\n        return enlarge_input, [anchor_h, anchor_h+h, anchor_w, anchor_w+w]\n\n    def forward_3P(self, mask, context, rgb, disp, edge, unit_length=128, cuda=None):\n        with torch.no_grad():\n            input = torch.cat((rgb, disp/disp.max(), edge, context, mask), dim=1)\n            n, c, h, w = input.shape\n            residual_h = int(np.ceil(h / float(unit_length)) * unit_length - h)\n            residual_w = int(np.ceil(w / float(unit_length)) * unit_length - w)\n            anchor_h = residual_h//2\n            anchor_w = residual_w//2\n            enlarge_input = torch.zeros((n, c, h + residual_h, w + residual_w)).to(cuda)\n            enlarge_input[..., anchor_h:anchor_h+h, anchor_w:anchor_w+w] = input\n            edge_output = self.forward(enlarge_input)\n            edge_output = edge_output[..., anchor_h:anchor_h+h, anchor_w:anchor_w+w]\n\n        return edge_output\n\n    def forward(self, x, refine_border=False):\n        if refine_border:\n            x, anchor = self.add_border(x, [5])\n        x1 = self.encoder_0(x)\n        x2 = self.encoder_1(x1)\n        x3 = self.encoder_2(x2)\n        x4 = self.middle(x3)\n        x5 = self.decoder_0(torch.cat((x4, x3), dim=1))\n        x6 = self.decoder_1(torch.cat((x5, x2), dim=1))\n        x7 = self.decoder_2(torch.cat((x6, x1), dim=1))\n        x = torch.sigmoid(x7)\n        if refine_border:\n            x = x[..., anchor[0]:anchor[1], anchor[2]:anchor[3]]\n\n        return x\n\nclass Inpaint_Color_Net(nn.Module):\n    def __init__(self, layer_size=7, upsampling_mode='nearest', add_hole_mask=False, add_two_layer=False, add_border=False):\n        super().__init__()\n        self.freeze_enc_bn = False\n        self.upsampling_mode = upsampling_mode\n        self.layer_size = layer_size\n        in_channels = 6\n        self.enc_1 = PCBActiv(in_channels, 64, bn=False, sample='down-7')\n        self.enc_2 = PCBActiv(64, 128, sample='down-5')\n        self.enc_3 = PCBActiv(128, 256, sample='down-5')\n        self.enc_4 = PCBActiv(256, 512, sample='down-3')\n        self.enc_5 = PCBActiv(512, 512, sample='down-3')\n        self.enc_6 = PCBActiv(512, 512, sample='down-3')\n        self.enc_7 = PCBActiv(512, 512, sample='down-3')\n\n        self.dec_7 = PCBActiv(512+512, 512, activ='leaky')\n        self.dec_6 = PCBActiv(512+512, 512, activ='leaky')\n\n        self.dec_5A = PCBActiv(512 + 512, 512, activ='leaky')\n        self.dec_4A = PCBActiv(512 + 256, 256, activ='leaky')\n        self.dec_3A = PCBActiv(256 + 128, 128, activ='leaky')\n        self.dec_2A = PCBActiv(128 + 64, 64, activ='leaky')\n        self.dec_1A = PCBActiv(64 + in_channels, 3, bn=False, activ=None, conv_bias=True)\n        '''\n        self.dec_5B = PCBActiv(512 + 512, 512, activ='leaky')\n        self.dec_4B = PCBActiv(512 + 256, 256, activ='leaky')\n        self.dec_3B = PCBActiv(256 + 128, 128, activ='leaky')\n        self.dec_2B = PCBActiv(128 + 64, 64, activ='leaky')\n        self.dec_1B = PCBActiv(64 + 4, 1, bn=False, activ=None, conv_bias=True)\n        '''\n    def cat(self, A, B):\n        return torch.cat((A, B), dim=1)\n\n    def upsample(self, feat, mask):\n        feat = F.interpolate(feat, scale_factor=2, mode=self.upsampling_mode)\n        mask = F.interpolate(mask, scale_factor=2, mode='nearest')\n\n        return feat, mask\n\n    def forward_3P(self, mask, context, rgb, edge, unit_length=128, cuda=None):\n        with torch.no_grad():\n            input = torch.cat((rgb, edge, context, mask), dim=1)\n            n, c, h, w = input.shape\n            residual_h = int(np.ceil(h / float(unit_length)) * unit_length - h) # + 128\n            residual_w = int(np.ceil(w / float(unit_length)) * unit_length - w) # + 256\n            anchor_h = residual_h//2\n            anchor_w = residual_w//2\n            enlarge_input = torch.zeros((n, c, h + residual_h, w + residual_w)).to(cuda)\n            enlarge_input[..., anchor_h:anchor_h+h, anchor_w:anchor_w+w] = input\n            # enlarge_input[:, 3] = 1. - enlarge_input[:, 3]\n            enlarge_input = enlarge_input.to(cuda)\n            rgb_output = self.forward(enlarge_input)\n            rgb_output = rgb_output[..., anchor_h:anchor_h+h, anchor_w:anchor_w+w]\n\n        return rgb_output\n\n    def forward(self, input, add_border=False):\n        input_mask = (input[:, -2:-1] + input[:, -1:]).clamp(0, 1)\n        H, W = input.shape[-2:]\n        f_0, h_0 = input, input_mask.repeat((1,input.shape[1],1,1))\n        f_1, h_1 = self.enc_1(f_0, h_0)\n        f_2, h_2 = self.enc_2(f_1, h_1)\n        f_3, h_3 = self.enc_3(f_2, h_2)\n        f_4, h_4 = self.enc_4(f_3, h_3)\n        f_5, h_5 = self.enc_5(f_4, h_4)\n        f_6, h_6 = self.enc_6(f_5, h_5)\n        f_7, h_7 = self.enc_7(f_6, h_6)\n\n        o_7, k_7 = self.upsample(f_7, h_7)\n        o_6, k_6 = self.dec_7(self.cat(o_7, f_6), self.cat(k_7, h_6))\n        o_6, k_6 = self.upsample(o_6, k_6)\n        o_5, k_5 = self.dec_6(self.cat(o_6, f_5), self.cat(k_6, h_5))\n        o_5, k_5 = self.upsample(o_5, k_5)\n        o_5A, k_5A = o_5, k_5\n        o_5B, k_5B = o_5, k_5\n        ###############\n        o_4A, k_4A = self.dec_5A(self.cat(o_5A, f_4), self.cat(k_5A, h_4))\n        o_4A, k_4A = self.upsample(o_4A, k_4A)\n        o_3A, k_3A = self.dec_4A(self.cat(o_4A, f_3), self.cat(k_4A, h_3))\n        o_3A, k_3A = self.upsample(o_3A, k_3A)\n        o_2A, k_2A = self.dec_3A(self.cat(o_3A, f_2), self.cat(k_3A, h_2))\n        o_2A, k_2A = self.upsample(o_2A, k_2A)\n        o_1A, k_1A = self.dec_2A(self.cat(o_2A, f_1), self.cat(k_2A, h_1))\n        o_1A, k_1A = self.upsample(o_1A, k_1A)\n        o_0A, k_0A = self.dec_1A(self.cat(o_1A, f_0), self.cat(k_1A, h_0))\n\n        return torch.sigmoid(o_0A)\n\n    def train(self, mode=True):\n        \"\"\"\n        Override the default train() to freeze the BN parameters\n        \"\"\"\n        super().train(mode)\n        if self.freeze_enc_bn:\n            for name, module in self.named_modules():\n                if isinstance(module, nn.BatchNorm2d) and 'enc' in name:\n                    module.eval()\n\nclass Discriminator(BaseNetwork):\n    def __init__(self, use_sigmoid=True, use_spectral_norm=True, init_weights=True, in_channels=None):\n        super(Discriminator, self).__init__()\n        self.use_sigmoid = use_sigmoid\n        self.conv1 = self.features = nn.Sequential(\n            spectral_norm(nn.Conv2d(in_channels=in_channels, out_channels=64, kernel_size=4, stride=2, padding=1, bias=not use_spectral_norm), use_spectral_norm),\n            nn.LeakyReLU(0.2, inplace=True),\n        )\n\n        self.conv2 = nn.Sequential(\n            spectral_norm(nn.Conv2d(in_channels=64, out_channels=128, kernel_size=4, stride=2, padding=1, bias=not use_spectral_norm), use_spectral_norm),\n            nn.LeakyReLU(0.2, inplace=True),\n        )\n\n        self.conv3 = nn.Sequential(\n            spectral_norm(nn.Conv2d(in_channels=128, out_channels=256, kernel_size=4, stride=2, padding=1, bias=not use_spectral_norm), use_spectral_norm),\n            nn.LeakyReLU(0.2, inplace=True),\n        )\n\n        self.conv4 = nn.Sequential(\n            spectral_norm(nn.Conv2d(in_channels=256, out_channels=512, kernel_size=4, stride=1, padding=1, bias=not use_spectral_norm), use_spectral_norm),\n            nn.LeakyReLU(0.2, inplace=True),\n        )\n\n        self.conv5 = nn.Sequential(\n            spectral_norm(nn.Conv2d(in_channels=512, out_channels=1, kernel_size=4, stride=1, padding=1, bias=not use_spectral_norm), use_spectral_norm),\n        )\n\n        if init_weights:\n            self.init_weights()\n\n    def forward(self, x):\n        conv1 = self.conv1(x)\n        conv2 = self.conv2(conv1)\n        conv3 = self.conv3(conv2)\n        conv4 = self.conv4(conv3)\n        conv5 = self.conv5(conv4)\n\n        outputs = conv5\n        if self.use_sigmoid:\n            outputs = torch.sigmoid(conv5)\n\n        return outputs, [conv1, conv2, conv3, conv4, conv5]\n\nclass ResnetBlock(nn.Module):\n    def __init__(self, dim, dilation=1):\n        super(ResnetBlock, self).__init__()\n        self.conv_block = nn.Sequential(\n            nn.ReflectionPad2d(dilation),\n            spectral_norm(nn.Conv2d(in_channels=dim, out_channels=dim, kernel_size=3, padding=0, dilation=dilation, bias=not True), True),\n            nn.InstanceNorm2d(dim, track_running_stats=False),\n            nn.LeakyReLU(negative_slope=0.2),\n\n            nn.ReflectionPad2d(1),\n            spectral_norm(nn.Conv2d(in_channels=dim, out_channels=dim, kernel_size=3, padding=0, dilation=1, bias=not True), True),\n            nn.InstanceNorm2d(dim, track_running_stats=False),\n        )\n\n    def forward(self, x):\n        out = x + self.conv_block(x)\n\n        # Remove ReLU at the end of the residual block\n        # http://torch.ch/blog/2016/02/04/resnets.html\n\n        return out\n\n\ndef spectral_norm(module, mode=True):\n    if mode:\n        return nn.utils.spectral_norm(module)\n\n    return module\n"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.0546875,
          "content": "[tool.black]\nline-length = 120\ntarget-version = ['py37']"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.107421875,
          "content": "opencv-python==4.2.0.32\nvispy==0.6.4\nmoviepy==1.0.2\ntransforms3d==0.3.1\nnetworkx==2.3\ncynetworkx\nscikit-image\n"
        },
        {
          "name": "utils.py",
          "type": "blob",
          "size": 74.5029296875,
          "content": "import os\nimport glob\nimport cv2\nimport scipy.misc as misc\nfrom skimage.transform import resize\nimport numpy as np\nfrom functools import reduce\nfrom operator import mul\nimport torch\nfrom torch import nn\nimport matplotlib.pyplot as plt\nimport re\ntry:\n    import cynetworkx as netx\nexcept ImportError:\n    import networkx as netx\nfrom scipy.ndimage import gaussian_filter\nfrom skimage.feature import canny\nimport collections\nimport shutil\nimport imageio\nimport copy\nfrom matplotlib import pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nimport time\nfrom scipy.interpolate import interp1d\nfrom collections import namedtuple\n\ndef path_planning(num_frames, x, y, z, path_type=''):\n    if path_type == 'straight-line':\n        corner_points = np.array([[0, 0, 0], [(0 + x) * 0.5, (0 + y) * 0.5, (0 + z) * 0.5], [x, y, z]])\n        corner_t = np.linspace(0, 1, len(corner_points))\n        t = np.linspace(0, 1, num_frames)\n        cs = interp1d(corner_t, corner_points, axis=0, kind='quadratic')\n        spline = cs(t)\n        xs, ys, zs = [xx.squeeze() for xx in np.split(spline, 3, 1)]\n    elif path_type == 'double-straight-line':\n        corner_points = np.array([[-x, -y, -z], [0, 0, 0], [x, y, z]])\n        corner_t = np.linspace(0, 1, len(corner_points))\n        t = np.linspace(0, 1, num_frames)\n        cs = interp1d(corner_t, corner_points, axis=0, kind='quadratic')\n        spline = cs(t)\n        xs, ys, zs = [xx.squeeze() for xx in np.split(spline, 3, 1)]        \n    elif path_type == 'circle':\n        xs, ys, zs = [], [], []\n        for frame_id, bs_shift_val in enumerate(np.arange(-2.0, 2.0, (4./num_frames))):\n            xs += [np.cos(bs_shift_val * np.pi) * 1 * x]\n            ys += [np.sin(bs_shift_val * np.pi) * 1 * y]\n            zs += [np.cos(bs_shift_val * np.pi/2.) * 1 * z]\n        xs, ys, zs = np.array(xs), np.array(ys), np.array(zs)\n\n    return xs, ys, zs\n\ndef open_small_mask(mask, context, open_iteration, kernel):\n    np_mask = mask.cpu().data.numpy().squeeze().astype(np.uint8)\n    raw_mask = np_mask.copy()\n    np_context = context.cpu().data.numpy().squeeze().astype(np.uint8)\n    np_input = np_mask + np_context\n    for _ in range(open_iteration):\n        np_input = cv2.erode(cv2.dilate(np_input, np.ones((kernel, kernel)), iterations=1), np.ones((kernel,kernel)), iterations=1)\n    np_mask[(np_input - np_context) > 0] = 1\n    out_mask = torch.FloatTensor(np_mask).to(mask)[None, None, ...]\n    \n    return out_mask\n\ndef filter_irrelevant_edge_new(self_edge, comp_edge, other_edges, other_edges_with_id, current_edge_id, context, depth, mesh, context_cc, spdb=False):\n    other_edges = other_edges.squeeze().astype(np.uint8)\n    other_edges_with_id = other_edges_with_id.squeeze()\n    self_edge = self_edge.squeeze()\n    dilate_bevel_self_edge = cv2.dilate((self_edge + comp_edge).astype(np.uint8), np.array([[1,1,1],[1,1,1],[1,1,1]]), iterations=1)\n    dilate_cross_self_edge = cv2.dilate((self_edge + comp_edge).astype(np.uint8), np.array([[0,1,0],[1,1,1],[0,1,0]]).astype(np.uint8), iterations=1)\n    edge_ids = np.unique(other_edges_with_id * context + (-1) * (1 - context)).astype(np.int)\n    end_depth_maps = np.zeros_like(self_edge)\n    self_edge_ids = np.sort(np.unique(other_edges_with_id[self_edge > 0]).astype(np.int))\n    self_edge_ids = self_edge_ids[1:] if self_edge_ids.shape[0] > 0  and self_edge_ids[0] == -1 else self_edge_ids\n    self_comp_ids = np.sort(np.unique(other_edges_with_id[comp_edge > 0]).astype(np.int))\n    self_comp_ids = self_comp_ids[1:] if self_comp_ids.shape[0] > 0  and self_comp_ids[0] == -1 else self_comp_ids\n    edge_ids = edge_ids[1:] if edge_ids[0] == -1 else edge_ids\n    other_edges_info = []\n    extend_other_edges = np.zeros_like(other_edges)\n    if spdb is True:\n        f, ((ax1, ax2, ax3)) = plt.subplots(1, 3, sharex=True, sharey=True); ax1.imshow(self_edge); ax2.imshow(context); ax3.imshow(other_edges_with_id * context + (-1) * (1 - context)); plt.show()\n        import pdb; pdb.set_trace()\n    filter_self_edge = np.zeros_like(self_edge)\n    for self_edge_id in self_edge_ids:\n        filter_self_edge[other_edges_with_id == self_edge_id] = 1\n    dilate_self_comp_edge = cv2.dilate(comp_edge, kernel=np.ones((3, 3)), iterations=2)\n    valid_self_comp_edge = np.zeros_like(comp_edge)\n    for self_comp_id in self_comp_ids:\n        valid_self_comp_edge[self_comp_id == other_edges_with_id] = 1\n    self_comp_edge = dilate_self_comp_edge * valid_self_comp_edge\n    filter_self_edge = (filter_self_edge + self_comp_edge).clip(0, 1)\n    for edge_id in edge_ids:\n        other_edge_locs = (other_edges_with_id == edge_id).astype(np.uint8)\n        condition = (other_edge_locs * other_edges * context.astype(np.uint8))\n        end_cross_point = dilate_cross_self_edge * condition * (1 - filter_self_edge)\n        end_bevel_point = dilate_bevel_self_edge * condition * (1 - filter_self_edge)\n        if end_bevel_point.max() != 0:\n            end_depth_maps[end_bevel_point != 0] = depth[end_bevel_point != 0]\n            if end_cross_point.max() == 0:\n                nxs, nys = np.where(end_bevel_point != 0)\n                for nx, ny in zip(nxs, nys):\n                    bevel_node = [xx for xx in context_cc if xx[0] == nx and xx[1] == ny][0]\n                for ne in mesh.neighbors(bevel_node):\n                    if other_edges_with_id[ne[0], ne[1]] > -1 and dilate_cross_self_edge[ne[0], ne[1]] > 0:\n                        extend_other_edges[ne[0], ne[1]] = 1\n                        break\n        else:\n            other_edges[other_edges_with_id == edge_id] = 0\n    other_edges = (other_edges + extend_other_edges).clip(0, 1) * context\n\n    return other_edges, end_depth_maps, other_edges_info\n\ndef clean_far_edge_new(input_edge, end_depth_maps, mask, context, global_mesh, info_on_pix, self_edge, inpaint_id, config):\n    mesh = netx.Graph()\n    hxs, hys = np.where(input_edge * mask > 0)\n    valid_near_edge = (input_edge != 0).astype(np.uint8) * context\n    valid_map = mask + context\n    invalid_edge_ids = []\n    for hx, hy in zip(hxs, hys):\n        node = (hx ,hy)\n        mesh.add_node((hx, hy))\n        eight_nes = [ne for ne in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1), \\\n                                   (hx + 1, hy + 1), (hx - 1, hy - 1), (hx - 1, hy + 1), (hx + 1, hy - 1)]\\\n                        if 0 <= ne[0] < input_edge.shape[0] and 0 <= ne[1] < input_edge.shape[1] and 0 < input_edge[ne[0], ne[1]]] # or end_depth_maps[ne[0], ne[1]] != 0]\n        for ne in eight_nes:\n            mesh.add_edge(node, ne, length=np.hypot(ne[0] - hx, ne[1] - hy))\n            if end_depth_maps[ne[0], ne[1]] != 0:\n                mesh.nodes[ne[0], ne[1]]['cnt'] = True\n                if end_depth_maps[ne[0], ne[1]] == 0:\n                    import pdb; pdb.set_trace()\n                mesh.nodes[ne[0], ne[1]]['depth'] = end_depth_maps[ne[0], ne[1]]\n            elif mask[ne[0], ne[1]] != 1:\n                four_nes = [nne for nne in [(ne[0] + 1, ne[1]), (ne[0] - 1, ne[1]), (ne[0], ne[1] + 1), (ne[0], ne[1] - 1)]\\\n                                 if nne[0] < end_depth_maps.shape[0] and nne[0] >= 0 and nne[1] < end_depth_maps.shape[1] and nne[1] >= 0]\n                for nne in four_nes:\n                    if end_depth_maps[nne[0], nne[1]] != 0:\n                        mesh.add_edge(nne, ne, length=np.hypot(nne[0] - ne[0], nne[1] - ne[1]))\n                        mesh.nodes[nne[0], nne[1]]['cnt'] = True\n                        mesh.nodes[nne[0], nne[1]]['depth'] = end_depth_maps[nne[0], nne[1]]\n    ccs = [*netx.connected_components(mesh)]\n    end_pts = []\n    for cc in ccs:\n        end_pts.append(set())\n        for node in cc:\n            if mesh.nodes[node].get('cnt') is not None:\n                end_pts[-1].add((node[0], node[1], mesh.nodes[node]['depth']))    \n    predef_npaths = [None for _ in range(len(ccs))]\n    fpath_map = np.zeros_like(input_edge) - 1\n    npath_map = np.zeros_like(input_edge) - 1\n    npaths, fpaths = dict(), dict()\n    break_flag = False\n    end_idx = 0\n    while end_idx < len(end_pts):\n        end_pt, cc = [*zip(end_pts, ccs)][end_idx]\n        end_idx += 1\n        sorted_end_pt = []\n        fpath = []\n        iter_fpath = []\n        if len(end_pt) > 2 or len(end_pt) == 0:\n            if len(end_pt) > 2:\n                continue\n            continue\n        if len(end_pt) == 2:\n            ravel_end = [*end_pt]\n            tmp_sub_mesh = mesh.subgraph(list(cc)).copy()\n            tmp_npath = [*netx.shortest_path(tmp_sub_mesh, (ravel_end[0][0], ravel_end[0][1]), (ravel_end[1][0], ravel_end[1][1]), weight='length')]\n            fpath_map1, npath_map1, disp_diff1 = plan_path(mesh, info_on_pix, cc, ravel_end[0:1], global_mesh, input_edge, mask, valid_map, inpaint_id, npath_map=None, fpath_map=None, npath=tmp_npath)\n            fpath_map2, npath_map2, disp_diff2 = plan_path(mesh, info_on_pix, cc, ravel_end[1:2], global_mesh, input_edge, mask, valid_map, inpaint_id, npath_map=None, fpath_map=None, npath=tmp_npath)\n            tmp_disp_diff = [disp_diff1, disp_diff2]\n            self_end = []\n            edge_len = []\n            ds_edge = cv2.dilate(self_edge.astype(np.uint8), np.ones((3, 3)), iterations=1)\n            if ds_edge[ravel_end[0][0], ravel_end[0][1]] > 0:\n                self_end.append(1)\n            else:\n                self_end.append(0)\n            if ds_edge[ravel_end[1][0], ravel_end[1][1]] > 0:\n                self_end.append(1)\n            else:\n                self_end.append(0)\n            edge_len = [np.count_nonzero(npath_map1), np.count_nonzero(npath_map2)]\n            sorted_end_pts = [xx[0] for xx in sorted(zip(ravel_end, self_end, edge_len, [disp_diff1, disp_diff2]), key=lambda x: (x[1], x[2]), reverse=True)]\n            re_npath_map1, re_fpath_map1 = (npath_map1 != -1).astype(np.uint8), (fpath_map1 != -1).astype(np.uint8)\n            re_npath_map2, re_fpath_map2 = (npath_map2 != -1).astype(np.uint8), (fpath_map2 != -1).astype(np.uint8)\n            if np.count_nonzero(re_npath_map1 * re_npath_map2 * mask) / \\\n                (np.count_nonzero((re_npath_map1 + re_npath_map2) * mask) + 1e-6) > 0.5\\\n                and np.count_nonzero(re_fpath_map1 * re_fpath_map2 * mask) / \\\n                     (np.count_nonzero((re_fpath_map1 + re_fpath_map2) * mask) + 1e-6) > 0.5\\\n                and tmp_disp_diff[0] != -1 and tmp_disp_diff[1] != -1:\n                my_fpath_map, my_npath_map, npath, fpath = \\\n                    plan_path_e2e(mesh, cc, sorted_end_pts, global_mesh, input_edge, mask, valid_map, inpaint_id, npath_map=None, fpath_map=None)\n                npath_map[my_npath_map != -1] = my_npath_map[my_npath_map != -1]\n                fpath_map[my_fpath_map != -1] = my_fpath_map[my_fpath_map != -1]\n                if len(fpath) > 0:\n                    edge_id = global_mesh.nodes[[*sorted_end_pts][0]]['edge_id']\n                    fpaths[edge_id] = fpath\n                    npaths[edge_id] = npath\n                invalid_edge_ids.append(edge_id)\n            else:\n                if tmp_disp_diff[0] != -1:\n                    ratio_a = tmp_disp_diff[0] / (np.sum(tmp_disp_diff) + 1e-8)\n                else:\n                    ratio_a = 0\n                if tmp_disp_diff[1] != -1:\n                    ratio_b = tmp_disp_diff[1] / (np.sum(tmp_disp_diff) + 1e-8)\n                else:\n                    ratio_b = 0\n                npath_len = len(tmp_npath)\n                if npath_len > config['depth_edge_dilate_2'] * 2:\n                    npath_len = npath_len - (config['depth_edge_dilate_2'] * 1)\n                tmp_npath_a = tmp_npath[:int(np.floor(npath_len * ratio_a))]\n                tmp_npath_b = tmp_npath[::-1][:int(np.floor(npath_len * ratio_b))]\n                tmp_merge = []\n                if len(tmp_npath_a) > 0 and sorted_end_pts[0][0] == tmp_npath_a[0][0] and sorted_end_pts[0][1] == tmp_npath_a[0][1]:\n                    if len(tmp_npath_a) > 0 and mask[tmp_npath_a[-1][0], tmp_npath_a[-1][1]] > 0:\n                        tmp_merge.append([sorted_end_pts[:1], tmp_npath_a])\n                    if len(tmp_npath_b) > 0 and mask[tmp_npath_b[-1][0], tmp_npath_b[-1][1]] > 0:\n                        tmp_merge.append([sorted_end_pts[1:2], tmp_npath_b])\n                elif len(tmp_npath_b) > 0 and sorted_end_pts[0][0] == tmp_npath_b[0][0] and sorted_end_pts[0][1] == tmp_npath_b[0][1]:\n                    if len(tmp_npath_b) > 0 and mask[tmp_npath_b[-1][0], tmp_npath_b[-1][1]] > 0:\n                        tmp_merge.append([sorted_end_pts[:1], tmp_npath_b])\n                    if len(tmp_npath_a) > 0 and mask[tmp_npath_a[-1][0], tmp_npath_a[-1][1]] > 0:\n                        tmp_merge.append([sorted_end_pts[1:2], tmp_npath_a])\n                for tmp_idx in range(len(tmp_merge)):\n                    if len(tmp_merge[tmp_idx][1]) == 0:\n                        continue\n                    end_pts.append(tmp_merge[tmp_idx][0])\n                    ccs.append(set(tmp_merge[tmp_idx][1]))\n        if len(end_pt) == 1:\n            sub_mesh = mesh.subgraph(list(cc)).copy()\n            pnodes = netx.periphery(sub_mesh)\n            if len(end_pt) == 1:\n                ends = [*end_pt]\n            elif len(sorted_end_pt) == 1:\n                ends = [*sorted_end_pt]\n            else:\n                import pdb; pdb.set_trace()\n            try:\n                edge_id = global_mesh.nodes[ends[0]]['edge_id']\n            except:\n                import pdb; pdb.set_trace()\n            pnodes = sorted(pnodes, \n                            key=lambda x: np.hypot((x[0] - ends[0][0]), (x[1] - ends[0][1])),\n                            reverse=True)[0]\n            npath = [*netx.shortest_path(sub_mesh, (ends[0][0], ends[0][1]), pnodes, weight='length')]\n            for np_node in npath:\n                npath_map[np_node[0], np_node[1]] = edge_id\n            fpath = []\n            if global_mesh.nodes[ends[0]].get('far') is None:\n                print(\"None far\")\n            else:\n                fnodes = global_mesh.nodes[ends[0]].get('far')\n                dmask = mask + 0\n                did = 0\n                while True:\n                    did += 1\n                    dmask = cv2.dilate(dmask, np.ones((3, 3)), iterations=1)\n                    if did > 3:\n                        break\n                    ffnode = [fnode for fnode in fnodes if (dmask[fnode[0], fnode[1]] > 0 and mask[fnode[0], fnode[1]] == 0 and\\\n                                                            global_mesh.nodes[fnode].get('inpaint_id') != inpaint_id + 1)]\n                    if len(ffnode) > 0:\n                        fnode = ffnode[0]\n                        break\n                if len(ffnode) == 0:\n                    continue\n                fpath.append((fnode[0], fnode[1]))\n                barrel_dir = np.array([[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]])\n                n2f_dir = (int(fnode[0] - npath[0][0]), int(fnode[1] - npath[0][1]))\n                while True:\n                    if barrel_dir[0, 0] == n2f_dir[0] and barrel_dir[0, 1] == n2f_dir[1]:\n                        n2f_barrel = barrel_dir.copy()\n                        break\n                    barrel_dir = np.roll(barrel_dir, 1, axis=0)\n                for step in range(0, len(npath)):\n                    if step == 0:\n                        continue\n                    elif step == 1:\n                        next_dir = (npath[step][0] - npath[step - 1][0], npath[step][1] - npath[step - 1][1])\n                        while True:\n                            if barrel_dir[0, 0] == next_dir[0] and barrel_dir[0, 1] == next_dir[1]:\n                                next_barrel = barrel_dir.copy()\n                                break\n                            barrel_dir = np.roll(barrel_dir, 1, axis=0)\n                        barrel_pair = np.stack((n2f_barrel, next_barrel), axis=0)\n                        n2f_dir = (barrel_pair[0, 0, 0], barrel_pair[0, 0, 1])\n                    elif step > 1:\n                        next_dir = (npath[step][0] - npath[step - 1][0], npath[step][1] - npath[step - 1][1])\n                        while True:\n                            if barrel_pair[1, 0, 0] == next_dir[0] and barrel_pair[1, 0, 1] == next_dir[1]:\n                                next_barrel = barrel_pair.copy()\n                                break\n                            barrel_pair = np.roll(barrel_pair, 1, axis=1)\n                        n2f_dir = (barrel_pair[0, 0, 0], barrel_pair[0, 0, 1])\n                    new_locs = []\n                    if abs(n2f_dir[0]) == 1:\n                        new_locs.append((npath[step][0] + n2f_dir[0], npath[step][1]))\n                    if abs(n2f_dir[1]) == 1:\n                        new_locs.append((npath[step][0], npath[step][1] + n2f_dir[1]))\n                    if len(new_locs) > 1:\n                        new_locs = sorted(new_locs, key=lambda xx: np.hypot((xx[0] - fpath[-1][0]), (xx[1] - fpath[-1][1])))\n                    break_flag = False\n                    for new_loc in new_locs:\n                        new_loc_nes = [xx for xx in [(new_loc[0] + 1, new_loc[1]), (new_loc[0] - 1, new_loc[1]), \n                                                    (new_loc[0], new_loc[1] + 1), (new_loc[0], new_loc[1] - 1)]\\\n                                            if xx[0] >= 0 and xx[0] < fpath_map.shape[0] and xx[1] >= 0 and xx[1] < fpath_map.shape[1]]\n                        if np.all([(fpath_map[nlne[0], nlne[1]] == -1) for nlne in new_loc_nes]) != True:\n                            break\n                        if npath_map[new_loc[0], new_loc[1]] != -1:\n                            if npath_map[new_loc[0], new_loc[1]] != edge_id:\n                                break_flag = True\n                                break\n                            else:\n                                continue\n                        if valid_map[new_loc[0], new_loc[1]] == 0:\n                            break_flag = True\n                            break\n                        fpath.append(new_loc)\n                    if break_flag is True:\n                        break\n                if step != len(npath) - 1:\n                    for xx in npath[step:]:\n                        if npath_map[xx[0], xx[1]] == edge_id:\n                            npath_map[xx[0], xx[1]] = -1\n                    npath = npath[:step]\n            if len(fpath) > 0:\n                for fp_node in fpath:\n                    fpath_map[fp_node[0], fp_node[1]] = edge_id\n                fpaths[edge_id] = fpath\n                npaths[edge_id] = npath\n        fpath_map[valid_near_edge != 0] = -1\n        if len(fpath) > 0:\n            iter_fpath = copy.deepcopy(fpaths[edge_id])\n        for node in iter_fpath:\n            if valid_near_edge[node[0], node[1]] != 0:\n                fpaths[edge_id].remove(node)\n\n    return fpath_map, npath_map, False, npaths, fpaths, invalid_edge_ids\n\ndef plan_path_e2e(mesh, cc, end_pts, global_mesh, input_edge, mask, valid_map, inpaint_id, npath_map=None, fpath_map=None):\n    my_npath_map = np.zeros_like(input_edge) - 1\n    my_fpath_map = np.zeros_like(input_edge) - 1\n    sub_mesh = mesh.subgraph(list(cc)).copy()\n    ends_1, ends_2 = end_pts[0], end_pts[1]\n    edge_id = global_mesh.nodes[ends_1]['edge_id']\n    npath = [*netx.shortest_path(sub_mesh, (ends_1[0], ends_1[1]), (ends_2[0], ends_2[1]), weight='length')]\n    for np_node in npath:\n        my_npath_map[np_node[0], np_node[1]] = edge_id\n    fpath = []\n    if global_mesh.nodes[ends_1].get('far') is None:\n        print(\"None far\")\n    else:\n        fnodes = global_mesh.nodes[ends_1].get('far')\n        dmask = mask + 0\n        while True:\n            dmask = cv2.dilate(dmask, np.ones((3, 3)), iterations=1)\n            ffnode = [fnode for fnode in fnodes if (dmask[fnode[0], fnode[1]] > 0 and mask[fnode[0], fnode[1]] == 0 and\\\n                                                            global_mesh.nodes[fnode].get('inpaint_id') != inpaint_id + 1)]\n            if len(ffnode) > 0:\n                fnode = ffnode[0]\n                break\n        e_fnodes = global_mesh.nodes[ends_2].get('far')\n        dmask = mask + 0\n        while True:\n            dmask = cv2.dilate(dmask, np.ones((3, 3)), iterations=1)\n            e_ffnode = [e_fnode for e_fnode in e_fnodes if (dmask[e_fnode[0], e_fnode[1]] > 0 and mask[e_fnode[0], e_fnode[1]] == 0 and\\\n                                                            global_mesh.nodes[e_fnode].get('inpaint_id') != inpaint_id + 1)]\n            if len(e_ffnode) > 0:\n                e_fnode = e_ffnode[0]\n                break            \n        fpath.append((fnode[0], fnode[1]))\n        if len(e_ffnode) == 0 or len(ffnode) == 0:\n            return my_npath_map, my_fpath_map, [], []\n        barrel_dir = np.array([[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]])\n        n2f_dir = (int(fnode[0] - npath[0][0]), int(fnode[1] - npath[0][1]))\n        while True:\n            if barrel_dir[0, 0] == n2f_dir[0] and barrel_dir[0, 1] == n2f_dir[1]:\n                n2f_barrel = barrel_dir.copy()\n                break\n            barrel_dir = np.roll(barrel_dir, 1, axis=0)\n        for step in range(0, len(npath)):\n            if step == 0:\n                continue\n            elif step == 1:\n                next_dir = (npath[step][0] - npath[step - 1][0], npath[step][1] - npath[step - 1][1])\n                while True:\n                    if barrel_dir[0, 0] == next_dir[0] and barrel_dir[0, 1] == next_dir[1]:\n                        next_barrel = barrel_dir.copy()\n                        break\n                    barrel_dir = np.roll(barrel_dir, 1, axis=0)\n                barrel_pair = np.stack((n2f_barrel, next_barrel), axis=0)\n                n2f_dir = (barrel_pair[0, 0, 0], barrel_pair[0, 0, 1])\n            elif step > 1:\n                next_dir = (npath[step][0] - npath[step - 1][0], npath[step][1] - npath[step - 1][1])\n                while True:\n                    if barrel_pair[1, 0, 0] == next_dir[0] and barrel_pair[1, 0, 1] == next_dir[1]:\n                        next_barrel = barrel_pair.copy()\n                        break\n                    barrel_pair = np.roll(barrel_pair, 1, axis=1)\n                n2f_dir = (barrel_pair[0, 0, 0], barrel_pair[0, 0, 1])\n            new_locs = []\n            if abs(n2f_dir[0]) == 1:\n                new_locs.append((npath[step][0] + n2f_dir[0], npath[step][1]))\n            if abs(n2f_dir[1]) == 1:\n                new_locs.append((npath[step][0], npath[step][1] + n2f_dir[1]))\n            if len(new_locs) > 1:\n                new_locs = sorted(new_locs, key=lambda xx: np.hypot((xx[0] - fpath[-1][0]), (xx[1] - fpath[-1][1])))\n            break_flag = False\n            for new_loc in new_locs:\n                new_loc_nes = [xx for xx in [(new_loc[0] + 1, new_loc[1]), (new_loc[0] - 1, new_loc[1]),\n                                            (new_loc[0], new_loc[1] + 1), (new_loc[0], new_loc[1] - 1)]\\\n                                    if xx[0] >= 0 and xx[0] < my_fpath_map.shape[0] and xx[1] >= 0 and xx[1] < my_fpath_map.shape[1]]\n                if fpath_map is not None and np.sum([fpath_map[nlne[0], nlne[1]] for nlne in new_loc_nes]) != 0:\n                    break_flag = True\n                    break\n                if my_npath_map[new_loc[0], new_loc[1]] != -1:\n                    continue\n                if npath_map is not None and npath_map[new_loc[0], new_loc[1]] != edge_id:\n                    break_flag = True\n                    break\n                fpath.append(new_loc)\n            if break_flag is True:\n                break\n        if (e_fnode[0], e_fnode[1]) not in fpath:\n            fpath.append((e_fnode[0], e_fnode[1]))\n        if step != len(npath) - 1:\n            for xx in npath[step:]:\n                if my_npath_map[xx[0], xx[1]] == edge_id:\n                    my_npath_map[xx[0], xx[1]] = -1\n            npath = npath[:step]\n        if len(fpath) > 0:\n            for fp_node in fpath:\n                my_fpath_map[fp_node[0], fp_node[1]] = edge_id\n    \n    return my_fpath_map, my_npath_map, npath, fpath\n\ndef plan_path(mesh, info_on_pix, cc, end_pt, global_mesh, input_edge, mask, valid_map, inpaint_id, npath_map=None, fpath_map=None, npath=None):\n    my_npath_map = np.zeros_like(input_edge) - 1\n    my_fpath_map = np.zeros_like(input_edge) - 1\n    sub_mesh = mesh.subgraph(list(cc)).copy()\n    pnodes = netx.periphery(sub_mesh)\n    ends = [*end_pt]\n    edge_id = global_mesh.nodes[ends[0]]['edge_id']\n    pnodes = sorted(pnodes, \n                    key=lambda x: np.hypot((x[0] - ends[0][0]), (x[1] - ends[0][1])),\n                    reverse=True)[0]\n    if npath is None:\n        npath = [*netx.shortest_path(sub_mesh, (ends[0][0], ends[0][1]), pnodes, weight='length')]\n    else:\n        if (ends[0][0], ends[0][1]) == npath[0]:\n            npath = npath\n        elif (ends[0][0], ends[0][1]) == npath[-1]:\n            npath = npath[::-1]\n        else:\n            import pdb; pdb.set_trace()\n    for np_node in npath:\n        my_npath_map[np_node[0], np_node[1]] = edge_id\n    fpath = []\n    if global_mesh.nodes[ends[0]].get('far') is None:\n        print(\"None far\")\n    else:\n        fnodes = global_mesh.nodes[ends[0]].get('far')\n        dmask = mask + 0\n        did = 0\n        while True:\n            did += 1\n            if did > 3:\n                return my_fpath_map, my_npath_map, -1\n            dmask = cv2.dilate(dmask, np.ones((3, 3)), iterations=1)\n            ffnode = [fnode for fnode in fnodes if (dmask[fnode[0], fnode[1]] > 0 and mask[fnode[0], fnode[1]] == 0 and\\\n                                                            global_mesh.nodes[fnode].get('inpaint_id') != inpaint_id + 1)]\n            if len(ffnode) > 0:\n                fnode = ffnode[0]\n                break\n        \n        fpath.append((fnode[0], fnode[1]))\n        disp_diff = 0.\n        for n_loc in npath:\n            if mask[n_loc[0], n_loc[1]] != 0:\n                disp_diff = abs(abs(1. / info_on_pix[(n_loc[0], n_loc[1])][0]['depth']) - abs(1. / ends[0][2]))\n                break\n        barrel_dir = np.array([[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]])\n        n2f_dir = (int(fnode[0] - npath[0][0]), int(fnode[1] - npath[0][1]))\n        while True:\n            if barrel_dir[0, 0] == n2f_dir[0] and barrel_dir[0, 1] == n2f_dir[1]:\n                n2f_barrel = barrel_dir.copy()\n                break\n            barrel_dir = np.roll(barrel_dir, 1, axis=0)\n        for step in range(0, len(npath)):\n            if step == 0:\n                continue\n            elif step == 1:\n                next_dir = (npath[step][0] - npath[step - 1][0], npath[step][1] - npath[step - 1][1])\n                while True:\n                    if barrel_dir[0, 0] == next_dir[0] and barrel_dir[0, 1] == next_dir[1]:\n                        next_barrel = barrel_dir.copy()\n                        break\n                    barrel_dir = np.roll(barrel_dir, 1, axis=0)\n                barrel_pair = np.stack((n2f_barrel, next_barrel), axis=0)\n                n2f_dir = (barrel_pair[0, 0, 0], barrel_pair[0, 0, 1])\n            elif step > 1:\n                next_dir = (npath[step][0] - npath[step - 1][0], npath[step][1] - npath[step - 1][1])\n                while True:\n                    if barrel_pair[1, 0, 0] == next_dir[0] and barrel_pair[1, 0, 1] == next_dir[1]:\n                        next_barrel = barrel_pair.copy()\n                        break\n                    barrel_pair = np.roll(barrel_pair, 1, axis=1)\n                n2f_dir = (barrel_pair[0, 0, 0], barrel_pair[0, 0, 1])\n            new_locs = []\n            if abs(n2f_dir[0]) == 1:\n                new_locs.append((npath[step][0] + n2f_dir[0], npath[step][1]))\n            if abs(n2f_dir[1]) == 1:\n                new_locs.append((npath[step][0], npath[step][1] + n2f_dir[1]))\n            if len(new_locs) > 1:\n                new_locs = sorted(new_locs, key=lambda xx: np.hypot((xx[0] - fpath[-1][0]), (xx[1] - fpath[-1][1])))\n            break_flag = False\n            for new_loc in new_locs:\n                new_loc_nes = [xx for xx in [(new_loc[0] + 1, new_loc[1]), (new_loc[0] - 1, new_loc[1]),\n                                        (new_loc[0], new_loc[1] + 1), (new_loc[0], new_loc[1] - 1)]\\\n                                if xx[0] >= 0 and xx[0] < my_fpath_map.shape[0] and xx[1] >= 0 and xx[1] < my_fpath_map.shape[1]]\n                if fpath_map is not None and np.all([(fpath_map[nlne[0], nlne[1]] == -1) for nlne in new_loc_nes]) != True:\n                    break_flag = True\n                    break\n                if np.all([(my_fpath_map[nlne[0], nlne[1]] == -1) for nlne in new_loc_nes]) != True:\n                    break_flag = True\n                    break \n                if my_npath_map[new_loc[0], new_loc[1]] != -1:\n                    continue\n                if npath_map is not None and npath_map[new_loc[0], new_loc[1]] != edge_id:\n                    break_flag = True\n                    break\n                if valid_map[new_loc[0], new_loc[1]] == 0:\n                    break_flag = True\n                    break\n                fpath.append(new_loc)\n            if break_flag is True:\n                break\n        if step != len(npath) - 1:\n            for xx in npath[step:]:\n                if my_npath_map[xx[0], xx[1]] == edge_id:\n                    my_npath_map[xx[0], xx[1]] = -1\n            npath = npath[:step]\n        if len(fpath) > 0:\n            for fp_node in fpath:\n                my_fpath_map[fp_node[0], fp_node[1]] = edge_id\n\n    return my_fpath_map, my_npath_map, disp_diff\n\ndef refresh_node(old_node, old_feat, new_node, new_feat, mesh, stime=False):\n    mesh.add_node(new_node)\n    mesh.nodes[new_node].update(new_feat)\n    mesh.nodes[new_node].update(old_feat)\n    for ne in mesh.neighbors(old_node):\n        mesh.add_edge(new_node, ne)\n    if mesh.nodes[new_node].get('far') is not None:\n        tmp_far_nodes = mesh.nodes[new_node]['far']\n        for far_node in tmp_far_nodes:\n            if mesh.has_node(far_node) is False:\n                mesh.nodes[new_node]['far'].remove(far_node)\n                continue\n            if mesh.nodes[far_node].get('near') is not None:\n                for idx in range(len(mesh.nodes[far_node].get('near'))):\n                    if mesh.nodes[far_node]['near'][idx][0] == new_node[0] and mesh.nodes[far_node]['near'][idx][1] == new_node[1]:\n                        if len(mesh.nodes[far_node]['near'][idx]) == len(old_node):\n                            mesh.nodes[far_node]['near'][idx] = new_node\n    if mesh.nodes[new_node].get('near') is not None:\n        tmp_near_nodes = mesh.nodes[new_node]['near']\n        for near_node in tmp_near_nodes:\n            if mesh.has_node(near_node) is False:\n                mesh.nodes[new_node]['near'].remove(near_node)\n                continue        \n            if mesh.nodes[near_node].get('far') is not None:\n                for idx in range(len(mesh.nodes[near_node].get('far'))):\n                    if mesh.nodes[near_node]['far'][idx][0] == new_node[0] and mesh.nodes[near_node]['far'][idx][1] == new_node[1]:\n                        if len(mesh.nodes[near_node]['far'][idx]) == len(old_node):\n                            mesh.nodes[near_node]['far'][idx] = new_node\n    if new_node != old_node:\n        mesh.remove_node(old_node)\n    if stime is False:\n        return mesh\n    else:\n        return mesh, None, None\n\n\ndef create_placeholder(context, mask, depth, fpath_map, npath_map, mesh, inpaint_id, edge_ccs, extend_edge_cc, all_edge_maps, self_edge_id):\n    add_node_time = 0\n    add_edge_time = 0\n    add_far_near_time = 0\n    valid_area = context + mask\n    H, W = mesh.graph['H'], mesh.graph['W']\n    edge_cc = edge_ccs[self_edge_id]\n    num_com = len(edge_cc) + len(extend_edge_cc)\n    hxs, hys = np.where(mask > 0)\n    for hx, hy in zip(hxs, hys):\n        mesh.add_node((hx, hy), inpaint_id=inpaint_id + 1, num_context=num_com)\n    for hx, hy in zip(hxs, hys):\n        four_nes = [(x, y) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1)] if\\\n                        0 <= x < mesh.graph['H'] and 0 <= y < mesh.graph['W'] and valid_area[x, y] != 0]\n        for ne in four_nes:\n            if mask[ne[0], ne[1]] != 0:\n                if not mesh.has_edge((hx, hy), ne):\n                    mesh.add_edge((hx, hy), ne)\n            elif depth[ne[0], ne[1]] != 0:\n                if mesh.has_node((ne[0], ne[1], depth[ne[0], ne[1]])) and\\\n                    not mesh.has_edge((hx, hy), (ne[0], ne[1], depth[ne[0], ne[1]])):\n                    mesh.add_edge((hx, hy), (ne[0], ne[1], depth[ne[0], ne[1]]))\n                else:\n                    print(\"Undefined context node.\")\n                    import pdb; pdb.set_trace()\n    near_ids = np.unique(npath_map)\n    if near_ids[0] == -1: near_ids = near_ids[1:]\n    for near_id in near_ids:\n        hxs, hys = np.where((fpath_map == near_id) & (mask > 0))\n        if hxs.shape[0] > 0:\n            mesh.graph['max_edge_id'] = mesh.graph['max_edge_id'] + 1\n        else:\n            break\n        for hx, hy in zip(hxs, hys):\n            mesh.nodes[(hx, hy)]['edge_id'] = int(round(mesh.graph['max_edge_id']))\n            four_nes = [(x, y) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1)] if\\\n                        x < mesh.graph['H'] and x >= 0 and y < mesh.graph['W'] and y >= 0 and npath_map[x, y] == near_id]\n            for xx in four_nes:\n                xx_n = copy.deepcopy(xx)\n                if not mesh.has_node(xx_n):\n                    if mesh.has_node((xx_n[0], xx_n[1], depth[xx_n[0], xx_n[1]])):\n                        xx_n = (xx_n[0], xx_n[1], depth[xx_n[0], xx_n[1]])\n                if mesh.has_edge((hx, hy), xx_n):\n                    # pass\n                    mesh.remove_edge((hx, hy), xx_n)\n                if mesh.nodes[(hx, hy)].get('near') is None:\n                    mesh.nodes[(hx, hy)]['near'] = []\n                mesh.nodes[(hx, hy)]['near'].append(xx_n)\n        connect_point_exception = set()\n        hxs, hys = np.where((npath_map == near_id) & (all_edge_maps > -1))\n        for hx, hy in zip(hxs, hys):\n            unknown_id = int(round(all_edge_maps[hx, hy]))\n            if unknown_id != near_id and unknown_id != self_edge_id:\n                unknown_node = set([xx for xx in edge_ccs[unknown_id] if xx[0] == hx and xx[1] == hy])\n                connect_point_exception |= unknown_node\n        hxs, hys = np.where((npath_map == near_id) & (mask > 0))                \n        if hxs.shape[0] > 0:\n            mesh.graph['max_edge_id'] = mesh.graph['max_edge_id'] + 1\n        else:\n            break\n        for hx, hy in zip(hxs, hys):\n            mesh.nodes[(hx, hy)]['edge_id'] = int(round(mesh.graph['max_edge_id']))\n            mesh.nodes[(hx, hy)]['connect_point_id'] = int(round(near_id)) \n            mesh.nodes[(hx, hy)]['connect_point_exception'] = connect_point_exception\n            four_nes = [(x, y) for x, y in [(hx + 1, hy), (hx - 1, hy), (hx, hy + 1), (hx, hy - 1)] if\\\n                        x < mesh.graph['H'] and x >= 0 and y < mesh.graph['W'] and y >= 0 and fpath_map[x, y] == near_id]\n            for xx in four_nes:\n                xx_n = copy.deepcopy(xx)\n                if not mesh.has_node(xx_n):\n                    if mesh.has_node((xx_n[0], xx_n[1], depth[xx_n[0], xx_n[1]])):\n                        xx_n = (xx_n[0], xx_n[1], depth[xx_n[0], xx_n[1]])\n                if mesh.has_edge((hx, hy), xx_n):\n                    mesh.remove_edge((hx, hy), xx_n)\n                if mesh.nodes[(hx, hy)].get('far') is None:\n                    mesh.nodes[(hx, hy)]['far'] = []\n                mesh.nodes[(hx, hy)]['far'].append(xx_n)\n\n    return mesh, add_node_time, add_edge_time, add_far_near_time\n\ndef clean_far_edge(mask_edge, mask_edge_with_id, context_edge, mask, info_on_pix, global_mesh, anchor):\n    if isinstance(mask_edge, torch.Tensor):\n        if mask_edge.is_cuda:\n            mask_edge = mask_edge.cpu()\n        mask_edge = mask_edge.data\n        mask_edge = mask_edge.numpy()\n    if isinstance(context_edge, torch.Tensor):\n        if context_edge.is_cuda:\n            context_edge = context_edge.cpu()\n        context_edge = context_edge.data\n        context_edge = context_edge.numpy()\n    if isinstance(mask, torch.Tensor):\n        if mask.is_cuda:\n            mask = mask.cpu()\n        mask = mask.data\n        mask = mask.numpy()\n    mask = mask.squeeze()\n    mask_edge = mask_edge.squeeze()\n    context_edge = context_edge.squeeze()\n    valid_near_edge = np.zeros_like(mask_edge)\n    far_edge = np.zeros_like(mask_edge)\n    far_edge_with_id = np.ones_like(mask_edge) * -1\n    near_edge_with_id = np.ones_like(mask_edge) * -1\n    uncleaned_far_edge = np.zeros_like(mask_edge)\n    # Detect if there is any valid pixel mask_edge, if not ==> return default value\n    if mask_edge.sum() == 0:\n        return far_edge, uncleaned_far_edge, far_edge_with_id, near_edge_with_id\n    mask_edge_ids = dict(collections.Counter(mask_edge_with_id.flatten())).keys()\n    for edge_id in mask_edge_ids:\n        if edge_id < 0:\n            continue\n        specific_edge_map = (mask_edge_with_id == edge_id).astype(np.uint8)\n        _, sub_specific_edge_maps = cv2.connectedComponents(specific_edge_map.astype(np.uint8), connectivity=8)\n        for sub_edge_id in range(1, sub_specific_edge_maps.max() + 1):\n            specific_edge_map = (sub_specific_edge_maps == sub_edge_id).astype(np.uint8)\n            edge_pxs, edge_pys = np.where(specific_edge_map > 0)\n            edge_mesh = netx.Graph()\n            for edge_px, edge_py in zip(edge_pxs, edge_pys):\n                edge_mesh.add_node((edge_px, edge_py))\n                for ex in [edge_px-1, edge_px, edge_px+1]:\n                    for ey in [edge_py-1, edge_py, edge_py+1]:\n                        if edge_px == ex and edge_py == ey:\n                            continue\n                        if ex < 0 or ex >= specific_edge_map.shape[0] or ey < 0 or ey >= specific_edge_map.shape[1]:\n                            continue\n                        if specific_edge_map[ex, ey] == 1:\n                            if edge_mesh.has_node((ex, ey)):\n                                edge_mesh.add_edge((ex, ey), (edge_px, edge_py))\n            periphery_nodes = netx.periphery(edge_mesh)\n            path_diameter = netx.diameter(edge_mesh)\n            start_near_node = None\n            for node_s in periphery_nodes:\n                for node_e in periphery_nodes:\n                    if node_s != node_e:\n                        if netx.shortest_path_length(edge_mesh, node_s, node_e) == path_diameter:\n                            if np.any(context_edge[node_s[0]-1:node_s[0]+2, node_s[1]-1:node_s[1]+2].flatten()):\n                                start_near_node = (node_s[0], node_s[1])\n                                end_near_node = (node_e[0], node_e[1])\n                                break\n                            if np.any(context_edge[node_e[0]-1:node_e[0]+2, node_e[1]-1:node_e[1]+2].flatten()):\n                                start_near_node = (node_e[0], node_e[1])\n                                end_near_node = (node_s[0], node_s[1])\n                                break\n                if start_near_node is not None:\n                    break\n            if start_near_node is None:\n                continue\n            new_specific_edge_map = np.zeros_like(mask)\n            for path_node in netx.shortest_path(edge_mesh, start_near_node, end_near_node):\n                new_specific_edge_map[path_node[0], path_node[1]] = 1\n            context_near_pxs, context_near_pys = np.where(context_edge[start_near_node[0]-1:start_near_node[0]+2, start_near_node[1]-1:start_near_node[1]+2] > 0)\n            distance = np.abs((context_near_pxs - 1)) + np.abs((context_near_pys - 1))\n            if (np.where(distance == distance.min())[0].shape[0]) > 1:\n                closest_pxs = context_near_pxs[np.where(distance == distance.min())[0]]\n                closest_pys = context_near_pys[np.where(distance == distance.min())[0]]\n                closest_depths = []\n                for closest_px, closest_py in zip(closest_pxs, closest_pys):\n                    if info_on_pix.get((closest_px + start_near_node[0] - 1 + anchor[0], closest_py + start_near_node[1] - 1 + anchor[2])) is not None:\n                        for info in info_on_pix.get((closest_px + start_near_node[0] - 1 + anchor[0], closest_py + start_near_node[1] - 1 + anchor[2])):\n                            if info['synthesis'] is False:\n                                closest_depths.append(abs(info['depth']))\n                context_near_px, context_near_py = closest_pxs[np.array(closest_depths).argmax()], closest_pys[np.array(closest_depths).argmax()]\n            else:\n                context_near_px, context_near_py = context_near_pxs[distance.argmin()], context_near_pys[distance.argmin()]\n            context_near_node = (start_near_node[0]-1 + context_near_px, start_near_node[1]-1 + context_near_py)\n            far_node_list = []\n            global_context_near_node = (context_near_node[0] + anchor[0], context_near_node[1] + anchor[2])\n            if info_on_pix.get(global_context_near_node) is not None:\n                for info in info_on_pix[global_context_near_node]:\n                    if info['synthesis'] is False:\n                        context_near_node_3d = (global_context_near_node[0], global_context_near_node[1], info['depth'])\n                        if global_mesh.nodes[context_near_node_3d].get('far') is not None:\n                            for far_node in global_mesh.nodes[context_near_node_3d].get('far'):\n                                far_node = (far_node[0] - anchor[0], far_node[1] - anchor[2], far_node[2])\n                                if mask[far_node[0], far_node[1]] == 0:\n                                    far_node_list.append([far_node[0], far_node[1]])\n            if len(far_node_list) > 0:\n                far_nodes_dist = np.sum(np.abs(np.array(far_node_list) - np.array([[edge_px, edge_py]])), axis=1)\n                context_far_node = tuple(far_node_list[far_nodes_dist.argmin()])\n                corresponding_far_edge = np.zeros_like(mask_edge)\n                corresponding_far_edge[context_far_node[0], context_far_node[1]] = 1\n                surround_map = cv2.dilate(new_specific_edge_map.astype(np.uint8), \n                                            np.array([[1,1,1],[1,1,1],[1,1,1]]).astype(np.uint8), \n                                            iterations=1)\n                specific_edge_map_wo_end_pt = new_specific_edge_map.copy()\n                specific_edge_map_wo_end_pt[end_near_node[0], end_near_node[1]] = 0\n                surround_map_wo_end_pt = cv2.dilate(specific_edge_map_wo_end_pt.astype(np.uint8), \n                                                    np.array([[1,1,1],[1,1,1],[1,1,1]]).astype(np.uint8), \n                                                    iterations=1)\n                surround_map_wo_end_pt[new_specific_edge_map > 0] = 0\n                surround_map_wo_end_pt[context_near_node[0], context_near_node[1]] = 0\n                surround_map = surround_map_wo_end_pt.copy()\n                _, far_edge_cc = cv2.connectedComponents(surround_map.astype(np.uint8), connectivity=4)\n                start_far_node = None\n                accompany_far_node = None\n                if surround_map[context_far_node[0], context_far_node[1]] == 1:\n                    start_far_node = context_far_node\n                else:\n                    four_nes = [(context_far_node[0] - 1, context_far_node[1]), \n                            (context_far_node[0] + 1, context_far_node[1]), \n                            (context_far_node[0], context_far_node[1] - 1), \n                            (context_far_node[0], context_far_node[1] + 1)]\n                    candidate_bevel = []            \n                    for ne in four_nes:\n                        if surround_map[ne[0], ne[1]] == 1:\n                            start_far_node = (ne[0], ne[1])\n                            break\n                        elif (ne[0] != context_near_node[0] or ne[1] != context_near_node[1]) and \\\n                                (ne[0] != start_near_node[0] or ne[1] != start_near_node[1]):\n                            candidate_bevel.append((ne[0], ne[1]))\n                    if start_far_node is None:\n                        for ne in candidate_bevel:\n                            if ne[0] == context_far_node[0]:\n                                bevel_xys = [[ne[0] + 1, ne[1]], [ne[0] - 1, ne[1]]]\n                            if ne[1] == context_far_node[1]:\n                                bevel_xys = [[ne[0], ne[1] + 1], [ne[0], ne[1] - 1]]\n                            for bevel_x, bevel_y in bevel_xys:\n                                if surround_map[bevel_x, bevel_y] == 1:\n                                    start_far_node = (bevel_x, bevel_y)\n                                    accompany_far_node = (ne[0], ne[1])\n                                    break\n                            if start_far_node is not None:\n                                break\n                if start_far_node is not None:\n                    for far_edge_id in range(1, far_edge_cc.max() + 1):\n                        specific_far_edge = (far_edge_cc == far_edge_id).astype(np.uint8)\n                        if specific_far_edge[start_far_node[0], start_far_node[1]] == 1:\n                            if accompany_far_node is not None:\n                                specific_far_edge[accompany_far_node] = 1\n                            far_edge[specific_far_edge > 0] = 1\n                            far_edge_with_id[specific_far_edge > 0] = edge_id\n                            end_far_candidates = np.zeros_like(far_edge)\n                            end_far_candidates[end_near_node[0], end_near_node[1]] = 1\n                            end_far_candidates = cv2.dilate(end_far_candidates.astype(np.uint8), \n                                                            np.array([[0,1,0],[1,1,1],[0,1,0]]).astype(np.uint8), \n                                                            iterations=1)\n                            end_far_candidates[end_near_node[0], end_near_node[1]] = 0\n                            invalid_nodes = (((far_edge_cc != far_edge_id).astype(np.uint8) * \\\n                                              (far_edge_cc != 0).astype(np.uint8)).astype(np.uint8) + \\\n                                             (new_specific_edge_map).astype(np.uint8) + \\\n                                             (mask == 0).astype(np.uint8)).clip(0, 1)\n                            end_far_candidates[invalid_nodes > 0] = 0\n                            far_edge[end_far_candidates > 0] = 1\n                            far_edge_with_id[end_far_candidates > 0] = edge_id\n                            \n                    far_edge[context_far_node[0], context_far_node[1]] = 1\n                    far_edge_with_id[context_far_node[0], context_far_node[1]] = edge_id\n                near_edge_with_id[(mask_edge_with_id == edge_id) > 0] = edge_id\n    uncleaned_far_edge = far_edge.copy()\n    far_edge[mask == 0] = 0\n\n    return far_edge, uncleaned_far_edge, far_edge_with_id, near_edge_with_id\n\ndef get_MiDaS_samples(image_folder, depth_folder, config, specific=None, aft_certain=None):\n    lines = [os.path.splitext(os.path.basename(xx))[0] for xx in glob.glob(os.path.join(image_folder, '*' + config['img_format']))]\n    samples = []\n    generic_pose = np.eye(4)\n    assert len(config['traj_types']) == len(config['x_shift_range']) ==\\\n           len(config['y_shift_range']) == len(config['z_shift_range']) == len(config['video_postfix']), \\\n           \"The number of elements in 'traj_types', 'x_shift_range', 'y_shift_range', 'z_shift_range' and \\\n               'video_postfix' should be equal.\"\n    tgt_pose = [[generic_pose * 1]]\n    tgts_poses = []\n    for traj_idx in range(len(config['traj_types'])):\n        tgt_poses = []\n        sx, sy, sz = path_planning(config['num_frames'], config['x_shift_range'][traj_idx], config['y_shift_range'][traj_idx],\n                                   config['z_shift_range'][traj_idx], path_type=config['traj_types'][traj_idx])\n        for xx, yy, zz in zip(sx, sy, sz):\n            tgt_poses.append(generic_pose * 1.)\n            tgt_poses[-1][:3, -1] = np.array([xx, yy, zz])\n        tgts_poses += [tgt_poses]    \n    tgt_pose = generic_pose * 1\n    \n    aft_flag = True\n    if aft_certain is not None and len(aft_certain) > 0:\n        aft_flag = False\n    for seq_dir in lines:\n        if specific is not None and len(specific) > 0:\n            if specific != seq_dir:\n                continue\n        if aft_certain is not None and len(aft_certain) > 0:\n            if aft_certain == seq_dir:\n                aft_flag = True\n            if aft_flag is False:\n                continue\n        samples.append({})\n        sdict = samples[-1]            \n        sdict['depth_fi'] = os.path.join(depth_folder, seq_dir + config['depth_format'])\n        sdict['ref_img_fi'] = os.path.join(image_folder, seq_dir + config['img_format'])\n        H, W = imageio.imread(sdict['ref_img_fi']).shape[:2]\n        sdict['int_mtx'] = np.array([[max(H, W), 0, W//2], [0, max(H, W), H//2], [0, 0, 1]]).astype(np.float32)\n        if sdict['int_mtx'].max() > 1:\n            sdict['int_mtx'][0, :] = sdict['int_mtx'][0, :] / float(W)\n            sdict['int_mtx'][1, :] = sdict['int_mtx'][1, :] / float(H)\n        sdict['ref_pose'] = np.eye(4)\n        sdict['tgt_pose'] = tgt_pose\n        sdict['tgts_poses'] = tgts_poses\n        sdict['video_postfix'] = config['video_postfix']\n        sdict['tgt_name'] = [os.path.splitext(os.path.basename(sdict['depth_fi']))[0]]\n        sdict['src_pair_name'] = sdict['tgt_name'][0]\n\n    return samples\n\ndef get_valid_size(imap):\n    x_max = np.where(imap.sum(1).squeeze() > 0)[0].max() + 1\n    x_min = np.where(imap.sum(1).squeeze() > 0)[0].min()\n    y_max = np.where(imap.sum(0).squeeze() > 0)[0].max() + 1\n    y_min = np.where(imap.sum(0).squeeze() > 0)[0].min()\n    size_dict = {'x_max':x_max, 'y_max':y_max, 'x_min':x_min, 'y_min':y_min}\n    \n    return size_dict\n\ndef dilate_valid_size(isize_dict, imap, dilate=[0, 0]):\n    osize_dict = copy.deepcopy(isize_dict)\n    osize_dict['x_min'] = max(0, osize_dict['x_min'] - dilate[0])\n    osize_dict['x_max'] = min(imap.shape[0], osize_dict['x_max'] + dilate[0])\n    osize_dict['y_min'] = max(0, osize_dict['y_min'] - dilate[0])\n    osize_dict['y_max'] = min(imap.shape[1], osize_dict['y_max'] + dilate[1])\n\n    return osize_dict\n\ndef crop_maps_by_size(size, *imaps):\n    omaps = []\n    for imap in imaps:\n        omaps.append(imap[size['x_min']:size['x_max'], size['y_min']:size['y_max']].copy())\n    \n    return omaps\n\ndef smooth_cntsyn_gap(init_depth_map, mask_region, context_region, init_mask_region=None):\n    if init_mask_region is not None:\n        curr_mask_region = init_mask_region * 1\n    else:\n        curr_mask_region = mask_region * 0\n    depth_map = init_depth_map.copy()\n    for _ in range(2):\n        cm_mask = context_region + curr_mask_region\n        depth_s1 = np.roll(depth_map, 1, 0)\n        depth_s2 = np.roll(depth_map, -1, 0)\n        depth_s3 = np.roll(depth_map, 1, 1)\n        depth_s4 = np.roll(depth_map, -1, 1)\n        mask_s1 = np.roll(cm_mask, 1, 0)\n        mask_s2 = np.roll(cm_mask, -1, 0)\n        mask_s3 = np.roll(cm_mask, 1, 1)\n        mask_s4 = np.roll(cm_mask, -1, 1)\n        fluxin_depths = (depth_s1 * mask_s1 + depth_s2 * mask_s2 + depth_s3 * mask_s3 + depth_s4 * mask_s4) / \\\n                        ((mask_s1 + mask_s2 + mask_s3 + mask_s4) + 1e-6)\n        fluxin_mask = (fluxin_depths != 0) * mask_region\n        init_mask = (fluxin_mask * (curr_mask_region >= 0).astype(np.float32) > 0).astype(np.uint8)\n        depth_map[init_mask > 0] = fluxin_depths[init_mask > 0]\n        if init_mask.shape[-1] > curr_mask_region.shape[-1]:\n            curr_mask_region[init_mask.sum(-1, keepdims=True) > 0] = 1\n        else:\n            curr_mask_region[init_mask > 0] = 1\n        depth_map[fluxin_mask > 0] = fluxin_depths[fluxin_mask > 0]\n\n    return depth_map\n\ndef read_MiDaS_depth(disp_fi, disp_rescale=10., h=None, w=None):\n    if 'npy' in os.path.splitext(disp_fi)[-1]:\n        disp = np.load(disp_fi)\n    else:\n        disp = imageio.imread(disp_fi).astype(np.float32)\n    disp = disp - disp.min()\n    disp = cv2.blur(disp / disp.max(), ksize=(3, 3)) * disp.max()\n    disp = (disp / disp.max()) * disp_rescale\n    if h is not None and w is not None:\n        disp = resize(disp / disp.max(), (h, w), order=1) * disp.max()\n    depth = 1. / np.maximum(disp, 0.05)\n\n    return depth\n\ndef follow_image_aspect_ratio(depth, image):\n    H, W = image.shape[:2]\n    image_aspect_ratio = H / W\n    dH, dW = depth.shape[:2]\n    depth_aspect_ratio = dH / dW\n    if depth_aspect_ratio > image_aspect_ratio:\n        resize_H = dH\n        resize_W = dH / image_aspect_ratio\n    else:\n        resize_W = dW\n        resize_H = dW * image_aspect_ratio\n    depth = resize(depth / depth.max(), \n                    (int(resize_H), \n                    int(resize_W)), \n                    order=0) * depth.max()\n    \n    return depth\n\ndef depth_resize(depth, origin_size, image_size):\n    if origin_size[0] is not 0:\n        max_depth = depth.max()\n        depth = depth / max_depth\n        depth = resize(depth, origin_size, order=1, mode='edge')\n        depth = depth * max_depth\n    else:\n        max_depth = depth.max()\n        depth = depth / max_depth\n        depth = resize(depth, image_size, order=1, mode='edge')\n        depth = depth * max_depth\n\n    return depth\n    \ndef filter_irrelevant_edge(self_edge, other_edges, other_edges_with_id, current_edge_id, context, edge_ccs, mesh, anchor):\n    other_edges = other_edges.squeeze()\n    other_edges_with_id = other_edges_with_id.squeeze()\n    \n    self_edge = self_edge.squeeze()\n    dilate_self_edge = cv2.dilate(self_edge.astype(np.uint8), np.array([[1,1,1],[1,1,1],[1,1,1]]).astype(np.uint8), iterations=1)\n    edge_ids = collections.Counter(other_edges_with_id.flatten()).keys()\n    other_edges_info = []\n    # import ipdb\n    # ipdb.set_trace()\n    for edge_id in edge_ids:\n        edge_id = int(edge_id)\n        if edge_id >= 0:\n            condition = ((other_edges_with_id == edge_id) * other_edges * context).astype(np.uint8)\n            if dilate_self_edge[condition > 0].sum() == 0:\n                other_edges[other_edges_with_id == edge_id] = 0\n            else:\n                num_condition, condition_labels = cv2.connectedComponents(condition, connectivity=8)\n                for condition_id in range(1, num_condition):\n                    isolate_condition = ((condition_labels == condition_id) > 0).astype(np.uint8)\n                    num_end_group, end_group = cv2.connectedComponents(((dilate_self_edge * isolate_condition) > 0).astype(np.uint8), connectivity=8)\n                    if num_end_group == 1:\n                        continue\n                    for end_id in range(1, num_end_group):\n                        end_pxs, end_pys = np.where((end_group == end_id))\n                        end_px, end_py = end_pxs[0], end_pys[0]\n                        other_edges_info.append({})\n                        other_edges_info[-1]['edge_id'] = edge_id\n                        # other_edges_info[-1]['near_depth'] = None\n                        other_edges_info[-1]['diff'] = None\n                        other_edges_info[-1]['edge_map'] = np.zeros_like(self_edge)\n                        other_edges_info[-1]['end_point_map'] = np.zeros_like(self_edge)\n                        other_edges_info[-1]['end_point_map'][(end_group == end_id)] = 1\n                        other_edges_info[-1]['forbidden_point_map'] = np.zeros_like(self_edge)\n                        other_edges_info[-1]['forbidden_point_map'][(end_group != end_id) * (end_group != 0)] = 1\n                        other_edges_info[-1]['forbidden_point_map'] = cv2.dilate(other_edges_info[-1]['forbidden_point_map'], kernel=np.array([[1,1,1],[1,1,1],[1,1,1]]), iterations=2)\n                        for x in edge_ccs[edge_id]:\n                            nx = x[0] - anchor[0]\n                            ny = x[1] - anchor[1]\n                            if nx == end_px and ny == end_py:\n                                # other_edges_info[-1]['near_depth'] = abs(nx)\n                                if mesh.nodes[x].get('far') is not None and len(mesh.nodes[x].get('far')) == 1:\n                                    other_edges_info[-1]['diff'] = abs(1./abs([*mesh.nodes[x].get('far')][0][2]) - 1./abs(x[2]))\n                                else:\n                                    other_edges_info[-1]['diff'] = 0\n                                # if end_group[nx, ny] != end_id and end_group[nx, ny] > 0:\n                                #     continue\n                            try:\n                                if isolate_condition[nx, ny] == 1:\n                                    other_edges_info[-1]['edge_map'][nx, ny] = 1\n                            except:\n                                pass\n    try:\n        other_edges_info = sorted(other_edges_info, key=lambda x : x['diff'], reverse=True)\n    except:\n        import pdb\n        pdb.set_trace()\n    # import pdb\n    # pdb.set_trace()\n    # other_edges = other_edges[..., None]\n    for other_edge in other_edges_info:\n        if other_edge['end_point_map'] is None:\n            import pdb\n            pdb.set_trace()\n\n    other_edges = other_edges * context\n\n    return other_edges, other_edges_info\n\ndef require_depth_edge(context_edge, mask):\n    dilate_mask = cv2.dilate(mask, np.array([[1,1,1],[1,1,1],[1,1,1]]).astype(np.uint8), iterations=1)\n    if (dilate_mask * context_edge).max() == 0:\n        return False\n    else:\n        return True\n\ndef refine_color_around_edge(mesh, info_on_pix, edge_ccs, config, spdb=False):\n    H, W = mesh.graph['H'], mesh.graph['W']\n    tmp_edge_ccs = copy.deepcopy(edge_ccs)\n    for edge_id, edge_cc in enumerate(edge_ccs):\n        if len(edge_cc) == 0:\n            continue\n        near_maps = np.zeros((H, W)).astype(np.bool)\n        far_maps = np.zeros((H, W)).astype(np.bool)\n        tmp_far_nodes = set()\n        far_nodes = set()\n        near_nodes = set()\n        end_nodes = set()        \n        for i in range(5):\n            if i == 0:\n                for edge_node in edge_cc:\n                    if mesh.nodes[edge_node].get('depth_edge_dilate_2_color_flag') is not True:\n                        break\n                    if mesh.nodes[edge_node].get('inpaint_id') == 1:\n                        near_nodes.add(edge_node)\n                        tmp_node = mesh.nodes[edge_node].get('far')\n                        tmp_node = set(tmp_node) if tmp_node is not None else set()\n                        tmp_far_nodes |= tmp_node\n                rmv_tmp_far_nodes = set()\n                for far_node in tmp_far_nodes:\n                    if not(mesh.has_node(far_node) and mesh.nodes[far_node].get('inpaint_id') == 1):\n                        rmv_tmp_far_nodes.add(far_node)\n                if len(tmp_far_nodes - rmv_tmp_far_nodes) == 0:\n                    break                        \n                else:\n                    for near_node in near_nodes:\n                        near_maps[near_node[0], near_node[1]] = True\n                        mesh.nodes[near_node]['refine_rgbd'] = True\n                        mesh.nodes[near_node]['backup_depth'] = near_node[2] \\\n                                    if mesh.nodes[near_node].get('real_depth') is None else mesh.nodes[near_node]['real_depth']\n                        mesh.nodes[near_node]['backup_color'] = mesh.nodes[near_node]['color']\n                for far_node in tmp_far_nodes:\n                    if mesh.has_node(far_node) and mesh.nodes[far_node].get('inpaint_id') == 1:\n                        far_nodes.add(far_node)\n                        far_maps[far_node[0], far_node[1]] = True\n                        mesh.nodes[far_node]['refine_rgbd'] = True\n                        mesh.nodes[far_node]['backup_depth'] = far_node[2] \\\n                                    if mesh.nodes[far_node].get('real_depth') is None else mesh.nodes[far_node]['real_depth']\n                        mesh.nodes[far_node]['backup_color'] = mesh.nodes[far_node]['color']\n                tmp_far_nodes = far_nodes\n                tmp_near_nodes = near_nodes\n            else:\n                tmp_far_nodes = new_tmp_far_nodes\n                tmp_near_nodes = new_tmp_near_nodes\n                new_tmp_far_nodes = None\n                new_tmp_near_nodes = None\n            new_tmp_far_nodes = set()\n            new_tmp_near_nodes = set()\n            for node in tmp_near_nodes:\n                for ne_node in mesh.neighbors(node):\n                    if far_maps[ne_node[0], ne_node[1]] == False and \\\n                        near_maps[ne_node[0], ne_node[1]] == False:\n                        if mesh.nodes[ne_node].get('inpaint_id') == 1:\n                            new_tmp_near_nodes.add(ne_node)\n                            near_maps[ne_node[0], ne_node[1]] = True\n                            mesh.nodes[ne_node]['refine_rgbd'] = True\n                            mesh.nodes[ne_node]['backup_depth'] = ne_node[2] \\\n                                    if mesh.nodes[ne_node].get('real_depth') is None else mesh.nodes[ne_node]['real_depth']\n                            mesh.nodes[ne_node]['backup_color'] = mesh.nodes[ne_node]['color']\n                        else:\n                            mesh.nodes[ne_node]['backup_depth'] = ne_node[2] \\\n                                    if mesh.nodes[ne_node].get('real_depth') is None else mesh.nodes[ne_node]['real_depth']\n                            mesh.nodes[ne_node]['backup_color'] = mesh.nodes[ne_node]['color']\n                            end_nodes.add(node)\n            near_nodes.update(new_tmp_near_nodes)\n            for node in tmp_far_nodes:\n                for ne_node in mesh.neighbors(node):\n                    if far_maps[ne_node[0], ne_node[1]] == False and \\\n                        near_maps[ne_node[0], ne_node[1]] == False:\n                        if mesh.nodes[ne_node].get('inpaint_id') == 1:\n                            new_tmp_far_nodes.add(ne_node)\n                            far_maps[ne_node[0], ne_node[1]] = True\n                            mesh.nodes[ne_node]['refine_rgbd'] = True\n                            mesh.nodes[ne_node]['backup_depth'] = ne_node[2] \\\n                                    if mesh.nodes[ne_node].get('real_depth') is None else mesh.nodes[ne_node]['real_depth']\n                            mesh.nodes[ne_node]['backup_color'] = mesh.nodes[ne_node]['color']\n                        else:\n                            mesh.nodes[ne_node]['backup_depth'] = ne_node[2] \\\n                                    if mesh.nodes[ne_node].get('real_depth') is None else mesh.nodes[ne_node]['real_depth']\n                            mesh.nodes[ne_node]['backup_color'] = mesh.nodes[ne_node]['color']\n                            end_nodes.add(node)\n            far_nodes.update(new_tmp_far_nodes)\n        if len(far_nodes) == 0:\n            tmp_edge_ccs[edge_id] = set()\n            continue\n        for node in new_tmp_far_nodes | new_tmp_near_nodes:\n            for ne_node in mesh.neighbors(node):\n                if far_maps[ne_node[0], ne_node[1]] == False and near_maps[ne_node[0], ne_node[1]] == False:\n                    end_nodes.add(node)\n                    mesh.nodes[ne_node]['backup_depth'] = ne_node[2] \\\n                            if mesh.nodes[ne_node].get('real_depth') is None else mesh.nodes[ne_node]['real_depth']\n                    mesh.nodes[ne_node]['backup_color'] = mesh.nodes[ne_node]['color']\n        tmp_end_nodes = end_nodes\n        \n        refine_nodes = near_nodes | far_nodes\n        remain_refine_nodes = copy.deepcopy(refine_nodes)\n        accum_idx = 0\n        while len(remain_refine_nodes) > 0:\n            accum_idx += 1\n            if accum_idx > 100:\n                break\n            new_tmp_end_nodes = None\n            new_tmp_end_nodes = set()\n            survive_tmp_end_nodes = set()\n            for node in tmp_end_nodes:\n                re_depth, re_color, re_count = 0, np.array([0., 0., 0.]), 0\n                for ne_node in mesh.neighbors(node):\n                    if mesh.nodes[ne_node].get('refine_rgbd') is True:\n                        if ne_node not in tmp_end_nodes:\n                            new_tmp_end_nodes.add(ne_node)\n                    else:\n                        try:\n                            re_depth += mesh.nodes[ne_node]['backup_depth']\n                            re_color += mesh.nodes[ne_node]['backup_color'].astype(np.float32)\n                            re_count += 1.\n                        except:\n                            import pdb; pdb.set_trace()\n                if re_count > 0:\n                    re_depth = re_depth / re_count\n                    re_color = re_color / re_count\n                    mesh.nodes[node]['backup_depth'] = re_depth\n                    mesh.nodes[node]['backup_color'] = re_color\n                    mesh.nodes[node]['refine_rgbd'] = False\n                else:\n                    survive_tmp_end_nodes.add(node)\n            for node in tmp_end_nodes - survive_tmp_end_nodes:\n                if node in remain_refine_nodes:\n                    remain_refine_nodes.remove(node)\n            tmp_end_nodes = new_tmp_end_nodes\n        if spdb == True:\n            bfrd_canvas = np.zeros((H, W))\n            bfrc_canvas = np.zeros((H, W, 3)).astype(np.uint8)\n            aftd_canvas = np.zeros((H, W))\n            aftc_canvas = np.zeros((H, W, 3)).astype(np.uint8)\n            for node in refine_nodes:\n                bfrd_canvas[node[0], node[1]] = abs(node[2])\n                aftd_canvas[node[0], node[1]] = abs(mesh.nodes[node]['backup_depth'])\n                bfrc_canvas[node[0], node[1]] = mesh.nodes[node]['color'].astype(np.uint8)\n                aftc_canvas[node[0], node[1]] = mesh.nodes[node]['backup_color'].astype(np.uint8)\n            f, (ax1, ax2, ax3, ax4) = plt.subplots(1, 4, sharex=True, sharey=True); \n            ax1.imshow(bfrd_canvas); \n            ax2.imshow(aftd_canvas); \n            ax3.imshow(bfrc_canvas); \n            ax4.imshow(aftc_canvas); \n            plt.show()\n            import pdb; pdb.set_trace()\n        for node in refine_nodes:\n            if mesh.nodes[node].get('refine_rgbd') is not None:\n                mesh.nodes[node].pop('refine_rgbd')\n                mesh.nodes[node]['color'] = mesh.nodes[node]['backup_color']\n                for info in info_on_pix[(node[0], node[1])]:\n                    if info['depth'] == node[2]:\n                        info['color'] = mesh.nodes[node]['backup_color']\n\n    return mesh, info_on_pix\n\ndef refine_depth_around_edge(mask_depth, far_edge, uncleaned_far_edge, near_edge, mask, all_depth, config):\n    if isinstance(mask_depth, torch.Tensor):\n        if mask_depth.is_cuda:\n            mask_depth = mask_depth.cpu()\n        mask_depth = mask_depth.data\n        mask_depth = mask_depth.numpy()\n    if isinstance(far_edge, torch.Tensor):\n        if far_edge.is_cuda:\n            far_edge = far_edge.cpu()\n        far_edge = far_edge.data\n        far_edge = far_edge.numpy()\n    if isinstance(uncleaned_far_edge, torch.Tensor):\n        if uncleaned_far_edge.is_cuda:\n            uncleaned_far_edge = uncleaned_far_edge.cpu()\n        uncleaned_far_edge = uncleaned_far_edge.data\n        uncleaned_far_edge = uncleaned_far_edge.numpy()\n    if isinstance(near_edge, torch.Tensor):\n        if near_edge.is_cuda:\n            near_edge = near_edge.cpu()\n        near_edge = near_edge.data\n        near_edge = near_edge.numpy()\n    if isinstance(mask, torch.Tensor):\n        if mask.is_cuda:\n            mask = mask.cpu()\n        mask = mask.data\n        mask = mask.numpy()\n    mask = mask.squeeze()\n    uncleaned_far_edge = uncleaned_far_edge.squeeze()\n    far_edge = far_edge.squeeze()\n    near_edge = near_edge.squeeze()\n    mask_depth = mask_depth.squeeze()\n    dilate_far_edge = cv2.dilate(uncleaned_far_edge.astype(np.uint8), kernel=np.array([[0,1,0],[1,1,1],[0,1,0]]).astype(np.uint8), iterations=1)\n    near_edge[dilate_far_edge == 0] = 0\n    dilate_near_edge = cv2.dilate(near_edge.astype(np.uint8), kernel=np.array([[0,1,0],[1,1,1],[0,1,0]]).astype(np.uint8), iterations=1)\n    far_edge[dilate_near_edge == 0] = 0\n    init_far_edge = far_edge.copy()\n    init_near_edge = near_edge.copy()\n    for i in range(config['depth_edge_dilate_2']):\n        init_far_edge = cv2.dilate(init_far_edge, kernel=np.array([[0,1,0],[1,1,1],[0,1,0]]).astype(np.uint8), iterations=1)\n        init_far_edge[init_near_edge == 1] = 0\n        init_near_edge = cv2.dilate(init_near_edge, kernel=np.array([[0,1,0],[1,1,1],[0,1,0]]).astype(np.uint8), iterations=1)\n        init_near_edge[init_far_edge == 1] = 0\n    init_far_edge[mask == 0] = 0\n    init_near_edge[mask == 0] = 0\n    hole_far_edge = 1 - init_far_edge\n    hole_near_edge = 1 - init_near_edge\n    change = None\n    while True:\n        change = False\n        hole_far_edge[init_near_edge == 1] = 0\n        hole_near_edge[init_far_edge == 1] = 0\n        far_pxs, far_pys = np.where((hole_far_edge == 0) * (init_far_edge == 1) > 0)\n        current_hole_far_edge = hole_far_edge.copy()\n        for far_px, far_py in zip(far_pxs, far_pys):\n            min_px = max(far_px - 1, 0) \n            max_px = min(far_px + 2, mask.shape[0]-1)\n            min_py = max(far_py - 1, 0) \n            max_py = min(far_py + 2, mask.shape[1]-1)\n            hole_far = current_hole_far_edge[min_px: max_px, min_py: max_py]\n            tmp_mask = mask[min_px: max_px, min_py: max_py]\n            all_depth_patch = all_depth[min_px: max_px, min_py: max_py] * 0\n            all_depth_mask = (all_depth_patch != 0).astype(np.uint8)\n            cross_element = np.array([[0,1,0],[1,1,1],[0,1,0]])[min_px - (far_px - 1): max_px - (far_px - 1), min_py - (far_py - 1): max_py - (far_py - 1)]\n            combine_mask = (tmp_mask + all_depth_mask).clip(0, 1) * hole_far * cross_element\n            tmp_patch = combine_mask * (mask_depth[min_px: max_px, min_py: max_py] + all_depth_patch)\n            number = np.count_nonzero(tmp_patch)\n            if number > 0:\n                mask_depth[far_px, far_py] = np.sum(tmp_patch).astype(np.float32) / max(number, 1e-6)\n                hole_far_edge[far_px, far_py] = 1\n                change = True\n        near_pxs, near_pys = np.where((hole_near_edge == 0) * (init_near_edge == 1) > 0)\n        current_hole_near_edge = hole_near_edge.copy()\n        for near_px, near_py in zip(near_pxs, near_pys):\n            min_px = max(near_px - 1, 0) \n            max_px = min(near_px + 2, mask.shape[0]-1)\n            min_py = max(near_py - 1, 0) \n            max_py = min(near_py + 2, mask.shape[1]-1)\n            hole_near = current_hole_near_edge[min_px: max_px, min_py: max_py]\n            tmp_mask = mask[min_px: max_px, min_py: max_py]\n            all_depth_patch = all_depth[min_px: max_px, min_py: max_py] * 0\n            all_depth_mask = (all_depth_patch != 0).astype(np.uint8)            \n            cross_element = np.array([[0,1,0],[1,1,1],[0,1,0]])[min_px - near_px + 1:max_px - near_px + 1, min_py - near_py + 1:max_py - near_py + 1]\n            combine_mask = (tmp_mask + all_depth_mask).clip(0, 1) * hole_near * cross_element\n            tmp_patch = combine_mask * (mask_depth[min_px: max_px, min_py: max_py] + all_depth_patch)\n            number = np.count_nonzero(tmp_patch)\n            if number > 0:                \n                mask_depth[near_px, near_py] = np.sum(tmp_patch) / max(number, 1e-6)\n                hole_near_edge[near_px, near_py] = 1\n                change = True\n        if change is False:\n            break\n        \n    return mask_depth\n\n\n\ndef vis_depth_edge_connectivity(depth, config):\n    disp = 1./depth\n    u_diff = (disp[1:, :] - disp[:-1, :])[:-1, 1:-1]\n    b_diff = (disp[:-1, :] - disp[1:, :])[1:, 1:-1]\n    l_diff = (disp[:, 1:] - disp[:, :-1])[1:-1, :-1]\n    r_diff = (disp[:, :-1] - disp[:, 1:])[1:-1, 1:]\n    u_over = (np.abs(u_diff) > config['depth_threshold']).astype(np.float32)\n    b_over = (np.abs(b_diff) > config['depth_threshold']).astype(np.float32)\n    l_over = (np.abs(l_diff) > config['depth_threshold']).astype(np.float32)\n    r_over = (np.abs(r_diff) > config['depth_threshold']).astype(np.float32)\n    concat_diff = np.stack([u_diff, b_diff, r_diff, l_diff], axis=-1)\n    concat_over = np.stack([u_over, b_over, r_over, l_over], axis=-1)\n    over_diff = concat_diff * concat_over\n    pos_over = (over_diff > 0).astype(np.float32).sum(-1).clip(0, 1)\n    neg_over = (over_diff < 0).astype(np.float32).sum(-1).clip(0, 1)\n    neg_over[(over_diff > 0).astype(np.float32).sum(-1) > 0] = 0\n    _, edge_label = cv2.connectedComponents(pos_over.astype(np.uint8), connectivity=8)\n    T_junction_maps = np.zeros_like(pos_over)\n    for edge_id in range(1, edge_label.max() + 1):\n        edge_map = (edge_label == edge_id).astype(np.uint8)\n        edge_map = np.pad(edge_map, pad_width=((1,1),(1,1)), mode='constant')\n        four_direc = np.roll(edge_map, 1, 1) + np.roll(edge_map, -1, 1) + np.roll(edge_map, 1, 0) + np.roll(edge_map, -1, 0)\n        eight_direc = np.roll(np.roll(edge_map, 1, 1), 1, 0) + np.roll(np.roll(edge_map, 1, 1), -1, 0) + \\\n                      np.roll(np.roll(edge_map, -1, 1), 1, 0) + np.roll(np.roll(edge_map, -1, 1), -1, 0)\n        eight_direc = (eight_direc + four_direc)[1:-1,1:-1]\n        pos_over[eight_direc > 2] = 0\n        T_junction_maps[eight_direc > 2] = 1\n    _, edge_label = cv2.connectedComponents(pos_over.astype(np.uint8), connectivity=8)\n    edge_label = np.pad(edge_label, 1, mode='constant')\n\n    return edge_label\n\n\n\ndef max_size(mat, value=0):\n    if not (mat and mat[0]): return (0, 0)\n    it = iter(mat)\n    prev = [(el==value) for el in next(it)]\n    max_size = max_rectangle_size(prev)\n    for row in it:\n        hist = [(1+h) if el == value else 0 for h, el in zip(prev, row)]\n        max_size = max(max_size, max_rectangle_size(hist), key=get_area)\n        prev = hist                                               \n    return max_size\n\ndef max_rectangle_size(histogram):\n    Info = namedtuple('Info', 'start height')\n    stack = []\n    top = lambda: stack[-1]\n    max_size = (0, 0) # height, width of the largest rectangle\n    pos = 0 # current position in the histogram\n    for pos, height in enumerate(histogram):\n        start = pos # position where rectangle starts\n        while True:\n            if not stack or height > top().height:\n                stack.append(Info(start, height)) # push\n            if stack and height < top().height:\n                max_size = max(max_size, (top().height, (pos-top().start)),\n                               key=get_area)\n                start, _ = stack.pop()\n                continue\n            break # height == top().height goes here\n                \n    pos += 1\n    for start, height in stack:\n        max_size = max(max_size, (height, (pos-start)),\n                       key=get_area)\n\n    return max_size\n\ndef get_area(size):\n    return reduce(mul, size)\n\ndef find_anchors(matrix):\n    matrix = [[*x] for x in matrix]\n    mh, mw = max_size(matrix)\n    matrix = np.array(matrix)\n    # element = np.zeros((mh, mw))\n    for i in range(matrix.shape[0] + 1 - mh):\n        for j in range(matrix.shape[1] + 1 - mw):\n            if matrix[i:i + mh, j:j + mw].max() == 0:\n                return i, i + mh, j, j + mw\n\ndef find_largest_rect(dst_img, bg_color=(128, 128, 128)):\n    valid = np.any(dst_img[..., :3] != bg_color, axis=-1) \n    dst_h, dst_w = dst_img.shape[:2]\n    ret, labels = cv2.connectedComponents(np.uint8(valid == False)) \n    red_mat = np.zeros_like(labels) \n    # denoise \n    for i in range(1, np.max(labels)+1, 1): \n        x, y, w, h = cv2.boundingRect(np.uint8(labels==i)) \n        if x == 0 or (x+w) == dst_h or y == 0 or (y+h) == dst_w: \n            red_mat[labels==i] = 1 \n    # crop \n    t, b, l, r = find_anchors(red_mat) \n\n    return t, b, l, r\n"
        },
        {
          "name": "video",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}