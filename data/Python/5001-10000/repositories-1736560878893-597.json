{
  "metadata": {
    "timestamp": 1736560878893,
    "page": 597,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nuno-faria/tiler",
      "stars": 5951,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0625,
          "content": "MIT License\r\n\r\nCopyright (c) 2019 nuno-faria\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.3095703125,
          "content": "![title](images/title_stripes.png)\n\nðŸ‘· Build images with images.\n\n\n## About\n\nTiler is a tool to create an image using all kinds of other smaller images (tiles). It is different from other mosaic tools since it can adapt to tiles with multiple shapes and sizes (i.e. not limited to squares).\n\nAn image can be built out of circles, lines, waves, cross stitches, legos, minecraft blocks, paper clips, letters, ... The possibilities are endless!\n\n\n## Installation\n\n- Clone the repo: `git clone https://github.com/nuno-faria/tiler.git`;\n- Install Python 3;\n- Install pip (optional, to install the dependencies);\n- Install dependencies: `pip install -r requirements.txt`\n\n## Usage\n\n- Make a folder with the tiles (and only the tiles) to build the image;\n    - The script `gen_tiles.py` can help in this task; it builds tiles with multiple colors based on the source tile (note: its recommended for the source file to have an RGB color of (240,240,240)). It is used as `python gen_tiles.py path/to/image` and creates a folder with a 'gen_' prefix in the same path as the base image.\n- Run `python tiler.py path/to/image path/to/tiles_folder/`.\n\n## Configuration\n\nAll configurations can be changed in the `conf.py` file.\n\n#### `gen_tiles.py`\n\n- `DEPTH` - number of divisions in each color channel (ex: DEPTH = 4 -> 4 * 4 * 4 = 64 colors);\n- `ROTATIONS` - list of rotations, in degrees, to apply over the original image (ex: [0, 90]).\n\n#### `tiler.py`\n\n- `COLOR_DEPTH` - number of divisions in each color channel (ex: COLOR_DEPTH = 4 -> 4 * 4 * 4 = 64 colors);\n- `IMAGE_SCALE` - scale to apply to the image to tile (1 = default scale);\n- `RESIZING_SCALES` - scale to apply to each tile (ex: [1, 0.75, 0.5, 0.25]);\n- `PIXEL_SHIFT` - number of pixels shifted to create each box (ex: (5,5)); if None, shift will be the same as the tile dimension);\n    <img src=\"images/pixel_shift.png\" width=\"100%\">\n- `OVERLAP_TILES` - if tiles can overlap;\n- `RENDER` - render image as its being built;\n- `POOL_SIZE` - multiprocessing pool size;\n- `IMAGE_TO_TILE` - image to tile (ignored if passed as the 1st arg);\n- `TILES_FOLDER` - folder with tiles (ignored if passed as the 2nd arg);\n- `OUT` - result image filename.\n\n\n## Examples\n\n### Circles\n\n#### Various sizes\n\n<img src=\"images/cake_circles.png\" width=\"40%\">\n\n[Original](https://www.flaticon.com/free-icon/cake_1102780) cake image by [pongsakornred](https://www.flaticon.com/authors/pongsakornred) from [FLATICON](https://www.flaticon.com).\n\n#### Fixed\n\n- 10x10\n<img src=\"images/cake_circles_simple.png\" width=\"40%\">\n<img src=\"images/starry_night_circles_10x10.png\" width=\"100%\">\n- 25x25\n<img src=\"images/starry_night_circles_25x25.png\" width=\"100%\">\n- 50x50\n<img src=\"images/starry_night_circles_50x50.png\" width=\"100%\">\n\n\n### Paper clips\n\n<img src=\"images/cake_clips.png\" width=\"40%\">\n\n\n### Cross stitch (times)\n\n<img src=\"images/cake_times.png\" width=\"40%\">\n\n<img src=\"images/starry_night_times.png\" width=\"100%\">\n\n\n### Hearts\n\n<img src=\"images/heart_hearts.png\" width=\"40%\">\n\n\n### Legos\n\n<img src=\"images/cake_lego.png\" width=\"40%\">\n<img src=\"images/starry_night_lego.png\" width=\"100%\">\n\n\n### Minecraft blocks\n\n<img src=\"images/cake_minecraft.png\" width=\"40%\">\n<img src=\"images/starry_night_minecraft.png\" width=\"100%\">\n\n\n### Stripes (lines)\n\n<img src=\"images/cake_stripes.png\" width=\"50%\">\n\n\n### At\n\n<img src=\"images/github_logo_at.png\" width=\"50%\">\n"
        },
        {
          "name": "conf.py",
          "type": "blob",
          "size": 0.955078125,
          "content": "# GEN TILES CONFS\n\n# number of divisions per channel (R, G and B)\n# DEPTH = 4 -> 4 * 4 * 4 = 64 colors\nDEPTH = 4\n# list of rotations, in degrees, to apply over the original image\nROTATIONS = [0]\n\n\n#############################\n\n\n# TILER CONFS\n\n# number of divisions per channel\n# (COLOR_DEPTH = 32 -> 32 * 32 * 32 = 32768 colors)\nCOLOR_DEPTH = 32\n# Scale of the image to be tiled (1 = default resolution)\nIMAGE_SCALE = 1\n# tiles scales (1 = default resolution)\nRESIZING_SCALES = [0.5, 0.4, 0.3, 0.2, 0.1]\n# number of pixels shifted to create each box (tuple with (x,y))\n# if value is None, shift will be done accordingly to tiles dimensions\nPIXEL_SHIFT = (5, 5)\n# if tiles can overlap\nOVERLAP_TILES = False\n# render image as its being built\nRENDER = False\n# multiprocessing pool size\nPOOL_SIZE = 8\n\n# out file name\nOUT = 'out.png'\n# image to tile (ignored if passed as the 1st arg)\nIMAGE_TO_TILE = None\n# folder with tiles (ignored if passed as the 2nd arg)\nTILES_FOLDER = None\n"
        },
        {
          "name": "gen_tiles.py",
          "type": "blob",
          "size": 1.6748046875,
          "content": "import cv2 \nimport numpy as np\nimport os\nimport sys\nfrom tqdm import tqdm\nimport math\nimport conf\n\n# DEPTH = 4 -> 4 * 4 * 4 = 64 colors\nDEPTH = conf.DEPTH\n# list of rotations, in degrees, to apply over the original image\nROTATIONS = conf.ROTATIONS\n\nimg_path = sys.argv[1]\nimg_dir = os.path.dirname(img_path)\nimg_name, ext = os.path.basename(img_path).rsplit('.', 1)\nout_folder = img_dir + '/gen_' + img_name\n\nif not os.path.exists(out_folder):\n    os.mkdir(out_folder)\n\nimg = cv2.imread(img_path, cv2.IMREAD_UNCHANGED)\nimg = img.astype('float')\n\nheight, width, channels = img.shape\ncenter = (width/2, height/2)\n\nfor b in tqdm(np.arange(0, 1.01, 1 / DEPTH)):\n    for g in np.arange(0, 1.01, 1 / DEPTH):\n        for r in np.arange(0, 1.01, 1 / DEPTH):\n            mult_vector = [b, g, r]\n            if channels == 4:\n                mult_vector.append(1)\n            new_img = img * mult_vector\n            new_img = new_img.astype('uint8')\n            for rotation in ROTATIONS:\n                rotation_matrix = cv2.getRotationMatrix2D(center, rotation, 1)\n                abs_cos = abs(rotation_matrix[0,0])\n                abs_sin = abs(rotation_matrix[0,1])\n                new_w = int(height * abs_sin + width * abs_cos)\n                new_h = int(height * abs_cos + width * abs_sin)\n                rotation_matrix[0, 2] += new_w/2 - center[0]\n                rotation_matrix[1, 2] += new_h/2 - center[1]\n                cv2.imwrite(\n                    f'{out_folder}/{img_name}_{round(r,1)}_{round(g,1)}_{round(b,1)}_r{rotation}.{ext}',\n                    cv2.warpAffine(new_img, rotation_matrix, (new_w, new_h)),\n                    # compress image\n                    [cv2.IMWRITE_PNG_COMPRESSION, 9])\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0234375,
          "content": "opencv-python\nnumpy\ntqdm"
        },
        {
          "name": "tiler.py",
          "type": "blob",
          "size": 6.4091796875,
          "content": "import cv2\nimport numpy as np\nimport os\nimport sys\nfrom collections import defaultdict\nfrom tqdm import tqdm\nfrom multiprocessing import Pool\nimport math\nimport pickle\nimport conf\nfrom time import sleep\n\n\n# number of colors per image\nCOLOR_DEPTH = conf.COLOR_DEPTH\n# image scale\nIMAGE_SCALE = conf.IMAGE_SCALE\n# tiles scales\nRESIZING_SCALES = conf.RESIZING_SCALES\n# number of pixels shifted to create each box (x,y)\nPIXEL_SHIFT = conf.PIXEL_SHIFT\n# multiprocessing pool size\nPOOL_SIZE = conf.POOL_SIZE\n# if tiles can overlap\nOVERLAP_TILES = conf.OVERLAP_TILES\n\n\n# reduces the number of colors in an image\ndef color_quantization(img, n_colors):\n    return np.round(img / 255 * n_colors) / n_colors * 255\n\n\n# returns an image given its path\ndef read_image(path, mainImage=False):\n    img = cv2.imread(path, cv2.IMREAD_UNCHANGED)\n    if img.shape[2] == 3:\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA)\n    img = color_quantization(img.astype('float'), COLOR_DEPTH)\n    # scale the image according to IMAGE_SCALE, if this is the main image\n    if mainImage:\n        img = cv2.resize(img, (0, 0), fx=IMAGE_SCALE, fy=IMAGE_SCALE)\n    return img.astype('uint8')\n\n\n# scales an image\ndef resize_image(img, ratio):\n    img = cv2.resize(img, (int(img.shape[1] * ratio), int(img.shape[0] * ratio)))\n    return img\n\n\n# the most frequent color in an image and its relative frequency\ndef mode_color(img, ignore_alpha=False):\n    counter = defaultdict(int)\n    total = 0\n    for y in img:\n        for x in y:\n            if len(x) < 4 or ignore_alpha or x[3] != 0:\n                counter[tuple(x[:3])] += 1\n            else:\n                counter[(-1,-1,-1)] += 1\n            total += 1\n\n    if total > 0:\n        mode_color = max(counter, key=counter.get)\n        if mode_color == (-1,-1,-1):\n            return None, None\n        else:\n            return mode_color, counter[mode_color] / total\n    else:\n        return None, None\n\n\n# displays an image\ndef show_image(img, wait=True):\n    cv2.imshow('img', img)\n    if wait:\n        cv2.waitKey(0)\n    else:\n        cv2.waitKey(1)\n\n\n# load and process the tiles\ndef load_tiles(paths):\n    print('Loading tiles')\n    tiles = defaultdict(list)\n\n    for path in paths:\n        if os.path.isdir(path):\n            for tile_name in tqdm(os.listdir(path)):\n                tile = read_image(os.path.join(path, tile_name))\n                mode, rel_freq = mode_color(tile, ignore_alpha=True)\n                if mode is not None:\n                    for scale in RESIZING_SCALES:\n                        t = resize_image(tile, scale)\n                        res = tuple(t.shape[:2])\n                        tiles[res].append({\n                            'tile': t,\n                            'mode': mode,\n                            'rel_freq': rel_freq\n                        })\n\n            with open('tiles.pickle', 'wb') as f:\n                pickle.dump(tiles, f)\n\n        # load pickle with tiles (one file only)\n        else:\n            with open(path, 'rb') as f:\n                tiles = pickle.load(f)\n\n    return tiles\n\n\n# returns the boxes (image and start pos) from an image, with 'res' resolution\ndef image_boxes(img, res):\n    if not PIXEL_SHIFT:\n        shift = np.flip(res)\n    else:\n        shift = PIXEL_SHIFT\n\n    boxes = []\n    for y in range(0, img.shape[0], shift[1]):\n        for x in range(0, img.shape[1], shift[0]):\n            boxes.append({\n                'img': img[y:y+res[0], x:x+res[1]],\n                'pos': (x,y)\n            })\n\n    return boxes\n\n\n# euclidean distance between two colors\ndef color_distance(c1, c2):\n    c1_int = [int(x) for x in c1]\n    c2_int = [int(x) for x in c2]\n    return math.sqrt((c1_int[0] - c2_int[0])**2 + (c1_int[1] - c2_int[1])**2 + (c1_int[2] - c2_int[2])**2)\n\n\n# returns the most similar tile to a box (in terms of color)\ndef most_similar_tile(box_mode_freq, tiles):\n    if not box_mode_freq[0]:\n        return (0, np.zeros(shape=tiles[0]['tile'].shape))\n    else:\n        min_distance = None\n        min_tile_img = None\n        for t in tiles:\n            dist = (1 + color_distance(box_mode_freq[0], t['mode'])) / box_mode_freq[1]\n            if min_distance is None or dist < min_distance:\n                min_distance = dist\n                min_tile_img = t['tile']\n        return (min_distance, min_tile_img)\n\n\n# builds the boxes and finds the best tile for each one\ndef get_processed_image_boxes(image_path, tiles):\n    print('Getting and processing boxes')\n    img = read_image(image_path, mainImage=True)\n    pool = Pool(POOL_SIZE)\n    all_boxes = []\n\n    for res, ts in tqdm(sorted(tiles.items(), reverse=True)):\n        boxes = image_boxes(img, res)\n        modes = pool.map(mode_color, [x['img'] for x in boxes])\n        most_similar_tiles = pool.starmap(most_similar_tile, zip(modes, [ts for x in range(len(modes))]))\n\n        i = 0\n        for min_dist, tile in most_similar_tiles:\n            boxes[i]['min_dist'] = min_dist\n            boxes[i]['tile'] = tile\n            i += 1\n\n        all_boxes += boxes\n\n    return all_boxes, img.shape\n\n\n# places a tile in the image\ndef place_tile(img, box):\n    p1 = np.flip(box['pos'])\n    p2 = p1 + box['img'].shape[:2]\n    img_box = img[p1[0]:p2[0], p1[1]:p2[1]]\n    mask = box['tile'][:, :, 3] != 0\n    mask = mask[:img_box.shape[0], :img_box.shape[1]]\n    if OVERLAP_TILES or not np.any(img_box[mask]):\n        img_box[mask] = box['tile'][:img_box.shape[0], :img_box.shape[1], :][mask]\n\n\n# tiles the image\ndef create_tiled_image(boxes, res, render=False):\n    print('Creating tiled image')\n    img = np.zeros(shape=(res[0], res[1], 4), dtype=np.uint8)\n\n    for box in tqdm(sorted(boxes, key=lambda x: x['min_dist'], reverse=OVERLAP_TILES)):\n        place_tile(img, box)\n        if render:\n            show_image(img, wait=False)\n            sleep(0.025)\n\n    return img\n\n\n# main\ndef main():\n    if len(sys.argv) > 1:\n        image_path = sys.argv[1]\n    else:\n        image_path = conf.IMAGE_TO_TILE\n\n    if len(sys.argv) > 2:\n        tiles_paths = sys.argv[2:]\n    else:\n        tiles_paths = conf.TILES_FOLDER.split(' ')\n\n    if not os.path.exists(image_path):\n        print('Image not found')\n        exit(-1)\n    for path in tiles_paths:\n        if not os.path.exists(path):\n            print('Tiles folder not found')\n            exit(-1)\n\n    tiles = load_tiles(tiles_paths)\n    boxes, original_res = get_processed_image_boxes(image_path, tiles)\n    img = create_tiled_image(boxes, original_res, render=conf.RENDER)\n    cv2.imwrite(conf.OUT, img)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
          "name": "tiles",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}