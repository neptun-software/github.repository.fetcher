{
  "metadata": {
    "timestamp": 1736561057232,
    "page": 840,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "humphd/have-fun-with-machine-learning",
      "stars": 5080,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0126953125,
          "content": ".DS_Store\n*~\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.92578125,
          "content": "MIT License\n\nCopyright (c) 2016 David Humphrey\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n-------------------------------\n\nDolphin and Seahorse images in data/dolphins-and-seahorses from Caltech101\nhttp://www.vision.caltech.edu/Image_Datasets/Caltech101/\n\nL. Fei-Fei, R. Fergus and P. Perona. Learning generative visual models\nfrom few training examples: an incremental Bayesian approach tested on\n101 object categories. IEEE. CVPR 2004, Workshop on Generative-Model\nBased Vision. 2004\n\n-------------------------------\n\nDolphin and Seahorse images in data/untrained-samples from various:\n\nhttps://unsplash.com/search/dolphin?photo=d93dJ4kehUg\nhttps://unsplash.com/search/dolphin?photo=i5FsBOLsB50\nhttps://unsplash.com/search/dolphin?photo=5tGiaWu1QQs\nhttps://upload.wikimedia.org/wikipedia/commons/d/dd/Black_Sea_fauna_Seahorse.JPG\nhttp://www.fusedjaw.com/wp-content/uploads/2003/10/Brazilian-Seahorse-In-Aquarium.jpg\nhttps://cdn.pixabay.com/photo/2016/08/03/22/30/seahorse-1568021_640.jpg\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 48.33203125,
          "content": "# Have Fun with Machine Learning: A Guide for Beginners\nAlso available in [Chinese (Traditional)](README_zh-tw.md).  \nAlso available in [Korean](README_ko-KR.md).\n\n## Preface\n\nThis is a **hands-on guide** to machine learning for programmers with *no background* in\nAI. Using a neural network doesn’t require a PhD, and you don’t need to be the person who\nmakes the next breakthrough in AI in order to *use* what exists today.  What we have now\nis already breathtaking, and highly usable.  I believe that more of us need to play with\nthis stuff like we would any other open source technology, instead of treating it like a\nresearch topic.\n\nIn this guide our goal will be to write a program that uses machine learning to predict, with a\nhigh degree of certainty, whether the images in [data/untrained-samples](data/untrained-samples)\nare of **dolphins** or **seahorses** using only the images themselves, and without\nhaving seen them before.  Here are two example images we'll use:\n\n![A dolphin](data/untrained-samples/dolphin1.jpg?raw=true \"Dolphin\")\n![A seahorse](data/untrained-samples/seahorse1.jpg?raw=true \"Seahorse\")\n\nTo do that we’re going to train and use a [Convolutional Neural Network (CNN)](https://en.wikipedia.org/wiki/Convolutional_neural_network).\nWe’re going to approach this from the point of view of a practitioner vs.\nfrom first principles. There is so much excitement about AI right now,\nbut much of what’s being written feels like being taught to do\ntricks on your bike by a physics professor at a chalkboard instead\nof your friends in the park.\n\nI’ve decided to write this on Github vs. as a blog post\nbecause I’m sure that some of what I’ve written below is misleading, naive, or\njust plain wrong.  I’m still learning myself, and I’ve found the lack of solid\nbeginner documentation an obstacle.  If you see me making a mistake or missing\nimportant details, please send a pull request. \n\nWith all of that out the way, let me show you how to do some tricks on your bike!\n\n## Overview\n\nHere’s what we’re going to explore:\n\n* Setup and use existing, open source machine learning technologies, specifically [Caffe](http://caffe.berkeleyvision.org/) and [DIGITS](https://developer.nvidia.com/digits)\n* Create a dataset of images\n* Train a neural network from scratch\n* Test our neural network on images it has never seen before\n* Improve our neural network’s accuracy by fine tuning existing neural networks (AlexNet and GoogLeNet)\n* Deploy and use our neural network\n\nThis guide won’t teach you how neural networks are designed, cover much theory,\nor use a single mathematical expression.  I don’t pretend to understand most of\nwhat I’m going to show you.  Instead, we’re going to use existing things in\ninteresting ways to solve a hard problem.\n\n> Q: \"I know you said we won’t talk about the theory of neural networks, but I’m\n> feeling like I’d at least like an overview before we get going.  Where should I start?\"\n\nThere are literally hundreds of introductions to this, from short posts to full\nonline courses.  Depending on how you like to learn, here are three options\nfor a good starting point:\n\n* This fantastic [blog post](https://jalammar.github.io/visual-interactive-guide-basics-neural-networks/) by J Alammar,\nwhich introduces the concepts of neural networks using intuitive examples.\n* Similarly, [this video](https://www.youtube.com/watch?v=FmpDIaiMIeA) introduction by [Brandon Rohrer](https://www.youtube.com/channel/UCsBKTrp45lTfHa_p49I2AEQ) is a really good intro to\nConvolutional Neural Networks like we'll be using\n* If you’d rather have a bit more theory, I’d recommend [this online book](http://neuralnetworksanddeeplearning.com/chap1.html) by [Michael Nielsen](http://michaelnielsen.org/).\n\n## Setup\n\nInstalling the software we'll use (Caffe and DIGITS) can be frustrating, depending on your platform\nand OS version.  By far the easiest way to do it is using Docker.  Below we examine how to do it with Docker,\nas well as how to do it natively.\n\n### Option 1a: Installing Caffe Natively\n\nFirst, we’re going to be using the [Caffe deep learning framework](http://caffe.berkeleyvision.org/)\nfrom the Berkely Vision and Learning Center (BSD licensed).\n\n> Q: “Wait a minute, why Caffe? Why not use something like TensorFlow,\n> which everyone is talking about these days…”  \n\nThere are a lot of great choices available, and you should look at all the\noptions.  [TensorFlow](https://www.tensorflow.org/) is great, and you should\nplay with it.  However, I’m using Caffe for a number of reasons:\n\n* It’s tailormade for computer vision problems\n* It has support for C++, Python, (with [node.js support](https://github.com/silklabs/node-caffe) coming)\n* It’s fast and stable\n\nBut the **number one reason** I’m using Caffe is that you **don’t need to write any code** to work\nwith it.  You can do everything declaratively (Caffe uses structured text files to define the\nnetwork architecture) and using command-line tools.  Also, you can use some nice front-ends for Caffe to make\ntraining and validating your network a lot easier.  We’ll be using\n[nVidia’s DIGITS](https://developer.nvidia.com/digits) tool below for just this purpose.\n\nCaffe can be a bit of work to get installed.  There are [installation instructions](http://caffe.berkeleyvision.org/installation.html)\nfor various platforms, including some prebuilt Docker or AWS configurations.  \n\n**NOTE:** when making my walkthrough, I used the following non-released version of Caffe from their Github repo:\nhttps://github.com/BVLC/caffe/commit/5a201dd960840c319cefd9fa9e2a40d2c76ddd73\n\nOn a Mac it can be frustrating to get working, with version issues halting\nyour progress at various steps in the build.  It took me a couple of days\nof trial and error.  There are a dozen guides I followed, each with slightly\ndifferent problems.  In the end I found [this one](https://gist.github.com/doctorpangloss/f8463bddce2a91b949639522ea1dcbe4) to be the closest.\nI’d also recommend [this post](https://eddiesmo.wordpress.com/2016/12/20/how-to-set-up-caffe-environment-and-pycaffe-on-os-x-10-12-sierra/),\nwhich is quite recent and links to many of the same discussions I saw. \n\nGetting Caffe installed is by far the hardest thing we'll do, which is pretty\nneat, since you’d assume the AI aspects would be harder!  Don’t give up if you have\nissues, it’s worth the pain.  If I was doing this again, I’d probably use an Ubuntu VM\ninstead of trying to do it on Mac directly.  There's also a [Caffe Users](https://groups.google.com/forum/#!forum/caffe-users) group, if you need answers.\n\n> Q: “Do I need powerful hardware to train a neural network? What if I don’t have\n> access to fancy GPUs?”\n\nIt’s true, deep neural networks require a lot of computing power and energy to\ntrain...if you’re training them from scratch and using massive datasets.\nWe aren’t going to do that.  The secret is to use a pretrained network that someone\nelse has already invested hundreds of hours of compute time training, and then to fine\ntune it to your particular dataset.  We’ll look at how to do this below, but suffice\nit to say that everything I’m going to show you, I’m doing on a year old MacBook\nPro without a fancy GPU.\n\nAs an aside, because I have an integrated Intel graphics card vs. an nVidia GPU,\nI decided to use the [OpenCL Caffe branch](https://github.com/BVLC/caffe/tree/opencl),\nand it’s worked great on my laptop.\n\nWhen you’re done installing Caffe, you should have, or be able to do all of the following:\n\n* A directory that contains your built caffe.  If you did this in the standard way,\nthere will be a `build/` dir which contains everything you need to run caffe,\nthe Python bindings, etc.  The parent dir that contains `build/` will be your\n`CAFFE_ROOT` (we’ll need this later).\n* Running `make test && make runtest` should pass\n* After installing all the Python deps (doing `pip install -r requirements.txt` in `python/`),\nrunning `make pycaffe && make pytest` should pass\n* You should also run `make distribute` in order to create a distributable version of caffe with all necessary headers, binaries, etc. in `distribute/`.\n\nOn my machine, with Caffe fully built, I’ve got the following basic layout in my CAFFE_ROOT dir:\n\n```\ncaffe/\n    build/\n        python/\n        lib/\n        tools/\n            caffe ← this is our main binary \n    distribute/\n        python/\n        lib/\n        include/\n        bin/\n        proto/\n```\n\nAt this point, we have everything we need to train, test, and program with neural\nnetworks.  In the next section we’ll add a user-friendly, web-based front end to\nCaffe called DIGITS, which will make training and testing our networks much easier.\n\n### Option 1b: Installing DIGITS Natively\n\nnVidia’s [Deep Learning GPU Training System, or DIGITS](https://github.com/NVIDIA/DIGITS),\nis BSD-licensed Python web app for training neural networks.  While it’s\npossible to do everything DIGITS does in Caffe at the command-line, or with code,\nusing DIGITS makes it a lot easier to get started.  I also found it more fun, due\nto the great visualizations, real-time charts, and other graphical features.\nSince you’re experimenting and trying to learn, I highly recommend beginning with DIGITS.\n\nThere are quite a few good docs at https://github.com/NVIDIA/DIGITS/tree/master/docs,\nincluding a few [Installation](https://github.com/NVIDIA/DIGITS/blob/master/docs/BuildDigits.md),\n[Configuration](https://github.com/NVIDIA/DIGITS/blob/master/docs/Configuration.md),\nand [Getting Started](https://github.com/NVIDIA/DIGITS/blob/master/docs/GettingStarted.md)\npages.  I’d recommend reading through everything there before you continue, as I’m not\nan expert on everything you can do with DIGITS.  There's also a public [DIGITS User Group](https://groups.google.com/forum/#!forum/digits-users) if you have questions you need to ask.\n\nThere are various ways to install and run DIGITS, from Docker to pre-baked packages\non Linux, or you can build it from source. I’m on a Mac, so I built it from source.\n\n**NOTE:** In my walkthrough I've used the following non-released version of DIGITS\nfrom their Github repo: https://github.com/NVIDIA/DIGITS/commit/81be5131821ade454eb47352477015d7c09753d9\n\nBecause it’s just a bunch of Python scripts, it was fairly painless to get working.\nThe one thing you need to do is tell DIGITS where your `CAFFE_ROOT` is by setting\nan environment variable before starting the server:\n\n```bash\nexport CAFFE_ROOT=/path/to/caffe\n./digits-devserver\n```\n\nNOTE: on Mac I had issues with the server scripts assuming my Python binary was\ncalled `python2`, where I only have `python2.7`.  You can symlink it in `/usr/bin`\nor modify the DIGITS startup script(s) to use the proper binary on your system.\n\nOnce the server is started, you can do everything else via your web browser at http://localhost:5000, which is what I'll do below.\n\n### Option 2: Caffe and DIGITS using Docker\n\nInstall [Docker](https://www.docker.com/), if not already installed, then run the following command\nin order to pull and run a full Caffe + Digits container.  A few things to note:\n* make sure port 8080 isn't allocated by another program. If so, change it to any other port you want.\n* change `/path/to/this/repository` to the location of this cloned repo, and `/data/repo` within the container\nwill be bound to this directory.  This is useful for accessing the images discussed below.\n\n```bash\ndocker run --name digits -d -p 8080:5000 -v /path/to/this/repository:/data/repo kaixhin/digits\n```\n\nNow that we have our container running you can open up your web browser and open `http://localhost:8080`. Everything in the repository is now in the container directory `/data/repo`.  That's it. You've now got Caffe and DIGITS working.\n\nIf you need shell access, use the following command:\n\n```bash\ndocker exec -it digits /bin/bash\n```\n\n## Training a Neural Network\n\nTraining a neural network involves a few steps:\n\n1. Assemble and prepare a dataset of categorized images\n2. Define the network’s architecture\n3. Train and Validate this network using the prepared dataset\n\nWe’re going to do this 3 different ways, in order to show the difference\nbetween starting from scratch and using a pretrained network, and also to show\nhow to work with two popular pretrained networks (AlexNet, GoogLeNet) that are\ncommonly used with Caffe and DIGITs.\n\nFor our training attempts, we’ll use a small dataset of Dolphins and Seahorses.\nI’ve put the images I used in [data/dolphins-and-seahorses](data/dolphins-and-seahorses).\nYou need at least 2 categories, but could have many more (some of the networks\nwe’ll use were trained on 1000+ image categories).  Our goal is to be able to\ngive an image to our network and have it tell us whether it’s a Dolphin or a Seahorse.\n\n### Prepare the Dataset\n\nThe easiest way to begin is to divide your images into a categorized directory layout:\n\n```\ndolphins-and-seahorses/\n    dolphin/\n        image_0001.jpg\n        image_0002.jpg\n        image_0003.jpg\n        ...\n    seahorse/\n        image_0001.jpg\n        image_0002.jpg\n        image_0003.jpg\n        ...\n```\n\nHere each directory is a category we want to classify, and each image within\nthat category dir an example we’ll use for training and validation. \n\n> Q: “Do my images have to be the same size?  What about the filenames, do they matter?”\n\nNo to both. The images sizes will be normalized before we feed them into\nthe network.  We’ll eventually want colour images of 256 x 256 pixels, but\nDIGITS will crop or squash (we'll squash) our images automatically in a moment.\nThe filenames are irrelevant--it’s only important which category they are contained\nwithin.\n\n> Q: “Can I do more complex segmentation of my categories?”\n\nYes. See https://github.com/NVIDIA/DIGITS/blob/digits-4.0/docs/ImageFolderFormat.md.\n\nWe want to use these images on disk to create a **New Dataset**, and specifically,\na **Classification Dataset**.\n\n![Create New Dataset](images/create-new-dataset.png?raw=true \"Create New Dataset\")\n\nWe’ll use the defaults DIGITS gives us, and point **Training Images** at the path\nto our [data/dolphins-and-seahorses](data/dolphins-and-seahorses) folder.\nDIGITS will use the categories (`dolphin` and `seahorse`) to create a database\nof squashed, 256 x 256 Training (75%) and Testing (25%) images.\n\nGive your Dataset a name,`dolphins-and-seahorses`, and click **Create**.\n\n![New Image Classification Dataset](images/new-image-classification-dataset.png?raw=true \"New Image Classification Dataset\")\n\nThis will create our dataset, which took only 4s on my laptop.  In the end I\nhave 92 Training images (49 dolphin, 43 seahorse) in 2 categories, with 30\nValidation images (16 dolphin, 14 seahorse).  It’s a really small dataset, but perfect\nfor our experimentation and learning purposes, because it won’t take forever to train\nand validate a network that uses it. \n\nYou can **Explore the db** if you want to see the images after they have been squashed. \n\n![Explore the db](images/explore-dataset.png?raw=true \"Explore the db\")\n\n### Training: Attempt 1, from Scratch\n\nBack in the DIGITS Home screen, we need to create a new **Classification Model**:\n\n![Create Classification Model](images/create-classification-model.png?raw=true \"Create Classification Model\")\n\nWe’ll start by training a model that uses our `dolphins-and-seahorses` dataset,\nand the default settings DIGITS provides.  For our first network, we’ll choose to\nuse one of the standard network architectures, [AlexNet (pdf)](http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf). [AlexNet’s design](http://vision.stanford.edu/teaching/cs231b_spring1415/slides/alexnet_tugce_kyunghee.pdf)\nwon a major computer vision competition called ImageNet in 2012.  The competition\nrequired categorizing 1000+ image categories across 1.2 million images.\n \n![New Classification Model 1](images/new-image-classification-model-attempt1.png?raw=true \"Model 1\")\n\nCaffe uses structured text files to define network architectures.  These text files\nare based on [Google’s Protocol Buffers](https://developers.google.com/protocol-buffers/).\nYou can read the [full schema](https://github.com/BVLC/caffe/blob/master/src/caffe/proto/caffe.proto) Caffe uses.\nFor the most part we’re not going to work with these, but it’s good to be aware of their\nexistence, since we’ll have to modify them in later steps.  The AlexNet prototxt file\nlooks like this, for example: https://github.com/BVLC/caffe/blob/master/models/bvlc_alexnet/train_val.prototxt. \n\nWe’ll train our network for **30 epochs**, which means that it will learn (with our\ntraining images) then test itself (using our validation images), and adjust the\nnetwork’s weights depending on how well it’s doing, and repeat this process 30 times.\nEach time it completes a cycle we’ll get info about **Accuracy** (0% to 100%,\nwhere higher is better) and what our **Loss** is (the sum of all the mistakes that were\nmade, where lower is better).  Ideally we want a network that is able to predict with\nhigh accuracy, and with few errors (small loss).\n\n**NOTE:** some people have [reported hitting errors in DIGITS](https://github.com/humphd/have-fun-with-machine-learning/issues/17)\ndoing this training run. For many, the problem related to available memory (the process\nneeds a lot of memory to work).  If you're using Docker, you might want to try\nincreasing the amount of memory available to DIGITS (in Docker, preferences -> advanced -> memory).\n\nInitially, our network’s accuracy is a bit below 50%.  This makes sense, because at first it’s\njust “guessing” between two categories using randomly assigned weights.  Over time\nit’s able to achieve 87.5% accuracy, with a loss of 0.37.  The entire 30 epoch run\ntook me just under 6 minutes.\n\n![Model Attempt 1](images/model-attempt1.png?raw=true \"Model Attempt 1\")\n\nWe can test our model using an image we upload or a URL to an image on the web.\nLet’s test it on a few examples that weren’t in our training/validation dataset:\n\n![Model 1 Classify 1](images/model-attempt1-classify1.png?raw=true \"Model 1 Classify 1\")\n\n![Model 1 Classify 2](images/model-attempt1-classify2.png?raw=true \"Model 1 Classify 2\")\n\nIt almost seems perfect, until we try another:\n\n![Model 1 Classify 3](images/model-attempt1-classify3.png?raw=true \"Model 1 Classify 3\")\n\nHere it falls down completely, and confuses a seahorse for a dolphin, and worse,\ndoes so with a high degree of confidence.\n\nThe reality is that our dataset is too small to be useful for training a really good\nneural network.  We really need 10s or 100s of thousands of images, and with that, a\nlot of computing power to process everything.\n\n### Training: Attempt 2, Fine Tuning AlexNet\n\n#### How Fine Tuning works\n\nDesigning a neural network from scratch, collecting data sufficient to train\nit (e.g., millions of images), and accessing GPUs for weeks to complete the\ntraining is beyond the reach of most of us.  To make it practical for smaller amounts\nof data to be used, we employ a technique called **Transfer Learning**, or **Fine Tuning**.\nFine tuning takes advantage of the layout of deep neural networks, and uses\npretrained networks to do the hard work of initial object detection.\n\nImagine using a neural network to be like looking at something far away with a \npair of binoculars.  You first put the binoculars to your eyes, and everything is\nblurry.  As you adjust the focus, you start to see colours, lines, shapes, and eventually\nyou are able to pick out the shape of a bird, then with some more adjustment you can\nidentify the species of bird.\n\nIn a multi-layered network, the initial layers extract features (e.g., edges), with\nlater layers using these features to detect shapes (e.g., a wheel, an eye), which are\nthen feed into final classification layers that detect items based on accumulated \ncharacteristics from previous layers (e.g., a cat vs. a dog).  A network has to be \nable to go from pixels to circles to eyes to two eyes placed in a particular orientation, \nand so on up to being able to finally conclude that an image depicts a cat.\n\nWhat we’d like to do is to specialize an existing, pretrained network for classifying \na new set of image classes instead of the ones on which it was initially trained. Because\nthe network already knows how to “see” features in images, we’d like to retrain \nit to “see” our particular image types.  We don’t need to start from scratch with the \nmajority of the layers--we want to transfer the learning already done in these layers \nto our new classification task.  Unlike our previous attempt, which used random weights, \nwe’ll use the existing weights of the final network in our training.  However, we’ll \nthrow away the final classification layer(s) and retrain the network with *our* image \ndataset, fine tuning it to our image classes.\n\nFor this to work, we need a pretrained network that is similar enough to our own data\nthat the learned weights will be useful.  Luckily, the networks we’ll use below were \ntrained on millions of natural images from [ImageNet](http://image-net.org/), which \nis useful across a broad range of classification tasks.\n\nThis technique has been used to do interesting things like screening for eye diseases \nfrom medical imagery, identifying plankton species from microscopic images collected at \nsea, to categorizing the artistic style of Flickr images.\n\nDoing this perfectly, like all of machine learning, requires you to understand the\ndata and network architecture--you have to be careful with overfitting of the data, \nmight need to fix some of the layers, might need to insert new layers, etc. However,\nmy experience is that it “Just Works” much of the time, and it’s worth you simply doing\nan experiment to see what you can achieve using our naive approach.\n\n#### Uploading Pretrained Networks\n\nIn our first attempt, we used AlexNet’s architecture, but started with random\nweights in the network’s layers.  What we’d like to do is download and use a\nversion of AlexNet that has already been trained on a massive dataset.\n\nThankfully we can do exactly this.  A snapshot of AlexNet is available for download: https://github.com/BVLC/caffe/tree/master/models/bvlc_alexnet.\nWe need the binary `.caffemodel` file, which is what contains the trained weights, and it’s\navailable for download at http://dl.caffe.berkeleyvision.org/bvlc_alexnet.caffemodel.\n\nWhile you’re downloading pretrained models, let’s get one more at the same time.\nIn 2014, Google won the same ImageNet competition with [GoogLeNet](https://research.google.com/pubs/pub43022.html) (codenamed Inception):\na 22-layer neural network. A snapshot of GoogLeNet is available for download\nas well, see https://github.com/BVLC/caffe/tree/master/models/bvlc_googlenet.\nAgain, we’ll need the `.caffemodel` file with all the pretrained weights,\nwhich is available for download at http://dl.caffe.berkeleyvision.org/bvlc_googlenet.caffemodel. \n\nWith these `.caffemodel` files in hand, we can upload them into DIGITs.  Go to\nthe **Pretrained Models** tab in DIGITs home page and choose **Upload Pretrained Model**:\n\n![Load Pretrained Model](images/load-pretrained-model.png?raw=true \"Load Pretrained Model\")\n\nFor both of these pretrained models, we can use the defaults DIGITs provides\n(i.e., colour, squashed images of 256 x 256).  We just need to provide the \n`Weights (**.caffemodel)` and `Model Definition (original.prototxt)`.\nClick each of those buttons to select a file.\n\nFor the model definitions we can use https://github.com/BVLC/caffe/blob/master/models/bvlc_googlenet/train_val.prototxt\nfor GoogLeNet and https://github.com/BVLC/caffe/blob/master/models/bvlc_alexnet/train_val.prototxt\nfor AlexNet.  We aren’t going to use the classification labels of these networks,\nso we’ll skip adding a `labels.txt` file:\n \n![Upload Pretrained Model](images/upload-pretrained-model.png?raw=true \"Upload Pretrained Model\")\n\nRepeat this process for both AlexNet and GoogLeNet, as we’ll use them both in the coming steps.\n\n> Q: \"Are there other networks that would be good as a basis for fine tuning?\"\n\nThe [Caffe Model Zoo](http://caffe.berkeleyvision.org/model_zoo.html) has quite a few other\npretrained networks that could be used, see https://github.com/BVLC/caffe/wiki/Model-Zoo.\n\n#### Fine Tuning AlexNet for Dolphins and Seahorses\n\nTraining a network using a pretrained Caffe Model is similar to starting from scratch,\nthough we have to make a few adjustments.  First, we’ll adjust the **Base Learning Rate**\nto 0.001 from 0.01, since we don’t need to make such large jumps (i.e., we’re fine tuning).\nWe’ll also use a **Pretrained Network**, and **Customize** it.\n\n![New Image Classification](images/new-image-classification-model-attempt2.png?raw=true \"New Image Classification\")\n\nIn the pretrained model’s definition (i.e., prototext), we need to rename all\nreferences to the final **Fully Connected Layer** (where the end result classifications\nhappen).  We do this because we want the model to re-learn new categories from\nour dataset vs. its original training data (i.e., we want to throw away the current\nfinal layer).  We have to rename the last fully connected layer from “fc8” to\nsomething else, “fc9” for example.  Finally, we also need to adjust the number\nof categories from `1000` to `2`, by changing `num_output` to `2`.\n\nHere are the changes we need to make:\n\n```diff\n@@ -332,8 +332,8 @@\n }\n layer {\n-  name: \"fc8\"\n+  name: \"fc9\"\n   type: \"InnerProduct\"\n   bottom: \"fc7\"\n-  top: \"fc8\"\n+  top: \"fc9\"\n   param {\n     lr_mult: 1\n@@ -345,5 +345,5 @@\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"gaussian\"\n@@ -359,5 +359,5 @@\n   name: \"accuracy\"\n   type: \"Accuracy\"\n-  bottom: \"fc8\"\n+  bottom: \"fc9\"\n   bottom: \"label\"\n   top: \"accuracy\"\n@@ -367,5 +367,5 @@\n   name: \"loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"fc8\"\n+  bottom: \"fc9\"\n   bottom: \"label\"\n   top: \"loss\"\n@@ -375,5 +375,5 @@\n   name: \"softmax\"\n   type: \"Softmax\"\n-  bottom: \"fc8\"\n+  bottom: \"fc9\"\n   top: \"softmax\"\n   include { stage: \"deploy\" }\n```\n\nI’ve included the fully modified file I’m using in [src/alexnet-customized.prototxt](src/alexnet-customized.prototxt).\n\nThis time our accuracy starts at ~60% and climbs right away to 87.5%, then to 96%\nand all the way up to 100%, with the Loss steadily decreasing. After 5 minutes we\nend up with an accuracy of 100% and a loss of 0.0009.\n\n![Model Attempt 2](images/model-attempt2.png?raw=true \"Model Attempt 2\")\n\nTesting the same seahorse image our previous network got wrong, we see a complete\nreversal: 100% seahorse.\n\n![Model 2 Classify 1](images/model-attempt2-classify1.png?raw=true \"Model 2 Classify 1\")\n\nEven a children’s drawing of a seahorse works:\n\n![Model 2 Classify 2](images/model-attempt2-classify2.png?raw=true \"Model 2 Classify 2\")\n\nThe same goes for a dolphin:\n\n![Model 2 Classify 3](images/model-attempt2-classify3.png?raw=true \"Model 2 Classify 3\")\n\nEven with images that you think might be hard, like this one that has multiple dolphins\nclose together, and with their bodies mostly underwater, it does the right thing:\n\n![Model 2 Classify 4](images/model-attempt2-classify4.png?raw=true \"Model 2 Classify 4\")\n\n### Training: Attempt 3, Fine Tuning GoogLeNet\n\nLike the previous AlexNet model we used for fine tuning, we can use GoogLeNet as well.\nModifying the network is a bit trickier, since you have to redefine three fully\nconnected layers instead of just one.\n\nTo fine tune GoogLeNet for our use case, we need to once again create a\nnew **Classification Model**:\n\n![New Classification Model](images/new-image-classification-model-attempt3.png?raw=true \"New Classification Model\")\n\nWe rename all references to the three fully connected classification layers,\n`loss1/classifier`, `loss2/classifier`, and `loss3/classifier`, and redefine\nthe number of categories (`num_output: 2`).  Here are the changes we need to make\nin order to rename the 3 classifier layers, as well as to change from 1000 to 2 categories:\n\n```diff\n@@ -917,10 +917,10 @@\n   exclude { stage: \"deploy\" }\n }\n layer {\n-  name: \"loss1/classifier\"\n+  name: \"loss1a/classifier\"\n   type: \"InnerProduct\"\n   bottom: \"loss1/fc\"\n-  top: \"loss1/classifier\"\n+  top: \"loss1a/classifier\"\n   param {\n     lr_mult: 1\n     decay_mult: 1\n@@ -930,7 +930,7 @@\n     decay_mult: 0\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"xavier\"\n       std: 0.0009765625\n@@ -945,7 +945,7 @@\n layer {\n   name: \"loss1/loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"loss1/classifier\"\n+  bottom: \"loss1a/classifier\"\n   bottom: \"label\"\n   top: \"loss1/loss\"\n   loss_weight: 0.3\n@@ -954,7 +954,7 @@\n layer {\n   name: \"loss1/top-1\"\n   type: \"Accuracy\"\n-  bottom: \"loss1/classifier\"\n+  bottom: \"loss1a/classifier\"\n   bottom: \"label\"\n   top: \"loss1/accuracy\"\n   include { stage: \"val\" }\n@@ -962,7 +962,7 @@\n layer {\n   name: \"loss1/top-5\"\n   type: \"Accuracy\"\n-  bottom: \"loss1/classifier\"\n+  bottom: \"loss1a/classifier\"\n   bottom: \"label\"\n   top: \"loss1/accuracy-top5\"\n   include { stage: \"val\" }\n@@ -1705,10 +1705,10 @@\n   exclude { stage: \"deploy\" }\n }\n layer {\n-  name: \"loss2/classifier\"\n+  name: \"loss2a/classifier\"\n   type: \"InnerProduct\"\n   bottom: \"loss2/fc\"\n-  top: \"loss2/classifier\"\n+  top: \"loss2a/classifier\"\n   param {\n     lr_mult: 1\n     decay_mult: 1\n@@ -1718,7 +1718,7 @@\n     decay_mult: 0\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"xavier\"\n       std: 0.0009765625\n@@ -1733,7 +1733,7 @@\n layer {\n   name: \"loss2/loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"loss2/classifier\"\n+  bottom: \"loss2a/classifier\"\n   bottom: \"label\"\n   top: \"loss2/loss\"\n   loss_weight: 0.3\n@@ -1742,7 +1742,7 @@\n layer {\n   name: \"loss2/top-1\"\n   type: \"Accuracy\"\n-  bottom: \"loss2/classifier\"\n+  bottom: \"loss2a/classifier\"\n   bottom: \"label\"\n   top: \"loss2/accuracy\"\n   include { stage: \"val\" }\n@@ -1750,7 +1750,7 @@\n layer {\n   name: \"loss2/top-5\"\n   type: \"Accuracy\"\n-  bottom: \"loss2/classifier\"\n+  bottom: \"loss2a/classifier\"\n   bottom: \"label\"\n   top: \"loss2/accuracy-top5\"\n   include { stage: \"val\" }\n@@ -2435,10 +2435,10 @@\n   }\n }\n layer {\n-  name: \"loss3/classifier\"\n+  name: \"loss3a/classifier\"\n   type: \"InnerProduct\"\n   bottom: \"pool5/7x7_s1\"\n-  top: \"loss3/classifier\"\n+  top: \"loss3a/classifier\"\n   param {\n     lr_mult: 1\n     decay_mult: 1\n@@ -2448,7 +2448,7 @@\n     decay_mult: 0\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"xavier\"\n     }\n@@ -2461,7 +2461,7 @@\n layer {\n   name: \"loss3/loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   bottom: \"label\"\n   top: \"loss\"\n   loss_weight: 1\n@@ -2470,7 +2470,7 @@\n layer {\n   name: \"loss3/top-1\"\n   type: \"Accuracy\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   bottom: \"label\"\n   top: \"accuracy\"\n   include { stage: \"val\" }\n@@ -2478,7 +2478,7 @@\n layer {\n   name: \"loss3/top-5\"\n   type: \"Accuracy\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   bottom: \"label\"\n   top: \"accuracy-top5\"\n   include { stage: \"val\" }\n@@ -2489,7 +2489,7 @@\n layer {\n   name: \"softmax\"\n   type: \"Softmax\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   top: \"softmax\"\n   include { stage: \"deploy\" }\n }\n```\n\nI’ve put the complete file in [src/googlenet-customized.prototxt](src/googlenet-customized.prototxt).\n\n> Q: \"What about changes to the prototext definitions of these networks?\n> We changed the fully connected layer name(s), and the number of categories.\n> What else could, or should be changed, and in what circumstances?\"\n\nGreat question, and it's something I'm wondering, too.  For example, I know that we can\n[\"fix\" certain layers](https://github.com/BVLC/caffe/wiki/Fine-Tuning-or-Training-Certain-Layers-Exclusively)\nso the weights don't change.  Doing other things involves understanding how the layers work,\nwhich is beyond this guide, and also beyond its author at present!\n\nLike we did with fine tuning AlexNet, we also reduce the learning rate by\n10% from `0.01` to `0.001`.\n\n> Q: \"What other changes would make sense when fine tuning these networks?\n> What about different numbers of epochs, batch sizes, solver types (Adam, AdaDelta, AdaGrad, etc),\n> learning rates, policies (Exponential Decay, Inverse Decay, Sigmoid Decay, etc),\n> step sizes, and gamma values?\"\n\nGreat question, and one that I wonder about as well.  I only have a vague understanding of these\nand it’s likely that there are improvements we can make if you know how to alter these\nvalues when training.  This is something that needs better documentation.\n\nBecause GoogLeNet has a more complicated architecture than AlexNet, fine tuning it requires\nmore time.  On my laptop, it takes 10 minutes to retrain GoogLeNet with our dataset,\nachieving 100% accuracy and a loss of 0.0070:\n\n![Model Attempt 3](images/model-attempt3.png?raw=true \"Model Attempt 3\")\n\nJust as we saw with the fine tuned version of AlexNet, our modified GoogLeNet\nperforms amazing well--the best so far:\n\n![Model Attempt 3 Classify 1](images/model-attempt3-classify1.png?raw=true \"Model Attempt 3 Classify 1\")\n\n![Model Attempt 3 Classify 2](images/model-attempt3-classify2.png?raw=true \"Model Attempt 3 Classify 2\")\n\n![Model Attempt 3 Classify 3](images/model-attempt3-classify3.png?raw=true \"Model Attempt 3 Classify 3\")\n\n## Using our Model\n\nWith our network trained and tested, it’s time to download and use it.  Each of the models\nwe trained in DIGITS has a **Download Model** button, as well as a way to select different\nsnapshots within our training run (e.g., `Epoch #30`):\n\n![Trained Models](images/trained-models.png?raw=true \"Trained Models\")\n\nClicking **Download Model** downloads a `tar.gz` archive containing the following files:\n\n```\ndeploy.prototxt\nmean.binaryproto\nsolver.prototxt\ninfo.json\noriginal.prototxt\nlabels.txt\nsnapshot_iter_90.caffemodel\ntrain_val.prototxt\n```\n\nThere’s a [nice description](https://github.com/BVLC/caffe/wiki/Using-a-Trained-Network:-Deploy) in\nthe Caffe documentation about how to use the model we just built.  It says:\n\n> A network is defined by its design (.prototxt), and its weights (.caffemodel). As a network is\n> being trained, the current state of that network's weights are stored in a .caffemodel. With both\n> of these we can move from the train/test phase into the production phase.\n>\n> In its current state, the design of the network is not designed for deployment. Before we can\n> release our network as a product, we often need to alter it in a few ways:\n>\n> 1. Remove the data layer that was used for training, as for in the case of classification we are no longer providing labels for our data.\n> 2. Remove any layer that is dependent upon data labels.\n> 3. Set the network up to accept data.\n> 4. Have the network output the result.\n\nDIGITS has already done the work for us, separating out the different versions of our `prototxt` files.\nThe files we’ll care about when using this network are:\n\n* `deploy.prototxt` - the definition of our network, ready for accepting image input data\n* `mean.binaryproto` - our model will need us to subtract the image mean from each image that it processes, and this is the mean image.\n* `labels.txt` - a list of our labels (`dolphin`, `seahorse`) in case we want to print them vs. just the category number\n* `snapshot_iter_90.caffemodel` - these are the trained weights for our network\n\nWe can use these files in a number of ways to classify new images.  For example, in our\n`CAFFE_ROOT` we can use `build/examples/cpp_classification/classification.bin` to classify one image:\n\n```bash\n$ cd $CAFFE_ROOT/build/examples/cpp_classification\n$ ./classification.bin deploy.prototxt snapshot_iter_90.caffemodel mean.binaryproto labels.txt dolphin1.jpg\n```\n\nThis will spit out a bunch of debug text, followed by the predictions for each of our two categories:\n\n```\n0.9997 - “dolphin”\n0.0003 - “seahorse”\n```\n\nYou can read the [complete C++ source](https://github.com/BVLC/caffe/tree/master/examples/cpp_classification)\nfor this in the [Caffe examples](https://github.com/BVLC/caffe/tree/master/examples).\n\nFor a classification version that uses the Python interface, DIGITS includes a [nice example](https://github.com/NVIDIA/DIGITS/tree/master/examples/classification).  There's also a fairly\n[well documented Python walkthrough](https://github.com/BVLC/caffe/blob/master/examples/00-classification.ipynb) in the Caffe examples.\n\n### Python example\n\nLet's write a program that uses our fine-tuned GoogLeNet model to classify the untrained images\nwe have in [data/untrained-samples](data/untrained-samples).  I've cobbled this together based on\nthe examples above, as well as the `caffe` [Python module's source](https://github.com/BVLC/caffe/tree/master/python),\nwhich you should prefer to anything I'm about to say.\n\nA full version of what I'm going to discuss is available in [src/classify-samples.py](src/classify-samples.py).\nLet's begin!\n\nFirst, we'll need the [NumPy](http://www.numpy.org/) module.  In a moment we'll be using [NumPy](http://www.numpy.org/)\nto work with [`ndarray`s](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html), which Caffe uses a lot.\nIf you haven't used them before, as I had not, you'd do well to begin by reading this\n[Quickstart tutorial](https://docs.scipy.org/doc/numpy-dev/user/quickstart.html).\n\nSecond, we'll need to load the `caffe` module from our `CAFFE_ROOT` dir.  If it's not already included\nin your Python environment, you can force it to load by adding it manually. Along with it we'll\nalso import caffe's protobuf module:\n\n```python\nimport numpy as np\n\ncaffe_root = '/path/to/your/caffe_root'\nsys.path.insert(0, os.path.join(caffe_root, 'python'))\nimport caffe\nfrom caffe.proto import caffe_pb2\n```\n\nNext we need to tell Caffe whether to [use the CPU or GPU](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/_caffe.cpp#L50-L52).\nFor our experiments, the CPU is fine:\n\n```python\ncaffe.set_mode_cpu()\n```\n\nNow we can use `caffe` to load our trained network.  To do so, we'll need some of the files we downloaded\nfrom DIGITS, namely:\n\n* `deploy.prototxt` - our \"network file\", the description of the network.\n* `snapshot_iter_90.caffemodel` - our trained \"weights\"\n\nWe obviously need to provide the full path, and I'll assume that my files are in a dir called `model/`:\n\n```python\nmodel_dir = 'model'\ndeploy_file = os.path.join(model_dir, 'deploy.prototxt')\nweights_file = os.path.join(model_dir, 'snapshot_iter_90.caffemodel')\nnet = caffe.Net(deploy_file, caffe.TEST, weights=weights_file)\n```\n\nThe `caffe.Net()` [constructor](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/_caffe.cpp#L91-L117)\ntakes a network file, a phase (`caffe.TEST` or `caffe.TRAIN`), as well as an optional weights filename.  When\nwe provide a weights file, the `Net` will automatically load them for us. The `Net` has a number of\n[methods and attributes](https://github.com/BVLC/caffe/blob/master/python/caffe/pycaffe.py) you can use.\n\n**Note:** There is also a [deprecated version of this constructor](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/_caffe.cpp#L119-L134),\nwhich seems to get used often in sample code on the web. It looks like this, in case you encounter it:\n\n```python\nnet = caffe.Net(str(deploy_file), str(model_file), caffe.TEST)\n```\n\nWe're interested in loading images of various sizes into our network for testing. As a result,\nwe'll need to *transform* them into a shape that our network can use (i.e., colour, 256x256).\nCaffe provides the [`Transformer` class](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L98)\nfor this purpose.  We'll use it to create a transformation appropriate for our images/network:\n\n```python\ntransformer = caffe.io.Transformer({'data': net.blobs['data'].data.shape})\n# set_transpose: https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L187\ntransformer.set_transpose('data', (2, 0, 1))\n# set_raw_scale: https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L221\ntransformer.set_raw_scale('data', 255)\n# set_channel_swap: https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L203\ntransformer.set_channel_swap('data', (2, 1, 0))\n```\n\nWe can also use the `mean.binaryproto` file DIGITS gave us to set our transformer's mean:\n\n```python\n# This code for setting the mean from https://github.com/NVIDIA/DIGITS/tree/master/examples/classification\nmean_file = os.path.join(model_dir, 'mean.binaryproto')\nwith open(mean_file, 'rb') as infile:\n    blob = caffe_pb2.BlobProto()\n    blob.MergeFromString(infile.read())\n    if blob.HasField('shape'):\n        blob_dims = blob.shape\n        assert len(blob_dims) == 4, 'Shape should have 4 dimensions - shape is %s' % blob.shape\n    elif blob.HasField('num') and blob.HasField('channels') and \\\n            blob.HasField('height') and blob.HasField('width'):\n        blob_dims = (blob.num, blob.channels, blob.height, blob.width)\n    else:\n        raise ValueError('blob does not provide shape or 4d dimensions')\n    pixel = np.reshape(blob.data, blob_dims[1:]).mean(1).mean(1)\n    transformer.set_mean('data', pixel)\n```\n\nIf we had a lot of labels, we might also choose to read in our labels file, which we can use\nlater by looking up the label for a probability using its position (e.g., 0=dolphin, 1=seahorse):\n\n```python\nlabels_file = os.path.join(model_dir, 'labels.txt')\nlabels = np.loadtxt(labels_file, str, delimiter='\\n')\n``` \n\nNow we're ready to classify an image.  We'll use [`caffe.io.load_image()`](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L279)\nto read our image file, then use our transformer to reshape it and set it as our network's data layer:\n\n```python\n# Load the image from disk using caffe's built-in I/O module\nimage = caffe.io.load_image(fullpath)\n# Preprocess the image into the proper format for feeding into the model\nnet.blobs['data'].data[...] = transformer.preprocess('data', image)\n```\n\n> Q: \"How could I use images (i.e., frames) from a camera or video stream instead of files?\"\n\nGreat question, here's a skeleton to get you started:\n\n```python\nimport cv2\n...\n# Get the shape of our input data layer, so we can resize the image\ninput_shape = net.blobs['data'].data.shape\n...\nwebCamCap = cv2.VideoCapture(0) # could also be a URL, filename\nif webCamCap.isOpened():\n    rval, frame = webCamCap.read()\nelse:\n    rval = False\n\nwhile rval:\n    rval, frame = webCamCap.read()\n    net.blobs['data'].data[...] = transformer.preprocess('data', frame)\n    ...\n\nwebCamCap.release()\n```\n\nBack to our problem, we next need to run the image data through our network and read out\nthe probabilities from our network's final `'softmax'` layer, which will be in order by label category:\n\n```python\n# Run the image's pixel data through the network\nout = net.forward()\n# Extract the probabilities of our two categories from the final layer\nsoftmax_layer = out['softmax']\n# Here we're converting to Python types from ndarray floats\ndolphin_prob = softmax_layer.item(0)\nseahorse_prob = softmax_layer.item(1)\n\n# Print the results. I'm using labels just to show how it's done\nlabel = labels[0] if dolphin_prob > seahorse_prob else labels[1]\nfilename = os.path.basename(fullpath)\nprint '%s is a %s dolphin=%.3f%% seahorse=%.3f%%' % (filename, label, dolphin_prob*100, seahorse_prob*100)\n```\n\nRunning the full version of this (see [src/classify-samples.py](src/classify-samples.py)) using our\nfine-tuned GoogLeNet network on our [data/untrained-samples](data/untrained-samples) images gives\nme the following output:\n\n```\n[...truncated caffe network output...]\ndolphin1.jpg is a dolphin dolphin=99.968% seahorse=0.032%\ndolphin2.jpg is a dolphin dolphin=99.997% seahorse=0.003%\ndolphin3.jpg is a dolphin dolphin=99.943% seahorse=0.057%\nseahorse1.jpg is a seahorse dolphin=0.365% seahorse=99.635%\nseahorse2.jpg is a seahorse dolphin=0.000% seahorse=100.000%\nseahorse3.jpg is a seahorse dolphin=0.014% seahorse=99.986%\n```\n\nI'm still trying to learn all the best practices for working with models in code. I wish I had more\nand better documented code examples, APIs, premade modules, etc to show you here. To be honest,\nmost of the code examples I’ve found are terse, and poorly documented--Caffe’s\ndocumentation is spotty, and assumes a lot.\n\nIt seems to me like there’s an opportunity for someone to build higher-level tools on top of the\nCaffe interfaces for beginners and basic workflows like we've done here.  It would be great if\nthere were more simple modules in high-level languages that I could point you at that “did the\nright thing” with our model; someone could/should take this on, and make *using* Caffe\nmodels as easy as DIGITS makes *training* them.  I’d love to have something I could use in node.js,\nfor example.  Ideally one shouldn’t be required to know so much about the internals of the model or Caffe.\nI haven’t used it yet, but [DeepDetect](https://deepdetect.com/) looks interesting on this front,\nand there are likely many other tools I don’t know about.\n\n## Results\n\nAt the beginning we said that our goal was to write a program that used a neural network to\ncorrectly classify all of the images in [data/untrained-samples](data/untrained-samples).\nThese are images of dolphins and seahorses that were never used in the training or validation\ndata:\n\n### Untrained Dolphin Images\n\n![Dolphin 1](data/untrained-samples/dolphin1.jpg?raw=true \"Dolphin 1\")\n![Dolphin 2](data/untrained-samples/dolphin2.jpg?raw=true \"Dolphin 2\")\n![Dolphin 3](data/untrained-samples/dolphin3.jpg?raw=true \"Dolphin 3\")\n\n### Untrained Seahorse Images\n\n![Seahorse 1](data/untrained-samples/seahorse1.jpg?raw=true \"Seahorse 1\")\n![Seahorse 2](data/untrained-samples/seahorse2.jpg?raw=true \"Seahorse 2\")\n![Seahorse 3](data/untrained-samples/seahorse3.jpg?raw=true \"Seahorse 3\")\n\nLet's look at how each of our three attempts did with this challenge:\n\n### Model Attempt 1: AlexNet from Scratch (3rd Place)\n\n| Image | Dolphin | Seahorse | Result | \n|-------|---------|----------|--------|\n|[dolphin1.jpg](data/untrained-samples/dolphin1.jpg)| 71.11% | 28.89% | :expressionless: |\n|[dolphin2.jpg](data/untrained-samples/dolphin2.jpg)| 99.2% | 0.8% | :sunglasses: |\n|[dolphin3.jpg](data/untrained-samples/dolphin3.jpg)| 63.3% | 36.7% | :confused: |\n|[seahorse1.jpg](data/untrained-samples/seahorse1.jpg)| 95.04% | 4.96% | :disappointed: |\n|[seahorse2.jpg](data/untrained-samples/seahorse2.jpg)| 56.64% | 43.36 |  :confused: |\n|[seahorse3.jpg](data/untrained-samples/seahorse3.jpg)| 7.06% | 92.94% |  :grin: |\n\n### Model Attempt 2: Fine Tuned AlexNet (2nd Place)\n\n| Image | Dolphin | Seahorse | Result | \n|-------|---------|----------|--------|\n|[dolphin1.jpg](data/untrained-samples/dolphin1.jpg)| 99.1% | 0.09% |  :sunglasses: |\n|[dolphin2.jpg](data/untrained-samples/dolphin2.jpg)| 99.5% | 0.05% |  :sunglasses: |\n|[dolphin3.jpg](data/untrained-samples/dolphin3.jpg)| 91.48% | 8.52% |  :grin: |\n|[seahorse1.jpg](data/untrained-samples/seahorse1.jpg)| 0% | 100% |  :sunglasses: |\n|[seahorse2.jpg](data/untrained-samples/seahorse2.jpg)| 0% | 100% |  :sunglasses: |\n|[seahorse3.jpg](data/untrained-samples/seahorse3.jpg)| 0% | 100% |  :sunglasses: |\n\n### Model Attempt 3: Fine Tuned GoogLeNet (1st Place)\n\n| Image | Dolphin | Seahorse | Result | \n|-------|---------|----------|--------|\n|[dolphin1.jpg](data/untrained-samples/dolphin1.jpg)| 99.86% | 0.14% |  :sunglasses: |\n|[dolphin2.jpg](data/untrained-samples/dolphin2.jpg)| 100% | 0% |  :sunglasses: |\n|[dolphin3.jpg](data/untrained-samples/dolphin3.jpg)| 100% | 0% |  :sunglasses: |\n|[seahorse1.jpg](data/untrained-samples/seahorse1.jpg)| 0.5% | 99.5% |  :sunglasses: |\n|[seahorse2.jpg](data/untrained-samples/seahorse2.jpg)| 0% | 100% |  :sunglasses: |\n|[seahorse3.jpg](data/untrained-samples/seahorse3.jpg)| 0.02% | 99.98% |  :sunglasses: |\n\n## Conclusion\n\nIt’s amazing how well our model works, and what’s possible by fine tuning a pretrained network.\nObviously our dolphin vs. seahorse example is contrived, and the dataset overly limited--we really\ndo want more and better data if we want our network to be robust.  But since our goal was to examine\nthe tools and workflows of neural networks, it’s turned out to be an ideal case, especially since it\ndidn’t require expensive equipment or massive amounts of time.\n\nAbove all I hope that this experience helps to remove the overwhelming fear of getting started.\nDeciding whether or not it’s worth investing time in learning the theories of machine learning and\nneural networks is easier when you’ve been able to see it work in a small way.  Now that you’ve got\na setup and a working approach, you can try doing other sorts of classifications.  You might also look\nat the other types of things you can do with Caffe and DIGITS, for example, finding objects within an\nimage, or doing segmentation.\n\nHave fun with machine learning!\n"
        },
        {
          "name": "README_ko-KR.md",
          "type": "blob",
          "size": 55.349609375,
          "content": "# Have Fun with Machine Learning: 초보자를 위한 가이드\n\n> Author: David Humphrey (original [English version](README.md))  \n> 한국어 번역：[zaysverse](https://github.com/zaysverse)\n\n\n  \n\n## 머리말\n\n이것은 인공지능에 대한 *배경지식이 없는* 프로그래머들을 위한 머신러닝 **실습 가이드**입니다. \n인공지능 신경망을 사용하는 것은 박사학위가 필요하지 않으며, 여러분은 크게 발전할 필요 없이\n이미 있는 것을 *사용*하면 됩니다. 지금 우리가 가지고 있는 것은 충분히 유용합니다. 저는 이것을 \n다른 오픈소스를 대하는 것처럼 더 많은 사람이 갖고 놀아야 한다고 생각합니다.   \n\n이 가이드에서 우리의 목표는 머신러닝을 이용하여 [데이터/훈련되지 않은 샘플들](data/untrained-samples)\n속 이미지가 **돌고래**인지 **해마**인지 이미지만으로 정확성 있게 예측하는 프로그램을 작성하는 것입니다.\n여기 우리가 사용할 두 가지 예제 사진들이 있습니다:\n\n![A dolphin](data/untrained-samples/dolphin1.jpg?raw=true \"Dolphin\")\n![A seahorse](data/untrained-samples/seahorse1.jpg?raw=true \"Seahorse\")\n\n그러기 위해 우리는 [나선형 신경망(CNN)](https://en.wikipedia.org/wiki/Convolutional_neural_network)\n을 훈련하고 사용할 것입니다. 우리는 이것을 실무자의 관점 또는 첫 번째 원리의 관점에서 접근할 것입니다.\n현재 인공지능에 많은 관심이 쏟아지고 있지만, 쓰인 대부분은 공원의 친구가 아니라 물리학교수가 자전거로\n트릭을 가르치는 것처럼 느껴집니다.\n\n저는 이것을 블로그 게시물처럼 깃허브 VS.에 작성하기로 했습니다. 제가 밑에 쓴 것 중 오해를 불러일으키거나\n부족하거나 혹은 완전히 잘못된 부분이 있을 수 있습니다. 저는 아직 배워가는 중이고, 견고한 초보자용 문서가 없는 것이\n장애물이라고 생각합니다. 실수가 있거나 중요한 세부사항이 누락된 것을 발견하셨다면, Pull request를 보내주십시오.\n\n소개가 끝났으니, 여러분에게 자전거 트릭을 몇 가지 보여드리겠습니다!\n\n## 개요\n\n지금부터 살펴볼 내용은 다음과 같습니다:\n\n* 특히 기존의 오픈 소스 머신러닝 기술을 설정하고 사용합니다.([Caffe](http://caffe.berkeleyvision.org/)와\n [DIGITS](https://developer.nvidia.com/digits))\n* 이미지 데이터셋을 만듭니다.\n* 신경망을 처음부터 훈련시킵니다.\n* 신경망이 겪은 적 없는 이미지로 신경망을 테스트합니다.\n* 기존 신경망을 하게 튜닝 -*fine Tuning*- 해 신경망의 정확성을 향상시킵니다. (AlexNet 와 GoogLeNet)\n* 신경망을 배포하고 사용합니다.\n\n이 가이드는 신경망이 어떻게 설계되는지, 많은 이론을 다루거나, 수학적 표현을 사용하는 법을\n가르쳐 주진 않습니다. 여러분에게 보여드릴 내용의 대부분을 이해한다고는 말하지 않겠습니다. \n대신 흥미로운 방식으로 기존의 것들을 사용해 어려운 문제를 해결해 나갈 것입니다.\n\n> Q: \"신경망의 이론에 관해서는 이야기하지 않는다고 말씀하셨습니다만, 앞으로 진행하기 전에\n>  적어도 목차(overview)가 필요하다고 생각합니다. 어디서부터 시작해야 할까요?\"\n\n이에 대한 소개는 짧은 게시물부터 온라인 전체 강좌까지 말 그대로 수백 가지가 넘습니다. 여러분이\n배우고 싶은 방법에 따라 좋은 출밤점을 위한 3가지 선택지가 있습니다:\n\n* 이 멋진 [블로그 게시물](https://jalammar.github.io/visual-interactive-guide-basics-neural-networks/) \n은 직관적인 예제들을 이용하여 신경망의 개념을 소개합니다.\n* 비슷하게, [브랜던 로러](https://www.youtube.com/channel/UCsBKTrp45lTfHa_p49I2AEQ)가 소개하는 \n[이 영상](https://www.youtube.com/watch?v=FmpDIaiMIeA) 은 우리가 사용하게 될 나선형 신경망에 대\n한 좋은 소개입니다.\n* 이론을 좀 더 알고 싶다면,  [마이클 닐슨](http://michaelnielsen.org/) 의 [온라인 책](http://neuralnetworksanddeeplearning.com/chap1.html) 을 추천합니다.\n\n## 설정\n\n사용할 소프트웨어(Caffe와 DIGITS)는 플랫폼 및 운영체제 버전에 따라 설치가 어려울 수 있습니다. 가장 쉬운 방법은 \n도커(Docker)를 사용하는 것입니다. 아래에서 도커(Docker)로 하는 방법과 기본으로 설치하는 방법을 살펴봅시다.\n\n### Option 1a: 네이티브하게 Caffe 설치\n\n먼저, 우리는 버클리 비전 및 학습 센터의 [Caffe 딥러닝 프레임워크](http://caffe.berkeleyvision.org/)\n를 사용할 것입니다. (BSD 라이센스)\n\n> Q: “잠깐만요, 왜 Caffe죠? Tensorflow와 같은 것을 사용하는 것은 어떨까요?\n> 요즘 모두가 말하는 것이잖아요...”  \n\n좋은 선택지가 많이 있고, 여러분은 모든 선택지를 살펴봐야 합니다. [TensorFlow](https://www.tensorflow.org/)는\n훌륭하고 여러분은 TensorFlow를 사용해도 좋습니다. 하지만 전 여러 가지 이유로 Caffe를 사용하고 있습니다:\n\n* 컴퓨터 비전 문제에 적격입니다. \n* C++과 phyhon을 지원합니다.([node.js 지원](https://github.com/silklabs/node-caffe) 예정)\n* 빠르고 안정적입니다.\n\n하지만 제가 Caffe를 사용하는 **첫 번째 이유**는 **어떤 코드도 쓸 필요 없기** 때문입니다. 여러분은 선언과 커맨드라인\n도구로 모든 것을 할 수 있습니다. (Caffe는 구조화된 텍스트 파일을 사용하여 네트워크 아키텍처를 정의합니다) 또한, \n여러분은 여러분의 네트워크를 더 쉽게 훈련하고 검증하기 위해 Caffe의 좋은 프론트 엔드들을 사용할 수 있습니다. \n우리는 [nVidia의 DIGITS](https://developer.nvidia.com/digits) 도구를 이러한 목적으로 사용할 것입니다.\n\nCaffe는 설치하기에 힘들 수 있습니다. 미리 만들어진 Docker와 AWS 구성을 포함하여 다양한 플랫폼에 대한 [설치 지침](http://caffe.berkeleyvision.org/installation.html)이 있습니다.\n\n**NOTE:** 저는 Github repo에서 출시되지 않은 다음 버전의 Caffe를 사용했습니다:\nhttps://github.com/BVLC/caffe/commit/5a201dd960840c319cefd9fa9e2a40d2c76ddd73\n\nMac에서는 버전 문제로 인해 빌드 내의 여러 단계에서 진행이 중단되어 작업을 시작하는 것이 어려울 수\n있습니다. 이틀 동안 시행착오를 겪었습니다. 여러 가이드를 따라 해봤지만, 각각은 약간씩 다른 문제들을\n가지고 있었습니다. 그 중 [이 가이드](https://gist.github.com/doctorpangloss/f8463bddce2a91b949639522ea1dcbe4)가\n가장 가까웠습니다.\n또한, [이 게시물](https://eddiesmo.wordpress.com/2016/12/20/how-to-set-up-caffe-environment-and-pycaffe-on-os-x-10-12-sierra/)을 추천합니다. 최근에 제가 봤던 많은 토론과 연결되어 있습니다.  \n\nCaffe 설치는 저희가 할 것 중 가장 어려운 일입니다. 꽤 멋진 일이죠. AI쪽은 더 어려울 거라고 생각하셨을 테니까요!\n몇 가지 문제를 겪으시더라도 포기하지 마세요. 그것은 그럴 가치가 있습니다. 만약 제가 이 작업을 다시 수행한다면, Mac에서 직접 수행하지 않고 Ubuntu VM을 사용할 것입니다. 도움이 더 필요하시다면, [Caffe 사용자](https://groups.google.com/forum/#!forum/caffe-users)그룹도 존재합니다.\n\n> Q: “신경망을 훈련시키려면 강력한 장비가 필요할까요? 좋은 GPU에 접근할 수 \n> 없다면 어떻게 해야 할까요?\"\n\n사실 심층 신경망은 훈련시키기 위한 많은 연산능력과 에너지를 필요로 합니다.. 대규모 데이터셋을 이용해 처음부터 훈련시키는 경우라면 말입니다.\n우리는 그렇게 하지 않을 거예요. 비결은 다른 사람이 이미 수백 시간에 걸쳐 훈련시켜논 사전 훈련된 신경망을 사용하여, 각자의 데이터셋에 맞게\n미세하게 조정하는 것 -*Fine Tuning*-입니다. 아래에서 이 작업을 어떻게 하는지 알아보겠지만, 제가 여러분에게 보여드릴 것은 최신 GPU가 탑재되지 않은 1년 \n된 맥북 프로를 사용하고 있습니다. \n\n이와는 별도로, 전 통합 인텔 그래픽 카드와 엔비디아 GPU를 가지고 있기 때문에 [OpenCL Caffe branch]\n(https://github.com/BVLC/caffe/tree/opencl)를 사용하기로 했고, 제 노트북에서 잘 작동했습니다. \n\nCaffe 설치가 완료되면 다음 작업을 수행하거나 수행해야 합니다:\n\n*  빌드된 caffe가 포함된 디렉터리입니다. 표준 방식으로 이 작업을 수행했다면, caffe, python 바인딩 등을 실행하는\n 데 필요한 모든 것이 `build/` 디렉터리에 있을 것입니다. `build/`의 상위 디렉터리는 `CAFFE_ROOT`(나중에 필요)입니다. \n* `make test && make runtest` 는 실행하지 마십시오.\n* 모든 python deps를 설치한 후(`python/`에서 `pip install -r requirements.txt` 실행), \n`make pycaffe && make pytest`는 실행하지 마십시오.\n* 또한 `distribute/` 안에 있는 모든 필수적인 헤더, 바이너리 등을 포함하는 배포 가능한 버전의 caffe를 생성하려면\n `make distribute`를 실행해야 합니다. \n\nCaffe가 완전히 빌드된 컴퓨터에서, CARRE_ROOT 디렉터리는 다음과 같은 기본 레이아웃을 따릅니다:\n\n```\ncaffe/\n    build/\n        python/\n        lib/\n        tools/\n            caffe ← 메인 바이너리입니다.\n    distribute/\n        python/\n        lib/\n        include/\n        bin/\n        proto/\n```\n\n이 시점에서 우리는 신경망으로 훈련, 테스트 및 프로그래밍하는 데 필요한 모든 것을 갖추고 있습니다. 다음 섹션에서는\n사용자 친화적인 웹 기반 프론트 엔드를 DIGITS라고 불리는 caffe에 추가하여 신경망을 훨씬 쉽게 교육하고 테스트할\n수 있습니다.\n\n### Option 1b: 네이티브하게 DIGITS 설치\n\nnVidia의 [딥러닝 GPU 훈련시스템(DIGITS)](https://github.com/NVIDIA/DIGITS)는 신경망 훈련을 위한\nBSD 라이선스의 python 웹 앱입니다. 커맨드 라인이나 코드로 DIGITS가 Caffe에서 하는 모든 작업을 실행할 수\n있지만, DIGITS를 사용하면 훨씬 쉽게 시작할 수 있습니다. 또한 뛰어난 시각화, 실시간 차트 및 기타 그래픽 기능들로\n인해 더 재미있을 것입니다.  배우기 위해선 경험을 쌓고 도전해봐야 하므로 DIGITS로 시작하는 것을 추천합니다. \n\nhttps://github.com/NVIDIA/DIGITS/tree/master/docs 에 \n[Installation](https://github.com/NVIDIA/DIGITS/blob/master/docs/BuildDigits.md)(설치),\n[Configuration](https://github.com/NVIDIA/DIGITS/blob/master/docs/Configuration.md)(구성),\n및 [Getting Started](https://github.com/NVIDIA/DIGITS/blob/master/docs/GettingStarted.md)\n(시작) 페이지들을 포함하는 좋은 문서들이 꽤 있습니다. 전 DIGITS의 모든 것들을 잘 아는 전문가가 아니기 때문에 계속하기\n전에 자세하게 읽어보는 걸 추천합니다. 도움이 더 필요하시다면,  공개 [DIGITS 사용자 그룹](https://groups.google.com/forum/#!forum/digits-users)\n도 있습니다.\n\nDocker부터 리눅스에서 패키지들을 pre-baked하거나 소스에서 빌드하기까지, DIGITS를 설치하고 실행하는 데에는 다양한\n방법이 있습니다. 저는 Mac을 사용하고 있음으로 소스에서 빌드했습니다.\n\n**NOTE:** 이 가이드에선 Github repo에서 출시되지 않은 DIGITS의 다음 버전을 사용했습니다 : https://github.com/NVIDIA/DIGITS/commit/81be5131821ade454eb47352477015d7c09753d9\n\npython 스크립트 묶음이기 때문에 작업하는 것은 힘들지 않았습니다. 여러분이 해야 할 것은 서버를\n시작하기 전에 환경 변수를 설정하여 `CAFFE_ROOT`의 위치를 DIGITS에 알려주는 것입니다:\n\n```bash\nexport CAFFE_ROOT=/path/to/caffe\n./digits-devserver\n```\n\nNOTE: Mac에서 파이썬 바이너리가 `pyhon2`라고 가정하고 서버 스크립트에 문제가 있었는데, 여기서 저는\n`python2.7`만 가지고 있었습니다. 이것은 `/usr/bin`에서 심볼릭링크로 접근하거나 DIGITS 부팅 시 \n스크립트를 조정하여 해결할 수 있습니다. 서버가 시작되면 http://localhost:5000 에 웹 브라우저를 \n통해 밑에서 다룰 모든 작업을 수행할 수 있습니다.\n\n### Option 2: Docker를 사용한 Caffe와 DIGITS \n\n[Docker](https://www.docker.com/)를 설치하고(설치되어 있지 않은 경우) 전체 Caffe + Digits \n컨테이너를 꺼내기 위해 다음 명령을 실행합니다. 몇 가지의 주의할 사항:\n* 포트 8080이 다른 프로그램에 할당되진 않았는지 확인하십시오. 만약 그렇다면, 임의의 다른 포트로\n 변경하십시오.\n* 이 복제(clone)된 repo의 위치를 `/path/to/this/repostiory`로 옮기십시오. 그러면 컨테이너\n 내의 `/data/repo`가 이 디렉터리에 바인딩됩니다. 이것은 아래 설명된 이미지에 접근하는 데\n 유용합니다. \n\n```bash\ndocker run --name digits -d -p 8080:5000 -v /path/to/this/repository:/data/repo kaixhin/digits\n```\n\n이제 컨테이너가 실행 중이므로 우리는 웹 브라우저를 열고 `http://localhost:8080`에 접근할 수 있습니다.\n이 repository의 모든 내용은 이제 컨테이너 디렉터리 `/data/repo`에 있습니다. 이제 다 했습니다. 이제 Caffe\n와 DIGITS가 실행되고 있습니다. \n셸에 접근이 필요한 경우, 다음 명령을 따라 하십시오:\n\n```bash\ndocker exec -it digits /bin/bash\n```\n\n## 신경망 훈련\n\n신경망을 훈련시키는 것은 몇 가지 단계를 수반합니다:\n\n1. 분류된 이미지의 데이터셋을 구성하고 준비하십시오\n2. 신경망의 아키텍처를 규정하십시오\n3. 준비된 데이터셋을 사용해 이 신경망을 훈련시키고 검증하십시오.\n\n처음부터 시작하는 것과 사전훈련된 신경망을 사용하는 것의 차이를 보여주고 Caffe와 DIGITs에서 흔히  \n사용되는 두 가지 인기 있는 사전훈련된 신경망(AlexNet, GoogLeNet)에서 어떻게 실행하는지 보여주기\n위해 우리는 이러한 3단계를 거칠 것입니다. \n\n우리는 훈련 시도에 돌고래와 해마의 작은 데이터셋을 사용할 것입니다. [data/dolphins-and-seahorses](data/dolphins-and-seahorses)에 제가 사용했던 이미지들을 넣어두었습니다. 2개 이상의 카테고리가 필요하고 여러분은 더\n많은 카테고리를 가질 수도 있습니다(사용할 신경망 중 일부는 1,000개 이상의 이미지 카테고리에 대해 \n훈련되었습니다). 우리의 목표는 우리의 신경망에 이미지를 주고 그것이 돌고래인지 해마인지 우리에게 \n알려주게 하는 것입니다.\n\n### 데이터셋 준비\n\n가장 쉬운 방법은 이미지들을 분류된 디렉터리 배치로 나누는 것입니다.:\n\n```\ndolphins-and-seahorses/\n    dolphin/\n        image_0001.jpg\n        image_0002.jpg\n        image_0003.jpg\n        ...\n    seahorse/\n        image_0001.jpg\n        image_0002.jpg\n        image_0003.jpg\n        ...\n```\n\n여기 각 디렉터리는 이미지를 분류할 카테고리이며, 해당 카테고리 디렉터리 내의 각 이미지는 훈련 및 검증에\n사용할 예제입니다. \n\n> Q: “이미지들의 사이즈가 같아야 하나요? 파일명은 어떻게 하죠, 그게 중요한가요?”\n\n둘 다 아닙니다. 이미지 크기는 우리가 신경망에 입력하기 전에 정규화될 것입니다. 우리는 마지막엔\n256 x 256 픽셀의 컬러 이미지를 사용하겠지만, DIGITS는 이미지를 자동으로 자르거나 스쿼시할 \n것입니다. 파일 이름은 관련이 없습니다--어떤 카테고리에 포함되느냐가 중요할 뿐입니다.  \n\n> Q: “제 카테고리들을 더 복잡하게 세분화해도 되나요?”\n\n네. https://github.com/NVIDIA/DIGITS/blob/digits-4.0/docs/ImageFolderFormat.md 를 참고하세요.\n\n우리는 이 이미지를 디스크에 사용하여 **New Dataset**, 그중에서도 **Classification Dataset**을\n생성하려고 합니다.\n\n![Create New Dataset](images/create-new-dataset.png?raw=true \"Create New Dataset\")\n\nDIGITS가 제공하는 기본 설정값을 사용하고 [data/dolphins-and-seahorses](data/dolphins-and-seahorses) \n폴더 경로에 **Training Images**를 지정합니다. DIGITS는 카테고리(`돌고래`와 `해마`)를 사용하여 \n스쿼시된 256 x 256 Training (75%) 및 Testing (25%) 이미지의 데이터베이스를 만듭니다. \n\nDataset에 `dolphins-and-seahorses`라는 이름을 지정하고, **Create**를 클릭합니다.\n\n![New Image Classification Dataset](images/new-image-classification-dataset.png?raw=true \"New Image Classification Dataset\")\n\n이제 데이터셋이 생성될 것입니다. 제 노트북에선 4초 만에 생성되었죠. 마지막으로 2개의 카테고리 속 92개의 \n훈련 이미지 -*Training images*- (돌고래 49개, 해마 43개)와 30개의 검증 이미지 -*Validation images*- (돌고래 16개,\n해마 14개)가 있습니다. 이것은 매우 작은 데이터셋이지만, 신경망을 훈련하고 검증하는 데 오랜 시간이 \n걸리지 않기 때문에 우리의 활동과 학습 목적에 알맞습니다.\n\n이미지가 스쿼시된 후 이미지를 확인하려면 **DB 탐색** -*Explore DB*- 을 하면 됩니다.\n\n![Explore the db](images/explore-dataset.png?raw=true \"Explore the db\")\n\n### 훈련: 시도 1, 처음부터\n\nDIGITS 홈 화면으로 돌아가서, 우리는 새로운 **분류 모델** -*Classification Model*- 을 생성해야 합니다:\n\n![Create Classification Model](images/create-classification-model.png?raw=true \"Create Classification Model\")\n\n우리는 우리의 `dolphins-and-seahorses` 데이터셋과 DIGITS가 제공하는 기본 설정값을 \n사용하는 모델을 훈련시키는 것부터 시작할 것입니다 첫 번째 신경망으로는 표준 신경망 \n아키텍처 중 하나인 [AlexNet (pdf)](http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf)\n을 사용할 것입니다. [AlexNet 설계](http://vision.stanford.edu/teaching/cs231b_spring1415/slides/alexnet_tugce_kyunghee.pdf)\n는 2012년 ImageNet이라는 큰 컴퓨터 비전 대회에서 우승했습니다. 이 대회는 120만\n개의 이미지에 걸쳐 1,000개 이상의 이미지 카테고리를 분류해야 했습니다. \n \n![New Classification Model 1](images/new-image-classification-model-attempt1.png?raw=true \"Model 1\")\n\nCaffe는 구조화된 텍스트 파일을 사용해 신경망 아키텍처를 정의합니다. 이러한 텍스트 파일은\n[Google의 프로토콜 버퍼](https://developers.google.com/protocol-buffers/)를 기반으로 합니다.\n여러분은 Caffe가 사용하는 [전체적인 도식](https://github.com/BVLC/caffe/blob/master/src/caffe/proto/caffe.proto)\n을 읽어보실 수 있습니다.\n대부분의 파트에서 우리는 이것들을 사용하지 않겠지만, 나중에 그것들을 수정해줘야 하므로 \n이러한 것들이 있다는 것을 알아두는 것이 좋습니다.\nAlextNet protxt 파일은 다음과 같습니다:\nhttps://github.com/BVLC/caffe/blob/master/models/bvlc_alexnet/train_val.prototxt. \n\n**epoch는 30**으로 신경망을 훈련시킵니다. 즉, 신경망이 학습(우리의 training image를 통해)하면 \n자체적으로 테스트(validation image를 사용해)하며 결과에 따라 신경망의 가중치를 조정하는 것을 \n30번 반복합니다. 한 사이클이 완료될 때마다 **Accuracy** (0%~100%, 높을수록 좋은 값)와 \n**Loss**가 얼마인지(발생한 모든 오류의 합계, 낮을수록 좋은 값)에 대한 정보를 얻을 수 있습니다.\n이상적으로는 우리는 오류(작은 손실 -*loss*-)가 거의 없는, 매우 정확하게 예측할 수 있는 신경망을\n원합니다.\n\n**NOTE:** 몇몇 사람들이 이 훈련을 시키면서 [DIGITS에서 hit 오류가 일어났다](https://github.com/humphd/have-fun-with-machine-learning/issues/17)\n고 보고했습니다. 대부분의 경우, 이 문제는 가용 메모리와 관련된 것입니다(프로세스가 실행하려면 많은\n메모리가 필요합니다). 여러분이 Docker를 사용하고 있다면, DIGITS에서 사용할 수 있는 메모리양을 \n늘릴 수 있습니다. (Docker에서, 환경설정 -*preferences*- -> 고급 -*preferences*- -> 메모리 -*preferences*- )\n\n처음엔, 우리 신경망의 정확도는 50% 미만입니다. 원래 이렇습니다. 처음에는 무작위로 할당된 가중치를 \n사용하여 두 카테고리 중 \"추측\"하는 것이기 때문입니다. 시간이 지남에 따라 0.37의 loss로 87.5%의 \n정확도를 달성할 수 있습니다. 전체 30 epoch까지 전 6분도 채 걸리지 않았습니다. \n\n![Model Attempt 1](images/model-attempt1.png?raw=true \"Model Attempt 1\")\n\n우리가 업로드한 이미지나 웹상의 이미지에 URL을 사용하여 우리의 모델을 테스트할 수 있습니다.\n훈련/검증 데이터셋에 없는 몇 가지 예제를 통해 테스트해 보겠습니다.\n\n![Model 1 Classify 1](images/model-attempt1-classify1.png?raw=true \"Model 1 Classify 1\")\n\n![Model 1 Classify 2](images/model-attempt1-classify2.png?raw=true \"Model 1 Classify 2\")\n\n거의 완벽해 보입니다. 다음 시도를 하기 전까지는 말이죠:\n\n![Model 1 Classify 3](images/model-attempt1-classify3.png?raw=true \"Model 1 Classify 3\")\n\n여기서 완전히 실패합니다. 해마를 돌고래로 착각하는데, 최악은 높은 자신감으로 해마라고 판별하는 것입니다.  \n\n현실은 우리의 데이터셋이 너무 작아 정말 좋은 신경망을 훈련시키는 데에는 쓸만 하지 않다는 것입니다.\n모든 것을 처리하기 위해선 높은 연산능력과 10초에서 100초 정도의 수천 개의 이미지가 필요합니다.\n\n### 훈련: 시도 2, AlexNet Fine Tuning\n\n#### Fine Tuning 하는 법 \n\n신경망을 처음부터 설계하고, 훈련하기에 충분한 데이터(e.g. 수백만의 이미지)를 수집하고,\n훈련을 완료하기 위해 몇 주 동안 GPU에 엑세스하는 것은 우리가 하기엔 벅찹니다. 더 적은 \n양의 데이터로도 사용될 수 있도록 우리는 **Transfer Learning** 또는 **Fine Tuning**이라는 \n기술을 사용할 것입니다. Fine Tuning은 심층 신경망의 레이아웃을 활용하고 사전훈련된 신경망을\n이용해 첫 번째 객체 감지 작업을 수행합니다. \n\n쌍안경으로 멀리 있는 것을 보는 것처럼 신경망을 사용하는 것을 상상해보십시오. 먼저,\n쌍안경을 눈에 대보면 모든 게 흐릿해집니다. 초점을 맞추면, 색깔, 선, 모양이 보이기 \n시작하고 마지막엔 새의 형태를 인식할 수 있게 됩니다. 그리고 조금 더 조정한다면 새의\n종까지 구분해낼 수 있게 됩니다.  \n\n다중 계층 신경망에서, 초기 계층은 특징(e.g. 가장자리)을 추출하고, 다음 계층은 형태\n(e.g. 바퀴, 눈)를 알아내기 위해 이러한 특징들을 사용합니다. 즉, 이전 계층들의 누적된 특성을\n기반으로 각각의 항목들을 분류하는 최종 분류 계층에 반영됩니다(e.g. 고양이 vs. 개). 신경망은 \n픽셀 단위에서 직사각형으로, 다리로, 특정 방향으로 걷는 두 개의 다리까지 인식할 수 \n있어야 하며, 마지막엔 이미지가 고양이를 가리킨다는 결론을 내릴 수 있어야 합니다.\n\n우리가 하고자 하는 것은 기존에 훈련되어있던 이미지 클래스 대신 새로운 이미지 클래스 세트로\n분류하기 위해 사전훈련된 기존 신경망을 전문적으로 다루는 것입니다. 신경망은 이미 이미지의 \n특징을 \"인식\"하는 법을 알고 있음으로 특정한 이미지 형태로 \"인식\"하기 위해 우리가 신경망을 \n재훈련하고자 합니다. 계층들의 대부분은 처음부터 시작할 필요가 없습니다--이런 계층에서 이미 \n수행했던 학습을 새로운 분류 작업으로 이전하고자 합니다. 랜덤한 가중치를 사용했던 이전 \n시도와는 달리, 우리는 최종 신경망의 기존 가중치를 훈련하는 데 사용할 것입니다. 그러나 \n우리는 최종 분류 계층을 버리고, *우리의* 이미지 데이터셋을 사용해 신경망을 재교육하여 \n이미지 클래스에 맞게 미세 조정 -*fine tuning*- 할 것입니다.\n\n이것이 실행되기 위해서는 학습된 가중치가 쓸만할 만큼 우리의 데이터와 충분히 비슷한 결과가 나오는\n사전훈련된 신경망이 필요합니다. 다행히도 우리가 아래에서 사용할 신경망은 [ImageNet](http://image-net.org/)\n의 수백만 개의 자연 이미지로 훈련되었으며, 광범위한 분류 작업에 뛰어난 성능을 보입니다. \n\n이 테크닉은 의학 이미지에서 눈병을 검사하고, 바다에서 수집한 현미경 이미지에서 플랑크톤 종을 \n식별하며, Flickr 이미지의 미술 양식을 분류하는 것과 같은 흥미로운 일들을 하는 데 사용되어 \n왔습니다. \n\n모든 머신러닝과 마찬가지로 이 작업을 완벽하게 수행하려면 데이터 및 신경망 아키텍처를 이해해야 \n합니다--데이터의 과적합에 주의해야 하며 일부 계층을 수정해야 하거나 새 계층을 삽입해야 하는 \n경우도 있습니다. 하지만, 제 경험상, 대부분의 경우에 \"단지 작동\"할 뿐이며 그저 경험을 쌓고\n우리의 단순한 접근법을 사용하여 무엇을 달성할 수 있는지 확인하는 것만으로 가치 있습니다.\n\n#### 사전훈련된 신경망 업로드\n\n첫 번째 시도에서는 Alexnet의 아키텍처를 사용했지만, 신경망 계층에서 랜덤한 가중치로 시작했습니다.\n우리는 대규모 데이터셋에 대해 이미 훈련받은 버전의 AlexNet을 다운로드하고 사용하고자 합니다.\n\n다행히도 우리는 이것을 바로 할 수 있습니다. AlexNet의 스냅샷은 여기서 다운로드할 수 있습니다: https://github.com/BVLC/caffe/tree/master/models/bvlc_alexnet.\n우리는 훈련된 가중치를 포함하고 있는 이진 파일 `.caffemodel` 도 필요하고, 그것은 http://dl.caffe.berkeleyvision.org/bvlc_alexnet.caffemodel 에서 다운로드할 수 있습니다. \n \n사전훈련된 모델을 받는 동안, 하나 더 해봅시다. \n2014년에 Google은 [GoogLeNet](https://research.google.com/pubs/pub43022.html)으로 같은 \nImageNet 대회에서 우승했습니다(코드명 Inception):  \n22계층의 신경망, GoogLeNet의 스냅샷도 다운로드할 수 있습니다. https://github.com/BVLC/caffe/tree/master/models/bvlc_googlenet 을 참조하십시오.\n다시 말하지만, 우리는  http://dl.caffe.berkeleyvision.org/bvlc_googlenet.caffemodel 에서 다운로드\n할 수 있는 모든 사전훈련된 가중치들로 구성된 `.caffemodel` 파일이 필요합니다.\n\n우리는 `.caffemodel` 파일을 가지고 DIGITs에 업로드할 수 있습니다. DIGITS 홈페이지에 \n**Pretrained Models** 탭으로 이동하여 **Upload Pretrained Model**을 클릭합니다:\n\n![Load Pretrained Model](images/load-pretrained-model.png?raw=true \"Load Pretrained Model\")\n\n이러한 사전훈련된 두 모델은 모두 DIGITS가 제공하는 기본설정값을 사용할 수 있습니다(i.e. \n256 x 256의 스쿼시 된 컬러 이미지). 우리는 `가중치 -Weights- (**.caffemodel)`\n및 ` 모델 정의 -Model Definition- (original.prototxt)`만 제공하면 됩니다.\n각 버튼을 클릭하여 파일을 선택하십시오.\n\n모델 정의(model definitions)에 대해서는 GoogLeNet의 경우에는 https://github.com/BVLC/caffe/blob/master/models/bvlc_googlenet/train_val.prototxt 을 \n참조하고 AlexNet의 경우에는 https://github.com/BVLC/caffe/blob/master/models/bvlc_alexnet/train_val.prototxt\n을 참조할 수 있습니다. 우리는 이러한 분류 레이블들을 사용하지 않을 것이므로 `labels.txt` 파일 추가는\n생략하겠습니다:\n\n![Upload Pretrained Model](images/upload-pretrained-model.png?raw=true \"Upload Pretrained Model\")\n\n다음 단계에서 AlexNet과 GoogLeNet을 모두 사용할 것이므로 이 과정을 반복하십시오.\n\n> Q: \"미세 조정 -fine tuning- 의 기반으로 적합한 다른 신경망이 있을까요?\"\n\n[Caffe Model Zoo](http://caffe.berkeleyvision.org/model_zoo.html) 는 다른 사전훈련된 \n신경망들을 꽤 많이 가지고 있습니다. https://github.com/BVLC/caffe/wiki/Model-Zoo 을 \n참조하십시오.\n\n#### 돌고래와 해마로 AlexNet을 미세 조정하기 -Fine Tuning-\n\n사전훈련된 Caffe 모델을 사용하여 신경망을 훈련하는 것은 몇 가지 조정을 해야 하지만, 처음부터 \n시작하는 것과 비슷합니다. 먼저, 이렇게 크게 변화할 필요가 없음므로(즉, *미세*하게 조정 \n중입니다.) **기본 학습 속도 -Base Learning Rate-** 를 0.01에서 0.001로 조정합니다. 우리는 \n또한 **사전훈련된 신경망 -Pretrained Network-** 을 사용하여 **커스터마이징 -Customize-** 할 \n것입니다.\n\n![New Image Classification](images/new-image-classification-model-attempt2.png?raw=true \"New Image Classification\")\n\n사전훈련된 모델의 정의(i.e. prototext)에서는 모든 참조의 이름을 **완전히 연결된 계층-*Fully Connected Layer*-**(최종 \n결과 분류가 이루어지는 곳)으로 변경해야 합니다. 모델이 원래의 훈련 데이터와 비교해 새로운 \n카테고리를 다시 학습하기를 원하기 때문입니다(즉, 현재의 마지막 계층은 폐기하고자 합니다). \n우리는 최종적으로 완전히 연결된 계층-*fully connected layer*-의 이름을 변경해야만 합니다. \n예를 들면, \"fc8\"에서 \"fc9\"로 말입니다. 마지막으로, 우리는 또한 `num_output`을 `2`로 변경하여, \n카테고리 수를 `1000`에서 `2`로 조정해야 합니다. \n\n여기 우리가 변경해야 할 사항이 있습니다:\n\n```diff\n@@ -332,8 +332,8 @@\n }\n layer {\n-  name: \"fc8\"\n+  name: \"fc9\"\n   type: \"InnerProduct\"\n   bottom: \"fc7\"\n-  top: \"fc8\"\n+  top: \"fc9\"\n   param {\n     lr_mult: 1\n@@ -345,5 +345,5 @@\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"gaussian\"\n@@ -359,5 +359,5 @@\n   name: \"accuracy\"\n   type: \"Accuracy\"\n-  bottom: \"fc8\"\n+  bottom: \"fc9\"\n   bottom: \"label\"\n   top: \"accuracy\"\n@@ -367,5 +367,5 @@\n   name: \"loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"fc8\"\n+  bottom: \"fc9\"\n   bottom: \"label\"\n   top: \"loss\"\n@@ -375,5 +375,5 @@\n   name: \"softmax\"\n   type: \"Softmax\"\n-  bottom: \"fc8\"\n+  bottom: \"fc9\"\n   top: \"softmax\"\n   include { stage: \"deploy\" }\n```\n\n제가 사용하고 있는 완전히 수정된 파일을 [src/alexnet-customized.prototxt](src/alexnet-customized.prototxt)\n에 포함했습니다.\n\n이번에는 정확도가 60%에서 시작해 87.5%로 급등하며 96%까지 이윽고 100%까지 상승하며, \n손실 *Loss* 은 꾸준히 감소했습니다. 5분이 지나면 100%의 정확도와 0.0009의 손실이 발생합니다.\n\n![Model Attempt 2](images/model-attempt2.png?raw=true \"Model Attempt 2\")\n\n이전 신경망이 오류를 일으킨 것과 같은 해마 이미지를 테스트한 결과, 우리는 완전한 반전을 \n볼 수 있습니다: 100% 해마.\n\n![Model 2 Classify 1](images/model-attempt2-classify1.png?raw=true \"Model 2 Classify 1\")\n\n심지어 어린이들이 그린 해마 이미지에도 효과가 있습니다:\n\n![Model 2 Classify 2](images/model-attempt2-classify2.png?raw=true \"Model 2 Classify 2\")\n\n돌고래도 마찬가지입니다:\n\n![Model 2 Classify 3](images/model-attempt2-classify3.png?raw=true \"Model 2 Classify 3\")\n\n이처럼 여러 마리의 돌고래들이 서로 가까이 붙어 있고, 그들의 몸 대부분이 물속에 잠겨 있어 식별하기에\n어려워 보이는 이미지들임에도 불구하고, 잘 작동됩니다:\n\n![Model 2 Classify 4](images/model-attempt2-classify4.png?raw=true \"Model 2 Classify 4\")\n\n### 훈련: 시도 3, GoogLeNet 미세 조정-*Fine Tuning*-\n\n우리가 미세 조정-*Fine Tuning*-을 위해 사용했던 이전의 AlexNet 모델과 마찬가지로, GoogLeNet도 \n사용할 수 있습니다. 신경망을 수정하는 것은 하나의 계층이 아니라 3개의 완전히 연결된 계층을 \n재정의해야 하므로 좀 더 까다롭습니다. \n\n우리의 유스케이스에 맞게 GoogLeNet을 미세 조정하려면, 우리는 또다시 새로운 **분류 모델-*Classification Model*-** \n을 만들어야 합니다:\n\n![New Classification Model](images/new-image-classification-model-attempt3.png?raw=true \"New Classification Model\")\n\n완전히 연결된 세 가지 분류 계층인 `loss1/classifier`, `loss2/classifier`, `loss3/classifier`의 \n모든 참조의 이름을 변경하고 카테고리 수를 재정의합니다(`num_output: 2`). 여기에 3개의 분류 계층의 \n이름을 변경하고 카테고리 수를 1,000개에서 2개로 변경하기 위해 해야 할 사항들이 있습니다:\n\n```diff\n@@ -917,10 +917,10 @@\n   exclude { stage: \"deploy\" }\n }\n layer {\n-  name: \"loss1/classifier\"\n+  name: \"loss1a/classifier\"\n   type: \"InnerProduct\"\n   bottom: \"loss1/fc\"\n-  top: \"loss1/classifier\"\n+  top: \"loss1a/classifier\"\n   param {\n     lr_mult: 1\n     decay_mult: 1\n@@ -930,7 +930,7 @@\n     decay_mult: 0\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"xavier\"\n       std: 0.0009765625\n@@ -945,7 +945,7 @@\n layer {\n   name: \"loss1/loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"loss1/classifier\"\n+  bottom: \"loss1a/classifier\"\n   bottom: \"label\"\n   top: \"loss1/loss\"\n   loss_weight: 0.3\n@@ -954,7 +954,7 @@\n layer {\n   name: \"loss1/top-1\"\n   type: \"Accuracy\"\n-  bottom: \"loss1/classifier\"\n+  bottom: \"loss1a/classifier\"\n   bottom: \"label\"\n   top: \"loss1/accuracy\"\n   include { stage: \"val\" }\n@@ -962,7 +962,7 @@\n layer {\n   name: \"loss1/top-5\"\n   type: \"Accuracy\"\n-  bottom: \"loss1/classifier\"\n+  bottom: \"loss1a/classifier\"\n   bottom: \"label\"\n   top: \"loss1/accuracy-top5\"\n   include { stage: \"val\" }\n@@ -1705,10 +1705,10 @@\n   exclude { stage: \"deploy\" }\n }\n layer {\n-  name: \"loss2/classifier\"\n+  name: \"loss2a/classifier\"\n   type: \"InnerProduct\"\n   bottom: \"loss2/fc\"\n-  top: \"loss2/classifier\"\n+  top: \"loss2a/classifier\"\n   param {\n     lr_mult: 1\n     decay_mult: 1\n@@ -1718,7 +1718,7 @@\n     decay_mult: 0\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"xavier\"\n       std: 0.0009765625\n@@ -1733,7 +1733,7 @@\n layer {\n   name: \"loss2/loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"loss2/classifier\"\n+  bottom: \"loss2a/classifier\"\n   bottom: \"label\"\n   top: \"loss2/loss\"\n   loss_weight: 0.3\n@@ -1742,7 +1742,7 @@\n layer {\n   name: \"loss2/top-1\"\n   type: \"Accuracy\"\n-  bottom: \"loss2/classifier\"\n+  bottom: \"loss2a/classifier\"\n   bottom: \"label\"\n   top: \"loss2/accuracy\"\n   include { stage: \"val\" }\n@@ -1750,7 +1750,7 @@\n layer {\n   name: \"loss2/top-5\"\n   type: \"Accuracy\"\n-  bottom: \"loss2/classifier\"\n+  bottom: \"loss2a/classifier\"\n   bottom: \"label\"\n   top: \"loss2/accuracy-top5\"\n   include { stage: \"val\" }\n@@ -2435,10 +2435,10 @@\n   }\n }\n layer {\n-  name: \"loss3/classifier\"\n+  name: \"loss3a/classifier\"\n   type: \"InnerProduct\"\n   bottom: \"pool5/7x7_s1\"\n-  top: \"loss3/classifier\"\n+  top: \"loss3a/classifier\"\n   param {\n     lr_mult: 1\n     decay_mult: 1\n@@ -2448,7 +2448,7 @@\n     decay_mult: 0\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"xavier\"\n     }\n@@ -2461,7 +2461,7 @@\n layer {\n   name: \"loss3/loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   bottom: \"label\"\n   top: \"loss\"\n   loss_weight: 1\n@@ -2470,7 +2470,7 @@\n layer {\n   name: \"loss3/top-1\"\n   type: \"Accuracy\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   bottom: \"label\"\n   top: \"accuracy\"\n   include { stage: \"val\" }\n@@ -2478,7 +2478,7 @@\n layer {\n   name: \"loss3/top-5\"\n   type: \"Accuracy\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   bottom: \"label\"\n   top: \"accuracy-top5\"\n   include { stage: \"val\" }\n@@ -2489,7 +2489,7 @@\n layer {\n   name: \"softmax\"\n   type: \"Softmax\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   top: \"softmax\"\n   include { stage: \"deploy\" }\n }\n```\n\n전체파일을 [src/googlenet-customized.prototxt](src/googlenet-customized.prototxt)에 저장했습니다.\n\n> Q: \"이러한 신경망의 prototext 정의를 변경하는 건 어떻게 하나요?\n> 우리는 완전히 연결된 계층의 이름과 카테고리의 수를 변경해보았습니다.\n> 그 밖에 어떤 것이 변경될 수 있으며 어떤 상황에서 변경되어야 하나요?\n\n좋은 질문입니다. 그건 저도 궁금한 것입니다. 예를 들어, 저는 가중치가 변하지 않도록 [특정 계층을 \"수정\"](https://github.com/BVLC/caffe/wiki/Fine-Tuning-or-Training-Certain-Layers-Exclusively)\n할 수 있다는 것을 알고 있습니다. 그 밖에 다른 것들을 하는 것은 계층들이 어떻게 작동하는지 \n이해해야 합니다. 이것은 이 안내서를 넘어선 일이고, 지금의 저자도 넘어서는 것입니다!\n\n앞에서 했던 AlexNet 미세 조정과 마찬가지로, 학습률을 `0.01`에서 `0.001`로 10% 낮춥니다.\n\n> Q: \"이러한 신경망을 미세 조정할 때 그 외에 어떤 변경이 의미가 있나요?\n> 다른 epoch 수, batch size,  솔버 유형 (Adam, AdaDelta, AdaGrad 등), 학습률, 정책\n> (Exponential Decay, Inverse Decay, Sigmoid Decay 등), 단계 크기, 감마 값은 어떻나요?\"\n\n좋은 질문이고 마찬가지로 저도 궁금한 것들입니다. 저는 이것들에 대해 막연하게 이해하고 있으며, \n훈련 시 이러한 값들을 어떤 식으로 변경해야 할지 안다면 개선할 수 있을 것입니다. 물론 이보다 \n더 좋은 문서가 필요할 것입니다.\n\nGoogLeNet은 architecture보다 더 복잡한 아키텍처이므로 미세 조정에 더 많은 시간이 필요합니다.\n제 노트북에서는 데이터셋으로 GoogLeNet을 재훈련시키는 데 10분이 소요되어 100% 정확도와 0.0070의 \n손실을 달성했습니다:\n\n![Model Attempt 3](images/model-attempt3.png?raw=true \"Model Attempt 3\")\n\nAlexNet의 미세 조정에서 살펴본 것처럼, 수정된 GoogLeNet은 잘 작동합니다--지금까지 중 가장 뛰어난 성능입니다:\n\n![Model Attempt 3 Classify 1](images/model-attempt3-classify1.png?raw=true \"Model Attempt 3 Classify 1\")\n\n![Model Attempt 3 Classify 2](images/model-attempt3-classify2.png?raw=true \"Model Attempt 3 Classify 2\")\n\n![Model Attempt 3 Classify 3](images/model-attempt3-classify3.png?raw=true \"Model Attempt 3 Classify 3\")\n\n## 모델 사용\n\n신경망을 훈련하고 테스트하였으니, 이제 다운받아 사용할 시간입니다. DIGITS로 훈련한 각 모델은 **Download Model** 버튼과 훈련 실행 중 서로 다른 스냅샷을 선택하는 방법이 있습니다(e.g. `Epoch #30`):\n\n![Trained Models](images/trained-models.png?raw=true \"Trained Models\")\n\n**Download Model** 를 클릭하면 다음 파일들이 압축된 `tar.gz` 파일이 다운로드됩니다:\n\n```\ndeploy.prototxt\nmean.binaryproto\nsolver.prototxt\ninfo.json\noriginal.prototxt\nlabels.txt\nsnapshot_iter_90.caffemodel\ntrain_val.prototxt\n```\n\nCaffe 문서에 우리가 방금 만든 모델의 사용법에 대한 [멋진 설명](https://github.com/BVLC/caffe/wiki/Using-a-Trained-Network:-Deploy)\n이 있습니다. 다음과 같이 쓰여 있습니다:\n\n> 신경망은 구조(.prototxt)와 가중치로(.caffemodel) 정의됩니다. 신경망이 훈련될 때\n> 가중치의 현재 상태-*current state*-는 .caffemodel에 저장됩니다. 이 두 가지를 통해 \n> 우리는 훈련/테스트 단계에서 생산-*production*- 단계로 이동할 수 있습니다.\n> \n> 현재 상태로서는 신경망의 구조는 배포용으로 설계되어있지 않습니다. 신경망을 제품으로 \n> 출시하기 전에 몇 가지 방법으로 신경망을 수정해야 합니다:\n>\n> 1. 분류-*classification*-에 관해서 데이터의 레이블을 더는 제공하지 않음으로 훈련에 사용된 데이터 계층을 제거하십시오.\n> 2. 데이터 레이블에 종속된 계층을 제거하십시오.\n> 3. 데이터를 수신하도록 신경망을 설정하십시오.\n> 4. 신경망이 결과를 출력하게 하십시오.\n\nDIGITS는 `prototxt` 파일의 각각 다른 버전들을 구분하여 이미 할 일을 끝냈습니다.\n신경망을 사용할 때 주의해야 할 파일:\n\n* `deploy.prototxt` - 이미지 입력 데이터를 받아들일 준비가 된 신경망의 정의\n* `mean.binaryproto` - 모델이 처리하는 각각의 이미지에서 빼야할 이미지가 있는데, 그 빼야할 이미지를 말한다.\n* `labels.txt` - 출력하고자 하는 레이블 (`dolphin`, `seahorse`)과 카테고리 번호만 출력하는 경우를 위한 목록\n* `snapshot_iter_90.caffemodel` - 이것들은 우리 신경망을 위해 훈련된 가중치들이다.\n\n우리는 이 파일들을 새로운 이미지로 분류하기 위해 다양한 방법들을 사용할 수 있습니다. 예를 들어, \n`CAFFE_ROOT`에서는 `build/examples/cpp_classification/classification.bin`을 사용해 하나의 \n이미지를 분류할 수 있습니다:\n\n```bash\n$ cd $CAFFE_ROOT/build/examples/cpp_classification\n$ ./classification.bin deploy.prototxt snapshot_iter_90.caffemodel mean.binaryproto labels.txt dolphin1.jpg\n```\n\n이러면 디버그 텍스트 다발을 뱉어내고, 이어서는 두 카테고리에 대한 예측이 뒤따를 것입니다:\n\n```\n0.9997 - “dolphin”\n0.0003 - “seahorse”\n```\n\n[전체 C++ 소스](https://github.com/BVLC/caffe/tree/master/examples/cpp_classification)는 \n[Caffe 예제들](https://github.com/BVLC/caffe/tree/master/examples)에서 확인할 수 있습니다.\n\nPython 인터페이스를 사용하는 분류 버전의 경우, DIGITS에 [좋은 예제](https://github.com/NVIDIA/DIGITS/tree/master/examples/classification)\n가 있습니다.또한 Caffe 예제들 안에는 [꽤 잘 문서화된 파이썬 워크스루](https://github.com/BVLC/caffe/blob/master/examples/00-classification.ipynb) \n도 있습니다.\n\n### 파이썬 예제\n\n미세 조정된 GoogLeNet 모델을 사용하여 [data/untrained-samples](data/untrained-samples)에 있는 \n훈련되지 않은 이미지를 분류하는 프로그램을 작성합시다. 위의 예제들과 `caffe` [Python module's source](https://github.com/BVLC/caffe/tree/master/python)\n를 바탕으로 종합해보았습니다. 여러분은 이제부터 알려드릴 것을 좋아하실 겁니다.\n\n제가 말하고자 하는 내용의 전체 버전은 [src/classify-samples.py](src/classify-samples.py)에서 확인하실 수 있습니다.\n시작하겠습니다.\n\n먼저, [NumPy](http://www.numpy.org/) 모듈이 필요합니다. 잠시 후에 [NumPy](http://www.numpy.org/)\n를 이용해 Caffe에서 많이 쓰이는 [`ndarray`s](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html)\n를 사용할 것입니다. 안 써보셨다면, 저도 안 써봤지만, 이 [퀵스타트 튜토리얼](https://docs.scipy.org/doc/numpy-dev/user/quickstart.html)\n을 읽어보시는 건 어떨까요?\n\n두 번째로 우리는 `CAFFE_ROOT` 디렉터리로부터 `caffe` 모듈을 적재해야 합니다. 파이썬 환경에 포함되어 \n있지 않으면 수동으로 추가하여 강제로 적재할 수 있습니다. 마찬가지로 우리는 caffe의 protobuf \n모듈도 가져와야 합니다:\n\n```python\nimport numpy as np\n\ncaffe_root = '/path/to/your/caffe_root'\nsys.path.insert(0, os.path.join(caffe_root, 'python'))\nimport caffe\nfrom caffe.proto import caffe_pb2\n```\n\n다음으로 [CPU 또는 GPU](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/_caffe.cpp#L50-L52)\n중 어떤 것을 사용하는지 Caffe에 알려야 합니다.\n실험에서 CPU는 잘 작동합니다:\n\n```python\ncaffe.set_mode_cpu()\n```\n\n이제 우리는 `caffe`에서 훈련된 신경망을 적재해보겠습니다. 그러려면 DIGITS에서 다운로드한 \n파일 중 일부가 필요합니다:\n\n* `deploy.prototxt` - our \"신경망 파일\", 신경망에 대한 서술.\n* `snapshot_iter_90.caffemodel` - 훈련된 \"가중치\"\n\n분명하게 전체 경로를 제공해줘야 하며, 전 제 파일들이 `model/` 디렉터리에 있다고 가정하겠습니다:\n\n```python\nmodel_dir = 'model'\ndeploy_file = os.path.join(model_dir, 'deploy.prototxt')\nweights_file = os.path.join(model_dir, 'snapshot_iter_90.caffemodel')\nnet = caffe.Net(deploy_file, caffe.TEST, weights=weights_file)\n```\n\n`caffe.Net()` [생성자](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/_caffe.cpp#L91-L117)\n는 신경망 파일, 단계-*phase*-(`caffe.TEST` 또는 `caffe.TRAIN`) 및 부가 가중치 파일 이름을 \n사용합니다. 우리가 가중치 파일을 주면, `Net`이 자동으로 적재합니다. `Net`에는 여러분이 사용할 \n수 있는 몇 가지 [method와 attribute](https://github.com/BVLC/caffe/blob/master/python/caffe/pycaffe.py)\n가 있습니다.\n\n**Note:** [생성자의 deprecated version](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/_caffe.cpp#L119-L134),\n도 있으며, 웹상에 샘플 코드에서 자주 사용되어 집니다. 이렇게 생겼습니다:\n\n```python\nnet = caffe.Net(str(deploy_file), str(model_file), caffe.TEST)\n```\n\n우리는 테스트를 위해 다양한 크기의 이미지를 신경망에 업로드하는 데 관심 있습니다. 따라서, 신경망에서 \n사용할 수 있는 형태(i.e. 컬러, 256x256)로 *변형*해야 하는데, 이를 위해 Caffe에서  [`Transformer` 클래스](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L98)\n를 제공하고 있습니다. 우리는 이것을 이미지/신경망에 알맞게 변형하기 위해 사용할 것입니다:\n\n```python\ntransformer = caffe.io.Transformer({'data': net.blobs['data'].data.shape})\n# set_transpose: https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L187\ntransformer.set_transpose('data', (2, 0, 1))\n# set_raw_scale: https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L221\ntransformer.set_raw_scale('data', 255)\n# set_channel_swap: https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L203\ntransformer.set_channel_swap('data', (2, 1, 0))\n```\n\n또한 transformer의 mean을 설정하기 위해 DIGITS가 제공하는 `mean.binaryproto` 파일을 사용하겠습니다:\n\n```python\n# This code for setting the mean from https://github.com/NVIDIA/DIGITS/tree/master/examples/classification\nmean_file = os.path.join(model_dir, 'mean.binaryproto')\nwith open(mean_file, 'rb') as infile:\n    blob = caffe_pb2.BlobProto()\n    blob.MergeFromString(infile.read())\n    if blob.HasField('shape'):\n        blob_dims = blob.shape\n        assert len(blob_dims) == 4, 'Shape should have 4 dimensions - shape is %s' % blob.shape\n    elif blob.HasField('num') and blob.HasField('channels') and \\\n            blob.HasField('height') and blob.HasField('width'):\n        blob_dims = (blob.num, blob.channels, blob.height, blob.width)\n    else:\n        raise ValueError('blob does not provide shape or 4d dimensions')\n    pixel = np.reshape(blob.data, blob_dims[1:]).mean(1).mean(1)\n    transformer.set_mean('data', pixel)\n```\n\n레이블이 많이 있다면 레이블 파일-*labels file*-을 가져올 수도 있는데,  나중에 레이블의 상태-*position*-\n(e.g. 0=dolphin, 1=seahorse)를 사용하여 확률에 대해 레이블을 조회하고 사용할 수 있습니다:\n\n```python\nlabels_file = os.path.join(model_dir, 'labels.txt')\nlabels = np.loadtxt(labels_file, str, delimiter='\\n')\n``` \n\n이제 이미지를 분류하기 위한 준비를 마쳤습니다. [`caffe.io.load_image()`](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L279)\n를 사용해 이미지 파일을 읽은 다음 transformer를 사용해 형태를 바꾸고 신경망의 데이터 계층으로 \n설정합니다:\n\n```python\n# Load the image from disk using caffe's built-in I/O module\nimage = caffe.io.load_image(fullpath)\n# Preprocess the image into the proper format for feeding into the model\nnet.blobs['data'].data[...] = transformer.preprocess('data', image)\n```\n\n> Q: \"파일 대신에, 카메라나 비디오 스트림의 이미지를 사용하려면 어떻게 해야 하나요?\"\n\n좋은 질문입니다. 여기 스켈레톤 코드가 있습니다:\n\n```python\nimport cv2\n...\n# Get the shape of our input data layer, so we can resize the image\ninput_shape = net.blobs['data'].data.shape\n...\nwebCamCap = cv2.VideoCapture(0) # could also be a URL, filename\nif webCamCap.isOpened():\n    rval, frame = webCamCap.read()\nelse:\n    rval = False\n\nwhile rval:\n    rval, frame = webCamCap.read()\n    net.blobs['data'].data[...] = transformer.preprocess('data', frame)\n    ...\n\nwebCamCap.release()\n```\n\n다시 우리의 문제로 돌아가서, 우리는 다음으로 이미지 데이터로 신경망을 실행하고 레이블 \n카테고리별로 순서대로 정렬될 신경망의 마지막 `'softmax'` 계층에서 확률을 읽어야 합니다:\n\n```python\n# Run the image's pixel data through the network\nout = net.forward()\n# Extract the probabilities of our two categories from the final layer\nsoftmax_layer = out['softmax']\n# Here we're converting to Python types from ndarray floats\ndolphin_prob = softmax_layer.item(0)\nseahorse_prob = softmax_layer.item(1)\n\n# Print the results. I'm using labels just to show how it's done\nlabel = labels[0] if dolphin_prob > seahorse_prob else labels[1]\nfilename = os.path.basename(fullpath)\nprint '%s is a %s dolphin=%.3f%% seahorse=%.3f%%' % (filename, label, dolphin_prob*100, seahorse_prob*100)\n```\n\n[data/untrained-samples](data/untrained-samples) 이미지에서 미세 조정된 GoogLeNet 신경망을 사용하여 \n이것의([src/classify-samples.py](src/classify-samples.py)를 보십시오. 풀 버전을 실행한다면 다음과 같은 결과가 나옵니다:\n\n```\n[...truncated caffe network output...]\ndolphin1.jpg is a dolphin dolphin=99.968% seahorse=0.032%\ndolphin2.jpg is a dolphin dolphin=99.997% seahorse=0.003%\ndolphin3.jpg is a dolphin dolphin=99.943% seahorse=0.057%\nseahorse1.jpg is a seahorse dolphin=0.365% seahorse=99.635%\nseahorse2.jpg is a seahorse dolphin=0.000% seahorse=100.000%\nseahorse3.jpg is a seahorse dolphin=0.014% seahorse=99.986%\n```\n\n저는 계속 코드상에서 모델로 작동하는 사례들을 살펴보며 공부하는 중입니다. 여기에 보여드릴 \n수 있는 코드 예시, API, free-made 모듈 등이 더 많이, 잘 문서화되면 좋겠습니다. 저도 제가 \n찾은 대부분의 코드 예제가 단순하고 어쩌면 형편없이 문서화되어 있다는 것을 알고 있습니다\n--특히 Caffe 문서는 지저분하고 많은 것을 가정해가며 했습니다.\n\n제가 보기엔 초보자용 Caffe 인터페이스와 여기와 같은 기초적인 워크플로우 위에 더 높은 수준의 \n도구를 구축할 기회가 온 것 같습니다. 여러분에게 \"잘했어\"라고 알려줄 수 있는 고급 언어로 된 더 \n간단한 모듈들이 있다면 좋을 텐데 말입니다; 누군가는 이것을 받아들일 수 있고, DIGITS가 *훈련*\n시키는 것만큼 쉽게 Caffe 모델을 사용할 수 있거나 사용해야 할 겁니다. Node.js같은 곳에서 \n사용할 수 있으면 좋을 텐데요. 이상적으로는 모델이나 Caffe 내부에 대해 많은 것을 알 필요는 \n없습니다. 아직 사용해본 적은 없지만, [DeepDetect](https://deepdetect.com/)도 이러한 면에서 \n흥미로워 보이고, 제가 알지 못하는 다른 많은 툴이 있을 수 있습니다. \n\n## 결과\n\n처음에 우리는 신경망을 이용하여 [data/untrained-samples](data/untrained-samples)의 모든 이미지를 \n올바르게 분류하는 프로그램을 작성하는 것이 목표라고 했었죠? 이건 훈련이나 검증 데이터로 쓰인 적 없는 \n돌고래와 해마의 이미지입니다:\n\n### 훈련에 쓰인 적 없는 돌고래 이미지\n\n![Dolphin 1](data/untrained-samples/dolphin1.jpg?raw=true \"Dolphin 1\")\n![Dolphin 2](data/untrained-samples/dolphin2.jpg?raw=true \"Dolphin 2\")\n![Dolphin 3](data/untrained-samples/dolphin3.jpg?raw=true \"Dolphin 3\")\n\n### 훈련에 쓰인 적 없는 해마 이미지\n\n![Seahorse 1](data/untrained-samples/seahorse1.jpg?raw=true \"Seahorse 1\")\n![Seahorse 2](data/untrained-samples/seahorse2.jpg?raw=true \"Seahorse 2\")\n![Seahorse 3](data/untrained-samples/seahorse3.jpg?raw=true \"Seahorse 3\")\n\n이 과제를 해결하기 위한 세 가지 시도를 각각 살펴보겠습니다:\n\n### 모델 시도 1: AlexNet, 처음부터 (3rd Place)\n\n| Image | Dolphin | Seahorse | Result | \n|-------|---------|----------|--------|\n|[dolphin1.jpg](data/untrained-samples/dolphin1.jpg)| 71.11% | 28.89% | :expressionless: |\n|[dolphin2.jpg](data/untrained-samples/dolphin2.jpg)| 99.2% | 0.8% | :sunglasses: |\n|[dolphin3.jpg](data/untrained-samples/dolphin3.jpg)| 63.3% | 36.7% | :confused: |\n|[seahorse1.jpg](data/untrained-samples/seahorse1.jpg)| 95.04% | 4.96% | :disappointed: |\n|[seahorse2.jpg](data/untrained-samples/seahorse2.jpg)| 56.64% | 43.36 |  :confused: |\n|[seahorse3.jpg](data/untrained-samples/seahorse3.jpg)| 7.06% | 92.94% |  :grin: |\n\n### Model Attempt 2: AlexNet, 미세 조정 (2nd Place)\n\n| Image | Dolphin | Seahorse | Result | \n|-------|---------|----------|--------|\n|[dolphin1.jpg](data/untrained-samples/dolphin1.jpg)| 99.1% | 0.09% |  :sunglasses: |\n|[dolphin2.jpg](data/untrained-samples/dolphin2.jpg)| 99.5% | 0.05% |  :sunglasses: |\n|[dolphin3.jpg](data/untrained-samples/dolphin3.jpg)| 91.48% | 8.52% |  :grin: |\n|[seahorse1.jpg](data/untrained-samples/seahorse1.jpg)| 0% | 100% |  :sunglasses: |\n|[seahorse2.jpg](data/untrained-samples/seahorse2.jpg)| 0% | 100% |  :sunglasses: |\n|[seahorse3.jpg](data/untrained-samples/seahorse3.jpg)| 0% | 100% |  :sunglasses: |\n\n### Model Attempt 3: GoogLeNet, 미세 조정 (1st Place)\n\n| Image | Dolphin | Seahorse | Result | \n|-------|---------|----------|--------|\n|[dolphin1.jpg](data/untrained-samples/dolphin1.jpg)| 99.86% | 0.14% |  :sunglasses: |\n|[dolphin2.jpg](data/untrained-samples/dolphin2.jpg)| 100% | 0% |  :sunglasses: |\n|[dolphin3.jpg](data/untrained-samples/dolphin3.jpg)| 100% | 0% |  :sunglasses: |\n|[seahorse1.jpg](data/untrained-samples/seahorse1.jpg)| 0.5% | 99.5% |  :sunglasses: |\n|[seahorse2.jpg](data/untrained-samples/seahorse2.jpg)| 0% | 100% |  :sunglasses: |\n|[seahorse3.jpg](data/untrained-samples/seahorse3.jpg)| 0.02% | 99.98% |  :sunglasses: |\n\n## 결론\n\n우리가 만든 모델이 얼마나 잘 작동하는지, 사전훈련된 신경망을 미세 조정함으로써 무엇이 가능한지는 정말 \n놀랍지 않나요? 물론 돌고래 vs 해마의 예제는 인위적이며 데이터셋이 지나치게 제한적이었습니다. 신경망이 \n강력해지기 위해선 훨씬 더 많은 데이터가 필요합니다. 하지만 우리의 목표는 신경망의 툴과 워크플로우를 \n조사하는 것이었기 때문에, 특히 비싼 장비나 많은 시간은 없었기 때문에 우리에겐 알맞은 케이스였습니다.\n\n무엇보다 이 경험이 시작에 대한 벅찬 두려움을 없애는 데 도움이 되길 바랍니다. 머신러닝과 신경망의 이론을 \n배우는 데 시간을 투자할 가치가 있는지를 결정하는 것은 간소화된 방식으로 볼 수 있을 때 더 쉬울 겁니다. \n이제 설정하는 법과 접근 방식을 알았으므로 다른 분류도 해볼 수 있을 것입니다. Caffe와 DIGITS로 \n수행할 수 있는 다른 유형들도 살펴볼 수 있게 되었습니다. 예를 들어, 이미지 내의 개체를 찾거나 분리하는 \n것 등입니다. \n\n머신러닝을 즐겨보세요!\n"
        },
        {
          "name": "README_zh-tw.md",
          "type": "blob",
          "size": 50.3876953125,
          "content": "# 機器學習動手玩：給新手的教學\n\n> Author: David Humphrey (original [English version](README.md))  \n  中文（繁體）語系譯者：[Birkhoff Lee](https://fb.me/birkhofflee)\n\n### 譯者有話要說 Translator's Note\n\n各位好。這是一篇很棒的教學，小弟希望能夠幫助到中文讀者，於是利用自己課後的時間（我還是個國中生）來翻譯這篇文章。在這篇文章裡有很多專業的術語，而有些是我不曾聽聞的——例如「Transfer Learning」——我遇到這些我不清楚的術語時，我使用 Google 來搜尋相關的中文文獻以期得到該術語現有的翻譯。還有一些內容是無法直接從英文翻到中文的，必須重建語境來翻譯，因此我會盡可能地不偏離原文的意思。如果您發現哪裡的翻譯有問題或是可以翻譯地更好，請開一個 issue 或是直接發一個 pull request 來協助修正翻譯，謝謝。\n\n## 序言\n\n這是一個提供給**無人工智慧背景知識**程式員的機器學習**實作教學**。使用類神經網絡事實上並不需要什麼博士學位，而且你也不需要成為下一個在人工智慧領域有極大突破的人，而且我們現在的成就已經十分驚人，且可用性極高。我相信大多數人是想玩玩看這個東西——就跟我們玩開源軟體一樣——而不是將它視為一個研究議題。\n\n在這篇教學中，我們的目標是寫一個程式，能夠使用機器學習來進行精確的判定——僅僅依該圖片來判斷在 [data/untrained-samples](data/untrained-samples) 中的陌生圖案是**海豚**還是**海馬**。以下是兩個我們將會用到的範例圖案：\n\n![一隻海豚](data/untrained-samples/dolphin1.jpg?raw=true \"海豚\")\n![一隻海馬](data/untrained-samples/seahorse1.jpg?raw=true \"海馬\")\n\n為了進行判定，我們將訓練一個[卷積神經網絡](https://zh.wikipedia.org/wiki/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C)。我們將以實踐者的角度（而不是以第一原理\\* 的觀點）來解決這個問題。人工智慧現在十分令人興奮，不過現在大多數關於 AI 的文章就像是物理學家在黑板上傳授你騎腳踏車技巧一樣，不過你應該與你的朋友在公園內練習才對不是嗎？\n\n我決定在 GitHub 上發表這篇文章，而不是在我的部落格上。因為我確定以下我所寫的內容有些會誤導讀者，或根本是錯的。我還在自學這一方面的知識，而且我發現一些新手教學會成為障礙。如果你發現我哪裡寫錯了、或是缺少了什麼重要的細節，請建立一個 pull request。\n\n把那些拋諸腦後吧！讓我來教你如何使用這些東西。\n\n> \\* 譯者按：「第一原理」是指不必經過驗證，即已明白的原理，即是理由已經存在於原理之中，也是自證原理。\n  就範圍大小區分，第一原理可以是解釋所有事件的終極真理，也可以視為一個系統一致性、連貫性的\n  一種根源性的解釋。\n\n## 概覽\n\n以下是我們將要探索的內容：\n\n* 設定並且使用現有且開放原始碼的機器學習技術，特別是 [Caffe](http://caffe.berkeleyvision.org/) 與 [DIGITS](https://developer.nvidia.com/digits)。\n* 建立一個圖像資料集\n* 從頭開始訓練一個類神經網絡\n* 用我們的類神經網絡測試判別它從沒見過的圖案\n* 對現有的類神經網絡（AlexNet 與 GoogLeNet）進行微調以改進我們類神經網絡的判別準確度\n* 部署並使用我們的類神經網絡\n\n這個教學將不會教你這些類神經網絡是如何設計的、其背後的理論，也不會給你什麼數學表達式。我不假裝全然理解我接下來將教你的。相反地，我們將以有趣的方式來用現有的東西解決一個困難的問題。\n\n> 問：「我知道你說了我們不會討論類神經網絡背後的理論，但是我還是覺得在我們開始之前我至少需要一些概覽。我該從何開始？」\n\n網路上大概有上百個關於這個東西的介紹。其中不乏短文、甚至完整的線上課程應有盡有。看你希望如何學習，這裡有三個不錯的選項供你參考：\n\n* 這個奇妙的[部落格文章](https://jalammar.github.io/visual-interactive-guide-basics-neural-networks/)，由 J Alammar 所著。它以直觀的例子介紹了類神經網絡的概念。\n* 類似的，這部由 [Brandon Rohrer](https://www.youtube.com/channel/UCsBKTrp45lTfHa_p49I2AEQ) 所拍攝的 [介紹影片](https://www.youtube.com/watch?v=FmpDIaiMIeA) 是個很不錯的關於卷積神經網絡（我們將會使用它）的介紹。\n* 如果你想了解更多其背後的理論，我會推薦你[這本書](http://neuralnetworksanddeeplearning.com/chap1.html)，它由 [Michael Nielsen](http://michaelnielsen.org/) 所著。\n\n## 設定\n\n根據你所使用的平台與作業系統版本，安裝我們將使用到的軟體（Caffe 與 DIGITS）可能會讓你感到十分挫敗。目前為止最簡單的方式是使用 Docker。以下我們將示範如何使用 Docker 來設定，以及如何用原生的方式來設定它。\n\n### 方法 1a：原生安裝 Caffe\n\n首先，我們將會使用到來自 Berkely Vision 及 Learning Center 的 [Caffe 深度學習框架](http://caffe.berkeleyvision.org/)（BSD 協議）。\n\n> 問：「等一下，為什麼要用 Caffe？為什麼不使用最近很多人都在討論的 TensorFlow?」\n\n我們有很多很棒的選擇，而且你應該都稍微了解一下他們。[TensorFlow](https://www.tensorflow.org/) 是很不錯，而且你也應該玩玩看。不過，由於以下這些原因我選擇使用 Caffe：\n\n* 它專門用來解決電腦視覺相關的問題\n* 它支援 C++、Python，及[即將到來的 Node.js 支援](https://github.com/silklabs/node-caffe)\n* 它既快又穩定\n\n不過最首要的原因是**你不需要寫任何程式碼**來使用它。你可以用說明的方式做任何事，或是用命令行工具（Caffe 使用結構化文字檔來定義網絡架構）。還有，你可以透過一些不錯的前端介面來使用 Caffe 以訓練及驗證你的網絡，這將變得十分簡單。我們將會使用 [nVidia 公司的 DIGITS](https://developer.nvidia.com/digits) 來當做我們的前端介面。\n\n要安裝好 Caffe 有點費力。這裡有對於某些平台的[安裝指引](http://caffe.berkeleyvision.org/installation.html)，及一些已經預先編譯好的 Docker 或 AWS 配置。\n\n**注意：** 當我在寫這篇時，我使用了這個非正式版本的 Caffe：https://github.com/BVLC/caffe/commit/5a201dd960840c319cefd9fa9e2a40d2c76ddd73\n\n想在 Mac 上安裝它很容易讓你感到挫敗，在編譯 Caffe 時會有很多版本問題，我試了很多天，也找了很多教學，每次都有略微不同的問題。最後我找到了最接近的[這篇](https://gist.github.com/doctorpangloss/f8463bddce2a91b949639522ea1dcbe4)。我也推薦[最近發表的這篇](https://eddiesmo.wordpress.com/2016/12/20/how-to-set-up-caffe-environment-and-pycaffe-on-os-x-10-12-sierra/)文章，裡面也提到很多我看到的討論串。對於中文讀者來說，[BirkhoffLee](https://github.com/BirkhoffLee) 也推薦了他完整的[中文版教學](https://blog.birkhoff.me/macos-sierra-10-12-2-build-caffe)，教你如何在 macOS Sierra 上編譯 Caffe。\n\n將 Caffe 安裝好是到目前為止我們將做的最難的事情，這很好，因為你可能會認為人工智慧方面的問題會更難。如果你遇到問題，千萬不要放棄，這是值得的。如果要讓我再做一次，我不會直接在 Mac 上安裝它，而是在一台 Ubuntu 虛擬機器上安裝。如果你有問題，這裡是 [Caffe 使用者群組](https://groups.google.com/forum/#!forum/caffe-users)，你可以在此提問。\n\n> 問：「訓練一個類神經網絡需不需要很好的硬體？如果我沒有很棒的 GPU 呢？」\n\n事實上沒錯。訓練一個深層類神經網絡需要非常大量的預算能力和精力...前提是你要用非常大量的資料集從頭開始訓練。我們不會這樣做。我們的秘訣是用一個別人事先以上百小時訓練好的類神經網絡，然後我們再針對我們的資料集進行微調。下面的教學將會教你如何這樣做。簡單來說，下面我所做的事情，都是我在一臺一歲的 MacBook Pro 上做的（這台沒有很好的 GPU）。\n\n順便說一下，因為我的 MacBook Pro 只有 Intel 整合繪圖處理器（即內建顯示核心），它沒有 nVidia 的 GPU，所以我決定使用 [Caffe 的 OpenCL 版本](https://github.com/BVLC/caffe/tree/opencl)，而且它在我的筆電上跑的很不錯。\n\n當你把 Caffe 搞定之後，你應該有，或能做這些東西：\n\n* 一個資料夾，裡面有你編譯好的 Caffe。如果你用了標準的方法來編譯它，裡面會有一個叫做「`build/`」的資料夾，它裡面有你跑 Caffe 所需要的所有東西，像是 Python 的綁定什麼的。那個包含 `build/` 的資料夾就是你的「`CAFFE_ROOT`」（我們等一下會用到這個）。\n* 執行 `make test && make runtest` 要能通過測試\n* 安裝完所有 Python 相依性套件之後（在 `python/` 內執行 `pip install -r requirements.txt`），執行 `make pycaffe && make pytest` 要能通過測試\n* 你也應該執行 `make distribute` 以建立一個含有所有必須的 header、binary 之類東西的可散佈版的 Caffe。\n\n在我的機器上，我已經完整的編譯好 Caffe 了。我的 CAFFE_ROOT 裡面的基本結構看起來長這樣：\n\n```\ncaffe/\n    build/\n        python/\n        lib/\n        tools/\n            caffe ← 這是我們主要使用的執行檔\n    distribute/\n        python/\n        lib/\n        include/\n        bin/\n        proto/\n```\n\n現在，我們已經萬事俱全，可以訓練、測試我們的網絡以及為它編寫程式了。在下一節我們將為 Caffe 添加一個十分友好的網頁介面——「DIGITS」，這樣我們訓練及測試我們的網絡時將變得更簡單。\n\n### 方法 1b：原生安裝 DIGITS\n\nnVidia 的[深度學習 GPU 訓練系統（DIGITS）](https://github.com/NVIDIA/DIGITS)是個 BSD 協議的 Python 網頁應用程式，專門用來訓練類神經網絡。雖然我們可以在命令行（或是自己寫程式）完成任何 DIGITS 對 Caffe 做的事，但是用 DIGITS 將讓我們更容易上手。我發現 DIGITS 的視覺化資料、即時圖表和其他類似的功能讓這一切都變得更有趣了。因為你還在實驗及嘗試學習，我非常推薦以 DIGITS 上手。\n\nhttps://github.com/NVIDIA/DIGITS/tree/master/docs 有一些十分不錯的文檔供你參考，裡面也有[安裝](https://github.com/NVIDIA/DIGITS/blob/master/docs/BuildDigits.md)、[設定](https://github.com/NVIDIA/DIGITS/blob/master/docs/Configuration.md)及[供你上手](https://github.com/NVIDIA/DIGITS/blob/master/docs/GettingStarted.md)的資料。我建議在你開始之前，先把所有東西都稍微看一遍，因為我並不是 DIGITS 的專家——我並不知道它能做的所有事情。如果你有什麼問題想問，公開的 [DIGITS 使用者群組](https://groups.google.com/forum/#!forum/digits-users)是一個不錯的地方。\n\n要安裝且執行 DIGITS 有很多方法，有 Docker image、預先包裝好的 Linux 套件，或者你也可以自行編譯它。我使用的是 Mac，所以我選擇自行編譯它。\n\n**注意：** 當我在寫這篇時，我使用了這個非正式版本的 DIGITS：https://github.com/NVIDIA/DIGITS/commit/81be5131821ade454eb47352477015d7c09753d9\n\nDIGITS 很容易安裝，因為他就只是一堆 Python 腳本。你唯一需要告訴 DIGITS 的一件事就是你的 `CAFFE_ROOT` 在哪裡。你可以用環境變數搞定這件事，然後就可以啟動伺服器了：\n\n```bash\nexport CAFFE_ROOT=/path/to/caffe\n./digits-devserver\n```\n\n注意：在 Mac 上我在啟動伺服器時發生了一些問題——啟動伺服器的腳本直接默認了我的 Python 執行檔叫做 `python2`，但是我只有 `python2.7`。你可以建立一個到 `/usr/bin` 的符號連結或是修改 DIGITS 的啟動腳本來使用正確的 Python 執行檔。\n\n當你啟動了伺服器之後，你可以透過你的網頁瀏覽器在這個網址做所有其他的事情（我們等下會做的事）了：http://localhost:5000。\n\n### 方法 2：用 Docker 執行 Caffe 與 DIGITS\n如果你還沒安裝 [Docker](https://www.docker.com/) 請先安裝它，接著執行以下指令來拉取與執行一個完整的 Caffe + DIGITS 容器。\n\n```bash\ngit clone https://github.com/humphd/have-fun-with-machine-learning\ndocker run --name digits -d -p 8080:5000 -v $(pwd)/have-fun-with-machine-learning:/data/repo kaixhin/digits\n```\n\n這樣容器就開始執行了，你可以打開你的瀏覽器然後打開 `http://localhost:8080`。所有在這個 repository 的資料都在容器內的 `/data/repo` 了。就這樣。你已經把 Caffe 與 DIGITS 搞定了。\n\n如果你需要 shell access，請使用以下指令：\n\n```bash\ndocker exec -it digits /bin/bash\n```\n\n## 訓練類神經網絡\n\n訓練一個類神經網絡涉及到這些步驟：\n\n1. 組合及準備一個分類好的照片的資料集  \n2. 定義這個類神經網絡的架構  \n3. 用準備好的資料集訓練及驗證這個網絡\n\n我們將用三種方法做這件事以體現出從頭開始訓練與使用一個預先訓練好的網絡之間的差別，順便了解如何使用 AlexNet 與 GoogLeNet 這兩個相當受歡迎的預先訓練好的網絡，他們常常與 Caffe 和 DIGITS 搭配使用。\n\n我們將使用一個包含了海豚與海馬的小資料集來嘗試訓練。我已經把我使用的照片放在了 [data/dolphins-and-seahorses](data/dolphins-and-seahorses)。你需要最少兩個分類，不過你可以有更多（有些你將會用到的網絡是以一千多個影像分類訓練而成的）。我們的目標是當我們給我們的網絡一個圖片，它能告訴我們他是隻海豚還是海馬。\n\n### 準備資料集\n\n要開始，最簡單的方法是將你的圖片分成這個分類好的資料夾樣式：\n\n```\ndolphins-and-seahorses/\n    dolphin/\n        image_0001.jpg\n        image_0002.jpg\n        image_0003.jpg\n        ...\n    seahorse/\n        image_0001.jpg\n        image_0002.jpg\n        image_0003.jpg\n        ...\n```\n\n這裡的每個資料夾都是一個我們想分類的類別（category），在裡面的每個圖片都將被我們用來訓練及驗證我們的網絡。\n\n> 問：「照片都要一樣的大小嗎？那檔案名稱呢？」\n\n兩個都不用管他。在我們餵食網絡之前，圖片的大小都會被一般化。我們會希望我們的照片尺寸是 256 x 256 像素，DIGITS 等一下會自動裁切或縮放（這裡選擇縮放）我們的圖片。那些檔案名稱你要怎麼取根本沒差——重要的是它們是在什麼分類裡。\n\n> 問：「我可以再細分我的分類嗎？」\n\n可以。詳閱 https://github.com/NVIDIA/DIGITS/blob/digits-4.0/docs/ImageFolderFormat.md 。\n\n我們將使用這些在硬碟上的照片來建立一個**新的資料集**，而且是一個**分類用資料集**。\n\n![建立一個資料集](images/create-new-dataset.png?raw=true \"建立一個資料集\")\n\n我們將使用 DIGITS 的默認設定，然後將 **Training Images** 指向我們 [data/dolphins-and-seahorses](data/dolphins-and-seahorses) 的資料夾。DIGITS 將會以 `dolphin` 與 `seahorse` 這兩個分類來建立一個縮放好（256 x 256）的資料集，其中的 75% 用來訓練，另外的 25% 用來測試。\n\n給你的資料集取個名字：`dolphins-and-seahorses`，然後點選 **Create**。\n\n![新的影像辨識資料集](images/new-image-classification-dataset.png?raw=true \"新的影像辨識資料集\")\n\n這會建立我們的資料集，在我的筆電上只用了 4 秒就跑完了。最後我在兩個類別裡共有 92 個訓練用圖片（49 個海豚和 43 個海馬）和 30 個驗證用圖片（16 個海豚和 43 海馬）。這是個十分小的資料集，不過對於我們的實驗和學習用途十分完美——訓練及驗證一個用這個資料集的網絡不會花我們一輩子的時間。\n\n如果你想看看縮放之後的圖片，你可以**瀏覽資料庫**。\n\n![Explore the db](images/explore-dataset.png?raw=true \"Explore the db\")\n\n### 訓練：第一次嘗試，從頭開始訓練\n\n回到 DIGITS 的主畫面，我們需要先建立一個新的**分類用模型**：\n\n![建立分類用模型](images/create-classification-model.png?raw=true \"建立分類用模型\")\n\n我們將從訓練一個使用我們 `dolphins-and-seahorses` 資料集的模型開始，我們將以 DIGITS 給的默認設定值來訓練它。這是我們的第一個網絡，我們選擇使用一個標準的網絡架構——「[AlexNet (pdf)](http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf)」。[AlexNet 的設計](http://vision.stanford.edu/teaching/cs231b_spring1415/slides/alexnet_tugce_kyunghee.pdf) 在 2012 年贏得了一個大型的電腦視覺比賽——ImageNet。這個比賽要求將一百二十萬個圖像分類到一千多種不同的分類中。\n\n![新的分類用模型 1](images/new-image-classification-model-attempt1.png?raw=true \"新的分類用模型 1\")\n\nCaffe 使用結構化的文字檔案來定義網絡架構。這些檔案使用的是 [Google 的 Protocol Buffers](https://developers.google.com/protocol-buffers/)。你可以閱讀 Caffe 使用的[整個架構](https://github.com/BVLC/caffe/blob/master/src/caffe/proto/caffe.proto)。\n這不是我們主要要處理的部分，不過他們的存在值得我們注意，因為我們等會要修改他們。AlexNet 的 prototxt 檔案長這樣，例如：https://github.com/BVLC/caffe/blob/master/models/bvlc_alexnet/train_val.prototxt 。\n\n我們將會訓練我們的網絡 **30 個循環週期**。這表示網絡會使用我們的訓練圖片來學習，接著使用驗證圖片來測試他自己，然後根據結果來調整網絡的權重，然後重複這整個過程三十遍。當它每次完成一個循環之後我們會得到它的**準確度（_accuracy_）**（0% ~ 100%，越高越好）以及**損失（_loss_）**（所有錯誤的總和，值越低越好）。對於一個網路而言，最理想的狀況是有高準確度與最低的損失。\n\n一開始，我們網路的準確度大致低於 50%。這十分合理，因為它一開始只是在用隨機的權重值來在兩個分類之間進行猜測。隨著訓練的時間增加，它的準確度可以達到 87.5%，且損失為 0.37。我的電腦用了不到六分鐘的時間就跑完這 30 個循環週期了。\n\n![模型 嘗試 1](images/model-attempt1.png?raw=true \"模型 嘗試 1\")\n\n我們可以上傳一張照片或一個圖片的 URL 來測試我們的模型。讓我們使用一些不在我們資料集的圖片來測試看看：\n\n![模型 1 分類 1](images/model-attempt1-classify1.png?raw=true \"模型 1 分類 1\")\n\n![模型 1 分類 2](images/model-attempt1-classify2.png?raw=true \"模型 1 分類 2\")\n\n看起來還蠻不錯的，但是這一張的話 ...：\n\n![模型 1 分類 3](images/model-attempt1-classify3.png?raw=true \"模型 1 分類 3\")\n\n我們的網絡在這張圖上完全失敗了，而且將海馬混淆成了海豚，更糟糕的是，它十分有自信地認為這張圖是海豚。\n\n事實上其實是我們的資料集太小了，沒辦法訓練一個很好的類神經網絡。我們很需要上萬甚至數十萬張照片來訓練，如果要這樣，我們還會需要十分強大的運算能力來處理這些照片。\n\n### 訓練：第二次嘗試，微調 AlexNet\n\n#### 微調背後的原理 \n\n> 譯者有話要說（Translator's Note）：本段的內容較為複雜（很多專業術語），因此我的翻譯可能沒有很好。如果你願意，你可以看看原文，並希望你能順便幫忙改進翻譯，謝謝。\n\n從頭開始設計一個類神經網絡、取得足夠的資料來訓練它（例如上百萬張照片）以及用好幾周的時間使用 GPU 來運算已經超出我們大多數人的能力範圍了。如果要使用較少的資料來訓練，我們會採用一個叫做「**遷移學習（_Transfer Learning_）**」的技術，也有人稱之為「**微調（_Fine Tuning_）**」。「微調」利用深層類神經網絡的架構及事先訓練好的網絡來達成一開始的物件偵測。\n\n想像一下你一拿起望遠鏡要看很遠很遠的東西的時候，你會先將望遠鏡貼近你的眼睛，接著你看到的一切都是模糊的。隨著望遠鏡的焦距的調整，你會慢慢開始看見顏色、線條、形狀…… 慢慢地你就能看清楚一隻鳥的形狀。再稍微調整一下，你就能辨識這隻鳥的種類了。這就是使用一個類神經網絡的過程。\n\n在一個多層網絡中，初始層（_initial layer_）提取一些特徵（例如：邊緣），接下來的層使用這些特徵來偵測形狀（例如輪子與眼睛），然後送到以在之前的層累積的特徵來偵測物件的最終分類層（例如一隻貓跟一隻狗）。一個網絡必須能夠從像素點開始掃描，到圓形、到眼睛、到朝著特定方向的兩個眼睛等等，直到最終能夠斷定這個照片內描繪的是一隻貓。\n\n我們想做的是讓一個現有的、事先訓練好的網絡能夠專門來分類一些全新的影像分類，而不是讓它來分類當初用來訓練這個網絡的圖形。之所以這樣做是因為這種網絡已經知道如何「看見」圖形中的特徵，然後我們要重新訓練它來讓它能「看見」我們要他分類的特殊圖形。我們不需要從頭開始設定大多數的層——我們想要轉移這些已經學習好的層到我們的新分類任務。不像我們之前的訓練嘗試使用的是隨機的權重，我們這次要使用最終網絡中已有的權重來進行訓練。總而言之，我們將把最終的分類層丟掉，然後用**我們自己**的影像資料集來重新訓練它，將他微調到我們自己的影像分類。\n\n如果要這樣做，我們需要一個與所需資料足夠相似的現有網絡，這樣它學習到的權重對我們來說才會有用處。幸運的是我們接下來將使用的網絡是曾使用上百萬個來自 [ImageNet](http://image-net.org/) 大自然的照片來進行訓練的網絡，因此它對非常多種不同的分類任務都十分的有用處。\n\n這項技術常被用來做有趣的事情，例如從自醫學圖像中掃描是否有眼部疾病、識別從海上採集的浮游生物顯微圖像，到分類 Flickr 網站圖片的藝術風格。\n\n跟所有的機器學習一樣，如果你想做到完美，你需要了解你的資料以及網絡架構——你必須注意這些資料是否會造成過度學習（_overfitting_）、你可能需要修復其中幾層，或是加入新的幾層，諸如此類。總之，我的經驗是它在大多數的時候是可行的，你值得試試看，看你能用我們的方法做得如何。\n\n#### 上傳已事先訓練好的網絡\n\n在我們第一次的嘗試中，我們使用了 AlexNet 的架構，但是在該網絡的層中我們以隨機的權重來開始訓練。我們現在希望能夠下載並使用一個已經使用龐大的資料集來訓練過的 AlexNet 版本。\n\n令人感激的是我們完全可以這樣做。一個 AlexNet 快照（_snapshot_）可以在這裡下載：https://github.com/BVLC/caffe/tree/master/models/bvlc_alexnet 。\n我們需要 `.caffemodel` 檔案，它裡面包含了已經訓練過的權重。我們可以在此下載它：http://dl.caffe.berkeleyvision.org/bvlc_alexnet.caffemodel 。\n\n當你在下載他們的時候，我們再順便多下載一個吧。在 2014 年，Google 使用了一個 22 層的類神經網絡 [GoogLeNet](https://research.google.com/pubs/pub43022.html) (代號為「Inception」）贏了同一個 ImageNet 比賽：\nGoogLeNet 也有個快照可以下載，在這裡：https://github.com/BVLC/caffe/tree/master/models/bvlc_googlenet 。跟上次一樣，我們會需要含有已訓練過權重的 `.caffemodel` 檔案，你可以在這裡下載它：http://dl.caffe.berkeleyvision.org/bvlc_googlenet.caffemodel 。\n\n有了這些 `.caffemodel` 檔案，我們就可以把他們上傳到 DIGITS 裡了。在 DIGITS 的首頁選擇「**Pretrained Models**」然後選擇 「**Upload Pretrained Model**」：\n\n![載入事先訓練好的模型](images/load-pretrained-model.png?raw=true \"載入事先訓練好的模型\")\n\n這兩個模型我們都使用 DIGITS 提供的預設設定。我們只需要提供 `Weights (**.caffemodel)` ，即權重值檔案 `.caffemodel` 以及 `Model Definition (original.prototxt)` 模型定義檔案 `original.prototxt`。點一下對應的按鈕並選擇你的檔案就可以上傳。\n\nGoogLeNet 的模型定義檔案我們使用 https://github.com/BVLC/caffe/blob/master/models/bvlc_googlenet/train_val.prototxt ，AlexNet 的我們使用 https://github.com/BVLC/caffe/blob/master/models/bvlc_alexnet/train_val.prototxt 。我們不會使用到分類標籤（_classification labels_），所以我們將跳過 `labels.txt`。\n\n![上傳事先訓練好的模型](images/upload-pretrained-model.png?raw=true \"上傳事先訓練好的模型\")\n\n記得兩個網絡（AlexNet 與 GoogLeNet）都要上傳，兩個網絡我們下面都會用到。\n\n> 問：「有其他可以拿來微調的網絡嗎？」\n\n[Caffe Model Zoo](http://caffe.berkeleyvision.org/model_zoo.html) 還有蠻多可以用的已訓練好的網絡，詳閱 https://github.com/BVLC/caffe/wiki/Model-Zoo 。\n\n#### 針對海豚與海馬來微調 AlexNet\n\n用一個已訓練好的 Caffe 模型來訓練一個網絡還蠻像是從頭開始訓練的，只不過我們需要做一些細微的調整。首先，我們將調整**基礎學習速率**（_**Base Learning Rate**_），因為我們不需要很大的變動（我們在微調），因此我們將把它從 0.01 改為 0.001。接下來選取下面的「**Pretrained Network**（**事先訓練好的網絡**）」，然後選擇 **Customize**（**自定義**）。\n\n![新的圖像分類用模型](images/new-image-classification-model-attempt2.png?raw=true \"新的圖像分類用模型\")\n\n在事先訓練好的模型的 prototext 定義中，我們需要將所有參考重命名到最終的**全連結層（_Fully Connected Layer_）**，全連結層負責最終分類。我們這樣做是因為我們希望模型自我們自己的資料集中重新學習新的分類，而不是使用它原本的訓練資料——我們要把它目前的最終層丟掉。我們必須將最終全連結層的名字「fc8」改為別的名字，就改成「fc9」好了。最後，我們需要把類別數量從 `1000` 改為 `2`，也就是將 `num_output` 改為 `2`。\n\n這是我們所需要作出的更動：\n\n```diff\n@@ -332,8 +332,8 @@\n }\n layer {\n-  name: \"fc8\"\n+  name: \"fc9\"\n   type: \"InnerProduct\"\n   bottom: \"fc7\"\n-  top: \"fc8\"\n+  top: \"fc9\"\n   param {\n     lr_mult: 1\n@@ -345,5 +345,5 @@\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"gaussian\"\n@@ -359,5 +359,5 @@\n   name: \"accuracy\"\n   type: \"Accuracy\"\n-  bottom: \"fc8\"\n+  bottom: \"fc9\"\n   bottom: \"label\"\n   top: \"accuracy\"\n@@ -367,5 +367,5 @@\n   name: \"loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"fc8\"\n+  bottom: \"fc9\"\n   bottom: \"label\"\n   top: \"loss\"\n@@ -375,5 +375,5 @@\n   name: \"softmax\"\n   type: \"Softmax\"\n-  bottom: \"fc8\"\n+  bottom: \"fc9\"\n   top: \"softmax\"\n   include { stage: \"deploy\" }\n```\n\n這裡有一份我實際在使用的修改過後的檔案：[src/alexnet-customized.prototxt](src/alexnet-customized.prototxt)。\n\n這次我們的準確度從 60% 上下然後立刻爬升到 87.5%，接著再到 96% 然後一路上升到 100%，損失也穩定地下降。五分鐘之後我們的結果是 100% 的準確度與 0.0009 的損失。\n\n![模型訓練嘗試 2](images/model-attempt2.png?raw=true \"模型訓練嘗試 2\")\n\n測試我們前一個網絡判斷錯誤的同一張照片，我們可以看到一個極大的差距：這次的結果是 100% 海馬。\n\n![模型 2 分類 1](images/model-attempt2-classify1.png?raw=true \"模型 2 分類 1\")\n\n就算是一個小孩畫的海馬都可以：\n\n![模型 2 分類 2](images/model-attempt2-classify2.png?raw=true \"模型 2 分類 2\")\n\n海豚的結果也一樣：\n\n![模型 2 分類 3](images/model-attempt2-classify3.png?raw=true \"模型 2 分類 3\")\n\n甚至你覺得可能很難判斷的照片，像是這張照片裡面有很多隻海豚靠在一起，且他們的身體幾乎都在水下，我們的網絡還是能給出正確的答案：\n\n![模型 2 分類 4](images/model-attempt2-classify4.png?raw=true \"模型 2 分類 4\")\n\n\n### 訓練：第三次嘗試，微調 GoogLeNet\n\n像是前面被我們拿來微調的的 AlexNet 模型，我們一樣可以用在 GoogLeNet 上。要修改 GoogLeNet 有點棘手，因為你需要重新定義三個全連結層，上次我們只重新定義了一個。\n\n我們要再一次建立一個新的**分類用模型**（_**Classification Model**_）以微調 GoogLeNet 至我們想要的狀態。\n\n![新的分類用模型](images/new-image-classification-model-attempt3.png?raw=true \"新的分類用模型\")\n\n我們將重新命名所有到這三個全連結辨識層的參考：`loss1/classifier`、`loss2/classifier` 和 `loss3/classifier`。接著我們要重新設定類別的數量（`num_output: 2`）。以下是我們需要更動的地方以修改上述設定：\n\n```diff\n@@ -917,10 +917,10 @@\n   exclude { stage: \"deploy\" }\n }\n layer {\n-  name: \"loss1/classifier\"\n+  name: \"loss1a/classifier\"\n   type: \"InnerProduct\"\n   bottom: \"loss1/fc\"\n-  top: \"loss1/classifier\"\n+  top: \"loss1a/classifier\"\n   param {\n     lr_mult: 1\n     decay_mult: 1\n@@ -930,7 +930,7 @@\n     decay_mult: 0\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"xavier\"\n       std: 0.0009765625\n@@ -945,7 +945,7 @@\n layer {\n   name: \"loss1/loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"loss1/classifier\"\n+  bottom: \"loss1a/classifier\"\n   bottom: \"label\"\n   top: \"loss1/loss\"\n   loss_weight: 0.3\n@@ -954,7 +954,7 @@\n layer {\n   name: \"loss1/top-1\"\n   type: \"Accuracy\"\n-  bottom: \"loss1/classifier\"\n+  bottom: \"loss1a/classifier\"\n   bottom: \"label\"\n   top: \"loss1/accuracy\"\n   include { stage: \"val\" }\n@@ -962,7 +962,7 @@\n layer {\n   name: \"loss1/top-5\"\n   type: \"Accuracy\"\n-  bottom: \"loss1/classifier\"\n+  bottom: \"loss1a/classifier\"\n   bottom: \"label\"\n   top: \"loss1/accuracy-top5\"\n   include { stage: \"val\" }\n@@ -1705,10 +1705,10 @@\n   exclude { stage: \"deploy\" }\n }\n layer {\n-  name: \"loss2/classifier\"\n+  name: \"loss2a/classifier\"\n   type: \"InnerProduct\"\n   bottom: \"loss2/fc\"\n-  top: \"loss2/classifier\"\n+  top: \"loss2a/classifier\"\n   param {\n     lr_mult: 1\n     decay_mult: 1\n@@ -1718,7 +1718,7 @@\n     decay_mult: 0\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"xavier\"\n       std: 0.0009765625\n@@ -1733,7 +1733,7 @@\n layer {\n   name: \"loss2/loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"loss2/classifier\"\n+  bottom: \"loss2a/classifier\"\n   bottom: \"label\"\n   top: \"loss2/loss\"\n   loss_weight: 0.3\n@@ -1742,7 +1742,7 @@\n layer {\n   name: \"loss2/top-1\"\n   type: \"Accuracy\"\n-  bottom: \"loss2/classifier\"\n+  bottom: \"loss2a/classifier\"\n   bottom: \"label\"\n   top: \"loss2/accuracy\"\n   include { stage: \"val\" }\n@@ -1750,7 +1750,7 @@\n layer {\n   name: \"loss2/top-5\"\n   type: \"Accuracy\"\n-  bottom: \"loss2/classifier\"\n+  bottom: \"loss2a/classifier\"\n   bottom: \"label\"\n   top: \"loss2/accuracy-top5\"\n   include { stage: \"val\" }\n@@ -2435,10 +2435,10 @@\n   }\n }\n layer {\n-  name: \"loss3/classifier\"\n+  name: \"loss3a/classifier\"\n   type: \"InnerProduct\"\n   bottom: \"pool5/7x7_s1\"\n-  top: \"loss3/classifier\"\n+  top: \"loss3a/classifier\"\n   param {\n     lr_mult: 1\n     decay_mult: 1\n@@ -2448,7 +2448,7 @@\n     decay_mult: 0\n   }\n   inner_product_param {\n-    num_output: 1000\n+    num_output: 2\n     weight_filler {\n       type: \"xavier\"\n     }\n@@ -2461,7 +2461,7 @@\n layer {\n   name: \"loss3/loss\"\n   type: \"SoftmaxWithLoss\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   bottom: \"label\"\n   top: \"loss\"\n   loss_weight: 1\n@@ -2470,7 +2470,7 @@\n layer {\n   name: \"loss3/top-1\"\n   type: \"Accuracy\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   bottom: \"label\"\n   top: \"accuracy\"\n   include { stage: \"val\" }\n@@ -2478,7 +2478,7 @@\n layer {\n   name: \"loss3/top-5\"\n   type: \"Accuracy\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   bottom: \"label\"\n   top: \"accuracy-top5\"\n   include { stage: \"val\" }\n@@ -2489,7 +2489,7 @@\n layer {\n   name: \"softmax\"\n   type: \"Softmax\"\n-  bottom: \"loss3/classifier\"\n+  bottom: \"loss3a/classifier\"\n   top: \"softmax\"\n   include { stage: \"deploy\" }\n }\n```\n\n我已經將完整的檔案放在了 [src/googlenet-customized.prototxt](src/googlenet-customized.prototxt)。\n\n> 問：「那對於這些網絡的 prototext 定義修改呢？我們已經修改了全連接層的名字還有類別的數量，還有什麼是我們可以或是應該要修改的東西，且是在什麼情況下？」\n\n很棒的問題，這也是我很想知道的事情。舉例來說，我知道我們可以[「修復」特定的「層」](https://github.com/BVLC/caffe/wiki/Fine-Tuning-or-Training-Certain-Layers-Exclusively)，這樣權重值就不會變動。做別的事情需要理解這些層背後的原理，這已經超出本教學的範圍，也已經超出本教學作者的知識範圍！\n\n就像我們對 AlexNet 所做的微調，我們也降低了 10% 的學習速率（_learning rate_），即從 `0.01` 降低到 `0.001`。\n\n> 問：「在微調時，還有哪些有意義的其他的更動？例如不同的循環週期數（_epochs_）怎麼樣？批尺寸（_batch sizes_）、求解方法（Adam、AdaDelta、AdaGrad 之類的）呢？學習速率（_learning rates_）、策略（Exponential Decay、Inverse Decay 和 Sigmoid Decay 等等）、步長和 gamma 值呢？」\n\n很好的問題，而且也是個我很好奇的問題。我對這些東西也只有很模糊的理解，如果你知道訓練時要如何調整這些數值，我們的設定也應該可以做出一些改進。這東西需要更好的說明文件。\n\n因為 GoogLeNet 的結構比 AlexNet 複雜得多，微調它要花上更多時間。我用了十分鐘用我們的資料集重新在我的筆電上訓練它，達到了 100% 的準確度以及 0.0070 的損失。\n\n![模型 第三次訓練嘗試](images/model-attempt3.png?raw=true \"模型 第三次訓練嘗試 3 辨識 3\")\n\n跟我們看到微調後 AlexNet 的表現一樣，我們修改過的 GoogLeNet 表現的也十分出色——它是我們目前訓練出最好的模型。\n\n![模型 第三次訓練嘗試 3 辨識 1](images/model-attempt3-classify1.png?raw=true \"模型 第三次訓練嘗試 3 辨識 1\")\n\n![模型 第三次訓練嘗試 3 辨識 2](images/model-attempt3-classify2.png?raw=true \"模型 第三次訓練嘗試 3 辨識 2\")\n\n![模型 第三次訓練嘗試 3 辨識 3](images/model-attempt3-classify3.png?raw=true \"模型 第三次訓練嘗試 3 辨識 3\")\n\n## 使用我們的模型\n\n我們已經訓練並測試好了我們的網絡，是時候下載並實際使用它了。每個我們在 DIGITS 內訓練的模型都有個 **Download Model**（**下載模型**） 的按鈕，也可以用來選擇不同的訓練時快照——例如 `Epoch #30`（`循環週期 #30`）：\n\n![訓練完成的模型](images/trained-models.png?raw=true “訓練完成的模型”)\n\n按下 **Download Model** 將會下載一個 `tar.gz` 壓縮檔，裡面有這些檔案：\n\n```\ndeploy.prototxt\nmean.binaryproto\nsolver.prototxt\ninfo.json\noriginal.prototxt\nlabels.txt\nsnapshot_iter_90.caffemodel\ntrain_val.prototxt\n```\n\n這裡有個對於如何使用我們剛訓練好的模型的一個[不錯的說明](https://github.com/BVLC/caffe/wiki/Using-a-Trained-Network:-Deploy)，裡面談到了：\n\n> 一個網絡是以其設計（.prototxt）及其權重（.caffemodel）來定義的。\n> 當一個網絡在訓練時，該網絡目前的權重狀態存在一個 .caffemodel 檔案中。\n> 當有了這兩個檔案，我們就可以從訓練及測試階段進入成品階段（_production phase_）了。\n>\n> 在它目前的狀態下，這個網絡的設計還沒有為部署準備好。在我們將我們的網絡釋出為產品前，我們常需要用以下的方法來調整它：\n>\n> 1. 將用來訓練的資料層刪除，因為在分類時我們將不會再為我們的資料提供標籤。\n> 2. 刪除任何依賴於資料標籤的層。\n> 3. 將網絡設定為可接受資料。\n> 4. 確認網絡可以輸出結果。\n\nDIGITS 已經幫我們把這些問題都解決了，也幫我們分離了不同的 `prototxt` 檔案版本。當我們在使用這個網絡的時候我們將會用到以下檔案：\n\n* `deploy.prototxt` —— 網絡的定義檔案，準備好接受影像輸入資料\n* `mean.binaryproto` —— 我們的模型會需要我們為每個它要處理的影像減去影像平均值（_image mean_），且這是平均影像資料（_the mean image_）。\n* `labels.txt` —— 一個放了我們所有標籤的列表（`dolphin` 與 `seahorse`），如果我們想看到網絡輸出的是這些標籤而不是類別編號時，這個派的上用場。\n* `snapshot_iter_90.caffemodel` —— 這是我們網絡訓練好的權重\n\n我們可以用不少方式以這些檔案來分類新的影像。例如，在我們的 `CAFFE_ROOT` 下，我們可以使用 `build/examples/cpp_classification/classification.bin` 來分類一個影像：\n\n```bash\n$ cd $CAFFE_ROOT/build/examples/cpp_classification\n$ ./classification.bin deploy.prototxt snapshot_iter_90.caffemodel mean.binaryproto labels.txt dolphin1.jpg\n```\n\n這會噴出一堆 debug 資訊，接下來是分別對兩個類別的預測結果：\n\n```\n0.9997 - “dolphin”\n0.0003 - “seahorse”\n```\n\n你可以在 [Caffe 範例](https://github.com/BVLC/caffe/tree/master/examples)中閱讀這個東西的[完整 C++ 原始碼](https://github.com/BVLC/caffe/tree/master/examples/cpp_classification)。\n\n對於 Python 應用程式來說，DIGITS 也有提供一個[不錯的範例](https://github.com/NVIDIA/DIGITS/tree/master/examples/classification)。Caffe 範例中也有一個[十分詳細的 Python 版教學](https://github.com/BVLC/caffe/blob/master/examples/00-classification.ipynb)。\n\n### Python 示例\n\n我們來寫一個用圖像分類程式，使用我們微調過的 GoogLeNet 模型來分類我們現有的未經訓練的圖片，它們在 [data/untrained-samples](data/untrained-samples) 裡。我已經把上面的例子都組合了起來，雖然 `caffe` [Python module 的原始碼](https://github.com/BVLC/caffe/tree/master/python) 也已經有了，但是你應該還是會比較喜歡我接下來要講的範例。\n\n接下來我要講的內容都在 [src/classify-samples.py](src/classify-samples.py) 裡，讓我們開始吧！\n\n首先，我們會需要一個叫 [NumPy](http://www.numpy.org/) 的模組（_module_）。我們等下會用它來操作 Caffe 大量使用的 [`ndarray`](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html)。如果你還沒使用過他們（我也沒有），你可以先閱讀這篇[快速入門教學](https://docs.scipy.org/doc/numpy-dev/user/quickstart.html)。\n\n接下來，我們會需要從 `CAFFE_ROOT` 載入 `caffe` 模組。如果它還沒有被加入到你的 Python 環境裡，你可以手動加入以強制載入它，我們也會順便載入 Caffe 的 protobuf 模組。\n\n```python\nimport numpy as np\n\ncaffe_root = '/path/to/your/caffe_root'\nsys.path.insert(0, os.path.join(caffe_root, 'python'))\nimport caffe\nfrom caffe.proto import caffe_pb2\n```\n\n接下來我們需要告訴 Caffe 要用 [CPU 還是 GPU](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/_caffe.cpp#L50-L52)。\n對於我們的實驗來說，CPU 就夠了：\n\n```python\ncaffe.set_mode_cpu()\n```\n\n現在我們可以使用 `caffe` 來載入我們訓練的網絡，我們會需要一些我們剛從 DIGITS 下載好的檔案：\n\n* `deploy.prototxt` —— 我們的「網絡檔案」，即網絡的描述。\n* `snapshot_iter_90.caffemodel` —— 我們訓練好的「權重」資料\n\n我們很顯然地需要提供完整的路徑（_full path_），我假設我的這些檔案放在一個叫做 `model/` 的資料夾：\n\n```python\nmodel_dir = 'model'\ndeploy_file = os.path.join(model_dir, 'deploy.prototxt')\nweights_file = os.path.join(model_dir, 'snapshot_iter_90.caffemodel')\nnet = caffe.Net(deploy_file, caffe.TEST, weights=weights_file)\n```\n`caffe.Net()` 的[構造函數（_constructor_）](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/_caffe.cpp#L91-L117)需要一個網絡檔案、一個階段描述（`caffe.TEST` 或 `caffe.TRAIN`）與一個（可選的）權重檔案名稱。當我們提供一個權重檔案時，`Net` 將會自動幫我們載入它。`Net` 有著不少你可以用的[方法與屬性](https://github.com/BVLC/caffe/blob/master/python/caffe/pycaffe.py)。\n\n**注：** 這個構造函數也有一個[已棄用的版本](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/_caffe.cpp#L119-L134)，它看起來常常在網絡上的範例程式碼中出現。如果你遇到了它，它看起來會像是這樣：\n\n```python\nnet = caffe.Net(str(deploy_file), str(model_file), caffe.TEST)\n```\n\n我們之後會將各式各樣大小的照片丟到我們的網絡中進行測試。因此，我們將把這些照片**轉換**成一個我們的網絡可以用的形狀（colour、256x256）。Caffe 提供了一個 [`Transformer` class](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L98) 專門用來處理這種情況。我們將會使用它來建立一個適合我們的影像及網絡的轉換器：\n\n```python\ntransformer = caffe.io.Transformer({'data': net.blobs['data'].data.shape})\n# set_transpose: https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L187\ntransformer.set_transpose('data', (2, 0, 1))\n# set_raw_scale: https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L221\ntransformer.set_raw_scale('data', 255)\n# set_channel_swap: https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L203\ntransformer.set_channel_swap('data', (2, 1, 0))\n```\n\n我們也可以使用 DIGITS 給了我們的 `mean.binaryproto` 檔案來設定我們的轉換器：\n\n```python\n# This code for setting the mean from https://github.com/NVIDIA/DIGITS/tree/master/examples/classification\nmean_file = os.path.join(model_dir, 'mean.binaryproto')\nwith open(mean_file, 'rb') as infile:\n    blob = caffe_pb2.BlobProto()\n    blob.MergeFromString(infile.read())\n    if blob.HasField('shape'):\n        blob_dims = blob.shape\n        assert len(blob_dims) == 4, 'Shape should have 4 dimensions - shape is %s' % blob.shape\n    elif blob.HasField('num') and blob.HasField('channels') and \\\n            blob.HasField('height') and blob.HasField('width'):\n        blob_dims = (blob.num, blob.channels, blob.height, blob.width)\n    else:\n        raise ValueError('blob does not provide shape or 4d dimensions')\n    pixel = np.reshape(blob.data, blob_dims[1:]).mean(1).mean(1)\n    transformer.set_mean('data', pixel)\n```\n\n如果我們有很多標籤，我們也可以選擇讀取我們的標籤檔案以用作稍後輸出機率的標籤（如：0=dolphin，1=seahorse）：\n\n```python\nlabels_file = os.path.join(model_dir, 'labels.txt')\nlabels = np.loadtxt(labels_file, str, delimiter='\\n')\n```\n\n現在我們已經準備好來辨識一個影像了。我們要使用 [`caffe.io.load_image()`](https://github.com/BVLC/caffe/blob/61944afd4e948a4e2b4ef553919a886a8a8b8246/python/caffe/io.py#L279) 來讀取我們的影像檔案，然後再使用我們的轉換器來重塑它，最後將它設定為我們網絡的資料層：\n\n```python\n# Load the image from disk using caffe's built-in I/O module\nimage = caffe.io.load_image(fullpath)\n# Preprocess the image into the proper format for feeding into the model\nnet.blobs['data'].data[...] = transformer.preprocess('data', image)\n```\n\n> 問：「我要怎麼測試來自相機或視訊流（幀）的影像而不是使用檔案來測試？」\n\n很棒的問題，以下是個供你開始的範例：\n\n```python\nimport cv2\n...\n# Get the shape of our input data layer, so we can resize the image\ninput_shape = net.blobs['data'].data.shape\n...\nwebCamCap = cv2.VideoCapture(0) # could also be a URL, filename\nif webCamCap.isOpened():\n    rval, frame = webCamCap.read()\nelse:\n    rval = False\n\nwhile rval:\n    rval, frame = webCamCap.read()\n    net.blobs['data'].data[...] = transformer.preprocess('data', frame)\n    ...\n\nwebCamCap.release()\n```\n\n回到我們的問題，我們接下來需要將我們的影像資料跑一遍我們的網絡然後再讀取我們網絡最終的 `'softmax'` 層返回的機率值，這個機率會依照我們的標籤分類來排序：\n\n```python\n# Run the image's pixel data through the network\nout = net.forward()\n# Extract the probabilities of our two categories from the final layer\nsoftmax_layer = out['softmax']\n# Here we're converting to Python types from ndarray floats\ndolphin_prob = softmax_layer.item(0)\nseahorse_prob = softmax_layer.item(1)\n\n# Print the results. I'm using labels just to show how it's done\nlabel = labels[0] if dolphin_prob > seahorse_prob else labels[1]\nfilename = os.path.basename(fullpath)\nprint '%s is a %s dolphin=%.3f%% seahorse=%.3f%%' % (filename, label, dolphin_prob*100, seahorse_prob*100)\n```\n\n使用我們微調的 GoogLeNet 以這整個程式（見 [src/classify-samples.py](src/classify-samples.py)）來測試我們的 [data/untrained-samples](data/untrained-samples) 影像，我得到了這些輸出：\n\n```\n[...truncated caffe network output...]\ndolphin1.jpg is a dolphin dolphin=99.968% seahorse=0.032%\ndolphin2.jpg is a dolphin dolphin=99.997% seahorse=0.003%\ndolphin3.jpg is a dolphin dolphin=99.943% seahorse=0.057%\nseahorse1.jpg is a seahorse dolphin=0.365% seahorse=99.635%\nseahorse2.jpg is a seahorse dolphin=0.000% seahorse=100.000%\nseahorse3.jpg is a seahorse dolphin=0.014% seahorse=99.986%\n```\n\n我還在試著學習所有使用程式碼來處理模型的最佳實踐。我很希望我能告訴你們更多更好的程式碼範例、API 與現有的模組等等。\n老實說，我找到的大多數程式碼範例都很簡潔，而且文件都寫的很糟糕——Caffe 的文件有很多問題，而且有著很多的假設。\n\n在我看來，應該有人能夠以 Caffe 介面為基礎來建立更高級別的工具與基本的工作流程，也就是我們以上所做的事情。如果在高級語言中有更多我能夠跟你指出它有「正確地使用我們的模型」的更簡單模組，那一定會很棒；應該有人能夠做到這一點，並且讓*使用* Caffe 模型跟使用 DIGITS 來*訓練*這些模型一樣簡單。舉例來說，我很希望我能夠用 node.js 來操作這些東西。最理想的情況是有一天沒有人會需要知道這麼多有關於模型與 Caffe 的運作模式。[DeepDetect](https://deepdetect.com/) 在這一點看起來十分的有趣，不過我還沒使用過它。而且我認為還有很多我不知道的工具。\n\n## 結果\n\n在最初我們說了我們的目標是寫一個能夠使用一個類神經網絡來正確分類 [data/untrained-samples](data/untrained-samples) 中的所有照片的程式。這些是在上述過程中從來沒用來訓練或是測試過的海豚或海馬的圖片：\n\n### 未訓練的海豚影像\n\n![海豚 1](data/untrained-samples/dolphin1.jpg?raw=true \"海豚 1\")\n![海豚 2](data/untrained-samples/dolphin2.jpg?raw=true \"海豚 2\")\n![海豚 3](data/untrained-samples/dolphin3.jpg?raw=true \"海豚 3\")\n\n### 未訓練的海馬影像\n\n![海馬 1](data/untrained-samples/seahorse1.jpg?raw=true \"海馬 1\")\n![海馬 2](data/untrained-samples/seahorse2.jpg?raw=true \"海馬 2\")\n![海馬 3](data/untrained-samples/seahorse3.jpg?raw=true \"海馬 3\")\n\n讓我們看看我們的三個訓練嘗試分別做得怎麼樣：\n\n### 模型第一次訓練嘗試：從頭開始訓練的 AlexNet（第三名）\n\n| 照片 | 海豚 | 海馬 | 結果 |\n|-------|---------|----------|--------|\n|[dolphin1.jpg](data/untrained-samples/dolphin1.jpg)| 71.11% | 28.89% | :expressionless: |\n|[dolphin2.jpg](data/untrained-samples/dolphin2.jpg)| 99.2% | 0.8% | :sunglasses: |\n|[dolphin3.jpg](data/untrained-samples/dolphin3.jpg)| 63.3% | 36.7% | :confused: |\n|[seahorse1.jpg](data/untrained-samples/seahorse1.jpg)| 95.04% | 4.96% | :disappointed: |\n|[seahorse2.jpg](data/untrained-samples/seahorse2.jpg)| 56.64% | 43.36 |  :confused: |\n|[seahorse3.jpg](data/untrained-samples/seahorse3.jpg)| 7.06% | 92.94% |  :grin: |\n\n### 模型第二次訓練嘗試: 微調後的 AlexNet（第二名）\n\n| 照片 | 海豚 | 海馬 | 結果 |\n|-------|---------|----------|--------|\n|[dolphin1.jpg](data/untrained-samples/dolphin1.jpg)| 99.1% | 0.09% |  :sunglasses: |\n|[dolphin2.jpg](data/untrained-samples/dolphin2.jpg)| 99.5% | 0.05% |  :sunglasses: |\n|[dolphin3.jpg](data/untrained-samples/dolphin3.jpg)| 91.48% | 8.52% |  :grin: |\n|[seahorse1.jpg](data/untrained-samples/seahorse1.jpg)| 0% | 100% |  :sunglasses: |\n|[seahorse2.jpg](data/untrained-samples/seahorse2.jpg)| 0% | 100% |  :sunglasses: |\n|[seahorse3.jpg](data/untrained-samples/seahorse3.jpg)| 0% | 100% |  :sunglasses: |\n\n### 模型第三次訓練嘗試: 微調後的 GoogLeNet（第一名）\n\n| 照片 | 海豚 | 海馬 | 結果 |\n|-------|---------|----------|--------|\n|[dolphin1.jpg](data/untrained-samples/dolphin1.jpg)| 99.86% | 0.14% |  :sunglasses: |\n|[dolphin2.jpg](data/untrained-samples/dolphin2.jpg)| 100% | 0% |  :sunglasses: |\n|[dolphin3.jpg](data/untrained-samples/dolphin3.jpg)| 100% | 0% |  :sunglasses: |\n|[seahorse1.jpg](data/untrained-samples/seahorse1.jpg)| 0.5% | 99.5% |  :sunglasses: |\n|[seahorse2.jpg](data/untrained-samples/seahorse2.jpg)| 0% | 100% |  :sunglasses: |\n|[seahorse3.jpg](data/untrained-samples/seahorse3.jpg)| 0.02% | 99.98% |  :sunglasses: |\n\n## 結論\n\n我們的模型跑起來真的十分令人驚訝，微調一個事先訓練好的網絡之後的成效也是。很明顯的，我們使用海豚及海馬作為例子是故意設計好的，且我們的資料集也太有限了——如果我們希望我們的網絡變得很強大，我們真的會需要更多更好的資料。不過既然我們的目的是玩玩看類神經網絡的工具及工作流程，這個結果還是十分理想的，尤其是它不需要昂貴的設備或大量的時間。\n\n我希望以上所有的經驗能讓你拋去所有剛踏進這個領域時產生的壓倒性恐懼。當你看過機器學習及類神經網絡實際運作的小例子之後，你應該能更容易地確定你是否值得在這個領域投入時間來學習它們背後的理論。現在你已經有了一個設定好的環境及一個可行的方法，你可以嘗試做做看其他類型的分類。你也可能會想要看看你還能用 Caffe 和 Digits 做什麼事情，例如在一個影像內尋找物件或是執行分割。\n\n「Have fun with machine learning!」\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}