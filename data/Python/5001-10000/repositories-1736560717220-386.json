{
  "metadata": {
    "timestamp": 1736560717220,
    "page": 386,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "amoffat/sh",
      "stars": 7002,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".coveragerc",
          "type": "blob",
          "size": 0.146484375,
          "content": "[run]\nbranch = True\nsource = sh\nrelative_files = True\n\n[report]\nexclude_lines =\n    pragma: no cover\n    if __name__  == .__main__.:\n    def __repr__\n"
        },
        {
          "name": ".flake8",
          "type": "blob",
          "size": 0.048828125,
          "content": "[flake8]\nmax-line-length = 88\nextend-ignore = E203"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0947265625,
          "content": "__pycache__/\n*.py[co]\n.tox\n.coverage\n/.cache/\n/.venv/\n/build\n/dist\n/docs/build\n/TODO.md\n/htmlcov/"
        },
        {
          "name": ".python-version",
          "type": "blob",
          "size": 0.0068359375,
          "content": "3.9.16\n"
        },
        {
          "name": ".readthedocs.yaml",
          "type": "blob",
          "size": 0.7685546875,
          "content": "# .readthedocs.yaml\n# Read the Docs configuration file\n# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details\n\n# Required\nversion: 2\n\n# Set the OS, Python version and other tools you might need\nbuild:\n  os: ubuntu-22.04\n  tools:\n    python: \"3.10\"\n  jobs:\n    post_create_environment:\n      - pip install poetry\n      - poetry config virtualenvs.create false\n    post_install:\n      - poetry install\n      - pip install -e .\n\n# Build documentation in the \"docs/\" directory with Sphinx\nsphinx:\n  configuration: docs/source/conf.py\n# Optional but recommended, declare the Python requirements required\n# to build your documentation\n# See https://docs.readthedocs.io/en/stable/guides/reproducible-builds.html\npython:\n  install:\n    - requirements: docs/requirements.txt\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 17.498046875,
          "content": "# Changelog\n\n## 2.2.1 - 1/9/25\n\n- Bugfix where `async` and `return_cmd` does not raise exceptions [#746](https://github.com/amoffat/sh/pull/746)\n\n## 2.2.0 - 1/9/25\n\n- `return_cmd` with `await` now works correctly [#743](https://github.com/amoffat/sh/issues/743)\n- Formal support for Python 3.12\n\n## 2.1.0 - 10/8/24\n\n- Add contrib command `sh.contrib.bash` [#736](https://github.com/amoffat/sh/pull/736)\n\n## 2.0.7 - 5/31/24\n\n- Fix `sh.glob` arguments [#708](https://github.com/amoffat/sh/issues/708)\n- Misc modernizations\n\n## 2.0.6 - 8/9/23\n\n- Add back appropriate sdist files [comment](https://github.com/amoffat/sh/commit/89333ae48069a5b445b3535232195b2de6f4648f)\n\n## 2.0.5 - 8/7/23\n\n- Allow nested `with` contexts [#690](https://github.com/amoffat/sh/issues/690)\n- Call correct asyncio function for getting event loop [#683](https://github.com/amoffat/sh/issues/683)\n\n## 2.0.4 - 5/13/22\n\n- Allow `ok_code` to be used with `fg` [#665](https://github.com/amoffat/sh/pull/665)\n- Make sure `new_group` never creates a new session [#675](https://github.com/amoffat/sh/pull/675)\n\n## 2.0.2 / 2.0.3 (misversioned) - 2/13/22\n\n- Performance regression when using a generator with `_in` [#650](https://github.com/amoffat/sh/pull/650)\n- Adding test support for python 3.11\n\n## 2.0.0 - 2/9/22\n\n- Executed commands now return a unicode string by default\n- Removed magical module-like execution contexts [#636](https://github.com/amoffat/sh/issues/636)\n- Added basic asyncio support via `_async`\n- Dropped support for Python < 3.8\n- Bumped default tty size to more standard (24, 80)\n- First argument being a RunningCommand no longer automatically passes it as stdin\n- `RunningCommand.__eq__` no longer has the side effect of executing the command [#518](https://github.com/amoffat/sh/pull/531)\n- `_tee` now supports both \"err\" and \"out\" [#215](https://github.com/amoffat/sh/issues/215)\n- Removed the builtin override `cd` [link](https://github.com/amoffat/sh/pull/584#discussion_r698055681)\n- Altered process launching model to behave more expectedly [#495](https://github.com/amoffat/sh/issues/495)\n- Bugfix where `_no_out` isn't allowed with `_iter=\"err\"` [#638](https://github.com/amoffat/sh/issues/638)\n- Allow keyword arguments to have a list of values [#529](https://github.com/amoffat/sh/issues/529)\n\n## 1.14.3 - 7/17/22\n\n- Bugfix where `Command` was not aware of default call args when wrapping the module [#559](https://github.com/amoffat/sh/pull/573)\n\n## 1.14.1 - 10/24/20\n\n- bugfix where setting `_ok_code` to not include 0, but 0 was the exit code [#545](https://github.com/amoffat/sh/pull/545)\n\n## 1.14.0 - 8/28/20\n\n- `_env` now more lenient in accepting dictionary-like objects [#527](https://github.com/amoffat/sh/issues/527)\n- `None` and `False` arguments now do not pass through to underlying command [#525](https://github.com/amoffat/sh/pull/525)\n- Implemented `find_spec` on the fancy importer, which fixes some Python3.4+ issues [#536](https://github.com/amoffat/sh/pull/536)\n\n## 1.13.1 - 4/28/20\n\n- regression fix if `_fg=False` [#520](https://github.com/amoffat/sh/issues/520)\n\n## 1.13.0 - 4/27/20\n\n- minor Travis CI fixes [#492](https://github.com/amoffat/sh/pull/492)\n- bugfix for boolean long options not respecting `_long_prefix` [#488](https://github.com/amoffat/sh/pull/488)\n- fix deprecation warning on Python 3.6 regexes [#482](https://github.com/amoffat/sh/pull/482)\n- `_pass_fds` and `_close_fds` special kwargs for controlling file descriptor inheritance in child.\n- more efficiently closing inherited fds [#406](https://github.com/amoffat/sh/issues/406)\n- bugfix where passing invalid dictionary to `_env` will cause a mysterious child 255 exit code. [#497](https://github.com/amoffat/sh/pull/497)\n- bugfix where `_in` using 0 or `sys.stdin` wasn't behaving like a TTY, if it was in fact a TTY. [#514](https://github.com/amoffat/sh/issues/514)\n- bugfix where `help(sh)` raised an exception [#455](https://github.com/amoffat/sh/issues/455)\n- bugfix fixing broken interactive ssh tutorial from docs\n- change to automatic tty merging into a single pty if `_tty_in=True` and `_tty_out=True`\n- introducing `_unify_ttys`, default False, which allows explicit tty merging into single pty\n- contrib command for `ssh` connections requiring passwords\n- performance fix for polling output too fast when using `_iter` [#462](https://github.com/amoffat/sh/issues/462)\n- execution contexts can now be used in python shell [#466](https://github.com/amoffat/sh/pull/466)\n- bugfix `ErrorReturnCode` instances can now be pickled\n- bugfix passing empty string or `None` for `_in` hanged [#427](https://github.com/amoffat/sh/pull/427)\n- bugfix where passing a filename or file-like object to `_out` wasn't using os.dup2 [#449](https://github.com/amoffat/sh/issues/449)\n- regression make `_fg` work with `_cwd` again [#330](https://github.com/amoffat/sh/issues/330)\n- an invalid `_cwd` now raises a `ForkException` not an `OSError`.\n- AIX support [#477](https://github.com/amoffat/sh/issues/477)\n- added a `timeout=None` param to `RunningCommand.wait()` [#515](https://github.com/amoffat/sh/issues/515)\n\n## 1.12.14 - 6/6/17\n\n- bugfix for poor sleep performance [#378](https://github.com/amoffat/sh/issues/378)\n- allow passing raw integer file descriptors for `_out` and `_err` handlers\n- bugfix for when `_tee` and `_out` are used, and the `_out` is a tty or pipe [#384](https://github.com/amoffat/sh/issues/384)\n- bugfix where python 3.3+ detected different arg counts for bound method output callbacks [#380](https://github.com/amoffat/sh/issues/380)\n\n## 1.12.12, 1.12.13 - 3/30/17\n\n- pypi readme doc bugfix [PR#377](https://github.com/amoffat/sh/pull/377)\n\n## 1.12.11 - 3/13/17\n\n- bugfix for relative paths to `sh.Command` not expanding to absolute paths [#372](https://github.com/amoffat/sh/issues/372)\n- updated for python 3.6\n- bugfix for SIGPIPE not being handled correctly on pipelined processes [#373](https://github.com/amoffat/sh/issues/373)\n\n## 1.12.10 - 3/02/17\n\n- bugfix for file descriptors over 1024 [#356](https://github.com/amoffat/sh/issues/356)\n- bugfix when `_err_to_out` is True and `_out` is pipe or tty [#365](https://github.com/amoffat/sh/issues/365)\n\n## 1.12.9 - 1/04/17\n\n- added `_bg_exc` for silencing exceptions in background threads [#350](https://github.com/amoffat/sh/pull/350)\n\n## 1.12.8 - 12/16/16\n\n- bugfix for patched glob.glob on python3.5 [#341](https://github.com/amoffat/sh/issues/341)\n\n## 1.12.7 - 12/07/16\n\n- added `_out` and `_out_bufsize` validator [#346](https://github.com/amoffat/sh/issues/346)\n- bugfix for internal stdout thread running when it shouldn't [#346](https://github.com/amoffat/sh/issues/346)\n\n## 1.12.6 - 12/02/16\n\n- regression bugfix on timeout [#344](https://github.com/amoffat/sh/issues/344)\n- regression bugfix on `_ok_code=None`\n\n## 1.12.5 - 12/01/16\n\n- further improvements on cpu usage\n\n## 1.12.4 - 11/30/16\n\n- regression in cpu usage [#339](https://github.com/amoffat/sh/issues/339)\n\n## 1.12.3 - 11/29/16\n\n- fd leak regression and fix for flawed fd leak detection test [#337](https://github.com/amoffat/sh/pull/337)\n\n## 1.12.2 - 11/28/16\n\n- support for `io.StringIO` in python2\n\n## 1.12.1 - 11/28/16\n\n- added support for using raw file descriptors for `_in`, `_out`, and `_err`\n- removed `.close()`ing `_out` handler if FIFO detected\n\n## 1.12.0 - 11/21/16\n\n- composed commands no longer propagate `_bg`\n- better support for using `sys.stdin` and `sys.stdout` for `_in` and `_out`\n- bugfix where `which()` would not stop searching at the first valid executable found in PATH\n- added `_long_prefix` for programs whose long arguments start with something other than `--` [#278](https://github.com/amoffat/sh/pull/278)\n- added `_log_msg` for advanced configuration of log message [#311](https://github.com/amoffat/sh/pull/311)\n- added `sh.contrib.sudo`\n- added `_arg_preprocess` for advanced command wrapping\n- alter callable `_in` arguments to signify completion with falsy chunk\n- bugfix where pipes passed into `_out` or `_err` were not flushed on process end [#252](https://github.com/amoffat/sh/pull/252)\n- deprecated `with sh.args(**kwargs)` in favor of `sh2 = sh(**kwargs)`\n- made `sh.pushd` thread safe\n- added `.kill_group()` and `.signal_group()` methods for better process control [#237](https://github.com/amoffat/sh/pull/237)\n- added `new_session` special keyword argument for controlling spawned process session [#266](https://github.com/amoffat/sh/issues/266)\n- bugfix better handling for EINTR on system calls [#292](https://github.com/amoffat/sh/pull/292)\n- bugfix where with-contexts were not threadsafe [#247](https://github.com/amoffat/sh/issues/195)\n- `_uid` new special keyword param for specifying the user id of the process [#133](https://github.com/amoffat/sh/issues/133)\n- bugfix where exceptions were swallowed by processes that weren't waited on [#309](https://github.com/amoffat/sh/issues/309)\n- bugfix where processes that dupd their stdout/stderr to a long running child process would cause sh to hang [#310](https://github.com/amoffat/sh/issues/310)\n- improved logging output [#323](https://github.com/amoffat/sh/issues/323)\n- bugfix for python3+ where binary data was passed into a process's stdin [#325](https://github.com/amoffat/sh/issues/325)\n- Introduced execution contexts which allow baking of common special keyword arguments into all commands [#269](https://github.com/amoffat/sh/issues/269)\n- `Command` and `which` now can take an optional `paths` parameter which specifies the search paths [#226](https://github.com/amoffat/sh/issues/226)\n- `_preexec_fn` option for executing a function after the child process forks but before it execs [#260](https://github.com/amoffat/sh/issues/260)\n- `_fg` reintroduced, with limited functionality. hurrah! [#92](https://github.com/amoffat/sh/issues/92)\n- bugfix where a command would block if passed a fd for stdin that wasn't yet ready to read [#253](https://github.com/amoffat/sh/issues/253)\n- `_long_sep` can now take `None` which splits the long form arguments into individual arguments [#258](https://github.com/amoffat/sh/issues/258)\n- making `_piped` perform \"direct\" piping by default (linking fds together). this fixes memory problems [#270](https://github.com/amoffat/sh/issues/270)\n- bugfix where calling `next()` on an iterable process that has raised `StopIteration`, hangs [#273](https://github.com/amoffat/sh/issues/273)\n- `sh.cd` called with no arguments no changes into the user's home directory, like native `cd` [#275](https://github.com/amoffat/sh/issues/275)\n- `sh.glob` removed entirely. the rationale is correctness over hand-holding. [#279](https://github.com/amoffat/sh/issues/279)\n- added `_truncate_exc`, defaulting to `True`, which tells our exceptions to truncate output.\n- bugfix for exceptions whose messages contained unicode\n- `_done` callback no longer assumes you want your command put in the background.\n- `_done` callback is now called asynchronously in a separate thread.\n- `_done` callback is called regardless of exception, which is necessary in order to release held resources, for example a process pool\n\n## 1.10 - 12/30/14\n\n- partially applied functions with `functools.partial` have been fixed for `_out` and `_err` callbacks [#160](https://github.com/amoffat/sh/issues/160)\n- `_out` or `_err` being callables no longer puts the running command in the background. to achieve the previous behavior, pass `_bg=True` to your command.\n- deprecated `_with` contexts [#195](https://github.com/amoffat/sh/issues/195)\n- `_timeout_signal` allows you to specify your own signal to kill a timed-out process with. use a constant from the `signal` stdlib module. [#171](https://github.com/amoffat/sh/issues/171)\n- signal exceptions can now be caught by number or name. `SignalException_9 == SignalException_SIGKILL`\n- child processes that timeout via `_timeout` raise `sh.TimeoutException` instead of `sh.SignalExeception_9` [#172](https://github.com/amoffat/sh/issues/172)\n- fixed `help(sh)` from the python shell and `pydoc sh` from the command line. [#173](https://github.com/amoffat/sh/issues/173)\n- program names can no longer be shadowed by names that sh.py defines internally. removed the requirement of trailing underscores for programs that could have their names shadowed, like `id`.\n- memory optimization when a child process's stdin is a newline-delimted string and our bufsize is newlines\n- feature, `_done` special keyword argument that accepts a callback to be called when the command completes successfully [#185](https://github.com/amoffat/sh/issues/185)\n- bugfix for being unable to print a baked command in python3+ [#176](https://github.com/amoffat/sh/issues/176)\n- bugfix for cwd not existing and causing the child process to continue running parent process code [#202](https://github.com/amoffat/sh/issues/202)\n- child process is now guaranteed to exit on exception between fork and exec.\n- fix python2 deprecation warning when running with -3 [PR #165](https://github.com/amoffat/sh/pull/165)\n- bugfix where sh.py was attempting to execute directories [#196](https://github.com/amoffat/sh/issues/196), [PR #189](https://github.com/amoffat/sh/pull/189)\n- only backgrounded processes will ignore SIGHUP\n- allowed `ok_code` to take a `range` object. [#PR 210](https://github.com/amoffat/sh/pull/210/files)\n- added `sh.args` with context which allows overriding of all command defaults for the duration of that context.\n- added `sh.pushd` with context which takes a directory name and changes to that directory for the duration of that with context. [PR #206](https://github.com/amoffat/sh/pull/206)\n- tests now include python 3.4 if available. tests also stop on the first\n  python that suite that fails.\n- SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGPIPE, SIGSYS have been added to the list of signals that throw an exception [PR #201](https://github.com/amoffat/sh/pull/201)\n- \"callable\" builtin has been faked for python3.1, which lacks it.\n- \"direct\" option added to `_piped` special keyword argument, which allows sh to hand off a process's stdout fd directly to another process, instead of buffering its stdout internally, then handing it off. [#119](https://github.com/amoffat/sh/issues/119)\n\n## 1.09 - 9/08/13\n\n- Fixed encoding errors related to a system encoding \"ascii\". [#123](https://github.com/amoffat/sh/issues/123)\n- Added exit_code attribute to SignalException and ErrorReturnCode exception classes. [#127](https://github.com/amoffat/sh/issues/127)\n- Making the default behavior of spawned processes to not be explicitly killed when the parent python process ends. Also making the spawned process ignore SIGHUP. [#139](https://github.com/amoffat/sh/issues/139)\n- Made OSX sleep hack to apply to PY2 as well as PY3.\n\n## 1.08 - 1/29/12\n\n- Added SignalException class and made all commands that end terminate by a signal defined in SIGNALS_THAT_SHOULD_THROW_EXCEPTION raise it. [#91](https://github.com/amoffat/sh/issues/91)\n- Bugfix where CommandNotFound was not being raised if Command was created by instantiation. [#113](https://github.com/amoffat/sh/issues/113)\n- Bugfix for Commands that are wrapped with functools.wraps() [#121](https://github.com/amoffat/sh/issues/121]\n- Bugfix where input arguments were being assumed as ascii or unicode, but never as a string in a different encoding.\n- \\_long_sep keyword argument added joining together a dictionary of arguments passed in to a command\n- Commands can now be passed a dictionary of args, and the keys will be interpretted \"raw\", with no underscore-to-hyphen conversion\n- Reserved Python keywords can now be used as subcommands by appending an underscore `_` to them\n\n## 1.07 - 11/21/12\n\n- Bugfix for PyDev when `locale.getpreferredencoding()` is empty.\n- Fixes for IPython3 that involve `sh.<tab>` and `sh?`\n- Added `_tee` special keyword argument to force stdout/stderr to store internally and make available for piping data that is being redirected.\n- Added `_decode_errors` to be passed to all stdout/stderr decoding of a process.\n- Added `_no_out`, `_no_err`, and `_no_pipe` special keyword arguments. These are used for long-running processes with lots of output.\n- Changed custom loggers that were created for each process to fixed loggers, so there are no longer logger references laying around in the logging module after the process ends and it garbage collected.\n\n## 1.06 - 11/10/12\n\n- Removed old undocumented cruft of ARG1..ARGN and ARGV.\n- Bugfix where `logging_enabled` could not be set from the importing module.\n- Disabled garbage collection before fork to prevent garbage collection in child process.\n- Major bugfix where cyclical references were preventing process objects (and their associated stdout/stderr buffers) from being garbage collected.\n- Bugfix in RunningCommand and OProc loggers, which could get really huge if a command was called that had a large number of arguments.\n\n## 1.05 - 10/20/12\n\n- Changing status from alpha to beta.\n- Python 3.3 officially supported.\n- Documentation fix. The section on exceptions now references the fact that signals do not raise an exception, even for signals that might seem like they should, e.g. segfault.\n- Bugfix with Python 3.3 where importing commands from the sh namespace resulted in an error related to `__path__`\n- Long-form and short-form options to commands may now be given False to disable the option from being passed into the command. This is useful to pass in a boolean flag that you flip to either True or False to enable or disable some functionality at runtime.\n\n## 1.04 - 10/07/12\n\n- Making `Command` class resolve the `path` parameter with `which` by default instead of expecting it to be resolved before it is passed in. This change shouldn't affect backwards compatibility.\n- Fixing a bug when an exception is raised from a program, and the error output has non-ascii text. This didn't work in Python < 3.0, because .decode()'s default encoding is typically ascii.\n"
        },
        {
          "name": "CODEOWNERS",
          "type": "blob",
          "size": 0.017578125,
          "content": "/.github/ @amoffat"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0400390625,
          "content": "Copyright (C) 2011-2012 by Andrew Moffat\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "MIGRATION.md",
          "type": "blob",
          "size": 2.775390625,
          "content": "# Migrating from 1._ to 2._\n\nThis document provides an upgrade path from `1.*` to `2.*`.\n\n## `sh.cd` builtin removed\n\nThere is no `sh.cd` command anymore. It was always command implemented in sh, as\nsome systems provide it as a shell builtin, while others have an actual binary.\nBut neither of them persisted the directory change between other `sh` calls,\nwhich is why it was implemented in sh.\n\n### Workaround\n\nIf you were using `sh.cd(dir)`, use the context manager `with sh.pushd(dir)`\ninstead. All of the commands in the managed context will have the correct\ndirectory.\n\n## Removed execution contexts / default arguments\n\nIn `1.*` you could do could spawn a new module from the `sh` module, one which\nhad customized defaults for the special keyword arguments. This module could\nthen be accessed just like `sh`, and you could even import commands from it.\n\nUnfortunately the magic required to make that work was brittle. Also it was not\naligned syntactically with the similar baking concept. We have therefore changed\nthe syntax to align with baking, and also removed the ability to import directly\nfrom this new baked execution context.\n\n### Workaround\n\n```python\nsh2 = sh(_tty_out=False)\nsh2.ls()\n```\n\nBecomes:\n\n```python\nsh2 = sh.bake(_tty_out=False)\nsh2.ls()\n```\n\nAnd\n\n```python\nsh2 = sh.bake(_tty_out=False)\nfrom sh2 import ls\nls()\n```\n\nBecomes:\n\n```python\nsh2 = sh.bake(_tty_out=False)\nls = sh2.ls\nls()\n```\n\n## Return value now a true string\n\nIn `2.*`, the return value of an executed `sh` command has changed (in most cases) from\na `RunningCommand` object to a unicode string. This makes using the output of a command\nmore natural.\n\n### Workaround\n\nTo continue returning a `RunningCommand` object, you must use the `_return_cmd=True`\nspecial keyword argument. You can achieve this on each file with the following code at\nthe top of files that use `sh`:\n\n```python\nimport sh\n\nsh = sh.bake(_return_cmd=True)\n```\n\n## Piping to STDIN\n\nPreviously, if the first argument of a sh command was an instance of `RunningCommand`,\nit was automatically fed into the process's STDIN. This is no longer the case and you\nmust explicitly use `_in=`.\n\n```python\nfrom sh import wc,ls\n\nprint(wc(ls(\"/home/<user>\", \"-l\"), \"-l\"))\n```\n\nBecomes:\n\n```python\nfrom sh import wc,ls\n\nprint(wc(\"-l\", _in=ls(\"/home/<user>\", \"-l\")))\n```\n\nOr:\n\n```python\nfrom sh import wc,ls\n\nprint(wc(\"-l\", _in=ls(\"/home/<user>\", \"-l\", _return_cmd=True)))\n```\n\n### Workaround\n\nNone\n\n## New processes don't launch in new session\n\nIn `1.*`, `_new_session` defaulted to `True`. It now defaults to `False`. The reason\nfor this is that it makes more sense for launched processes to default to being in\nthe process group of the python script, so that they receive SIGINTs correctly.\n\n### Workaround\n\nTo preserve the old behavior:\n\n```python\nimport sh\n\nsh = sh.bake(_new_session=True)\n```\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.44140625,
          "content": "# runs all tests on all envs, in parallel\n.PHONY: test\ntest: build_test_image\n\tdocker run -it --rm amoffat/shtest tox -p\n\n# one test on all envs, in parallel\n.PHONY: test_one\ntest_one: build_test_image\n\tdocker run -it --rm amoffat/shtest tox -p -- $(test)\n\n.PHONY: build_test_image\nbuild_test_image:\n\tdocker build -t amoffat/shtest -f tests/Dockerfile --build-arg cache_bust=951 .\n\n# publishes to PYPI\n.PHONY: release\nrelease:\n\tpoetry publish --dry-run"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 2.0595703125,
          "content": ".. image:: https://raw.githubusercontent.com/amoffat/sh/master/images/logo-230.png\n    :target: https://amoffat.github.com/sh\n    :alt: Logo\n\n**If you are migrating from 1.* to 2.*, please see MIGRATION.md**\n\n|\n\n.. image:: https://img.shields.io/pypi/v/sh.svg?style=flat-square\n    :target: https://pypi.python.org/pypi/sh\n    :alt: Version\n.. image:: https://img.shields.io/pypi/dm/sh.svg?style=flat-square\n    :target: https://pypi.python.org/pypi/sh\n    :alt: Downloads Status\n.. image:: https://img.shields.io/pypi/pyversions/sh.svg?style=flat-square\n    :target: https://pypi.python.org/pypi/sh\n    :alt: Python Versions\n.. image:: https://img.shields.io/coveralls/amoffat/sh.svg?style=flat-square\n    :target: https://coveralls.io/r/amoffat/sh?branch=master\n    :alt: Coverage Status\n\n|\n\nsh is a full-fledged subprocess replacement for Python 3.8 - 3.12, and PyPy\nthat allows you to call *any* program as if it were a function:\n\n.. code:: python\n\n    from sh import ifconfig\n    print(ifconfig(\"eth0\"))\n\nsh is *not* a collection of system commands implemented in Python.\n\nsh relies on various Unix system calls and only works on Unix-like operating\nsystems - Linux, macOS, BSDs etc. Specifically, Windows is not supported.\n\n`Complete documentation here <https://sh.readthedocs.io/>`_\n\nInstallation\n============\n\n::\n\n    $> pip install sh\n\nSupport\n=======\n* `Andrew Moffat <https://github.com/amoffat>`_ - author/maintainer\n* `Erik Cederstrand <https://github.com/ecederstrand>`_ - maintainer\n\n\nDevelopers\n==========\n\nTesting\n-------\n\nTests are run in a docker container against all supported Python versions. To run, make the following target::\n\n    $> make test\n\nTo run a single test::\n\n    $> make test='FunctionalTests.test_background' test_one\n\nCoverage\n--------\n\nFirst run all of the tests::\n\n    $> SH_TESTS_RUNNING=1 coverage run --source=sh -m pytest\n\nThis will aggregate a ``.coverage``.  You may then visualize the report with::\n\n    $> coverage report\n\nOr generate visual html files with::\n\n    $> coverage html\n\nWhich will create ``./htmlcov/index.html`` that you may open in a web browser.\n"
        },
        {
          "name": "dev_scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "poetry.lock",
          "type": "blob",
          "size": 67.345703125,
          "content": "[[package]]\nname = \"alabaster\"\nversion = \"0.7.12\"\ndescription = \"A configurable sidebar-enabled Sphinx theme\"\ncategory = \"dev\"\noptional = false\npython-versions = \"*\"\n\n[[package]]\nname = \"babel\"\nversion = \"2.9.1\"\ndescription = \"Internationalization utilities\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*\"\n\n[package.dependencies]\npytz = \">=2015.7\"\n\n[[package]]\nname = \"black\"\nversion = \"23.7.0\"\ndescription = \"The uncompromising code formatter.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.8\"\n\n[package.dependencies]\nclick = \">=8.0.0\"\nmypy-extensions = \">=0.4.3\"\npackaging = \">=22.0\"\npathspec = \">=0.9.0\"\nplatformdirs = \">=2\"\ntomli = {version = \">=1.1.0\", markers = \"python_version < \\\"3.11\\\"\"}\ntyping-extensions = {version = \">=3.10.0.0\", markers = \"python_version < \\\"3.10\\\"\"}\n\n[package.extras]\ncolorama = [\"colorama (>=0.4.3)\"]\nd = [\"aiohttp (>=3.7.4)\"]\njupyter = [\"ipython (>=7.8.0)\", \"tokenize-rt (>=3.2.0)\"]\nuvloop = [\"uvloop (>=0.15.2)\"]\n\n[[package]]\nname = \"cachetools\"\nversion = \"5.3.1\"\ndescription = \"Extensible memoizing collections and decorators\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[[package]]\nname = \"certifi\"\nversion = \"2022.12.7\"\ndescription = \"Python package for providing Mozilla's CA Bundle.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6\"\n\n[[package]]\nname = \"chardet\"\nversion = \"5.1.0\"\ndescription = \"Universal encoding detector for Python 3\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[[package]]\nname = \"charset-normalizer\"\nversion = \"2.0.4\"\ndescription = \"The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.5.0\"\n\n[package.extras]\nunicode-backport = [\"unicodedata2\"]\n\n[[package]]\nname = \"click\"\nversion = \"8.0.1\"\ndescription = \"Composable command line interface toolkit\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6\"\n\n[package.dependencies]\ncolorama = {version = \"*\", markers = \"platform_system == \\\"Windows\\\"\"}\n\n[[package]]\nname = \"colorama\"\nversion = \"0.4.6\"\ndescription = \"Cross-platform colored terminal text.\"\ncategory = \"dev\"\noptional = false\npython-versions = \"!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*,!=3.6.*,>=2.7\"\n\n[[package]]\nname = \"commonmark\"\nversion = \"0.9.1\"\ndescription = \"Python parser for the CommonMark Markdown spec\"\ncategory = \"dev\"\noptional = false\npython-versions = \"*\"\n\n[package.extras]\ntest = [\"flake8 (==3.7.8)\", \"hypothesis (==3.55.3)\"]\n\n[[package]]\nname = \"coverage\"\nversion = \"7.2.7\"\ndescription = \"Code coverage measurement for Python\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[package.extras]\ntoml = [\"tomli\"]\n\n[[package]]\nname = \"distlib\"\nversion = \"0.3.7\"\ndescription = \"Distribution utilities\"\ncategory = \"dev\"\noptional = false\npython-versions = \"*\"\n\n[[package]]\nname = \"docutils\"\nversion = \"0.18.1\"\ndescription = \"Docutils -- Python Documentation Utilities\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*\"\n\n[[package]]\nname = \"exceptiongroup\"\nversion = \"1.1.0\"\ndescription = \"Backport of PEP 654 (exception groups)\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[package.extras]\ntest = [\"pytest (>=6)\"]\n\n[[package]]\nname = \"filelock\"\nversion = \"3.12.2\"\ndescription = \"A platform independent file lock.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[package.extras]\ndocs = [\"furo (>=2023.5.20)\", \"sphinx (>=7.0.1)\", \"sphinx-autodoc-typehints (>=1.23,!=1.23.4)\"]\ntesting = [\"covdefaults (>=2.3)\", \"coverage (>=7.2.7)\", \"diff-cover (>=7.5)\", \"pytest (>=7.3.1)\", \"pytest-cov (>=4.1)\", \"pytest-mock (>=3.10)\", \"pytest-timeout (>=2.1)\"]\n\n[[package]]\nname = \"flake8\"\nversion = \"6.1.0\"\ndescription = \"the modular source code checker: pep8 pyflakes and co\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.8.1\"\n\n[package.dependencies]\nmccabe = \">=0.7.0,<0.8.0\"\npycodestyle = \">=2.11.0,<2.12.0\"\npyflakes = \">=3.1.0,<3.2.0\"\n\n[[package]]\nname = \"idna\"\nversion = \"3.2\"\ndescription = \"Internationalized Domain Names in Applications (IDNA)\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.5\"\n\n[[package]]\nname = \"imagesize\"\nversion = \"1.4.1\"\ndescription = \"Getting image size from png/jpeg/jpeg2000/gif file\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*\"\n\n[[package]]\nname = \"importlib-metadata\"\nversion = \"4.8.1\"\ndescription = \"Read metadata from Python packages\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6\"\n\n[package.dependencies]\nzipp = \">=0.5\"\n\n[package.extras]\ndocs = [\"jaraco.packaging (>=8.2)\", \"rst.linker (>=1.9)\", \"sphinx\"]\nperf = [\"ipython\"]\ntesting = [\"flufl.flake8\", \"importlib-resources (>=1.3)\", \"packaging\", \"pep517\", \"pyfakefs\", \"pytest (>=4.6)\", \"pytest-black (>=0.3.7)\", \"pytest-checkdocs (>=2.4)\", \"pytest-cov\", \"pytest-enabler (>=1.0.1)\", \"pytest-flake8\", \"pytest-mypy\", \"pytest-perf (>=0.9.2)\"]\n\n[[package]]\nname = \"iniconfig\"\nversion = \"1.1.1\"\ndescription = \"iniconfig: brain-dead simple config-ini parsing\"\ncategory = \"dev\"\noptional = false\npython-versions = \"*\"\n\n[[package]]\nname = \"jinja2\"\nversion = \"3.0.1\"\ndescription = \"A very fast and expressive template engine.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6\"\n\n[package.dependencies]\nMarkupSafe = \">=2.0\"\n\n[package.extras]\ni18n = [\"Babel (>=2.7)\"]\n\n[[package]]\nname = \"markupsafe\"\nversion = \"2.0.1\"\ndescription = \"Safely add untrusted strings to HTML/XML markup.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6\"\n\n[[package]]\nname = \"mccabe\"\nversion = \"0.7.0\"\ndescription = \"McCabe checker, plugin for flake8\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6\"\n\n[[package]]\nname = \"mypy\"\nversion = \"1.4.1\"\ndescription = \"Optional static typing for Python\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[package.dependencies]\nmypy-extensions = \">=1.0.0\"\ntomli = {version = \">=1.1.0\", markers = \"python_version < \\\"3.11\\\"\"}\ntyping-extensions = \">=4.1.0\"\n\n[package.extras]\ndmypy = [\"psutil (>=4.0)\"]\ninstall-types = [\"pip\"]\npython2 = [\"typed-ast (>=1.4.0,<2)\"]\nreports = [\"lxml\"]\n\n[[package]]\nname = \"mypy-extensions\"\nversion = \"1.0.0\"\ndescription = \"Type system extensions for programs checked with the mypy type checker.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.5\"\n\n[[package]]\nname = \"packaging\"\nversion = \"23.1\"\ndescription = \"Core utilities for Python packages\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[[package]]\nname = \"pathspec\"\nversion = \"0.9.0\"\ndescription = \"Utility library for gitignore style pattern matching of file paths.\"\ncategory = \"dev\"\noptional = false\npython-versions = \"!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,>=2.7\"\n\n[[package]]\nname = \"platformdirs\"\nversion = \"3.10.0\"\ndescription = \"A small Python package for determining appropriate platform-specific dirs, e.g. a \\\"user data dir\\\".\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[package.extras]\ndocs = [\"furo (>=2023.7.26)\", \"proselint (>=0.13)\", \"sphinx (>=7.1.1)\", \"sphinx-autodoc-typehints (>=1.24)\"]\ntest = [\"appdirs (==1.4.4)\", \"covdefaults (>=2.3)\", \"pytest (>=7.4)\", \"pytest-cov (>=4.1)\", \"pytest-mock (>=3.11.1)\"]\n\n[[package]]\nname = \"pluggy\"\nversion = \"1.2.0\"\ndescription = \"plugin and hook calling mechanisms for python\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[package.extras]\ndev = [\"pre-commit\", \"tox\"]\ntesting = [\"pytest\", \"pytest-benchmark\"]\n\n[[package]]\nname = \"pycodestyle\"\nversion = \"2.11.0\"\ndescription = \"Python style guide checker\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.8\"\n\n[[package]]\nname = \"pydantic\"\nversion = \"1.9.2\"\ndescription = \"Data validation and settings management using python type hints\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6.1\"\n\n[package.dependencies]\ntyping-extensions = \">=3.7.4.3\"\n\n[package.extras]\ndotenv = [\"python-dotenv (>=0.10.4)\"]\nemail = [\"email-validator (>=1.0.3)\"]\n\n[[package]]\nname = \"pyflakes\"\nversion = \"3.1.0\"\ndescription = \"passive checker of Python programs\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.8\"\n\n[[package]]\nname = \"pygments\"\nversion = \"2.14.0\"\ndescription = \"Pygments is a syntax highlighting package written in Python.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6\"\n\n[package.extras]\nplugins = [\"importlib-metadata\"]\n\n[[package]]\nname = \"pyproject-api\"\nversion = \"1.5.3\"\ndescription = \"API to interact with the python pyproject.toml based projects\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[package.dependencies]\npackaging = \">=23.1\"\ntomli = {version = \">=2.0.1\", markers = \"python_version < \\\"3.11\\\"\"}\n\n[package.extras]\ndocs = [\"furo (>=2023.5.20)\", \"sphinx (>=7.0.1)\", \"sphinx-autodoc-typehints (>=1.23,!=1.23.4)\"]\ntesting = [\"covdefaults (>=2.3)\", \"importlib-metadata (>=6.6)\", \"pytest (>=7.3.1)\", \"pytest-cov (>=4.1)\", \"pytest-mock (>=3.10)\", \"setuptools (>=67.8)\", \"wheel (>=0.40)\"]\n\n[[package]]\nname = \"pytest\"\nversion = \"7.4.0\"\ndescription = \"pytest: simple powerful testing with Python\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[package.dependencies]\ncolorama = {version = \"*\", markers = \"sys_platform == \\\"win32\\\"\"}\nexceptiongroup = {version = \">=1.0.0rc8\", markers = \"python_version < \\\"3.11\\\"\"}\niniconfig = \"*\"\npackaging = \"*\"\npluggy = \">=0.12,<2.0\"\ntomli = {version = \">=1.0.0\", markers = \"python_version < \\\"3.11\\\"\"}\n\n[package.extras]\ntesting = [\"argcomplete\", \"attrs (>=19.2.0)\", \"hypothesis (>=3.56)\", \"mock\", \"nose\", \"pygments (>=2.7.2)\", \"requests\", \"setuptools\", \"xmlschema\"]\n\n[[package]]\nname = \"pytz\"\nversion = \"2021.1\"\ndescription = \"World timezone definitions, modern and historical\"\ncategory = \"dev\"\noptional = false\npython-versions = \"*\"\n\n[[package]]\nname = \"requests\"\nversion = \"2.26.0\"\ndescription = \"Python HTTP for Humans.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*\"\n\n[package.dependencies]\ncertifi = \">=2017.4.17\"\ncharset-normalizer = {version = \">=2.0.0,<2.1.0\", markers = \"python_version >= \\\"3\\\"\"}\nidna = {version = \">=2.5,<4\", markers = \"python_version >= \\\"3\\\"\"}\nurllib3 = \">=1.21.1,<1.27\"\n\n[package.extras]\nsocks = [\"PySocks (>=1.5.6,!=1.5.7)\", \"win-inet-pton\"]\nuse-chardet-on-py3 = [\"chardet (>=3.0.2,<5)\"]\n\n[[package]]\nname = \"rich\"\nversion = \"12.0.1\"\ndescription = \"Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6.2,<4.0.0\"\n\n[package.dependencies]\ncommonmark = \">=0.9.0,<0.10.0\"\npygments = \">=2.6.0,<3.0.0\"\n\n[package.extras]\njupyter = [\"ipywidgets (>=7.5.1,<8.0.0)\"]\n\n[[package]]\nname = \"rstcheck\"\nversion = \"6.1.2\"\ndescription = \"Checks syntax of reStructuredText and code blocks nested within it\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7,<4.0\"\n\n[package.dependencies]\nrstcheck-core = \">=1.0.2,<2.0.0\"\ntyper = {version = \">=0.4.1,<0.8\", extras = [\"all\"]}\n\n[package.extras]\ndocs = [\"m2r2 (>=0.3.2)\", \"sphinx\", \"sphinx-autobuild (==2021.3.14)\", \"sphinx-click (>=4.0.3,<5.0.0)\", \"sphinx-rtd-dark-mode (>=1.2.4,<2.0.0)\", \"sphinx-rtd-theme (<1)\", \"sphinxcontrib-spelling (>=7.3)\"]\nsphinx = [\"sphinx\"]\ntesting = [\"coverage-conditional-plugin (>=0.5)\", \"coverage[toml] (>=6.0)\", \"pytest (>=7.2)\", \"pytest-cov (>=3.0)\", \"pytest-randomly (>=3.0)\", \"pytest-sugar (>=0.9.5)\"]\ntoml = [\"tomli\"]\n\n[[package]]\nname = \"rstcheck-core\"\nversion = \"1.0.3\"\ndescription = \"Checks syntax of reStructuredText and code blocks nested within it\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7,<4.0\"\n\n[package.dependencies]\ndocutils = \">=0.7,<0.20\"\npydantic = \">=1.2,<2.0\"\ntypes-docutils = \">=0.18,<0.20\"\n\n[package.extras]\ndocs = [\"m2r2 (>=0.3.2)\", \"sphinx (>=4.0,<6.0)\", \"sphinx-autobuild (==2021.3.14)\", \"sphinx-autodoc-typehints (>=1.15)\", \"sphinx-rtd-dark-mode (>=1.2.4,<2.0.0)\", \"sphinx-rtd-theme (<1)\", \"sphinxcontrib-apidoc (>=0.3)\", \"sphinxcontrib-spelling (>=7.3)\"]\nsphinx = [\"sphinx (>=4.0,<6.0)\"]\ntesting = [\"coverage-conditional-plugin (>=0.5)\", \"coverage[toml] (>=6.0)\", \"pytest (>=6.0)\", \"pytest-cov (>=3.0)\", \"pytest-mock (>=3.7)\", \"pytest-randomly (>=3.0)\", \"pytest-sugar (>=0.9.5)\"]\ntoml = [\"tomli (>=2.0,<3.0)\"]\n\n[[package]]\nname = \"shellingham\"\nversion = \"1.5.0.post1\"\ndescription = \"Tool to Detect Surrounding Shell\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[[package]]\nname = \"snowballstemmer\"\nversion = \"2.1.0\"\ndescription = \"This package provides 29 stemmers for 28 languages generated from Snowball algorithms.\"\ncategory = \"dev\"\noptional = false\npython-versions = \"*\"\n\n[[package]]\nname = \"sphinx\"\nversion = \"6.1.3\"\ndescription = \"Python documentation generator\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.8\"\n\n[package.dependencies]\nalabaster = \">=0.7,<0.8\"\nbabel = \">=2.9\"\ncolorama = {version = \">=0.4.5\", markers = \"sys_platform == \\\"win32\\\"\"}\ndocutils = \">=0.18,<0.20\"\nimagesize = \">=1.3\"\nimportlib-metadata = {version = \">=4.8\", markers = \"python_version < \\\"3.10\\\"\"}\nJinja2 = \">=3.0\"\npackaging = \">=21.0\"\nPygments = \">=2.13\"\nrequests = \">=2.25.0\"\nsnowballstemmer = \">=2.0\"\nsphinxcontrib-applehelp = \"*\"\nsphinxcontrib-devhelp = \"*\"\nsphinxcontrib-htmlhelp = \">=2.0.0\"\nsphinxcontrib-jsmath = \"*\"\nsphinxcontrib-qthelp = \"*\"\nsphinxcontrib-serializinghtml = \">=1.1.5\"\n\n[package.extras]\ndocs = [\"sphinxcontrib-websupport\"]\nlint = [\"docutils-stubs\", \"flake8 (>=3.5.0)\", \"flake8-simplify\", \"isort\", \"mypy (>=0.990)\", \"ruff\", \"sphinx-lint\", \"types-requests\"]\ntest = [\"cython\", \"html5lib\", \"pytest (>=4.6)\"]\n\n[[package]]\nname = \"sphinx-rtd-theme\"\nversion = \"1.2.2\"\ndescription = \"Read the Docs theme for Sphinx\"\ncategory = \"dev\"\noptional = false\npython-versions = \"!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*,>=2.7\"\n\n[package.dependencies]\ndocutils = \"<0.19\"\nsphinx = \">=1.6,<7\"\nsphinxcontrib-jquery = \">=4,<5\"\n\n[package.extras]\ndev = [\"bump2version\", \"sphinxcontrib-httpdomain\", \"transifex-client\", \"wheel\"]\n\n[[package]]\nname = \"sphinxcontrib-applehelp\"\nversion = \"1.0.2\"\ndescription = \"sphinxcontrib-applehelp is a sphinx extension which outputs Apple help books\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.5\"\n\n[package.extras]\nlint = [\"docutils-stubs\", \"flake8\", \"mypy\"]\ntest = [\"pytest\"]\n\n[[package]]\nname = \"sphinxcontrib-devhelp\"\nversion = \"1.0.2\"\ndescription = \"sphinxcontrib-devhelp is a sphinx extension which outputs Devhelp document.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.5\"\n\n[package.extras]\nlint = [\"docutils-stubs\", \"flake8\", \"mypy\"]\ntest = [\"pytest\"]\n\n[[package]]\nname = \"sphinxcontrib-htmlhelp\"\nversion = \"2.0.0\"\ndescription = \"sphinxcontrib-htmlhelp is a sphinx extension which renders HTML help files\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6\"\n\n[package.extras]\nlint = [\"docutils-stubs\", \"flake8\", \"mypy\"]\ntest = [\"html5lib\", \"pytest\"]\n\n[[package]]\nname = \"sphinxcontrib-jquery\"\nversion = \"4.1\"\ndescription = \"Extension to include jQuery on newer Sphinx releases\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=2.7\"\n\n[package.dependencies]\nSphinx = \">=1.8\"\n\n[[package]]\nname = \"sphinxcontrib-jsmath\"\nversion = \"1.0.1\"\ndescription = \"A sphinx extension which renders display math in HTML via JavaScript\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.5\"\n\n[package.extras]\ntest = [\"flake8\", \"mypy\", \"pytest\"]\n\n[[package]]\nname = \"sphinxcontrib-qthelp\"\nversion = \"1.0.3\"\ndescription = \"sphinxcontrib-qthelp is a sphinx extension which outputs QtHelp document.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.5\"\n\n[package.extras]\nlint = [\"docutils-stubs\", \"flake8\", \"mypy\"]\ntest = [\"pytest\"]\n\n[[package]]\nname = \"sphinxcontrib-serializinghtml\"\nversion = \"1.1.5\"\ndescription = \"sphinxcontrib-serializinghtml is a sphinx extension which outputs \\\"serialized\\\" HTML files (json and pickle).\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.5\"\n\n[package.extras]\nlint = [\"docutils-stubs\", \"flake8\", \"mypy\"]\ntest = [\"pytest\"]\n\n[[package]]\nname = \"toml\"\nversion = \"0.10.2\"\ndescription = \"Python Library for Tom's Obvious, Minimal Language\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=2.6, !=3.0.*, !=3.1.*, !=3.2.*\"\n\n[[package]]\nname = \"tomli\"\nversion = \"2.0.1\"\ndescription = \"A lil' TOML parser\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[[package]]\nname = \"tox\"\nversion = \"4.6.4\"\ndescription = \"tox is a generic virtualenv management and test command line tool\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[package.dependencies]\ncachetools = \">=5.3.1\"\nchardet = \">=5.1\"\ncolorama = \">=0.4.6\"\nfilelock = \">=3.12.2\"\npackaging = \">=23.1\"\nplatformdirs = \">=3.8\"\npluggy = \">=1.2\"\npyproject-api = \">=1.5.2\"\ntomli = {version = \">=2.0.1\", markers = \"python_version < \\\"3.11\\\"\"}\nvirtualenv = \">=20.23.1\"\n\n[package.extras]\ndocs = [\"furo (>=2023.5.20)\", \"sphinx (>=7.0.1)\", \"sphinx-argparse-cli (>=1.11.1)\", \"sphinx-autodoc-typehints (>=1.23.3,!=1.23.4)\", \"sphinx-copybutton (>=0.5.2)\", \"sphinx-inline-tabs (>=2023.4.21)\", \"sphinxcontrib-towncrier (>=0.2.1a0)\", \"towncrier (>=23.6)\"]\ntesting = [\"build[virtualenv] (>=0.10)\", \"covdefaults (>=2.3)\", \"detect-test-pollution (>=1.1.1)\", \"devpi-process (>=0.3.1)\", \"diff-cover (>=7.6)\", \"distlib (>=0.3.6)\", \"flaky (>=3.7)\", \"hatch-vcs (>=0.3)\", \"hatchling (>=1.17.1)\", \"psutil (>=5.9.5)\", \"pytest (>=7.4)\", \"pytest-cov (>=4.1)\", \"pytest-mock (>=3.11.1)\", \"pytest-xdist (>=3.3.1)\", \"re-assert (>=1.1)\", \"time-machine (>=2.10)\", \"wheel (>=0.40)\"]\n\n[[package]]\nname = \"typer\"\nversion = \"0.7.0\"\ndescription = \"Typer, build great CLIs. Easy to code. Based on Python type hints.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6\"\n\n[package.dependencies]\nclick = \">=7.1.1,<9.0.0\"\ncolorama = {version = \">=0.4.3,<0.5.0\", optional = true, markers = \"extra == \\\"all\\\"\"}\nrich = {version = \">=10.11.0,<13.0.0\", optional = true, markers = \"extra == \\\"all\\\"\"}\nshellingham = {version = \">=1.3.0,<2.0.0\", optional = true, markers = \"extra == \\\"all\\\"\"}\n\n[package.extras]\nall = [\"colorama (>=0.4.3,<0.5.0)\", \"rich (>=10.11.0,<13.0.0)\", \"shellingham (>=1.3.0,<2.0.0)\"]\ndev = [\"autoflake (>=1.3.1,<2.0.0)\", \"flake8 (>=3.8.3,<4.0.0)\", \"pre-commit (>=2.17.0,<3.0.0)\"]\ndoc = [\"cairosvg (>=2.5.2,<3.0.0)\", \"mdx-include (>=1.4.1,<2.0.0)\", \"mkdocs (>=1.1.2,<2.0.0)\", \"mkdocs-material (>=8.1.4,<9.0.0)\", \"pillow (>=9.3.0,<10.0.0)\"]\ntest = [\"black (>=22.3.0,<23.0.0)\", \"coverage (>=6.2,<7.0)\", \"isort (>=5.0.6,<6.0.0)\", \"mypy (==0.910)\", \"pytest (>=4.4.0,<8.0.0)\", \"pytest-cov (>=2.10.0,<5.0.0)\", \"pytest-sugar (>=0.9.4,<0.10.0)\", \"pytest-xdist (>=1.32.0,<4.0.0)\", \"rich (>=10.11.0,<13.0.0)\", \"shellingham (>=1.3.0,<2.0.0)\"]\n\n[[package]]\nname = \"types-docutils\"\nversion = \"0.19.1.3\"\ndescription = \"Typing stubs for docutils\"\ncategory = \"dev\"\noptional = false\npython-versions = \"*\"\n\n[[package]]\nname = \"typing-extensions\"\nversion = \"4.7.1\"\ndescription = \"Backported and Experimental Type Hints for Python 3.7+\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[[package]]\nname = \"urllib3\"\nversion = \"1.26.6\"\ndescription = \"HTTP library with thread-safe connection pooling, file post, and more.\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, <4\"\n\n[package.extras]\nbrotli = [\"brotlipy (>=0.6.0)\"]\nsecure = [\"certifi\", \"cryptography (>=1.3.4)\", \"idna (>=2.0.0)\", \"ipaddress\", \"pyOpenSSL (>=0.14)\"]\nsocks = [\"PySocks (>=1.5.6,!=1.5.7,<2.0)\"]\n\n[[package]]\nname = \"virtualenv\"\nversion = \"20.24.2\"\ndescription = \"Virtual Python Environment builder\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.7\"\n\n[package.dependencies]\ndistlib = \">=0.3.7,<1\"\nfilelock = \">=3.12.2,<4\"\nplatformdirs = \">=3.9.1,<4\"\n\n[package.extras]\ndocs = [\"furo (>=2023.5.20)\", \"proselint (>=0.13)\", \"sphinx (>=7.0.1)\", \"sphinx-argparse (>=0.4)\", \"sphinxcontrib-towncrier (>=0.2.1a0)\", \"towncrier (>=23.6)\"]\ntest = [\"covdefaults (>=2.3)\", \"coverage (>=7.2.7)\", \"coverage-enable-subprocess (>=1)\", \"flaky (>=3.7)\", \"packaging (>=23.1)\", \"pytest (>=7.4)\", \"pytest-env (>=0.8.2)\", \"pytest-freezer (>=0.4.8)\", \"pytest-mock (>=3.11.1)\", \"pytest-randomly (>=3.12)\", \"pytest-timeout (>=2.1)\", \"setuptools (>=68)\", \"time-machine (>=2.10)\"]\n\n[[package]]\nname = \"zipp\"\nversion = \"3.5.0\"\ndescription = \"Backport of pathlib-compatible object wrapper for zip files\"\ncategory = \"dev\"\noptional = false\npython-versions = \">=3.6\"\n\n[package.extras]\ndocs = [\"jaraco.packaging (>=8.2)\", \"rst.linker (>=1.9)\", \"sphinx\"]\ntesting = [\"func-timeout\", \"jaraco.itertools\", \"pytest (>=4.6)\", \"pytest-black (>=0.3.7)\", \"pytest-checkdocs (>=2.4)\", \"pytest-cov\", \"pytest-enabler (>=1.0.1)\", \"pytest-flake8\", \"pytest-mypy\"]\n\n[metadata]\nlock-version = \"1.1\"\npython-versions = \">=3.8.1,<4.0\"\ncontent-hash = \"fd15344e892d371cda817467a113a25c5f87fcc78b17c527fee200b8e4262043\"\n\n[metadata.files]\nalabaster = [\n    {file = \"alabaster-0.7.12-py2.py3-none-any.whl\", hash = \"sha256:446438bdcca0e05bd45ea2de1668c1d9b032e1a9154c2c259092d77031ddd359\"},\n    {file = \"alabaster-0.7.12.tar.gz\", hash = \"sha256:a661d72d58e6ea8a57f7a86e37d86716863ee5e92788398526d58b26a4e4dc02\"},\n]\nbabel = [\n    {file = \"Babel-2.9.1-py2.py3-none-any.whl\", hash = \"sha256:ab49e12b91d937cd11f0b67cb259a57ab4ad2b59ac7a3b41d6c06c0ac5b0def9\"},\n    {file = \"Babel-2.9.1.tar.gz\", hash = \"sha256:bc0c176f9f6a994582230df350aa6e05ba2ebe4b3ac317eab29d9be5d2768da0\"},\n]\nblack = [\n    {file = \"black-23.7.0-cp310-cp310-macosx_10_16_arm64.whl\", hash = \"sha256:5c4bc552ab52f6c1c506ccae05681fab58c3f72d59ae6e6639e8885e94fe2587\"},\n    {file = \"black-23.7.0-cp310-cp310-macosx_10_16_universal2.whl\", hash = \"sha256:552513d5cd5694590d7ef6f46e1767a4df9af168d449ff767b13b084c020e63f\"},\n    {file = \"black-23.7.0-cp310-cp310-macosx_10_16_x86_64.whl\", hash = \"sha256:86cee259349b4448adb4ef9b204bb4467aae74a386bce85d56ba4f5dc0da27be\"},\n    {file = \"black-23.7.0-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:501387a9edcb75d7ae8a4412bb8749900386eaef258f1aefab18adddea1936bc\"},\n    {file = \"black-23.7.0-cp310-cp310-win_amd64.whl\", hash = \"sha256:fb074d8b213749fa1d077d630db0d5f8cc3b2ae63587ad4116e8a436e9bbe995\"},\n    {file = \"black-23.7.0-cp311-cp311-macosx_10_16_arm64.whl\", hash = \"sha256:b5b0ee6d96b345a8b420100b7d71ebfdd19fab5e8301aff48ec270042cd40ac2\"},\n    {file = \"black-23.7.0-cp311-cp311-macosx_10_16_universal2.whl\", hash = \"sha256:893695a76b140881531062d48476ebe4a48f5d1e9388177e175d76234ca247cd\"},\n    {file = \"black-23.7.0-cp311-cp311-macosx_10_16_x86_64.whl\", hash = \"sha256:c333286dc3ddca6fdff74670b911cccedacb4ef0a60b34e491b8a67c833b343a\"},\n    {file = \"black-23.7.0-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:831d8f54c3a8c8cf55f64d0422ee875eecac26f5f649fb6c1df65316b67c8926\"},\n    {file = \"black-23.7.0-cp311-cp311-win_amd64.whl\", hash = \"sha256:7f3bf2dec7d541b4619b8ce526bda74a6b0bffc480a163fed32eb8b3c9aed8ad\"},\n    {file = \"black-23.7.0-cp38-cp38-macosx_10_16_arm64.whl\", hash = \"sha256:f9062af71c59c004cd519e2fb8f5d25d39e46d3af011b41ab43b9c74e27e236f\"},\n    {file = \"black-23.7.0-cp38-cp38-macosx_10_16_universal2.whl\", hash = \"sha256:01ede61aac8c154b55f35301fac3e730baf0c9cf8120f65a9cd61a81cfb4a0c3\"},\n    {file = \"black-23.7.0-cp38-cp38-macosx_10_16_x86_64.whl\", hash = \"sha256:327a8c2550ddc573b51e2c352adb88143464bb9d92c10416feb86b0f5aee5ff6\"},\n    {file = \"black-23.7.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:6d1c6022b86f83b632d06f2b02774134def5d4d4f1dac8bef16d90cda18ba28a\"},\n    {file = \"black-23.7.0-cp38-cp38-win_amd64.whl\", hash = \"sha256:27eb7a0c71604d5de083757fbdb245b1a4fae60e9596514c6ec497eb63f95320\"},\n    {file = \"black-23.7.0-cp39-cp39-macosx_10_16_arm64.whl\", hash = \"sha256:8417dbd2f57b5701492cd46edcecc4f9208dc75529bcf76c514864e48da867d9\"},\n    {file = \"black-23.7.0-cp39-cp39-macosx_10_16_universal2.whl\", hash = \"sha256:47e56d83aad53ca140da0af87678fb38e44fd6bc0af71eebab2d1f59b1acf1d3\"},\n    {file = \"black-23.7.0-cp39-cp39-macosx_10_16_x86_64.whl\", hash = \"sha256:25cc308838fe71f7065df53aedd20327969d05671bac95b38fdf37ebe70ac087\"},\n    {file = \"black-23.7.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:642496b675095d423f9b8448243336f8ec71c9d4d57ec17bf795b67f08132a91\"},\n    {file = \"black-23.7.0-cp39-cp39-win_amd64.whl\", hash = \"sha256:ad0014efc7acf0bd745792bd0d8857413652979200ab924fbf239062adc12491\"},\n    {file = \"black-23.7.0-py3-none-any.whl\", hash = \"sha256:9fd59d418c60c0348505f2ddf9609c1e1de8e7493eab96198fc89d9f865e7a96\"},\n    {file = \"black-23.7.0.tar.gz\", hash = \"sha256:022a582720b0d9480ed82576c920a8c1dde97cc38ff11d8d8859b3bd6ca9eedb\"},\n]\ncachetools = [\n    {file = \"cachetools-5.3.1-py3-none-any.whl\", hash = \"sha256:95ef631eeaea14ba2e36f06437f36463aac3a096799e876ee55e5cdccb102590\"},\n    {file = \"cachetools-5.3.1.tar.gz\", hash = \"sha256:dce83f2d9b4e1f732a8cd44af8e8fab2dbe46201467fc98b3ef8f269092bf62b\"},\n]\ncertifi = [\n    {file = \"certifi-2022.12.7-py3-none-any.whl\", hash = \"sha256:4ad3232f5e926d6718ec31cfc1fcadfde020920e278684144551c91769c7bc18\"},\n    {file = \"certifi-2022.12.7.tar.gz\", hash = \"sha256:35824b4c3a97115964b408844d64aa14db1cc518f6562e8d7261699d1350a9e3\"},\n]\nchardet = [\n    {file = \"chardet-5.1.0-py3-none-any.whl\", hash = \"sha256:362777fb014af596ad31334fde1e8c327dfdb076e1960d1694662d46a6917ab9\"},\n    {file = \"chardet-5.1.0.tar.gz\", hash = \"sha256:0d62712b956bc154f85fb0a266e2a3c5913c2967e00348701b32411d6def31e5\"},\n]\ncharset-normalizer = [\n    {file = \"charset-normalizer-2.0.4.tar.gz\", hash = \"sha256:f23667ebe1084be45f6ae0538e4a5a865206544097e4e8bbcacf42cd02a348f3\"},\n    {file = \"charset_normalizer-2.0.4-py3-none-any.whl\", hash = \"sha256:0c8911edd15d19223366a194a513099a302055a962bca2cec0f54b8b63175d8b\"},\n]\nclick = [\n    {file = \"click-8.0.1-py3-none-any.whl\", hash = \"sha256:fba402a4a47334742d782209a7c79bc448911afe1149d07bdabdf480b3e2f4b6\"},\n    {file = \"click-8.0.1.tar.gz\", hash = \"sha256:8c04c11192119b1ef78ea049e0a6f0463e4c48ef00a30160c704337586f3ad7a\"},\n]\ncolorama = [\n    {file = \"colorama-0.4.6-py2.py3-none-any.whl\", hash = \"sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6\"},\n    {file = \"colorama-0.4.6.tar.gz\", hash = \"sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44\"},\n]\ncommonmark = [\n    {file = \"commonmark-0.9.1-py2.py3-none-any.whl\", hash = \"sha256:da2f38c92590f83de410ba1a3cbceafbc74fee9def35f9251ba9a971d6d66fd9\"},\n    {file = \"commonmark-0.9.1.tar.gz\", hash = \"sha256:452f9dc859be7f06631ddcb328b6919c67984aca654e5fefb3914d54691aed60\"},\n]\ncoverage = [\n    {file = \"coverage-7.2.7-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:d39b5b4f2a66ccae8b7263ac3c8170994b65266797fb96cbbfd3fb5b23921db8\"},\n    {file = \"coverage-7.2.7-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:6d040ef7c9859bb11dfeb056ff5b3872436e3b5e401817d87a31e1750b9ae2fb\"},\n    {file = \"coverage-7.2.7-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:ba90a9563ba44a72fda2e85302c3abc71c5589cea608ca16c22b9804262aaeb6\"},\n    {file = \"coverage-7.2.7-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:e7d9405291c6928619403db1d10bd07888888ec1abcbd9748fdaa971d7d661b2\"},\n    {file = \"coverage-7.2.7-cp310-cp310-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:31563e97dae5598556600466ad9beea39fb04e0229e61c12eaa206e0aa202063\"},\n    {file = \"coverage-7.2.7-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:ebba1cd308ef115925421d3e6a586e655ca5a77b5bf41e02eb0e4562a111f2d1\"},\n    {file = \"coverage-7.2.7-cp310-cp310-musllinux_1_1_i686.whl\", hash = \"sha256:cb017fd1b2603ef59e374ba2063f593abe0fc45f2ad9abdde5b4d83bd922a353\"},\n    {file = \"coverage-7.2.7-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:d62a5c7dad11015c66fbb9d881bc4caa5b12f16292f857842d9d1871595f4495\"},\n    {file = \"coverage-7.2.7-cp310-cp310-win32.whl\", hash = \"sha256:ee57190f24fba796e36bb6d3aa8a8783c643d8fa9760c89f7a98ab5455fbf818\"},\n    {file = \"coverage-7.2.7-cp310-cp310-win_amd64.whl\", hash = \"sha256:f75f7168ab25dd93110c8a8117a22450c19976afbc44234cbf71481094c1b850\"},\n    {file = \"coverage-7.2.7-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:06a9a2be0b5b576c3f18f1a241f0473575c4a26021b52b2a85263a00f034d51f\"},\n    {file = \"coverage-7.2.7-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:5baa06420f837184130752b7c5ea0808762083bf3487b5038d68b012e5937dbe\"},\n    {file = \"coverage-7.2.7-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:fdec9e8cbf13a5bf63290fc6013d216a4c7232efb51548594ca3631a7f13c3a3\"},\n    {file = \"coverage-7.2.7-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:52edc1a60c0d34afa421c9c37078817b2e67a392cab17d97283b64c5833f427f\"},\n    {file = \"coverage-7.2.7-cp311-cp311-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:63426706118b7f5cf6bb6c895dc215d8a418d5952544042c8a2d9fe87fcf09cb\"},\n    {file = \"coverage-7.2.7-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:afb17f84d56068a7c29f5fa37bfd38d5aba69e3304af08ee94da8ed5b0865833\"},\n    {file = \"coverage-7.2.7-cp311-cp311-musllinux_1_1_i686.whl\", hash = \"sha256:48c19d2159d433ccc99e729ceae7d5293fbffa0bdb94952d3579983d1c8c9d97\"},\n    {file = \"coverage-7.2.7-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:0e1f928eaf5469c11e886fe0885ad2bf1ec606434e79842a879277895a50942a\"},\n    {file = \"coverage-7.2.7-cp311-cp311-win32.whl\", hash = \"sha256:33d6d3ea29d5b3a1a632b3c4e4f4ecae24ef170b0b9ee493883f2df10039959a\"},\n    {file = \"coverage-7.2.7-cp311-cp311-win_amd64.whl\", hash = \"sha256:5b7540161790b2f28143191f5f8ec02fb132660ff175b7747b95dcb77ac26562\"},\n    {file = \"coverage-7.2.7-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:f2f67fe12b22cd130d34d0ef79206061bfb5eda52feb6ce0dba0644e20a03cf4\"},\n    {file = \"coverage-7.2.7-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:a342242fe22407f3c17f4b499276a02b01e80f861f1682ad1d95b04018e0c0d4\"},\n    {file = \"coverage-7.2.7-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:171717c7cb6b453aebac9a2ef603699da237f341b38eebfee9be75d27dc38e01\"},\n    {file = \"coverage-7.2.7-cp312-cp312-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:49969a9f7ffa086d973d91cec8d2e31080436ef0fb4a359cae927e742abfaaa6\"},\n    {file = \"coverage-7.2.7-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:b46517c02ccd08092f4fa99f24c3b83d8f92f739b4657b0f146246a0ca6a831d\"},\n    {file = \"coverage-7.2.7-cp312-cp312-musllinux_1_1_i686.whl\", hash = \"sha256:a3d33a6b3eae87ceaefa91ffdc130b5e8536182cd6dfdbfc1aa56b46ff8c86de\"},\n    {file = \"coverage-7.2.7-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:976b9c42fb2a43ebf304fa7d4a310e5f16cc99992f33eced91ef6f908bd8f33d\"},\n    {file = \"coverage-7.2.7-cp312-cp312-win32.whl\", hash = \"sha256:8de8bb0e5ad103888d65abef8bca41ab93721647590a3f740100cd65c3b00511\"},\n    {file = \"coverage-7.2.7-cp312-cp312-win_amd64.whl\", hash = \"sha256:9e31cb64d7de6b6f09702bb27c02d1904b3aebfca610c12772452c4e6c21a0d3\"},\n    {file = \"coverage-7.2.7-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:58c2ccc2f00ecb51253cbe5d8d7122a34590fac9646a960d1430d5b15321d95f\"},\n    {file = \"coverage-7.2.7-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:d22656368f0e6189e24722214ed8d66b8022db19d182927b9a248a2a8a2f67eb\"},\n    {file = \"coverage-7.2.7-cp37-cp37m-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:a895fcc7b15c3fc72beb43cdcbdf0ddb7d2ebc959edac9cef390b0d14f39f8a9\"},\n    {file = \"coverage-7.2.7-cp37-cp37m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:e84606b74eb7de6ff581a7915e2dab7a28a0517fbe1c9239eb227e1354064dcd\"},\n    {file = \"coverage-7.2.7-cp37-cp37m-musllinux_1_1_aarch64.whl\", hash = \"sha256:0a5f9e1dbd7fbe30196578ca36f3fba75376fb99888c395c5880b355e2875f8a\"},\n    {file = \"coverage-7.2.7-cp37-cp37m-musllinux_1_1_i686.whl\", hash = \"sha256:419bfd2caae268623dd469eff96d510a920c90928b60f2073d79f8fe2bbc5959\"},\n    {file = \"coverage-7.2.7-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:2aee274c46590717f38ae5e4650988d1af340fe06167546cc32fe2f58ed05b02\"},\n    {file = \"coverage-7.2.7-cp37-cp37m-win32.whl\", hash = \"sha256:61b9a528fb348373c433e8966535074b802c7a5d7f23c4f421e6c6e2f1697a6f\"},\n    {file = \"coverage-7.2.7-cp37-cp37m-win_amd64.whl\", hash = \"sha256:b1c546aca0ca4d028901d825015dc8e4d56aac4b541877690eb76490f1dc8ed0\"},\n    {file = \"coverage-7.2.7-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:54b896376ab563bd38453cecb813c295cf347cf5906e8b41d340b0321a5433e5\"},\n    {file = \"coverage-7.2.7-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:3d376df58cc111dc8e21e3b6e24606b5bb5dee6024f46a5abca99124b2229ef5\"},\n    {file = \"coverage-7.2.7-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:5e330fc79bd7207e46c7d7fd2bb4af2963f5f635703925543a70b99574b0fea9\"},\n    {file = \"coverage-7.2.7-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:1e9d683426464e4a252bf70c3498756055016f99ddaec3774bf368e76bbe02b6\"},\n    {file = \"coverage-7.2.7-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:8d13c64ee2d33eccf7437961b6ea7ad8673e2be040b4f7fd4fd4d4d28d9ccb1e\"},\n    {file = \"coverage-7.2.7-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:b7aa5f8a41217360e600da646004f878250a0d6738bcdc11a0a39928d7dc2050\"},\n    {file = \"coverage-7.2.7-cp38-cp38-musllinux_1_1_i686.whl\", hash = \"sha256:8fa03bce9bfbeeef9f3b160a8bed39a221d82308b4152b27d82d8daa7041fee5\"},\n    {file = \"coverage-7.2.7-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:245167dd26180ab4c91d5e1496a30be4cd721a5cf2abf52974f965f10f11419f\"},\n    {file = \"coverage-7.2.7-cp38-cp38-win32.whl\", hash = \"sha256:d2c2db7fd82e9b72937969bceac4d6ca89660db0a0967614ce2481e81a0b771e\"},\n    {file = \"coverage-7.2.7-cp38-cp38-win_amd64.whl\", hash = \"sha256:2e07b54284e381531c87f785f613b833569c14ecacdcb85d56b25c4622c16c3c\"},\n    {file = \"coverage-7.2.7-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:537891ae8ce59ef63d0123f7ac9e2ae0fc8b72c7ccbe5296fec45fd68967b6c9\"},\n    {file = \"coverage-7.2.7-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:06fb182e69f33f6cd1d39a6c597294cff3143554b64b9825d1dc69d18cc2fff2\"},\n    {file = \"coverage-7.2.7-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:201e7389591af40950a6480bd9edfa8ed04346ff80002cec1a66cac4549c1ad7\"},\n    {file = \"coverage-7.2.7-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:f6951407391b639504e3b3be51b7ba5f3528adbf1a8ac3302b687ecababf929e\"},\n    {file = \"coverage-7.2.7-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:6f48351d66575f535669306aa7d6d6f71bc43372473b54a832222803eb956fd1\"},\n    {file = \"coverage-7.2.7-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:b29019c76039dc3c0fd815c41392a044ce555d9bcdd38b0fb60fb4cd8e475ba9\"},\n    {file = \"coverage-7.2.7-cp39-cp39-musllinux_1_1_i686.whl\", hash = \"sha256:81c13a1fc7468c40f13420732805a4c38a105d89848b7c10af65a90beff25250\"},\n    {file = \"coverage-7.2.7-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:975d70ab7e3c80a3fe86001d8751f6778905ec723f5b110aed1e450da9d4b7f2\"},\n    {file = \"coverage-7.2.7-cp39-cp39-win32.whl\", hash = \"sha256:7ee7d9d4822c8acc74a5e26c50604dff824710bc8de424904c0982e25c39c6cb\"},\n    {file = \"coverage-7.2.7-cp39-cp39-win_amd64.whl\", hash = \"sha256:eb393e5ebc85245347950143969b241d08b52b88a3dc39479822e073a1a8eb27\"},\n    {file = \"coverage-7.2.7-pp37.pp38.pp39-none-any.whl\", hash = \"sha256:b7b4c971f05e6ae490fef852c218b0e79d4e52f79ef0c8475566584a8fb3e01d\"},\n    {file = \"coverage-7.2.7.tar.gz\", hash = \"sha256:924d94291ca674905fe9481f12294eb11f2d3d3fd1adb20314ba89e94f44ed59\"},\n]\ndistlib = [\n    {file = \"distlib-0.3.7-py2.py3-none-any.whl\", hash = \"sha256:2e24928bc811348f0feb63014e97aaae3037f2cf48712d51ae61df7fd6075057\"},\n    {file = \"distlib-0.3.7.tar.gz\", hash = \"sha256:9dafe54b34a028eafd95039d5e5d4851a13734540f1331060d31c9916e7147a8\"},\n]\ndocutils = [\n    {file = \"docutils-0.18.1-py2.py3-none-any.whl\", hash = \"sha256:23010f129180089fbcd3bc08cfefccb3b890b0050e1ca00c867036e9d161b98c\"},\n    {file = \"docutils-0.18.1.tar.gz\", hash = \"sha256:679987caf361a7539d76e584cbeddc311e3aee937877c87346f31debc63e9d06\"},\n]\nexceptiongroup = [\n    {file = \"exceptiongroup-1.1.0-py3-none-any.whl\", hash = \"sha256:327cbda3da756e2de031a3107b81ab7b3770a602c4d16ca618298c526f4bec1e\"},\n    {file = \"exceptiongroup-1.1.0.tar.gz\", hash = \"sha256:bcb67d800a4497e1b404c2dd44fca47d3b7a5e5433dbab67f96c1a685cdfdf23\"},\n]\nfilelock = [\n    {file = \"filelock-3.12.2-py3-none-any.whl\", hash = \"sha256:cbb791cdea2a72f23da6ac5b5269ab0a0d161e9ef0100e653b69049a7706d1ec\"},\n    {file = \"filelock-3.12.2.tar.gz\", hash = \"sha256:002740518d8aa59a26b0c76e10fb8c6e15eae825d34b6fdf670333fd7b938d81\"},\n]\nflake8 = [\n    {file = \"flake8-6.1.0-py2.py3-none-any.whl\", hash = \"sha256:ffdfce58ea94c6580c77888a86506937f9a1a227dfcd15f245d694ae20a6b6e5\"},\n    {file = \"flake8-6.1.0.tar.gz\", hash = \"sha256:d5b3857f07c030bdb5bf41c7f53799571d75c4491748a3adcd47de929e34cd23\"},\n]\nidna = [\n    {file = \"idna-3.2-py3-none-any.whl\", hash = \"sha256:14475042e284991034cb48e06f6851428fb14c4dc953acd9be9a5e95c7b6dd7a\"},\n    {file = \"idna-3.2.tar.gz\", hash = \"sha256:467fbad99067910785144ce333826c71fb0e63a425657295239737f7ecd125f3\"},\n]\nimagesize = [\n    {file = \"imagesize-1.4.1-py2.py3-none-any.whl\", hash = \"sha256:0d8d18d08f840c19d0ee7ca1fd82490fdc3729b7ac93f49870406ddde8ef8d8b\"},\n    {file = \"imagesize-1.4.1.tar.gz\", hash = \"sha256:69150444affb9cb0d5cc5a92b3676f0b2fb7cd9ae39e947a5e11a36b4497cd4a\"},\n]\nimportlib-metadata = [\n    {file = \"importlib_metadata-4.8.1-py3-none-any.whl\", hash = \"sha256:b618b6d2d5ffa2f16add5697cf57a46c76a56229b0ed1c438322e4e95645bd15\"},\n    {file = \"importlib_metadata-4.8.1.tar.gz\", hash = \"sha256:f284b3e11256ad1e5d03ab86bb2ccd6f5339688ff17a4d797a0fe7df326f23b1\"},\n]\niniconfig = [\n    {file = \"iniconfig-1.1.1-py2.py3-none-any.whl\", hash = \"sha256:011e24c64b7f47f6ebd835bb12a743f2fbe9a26d4cecaa7f53bc4f35ee9da8b3\"},\n    {file = \"iniconfig-1.1.1.tar.gz\", hash = \"sha256:bc3af051d7d14b2ee5ef9969666def0cd1a000e121eaea580d4a313df4b37f32\"},\n]\njinja2 = [\n    {file = \"Jinja2-3.0.1-py3-none-any.whl\", hash = \"sha256:1f06f2da51e7b56b8f238affdd6b4e2c61e39598a378cc49345bc1bd42a978a4\"},\n    {file = \"Jinja2-3.0.1.tar.gz\", hash = \"sha256:703f484b47a6af502e743c9122595cc812b0271f661722403114f71a79d0f5a4\"},\n]\nmarkupsafe = [\n    {file = \"MarkupSafe-2.0.1-cp310-cp310-macosx_10_9_universal2.whl\", hash = \"sha256:d8446c54dc28c01e5a2dbac5a25f071f6653e6e40f3a8818e8b45d790fe6ef53\"},\n    {file = \"MarkupSafe-2.0.1-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:36bc903cbb393720fad60fc28c10de6acf10dc6cc883f3e24ee4012371399a38\"},\n    {file = \"MarkupSafe-2.0.1-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:2d7d807855b419fc2ed3e631034685db6079889a1f01d5d9dac950f764da3dad\"},\n    {file = \"MarkupSafe-2.0.1-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:add36cb2dbb8b736611303cd3bfcee00afd96471b09cda130da3581cbdc56a6d\"},\n    {file = \"MarkupSafe-2.0.1-cp310-cp310-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl\", hash = \"sha256:168cd0a3642de83558a5153c8bd34f175a9a6e7f6dc6384b9655d2697312a646\"},\n    {file = \"MarkupSafe-2.0.1-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:4dc8f9fb58f7364b63fd9f85013b780ef83c11857ae79f2feda41e270468dd9b\"},\n    {file = \"MarkupSafe-2.0.1-cp310-cp310-musllinux_1_1_i686.whl\", hash = \"sha256:20dca64a3ef2d6e4d5d615a3fd418ad3bde77a47ec8a23d984a12b5b4c74491a\"},\n    {file = \"MarkupSafe-2.0.1-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:cdfba22ea2f0029c9261a4bd07e830a8da012291fbe44dc794e488b6c9bb353a\"},\n    {file = \"MarkupSafe-2.0.1-cp310-cp310-win32.whl\", hash = \"sha256:99df47edb6bda1249d3e80fdabb1dab8c08ef3975f69aed437cb69d0a5de1e28\"},\n    {file = \"MarkupSafe-2.0.1-cp310-cp310-win_amd64.whl\", hash = \"sha256:e0f138900af21926a02425cf736db95be9f4af72ba1bb21453432a07f6082134\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-macosx_10_9_x86_64.whl\", hash = \"sha256:f9081981fe268bd86831e5c75f7de206ef275defcb82bc70740ae6dc507aee51\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-manylinux1_i686.whl\", hash = \"sha256:0955295dd5eec6cb6cc2fe1698f4c6d84af2e92de33fbcac4111913cd100a6ff\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-manylinux1_x86_64.whl\", hash = \"sha256:0446679737af14f45767963a1a9ef7620189912317d095f2d9ffa183a4d25d2b\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-manylinux2010_i686.whl\", hash = \"sha256:f826e31d18b516f653fe296d967d700fddad5901ae07c622bb3705955e1faa94\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-manylinux2010_x86_64.whl\", hash = \"sha256:fa130dd50c57d53368c9d59395cb5526eda596d3ffe36666cd81a44d56e48872\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-manylinux2014_aarch64.whl\", hash = \"sha256:905fec760bd2fa1388bb5b489ee8ee5f7291d692638ea5f67982d968366bef9f\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:bf5d821ffabf0ef3533c39c518f3357b171a1651c1ff6827325e4489b0e46c3c\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-manylinux_2_5_i686.manylinux1_i686.manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:0d4b31cc67ab36e3392bbf3862cfbadac3db12bdd8b02a2731f509ed5b829724\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl\", hash = \"sha256:baa1a4e8f868845af802979fcdbf0bb11f94f1cb7ced4c4b8a351bb60d108145\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-musllinux_1_1_aarch64.whl\", hash = \"sha256:deb993cacb280823246a026e3b2d81c493c53de6acfd5e6bfe31ab3402bb37dd\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-musllinux_1_1_i686.whl\", hash = \"sha256:63f3268ba69ace99cab4e3e3b5840b03340efed0948ab8f78d2fd87ee5442a4f\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-musllinux_1_1_x86_64.whl\", hash = \"sha256:8d206346619592c6200148b01a2142798c989edcb9c896f9ac9722a99d4e77e6\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-win32.whl\", hash = \"sha256:6c4ca60fa24e85fe25b912b01e62cb969d69a23a5d5867682dd3e80b5b02581d\"},\n    {file = \"MarkupSafe-2.0.1-cp36-cp36m-win_amd64.whl\", hash = \"sha256:b2f4bf27480f5e5e8ce285a8c8fd176c0b03e93dcc6646477d4630e83440c6a9\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:0717a7390a68be14b8c793ba258e075c6f4ca819f15edfc2a3a027c823718567\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-manylinux1_i686.whl\", hash = \"sha256:6557b31b5e2c9ddf0de32a691f2312a32f77cd7681d8af66c2692efdbef84c18\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-manylinux1_x86_64.whl\", hash = \"sha256:49e3ceeabbfb9d66c3aef5af3a60cc43b85c33df25ce03d0031a608b0a8b2e3f\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-manylinux2010_i686.whl\", hash = \"sha256:d7f9850398e85aba693bb640262d3611788b1f29a79f0c93c565694658f4071f\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-manylinux2010_x86_64.whl\", hash = \"sha256:6a7fae0dd14cf60ad5ff42baa2e95727c3d81ded453457771d02b7d2b3f9c0c2\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-manylinux2014_aarch64.whl\", hash = \"sha256:b7f2d075102dc8c794cbde1947378051c4e5180d52d276987b8d28a3bd58c17d\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:e9936f0b261d4df76ad22f8fee3ae83b60d7c3e871292cd42f40b81b70afae85\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-manylinux_2_5_i686.manylinux1_i686.manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:2a7d351cbd8cfeb19ca00de495e224dea7e7d919659c2841bbb7f420ad03e2d6\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl\", hash = \"sha256:60bf42e36abfaf9aff1f50f52644b336d4f0a3fd6d8a60ca0d054ac9f713a864\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-musllinux_1_1_aarch64.whl\", hash = \"sha256:d6c7ebd4e944c85e2c3421e612a7057a2f48d478d79e61800d81468a8d842207\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-musllinux_1_1_i686.whl\", hash = \"sha256:f0567c4dc99f264f49fe27da5f735f414c4e7e7dd850cfd8e69f0862d7c74ea9\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:89c687013cb1cd489a0f0ac24febe8c7a666e6e221b783e53ac50ebf68e45d86\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-win32.whl\", hash = \"sha256:a30e67a65b53ea0a5e62fe23682cfe22712e01f453b95233b25502f7c61cb415\"},\n    {file = \"MarkupSafe-2.0.1-cp37-cp37m-win_amd64.whl\", hash = \"sha256:611d1ad9a4288cf3e3c16014564df047fe08410e628f89805e475368bd304914\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-macosx_10_9_universal2.whl\", hash = \"sha256:5bb28c636d87e840583ee3adeb78172efc47c8b26127267f54a9c0ec251d41a9\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:be98f628055368795d818ebf93da628541e10b75b41c559fdf36d104c5787066\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-manylinux1_i686.whl\", hash = \"sha256:1d609f577dc6e1aa17d746f8bd3c31aa4d258f4070d61b2aa5c4166c1539de35\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-manylinux1_x86_64.whl\", hash = \"sha256:7d91275b0245b1da4d4cfa07e0faedd5b0812efc15b702576d103293e252af1b\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-manylinux2010_i686.whl\", hash = \"sha256:01a9b8ea66f1658938f65b93a85ebe8bc016e6769611be228d797c9d998dd298\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-manylinux2010_x86_64.whl\", hash = \"sha256:47ab1e7b91c098ab893b828deafa1203de86d0bc6ab587b160f78fe6c4011f75\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-manylinux2014_aarch64.whl\", hash = \"sha256:97383d78eb34da7e1fa37dd273c20ad4320929af65d156e35a5e2d89566d9dfb\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:6fcf051089389abe060c9cd7caa212c707e58153afa2c649f00346ce6d260f1b\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:5855f8438a7d1d458206a2466bf82b0f104a3724bf96a1c781ab731e4201731a\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl\", hash = \"sha256:3dd007d54ee88b46be476e293f48c85048603f5f516008bee124ddd891398ed6\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:aca6377c0cb8a8253e493c6b451565ac77e98c2951c45f913e0b52facdcff83f\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-musllinux_1_1_i686.whl\", hash = \"sha256:04635854b943835a6ea959e948d19dcd311762c5c0c6e1f0e16ee57022669194\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:6300b8454aa6930a24b9618fbb54b5a68135092bc666f7b06901f897fa5c2fee\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-win32.whl\", hash = \"sha256:023cb26ec21ece8dc3907c0e8320058b2e0cb3c55cf9564da612bc325bed5e64\"},\n    {file = \"MarkupSafe-2.0.1-cp38-cp38-win_amd64.whl\", hash = \"sha256:984d76483eb32f1bcb536dc27e4ad56bba4baa70be32fa87152832cdd9db0833\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-macosx_10_9_universal2.whl\", hash = \"sha256:2ef54abee730b502252bcdf31b10dacb0a416229b72c18b19e24a4509f273d26\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:3c112550557578c26af18a1ccc9e090bfe03832ae994343cfdacd287db6a6ae7\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-manylinux1_i686.whl\", hash = \"sha256:53edb4da6925ad13c07b6d26c2a852bd81e364f95301c66e930ab2aef5b5ddd8\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-manylinux1_x86_64.whl\", hash = \"sha256:f5653a225f31e113b152e56f154ccbe59eeb1c7487b39b9d9f9cdb58e6c79dc5\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-manylinux2010_i686.whl\", hash = \"sha256:4efca8f86c54b22348a5467704e3fec767b2db12fc39c6d963168ab1d3fc9135\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-manylinux2010_x86_64.whl\", hash = \"sha256:ab3ef638ace319fa26553db0624c4699e31a28bb2a835c5faca8f8acf6a5a902\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-manylinux2014_aarch64.whl\", hash = \"sha256:f8ba0e8349a38d3001fae7eadded3f6606f0da5d748ee53cc1dab1d6527b9509\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:c47adbc92fc1bb2b3274c4b3a43ae0e4573d9fbff4f54cd484555edbf030baf1\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:37205cac2a79194e3750b0af2a5720d95f786a55ce7df90c3af697bfa100eaac\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl\", hash = \"sha256:1f2ade76b9903f39aa442b4aadd2177decb66525062db244b35d71d0ee8599b6\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:4296f2b1ce8c86a6aea78613c34bb1a672ea0e3de9c6ba08a960efe0b0a09047\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-musllinux_1_1_i686.whl\", hash = \"sha256:9f02365d4e99430a12647f09b6cc8bab61a6564363f313126f775eb4f6ef798e\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:5b6d930f030f8ed98e3e6c98ffa0652bdb82601e7a016ec2ab5d7ff23baa78d1\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-win32.whl\", hash = \"sha256:10f82115e21dc0dfec9ab5c0223652f7197feb168c940f3ef61563fc2d6beb74\"},\n    {file = \"MarkupSafe-2.0.1-cp39-cp39-win_amd64.whl\", hash = \"sha256:693ce3f9e70a6cf7d2fb9e6c9d8b204b6b39897a2c4a1aa65728d5ac97dcc1d8\"},\n    {file = \"MarkupSafe-2.0.1.tar.gz\", hash = \"sha256:594c67807fb16238b30c44bdf74f36c02cdf22d1c8cda91ef8a0ed8dabf5620a\"},\n]\nmccabe = [\n    {file = \"mccabe-0.7.0-py2.py3-none-any.whl\", hash = \"sha256:6c2d30ab6be0e4a46919781807b4f0d834ebdd6c6e3dca0bda5a15f863427b6e\"},\n    {file = \"mccabe-0.7.0.tar.gz\", hash = \"sha256:348e0240c33b60bbdf4e523192ef919f28cb2c3d7d5c7794f74009290f236325\"},\n]\nmypy = [\n    {file = \"mypy-1.4.1-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:566e72b0cd6598503e48ea610e0052d1b8168e60a46e0bfd34b3acf2d57f96a8\"},\n    {file = \"mypy-1.4.1-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:ca637024ca67ab24a7fd6f65d280572c3794665eaf5edcc7e90a866544076878\"},\n    {file = \"mypy-1.4.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:0dde1d180cd84f0624c5dcaaa89c89775550a675aff96b5848de78fb11adabcd\"},\n    {file = \"mypy-1.4.1-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:8c4d8e89aa7de683e2056a581ce63c46a0c41e31bd2b6d34144e2c80f5ea53dc\"},\n    {file = \"mypy-1.4.1-cp310-cp310-win_amd64.whl\", hash = \"sha256:bfdca17c36ae01a21274a3c387a63aa1aafe72bff976522886869ef131b937f1\"},\n    {file = \"mypy-1.4.1-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:7549fbf655e5825d787bbc9ecf6028731973f78088fbca3a1f4145c39ef09462\"},\n    {file = \"mypy-1.4.1-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:98324ec3ecf12296e6422939e54763faedbfcc502ea4a4c38502082711867258\"},\n    {file = \"mypy-1.4.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:141dedfdbfe8a04142881ff30ce6e6653c9685b354876b12e4fe6c78598b45e2\"},\n    {file = \"mypy-1.4.1-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:8207b7105829eca6f3d774f64a904190bb2231de91b8b186d21ffd98005f14a7\"},\n    {file = \"mypy-1.4.1-cp311-cp311-win_amd64.whl\", hash = \"sha256:16f0db5b641ba159eff72cff08edc3875f2b62b2fa2bc24f68c1e7a4e8232d01\"},\n    {file = \"mypy-1.4.1-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:470c969bb3f9a9efcedbadcd19a74ffb34a25f8e6b0e02dae7c0e71f8372f97b\"},\n    {file = \"mypy-1.4.1-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:e5952d2d18b79f7dc25e62e014fe5a23eb1a3d2bc66318df8988a01b1a037c5b\"},\n    {file = \"mypy-1.4.1-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:190b6bab0302cec4e9e6767d3eb66085aef2a1cc98fe04936d8a42ed2ba77bb7\"},\n    {file = \"mypy-1.4.1-cp37-cp37m-win_amd64.whl\", hash = \"sha256:9d40652cc4fe33871ad3338581dca3297ff5f2213d0df345bcfbde5162abf0c9\"},\n    {file = \"mypy-1.4.1-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:01fd2e9f85622d981fd9063bfaef1aed6e336eaacca00892cd2d82801ab7c042\"},\n    {file = \"mypy-1.4.1-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:2460a58faeea905aeb1b9b36f5065f2dc9a9c6e4c992a6499a2360c6c74ceca3\"},\n    {file = \"mypy-1.4.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:a2746d69a8196698146a3dbe29104f9eb6a2a4d8a27878d92169a6c0b74435b6\"},\n    {file = \"mypy-1.4.1-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:ae704dcfaa180ff7c4cfbad23e74321a2b774f92ca77fd94ce1049175a21c97f\"},\n    {file = \"mypy-1.4.1-cp38-cp38-win_amd64.whl\", hash = \"sha256:43d24f6437925ce50139a310a64b2ab048cb2d3694c84c71c3f2a1626d8101dc\"},\n    {file = \"mypy-1.4.1-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:c482e1246726616088532b5e964e39765b6d1520791348e6c9dc3af25b233828\"},\n    {file = \"mypy-1.4.1-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:43b592511672017f5b1a483527fd2684347fdffc041c9ef53428c8dc530f79a3\"},\n    {file = \"mypy-1.4.1-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:34a9239d5b3502c17f07fd7c0b2ae6b7dd7d7f6af35fbb5072c6208e76295816\"},\n    {file = \"mypy-1.4.1-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:5703097c4936bbb9e9bce41478c8d08edd2865e177dc4c52be759f81ee4dd26c\"},\n    {file = \"mypy-1.4.1-cp39-cp39-win_amd64.whl\", hash = \"sha256:e02d700ec8d9b1859790c0475df4e4092c7bf3272a4fd2c9f33d87fac4427b8f\"},\n    {file = \"mypy-1.4.1-py3-none-any.whl\", hash = \"sha256:45d32cec14e7b97af848bddd97d85ea4f0db4d5a149ed9676caa4eb2f7402bb4\"},\n    {file = \"mypy-1.4.1.tar.gz\", hash = \"sha256:9bbcd9ab8ea1f2e1c8031c21445b511442cc45c89951e49bbf852cbb70755b1b\"},\n]\nmypy-extensions = [\n    {file = \"mypy_extensions-1.0.0-py3-none-any.whl\", hash = \"sha256:4392f6c0eb8a5668a69e23d168ffa70f0be9ccfd32b5cc2d26a34ae5b844552d\"},\n    {file = \"mypy_extensions-1.0.0.tar.gz\", hash = \"sha256:75dbf8955dc00442a438fc4d0666508a9a97b6bd41aa2f0ffe9d2f2725af0782\"},\n]\npackaging = [\n    {file = \"packaging-23.1-py3-none-any.whl\", hash = \"sha256:994793af429502c4ea2ebf6bf664629d07c1a9fe974af92966e4b8d2df7edc61\"},\n    {file = \"packaging-23.1.tar.gz\", hash = \"sha256:a392980d2b6cffa644431898be54b0045151319d1e7ec34f0cfed48767dd334f\"},\n]\npathspec = [\n    {file = \"pathspec-0.9.0-py2.py3-none-any.whl\", hash = \"sha256:7d15c4ddb0b5c802d161efc417ec1a2558ea2653c2e8ad9c19098201dc1c993a\"},\n    {file = \"pathspec-0.9.0.tar.gz\", hash = \"sha256:e564499435a2673d586f6b2130bb5b95f04a3ba06f81b8f895b651a3c76aabb1\"},\n]\nplatformdirs = [\n    {file = \"platformdirs-3.10.0-py3-none-any.whl\", hash = \"sha256:d7c24979f292f916dc9cbf8648319032f551ea8c49a4c9bf2fb556a02070ec1d\"},\n    {file = \"platformdirs-3.10.0.tar.gz\", hash = \"sha256:b45696dab2d7cc691a3226759c0d3b00c47c8b6e293d96f6436f733303f77f6d\"},\n]\npluggy = [\n    {file = \"pluggy-1.2.0-py3-none-any.whl\", hash = \"sha256:c2fd55a7d7a3863cba1a013e4e2414658b1d07b6bc57b3919e0c63c9abb99849\"},\n    {file = \"pluggy-1.2.0.tar.gz\", hash = \"sha256:d12f0c4b579b15f5e054301bb226ee85eeeba08ffec228092f8defbaa3a4c4b3\"},\n]\npycodestyle = [\n    {file = \"pycodestyle-2.11.0-py2.py3-none-any.whl\", hash = \"sha256:5d1013ba8dc7895b548be5afb05740ca82454fd899971563d2ef625d090326f8\"},\n    {file = \"pycodestyle-2.11.0.tar.gz\", hash = \"sha256:259bcc17857d8a8b3b4a2327324b79e5f020a13c16074670f9c8c8f872ea76d0\"},\n]\npydantic = [\n    {file = \"pydantic-1.9.2-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:9c9e04a6cdb7a363d7cb3ccf0efea51e0abb48e180c0d31dca8d247967d85c6e\"},\n    {file = \"pydantic-1.9.2-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:fafe841be1103f340a24977f61dee76172e4ae5f647ab9e7fd1e1fca51524f08\"},\n    {file = \"pydantic-1.9.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:afacf6d2a41ed91fc631bade88b1d319c51ab5418870802cedb590b709c5ae3c\"},\n    {file = \"pydantic-1.9.2-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:3ee0d69b2a5b341fc7927e92cae7ddcfd95e624dfc4870b32a85568bd65e6131\"},\n    {file = \"pydantic-1.9.2-cp310-cp310-musllinux_1_1_i686.whl\", hash = \"sha256:ff68fc85355532ea77559ede81f35fff79a6a5543477e168ab3a381887caea76\"},\n    {file = \"pydantic-1.9.2-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:c0f5e142ef8217019e3eef6ae1b6b55f09a7a15972958d44fbd228214cede567\"},\n    {file = \"pydantic-1.9.2-cp310-cp310-win_amd64.whl\", hash = \"sha256:615661bfc37e82ac677543704437ff737418e4ea04bef9cf11c6d27346606044\"},\n    {file = \"pydantic-1.9.2-cp36-cp36m-macosx_10_9_x86_64.whl\", hash = \"sha256:328558c9f2eed77bd8fffad3cef39dbbe3edc7044517f4625a769d45d4cf7555\"},\n    {file = \"pydantic-1.9.2-cp36-cp36m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:2bd446bdb7755c3a94e56d7bdfd3ee92396070efa8ef3a34fab9579fe6aa1d84\"},\n    {file = \"pydantic-1.9.2-cp36-cp36m-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:e0b214e57623a535936005797567231a12d0da0c29711eb3514bc2b3cd008d0f\"},\n    {file = \"pydantic-1.9.2-cp36-cp36m-musllinux_1_1_i686.whl\", hash = \"sha256:d8ce3fb0841763a89322ea0432f1f59a2d3feae07a63ea2c958b2315e1ae8adb\"},\n    {file = \"pydantic-1.9.2-cp36-cp36m-musllinux_1_1_x86_64.whl\", hash = \"sha256:b34ba24f3e2d0b39b43f0ca62008f7ba962cff51efa56e64ee25c4af6eed987b\"},\n    {file = \"pydantic-1.9.2-cp36-cp36m-win_amd64.whl\", hash = \"sha256:84d76ecc908d917f4684b354a39fd885d69dd0491be175f3465fe4b59811c001\"},\n    {file = \"pydantic-1.9.2-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:4de71c718c9756d679420c69f216776c2e977459f77e8f679a4a961dc7304a56\"},\n    {file = \"pydantic-1.9.2-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:5803ad846cdd1ed0d97eb00292b870c29c1f03732a010e66908ff48a762f20e4\"},\n    {file = \"pydantic-1.9.2-cp37-cp37m-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:a8c5360a0297a713b4123608a7909e6869e1b56d0e96eb0d792c27585d40757f\"},\n    {file = \"pydantic-1.9.2-cp37-cp37m-musllinux_1_1_i686.whl\", hash = \"sha256:cdb4272678db803ddf94caa4f94f8672e9a46bae4a44f167095e4d06fec12979\"},\n    {file = \"pydantic-1.9.2-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:19b5686387ea0d1ea52ecc4cffb71abb21702c5e5b2ac626fd4dbaa0834aa49d\"},\n    {file = \"pydantic-1.9.2-cp37-cp37m-win_amd64.whl\", hash = \"sha256:32e0b4fb13ad4db4058a7c3c80e2569adbd810c25e6ca3bbd8b2a9cc2cc871d7\"},\n    {file = \"pydantic-1.9.2-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:91089b2e281713f3893cd01d8e576771cd5bfdfbff5d0ed95969f47ef6d676c3\"},\n    {file = \"pydantic-1.9.2-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:e631c70c9280e3129f071635b81207cad85e6c08e253539467e4ead0e5b219aa\"},\n    {file = \"pydantic-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:4b3946f87e5cef3ba2e7bd3a4eb5a20385fe36521d6cc1ebf3c08a6697c6cfb3\"},\n    {file = \"pydantic-1.9.2-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:5565a49effe38d51882cb7bac18bda013cdb34d80ac336428e8908f0b72499b0\"},\n    {file = \"pydantic-1.9.2-cp38-cp38-musllinux_1_1_i686.whl\", hash = \"sha256:bd67cb2c2d9602ad159389c29e4ca964b86fa2f35c2faef54c3eb28b4efd36c8\"},\n    {file = \"pydantic-1.9.2-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:4aafd4e55e8ad5bd1b19572ea2df546ccace7945853832bb99422a79c70ce9b8\"},\n    {file = \"pydantic-1.9.2-cp38-cp38-win_amd64.whl\", hash = \"sha256:d70916235d478404a3fa8c997b003b5f33aeac4686ac1baa767234a0f8ac2326\"},\n    {file = \"pydantic-1.9.2-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:f0ca86b525264daa5f6b192f216a0d1e860b7383e3da1c65a1908f9c02f42801\"},\n    {file = \"pydantic-1.9.2-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:1061c6ee6204f4f5a27133126854948e3b3d51fcc16ead2e5d04378c199b2f44\"},\n    {file = \"pydantic-1.9.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:e78578f0c7481c850d1c969aca9a65405887003484d24f6110458fb02cca7747\"},\n    {file = \"pydantic-1.9.2-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:5da164119602212a3fe7e3bc08911a89db4710ae51444b4224c2382fd09ad453\"},\n    {file = \"pydantic-1.9.2-cp39-cp39-musllinux_1_1_i686.whl\", hash = \"sha256:7ead3cd020d526f75b4188e0a8d71c0dbbe1b4b6b5dc0ea775a93aca16256aeb\"},\n    {file = \"pydantic-1.9.2-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:7d0f183b305629765910eaad707800d2f47c6ac5bcfb8c6397abdc30b69eeb15\"},\n    {file = \"pydantic-1.9.2-cp39-cp39-win_amd64.whl\", hash = \"sha256:f1a68f4f65a9ee64b6ccccb5bf7e17db07caebd2730109cb8a95863cfa9c4e55\"},\n    {file = \"pydantic-1.9.2-py3-none-any.whl\", hash = \"sha256:78a4d6bdfd116a559aeec9a4cfe77dda62acc6233f8b56a716edad2651023e5e\"},\n    {file = \"pydantic-1.9.2.tar.gz\", hash = \"sha256:8cb0bc509bfb71305d7a59d00163d5f9fc4530f0881ea32c74ff4f74c85f3d3d\"},\n]\npyflakes = [\n    {file = \"pyflakes-3.1.0-py2.py3-none-any.whl\", hash = \"sha256:4132f6d49cb4dae6819e5379898f2b8cce3c5f23994194c24b77d5da2e36f774\"},\n    {file = \"pyflakes-3.1.0.tar.gz\", hash = \"sha256:a0aae034c444db0071aa077972ba4768d40c830d9539fd45bf4cd3f8f6992efc\"},\n]\npygments = [\n    {file = \"Pygments-2.14.0-py3-none-any.whl\", hash = \"sha256:fa7bd7bd2771287c0de303af8bfdfc731f51bd2c6a47ab69d117138893b82717\"},\n    {file = \"Pygments-2.14.0.tar.gz\", hash = \"sha256:b3ed06a9e8ac9a9aae5a6f5dbe78a8a58655d17b43b93c078f094ddc476ae297\"},\n]\npyproject-api = [\n    {file = \"pyproject_api-1.5.3-py3-none-any.whl\", hash = \"sha256:14cf09828670c7b08842249c1f28c8ee6581b872e893f81b62d5465bec41502f\"},\n    {file = \"pyproject_api-1.5.3.tar.gz\", hash = \"sha256:ffb5b2d7cad43f5b2688ab490de7c4d3f6f15e0b819cb588c4b771567c9729eb\"},\n]\npytest = [\n    {file = \"pytest-7.4.0-py3-none-any.whl\", hash = \"sha256:78bf16451a2eb8c7a2ea98e32dc119fd2aa758f1d5d66dbf0a59d69a3969df32\"},\n    {file = \"pytest-7.4.0.tar.gz\", hash = \"sha256:b4bf8c45bd59934ed84001ad51e11b4ee40d40a1229d2c79f9c592b0a3f6bd8a\"},\n]\npytz = [\n    {file = \"pytz-2021.1-py2.py3-none-any.whl\", hash = \"sha256:eb10ce3e7736052ed3623d49975ce333bcd712c7bb19a58b9e2089d4057d0798\"},\n    {file = \"pytz-2021.1.tar.gz\", hash = \"sha256:83a4a90894bf38e243cf052c8b58f381bfe9a7a483f6a9cab140bc7f702ac4da\"},\n]\nrequests = [\n    {file = \"requests-2.26.0-py2.py3-none-any.whl\", hash = \"sha256:6c1246513ecd5ecd4528a0906f910e8f0f9c6b8ec72030dc9fd154dc1a6efd24\"},\n    {file = \"requests-2.26.0.tar.gz\", hash = \"sha256:b8aa58f8cf793ffd8782d3d8cb19e66ef36f7aba4353eec859e74678b01b07a7\"},\n]\nrich = [\n    {file = \"rich-12.0.1-py3-none-any.whl\", hash = \"sha256:ce5c714e984a2d185399e4e1dd1f8b2feacb7cecfc576f1522425643a36a57ea\"},\n    {file = \"rich-12.0.1.tar.gz\", hash = \"sha256:3fba9dd15ebe048e2795a02ac19baee79dc12cc50b074ef70f2958cd651b59a9\"},\n]\nrstcheck = [\n    {file = \"rstcheck-6.1.2-py3-none-any.whl\", hash = \"sha256:4aaa46e0debc179f849807c453fa384fd2b75167faf5b1274115730805fab529\"},\n    {file = \"rstcheck-6.1.2.tar.gz\", hash = \"sha256:f9cb07a72ef9a81d1e32187eae29b00a89421ccba1bde0b1652a08ed0923f61b\"},\n]\nrstcheck-core = [\n    {file = \"rstcheck_core-1.0.3-py3-none-any.whl\", hash = \"sha256:d75d7df8f15b58e8aafe322d6fb6ef1ac8d12bb563089b0696948a00ee7f601a\"},\n    {file = \"rstcheck_core-1.0.3.tar.gz\", hash = \"sha256:add19c9a1b97d9087f4b463b49c12cd8a9c03689a255e99089c70a2692f16369\"},\n]\nshellingham = [\n    {file = \"shellingham-1.5.0.post1-py2.py3-none-any.whl\", hash = \"sha256:368bf8c00754fd4f55afb7bbb86e272df77e4dc76ac29dbcbb81a59e9fc15744\"},\n    {file = \"shellingham-1.5.0.post1.tar.gz\", hash = \"sha256:823bc5fb5c34d60f285b624e7264f4dda254bc803a3774a147bf99c0e3004a28\"},\n]\nsnowballstemmer = [\n    {file = \"snowballstemmer-2.1.0-py2.py3-none-any.whl\", hash = \"sha256:b51b447bea85f9968c13b650126a888aabd4cb4463fca868ec596826325dedc2\"},\n    {file = \"snowballstemmer-2.1.0.tar.gz\", hash = \"sha256:e997baa4f2e9139951b6f4c631bad912dfd3c792467e2f03d7239464af90e914\"},\n]\nsphinx = [\n    {file = \"Sphinx-6.1.3.tar.gz\", hash = \"sha256:0dac3b698538ffef41716cf97ba26c1c7788dba73ce6f150c1ff5b4720786dd2\"},\n    {file = \"sphinx-6.1.3-py3-none-any.whl\", hash = \"sha256:807d1cb3d6be87eb78a381c3e70ebd8d346b9a25f3753e9947e866b2786865fc\"},\n]\nsphinx-rtd-theme = [\n    {file = \"sphinx_rtd_theme-1.2.2-py2.py3-none-any.whl\", hash = \"sha256:6a7e7d8af34eb8fc57d52a09c6b6b9c46ff44aea5951bc831eeb9245378f3689\"},\n    {file = \"sphinx_rtd_theme-1.2.2.tar.gz\", hash = \"sha256:01c5c5a72e2d025bd23d1f06c59a4831b06e6ce6c01fdd5ebfe9986c0a880fc7\"},\n]\nsphinxcontrib-applehelp = [\n    {file = \"sphinxcontrib-applehelp-1.0.2.tar.gz\", hash = \"sha256:a072735ec80e7675e3f432fcae8610ecf509c5f1869d17e2eecff44389cdbc58\"},\n    {file = \"sphinxcontrib_applehelp-1.0.2-py2.py3-none-any.whl\", hash = \"sha256:806111e5e962be97c29ec4c1e7fe277bfd19e9652fb1a4392105b43e01af885a\"},\n]\nsphinxcontrib-devhelp = [\n    {file = \"sphinxcontrib-devhelp-1.0.2.tar.gz\", hash = \"sha256:ff7f1afa7b9642e7060379360a67e9c41e8f3121f2ce9164266f61b9f4b338e4\"},\n    {file = \"sphinxcontrib_devhelp-1.0.2-py2.py3-none-any.whl\", hash = \"sha256:8165223f9a335cc1af7ffe1ed31d2871f325254c0423bc0c4c7cd1c1e4734a2e\"},\n]\nsphinxcontrib-htmlhelp = [\n    {file = \"sphinxcontrib-htmlhelp-2.0.0.tar.gz\", hash = \"sha256:f5f8bb2d0d629f398bf47d0d69c07bc13b65f75a81ad9e2f71a63d4b7a2f6db2\"},\n    {file = \"sphinxcontrib_htmlhelp-2.0.0-py2.py3-none-any.whl\", hash = \"sha256:d412243dfb797ae3ec2b59eca0e52dac12e75a241bf0e4eb861e450d06c6ed07\"},\n]\nsphinxcontrib-jquery = [\n    {file = \"sphinxcontrib-jquery-4.1.tar.gz\", hash = \"sha256:1620739f04e36a2c779f1a131a2dfd49b2fd07351bf1968ced074365933abc7a\"},\n    {file = \"sphinxcontrib_jquery-4.1-py2.py3-none-any.whl\", hash = \"sha256:f936030d7d0147dd026a4f2b5a57343d233f1fc7b363f68b3d4f1cb0993878ae\"},\n]\nsphinxcontrib-jsmath = [\n    {file = \"sphinxcontrib-jsmath-1.0.1.tar.gz\", hash = \"sha256:a9925e4a4587247ed2191a22df5f6970656cb8ca2bd6284309578f2153e0c4b8\"},\n    {file = \"sphinxcontrib_jsmath-1.0.1-py2.py3-none-any.whl\", hash = \"sha256:2ec2eaebfb78f3f2078e73666b1415417a116cc848b72e5172e596c871103178\"},\n]\nsphinxcontrib-qthelp = [\n    {file = \"sphinxcontrib-qthelp-1.0.3.tar.gz\", hash = \"sha256:4c33767ee058b70dba89a6fc5c1892c0d57a54be67ddd3e7875a18d14cba5a72\"},\n    {file = \"sphinxcontrib_qthelp-1.0.3-py2.py3-none-any.whl\", hash = \"sha256:bd9fc24bcb748a8d51fd4ecaade681350aa63009a347a8c14e637895444dfab6\"},\n]\nsphinxcontrib-serializinghtml = [\n    {file = \"sphinxcontrib-serializinghtml-1.1.5.tar.gz\", hash = \"sha256:aa5f6de5dfdf809ef505c4895e51ef5c9eac17d0f287933eb49ec495280b6952\"},\n    {file = \"sphinxcontrib_serializinghtml-1.1.5-py2.py3-none-any.whl\", hash = \"sha256:352a9a00ae864471d3a7ead8d7d79f5fc0b57e8b3f95e9867eb9eb28999b92fd\"},\n]\ntoml = [\n    {file = \"toml-0.10.2-py2.py3-none-any.whl\", hash = \"sha256:806143ae5bfb6a3c6e736a764057db0e6a0e05e338b5630894a5f779cabb4f9b\"},\n    {file = \"toml-0.10.2.tar.gz\", hash = \"sha256:b3bda1d108d5dd99f4a20d24d9c348e91c4db7ab1b749200bded2f839ccbe68f\"},\n]\ntomli = [\n    {file = \"tomli-2.0.1-py3-none-any.whl\", hash = \"sha256:939de3e7a6161af0c887ef91b7d41a53e7c5a1ca976325f429cb46ea9bc30ecc\"},\n    {file = \"tomli-2.0.1.tar.gz\", hash = \"sha256:de526c12914f0c550d15924c62d72abc48d6fe7364aa87328337a31007fe8a4f\"},\n]\ntox = [\n    {file = \"tox-4.6.4-py3-none-any.whl\", hash = \"sha256:1b8f8ae08d6a5475cad9d508236c51ea060620126fd7c3c513d0f5c7f29cc776\"},\n    {file = \"tox-4.6.4.tar.gz\", hash = \"sha256:5e2ad8845764706170d3dcaac171704513cc8a725655219acb62fe4380bdadda\"},\n]\ntyper = [\n    {file = \"typer-0.7.0-py3-none-any.whl\", hash = \"sha256:b5e704f4e48ec263de1c0b3a2387cd405a13767d2f907f44c1a08cbad96f606d\"},\n    {file = \"typer-0.7.0.tar.gz\", hash = \"sha256:ff797846578a9f2a201b53442aedeb543319466870fbe1c701eab66dd7681165\"},\n]\ntypes-docutils = [\n    {file = \"types-docutils-0.19.1.3.tar.gz\", hash = \"sha256:36fe30de56f1ece1a9f7a990d47daa781b5af831d2b3f2dcb7dfd01b857cc3d4\"},\n    {file = \"types_docutils-0.19.1.3-py3-none-any.whl\", hash = \"sha256:d608e6b91ccf0e8e01c586a0af5b0e0462382d3be65b734af82d40c9d010735d\"},\n]\ntyping-extensions = [\n    {file = \"typing_extensions-4.7.1-py3-none-any.whl\", hash = \"sha256:440d5dd3af93b060174bf433bccd69b0babc3b15b1a8dca43789fd7f61514b36\"},\n    {file = \"typing_extensions-4.7.1.tar.gz\", hash = \"sha256:b75ddc264f0ba5615db7ba217daeb99701ad295353c45f9e95963337ceeeffb2\"},\n]\nurllib3 = [\n    {file = \"urllib3-1.26.6-py2.py3-none-any.whl\", hash = \"sha256:39fb8672126159acb139a7718dd10806104dec1e2f0f6c88aab05d17df10c8d4\"},\n    {file = \"urllib3-1.26.6.tar.gz\", hash = \"sha256:f57b4c16c62fa2760b7e3d97c35b255512fb6b59a259730f36ba32ce9f8e342f\"},\n]\nvirtualenv = [\n    {file = \"virtualenv-20.24.2-py3-none-any.whl\", hash = \"sha256:43a3052be36080548bdee0b42919c88072037d50d56c28bd3f853cbe92b953ff\"},\n    {file = \"virtualenv-20.24.2.tar.gz\", hash = \"sha256:fd8a78f46f6b99a67b7ec5cf73f92357891a7b3a40fd97637c27f854aae3b9e0\"},\n]\nzipp = [\n    {file = \"zipp-3.5.0-py3-none-any.whl\", hash = \"sha256:957cfda87797e389580cb8b9e3870841ca991e2125350677b2ca83a0e99390a3\"},\n    {file = \"zipp-3.5.0.tar.gz\", hash = \"sha256:f5812b1e007e48cff63449a5e9f4e7ebea716b4111f9c4f9a645f91d579bf0c4\"},\n]\n"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 1.78515625,
          "content": "[tool.poetry]\nname = \"sh\"\nversion = \"2.2.1\"\ndescription = \"Python subprocess replacement\"\nauthors = [\"Andrew Moffat <arwmoffat@gmail.com>\"]\nreadme = \"README.rst\"\nmaintainers = [\n    \"Andrew Moffat <arwmoffat@gmail.com>\",\n    \"Erik Cederstrand <erik@cederstrand.dk>\",\n]\nhomepage = \"https://sh.readthedocs.io/\"\nrepository = \"https://github.com/amoffat/sh\"\ndocumentation = \"https://sh.readthedocs.io/\"\nlicense = \"MIT\"\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Environment :: Console\",\n    \"Intended Audience :: Developers\",\n    \"Intended Audience :: System Administrators\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: Implementation :: CPython\",\n    \"Programming Language :: Python :: Implementation :: PyPy\",\n    \"Topic :: Software Development :: Build Tools\",\n    \"Topic :: Software Development :: Libraries :: Python Modules\",\n]\ninclude = [\n    { path = \"CHANGELOG.md\", format = \"sdist\" },\n    { path = \"MIGRATION.md\", format = \"sdist\" },\n    { path = \"images\", format = \"sdist\" },\n    { path = \"Makefile\", format = \"sdist\" },\n    { path = \"tests\", format = \"sdist\" },\n    { path = \"tox.ini\", format = \"sdist\" },\n    { path = \"LICENSE.txt\", format = \"sdist\" },\n]\n\n[tool.poetry.dependencies]\npython = \">=3.8.1,<4.0\"\n\n[tool.poetry.group.dev.dependencies]\ntox = \"^4.6.4\"\nblack = \"^23.7.0\"\ncoverage = \"^7.2.7\"\nflake8 = \"^6.1.0\"\nrstcheck = \"^6.1.2\"\nsphinx = \">=1.6,<7\"\nsphinx-rtd-theme = \"^1.2.2\"\npytest = \"^7.4.0\"\nmypy = \"^1.4.1\"\ntoml = \"^0.10.2\"\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0a5\"]\nbuild-backend = \"poetry.core.masonry.api\"\n"
        },
        {
          "name": "sh.py",
          "type": "blob",
          "size": 124.0126953125,
          "content": "\"\"\"\nhttps://sh.readthedocs.io/en/latest/\nhttps://github.com/amoffat/sh\n\"\"\"\n# ===============================================================================\n# Copyright (C) 2011-2023 by Andrew Moffat\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n# ===============================================================================\nimport asyncio\nfrom collections import deque\nfrom collections.abc import Mapping\n\nimport platform\nfrom importlib import metadata\n\ntry:\n    __version__ = metadata.version(\"sh\")\nexcept metadata.PackageNotFoundError:  # pragma: no cover\n    __version__ = \"unknown\"\n\nif \"windows\" in platform.system().lower():  # pragma: no cover\n    raise ImportError(\n        f\"sh {__version__} is currently only supported on Linux and macOS.\"\n    )\n\nimport errno\nimport fcntl\nimport gc\nimport getpass\nimport glob as glob_module\nimport inspect\nimport logging\nimport os\nimport pty\nimport pwd\nimport re\nimport select\nimport signal\nimport stat\nimport struct\nimport sys\nimport termios\nimport textwrap\nimport threading\nimport time\nimport traceback\nimport tty\nimport warnings\nimport weakref\nfrom asyncio import Queue as AQueue\nfrom contextlib import contextmanager\nfrom functools import partial\nfrom io import BytesIO, StringIO, UnsupportedOperation\nfrom io import open as fdopen\nfrom locale import getpreferredencoding\nfrom queue import Empty, Queue\nfrom shlex import quote as shlex_quote\nfrom types import GeneratorType, ModuleType\nfrom typing import Any, Dict, Type, Union\n\n__project_url__ = \"https://github.com/amoffat/sh\"\n\nTEE_STDOUT = {True, \"out\", 1}\nTEE_STDERR = {\"err\", 2}\n\nDEFAULT_ENCODING = getpreferredencoding() or \"UTF-8\"\n\nIS_MACOS = platform.system() in (\"AIX\", \"Darwin\")\nSH_LOGGER_NAME = __name__\n\n# normally i would hate this idea of using a global to signify whether we are\n# running tests, because it breaks the assumption that what is running in the\n# tests is what will run live, but we ONLY use this in a place that has no\n# serious side-effects that could change anything.  as long as we do that, it\n# should be ok\nRUNNING_TESTS = bool(int(os.environ.get(\"SH_TESTS_RUNNING\", \"0\")))\nFORCE_USE_SELECT = bool(int(os.environ.get(\"SH_TESTS_USE_SELECT\", \"0\")))\n\n# a re-entrant lock for pushd.  this way, multiple threads that happen to use\n# pushd will all see the current working directory for the duration of the\n# with-context\nPUSHD_LOCK = threading.RLock()\n\n\ndef get_num_args(fn):\n    return len(inspect.getfullargspec(fn).args)\n\n\n_unicode_methods = set(dir(\"\"))\n\nHAS_POLL = hasattr(select, \"poll\")\nPOLLER_EVENT_READ = 1\nPOLLER_EVENT_WRITE = 2\nPOLLER_EVENT_HUP = 4\nPOLLER_EVENT_ERROR = 8\n\n\nclass PollPoller:\n    def __init__(self):\n        self._poll = select.poll()\n        # file descriptor <-> file object bidirectional maps\n        self.fd_lookup = {}\n        self.fo_lookup = {}\n\n    def __nonzero__(self):\n        return len(self.fd_lookup) != 0\n\n    def __len__(self):\n        return len(self.fd_lookup)\n\n    def _set_fileobject(self, f):\n        if hasattr(f, \"fileno\"):\n            fd = f.fileno()\n            self.fd_lookup[fd] = f\n            self.fo_lookup[f] = fd\n        else:\n            self.fd_lookup[f] = f\n            self.fo_lookup[f] = f\n\n    def _remove_fileobject(self, f):\n        if hasattr(f, \"fileno\"):\n            fd = f.fileno()\n            del self.fd_lookup[fd]\n            del self.fo_lookup[f]\n        else:\n            del self.fd_lookup[f]\n            del self.fo_lookup[f]\n\n    def _get_file_descriptor(self, f):\n        return self.fo_lookup.get(f)\n\n    def _get_file_object(self, fd):\n        return self.fd_lookup.get(fd)\n\n    def _register(self, f, events):\n        # f can be a file descriptor or file object\n        self._set_fileobject(f)\n        fd = self._get_file_descriptor(f)\n        self._poll.register(fd, events)\n\n    def register_read(self, f):\n        self._register(f, select.POLLIN | select.POLLPRI)\n\n    def register_write(self, f):\n        self._register(f, select.POLLOUT)\n\n    def register_error(self, f):\n        self._register(f, select.POLLERR | select.POLLHUP | select.POLLNVAL)\n\n    def unregister(self, f):\n        fd = self._get_file_descriptor(f)\n        self._poll.unregister(fd)\n        self._remove_fileobject(f)\n\n    def poll(self, timeout):\n        if timeout is not None:\n            # convert from seconds to milliseconds\n            timeout *= 1000\n        changes = self._poll.poll(timeout)\n        results = []\n        for fd, events in changes:\n            f = self._get_file_object(fd)\n            if events & (select.POLLIN | select.POLLPRI):\n                results.append((f, POLLER_EVENT_READ))\n            elif events & select.POLLOUT:\n                results.append((f, POLLER_EVENT_WRITE))\n            elif events & select.POLLHUP:\n                results.append((f, POLLER_EVENT_HUP))\n            elif events & (select.POLLERR | select.POLLNVAL):\n                results.append((f, POLLER_EVENT_ERROR))\n        return results\n\n\nclass SelectPoller:\n    def __init__(self):\n        self.rlist = []\n        self.wlist = []\n        self.xlist = []\n\n    def __nonzero__(self):\n        return len(self.rlist) + len(self.wlist) + len(self.xlist) != 0\n\n    def __len__(self):\n        return len(self.rlist) + len(self.wlist) + len(self.xlist)\n\n    @staticmethod\n    def _register(f, events):\n        if f not in events:\n            events.append(f)\n\n    @staticmethod\n    def _unregister(f, events):\n        if f in events:\n            events.remove(f)\n\n    def register_read(self, f):\n        self._register(f, self.rlist)\n\n    def register_write(self, f):\n        self._register(f, self.wlist)\n\n    def register_error(self, f):\n        self._register(f, self.xlist)\n\n    def unregister(self, f):\n        self._unregister(f, self.rlist)\n        self._unregister(f, self.wlist)\n        self._unregister(f, self.xlist)\n\n    def poll(self, timeout):\n        _in, _out, _err = select.select(self.rlist, self.wlist, self.xlist, timeout)\n        results = []\n        for f in _in:\n            results.append((f, POLLER_EVENT_READ))\n        for f in _out:\n            results.append((f, POLLER_EVENT_WRITE))\n        for f in _err:\n            results.append((f, POLLER_EVENT_ERROR))\n        return results\n\n\n# here we use an use a poller interface that transparently selects the most\n# capable poller (out of either select.select or select.poll).  this was added\n# by zhangyafeikimi when he discovered that if the fds created internally by sh\n# numbered > 1024, select.select failed (a limitation of select.select).  this\n# can happen if your script opens a lot of files\nPoller: Union[Type[SelectPoller], Type[PollPoller]] = SelectPoller\nif HAS_POLL and not FORCE_USE_SELECT:\n    Poller = PollPoller\n\n\nclass ForkException(Exception):\n    def __init__(self, orig_exc):\n        msg = f\"\"\"\n\nOriginal exception:\n===================\n\n{textwrap.indent(orig_exc, \"    \")}\n\"\"\"\n        Exception.__init__(self, msg)\n\n\nclass ErrorReturnCodeMeta(type):\n    \"\"\"a metaclass which provides the ability for an ErrorReturnCode (or\n    derived) instance, imported from one sh module, to be considered the\n    subclass of ErrorReturnCode from another module.  this is mostly necessary\n    in the tests, where we do assertRaises, but the ErrorReturnCode that the\n    program we're testing throws may not be the same class that we pass to\n    assertRaises\n    \"\"\"\n\n    def __subclasscheck__(self, o):\n        other_bases = {b.__name__ for b in o.__bases__}\n        return self.__name__ in other_bases or o.__name__ == self.__name__\n\n\nclass ErrorReturnCode(Exception):\n    __metaclass__ = ErrorReturnCodeMeta\n\n    \"\"\" base class for all exceptions as a result of a command's exit status\n    being deemed an error.  this base class is dynamically subclassed into\n    derived classes with the format: ErrorReturnCode_NNN where NNN is the exit\n    code number.  the reason for this is it reduces boiler plate code when\n    testing error return codes:\n\n        try:\n            some_cmd()\n        except ErrorReturnCode_12:\n            print(\"couldn't do X\")\n\n    vs:\n        try:\n            some_cmd()\n        except ErrorReturnCode as e:\n            if e.exit_code == 12:\n                print(\"couldn't do X\")\n\n    it's not much of a savings, but i believe it makes the code easier to read \"\"\"\n\n    truncate_cap = 750\n\n    def __reduce__(self):\n        return self.__class__, (self.full_cmd, self.stdout, self.stderr, self.truncate)\n\n    def __init__(self, full_cmd, stdout, stderr, truncate=True):\n        self.exit_code = self.exit_code  # makes pylint happy\n        self.full_cmd = full_cmd\n        self.stdout = stdout\n        self.stderr = stderr\n        self.truncate = truncate\n\n        exc_stdout = self.stdout\n        if truncate:\n            exc_stdout = exc_stdout[: self.truncate_cap]\n            out_delta = len(self.stdout) - len(exc_stdout)\n            if out_delta:\n                exc_stdout += (f\"... ({out_delta} more, please see e.stdout)\").encode()\n\n        exc_stderr = self.stderr\n        if truncate:\n            exc_stderr = exc_stderr[: self.truncate_cap]\n            err_delta = len(self.stderr) - len(exc_stderr)\n            if err_delta:\n                exc_stderr += (f\"... ({err_delta} more, please see e.stderr)\").encode()\n\n        msg = (\n            f\"\\n\\n  RAN: {self.full_cmd}\"\n            f\"\\n\\n  STDOUT:\\n{exc_stdout.decode(DEFAULT_ENCODING, 'replace')}\"\n            f\"\\n\\n  STDERR:\\n{exc_stderr.decode(DEFAULT_ENCODING, 'replace')}\"\n        )\n\n        super().__init__(msg)\n\n\nclass SignalException(ErrorReturnCode):\n    pass\n\n\nclass TimeoutException(Exception):\n    \"\"\"the exception thrown when a command is killed because a specified\n    timeout (via _timeout or .wait(timeout)) was hit\"\"\"\n\n    def __init__(self, exit_code, full_cmd):\n        self.exit_code = exit_code\n        self.full_cmd = full_cmd\n        super(Exception, self).__init__()\n\n\nSIGNALS_THAT_SHOULD_THROW_EXCEPTION = {\n    signal.SIGABRT,\n    signal.SIGBUS,\n    signal.SIGFPE,\n    signal.SIGILL,\n    signal.SIGINT,\n    signal.SIGKILL,\n    signal.SIGPIPE,\n    signal.SIGQUIT,\n    signal.SIGSEGV,\n    signal.SIGTERM,\n    signal.SIGSYS,\n}\n\n\n# we subclass AttributeError because:\n# https://github.com/ipython/ipython/issues/2577\n# https://github.com/amoffat/sh/issues/97#issuecomment-10610629\nclass CommandNotFound(AttributeError):\n    pass\n\n\nrc_exc_regex = re.compile(r\"(ErrorReturnCode|SignalException)_((\\d+)|SIG[a-zA-Z]+)\")\nrc_exc_cache: Dict[str, Type[ErrorReturnCode]] = {}\n\nSIGNAL_MAPPING = {\n    v: k for k, v in signal.__dict__.items() if re.match(r\"SIG[a-zA-Z]+\", k)\n}\n\n\ndef get_exc_from_name(name):\n    \"\"\"takes an exception name, like:\n\n        ErrorReturnCode_1\n        SignalException_9\n        SignalException_SIGHUP\n\n    and returns the corresponding exception.  this is primarily used for\n    importing exceptions from sh into user code, for instance, to capture those\n    exceptions\"\"\"\n\n    exc = None\n    try:\n        return rc_exc_cache[name]\n    except KeyError:\n        m = rc_exc_regex.match(name)\n        if m:\n            base = m.group(1)\n            rc_or_sig_name = m.group(2)\n\n            if base == \"SignalException\":\n                try:\n                    rc = -int(rc_or_sig_name)\n                except ValueError:\n                    rc = -getattr(signal, rc_or_sig_name)\n            else:\n                rc = int(rc_or_sig_name)\n\n            exc = get_rc_exc(rc)\n    return exc\n\n\ndef get_rc_exc(rc):\n    \"\"\"takes a exit code or negative signal number and produces an exception\n    that corresponds to that return code.  positive return codes yield\n    ErrorReturnCode exception, negative return codes yield SignalException\n\n    we also cache the generated exception so that only one signal of that type\n    exists, preserving identity\"\"\"\n\n    try:\n        return rc_exc_cache[rc]\n    except KeyError:\n        pass\n\n    if rc >= 0:\n        name = f\"ErrorReturnCode_{rc}\"\n        base = ErrorReturnCode\n    else:\n        name = f\"SignalException_{SIGNAL_MAPPING[abs(rc)]}\"\n        base = SignalException\n\n    exc = ErrorReturnCodeMeta(name, (base,), {\"exit_code\": rc})\n    rc_exc_cache[rc] = exc\n    return exc\n\n\n# we monkey patch glob.  i'm normally generally against monkey patching, but i\n# decided to do this really un-intrusive patch because we need a way to detect\n# if a list that we pass into an sh command was generated from glob.  the reason\n# being that glob returns an empty list if a pattern is not found, and so\n# commands will treat the empty list as no arguments, which can be a problem,\n# ie:\n#\n#   ls(glob(\"*.ojfawe\"))\n#\n# ^ will show the contents of your home directory, because it's essentially\n# running ls([]) which, as a process, is just \"ls\".\n#\n# so we subclass list and monkey patch the glob function.  nobody should be the\n# wiser, but we'll have results that we can make some determinations on\n_old_glob = glob_module.glob\n\n\nclass GlobResults(list):\n    def __init__(self, path, results):\n        self.path = path\n        list.__init__(self, results)\n\n\ndef glob(path, *args, **kwargs):\n    expanded = GlobResults(path, _old_glob(path, *args, **kwargs))\n    return expanded\n\n\nglob_module.glob = glob  # type: ignore\n\n\ndef canonicalize(path):\n    return os.path.abspath(os.path.expanduser(path))\n\n\ndef _which(program, paths=None):\n    \"\"\"takes a program name or full path, plus an optional collection of search\n    paths, and returns the full path of the requested executable.  if paths is\n    specified, it is the entire list of search paths, and the PATH env is not\n    used at all.  otherwise, PATH env is used to look for the program\"\"\"\n\n    def is_exe(file_path):\n        return (\n            os.path.exists(file_path)\n            and os.access(file_path, os.X_OK)\n            and os.path.isfile(os.path.realpath(file_path))\n        )\n\n    found_path = None\n    fpath, fname = os.path.split(program)\n\n    # if there's a path component, then we've specified a path to the program,\n    # and we should just test if that program is executable.  if it is, return\n    if fpath:\n        program = canonicalize(program)\n        if is_exe(program):\n            found_path = program\n\n    # otherwise, we've just passed in the program name, and we need to search\n    # the paths to find where it actually lives\n    else:\n        paths_to_search = []\n\n        if isinstance(paths, (tuple, list)):\n            paths_to_search.extend(paths)\n        else:\n            env_paths = os.environ.get(\"PATH\", \"\").split(os.pathsep)\n            paths_to_search.extend(env_paths)\n\n        for path in paths_to_search:\n            exe_file = os.path.join(canonicalize(path), program)\n            if is_exe(exe_file):\n                found_path = exe_file\n                break\n\n    return found_path\n\n\ndef resolve_command_path(program):\n    path = _which(program)\n    if not path:\n        # our actual command might have a dash in it, but we can't call\n        # that from python (we have to use underscores), so we'll check\n        # if a dash version of our underscore command exists and use that\n        # if it does\n        if \"_\" in program:\n            path = _which(program.replace(\"_\", \"-\"))\n        if not path:\n            return None\n    return path\n\n\ndef resolve_command(name, command_cls, baked_args=None):\n    path = resolve_command_path(name)\n    cmd = None\n    if path:\n        cmd = command_cls(path)\n        if baked_args:\n            cmd = cmd.bake(**baked_args)\n    return cmd\n\n\nclass Logger:\n    \"\"\"provides a memory-inexpensive logger.  a gotcha about python's builtin\n    logger is that logger objects are never garbage collected.  if you create a\n    thousand loggers with unique names, they'll sit there in memory until your\n    script is done.  with sh, it's easy to create loggers with unique names if\n    we want our loggers to include our command arguments.  for example, these\n    are all unique loggers:\n\n            ls -l\n            ls -l /tmp\n            ls /tmp\n\n    so instead of creating unique loggers, and without sacrificing logging\n    output, we use this class, which maintains as part of its state, the logging\n    \"context\", which will be the very unique name.  this allows us to get a\n    logger with a very general name, eg: \"command\", and have a unique name\n    appended to it via the context, eg: \"ls -l /tmp\" \"\"\"\n\n    def __init__(self, name, context=None):\n        self.name = name\n        self.log = logging.getLogger(f\"{SH_LOGGER_NAME}.{name}\")\n        self.context = self.sanitize_context(context)\n\n    def _format_msg(self, msg, *a):\n        if self.context:\n            msg = f\"{self.context}: {msg}\"\n        return msg % a\n\n    @staticmethod\n    def sanitize_context(context):\n        if context:\n            context = context.replace(\"%\", \"%%\")\n        return context or \"\"\n\n    def get_child(self, name, context):\n        new_name = self.name + \".\" + name\n        new_context = self.context + \".\" + context\n        return Logger(new_name, new_context)\n\n    def info(self, msg, *a):\n        self.log.info(self._format_msg(msg, *a))\n\n    def debug(self, msg, *a):\n        self.log.debug(self._format_msg(msg, *a))\n\n    def error(self, msg, *a):\n        self.log.error(self._format_msg(msg, *a))\n\n    def exception(self, msg, *a):\n        self.log.exception(self._format_msg(msg, *a))\n\n\ndef default_logger_str(cmd, call_args, pid=None):\n    if pid:\n        s = f\"<Command {cmd!r}, pid {pid}>\"\n    else:\n        s = f\"<Command {cmd!r}>\"\n    return s\n\n\nclass RunningCommand:\n    \"\"\"this represents an executing Command object.  it is returned as the\n    result of __call__() being executed on a Command instance.  this creates a\n    reference to a OProc instance, which is a low-level wrapper around the\n    process that was exec'd\n\n    this is the class that gets manipulated the most by user code, and so it\n    implements various convenience methods and logical mechanisms for the\n    underlying process.  for example, if a user tries to access a\n    backgrounded-process's stdout/err, the RunningCommand object is smart enough\n    to know to wait() on the process to finish first.  and when the process\n    finishes, RunningCommand is smart enough to translate exit codes to\n    exceptions.\"\"\"\n\n    # these are attributes that we allow to pass through to OProc\n    _OProc_attr_allowlist = {\n        \"signal\",\n        \"terminate\",\n        \"kill\",\n        \"kill_group\",\n        \"signal_group\",\n        \"pid\",\n        \"sid\",\n        \"pgid\",\n        \"ctty\",\n        \"input_thread_exc\",\n        \"output_thread_exc\",\n        \"bg_thread_exc\",\n    }\n\n    def __init__(self, cmd, call_args, stdin, stdout, stderr):\n        # self.ran is used for auditing what actually ran.  for example, in\n        # exceptions, or if you just want to know what was ran after the\n        # command ran\n        self.ran = \" \".join([shlex_quote(str(arg)) for arg in cmd])\n\n        self.call_args = call_args\n        self.cmd = cmd\n\n        self.process = None\n        self._waited_until_completion = False\n        should_wait = True\n        spawn_process = True\n\n        # if we're using an async for loop on this object, we need to put the underlying\n        # iterable in no-block mode. however, we will only know if we're using an async\n        # for loop after this object is constructed. so we'll set it to False now, but\n        # then later set it to True if we need it\n        self._force_noblock_iter = False\n\n        # this event is used when we want to `await` a RunningCommand. see how it gets\n        # used in self.__await__\n        try:\n            asyncio.get_running_loop()\n        except RuntimeError:\n            self.aio_output_complete = None\n        else:\n            self.aio_output_complete = asyncio.Event()\n\n        # this is used to track if we've already raised StopIteration, and if we\n        # have, raise it immediately again if the user tries to call next() on\n        # us.  https://github.com/amoffat/sh/issues/273\n        self._stopped_iteration = False\n\n        # with contexts shouldn't run at all yet, they prepend\n        # to every command in the context\n        if call_args[\"with\"]:\n            spawn_process = False\n            get_prepend_stack().append(self)\n\n        if call_args[\"piped\"] or call_args[\"iter\"] or call_args[\"iter_noblock\"]:\n            should_wait = False\n\n        if call_args[\"async\"]:\n            should_wait = False\n\n        # we're running in the background, return self and let us lazily\n        # evaluate\n        if call_args[\"bg\"]:\n            should_wait = False\n\n        # redirection\n        if call_args[\"err_to_out\"]:\n            stderr = OProc.STDOUT\n\n        done_callback = call_args[\"done\"]\n        if done_callback:\n            call_args[\"done\"] = partial(done_callback, self)\n\n        # set up which stream should write to the pipe\n        # TODO, make pipe None by default and limit the size of the Queue\n        # in oproc.OProc\n        pipe = OProc.STDOUT\n        if call_args[\"iter\"] == \"out\" or call_args[\"iter\"] is True:\n            pipe = OProc.STDOUT\n        elif call_args[\"iter\"] == \"err\":\n            pipe = OProc.STDERR\n\n        if call_args[\"iter_noblock\"] == \"out\" or call_args[\"iter_noblock\"] is True:\n            pipe = OProc.STDOUT\n        elif call_args[\"iter_noblock\"] == \"err\":\n            pipe = OProc.STDERR\n\n        # there's currently only one case where we wouldn't spawn a child\n        # process, and that's if we're using a with-context with our command\n        self._spawned_and_waited = False\n        if spawn_process:\n            log_str_factory = call_args[\"log_msg\"] or default_logger_str\n            logger_str = log_str_factory(self.ran, call_args)\n            self.log = Logger(\"command\", logger_str)\n\n            self.log.debug(\"starting process\")\n\n            if should_wait:\n                self._spawned_and_waited = True\n\n            # this lock is needed because of a race condition where a background\n            # thread, created in the OProc constructor, may try to access\n            # self.process, but it has not been assigned yet\n            process_assign_lock = threading.Lock()\n            with process_assign_lock:\n                self.process = OProc(\n                    self,\n                    self.log,\n                    cmd,\n                    stdin,\n                    stdout,\n                    stderr,\n                    self.call_args,\n                    pipe,\n                    process_assign_lock,\n                )\n\n            logger_str = log_str_factory(self.ran, call_args, self.process.pid)\n            self.log.context = self.log.sanitize_context(logger_str)\n            self.log.info(\"process started\")\n\n            if should_wait:\n                self.wait()\n\n    def wait(self, timeout=None):\n        \"\"\"waits for the running command to finish.  this is called on all\n        running commands, eventually, except for ones that run in the background\n\n        if timeout is a number, it is the number of seconds to wait for the process to\n        resolve. otherwise block on wait.\n\n        this function can raise a TimeoutException, either because of a `_timeout` on\n        the command itself as it was\n        launched, or because of a timeout passed into this method.\n        \"\"\"\n        if not self._waited_until_completion:\n            # if we've been given a timeout, we need to poll is_alive()\n            if timeout is not None:\n                waited_for = 0\n                sleep_amt = 0.1\n                alive = False\n                exit_code = None\n                if timeout < 0:\n                    raise RuntimeError(\"timeout cannot be negative\")\n\n                # while we still have time to wait, run this loop\n                # notice that alive and exit_code are only defined in this loop, but\n                # the loop is also guaranteed to run, defining them, given the\n                # constraints that timeout is non-negative\n                while waited_for <= timeout:\n                    alive, exit_code = self.process.is_alive()\n\n                    # if we're alive, we need to wait some more, but let's sleep\n                    # before we poll again\n                    if alive:\n                        time.sleep(sleep_amt)\n                        waited_for += sleep_amt\n\n                    # but if we're not alive, we're done waiting\n                    else:\n                        break\n\n                # if we've made it this far, and we're still alive, then it means we\n                # timed out waiting\n                if alive:\n                    raise TimeoutException(None, self.ran)\n\n                # if we didn't time out, we fall through and let the rest of the code\n                # handle exit_code. notice that we set _waited_until_completion here,\n                # only if we didn't time out. this allows us to re-wait again on\n                # timeout, if we catch the TimeoutException in the parent frame\n                self._waited_until_completion = True\n\n            else:\n                exit_code = self.process.wait()\n                self._waited_until_completion = True\n\n            if self.process.timed_out:\n                # if we timed out, our exit code represents a signal, which is\n                # negative, so let's make it positive to store in our\n                # TimeoutException\n                raise TimeoutException(-exit_code, self.ran)\n\n            else:\n                self.handle_command_exit_code(exit_code)\n\n                # if an iterable command is using an instance of OProc for its stdin,\n                # wait on it.  the process is probably set to \"piped\", which means it\n                # won't be waited on, which means exceptions won't propagate up to the\n                # main thread.  this allows them to bubble up\n                if self.process._stdin_process:\n                    self.process._stdin_process.command.wait()\n\n            self.log.debug(\"process completed\")\n        return self\n\n    def is_alive(self):\n        \"\"\"returns whether or not we're still alive. this call has side-effects on\n        OProc\"\"\"\n        return self.process.is_alive()[0]\n\n    def handle_command_exit_code(self, code):\n        \"\"\"here we determine if we had an exception, or an error code that we\n        weren't expecting to see.  if we did, we create and raise an exception\n        \"\"\"\n        ca = self.call_args\n        exc_class = get_exc_exit_code_would_raise(code, ca[\"ok_code\"], ca[\"piped\"])\n        if exc_class:\n            exc = exc_class(\n                self.ran, self.process.stdout, self.process.stderr, ca[\"truncate_exc\"]\n            )\n            raise exc\n\n    @property\n    def stdout(self):\n        self.wait()\n        return self.process.stdout\n\n    @property\n    def stderr(self):\n        self.wait()\n        return self.process.stderr\n\n    @property\n    def exit_code(self):\n        self.wait()\n        return self.process.exit_code\n\n    def __len__(self):\n        return len(str(self))\n\n    def __enter__(self):\n        \"\"\"we don't actually do anything here because anything that should have\n        been done would have been done in the Command.__call__ call.\n        essentially all that has to happen is the command be pushed on the\n        prepend stack.\"\"\"\n        pass\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        \"\"\"allow us to iterate over the output of our command\"\"\"\n\n        if self._stopped_iteration:\n            raise StopIteration()\n\n        pq = self.process._pipe_queue\n\n        # the idea with this is, if we're using regular `_iter` (non-asyncio), then we\n        # want to have blocking be True when we read from the pipe queue, so our cpu\n        # doesn't spin too fast. however, if we *are* using asyncio (an async for loop),\n        # then we want non-blocking pipe queue reads, because we'll do an asyncio.sleep,\n        # in the coroutine that is doing the iteration, this way coroutines have better\n        # yielding (see queue_connector in __aiter__).\n        block_pq_read = not self._force_noblock_iter\n\n        # we do this because if get blocks, we can't catch a KeyboardInterrupt\n        # so the slight timeout allows for that.\n        while True:\n            try:\n                chunk = pq.get(block_pq_read, self.call_args[\"iter_poll_time\"])\n            except Empty:\n                if self.call_args[\"iter_noblock\"] or self._force_noblock_iter:\n                    return errno.EWOULDBLOCK\n            else:\n                if chunk is None:\n                    self.wait()\n                    self._stopped_iteration = True\n                    raise StopIteration()\n                try:\n                    return chunk.decode(\n                        self.call_args[\"encoding\"], self.call_args[\"decode_errors\"]\n                    )\n                except UnicodeDecodeError:\n                    return chunk\n\n    def __await__(self):\n        async def wait_for_completion():\n            await self.aio_output_complete.wait()\n            if self.call_args[\"return_cmd\"]:\n                # We know the command has completed already,\n                # but need to catch exceptions\n                self.wait()\n                return self\n            else:\n                return str(self)\n\n        return wait_for_completion().__await__()\n\n    def __aiter__(self):\n        # maxsize is critical to making sure our queue_connector function below yields\n        # when it awaits _aio_queue.put(chunk). if we didn't have a maxsize, our loop\n        # would happily iterate through `chunk in self` and put onto the queue without\n        # any blocking, and therefore no yielding, which would prevent other coroutines\n        # from running.\n        self._aio_queue = AQueue(maxsize=1)\n        self._force_noblock_iter = True\n\n        # the sole purpose of this coroutine is to connect our pipe_queue (which is\n        # being populated by a thread) to an asyncio-friendly queue. then, in __anext__,\n        # we can iterate over that asyncio queue.\n        async def queue_connector():\n            try:\n                # this will spin as fast as possible if there's no data to read,\n                # thanks to self._force_noblock_iter. so we sleep below.\n                for chunk in self:\n                    if chunk == errno.EWOULDBLOCK:\n                        # let us have better coroutine yielding.\n                        await asyncio.sleep(0.01)\n                    else:\n                        await self._aio_queue.put(chunk)\n            finally:\n                await self._aio_queue.put(None)\n\n        task = asyncio.create_task(queue_connector())\n        self._aio_task = task\n        return self\n\n    async def __anext__(self):\n        chunk = await self._aio_queue.get()\n        if chunk is not None:\n            return chunk\n        else:\n            exc = self._aio_task.exception()\n            if exc is not None:\n                raise exc\n            raise StopAsyncIteration\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.call_args[\"with\"] and get_prepend_stack():\n            get_prepend_stack().pop()\n\n    def __str__(self):\n        if self.process and self.stdout:\n            return self.stdout.decode(\n                self.call_args[\"encoding\"], self.call_args[\"decode_errors\"]\n            )\n        return \"\"\n\n    def __eq__(self, other):\n        return id(self) == id(other)\n\n    def __contains__(self, item):\n        return item in str(self)\n\n    def __getattr__(self, p):\n        # let these three attributes pass through to the OProc object\n        if p in self._OProc_attr_allowlist:\n            if self.process:\n                return getattr(self.process, p)\n            else:\n                raise AttributeError\n\n        # see if strings have what we're looking for\n        if p in _unicode_methods:\n            return getattr(str(self), p)\n\n        raise AttributeError\n\n    def __repr__(self):\n        try:\n            return str(self)\n        except UnicodeDecodeError:\n            if self.process:\n                if self.stdout:\n                    return repr(self.stdout)\n            return repr(\"\")\n\n    def __long__(self):\n        return int(str(self).strip())\n\n    def __float__(self):\n        return float(str(self).strip())\n\n    def __int__(self):\n        return int(str(self).strip())\n\n\ndef output_redirect_is_filename(out):\n    return isinstance(out, str) or hasattr(out, \"__fspath__\")\n\n\ndef get_prepend_stack():\n    tl = Command.thread_local\n    if not hasattr(tl, \"_prepend_stack\"):\n        tl._prepend_stack = []\n    return tl._prepend_stack\n\n\ndef special_kwarg_validator(passed_kwargs, merged_kwargs, invalid_list):\n    s1 = set(passed_kwargs.keys())\n    invalid_args = []\n\n    for elem in invalid_list:\n        if callable(elem):\n            fn = elem\n            ret = fn(passed_kwargs, merged_kwargs)\n            invalid_args.extend(ret)\n\n        else:\n            elem, error_msg = elem\n\n            if s1.issuperset(elem):\n                invalid_args.append((elem, error_msg))\n\n    return invalid_args\n\n\ndef get_fileno(ob):\n    # in py2, this will return None.  in py3, it will return an method that\n    # raises when called\n    fileno_meth = getattr(ob, \"fileno\", None)\n\n    fileno = None\n    if fileno_meth:\n        # py3 StringIO objects will report a fileno, but calling it will raise\n        # an exception\n        try:\n            fileno = fileno_meth()\n        except UnsupportedOperation:\n            pass\n    elif isinstance(ob, (int,)) and ob >= 0:\n        fileno = ob\n\n    return fileno\n\n\ndef ob_is_fd_based(ob):\n    return get_fileno(ob) is not None\n\n\ndef ob_is_tty(ob):\n    \"\"\"checks if an object (like a file-like object) is a tty.\"\"\"\n    fileno = get_fileno(ob)\n    is_tty = False\n    if fileno is not None:\n        is_tty = os.isatty(fileno)\n    return is_tty\n\n\ndef ob_is_pipe(ob):\n    fileno = get_fileno(ob)\n    is_pipe = False\n    if fileno:\n        fd_stat = os.fstat(fileno)\n        is_pipe = stat.S_ISFIFO(fd_stat.st_mode)\n    return is_pipe\n\n\ndef output_iterator_validator(passed_kwargs, merged_kwargs):\n    invalid = []\n    if passed_kwargs.get(\"no_out\") and passed_kwargs.get(\"iter\") in (True, \"out\"):\n        error = \"You cannot iterate over output if there is no output\"\n        invalid.append(((\"no_out\", \"iter\"), error))\n    return invalid\n\n\ndef tty_in_validator(passed_kwargs, merged_kwargs):\n    # here we'll validate that people aren't randomly shotgun-debugging different tty\n    # options and hoping that they'll work, without understanding what they do\n    pairs = ((\"tty_in\", \"in\"), (\"tty_out\", \"out\"))\n    invalid = []\n    for tty_type, std in pairs:\n        if tty_type in passed_kwargs and ob_is_tty(passed_kwargs.get(std, None)):\n            error = (\n                f\"`_{std}` is a TTY already, so so it doesn't make sense to set up a\"\n                f\" TTY with `_{tty_type}`\"\n            )\n            invalid.append(((tty_type, std), error))\n\n    # if unify_ttys is set, then both tty_in and tty_out must both be True\n    if merged_kwargs[\"unify_ttys\"] and not (\n        merged_kwargs[\"tty_in\"] and merged_kwargs[\"tty_out\"]\n    ):\n        invalid.append(\n            (\n                (\"unify_ttys\", \"tty_in\", \"tty_out\"),\n                \"`_tty_in` and `_tty_out` must both be True if `_unify_ttys` is True\",\n            )\n        )\n\n    return invalid\n\n\ndef fg_validator(passed_kwargs, merged_kwargs):\n    \"\"\"fg is not valid with basically every other option\"\"\"\n\n    invalid = []\n    msg = \"\"\"\\\n_fg is invalid with nearly every other option, see warning and workaround here:\n\n    https://sh.readthedocs.io/en/latest/sections/special_arguments.html#fg\"\"\"\n    allowlist = {\"env\", \"fg\", \"cwd\", \"ok_code\"}\n    offending = set(passed_kwargs.keys()) - allowlist\n\n    if \"fg\" in passed_kwargs and passed_kwargs[\"fg\"] and offending:\n        invalid.append((\"fg\", msg))\n    return invalid\n\n\ndef bufsize_validator(passed_kwargs, merged_kwargs):\n    \"\"\"a validator to prevent a user from saying that they want custom\n    buffering when they're using an in/out object that will be os.dup'ed to the\n    process, and has its own buffering.  an example is a pipe or a tty.  it\n    doesn't make sense to tell them to have a custom buffering, since the os\n    controls this.\"\"\"\n    invalid = []\n\n    in_ob = passed_kwargs.get(\"in\", None)\n    out_ob = passed_kwargs.get(\"out\", None)\n\n    in_buf = passed_kwargs.get(\"in_bufsize\", None)\n    out_buf = passed_kwargs.get(\"out_bufsize\", None)\n\n    in_no_buf = ob_is_fd_based(in_ob)\n    out_no_buf = ob_is_fd_based(out_ob)\n\n    err = \"Can't specify an {target} bufsize if the {target} target is a pipe or TTY\"\n\n    if in_no_buf and in_buf is not None:\n        invalid.append(((\"in\", \"in_bufsize\"), err.format(target=\"in\")))\n\n    if out_no_buf and out_buf is not None:\n        invalid.append(((\"out\", \"out_bufsize\"), err.format(target=\"out\")))\n\n    return invalid\n\n\ndef env_validator(passed_kwargs, merged_kwargs):\n    \"\"\"a validator to check that env is a dictionary and that all environment variable\n    keys and values are strings. Otherwise, we would exit with a confusing exit code\n    255.\"\"\"\n    invalid = []\n\n    env = passed_kwargs.get(\"env\", None)\n    if env is None:\n        return invalid\n\n    if not isinstance(env, Mapping):\n        invalid.append((\"env\", f\"env must be dict-like. Got {env!r}\"))\n        return invalid\n\n    for k, v in passed_kwargs[\"env\"].items():\n        if not isinstance(k, str):\n            invalid.append((\"env\", f\"env key {k!r} must be a str\"))\n        if not isinstance(v, str):\n            invalid.append((\"env\", f\"value {v!r} of env key {k!r} must be a str\"))\n\n    return invalid\n\n\nclass Command:\n    \"\"\"represents an un-run system program, like \"ls\" or \"cd\".  because it\n    represents the program itself (and not a running instance of it), it should\n    hold very little state.  in fact, the only state it does hold is baked\n    arguments.\n\n    when a Command object is called, the result that is returned is a\n    RunningCommand object, which represents the Command put into an execution\n    state.\"\"\"\n\n    thread_local = threading.local()\n    RunningCommandCls = RunningCommand\n\n    _call_args: Dict[str, Any] = {\n        \"fg\": False,  # run command in foreground\n        # run a command in the background.  commands run in the background\n        # ignore SIGHUP and do not automatically exit when the parent process\n        # ends\n        \"bg\": False,\n        # automatically report exceptions for background commands\n        \"bg_exc\": True,\n        \"with\": False,  # prepend the command to every command after it\n        \"in\": None,\n        \"out\": None,  # redirect STDOUT\n        \"err\": None,  # redirect STDERR\n        \"err_to_out\": None,  # redirect STDERR to STDOUT\n        # stdin buffer size\n        # 1 for line, 0 for unbuffered, any other number for that amount\n        \"in_bufsize\": 0,\n        # stdout buffer size, same values as above\n        \"out_bufsize\": 1,\n        \"err_bufsize\": 1,\n        # this is how big the output buffers will be for stdout and stderr.\n        # this is essentially how much output they will store from the process.\n        # we use a deque, so if it overflows past this amount, the first items\n        # get pushed off as each new item gets added.\n        #\n        # NOTICE\n        # this is not a *BYTE* size, this is a *CHUNK* size...meaning, that if\n        # you're buffering out/err at 1024 bytes, the internal buffer size will\n        # be \"internal_bufsize\" CHUNKS of 1024 bytes\n        \"internal_bufsize\": 3 * 1024**2,\n        \"env\": None,\n        \"piped\": None,\n        \"iter\": None,\n        \"iter_noblock\": None,\n        # the amount of time to sleep between polling for the iter output queue\n        \"iter_poll_time\": 0.1,\n        \"ok_code\": 0,\n        \"cwd\": None,\n        # the separator delimiting between a long-argument's name and its value\n        # setting this to None will cause name and value to be two separate\n        # arguments, like for short options\n        # for example, --arg=derp, '=' is the long_sep\n        \"long_sep\": \"=\",\n        # the prefix used for long arguments\n        \"long_prefix\": \"--\",\n        # this is for programs that expect their input to be from a terminal.\n        # ssh is one of those programs\n        \"tty_in\": False,\n        \"tty_out\": True,\n        \"unify_ttys\": False,\n        \"encoding\": DEFAULT_ENCODING,\n        \"decode_errors\": \"strict\",\n        # how long the process should run before it is auto-killed\n        \"timeout\": None,\n        \"timeout_signal\": signal.SIGKILL,\n        # TODO write some docs on \"long-running processes\"\n        # these control whether or not stdout/err will get aggregated together\n        # as the process runs.  this has memory usage implications, so sometimes\n        # with long-running processes with a lot of data, it makes sense to\n        # set these to true\n        \"no_out\": False,\n        \"no_err\": False,\n        \"no_pipe\": False,\n        # if any redirection is used for stdout or stderr, internal buffering\n        # of that data is not stored.  this forces it to be stored, as if\n        # the output is being T'd to both the redirected destination and our\n        # internal buffers\n        \"tee\": None,\n        # will be called when a process terminates regardless of exception\n        \"done\": None,\n        # a tuple (rows, columns) of the desired size of both the stdout and\n        # stdin ttys, if ttys are being used\n        \"tty_size\": (24, 80),\n        # whether or not our exceptions should be truncated\n        \"truncate_exc\": True,\n        # a function to call after the child forks but before the process execs\n        \"preexec_fn\": None,\n        # UID to set after forking. Requires root privileges. Not supported on\n        # Windows.\n        \"uid\": None,\n        # put the forked process in its own process session?\n        \"new_session\": False,\n        # put the forked process in its own process group?\n        \"new_group\": False,\n        # pre-process args passed into __call__.  only really useful when used\n        # in .bake()\n        \"arg_preprocess\": None,\n        # a callable that produces a log message from an argument tuple of the\n        # command and the args\n        \"log_msg\": None,\n        # whether or not to close all inherited fds. typically, this should be True,\n        # as inheriting fds can be a security vulnerability\n        \"close_fds\": True,\n        # a allowlist of the integer fds to pass through to the child process. setting\n        # this forces close_fds to be True\n        \"pass_fds\": set(),\n        # return an instance of RunningCommand always. if this isn't True, then\n        # sometimes we may return just a plain unicode string\n        \"return_cmd\": False,\n        \"async\": False,\n    }\n\n    # this is a collection of validators to make sure the special kwargs make\n    # sense\n    _kwarg_validators = (\n        ((\"err\", \"err_to_out\"), \"Stderr is already being redirected\"),\n        ((\"piped\", \"iter\"), \"You cannot iterate when this command is being piped\"),\n        (\n            (\"piped\", \"no_pipe\"),\n            \"Using a pipe doesn't make sense if you've disabled the pipe\",\n        ),\n        output_iterator_validator,\n        ((\"close_fds\", \"pass_fds\"), \"Passing `pass_fds` forces `close_fds` to be True\"),\n        tty_in_validator,\n        bufsize_validator,\n        env_validator,\n        fg_validator,\n    )\n\n    def __init__(self, path, search_paths=None):\n        found = _which(path, search_paths)\n\n        self._path = \"\"\n\n        # is the command baked (aka, partially applied)?\n        self._partial = False\n        self._partial_baked_args = []\n        self._partial_call_args = {}\n\n        # bugfix for functools.wraps.  issue #121\n        self.__name__ = str(self)\n\n        if not found:\n            raise CommandNotFound(path)\n\n        # the reason why we set the values early in the constructor, and again\n        # here, is for people who have tools that inspect the stack on\n        # exception.  if CommandNotFound is raised, we need self._path and the\n        # other attributes to be set correctly, so repr() works when they're\n        # inspecting the stack.  issue #304\n        self._path = found\n        self.__name__ = str(self)\n\n    def __getattribute__(self, name):\n        # convenience\n        get_attr = partial(object.__getattribute__, self)\n        val = None\n\n        if name.startswith(\"_\"):\n            val = get_attr(name)\n\n        elif name == \"bake\":\n            val = get_attr(\"bake\")\n\n        # here we have a way of getting past shadowed subcommands.  for example,\n        # if \"git bake\" was a thing, we wouldn't be able to do `git.bake()`\n        # because `.bake()` is already a method.  so we allow `git.bake_()`\n        elif name.endswith(\"_\"):\n            name = name[:-1]\n\n        if val is None:\n            val = get_attr(\"bake\")(name)\n\n        return val\n\n    @classmethod\n    def _extract_call_args(cls, kwargs):\n        \"\"\"takes kwargs that were passed to a command's __call__ and extracts\n        out the special keyword arguments, we return a tuple of special keyword\n        args, and kwargs that will go to the exec'ed command\"\"\"\n\n        kwargs = kwargs.copy()\n        call_args = {}\n        for parg, default in cls._call_args.items():\n            key = \"_\" + parg\n\n            if key in kwargs:\n                call_args[parg] = kwargs[key]\n                del kwargs[key]\n\n        merged_args = cls._call_args.copy()\n        merged_args.update(call_args)\n        invalid_kwargs = special_kwarg_validator(\n            call_args, merged_args, cls._kwarg_validators\n        )\n\n        if invalid_kwargs:\n            exc_msg = []\n            for kwarg, error_msg in invalid_kwargs:\n                exc_msg.append(f\"  {kwarg!r}: {error_msg}\")\n            exc_msg = \"\\n\".join(exc_msg)\n            raise TypeError(f\"Invalid special arguments:\\n\\n{exc_msg}\\n\")\n\n        return call_args, kwargs\n\n    def bake(self, *args, **kwargs):\n        \"\"\"returns a new Command object after baking(freezing) the given\n        command arguments which are used automatically when its exec'ed\n\n        special keyword arguments can be temporary baked and additionally be\n        overridden in __call__ or in subsequent bakes (basically setting\n        defaults)\"\"\"\n\n        # construct the base Command\n        fn = type(self)(self._path)\n        fn._partial = True\n\n        call_args, kwargs = self._extract_call_args(kwargs)\n\n        fn._partial_call_args.update(self._partial_call_args)\n        fn._partial_call_args.update(call_args)\n        fn._partial_baked_args.extend(self._partial_baked_args)\n        sep = call_args.get(\"long_sep\", self._call_args[\"long_sep\"])\n        prefix = call_args.get(\"long_prefix\", self._call_args[\"long_prefix\"])\n        fn._partial_baked_args.extend(compile_args(args, kwargs, sep, prefix))\n        return fn\n\n    def __str__(self):\n        baked_args = \" \".join(self._partial_baked_args)\n        if baked_args:\n            baked_args = \" \" + baked_args\n        return self._path + baked_args\n\n    def __eq__(self, other):\n        return str(self) == str(other)\n\n    def __repr__(self):\n        return f\"<Command {str(self)!r}>\"\n\n    def __enter__(self):\n        self(_with=True)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        get_prepend_stack().pop()\n\n    def __call__(self, *args, **kwargs):\n        kwargs = kwargs.copy()\n        args = list(args)\n\n        # this will hold our final command, including arguments, that will be\n        # exec'ed\n        cmd = []\n\n        # this will hold a complete mapping of all our special keyword arguments\n        # and their values\n        call_args = self.__class__._call_args.copy()\n\n        # aggregate any 'with' contexts\n        for prepend in get_prepend_stack():\n            pcall_args = prepend.call_args.copy()\n            # don't pass the 'with' call arg\n            pcall_args.pop(\"with\", None)\n\n            call_args.update(pcall_args)\n            # we do not prepend commands used as a 'with' context as they will\n            # be prepended to any nested commands\n            if not kwargs.get(\"_with\", False):\n                cmd.extend(prepend.cmd)\n\n        cmd.append(self._path)\n\n        # do we have an argument pre-processor?  if so, run it.  we need to do\n        # this early, so that args, kwargs are accurate\n        preprocessor = self._partial_call_args.get(\"arg_preprocess\", None)\n        if preprocessor:\n            args, kwargs = preprocessor(args, kwargs)\n\n        # here we extract the special kwargs and override any\n        # special kwargs from the possibly baked command\n        extracted_call_args, kwargs = self._extract_call_args(kwargs)\n\n        call_args.update(self._partial_call_args)\n        call_args.update(extracted_call_args)\n\n        # handle a None.  this is added back only to not break the api in the\n        # 1.* version.  TODO remove this in 2.0, as \"ok_code\", if specified,\n        # should always be a definitive value or list of values, and None is\n        # ambiguous\n        if call_args[\"ok_code\"] is None:\n            call_args[\"ok_code\"] = 0\n\n        if not getattr(call_args[\"ok_code\"], \"__iter__\", None):\n            call_args[\"ok_code\"] = [call_args[\"ok_code\"]]\n\n        # determine what our real STDIN is. is it something explicitly passed into\n        # _in?\n        stdin = call_args[\"in\"]\n\n        # now that we have our stdin, let's figure out how we should handle it\n        if isinstance(stdin, RunningCommand):\n            if stdin.call_args[\"piped\"]:\n                stdin = stdin.process\n            else:\n                stdin = stdin.process._pipe_queue\n\n        processed_args = compile_args(\n            args, kwargs, call_args[\"long_sep\"], call_args[\"long_prefix\"]\n        )\n\n        # makes sure our arguments are broken up correctly\n        split_args = self._partial_baked_args + processed_args\n\n        final_args = split_args\n\n        cmd.extend(final_args)\n\n        # if we're running in foreground mode, we need to completely bypass\n        # launching a RunningCommand and OProc and just do a spawn\n        if call_args[\"fg\"]:\n            cwd = call_args[\"cwd\"] or os.getcwd()\n            with pushd(cwd):\n                if call_args[\"env\"] is None:\n                    exit_code = os.spawnv(os.P_WAIT, cmd[0], cmd)\n                else:\n                    exit_code = os.spawnve(os.P_WAIT, cmd[0], cmd, call_args[\"env\"])\n\n            exc_class = get_exc_exit_code_would_raise(\n                exit_code, call_args[\"ok_code\"], call_args[\"piped\"]\n            )\n            if exc_class:\n                ran = \" \".join(cmd)\n                exc = exc_class(ran, b\"\", b\"\", call_args[\"truncate_exc\"])\n                raise exc\n            return None\n\n        # stdout redirection\n        stdout = call_args[\"out\"]\n        if output_redirect_is_filename(stdout):\n            stdout = open(str(stdout), \"wb\")\n\n        # stderr redirection\n        stderr = call_args[\"err\"]\n        if output_redirect_is_filename(stderr):\n            stderr = open(str(stderr), \"wb\")\n\n        rc = self.__class__.RunningCommandCls(cmd, call_args, stdin, stdout, stderr)\n        if rc._spawned_and_waited and not call_args[\"return_cmd\"]:\n            return str(rc)\n        else:\n            return rc\n\n\ndef compile_args(a, kwargs, sep, prefix):\n    \"\"\"takes args and kwargs, as they were passed into the command instance\n    being executed with __call__, and compose them into a flat list that\n    will eventually be fed into exec.  example:\n\n    with this call:\n\n        sh.ls(\"-l\", \"/tmp\", color=\"never\")\n\n    this function receives\n\n        args = ['-l', '/tmp']\n        kwargs = {'color': 'never'}\n\n    and produces\n\n        ['-l', '/tmp', '--color=geneticnever']\n\n    \"\"\"\n    processed_args = []\n\n    # aggregate positional args\n    for arg in a:\n        if isinstance(arg, (list, tuple)):\n            if isinstance(arg, GlobResults) and not arg:\n                arg = [arg.path]\n\n            for sub_arg in arg:\n                processed_args.append(sub_arg)\n        elif isinstance(arg, dict):\n            processed_args += _aggregate_keywords(arg, sep, prefix, raw=True)\n\n        # see https://github.com/amoffat/sh/issues/522\n        elif arg is None or arg is False:\n            pass\n        else:\n            processed_args.append(str(arg))\n\n    # aggregate the keyword arguments\n    processed_args += _aggregate_keywords(kwargs, sep, prefix)\n\n    return processed_args\n\n\ndef _aggregate_keywords(keywords, sep, prefix, raw=False):\n    \"\"\"take our keyword arguments, and a separator, and compose the list of\n    flat long (and short) arguments.  example\n\n        {'color': 'never', 't': True, 'something': True} with sep '='\n\n    becomes\n\n        ['--color=never', '-t', '--something']\n\n    the `raw` argument indicates whether or not we should leave the argument\n    name alone, or whether we should replace \"_\" with \"-\".  if we pass in a\n    dictionary, like this:\n\n        sh.command({\"some_option\": 12})\n\n    then `raw` gets set to True, because we want to leave the key as-is, to\n    produce:\n\n        ['--some_option=12']\n\n    but if we just use a command's kwargs, `raw` is False, which means this:\n\n        sh.command(some_option=12)\n\n    becomes:\n\n        ['--some-option=12']\n\n    essentially, using kwargs is a convenience, but it lacks the ability to\n    put a '-' in the name, so we do the replacement of '_' to '-' for you.\n    but when you really don't want that to happen, you should use a\n    dictionary instead with the exact names you want\n    \"\"\"\n\n    processed = []\n\n    for k, maybe_list_of_v in keywords.items():\n        # turn our value(s) into a list of values so that we can process them\n        # all individually under the same key\n        list_of_v = [maybe_list_of_v]\n        if isinstance(maybe_list_of_v, (list, tuple)):\n            list_of_v = maybe_list_of_v\n\n        for v in list_of_v:\n            # we're passing a short arg as a kwarg, example:\n            # cut(d=\"\\t\")\n            if len(k) == 1:\n                if v is not False:\n                    processed.append(\"-\" + k)\n                    if v is not True:\n                        processed.append(str(v))\n\n            # we're doing a long arg\n            else:\n                if not raw:\n                    k = k.replace(\"_\", \"-\")\n\n                # if it's true, it has no value, just pass the name\n                if v is True:\n                    processed.append(prefix + k)\n                # if it's false, skip passing it\n                elif v is False:\n                    pass\n\n                # we may need to break the argument up into multiple arguments\n                elif sep is None or sep == \" \":\n                    processed.append(prefix + k)\n                    processed.append(str(v))\n                # otherwise just join it together into a single argument\n                else:\n                    arg = f\"{prefix}{k}{sep}{v}\"\n                    processed.append(arg)\n\n    return processed\n\n\ndef _start_daemon_thread(fn, name, exc_queue, *a):\n    def wrap(*rgs, **kwargs):\n        try:\n            fn(*rgs, **kwargs)\n        except Exception as e:\n            exc_queue.put(e)\n            raise\n\n    thread = threading.Thread(target=wrap, name=name, args=a)\n    thread.daemon = True\n    thread.start()\n    return thread\n\n\ndef setwinsize(fd, rows_cols):\n    \"\"\"set the terminal size of a tty file descriptor.  borrowed logic\n    from pexpect.py\"\"\"\n    rows, cols = rows_cols\n    winsize = getattr(termios, \"TIOCSWINSZ\", -2146929561)\n\n    s = struct.pack(\"HHHH\", rows, cols, 0, 0)\n    fcntl.ioctl(fd, winsize, s)\n\n\ndef construct_streamreader_callback(process, handler):\n    \"\"\"here we're constructing a closure for our streamreader callback.  this\n    is used in the case that we pass a callback into _out or _err, meaning we\n    want to our callback to handle each bit of output\n\n    we construct the closure based on how many arguments it takes.  the reason\n    for this is to make it as easy as possible for people to use, without\n    limiting them.  a new user will assume the callback takes 1 argument (the\n    data).  as they get more advanced, they may want to terminate the process,\n    or pass some stdin back, and will realize that they can pass a callback of\n    more args\"\"\"\n\n    # implied arg refers to the \"self\" that methods will pass in.  we need to\n    # account for this implied arg when figuring out what function the user\n    # passed in based on number of args\n    implied_arg = 0\n\n    partial_args = 0\n    handler_to_inspect = handler\n\n    if isinstance(handler, partial):\n        partial_args = len(handler.args)\n        handler_to_inspect = handler.func\n\n    if inspect.ismethod(handler_to_inspect):\n        implied_arg = 1\n        num_args = get_num_args(handler_to_inspect)\n\n    else:\n        if inspect.isfunction(handler_to_inspect):\n            num_args = get_num_args(handler_to_inspect)\n\n        # is an object instance with __call__ method\n        else:\n            implied_arg = 1\n            num_args = get_num_args(handler_to_inspect.__call__)\n\n    net_args = num_args - implied_arg - partial_args\n\n    handler_args = ()\n\n    # just the chunk\n    if net_args == 1:\n        handler_args = ()\n\n    # chunk, stdin\n    if net_args == 2:\n        handler_args = (process.stdin,)\n\n    # chunk, stdin, process\n    elif net_args == 3:\n        # notice we're only storing a weakref, to prevent cyclic references\n        # (where the process holds a streamreader, and a streamreader holds a\n        # handler-closure with a reference to the process\n        handler_args = (process.stdin, weakref.ref(process))\n\n    def fn(chunk):\n        # this is pretty ugly, but we're evaluating the process at call-time,\n        # because it's a weakref\n        a = handler_args\n        if len(a) == 2:\n            a = (handler_args[0], handler_args[1]())\n        return handler(chunk, *a)\n\n    return fn\n\n\ndef get_exc_exit_code_would_raise(exit_code, ok_codes, sigpipe_ok):\n    exc = None\n    success = exit_code in ok_codes\n    bad_sig = -exit_code in SIGNALS_THAT_SHOULD_THROW_EXCEPTION\n\n    # if this is a piped command, SIGPIPE must be ignored by us and not raise an\n    # exception, since it's perfectly normal for the consumer of a process's\n    # pipe to terminate early\n    if sigpipe_ok and -exit_code == signal.SIGPIPE:\n        bad_sig = False\n        success = True\n\n    if not success or bad_sig:\n        exc = get_rc_exc(exit_code)\n    return exc\n\n\ndef handle_process_exit_code(exit_code):\n    \"\"\"this should only ever be called once for each child process\"\"\"\n    # if we exited from a signal, let our exit code reflect that\n    if os.WIFSIGNALED(exit_code):\n        exit_code = -os.WTERMSIG(exit_code)\n    # otherwise just give us a normal exit code\n    elif os.WIFEXITED(exit_code):\n        exit_code = os.WEXITSTATUS(exit_code)\n    else:\n        raise RuntimeError(\"Unknown child exit status!\")\n\n    return exit_code\n\n\ndef no_interrupt(syscall, *args, **kwargs):\n    \"\"\"a helper for making system calls immune to EINTR\"\"\"\n    ret = None\n\n    while True:\n        try:\n            ret = syscall(*args, **kwargs)\n        except OSError as e:\n            if e.errno == errno.EINTR:\n                continue\n            else:\n                raise\n        else:\n            break\n\n    return ret\n\n\nclass OProc:\n    \"\"\"this class is instantiated by RunningCommand for a command to be exec'd.\n    it handles all the nasty business involved with correctly setting up the\n    input/output to the child process.  it gets its name for subprocess.Popen\n    (process open) but we're calling ours OProc (open process)\"\"\"\n\n    _default_window_size = (24, 80)\n\n    # used in redirecting\n    STDOUT = -1\n    STDERR = -2\n\n    def __init__(\n        self,\n        command,\n        parent_log,\n        cmd,\n        stdin,\n        stdout,\n        stderr,\n        call_args,\n        pipe,\n        process_assign_lock,\n    ):\n        \"\"\"\n        cmd is the full list of arguments that will be exec'd.  it includes the program\n        name and all its arguments.\n\n        stdin, stdout, stderr are what the child will use for standard input/output/err.\n\n        call_args is a mapping of all the special keyword arguments to apply to the\n        child process.\n        \"\"\"\n        self.command = command\n        self.call_args = call_args\n\n        # convenience\n        ca = self.call_args\n\n        if ca[\"uid\"] is not None:\n            if os.getuid() != 0:\n                raise RuntimeError(\"UID setting requires root privileges\")\n\n            target_uid = ca[\"uid\"]\n\n            pwrec = pwd.getpwuid(ca[\"uid\"])\n            target_gid = pwrec.pw_gid\n        else:\n            target_uid, target_gid = None, None\n\n        # I had issues with getting 'Input/Output error reading stdin' from dd,\n        # until I set _tty_out=False\n        if ca[\"piped\"]:\n            ca[\"tty_out\"] = False\n\n        self._stdin_process = None\n\n        # if the objects that we are passing to the OProc happen to be a\n        # file-like object that is a tty, for example `sys.stdin`, then, later\n        # on in this constructor, we're going to skip out on setting up pipes\n        # and pseudoterminals for those endpoints\n        stdin_is_fd_based = ob_is_fd_based(stdin)\n        stdout_is_fd_based = ob_is_fd_based(stdout)\n        stderr_is_fd_based = ob_is_fd_based(stderr)\n\n        if isinstance(ca[\"tee\"], (str, bool, int)) or ca[\"tee\"] is None:\n            tee = {ca[\"tee\"]}\n        else:\n            tee = set(ca[\"tee\"])\n        tee_out = TEE_STDOUT.intersection(tee)\n        tee_err = TEE_STDERR.intersection(tee)\n\n        single_tty = ca[\"tty_in\"] and ca[\"tty_out\"] and ca[\"unify_ttys\"]\n\n        # this logic is a little convoluted, but basically this top-level\n        # if/else is for consolidating input and output TTYs into a single\n        # TTY.  this is the only way some secure programs like ssh will\n        # output correctly (is if stdout and stdin are both the same TTY)\n        if single_tty:\n            # master_fd, slave_fd = pty.openpty()\n            #\n            # Anything that is written on the master end is provided to the process on\n            # the slave end as though it was\n            # input typed on a terminal. -\"man 7 pty\"\n            #\n            # later, in the child process, we're going to do this, so keep it in mind:\n            #\n            #    os.dup2(self._stdin_child_fd, 0)\n            #    os.dup2(self._stdout_child_fd, 1)\n            #    os.dup2(self._stderr_child_fd, 2)\n            self._stdin_parent_fd, self._stdin_child_fd = pty.openpty()\n\n            # this makes our parent fds behave like a terminal. it says that the very\n            # same fd that we \"type\" to (for stdin) is the same one that we see output\n            # printed to (for stdout)\n            self._stdout_parent_fd = os.dup(self._stdin_parent_fd)\n\n            # this line is what makes stdout and stdin attached to the same pty. in\n            # other words the process will write to the same underlying fd as stdout\n            # as it uses to read from for stdin. this makes programs like ssh happy\n            self._stdout_child_fd = os.dup(self._stdin_child_fd)\n\n            self._stderr_parent_fd = os.dup(self._stdin_parent_fd)\n            self._stderr_child_fd = os.dup(self._stdin_child_fd)\n\n        # do not consolidate stdin and stdout.  this is the most common use-\n        # case\n        else:\n            # this check here is because we may be doing piping and so our stdin\n            # might be an instance of OProc\n            if isinstance(stdin, OProc) and stdin.call_args[\"piped\"]:\n                self._stdin_child_fd = stdin._pipe_fd\n                self._stdin_parent_fd = None\n                self._stdin_process = stdin\n\n            elif stdin_is_fd_based:\n                self._stdin_child_fd = os.dup(get_fileno(stdin))\n                self._stdin_parent_fd = None\n\n            elif ca[\"tty_in\"]:\n                self._stdin_parent_fd, self._stdin_child_fd = pty.openpty()\n\n            # tty_in=False is the default\n            else:\n                self._stdin_child_fd, self._stdin_parent_fd = os.pipe()\n\n            if stdout_is_fd_based and not tee_out:\n                self._stdout_child_fd = os.dup(get_fileno(stdout))\n                self._stdout_parent_fd = None\n\n            # tty_out=True is the default\n            elif ca[\"tty_out\"]:\n                self._stdout_parent_fd, self._stdout_child_fd = pty.openpty()\n\n            else:\n                self._stdout_parent_fd, self._stdout_child_fd = os.pipe()\n\n            # unless STDERR is going to STDOUT, it ALWAYS needs to be a pipe,\n            # and never a PTY.  the reason for this is not totally clear to me,\n            # but it has to do with the fact that if STDERR isn't set as the\n            # CTTY (because STDOUT is), the STDERR buffer won't always flush\n            # by the time the process exits, and the data will be lost.\n            # i've only seen this on OSX.\n            if stderr is OProc.STDOUT:\n                # if stderr is going to stdout, but stdout is a tty or a pipe,\n                # we should not specify a read_fd, because stdout is os.dup'ed\n                # directly to the stdout fd (no pipe), and so stderr won't have\n                # a slave end of a pipe either to dup\n                if stdout_is_fd_based and not tee_out:\n                    self._stderr_parent_fd = None\n                else:\n                    self._stderr_parent_fd = os.dup(self._stdout_parent_fd)\n                self._stderr_child_fd = os.dup(self._stdout_child_fd)\n\n            elif stderr_is_fd_based and not tee_err:\n                self._stderr_child_fd = os.dup(get_fileno(stderr))\n                self._stderr_parent_fd = None\n\n            else:\n                self._stderr_parent_fd, self._stderr_child_fd = os.pipe()\n\n        piped = ca[\"piped\"]\n        self._pipe_fd = None\n        if piped:\n            fd_to_use = self._stdout_parent_fd\n            if piped == \"err\":\n                fd_to_use = self._stderr_parent_fd\n            self._pipe_fd = os.dup(fd_to_use)\n\n        new_session = ca[\"new_session\"]\n        new_group = ca[\"new_group\"]\n        needs_ctty = ca[\"tty_in\"]\n\n        # if we need a controlling terminal, we have to be in a new session where we\n        # are the session leader, otherwise we would need to take over the existing\n        # process session, and we can't do that(?)\n        if needs_ctty:\n            new_session = True\n\n        self.ctty = None\n        if needs_ctty:\n            self.ctty = os.ttyname(self._stdin_child_fd)\n\n        gc_enabled = gc.isenabled()\n        if gc_enabled:\n            gc.disable()\n\n        # for synchronizing\n        session_pipe_read, session_pipe_write = os.pipe()\n        exc_pipe_read, exc_pipe_write = os.pipe()\n\n        # this pipe is for synchronizing with the child that the parent has\n        # closed its in/out/err fds.  this is a bug on OSX (but not linux),\n        # where we can lose output sometimes, due to a race, if we do\n        # os.close(self._stdout_child_fd) in the parent after the child starts\n        # writing.\n        if IS_MACOS:\n            close_pipe_read, close_pipe_write = os.pipe()\n        else:\n            close_pipe_read, close_pipe_write = None, None\n\n        # session id, group id, process id\n        self.sid = None\n        self.pgid = None\n        self.pid = os.fork()\n\n        # child\n        if self.pid == 0:  # pragma: no cover\n            if IS_MACOS:\n                os.read(close_pipe_read, 1)\n                os.close(close_pipe_read)\n                os.close(close_pipe_write)\n\n            # this is critical\n            # our exc_pipe_write must have CLOEXEC enabled. the reason for this is\n            # tricky: if our child (the block we're in now), has an exception, we need\n            # to be able to write to exc_pipe_write, so that when the parent does\n            # os.read(exc_pipe_read), it gets our traceback.  however,\n            # os.read(exc_pipe_read) in the parent blocks, so if our child *doesn't*\n            # have an exception, and doesn't close the writing end, it hangs forever.\n            # not good!  but obviously the child can't close the writing end until it\n            # knows it's not going to have an exception, which is impossible to know\n            # because but what if os.execv has an exception?  so the answer is CLOEXEC,\n            # so that the writing end of the pipe gets closed upon successful exec,\n            # and the parent reading the read end won't block (close breaks the block).\n            flags = fcntl.fcntl(exc_pipe_write, fcntl.F_GETFD)\n            flags |= fcntl.FD_CLOEXEC\n            fcntl.fcntl(exc_pipe_write, fcntl.F_SETFD, flags)\n\n            try:\n                # ignoring SIGHUP lets us persist even after the controlling terminal\n                # is closed\n                if ca[\"bg\"] is True:\n                    signal.signal(signal.SIGHUP, signal.SIG_IGN)\n\n                # python ignores SIGPIPE by default.  we must make sure to put\n                # this behavior back to the default for spawned processes,\n                # otherwise SIGPIPE won't kill piped processes, which is what we\n                # need, so that we can check the error code of the killed\n                # process to see that SIGPIPE killed it\n                signal.signal(signal.SIGPIPE, signal.SIG_DFL)\n\n                # put our forked process in a new session?  this will relinquish\n                # any control of our inherited CTTY and also make our parent\n                # process init\n                if new_session:\n                    os.setsid()\n                elif new_group:\n                    os.setpgid(0, 0)\n\n                sid = os.getsid(0)\n                pgid = os.getpgid(0)\n                payload = (f\"{sid},{pgid}\").encode(DEFAULT_ENCODING)\n                os.write(session_pipe_write, payload)\n\n                if ca[\"tty_out\"] and not stdout_is_fd_based and not single_tty:\n                    # set raw mode, so there isn't any weird translation of\n                    # newlines to \\r\\n and other oddities.  we're not outputting\n                    # to a terminal anyways\n                    #\n                    # we HAVE to do this here, and not in the parent process,\n                    # because we have to guarantee that this is set before the\n                    # child process is run, and we can't do it twice.\n                    tty.setraw(self._stdout_child_fd)\n\n                # if the parent-side fd for stdin exists, close it.  the case\n                # where it may not exist is if we're using piping\n                if self._stdin_parent_fd:\n                    os.close(self._stdin_parent_fd)\n\n                if self._stdout_parent_fd:\n                    os.close(self._stdout_parent_fd)\n\n                if self._stderr_parent_fd:\n                    os.close(self._stderr_parent_fd)\n\n                os.close(session_pipe_read)\n                os.close(exc_pipe_read)\n\n                cwd = ca[\"cwd\"]\n                if cwd:\n                    os.chdir(cwd)\n\n                os.dup2(self._stdin_child_fd, 0)\n                os.dup2(self._stdout_child_fd, 1)\n                os.dup2(self._stderr_child_fd, 2)\n\n                # set our controlling terminal, but only if we're using a tty\n                # for stdin.  it doesn't make sense to have a ctty otherwise\n                if needs_ctty:\n                    tmp_fd = os.open(os.ttyname(0), os.O_RDWR)\n                    os.close(tmp_fd)\n\n                if ca[\"tty_out\"] and not stdout_is_fd_based:\n                    setwinsize(1, ca[\"tty_size\"])\n\n                if ca[\"uid\"] is not None:\n                    os.setgid(target_gid)\n                    os.setuid(target_uid)\n\n                preexec_fn = ca[\"preexec_fn\"]\n                if callable(preexec_fn):\n                    preexec_fn()\n\n                close_fds = ca[\"close_fds\"]\n                if ca[\"pass_fds\"]:\n                    close_fds = True\n\n                if close_fds:\n                    pass_fds = {0, 1, 2, exc_pipe_write}\n                    pass_fds.update(ca[\"pass_fds\"])\n\n                    # don't inherit file descriptors\n                    try:\n                        inherited_fds = os.listdir(\"/dev/fd\")\n                    except OSError:\n                        # Some systems don't have /dev/fd. Raises OSError in\n                        # Python2, FileNotFoundError on Python3. The latter doesn't\n                        # exist on Python2, but inherits from IOError, which does.\n                        inherited_fds = os.listdir(\"/proc/self/fd\")\n                    inherited_fds = {int(fd) for fd in inherited_fds} - pass_fds\n                    for fd in inherited_fds:\n                        try:\n                            os.close(fd)\n                        except OSError:\n                            pass\n\n                # python=3.6, locale=c will fail test_unicode_arg if we don't\n                # explicitly encode to bytes via our desired encoding. this does\n                # not seem to be the case in other python versions, even if locale=c\n                bytes_cmd = [c.encode(ca[\"encoding\"]) for c in cmd]\n\n                # actually execute the process\n                if ca[\"env\"] is None:\n                    os.execv(bytes_cmd[0], bytes_cmd)\n                else:\n                    os.execve(bytes_cmd[0], bytes_cmd, ca[\"env\"])\n\n            # we must ensure that we carefully exit the child process on\n            # exception, otherwise the parent process code will be executed\n            # twice on exception https://github.com/amoffat/sh/issues/202\n            #\n            # if your parent process experiences an exit code 255, it is most\n            # likely that an exception occurred between the fork of the child\n            # and the exec.  this should be reported.\n            except Exception:  # noqa: E722\n                # some helpful debugging\n                tb = traceback.format_exc().encode(\"utf8\", \"ignore\")\n\n                try:\n                    os.write(exc_pipe_write, tb)\n\n                except Exception as e:\n                    # dump to stderr if we cannot save it to exc_pipe_write\n                    sys.stderr.write(f\"\\nFATAL SH ERROR: {e}\\n\")\n\n                finally:\n                    os._exit(255)\n\n        # parent\n        else:\n            if gc_enabled:\n                gc.enable()\n\n            os.close(self._stdin_child_fd)\n            os.close(self._stdout_child_fd)\n            os.close(self._stderr_child_fd)\n\n            # tell our child process that we've closed our write_fds, so it is\n            # ok to proceed towards exec.  see the comment where this pipe is\n            # opened, for why this is necessary\n            if IS_MACOS:\n                os.close(close_pipe_read)\n                os.write(close_pipe_write, str(1).encode(DEFAULT_ENCODING))\n                os.close(close_pipe_write)\n\n            os.close(exc_pipe_write)\n            fork_exc = os.read(exc_pipe_read, 1024**2)\n            os.close(exc_pipe_read)\n            if fork_exc:\n                fork_exc = fork_exc.decode(DEFAULT_ENCODING)\n                raise ForkException(fork_exc)\n\n            os.close(session_pipe_write)\n            sid, pgid = (\n                os.read(session_pipe_read, 1024).decode(DEFAULT_ENCODING).split(\",\")\n            )\n            os.close(session_pipe_read)\n            self.sid = int(sid)\n            self.pgid = int(pgid)\n\n            # used to determine what exception to raise.  if our process was\n            # killed via a timeout counter, we'll raise something different than\n            # a SIGKILL exception\n            self.timed_out = False\n\n            self.started = time.time()\n            self.cmd = cmd\n\n            # exit code should only be manipulated from within self._wait_lock\n            # to prevent race conditions\n            self.exit_code = None\n\n            self.stdin = stdin\n\n            # this accounts for when _out is a callable that is passed stdin.  in that\n            # case, if stdin is unspecified, we must set it to a queue, so callbacks can\n            # put things on it\n            if callable(ca[\"out\"]) and self.stdin is None:\n                self.stdin = Queue()\n\n            # _pipe_queue is used internally to hand off stdout from one process\n            # to another.  by default, all stdout from a process gets dumped\n            # into this pipe queue, to be consumed in real time (hence the\n            # thread-safe Queue), or at a potentially later time\n            self._pipe_queue = Queue()\n\n            # this is used to prevent a race condition when we're waiting for\n            # a process to end, and the OProc's internal threads are also checking\n            # for the processes's end\n            self._wait_lock = threading.Lock()\n\n            # these are for aggregating the stdout and stderr.  we use a deque\n            # because we don't want to overflow\n            self._stdout = deque(maxlen=ca[\"internal_bufsize\"])\n            self._stderr = deque(maxlen=ca[\"internal_bufsize\"])\n\n            if ca[\"tty_in\"] and not stdin_is_fd_based:\n                setwinsize(self._stdin_parent_fd, ca[\"tty_size\"])\n\n            self.log = parent_log.get_child(\"process\", repr(self))\n\n            self.log.debug(\"started process\")\n\n            # disable echoing, but only if it's a tty that we created ourselves\n            if ca[\"tty_in\"] and not stdin_is_fd_based:\n                attr = termios.tcgetattr(self._stdin_parent_fd)\n                attr[3] &= ~termios.ECHO\n                termios.tcsetattr(self._stdin_parent_fd, termios.TCSANOW, attr)\n\n            # this represents the connection from a Queue object (or whatever\n            # we're using to feed STDIN) to the process's STDIN fd\n            self._stdin_stream = None\n            if self._stdin_parent_fd:\n                log = self.log.get_child(\"streamwriter\", \"stdin\")\n                self._stdin_stream = StreamWriter(\n                    log,\n                    self._stdin_parent_fd,\n                    self.stdin,\n                    ca[\"in_bufsize\"],\n                    ca[\"encoding\"],\n                    ca[\"tty_in\"],\n                )\n\n            stdout_pipe = None\n            if pipe is OProc.STDOUT and not ca[\"no_pipe\"]:\n                stdout_pipe = self._pipe_queue\n\n            # this represents the connection from a process's STDOUT fd to\n            # wherever it has to go, sometimes a pipe Queue (that we will use\n            # to pipe data to other processes), and also an internal deque\n            # that we use to aggregate all the output\n            save_stdout = not ca[\"no_out\"] and (tee_out or stdout is None)\n\n            pipe_out = ca[\"piped\"] in (\"out\", True)\n            pipe_err = ca[\"piped\"] in (\"err\",)\n\n            # if we're piping directly into another process's file descriptor, we\n            # bypass reading from the stdout stream altogether, because we've\n            # already hooked up this processes's stdout fd to the other\n            # processes's stdin fd\n            self._stdout_stream = None\n            if not pipe_out and self._stdout_parent_fd:\n                if callable(stdout):\n                    stdout = construct_streamreader_callback(self, stdout)\n                self._stdout_stream = StreamReader(\n                    self.log.get_child(\"streamreader\", \"stdout\"),\n                    self._stdout_parent_fd,\n                    stdout,\n                    self._stdout,\n                    ca[\"out_bufsize\"],\n                    ca[\"encoding\"],\n                    ca[\"decode_errors\"],\n                    stdout_pipe,\n                    save_data=save_stdout,\n                )\n\n            elif self._stdout_parent_fd:\n                os.close(self._stdout_parent_fd)\n\n            # if stderr is going to one place (because it's grouped with stdout,\n            # or we're dealing with a single tty), then we don't actually need a\n            # stream reader for stderr, because we've already set one up for\n            # stdout above\n            self._stderr_stream = None\n            if (\n                stderr is not OProc.STDOUT\n                and not single_tty\n                and not pipe_err\n                and self._stderr_parent_fd\n            ):\n                stderr_pipe = None\n                if pipe is OProc.STDERR and not ca[\"no_pipe\"]:\n                    stderr_pipe = self._pipe_queue\n\n                save_stderr = not ca[\"no_err\"] and (tee_err or stderr is None)\n\n                if callable(stderr):\n                    stderr = construct_streamreader_callback(self, stderr)\n\n                self._stderr_stream = StreamReader(\n                    Logger(\"streamreader\"),\n                    self._stderr_parent_fd,\n                    stderr,\n                    self._stderr,\n                    ca[\"err_bufsize\"],\n                    ca[\"encoding\"],\n                    ca[\"decode_errors\"],\n                    stderr_pipe,\n                    save_data=save_stderr,\n                )\n\n            elif self._stderr_parent_fd:\n                os.close(self._stderr_parent_fd)\n\n            def timeout_fn():\n                self.timed_out = True\n                self.signal(ca[\"timeout_signal\"])\n\n            self._timeout_event = None\n            self._timeout_timer = None\n            if ca[\"timeout\"]:\n                self._timeout_event = threading.Event()\n                self._timeout_timer = threading.Timer(\n                    ca[\"timeout\"], self._timeout_event.set\n                )\n                self._timeout_timer.start()\n\n            # this is for cases where we know that the RunningCommand that was\n            # launched was not .wait()ed on to complete.  in those unique cases,\n            # we allow the thread that processes output to report exceptions in\n            # that thread.  it's important that we only allow reporting of the\n            # exception, and nothing else (like the additional stuff that\n            # RunningCommand.wait() does), because we want the exception to be\n            # re-raised in the future, if we DO call .wait()\n            handle_exit_code = None\n            if (\n                not self.command._spawned_and_waited\n                and ca[\"bg_exc\"]\n                # we don't want background exceptions if we're doing async stuff,\n                # because we want those to bubble up.\n                and not ca[\"async\"]\n            ):\n\n                def fn(exit_code):\n                    with process_assign_lock:\n                        return self.command.handle_command_exit_code(exit_code)\n\n                handle_exit_code = fn\n\n            self._quit_threads = threading.Event()\n\n            thread_name = f\"background thread for pid {self.pid}\"\n            self._bg_thread_exc_queue = Queue(1)\n            self._background_thread = _start_daemon_thread(\n                background_thread,\n                thread_name,\n                self._bg_thread_exc_queue,\n                timeout_fn,\n                self._timeout_event,\n                handle_exit_code,\n                self.is_alive,\n                self._quit_threads,\n            )\n\n            # start the main io threads. stdin thread is not needed if we are\n            # connecting from another process's stdout pipe\n            self._input_thread = None\n            self._input_thread_exc_queue = Queue(1)\n            if self._stdin_stream:\n                close_before_term = not needs_ctty\n                thread_name = f\"STDIN thread for pid {self.pid}\"\n                self._input_thread = _start_daemon_thread(\n                    input_thread,\n                    thread_name,\n                    self._input_thread_exc_queue,\n                    self.log,\n                    self._stdin_stream,\n                    self.is_alive,\n                    self._quit_threads,\n                    close_before_term,\n                )\n\n            # this event is for cases where the subprocess that we launch\n            # launches its OWN subprocess and os.dup's the stdout/stderr fds to that\n            # new subprocess.  in that case, stdout and stderr will never EOF,\n            # so our output_thread will never finish and will hang.  this event\n            # prevents that hanging\n            self._stop_output_event = threading.Event()\n\n            # we need to set up a callback to fire when our `output_thread` is about\n            # to exit. this callback will set an asyncio Event, so that coroutiens can\n            # be notified that our output is finished.\n            # if the `sh` command was launched from within a thread (so we're not in\n            # the main thread), then we won't have an event loop.\n            try:\n                loop = asyncio.get_running_loop()\n            except RuntimeError:\n\n                def output_complete():\n                    pass\n\n            else:\n\n                def output_complete():\n                    loop.call_soon_threadsafe(self.command.aio_output_complete.set)\n\n            self._output_thread_exc_queue = Queue(1)\n            thread_name = f\"STDOUT/ERR thread for pid {self.pid}\"\n            self._output_thread = _start_daemon_thread(\n                output_thread,\n                thread_name,\n                self._output_thread_exc_queue,\n                self.log,\n                self._stdout_stream,\n                self._stderr_stream,\n                self._timeout_event,\n                self.is_alive,\n                self._quit_threads,\n                self._stop_output_event,\n                output_complete,\n            )\n\n    def __repr__(self):\n        return f\"<Process {self.pid} {self.cmd[:500]!r}>\"\n\n    def change_in_bufsize(self, buf):\n        self._stdin_stream.stream_bufferer.change_buffering(buf)\n\n    def change_out_bufsize(self, buf):\n        self._stdout_stream.stream_bufferer.change_buffering(buf)\n\n    def change_err_bufsize(self, buf):\n        self._stderr_stream.stream_bufferer.change_buffering(buf)\n\n    @property\n    def stdout(self):\n        return \"\".encode(self.call_args[\"encoding\"]).join(self._stdout)\n\n    @property\n    def stderr(self):\n        return \"\".encode(self.call_args[\"encoding\"]).join(self._stderr)\n\n    def get_pgid(self):\n        \"\"\"return the CURRENT group id of the process. this differs from\n        self.pgid in that this reflects the current state of the process, where\n        self.pgid is the group id at launch\"\"\"\n        return os.getpgid(self.pid)\n\n    def get_sid(self):\n        \"\"\"return the CURRENT session id of the process. this differs from\n        self.sid in that this reflects the current state of the process, where\n        self.sid is the session id at launch\"\"\"\n        return os.getsid(self.pid)\n\n    def signal_group(self, sig):\n        self.log.debug(\"sending signal %d to group\", sig)\n        os.killpg(self.get_pgid(), sig)\n\n    def signal(self, sig):\n        self.log.debug(\"sending signal %d\", sig)\n        os.kill(self.pid, sig)\n\n    def kill_group(self):\n        self.log.debug(\"killing group\")\n        self.signal_group(signal.SIGKILL)\n\n    def kill(self):\n        self.log.debug(\"killing\")\n        self.signal(signal.SIGKILL)\n\n    def terminate(self):\n        self.log.debug(\"terminating\")\n        self.signal(signal.SIGTERM)\n\n    def is_alive(self):\n        \"\"\"polls if our child process has completed, without blocking.  this\n        method has side-effects, such as setting our exit_code, if we happen to\n        see our child exit while this is running\"\"\"\n\n        if self.exit_code is not None:\n            return False, self.exit_code\n\n        # what we're doing here essentially is making sure that the main thread\n        # (or another thread), isn't calling .wait() on the process.  because\n        # .wait() calls os.waitpid(self.pid, 0), we can't do an os.waitpid\n        # here...because if we did, and the process exited while in this\n        # thread, the main thread's os.waitpid(self.pid, 0) would raise OSError\n        # (because the process ended in another thread).\n        #\n        # so essentially what we're doing is, using this lock, checking if\n        # we're calling .wait(), and if we are, let .wait() get the exit code\n        # and handle the status, otherwise let us do it.\n        #\n        # Using a small timeout provides backpressure against code that spams\n        # calls to .is_alive() which may block the main thread from acquiring\n        # the lock otherwise.\n        acquired = self._wait_lock.acquire(timeout=0.00001)\n        if not acquired:\n            if self.exit_code is not None:\n                return False, self.exit_code\n            return True, self.exit_code\n\n        witnessed_end = False\n        try:\n            # WNOHANG is just that...we're calling waitpid without hanging...\n            # essentially polling the process.  the return result is (0, 0) if\n            # there's no process status, so we check that pid == self.pid below\n            # in order to determine how to proceed\n            pid, exit_code = no_interrupt(os.waitpid, self.pid, os.WNOHANG)\n            if pid == self.pid:\n                self.exit_code = handle_process_exit_code(exit_code)\n                witnessed_end = True\n\n                return False, self.exit_code\n\n        # no child process\n        except OSError:\n            return False, self.exit_code\n        else:\n            return True, self.exit_code\n        finally:\n            self._wait_lock.release()\n            if witnessed_end:\n                self._process_just_ended()\n\n    def _process_just_ended(self):\n        if self._timeout_timer:\n            self._timeout_timer.cancel()\n\n        done_callback = self.call_args[\"done\"]\n        if done_callback:\n            success = self.exit_code in self.call_args[\"ok_code\"]\n            done_callback(success, self.exit_code)\n\n        # this can only be closed at the end of the process, because it might be\n        # the CTTY, and closing it prematurely will send a SIGHUP.  we also\n        # don't want to close it if there's a self._stdin_stream, because that\n        # is in charge of closing it also\n        if self._stdin_parent_fd and not self._stdin_stream:\n            os.close(self._stdin_parent_fd)\n\n    def wait(self):\n        \"\"\"waits for the process to complete, handles the exit code\"\"\"\n\n        self.log.debug(\"acquiring wait lock to wait for completion\")\n        # using the lock in a with-context blocks, which is what we want if\n        # we're running wait()\n        with self._wait_lock:\n            self.log.debug(\"got wait lock\")\n            witnessed_end = False\n\n            if self.exit_code is None:\n                self.log.debug(\"exit code not set, waiting on pid\")\n                pid, exit_code = no_interrupt(os.waitpid, self.pid, 0)  # blocks\n                self.exit_code = handle_process_exit_code(exit_code)\n                witnessed_end = True\n\n            else:\n                self.log.debug(\n                    \"exit code already set (%d), no need to wait\", self.exit_code\n                )\n        self._process_exit_cleanup(witnessed_end=witnessed_end)\n        return self.exit_code\n\n    def _process_exit_cleanup(self, witnessed_end):\n        self._quit_threads.set()\n\n        # we may not have a thread for stdin, if the pipe has been connected\n        # via _piped=\"direct\"\n        if self._input_thread:\n            self._input_thread.join()\n\n        # wait, then signal to our output thread that the child process is\n        # done, and we should have finished reading all the stdout/stderr\n        # data that we can by now\n        timer = threading.Timer(2.0, self._stop_output_event.set)\n        timer.start()\n\n        # wait for our stdout and stderr streamreaders to finish reading and\n        # aggregating the process output\n        self._output_thread.join()\n        timer.cancel()\n\n        self._background_thread.join()\n\n        if witnessed_end:\n            self._process_just_ended()\n\n\ndef input_thread(log, stdin, is_alive, quit_thread, close_before_term):\n    \"\"\"this is run in a separate thread.  it writes into our process's\n    stdin (a streamwriter) and waits the process to end AND everything that\n    can be written to be written\"\"\"\n\n    closed = False\n    alive = True\n    poller = Poller()\n    poller.register_write(stdin)\n\n    while poller and alive:\n        changed = poller.poll(1)\n        for fd, events in changed:\n            if events & (POLLER_EVENT_WRITE | POLLER_EVENT_HUP):\n                log.debug(\"%r ready for more input\", stdin)\n                done = stdin.write()\n\n                if done:\n                    poller.unregister(stdin)\n                    if close_before_term:\n                        stdin.close()\n                        closed = True\n\n        alive, _ = is_alive()\n\n    while alive:\n        quit_thread.wait(1)\n        alive, _ = is_alive()\n\n    if not closed:\n        stdin.close()\n\n\ndef event_wait(ev, timeout=None):\n    triggered = ev.wait(timeout)\n    return triggered\n\n\ndef background_thread(\n    timeout_fn, timeout_event, handle_exit_code, is_alive, quit_thread\n):\n    \"\"\"handles the timeout logic\"\"\"\n\n    # if there's a timeout event, loop\n    if timeout_event:\n        while not quit_thread.is_set():\n            timed_out = event_wait(timeout_event, 0.1)\n            if timed_out:\n                timeout_fn()\n                break\n\n    # handle_exit_code will be a function ONLY if our command was NOT waited on\n    # as part of its spawning.  in other words, it's probably a background\n    # command\n    #\n    # this reports the exit code exception in our thread.  it's purely for the\n    # user's awareness, and cannot be caught or used in any way, so it's ok to\n    # suppress this during the tests\n    if handle_exit_code and not RUNNING_TESTS:  # pragma: no cover\n        alive = True\n        exit_code = None\n        while alive:\n            quit_thread.wait(1)\n            alive, exit_code = is_alive()\n\n        handle_exit_code(exit_code)\n\n\ndef output_thread(\n    log,\n    stdout,\n    stderr,\n    timeout_event,\n    is_alive,\n    quit_thread,\n    stop_output_event,\n    output_complete,\n):\n    \"\"\"this function is run in a separate thread.  it reads from the\n    process's stdout stream (a streamreader), and waits for it to claim that\n    its done\"\"\"\n\n    poller = Poller()\n    if stdout is not None:\n        poller.register_read(stdout)\n    if stderr is not None:\n        poller.register_read(stderr)\n\n    # this is our poll loop for polling stdout or stderr that is ready to\n    # be read and processed.  if one of those streamreaders indicate that it\n    # is done altogether being read from, we remove it from our list of\n    # things to poll.  when no more things are left to poll, we leave this\n    # loop and clean up\n    while poller:\n        changed = no_interrupt(poller.poll, 0.1)\n        for f, events in changed:\n            if events & (POLLER_EVENT_READ | POLLER_EVENT_HUP):\n                log.debug(\"%r ready to be read from\", f)\n                done = f.read()\n                if done:\n                    poller.unregister(f)\n            elif events & POLLER_EVENT_ERROR:\n                # for some reason, we have to just ignore streams that have had an\n                # error.  i'm not exactly sure why, but don't remove this until we\n                # figure that out, and create a test for it\n                pass\n\n        if timeout_event and timeout_event.is_set():\n            break\n\n        if stop_output_event.is_set():\n            break\n\n    # we need to wait until the process is guaranteed dead before closing our\n    # outputs, otherwise SIGPIPE\n    alive, _ = is_alive()\n    while alive:\n        quit_thread.wait(1)\n        alive, _ = is_alive()\n\n    if stdout:\n        stdout.close()\n\n    if stderr:\n        stderr.close()\n\n    output_complete()\n\n\nclass DoneReadingForever(Exception):\n    pass\n\n\nclass NotYetReadyToRead(Exception):\n    pass\n\n\ndef determine_how_to_read_input(input_obj):\n    \"\"\"given some kind of input object, return a function that knows how to\n    read chunks of that input object.\n\n    each reader function should return a chunk and raise a DoneReadingForever\n    exception, or return None, when there's no more data to read\n\n    NOTE: the function returned does not need to care much about the requested\n    buffering type (eg, unbuffered vs newline-buffered).  the StreamBufferer\n    will take care of that.  these functions just need to return a\n    reasonably-sized chunk of data.\"\"\"\n\n    if isinstance(input_obj, Queue):\n        log_msg = \"queue\"\n        get_chunk = get_queue_chunk_reader(input_obj)\n\n    elif callable(input_obj):\n        log_msg = \"callable\"\n        get_chunk = get_callable_chunk_reader(input_obj)\n\n    # also handles stringio\n    elif hasattr(input_obj, \"read\"):\n        log_msg = \"file descriptor\"\n        get_chunk = get_file_chunk_reader(input_obj)\n\n    elif isinstance(input_obj, str):\n        log_msg = \"string\"\n        get_chunk = get_iter_string_reader(input_obj)\n\n    elif isinstance(input_obj, bytes):\n        log_msg = \"bytes\"\n        get_chunk = get_iter_string_reader(input_obj)\n\n    elif isinstance(input_obj, GeneratorType):\n        log_msg = \"generator\"\n        get_chunk = get_iter_chunk_reader(iter(input_obj))\n\n    elif input_obj is None:\n        log_msg = \"None\"\n\n        def raise_():\n            raise DoneReadingForever\n\n        get_chunk = raise_\n\n    else:\n        try:\n            it = iter(input_obj)\n        except TypeError:\n            raise Exception(\"unknown input object\")\n        else:\n            log_msg = \"general iterable\"\n            get_chunk = get_iter_chunk_reader(it)\n\n    return get_chunk, log_msg\n\n\ndef get_queue_chunk_reader(stdin):\n    def fn():\n        try:\n            chunk = stdin.get(True, 0.1)\n        except Empty:\n            raise NotYetReadyToRead\n        if chunk is None:\n            raise DoneReadingForever\n        return chunk\n\n    return fn\n\n\ndef get_callable_chunk_reader(stdin):\n    def fn():\n        try:\n            data = stdin()\n        except DoneReadingForever:\n            raise\n\n        if not data:\n            raise DoneReadingForever\n\n        return data\n\n    return fn\n\n\ndef get_iter_string_reader(stdin):\n    \"\"\"return an iterator that returns a chunk of a string every time it is\n    called.  notice that even though bufsize_type might be line buffered, we're\n    not doing any line buffering here.  that's because our StreamBufferer\n    handles all buffering.  we just need to return a reasonable-sized chunk.\"\"\"\n    bufsize = 1024\n    iter_str = (stdin[i : i + bufsize] for i in range(0, len(stdin), bufsize))\n    return get_iter_chunk_reader(iter_str)\n\n\ndef get_iter_chunk_reader(stdin):\n    def fn():\n        try:\n            chunk = stdin.__next__()\n            return chunk\n        except StopIteration:\n            raise DoneReadingForever\n\n    return fn\n\n\ndef get_file_chunk_reader(stdin):\n    bufsize = 1024\n\n    def fn():\n        # python 3.* includes a fileno on stringios, but accessing it throws an\n        # exception.  that exception is how we'll know we can't do a poll on\n        # stdin\n        is_real_file = True\n        try:\n            stdin.fileno()\n        except UnsupportedOperation:\n            is_real_file = False\n\n        # this poll is for files that may not yet be ready to read.  we test\n        # for fileno because StringIO/BytesIO cannot be used in a poll\n        if is_real_file and hasattr(stdin, \"fileno\"):\n            poller = Poller()\n            poller.register_read(stdin)\n            changed = poller.poll(0.1)\n            ready = False\n            for fd, events in changed:\n                if events & (POLLER_EVENT_READ | POLLER_EVENT_HUP):\n                    ready = True\n            if not ready:\n                raise NotYetReadyToRead\n\n        chunk = stdin.read(bufsize)\n        if not chunk:\n            raise DoneReadingForever\n        else:\n            return chunk\n\n    return fn\n\n\ndef bufsize_type_to_bufsize(bf_type):\n    \"\"\"for a given bufsize type, return the actual bufsize we will read.\n    notice that although 1 means \"newline-buffered\", we're reading a chunk size\n    of 1024.  this is because we have to read something.  we let a\n    StreamBufferer instance handle splitting our chunk on newlines\"\"\"\n\n    # newlines\n    if bf_type == 1:\n        bufsize = 1024\n    # unbuffered\n    elif bf_type == 0:\n        bufsize = 1\n    # or buffered by specific amount\n    else:\n        bufsize = bf_type\n\n    return bufsize\n\n\nclass StreamWriter:\n    \"\"\"StreamWriter reads from some input (the stdin param) and writes to a fd\n    (the stream param).  the stdin may be a Queue, a callable, something with\n    the \"read\" method, a string, or an iterable\"\"\"\n\n    def __init__(self, log, stream, stdin, bufsize_type, encoding, tty_in):\n        self.stream = stream\n        self.stdin = stdin\n\n        self.log = log\n        self.encoding = encoding\n        self.tty_in = tty_in\n\n        self.stream_bufferer = StreamBufferer(bufsize_type, self.encoding)\n        self.get_chunk, log_msg = determine_how_to_read_input(stdin)\n        self.log.debug(\"parsed stdin as a %s\", log_msg)\n\n    def fileno(self):\n        \"\"\"defining this allows us to do poll on an instance of this\n        class\"\"\"\n        return self.stream\n\n    def write(self):\n        \"\"\"attempt to get a chunk of data to write to our child process's\n        stdin, then write it.  the return value answers the questions \"are we\n        done writing forever?\" \"\"\"\n\n        # get_chunk may sometimes return bytes, and sometimes return strings\n        # because of the nature of the different types of STDIN objects we\n        # support\n        try:\n            chunk = self.get_chunk()\n            if chunk is None:\n                raise DoneReadingForever\n\n        except DoneReadingForever:\n            self.log.debug(\"done reading\")\n\n            if self.tty_in:\n                # EOF time\n                try:\n                    char = termios.tcgetattr(self.stream)[6][termios.VEOF]\n                except:  # noqa: E722\n                    char = chr(4).encode()\n\n                # normally, one EOF should be enough to signal to an program\n                # that is read()ing, to return 0 and be on your way.  however,\n                # some programs are misbehaved, like python3.1 and python3.2.\n                # they don't stop reading sometimes after read() returns 0.\n                # this can be demonstrated with the following program:\n                #\n                # import sys\n                # sys.stdout.write(sys.stdin.read())\n                #\n                # then type 'a' followed by ctrl-d 3 times.  in python\n                # 2.6,2.7,3.3,3.4,3.5,3.6, it only takes 2 ctrl-d to terminate.\n                # however, in python 3.1 and 3.2, it takes all 3.\n                #\n                # so here we send an extra EOF along, just in case.  i don't\n                # believe it can hurt anything\n                os.write(self.stream, char)\n                os.write(self.stream, char)\n\n            return True\n\n        except NotYetReadyToRead:\n            self.log.debug(\"received no data\")\n            return False\n\n        # if we're not bytes, make us bytes\n        if not isinstance(chunk, bytes):\n            chunk = chunk.encode(self.encoding)\n\n        for proc_chunk in self.stream_bufferer.process(chunk):\n            self.log.debug(\"got chunk size %d: %r\", len(proc_chunk), proc_chunk[:30])\n\n            self.log.debug(\"writing chunk to process\")\n            try:\n                os.write(self.stream, proc_chunk)\n            except OSError:\n                self.log.debug(\"OSError writing stdin chunk\")\n                return True\n\n    def close(self):\n        self.log.debug(\"closing, but flushing first\")\n        chunk = self.stream_bufferer.flush()\n        self.log.debug(\"got chunk size %d to flush: %r\", len(chunk), chunk[:30])\n        try:\n            if chunk:\n                os.write(self.stream, chunk)\n\n        except OSError:\n            pass\n\n        os.close(self.stream)\n\n\ndef determine_how_to_feed_output(handler, encoding, decode_errors):\n    if callable(handler):\n        process, finish = get_callback_chunk_consumer(handler, encoding, decode_errors)\n\n    # in py3, this is used for bytes\n    elif isinstance(handler, BytesIO):\n        process, finish = get_cstringio_chunk_consumer(handler)\n\n    # in py3, this is used for unicode\n    elif isinstance(handler, StringIO):\n        process, finish = get_stringio_chunk_consumer(handler, encoding, decode_errors)\n\n    elif hasattr(handler, \"write\"):\n        process, finish = get_file_chunk_consumer(handler, decode_errors)\n\n    else:\n        try:\n            handler = int(handler)\n        except (ValueError, TypeError):\n\n            def process(chunk):\n                return False  # noqa: E731\n\n            def finish():\n                return None  # noqa: E731\n\n        else:\n            process, finish = get_fd_chunk_consumer(handler, decode_errors)\n\n    return process, finish\n\n\ndef get_fd_chunk_consumer(handler, decode_errors):\n    handler = fdopen(handler, \"w\", closefd=False)\n    return get_file_chunk_consumer(handler, decode_errors)\n\n\ndef get_file_chunk_consumer(handler, decode_errors):\n    if getattr(handler, \"encoding\", None):\n\n        def encode(chunk):\n            return chunk.decode(handler.encoding, decode_errors)  # noqa: E731\n\n    else:\n\n        def encode(chunk):\n            return chunk  # noqa: E731\n\n    if hasattr(handler, \"flush\"):\n        flush = handler.flush\n    else:\n\n        def flush():\n            return None  # noqa: E731\n\n    def process(chunk):\n        handler.write(encode(chunk))\n        # we should flush on an fd.  chunk is already the correctly-buffered\n        # size, so we don't need the fd buffering as well\n        flush()\n        return False\n\n    def finish():\n        flush()\n\n    return process, finish\n\n\ndef get_callback_chunk_consumer(handler, encoding, decode_errors):\n    def process(chunk):\n        # try to use the encoding first, if that doesn't work, send\n        # the bytes, because it might be binary\n        try:\n            chunk = chunk.decode(encoding, decode_errors)\n        except UnicodeDecodeError:\n            pass\n        return handler(chunk)\n\n    def finish():\n        pass\n\n    return process, finish\n\n\ndef get_cstringio_chunk_consumer(handler):\n    def process(chunk):\n        handler.write(chunk)\n        return False\n\n    def finish():\n        pass\n\n    return process, finish\n\n\ndef get_stringio_chunk_consumer(handler, encoding, decode_errors):\n    def process(chunk):\n        handler.write(chunk.decode(encoding, decode_errors))\n        return False\n\n    def finish():\n        pass\n\n    return process, finish\n\n\nclass StreamReader:\n    \"\"\"reads from some output (the stream) and sends what it just read to the\n    handler.\"\"\"\n\n    def __init__(\n        self,\n        log,\n        stream,\n        handler,\n        buffer,\n        bufsize_type,\n        encoding,\n        decode_errors,\n        pipe_queue=None,\n        save_data=True,\n    ):\n        self.stream = stream\n        self.buffer = buffer\n        self.save_data = save_data\n        self.encoding = encoding\n        self.decode_errors = decode_errors\n\n        self.pipe_queue = None\n        if pipe_queue:\n            self.pipe_queue = weakref.ref(pipe_queue)\n\n        self.log = log\n\n        self.stream_bufferer = StreamBufferer(\n            bufsize_type, self.encoding, self.decode_errors\n        )\n        self.bufsize = bufsize_type_to_bufsize(bufsize_type)\n\n        self.process_chunk, self.finish_chunk_processor = determine_how_to_feed_output(\n            handler, encoding, decode_errors\n        )\n\n        self.should_quit = False\n\n    def fileno(self):\n        \"\"\"defining this allows us to do poll on an instance of this\n        class\"\"\"\n        return self.stream\n\n    def close(self):\n        chunk = self.stream_bufferer.flush()\n        self.log.debug(\"got chunk size %d to flush: %r\", len(chunk), chunk[:30])\n        if chunk:\n            self.write_chunk(chunk)\n\n        self.finish_chunk_processor()\n\n        if self.pipe_queue and self.save_data:\n            self.pipe_queue().put(None)\n\n        os.close(self.stream)\n\n    def write_chunk(self, chunk):\n        # in PY3, the chunk coming in will be bytes, so keep that in mind\n\n        if not self.should_quit:\n            self.should_quit = self.process_chunk(chunk)\n\n        if self.save_data:\n            self.buffer.append(chunk)\n\n            if self.pipe_queue:\n                self.log.debug(\"putting chunk onto pipe: %r\", chunk[:30])\n                self.pipe_queue().put(chunk)\n\n    def read(self):\n        # if we're PY3, we're reading bytes, otherwise we're reading\n        # str\n        try:\n            chunk = no_interrupt(os.read, self.stream, self.bufsize)\n        except OSError as e:\n            self.log.debug(\"got errno %d, done reading\", e.errno)\n            return True\n        if not chunk:\n            self.log.debug(\"got no chunk, done reading\")\n            return True\n\n        self.log.debug(\"got chunk size %d: %r\", len(chunk), chunk[:30])\n        for chunk in self.stream_bufferer.process(chunk):\n            self.write_chunk(chunk)\n\n\nclass StreamBufferer:\n    \"\"\"this is used for feeding in chunks of stdout/stderr, and breaking it up\n    into chunks that will actually be put into the internal buffers.  for\n    example, if you have two processes, one being piped to the other, and you\n    want that, first process to feed lines of data (instead of the chunks\n    however they come in), OProc will use an instance of this class to chop up\n    the data and feed it as lines to be sent down the pipe\"\"\"\n\n    def __init__(self, buffer_type, encoding=DEFAULT_ENCODING, decode_errors=\"strict\"):\n        # 0 for unbuffered, 1 for line, everything else for that amount\n        self.type = buffer_type\n        self.buffer = []\n        self.n_buffer_count = 0\n        self.encoding = encoding\n        self.decode_errors = decode_errors\n\n        # this is for if we change buffering types.  if we change from line\n        # buffered to unbuffered, its very possible that our self.buffer list\n        # has data that was being saved up (while we searched for a newline).\n        # we need to use that up, so we don't lose it\n        self._use_up_buffer_first = False\n\n        # the buffering lock is used because we might change the buffering\n        # types from a different thread.  for example, if we have a stdout\n        # callback, we might use it to change the way stdin buffers.  so we\n        # lock\n        self._buffering_lock = threading.RLock()\n        self.log = Logger(\"stream_bufferer\")\n\n    def change_buffering(self, new_type):\n        # TODO, when we stop supporting 2.6, make this a with context\n        self.log.debug(\"acquiring buffering lock for changing buffering\")\n        self._buffering_lock.acquire()\n        self.log.debug(\"got buffering lock for changing buffering\")\n        try:\n            if new_type == 0:\n                self._use_up_buffer_first = True\n\n            self.type = new_type\n        finally:\n            self._buffering_lock.release()\n            self.log.debug(\"released buffering lock for changing buffering\")\n\n    def process(self, chunk):\n        # MAKE SURE THAT THE INPUT IS PY3 BYTES\n        # THE OUTPUT IS ALWAYS PY3 BYTES\n\n        # TODO, when we stop supporting 2.6, make this a with context\n        self.log.debug(\n            \"acquiring buffering lock to process chunk (buffering: %d)\", self.type\n        )\n        self._buffering_lock.acquire()\n        self.log.debug(\"got buffering lock to process chunk (buffering: %d)\", self.type)\n        try:\n            # unbuffered\n            if self.type == 0:\n                if self._use_up_buffer_first:\n                    self._use_up_buffer_first = False\n                    to_write = self.buffer\n                    self.buffer = []\n                    to_write.append(chunk)\n                    return to_write\n\n                return [chunk]\n\n            # line buffered\n            elif self.type == 1:\n                total_to_write = []\n                nl = \"\\n\".encode(self.encoding)\n                while True:\n                    newline = chunk.find(nl)\n                    if newline == -1:\n                        break\n\n                    chunk_to_write = chunk[: newline + 1]\n                    if self.buffer:\n                        chunk_to_write = b\"\".join(self.buffer) + chunk_to_write\n\n                        self.buffer = []\n                        self.n_buffer_count = 0\n\n                    chunk = chunk[newline + 1 :]\n                    total_to_write.append(chunk_to_write)\n\n                if chunk:\n                    self.buffer.append(chunk)\n                    self.n_buffer_count += len(chunk)\n                return total_to_write\n\n            # N size buffered\n            else:\n                total_to_write = []\n                while True:\n                    overage = self.n_buffer_count + len(chunk) - self.type\n                    if overage >= 0:\n                        ret = \"\".encode(self.encoding).join(self.buffer) + chunk\n                        chunk_to_write = ret[: self.type]\n                        chunk = ret[self.type :]\n                        total_to_write.append(chunk_to_write)\n                        self.buffer = []\n                        self.n_buffer_count = 0\n                    else:\n                        self.buffer.append(chunk)\n                        self.n_buffer_count += len(chunk)\n                        break\n                return total_to_write\n        finally:\n            self._buffering_lock.release()\n            self.log.debug(\n                \"released buffering lock for processing chunk (buffering: %d)\",\n                self.type,\n            )\n\n    def flush(self):\n        self.log.debug(\"acquiring buffering lock for flushing buffer\")\n        self._buffering_lock.acquire()\n        self.log.debug(\"got buffering lock for flushing buffer\")\n        try:\n            ret = \"\".encode(self.encoding).join(self.buffer)\n            self.buffer = []\n            return ret\n        finally:\n            self._buffering_lock.release()\n            self.log.debug(\"released buffering lock for flushing buffer\")\n\n\ndef with_lock(lock):\n    def wrapped(fn):\n        fn = contextmanager(fn)\n\n        @contextmanager\n        def wrapped2(*args, **kwargs):\n            with lock:\n                with fn(*args, **kwargs):\n                    yield\n\n        return wrapped2\n\n    return wrapped\n\n\n@with_lock(PUSHD_LOCK)\ndef pushd(path):\n    \"\"\"pushd changes the actual working directory for the duration of the\n    context, unlike the _cwd arg this will work with other built-ins such as\n    sh.glob correctly\"\"\"\n    orig_path = os.getcwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(orig_path)\n\n\n@contextmanager\ndef _args(**kwargs):\n    \"\"\"allows us to temporarily override all the special keyword parameters in\n    a with context\"\"\"\n\n    kwargs_str = \",\".join([f\"{k}={v!r}\" for k, v in kwargs.items()])\n\n    raise DeprecationWarning(\n        f\"\"\"\n\nsh.args() has been deprecated because it was never thread safe.  use the\nfollowing instead:\n\n    sh2 = sh({kwargs_str})\n    sh2.your_command()\n\nor\n\n    sh2 = sh({kwargs_str})\n    from sh2 import your_command\n    your_command()\n\n\"\"\"\n    )\n\n\nclass Environment(dict):\n    \"\"\"this allows lookups to names that aren't found in the global scope to be\n    searched for as a program name.  for example, if \"ls\" isn't found in this\n    module's scope, we consider it a system program and try to find it.\n\n    we use a dict instead of just a regular object as the base class because the\n    exec() statement used in the run_repl requires the \"globals\" argument to be a\n    dictionary\"\"\"\n\n    # this is a list of all of the names that the sh module exports that will\n    # not resolve to functions.  we don't want to accidentally shadow real\n    # commands with functions/imports that we define in sh.py.  for example,\n    # \"import time\" may override the time system program\n    allowlist = {\n        \"Command\",\n        \"RunningCommand\",\n        \"CommandNotFound\",\n        \"DEFAULT_ENCODING\",\n        \"DoneReadingForever\",\n        \"ErrorReturnCode\",\n        \"NotYetReadyToRead\",\n        \"SignalException\",\n        \"ForkException\",\n        \"TimeoutException\",\n        \"StreamBufferer\",\n        \"_aggregate_keywords\",\n        \"__project_url__\",\n        \"__version__\",\n        \"__file__\",\n        \"_args\",\n        \"pushd\",\n        \"glob\",\n        \"contrib\",\n    }\n\n    def __init__(self, globs, baked_args=None):\n        \"\"\"baked_args are defaults for the 'sh' execution context.  for\n        example:\n\n            tmp = sh(_out=StringIO())\n\n        'out' would end up in here as an entry in the baked_args dict\"\"\"\n        super(dict, self).__init__()\n        self.globs = globs\n        self.baked_args = baked_args or {}\n\n    def __getitem__(self, k):\n        if k == \"args\":\n            # Let the deprecated '_args' context manager be imported as 'args'\n            k = \"_args\"\n\n        # if we're trying to import something real, see if it's in our global scope.\n        # what defines \"real\" is that it's in our allowlist\n        if k in self.allowlist:\n            return self.globs[k]\n\n        # somebody tried to be funny and do \"from sh import *\"\n        if k == \"__all__\":\n            warnings.warn(\n                \"Cannot import * from sh. Please import sh or import programs \"\n                \"individually.\"\n            )\n            return []\n\n        # check if we're naming a dynamically generated ReturnCode exception\n        exc = get_exc_from_name(k)\n        if exc:\n            return exc\n\n        # https://github.com/ipython/ipython/issues/2577\n        # https://github.com/amoffat/sh/issues/97#issuecomment-10610629\n        if k.startswith(\"__\") and k.endswith(\"__\"):\n            raise AttributeError\n\n        # is it a command?\n        cmd = resolve_command(k, self.globs[Command.__name__], self.baked_args)\n        if cmd:\n            return cmd\n\n        # is it a custom builtin?\n        builtin = getattr(self, \"b_\" + k, None)\n        if builtin:\n            return builtin\n\n        # how about an environment variable?\n        # this check must come after testing if its a command, because on some\n        # systems, there are an environment variables that can conflict with\n        # command names.\n        # https://github.com/amoffat/sh/issues/238\n        try:\n            return os.environ[k]\n        except KeyError:\n            pass\n\n        # nothing found, raise an exception\n        raise CommandNotFound(k)\n\n    # Methods that begin with \"b_\" are implementations of shell built-ins that\n    # people are used to, but which may not have an executable equivalent.\n    @staticmethod\n    def b_which(program, paths=None):\n        return _which(program, paths)\n\n\nclass Contrib(ModuleType):  # pragma: no cover\n    @classmethod\n    def __call__(cls, name):\n        def wrapper1(fn):\n            @property\n            def cmd_getter(self):\n                cmd = resolve_command(name, Command)\n\n                if not cmd:\n                    raise CommandNotFound(name)\n\n                new_cmd = fn(cmd)\n                return new_cmd\n\n            setattr(cls, name, cmd_getter)\n            return fn\n\n        return wrapper1\n\n\nmod_name = __name__ + \".contrib\"\ncontrib = Contrib(mod_name)\nsys.modules[mod_name] = contrib\n\n\n@contrib(\"git\")\ndef git(orig):  # pragma: no cover\n    \"\"\"most git commands play nicer without a TTY\"\"\"\n    cmd = orig.bake(_tty_out=False)\n    return cmd\n\n\n@contrib(\"bash\")\ndef bash(orig):\n    cmd = orig.bake(\"-c\")\n    return cmd\n\n\n@contrib(\"sudo\")\ndef sudo(orig):  # pragma: no cover\n    \"\"\"a nicer version of sudo that uses getpass to ask for a password, or\n    allows the first argument to be a string password\"\"\"\n\n    prompt = f\"[sudo] password for {getpass.getuser()}: \"\n\n    def stdin():\n        pw = getpass.getpass(prompt=prompt) + \"\\n\"\n        yield pw\n\n    def process(a, kwargs):\n        password = kwargs.pop(\"password\", None)\n\n        if password is None:\n            pass_getter = stdin()\n        else:\n            pass_getter = password.rstrip(\"\\n\") + \"\\n\"\n\n        kwargs[\"_in\"] = pass_getter\n        return a, kwargs\n\n    cmd = orig.bake(\"-S\", _arg_preprocess=process)\n    return cmd\n\n\n@contrib(\"ssh\")\ndef ssh(orig):  # pragma: no cover\n    \"\"\"An ssh command for automatic password login\"\"\"\n\n    class SessionContent:\n        def __init__(self):\n            self.chars = deque(maxlen=50000)\n            self.lines = deque(maxlen=5000)\n            self.line_chars = []\n            self.last_line = \"\"\n            self.cur_char = \"\"\n\n        def append_char(self, char):\n            if char == \"\\n\":\n                line = self.cur_line\n                self.last_line = line\n                self.lines.append(line)\n                self.line_chars = []\n            else:\n                self.line_chars.append(char)\n\n            self.chars.append(char)\n            self.cur_char = char\n\n        @property\n        def cur_line(self):\n            line = \"\".join(self.line_chars)\n            return line\n\n    class SSHInteract:\n        def __init__(self, prompt_match, pass_getter, out_handler, login_success):\n            self.prompt_match = prompt_match\n            self.pass_getter = pass_getter\n            self.out_handler = out_handler\n            self.login_success = login_success\n            self.content = SessionContent()\n\n            # some basic state\n            self.pw_entered = False\n            self.success = False\n\n        def __call__(self, char, stdin):\n            self.content.append_char(char)\n\n            if self.pw_entered and not self.success:\n                self.success = self.login_success(self.content)\n\n            if self.success:\n                return self.out_handler(self.content, stdin)\n\n            if self.prompt_match(self.content):\n                password = self.pass_getter()\n                stdin.put(password + \"\\n\")\n                self.pw_entered = True\n\n    def process(a, kwargs):\n        real_out_handler = kwargs.pop(\"interact\")\n        password = kwargs.pop(\"password\", None)\n        login_success = kwargs.pop(\"login_success\", None)\n        prompt_match = kwargs.pop(\"prompt\", None)\n        prompt = \"Please enter SSH password: \"\n\n        if prompt_match is None:\n\n            def prompt_match(content):\n                return content.cur_line.endswith(\"password: \")  # noqa: E731\n\n        if password is None:\n\n            def pass_getter():\n                return getpass.getpass(prompt=prompt)  # noqa: E731\n\n        else:\n\n            def pass_getter():\n                return password.rstrip(\"\\n\")  # noqa: E731\n\n        if login_success is None:\n\n            def login_success(content):\n                return True  # noqa: E731\n\n        kwargs[\"_out\"] = SSHInteract(\n            prompt_match, pass_getter, real_out_handler, login_success\n        )\n        return a, kwargs\n\n    cmd = orig.bake(\n        _out_bufsize=0, _tty_in=True, _unify_ttys=True, _arg_preprocess=process\n    )\n    return cmd\n\n\ndef run_repl(env):  # pragma: no cover\n    print(f\"\\n>> sh v{__version__}\\n>> https://github.com/amoffat/sh\\n\")\n\n    while True:\n        try:\n            line = input(\"sh> \")\n        except (ValueError, EOFError):\n            break\n\n        try:\n            exec(compile(line, \"<dummy>\", \"single\"), env, env)\n        except SystemExit:\n            break\n        except:  # noqa: E722\n            print(traceback.format_exc())\n\n    # cleans up our last line\n    print(\"\")\n\n\n# this is a thin wrapper around THIS module (we patch sys.modules[__name__]).\n# this is in the case that the user does a \"from sh import whatever\"\n# in other words, they only want to import certain programs, not the whole\n# system PATH worth of commands.  in this case, we just proxy the\n# import lookup to our Environment class\nclass SelfWrapper(ModuleType):\n    def __init__(self, self_module, baked_args=None):\n        # this is super ugly to have to copy attributes like this,\n        # but it seems to be the only way to make reload() behave\n        # nicely.  if i make these attributes dynamic lookups in\n        # __getattr__, reload sometimes chokes in weird ways...\n        super().__init__(\n            name=getattr(self_module, \"__name__\", None),\n            doc=getattr(self_module, \"__doc__\", None),\n        )\n        for attr in [\"__builtins__\", \"__file__\", \"__package__\"]:\n            setattr(self, attr, getattr(self_module, attr, None))\n\n        # python 3.2 (2.7 and 3.3 work fine) breaks on osx (not ubuntu)\n        # if we set this to None.  and 3.3 needs a value for __path__\n        self.__path__ = []\n        self.__self_module = self_module\n\n        # Copy the Command class and add any baked call kwargs to it\n        command_cls = Command\n        cls_attrs = command_cls.__dict__.copy()\n        cls_attrs.pop(\"__dict__\", None)\n        if baked_args:\n            call_args, _ = command_cls._extract_call_args(baked_args)\n            cls_attrs[\"_call_args\"] = cls_attrs[\"_call_args\"].copy()\n            cls_attrs[\"_call_args\"].update(call_args)\n        globs = globals().copy()\n        globs[command_cls.__name__] = type(\n            command_cls.__name__, command_cls.__bases__, cls_attrs\n        )\n\n        self.__env = Environment(globs, baked_args=baked_args)\n\n    def __getattr__(self, name):\n        return self.__env[name]\n\n    def bake(self, **kwargs):\n        baked_args = self.__env.baked_args.copy()\n        baked_args.update(kwargs)\n        new_sh = self.__class__(self.__self_module, baked_args)\n        return new_sh\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    # we're being run as a stand-alone script\n    env = Environment(globals())\n    run_repl(env)\nelse:\n    # we're being imported from somewhere\n    sys.modules[__name__] = SelfWrapper(sys.modules[__name__])\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tox.ini",
          "type": "blob",
          "size": 0.53515625,
          "content": "[tox]\nenvlist = py{38,39,310,311}-locale-{c,utf8}-poller-{poll,select},lint\nisolated_build = True\n\n[testenv]\nallowlist_externals = poetry\nsetenv =\n    locale-c: LANG=C\n    locale-utf8: LANG=en_US.UTF-8\n    poller-select: SH_TESTS_USE_SELECT=1\n    poller-poll: SH_TESTS_USE_SELECT=0\n    SH_TESTS_RUNNING=1\ncommands =\n    python sh_test.py {posargs}\n\n[testenv:lint]\nallowlist_externals =\n    flake8\n    black\n    rstcheck\n    mypy\ncommands =\n    flake8 sh.py sh_test.py\n    black --check --diff sh.py sh_test.py\n    rstcheck README.rst\n    mypy sh.py"
        }
      ]
    }
  ]
}