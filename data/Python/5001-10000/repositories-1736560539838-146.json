{
  "metadata": {
    "timestamp": 1736560539838,
    "page": 146,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bottlepy/bottle",
      "stars": 8506,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.18359375,
          "content": "*.pyc\n*.pyo\n*.db\n*.log\n*.mo\n._*\n*.*~\n__pycache__\n\ndist/\nbuild/\nMANIFEST\nbottle.egg-info/\n\n.idea/\n\nhtmlcov/\n.htmlcoverage/\n.coverage\n.name\n.tox/\n.pytest_cache\n\ndocs/_locale/_pot/.doctrees/\n"
        },
        {
          "name": ".readthedocs.yaml",
          "type": "blob",
          "size": 0.5888671875,
          "content": "# Read the Docs configuration file for Sphinx projects\n# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details\n\n# Required\nversion: 2\n\n# Set the OS, Python version and other tools you might need\nbuild:\n  os: ubuntu-22.04\n  tools:\n    python: latest\n\n# Build documentation in the \"docs/\" directory with Sphinx\nsphinx:\n  configuration: docs/conf.py\n\n# Optional but recommended, declare the Python requirements required\n# to build your documentation\n# See https://docs.readthedocs.io/en/stable/guides/reproducible-builds.html\npython:\n  install:\n    - requirements: docs/requirements.txt"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 1.296875,
          "content": "Bottle is written and maintained by Marcel Hellkamp <marc@bottlepy.org>.\n\nThanks to all the people who found bugs, sent patches, spread the word, helped each other on the mailing-list and made this project possible. I hope the following (alphabetically sorted) list is complete. If you miss your name on that list (or want your name removed) please file a pull request.\n\n* acasajus\n* Adam R. Smith\n* Alexey Borzenkov\n* Alexis Daboville\n* Anton I. Sipos\n* Anton Kolechkin\n* apexi200sx\n* apheage\n* BillMa\n* Brad Greenlee\n* Brandon Gilmore\n* Branko Vukelic\n* Brian Sierakowski\n* Brian Wickman\n* Carl Scharenberg\n* Damien Degois\n* David Buxton\n* Duane Johnson\n* fcamel\n* Frank Murphy\n* Frederic Junod\n* goldfaber3012\n* Greg Milby\n* gstein\n* Ian Davis\n* Itamar Nabriski\n* Iuri de Silvio\n* Jaimie Murdock\n* Jeff Nichols\n* Jeremy Kelley\n* joegester\n* Johannes Krampf\n* Jonas Haag\n* Joshua Roesslein\n* Judson Neer\n* Karl\n* Kevin Zuber\n* Kraken\n* Kyle Fritz\n* m35\n* Marcos Neves\n* masklinn\n* Michael Labbe\n* Michael Soulier\n* `reddit <http://reddit.com/r/python>`_\n* Nicolas Vanhoren\n* Oz N Tiram\n* Robert Rollins\n* rogererens\n* rwxrwx\n* Santiago Gala\n* Sean M. Collins\n* Sebastian Wollrath\n* Seth\n* Sigurd Høgsbro\n* Stuart Rackham\n* Sun Ning\n* Tomás A. Schertel\n* Tristan Zajonc\n* voltron\n* Wieland Hoffmann\n* zombat\n* Thiago Avelino\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.041015625,
          "content": "Copyright (c) 2009-2024, Marcel Hellkamp.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.0810546875,
          "content": "VERSION = $(shell ./bottle.py --version)\nVENV = build/venv\n\n.PHONY: test\ntest: venv\n\t$(VENV)/bin/pytest\n\n.PHONY: coverage\ncoverage: venv\n\t$(VENV)/bin/pytest -q --cov=bottle --cov-report=term --cov-report=html:build/htmlcov\n\n.PHONY: build\nbuild: test\n\t$(VENV)/bin/python -m build\n\n.PHONY: docs\ndocs: venv\n\t$(VENV)/bin/sphinx-build -b html docs build/docs/html/;\n\n.PHONY: watchdocs\nwatchdocs: venv\n\t-mkdir -p build/docs/watch/\n\t$(VENV)/bin/sphinx-autobuild -b html docs build/docs/watch/;\n\n.PHONY: version\nversion:\n\t@echo $(VERSION)\n\n.PHONY: venv\nvenv: $(VENV)/.installed\n$(VENV)/.installed: Makefile pyproject.toml\n\ttest -d $(VENV) || python3 -m venv $(VENV)\n\t$(VENV)/bin/python3 -m ensurepip\n\t$(VENV)/bin/pip install -q -U pip\n\t$(VENV)/bin/pip install -q -e .[dev]\n\ttouch $(VENV)/.installed\n\n.PHONY: venv\nclean:\n\trm -rf $(VENV) build/ dist/ MANIFEST .coverage .pytest_cache bottle.egg-info 2>/dev/null || true\n\tfind . -name '__pycache__' -exec rm -rf {} +\n\tfind . -name '*.pyc' -exec rm -f {} +\n\tfind . -name '*.pyo' -exec rm -f {} +\n\tfind . -name '*~' -exec rm -f {} +\n\tfind . -name '._*' -exec rm -f {} +\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 2.779296875,
          "content": ".. image:: http://bottlepy.org/docs/dev/_static/logo_nav.png\n  :target: http://bottlepy.org/\n  :alt: Bottle Logo\n  :align: right\n\n.. image:: https://github.com/bottlepy/bottle/workflows/Tests/badge.svg\n    :target: https://github.com/bottlepy/bottle/workflows/Tests\n    :alt: Tests Status\n\n.. image:: https://img.shields.io/pypi/v/bottle.svg\n    :target: https://pypi.python.org/pypi/bottle/\n    :alt: Latest Version\n\n.. image:: https://img.shields.io/pypi/l/bottle.svg\n    :target: https://pypi.python.org/pypi/bottle/\n    :alt: License\n\n.. _Python: https://python.org/\n.. _mako: https://www.makotemplates.org/\n.. _cheetah: https://www.cheetahtemplate.org/\n.. _jinja2: https://jinja.palletsprojects.com/\n\n.. _WSGI: https://peps.python.org/pep-3333/\n.. _gunicorn: https://gunicorn.org/\n.. _paste: https://pythonpaste.readthedocs.io/\n.. _cheroot: https://cheroot.cherrypy.dev/\n\n============================\nBottle: Python Web Framework\n============================\n\nBottle is a fast, simple and lightweight WSGI_ micro web-framework for Python_. It is distributed as a single file module and has no dependencies other than the `Python Standard Library <http://docs.python.org/library/>`_.\n\n* **Routing:** Requests to function-call mapping with support for clean and dynamic URLs.\n* **Templates:** Fast `built-in template engine <http://bottlepy.org/docs/dev/tutorial.html#tutorial-templates>`_ and support for mako_, jinja2_ and cheetah_ templates.\n* **Utilities:** Convenient access to form data, file uploads, cookies, headers and other HTTP features.\n* **Server:** Built-in development server and ready-to-use adapters for a wide range of WSGI_ capable HTTP server (e.g. gunicorn_, paste_ or cheroot_).\n\n\nHomepage and documentation: http://bottlepy.org\n\n\nExample: \"Hello World\" in a bottle\n----------------------------------\n\n.. code-block:: python\n\n  from bottle import route, run, template\n\n  @route('/hello/<name>')\n  def index(name):\n      return template('<b>Hello {{name}}</b>!', name=name)\n\n  run(host='localhost', port=8080)\n\nRun this script or paste it into a Python console, then point your browser to `<http://localhost:8080/hello/world>`_. That's it.\n\n\nDownload and Install\n--------------------\n\n.. __: https://github.com/bottlepy/bottle/raw/master/bottle.py\n\nInstall the latest stable release with ``pip install bottle`` or download `bottle.py`__ (unstable) into your project directory. There are no hard dependencies other than the Python standard library.\n\nLicense\n-------\n\n.. __: https://github.com/bottlepy/bottle/raw/master/LICENSE\n\nCode and documentation are available according to the MIT License (see LICENSE__).\n\nThe Bottle logo however is *NOT* covered by that license. It is allowed to use the logo as a link to the bottle homepage or in direct context with the unmodified library. In all other cases, please ask first.\n"
        },
        {
          "name": "bottle.py",
          "type": "blob",
          "size": 171.4521484375,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nBottle is a fast and simple micro-framework for small web applications. It\noffers request dispatching (Routes) with URL parameter support, templates,\na built-in HTTP Server and adapters for many third party WSGI/HTTP-server and\ntemplate engines - all in a single file and with no dependencies other than the\nPython Standard Library.\n\nHomepage and documentation: http://bottlepy.org/\n\nCopyright (c) 2009-2024, Marcel Hellkamp.\nLicense: MIT (see LICENSE for details)\n\"\"\"\n\nimport sys\n\n__author__ = 'Marcel Hellkamp'\n__version__ = '0.14-dev'\n__license__ = 'MIT'\n\n###############################################################################\n# Command-line interface ######################################################\n###############################################################################\n# INFO: Some server adapters need to monkey-patch std-lib modules before they\n# are imported. This is why some of the command-line handling is done here, but\n# the actual call to _main() is at the end of the file.\n\n\ndef _cli_parse(args):  # pragma: no coverage\n    from argparse import ArgumentParser\n\n    parser = ArgumentParser(prog=args[0], usage=\"%(prog)s [options] package.module:app\")\n    opt = parser.add_argument\n    opt(\"--version\", action=\"store_true\", help=\"show version number.\")\n    opt(\"-b\", \"--bind\", metavar=\"ADDRESS\", help=\"bind socket to ADDRESS.\")\n    opt(\"-s\", \"--server\", default='wsgiref', help=\"use SERVER as backend.\")\n    opt(\"-p\", \"--plugin\", action=\"append\", help=\"install additional plugin/s.\")\n    opt(\"-c\", \"--conf\", action=\"append\", metavar=\"FILE\",\n        help=\"load config values from FILE.\")\n    opt(\"-C\", \"--param\", action=\"append\", metavar=\"NAME=VALUE\",\n        help=\"override config values.\")\n    opt(\"--debug\", action=\"store_true\", help=\"start server in debug mode.\")\n    opt(\"--reload\", action=\"store_true\", help=\"auto-reload on file changes.\")\n    opt('app', help='WSGI app entry point.', nargs='?')\n\n    cli_args = parser.parse_args(args[1:])\n\n    return cli_args, parser\n\n\ndef _cli_patch(cli_args):  # pragma: no coverage\n    parsed_args, _ = _cli_parse(cli_args)\n    opts = parsed_args\n    if opts.server:\n        if opts.server.startswith('gevent'):\n            import gevent.monkey\n            gevent.monkey.patch_all()\n        elif opts.server.startswith('eventlet'):\n            import eventlet\n            eventlet.monkey_patch()\n\n\nif __name__ == '__main__':\n    _cli_patch(sys.argv)\n\n###############################################################################\n# Imports and Helpers used everywhere else #####################################\n###############################################################################\n\nimport base64, calendar, email.utils, functools, hmac, itertools, \\\n    mimetypes, os, re, tempfile, threading, time, warnings, weakref, hashlib\n\nfrom types import FunctionType\nfrom datetime import date as datedate, datetime, timedelta\nfrom tempfile import NamedTemporaryFile\nfrom traceback import format_exc, print_exc\nfrom unicodedata import normalize\n\ntry:\n    from ujson import dumps as json_dumps, loads as json_lds\nexcept ImportError:\n    from json import dumps as json_dumps, loads as json_lds\n\npy = sys.version_info\n\nimport http.client as httplib\nimport _thread as thread\nfrom urllib.parse import urljoin, SplitResult as UrlSplitResult\nfrom urllib.parse import urlencode, quote as urlquote, unquote as urlunquote\nfrom http.cookies import SimpleCookie, Morsel, CookieError\nfrom collections.abc import MutableMapping as DictMixin\nfrom types import ModuleType as new_module\nimport pickle\nfrom io import BytesIO\nimport configparser\nfrom datetime import timezone\nUTC = timezone.utc\nimport inspect\n\njson_loads = lambda s: json_lds(touni(s))\ncallable = lambda x: hasattr(x, '__call__')\n\ndef _wsgi_recode(src):\n    \"\"\" Translate a PEP-3333 latin1-string to utf8+surrogateescape \"\"\"\n    if src.isascii():\n        return src\n    return src.encode('latin1').decode('utf8', 'surrogateescape')\n\n\ndef _raise(*a):\n    raise a[0](a[1]).with_traceback(a[2])\n\n\n# Some helpers for string/byte handling\ndef tob(s, enc='utf8'):\n    if isinstance(s, str):\n        return s.encode(enc)\n    return b'' if s is None else bytes(s)\n\n\ndef touni(s, enc='utf8', err='strict'):\n    if isinstance(s, (bytes, bytearray)):\n        return str(s, enc, err)\n    return \"\" if s is None else str(s)\n\n\ndef _stderr(*args):\n    try:\n        print(*args, file=sys.stderr)\n    except (IOError, AttributeError):\n        pass # Some environments do not allow printing (mod_wsgi)\n\n\n# A bug in functools causes it to break if the wrapper is an instance method\ndef update_wrapper(wrapper, wrapped, *a, **ka):\n    try:\n        functools.update_wrapper(wrapper, wrapped, *a, **ka)\n    except AttributeError:\n        pass\n\n# These helpers are used at module level and need to be defined first.\n# And yes, I know PEP-8, but sometimes a lower-case classname makes more sense.\n\n\ndef depr(major, minor, cause, fix, stacklevel=3):\n    text = \"Warning: Use of deprecated feature or API. (Deprecated in Bottle-%d.%d)\\n\"\\\n           \"Cause: %s\\n\"\\\n           \"Fix: %s\\n\" % (major, minor, cause, fix)\n    if DEBUG == 'strict':\n        raise DeprecationWarning(text)\n    warnings.warn(text, DeprecationWarning, stacklevel=stacklevel)\n    return DeprecationWarning(text)\n\n\ndef makelist(data):  # This is just too handy\n    if isinstance(data, (tuple, list, set, dict)):\n        return list(data)\n    elif data:\n        return [data]\n    else:\n        return []\n\n\nclass DictProperty(object):\n    \"\"\" Property that maps to a key in a local dict-like attribute. \"\"\"\n\n    def __init__(self, attr, key=None, read_only=False):\n        self.attr, self.key, self.read_only = attr, key, read_only\n\n    def __call__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter, self.key = func, self.key or func.__name__\n        return self\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        key, storage = self.key, getattr(obj, self.attr)\n        if key not in storage: storage[key] = self.getter(obj)\n        return storage[key]\n\n    def __set__(self, obj, value):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        getattr(obj, self.attr)[self.key] = value\n\n    def __delete__(self, obj):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        del getattr(obj, self.attr)[self.key]\n\n\nclass cached_property(object):\n    \"\"\" A property that is only computed once per instance and then replaces\n        itself with an ordinary attribute. Deleting the attribute resets the\n        property. \"\"\"\n\n    def __init__(self, func):\n        update_wrapper(self, func)\n        self.func = func\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        value = obj.__dict__[self.func.__name__] = self.func(obj)\n        return value\n\n\nclass lazy_attribute(object):\n    \"\"\" A property that caches itself to the class object. \"\"\"\n\n    def __init__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter = func\n\n    def __get__(self, obj, cls):\n        value = self.getter(cls)\n        setattr(cls, self.__name__, value)\n        return value\n\n\n###############################################################################\n# Exceptions and Events #######################################################\n###############################################################################\n\n\nclass BottleException(Exception):\n    \"\"\" A base class for exceptions used by bottle. \"\"\"\n    pass\n\n###############################################################################\n# Routing ######################################################################\n###############################################################################\n\n\nclass RouteError(BottleException):\n    \"\"\" This is a base class for all routing related exceptions \"\"\"\n\n\nclass RouterUnknownModeError(RouteError):\n    pass\n\n\nclass RouteSyntaxError(RouteError):\n    \"\"\" The route parser found something not supported by this router. \"\"\"\n\n\nclass RouteBuildError(RouteError):\n    \"\"\" The route could not be built. \"\"\"\n\n\ndef _re_flatten(p):\n    \"\"\" Turn all capturing groups in a regular expression pattern into\n        non-capturing groups. \"\"\"\n    if '(' not in p:\n        return p\n    return re.sub(r'(\\\\*)(\\(\\?P<[^>]+>|\\((?!\\?))', lambda m: m.group(0) if\n                  len(m.group(1)) % 2 else m.group(1) + '(?:', p)\n\n\nclass Router(object):\n    \"\"\" A Router is an ordered collection of route->target pairs. It is used to\n        efficiently match WSGI requests against a number of routes and return\n        the first target that satisfies the request. The target may be anything,\n        usually a string, ID or callable object. A route consists of a path-rule\n        and a HTTP method.\n\n        The path-rule is either a static path (e.g. `/contact`) or a dynamic\n        path that contains wildcards (e.g. `/wiki/<page>`). The wildcard syntax\n        and details on the matching order are described in docs:`routing`.\n    \"\"\"\n\n    default_pattern = '[^/]+'\n    default_filter = 're'\n\n    #: The current CPython regexp implementation does not allow more\n    #: than 99 matching groups per regular expression.\n    _MAX_GROUPS_PER_PATTERN = 99\n\n    def __init__(self, strict=False):\n        self.rules = []  # All rules in order\n        self._groups = {}  # index of regexes to find them in dyna_routes\n        self.builder = {}  # Data structure for the url builder\n        self.static = {}  # Search structure for static routes\n        self.dyna_routes = {}\n        self.dyna_regexes = {}  # Search structure for dynamic routes\n        #: If true, static routes are no longer checked first.\n        self.strict_order = strict\n        self.filters = {\n            're': lambda conf: (_re_flatten(conf or self.default_pattern),\n                                None, None),\n            'int': lambda conf: (r'-?\\d+', int, lambda x: str(int(x))),\n            'float': lambda conf: (r'-?[\\d.]+', float, lambda x: str(float(x))),\n            'path': lambda conf: (r'.+?', None, None)\n        }\n\n    def add_filter(self, name, func):\n        \"\"\" Add a filter. The provided function is called with the configuration\n        string as parameter and must return a (regexp, to_python, to_url) tuple.\n        The first element is a string, the last two are callables or None. \"\"\"\n        self.filters[name] = func\n\n    rule_syntax = re.compile('(\\\\\\\\*)'\n        '(?:(?::([a-zA-Z_][a-zA-Z_0-9]*)?()(?:#(.*?)#)?)'\n          '|(?:<([a-zA-Z_][a-zA-Z_0-9]*)?(?::([a-zA-Z_]*)'\n            '(?::((?:\\\\\\\\.|[^\\\\\\\\>])+)?)?)?>))')\n\n    def _itertokens(self, rule):\n        offset, prefix = 0, ''\n        for match in self.rule_syntax.finditer(rule):\n            prefix += rule[offset:match.start()]\n            g = match.groups()\n            if g[2] is not None:\n                depr(0, 13, \"Use of old route syntax.\",\n                            \"Use <name> instead of :name in routes.\",\n                            stacklevel=4)\n            if len(g[0]) % 2:  # Escaped wildcard\n                prefix += match.group(0)[len(g[0]):]\n                offset = match.end()\n                continue\n            if prefix:\n                yield prefix, None, None\n            name, filtr, conf = g[4:7] if g[2] is None else g[1:4]\n            yield name, filtr or 'default', conf or None\n            offset, prefix = match.end(), ''\n        if offset <= len(rule) or prefix:\n            yield prefix + rule[offset:], None, None\n\n    def add(self, rule, method, target, name=None):\n        \"\"\" Add a new rule or replace the target for an existing rule. \"\"\"\n        anons = 0  # Number of anonymous wildcards found\n        keys = []  # Names of keys\n        pattern = ''  # Regular expression pattern with named groups\n        filters = []  # Lists of wildcard input filters\n        builder = []  # Data structure for the URL builder\n        is_static = True\n\n        for key, mode, conf in self._itertokens(rule):\n            if mode:\n                is_static = False\n                if mode == 'default': mode = self.default_filter\n                mask, in_filter, out_filter = self.filters[mode](conf)\n                if not key:\n                    pattern += '(?:%s)' % mask\n                    key = 'anon%d' % anons\n                    anons += 1\n                else:\n                    pattern += '(?P<%s>%s)' % (key, mask)\n                    keys.append(key)\n                if in_filter: filters.append((key, in_filter))\n                builder.append((key, out_filter or str))\n            elif key:\n                pattern += re.escape(key)\n                builder.append((None, key))\n\n        self.builder[rule] = builder\n        if name: self.builder[name] = builder\n\n        if is_static and not self.strict_order:\n            self.static.setdefault(method, {})\n            self.static[method][self.build(rule)] = (target, None)\n            return\n\n        try:\n            re_pattern = re.compile('^(%s)$' % pattern)\n            re_match = re_pattern.match\n        except re.error as e:\n            raise RouteSyntaxError(\"Could not add Route: %s (%s)\" % (rule, e))\n\n        if filters:\n\n            def getargs(path):\n                url_args = re_match(path).groupdict()\n                for name, wildcard_filter in filters:\n                    try:\n                        url_args[name] = wildcard_filter(url_args[name])\n                    except ValueError:\n                        raise HTTPError(400, 'Path has wrong format.')\n                return url_args\n        elif re_pattern.groupindex:\n\n            def getargs(path):\n                return re_match(path).groupdict()\n        else:\n            getargs = None\n\n        flatpat = _re_flatten(pattern)\n        whole_rule = (rule, flatpat, target, getargs)\n\n        if (flatpat, method) in self._groups:\n            if DEBUG:\n                msg = 'Route <%s %s> overwrites a previously defined route'\n                warnings.warn(msg % (method, rule), RuntimeWarning, stacklevel=3)\n            self.dyna_routes[method][\n                self._groups[flatpat, method]] = whole_rule\n        else:\n            self.dyna_routes.setdefault(method, []).append(whole_rule)\n            self._groups[flatpat, method] = len(self.dyna_routes[method]) - 1\n\n        self._compile(method)\n\n    def _compile(self, method):\n        all_rules = self.dyna_routes[method]\n        comborules = self.dyna_regexes[method] = []\n        maxgroups = self._MAX_GROUPS_PER_PATTERN\n        for x in range(0, len(all_rules), maxgroups):\n            some = all_rules[x:x + maxgroups]\n            combined = (flatpat for (_, flatpat, _, _) in some)\n            combined = '|'.join('(^%s$)' % flatpat for flatpat in combined)\n            combined = re.compile(combined).match\n            rules = [(target, getargs) for (_, _, target, getargs) in some]\n            comborules.append((combined, rules))\n\n    def build(self, _name, *anons, **query):\n        \"\"\" Build an URL by filling the wildcards in a rule. \"\"\"\n        builder = self.builder.get(_name)\n        if not builder:\n            raise RouteBuildError(\"No route with that name.\", _name)\n        try:\n            for i, value in enumerate(anons):\n                query['anon%d' % i] = value\n            url = ''.join([f(query.pop(n)) if n else f for (n, f) in builder])\n            return url if not query else url + '?' + urlencode(query)\n        except KeyError as E:\n            raise RouteBuildError('Missing URL argument: %r' % E.args[0])\n\n    def match(self, environ):\n        \"\"\" Return a (target, url_args) tuple or raise HTTPError(400/404/405). \"\"\"\n        verb = environ['REQUEST_METHOD'].upper()\n        path = environ['PATH_INFO'] or '/'\n\n        methods = ('PROXY', 'HEAD', 'GET', 'ANY') if verb == 'HEAD' else ('PROXY', verb, 'ANY')\n\n        for method in methods:\n            if method in self.static and path in self.static[method]:\n                target, getargs = self.static[method][path]\n                return target, getargs(path) if getargs else {}\n            elif method in self.dyna_regexes:\n                for combined, rules in self.dyna_regexes[method]:\n                    match = combined(path)\n                    if match:\n                        target, getargs = rules[match.lastindex - 1]\n                        return target, getargs(path) if getargs else {}\n\n        # No matching route found. Collect alternative methods for 405 response\n        allowed = set([])\n        nocheck = set(methods)\n        for method in set(self.static) - nocheck:\n            if path in self.static[method]:\n                allowed.add(method)\n        for method in set(self.dyna_regexes) - allowed - nocheck:\n            for combined, rules in self.dyna_regexes[method]:\n                match = combined(path)\n                if match:\n                    allowed.add(method)\n        if allowed:\n            allow_header = \",\".join(sorted(allowed))\n            raise HTTPError(405, \"Method not allowed.\", Allow=allow_header)\n\n        # No matching route and no alternative method found. We give up\n        raise HTTPError(404, \"Not found: \" + repr(path))\n\n\nclass Route(object):\n    \"\"\" This class wraps a route callback along with route specific metadata and\n        configuration and applies Plugins on demand. It is also responsible for\n        turning an URL path rule into a regular expression usable by the Router.\n    \"\"\"\n\n    def __init__(self, app, rule, method, callback,\n                 name=None,\n                 plugins=None,\n                 skiplist=None, **config):\n        #: The application this route is installed to.\n        self.app = app\n        #: The path-rule string (e.g. ``/wiki/<page>``).\n        self.rule = rule\n        #: The HTTP method as a string (e.g. ``GET``).\n        self.method = method\n        #: The original callback with no plugins applied. Useful for introspection.\n        self.callback = callback\n        #: The name of the route (if specified) or ``None``.\n        self.name = name or None\n        #: A list of route-specific plugins (see :meth:`Bottle.route`).\n        self.plugins = plugins or []\n        #: A list of plugins to not apply to this route (see :meth:`Bottle.route`).\n        self.skiplist = skiplist or []\n        #: Additional keyword arguments passed to the :meth:`Bottle.route`\n        #: decorator are stored in this dictionary. Used for route-specific\n        #: plugin configuration and meta-data.\n        self.config = app.config._make_overlay()\n        self.config.load_dict(config)\n\n    @cached_property\n    def call(self):\n        \"\"\" The route callback with all plugins applied. This property is\n            created on demand and then cached to speed up subsequent requests.\"\"\"\n        return self._make_callback()\n\n    def reset(self):\n        \"\"\" Forget any cached values. The next time :attr:`call` is accessed,\n            all plugins are re-applied. \"\"\"\n        self.__dict__.pop('call', None)\n\n    def prepare(self):\n        \"\"\" Do all on-demand work immediately (useful for debugging).\"\"\"\n        self.call\n\n    def all_plugins(self):\n        \"\"\" Yield all Plugins affecting this route. \"\"\"\n        unique = set()\n        for p in reversed(self.app.plugins + self.plugins):\n            if True in self.skiplist: break\n            name = getattr(p, 'name', False)\n            if name and (name in self.skiplist or name in unique): continue\n            if p in self.skiplist or type(p) in self.skiplist: continue\n            if name: unique.add(name)\n            yield p\n\n    def _make_callback(self):\n        callback = self.callback\n        for plugin in self.all_plugins():\n            if hasattr(plugin, 'apply'):\n                callback = plugin.apply(callback, self)\n            else:\n                callback = plugin(callback)\n            if callback is not self.callback:\n                update_wrapper(callback, self.callback)\n        return callback\n\n    def get_undecorated_callback(self):\n        \"\"\" Return the callback. If the callback is a decorated function, try to\n            recover the original function. \"\"\"\n        func = self.callback\n        func = getattr(func, '__func__', func)\n        while hasattr(func, '__closure__') and getattr(func, '__closure__'):\n            attributes = getattr(func, '__closure__')\n            func = attributes[0].cell_contents\n\n            # in case of decorators with multiple arguments\n            if not isinstance(func, FunctionType):\n                # pick first FunctionType instance from multiple arguments\n                func = filter(lambda x: isinstance(x, FunctionType),\n                              map(lambda x: x.cell_contents, attributes))\n                func = list(func)[0]  # py3 support\n        return func\n\n    def get_callback_args(self):\n        \"\"\" Return a list of argument names the callback (most likely) accepts\n            as keyword arguments. If the callback is a decorated function, try\n            to recover the original function before inspection. \"\"\"\n        sig = inspect.signature(self.get_undecorated_callback())\n        return [p.name for p in sig.parameters.values() if p.kind in (\n            p.POSITIONAL_OR_KEYWORD, p.KEYWORD_ONLY\n        )]\n\n    def get_config(self, key, default=None):\n        \"\"\" Lookup a config field and return its value, first checking the\n            route.config, then route.app.config.\"\"\"\n        depr(0, 13, \"Route.get_config() is deprecated.\",\n                    \"The Route.config property already includes values from the\"\n                    \" application config for missing keys. Access it directly.\")\n        return self.config.get(key, default)\n\n    def __repr__(self):\n        cb = self.get_undecorated_callback()\n        return '<%s %s -> %s:%s>' % (self.method, self.rule, cb.__module__, cb.__name__)\n\n###############################################################################\n# Application Object ###########################################################\n###############################################################################\n\n\nclass Bottle(object):\n    \"\"\" Each Bottle object represents a single, distinct web application and\n        consists of routes, callbacks, plugins, resources and configuration.\n        Instances are callable WSGI applications.\n\n        :param catchall: If true (default), handle all exceptions. Turn off to\n                         let debugging middleware handle exceptions.\n    \"\"\"\n\n    @lazy_attribute\n    def _global_config(cls):\n        cfg = ConfigDict()\n        cfg.meta_set('catchall', 'validate', bool)\n        return cfg\n\n    def __init__(self, **kwargs):\n        #: A :class:`ConfigDict` for app specific configuration.\n        self.config = self._global_config._make_overlay()\n        self.config._add_change_listener(\n            functools.partial(self.trigger_hook, 'config'))\n\n        self.config.update({\n            \"catchall\": True\n        })\n\n        if kwargs.get('catchall') is False:\n            depr(0, 13, \"Bottle(catchall) keyword argument.\",\n                        \"The 'catchall' setting is now part of the app \"\n                        \"configuration. Fix: `app.config['catchall'] = False`\")\n            self.config['catchall'] = False\n        if kwargs.get('autojson') is False:\n            depr(0, 13, \"Bottle(autojson) keyword argument.\",\n                 \"The 'autojson' setting is now part of the app \"\n                 \"configuration. Fix: `app.config['json.enable'] = False`\")\n            self.config['json.enable'] = False\n\n        self._mounts = []\n\n        #: A :class:`ResourceManager` for application files\n        self.resources = ResourceManager()\n\n        self.routes = []  # List of installed :class:`Route` instances.\n        self.router = Router()  # Maps requests to :class:`Route` instances.\n        self.error_handler = {}\n\n        # Core plugins\n        self.plugins = []  # List of installed plugins.\n        self.install(JSONPlugin())\n        self.install(TemplatePlugin())\n\n    #: If true, most exceptions are caught and returned as :exc:`HTTPError`\n    catchall = DictProperty('config', 'catchall')\n\n    __hook_names = 'before_request', 'after_request', 'app_reset', 'config'\n    __hook_reversed = {'after_request'}\n\n    @cached_property\n    def _hooks(self):\n        return dict((name, []) for name in self.__hook_names)\n\n    def add_hook(self, name, func):\n        \"\"\" Attach a callback to a hook. Three hooks are currently implemented:\n\n            before_request\n                Executed once before each request. The request context is\n                available, but no routing has happened yet.\n            after_request\n                Executed once after each request regardless of its outcome.\n            app_reset\n                Called whenever :meth:`Bottle.reset` is called.\n        \"\"\"\n        if name in self.__hook_reversed:\n            self._hooks[name].insert(0, func)\n        else:\n            self._hooks[name].append(func)\n\n    def remove_hook(self, name, func):\n        \"\"\" Remove a callback from a hook. \"\"\"\n        if name in self._hooks and func in self._hooks[name]:\n            self._hooks[name].remove(func)\n            return True\n\n    def trigger_hook(self, __name, *args, **kwargs):\n        \"\"\" Trigger a hook and return a list of results. \"\"\"\n        return [hook(*args, **kwargs) for hook in self._hooks[__name][:]]\n\n    def hook(self, name):\n        \"\"\" Return a decorator that attaches a callback to a hook. See\n            :meth:`add_hook` for details.\"\"\"\n\n        def decorator(func):\n            self.add_hook(name, func)\n            return func\n\n        return decorator\n\n    def _mount_wsgi(self, prefix, app, **options):\n        segments = [p for p in prefix.split('/') if p]\n        if not segments:\n            raise ValueError('WSGI applications cannot be mounted to \"/\".')\n        path_depth = len(segments)\n\n        def mountpoint_wrapper():\n            try:\n                request.path_shift(path_depth)\n                rs = HTTPResponse([])\n\n                def start_response(status, headerlist, exc_info=None):\n                    if exc_info:\n                        _raise(*exc_info)\n                    status = _wsgi_recode(status)\n                    headerlist = [(k, _wsgi_recode(v))\n                                    for (k, v) in headerlist]\n                    rs.status = status\n                    for name, value in headerlist:\n                        rs.add_header(name, value)\n                    return rs.body.append\n\n                body = app(request.environ, start_response)\n                rs.body = itertools.chain(rs.body, body) if rs.body else body\n                return rs\n            finally:\n                request.path_shift(-path_depth)\n\n        options.setdefault('skip', True)\n        options.setdefault('method', 'PROXY')\n        options.setdefault('mountpoint', {'prefix': prefix, 'target': app})\n        options['callback'] = mountpoint_wrapper\n\n        self.route('/%s/<:re:.*>' % '/'.join(segments), **options)\n        if not prefix.endswith('/'):\n            self.route('/' + '/'.join(segments), **options)\n\n    def _mount_app(self, prefix, app, **options):\n        if app in self._mounts or '_mount.app' in app.config:\n            depr(0, 13, \"Application mounted multiple times. Falling back to WSGI mount.\",\n                 \"Clone application before mounting to a different location.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        if options:\n            depr(0, 13, \"Unsupported mount options. Falling back to WSGI mount.\",\n                 \"Do not specify any route options when mounting bottle application.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        if not prefix.endswith(\"/\"):\n            depr(0, 13, \"Prefix must end in '/'. Falling back to WSGI mount.\",\n                 \"Consider adding an explicit redirect from '/prefix' to '/prefix/' in the parent application.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        self._mounts.append(app)\n        app.config['_mount.prefix'] = prefix\n        app.config['_mount.app'] = self\n        for route in app.routes:\n            route.rule = prefix + route.rule.lstrip('/')\n            self.add_route(route)\n\n    def mount(self, prefix, app, **options):\n        \"\"\" Mount an application (:class:`Bottle` or plain WSGI) to a specific\n            URL prefix. Example::\n\n                parent_app.mount('/prefix/', child_app)\n\n            :param prefix: path prefix or `mount-point`.\n            :param app: an instance of :class:`Bottle` or a WSGI application.\n\n            Plugins from the parent application are not applied to the routes\n            of the mounted child application. If you need plugins in the child\n            application, install them separately.\n\n            While it is possible to use path wildcards within the prefix path\n            (:class:`Bottle` childs only), it is highly discouraged.\n\n            The prefix path must end with a slash. If you want to access the\n            root of the child application via `/prefix` in addition to\n            `/prefix/`, consider adding a route with a 307 redirect to the\n            parent application.\n        \"\"\"\n\n        if not prefix.startswith('/'):\n            raise ValueError(\"Prefix must start with '/'\")\n\n        if isinstance(app, Bottle):\n            return self._mount_app(prefix, app, **options)\n        else:\n            return self._mount_wsgi(prefix, app, **options)\n\n    def merge(self, routes):\n        \"\"\" Merge the routes of another :class:`Bottle` application or a list of\n            :class:`Route` objects into this application. The routes keep their\n            'owner', meaning that the :data:`Route.app` attribute is not\n            changed. \"\"\"\n        if isinstance(routes, Bottle):\n            routes = routes.routes\n        for route in routes:\n            self.add_route(route)\n\n    def install(self, plugin):\n        \"\"\" Add a plugin to the list of plugins and prepare it for being\n            applied to all routes of this application. A plugin may be a simple\n            decorator or an object that implements the :class:`Plugin` API.\n        \"\"\"\n        if hasattr(plugin, 'setup'): plugin.setup(self)\n        if not callable(plugin) and not hasattr(plugin, 'apply'):\n            raise TypeError(\"Plugins must be callable or implement .apply()\")\n        self.plugins.append(plugin)\n        self.reset()\n        return plugin\n\n    def uninstall(self, plugin):\n        \"\"\" Uninstall plugins. Pass an instance to remove a specific plugin, a type\n            object to remove all plugins that match that type, a string to remove\n            all plugins with a matching ``name`` attribute or ``True`` to remove all\n            plugins. Return the list of removed plugins. \"\"\"\n        removed, remove = [], plugin\n        for i, plugin in list(enumerate(self.plugins))[::-1]:\n            if remove is True or remove is plugin or remove is type(plugin) \\\n            or getattr(plugin, 'name', True) == remove:\n                removed.append(plugin)\n                del self.plugins[i]\n                if hasattr(plugin, 'close'): plugin.close()\n        if removed: self.reset()\n        return removed\n\n    def reset(self, route=None):\n        \"\"\" Reset all routes (force plugins to be re-applied) and clear all\n            caches. If an ID or route object is given, only that specific route\n            is affected. \"\"\"\n        if route is None: routes = self.routes\n        elif isinstance(route, Route): routes = [route]\n        else: routes = [self.routes[route]]\n        for route in routes:\n            route.reset()\n        if DEBUG:\n            for route in routes:\n                route.prepare()\n        self.trigger_hook('app_reset')\n\n    def close(self):\n        \"\"\" Close the application and all installed plugins. \"\"\"\n        for plugin in self.plugins:\n            if hasattr(plugin, 'close'): plugin.close()\n\n    def run(self, **kwargs):\n        \"\"\" Calls :func:`run` with the same parameters. \"\"\"\n        run(self, **kwargs)\n\n    def match(self, environ):\n        \"\"\" Search for a matching route and return a (:class:`Route`, urlargs)\n            tuple. The second value is a dictionary with parameters extracted\n            from the URL. Raise :exc:`HTTPError` (404/405) on a non-match.\"\"\"\n        return self.router.match(environ)\n\n    def get_url(self, routename, **kargs):\n        \"\"\" Return a string that matches a named route \"\"\"\n        scriptname = request.environ.get('SCRIPT_NAME', '').strip('/') + '/'\n        location = self.router.build(routename, **kargs).lstrip('/')\n        return urljoin(urljoin('/', scriptname), location)\n\n    def add_route(self, route):\n        \"\"\" Add a route object, but do not change the :data:`Route.app`\n            attribute.\"\"\"\n        self.routes.append(route)\n        self.router.add(route.rule, route.method, route, name=route.name)\n        if DEBUG: route.prepare()\n\n    def route(self,\n              path=None,\n              method='GET',\n              callback=None,\n              name=None,\n              apply=None,\n              skip=None, **config):\n        \"\"\" A decorator to bind a function to a request URL. Example::\n\n                @app.route('/hello/<name>')\n                def hello(name):\n                    return 'Hello %s' % name\n\n            The ``<name>`` part is a wildcard. See :class:`Router` for syntax\n            details.\n\n            :param path: Request path or a list of paths to listen to. If no\n              path is specified, it is automatically generated from the\n              signature of the function.\n            :param method: HTTP method (`GET`, `POST`, `PUT`, ...) or a list of\n              methods to listen to. (default: `GET`)\n            :param callback: An optional shortcut to avoid the decorator\n              syntax. ``route(..., callback=func)`` equals ``route(...)(func)``\n            :param name: The name for this route. (default: None)\n            :param apply: A decorator or plugin or a list of plugins. These are\n              applied to the route callback in addition to installed plugins.\n            :param skip: A list of plugins, plugin classes or names. Matching\n              plugins are not installed to this route. ``True`` skips all.\n\n            Any additional keyword arguments are stored as route-specific\n            configuration and passed to plugins (see :meth:`Plugin.apply`).\n        \"\"\"\n        if callable(path): path, callback = None, path\n        plugins = makelist(apply)\n        skiplist = makelist(skip)\n\n        def decorator(callback):\n            if isinstance(callback, str): callback = load(callback)\n            for rule in makelist(path) or yieldroutes(callback):\n                for verb in makelist(method):\n                    verb = verb.upper()\n                    route = Route(self, rule, verb, callback,\n                                  name=name,\n                                  plugins=plugins,\n                                  skiplist=skiplist, **config)\n                    self.add_route(route)\n            return callback\n\n        return decorator(callback) if callback else decorator\n\n    def get(self, path=None, method='GET', **options):\n        \"\"\" Equals :meth:`route`. \"\"\"\n        return self.route(path, method, **options)\n\n    def post(self, path=None, method='POST', **options):\n        \"\"\" Equals :meth:`route` with a ``POST`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def put(self, path=None, method='PUT', **options):\n        \"\"\" Equals :meth:`route` with a ``PUT`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def delete(self, path=None, method='DELETE', **options):\n        \"\"\" Equals :meth:`route` with a ``DELETE`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def patch(self, path=None, method='PATCH', **options):\n        \"\"\" Equals :meth:`route` with a ``PATCH`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def error(self, code=500, callback=None):\n        \"\"\" Register an output handler for a HTTP error code. Can\n            be used as a decorator or called directly ::\n\n                def error_handler_500(error):\n                    return 'error_handler_500'\n\n                app.error(code=500, callback=error_handler_500)\n\n                @app.error(404)\n                def error_handler_404(error):\n                    return 'error_handler_404'\n\n        \"\"\"\n\n        def decorator(callback):\n            if isinstance(callback, str): callback = load(callback)\n            self.error_handler[int(code)] = callback\n            return callback\n\n        return decorator(callback) if callback else decorator\n\n    def default_error_handler(self, res):\n        return tob(template(ERROR_PAGE_TEMPLATE, e=res, template_settings=dict(name='__ERROR_PAGE_TEMPLATE')))\n\n    def _handle(self, environ):\n        path = environ['bottle.raw_path'] = environ['PATH_INFO']\n        environ['PATH_INFO'] = _wsgi_recode(path)\n\n        environ['bottle.app'] = self\n        request.bind(environ)\n        response.bind()\n\n        try:\n            out = None\n            try:\n                self.trigger_hook('before_request')\n                route, args = self.router.match(environ)\n                environ['route.handle'] = route\n                environ['bottle.route'] = route\n                environ['route.url_args'] = args\n                out = route.call(**args)\n            except HTTPResponse as E:\n                out = E\n            finally:\n                if isinstance(out, HTTPResponse):\n                    out.apply(response)\n                try:\n                    self.trigger_hook('after_request')\n                except HTTPResponse as E:\n                    out = E\n                    out.apply(response)\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as E:\n            if not self.catchall: raise\n            stacktrace = format_exc()\n            environ['wsgi.errors'].write(stacktrace)\n            environ['wsgi.errors'].flush()\n            environ['bottle.exc_info'] = sys.exc_info()\n            out = HTTPError(500, \"Internal Server Error\", E, stacktrace)\n            out.apply(response)\n\n        return out\n\n    def _cast(self, out, peek=None):\n        \"\"\" Try to convert the parameter into something WSGI compatible and set\n        correct HTTP headers when possible.\n        Support: False, bytes/bytearray, str, dict, HTTPResponse, HTTPError, file-like,\n        iterable of bytes/bytearray or str instances.\n        \"\"\"\n\n        # Empty output is done here\n        if not out:\n            if 'Content-Length' not in response:\n                response['Content-Length'] = 0\n            return []\n        # Join lists of byte or unicode strings. Mixed lists are NOT supported\n        if isinstance(out, (tuple, list))\\\n        and isinstance(out[0], (bytes, str)):\n            out = out[0][0:0].join(out)  # b'abc'[0:0] -> b''\n        # Encode unicode strings\n        if isinstance(out, str):\n            out = out.encode(response.charset)\n        # Byte Strings are just returned\n        if isinstance(out, bytes):\n            if 'Content-Length' not in response:\n                response['Content-Length'] = len(out)\n            return [out]\n        # HTTPError or HTTPException (recursive, because they may wrap anything)\n        # TODO: Handle these explicitly in handle() or make them iterable.\n        if isinstance(out, HTTPError):\n            out.apply(response)\n            out = self.error_handler.get(out.status_code,\n                                         self.default_error_handler)(out)\n            return self._cast(out)\n        if isinstance(out, HTTPResponse):\n            out.apply(response)\n            return self._cast(out.body)\n\n        # File-like objects.\n        if hasattr(out, 'read'):\n            if 'wsgi.file_wrapper' in request.environ:\n                return request.environ['wsgi.file_wrapper'](out)\n            elif hasattr(out, 'close') or not hasattr(out, '__iter__'):\n                return WSGIFileWrapper(out)\n\n        # Handle Iterables. We peek into them to detect their inner type.\n        try:\n            iout = iter(out)\n            first = next(iout)\n            while not first:\n                first = next(iout)\n        except StopIteration:\n            return self._cast('')\n        except HTTPResponse as E:\n            first = E\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as error:\n            if not self.catchall: raise\n            first = HTTPError(500, 'Unhandled exception', error, format_exc())\n\n        # These are the inner types allowed in iterator or generator objects.\n        if isinstance(first, HTTPResponse):\n            return self._cast(first)\n        elif isinstance(first, bytes):\n            new_iter = itertools.chain([first], iout)\n        elif isinstance(first, str):\n            encoder = lambda x: x.encode(response.charset)\n            new_iter = map(encoder, itertools.chain([first], iout))\n        else:\n            msg = 'Unsupported response type: %s' % type(first)\n            return self._cast(HTTPError(500, msg))\n        if hasattr(out, 'close'):\n            new_iter = _closeiter(new_iter, out.close)\n        return new_iter\n\n    def wsgi(self, environ, start_response):\n        \"\"\" The bottle WSGI-interface. \"\"\"\n        try:\n            out = self._cast(self._handle(environ))\n            # rfc2616 section 4.3\n            if response._status_code in (100, 101, 204, 304)\\\n            or environ['REQUEST_METHOD'] == 'HEAD':\n                if hasattr(out, 'close'): out.close()\n                out = []\n            exc_info = environ.get('bottle.exc_info')\n            if exc_info is not None:\n                del environ['bottle.exc_info']\n            start_response(response._wsgi_status_line(), response.headerlist, exc_info)\n            return out\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as E:\n            if not self.catchall: raise\n            err = '<h1>Critical error while processing request: %s</h1>' \\\n                  % html_escape(environ.get('PATH_INFO', '/'))\n            if DEBUG:\n                err += '<h2>Error:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       '<h2>Traceback:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       % (html_escape(repr(E)), html_escape(format_exc()))\n            environ['wsgi.errors'].write(err)\n            environ['wsgi.errors'].flush()\n            headers = [('Content-Type', 'text/html; charset=UTF-8')]\n            start_response('500 INTERNAL SERVER ERROR', headers, sys.exc_info())\n            return [tob(err)]\n\n    def __call__(self, environ, start_response):\n        \"\"\" Each instance of :class:'Bottle' is a WSGI application. \"\"\"\n        return self.wsgi(environ, start_response)\n\n    def __enter__(self):\n        \"\"\" Use this application as default for all module-level shortcuts. \"\"\"\n        default_app.push(self)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        default_app.pop()\n\n    def __setattr__(self, name, value):\n        if name in self.__dict__:\n            raise AttributeError(\"Attribute %s already defined. Plugin conflict?\" % name)\n        object.__setattr__(self, name, value)\n\n###############################################################################\n# HTTP and WSGI Tools ##########################################################\n###############################################################################\n\n\nclass BaseRequest(object):\n    \"\"\" A wrapper for WSGI environment dictionaries that adds a lot of\n        convenient access methods and properties. Most of them are read-only.\n\n        Adding new attributes to a request actually adds them to the environ\n        dictionary (as 'bottle.request.ext.<name>'). This is the recommended\n        way to store and access request-specific data.\n    \"\"\"\n\n    __slots__ = ('environ', )\n\n    #: Maximum size of memory buffer for :attr:`body` in bytes.\n    MEMFILE_MAX = 102400\n\n    def __init__(self, environ=None):\n        \"\"\" Wrap a WSGI environ dictionary. \"\"\"\n        #: The wrapped WSGI environ dictionary. This is the only real attribute.\n        #: All other attributes actually are read-only properties.\n        self.environ = {} if environ is None else environ\n        self.environ['bottle.request'] = self\n\n    @DictProperty('environ', 'bottle.app', read_only=True)\n    def app(self):\n        \"\"\" Bottle application handling this request. \"\"\"\n        raise RuntimeError('This request is not connected to an application.')\n\n    @DictProperty('environ', 'bottle.route', read_only=True)\n    def route(self):\n        \"\"\" The bottle :class:`Route` object that matches this request. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @DictProperty('environ', 'route.url_args', read_only=True)\n    def url_args(self):\n        \"\"\" The arguments extracted from the URL. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @property\n    def path(self):\n        \"\"\" The value of ``PATH_INFO`` with exactly one prefixed slash (to fix\n            broken clients and avoid the \"empty path\" edge case). \"\"\"\n        return '/' + self.environ.get('PATH_INFO', '').lstrip('/')\n\n    @property\n    def method(self):\n        \"\"\" The ``REQUEST_METHOD`` value as an uppercase string. \"\"\"\n        return self.environ.get('REQUEST_METHOD', 'GET').upper()\n\n    @DictProperty('environ', 'bottle.request.headers', read_only=True)\n    def headers(self):\n        \"\"\" A :class:`WSGIHeaderDict` that provides case-insensitive access to\n            HTTP request headers. \"\"\"\n        return WSGIHeaderDict(self.environ)\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a request header, or a given default value. \"\"\"\n        return self.headers.get(name, default)\n\n    @DictProperty('environ', 'bottle.request.cookies', read_only=True)\n    def cookies(self):\n        \"\"\" Cookies parsed into a :class:`FormsDict`. Signed cookies are NOT\n            decoded. Use :meth:`get_cookie` if you expect signed cookies. \"\"\"\n        cookie_header = _wsgi_recode(self.environ.get('HTTP_COOKIE', ''))\n        cookies = SimpleCookie(cookie_header).values()\n        return FormsDict((c.key, c.value) for c in cookies)\n\n    def get_cookie(self, key, default=None, secret=None, digestmod=hashlib.sha256):\n        \"\"\" Return the content of a cookie. To read a `Signed Cookie`, the\n            `secret` must match the one used to create the cookie (see\n            :meth:`Response.set_cookie <BaseResponse.set_cookie>`). If anything goes wrong (missing\n            cookie or wrong signature), return a default value. \"\"\"\n        value = self.cookies.get(key)\n        if secret:\n            # See BaseResponse.set_cookie for details on signed cookies.\n            if value and value.startswith('!') and '?' in value:\n                sig, msg = map(tob, value[1:].split('?', 1))\n                hash = hmac.new(tob(secret), msg, digestmod=digestmod).digest()\n                if _lscmp(sig, base64.b64encode(hash)):\n                    dst = pickle.loads(base64.b64decode(msg))\n                    if dst and dst[0] == key:\n                        return dst[1]\n            return default\n        return value or default\n\n    @DictProperty('environ', 'bottle.request.query', read_only=True)\n    def query(self):\n        \"\"\" The :attr:`query_string` parsed into a :class:`FormsDict`. These\n            values are sometimes called \"URL arguments\" or \"GET parameters\", but\n            not to be confused with \"URL wildcards\" as they are provided by the\n            :class:`Router`. \"\"\"\n        get = self.environ['bottle.get'] = FormsDict()\n        pairs = _parse_qsl(self.environ.get('QUERY_STRING', ''), 'utf8')\n        for key, value in pairs:\n            get[key] = value\n        return get\n\n    @DictProperty('environ', 'bottle.request.forms', read_only=True)\n    def forms(self):\n        \"\"\" Form values parsed from an `url-encoded` or `multipart/form-data`\n            encoded POST or PUT request body. The result is returned as a\n            :class:`FormsDict`. All keys and values are strings. File uploads\n            are stored separately in :attr:`files`. \"\"\"\n        forms = FormsDict()\n        for name, item in self.POST.allitems():\n            if not isinstance(item, FileUpload):\n                forms[name] = item\n        return forms\n\n    @DictProperty('environ', 'bottle.request.params', read_only=True)\n    def params(self):\n        \"\"\" A :class:`FormsDict` with the combined values of :attr:`query` and\n            :attr:`forms`. File uploads are stored in :attr:`files`. \"\"\"\n        params = FormsDict()\n        for key, value in self.query.allitems():\n            params[key] = value\n        for key, value in self.forms.allitems():\n            params[key] = value\n        return params\n\n    @DictProperty('environ', 'bottle.request.files', read_only=True)\n    def files(self):\n        \"\"\" File uploads parsed from `multipart/form-data` encoded POST or PUT\n            request body. The values are instances of :class:`FileUpload`.\n\n        \"\"\"\n        files = FormsDict()\n        for name, item in self.POST.allitems():\n            if isinstance(item, FileUpload):\n                files[name] = item\n        return files\n\n    @DictProperty('environ', 'bottle.request.json', read_only=True)\n    def json(self):\n        \"\"\" If the ``Content-Type`` header is ``application/json`` or\n            ``application/json-rpc``, this property holds the parsed content\n            of the request body. Only requests smaller than :attr:`MEMFILE_MAX`\n            are processed to avoid memory exhaustion.\n            Invalid JSON raises a 400 error response.\n        \"\"\"\n        ctype = self.environ.get('CONTENT_TYPE', '').lower().split(';')[0]\n        if ctype in ('application/json', 'application/json-rpc'):\n            b = self._get_body_string(self.MEMFILE_MAX)\n            if not b:\n                return None\n            try:\n                return json_loads(b)\n            except (ValueError, TypeError) as err:\n                raise HTTPError(400, 'Invalid JSON', exception=err)\n        return None\n\n    def _iter_body(self, read, bufsize):\n        maxread = max(0, self.content_length)\n        while maxread:\n            part = read(min(maxread, bufsize))\n            if not part: break\n            yield part\n            maxread -= len(part)\n\n    @staticmethod\n    def _iter_chunked(read, bufsize):\n        err = HTTPError(400, 'Error while parsing chunked transfer body.')\n        rn, sem, bs = b'\\r\\n', b';', b''\n        while True:\n            header = read(1)\n            while header[-2:] != rn:\n                c = read(1)\n                header += c\n                if not c: raise err\n                if len(header) > bufsize: raise err\n            size, _, _ = header.partition(sem)\n            try:\n                maxread = int(size.strip(), 16)\n            except ValueError:\n                raise err\n            if maxread == 0: break\n            buff = bs\n            while maxread > 0:\n                if not buff:\n                    buff = read(min(maxread, bufsize))\n                part, buff = buff[:maxread], buff[maxread:]\n                if not part: raise err\n                yield part\n                maxread -= len(part)\n            if read(2) != rn:\n                raise err\n\n    @DictProperty('environ', 'bottle.request.body', read_only=True)\n    def _body(self):\n        try:\n            read_func = self.environ['wsgi.input'].read\n        except KeyError:\n            self.environ['wsgi.input'] = BytesIO()\n            return self.environ['wsgi.input']\n        body_iter = self._iter_chunked if self.chunked else self._iter_body\n        body, body_size, is_temp_file = BytesIO(), 0, False\n        for part in body_iter(read_func, self.MEMFILE_MAX):\n            body.write(part)\n            body_size += len(part)\n            if not is_temp_file and body_size > self.MEMFILE_MAX:\n                body, tmp = NamedTemporaryFile(mode='w+b'), body\n                body.write(tmp.getvalue())\n                del tmp\n                is_temp_file = True\n        self.environ['wsgi.input'] = body\n        body.seek(0)\n        return body\n\n    def _get_body_string(self, maxread):\n        \"\"\" Read body into a string. Raise HTTPError(413) on requests that are\n            too large. \"\"\"\n        if self.content_length > maxread:\n            raise HTTPError(413, 'Request entity too large')\n        data = self.body.read(maxread + 1)\n        if len(data) > maxread:\n            raise HTTPError(413, 'Request entity too large')\n        return data\n\n    @property\n    def body(self):\n        \"\"\" The HTTP request body as a seek-able file-like object. Depending on\n            :attr:`MEMFILE_MAX`, this is either a temporary file or a\n            :class:`io.BytesIO` instance. Accessing this property for the first\n            time reads and replaces the ``wsgi.input`` environ variable.\n            Subsequent accesses just do a `seek(0)` on the file object. \"\"\"\n        self._body.seek(0)\n        return self._body\n\n    @property\n    def chunked(self):\n        \"\"\" True if Chunked transfer encoding was. \"\"\"\n        return 'chunked' in self.environ.get(\n            'HTTP_TRANSFER_ENCODING', '').lower()\n\n    #: An alias for :attr:`query`.\n    GET = query\n\n    @DictProperty('environ', 'bottle.request.post', read_only=True)\n    def POST(self):\n        \"\"\" The values of :attr:`forms` and :attr:`files` combined into a single\n            :class:`FormsDict`. Values are either strings (form values) or\n            instances of :class:`FileUpload`.\n        \"\"\"\n        post = FormsDict()\n        content_type = self.environ.get('CONTENT_TYPE', '')\n        content_type, options = _parse_http_header(content_type)[0]\n        # We default to application/x-www-form-urlencoded for everything that\n        # is not multipart and take the fast path (also: 3.1 workaround)\n        if not content_type.startswith('multipart/'):\n            body = self._get_body_string(self.MEMFILE_MAX).decode('utf8', 'surrogateescape')\n            for key, value in _parse_qsl(body, 'utf8'):\n                post[key] = value\n            return post\n\n        charset = options.get(\"charset\", \"utf8\")\n        boundary = options.get(\"boundary\")\n        if not boundary:\n            raise MultipartError(\"Invalid content type header, missing boundary\")\n        parser = _MultipartParser(self.body, boundary, self.content_length,\n            mem_limit=self.MEMFILE_MAX, memfile_limit=self.MEMFILE_MAX,\n            charset=charset)\n\n        for part in parser.parse():\n            if not part.filename and part.is_buffered():\n                post[part.name] = part.value\n            else:\n                post[part.name] = FileUpload(part.file, part.name,\n                                            part.filename, part.headerlist)\n\n        return post\n\n    @property\n    def url(self):\n        \"\"\" The full request URI including hostname and scheme. If your app\n            lives behind a reverse proxy or load balancer and you get confusing\n            results, make sure that the ``X-Forwarded-Host`` header is set\n            correctly. \"\"\"\n        return self.urlparts.geturl()\n\n    @DictProperty('environ', 'bottle.request.urlparts', read_only=True)\n    def urlparts(self):\n        \"\"\" The :attr:`url` string as an :class:`urlparse.SplitResult` tuple.\n            The tuple contains (scheme, host, path, query_string and fragment),\n            but the fragment is always empty because it is not visible to the\n            server. \"\"\"\n        env = self.environ\n        http = env.get('HTTP_X_FORWARDED_PROTO') \\\n             or env.get('wsgi.url_scheme', 'http')\n        host = env.get('HTTP_X_FORWARDED_HOST') or env.get('HTTP_HOST')\n        if not host:\n            # HTTP 1.1 requires a Host-header. This is for HTTP/1.0 clients.\n            host = env.get('SERVER_NAME', '127.0.0.1')\n            port = env.get('SERVER_PORT')\n            if port and port != ('80' if http == 'http' else '443'):\n                host += ':' + port\n        path = urlquote(self.fullpath)\n        return UrlSplitResult(http, host, path, env.get('QUERY_STRING'), '')\n\n    @property\n    def fullpath(self):\n        \"\"\" Request path including :attr:`script_name` (if present). \"\"\"\n        return urljoin(self.script_name, self.path.lstrip('/'))\n\n    @property\n    def query_string(self):\n        \"\"\" The raw :attr:`query` part of the URL (everything in between ``?``\n            and ``#``) as a string. \"\"\"\n        return self.environ.get('QUERY_STRING', '')\n\n    @property\n    def script_name(self):\n        \"\"\" The initial portion of the URL's `path` that was removed by a higher\n            level (server or routing middleware) before the application was\n            called. This script path is returned with leading and tailing\n            slashes. \"\"\"\n        script_name = self.environ.get('SCRIPT_NAME', '').strip('/')\n        return '/' + script_name + '/' if script_name else '/'\n\n    def path_shift(self, shift=1):\n        \"\"\" Shift path segments from :attr:`path` to :attr:`script_name` and\n            vice versa.\n\n           :param shift: The number of path segments to shift. May be negative\n                         to change the shift direction. (default: 1)\n        \"\"\"\n        script, path = path_shift(self.environ.get('SCRIPT_NAME', '/'), self.path, shift)\n        self['SCRIPT_NAME'], self['PATH_INFO'] = script, path\n\n    @property\n    def content_length(self):\n        \"\"\" The request body length as an integer. The client is responsible to\n            set this header. Otherwise, the real length of the body is unknown\n            and -1 is returned. In this case, :attr:`body` will be empty. \"\"\"\n        return int(self.environ.get('CONTENT_LENGTH') or -1)\n\n    @property\n    def content_type(self):\n        \"\"\" The Content-Type header as a lowercase-string (default: empty). \"\"\"\n        return self.environ.get('CONTENT_TYPE', '').lower()\n\n    @property\n    def is_xhr(self):\n        \"\"\" True if the request was triggered by a XMLHttpRequest. This only\n            works with JavaScript libraries that support the `X-Requested-With`\n            header (most of the popular libraries do). \"\"\"\n        requested_with = self.environ.get('HTTP_X_REQUESTED_WITH', '')\n        return requested_with.lower() == 'xmlhttprequest'\n\n    @property\n    def is_ajax(self):\n        \"\"\" Alias for :attr:`is_xhr`. \"Ajax\" is not the right term. \"\"\"\n        return self.is_xhr\n\n    @property\n    def auth(self):\n        \"\"\" HTTP authentication data as a (user, password) tuple. This\n            implementation currently supports basic (not digest) authentication\n            only. If the authentication happened at a higher level (e.g. in the\n            front web-server or a middleware), the password field is None, but\n            the user field is looked up from the ``REMOTE_USER`` environ\n            variable. On any errors, None is returned. \"\"\"\n        basic = parse_auth(self.environ.get('HTTP_AUTHORIZATION', ''))\n        if basic: return basic\n        ruser = self.environ.get('REMOTE_USER')\n        if ruser: return (ruser, None)\n        return None\n\n    @property\n    def remote_route(self):\n        \"\"\" A list of all IPs that were involved in this request, starting with\n            the client IP and followed by zero or more proxies. This does only\n            work if all proxies support the ```X-Forwarded-For`` header. Note\n            that this information can be forged by malicious clients. \"\"\"\n        proxy = self.environ.get('HTTP_X_FORWARDED_FOR')\n        if proxy: return [ip.strip() for ip in proxy.split(',')]\n        remote = self.environ.get('REMOTE_ADDR')\n        return [remote] if remote else []\n\n    @property\n    def remote_addr(self):\n        \"\"\" The client IP as a string. Note that this information can be forged\n            by malicious clients. \"\"\"\n        route = self.remote_route\n        return route[0] if route else None\n\n    def copy(self):\n        \"\"\" Return a new :class:`Request` with a shallow :attr:`environ` copy. \"\"\"\n        return Request(self.environ.copy())\n\n    def get(self, key, default=None):\n        return self.environ.get(key, default)\n\n    def __getitem__(self, key):\n        return self.environ[key]\n\n    def __delitem__(self, key):\n        self[key] = \"\"\n        del (self.environ[key])\n\n    def __iter__(self):\n        return iter(self.environ)\n\n    def __len__(self):\n        return len(self.environ)\n\n    def keys(self):\n        return self.environ.keys()\n\n    def __setitem__(self, key, value):\n        \"\"\" Change an environ value and clear all caches that depend on it. \"\"\"\n\n        if self.environ.get('bottle.request.readonly'):\n            raise KeyError('The environ dictionary is read-only.')\n\n        self.environ[key] = value\n        todelete = ()\n\n        if key == 'wsgi.input':\n            todelete = ('body', 'forms', 'files', 'params', 'post', 'json')\n        elif key == 'QUERY_STRING':\n            todelete = ('query', 'params')\n        elif key.startswith('HTTP_'):\n            todelete = ('headers', 'cookies')\n\n        for key in todelete:\n            self.environ.pop('bottle.request.' + key, None)\n\n    def __repr__(self):\n        return '<%s: %s %s>' % (self.__class__.__name__, self.method, self.url)\n\n    def __getattr__(self, name):\n        \"\"\" Search in self.environ for additional user defined attributes. \"\"\"\n        try:\n            var = self.environ['bottle.request.ext.%s' % name]\n            return var.__get__(self) if hasattr(var, '__get__') else var\n        except KeyError:\n            raise AttributeError('Attribute %r not defined.' % name)\n\n    def __setattr__(self, name, value):\n        \"\"\" Define new attributes that are local to the bound request environment. \"\"\"\n        if name == 'environ': return object.__setattr__(self, name, value)\n        key = 'bottle.request.ext.%s' % name\n        if hasattr(self, name):\n            raise AttributeError(\"Attribute already defined: %s\" % name)\n        self.environ[key] = value\n\n    def __delattr__(self, name):\n        try:\n            del self.environ['bottle.request.ext.%s' % name]\n        except KeyError:\n            raise AttributeError(\"Attribute not defined: %s\" % name)\n\n\ndef _hkey(key):\n    key = touni(key)\n    if '\\n' in key or '\\r' in key or '\\0' in key:\n        raise ValueError(\"Header names must not contain control characters: %r\" % key)\n    return key.title().replace('_', '-')\n\n\ndef _hval(value):\n    value = touni(value)\n    if '\\n' in value or '\\r' in value or '\\0' in value:\n        raise ValueError(\"Header value must not contain control characters: %r\" % value)\n    return value\n\n\nclass HeaderProperty(object):\n    def __init__(self, name, reader=None, writer=None, default=''):\n        self.name, self.default = name, default\n        self.reader, self.writer = reader, writer\n        self.__doc__ = 'Current value of the %r header.' % name.title()\n\n    def __get__(self, obj, _):\n        if obj is None: return self\n        value = obj.get_header(self.name, self.default)\n        return self.reader(value) if self.reader else value\n\n    def __set__(self, obj, value):\n        obj[self.name] = self.writer(value) if self.writer else value\n\n    def __delete__(self, obj):\n        del obj[self.name]\n\n\nclass BaseResponse(object):\n    \"\"\" Storage class for a response body as well as headers and cookies.\n\n        This class does support dict-like case-insensitive item-access to\n        headers, but is NOT a dict. Most notably, iterating over a response\n        yields parts of the body and not the headers.\n    \"\"\"\n\n    default_status = 200\n    default_content_type = 'text/html; charset=UTF-8'\n\n    # Header denylist for specific response codes\n    # (rfc2616 section 10.2.3 and 10.3.5)\n    bad_headers = {\n        204: frozenset(('Content-Type', 'Content-Length')),\n        304: frozenset(('Allow', 'Content-Encoding', 'Content-Language',\n                  'Content-Length', 'Content-Range', 'Content-Type',\n                  'Content-Md5', 'Last-Modified'))\n    }\n\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        \"\"\" Create a new response object.\n\n        :param body: The response body as one of the supported types.\n        :param status: Either an HTTP status code (e.g. 200) or a status line\n                       including the reason phrase (e.g. '200 OK').\n        :param headers: A dictionary or a list of name-value pairs.\n\n        Additional keyword arguments are added to the list of headers.\n        Underscores in the header name are replaced with dashes.\n        \"\"\"\n        self._cookies = None\n        self._headers = {}\n        self.body = body\n        self.status = status or self.default_status\n        if headers:\n            if isinstance(headers, dict):\n                headers = headers.items()\n            for name, value in headers:\n                self.add_header(name, value)\n        if more_headers:\n            for name, value in more_headers.items():\n                self.add_header(name, value)\n\n    def copy(self, cls=None):\n        \"\"\" Returns a copy of self. \"\"\"\n        cls = cls or BaseResponse\n        assert issubclass(cls, BaseResponse)\n        copy = cls()\n        copy.status = self.status\n        copy._headers = dict((k, v[:]) for (k, v) in self._headers.items())\n        if self._cookies:\n            cookies = copy._cookies = SimpleCookie()\n            for k,v in self._cookies.items():\n                cookies[k] = v.value\n                cookies[k].update(v) # also copy cookie attributes\n        return copy\n\n    def __iter__(self):\n        return iter(self.body)\n\n    def close(self):\n        if hasattr(self.body, 'close'):\n            self.body.close()\n\n    @property\n    def status_line(self):\n        \"\"\" The HTTP status line as a string (e.g. ``404 Not Found``).\"\"\"\n        return self._status_line\n\n    @property\n    def status_code(self):\n        \"\"\" The HTTP status code as an integer (e.g. 404).\"\"\"\n        return self._status_code\n\n    def _set_status(self, status):\n        if isinstance(status, int):\n            code, status = status, _HTTP_STATUS_LINES.get(status)\n        elif ' ' in status:\n            if '\\n' in status or '\\r' in status or '\\0' in status:\n                raise ValueError('Status line must not include control chars.')\n            status = status.strip()\n            code = int(status.split()[0])\n        else:\n            raise ValueError('String status line without a reason phrase.')\n        if not 100 <= code <= 999:\n            raise ValueError('Status code out of range.')\n        self._status_code = code\n        self._status_line = str(status or ('%d Unknown' % code))\n\n    def _get_status(self):\n        return self._status_line\n\n    status = property(\n        _get_status, _set_status, None,\n        ''' A writeable property to change the HTTP response status. It accepts\n            either a numeric code (100-999) or a string with a custom reason\n            phrase (e.g. \"404 Brain not found\"). Both :data:`status_line` and\n            :data:`status_code` are updated accordingly. The return value is\n            always a status string. ''')\n    del _get_status, _set_status\n\n    @property\n    def headers(self):\n        \"\"\" An instance of :class:`HeaderDict`, a case-insensitive dict-like\n            view on the response headers. \"\"\"\n        hdict = HeaderDict()\n        hdict.dict = self._headers\n        return hdict\n\n    def __contains__(self, name):\n        return _hkey(name) in self._headers\n\n    def __delitem__(self, name):\n        del self._headers[_hkey(name)]\n\n    def __getitem__(self, name):\n        return self._headers[_hkey(name)][-1]\n\n    def __setitem__(self, name, value):\n        self._headers[_hkey(name)] = [_hval(value)]\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a previously defined header. If there is no\n            header with that name, return a default value. \"\"\"\n        return self._headers.get(_hkey(name), [default])[-1]\n\n    def set_header(self, name, value):\n        \"\"\" Create a new response header, replacing any previously defined\n            headers with the same name. \"\"\"\n        self._headers[_hkey(name)] = [_hval(value)]\n\n    def add_header(self, name, value):\n        \"\"\" Add an additional response header, not removing duplicates. \"\"\"\n        self._headers.setdefault(_hkey(name), []).append(_hval(value))\n\n    def iter_headers(self):\n        \"\"\" Yield (header, value) tuples, skipping headers that are not\n            allowed with the current response status code. \"\"\"\n        return self.headerlist\n\n    def _wsgi_status_line(self):\n        \"\"\" WSGI conform status line (latin1-encodeable) \"\"\"\n        return self._status_line.encode('utf8', 'surrogateescape').decode('latin1')\n\n    @property\n    def headerlist(self):\n        \"\"\" WSGI conform list of (header, value) tuples. \"\"\"\n        out = []\n        headers = list(self._headers.items())\n        if 'Content-Type' not in self._headers:\n            headers.append(('Content-Type', [self.default_content_type]))\n        if self._status_code in self.bad_headers:\n            bad_headers = self.bad_headers[self._status_code]\n            headers = [h for h in headers if h[0] not in bad_headers]\n        out += [(name, val) for (name, vals) in headers for val in vals]\n        if self._cookies:\n            for c in self._cookies.values():\n                out.append(('Set-Cookie', _hval(c.OutputString())))\n        out = [(k, v.encode('utf8', 'surrogateescape').decode('latin1')) for (k, v) in out]\n        return out\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int, default=-1)\n    expires = HeaderProperty(\n        'Expires',\n        reader=lambda x: datetime.fromtimestamp(parse_date(x), UTC),\n        writer=lambda x: http_date(x))\n\n    @property\n    def charset(self, default='UTF-8'):\n        \"\"\" Return the charset specified in the content-type header (default: utf8). \"\"\"\n        if 'charset=' in self.content_type:\n            return self.content_type.split('charset=')[-1].split(';')[0].strip()\n        return default\n\n    def set_cookie(self, name, value, secret=None, digestmod=hashlib.sha256, **options):\n        \"\"\" Create a new cookie or replace an old one. If the `secret` parameter is\n            set, create a `Signed Cookie` (described below).\n\n            :param name: the name of the cookie.\n            :param value: the value of the cookie.\n            :param secret: a signature key required for signed cookies.\n\n            Additionally, this method accepts all RFC 2109 attributes that are\n            supported by :class:`cookie.Morsel`, including:\n\n            :param maxage: maximum age in seconds. (default: None)\n            :param expires: a datetime object or UNIX timestamp. (default: None)\n            :param domain: the domain that is allowed to read the cookie.\n              (default: current domain)\n            :param path: limits the cookie to a given path (default: current path)\n            :param secure: limit the cookie to HTTPS connections (default: off).\n            :param httponly: prevents client-side javascript to read this cookie\n              (default: off, requires Python 2.6 or newer).\n            :param samesite: Control or disable third-party use for this cookie.\n              Possible values: `lax`, `strict` or `none` (default).\n\n            If neither `expires` nor `maxage` is set (default), the cookie will\n            expire at the end of the browser session (as soon as the browser\n            window is closed).\n\n            Signed cookies may store any pickle-able object and are\n            cryptographically signed to prevent manipulation. Keep in mind that\n            cookies are limited to 4kb in most browsers.\n\n            Warning: Pickle is a potentially dangerous format. If an attacker\n            gains access to the secret key, he could forge cookies that execute\n            code on server side if unpickled. Using pickle is discouraged and\n            support for it will be removed in later versions of bottle.\n\n            Warning: Signed cookies are not encrypted (the client can still see\n            the content) and not copy-protected (the client can restore an old\n            cookie). The main intention is to make pickling and unpickling\n            save, not to store secret information at client side.\n        \"\"\"\n        if not self._cookies:\n            self._cookies = SimpleCookie()\n\n        # Monkey-patch Cookie lib to support 'SameSite' parameter\n        # https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1\n        if py < (3, 8, 0):\n            Morsel._reserved.setdefault('samesite', 'SameSite')\n\n        if secret:\n            if not isinstance(value, str):\n                depr(0, 13, \"Pickling of arbitrary objects into cookies is \"\n                            \"deprecated.\", \"Only store strings in cookies. \"\n                            \"JSON strings are fine, too.\")\n            encoded = base64.b64encode(pickle.dumps([name, value], -1))\n            sig = base64.b64encode(hmac.new(tob(secret), encoded,\n                                            digestmod=digestmod).digest())\n            value = touni(b'!' + sig + b'?' + encoded)\n        elif not isinstance(value, str):\n            raise TypeError('Secret key required for non-string cookies.')\n\n        # Cookie size plus options must not exceed 4kb.\n        if len(name) + len(value) > 3800:\n            raise ValueError('Content does not fit into a cookie.')\n\n        self._cookies[name] = value\n\n        for key, value in options.items():\n            if key in ('max_age', 'maxage'): # 'maxage' variant added in 0.13\n                key = 'max-age'\n                if isinstance(value, timedelta):\n                    value = value.seconds + value.days * 24 * 3600\n            if key == 'expires':\n                value = http_date(value)\n            if key in ('same_site', 'samesite'): # 'samesite' variant added in 0.13\n                key, value = 'samesite', (value or \"none\").lower()\n                if value not in ('lax', 'strict', 'none'):\n                    raise CookieError(\"Invalid value for SameSite\")\n            if key in ('secure', 'httponly') and not value:\n                continue\n            self._cookies[name][key] = value\n\n    def delete_cookie(self, key, **kwargs):\n        \"\"\" Delete a cookie. Be sure to use the same `domain` and `path`\n            settings as used to create the cookie. \"\"\"\n        kwargs['max_age'] = -1\n        kwargs['expires'] = 0\n        self.set_cookie(key, '', **kwargs)\n\n    def __repr__(self):\n        out = ''\n        for name, value in self.headerlist:\n            out += '%s: %s\\n' % (name.title(), value.strip())\n        return out\n\n\ndef _local_property():\n    ls = threading.local()\n\n    def fget(_):\n        try:\n            return ls.var\n        except AttributeError:\n            raise RuntimeError(\"Request context not initialized.\")\n\n    def fset(_, value):\n        ls.var = value\n\n    def fdel(_):\n        del ls.var\n\n    return property(fget, fset, fdel, 'Thread-local property')\n\n\nclass LocalRequest(BaseRequest):\n    \"\"\" A thread-local subclass of :class:`BaseRequest` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`request`). If accessed during a\n        request/response cycle, this instance always refers to the *current*\n        request (even on a multithreaded server). \"\"\"\n    bind = BaseRequest.__init__\n    environ = _local_property()\n\n\nclass LocalResponse(BaseResponse):\n    \"\"\" A thread-local subclass of :class:`BaseResponse` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`response`). Its attributes are used\n        to build the HTTP response at the end of the request/response cycle.\n    \"\"\"\n    bind = BaseResponse.__init__\n    _status_line = _local_property()\n    _status_code = _local_property()\n    _cookies = _local_property()\n    _headers = _local_property()\n    body = _local_property()\n\n\nRequest = BaseRequest\nResponse = BaseResponse\n\n\nclass HTTPResponse(Response, BottleException):\n    \"\"\" A subclass of :class:`Response` that can be raised or returned from request\n        handlers to short-curcuit request processing and override changes made to the\n        global :data:`request` object. This bypasses error handlers, even if the status\n        code indicates an error. Return or raise :class:`HTTPError` to trigger error\n        handlers.\n    \"\"\"\n\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        super(HTTPResponse, self).__init__(body, status, headers, **more_headers)\n\n    def apply(self, other):\n        \"\"\" Copy the state of this response to a different :class:`Response` object. \"\"\"\n        other._status_code = self._status_code\n        other._status_line = self._status_line\n        other._headers = self._headers\n        other._cookies = self._cookies\n        other.body = self.body\n\n\nclass HTTPError(HTTPResponse):\n    \"\"\" A subclass of :class:`HTTPResponse` that triggers error handlers. \"\"\"\n\n    default_status = 500\n\n    def __init__(self,\n                 status=None,\n                 body=None,\n                 exception=None,\n                 traceback=None, **more_headers):\n        self.exception = exception\n        self.traceback = traceback\n        super(HTTPError, self).__init__(body, status, **more_headers)\n\n###############################################################################\n# Plugins ######################################################################\n###############################################################################\n\n\nclass PluginError(BottleException):\n    pass\n\n\nclass JSONPlugin(object):\n    name = 'json'\n    api = 2\n\n    def __init__(self, json_dumps=json_dumps):\n        self.json_dumps = json_dumps\n\n    def setup(self, app):\n        app.config._define('json.enable', default=True, validate=bool,\n                          help=\"Enable or disable automatic dict->json filter.\")\n        app.config._define('json.ascii', default=False, validate=bool,\n                          help=\"Use only 7-bit ASCII characters in output.\")\n        app.config._define('json.indent', default=True, validate=bool,\n                          help=\"Add whitespace to make json more readable.\")\n        app.config._define('json.dump_func', default=None,\n                          help=\"If defined, use this function to transform\"\n                               \" dict into json. The other options no longer\"\n                               \" apply.\")\n\n    def apply(self, callback, route):\n        dumps = self.json_dumps\n        if not self.json_dumps: return callback\n\n        @functools.wraps(callback)\n        def wrapper(*a, **ka):\n            try:\n                rv = callback(*a, **ka)\n            except HTTPResponse as resp:\n                rv = resp\n\n            if isinstance(rv, dict):\n                # Attempt to serialize, raises exception on failure\n                json_response = dumps(rv)\n                # Set content type only if serialization successful\n                response.content_type = 'application/json'\n                return json_response\n            elif isinstance(rv, HTTPResponse) and isinstance(rv.body, dict):\n                rv.body = dumps(rv.body)\n                rv.content_type = 'application/json'\n            return rv\n\n        return wrapper\n\n\nclass TemplatePlugin(object):\n    \"\"\" This plugin applies the :func:`view` decorator to all routes with a\n        `template` config parameter. If the parameter is a tuple, the second\n        element must be a dict with additional options (e.g. `template_engine`)\n        or default variables for the template. \"\"\"\n    name = 'template'\n    api = 2\n\n    def setup(self, app):\n        app.tpl = self\n\n    def apply(self, callback, route):\n        conf = route.config.get('template')\n        if isinstance(conf, (tuple, list)) and len(conf) == 2:\n            return view(conf[0], **conf[1])(callback)\n        elif isinstance(conf, str):\n            return view(conf)(callback)\n        else:\n            return callback\n\n\n#: Not a plugin, but part of the plugin API. TODO: Find a better place.\nclass _ImportRedirect(object):\n    def __init__(self, name, impmask):\n        \"\"\" Create a virtual package that redirects imports (see PEP 302). \"\"\"\n        self.name = name\n        self.impmask = impmask\n        self.module = sys.modules.setdefault(name, new_module(name))\n        self.module.__dict__.update({\n            '__file__': __file__,\n            '__path__': [],\n            '__all__': [],\n            '__loader__': self\n        })\n        sys.meta_path.append(self)\n\n    def find_spec(self, fullname, path, target=None):\n        if '.' not in fullname: return\n        if fullname.rsplit('.', 1)[0] != self.name: return\n        from importlib.util import spec_from_loader\n        return spec_from_loader(fullname, self)\n\n    def find_module(self, fullname, path=None):\n        if '.' not in fullname: return\n        if fullname.rsplit('.', 1)[0] != self.name: return\n        return self\n\n    def create_module(self, spec):\n        return self.load_module(spec.name)\n\n    def exec_module(self, module):\n        pass # This probably breaks importlib.reload() :/\n\n    def load_module(self, fullname):\n        if fullname in sys.modules: return sys.modules[fullname]\n        modname = fullname.rsplit('.', 1)[1]\n        realname = self.impmask % modname\n        __import__(realname)\n        module = sys.modules[fullname] = sys.modules[realname]\n        setattr(self.module, modname, module)\n        module.__loader__ = self\n        return module\n\n###############################################################################\n# Common Utilities #############################################################\n###############################################################################\n\n\nclass MultiDict(DictMixin):\n    \"\"\" This dict stores multiple values per key, but behaves exactly like a\n        normal dict in that it returns only the newest value for any given key.\n        There are special methods available to access the full list of values.\n    \"\"\"\n\n    def __init__(self, *a, **k):\n        self.dict = dict((k, [v]) for (k, v) in dict(*a, **k).items())\n\n    def __len__(self):\n        return len(self.dict)\n\n    def __iter__(self):\n        return iter(self.dict)\n\n    def __contains__(self, key):\n        return key in self.dict\n\n    def __delitem__(self, key):\n        del self.dict[key]\n\n    def __getitem__(self, key):\n        return self.dict[key][-1]\n\n    def __setitem__(self, key, value):\n        self.append(key, value)\n\n    def keys(self):\n        return self.dict.keys()\n\n    def values(self):\n        return (v[-1] for v in self.dict.values())\n\n    def items(self):\n        return ((k, v[-1]) for k, v in self.dict.items())\n\n    def allitems(self):\n        return ((k, v) for k, vl in self.dict.items() for v in vl)\n\n    iterkeys = keys\n    itervalues = values\n    iteritems = items\n    iterallitems = allitems\n\n    def get(self, key, default=None, index=-1, type=None):\n        \"\"\" Return the most recent value for a key.\n\n            :param default: The default value to be returned if the key is not\n                   present or the type conversion fails.\n            :param index: An index for the list of available values.\n            :param type: If defined, this callable is used to cast the value\n                    into a specific type. Exception are suppressed and result in\n                    the default value to be returned.\n        \"\"\"\n        try:\n            val = self.dict[key][index]\n            return type(val) if type else val\n        except Exception:\n            pass\n        return default\n\n    def append(self, key, value):\n        \"\"\" Add a new value to the list of values for this key. \"\"\"\n        self.dict.setdefault(key, []).append(value)\n\n    def replace(self, key, value):\n        \"\"\" Replace the list of values with a single value. \"\"\"\n        self.dict[key] = [value]\n\n    def getall(self, key):\n        \"\"\" Return a (possibly empty) list of values for a key. \"\"\"\n        return self.dict.get(key) or []\n\n    #: Aliases for WTForms to mimic other multi-dict APIs (Django)\n    getone = get\n    getlist = getall\n\n\nclass FormsDict(MultiDict):\n    \"\"\" This :class:`MultiDict` subclass is used to store request form data.\n        Additionally to the normal dict-like item access methods, this container\n        also supports attribute-like access to its values. Missing attributes\n        default to an empty string.\n\n        .. versionchanged:: 0.14\n            All keys and values are now decoded as utf8 by default, item and\n            attribute access will return the same string.\n    \"\"\"\n\n    def decode(self, encoding=None):\n        \"\"\" (deprecated) Starting with 0.13 all keys and values are already\n            correctly decoded. \"\"\"\n        copy = FormsDict()\n        for key, value in self.allitems():\n            copy[key] = value\n        return copy\n\n    def getunicode(self, name, default=None, encoding=None):\n        \"\"\" (deprecated) Return the value as a unicode string, or the default. \"\"\"\n        return self.get(name, default)\n\n    def __getattr__(self, name, default=str()):\n        # Without this guard, pickle generates a cryptic TypeError:\n        if name.startswith('__') and name.endswith('__'):\n            return super(FormsDict, self).__getattr__(name)\n        return self.get(name, default=default)\n\nclass HeaderDict(MultiDict):\n    \"\"\" A case-insensitive version of :class:`MultiDict` that defaults to\n        replace the old value instead of appending it. \"\"\"\n\n    def __init__(self, *a, **ka):\n        self.dict = {}\n        if a or ka: self.update(*a, **ka)\n\n    def __contains__(self, key):\n        return _hkey(key) in self.dict\n\n    def __delitem__(self, key):\n        del self.dict[_hkey(key)]\n\n    def __getitem__(self, key):\n        return self.dict[_hkey(key)][-1]\n\n    def __setitem__(self, key, value):\n        self.dict[_hkey(key)] = [_hval(value)]\n\n    def append(self, key, value):\n        self.dict.setdefault(_hkey(key), []).append(_hval(value))\n\n    def replace(self, key, value):\n        self.dict[_hkey(key)] = [_hval(value)]\n\n    def getall(self, key):\n        return self.dict.get(_hkey(key)) or []\n\n    def get(self, key, default=None, index=-1):\n        return MultiDict.get(self, _hkey(key), default, index)\n\n    def filter(self, names):\n        for name in (_hkey(n) for n in names):\n            if name in self.dict:\n                del self.dict[name]\n\n\nclass WSGIHeaderDict(DictMixin):\n    \"\"\" This dict-like class wraps a WSGI environ dict and provides convenient\n        access to HTTP_* fields. Header names are case-insensitive and titled by default.\n    \"\"\"\n    #: List of keys that do not have a ``HTTP_`` prefix.\n    cgikeys = ('CONTENT_TYPE', 'CONTENT_LENGTH')\n\n    def __init__(self, environ):\n        self.environ = environ\n\n    def _ekey(self, key):\n        \"\"\" Translate header field name to CGI/WSGI environ key. \"\"\"\n        key = key.replace('-', '_').upper()\n        if key in self.cgikeys:\n            return key\n        return 'HTTP_' + key\n\n    def raw(self, key, default=None):\n        \"\"\" Return the header value as is (not utf8-translated). \"\"\"\n        return self.environ.get(self._ekey(key), default)\n\n    def __getitem__(self, key):\n        return _wsgi_recode(self.environ[self._ekey(key)])\n\n    def __setitem__(self, key, value):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __delitem__(self, key):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __iter__(self):\n        for key in self.environ:\n            if key[:5] == 'HTTP_':\n                yield _hkey(key[5:])\n            elif key in self.cgikeys:\n                yield _hkey(key)\n\n    def keys(self):\n        return [x for x in self]\n\n    def __len__(self):\n        return len(self.keys())\n\n    def __contains__(self, key):\n        return self._ekey(key) in self.environ\n\n_UNSET = object()\n\nclass ConfigDict(dict):\n    \"\"\" A dict-like configuration storage with additional support for\n        namespaces, validators, meta-data and overlays.\n\n        This dict-like class is heavily optimized for read access.\n        Read-only methods and item access should be as fast as a native dict.\n    \"\"\"\n\n    __slots__ = ('_meta', '_change_listener', '_overlays', '_virtual_keys', '_source', '__weakref__')\n\n    def __init__(self):\n        self._meta = {}\n        self._change_listener = []\n        #: Weak references of overlays that need to be kept in sync.\n        self._overlays = []\n        #: Config that is the source for this overlay.\n        self._source = None\n        #: Keys of values copied from the source (values we do not own)\n        self._virtual_keys = set()\n\n    def load_module(self, name, squash=True):\n        \"\"\"Load values from a Python module.\n\n           Import a python module by name and add all upper-case module-level\n           variables to this config dict.\n\n           :param name: Module name to import and load.\n           :param squash: If true (default), nested dicts are assumed to\n              represent namespaces and flattened (see :meth:`load_dict`).\n        \"\"\"\n        config_obj = load(name)\n        obj = {key: getattr(config_obj, key)\n               for key in dir(config_obj) if key.isupper()}\n\n        if squash:\n            self.load_dict(obj)\n        else:\n            self.update(obj)\n        return self\n\n    def load_config(self, filename, **options):\n        \"\"\" Load values from ``*.ini`` style config files using configparser.\n\n            INI style sections (e.g. ``[section]``) are used as namespace for\n            all keys within that section. Both section and key names may contain\n            dots as namespace separators and are converted to lower-case.\n\n            The special sections ``[bottle]`` and ``[ROOT]`` refer to the root\n            namespace and the ``[DEFAULT]`` section defines default values for all\n            other sections.\n\n            :param filename: The path of a config file, or a list of paths.\n            :param options: All keyword parameters are passed to the underlying\n                :class:`python:configparser.ConfigParser` constructor call.\n\n        \"\"\"\n        options.setdefault('allow_no_value', True)\n        options.setdefault('interpolation', configparser.ExtendedInterpolation())\n        conf = configparser.ConfigParser(**options)\n        conf.read(filename)\n        for section in conf.sections():\n            for key in conf.options(section):\n                value = conf.get(section, key)\n                if section not in ('bottle', 'ROOT'):\n                    key = section + '.' + key\n                self[key.lower()] = value\n        return self\n\n    def load_dict(self, source, namespace=''):\n        \"\"\" Load values from a dictionary structure. Nesting can be used to\n            represent namespaces.\n\n            >>> c = ConfigDict()\n            >>> c.load_dict({'some': {'namespace': {'key': 'value'} } })\n            {'some.namespace.key': 'value'}\n        \"\"\"\n        for key, value in source.items():\n            if isinstance(key, str):\n                nskey = (namespace + '.' + key).strip('.')\n                if isinstance(value, dict):\n                    self.load_dict(value, namespace=nskey)\n                else:\n                    self[nskey] = value\n            else:\n                raise TypeError('Key has type %r (not a string)' % type(key))\n        return self\n\n    def update(self, *a, **ka):\n        \"\"\" If the first parameter is a string, all keys are prefixed with this\n            namespace. Apart from that it works just as the usual dict.update().\n\n            >>> c = ConfigDict()\n            >>> c.update('some.namespace', key='value')\n        \"\"\"\n        prefix = ''\n        if a and isinstance(a[0], str):\n            prefix = a[0].strip('.') + '.'\n            a = a[1:]\n        for key, value in dict(*a, **ka).items():\n            self[prefix + key] = value\n\n    def setdefault(self, key, value=None):\n        if key not in self:\n            self[key] = value\n        return self[key]\n\n    def __setitem__(self, key, value):\n        if not isinstance(key, str):\n            raise TypeError('Key has type %r (not a string)' % type(key))\n\n        self._virtual_keys.discard(key)\n\n        value = self.meta_get(key, 'filter', lambda x: x)(value)\n        if key in self and self[key] is value:\n            return\n\n        self._on_change(key, value)\n        dict.__setitem__(self, key, value)\n\n        for overlay in self._iter_overlays():\n            overlay._set_virtual(key, value)\n\n    def __delitem__(self, key):\n        if key not in self:\n            raise KeyError(key)\n        if key in self._virtual_keys:\n            raise KeyError(\"Virtual keys cannot be deleted: %s\" % key)\n\n        if self._source and key in self._source:\n            # Not virtual, but present in source -> Restore virtual value\n            dict.__delitem__(self, key)\n            self._set_virtual(key, self._source[key])\n        else:  # not virtual, not present in source. This is OUR value\n            self._on_change(key, None)\n            dict.__delitem__(self, key)\n            for overlay in self._iter_overlays():\n                overlay._delete_virtual(key)\n\n    def _set_virtual(self, key, value):\n        \"\"\" Recursively set or update virtual keys. \"\"\"\n        if key in self and key not in self._virtual_keys:\n            return  # Do nothing for non-virtual keys.\n\n        self._virtual_keys.add(key)\n        if key in self and self[key] is not value:\n            self._on_change(key, value)\n        dict.__setitem__(self, key, value)\n        for overlay in self._iter_overlays():\n            overlay._set_virtual(key, value)\n\n    def _delete_virtual(self, key):\n        \"\"\" Recursively delete virtual entry. \"\"\"\n        if key not in self._virtual_keys:\n            return  # Do nothing for non-virtual keys.\n\n        if key in self:\n            self._on_change(key, None)\n        dict.__delitem__(self, key)\n        self._virtual_keys.discard(key)\n        for overlay in self._iter_overlays():\n            overlay._delete_virtual(key)\n\n    def _on_change(self, key, value):\n        for cb in self._change_listener:\n            if cb(self, key, value):\n                return True\n\n    def _add_change_listener(self, func):\n        self._change_listener.append(func)\n        return func\n\n    def meta_get(self, key, metafield, default=None):\n        \"\"\" Return the value of a meta field for a key. \"\"\"\n        return self._meta.get(key, {}).get(metafield, default)\n\n    def meta_set(self, key, metafield, value):\n        \"\"\" Set the meta field for a key to a new value.\n        \n            Meta-fields are shared between all members of an overlay tree.\n        \"\"\"\n        self._meta.setdefault(key, {})[metafield] = value\n\n    def meta_list(self, key):\n        \"\"\" Return an iterable of meta field names defined for a key. \"\"\"\n        return self._meta.get(key, {}).keys()\n\n    def _define(self, key, default=_UNSET, help=_UNSET, validate=_UNSET):\n        \"\"\" (Unstable) Shortcut for plugins to define own config parameters. \"\"\"\n        if default is not _UNSET:\n            self.setdefault(key, default)\n        if help is not _UNSET:\n            self.meta_set(key, 'help', help)\n        if validate is not _UNSET:\n            self.meta_set(key, 'validate', validate)\n\n    def _iter_overlays(self):\n        for ref in self._overlays:\n            overlay = ref()\n            if overlay is not None:\n                yield overlay\n\n    def _make_overlay(self):\n        \"\"\" (Unstable) Create a new overlay that acts like a chained map: Values\n            missing in the overlay are copied from the source map. Both maps\n            share the same meta entries.\n\n            Entries that were copied from the source are called 'virtual'. You\n            can not delete virtual keys, but overwrite them, which turns them\n            into non-virtual entries. Setting keys on an overlay never affects\n            its source, but may affect any number of child overlays.\n\n            Other than collections.ChainMap or most other implementations, this\n            approach does not resolve missing keys on demand, but instead\n            actively copies all values from the source to the overlay and keeps\n            track of virtual and non-virtual keys internally. This removes any\n            lookup-overhead. Read-access is as fast as a build-in dict for both\n            virtual and non-virtual keys.\n\n            Changes are propagated recursively and depth-first. A failing\n            on-change handler in an overlay stops the propagation of virtual\n            values and may result in an partly updated tree. Take extra care\n            here and make sure that on-change handlers never fail.\n\n            Used by Route.config\n        \"\"\"\n        # Cleanup dead references\n        self._overlays[:] = [ref for ref in self._overlays if ref() is not None]\n\n        overlay = ConfigDict()\n        overlay._meta = self._meta\n        overlay._source = self\n        self._overlays.append(weakref.ref(overlay))\n        for key in self:\n            overlay._set_virtual(key, self[key])\n        return overlay\n\n\n\n\nclass AppStack(list):\n    \"\"\" A stack-like list. Calling it returns the head of the stack. \"\"\"\n\n    def __call__(self):\n        \"\"\" Return the current default application. \"\"\"\n        return self.default\n\n    def push(self, value=None):\n        \"\"\" Add a new :class:`Bottle` instance to the stack \"\"\"\n        if not isinstance(value, Bottle):\n            value = Bottle()\n        self.append(value)\n        return value\n    new_app = push\n\n    @property\n    def default(self):\n        try:\n            return self[-1]\n        except IndexError:\n            return self.push()\n\n\nclass WSGIFileWrapper(object):\n    def __init__(self, fp, buffer_size=1024 * 64):\n        self.fp, self.buffer_size = fp, buffer_size\n        for attr in 'fileno', 'close', 'read', 'readlines', 'tell', 'seek':\n            if hasattr(fp, attr): setattr(self, attr, getattr(fp, attr))\n\n    def __iter__(self):\n        buff, read = self.buffer_size, self.read\n        part = read(buff)\n        while part:\n            yield part\n            part = read(buff)\n\n\nclass _closeiter(object):\n    \"\"\" This only exists to be able to attach a .close method to iterators that\n        do not support attribute assignment (most of itertools). \"\"\"\n\n    def __init__(self, iterator, close=None):\n        self.iterator = iterator\n        self.close_callbacks = makelist(close)\n\n    def __iter__(self):\n        return iter(self.iterator)\n\n    def close(self):\n        for func in self.close_callbacks:\n            func()\n\n\nclass ResourceManager(object):\n    \"\"\" This class manages a list of search paths and helps to find and open\n        application-bound resources (files).\n\n        :param base: default value for :meth:`add_path` calls.\n        :param opener: callable used to open resources.\n        :param cachemode: controls which lookups are cached. One of 'all',\n                         'found' or 'none'.\n    \"\"\"\n\n    def __init__(self, base='./', opener=open, cachemode='all'):\n        self.opener = opener\n        self.base = base\n        self.cachemode = cachemode\n\n        #: A list of search paths. See :meth:`add_path` for details.\n        self.path = []\n        #: A cache for resolved paths. ``res.cache.clear()`` clears the cache.\n        self.cache = {}\n\n    def add_path(self, path, base=None, index=None, create=False):\n        \"\"\" Add a new path to the list of search paths. Return False if the\n            path does not exist.\n\n            :param path: The new search path. Relative paths are turned into\n                an absolute and normalized form. If the path looks like a file\n                (not ending in `/`), the filename is stripped off.\n            :param base: Path used to absolutize relative search paths.\n                Defaults to :attr:`base` which defaults to ``os.getcwd()``.\n            :param index: Position within the list of search paths. Defaults\n                to last index (appends to the list).\n\n            The `base` parameter makes it easy to reference files installed\n            along with a python module or package::\n\n                res.add_path('./resources/', __file__)\n        \"\"\"\n        base = os.path.abspath(os.path.dirname(base or self.base))\n        path = os.path.abspath(os.path.join(base, os.path.dirname(path)))\n        path += os.sep\n        if path in self.path:\n            self.path.remove(path)\n        if create and not os.path.isdir(path):\n            os.makedirs(path)\n        if index is None:\n            self.path.append(path)\n        else:\n            self.path.insert(index, path)\n        self.cache.clear()\n        return os.path.exists(path)\n\n    def __iter__(self):\n        \"\"\" Iterate over all existing files in all registered paths. \"\"\"\n        search = self.path[:]\n        while search:\n            path = search.pop()\n            if not os.path.isdir(path): continue\n            for name in os.listdir(path):\n                full = os.path.join(path, name)\n                if os.path.isdir(full): search.append(full)\n                else: yield full\n\n    def lookup(self, name):\n        \"\"\" Search for a resource and return an absolute file path, or `None`.\n\n            The :attr:`path` list is searched in order. The first match is\n            returned. Symlinks are followed. The result is cached to speed up\n            future lookups. \"\"\"\n        if name not in self.cache or DEBUG:\n            for path in self.path:\n                fpath = os.path.join(path, name)\n                if os.path.isfile(fpath):\n                    if self.cachemode in ('all', 'found'):\n                        self.cache[name] = fpath\n                    return fpath\n            if self.cachemode == 'all':\n                self.cache[name] = None\n        return self.cache[name]\n\n    def open(self, name, mode='r', *args, **kwargs):\n        \"\"\" Find a resource and return a file object, or raise IOError. \"\"\"\n        fname = self.lookup(name)\n        if not fname: raise IOError(\"Resource %r not found.\" % name)\n        return self.opener(fname, mode=mode, *args, **kwargs)\n\n\nclass FileUpload(object):\n    def __init__(self, fileobj, name, filename, headers=None):\n        \"\"\" Wrapper for a single file uploaded via ``multipart/form-data``. \"\"\"\n        #: Open file(-like) object (BytesIO buffer or temporary file)\n        self.file = fileobj\n        #: Name of the upload form field\n        self.name = name\n        #: Raw filename as sent by the client (may contain unsafe characters)\n        self.raw_filename = filename\n        #: A :class:`HeaderDict` with additional headers (e.g. content-type)\n        self.headers = HeaderDict(headers) if headers else HeaderDict()\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int, default=-1)\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a header within the multipart part. \"\"\"\n        return self.headers.get(name, default)\n\n    @cached_property\n    def filename(self):\n        \"\"\" Name of the file on the client file system, but normalized to ensure\n            file system compatibility. An empty filename is returned as 'empty'.\n\n            Only ASCII letters, digits, dashes, underscores and dots are\n            allowed in the final filename. Accents are removed, if possible.\n            Whitespace is replaced by a single dash. Leading or tailing dots\n            or dashes are removed. The filename is limited to 255 characters.\n        \"\"\"\n        fname = self.raw_filename\n        fname = normalize('NFKD', fname)\n        fname = fname.encode('ASCII', 'ignore').decode('ASCII')\n        fname = os.path.basename(fname.replace('\\\\', os.path.sep))\n        fname = re.sub(r'[^a-zA-Z0-9-_.\\s]', '', fname).strip()\n        fname = re.sub(r'[-\\s]+', '-', fname).strip('.-')\n        return fname[:255] or 'empty'\n\n    def _copy_file(self, fp, chunk_size=2 ** 16):\n        read, write, offset = self.file.read, fp.write, self.file.tell()\n        while 1:\n            buf = read(chunk_size)\n            if not buf: break\n            write(buf)\n        self.file.seek(offset)\n\n    def save(self, destination, overwrite=False, chunk_size=2 ** 16):\n        \"\"\" Save file to disk or copy its content to an open file(-like) object.\n            If *destination* is a directory, :attr:`filename` is added to the\n            path. Existing files are not overwritten by default (IOError).\n\n            :param destination: File path, directory or file(-like) object.\n            :param overwrite: If True, replace existing files. (default: False)\n            :param chunk_size: Bytes to read at a time. (default: 64kb)\n        \"\"\"\n        if isinstance(destination, str):  # Except file-likes here\n            if os.path.isdir(destination):\n                destination = os.path.join(destination, self.filename)\n            if not overwrite and os.path.exists(destination):\n                raise IOError('File exists.')\n            with open(destination, 'wb') as fp:\n                self._copy_file(fp, chunk_size)\n        else:\n            self._copy_file(destination, chunk_size)\n\n###############################################################################\n# Application Helper ###########################################################\n###############################################################################\n\n\ndef abort(code=500, text='Unknown Error.'):\n    \"\"\" Aborts execution and causes a HTTP error. \"\"\"\n    raise HTTPError(code, text)\n\n\ndef redirect(url, code=None):\n    \"\"\" Aborts execution and causes a 303 or 302 redirect, depending on\n        the HTTP protocol version. \"\"\"\n    if not code:\n        code = 303 if request.get('SERVER_PROTOCOL') == \"HTTP/1.1\" else 302\n    res = response.copy(cls=HTTPResponse)\n    res.status = code\n    res.body = \"\"\n    res.set_header('Location', urljoin(request.url, url))\n    raise res\n\n\ndef _rangeiter(fp, offset, limit, bufsize=1024 * 1024):\n    \"\"\" Yield chunks from a range in a file. \"\"\"\n    fp.seek(offset)\n    while limit > 0:\n        part = fp.read(min(limit, bufsize))\n        if not part:\n            break\n        limit -= len(part)\n        yield part\n\n\ndef static_file(filename, root,\n                mimetype=True,\n                download=False,\n                charset='UTF-8',\n                etag=None,\n                headers=None):\n    \"\"\" Open a file in a safe way and return an instance of :exc:`HTTPResponse`\n        that can be sent back to the client.\n\n        :param filename: Name or path of the file to send, relative to ``root``.\n        :param root: Root path for file lookups. Should be an absolute directory\n            path.\n        :param mimetype: Provide the content-type header (default: guess from\n            file extension)\n        :param download: If True, ask the browser to open a `Save as...` dialog\n            instead of opening the file with the associated program. You can\n            specify a custom filename as a string. If not specified, the\n            original filename is used (default: False).\n        :param charset: The charset for files with a ``text/*`` mime-type.\n            (default: UTF-8)\n        :param etag: Provide a pre-computed ETag header. If set to ``False``,\n            ETag handling is disabled. (default: auto-generate ETag header)\n        :param headers: Additional headers dict to add to the response.\n\n        While checking user input is always a good idea, this function provides\n        additional protection against malicious ``filename`` parameters from\n        breaking out of the ``root`` directory and leaking sensitive information\n        to an attacker.\n\n        Read-protected files or files outside of the ``root`` directory are\n        answered with ``403 Access Denied``. Missing files result in a\n        ``404 Not Found`` response. Conditional requests (``If-Modified-Since``,\n        ``If-None-Match``) are answered with ``304 Not Modified`` whenever\n        possible. ``HEAD`` and ``Range`` requests (used by download managers to\n        check or continue partial downloads) are also handled automatically.\n    \"\"\"\n\n    root = os.path.join(os.path.abspath(root), '')\n    filename = os.path.abspath(os.path.join(root, filename.strip('/\\\\')))\n    headers = headers.copy() if headers else {}\n    getenv = request.environ.get\n\n    if not filename.startswith(root):\n        return HTTPError(403, \"Access denied.\")\n    if not os.path.exists(filename) or not os.path.isfile(filename):\n        return HTTPError(404, \"File does not exist.\")\n    if not os.access(filename, os.R_OK):\n        return HTTPError(403, \"You do not have permission to access this file.\")\n\n    if mimetype is True:\n        name = download if isinstance(download, str) else filename\n        mimetype, encoding = mimetypes.guess_type(name)\n        if encoding == 'gzip':\n            mimetype = 'application/gzip'\n        elif encoding: # e.g. bzip2 -> application/x-bzip2\n            mimetype = 'application/x-' + encoding\n\n    if charset and mimetype and 'charset=' not in mimetype \\\n        and (mimetype[:5] == 'text/' or mimetype == 'application/javascript'):\n        mimetype += '; charset=%s' % charset\n\n    if mimetype:\n        headers['Content-Type'] = mimetype\n\n    if download is True:\n        download = os.path.basename(filename)\n\n    if download:\n        download = download.replace('\"','')\n        headers['Content-Disposition'] = 'attachment; filename=\"%s\"' % download\n\n    stats = os.stat(filename)\n    headers['Content-Length'] = clen = stats.st_size\n    headers['Last-Modified'] = email.utils.formatdate(stats.st_mtime, usegmt=True)\n    headers['Date'] = email.utils.formatdate(time.time(), usegmt=True)\n\n    if etag is None:\n        etag = '%d:%d:%d:%d:%s' % (stats.st_dev, stats.st_ino, stats.st_mtime,\n                                   clen, filename)\n        etag = hashlib.sha1(tob(etag)).hexdigest()\n\n    if etag:\n        headers['ETag'] = etag\n        check = getenv('HTTP_IF_NONE_MATCH')\n        if check and check == etag:\n            return HTTPResponse(status=304, **headers)\n\n    ims = getenv('HTTP_IF_MODIFIED_SINCE')\n    if ims:\n        ims = parse_date(ims.split(\";\")[0].strip())\n        if ims is not None and ims >= int(stats.st_mtime):\n            return HTTPResponse(status=304, **headers)\n\n    body = '' if request.method == 'HEAD' else open(filename, 'rb')\n\n    headers[\"Accept-Ranges\"] = \"bytes\"\n    range_header = getenv('HTTP_RANGE')\n    if range_header:\n        ranges = list(parse_range_header(range_header, clen))\n        if not ranges:\n            return HTTPError(416, \"Requested Range Not Satisfiable\")\n        offset, end = ranges[0]\n        rlen = end - offset\n        headers[\"Content-Range\"] = \"bytes %d-%d/%d\" % (offset, end - 1, clen)\n        headers[\"Content-Length\"] = str(rlen)\n        if body: body = _closeiter(_rangeiter(body, offset, rlen), body.close)\n        return HTTPResponse(body, status=206, **headers)\n    return HTTPResponse(body, **headers)\n\n###############################################################################\n# HTTP Utilities and MISC (TODO) ###############################################\n###############################################################################\n\n\ndef debug(mode=True):\n    \"\"\" Change the debug level.\n    There is only one debug level supported at the moment.\"\"\"\n    global DEBUG\n    if mode: warnings.simplefilter('default')\n    DEBUG = bool(mode)\n\n\ndef http_date(value):\n    if isinstance(value, str):\n        return value\n    if isinstance(value, datetime):\n        # aware datetime.datetime is converted to UTC time\n        # naive datetime.datetime is treated as UTC time\n        value = value.utctimetuple()\n    elif isinstance(value, datedate):\n        # datetime.date is naive, and is treated as UTC time\n        value = value.timetuple()\n    if not isinstance(value, (int, float)):\n        # convert struct_time in UTC to UNIX timestamp\n        value = calendar.timegm(value)\n    return email.utils.formatdate(value, usegmt=True)\n\n\ndef parse_date(ims):\n    \"\"\" Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. \"\"\"\n    try:\n        ts = email.utils.parsedate_tz(ims)\n        return calendar.timegm(ts[:8] + (0, )) - (ts[9] or 0)\n    except (TypeError, ValueError, IndexError, OverflowError):\n        return None\n\n\ndef parse_auth(header):\n    \"\"\" Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None\"\"\"\n    try:\n        method, data = header.split(None, 1)\n        if method.lower() == 'basic':\n            user, pwd = touni(base64.b64decode(tob(data))).split(':', 1)\n            return user, pwd\n    except (KeyError, ValueError):\n        return None\n\n\ndef parse_range_header(header, maxlen=0):\n    \"\"\" Yield (start, end) ranges parsed from a HTTP Range header. Skip\n        unsatisfiable ranges. The end index is non-inclusive.\"\"\"\n    if not header or header[:6] != 'bytes=': return\n    ranges = [r.split('-', 1) for r in header[6:].split(',') if '-' in r]\n    for start, end in ranges:\n        try:\n            if not start:  # bytes=-100    -> last 100 bytes\n                start, end = max(0, maxlen - int(end)), maxlen\n            elif not end:  # bytes=100-    -> all but the first 99 bytes\n                start, end = int(start), maxlen\n            else:  # bytes=100-200 -> bytes 100-200 (inclusive)\n                start, end = int(start), min(int(end) + 1, maxlen)\n            if 0 <= start < end <= maxlen:\n                yield start, end\n        except ValueError:\n            pass\n\n\n#: Header tokenizer used by _parse_http_header()\n_hsplit = re.compile('(?:(?:\"((?:[^\"\\\\\\\\]|\\\\\\\\.)*)\")|([^;,=]+))([;,=]?)').findall\n\ndef _parse_http_header(h):\n    \"\"\" Parses a typical multi-valued and parametrised HTTP header (e.g. Accept headers) and returns a list of values\n        and parameters. For non-standard or broken input, this implementation may return partial results.\n    :param h: A header string (e.g. ``text/html,text/plain;q=0.9,*/*;q=0.8``)\n    :return: List of (value, params) tuples. The second element is a (possibly empty) dict.\n    \"\"\"\n    values = []\n    if '\"' not in h:  # INFO: Fast path without regexp (~2x faster)\n        for value in h.split(','):\n            parts = value.split(';')\n            values.append((parts[0].strip(), {}))\n            for attr in parts[1:]:\n                name, value = attr.split('=', 1)\n                values[-1][1][name.strip().lower()] = value.strip()\n    else:\n        lop, key, attrs = ',', None, {}\n        for quoted, plain, tok in _hsplit(h):\n            value = plain.strip() if plain else quoted.replace('\\\\\"', '\"')\n            if lop == ',':\n                attrs = {}\n                values.append((value, attrs))\n            elif lop == ';':\n                if tok == '=':\n                    key = value\n                else:\n                    attrs[value.strip().lower()] = ''\n            elif lop == '=' and key:\n                attrs[key.strip().lower()] = value\n                key = None\n            lop = tok\n    return values\n\n\ndef _parse_qsl(qs, encoding=\"utf8\"):\n    r = []\n    for pair in qs.split('&'):\n        if not pair: continue\n        nv = pair.split('=', 1)\n        if len(nv) != 2: nv.append('')\n        key = urlunquote(nv[0].replace('+', ' '), encoding)\n        value = urlunquote(nv[1].replace('+', ' '), encoding)\n        r.append((key, value))\n    return r\n\n\ndef _lscmp(a, b):\n    \"\"\" Compares two strings in a cryptographically safe way:\n        Runtime is not affected by length of common prefix. \"\"\"\n    return not sum(0 if x == y else 1\n                   for x, y in zip(a, b)) and len(a) == len(b)\n\n\ndef cookie_encode(data, key, digestmod=None):\n    \"\"\" Encode and sign a pickle-able object. Return a (byte) string \"\"\"\n    depr(0, 13, \"cookie_encode() will be removed soon.\",\n                \"Do not use this API directly.\")\n    digestmod = digestmod or hashlib.sha256\n    msg = base64.b64encode(pickle.dumps(data, -1))\n    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=digestmod).digest())\n    return b'!' + sig + b'?' + msg\n\n\ndef cookie_decode(data, key, digestmod=None):\n    \"\"\" Verify and decode an encoded string. Return an object or None.\"\"\"\n    depr(0, 13, \"cookie_decode() will be removed soon.\",\n                \"Do not use this API directly.\")\n    data = tob(data)\n    if cookie_is_encoded(data):\n        sig, msg = data.split(b'?', 1)\n        digestmod = digestmod or hashlib.sha256\n        hashed = hmac.new(tob(key), msg, digestmod=digestmod).digest()\n        if _lscmp(sig[1:], base64.b64encode(hashed)):\n            return pickle.loads(base64.b64decode(msg))\n    return None\n\n\ndef cookie_is_encoded(data):\n    \"\"\" Return True if the argument looks like a encoded cookie.\"\"\"\n    depr(0, 13, \"cookie_is_encoded() will be removed soon.\",\n                \"Do not use this API directly.\")\n    return bool(data.startswith(b'!') and b'?' in data)\n\n\ndef html_escape(string):\n    \"\"\" Escape HTML special characters ``&<>`` and quotes ``'\"``. \"\"\"\n    return string.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\\\n                 .replace('\"', '&quot;').replace(\"'\", '&#039;')\n\n\ndef html_quote(string):\n    \"\"\" Escape and quote a string to be used as an HTTP attribute.\"\"\"\n    return '\"%s\"' % html_escape(string).replace('\\n', '&#10;')\\\n                    .replace('\\r', '&#13;').replace('\\t', '&#9;')\n\n\ndef yieldroutes(func):\n    \"\"\" Return a generator for routes that match the signature (name, args)\n    of the func parameter. This may yield more than one route if the function\n    takes optional keyword arguments. The output is best described by example::\n\n        a()         -> '/a'\n        b(x, y)     -> '/b/<x>/<y>'\n        c(x, y=5)   -> '/c/<x>' and '/c/<x>/<y>'\n        d(x=5, y=6) -> '/d' and '/d/<x>' and '/d/<x>/<y>'\n    \"\"\"\n    path = '/' + func.__name__.replace('__', '/').lstrip('/')\n    sig = inspect.signature(func, follow_wrapped=False)\n    for p in sig.parameters.values():\n        if p.kind == p.POSITIONAL_ONLY:\n            raise ValueError(\"Invalid signature for yieldroutes: %s\" % sig)\n        if p.kind in (p.POSITIONAL_OR_KEYWORD, p.KEYWORD_ONLY):\n            if p.default != p.empty:\n                yield path  # Yield path without this (optional) parameter.\n            path += \"/<%s>\" % p.name\n    yield path\n\n\ndef path_shift(script_name, path_info, shift=1):\n    \"\"\" Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.\n\n        :return: The modified paths.\n        :param script_name: The SCRIPT_NAME path.\n        :param script_name: The PATH_INFO path.\n        :param shift: The number of path fragments to shift. May be negative to\n          change the shift direction. (default: 1)\n    \"\"\"\n    if shift == 0: return script_name, path_info\n    pathlist = path_info.strip('/').split('/')\n    scriptlist = script_name.strip('/').split('/')\n    if pathlist and pathlist[0] == '': pathlist = []\n    if scriptlist and scriptlist[0] == '': scriptlist = []\n    if 0 < shift <= len(pathlist):\n        moved = pathlist[:shift]\n        scriptlist = scriptlist + moved\n        pathlist = pathlist[shift:]\n    elif 0 > shift >= -len(scriptlist):\n        moved = scriptlist[shift:]\n        pathlist = moved + pathlist\n        scriptlist = scriptlist[:shift]\n    else:\n        empty = 'SCRIPT_NAME' if shift < 0 else 'PATH_INFO'\n        raise AssertionError(\"Cannot shift. Nothing left from %s\" % empty)\n    new_script_name = '/' + '/'.join(scriptlist)\n    new_path_info = '/' + '/'.join(pathlist)\n    if path_info.endswith('/') and pathlist: new_path_info += '/'\n    return new_script_name, new_path_info\n\n\ndef auth_basic(check, realm=\"private\", text=\"Access denied\"):\n    \"\"\" Callback decorator to require HTTP auth (basic).\n        TODO: Add route(check_auth=...) parameter. \"\"\"\n\n    def decorator(func):\n\n        @functools.wraps(func)\n        def wrapper(*a, **ka):\n            user, password = request.auth or (None, None)\n            if user is None or not check(user, password):\n                err = HTTPError(401, text)\n                err.add_header('WWW-Authenticate', 'Basic realm=\"%s\"' % realm)\n                return err\n            return func(*a, **ka)\n\n        return wrapper\n\n    return decorator\n\n# Shortcuts for common Bottle methods.\n# They all refer to the current default application.\n\n\ndef make_default_app_wrapper(name):\n    \"\"\" Return a callable that relays calls to the current default app. \"\"\"\n\n    @functools.wraps(getattr(Bottle, name))\n    def wrapper(*a, **ka):\n        return getattr(app(), name)(*a, **ka)\n\n    return wrapper\n\n\nroute     = make_default_app_wrapper('route')\nget       = make_default_app_wrapper('get')\npost      = make_default_app_wrapper('post')\nput       = make_default_app_wrapper('put')\ndelete    = make_default_app_wrapper('delete')\npatch     = make_default_app_wrapper('patch')\nerror     = make_default_app_wrapper('error')\nmount     = make_default_app_wrapper('mount')\nhook      = make_default_app_wrapper('hook')\ninstall   = make_default_app_wrapper('install')\nuninstall = make_default_app_wrapper('uninstall')\nurl       = make_default_app_wrapper('get_url')\n\n\n###############################################################################\n# Multipart Handling ###########################################################\n###############################################################################\n# cgi.FieldStorage was deprecated in Python 3.11 and removed in 3.13\n# This implementation is based on https://github.com/defnull/multipart/\n\n\nclass MultipartError(HTTPError):\n    def __init__(self, msg):\n        HTTPError.__init__(self, 400, \"MultipartError: \" + msg)\n\n\nclass _MultipartParser(object):\n    def __init__(\n        self,\n        stream,\n        boundary,\n        content_length=-1,\n        disk_limit=2 ** 30,\n        mem_limit=2 ** 20,\n        memfile_limit=2 ** 18,\n        buffer_size=2 ** 16,\n        charset=\"latin1\",\n    ):\n        self.stream = stream\n        self.boundary = boundary\n        self.content_length = content_length\n        self.disk_limit = disk_limit\n        self.memfile_limit = memfile_limit\n        self.mem_limit = min(mem_limit, self.disk_limit)\n        self.buffer_size = min(buffer_size, self.mem_limit)\n        self.charset = charset\n\n        if not boundary:\n            raise MultipartError(\"No boundary.\")\n\n        if self.buffer_size - 6 < len(boundary):  # \"--boundary--\\r\\n\"\n            raise MultipartError(\"Boundary does not fit into buffer_size.\")\n\n    def _lineiter(self):\n        \"\"\" Iterate over a binary file-like object (crlf terminated) line by\n            line. Each line is returned as a (line, crlf) tuple. Lines larger\n            than buffer_size are split into chunks where all but the last chunk\n            has an empty string instead of crlf. Maximum chunk size is twice the\n            buffer size.\n        \"\"\"\n\n        read = self.stream.read\n        maxread, maxbuf = self.content_length, self.buffer_size\n        partial = b\"\"  # Contains the last (partial) line\n\n        while True:\n            chunk = read(maxbuf if maxread < 0 else min(maxbuf, maxread))\n            maxread -= len(chunk)\n            if not chunk:\n                if partial:\n                    yield partial, b''\n                break\n\n            if partial:\n                chunk = partial + chunk\n\n            scanpos = 0\n            while True:\n                i = chunk.find(b'\\r\\n', scanpos)\n                if i >= 0:\n                    yield chunk[scanpos:i], b'\\r\\n'\n                    scanpos = i + 2\n                else: # CRLF not found\n                    partial = chunk[scanpos:] if scanpos else chunk\n                    break\n\n            if len(partial) > maxbuf:\n                yield partial[:-1], b\"\"\n                partial = partial[-1:]\n\n    def parse(self):\n        \"\"\" Return a MultiPart iterator. Can only be called once. \"\"\"\n\n        lines, line = self._lineiter(), \"\"\n        separator = b\"--\" + tob(self.boundary)\n        terminator = separator + b\"--\"\n        mem_used, disk_used = 0, 0  # Track used resources to prevent DoS\n        is_tail = False  # True if the last line was incomplete (cutted)\n\n        # Consume first boundary. Ignore any preamble, as required by RFC\n        # 2046, section 5.1.1.\n        for line, nl in lines:\n            if line in (separator, terminator):\n                break\n        else:\n            raise MultipartError(\"Stream does not contain boundary\")\n\n        # First line is termainating boundary -> empty multipart stream\n        if line == terminator:\n            for _ in lines:\n                raise MultipartError(\"Found data after empty multipart stream\")\n            return\n\n        part_options = {\n            \"buffer_size\": self.buffer_size,\n            \"memfile_limit\": self.memfile_limit,\n            \"charset\": self.charset,\n        }\n        part = _MultipartPart(**part_options)\n\n        for line, nl in lines:\n            if not is_tail and (line == separator or line == terminator):\n                part.finish()\n                if part.is_buffered():\n                    mem_used += part.size\n                else:\n                    disk_used += part.size\n                yield part\n                if line == terminator:\n                    break\n                part = _MultipartPart(**part_options)\n            else:\n                is_tail = not nl  # The next line continues this one\n                try:\n                    part.feed(line, nl)\n                    if part.is_buffered():\n                        if part.size + mem_used > self.mem_limit:\n                            raise MultipartError(\"Memory limit reached.\")\n                    elif part.size + disk_used > self.disk_limit:\n                        raise MultipartError(\"Disk limit reached.\")\n                except MultipartError:\n                    part.close()\n                    raise\n        else:\n            part.close()\n\n        if line != terminator:\n            raise MultipartError(\"Unexpected end of multipart stream.\")\n\n\nclass _MultipartPart(object):\n    def __init__(self, buffer_size=2 ** 16, memfile_limit=2 ** 18, charset=\"latin1\"):\n        self.headerlist = []\n        self.headers = None\n        self.file = False\n        self.size = 0\n        self._buf = b\"\"\n        self.disposition = None\n        self.name = None\n        self.filename = None\n        self.content_type = None\n        self.charset = charset\n        self.memfile_limit = memfile_limit\n        self.buffer_size = buffer_size\n\n    def feed(self, line, nl=\"\"):\n        if self.file:\n            return self.write_body(line, nl)\n        return self.write_header(line, nl)\n\n    def write_header(self, line, nl):\n        line = str(line, self.charset)\n\n        if not nl:\n            raise MultipartError(\"Unexpected end of line in header.\")\n\n        if not line.strip():  # blank line -> end of header segment\n            self.finish_header()\n        elif line[0] in \" \\t\" and self.headerlist:\n            name, value = self.headerlist.pop()\n            self.headerlist.append((name, value + line.strip()))\n        else:\n            if \":\" not in line:\n                raise MultipartError(\"Syntax error in header: No colon.\")\n\n            name, value = line.split(\":\", 1)\n            self.headerlist.append((name.strip(), value.strip()))\n\n    def write_body(self, line, nl):\n        if not line and not nl:\n            return  # This does not even flush the buffer\n\n        self.size += len(line) + len(self._buf)\n        self.file.write(self._buf + line)\n        self._buf = nl\n\n        if self.content_length > 0 and self.size > self.content_length:\n            raise MultipartError(\"Size of body exceeds Content-Length header.\")\n\n        if self.size > self.memfile_limit and isinstance(self.file, BytesIO):\n            self.file, old = NamedTemporaryFile(mode=\"w+b\"), self.file\n            old.seek(0)\n\n            copied, maxcopy, chunksize = 0, self.size, self.buffer_size\n            read, write = old.read, self.file.write\n            while copied < maxcopy:\n                chunk = read(min(chunksize, maxcopy - copied))\n                write(chunk)\n                copied += len(chunk)\n\n    def finish_header(self):\n        self.file = BytesIO()\n        self.headers = HeaderDict(self.headerlist)\n        content_disposition = self.headers.get(\"Content-Disposition\")\n        content_type = self.headers.get(\"Content-Type\")\n\n        if not content_disposition:\n            raise MultipartError(\"Content-Disposition header is missing.\")\n\n        self.disposition, self.options = _parse_http_header(content_disposition)[0]\n        self.name = self.options.get(\"name\")\n        if \"filename\" in self.options:\n            self.filename = self.options.get(\"filename\")\n            if self.filename[1:3] == \":\\\\\" or self.filename[:2] == \"\\\\\\\\\":\n                self.filename = self.filename.split(\"\\\\\")[-1] # ie6 bug\n\n        self.content_type, options = _parse_http_header(content_type)[0] if content_type else (None, {})\n        self.charset = options.get(\"charset\") or self.charset\n\n        self.content_length = int(self.headers.get(\"Content-Length\", \"-1\"))\n\n    def finish(self):\n        if not self.file:\n            raise MultipartError(\"Incomplete part: Header section not closed.\")\n        self.file.seek(0)\n\n    def is_buffered(self):\n        \"\"\" Return true if the data is fully buffered in memory.\"\"\"\n        return isinstance(self.file, BytesIO)\n\n    @property\n    def value(self):\n        \"\"\" Data decoded with the specified charset \"\"\"\n        return str(self.raw, self.charset)\n\n    @property\n    def raw(self):\n        \"\"\" Data without decoding \"\"\"\n        pos = self.file.tell()\n        self.file.seek(0)\n\n        try:\n            return self.file.read()\n        finally:\n            self.file.seek(pos)\n\n    def close(self):\n        if self.file:\n            self.file.close()\n            self.file = False\n\n###############################################################################\n# Server Adapter ###############################################################\n###############################################################################\n\n# Before you edit or add a server adapter, please read:\n# - https://github.com/bottlepy/bottle/pull/647#issuecomment-60152870\n# - https://github.com/bottlepy/bottle/pull/865#issuecomment-242795341\n\nclass ServerAdapter(object):\n    quiet = False\n\n    def __init__(self, host='127.0.0.1', port=8080, **options):\n        self.options = options\n        self.host = host\n        self.port = int(port)\n\n    def run(self, handler):  # pragma: no cover\n        pass\n\n    @property\n    def _listen_url(self):\n        if self.host.startswith(\"unix:\"):\n            return self.host\n        elif ':' in self.host:\n            return \"http://[%s]:%d/\" % (self.host, self.port)\n        else:\n            return \"http://%s:%d/\" % (self.host, self.port)\n\n    def __repr__(self):\n        args = ', '.join('%s=%r' % kv for kv in self.options.items())\n        return \"%s(%s)\" % (self.__class__.__name__, args)\n\n\nclass CGIServer(ServerAdapter):\n    quiet = True\n\n    def run(self, handler):  # pragma: no cover\n        from wsgiref.handlers import CGIHandler\n\n        def fixed_environ(environ, start_response):\n            environ.setdefault('PATH_INFO', '')\n            return handler(environ, start_response)\n\n        CGIHandler().run(fixed_environ)\n\n\nclass FlupFCGIServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        import flup.server.fcgi\n        self.options.setdefault('bindAddress', (self.host, self.port))\n        flup.server.fcgi.WSGIServer(handler, **self.options).run()\n\n\nclass WSGIRefServer(ServerAdapter):\n    def run(self, app):  # pragma: no cover\n        from wsgiref.simple_server import make_server\n        from wsgiref.simple_server import WSGIRequestHandler, WSGIServer\n        import socket\n\n        class FixedHandler(WSGIRequestHandler):\n            def address_string(self):  # Prevent reverse DNS lookups please.\n                return self.client_address[0]\n\n            def log_request(*args, **kw):\n                if not self.quiet:\n                    return WSGIRequestHandler.log_request(*args, **kw)\n\n        handler_cls = self.options.get('handler_class', FixedHandler)\n        server_cls = self.options.get('server_class', WSGIServer)\n\n        if ':' in self.host:  # Fix wsgiref for IPv6 addresses.\n            if getattr(server_cls, 'address_family') == socket.AF_INET:\n\n                class server_cls(server_cls):\n                    address_family = socket.AF_INET6\n\n        self.srv = make_server(self.host, self.port, app, server_cls,\n                               handler_cls)\n        self.port = self.srv.server_port  # update port actual port (0 means random)\n        try:\n            self.srv.serve_forever()\n        except KeyboardInterrupt:\n            self.srv.server_close()  # Prevent ResourceWarning: unclosed socket\n            raise\n\n\nclass CherryPyServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        depr(0, 13, \"The wsgi server part of cherrypy was split into a new \"\n                    \"project called 'cheroot'.\", \"Use the 'cheroot' server \"\n                    \"adapter instead of cherrypy.\")\n        from cherrypy import wsgiserver # This will fail for CherryPy >= 9\n\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n\n        certfile = self.options.get('certfile')\n        if certfile:\n            del self.options['certfile']\n        keyfile = self.options.get('keyfile')\n        if keyfile:\n            del self.options['keyfile']\n\n        server = wsgiserver.CherryPyWSGIServer(**self.options)\n        if certfile:\n            server.ssl_certificate = certfile\n        if keyfile:\n            server.ssl_private_key = keyfile\n\n        try:\n            server.start()\n        finally:\n            server.stop()\n\n\nclass CherootServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        from cheroot import wsgi\n        from cheroot.ssl import builtin\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n        certfile = self.options.pop('certfile', None)\n        keyfile = self.options.pop('keyfile', None)\n        chainfile = self.options.pop('chainfile', None)\n        server = wsgi.Server(**self.options)\n        if certfile and keyfile:\n            server.ssl_adapter = builtin.BuiltinSSLAdapter(\n                    certfile, keyfile, chainfile)\n        try:\n            server.start()\n        finally:\n            server.stop()\n\n\nclass WaitressServer(ServerAdapter):\n    def run(self, handler):\n        from waitress import serve\n        serve(handler, host=self.host, port=self.port, _quiet=self.quiet, **self.options)\n\n\nclass PasteServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        from paste import httpserver\n        from paste.translogger import TransLogger\n        handler = TransLogger(handler, setup_console_handler=(not self.quiet))\n        httpserver.serve(handler,\n                         host=self.host,\n                         port=str(self.port), **self.options)\n\n\nclass MeinheldServer(ServerAdapter):\n    def run(self, handler):\n        from meinheld import server\n        server.listen((self.host, self.port))\n        server.run(handler)\n\n\nclass FapwsServer(ServerAdapter):\n    \"\"\" Extremely fast webserver using libev. See https://github.com/william-os4y/fapws3 \"\"\"\n\n    def run(self, handler):  # pragma: no cover\n        depr(0, 13, \"fapws3 is not maintained and support will be dropped.\")\n        import fapws._evwsgi as evwsgi\n        from fapws import base, config\n        port = self.port\n        if float(config.SERVER_IDENT[-2:]) > 0.4:\n            # fapws3 silently changed its API in 0.5\n            port = str(port)\n        evwsgi.start(self.host, port)\n        # fapws3 never releases the GIL. Complain upstream. I tried. No luck.\n        if 'BOTTLE_CHILD' in os.environ and not self.quiet:\n            _stderr(\"WARNING: Auto-reloading does not work with Fapws3.\")\n            _stderr(\"         (Fapws3 breaks python thread support)\")\n        evwsgi.set_base_module(base)\n\n        def app(environ, start_response):\n            environ['wsgi.multiprocess'] = False\n            return handler(environ, start_response)\n\n        evwsgi.wsgi_cb(('', app))\n        evwsgi.run()\n\n\nclass TornadoServer(ServerAdapter):\n    \"\"\" The super hyped asynchronous server by facebook. Untested. \"\"\"\n\n    def run(self, handler):  # pragma: no cover\n        import tornado.wsgi, tornado.httpserver, tornado.ioloop\n        container = tornado.wsgi.WSGIContainer(handler)\n        server = tornado.httpserver.HTTPServer(container)\n        server.listen(port=self.port, address=self.host)\n        tornado.ioloop.IOLoop.instance().start()\n\n\nclass AppEngineServer(ServerAdapter):\n    \"\"\" Adapter for Google App Engine. \"\"\"\n    quiet = True\n\n    def run(self, handler):\n        depr(0, 13, \"AppEngineServer no longer required\",\n             \"Configure your application directly in your app.yaml\")\n        from google.appengine.ext.webapp import util\n        # A main() function in the handler script enables 'App Caching'.\n        # Lets makes sure it is there. This _really_ improves performance.\n        module = sys.modules.get('__main__')\n        if module and not hasattr(module, 'main'):\n            module.main = lambda: util.run_wsgi_app(handler)\n        util.run_wsgi_app(handler)\n\n\nclass TwistedServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n\n    def run(self, handler):\n        from twisted.web import server, wsgi\n        from twisted.python.threadpool import ThreadPool\n        from twisted.internet import reactor\n        thread_pool = ThreadPool()\n        thread_pool.start()\n        reactor.addSystemEventTrigger('after', 'shutdown', thread_pool.stop)\n        factory = server.Site(wsgi.WSGIResource(reactor, thread_pool, handler))\n        reactor.listenTCP(self.port, factory, interface=self.host)\n        if not reactor.running:\n            reactor.run()\n\n\nclass DieselServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n\n    def run(self, handler):\n        depr(0, 13, \"Diesel is not tested or supported and will be removed.\")\n        from diesel.protocols.wsgi import WSGIApplication\n        app = WSGIApplication(handler, port=self.port)\n        app.run()\n\n\nclass GeventServer(ServerAdapter):\n    \"\"\" Untested. Options:\n\n        * See gevent.wsgi.WSGIServer() documentation for more options.\n    \"\"\"\n\n    def run(self, handler):\n        from gevent import pywsgi, local\n        if not isinstance(threading.local(), local.local):\n            msg = \"Bottle requires gevent.monkey.patch_all() (before import)\"\n            raise RuntimeError(msg)\n        if self.quiet:\n            self.options['log'] = None\n        address = (self.host, self.port)\n        server = pywsgi.WSGIServer(address, handler, **self.options)\n        if 'BOTTLE_CHILD' in os.environ:\n            import signal\n            signal.signal(signal.SIGINT, lambda s, f: server.stop())\n        server.serve_forever()\n\n\nclass GunicornServer(ServerAdapter):\n    \"\"\" Untested. See http://gunicorn.org/configure.html for options. \"\"\"\n\n    def run(self, handler):\n        from gunicorn.app.base import BaseApplication\n\n        if self.host.startswith(\"unix:\"):\n            config = {'bind': self.host}\n        else:\n            config = {'bind': \"%s:%d\" % (self.host, self.port)}\n\n        config.update(self.options)\n\n        class GunicornApplication(BaseApplication):\n            def load_config(self):\n                for key, value in config.items():\n                    self.cfg.set(key, value)\n\n            def load(self):\n                return handler\n\n        GunicornApplication().run()\n\n\nclass EventletServer(ServerAdapter):\n    \"\"\" Untested. Options:\n\n        * `backlog` adjust the eventlet backlog parameter which is the maximum\n          number of queued connections. Should be at least 1; the maximum\n          value is system-dependent.\n        * `family`: (default is 2) socket family, optional. See socket\n          documentation for available families.\n    \"\"\"\n\n    def run(self, handler):\n        from eventlet import wsgi, listen, patcher\n        if not patcher.is_monkey_patched(os):\n            msg = \"Bottle requires eventlet.monkey_patch() (before import)\"\n            raise RuntimeError(msg)\n        socket_args = {}\n        for arg in ('backlog', 'family'):\n            try:\n                socket_args[arg] = self.options.pop(arg)\n            except KeyError:\n                pass\n        address = (self.host, self.port)\n        try:\n            wsgi.server(listen(address, **socket_args), handler,\n                        log_output=(not self.quiet))\n        except TypeError:\n            # Fallback, if we have old version of eventlet\n            wsgi.server(listen(address), handler)\n\n\nclass BjoernServer(ServerAdapter):\n    \"\"\" Fast server written in C: https://github.com/jonashaag/bjoern \"\"\"\n\n    def run(self, handler):\n        from bjoern import run\n        run(handler, self.host, self.port, reuse_port=True)\n\nclass AsyncioServerAdapter(ServerAdapter):\n    \"\"\" Extend ServerAdapter for adding custom event loop \"\"\"\n    def get_event_loop(self):\n        pass\n\nclass AiohttpServer(AsyncioServerAdapter):\n    \"\"\" Asynchronous HTTP client/server framework for asyncio\n        https://pypi.python.org/pypi/aiohttp/\n        https://pypi.org/project/aiohttp-wsgi/\n    \"\"\"\n\n    def get_event_loop(self):\n        import asyncio\n        return asyncio.new_event_loop()\n\n    def run(self, handler):\n        import asyncio\n        from aiohttp_wsgi.wsgi import serve\n        self.loop = self.get_event_loop()\n        asyncio.set_event_loop(self.loop)\n\n        if 'BOTTLE_CHILD' in os.environ:\n            import signal\n            signal.signal(signal.SIGINT, lambda s, f: self.loop.stop())\n\n        serve(handler, host=self.host, port=self.port)\n\n\nclass AiohttpUVLoopServer(AiohttpServer):\n    \"\"\"uvloop\n       https://github.com/MagicStack/uvloop\n    \"\"\"\n    def get_event_loop(self):\n        import uvloop\n        return uvloop.new_event_loop()\n\nclass AutoServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    adapters = [WaitressServer, PasteServer, TwistedServer, CherryPyServer,\n                CherootServer, WSGIRefServer]\n\n    def run(self, handler):\n        for sa in self.adapters:\n            try:\n                return sa(self.host, self.port, **self.options).run(handler)\n            except ImportError:\n                pass\n\n\nserver_names = {\n    'cgi': CGIServer,\n    'flup': FlupFCGIServer,\n    'wsgiref': WSGIRefServer,\n    'waitress': WaitressServer,\n    'cherrypy': CherryPyServer,\n    'cheroot': CherootServer,\n    'paste': PasteServer,\n    'fapws3': FapwsServer,\n    'tornado': TornadoServer,\n    'gae': AppEngineServer,\n    'twisted': TwistedServer,\n    'diesel': DieselServer,\n    'meinheld': MeinheldServer,\n    'gunicorn': GunicornServer,\n    'eventlet': EventletServer,\n    'gevent': GeventServer,\n    'bjoern': BjoernServer,\n    'aiohttp': AiohttpServer,\n    'uvloop': AiohttpUVLoopServer,\n    'auto': AutoServer,\n}\n\n###############################################################################\n# Application Control ##########################################################\n###############################################################################\n\n\ndef load(target, **namespace):\n    \"\"\" Import a module or fetch an object from a module.\n\n        * ``package.module`` returns `module` as a module object.\n        * ``pack.mod:name`` returns the module variable `name` from `pack.mod`.\n        * ``pack.mod:func()`` calls `pack.mod.func()` and returns the result.\n\n        The last form accepts not only function calls, but any type of\n        expression. Keyword arguments passed to this function are available as\n        local variables. Example: ``import_string('re:compile(x)', x='[a-z]')``\n    \"\"\"\n    module, target = target.split(\":\", 1) if ':' in target else (target, None)\n    if module not in sys.modules: __import__(module)\n    if not target: return sys.modules[module]\n    if target.isalnum(): return getattr(sys.modules[module], target)\n    package_name = module.split('.')[0]\n    namespace[package_name] = sys.modules[package_name]\n    return eval('%s.%s' % (module, target), namespace)\n\n\ndef load_app(target):\n    \"\"\" Load a bottle application from a module and make sure that the import\n        does not affect the current default application, but returns a separate\n        application object. See :func:`load` for the target parameter. \"\"\"\n    global NORUN\n    NORUN, nr_old = True, NORUN\n    tmp = default_app.push()  # Create a new \"default application\"\n    try:\n        rv = load(target)  # Import the target module\n        return rv if callable(rv) else tmp\n    finally:\n        default_app.remove(tmp)  # Remove the temporary added default application\n        NORUN = nr_old\n\n\n_debug = debug\n\n\ndef run(app=None,\n        server='wsgiref',\n        host='127.0.0.1',\n        port=8080,\n        interval=1,\n        reloader=False,\n        quiet=False,\n        plugins=None,\n        debug=None,\n        config=None, **kargs):\n    \"\"\" Start a server instance. This method blocks until the server terminates.\n\n        :param app: WSGI application or target string supported by\n               :func:`load_app`. (default: :func:`default_app`)\n        :param server: Server adapter to use. See :data:`server_names` keys\n               for valid names or pass a :class:`ServerAdapter` subclass.\n               (default: `wsgiref`)\n        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on\n               all interfaces including the external one. (default: 127.0.0.1)\n        :param port: Server port to bind to. Values below 1024 require root\n               privileges. (default: 8080)\n        :param reloader: Start auto-reloading server? (default: False)\n        :param interval: Auto-reloader interval in seconds (default: 1)\n        :param quiet: Suppress output to stdout and stderr? (default: False)\n        :param options: Options passed to the server adapter.\n     \"\"\"\n    if NORUN: return\n    if reloader and not os.environ.get('BOTTLE_CHILD'):\n        import subprocess\n        fd, lockfile = tempfile.mkstemp(prefix='bottle.', suffix='.lock')\n        environ = os.environ.copy()\n        environ['BOTTLE_CHILD'] = 'true'\n        environ['BOTTLE_LOCKFILE'] = lockfile\n        args = [sys.executable] + sys.argv\n        # If a package was loaded with `python -m`, then `sys.argv` needs to be\n        # restored to the original value, or imports might break. See #1336\n        if getattr(sys.modules.get('__main__'), '__package__', None):\n            args[1:1] = [\"-m\", sys.modules['__main__'].__package__]\n\n        try:\n            os.close(fd)  # We never write to this file\n            while os.path.exists(lockfile):\n                p = subprocess.Popen(args, env=environ)\n                while p.poll() is None:\n                    os.utime(lockfile, None)  # Tell child we are still alive\n                    time.sleep(interval)\n                if p.returncode == 3:  # Child wants to be restarted\n                    continue\n                sys.exit(p.returncode)\n        except KeyboardInterrupt:\n            pass\n        finally:\n            if os.path.exists(lockfile):\n                os.unlink(lockfile)\n        return\n\n    try:\n        if debug is not None: _debug(debug)\n        app = app or default_app()\n        if isinstance(app, str):\n            app = load_app(app)\n        if not callable(app):\n            raise ValueError(\"Application is not callable: %r\" % app)\n\n        for plugin in plugins or []:\n            if isinstance(plugin, str):\n                plugin = load(plugin)\n            app.install(plugin)\n\n        if config:\n            app.config.update(config)\n\n        if server in server_names:\n            server = server_names.get(server)\n        if isinstance(server, str):\n            server = load(server)\n        if isinstance(server, type):\n            server = server(host=host, port=port, **kargs)\n        if not isinstance(server, ServerAdapter):\n            raise ValueError(\"Unknown or unsupported server: %r\" % server)\n\n        server.quiet = server.quiet or quiet\n        if not server.quiet:\n            _stderr(\"Bottle v%s server starting up (using %s)...\" %\n                    (__version__, repr(server)))\n            _stderr(\"Listening on %s\" % server._listen_url)\n            _stderr(\"Hit Ctrl-C to quit.\\n\")\n\n        if reloader:\n            lockfile = os.environ.get('BOTTLE_LOCKFILE')\n            bgcheck = FileCheckerThread(lockfile, interval)\n            with bgcheck:\n                server.run(app)\n            if bgcheck.status == 'reload':\n                sys.exit(3)\n        else:\n            server.run(app)\n    except KeyboardInterrupt:\n        pass\n    except (SystemExit, MemoryError):\n        raise\n    except:\n        if not reloader: raise\n        if not getattr(server, 'quiet', quiet):\n            print_exc()\n        time.sleep(interval)\n        sys.exit(3)\n\n\nclass FileCheckerThread(threading.Thread):\n    \"\"\" Interrupt main-thread as soon as a changed module file is detected,\n        the lockfile gets deleted or gets too old. \"\"\"\n\n    def __init__(self, lockfile, interval):\n        threading.Thread.__init__(self)\n        self.daemon = True\n        self.lockfile, self.interval = lockfile, interval\n        #: Is one of 'reload', 'error' or 'exit'\n        self.status = None\n\n    def run(self):\n        exists = os.path.exists\n        mtime = lambda p: os.stat(p).st_mtime\n        files = dict()\n\n        for module in list(sys.modules.values()):\n            path = getattr(module, '__file__', '') or ''\n            if path[-4:] in ('.pyo', '.pyc'): path = path[:-1]\n            if path and exists(path): files[path] = mtime(path)\n\n        while not self.status:\n            if not exists(self.lockfile)\\\n            or mtime(self.lockfile) < time.time() - self.interval - 5:\n                self.status = 'error'\n                thread.interrupt_main()\n            for path, lmtime in list(files.items()):\n                if not exists(path) or mtime(path) > lmtime:\n                    self.status = 'reload'\n                    thread.interrupt_main()\n                    break\n            time.sleep(self.interval)\n\n    def __enter__(self):\n        self.start()\n\n    def __exit__(self, exc_type, *_):\n        if not self.status: self.status = 'exit'  # silent exit\n        self.join()\n        return exc_type is not None and issubclass(exc_type, KeyboardInterrupt)\n\n###############################################################################\n# Template Adapters ############################################################\n###############################################################################\n\n\nclass TemplateError(BottleException):\n    pass\n\n\nclass BaseTemplate(object):\n    \"\"\" Base class and minimal API for template adapters \"\"\"\n    extensions = ['tpl', 'html', 'thtml', 'stpl']\n    settings = {}  # used in prepare()\n    defaults = {}  # used in render()\n\n    def __init__(self,\n                 source=None,\n                 name=None,\n                 lookup=None,\n                 encoding='utf8', **settings):\n        \"\"\" Create a new template.\n        If the source parameter (str or buffer) is missing, the name argument\n        is used to guess a template filename. Subclasses can assume that\n        self.source and/or self.filename are set. Both are strings.\n        The lookup, encoding and settings parameters are stored as instance\n        variables.\n        The lookup parameter stores a list containing directory paths.\n        The encoding parameter should be used to decode byte strings or files.\n        The settings parameter contains a dict for engine-specific settings.\n        \"\"\"\n        self.name = name\n        self.source = source.read() if hasattr(source, 'read') else source\n        self.filename = source.filename if hasattr(source, 'filename') else None\n        self.lookup = [os.path.abspath(x) for x in lookup] if lookup else []\n        self.encoding = encoding\n        self.settings = self.settings.copy()  # Copy from class variable\n        self.settings.update(settings)  # Apply\n        if not self.source and self.name:\n            self.filename = self.search(self.name, self.lookup)\n            if not self.filename:\n                raise TemplateError('Template %s not found.' % repr(name))\n        if not self.source and not self.filename:\n            raise TemplateError('No template specified.')\n        self.prepare(**self.settings)\n\n    @classmethod\n    def search(cls, name, lookup=None):\n        \"\"\" Search name in all directories specified in lookup.\n        First without, then with common extensions. Return first hit. \"\"\"\n        if not lookup:\n            raise depr(0, 12, \"Empty template lookup path.\", \"Configure a template lookup path.\")\n\n        if os.path.isabs(name):\n            raise depr(0, 12, \"Use of absolute path for template name.\",\n                       \"Refer to templates with names or paths relative to the lookup path.\")\n\n        for spath in lookup:\n            spath = os.path.abspath(spath) + os.sep\n            fname = os.path.abspath(os.path.join(spath, name))\n            if not fname.startswith(spath): continue\n            if os.path.isfile(fname): return fname\n            for ext in cls.extensions:\n                if os.path.isfile('%s.%s' % (fname, ext)):\n                    return '%s.%s' % (fname, ext)\n\n    @classmethod\n    def global_config(cls, key, *args):\n        \"\"\" This reads or sets the global settings stored in class.settings. \"\"\"\n        if args:\n            cls.settings = cls.settings.copy()  # Make settings local to class\n            cls.settings[key] = args[0]\n        else:\n            return cls.settings[key]\n\n    def prepare(self, **options):\n        \"\"\" Run preparations (parsing, caching, ...).\n        It should be possible to call this again to refresh a template or to\n        update settings.\n        \"\"\"\n        raise NotImplementedError\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template with the specified local variables and return\n        a single byte or unicode string. If it is a byte string, the encoding\n        must match self.encoding. This method must be thread-safe!\n        Local variables may be provided in dictionaries (args)\n        or directly, as keywords (kwargs).\n        \"\"\"\n        raise NotImplementedError\n\n\nclass MakoTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from mako.template import Template\n        from mako.lookup import TemplateLookup\n        options.update({'input_encoding': self.encoding})\n        options.setdefault('format_exceptions', bool(DEBUG))\n        lookup = TemplateLookup(directories=self.lookup, **options)\n        if self.source:\n            self.tpl = Template(self.source, lookup=lookup, **options)\n        else:\n            self.tpl = Template(uri=self.name,\n                                filename=self.filename,\n                                lookup=lookup, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n\nclass CheetahTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from Cheetah.Template import Template\n        self.context = threading.local()\n        self.context.vars = {}\n        options['searchList'] = [self.context.vars]\n        if self.source:\n            self.tpl = Template(source=self.source, **options)\n        else:\n            self.tpl = Template(file=self.filename, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        self.context.vars.update(self.defaults)\n        self.context.vars.update(kwargs)\n        out = str(self.tpl)\n        self.context.vars.clear()\n        return out\n\n\nclass Jinja2Template(BaseTemplate):\n    def prepare(self, filters=None, tests=None, globals={}, **kwargs):\n        from jinja2 import Environment, FunctionLoader\n        self.env = Environment(loader=FunctionLoader(self.loader), **kwargs)\n        if filters: self.env.filters.update(filters)\n        if tests: self.env.tests.update(tests)\n        if globals: self.env.globals.update(globals)\n        if self.source:\n            self.tpl = self.env.from_string(self.source)\n        else:\n            self.tpl = self.env.get_template(self.name)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n    def loader(self, name):\n        if name == self.filename:\n            fname = name\n        else:\n            fname = self.search(name, self.lookup)\n        if not fname: return\n        with open(fname, \"rb\") as f:\n            return (f.read().decode(self.encoding), fname, lambda: False)\n\n\nclass SimpleTemplate(BaseTemplate):\n    def prepare(self,\n                escape_func=html_escape,\n                noescape=False,\n                syntax=None, **ka):\n        self.cache = {}\n        enc = self.encoding\n        self._str = lambda x: touni(x, enc)\n        self._escape = lambda x: escape_func(touni(x, enc))\n        self.syntax = syntax\n        if noescape:\n            self._str, self._escape = self._escape, self._str\n\n    @cached_property\n    def co(self):\n        return compile(self.code, self.filename or '<string>', 'exec')\n\n    @cached_property\n    def code(self):\n        source = self.source\n        if not source:\n            with open(self.filename, 'rb') as f:\n                source = f.read()\n        try:\n            source, encoding = touni(source), 'utf8'\n        except UnicodeError:\n            raise depr(0, 11, 'Unsupported template encodings.', 'Use utf-8 for templates.')\n        parser = StplParser(source, encoding=encoding, syntax=self.syntax)\n        code = parser.translate()\n        self.encoding = parser.encoding\n        return code\n\n    def _rebase(self, _env, _name=None, **kwargs):\n        _env['_rebase'] = (_name, kwargs)\n\n    def _include(self, _env, _name=None, **kwargs):\n        env = _env.copy()\n        env.update(kwargs)\n        if _name not in self.cache:\n            self.cache[_name] = self.__class__(name=_name, lookup=self.lookup, syntax=self.syntax)\n        return self.cache[_name].execute(env['_stdout'], env)\n\n    def execute(self, _stdout, kwargs):\n        env = self.defaults.copy()\n        env.update(kwargs)\n        env.update({\n            '_stdout': _stdout,\n            '_printlist': _stdout.extend,\n            'include': functools.partial(self._include, env),\n            'rebase': functools.partial(self._rebase, env),\n            '_rebase': None,\n            '_str': self._str,\n            '_escape': self._escape,\n            'get': env.get,\n            'setdefault': env.setdefault,\n            'defined': env.__contains__\n        })\n        exec(self.co, env)\n        if env.get('_rebase'):\n            subtpl, rargs = env.pop('_rebase')\n            rargs['base'] = ''.join(_stdout)  # copy stdout\n            del _stdout[:]  # clear stdout\n            return self._include(env, subtpl, **rargs)\n        return env\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template using keyword arguments as local variables. \"\"\"\n        env = {}\n        stdout = []\n        for dictarg in args:\n            env.update(dictarg)\n        env.update(kwargs)\n        self.execute(stdout, env)\n        return ''.join(stdout)\n\n\nclass StplSyntaxError(TemplateError):\n    pass\n\n\nclass StplParser(object):\n    \"\"\" Parser for stpl templates. \"\"\"\n    _re_cache = {}  #: Cache for compiled re patterns\n\n    # This huge pile of voodoo magic splits python code into 8 different tokens.\n    # We use the verbose (?x) regex mode to make this more manageable\n\n    _re_tok = r'''(\n        [urbURB]*\n        (?:  ''(?!')\n            |\"\"(?!\")\n            |'{6}\n            |\"{6}\n            |'(?:[^\\\\']|\\\\.)+?'\n            |\"(?:[^\\\\\"]|\\\\.)+?\"\n            |'{3}(?:[^\\\\]|\\\\.|\\n)+?'{3}\n            |\"{3}(?:[^\\\\]|\\\\.|\\n)+?\"{3}\n        )\n    )'''\n\n    _re_inl = _re_tok.replace(r'|\\n', '')  # We re-use this string pattern later\n\n    _re_tok += r'''\n        # 2: Comments (until end of line, but not the newline itself)\n        |(\\#.*)\n\n        # 3: Open and close (4) grouping tokens\n        |([\\[\\{\\(])\n        |([\\]\\}\\)])\n\n        # 5,6: Keywords that start or continue a python block (only start of line)\n        |^([\\ \\t]*(?:if|for|while|with|try|def|class)\\b)\n        |^([\\ \\t]*(?:elif|else|except|finally)\\b)\n\n        # 7: Our special 'end' keyword (but only if it stands alone)\n        |((?:^|;)[\\ \\t]*end[\\ \\t]*(?=(?:%(block_close)s[\\ \\t]*)?\\r?$|;|\\#))\n\n        # 8: A customizable end-of-code-block template token (only end of line)\n        |(%(block_close)s[\\ \\t]*(?=\\r?$))\n\n        # 9: And finally, a single newline. The 10th token is 'everything else'\n        |(\\r?\\n)\n    '''\n\n    # Match the start tokens of code areas in a template\n    _re_split = r'''(?m)^[ \\t]*(\\\\?)((%(line_start)s)|(%(block_start)s))'''\n    # Match inline statements (may contain python strings)\n    _re_inl = r'''%%(inline_start)s((?:%s|[^'\"\\n])*?)%%(inline_end)s''' % _re_inl\n\n    # add the flag in front of the regexp to avoid Deprecation warning (see Issue #949)\n    # verbose and dot-matches-newline mode\n    _re_tok = '(?mx)' + _re_tok\n    _re_inl = '(?mx)' + _re_inl\n\n\n    default_syntax = '<% %> % {{ }}'\n\n    def __init__(self, source, syntax=None, encoding='utf8'):\n        self.source, self.encoding = touni(source, encoding), encoding\n        self.set_syntax(syntax or self.default_syntax)\n        self.code_buffer, self.text_buffer = [], []\n        self.lineno, self.offset = 1, 0\n        self.indent, self.indent_mod = 0, 0\n        self.paren_depth = 0\n\n    def get_syntax(self):\n        \"\"\" Tokens as a space separated string (default: <% %> % {{ }}) \"\"\"\n        return self._syntax\n\n    def set_syntax(self, syntax):\n        self._syntax = syntax\n        self._tokens = syntax.split()\n        if syntax not in self._re_cache:\n            names = 'block_start block_close line_start inline_start inline_end'\n            etokens = map(re.escape, self._tokens)\n            pattern_vars = dict(zip(names.split(), etokens))\n            patterns = (self._re_split, self._re_tok, self._re_inl)\n            patterns = [re.compile(p % pattern_vars) for p in patterns]\n            self._re_cache[syntax] = patterns\n        self.re_split, self.re_tok, self.re_inl = self._re_cache[syntax]\n\n    syntax = property(get_syntax, set_syntax)\n\n    def translate(self):\n        if self.offset: raise RuntimeError('Parser is a one time instance.')\n        while True:\n            m = self.re_split.search(self.source, pos=self.offset)\n            if m:\n                text = self.source[self.offset:m.start()]\n                self.text_buffer.append(text)\n                self.offset = m.end()\n                if m.group(1):  # Escape syntax\n                    line, sep, _ = self.source[self.offset:].partition('\\n')\n                    self.text_buffer.append(self.source[m.start():m.start(1)] +\n                                            m.group(2) + line + sep)\n                    self.offset += len(line + sep)\n                    continue\n                self.flush_text()\n                self.offset += self.read_code(self.source[self.offset:],\n                                              multiline=bool(m.group(4)))\n            else:\n                break\n        self.text_buffer.append(self.source[self.offset:])\n        self.flush_text()\n        return ''.join(self.code_buffer)\n\n    def read_code(self, pysource, multiline):\n        code_line, comment = '', ''\n        offset = 0\n        while True:\n            m = self.re_tok.search(pysource, pos=offset)\n            if not m:\n                code_line += pysource[offset:]\n                offset = len(pysource)\n                self.write_code(code_line.strip(), comment)\n                break\n            code_line += pysource[offset:m.start()]\n            offset = m.end()\n            _str, _com, _po, _pc, _blk1, _blk2, _end, _cend, _nl = m.groups()\n            if self.paren_depth > 0 and (_blk1 or _blk2):  # a if b else c\n                code_line += _blk1 or _blk2\n                continue\n            if _str:  # Python string\n                code_line += _str\n            elif _com:  # Python comment (up to EOL)\n                comment = _com\n                if multiline and _com.strip().endswith(self._tokens[1]):\n                    multiline = False  # Allow end-of-block in comments\n            elif _po:  # open parenthesis\n                self.paren_depth += 1\n                code_line += _po\n            elif _pc:  # close parenthesis\n                if self.paren_depth > 0:\n                    # we could check for matching parentheses here, but it's\n                    # easier to leave that to python - just check counts\n                    self.paren_depth -= 1\n                code_line += _pc\n            elif _blk1:  # Start-block keyword (if/for/while/def/try/...)\n                code_line = _blk1\n                self.indent += 1\n                self.indent_mod -= 1\n            elif _blk2:  # Continue-block keyword (else/elif/except/...)\n                code_line = _blk2\n                self.indent_mod -= 1\n            elif _cend:  # The end-code-block template token (usually '%>')\n                if multiline: multiline = False\n                else: code_line += _cend\n            elif _end:\n                self.indent -= 1\n                self.indent_mod += 1\n            else:  # \\n\n                self.write_code(code_line.strip(), comment)\n                self.lineno += 1\n                code_line, comment, self.indent_mod = '', '', 0\n                if not multiline:\n                    break\n\n        return offset\n\n    def flush_text(self):\n        text = ''.join(self.text_buffer)\n        del self.text_buffer[:]\n        if not text: return\n        parts, pos, nl = [], 0, '\\\\\\n' + '  ' * self.indent\n        for m in self.re_inl.finditer(text):\n            prefix, pos = text[pos:m.start()], m.end()\n            if prefix:\n                parts.append(nl.join(map(repr, prefix.splitlines(True))))\n            if prefix.endswith('\\n'): parts[-1] += nl\n            parts.append(self.process_inline(m.group(1).strip()))\n        if pos < len(text):\n            prefix = text[pos:]\n            lines = prefix.splitlines(True)\n            if lines[-1].endswith('\\\\\\\\\\n'): lines[-1] = lines[-1][:-3]\n            elif lines[-1].endswith('\\\\\\\\\\r\\n'): lines[-1] = lines[-1][:-4]\n            parts.append(nl.join(map(repr, lines)))\n        code = '_printlist((%s,))' % ', '.join(parts)\n        self.lineno += code.count('\\n') + 1\n        self.write_code(code)\n\n    @staticmethod\n    def process_inline(chunk):\n        if chunk[0] == '!': return '_str(%s)' % chunk[1:]\n        return '_escape(%s)' % chunk\n\n    def write_code(self, line, comment=''):\n        code = '  ' * (self.indent + self.indent_mod)\n        code += line.lstrip() + comment + '\\n'\n        self.code_buffer.append(code)\n\n\ndef template(*args, **kwargs):\n    \"\"\"\n    Get a rendered template as a string iterator.\n    You can use a name, a filename or a template string as first parameter.\n    Template rendering arguments can be passed as dictionaries\n    or directly (as keyword arguments).\n    \"\"\"\n    tpl = args[0] if args else None\n    for dictarg in args[1:]:\n        kwargs.update(dictarg)\n    adapter = kwargs.pop('template_adapter', SimpleTemplate)\n    lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)\n    tplid = (id(lookup), tpl)\n    if tplid not in TEMPLATES or DEBUG:\n        settings = kwargs.pop('template_settings', {})\n        if isinstance(tpl, adapter):\n            TEMPLATES[tplid] = tpl\n            if settings: TEMPLATES[tplid].prepare(**settings)\n        elif \"\\n\" in tpl or \"{\" in tpl or \"%\" in tpl or '$' in tpl:\n            TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)\n        else:\n            TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)\n    if not TEMPLATES[tplid]:\n        abort(500, 'Template (%s) not found' % tpl)\n    return TEMPLATES[tplid].render(kwargs)\n\n\nmako_template = functools.partial(template, template_adapter=MakoTemplate)\ncheetah_template = functools.partial(template,\n                                     template_adapter=CheetahTemplate)\njinja2_template = functools.partial(template, template_adapter=Jinja2Template)\n\n\ndef view(tpl_name, **defaults):\n    \"\"\" Decorator: renders a template for a handler.\n        The handler can control its behavior like that:\n\n          - return a dict of template vars to fill out the template\n          - return something other than a dict and the view decorator will not\n            process the template, but return the handler result as is.\n            This includes returning a HTTPResponse(dict) to get,\n            for instance, JSON with autojson or other castfilters.\n    \"\"\"\n\n    def decorator(func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            if isinstance(result, (dict, DictMixin)):\n                tplvars = defaults.copy()\n                tplvars.update(result)\n                return template(tpl_name, **tplvars)\n            elif result is None:\n                return template(tpl_name, **defaults)\n            return result\n\n        return wrapper\n\n    return decorator\n\n\nmako_view = functools.partial(view, template_adapter=MakoTemplate)\ncheetah_view = functools.partial(view, template_adapter=CheetahTemplate)\njinja2_view = functools.partial(view, template_adapter=Jinja2Template)\n\n###############################################################################\n# Constants and Globals ########################################################\n###############################################################################\n\nTEMPLATE_PATH = ['./', './views/']\nTEMPLATES = {}\nDEBUG = False\nNORUN = False  # If set, run() does nothing. Used by load_app()\n\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\nHTTP_CODES = httplib.responses.copy()\nHTTP_CODES[418] = \"I'm a teapot\"  # RFC 2324\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[451] = \"Unavailable For Legal Reasons\" # RFC 7725\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s' % (k, v))\n                          for (k, v) in HTTP_CODES.items())\n\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, request\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n    <html>\n        <head>\n            <title>Error: {{e.status}}</title>\n            <style type=\"text/css\">\n              html {background-color: #eee; font-family: sans-serif;}\n              body {background-color: #fff; border: 1px solid #ddd;\n                    padding: 15px; margin: 15px;}\n              pre {background-color: #eee; border: 1px solid #ddd; padding: 5px;}\n            </style>\n        </head>\n        <body>\n            <h1>Error: {{e.status}}</h1>\n            <p>Sorry, the requested URL <tt>{{repr(request.url)}}</tt>\n               caused an error:</p>\n            <pre>{{e.body}}</pre>\n            %%if DEBUG and e.exception:\n              <h2>Exception:</h2>\n              %%try:\n                %%exc = repr(e.exception)\n              %%except:\n                %%exc = '<unprintable %%s object>' %% type(e.exception).__name__\n              %%end\n              <pre>{{exc}}</pre>\n            %%end\n            %%if DEBUG and e.traceback:\n              <h2>Traceback:</h2>\n              <pre>{{e.traceback}}</pre>\n            %%end\n        </body>\n    </html>\n%%except ImportError:\n    <b>ImportError:</b> Could not generate the error page. Please add bottle to\n    the import path.\n%%end\n\"\"\" % __name__\n\n#: A thread-safe instance of :class:`LocalRequest`. If accessed from within a\n#: request callback, this instance always refers to the *current* request\n#: (even on a multi-threaded server).\nrequest = LocalRequest()\n\n#: A thread-safe instance of :class:`LocalResponse`. It is used to change the\n#: HTTP response for the *current* request.\nresponse = LocalResponse()\n\n#: A thread-safe namespace. Not used by Bottle.\nlocal = threading.local()\n\n# Initialize app stack (create first empty Bottle app now deferred until needed)\n# BC: 0.6.4 and needed for run()\napps = app = default_app = AppStack()\n\n#: A virtual package that redirects import statements.\n#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.\next = _ImportRedirect('bottle.ext' if __name__ == '__main__' else\n                      __name__ + \".ext\", 'bottle_%s').module\n\n\ndef _main(argv):  # pragma: no coverage\n    args, parser = _cli_parse(argv)\n\n    def _cli_error(cli_msg):\n        parser.print_help()\n        _stderr('\\nError: %s\\n' % cli_msg)\n        sys.exit(1)\n\n    if args.version:\n        print(__version__)\n        sys.exit(0)\n    if not args.app:\n        _cli_error(\"No application entry point specified.\")\n\n    sys.path.insert(0, '.')\n    sys.modules.setdefault('bottle', sys.modules['__main__'])\n\n    host, port = (args.bind or 'localhost'), 8080\n    if ':' in host and host.rfind(']') < host.rfind(':'):\n        host, port = host.rsplit(':', 1)\n    host = host.strip('[]')\n\n    config = ConfigDict()\n\n    for cfile in args.conf or []:\n        try:\n            if cfile.endswith('.json'):\n                with open(cfile, 'rb') as fp:\n                    config.load_dict(json_loads(fp.read()))\n            else:\n                config.load_config(cfile)\n        except configparser.Error as parse_error:\n            _cli_error(parse_error)\n        except IOError:\n            _cli_error(\"Unable to read config file %r\" % cfile)\n        except (UnicodeError, TypeError, ValueError) as error:\n            _cli_error(\"Unable to parse config file %r: %s\" % (cfile, error))\n\n    for cval in args.param or []:\n        if '=' in cval:\n            config.update((cval.split('=', 1),))\n        else:\n            config[cval] = True\n\n    run(args.app,\n        host=host,\n        port=int(port),\n        server=args.server,\n        reloader=args.reload,\n        plugins=args.plugin,\n        debug=args.debug,\n        config=config)\n\n\ndef main():\n    _main(sys.argv)\n\n\nif __name__ == '__main__':  # pragma: no coverage\n    main()\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 1.689453125,
          "content": "[build-system]\nrequires = [\"flit_core >=3.9,<4\"]\nbuild-backend = \"flit_core.buildapi\"\n\n[project]\nname = \"bottle\"\ndynamic = [\"version\"]\nrequires-python = \">=3.8\"\nlicense = {file = \"LICENSE\"}\ndescription = \"Fast and simple WSGI-framework for small web-applications.\"\nreadme = \"README.rst\"\nkeywords = [\"bottle\", \"wsgi\", \"microframework\"]\nauthors = [\n  {name = \"Marcel Hellkamp\", email = \"marc@gsites.de\"},\n]\nclassifiers = [\n    \"Development Status :: 6 - Mature\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n    \"Framework :: Bottle\",\n    \"Topic :: Internet :: WWW/HTTP\",\n    \"Topic :: Internet :: WWW/HTTP :: Dynamic Content\",\n    \"Topic :: Internet :: WWW/HTTP :: Dynamic Content :: CGI Tools/Libraries\",\n    \"Topic :: Internet :: WWW/HTTP :: WSGI\",\n    \"Topic :: Internet :: WWW/HTTP :: WSGI :: Application\",\n    \"Topic :: Internet :: WWW/HTTP :: WSGI :: Middleware\",\n    \"Topic :: Internet :: WWW/HTTP :: WSGI :: Server\",\n    \"Topic :: Software Development :: Libraries :: Application Frameworks\",\n    \"Programming Language :: Python :: 3\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest\",\n    \"pytest-cov\",\n    \"sphinx\",\n    \"sphinx-autobuild\",\n    \"sphinx-intl\",\n    \"build\",\n    \"twine\",\n]\n\n[project.urls]\nHomepage = \"https://bottlepy.org\"\nDocumentation = \"https://bottlepy.org\"\nRepository = \"http://github.com/bottlepy/bottle.git\"\nIssues = \"https://github.com/bottlepy/bottle/issues\"\nChangelog = \"https://bottlepy.org/docs/dev/changelog.html\"\n\n[project.scripts]\n\"bottle\" = \"bottle:main\"\n\n[tool.flit.sdist]\ninclude = [\n  \"test/*.py\",\n  \"test/views/*.tpl\",\n  \"AUTHORS\"\n]\n\n[tool.pytest.ini_options]\naddopts = \"-ra\"\ntestpaths = [ \"test\" ]"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}