{
  "metadata": {
    "timestamp": 1736560864570,
    "page": 575,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "corpnewt/gibMacOS",
      "stars": 6033,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.11328125,
          "content": "# Ensure all .bat scripts use CRLF line endings\n# This can prevent a number of odd batch issues\n*.bat text eol=crlf\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.2724609375,
          "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# Ignore hidden files\n.*\n\n# Ignore our save directory\nmacOS Downloads\n\n# Ignore dd\nddrelease64.exe\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n.hypothesis/\n.pytest_cache/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# pyenv\n.python-version\n\n# celery beat schedule file\ncelerybeat-schedule\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n"
        },
        {
          "name": "BuildmacOSInstallApp.command",
          "type": "blob",
          "size": 9.7861328125,
          "content": "#!/usr/bin/env bash\n\n# Get the curent directory, the script name\n# and the script name with \"py\" substituted for the extension.\nargs=( \"$@\" )\ndir=\"$(cd -- \"$(dirname \"$0\")\" >/dev/null 2>&1; pwd -P)\"\nscript=\"${0##*/}\"\ntarget=\"${script%.*}.py\"\n\n# use_py3:\n#   TRUE  = Use if found, use py2 otherwise\n#   FALSE = Use py2\n#   FORCE = Use py3\nuse_py3=\"TRUE\"\n\n# We'll parse if the first argument passed is\n# --install-python and if so, we'll just install\njust_installing=\"FALSE\"\n\ntempdir=\"\"\n\ncompare_to_version () {\n    # Compares our OS version to the passed OS version, and\n    # return a 1 if we match the passed compare type, or a 0 if we don't.\n    # $1 = 0 (equal), 1 (greater), 2 (less), 3 (gequal), 4 (lequal)\n    # $2 = OS version to compare ours to\n    if [ -z \"$1\" ] || [ -z \"$2\" ]; then\n        # Missing info - bail.\n        return\n    fi\n    local current_os= comp=\n    current_os=\"$(sw_vers -productVersion)\"\n    comp=\"$(vercomp \"$current_os\" \"$2\")\"\n    # Check gequal and lequal first\n    if [[ \"$1\" == \"3\" && (\"$comp\" == \"1\" || \"$comp\" == \"0\") ]] || [[ \"$1\" == \"4\" && (\"$comp\" == \"2\" || \"$comp\" == \"0\") ]] || [[ \"$comp\" == \"$1\" ]]; then\n        # Matched\n        echo \"1\"\n    else\n        # No match\n        echo \"0\"\n    fi\n}\n\nset_use_py3_if () {\n    # Auto sets the \"use_py3\" variable based on\n    # conditions passed\n    # $1 = 0 (equal), 1 (greater), 2 (less), 3 (gequal), 4 (lequal)\n    # $2 = OS version to compare\n    # $3 = TRUE/FALSE/FORCE in case of match\n    if [ -z \"$1\" ] || [ -z \"$2\" ] || [ -z \"$3\" ]; then\n        # Missing vars - bail with no changes.\n        return\n    fi\n    if [ \"$(compare_to_version \"$1\" \"$2\")\" == \"1\" ]; then\n        use_py3=\"$3\"\n    fi\n}\n\nget_remote_py_version () {\n    local pyurl= py_html= py_vers= py_num=\"3\"\n    pyurl=\"https://www.python.org/downloads/macos/\"\n    py_html=\"$(curl -L $pyurl --compressed 2>&1)\"\n    if [ -z \"$use_py3\" ]; then\n        use_py3=\"TRUE\"\n    fi\n    if [ \"$use_py3\" == \"FALSE\" ]; then\n        py_num=\"2\"\n    fi\n    py_vers=\"$(echo \"$py_html\" | grep -i \"Latest Python $py_num Release\" | awk '{print $8}' | cut -d'<' -f1)\"\n    echo \"$py_vers\"\n}\n\ndownload_py () {\n    local vers=\"$1\" url=\n    clear\n    echo \"  ###                        ###\"\n    echo \" #     Downloading Python     #\"\n    echo \"###                        ###\"\n    echo\n    if [ -z \"$vers\" ]; then\n        echo \"Gathering latest version...\"\n        vers=\"$(get_remote_py_version)\"\n    fi\n    if [ -z \"$vers\" ]; then\n        # Didn't get it still - bail\n        print_error\n    fi\n    echo \"Located Version:  $vers\"\n    echo\n    echo \"Building download url...\"\n    url=\"$(curl -L https://www.python.org/downloads/release/python-${vers//./}/ --compressed 2>&1 | grep -iE \"python-$vers-macos.*.pkg\\\"\" | awk -F'\"' '{ print $2 }')\"\n    if [ -z \"$url\" ]; then\n        # Couldn't get the URL - bail\n        print_error\n    fi\n    echo \" - $url\"\n    echo\n    echo \"Downloading...\"\n    echo\n    # Create a temp dir and download to it\n    tempdir=\"$(mktemp -d 2>/dev/null || mktemp -d -t 'tempdir')\"\n    curl \"$url\" -o \"$tempdir/python.pkg\"\n    if [ \"$?\" != \"0\" ]; then\n        echo\n        echo \" - Failed to download python installer!\"\n        echo\n        exit $?\n    fi\n    echo\n    echo \"Running python install package...\"\n    echo\n    sudo installer -pkg \"$tempdir/python.pkg\" -target /\n    if [ \"$?\" != \"0\" ]; then\n        echo\n        echo \" - Failed to install python!\"\n        echo\n        exit $?\n    fi\n    # Now we expand the package and look for a shell update script\n    pkgutil --expand \"$tempdir/python.pkg\" \"$tempdir/python\"\n    if [ -e \"$tempdir/python/Python_Shell_Profile_Updater.pkg/Scripts/postinstall\" ]; then\n        # Run the script\n        echo\n        echo \"Updating PATH...\"\n        echo\n        \"$tempdir/python/Python_Shell_Profile_Updater.pkg/Scripts/postinstall\"\n    fi\n    vers_folder=\"Python $(echo \"$vers\" | cut -d'.' -f1 -f2)\"\n    if [ -f \"/Applications/$vers_folder/Install Certificates.command\" ]; then\n        # Certs script exists - let's execute that to make sure our certificates are updated\n        echo\n        echo \"Updating Certificates...\"\n        echo\n        \"/Applications/$vers_folder/Install Certificates.command\"\n    fi\n    echo\n    echo \"Cleaning up...\"\n    cleanup\n    echo\n    if [ \"$just_installing\" == \"TRUE\" ]; then\n        echo \"Done.\"\n    else\n        # Now we check for py again\n        echo \"Rechecking py...\"\n        downloaded=\"TRUE\"\n        clear\n        main\n    fi\n}\n\ncleanup () {\n    if [ -d \"$tempdir\" ]; then\n        rm -Rf \"$tempdir\"\n    fi\n}\n\nprint_error() {\n    clear\n    cleanup\n    echo \"  ###                      ###\"\n    echo \" #     Python Not Found     #\"\n    echo \"###                      ###\"\n    echo\n    echo \"Python is not installed or not found in your PATH var.\"\n    echo\n    if [ \"$kernel\" == \"Darwin\" ]; then\n        echo \"Please go to https://www.python.org/downloads/macos/ to\"\n        echo \"download and install the latest version, then try again.\"\n    else\n        echo \"Please install python through your package manager and\"\n        echo \"try again.\"\n    fi\n    echo\n    exit 1\n}\n\nprint_target_missing() {\n    clear\n    cleanup\n    echo \"  ###                      ###\"\n    echo \" #     Target Not Found     #\"\n    echo \"###                      ###\"\n    echo\n    echo \"Could not locate $target!\"\n    echo\n    exit 1\n}\n\nformat_version () {\n    local vers=\"$1\"\n    echo \"$(echo \"$1\" | awk -F. '{ printf(\"%d%03d%03d%03d\\n\", $1,$2,$3,$4); }')\"\n}\n\nvercomp () {\n    # Modified from: https://apple.stackexchange.com/a/123408/11374\n    local ver1=\"$(format_version \"$1\")\" ver2=\"$(format_version \"$2\")\"\n    if [ $ver1 -gt $ver2 ]; then\n        echo \"1\"\n    elif [ $ver1 -lt $ver2 ]; then\n        echo \"2\"\n    else\n        echo \"0\"\n    fi\n}\n\nget_local_python_version() {\n    # $1 = Python bin name (defaults to python3)\n    # Echoes the path to the highest version of the passed python bin if any\n    local py_name=\"$1\" max_version= python= python_version= python_path=\n    if [ -z \"$py_name\" ]; then\n        py_name=\"python3\"\n    fi\n    py_list=\"$(which -a \"$py_name\" 2>/dev/null)\"\n    # Walk that newline separated list\n    while read python; do\n        if [ -z \"$python\" ]; then\n            # Got a blank line - skip\n            continue\n        fi\n        if [ \"$check_py3_stub\" == \"1\" ] && [ \"$python\" == \"/usr/bin/python3\" ]; then\n            # See if we have a valid developer path\n            xcode-select -p > /dev/null 2>&1\n            if [ \"$?\" != \"0\" ]; then\n                # /usr/bin/python3 path - but no valid developer dir\n                continue\n            fi\n        fi\n        python_version=\"$(get_python_version $python)\"\n        if [ -z \"$python_version\" ]; then\n            # Didn't find a py version - skip\n            continue\n        fi\n        # Got the py version - compare to our max\n        if [ -z \"$max_version\" ] || [ \"$(vercomp \"$python_version\" \"$max_version\")\" == \"1\" ]; then\n            # Max not set, or less than the current - update it\n            max_version=\"$python_version\"\n            python_path=\"$python\"\n        fi\n    done <<< \"$py_list\"\n    echo \"$python_path\"\n}\n\nget_python_version() {\n    local py_path=\"$1\" py_version=\n    # Get the python version by piping stderr into stdout (for py2), then grepping the output for\n    # the word \"python\", getting the second element, and grepping for an alphanumeric version number\n    py_version=\"$($py_path -V 2>&1 | grep -i python | cut -d' ' -f2 | grep -E \"[A-Za-z\\d\\.]+\")\"\n    if [ ! -z \"$py_version\" ]; then\n        echo \"$py_version\"\n    fi\n}\n\nprompt_and_download() {\n    if [ \"$downloaded\" != \"FALSE\" ] || [ \"$kernel\" != \"Darwin\" ]; then\n        # We already tried to download, or we're not on macOS - just bail\n        print_error\n    fi\n    clear\n    echo \"  ###                      ###\"\n    echo \" #     Python Not Found     #\"\n    echo \"###                      ###\"\n    echo\n    target_py=\"Python 3\"\n    printed_py=\"Python 2 or 3\"\n    if [ \"$use_py3\" == \"FORCE\" ]; then\n        printed_py=\"Python 3\"\n    elif [ \"$use_py3\" == \"FALSE\" ]; then\n        target_py=\"Python 2\"\n        printed_py=\"Python 2\"\n    fi\n    echo \"Could not locate $printed_py!\"\n    echo\n    echo \"This script requires $printed_py to run.\"\n    echo\n    while true; do\n        read -p \"Would you like to install the latest $target_py now? (y/n):  \" yn\n        case $yn in\n            [Yy]* ) download_py;break;;\n            [Nn]* ) print_error;;\n        esac\n    done\n}\n\nmain() {\n    local python= version=\n    # Verify our target exists\n    if [ ! -f \"$dir/$target\" ]; then\n        # Doesn't exist\n        print_target_missing\n    fi\n    if [ -z \"$use_py3\" ]; then\n        use_py3=\"TRUE\"\n    fi\n    if [ \"$use_py3\" != \"FALSE\" ]; then\n        # Check for py3 first\n        python=\"$(get_local_python_version python3)\"\n    fi\n    if [ \"$use_py3\" != \"FORCE\" ] && [ -z \"$python\" ]; then\n        # We aren't using py3 explicitly, and we don't already have a path\n        python=\"$(get_local_python_version python2)\"\n        if [ -z \"$python\" ]; then\n            # Try just looking for \"python\"\n            python=\"$(get_local_python_version python)\"\n        fi\n    fi\n    if [ -z \"$python\" ]; then\n        # Didn't ever find it - prompt\n        prompt_and_download\n        return 1\n    fi\n    # Found it - start our script and pass all args\n    \"$python\" \"$dir/$target\" \"${args[@]}\"\n}\n\n# Keep track of whether or not we're on macOS to determine if\n# we can download and install python for the user as needed.\nkernel=\"$(uname -s)\"\n# Check to see if we need to force based on\n# macOS version. 10.15 has a dummy python3 version\n# that can trip up some py3 detection in other scripts.\n# set_use_py3_if \"3\" \"10.15\" \"FORCE\"\ndownloaded=\"FALSE\"\n# Check for the aforementioned /usr/bin/python3 stub if\n# our OS version is 10.15 or greater.\ncheck_py3_stub=\"$(compare_to_version \"3\" \"10.15\")\"\ntrap cleanup EXIT\nif [ \"$1\" == \"--install-python\" ] && [ \"$kernel\" == \"Darwin\" ]; then\n    just_installing=\"TRUE\"\n    download_py\nelse\n    main\nfi\n"
        },
        {
          "name": "BuildmacOSInstallApp.py",
          "type": "blob",
          "size": 8.4169921875,
          "content": "#!/usr/bin/env python\nfrom Scripts import *\nimport os, datetime, shutil, time, sys, argparse\n\n# Using the techniques outlined by wolfmannight here:  https://www.insanelymac.com/forum/topic/338810-create-legit-copy-of-macos-from-apple-catalog/\n\nclass buildMacOSInstallApp:\n    def __init__(self):\n        self.r = run.Run()\n        self.u = utils.Utils(\"Build macOS Install App\")\n        self.target_files = [\n            \"BaseSystem.dmg\",\n            \"BaseSystem.chunklist\",\n            \"InstallESDDmg.pkg\",\n            \"InstallInfo.plist\",\n            \"AppleDiagnostics.dmg\",\n            \"AppleDiagnostics.chunklist\"\n        ]\n        # Verify we're on macOS - this doesn't work anywhere else\n        if not sys.platform == \"darwin\":\n            self.u.head(\"WARNING\")\n            print(\"\")\n            print(\"This script only runs on macOS!\")\n            print(\"\")\n            exit(1)\n\n    def mount_dmg(self, dmg, no_browse = False):\n        # Mounts the passed dmg and returns the mount point(s)\n        args = [\"/usr/bin/hdiutil\", \"attach\", dmg, \"-plist\", \"-noverify\"]\n        if no_browse:\n            args.append(\"-nobrowse\")\n        out = self.r.run({\"args\":args})\n        if out[2] != 0:\n            # Failed!\n            raise Exception(\"Mount Failed!\", \"{} failed to mount:\\n\\n{}\".format(os.path.basename(dmg), out[1]))\n        # Get the plist data returned, and locate the mount points\n        try:\n            plist_data = plist.loads(out[0])\n            mounts = [x[\"mount-point\"] for x in plist_data.get(\"system-entities\", []) if \"mount-point\" in x]\n            return mounts\n        except:\n            raise Exception(\"Mount Failed!\", \"No mount points returned from {}\".format(os.path.basename(dmg)))\n\n    def unmount_dmg(self, mount_point):\n        # Unmounts the passed dmg or mount point - retries with force if failed\n        # Can take either a single point or a list\n        if not type(mount_point) is list:\n            mount_point = [mount_point]\n        unmounted = []\n        for m in mount_point:    \n            args = [\"/usr/bin/hdiutil\", \"detach\", m]\n            out = self.r.run({\"args\":args})\n            if out[2] != 0:\n                # Polite failed, let's crush this b!\n                args.append(\"-force\")\n                out = self.r.run({\"args\":args})\n                if out[2] != 0:\n                    # Oh... failed again... onto the next...\n                    print(out[1])\n                    continue\n            unmounted.append(m)\n        return unmounted\n\n    def main(self):\n        while True:\n            self.u.head()\n            print(\"\")\n            print(\"Q. Quit\")\n            print(\"\")\n            fold = self.u.grab(\"Please drag and drop the output folder from gibMacOS here:  \")\n            print(\"\")\n            if fold.lower() == \"q\":\n                self.u.custom_quit()\n            f_path = self.u.check_path(fold)\n            if not f_path:\n                print(\"That path does not exist!\\n\")\n                self.u.grab(\"Press [enter] to return...\")\n                continue\n            # Let's check if it's a folder.  If not, make the next directory up the target\n            if not os.path.isdir(f_path):\n                f_path = os.path.dirname(os.path.realpath(f_path))\n            # Walk the contents of f_path and ensure we have all the needed files\n            lower_contents = [y.lower() for y in os.listdir(f_path)]\n            # Check if we got an InstallAssistant.pkg - and if so, just open that\n            if \"installassistant.pkg\" in lower_contents:\n                self.u.head(\"InstallAssistant.pkg Found\")\n                print(\"\")\n                print(\"Located InstallAssistant.pkg in the passed folder.\\n\")\n                print(\"As of macOS Big Sur (11.x), Apple changed how they distribute the OS files in\")\n                print(\"the software update catalog.\\n\")\n                print(\"Double clicking the InstallAssistant.pkg will open it in Installer, which will\")\n                print(\"copy the Install macOS [version].app to your /Applications folder.\\n\")\n                print(\"Opening InstallAssistant.pkg...\")\n                self.r.run({\"args\":[\"open\",os.path.join(f_path,\"InstallAssistant.pkg\")]})\n                print(\"\")\n                self.u.grab(\"Press [enter] to return...\")\n                continue\n            missing_list = [x for x in self.target_files if not x.lower() in lower_contents]\n            if len(missing_list):\n                self.u.head(\"Missing Required Files\")\n                print(\"\")\n                print(\"That folder is missing the following required files:\")\n                print(\", \".join(missing_list))\n                print(\"\")\n                self.u.grab(\"Press [enter] to return...\")\n            # Time to build the installer!\n            cwd = os.getcwd()\n            os.chdir(f_path)\n            base_mounts = []\n            try:\n                self.u.head(\"Building Installer\")\n                print(\"\")\n                print(\"Taking ownership of downloaded files...\")\n                for x in self.target_files:\n                    print(\" - {}...\".format(x))\n                    self.r.run({\"args\":[\"chmod\",\"a+x\",x]})\n                print(\"Mounting BaseSystem.dmg...\")\n                base_mounts = self.mount_dmg(\"BaseSystem.dmg\")\n                if not len(base_mounts):\n                    raise Exception(\"Mount Failed!\", \"No mount points were returned from BaseSystem.dmg\")\n                base_mount = base_mounts[0] # Let's assume the first\n                print(\"Locating Installer app...\")\n                install_app = next((x for x in os.listdir(base_mount) if os.path.isdir(os.path.join(base_mount,x)) and x.lower().endswith(\".app\") and not x.startswith(\".\")),None)\n                if not install_app:\n                    raise Exception(\"Installer app not located in {}\".format(base_mount))\n                print(\" - Found {}\".format(install_app))\n                # Copy the .app over\n                out = self.r.run({\"args\":[\"cp\",\"-R\",os.path.join(base_mount,install_app),os.path.join(f_path,install_app)]})\n                if out[2] != 0:\n                    raise Exception(\"Copy Failed!\", out[1])\n                print(\"Unmounting BaseSystem.dmg...\")\n                for x in base_mounts:\n                    self.unmount_dmg(x)\n                base_mounts = []\n                shared_support = os.path.join(f_path,install_app,\"Contents\",\"SharedSupport\")\n                if not os.path.exists(shared_support):\n                    print(\"Creating SharedSupport directory...\")\n                    os.makedirs(shared_support)\n                print(\"Copying files to SharedSupport...\")\n                for x in self.target_files:\n                    y = \"InstallESD.dmg\" if x.lower() == \"installesddmg.pkg\" else x # InstallESDDmg.pkg gets renamed to InstallESD.dmg - all others stay the same\n                    print(\" - {}{}\".format(x, \" --> {}\".format(y) if y != x else \"\"))\n                    out = self.r.run({\"args\":[\"cp\",\"-R\",os.path.join(f_path,x),os.path.join(shared_support,y)]})\n                    if out[2] != 0:\n                        raise Exception(\"Copy Failed!\", out[1])\n                print(\"Patching InstallInfo.plist...\")\n                with open(os.path.join(shared_support,\"InstallInfo.plist\"),\"rb\") as f:\n                    p = plist.load(f)\n                if \"Payload Image Info\" in p:\n                    pii = p[\"Payload Image Info\"]\n                    if \"URL\" in pii: pii[\"URL\"] = pii[\"URL\"].replace(\"InstallESDDmg.pkg\",\"InstallESD.dmg\")\n                    if \"id\" in pii: pii[\"id\"] = pii[\"id\"].replace(\"com.apple.pkg.InstallESDDmg\",\"com.apple.dmg.InstallESD\")\n                    pii.pop(\"chunklistURL\",None)\n                    pii.pop(\"chunklistid\",None)\n                with open(os.path.join(shared_support,\"InstallInfo.plist\"),\"wb\") as f:\n                    plist.dump(p,f)\n                print(\"\")\n                print(\"Created:  {}\".format(install_app))\n                print(\"Saved to: {}\".format(os.path.join(f_path,install_app)))\n                print(\"\")\n                self.u.grab(\"Press [enter] to return...\")\n            except Exception as e:\n                print(\"An error occurred:\")\n                print(\" - {}\".format(e))\n                print(\"\")\n                if len(base_mounts):\n                    for x in base_mounts:\n                        print(\" - Unmounting {}...\".format(x))\n                        self.unmount_dmg(x)\n                    print(\"\")\n                self.u.grab(\"Press [enter] to return...\")\n\nif __name__ == '__main__':\n    b = buildMacOSInstallApp()\n    b.main()\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0400390625,
          "content": "MIT License\n\nCopyright (c) 2018 CorpNewt\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "MakeInstall.bat",
          "type": "blob",
          "size": 12.8134765625,
          "content": "@echo off\nREM Get our local path before delayed expansion - allows ! in path\nset \"thisDir=%~dp0\"\n\nsetlocal enableDelayedExpansion\nREM Setup initial vars\nset \"script_name=\"\nset /a tried=0\nset \"toask=yes\"\nset \"pause_on_error=yes\"\nset \"py2v=\"\nset \"py2path=\"\nset \"py3v=\"\nset \"py3path=\"\nset \"pypath=\"\nset \"targetpy=3\"\n\nREM use_py3:\nREM   TRUE  = Use if found, use py2 otherwise\nREM   FALSE = Use py2\nREM   FORCE = Use py3\nset \"use_py3=TRUE\"\n\nREM We'll parse if the first argument passed is\nREM --install-python and if so, we'll just install\nset \"just_installing=FALSE\"\n\nREM Get the system32 (or equivalent) path\ncall :getsyspath \"syspath\"\n\nREM Make sure the syspath exists\nif \"!syspath!\" == \"\" (\n    if exist \"%SYSTEMROOT%\\system32\\cmd.exe\" (\n        if exist \"%SYSTEMROOT%\\system32\\reg.exe\" (\n            if exist \"%SYSTEMROOT%\\system32\\where.exe\" (\n                REM Fall back on the default path if it exists\n                set \"ComSpec=%SYSTEMROOT%\\system32\\cmd.exe\"\n                set \"syspath=%SYSTEMROOT%\\system32\\\"\n            )\n        )\n    )\n    if \"!syspath!\" == \"\" (\n        cls\n        echo   ###     ###\n        echo  # Warning #\n        echo ###     ###\n        echo.\n        echo Could not locate cmd.exe, reg.exe, or where.exe\n        echo.\n        echo Please ensure your ComSpec environment variable is properly configured and\n        echo points directly to cmd.exe, then try again.\n        echo.\n        echo Current CompSpec Value: \"%ComSpec%\"\n        echo.\n        echo Press [enter] to quit.\n        pause > nul\n        exit /b 1\n    )\n)\n\nif \"%~1\" == \"--install-python\" (\n    set \"just_installing=TRUE\"\n    goto installpy\n)\n\ngoto checkscript\n\n:checkscript\nREM Check for our script first\nset \"looking_for=!script_name!\"\nif \"!script_name!\" == \"\" (\n    set \"looking_for=%~n0.py or %~n0.command\"\n    set \"script_name=%~n0.py\"\n    if not exist \"!thisDir!\\!script_name!\" (\n        set \"script_name=%~n0.command\"\n    )\n)\nif not exist \"!thisDir!\\!script_name!\" (\n    echo Could not find !looking_for!.\n    echo Please make sure to run this script from the same directory\n    echo as !looking_for!.\n    echo.\n    echo Press [enter] to quit.\n    pause > nul\n    exit /b 1\n)\ngoto checkpy\n\n:checkpy\ncall :updatepath\nfor /f \"USEBACKQ tokens=*\" %%x in (`!syspath!where.exe python 2^> nul`) do ( call :checkpyversion \"%%x\" \"py2v\" \"py2path\" \"py3v\" \"py3path\" )\nfor /f \"USEBACKQ tokens=*\" %%x in (`!syspath!where.exe python3 2^> nul`) do ( call :checkpyversion \"%%x\" \"py2v\" \"py2path\" \"py3v\" \"py3path\" )\nfor /f \"USEBACKQ tokens=*\" %%x in (`!syspath!where.exe py 2^> nul`) do ( call :checkpylauncher \"%%x\" \"py2v\" \"py2path\" \"py3v\" \"py3path\" )\nREM Walk our returns to see if we need to install\nif /i \"!use_py3!\" == \"FALSE\" (\n    set \"targetpy=2\"\n    set \"pypath=!py2path!\"\n) else if /i \"!use_py3!\" == \"FORCE\" (\n    set \"pypath=!py3path!\"\n) else if /i \"!use_py3!\" == \"TRUE\" (\n    set \"pypath=!py3path!\"\n    if \"!pypath!\" == \"\" set \"pypath=!py2path!\"\n)\nif not \"!pypath!\" == \"\" (\n    goto runscript\n)\nif !tried! lss 1 (\n    if /i \"!toask!\"==\"yes\" (\n        REM Better ask permission first\n        goto askinstall\n    ) else (\n        goto installpy\n    )\n) else (\n    cls\n    echo   ###     ###\n    echo  # Warning #\n    echo ###     ###\n    echo.\n    REM Couldn't install for whatever reason - give the error message\n    echo Python is not installed or not found in your PATH var.\n    echo Please install it from https://www.python.org/downloads/windows/\n    echo.\n    echo Make sure you check the box labeled:\n    echo.\n    echo \"Add Python X.X to PATH\"\n    echo.\n    echo Where X.X is the py version you're installing.\n    echo.\n    echo Press [enter] to quit.\n    pause > nul\n    exit /b 1\n)\ngoto runscript\n\n:checkpylauncher <path> <py2v> <py2path> <py3v> <py3path>\nREM Attempt to check the latest python 2 and 3 versions via the py launcher\nfor /f \"USEBACKQ tokens=*\" %%x in (`%~1 -2 -c \"import sys; print(sys.executable)\" 2^> nul`) do ( call :checkpyversion \"%%x\" \"%~2\" \"%~3\" \"%~4\" \"%~5\" )\nfor /f \"USEBACKQ tokens=*\" %%x in (`%~1 -3 -c \"import sys; print(sys.executable)\" 2^> nul`) do ( call :checkpyversion \"%%x\" \"%~2\" \"%~3\" \"%~4\" \"%~5\" )\ngoto :EOF\n\n:checkpyversion <path> <py2v> <py2path> <py3v> <py3path>\nset \"version=\"&for /f \"tokens=2* USEBACKQ delims= \" %%a in (`\"%~1\" -V 2^>^&1`) do (\n    REM Ensure we have a version number\n    call :isnumber \"%%a\"\n    if not \"!errorlevel!\" == \"0\" goto :EOF\n    set \"version=%%a\"\n)\nif not defined version goto :EOF\nif \"!version:~0,1!\" == \"2\" (\n    REM Python 2\n    call :comparepyversion \"!version!\" \"!%~2!\"\n    if \"!errorlevel!\" == \"1\" (\n        set \"%~2=!version!\"\n        set \"%~3=%~1\"\n    )\n) else (\n    REM Python 3\n    call :comparepyversion \"!version!\" \"!%~4!\"\n    if \"!errorlevel!\" == \"1\" (\n        set \"%~4=!version!\"\n        set \"%~5=%~1\"\n    )\n)\ngoto :EOF\n\n:isnumber <check_value>\nset \"var=\"&for /f \"delims=0123456789.\" %%i in (\"%~1\") do set var=%%i\nif defined var (exit /b 1)\nexit /b 0\n\n:comparepyversion <version1> <version2> <return>\nREM Exits with status 0 if equal, 1 if v1 gtr v2, 2 if v1 lss v2\nfor /f \"tokens=1,2,3 delims=.\" %%a in (\"%~1\") do (\n    set a1=%%a\n    set a2=%%b\n    set a3=%%c\n)\nfor /f \"tokens=1,2,3 delims=.\" %%a in (\"%~2\") do (\n    set b1=%%a\n    set b2=%%b\n    set b3=%%c\n)\nif not defined a1 set a1=0\nif not defined a2 set a2=0\nif not defined a3 set a3=0\nif not defined b1 set b1=0\nif not defined b2 set b2=0\nif not defined b3 set b3=0\nif %a1% gtr %b1% exit /b 1\nif %a1% lss %b1% exit /b 2\nif %a2% gtr %b2% exit /b 1\nif %a2% lss %b2% exit /b 2\nif %a3% gtr %b3% exit /b 1\nif %a3% lss %b3% exit /b 2\nexit /b 0\n\n:askinstall\ncls\necho   ###              ###\necho  # Python Not Found #\necho ###              ###\necho.\necho Python !targetpy! was not found on the system or in the PATH var.\necho.\nset /p \"menu=Would you like to install it now? [y/n]: \"\nif /i \"!menu!\"==\"y\" (\n    REM We got the OK - install it\n    goto installpy\n) else if \"!menu!\"==\"n\" (\n    REM No OK here...\n    set /a tried=!tried!+1\n    goto checkpy\n)\nREM Incorrect answer - go back\ngoto askinstall\n\n:installpy\nREM This will attempt to download and install python\nREM First we get the html for the python downloads page for Windows\nset /a tried=!tried!+1\ncls\necho   ###               ###\necho  # Installing Python #\necho ###               ###\necho.\necho Gathering info from https://www.python.org/downloads/windows/...\npowershell -command \"[Net.ServicePointManager]::SecurityProtocol=[Net.SecurityProtocolType]::Tls12;(new-object System.Net.WebClient).DownloadFile('https://www.python.org/downloads/windows/','%TEMP%\\pyurl.txt')\"\nREM Extract it if it's gzip compressed\npowershell -command \"$infile='%TEMP%\\pyurl.txt';$outfile='%TEMP%\\pyurl.temp';try{$input=New-Object System.IO.FileStream $infile,([IO.FileMode]::Open),([IO.FileAccess]::Read),([IO.FileShare]::Read);$output=New-Object System.IO.FileStream $outfile,([IO.FileMode]::Create),([IO.FileAccess]::Write),([IO.FileShare]::None);$gzipStream=New-Object System.IO.Compression.GzipStream $input,([IO.Compression.CompressionMode]::Decompress);$buffer=New-Object byte[](1024);while($true){$read=$gzipstream.Read($buffer,0,1024);if($read -le 0){break};$output.Write($buffer,0,$read)};$gzipStream.Close();$output.Close();$input.Close();Move-Item -Path $outfile -Destination $infile -Force}catch{}\"\nif not exist \"%TEMP%\\pyurl.txt\" (\n    if /i \"!just_installing!\" == \"TRUE\" (\n        echo Failed to get info\n        exit /b 1\n    ) else (\n        goto checkpy\n    )\n)\necho Parsing for latest...\npushd \"%TEMP%\"\n:: Version detection code slimmed by LussacZheng (https://github.com/corpnewt/gibMacOS/issues/20)\nfor /f \"tokens=9 delims=< \" %%x in ('findstr /i /c:\"Latest Python !targetpy! Release\" pyurl.txt') do ( set \"release=%%x\" )\npopd\nif \"!release!\" == \"\" (\n    if /i \"!just_installing!\" == \"TRUE\" (\n        echo Failed to get python version\n        exit /b 1\n    ) else (\n        goto checkpy\n    )\n)\necho Found Python !release! - Downloading...\nREM Let's delete our txt file now - we no longer need it\ndel \"%TEMP%\\pyurl.txt\"\nREM At this point - we should have the version number.\nREM We can build the url like so: \"https://www.python.org/ftp/python/[version]/python-[version]-amd64.exe\"\nset \"url=https://www.python.org/ftp/python/!release!/python-!release!-amd64.exe\"\nset \"pytype=exe\"\nif \"!targetpy!\" == \"2\" (\n    set \"url=https://www.python.org/ftp/python/!release!/python-!release!.amd64.msi\"\n    set \"pytype=msi\"\n)\nREM Now we download it with our slick powershell command\npowershell -command \"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; (new-object System.Net.WebClient).DownloadFile('!url!','%TEMP%\\pyinstall.!pytype!')\"\nREM If it doesn't exist - we bail\nif not exist \"%TEMP%\\pyinstall.!pytype!\" (\n    if /i \"!just_installing!\" == \"TRUE\" (\n        echo Failed to download installer\n        exit /b 1\n    ) else (\n        goto checkpy\n    )\n)\nREM It should exist at this point - let's run it to install silently\necho Installing...\npushd \"%TEMP%\"\nif /i \"!pytype!\" == \"exe\" (\n    echo pyinstall.exe /quiet PrependPath=1 Include_test=0 Shortcuts=0 Include_launcher=0\n    pyinstall.exe /quiet PrependPath=1 Include_test=0 Shortcuts=0 Include_launcher=0\n) else (\n    set \"foldername=!release:.=!\"\n    echo msiexec /i pyinstall.msi /qb ADDLOCAL=ALL TARGETDIR=\"%LocalAppData%\\Programs\\Python\\Python!foldername:~0,2!\"\n    msiexec /i pyinstall.msi /qb ADDLOCAL=ALL TARGETDIR=\"%LocalAppData%\\Programs\\Python\\Python!foldername:~0,2!\"\n)\npopd\necho Installer finished with %ERRORLEVEL% status.\nREM Now we should be able to delete the installer and check for py again\ndel \"%TEMP%\\pyinstall.!pytype!\"\nREM If it worked, then we should have python in our PATH\nREM this does not get updated right away though - let's try\nREM manually updating the local PATH var\ncall :updatepath\nif /i \"!just_installing!\" == \"TRUE\" (\n    echo.\n    echo Done.\n) else (\n    goto checkpy\n)\nexit /b\n\n:runscript\nREM Python found\ncls\nset \"args=%*\"\nset \"args=!args:\"=!\"\nif \"!args!\"==\"\" (\n    \"!pypath!\" \"!thisDir!!script_name!\"\n) else (\n    \"!pypath!\" \"!thisDir!!script_name!\" %*\n)\nif /i \"!pause_on_error!\" == \"yes\" (\n    if not \"%ERRORLEVEL%\" == \"0\" (\n        echo.\n        echo Script exited with error code: %ERRORLEVEL%\n        echo.\n        echo Press [enter] to exit...\n        pause > nul\n    )\n)\ngoto :EOF\n\n:undouble <string_name> <string_value> <character>\nREM Helper function to strip doubles of a single character out of a string recursively\nset \"string_value=%~2\"\n:undouble_continue\nset \"check=!string_value:%~3%~3=%~3!\"\nif not \"!check!\" == \"!string_value!\" (\n    set \"string_value=!check!\"\n    goto :undouble_continue\n)\nset \"%~1=!check!\"\ngoto :EOF\n\n:updatepath\nset \"spath=\"\nset \"upath=\"\nfor /f \"USEBACKQ tokens=2* delims= \" %%i in (`!syspath!reg.exe query \"HKCU\\Environment\" /v \"Path\" 2^> nul`) do ( if not \"%%j\" == \"\" set \"upath=%%j\" )\nfor /f \"USEBACKQ tokens=2* delims= \" %%i in (`!syspath!reg.exe query \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\" /v \"Path\" 2^> nul`) do ( if not \"%%j\" == \"\" set \"spath=%%j\" )\nif not \"%spath%\" == \"\" (\n    REM We got something in the system path\n    set \"PATH=%spath%\"\n    if not \"%upath%\" == \"\" (\n        REM We also have something in the user path\n        set \"PATH=%PATH%;%upath%\"\n    )\n) else if not \"%upath%\" == \"\" (\n    set \"PATH=%upath%\"\n)\nREM Remove double semicolons from the adjusted PATH\ncall :undouble \"PATH\" \"%PATH%\" \";\"\ngoto :EOF\n\n:getsyspath <variable_name>\nREM Helper method to return a valid path to cmd.exe, reg.exe, and where.exe by\nREM walking the ComSpec var - will also repair it in memory if need be\nREM Strip double semi-colons\ncall :undouble \"temppath\" \"%ComSpec%\" \";\"\n\nREM Dirty hack to leverage the \"line feed\" approach - there are some odd side\nREM effects with this.  Do not use this variable name in comments near this\nREM line - as it seems to behave erradically.\n(set LF=^\n%=this line is empty=%\n)\nREM Replace instances of semi-colons with a line feed and wrap\nREM in parenthesis to work around some strange batch behavior\nset \"testpath=%temppath:;=!LF!%\"\n\nREM Let's walk each path and test if cmd.exe, reg.exe, and where.exe exist there\nset /a found=0\nfor /f \"tokens=* delims=\" %%i in (\"!testpath!\") do (\n    REM Only continue if we haven't found it yet\n    if not \"%%i\" == \"\" (\n        if !found! lss 1 (\n            set \"checkpath=%%i\"\n            REM Remove \"cmd.exe\" from the end if it exists\n            if /i \"!checkpath:~-7!\" == \"cmd.exe\" (\n                set \"checkpath=!checkpath:~0,-7!\"\n            )\n            REM Pad the end with a backslash if needed\n            if not \"!checkpath:~-1!\" == \"\\\" (\n                set \"checkpath=!checkpath!\\\"\n            )\n            REM Let's see if cmd, reg, and where exist there - and set it if so\n            if EXIST \"!checkpath!cmd.exe\" (\n                if EXIST \"!checkpath!reg.exe\" (\n                    if EXIST \"!checkpath!where.exe\" (\n                        set /a found=1\n                        set \"ComSpec=!checkpath!cmd.exe\"\n                        set \"%~1=!checkpath!\"\n                    )\n                )\n            )\n        )\n    )\n)\ngoto :EOF\n"
        },
        {
          "name": "MakeInstall.py",
          "type": "blob",
          "size": 47.189453125,
          "content": "from Scripts import utils, diskwin, downloader, run\r\nimport os, sys, tempfile, shutil, zipfile, platform, json, time\r\n\r\nclass WinUSB:\r\n\r\n    def __init__(self):\r\n        self.u = utils.Utils(\"MakeInstall\")\r\n        if not self.u.check_admin():\r\n            # Try to self-elevate\r\n            self.u.elevate(os.path.realpath(__file__))\r\n            exit()\r\n        self.min_plat = 9600\r\n        # Make sure we're on windows\r\n        self.verify_os()\r\n        # Setup initial vars\r\n        self.d = diskwin.Disk()\r\n        self.dl = downloader.Downloader()\r\n        self.r = run.Run()\r\n        self.scripts = \"Scripts\"\r\n        self.s_path  = os.path.join(os.path.dirname(os.path.realpath(__file__)), self.scripts)\r\n        # self.dd_url  = \"http://www.chrysocome.net/downloads/ddrelease64.exe\"\r\n        self.dd_url  = \"https://github.com/corpnewt/gibMacOS/files/4573241/ddrelease64.exe.zip\" # Rehost due to download issues\r\n        self.dd_name = \".\".join(os.path.basename(self.dd_url).split(\".\")[:-1]) # Get the name without the last extension\r\n        self.z_json = \"https://sourceforge.net/projects/sevenzip/best_release.json\"\r\n        self.z_url2 = \"https://www.7-zip.org/a/7z1806-x64.msi\"\r\n        self.z_url  = \"https://www.7-zip.org/a/7z[[vers]]-x64.msi\"\r\n        self.z_name = \"7z.exe\"\r\n        self.bi_url = \"https://raw.githubusercontent.com/corpnewt/gibMacOS/master/Scripts/BOOTICEx64.exe\"\r\n        self.bi_name = \"BOOTICEx64.exe\"\r\n        self.clover_url = \"https://api.github.com/repos/CloverHackyColor/CloverBootloader/releases\"\r\n        self.dids_url = \"https://api.github.com/repos/dids/clover-builder/releases\"\r\n        self.oc_url = \"https://api.github.com/repos/acidanthera/OpenCorePkg/releases\"\r\n        self.oc_boot = \"boot\"\r\n        self.oc_boot_alt = \"bootX64\"\r\n        self.oc_boot0 = \"boot0\"\r\n        self.oc_boot1 = \"boot1f32\"\r\n        # self.oc_boot_url = \"https://github.com/acidanthera/OpenCorePkg/raw/master/Utilities/LegacyBoot/\"\r\n        self.oc_boot_url = \"https://github.com/acidanthera/OpenCorePkg/raw/870017d0e5d53abeaf0347997da912c3e382a04a/Utilities/LegacyBoot/\"\r\n        self.diskpart = os.path.join(os.environ['SYSTEMDRIVE'] + \"\\\\\", \"Windows\", \"System32\", \"diskpart.exe\")\r\n        # From Tim Sutton's brigadier:  https://github.com/timsutton/brigadier/blob/master/brigadier\r\n        self.z_path = None\r\n        self.z_path64 = os.path.join(os.environ['SYSTEMDRIVE'] + \"\\\\\", \"Program Files\", \"7-Zip\", \"7z.exe\")\r\n        self.z_path32 = os.path.join(os.environ['SYSTEMDRIVE'] + \"\\\\\", \"Program Files (x86)\", \"7-Zip\", \"7z.exe\")\r\n        self.recovery_suffixes = (\r\n            \"recoveryhdupdate.pkg\",\r\n            \"recoveryhdmetadmg.pkg\",\r\n            \"basesystem.dmg\",\r\n            \"recoveryimage.dmg\"\r\n        )\r\n        self.dd_bootsector = True\r\n        self.boot0 = \"boot0af\"\r\n        self.boot1 = \"boot1f32alt\"\r\n        self.boot  = \"boot6\"\r\n        self.efi_id = \"c12a7328-f81f-11d2-ba4b-00a0c93ec93b\" # EFI\r\n        self.bas_id = \"ebd0a0a2-b9e5-4433-87c0-68b6b72699c7\" # Microsoft Basic Data\r\n        self.hfs_id = \"48465300-0000-11AA-AA11-00306543ECAC\" # HFS+\r\n        self.rec_id = \"426F6F74-0000-11AA-AA11-00306543ECAC\" # Apple Boot partition (Recovery HD)\r\n        self.show_all_disks = False\r\n    \r\n    def verify_os(self):\r\n        self.u.head(\"Verifying OS\")\r\n        print(\"\")\r\n        print(\"Verifying OS name...\")\r\n        if not os.name==\"nt\":\r\n            print(\"\")\r\n            print(\"This script is only for Windows!\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to exit...\")\r\n            exit(1)\r\n        print(\" - Name = NT\")\r\n        print(\"Verifying OS version...\")\r\n        # Verify we're at version 9600 or greater\r\n        try:\r\n            # Set plat to the last item of the output split by . - looks like:\r\n            # Windows-8.1-6.3.9600\r\n            # or this:\r\n            # Windows-10-10.0.17134-SP0\r\n            plat = int(platform.platform().split(\".\")[-1].split(\"-\")[0])\r\n        except:\r\n            plat = 0\r\n        if plat < self.min_plat:\r\n            print(\"\")\r\n            print(\"Currently running {}, this script requires version {} or newer.\".format(platform.platform(), self.min_plat))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to exit...\")\r\n            exit(1)\r\n        print(\" - Version = {}\".format(plat))\r\n        print(\"\")\r\n        print(\"{} >= {}, continuing...\".format(plat, self.min_plat))\r\n\r\n    def get_disks_of_type(self, disk_list, disk_type=(0,2)):\r\n        disks = {}\r\n        for disk in disk_list:\r\n            if disk_list[disk].get(\"type\",0) in disk_type:\r\n                disks[disk] = disk_list[disk]\r\n        return disks\r\n\r\n    def check_dd(self):\r\n        # Checks if ddrelease64.exe exists in our Scripts dir\r\n        # and if not - downloads it\r\n        #\r\n        # Returns True if exists/downloaded successfully\r\n        # or False if issues.\r\n        # Check for dd.exe in the current dir\r\n        if os.path.exists(os.path.join(self.s_path, self.dd_name)):\r\n            # print(\"Located {}!\".format(self.dd_name))\r\n            # Got it\r\n            return True\r\n        print(\"Couldn't locate {} - downloading...\".format(self.dd_name))\r\n        temp = tempfile.mkdtemp()\r\n        z_file = os.path.basename(self.dd_url)\r\n        # Now we need to download\r\n        self.dl.stream_to_file(self.dd_url, os.path.join(temp,z_file))\r\n        print(\" - Extracting...\")\r\n        # Extract with built-in tools \\o/\r\n        cwd = os.getcwd()\r\n        os.chdir(temp)\r\n        with zipfile.ZipFile(os.path.join(temp,z_file)) as z:\r\n            z.extractall(temp)\r\n        for x in os.listdir(temp):\r\n            if self.dd_name.lower() == x.lower():\r\n                # Found it\r\n                print(\" - Found {}\".format(x))\r\n                print(\"   - Copying to {} directory...\".format(self.scripts))\r\n                shutil.copy(os.path.join(temp,x), os.path.join(self.s_path,x))\r\n        # Return to prior cwd\r\n        os.chdir(cwd)\r\n        # Remove the temp folder\r\n        shutil.rmtree(temp,ignore_errors=True)\r\n        print(\"\")\r\n        return os.path.exists(os.path.join(self.s_path, self.dd_name))\r\n\r\n    def check_7z(self):\r\n        # Check the PATH var first\r\n        z_path = self.r.run({\"args\":[\"where.exe\",\"7z.exe\"]})[0].split(\"\\n\")[0].rstrip(\"\\r\")\r\n        self.z_path = next((x for x in (z_path,self.z_path64,self.z_path32) if x and os.path.isfile(x)),None)\r\n        if self.z_path:\r\n            return True\r\n        print(\"Didn't locate {} - downloading...\".format(self.z_name))\r\n        # Didn't find it - let's do some stupid stuff\r\n        # First we get our json response - or rather, try to, then parse it\r\n        # looking for the current version\r\n        dl_url = None\r\n        try:\r\n            json_data = json.loads(self.dl.get_string(self.z_json))\r\n            v_num = json_data.get(\"release\",{}).get(\"filename\",\"\").split(\"/\")[-1].lower().split(\"-\")[0].replace(\"7z\",\"\").replace(\".exe\",\"\")\r\n            if len(v_num):\r\n                dl_url = self.z_url.replace(\"[[vers]]\",v_num)\r\n        except:\r\n            pass\r\n        if not dl_url:\r\n            dl_url = self.z_url2\r\n        temp = tempfile.mkdtemp()\r\n        dl_file = self.dl.stream_to_file(dl_url, os.path.join(temp, self.z_name))\r\n        if not dl_file: # Didn't download right\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            return False\r\n        print(\"\")\r\n        print(\"Installing 7zip...\")\r\n        # From Tim Sutton's brigadier:  https://github.com/timsutton/brigadier/blob/master/brigadier\r\n        out = self.r.run({\"args\":[\"msiexec\", \"/qn\", \"/i\", os.path.join(temp, self.z_name)],\"stream\":True})\r\n        if out[2] != 0:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\"Error ({})\".format(out[2]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to exit...\")\r\n            exit(1)\r\n        print(\"\")\r\n        self.z_path = self.z_path64 if os.path.exists(self.z_path64) else self.z_path32 if os.path.exists(self.z_path32) else None\r\n        return self.z_path and os.path.exists(self.z_path)\r\n\r\n    def check_bi(self):\r\n        # Checks for BOOTICEx64.exe in our scripts dir\r\n        # and downloads it if need be\r\n        if os.path.exists(os.path.join(self.s_path, self.bi_name)):\r\n            # print(\"Located {}!\".format(self.bi_name))\r\n            # Got it\r\n            return True\r\n        print(\"Couldn't locate {} - downloading...\".format(self.bi_name))\r\n        self.dl.stream_to_file(self.bi_url, os.path.join(self.s_path, self.bi_name))\r\n        print(\"\")\r\n        return os.path.exists(os.path.join(self.s_path,self.bi_name))\r\n\r\n    def get_dl_url_from_json(self,json_data,suffix=(\".lzma\",\".iso.7z\")):\r\n        try: j_list = json.loads(json_data)\r\n        except: return None\r\n        j_list = j_list if isinstance(j_list,list) else [j_list]\r\n        for j in j_list:\r\n            dl_link = next((x.get(\"browser_download_url\", None) for x in j.get(\"assets\", []) if x.get(\"browser_download_url\", \"\").endswith(suffix)), None)\r\n            if dl_link: break\r\n        if not dl_link:\r\n            return None\r\n        return { \"url\" : dl_link, \"name\" : os.path.basename(dl_link), \"info\" : j.get(\"body\", None) }\r\n\r\n    def get_dl_info(self,clover_version=None):\r\n        # Returns the latest download package and info in a\r\n        # dictionary:  { \"url\" : dl_url, \"name\" : name, \"info\" : update_info }\r\n        # Attempt Dids' repo first - falling back on Clover's official repo as needed\r\n        clover_urls = (self.clover_url,self.dids_url)\r\n        try:\r\n            assert int(clover_version) <= 5122 # Check if we're trying to get r5122 or prior\r\n            # If we didn't throw an exception, we can reverse the order of the URLs to check\r\n            # Dids' builder first\r\n            clover_urls = (self.dids_url,self.clover_url)\r\n        except:\r\n            pass # Wasn't a proper int, or was above 5122\r\n        for url in clover_urls:\r\n            # Tag is e.g. 5098 on Slice's repo, and e.g. v2.5k_r5098 or v5.0_r5xxx on Dids'\r\n            # accommodate as needed\r\n            if not clover_version:\r\n                search_url = url\r\n            elif url == self.clover_url:\r\n                # Using CloverHackyColor's repo - set the tag to the version\r\n                search_url = \"{}/tags/{}\".format(url,clover_version)\r\n            else:\r\n                # Using Dids' clover builder - figure out the prefix based on the version\r\n                search_url = \"{}/tags/v{}_r{}\".format(url,\"5.0\" if clover_version >= \"5118\" else \"2.5k\",clover_version)\r\n            print(\" - Checking {}\".format(search_url))\r\n            json_data = self.dl.get_string(search_url, False)\r\n            if not json_data: print(\" --> Not found!\")\r\n            else: return self.get_dl_url_from_json(json_data)\r\n        return None\r\n\r\n    def get_oc_dl_info(self):\r\n        json_data = self.dl.get_string(self.oc_url, False)\r\n        if not json_data: print(\" --> Not found!\")\r\n        else: return self.get_dl_url_from_json(json_data,suffix=\"-RELEASE.zip\")\r\n\r\n    def diskpart_flag(self, disk, as_efi=False):\r\n        # Sets and unsets the GUID needed for a GPT EFI partition ID\r\n        self.u.head(\"Changing ID With DiskPart\")\r\n        print(\"\")\r\n        print(\"Setting type as {}...\".format(\"EFI\" if as_efi else \"Basic Data\"))\r\n        print(\"\")\r\n        # - EFI system partition: c12a7328-f81f-11d2-ba4b-00a0c93ec93b\r\n        # - Basic data partition: ebd0a0a2-b9e5-4433-87c0-68b6b72699c7\r\n        dp_script = \"\\n\".join([\r\n            \"select disk {}\".format(disk.get(\"index\",-1)),\r\n            \"sel part 1\",\r\n            \"set id={}\".format(self.efi_id if as_efi else self.bas_id)\r\n        ])\r\n        temp = tempfile.mkdtemp()\r\n        script = os.path.join(temp, \"diskpart.txt\")\r\n        try:\r\n            with open(script,\"w\") as f:\r\n                f.write(dp_script)\r\n        except:\r\n            shutil.rmtree(temp)\r\n            print(\"Error creating script!\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        # Let's try to run it!\r\n        out = self.r.run({\"args\":[self.diskpart,\"/s\",script],\"stream\":True})\r\n        # Ditch our script regardless of whether diskpart worked or not\r\n        shutil.rmtree(temp)\r\n        print(\"\")\r\n        if out[2] != 0:\r\n            # Error city!\r\n            print(\"DiskPart exited with non-zero status ({}).  Aborting.\".format(out[2]))\r\n        else:\r\n            print(\"Done - You may need to replug your drive for the\")\r\n            print(\"changes to take effect.\")\r\n        print(\"\")\r\n        self.u.grab(\"Press [enter] to return...\")\r\n\r\n    def diskpart_erase(self, disk, gpt=False, clover_version = None, local_file = None):\r\n        # Generate a script that we can pipe to diskpart to erase our disk\r\n        self.u.head(\"Erasing With DiskPart\")\r\n        print(\"\")\r\n        # Then we'll re-gather our disk info on success and move forward\r\n        # Using MBR to effectively set the individual partition types\r\n        # Keeps us from having issues mounting the EFI on Windows -\r\n        # and also lets us explicitly set the partition id for the main\r\n        # data partition.\r\n        if not gpt:\r\n            print(\"Using MBR...\")\r\n            dp_script = \"\\n\".join([\r\n                \"select disk {}\".format(disk.get(\"index\",-1)),\r\n                \"clean\",\r\n                \"convert mbr\",\r\n                \"create partition primary size=200\",\r\n                \"format quick fs=fat32 label='BOOT'\",\r\n                \"active\",\r\n                \"create partition primary\",\r\n                \"select part 2\",\r\n                \"set id=AB\", # AF = HFS, AB = Recovery\r\n                \"select part 1\",\r\n                \"assign\"\r\n            ])\r\n        else:\r\n            print(\"Using GPT...\")\r\n            dp_script = \"\\n\".join([\r\n                \"select disk {}\".format(disk.get(\"index\",-1)),\r\n                \"clean\",\r\n                \"convert gpt\",\r\n                \"create partition primary size=200\",\r\n                \"format quick fs=fat32 label='BOOT'\",\r\n                \"create partition primary id={}\".format(self.hfs_id)\r\n            ])\r\n        temp = tempfile.mkdtemp()\r\n        script = os.path.join(temp, \"diskpart.txt\")\r\n        try:\r\n            with open(script,\"w\") as f:\r\n                f.write(dp_script)\r\n        except:\r\n            shutil.rmtree(temp)\r\n            print(\"Error creating script!\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        # Let's try to run it!\r\n        out = self.r.run({\"args\":[self.diskpart,\"/s\",script],\"stream\":True})\r\n        # Ditch our script regardless of whether diskpart worked or not\r\n        shutil.rmtree(temp)\r\n        if out[2] != 0:\r\n            # Error city!\r\n            print(\"\")\r\n            print(\"DiskPart exited with non-zero status ({}).  Aborting.\".format(out[2]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        # We should now have a fresh drive to work with\r\n        # Let's write an image or something\r\n        self.u.head(\"Updating Disk Information\")\r\n        print(\"\")\r\n        print(\"Re-populating list...\")\r\n        self.d.update()\r\n        print(\"Relocating disk {}\".format(disk[\"index\"]))\r\n        disk = self.d.disks[str(disk[\"index\"])]\r\n        self.select_package(disk, clover_version, local_file=local_file)\r\n\r\n    def select_package(self, disk, clover_version = None, local_file = None):\r\n        self.u.head(\"Select Recovery Package\")\r\n        print(\"\")\r\n        print(\"{}. {} - {} ({})\".format(\r\n            disk.get(\"index\",-1), \r\n            disk.get(\"model\",\"Unknown\"), \r\n            self.dl.get_size(disk.get(\"size\",-1),strip_zeroes=True),\r\n            [\"Unknown\",\"No Root Dir\",\"Removable\",\"Local\",\"Network\",\"Disc\",\"RAM Disk\"][disk.get(\"type\",0)]\r\n            ))\r\n        print(\"\")\r\n        print(\"M. Main Menu\")\r\n        print(\"Q. Quit\")\r\n        print(\"\")\r\n        print(\"(To copy a file's path, shift + right-click in Explorer and select 'Copy as path')\\n\")\r\n        menu = self.u.grab(\"Please paste the recovery update pkg/dmg path to extract:  \")\r\n        if menu.lower() == \"q\":\r\n            self.u.custom_quit()\r\n        if menu.lower() == \"m\":\r\n            return\r\n        path = self.u.check_path(menu)\r\n        if not path:\r\n            self.select_package(disk, clover_version, local_file=local_file)\r\n            return\r\n        # Got the package - let's make sure it's named right - just in case\r\n        if os.path.basename(path).lower().endswith(\".hfs\"):\r\n            # We have an hfs image already - bypass extraction\r\n            self.dd_image(disk, path, clover_version, local_file=local_file)\r\n            return\r\n        # If it's a directory, find the first recovery hit\r\n        if os.path.isdir(path):\r\n            for f in os.listdir(path):\r\n                if f.lower().endswith(self.recovery_suffixes):\r\n                    path = os.path.join(path, f)\r\n                    break\r\n        # Make sure it's named right for recovery stuffs\r\n        if not path.lower().endswith(self.recovery_suffixes):\r\n            self.u.head(\"Invalid Package\")\r\n            print(\"\")\r\n            print(\"{} is not in the available recovery package names:\\n{}\".format(os.path.basename(path), \", \".join(self.recovery_suffixes)))\r\n            print(\"\")\r\n            print(\"Ensure you're passing a proper recovery package.\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return to package selection...\")\r\n            self.select_package(disk, clover_version, local_file=local_file)\r\n            return\r\n        self.u.head(\"Extracting Package\")\r\n        print(\"\")\r\n        temp = tempfile.mkdtemp()\r\n        cwd = os.getcwd()\r\n        os.chdir(temp)\r\n        print(\"Located {}...\".format(os.path.basename(path)))\r\n        if not path.lower().endswith(\".dmg\"):\r\n            # Extract in sections and remove any files we run into\r\n            print(\"Extracting Recovery dmg...\")\r\n            out = self.r.run({\"args\":[self.z_path, \"e\", \"-txar\", path, \"*.dmg\"]})\r\n            if out[2] != 0:\r\n                shutil.rmtree(temp,ignore_errors=True)\r\n                print(\"An error occurred extracting: {}\".format(out[2]))\r\n                print(\"\")\r\n                self.u.grab(\"Press [enter] to return...\")\r\n                return\r\n            print(\"Extracting BaseSystem.dmg...\")\r\n            # No files to delete here - let's extract the next part\r\n            out = self.r.run({\"args\":[self.z_path, \"e\", \"*.dmg\", \"*/Base*.dmg\"]})\r\n            if out[2] != 0:\r\n                shutil.rmtree(temp,ignore_errors=True)\r\n                print(\"An error occurred extracting: {}\".format(out[2]))\r\n                print(\"\")\r\n                self.u.grab(\"Press [enter] to return...\")\r\n                return\r\n            # If we got here - we should delete everything in the temp folder except\r\n            # for a .dmg that starts with Base\r\n            del_list = [x for x in os.listdir(temp) if not (x.lower().startswith(\"base\") and x.lower().endswith(\".dmg\"))]\r\n            for d in del_list:\r\n                os.remove(os.path.join(temp, d))\r\n        # Onto the last command\r\n        print(\"Extracting hfs...\")\r\n        out = self.r.run({\"args\":[self.z_path, \"e\", \"-tdmg\", path if path.lower().endswith(\".dmg\") else \"Base*.dmg\", \"*.hfs\"]})\r\n        if out[2] != 0:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\"An error occurred extracting: {}\".format(out[2]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        # If we got here - we should delete everything in the temp folder except\r\n        # for a .dmg that starts with Base\r\n        del_list = [x for x in os.listdir(temp) if not x.lower().endswith(\".hfs\")]\r\n        for d in del_list:\r\n            os.remove(os.path.join(temp, d))\r\n        print(\"Extracted successfully!\")\r\n        hfs = next((x for x in os.listdir(temp) if x.lower().endswith(\".hfs\")),None)\r\n        # Now to dd our image - if it exists\r\n        if not hfs:\r\n            print(\"Missing the .hfs file!  Aborting.\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n        else:\r\n            self.dd_image(disk, os.path.join(temp, hfs), clover_version, local_file=local_file)\r\n        shutil.rmtree(temp,ignore_errors=True)\r\n\r\n    def dd_image(self, disk, image, clover_version = None, local_file = None):\r\n        # Let's dd the shit out of our disk\r\n        self.u.head(\"Copying Image To Drive\")\r\n        print(\"\")\r\n        print(\"Image: {}\".format(image))\r\n        print(\"\")\r\n        print(\"Disk {}. {} - {} ({})\".format(\r\n            disk.get(\"index\",-1), \r\n            disk.get(\"model\",\"Unknown\"), \r\n            self.dl.get_size(disk.get(\"size\",-1),strip_zeroes=True),\r\n            [\"Unknown\",\"No Root Dir\",\"Removable\",\"Local\",\"Network\",\"Disc\",\"RAM Disk\"][disk.get(\"type\",0)]\r\n            ))\r\n        print(\"\")\r\n        args = [\r\n            os.path.join(self.s_path, self.dd_name),\r\n            \"if={}\".format(image),\r\n            \"of=\\\\\\\\?\\\\Device\\\\Harddisk{}\\\\Partition2\".format(disk.get(\"index\",-1)),\r\n            \"bs=8M\",\r\n            \"--progress\"\r\n        ]\r\n        print(\" \".join(args))\r\n        print(\"\")\r\n        print(\"This may take some time!\")\r\n        print(\"\")\r\n        out = self.r.run({\"args\":args})\r\n        if len(out[1].split(\"Error\")) > 1:\r\n            # We had some error text - dd, even when failing likes to give us a 0\r\n            # status code.  It also sends a ton of text through stderr - so we comb\r\n            # that for \"Error\" then split by that to skip the extra fluff and show only\r\n            # the error.\r\n            print(\"An error occurred:\\n\\n{}\".format(\"Error\"+out[1].split(\"Error\")[1]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return to the main menu...\")\r\n            return\r\n        # Install Clover/OC to the target drive\r\n        if clover_version == \"OpenCore\": self.install_oc(disk, local_file=local_file)\r\n        else: self.install_clover(disk, clover_version, local_file=local_file)\r\n\r\n    def install_oc(self, disk, local_file = None):\r\n        self.u.head(\"Installing OpenCore\")\r\n        print(\"\")\r\n        print(\"Gathering info...\")\r\n        if not local_file:\r\n            o = self.get_oc_dl_info()\r\n            if o is None:\r\n                print(\" - Error communicating with github!\")\r\n                print(\"\")\r\n                self.u.grab(\"Press [enter] to return...\")\r\n                return\r\n            print(\" - Got {}\".format(o.get(\"name\",\"Unknown Version\")))\r\n            print(\"Downloading...\")\r\n            temp = tempfile.mkdtemp()\r\n            os.chdir(temp)\r\n            self.dl.stream_to_file(o[\"url\"], os.path.join(temp, o[\"name\"]))\r\n        else:\r\n            print(\"Using local file: {}\".format(local_file))\r\n            temp = tempfile.mkdtemp()\r\n            os.chdir(temp)\r\n            o = {\"name\":os.path.basename(local_file)}\r\n            # Copy to the temp folder\r\n            shutil.copy(local_file,os.path.join(temp,o[\"name\"]))\r\n        print(\"\") # Empty space to clear the download progress\r\n        if not os.path.exists(os.path.join(temp, o[\"name\"])):\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\" - Download failed.  Aborting...\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        oc_zip = o[\"name\"]\r\n        # Got a valid file in our temp dir\r\n        print(\"Extracting {}...\".format(oc_zip))\r\n        out = self.r.run({\"args\":[self.z_path, \"x\", os.path.join(temp,oc_zip)]})\r\n        if out[2] != 0:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\" - An error occurred extracting: {}\".format(out[2]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        # We need to also gather our boot, boot0af, and boot1f32 files\r\n        print(\"Gathering DUET boot files...\")\r\n        uefi_only = False\r\n        duet_loc = os.path.join(temp,\"Utilities\",\"LegacyBoot\")\r\n        for x in (self.oc_boot,self.oc_boot_alt,self.oc_boot0,self.oc_boot1):\r\n            # Check the local dir first\r\n            if os.path.exists(os.path.join(duet_loc,x)):\r\n                print(\" - {}\".format(x))\r\n                # Copy it over\r\n                target_name = self.oc_boot if x == self.oc_boot_alt else x\r\n                shutil.copy(os.path.join(duet_loc,x), os.path.join(temp,target_name))\r\n        missing_list = [x for x in (self.oc_boot,self.oc_boot0,self.oc_boot1) if not os.path.exists(os.path.join(temp,x))]\r\n        if missing_list:\r\n            print(\" - Missing: {}\".format(\", \".join(missing_list)))\r\n            print(\"Attempting to download...\")\r\n            for x in missing_list:\r\n                print(\" - {}\".format(x))\r\n                self.dl.stream_to_file(self.oc_boot_url + x, os.path.join(temp,x),False)\r\n            if not all((os.path.exists(os.path.join(temp,x)) for x in missing_list)):\r\n                print(\"Could not located all required DUET files - USB will be UEFI ONLY\")\r\n                uefi_only = True\r\n        # At this point, we should have a boot0xx file and an EFI folder in the temp dir\r\n        # We need to udpate the disk list though - to reflect the current file system on part 1\r\n        # of our current disk\r\n        self.d.update() # assumes our disk number stays the same\r\n        # Some users are having issues with the \"partitions\" key not populating - possibly a 3rd party disk management soft?\r\n        # Possibly a bad USB?\r\n        # We'll see if the key exists - if not, we'll throw an error.\r\n        if self.d.disks[str(disk[\"index\"])].get(\"partitions\",None) is None:\r\n            # No partitions found.\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\"No partitions located on disk!\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        part = self.d.disks[str(disk[\"index\"])][\"partitions\"].get(\"0\",{}).get(\"letter\",None) # get the first partition's letter\r\n        if part is None:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\"Lost original disk - or formatting failed!\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        # Here we have our disk and partitions and such - the BOOT partition\r\n        # will be the first partition\r\n        # Let's copy over the EFI folder and then dd the boot0xx file\r\n        print(\"Copying EFI folder to {}/EFI...\".format(part))\r\n        source_efi = None\r\n        if os.path.exists(os.path.join(temp,\"EFI\")):\r\n            source_efi = os.path.join(temp,\"EFI\")\r\n        elif os.path.exists(os.path.join(temp,\"X64\",\"EFI\")):\r\n            source_efi = os.path.join(temp,\"X64\",\"EFI\")\r\n        if not source_efi:\r\n            print(\" - Source EFI not found!\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        if os.path.exists(\"{}/EFI\".format(part)):\r\n            print(\" - EFI exists - removing...\")\r\n            shutil.rmtree(\"{}/EFI\".format(part),ignore_errors=True)\r\n            time.sleep(1) # Added because windows is dumb\r\n        shutil.copytree(source_efi, \"{}/EFI\".format(part))\r\n        if not uefi_only:\r\n            # Copy boot over to the root of the EFI volume\r\n            print(\"Copying {} to {}/boot...\".format(self.oc_boot,part))\r\n            shutil.copy(os.path.join(temp,self.oc_boot),\"{}/boot\".format(part))\r\n            # Use bootice to update the MBR and PBR - always on the first\r\n            # partition (which is 0 in bootice)\r\n            print(\"Updating the MBR with {}...\".format(self.oc_boot0))\r\n            args = [\r\n                os.path.join(self.s_path,self.bi_name),\r\n                \"/device={}\".format(disk.get(\"index\",-1)),\r\n                \"/mbr\",\r\n                \"/restore\",\r\n                \"/file={}\".format(os.path.join(temp,self.oc_boot0)),\r\n                \"/keep_dpt\",\r\n                \"/quiet\"\r\n            ]\r\n            out = self.r.run({\"args\":args})\r\n            if out[2] != 0:\r\n                shutil.rmtree(temp,ignore_errors=True)\r\n                print(\" - An error occurred updating the MBR: {}\".format(out[2]))\r\n                print(\"\")\r\n                self.u.grab(\"Press [enter] to return...\")\r\n                return\r\n            print(\"Updating the PBR with {}...\".format(self.oc_boot1))\r\n            args = [\r\n                os.path.join(self.s_path,self.bi_name),\r\n                \"/device={}:0\".format(disk.get(\"index\",-1)),\r\n                \"/pbr\",\r\n                \"/restore\",\r\n                \"/file={}\".format(os.path.join(temp,self.oc_boot1)),\r\n                \"/keep_bpb\",\r\n                \"/quiet\"\r\n            ]\r\n            out = self.r.run({\"args\":args})\r\n            if out[2] != 0:\r\n                shutil.rmtree(temp,ignore_errors=True)\r\n                print(\" - An error occurred updating the PBR: {}\".format(out[2]))\r\n                print(\"\")\r\n                self.u.grab(\"Press [enter] to return...\")\r\n                return\r\n        print(\"Cleaning up...\")\r\n        shutil.rmtree(temp,ignore_errors=True)\r\n        print(\"\")\r\n        print(\"Done.\")\r\n        print(\"\")\r\n        self.u.grab(\"Press [enter] to return to the main menu...\")\r\n\r\n    def install_clover(self, disk, clover_version = None, local_file = None):\r\n        self.u.head(\"Installing Clover - {}\".format(\"Latest\" if not clover_version else \"r\"+clover_version))\r\n        print(\"\")\r\n        print(\"Gathering info...\")\r\n        if not local_file:\r\n            c = self.get_dl_info(clover_version)\r\n            if c is None:\r\n                if clover_version is None: print(\" - Error communicating with github!\")\r\n                else: print(\" - Error gathering info for Clover r{}\".format(clover_version))\r\n                print(\"\")\r\n                self.u.grab(\"Press [enter] to return...\")\r\n                return\r\n            print(\" - Got {}\".format(c.get(\"name\",\"Unknown Version\")))\r\n            print(\"Downloading...\")\r\n            temp = tempfile.mkdtemp()\r\n            os.chdir(temp)\r\n            self.dl.stream_to_file(c[\"url\"], os.path.join(temp, c[\"name\"]))\r\n        else:\r\n            print(\"Using local file: {}\".format(local_file))\r\n            temp = tempfile.mkdtemp()\r\n            os.chdir(temp)\r\n            c = {\"name\":os.path.basename(local_file)}\r\n            # Copy to the temp folder\r\n            shutil.copy(local_file,os.path.join(temp,c[\"name\"]))\r\n        print(\"\") # Empty space to clear the download progress\r\n        if not os.path.exists(os.path.join(temp, c[\"name\"])):\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\" - Download failed.  Aborting...\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        clover_archive = c[\"name\"]\r\n        # Got a valid file in our temp dir\r\n        print(\"Extracting {}...\".format(clover_archive))\r\n        out = self.r.run({\"args\":[self.z_path, \"e\", os.path.join(temp,clover_archive)]})\r\n        if out[2] != 0:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\" - An error occurred extracting: {}\".format(out[2]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        # Should result in a .tar file\r\n        clover_tar = next((x for x in os.listdir(temp) if x.lower().endswith(\".tar\")),None)\r\n        if clover_tar:\r\n            # Got a .tar archive - get the .iso\r\n            print(\"Extracting {}...\".format(clover_tar))\r\n            out = self.r.run({\"args\":[self.z_path, \"e\", os.path.join(temp,clover_tar)]})\r\n            if out[2] != 0:\r\n                shutil.rmtree(temp,ignore_errors=True)\r\n                print(\" - An error occurred extracting: {}\".format(out[2]))\r\n                print(\"\")\r\n                self.u.grab(\"Press [enter] to return...\")\r\n                return\r\n        # Should result in a .iso file\r\n        clover_iso = next((x for x in os.listdir(temp) if x.lower().endswith(\".iso\")),None)\r\n        if not clover_iso:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\" - No .iso found - aborting...\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        # Got the .iso - let's extract the needed parts\r\n        print(\"Extracting EFI from {}...\".format(clover_iso))\r\n        out = self.r.run({\"args\":[self.z_path, \"x\", os.path.join(temp,clover_iso), \"EFI*\"]})\r\n        if out[2] != 0:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\" - An error occurred extracting: {}\".format(out[2]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        print(\"Extracting {} from {}...\".format(self.boot0,clover_iso))\r\n        out = self.r.run({\"args\":[self.z_path, \"e\", os.path.join(temp,clover_iso), self.boot0, \"-r\"]})\r\n        if out[2] != 0:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\" - An error occurred extracting: {}\".format(out[2]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        print(\"Extracting {} from {}...\".format(self.boot1,clover_iso))\r\n        out = self.r.run({\"args\":[self.z_path, \"e\", os.path.join(temp,clover_iso), self.boot1, \"-r\"]})\r\n        if out[2] != 0:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\" - An error occurred extracting: {}\".format(out[2]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        print(\"Extracting {} from {}...\".format(self.boot,clover_iso))\r\n        out = self.r.run({\"args\":[self.z_path, \"e\", os.path.join(temp,clover_iso), self.boot, \"-r\"]})\r\n        if out[2] != 0:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\" - An error occurred extracting: {}\".format(out[2]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        # At this point, we should have a boot0xx file and an EFI folder in the temp dir\r\n        # We need to udpate the disk list though - to reflect the current file system on part 1\r\n        # of our current disk\r\n        self.d.update() # assumes our disk number stays the same\r\n        # Some users are having issues with the \"partitions\" key not populating - possibly a 3rd party disk management soft?\r\n        # Possibly a bad USB?\r\n        # We'll see if the key exists - if not, we'll throw an error.\r\n        if self.d.disks[str(disk[\"index\"])].get(\"partitions\",None) is None:\r\n            # No partitions found.\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\"No partitions located on disk!\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        part = self.d.disks[str(disk[\"index\"])][\"partitions\"].get(\"0\",{}).get(\"letter\",None) # get the first partition's letter\r\n        if part is None:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\"Lost original disk - or formatting failed!\")\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        # Here we have our disk and partitions and such - the CLOVER partition\r\n        # will be the first partition\r\n        # Let's copy over the EFI folder and then dd the boot0xx file\r\n        print(\"Copying EFI folder to {}/EFI...\".format(part))\r\n        if os.path.exists(\"{}/EFI\".format(part)):\r\n            print(\" - EFI exists - removing...\")\r\n            shutil.rmtree(\"{}/EFI\".format(part),ignore_errors=True)\r\n            time.sleep(1) # Added because windows is dumb\r\n        shutil.copytree(os.path.join(temp,\"EFI\"), \"{}/EFI\".format(part))\r\n        # Copy boot6 over to the root of the EFI volume - and rename it to boot\r\n        print(\"Copying {} to {}/boot...\".format(self.boot,part))\r\n        shutil.copy(os.path.join(temp,self.boot),\"{}/boot\".format(part))\r\n        # Use bootice to update the MBR and PBR - always on the first\r\n        # partition (which is 0 in bootice)\r\n        print(\"Updating the MBR with {}...\".format(self.boot0))\r\n        args = [\r\n            os.path.join(self.s_path,self.bi_name),\r\n            \"/device={}\".format(disk.get(\"index\",-1)),\r\n            \"/mbr\",\r\n            \"/restore\",\r\n            \"/file={}\".format(os.path.join(temp,self.boot0)),\r\n            \"/keep_dpt\",\r\n            \"/quiet\"\r\n        ]\r\n        out = self.r.run({\"args\":args})\r\n        if out[2] != 0:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\" - An error occurred updating the MBR: {}\".format(out[2]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        print(\"Updating the PBR with {}...\".format(self.boot1))\r\n        args = [\r\n            os.path.join(self.s_path,self.bi_name),\r\n            \"/device={}:0\".format(disk.get(\"index\",-1)),\r\n            \"/pbr\",\r\n            \"/restore\",\r\n            \"/file={}\".format(os.path.join(temp,self.boot1)),\r\n            \"/keep_bpb\",\r\n            \"/quiet\"\r\n        ]\r\n        out = self.r.run({\"args\":args})\r\n        if out[2] != 0:\r\n            shutil.rmtree(temp,ignore_errors=True)\r\n            print(\" - An error occurred updating the PBR: {}\".format(out[2]))\r\n            print(\"\")\r\n            self.u.grab(\"Press [enter] to return...\")\r\n            return\r\n        print(\"Cleaning up...\")\r\n        shutil.rmtree(temp,ignore_errors=True)\r\n        print(\"\")\r\n        print(\"Done.\")\r\n        print(\"\")\r\n        self.u.grab(\"Press [enter] to return to the main menu...\")\r\n\r\n    def main(self):\r\n        # Start out with our cd in the right spot.\r\n        os.chdir(os.path.dirname(os.path.realpath(__file__)))\r\n        # Let's make sure we have the required files needed\r\n        self.u.head(\"Checking Required Tools\")\r\n        print(\"\")\r\n        if not self.check_dd():\r\n            print(\"Couldn't find or install {} - aborting!\\n\".format(self.dd_name))\r\n            self.u.grab(\"Press [enter] to exit...\")\r\n            exit(1)\r\n        if not self.check_7z():\r\n            print(\"Couldn't find or install {} - aborting!\\n\".format(self.z_name))\r\n            self.u.grab(\"Press [enter] to exit...\")\r\n            exit(1)\r\n        if not self.check_bi():\r\n            print(\"Couldn't find or install {} - aborting!\\n\".format(self.bi_name))\r\n            self.u.grab(\"Press [enter] to exit...\")\r\n            exit(1)\r\n        # Let's just setup a real simple interface and try to write some data\r\n        self.u.head(\"Gathering Disk Info\")\r\n        print(\"\")\r\n        print(\"Populating list...\")\r\n        self.d.update()\r\n        print(\"\")\r\n        print(\"Done!\")\r\n        # Let's serve up a list of *only* removable media\r\n        self.u.head(\"Potential Removable Media\")\r\n        print(\"\")\r\n        rem_disks = self.get_disks_of_type(self.d.disks) if not self.show_all_disks else self.d.disks\r\n\r\n        # Types: 0 = Unknown, 1 = No Root Dir, 2 = Removable, 3 = Local, 4 = Network, 5 = Disc, 6 = RAM disk\r\n\r\n        if self.show_all_disks:\r\n            print(\"!WARNING!  This list includes ALL disk types.\")\r\n            print(\"!WARNING!  Be ABSOLUTELY sure before selecting\")\r\n            print(\"!WARNING!  a disk!\")\r\n        else:\r\n            print(\"!WARNING!  This list includes both Removable AND\")\r\n            print(\"!WARNING!  Unknown disk types.  Be ABSOLUTELY sure\")\r\n            print(\"!WARNING!  before selecting a disk!\")\r\n        print(\"\")\r\n        for disk in sorted(rem_disks,key=lambda x:int(x)):\r\n            print(\"{}. {} - {} ({})\".format(\r\n                disk, \r\n                rem_disks[disk].get(\"model\",\"Unknown\"), \r\n                self.dl.get_size(rem_disks[disk].get(\"size\",-1),strip_zeroes=True),\r\n                [\"Unknown\",\"No Root Dir\",\"Removable\",\"Local\",\"Network\",\"Disc\",\"RAM Disk\"][rem_disks[disk].get(\"type\",0)]\r\n                ))\r\n            if not len(rem_disks[disk].get(\"partitions\",{})):\r\n                print(\"   No Mounted Partitions\")\r\n            else:\r\n                parts = rem_disks[disk][\"partitions\"]\r\n                for p in sorted(parts,key=lambda x:int(x)):\r\n                    print(\"   {}. {} ({}) {} - {}\".format(\r\n                        p,\r\n                        parts[p].get(\"letter\",\"No Letter\"),\r\n                        \"No Name\" if not parts[p].get(\"name\",None) else parts[p].get(\"name\",\"No Name\"),\r\n                        parts[p].get(\"file system\",\"Unknown FS\"),\r\n                        self.dl.get_size(parts[p].get(\"size\",-1),strip_zeroes=True)\r\n                    ))\r\n        print(\"\")\r\n        print(\"Q. Quit\")\r\n        print(\"\")\r\n        print(\"Usage: [drive number][options] r[Clover revision (optional), requires C]\\n  (eg. 1B C r5092)\")\r\n        print(\"  Options are as follows with precedence B > F > E > U > G:\")\r\n        print(\"    B = Only install the boot manager to the drive's first partition.\")\r\n        print(\"    F = Skip formatting the disk - will install the boot manager to the first\")\r\n        print(\"        partition, and dd the recovery image to the second.\")\r\n        print(\"    E = Sets the type of the drive's first partition to EFI.\")\r\n        print(\"    U = Similar to E, but sets the type to Basic Data (useful for editing).\")\r\n        print(\"    G = Format as GPT (default is MBR).\")\r\n        print(\"    C = Use Clover instead of OpenCore.\")\r\n        print(\"    L = Provide a local archive for the boot manager - must still use C if Clover.\")\r\n        print(\"    D = Used without a drive number, toggles showing all disks (currently {}).\".format(\"ENABLED\" if self.show_all_disks else \"DISABLED\"))\r\n        print(\"\")\r\n        menu = self.u.grab(\"Please select a disk or press [enter] with no options to refresh:  \")\r\n        if not len(menu):\r\n            self.main()\r\n            return\r\n        if menu.lower() == \"q\":\r\n            self.u.custom_quit()\r\n        if menu.lower() == \"d\":\r\n            self.show_all_disks ^= True\r\n            self.main()\r\n            return\r\n        only_boot = set_efi = unset_efi = use_gpt = user_provided = no_format = False\r\n        local_file = None\r\n        use_oc = True\r\n        if \"b\" in menu.lower():\r\n            only_boot = True\r\n            menu = menu.lower().replace(\"b\",\"\")\r\n        if \"c\" in menu.lower():\r\n            use_oc = False\r\n            menu = menu.lower().replace(\"c\",\"\")\r\n        if \"o\" in menu.lower(): # Remove legacy \"o\" value\r\n            menu = menu.lower().replace(\"o\",\"\")\r\n        if \"e\" in menu.lower():\r\n            set_efi = True\r\n            menu = menu.lower().replace(\"e\",\"\")\r\n        if \"u\" in menu.lower():\r\n            unset_efi = True\r\n            menu = menu.lower().replace(\"u\",\"\")\r\n        if \"g\" in menu.lower():\r\n            use_gpt = True\r\n            menu = menu.lower().replace(\"g\",\"\")\r\n        if \"l\" in menu.lower():\r\n            user_provided = True\r\n            menu = menu.lower().replace(\"l\",\"\")\r\n        if \"f\" in menu.lower():\r\n            no_format = True\r\n            menu = menu.lower().replace(\"f\",\"\")\r\n\r\n        # Extract Clover version from args if found\r\n        clover_list = [x for x in menu.split() if x.lower().startswith(\"r\") and all(y in \"0123456789\" for y in x[1:])]\r\n        menu = \" \".join([x for x in menu.split() if not x in clover_list])\r\n        clover_version = None if not len(clover_list) else clover_list[0][1:] # Skip the \"r\" prefix\r\n\r\n        # Prepare for OC if need be\r\n        if use_oc: clover_version = \"OpenCore\"\r\n\r\n        selected_disk = rem_disks.get(menu.strip(),None)\r\n        if not selected_disk:\r\n            self.u.head(\"Invalid Choice\")\r\n            print(\"\")\r\n            print(\"Disk {} is not an option.\".format(menu))\r\n            print(\"\")\r\n            self.u.grab(\"Returning in 5 seconds...\", timeout=5)\r\n            self.main()\r\n            return\r\n        # Got a disk!\r\n        if user_provided:\r\n            # Prompt the user for the target archive\r\n            while True:\r\n                self.u.head(\"Local Archive\")\r\n                print(\"\")\r\n                if use_oc:\r\n                    print(\"NOTE:  OpenCore archives are expected to be .zip!\")\r\n                else:\r\n                    print(\"NOTE:  Clover archives are expected to be an ISO packed in either .tar.lzma or .7z!\")\r\n                print(\"\")\r\n                print(\"M. Return to the menu\")\r\n                print(\"Q. Quit\")\r\n                print(\"\")\r\n                print(\"(To copy a file's path, shift + right-click in Explorer and select 'Copy as path')\\n\")\r\n                l = self.u.grab(\"Please {} archive path here:  \".format(\"OpenCore\" if use_oc else \"Clover\"))\r\n                if not len(l):\r\n                    continue\r\n                if l.lower() == \"m\":\r\n                    break\r\n                elif l.lower() == \"q\":\r\n                    self.u.custom_quit()\r\n                l_check = self.u.check_path(l)\r\n                if not l_check or not l_check.lower().endswith(\".zip\" if use_oc else (\".tar.lzma\",\".7z\")):\r\n                    continue\r\n                # Got a valid path that ends with the proper extension\r\n                local_file = l_check\r\n                break\r\n            # Check if we got something\r\n            if not local_file:\r\n                self.main()\r\n                return\r\n        if only_boot:\r\n            if use_oc: self.install_oc(selected_disk, local_file=local_file)\r\n            else: self.install_clover(selected_disk, clover_version, local_file=local_file)\r\n        elif no_format:\r\n            # Make sure we warn the user that the second partition **NEEDS** to be a RAW\r\n            # partition for dd to properly work\r\n            while True:\r\n                self.u.head(\"WARNING\")\r\n                print(\"\")\r\n                print(\"{}. {} - {} ({})\".format(\r\n                    selected_disk.get(\"index\",-1), \r\n                    selected_disk.get(\"model\",\"Unknown\"), \r\n                    self.dl.get_size(selected_disk.get(\"size\",-1),strip_zeroes=True),\r\n                    [\"Unknown\",\"No Root Dir\",\"Removable\",\"Local\",\"Network\",\"Disc\",\"RAM Disk\"][selected_disk.get(\"type\",0)]\r\n                    ))\r\n                print(\"\")\r\n                print(\"In order to continue without formatting, the selected disk's first\")\r\n                print(\"partition MUST be FAT32, and the second MUST be RAW.  If that is not\")\r\n                print(\"the case, the operation WILL fail.\")\r\n                print(\"\")\r\n                yn = self.u.grab(\"Continue? (y/n):  \")\r\n                if yn.lower() == \"n\":\r\n                    self.main()\r\n                    return\r\n                if yn.lower() == \"y\":\r\n                    break\r\n            self.select_package(selected_disk, clover_version, local_file=local_file)\r\n        elif set_efi:\r\n            self.diskpart_flag(selected_disk, True)\r\n        elif unset_efi:\r\n            self.diskpart_flag(selected_disk, False)\r\n        else:\r\n            # Check erase\r\n            while True:\r\n                self.u.head(\"Erase {}\".format(selected_disk.get(\"model\",\"Unknown\")))\r\n                print(\"\")\r\n                print(\"{}. {} - {} ({})\".format(\r\n                    selected_disk.get(\"index\",-1), \r\n                    selected_disk.get(\"model\",\"Unknown\"), \r\n                    self.dl.get_size(selected_disk.get(\"size\",-1),strip_zeroes=True),\r\n                    [\"Unknown\",\"No Root Dir\",\"Removable\",\"Local\",\"Network\",\"Disc\",\"RAM Disk\"][selected_disk.get(\"type\",0)]\r\n                    ))\r\n                print(\"\")\r\n                print(\"If you continue - THIS DISK WILL BE ERASED\")\r\n                print(\"ALL DATA WILL BE LOST AND ALL PARTITIONS WILL\")\r\n                print(\"BE REMOVED!!!!!!!\")\r\n                print(\"\")\r\n                yn = self.u.grab(\"Continue? (y/n):  \")\r\n                if yn.lower() == \"n\":\r\n                    self.main()\r\n                    return\r\n                if yn.lower() == \"y\":\r\n                    break\r\n            # Got the OK to erase!  Let's format a diskpart script!\r\n            self.diskpart_erase(selected_disk, use_gpt, clover_version, local_file=local_file)\r\n        self.main()\r\n\r\nif __name__ == '__main__':\r\n    w = WinUSB()\r\n    w.main()\r\n"
        },
        {
          "name": "Readme.md",
          "type": "blob",
          "size": 1.2451171875,
          "content": "Py2/py3 script that can download macOS components direct from Apple\n\nCan also now build Internet Recovery USB installers from Windows using [dd](http://www.chrysocome.net/dd) and [7zip](https://www.7-zip.org/download.html).\n\n**NOTE:** As of macOS 11 (Big Sur), Apple has changed the way they distribute macOS, and internet recovery USBs can no longer be built via MakeInstall on Windows.  macOS versions through Catalina will still work though.\n\n**NOTE 2:** As of macOS 11 (Big Sur), Apple distributes the OS via an InstallAssistant.pkg file.  `BuildmacOSInstallApp.command` is not needed to create the install application when in macOS in this case - and you can simply run `InstallAssistant.pkg`, which will place the install app in your /Applications folder on macOS.\n\nThanks to:\n\n* FoxletFox for [FetchMacOS](http://www.insanelymac.com/forum/topic/326366-fetchmacos-a-tool-to-download-macos-on-non-mac-platforms/) and outlining the URL setup\n* munki for his [macadmin-scripts](https://github.com/munki/macadmin-scripts)\n* timsutton for [brigadier](https://github.com/timsutton/brigadier)\n* wolfmannight for [manOSDownloader_rc](https://www.insanelymac.com/forum/topic/338810-create-legit-copy-of-macos-from-apple-catalog/) off which BuildmacOSInstallApp.command is based\n"
        },
        {
          "name": "Scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "gibMacOS.bat",
          "type": "blob",
          "size": 12.8134765625,
          "content": "@echo off\nREM Get our local path before delayed expansion - allows ! in path\nset \"thisDir=%~dp0\"\n\nsetlocal enableDelayedExpansion\nREM Setup initial vars\nset \"script_name=\"\nset /a tried=0\nset \"toask=yes\"\nset \"pause_on_error=yes\"\nset \"py2v=\"\nset \"py2path=\"\nset \"py3v=\"\nset \"py3path=\"\nset \"pypath=\"\nset \"targetpy=3\"\n\nREM use_py3:\nREM   TRUE  = Use if found, use py2 otherwise\nREM   FALSE = Use py2\nREM   FORCE = Use py3\nset \"use_py3=TRUE\"\n\nREM We'll parse if the first argument passed is\nREM --install-python and if so, we'll just install\nset \"just_installing=FALSE\"\n\nREM Get the system32 (or equivalent) path\ncall :getsyspath \"syspath\"\n\nREM Make sure the syspath exists\nif \"!syspath!\" == \"\" (\n    if exist \"%SYSTEMROOT%\\system32\\cmd.exe\" (\n        if exist \"%SYSTEMROOT%\\system32\\reg.exe\" (\n            if exist \"%SYSTEMROOT%\\system32\\where.exe\" (\n                REM Fall back on the default path if it exists\n                set \"ComSpec=%SYSTEMROOT%\\system32\\cmd.exe\"\n                set \"syspath=%SYSTEMROOT%\\system32\\\"\n            )\n        )\n    )\n    if \"!syspath!\" == \"\" (\n        cls\n        echo   ###     ###\n        echo  # Warning #\n        echo ###     ###\n        echo.\n        echo Could not locate cmd.exe, reg.exe, or where.exe\n        echo.\n        echo Please ensure your ComSpec environment variable is properly configured and\n        echo points directly to cmd.exe, then try again.\n        echo.\n        echo Current CompSpec Value: \"%ComSpec%\"\n        echo.\n        echo Press [enter] to quit.\n        pause > nul\n        exit /b 1\n    )\n)\n\nif \"%~1\" == \"--install-python\" (\n    set \"just_installing=TRUE\"\n    goto installpy\n)\n\ngoto checkscript\n\n:checkscript\nREM Check for our script first\nset \"looking_for=!script_name!\"\nif \"!script_name!\" == \"\" (\n    set \"looking_for=%~n0.py or %~n0.command\"\n    set \"script_name=%~n0.py\"\n    if not exist \"!thisDir!\\!script_name!\" (\n        set \"script_name=%~n0.command\"\n    )\n)\nif not exist \"!thisDir!\\!script_name!\" (\n    echo Could not find !looking_for!.\n    echo Please make sure to run this script from the same directory\n    echo as !looking_for!.\n    echo.\n    echo Press [enter] to quit.\n    pause > nul\n    exit /b 1\n)\ngoto checkpy\n\n:checkpy\ncall :updatepath\nfor /f \"USEBACKQ tokens=*\" %%x in (`!syspath!where.exe python 2^> nul`) do ( call :checkpyversion \"%%x\" \"py2v\" \"py2path\" \"py3v\" \"py3path\" )\nfor /f \"USEBACKQ tokens=*\" %%x in (`!syspath!where.exe python3 2^> nul`) do ( call :checkpyversion \"%%x\" \"py2v\" \"py2path\" \"py3v\" \"py3path\" )\nfor /f \"USEBACKQ tokens=*\" %%x in (`!syspath!where.exe py 2^> nul`) do ( call :checkpylauncher \"%%x\" \"py2v\" \"py2path\" \"py3v\" \"py3path\" )\nREM Walk our returns to see if we need to install\nif /i \"!use_py3!\" == \"FALSE\" (\n    set \"targetpy=2\"\n    set \"pypath=!py2path!\"\n) else if /i \"!use_py3!\" == \"FORCE\" (\n    set \"pypath=!py3path!\"\n) else if /i \"!use_py3!\" == \"TRUE\" (\n    set \"pypath=!py3path!\"\n    if \"!pypath!\" == \"\" set \"pypath=!py2path!\"\n)\nif not \"!pypath!\" == \"\" (\n    goto runscript\n)\nif !tried! lss 1 (\n    if /i \"!toask!\"==\"yes\" (\n        REM Better ask permission first\n        goto askinstall\n    ) else (\n        goto installpy\n    )\n) else (\n    cls\n    echo   ###     ###\n    echo  # Warning #\n    echo ###     ###\n    echo.\n    REM Couldn't install for whatever reason - give the error message\n    echo Python is not installed or not found in your PATH var.\n    echo Please install it from https://www.python.org/downloads/windows/\n    echo.\n    echo Make sure you check the box labeled:\n    echo.\n    echo \"Add Python X.X to PATH\"\n    echo.\n    echo Where X.X is the py version you're installing.\n    echo.\n    echo Press [enter] to quit.\n    pause > nul\n    exit /b 1\n)\ngoto runscript\n\n:checkpylauncher <path> <py2v> <py2path> <py3v> <py3path>\nREM Attempt to check the latest python 2 and 3 versions via the py launcher\nfor /f \"USEBACKQ tokens=*\" %%x in (`%~1 -2 -c \"import sys; print(sys.executable)\" 2^> nul`) do ( call :checkpyversion \"%%x\" \"%~2\" \"%~3\" \"%~4\" \"%~5\" )\nfor /f \"USEBACKQ tokens=*\" %%x in (`%~1 -3 -c \"import sys; print(sys.executable)\" 2^> nul`) do ( call :checkpyversion \"%%x\" \"%~2\" \"%~3\" \"%~4\" \"%~5\" )\ngoto :EOF\n\n:checkpyversion <path> <py2v> <py2path> <py3v> <py3path>\nset \"version=\"&for /f \"tokens=2* USEBACKQ delims= \" %%a in (`\"%~1\" -V 2^>^&1`) do (\n    REM Ensure we have a version number\n    call :isnumber \"%%a\"\n    if not \"!errorlevel!\" == \"0\" goto :EOF\n    set \"version=%%a\"\n)\nif not defined version goto :EOF\nif \"!version:~0,1!\" == \"2\" (\n    REM Python 2\n    call :comparepyversion \"!version!\" \"!%~2!\"\n    if \"!errorlevel!\" == \"1\" (\n        set \"%~2=!version!\"\n        set \"%~3=%~1\"\n    )\n) else (\n    REM Python 3\n    call :comparepyversion \"!version!\" \"!%~4!\"\n    if \"!errorlevel!\" == \"1\" (\n        set \"%~4=!version!\"\n        set \"%~5=%~1\"\n    )\n)\ngoto :EOF\n\n:isnumber <check_value>\nset \"var=\"&for /f \"delims=0123456789.\" %%i in (\"%~1\") do set var=%%i\nif defined var (exit /b 1)\nexit /b 0\n\n:comparepyversion <version1> <version2> <return>\nREM Exits with status 0 if equal, 1 if v1 gtr v2, 2 if v1 lss v2\nfor /f \"tokens=1,2,3 delims=.\" %%a in (\"%~1\") do (\n    set a1=%%a\n    set a2=%%b\n    set a3=%%c\n)\nfor /f \"tokens=1,2,3 delims=.\" %%a in (\"%~2\") do (\n    set b1=%%a\n    set b2=%%b\n    set b3=%%c\n)\nif not defined a1 set a1=0\nif not defined a2 set a2=0\nif not defined a3 set a3=0\nif not defined b1 set b1=0\nif not defined b2 set b2=0\nif not defined b3 set b3=0\nif %a1% gtr %b1% exit /b 1\nif %a1% lss %b1% exit /b 2\nif %a2% gtr %b2% exit /b 1\nif %a2% lss %b2% exit /b 2\nif %a3% gtr %b3% exit /b 1\nif %a3% lss %b3% exit /b 2\nexit /b 0\n\n:askinstall\ncls\necho   ###              ###\necho  # Python Not Found #\necho ###              ###\necho.\necho Python !targetpy! was not found on the system or in the PATH var.\necho.\nset /p \"menu=Would you like to install it now? [y/n]: \"\nif /i \"!menu!\"==\"y\" (\n    REM We got the OK - install it\n    goto installpy\n) else if \"!menu!\"==\"n\" (\n    REM No OK here...\n    set /a tried=!tried!+1\n    goto checkpy\n)\nREM Incorrect answer - go back\ngoto askinstall\n\n:installpy\nREM This will attempt to download and install python\nREM First we get the html for the python downloads page for Windows\nset /a tried=!tried!+1\ncls\necho   ###               ###\necho  # Installing Python #\necho ###               ###\necho.\necho Gathering info from https://www.python.org/downloads/windows/...\npowershell -command \"[Net.ServicePointManager]::SecurityProtocol=[Net.SecurityProtocolType]::Tls12;(new-object System.Net.WebClient).DownloadFile('https://www.python.org/downloads/windows/','%TEMP%\\pyurl.txt')\"\nREM Extract it if it's gzip compressed\npowershell -command \"$infile='%TEMP%\\pyurl.txt';$outfile='%TEMP%\\pyurl.temp';try{$input=New-Object System.IO.FileStream $infile,([IO.FileMode]::Open),([IO.FileAccess]::Read),([IO.FileShare]::Read);$output=New-Object System.IO.FileStream $outfile,([IO.FileMode]::Create),([IO.FileAccess]::Write),([IO.FileShare]::None);$gzipStream=New-Object System.IO.Compression.GzipStream $input,([IO.Compression.CompressionMode]::Decompress);$buffer=New-Object byte[](1024);while($true){$read=$gzipstream.Read($buffer,0,1024);if($read -le 0){break};$output.Write($buffer,0,$read)};$gzipStream.Close();$output.Close();$input.Close();Move-Item -Path $outfile -Destination $infile -Force}catch{}\"\nif not exist \"%TEMP%\\pyurl.txt\" (\n    if /i \"!just_installing!\" == \"TRUE\" (\n        echo Failed to get info\n        exit /b 1\n    ) else (\n        goto checkpy\n    )\n)\necho Parsing for latest...\npushd \"%TEMP%\"\n:: Version detection code slimmed by LussacZheng (https://github.com/corpnewt/gibMacOS/issues/20)\nfor /f \"tokens=9 delims=< \" %%x in ('findstr /i /c:\"Latest Python !targetpy! Release\" pyurl.txt') do ( set \"release=%%x\" )\npopd\nif \"!release!\" == \"\" (\n    if /i \"!just_installing!\" == \"TRUE\" (\n        echo Failed to get python version\n        exit /b 1\n    ) else (\n        goto checkpy\n    )\n)\necho Found Python !release! - Downloading...\nREM Let's delete our txt file now - we no longer need it\ndel \"%TEMP%\\pyurl.txt\"\nREM At this point - we should have the version number.\nREM We can build the url like so: \"https://www.python.org/ftp/python/[version]/python-[version]-amd64.exe\"\nset \"url=https://www.python.org/ftp/python/!release!/python-!release!-amd64.exe\"\nset \"pytype=exe\"\nif \"!targetpy!\" == \"2\" (\n    set \"url=https://www.python.org/ftp/python/!release!/python-!release!.amd64.msi\"\n    set \"pytype=msi\"\n)\nREM Now we download it with our slick powershell command\npowershell -command \"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; (new-object System.Net.WebClient).DownloadFile('!url!','%TEMP%\\pyinstall.!pytype!')\"\nREM If it doesn't exist - we bail\nif not exist \"%TEMP%\\pyinstall.!pytype!\" (\n    if /i \"!just_installing!\" == \"TRUE\" (\n        echo Failed to download installer\n        exit /b 1\n    ) else (\n        goto checkpy\n    )\n)\nREM It should exist at this point - let's run it to install silently\necho Installing...\npushd \"%TEMP%\"\nif /i \"!pytype!\" == \"exe\" (\n    echo pyinstall.exe /quiet PrependPath=1 Include_test=0 Shortcuts=0 Include_launcher=0\n    pyinstall.exe /quiet PrependPath=1 Include_test=0 Shortcuts=0 Include_launcher=0\n) else (\n    set \"foldername=!release:.=!\"\n    echo msiexec /i pyinstall.msi /qb ADDLOCAL=ALL TARGETDIR=\"%LocalAppData%\\Programs\\Python\\Python!foldername:~0,2!\"\n    msiexec /i pyinstall.msi /qb ADDLOCAL=ALL TARGETDIR=\"%LocalAppData%\\Programs\\Python\\Python!foldername:~0,2!\"\n)\npopd\necho Installer finished with %ERRORLEVEL% status.\nREM Now we should be able to delete the installer and check for py again\ndel \"%TEMP%\\pyinstall.!pytype!\"\nREM If it worked, then we should have python in our PATH\nREM this does not get updated right away though - let's try\nREM manually updating the local PATH var\ncall :updatepath\nif /i \"!just_installing!\" == \"TRUE\" (\n    echo.\n    echo Done.\n) else (\n    goto checkpy\n)\nexit /b\n\n:runscript\nREM Python found\ncls\nset \"args=%*\"\nset \"args=!args:\"=!\"\nif \"!args!\"==\"\" (\n    \"!pypath!\" \"!thisDir!!script_name!\"\n) else (\n    \"!pypath!\" \"!thisDir!!script_name!\" %*\n)\nif /i \"!pause_on_error!\" == \"yes\" (\n    if not \"%ERRORLEVEL%\" == \"0\" (\n        echo.\n        echo Script exited with error code: %ERRORLEVEL%\n        echo.\n        echo Press [enter] to exit...\n        pause > nul\n    )\n)\ngoto :EOF\n\n:undouble <string_name> <string_value> <character>\nREM Helper function to strip doubles of a single character out of a string recursively\nset \"string_value=%~2\"\n:undouble_continue\nset \"check=!string_value:%~3%~3=%~3!\"\nif not \"!check!\" == \"!string_value!\" (\n    set \"string_value=!check!\"\n    goto :undouble_continue\n)\nset \"%~1=!check!\"\ngoto :EOF\n\n:updatepath\nset \"spath=\"\nset \"upath=\"\nfor /f \"USEBACKQ tokens=2* delims= \" %%i in (`!syspath!reg.exe query \"HKCU\\Environment\" /v \"Path\" 2^> nul`) do ( if not \"%%j\" == \"\" set \"upath=%%j\" )\nfor /f \"USEBACKQ tokens=2* delims= \" %%i in (`!syspath!reg.exe query \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\" /v \"Path\" 2^> nul`) do ( if not \"%%j\" == \"\" set \"spath=%%j\" )\nif not \"%spath%\" == \"\" (\n    REM We got something in the system path\n    set \"PATH=%spath%\"\n    if not \"%upath%\" == \"\" (\n        REM We also have something in the user path\n        set \"PATH=%PATH%;%upath%\"\n    )\n) else if not \"%upath%\" == \"\" (\n    set \"PATH=%upath%\"\n)\nREM Remove double semicolons from the adjusted PATH\ncall :undouble \"PATH\" \"%PATH%\" \";\"\ngoto :EOF\n\n:getsyspath <variable_name>\nREM Helper method to return a valid path to cmd.exe, reg.exe, and where.exe by\nREM walking the ComSpec var - will also repair it in memory if need be\nREM Strip double semi-colons\ncall :undouble \"temppath\" \"%ComSpec%\" \";\"\n\nREM Dirty hack to leverage the \"line feed\" approach - there are some odd side\nREM effects with this.  Do not use this variable name in comments near this\nREM line - as it seems to behave erradically.\n(set LF=^\n%=this line is empty=%\n)\nREM Replace instances of semi-colons with a line feed and wrap\nREM in parenthesis to work around some strange batch behavior\nset \"testpath=%temppath:;=!LF!%\"\n\nREM Let's walk each path and test if cmd.exe, reg.exe, and where.exe exist there\nset /a found=0\nfor /f \"tokens=* delims=\" %%i in (\"!testpath!\") do (\n    REM Only continue if we haven't found it yet\n    if not \"%%i\" == \"\" (\n        if !found! lss 1 (\n            set \"checkpath=%%i\"\n            REM Remove \"cmd.exe\" from the end if it exists\n            if /i \"!checkpath:~-7!\" == \"cmd.exe\" (\n                set \"checkpath=!checkpath:~0,-7!\"\n            )\n            REM Pad the end with a backslash if needed\n            if not \"!checkpath:~-1!\" == \"\\\" (\n                set \"checkpath=!checkpath!\\\"\n            )\n            REM Let's see if cmd, reg, and where exist there - and set it if so\n            if EXIST \"!checkpath!cmd.exe\" (\n                if EXIST \"!checkpath!reg.exe\" (\n                    if EXIST \"!checkpath!where.exe\" (\n                        set /a found=1\n                        set \"ComSpec=!checkpath!cmd.exe\"\n                        set \"%~1=!checkpath!\"\n                    )\n                )\n            )\n        )\n    )\n)\ngoto :EOF\n"
        },
        {
          "name": "gibMacOS.command",
          "type": "blob",
          "size": 9.7861328125,
          "content": "#!/usr/bin/env bash\n\n# Get the curent directory, the script name\n# and the script name with \"py\" substituted for the extension.\nargs=( \"$@\" )\ndir=\"$(cd -- \"$(dirname \"$0\")\" >/dev/null 2>&1; pwd -P)\"\nscript=\"${0##*/}\"\ntarget=\"${script%.*}.py\"\n\n# use_py3:\n#   TRUE  = Use if found, use py2 otherwise\n#   FALSE = Use py2\n#   FORCE = Use py3\nuse_py3=\"TRUE\"\n\n# We'll parse if the first argument passed is\n# --install-python and if so, we'll just install\njust_installing=\"FALSE\"\n\ntempdir=\"\"\n\ncompare_to_version () {\n    # Compares our OS version to the passed OS version, and\n    # return a 1 if we match the passed compare type, or a 0 if we don't.\n    # $1 = 0 (equal), 1 (greater), 2 (less), 3 (gequal), 4 (lequal)\n    # $2 = OS version to compare ours to\n    if [ -z \"$1\" ] || [ -z \"$2\" ]; then\n        # Missing info - bail.\n        return\n    fi\n    local current_os= comp=\n    current_os=\"$(sw_vers -productVersion)\"\n    comp=\"$(vercomp \"$current_os\" \"$2\")\"\n    # Check gequal and lequal first\n    if [[ \"$1\" == \"3\" && (\"$comp\" == \"1\" || \"$comp\" == \"0\") ]] || [[ \"$1\" == \"4\" && (\"$comp\" == \"2\" || \"$comp\" == \"0\") ]] || [[ \"$comp\" == \"$1\" ]]; then\n        # Matched\n        echo \"1\"\n    else\n        # No match\n        echo \"0\"\n    fi\n}\n\nset_use_py3_if () {\n    # Auto sets the \"use_py3\" variable based on\n    # conditions passed\n    # $1 = 0 (equal), 1 (greater), 2 (less), 3 (gequal), 4 (lequal)\n    # $2 = OS version to compare\n    # $3 = TRUE/FALSE/FORCE in case of match\n    if [ -z \"$1\" ] || [ -z \"$2\" ] || [ -z \"$3\" ]; then\n        # Missing vars - bail with no changes.\n        return\n    fi\n    if [ \"$(compare_to_version \"$1\" \"$2\")\" == \"1\" ]; then\n        use_py3=\"$3\"\n    fi\n}\n\nget_remote_py_version () {\n    local pyurl= py_html= py_vers= py_num=\"3\"\n    pyurl=\"https://www.python.org/downloads/macos/\"\n    py_html=\"$(curl -L $pyurl --compressed 2>&1)\"\n    if [ -z \"$use_py3\" ]; then\n        use_py3=\"TRUE\"\n    fi\n    if [ \"$use_py3\" == \"FALSE\" ]; then\n        py_num=\"2\"\n    fi\n    py_vers=\"$(echo \"$py_html\" | grep -i \"Latest Python $py_num Release\" | awk '{print $8}' | cut -d'<' -f1)\"\n    echo \"$py_vers\"\n}\n\ndownload_py () {\n    local vers=\"$1\" url=\n    clear\n    echo \"  ###                        ###\"\n    echo \" #     Downloading Python     #\"\n    echo \"###                        ###\"\n    echo\n    if [ -z \"$vers\" ]; then\n        echo \"Gathering latest version...\"\n        vers=\"$(get_remote_py_version)\"\n    fi\n    if [ -z \"$vers\" ]; then\n        # Didn't get it still - bail\n        print_error\n    fi\n    echo \"Located Version:  $vers\"\n    echo\n    echo \"Building download url...\"\n    url=\"$(curl -L https://www.python.org/downloads/release/python-${vers//./}/ --compressed 2>&1 | grep -iE \"python-$vers-macos.*.pkg\\\"\" | awk -F'\"' '{ print $2 }')\"\n    if [ -z \"$url\" ]; then\n        # Couldn't get the URL - bail\n        print_error\n    fi\n    echo \" - $url\"\n    echo\n    echo \"Downloading...\"\n    echo\n    # Create a temp dir and download to it\n    tempdir=\"$(mktemp -d 2>/dev/null || mktemp -d -t 'tempdir')\"\n    curl \"$url\" -o \"$tempdir/python.pkg\"\n    if [ \"$?\" != \"0\" ]; then\n        echo\n        echo \" - Failed to download python installer!\"\n        echo\n        exit $?\n    fi\n    echo\n    echo \"Running python install package...\"\n    echo\n    sudo installer -pkg \"$tempdir/python.pkg\" -target /\n    if [ \"$?\" != \"0\" ]; then\n        echo\n        echo \" - Failed to install python!\"\n        echo\n        exit $?\n    fi\n    # Now we expand the package and look for a shell update script\n    pkgutil --expand \"$tempdir/python.pkg\" \"$tempdir/python\"\n    if [ -e \"$tempdir/python/Python_Shell_Profile_Updater.pkg/Scripts/postinstall\" ]; then\n        # Run the script\n        echo\n        echo \"Updating PATH...\"\n        echo\n        \"$tempdir/python/Python_Shell_Profile_Updater.pkg/Scripts/postinstall\"\n    fi\n    vers_folder=\"Python $(echo \"$vers\" | cut -d'.' -f1 -f2)\"\n    if [ -f \"/Applications/$vers_folder/Install Certificates.command\" ]; then\n        # Certs script exists - let's execute that to make sure our certificates are updated\n        echo\n        echo \"Updating Certificates...\"\n        echo\n        \"/Applications/$vers_folder/Install Certificates.command\"\n    fi\n    echo\n    echo \"Cleaning up...\"\n    cleanup\n    echo\n    if [ \"$just_installing\" == \"TRUE\" ]; then\n        echo \"Done.\"\n    else\n        # Now we check for py again\n        echo \"Rechecking py...\"\n        downloaded=\"TRUE\"\n        clear\n        main\n    fi\n}\n\ncleanup () {\n    if [ -d \"$tempdir\" ]; then\n        rm -Rf \"$tempdir\"\n    fi\n}\n\nprint_error() {\n    clear\n    cleanup\n    echo \"  ###                      ###\"\n    echo \" #     Python Not Found     #\"\n    echo \"###                      ###\"\n    echo\n    echo \"Python is not installed or not found in your PATH var.\"\n    echo\n    if [ \"$kernel\" == \"Darwin\" ]; then\n        echo \"Please go to https://www.python.org/downloads/macos/ to\"\n        echo \"download and install the latest version, then try again.\"\n    else\n        echo \"Please install python through your package manager and\"\n        echo \"try again.\"\n    fi\n    echo\n    exit 1\n}\n\nprint_target_missing() {\n    clear\n    cleanup\n    echo \"  ###                      ###\"\n    echo \" #     Target Not Found     #\"\n    echo \"###                      ###\"\n    echo\n    echo \"Could not locate $target!\"\n    echo\n    exit 1\n}\n\nformat_version () {\n    local vers=\"$1\"\n    echo \"$(echo \"$1\" | awk -F. '{ printf(\"%d%03d%03d%03d\\n\", $1,$2,$3,$4); }')\"\n}\n\nvercomp () {\n    # Modified from: https://apple.stackexchange.com/a/123408/11374\n    local ver1=\"$(format_version \"$1\")\" ver2=\"$(format_version \"$2\")\"\n    if [ $ver1 -gt $ver2 ]; then\n        echo \"1\"\n    elif [ $ver1 -lt $ver2 ]; then\n        echo \"2\"\n    else\n        echo \"0\"\n    fi\n}\n\nget_local_python_version() {\n    # $1 = Python bin name (defaults to python3)\n    # Echoes the path to the highest version of the passed python bin if any\n    local py_name=\"$1\" max_version= python= python_version= python_path=\n    if [ -z \"$py_name\" ]; then\n        py_name=\"python3\"\n    fi\n    py_list=\"$(which -a \"$py_name\" 2>/dev/null)\"\n    # Walk that newline separated list\n    while read python; do\n        if [ -z \"$python\" ]; then\n            # Got a blank line - skip\n            continue\n        fi\n        if [ \"$check_py3_stub\" == \"1\" ] && [ \"$python\" == \"/usr/bin/python3\" ]; then\n            # See if we have a valid developer path\n            xcode-select -p > /dev/null 2>&1\n            if [ \"$?\" != \"0\" ]; then\n                # /usr/bin/python3 path - but no valid developer dir\n                continue\n            fi\n        fi\n        python_version=\"$(get_python_version $python)\"\n        if [ -z \"$python_version\" ]; then\n            # Didn't find a py version - skip\n            continue\n        fi\n        # Got the py version - compare to our max\n        if [ -z \"$max_version\" ] || [ \"$(vercomp \"$python_version\" \"$max_version\")\" == \"1\" ]; then\n            # Max not set, or less than the current - update it\n            max_version=\"$python_version\"\n            python_path=\"$python\"\n        fi\n    done <<< \"$py_list\"\n    echo \"$python_path\"\n}\n\nget_python_version() {\n    local py_path=\"$1\" py_version=\n    # Get the python version by piping stderr into stdout (for py2), then grepping the output for\n    # the word \"python\", getting the second element, and grepping for an alphanumeric version number\n    py_version=\"$($py_path -V 2>&1 | grep -i python | cut -d' ' -f2 | grep -E \"[A-Za-z\\d\\.]+\")\"\n    if [ ! -z \"$py_version\" ]; then\n        echo \"$py_version\"\n    fi\n}\n\nprompt_and_download() {\n    if [ \"$downloaded\" != \"FALSE\" ] || [ \"$kernel\" != \"Darwin\" ]; then\n        # We already tried to download, or we're not on macOS - just bail\n        print_error\n    fi\n    clear\n    echo \"  ###                      ###\"\n    echo \" #     Python Not Found     #\"\n    echo \"###                      ###\"\n    echo\n    target_py=\"Python 3\"\n    printed_py=\"Python 2 or 3\"\n    if [ \"$use_py3\" == \"FORCE\" ]; then\n        printed_py=\"Python 3\"\n    elif [ \"$use_py3\" == \"FALSE\" ]; then\n        target_py=\"Python 2\"\n        printed_py=\"Python 2\"\n    fi\n    echo \"Could not locate $printed_py!\"\n    echo\n    echo \"This script requires $printed_py to run.\"\n    echo\n    while true; do\n        read -p \"Would you like to install the latest $target_py now? (y/n):  \" yn\n        case $yn in\n            [Yy]* ) download_py;break;;\n            [Nn]* ) print_error;;\n        esac\n    done\n}\n\nmain() {\n    local python= version=\n    # Verify our target exists\n    if [ ! -f \"$dir/$target\" ]; then\n        # Doesn't exist\n        print_target_missing\n    fi\n    if [ -z \"$use_py3\" ]; then\n        use_py3=\"TRUE\"\n    fi\n    if [ \"$use_py3\" != \"FALSE\" ]; then\n        # Check for py3 first\n        python=\"$(get_local_python_version python3)\"\n    fi\n    if [ \"$use_py3\" != \"FORCE\" ] && [ -z \"$python\" ]; then\n        # We aren't using py3 explicitly, and we don't already have a path\n        python=\"$(get_local_python_version python2)\"\n        if [ -z \"$python\" ]; then\n            # Try just looking for \"python\"\n            python=\"$(get_local_python_version python)\"\n        fi\n    fi\n    if [ -z \"$python\" ]; then\n        # Didn't ever find it - prompt\n        prompt_and_download\n        return 1\n    fi\n    # Found it - start our script and pass all args\n    \"$python\" \"$dir/$target\" \"${args[@]}\"\n}\n\n# Keep track of whether or not we're on macOS to determine if\n# we can download and install python for the user as needed.\nkernel=\"$(uname -s)\"\n# Check to see if we need to force based on\n# macOS version. 10.15 has a dummy python3 version\n# that can trip up some py3 detection in other scripts.\n# set_use_py3_if \"3\" \"10.15\" \"FORCE\"\ndownloaded=\"FALSE\"\n# Check for the aforementioned /usr/bin/python3 stub if\n# our OS version is 10.15 or greater.\ncheck_py3_stub=\"$(compare_to_version \"3\" \"10.15\")\"\ntrap cleanup EXIT\nif [ \"$1\" == \"--install-python\" ] && [ \"$kernel\" == \"Darwin\" ]; then\n    just_installing=\"TRUE\"\n    download_py\nelse\n    main\nfi\n"
        },
        {
          "name": "gibMacOS.py",
          "type": "blob",
          "size": 30.291015625,
          "content": "#!/usr/bin/env python3\nfrom Scripts import downloader,utils,run,plist\nimport os, shutil, time, sys, argparse, re, json\n\nclass ProgramError(Exception):\n    def __init__(self, message, title = \"Error\"):\n        super(Exception, self).__init__(message)\n        self.title = title\n\n\nclass gibMacOS:\n    def __init__(self, interactive = True, download_dir = None):\n        self.interactive = interactive\n        self.download_dir = download_dir\n        self.d = downloader.Downloader()\n        self.u = utils.Utils(\"gibMacOS\", interactive=interactive)\n        self.r = run.Run()\n        self.min_w = 80\n        self.min_h = 24\n        if os.name == \"nt\":\n            self.min_w = 120\n            self.min_h = 30\n        self.resize()\n\n        self.catalog_suffix = {\n            \"public\" : \"beta\",\n            \"publicrelease\" : \"\",\n            \"customer\" : \"customerseed\",\n            \"developer\" : \"seed\"\n        }\n        \n        # Load settings.json if it exists in the Scripts folder\n        self.settings_path = os.path.join(os.path.dirname(os.path.realpath(__file__)),\"Scripts\",\"settings.json\")\n        self.settings = {}\n        if os.path.exists(self.settings_path):\n            try: self.settings = json.load(open(self.settings_path))\n            except: pass\n        \n        self.current_macos = self.settings.get(\"current_macos\",20) # if > 16, assume X-5, else 10.X\n        self.min_macos = 5\n        self.print_urls = self.settings.get(\"print_urls\",False)\n        self.print_json = False\n        self.hide_pid = self.settings.get(\"hide_pid\",False)\n        self.mac_os_names_url = {\n            \"8\" : \"mountainlion\",\n            \"7\" : \"lion\",\n            \"6\" : \"snowleopard\",\n            \"5\" : \"leopard\"\n        }\n        self.version_names = {\n            \"tiger\" : \"10.4\",\n            \"leopard\" : \"10.5\",\n            \"snow leopard\" : \"10.6\",\n            \"lion\" : \"10.7\",\n            \"mountain lion\" : \"10.8\",\n            \"mavericks\" : \"10.9\",\n            \"yosemite\" : \"10.10\",\n            \"el capitan\" : \"10.11\",\n            \"sierra\" : \"10.12\",\n            \"high sierra\" : \"10.13\",\n            \"mojave\" : \"10.14\",\n            \"catalina\" : \"10.15\",\n            \"big sur\" : \"11\",\n            \"monterey\" : \"12\",\n            \"ventura\" : \"13\",\n            \"sonoma\" : \"14\",\n            \"sequoia\" : \"15\"\n        }\n        self.current_catalog = self.settings.get(\"current_catalog\",\"publicrelease\")\n        self.catalog_data    = None\n        self.scripts = \"Scripts\"\n        self.plist   = \"sucatalog.plist\"\n        self.save_local = False\n        self.force_local = False\n        self.find_recovery = self.settings.get(\"find_recovery\",False)\n        self.recovery_suffixes = (\n            \"RecoveryHDUpdate.pkg\",\n            \"RecoveryHDMetaDmg.pkg\"\n        )\n        self.settings_to_save = (\n            \"current_macos\",\n            \"current_catalog\",\n            \"print_urls\",\n            \"find_recovery\",\n            \"hide_pid\"\n        )\n\n    def resize(self, width=0, height=0):\n        if not self.interactive:\n            return\n        width = width if width > self.min_w else self.min_w\n        height = height if height > self.min_h else self.min_h\n        self.u.resize(width, height)\n\n    def save_settings(self):\n        # Ensure we're using the latest values\n        for setting in self.settings_to_save:\n            self.settings[setting] = getattr(self,setting,None)\n        try:\n            json.dump(self.settings,open(self.settings_path,\"w\"),indent=2)\n        except Exception as e:\n            raise ProgramError(\n                    \"Failed to save settings to:\\n\\n{}\\n\\nWith error:\\n\\n - {}\\n\".format(self.settings_path,repr(e)),\n                    title=\"Error Saving Settings\")\n\n    def set_prods(self):\n        self.resize()\n        if not self.get_catalog_data(self.save_local):\n            message = \"The currently selected catalog ({}) was not reachable\\n\".format(self.current_catalog)\n            if self.save_local:\n                message += \"and I was unable to locate a valid {} file in the\\n{} directory.\\n\".format(self.plist, self.scripts)\n            message += \"Please ensure you have a working internet connection.\"\n            raise ProgramError(message, title=\"Catalog Data Error\")\n        self.u.head(\"Parsing Data\")\n        self.u.info(\"Scanning products after catalog download...\\n\")\n        self.mac_prods = self.get_dict_for_prods(self.get_installers())\n\n    def set_catalog(self, catalog):\n        self.current_catalog = catalog.lower() if catalog.lower() in self.catalog_suffix else \"publicrelease\"\n\n    def num_to_macos(self,macos_num,for_url=True):\n        if for_url: # Resolve 8-5 to their names and show Big Sur as 10.16\n            return self.mac_os_names_url.get(str(macos_num),\"10.{}\".format(macos_num)) if macos_num <= 16 else str(macos_num-5)\n        # Return 10.xx for anything Catalina and lower, otherwise 11+\n        return \"10.{}\".format(macos_num) if macos_num <= 15 else str(macos_num-5)\n\n    def macos_to_num(self,macos):\n        try:\n            macos_parts = [int(x) for x in macos.split(\".\")][:2 if macos.startswith(\"10.\") else 1]\n            if macos_parts[0] == 11: macos_parts = [10,16] # Big sur\n        except:\n            return None\n        if len(macos_parts) > 1: return macos_parts[1]\n        return 5+macos_parts[0]\n\n    def get_macos_versions(self,minos=None,maxos=None,catalog=\"\"):\n        if minos is None: minos = self.min_macos\n        if maxos is None: maxos = self.current_macos\n        if minos > maxos: minos,maxos = maxos,minos # Ensure min is less than or equal\n        os_versions = [self.num_to_macos(x,for_url=True) for x in range(minos,maxos+1)]\n        if catalog:\n            # We have a custom catalog - prepend the first entry + catalog to the list\n            custom_cat_entry = os_versions[-1]+catalog\n            os_versions.append(custom_cat_entry)\n        return os_versions\n\n    def build_url(self, **kwargs):\n        catalog = kwargs.get(\"catalog\", self.current_catalog).lower()\n        catalog = catalog if catalog.lower() in self.catalog_suffix else \"publicrelease\"\n        version = int(kwargs.get(\"version\", self.current_macos))\n        return \"https://swscan.apple.com/content/catalogs/others/index-{}.merged-1.sucatalog\".format(\n            \"-\".join(reversed(self.get_macos_versions(self.min_macos,version,catalog=self.catalog_suffix.get(catalog,\"\"))))\n        )\n\n    def get_catalog_data(self, local = False):\n        # Gets the data based on our current_catalog\n        url = self.build_url(catalog=self.current_catalog, version=self.current_macos)\n        self.u.head(\"Downloading Catalog\")\n        if local:\n            self.u.info(\"Checking locally for {}\".format(self.plist))\n            cwd = os.getcwd()\n            os.chdir(os.path.dirname(os.path.realpath(__file__)))\n            if os.path.exists(os.path.join(os.path.dirname(os.path.realpath(__file__)), self.scripts, self.plist)):\n                self.u.info(\" - Found - loading...\")\n                try:\n                    with open(os.path.join(os.getcwd(), self.scripts, self.plist), \"rb\") as f:\n                        self.catalog_data = plist.load(f)\n                    os.chdir(cwd)\n                    return True\n                except:\n                    self.u.info(\" - Error loading - downloading instead...\\n\")\n                    os.chdir(cwd)\n            else:\n                self.u.info(\" - Not found - downloading instead...\\n\")\n        self.u.info(\"Currently downloading {} catalog from:\\n\\n{}\\n\".format(self.current_catalog, url))\n        try:\n            b = self.d.get_bytes(url, self.interactive)\n            self.u.info(\"\")\n            self.catalog_data = plist.loads(b)\n        except:\n            self.u.info(\"Error downloading!\")\n            return False\n        try:\n            # Assume it's valid data - dump it to a local file\n            if local or self.force_local:\n                self.u.info(\" - Saving to {}...\".format(self.plist))\n                cwd = os.getcwd()\n                os.chdir(os.path.dirname(os.path.realpath(__file__)))\n                with open(os.path.join(os.getcwd(), self.scripts, self.plist), \"wb\") as f:\n                    plist.dump(self.catalog_data, f)\n                os.chdir(cwd)\n        except:\n            self.u.info(\" - Error saving!\")\n            return False\n        return True\n\n    def get_installers(self, plist_dict = None):\n        if not plist_dict:\n            plist_dict = self.catalog_data\n        if not plist_dict:\n            return []\n        mac_prods = []\n        for p in plist_dict.get(\"Products\", {}):\n            if not self.find_recovery:\n                val = plist_dict.get(\"Products\",{}).get(p,{}).get(\"ExtendedMetaInfo\",{}).get(\"InstallAssistantPackageIdentifiers\",{})\n                if val.get(\"OSInstall\",{}) == \"com.apple.mpkg.OSInstall\" or val.get(\"SharedSupport\",\"\").startswith(\"com.apple.pkg.InstallAssistant\"):\n                    mac_prods.append(p)\n            else:\n                # Find out if we have any of the recovery_suffixes\n                if any(x for x in plist_dict.get(\"Products\",{}).get(p,{}).get(\"Packages\",[]) if x[\"URL\"].endswith(self.recovery_suffixes)):\n                    mac_prods.append(p)\n        return mac_prods\n\n    def get_build_version(self, dist_dict):\n        build = version = name = \"Unknown\"\n        try:\n            dist_url = dist_dict.get(\"English\",\"\") if dist_dict.get(\"English\",None) else dist_dict.get(\"en\",\"\")\n            dist_file = self.d.get_bytes(dist_url, False).decode(\"utf-8\")\n        except:\n            dist_file = \"\"\n            pass\n        build_search = \"macOSProductBuildVersion\" if \"macOSProductBuildVersion\" in dist_file else \"BUILD\"\n        vers_search  = \"macOSProductVersion\" if \"macOSProductVersion\" in dist_file else \"VERSION\"\n        try:\n            build = dist_file.split(\"<key>{}</key>\".format(build_search))[1].split(\"<string>\")[1].split(\"</string>\")[0]\n        except:\n            pass\n        try:\n            version = dist_file.split(\"<key>{}</key>\".format(vers_search))[1].split(\"<string>\")[1].split(\"</string>\")[0]\n        except:\n            pass\n        try:\n            name = re.search(r\"<title>(.+?)</title>\",dist_file).group(1)\n        except:\n            pass\n        try:\n            # XXX: This is parsing a JavaScript array from the script part of the dist file.\n            device_ids = re.search(r\"var supportedDeviceIDs\\s*=\\s*\\[([^]]+)\\];\", dist_file)[1]\n            device_ids = set(i.lower() for i in re.findall(r\"'([^',]+)'\", device_ids))\n        except:\n            device_ids = set()\n        return (build,version,name,device_ids)\n\n    def get_dict_for_prods(self, prods, plist_dict = None):\n        if plist_dict==self.catalog_data==None:\n            plist_dict = {}\n        else:\n            plist_dict = self.catalog_data if plist_dict == None else plist_dict\n\n        prod_list = []\n        for prod in prods:\n            # Grab the ServerMetadataURL for the passed product key if it exists\n            prodd = {\"product\":prod}\n            try:\n                b = self.d.get_bytes(plist_dict.get(\"Products\",{}).get(prod,{}).get(\"ServerMetadataURL\",\"\"), False)\n                smd = plist.loads(b)\n            except:\n                smd = {}\n            # Populate some info!\n            prodd[\"date\"] = plist_dict.get(\"Products\",{}).get(prod,{}).get(\"PostDate\",\"\")\n            prodd[\"installer\"] = plist_dict.get(\"Products\",{}).get(prod,{}).get(\"ExtendedMetaInfo\",{}).get(\"InstallAssistantPackageIdentifiers\",{}).get(\"OSInstall\",{}) == \"com.apple.mpkg.OSInstall\"\n            prodd[\"time\"] = time.mktime(prodd[\"date\"].timetuple()) + prodd[\"date\"].microsecond / 1E6\n            prodd[\"version\"] = smd.get(\"CFBundleShortVersionString\",\"Unknown\").strip()\n            # Try to get the description too\n            try:\n                desc = smd.get(\"localization\",{}).get(\"English\",{}).get(\"description\",\"\").decode(\"utf-8\")\n                desctext = desc.split('\"p1\">')[1].split(\"</a>\")[0]\n            except:\n                desctext = None\n            prodd[\"description\"] = desctext\n            # Iterate the available packages and save their urls and sizes\n            if self.find_recovery:\n                # Only get the recovery packages\n                prodd[\"packages\"] = [x for x in plist_dict.get(\"Products\",{}).get(prod,{}).get(\"Packages\",[]) if x[\"URL\"].endswith(self.recovery_suffixes)]\n            else:\n                # Add them all!\n                prodd[\"packages\"] = plist_dict.get(\"Products\",{}).get(prod,{}).get(\"Packages\",[])\n            # Get size\n            prodd[\"size\"] = self.d.get_size(sum([i[\"Size\"] for i in prodd[\"packages\"]]))\n            # Attempt to get the build/version/name/device-ids info from the dist\n            prodd[\"build\"],v,n,prodd[\"device_ids\"] = self.get_build_version(plist_dict.get(\"Products\",{}).get(prod,{}).get(\"Distributions\",{}))\n            prodd[\"title\"] = smd.get(\"localization\",{}).get(\"English\",{}).get(\"title\",n)\n            self.u.info(\" -->{}. {} ({}){}\".format(\n                str(len(prod_list)+1).rjust(3),\n                prodd[\"title\"],\n                prodd[\"build\"],\n                \" - FULL Install\" if self.find_recovery and prodd[\"installer\"] else \"\"\n            ))\n            if v.lower() != \"unknown\":\n                prodd[\"version\"] = v\n            prod_list.append(prodd)\n        # Sort by newest\n        prod_list = sorted(prod_list, key=lambda x:x[\"time\"], reverse=True)\n        return prod_list\n\n    def download_prod(self, prod, dmg = False):\n        # Takes a dictonary of details and downloads it\n        self.resize()\n        name = \"{} - {} {} ({})\".format(prod[\"product\"], prod[\"version\"], prod[\"title\"], prod[\"build\"]).replace(\":\",\"\").strip()\n        download_dir = self.download_dir or os.path.join(os.path.dirname(os.path.realpath(__file__)), \"macOS Downloads\", self.current_catalog, name)\n        dl_list = []\n        for x in prod[\"packages\"]:\n            if not x.get(\"URL\",None):\n                continue\n            if dmg and not x.get(\"URL\",\"\").lower().endswith(\".dmg\"):\n                continue\n            # add it to the list\n            dl_list.append(x)\n        if not len(dl_list):\n            raise ProgramError(\"There were no files to download\")\n        done = []\n        if self.print_json:\n            print(self.product_to_json(prod))\n            if self.interactive:\n                print(\"\")\n                self.u.grab(\"Press [enter] to return...\")\n            return\n        elif self.print_urls:\n            self.u.head(\"Download Links\")\n            print(\"{}:\\n\".format(name))\n            print(\"\\n\".join([\" - {} ({}) \\n   --> {}\".format(\n                os.path.basename(x[\"URL\"]),\n                self.d.get_size(x[\"Size\"],strip_zeroes=True) if x.get(\"Size\") is not None else \"?? MB\",\n                x[\"URL\"]\n            ) for x in dl_list]))\n            if self.interactive:\n                print(\"\")\n                self.u.grab(\"Press [enter] to return...\")\n            return\n        # Only check the dirs if we need to\n        if self.download_dir is None and os.path.exists(download_dir):\n            while True:\n                self.u.head(\"Already Exists\")\n                self.u.info(\"It looks like you've already downloaded {}\\n\".format(name))\n                if not self.interactive:\n                    return\n                menu = self.u.grab(\"Redownload? (y/n):  \")\n                if not len(menu):\n                    continue\n                if menu[0].lower() == \"n\":\n                    return\n                if menu[0].lower() == \"y\":\n                    break\n            # Remove the old copy, then re-download\n            shutil.rmtree(download_dir)\n        # Make it new\n        os.makedirs(download_dir)\n        for c,x in enumerate(dl_list,start=1):\n            url = x[\"URL\"]\n            self.u.head(\"Downloading File {} of {}\".format(c, len(dl_list)))\n            if len(done):\n                self.u.info(\"\\n\".join([\"{} --> {}\".format(y[\"name\"], \"Succeeded\" if y[\"status\"] else \"Failed\") for y in done]))\n                self.u.info(\"\")\n            if dmg:\n                self.u.info(\"NOTE: Only Downloading DMG Files\\n\")\n            self.u.info(\"Downloading {} for {}...\\n\".format(os.path.basename(url), name))\n            try:\n                result = self.d.stream_to_file(url, os.path.join(download_dir, os.path.basename(url)))\n                assert result is not None\n                done.append({\"name\":os.path.basename(url), \"status\":True})\n            except:\n                done.append({\"name\":os.path.basename(url), \"status\":False})\n        succeeded = [x for x in done if x[\"status\"]]\n        failed    = [x for x in done if not x[\"status\"]]\n        self.u.head(\"Downloaded {} of {}\".format(len(succeeded), len(dl_list)))\n        self.u.info(\"Succeeded:\")\n        if len(succeeded):\n            for x in succeeded:\n                self.u.info(\"  {}\".format(x[\"name\"]))\n        else:\n            self.u.info(\"  None\")\n        self.u.info(\"\\nFailed:\")\n        if len(failed):\n            for x in failed:\n                self.u.info(\"  {}\".format(x[\"name\"]))\n        else:\n            self.u.info(\"  None\")\n        self.u.info(\"\\nFiles saved to:\\n  {}\\n\".format(download_dir))\n        if self.interactive:\n            self.u.grab(\"Press [enter] to return...\")\n        elif len(failed):\n            raise ProgramError(\"{} files failed to download\".format(len(failed)))\n\n    def product_to_json(self, prod):\n        prod_dict = {}\n        for key in [\"product\", \"version\", \"build\", \"title\", \"size\", \"packages\"]:\n            if key in prod:\n                prod_dict[key] = prod[key]\n        prod_dict[\"date\"] = prod[\"date\"].isoformat()\n        prod_dict[\"deviceIds\"] = list(prod[\"device_ids\"])\n        return json.dumps(prod_dict,indent=2)\n\n    def show_catalog_url(self):\n        self.resize()\n        self.u.head()\n        print(\"Current Catalog:   {}\".format(self.current_catalog))\n        print(\"Max macOS Version: {}\".format(self.num_to_macos(self.current_macos,for_url=False)))\n        print(\"\")\n        print(\"{}\".format(self.build_url()))\n        if self.interactive:\n            print(\"\")\n            self.u.grab(\"Press [enter] to return...\")\n\n    def pick_catalog(self):\n        self.resize()\n        self.u.head(\"Select SU Catalog\")\n        count = 0\n        for x in self.catalog_suffix:\n            count += 1\n            print(\"{}. {}\".format(count, x))\n        print(\"\")\n        print(\"M. Main Menu\")\n        print(\"Q. Quit\")\n        print(\"\")\n        menu = self.u.grab(\"Please select an option:  \")\n        if not len(menu):\n            self.pick_catalog()\n            return\n        if menu[0].lower() == \"m\":\n            return\n        elif menu[0].lower() == \"q\":\n            self.u.custom_quit()\n        # Should have something to test here\n        try:\n            i = int(menu)\n            self.current_catalog = list(self.catalog_suffix)[i-1]\n            self.save_settings()\n        except:\n            # Incorrect - try again\n            self.pick_catalog()\n            return\n        # If we made it here - then we got something\n        # Reload with the proper catalog\n        self.get_catalog_data()\n\n    def pick_macos(self):\n        self.resize()\n        self.u.head(\"Select Max macOS Version\")\n        print(\"Currently set to {}\".format(self.num_to_macos(self.current_macos,for_url=False)))\n        print(\"\")\n        print(\"M. Main Menu\")\n        print(\"Q. Quit\")\n        print(\"\")\n        print(\"Please type the max macOS version for the catalog url\")\n        menu = self.u.grab(\"eg. 10.15 for Catalina, 11 for Big Sur, 12 for Monterey:  \")\n        if not len(menu):\n            self.pick_macos()\n            return\n        if menu[0].lower() == \"m\":\n            return\n        elif menu[0].lower() == \"q\":\n            self.u.custom_quit()\n        # At this point - we should have something in the proper format\n        version = self.macos_to_num(menu)\n        if not version: return\n        self.current_macos = version\n        self.save_settings()\n        # At this point, we should be good\n        self.get_catalog_data()\n\n    def main(self, dmg = False):\n        lines = []\n        lines.append(\"Available Products:\")\n        lines.append(\" \")\n        if not len(self.mac_prods):\n            lines.append(\"No installers in catalog!\")\n            lines.append(\" \")\n        for num,p in enumerate(self.mac_prods,start=1):\n            var1 = \"{}. {} {}\".format(str(num).rjust(2), p[\"title\"], p[\"version\"])\n            var2 = \"\"\n            if p[\"build\"].lower() != \"unknown\":\n                var1 += \" ({})\".format(p[\"build\"])\n            if not self.hide_pid:\n                var2 = \"   - {} - Added {} - {}\".format(p[\"product\"], p[\"date\"], p[\"size\"])\n            if self.find_recovery and p[\"installer\"]:\n                # Show that it's a full installer\n                if self.hide_pid:\n                    var1 += \" - FULL Install\"\n                else:\n                    var2 += \" - FULL Install\"\n            lines.append(var1)\n            if not self.hide_pid:\n                lines.append(var2)\n        lines.append(\" \")\n        lines.append(\"M. Change Max-OS Version (Currently {})\".format(self.num_to_macos(self.current_macos,for_url=False)))\n        lines.append(\"C. Change Catalog (Currently {})\".format(self.current_catalog))\n        lines.append(\"I. Only Print URLs (Currently {})\".format(\"On\" if self.print_urls else \"Off\"))\n        lines.append(\"H. Hide Package IDs and Upload Dates\")\n        if sys.platform.lower() == \"darwin\":\n            lines.append(\"S. Set Current Catalog to SoftwareUpdate Catalog\")\n            lines.append(\"L. Clear SoftwareUpdate Catalog\")\n        lines.append(\"R. Toggle Recovery-Only (Currently {})\".format(\"On\" if self.find_recovery else \"Off\"))\n        lines.append(\"U. Show Catalog URL\")\n        lines.append(\"Q. Quit\")\n        lines.append(\" \")\n        self.resize(len(max(lines)), len(lines)+5)\n        self.u.head()\n        print(\"\\n\".join(lines))\n        menu = self.u.grab(\"Please select an option:  \")\n        if not len(menu):\n            return\n        if menu[0].lower() == \"q\":\n            self.resize()\n            self.u.custom_quit()\n        elif menu[0].lower() == \"u\":\n            self.show_catalog_url()\n            return\n        elif menu[0].lower() == \"m\":\n            self.pick_macos()\n        elif menu[0].lower() == \"c\":\n            self.pick_catalog()\n        elif menu[0].lower() == \"i\":\n            self.print_urls ^= True\n            self.save_settings()\n            return\n        elif menu[0].lower() == \"h\":\n            self.hide_pid ^= True\n            self.save_settings()\n        elif menu[0].lower() == \"l\" and sys.platform.lower() == \"darwin\":\n            # Clear the software update catalog\n            self.u.head(\"Clearing SU CatalogURL\")\n            print(\"sudo softwareupdate --clear-catalog\")\n            self.r.run({\"args\":[\"softwareupdate\",\"--clear-catalog\"],\"sudo\":True})\n            print(\"\")\n            self.u.grab(\"Done.\", timeout=5)\n            return\n        elif menu[0].lower() == \"s\" and sys.platform.lower() == \"darwin\":\n            # Set the software update catalog to our current catalog url\n            self.u.head(\"Setting SU CatalogURL\")\n            url = self.build_url(catalog=self.current_catalog, version=self.current_macos)\n            print(\"Setting catalog URL to:\\n{}\".format(url))\n            print(\"\")\n            print(\"sudo softwareupdate --set-catalog {}\".format(url))\n            self.r.run({\"args\":[\"softwareupdate\",\"--set-catalog\",url],\"sudo\":True})\n            print(\"\")\n            self.u.grab(\"Done\",timeout=5)\n            return\n        elif menu[0].lower() == \"r\":\n            self.find_recovery ^= True\n            self.save_settings()\n        if menu[0].lower() in [\"m\",\"c\",\"r\"]:\n            self.resize()\n            self.u.head(\"Parsing Data\")\n            print(\"Re-scanning products after url preference toggled...\\n\")\n            self.mac_prods = self.get_dict_for_prods(self.get_installers())\n            return\n        \n        # Assume we picked something\n        try:\n            menu = int(menu)\n        except:\n            return\n        if menu < 1 or menu > len(self.mac_prods):\n            return\n        self.download_prod(self.mac_prods[menu-1], dmg)\n\n    def get_latest(self, device_id = None, dmg = False):\n        self.u.head(\"Downloading Latest\")\n        prods = sorted(self.mac_prods, key=lambda x:x['version'], reverse=True)\n        if device_id:\n            prod = next(p for p in prods if device_id.lower() in p[\"device_ids\"])\n            if not prod:\n                raise ProgramError(\"No version found for Device ID '{}'\".format(device_id))\n        else:\n            prod = prods[0]\n        self.download_prod(prod, dmg)\n\n    def get_for_product(self, prod, dmg = False):\n        self.u.head(\"Downloading for {}\".format(prod))\n        for p in self.mac_prods:\n            if p[\"product\"] == prod:\n                self.download_prod(p, dmg)\n                return\n        raise ProgramError(\"{} not found\".format(prod))\n\n    def get_for_version(self, vers, build = None, device_id = None, dmg = False):\n        self.u.head(\"Downloading for {} {}\".format(vers, build or \"\"))\n        # Map the versions to their names\n        v = self.version_names.get(vers.lower(),vers.lower())\n        v_dict = {}\n        for n in self.version_names:\n            v_dict[self.version_names[n]] = n\n        n = v_dict.get(v, v)\n        for p in sorted(self.mac_prods, key=lambda x:x['version'], reverse=True):\n            if build and p[\"build\"] != build:\n                continue\n            if device_id and device_id.lower() not in p[\"device_ids\"]:\n                continue\n            pt = p[\"title\"].lower()\n            pv = p[\"version\"].lower()\n            # Need to compare verisons - n = name, v = version\n            # p[\"version\"] and p[\"title\"] may contain either the version\n            # or name - so check both\n            # We want to make sure, if we match the name to the title, that we only match\n            # once - so Sierra/High Sierra don't cross-match\n            #\n            # First check if p[\"version\"] isn't \" \" or \"1.0\"\n            if not pv in [\" \",\"1.0\"]:\n                # Have a real version - match this first\n                if pv.startswith(v):\n                    self.download_prod(p, dmg)\n                    return\n            # Didn't match the version - or version was bad, let's check\n            # the title\n            # Need to make sure n is in the version name, but not equal to it,\n            # and the version name is in p[\"title\"] to disqualify\n            # i.e. - \"Sierra\" exists in \"High Sierra\", but does not equal \"High Sierra\"\n            # and \"High Sierra\" is in \"macOS High Sierra 10.13.6\" - This would match\n            name_match = [x for x in self.version_names if n in x and x != n and x in pt]\n            if (n in pt) and not len(name_match):\n                self.download_prod(p, dmg)\n                return\n        raise ProgramError(\"'{}' '{}' not found\".format(vers, build or \"\"))\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-l\", \"--latest\", help=\"downloads the version available in the current catalog (overrides --build, --version and --product)\", action=\"store_true\")\n    parser.add_argument(\"-r\", \"--recovery\", help=\"looks for RecoveryHDUpdate.pkg and RecoveryHDMetaDmg.pkg in lieu of com.apple.mpkg.OSInstall (overrides --dmg)\", action=\"store_true\")\n    parser.add_argument(\"-d\", \"--dmg\", help=\"downloads only the .dmg files\", action=\"store_true\")\n    parser.add_argument(\"-s\", \"--savelocal\", help=\"uses a locally saved sucatalog.plist if exists\", action=\"store_true\")\n    parser.add_argument(\"-n\", \"--newlocal\", help=\"downloads and saves locally, overwriting any prior local sucatalog.plist\", action=\"store_true\")\n    parser.add_argument(\"-c\", \"--catalog\", help=\"sets the CATALOG to use - publicrelease, public, customer, developer\")\n    parser.add_argument(\"-p\", \"--product\", help=\"sets the product id to search for (overrides --version)\")\n    parser.add_argument(\"-v\", \"--version\", help=\"sets the version of macOS to target - eg '-v 10.14' or '-v Yosemite'\")\n    parser.add_argument(\"-b\", \"--build\", help=\"sets the build of macOS to target - eg '22G120' (must be used together with --version)\")\n    parser.add_argument(\"-m\", \"--maxos\", help=\"sets the max macOS version to consider when building the url - eg 10.14\")\n    parser.add_argument(\"-D\", \"--device-id\", help=\"use with --version or --latest to search for versions supporting the specified Device ID - eg VMM-x86_64 for any x86_64\")\n    parser.add_argument(\"-i\", \"--print-urls\", help=\"only prints the download URLs, does not actually download them\", action=\"store_true\")\n    parser.add_argument(\"-j\", \"--print-json\", help=\"only prints the product metadata in JSON, does not actually download it\", action=\"store_true\")\n    parser.add_argument(\"--no-interactive\", help=\"run in non-interactive mode (auto-enabled when using --product or --version)\", action=\"store_true\")\n    parser.add_argument(\"-o\", \"--download-dir\", help=\"overrides directory where the downloaded files are saved\")\n    args = parser.parse_args()\n\n    if args.build and not (args.latest or args.product or args.version):\n        print(\"The --build option requires a --version\")\n        exit(1)\n\n    interactive = not any((args.no_interactive,args.product,args.version))\n    g = gibMacOS(interactive=interactive, download_dir=args.download_dir)\n\n    if args.recovery:\n        args.dmg = False\n        g.find_recovery = args.recovery\n\n    if args.savelocal:\n        g.save_local = True\n\n    if args.newlocal:\n        g.force_local = True\n\n    if args.print_urls:\n        g.print_urls = True\n\n    if args.print_json:\n        g.print_json = True\n\n    if args.maxos:\n        try:\n            version = g.macos_to_num(args.maxos)\n            if version: g.current_macos = version\n        except:\n            pass\n    if args.catalog:\n        # Set the catalog\n        g.set_catalog(args.catalog)\n\n    try:\n        # Done setting up pre-requisites\n        g.set_prods()\n\n        if args.latest:\n            g.get_latest(device_id=args.device_id, dmg=args.dmg)\n        elif args.product != None:\n            g.get_for_product(args.product, args.dmg)\n        elif args.version != None:\n            g.get_for_version(args.version, args.build, device_id=args.device_id, dmg=args.dmg)\n        elif g.interactive:\n            while True:\n                try:\n                    g.main(args.dmg)\n                except ProgramError as e:\n                    g.u.head(e.title)\n                    print(str(e))\n                    print(\"\")\n                    g.u.grab(\"Press [enter] to return...\")\n        else:\n            raise ProgramError(\"No command specified\")\n    except ProgramError as e:\n        print(str(e))\n        if g.interactive:\n            print(\"\")\n            g.u.grab(\"Press [enter] to exit...\")\n        else:\n            exit(1)\n    exit(0)\n"
        }
      ]
    }
  ]
}