{
  "metadata": {
    "timestamp": 1736560487835,
    "page": 79,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jiaaro/pydub",
      "stars": 9089,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.10546875,
          "content": "*.pyc\n/.project\n/.pydevproject\n/dist/\n/pydub.egg-info/\n.DS_Store\nenv\n*.swp\n.idea\n\n/build/\n.remote-sync.json\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.373046875,
          "content": "os: linux\ndist: bionic  # focal\nlanguage: python\nbefore_install:\n  - sudo apt-get update --fix-missing\ninstall:\n  - sudo apt-get install -y ffmpeg libopus-dev python-scipy python3-scipy\npython:\n  - \"2.7\"\n  - \"3.6\"\n  - \"3.7\"\n  - \"3.8\"\n  - \"3.9\"\n  - \"pypy2\"\n  - \"pypy3\"\nscript:\n  - python test/test.py\nafter_script:\n  - pip install pylama && python -m pylama -i W,E501 pydub/ || true\n"
        },
        {
          "name": "API.markdown",
          "type": "blob",
          "size": 26.7021484375,
          "content": "# API Documentation\n\nThis document is a work in progress.\n\nIf you're looking for some functionality in particular, it's a good idea to take a look at the [source code](https://github.com/jiaaro/pydub). Core functionality is mostly in `pydub/audio_segment.py` – a number of `AudioSegment` methods are in the `pydub/effects.py` module, and added to `AudioSegment` via the effect registration process (the `register_pydub_effect()` decorator function)\n\nCurrently Undocumented:\n\n- Playback (`pydub.playback`)\n- Signal Processing (compression, EQ, normalize, speed change - `pydub.effects`, `pydub.scipy_effects`)\n- Signal generators (Sine, Square, Sawtooth, Whitenoise, etc - `pydub.generators`)\n- Effect registration system (basically the `pydub.utils.register_pydub_effect` decorator)\n\n\n## AudioSegment()\n\n`AudioSegment` objects are immutable, and support a number of operators.\n\n```python\nfrom pydub import AudioSegment\nsound1 = AudioSegment.from_file(\"/path/to/sound.wav\", format=\"wav\")\nsound2 = AudioSegment.from_file(\"/path/to/another_sound.wav\", format=\"wav\")\n\n# sound1 6 dB louder, then 3.5 dB quieter\nlouder = sound1 + 6\nquieter = sound1 - 3.5\n\n# sound1, with sound2 appended\ncombined = sound1 + sound2\n\n# sound1 repeated 3 times\nrepeated = sound1 * 3\n\n# duration\nduration_in_milliseconds = len(sound1)\n\n# first 5 seconds of sound1\nbeginning = sound1[:5000]\n\n# last 5 seconds of sound1\nend = sound1[-5000:]\n\n# split sound1 in 5-second slices\nslices = sound1[::5000]\n\n# Advanced usage, if you have raw audio data:\nsound = AudioSegment(\n    # raw audio data (bytes)\n    data=b'…',\n\n    # 2 byte (16 bit) samples\n    sample_width=2,\n\n    # 44.1 kHz frame rate\n    frame_rate=44100,\n\n    # stereo\n    channels=2\n)\n```\n\nAny operations that combine multiple `AudioSegment` objects in *any* way will first ensure that they have the same number of channels, frame rate, sample rate, bit depth, etc. When these things do not match, the lower quality sound is modified to match the quality of the higher quality sound so that quality is not lost: mono is converted to stereo, bit depth and frame rate/sample rate are increased as needed. If you do not want this behavior, you may explicitly reduce the number of channels, bits, etc using the appropriate `AudioSegment` methods.\n\n### AudioSegment(…).from_file()\n\nOpen an audio file as an `AudioSegment` instance and return it. there are also a number of wrappers provided for convenience, but you should probably just use this directly.\n\n```python\nfrom pydub import AudioSegment\n\n# wave and raw don’t use ffmpeg\nwav_audio = AudioSegment.from_file(\"/path/to/sound.wav\", format=\"wav\")\nraw_audio = AudioSegment.from_file(\"/path/to/sound.raw\", format=\"raw\",\n                                   frame_rate=44100, channels=2, sample_width=2)\n\n# all other formats use ffmpeg\nmp3_audio = AudioSegment.from_file(\"/path/to/sound.mp3\", format=\"mp3\")\n\n# use a file you've already opened (advanced …ish)\nwith open(\"/path/to/sound.wav\", \"rb\") as wav_file:\n    audio_segment = AudioSegment.from_file(wav_file, format=\"wav\")\n\n# also supports the os.PathLike protocol for python >= 3.6\nfrom pathlib import Path\nwav_path = Path(\"path/to/sound.wav\")\nwav_audio = AudioSegment.from_file(wav_path)\n```\n\nThe first argument is the path (as a string) of the file to read, **or** a file handle to read from.\n\n**Supported keyword arguments**:\n\n- `format` | example: `\"aif\"` | default: autodetected\n  Format of the output file. Supports `\"wav\"` and `\"raw\"` natively, requires ffmpeg for all other formats. `\"raw\"` files require 3 additional keyword arguments, `sample_width`, `frame_rate`, and `channels`, denoted below with: **`raw` only**. This extra info is required because raw audio files do not have headers to include this info in the file itself like wav files do.\n- `sample_width` | example: `2`\n  **`raw` only** — Use `1` for 8-bit audio `2` for 16-bit (CD quality) and `4` for 32-bit. It’s the number of bytes per sample.\n- `channels` | example: `1`\n  **`raw` only** — `1` for mono, `2` for stereo.\n- `frame_rate` | example: `2`\n  **`raw` only** — Also known as sample rate, common values are `44100` (44.1kHz - CD audio), and `48000` (48kHz - DVD audio)\n- `start_second` | example: `2.0` | default: `None`\n  Offset (in seconds) to start loading the audio file. If `None`, the audio will start loading from the beginning.\n- `duration` | example: `2.5` | default: `None`\n  Number of seconds to be loaded. If `None`, full audio will be loaded.\n\n\n### AudioSegment(…).export()\n\nWrite the `AudioSegment` object to a file – returns a file handle of the output file (you don't have to do anything with it, though).\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"/path/to/sound.wav\", format=\"wav\")\n\n# simple export\nfile_handle = sound.export(\"/path/to/output.mp3\", format=\"mp3\")\n\n# more complex export\nfile_handle = sound.export(\"/path/to/output.mp3\",\n                           format=\"mp3\",\n                           bitrate=\"192k\",\n                           tags={\"album\": \"The Bends\", \"artist\": \"Radiohead\"},\n                           cover=\"/path/to/albumcovers/radioheadthebends.jpg\")\n\n# split sound in 5-second slices and export\nfor i, chunk in enumerate(sound[::5000]):\n  with open(\"sound-%s.mp3\" % i, \"wb\") as f:\n    chunk.export(f, format=\"mp3\")\n```\n\nThe first argument is the location (as a string) to write the output, **or** a file handle to write to. If you do not pass an output file or path, a temporary file is generated.\n\n**Supported keyword arguments**:\n\n- `format` | example: `\"aif\"` | default: `\"mp3\"`\n  Format of the output file. Supports `\"wav\"` and `\"raw\"` natively, requires ffmpeg for all other formats.\n- `codec` | example: `\"libvorbis\"`\n  For formats that may contain content encoded with different codecs, you can specify the codec you'd like the encoder to use. For example, the \"ogg\" format is often used with the \"libvorbis\" codec. (requires ffmpeg)\n- `bitrate` | example: `\"128k\"`\n  For compressed formats, you can pass the bitrate you'd like the encoder to use (requires ffmpeg). Each codec accepts different bitrate arguments so take a look at the [ffmpeg documentation](https://www.ffmpeg.org/ffmpeg-codecs.html#Audio-Encoders) for details (bitrate usually shown as `-b`, `-ba` or `-a:b`).\n- `tags` | example: `{\"album\": \"1989\", \"artist\": \"Taylor Swift\"}`\n  Allows you to supply media info tags for the encoder (requires ffmpeg). Not all formats can receive tags (mp3 can).\n- `parameters` | example: `[\"-ac\", \"2\"]`\n  Pass additional [command line parameters](https://www.ffmpeg.org/ffmpeg.html) to the ffmpeg call. These are added to the end of the call (in the output file section).\n- `id3v2_version` | example: `\"3\"` | default: `\"4\"`\n  Set the ID3v2 version used by ffmpeg to add tags to the output file. If you want Windows Exlorer to display tags, use `\"3\"` here ([source](http://superuser.com/a/453133)).\n- `cover` | example: `\"/path/to/imgfile.png\"`\n  Allows you to supply a cover image (path to the image file). Currently, only MP3 files allow this keyword argument. Cover image must be a jpeg, png, bmp, or tiff file.\n\n\n### AudioSegment.empty()\n\nCreates a zero-duration `AudioSegment`.\n\n```python\nfrom pydub import AudioSegment\nempty = AudioSegment.empty()\n\nlen(empty) == 0\n```\n\nThis is useful for aggregation loops:\n```python\nfrom pydub import AudioSegment\n\nsounds = [\n  AudioSegment.from_wav(\"sound1.wav\"),\n  AudioSegment.from_wav(\"sound2.wav\"),\n  AudioSegment.from_wav(\"sound3.wav\"),\n]\n\nplaylist = AudioSegment.empty()\nfor sound in sounds:\n  playlist += sound\n```\n\n### AudioSegment.silent()\n\nCreates a silent audiosegment, which can be used as a placeholder, spacer, or as a canvas to overlay other sounds on top of.\n\n```python\nfrom pydub import AudioSegment\n\nten_second_silence = AudioSegment.silent(duration=10000)\n```\n\n**Supported keyword arguments**:\n\n- `duration` | example: `3000` | default: `1000` (1 second)\n  Length of the silent `AudioSegment`, in milliseconds\n- `frame_rate` | example `44100` | default: `11025` (11.025 kHz)\n  Frame rate (i.e., sample rate) of the silent `AudioSegment` in Hz\n\n### AudioSegment.from_mono_audiosegments()\n\nCreates a multi-channel audiosegment out of multiple mono audiosegments (two or more). Each mono audiosegment passed in should be exactly the same length, down to the frame count.\n\n```python\nfrom pydub import AudioSegment\n\nleft_channel = AudioSegment.from_wav(\"sound1.wav\")\nright_channel = AudioSegment.from_wav(\"sound1.wav\")\n\nstereo_sound = AudioSegment.from_mono_audiosegments(left_channel, right_channel)\n```\n\n### AudioSegment(…).dBFS\n\nReturns the loudness of the `AudioSegment` in dBFS (db relative to the maximum possible loudness). A Square wave at maximum amplitude will be roughly 0 dBFS (maximum loudness), whereas a Sine Wave at maximum amplitude will be roughly -3 dBFS.\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"sound1.wav\")\n\nloudness = sound.dBFS\n```\n\n### AudioSegment(…).channels\n\nNumber of channels in this audio segment (1 means mono, 2 means stereo)\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"sound1.wav\")\n\nchannel_count = sound.channels\n```\n\n### AudioSegment(…).sample_width\n\nNumber of bytes in each sample (1 means 8 bit, 2 means 16 bit, etc). CD Audio is 16 bit, (sample width of 2 bytes).\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"sound1.wav\")\n\nbytes_per_sample = sound.sample_width\n```\n\n### AudioSegment(…).frame_rate\n\nCD Audio has a 44.1kHz sample rate, which means `frame_rate` will be `44100` (same as sample rate, see `frame_width`). Common values are `44100` (CD), `48000` (DVD), `22050`, `24000`, `12000` and `11025`.\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"sound1.wav\")\n\nframes_per_second = sound.frame_rate\n```\n\n### AudioSegment(…).frame_width\n\nNumber of bytes for each \"frame\". A frame contains a sample for each channel (so for stereo you have 2 samples per frame, which are played simultaneously). `frame_width` is equal to `channels * sample_width`. For CD Audio it'll be `4` (2 channels times 2 bytes per sample).\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"sound1.wav\")\n\nbytes_per_frame = sound.frame_width\n```\n\n### AudioSegment(…).rms\n\nA measure of loudness. Used to compute dBFS, which is what you should use in most cases. Loudness is logarithmic (rms is not), which makes dB a much more natural scale.\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"sound1.wav\")\n\nloudness = sound.rms\n```\n\n### AudioSegment(…).max\n\nThe highest amplitude of any sample in the `AudioSegment`. Useful for things like normalization (which is provided in `pydub.effects.normalize`).\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"sound1.wav\")\n\npeak_amplitude = sound.max\n```\n\n### AudioSegment(…).max_dBFS\n\nThe highest amplitude of any sample in the `AudioSegment`, in dBFS (relative to the highest possible amplitude value). Useful for things like normalization (which is provided in `pydub.effects.normalize`).\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"sound1.wav\")\n\nnormalized_sound = sound.apply_gain(-sound.max_dBFS)\n```\n\n### AudioSegment(…).duration_seconds\n\nReturns the duration of the `AudioSegment` in seconds (`len(sound)` returns milliseconds). This is provided for convenience; it calls `len()` internally.\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"sound1.wav\")\n\nassert sound.duration_seconds == (len(sound) / 1000.0)\n```\n\n### AudioSegment(…).raw_data\n\nThe raw audio data of the AudioSegment. Useful for interacting with other audio libraries or weird APIs that want audio data in the form of a bytestring. Also comes in handy if you’re implementing effects or other direct signal processing.\n\nYou probably don’t need this, but if you do… you’ll know.\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"sound1.wav\")\n\nraw_audio_data = sound.raw_data\n```\n\n### AudioSegment(…).frame_count()\n\nReturns the number of frames in the `AudioSegment`. Optionally you may pass in a `ms` keywork argument to retrieve the number of frames in that number of milliseconds of audio in the `AudioSegment` (useful for slicing, etc).\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(\"sound1.wav\")\n\nnumber_of_frames_in_sound = sound.frame_count()\n\nnumber_of_frames_in_200ms_of_sound = sound.frame_count(ms=200)\n```\n\n**Supported keyword arguments**:\n\n- `ms` | example: `3000` | default: `None` (entire duration of `AudioSegment`)\n  When specified, method returns number of frames in X milliseconds of the `AudioSegment`\n\n### AudioSegment(…).append()\n\nReturns a new `AudioSegment`, created by appending another `AudioSegment` to this one (i.e., adding it to the end), Optionally using a crossfade. `AudioSegment(…).append()` is used internally when adding `AudioSegment` objects together with the `+` operator.\n\nBy default a 100ms (0.1 second) crossfade is used to eliminate pops and crackles.\n\n```python\nfrom pydub import AudioSegment\nsound1 = AudioSegment.from_file(\"sound1.wav\")\nsound2 = AudioSegment.from_file(\"sound2.wav\")\n\n# default 100 ms crossfade\ncombined = sound1.append(sound2)\n\n# 5000 ms crossfade\ncombined_with_5_sec_crossfade = sound1.append(sound2, crossfade=5000)\n\n# no crossfade\nno_crossfade1 = sound1.append(sound2, crossfade=0)\n\n# no crossfade\nno_crossfade2 = sound1 + sound2\n```\n\n**Supported keyword arguments**:\n\n- `crossfade` | example: `3000` | default: `100` (entire duration of `AudioSegment`)\n  When specified, method returns number of frames in X milliseconds of the `AudioSegment`\n\n### AudioSegment(…).overlay()\n\nOverlays an `AudioSegment` onto this one. In the resulting `AudioSegment` they will play simultaneously. If the overlaid `AudioSegment` is longer than this one, the result will be truncated (so the end of the overlaid sound will be cut off). The result is always the same length as this `AudioSegment` even when using the `loop`, and `times` keyword arguments.\n\nSince `AudioSegment` objects are immutable, you can get around this by overlaying the shorter sound on the longer one, or by creating a silent `AudioSegment` with the appropriate duration, and overlaying both sounds on to that one.\n\n```python\nfrom pydub import AudioSegment\nsound1 = AudioSegment.from_file(\"sound1.wav\")\nsound2 = AudioSegment.from_file(\"sound2.wav\")\n\nplayed_togther = sound1.overlay(sound2)\n\nsound2_starts_after_delay = sound1.overlay(sound2, position=5000)\n\nvolume_of_sound1_reduced_during_overlay = sound1.overlay(sound2, gain_during_overlay=-8)\n\nsound2_repeats_until_sound1_ends = sound1.overlay(sound2, loop=true)\n\nsound2_plays_twice = sound1.overlay(sound2, times=2)\n\n# assume sound1 is 30 sec long and sound2 is 5 sec long:\nsound2_plays_a_lot = sound1.overlay(sound2, times=10000)\nlen(sound1) == len(sound2_plays_a_lot)\n```\n\n**Supported keyword arguments**:\n\n- `position` | example: `3000` | default: `0` (beginning of this `AudioSegment`)\n  The overlaid `AudioSegment` will not begin until X milliseconds have passed\n- `loop` | example: `True` | default: `False` (entire duration of `AudioSegment`)\n  The overlaid `AudioSegment` will repeat (starting at `position`) until the end of this `AudioSegment`\n- `times` | example: `4` | default: `1` (entire duration of `AudioSegment`)\n  The overlaid `AudioSegment` will repeat X times (starting at `position`) but will still be truncated to the length of this `AudioSegment`\n- `gain_during_overlay` | example: `-6.0` | default: `0` (no change in volume during overlay)\n  Change the original audio by this many dB while overlaying audio. This can be used to make the original audio quieter while the overlaid audio plays.\n\n### AudioSegment(…).apply_gain(`gain`)\n\nChange the amplitude (generally, loudness) of the `AudioSegment`. Gain is specified in dB. This method is used internally by the `+` operator.\n\n```python\nfrom pydub import AudioSegment\nsound1 = AudioSegment.from_file(\"sound1.wav\")\n\n# make sound1 louder by 3.5 dB\nlouder_via_method = sound1.apply_gain(+3.5)\nlouder_via_operator = sound1 + 3.5\n\n# make sound1 quieter by 5.7 dB\nquieter_via_method = sound1.apply_gain(-5.7)\nquieter_via_operator = sound1 - 5.7\n```\n\n### AudioSegment(…).fade()\n\nA more general (more flexible) fade method. You may specify `start` and `end`, or one of the two along with duration (e.g., `start` and `duration`).\n\n```python\nfrom pydub import AudioSegment\nsound1 = AudioSegment.from_file(\"sound1.wav\")\n\nfade_louder_for_3_seconds_in_middle = sound1.fade(to_gain=+6.0, start=7500, duration=3000)\n\nfade_quieter_beteen_2_and_3_seconds = sound1.fade(to_gain=-3.5, start=2000, end=3000)\n\n# easy way is to use the .fade_in() convenience method. note: -120dB is basically silent.\nfade_in_the_hard_way = sound1.fade(from_gain=-120.0, start=0, duration=5000)\nfade_out_the_hard_way = sound1.fade(to_gain=-120.0, end=0, duration=5000)\n```\n\n**Supported keyword arguments**:\n\n- `to_gain` | example: `-3.0` | default: `0` (0dB, no change)\n  Resulting change at the end of the fade. `-6.0` means fade will be be from 0dB (no change) to -6dB, and everything after the fade will be -6dB.\n- `from_gain` | example: `-3.0` | default: `0` (0dB, no change)\n  Change at the beginning of the fade. `-6.0` means fade (and all audio before it) will be be at -6dB will fade up to 0dB – the rest of the audio after the fade will be at 0dB (i.e., unchanged).\n- `start` | example: `7500` | NO DEFAULT\n  Position to begin fading (in milliseconds). `5500` means fade will begin after 5.5 seconds.\n- `end` | example: `4` | NO DEFAULT\n  The overlaid `AudioSegment` will repeat X times (starting at `position`) but will still be truncated to the length of this `AudioSegment`\n- `duration` | example: `4` | NO DEFAULT\n  You can use `start` or `end` with duration, instead of specifying both - provided as a convenience.\n\n### AudioSegment(…).fade_out()\n\nFade out (to silent) the end of this `AudioSegment`. Uses `.fade()` internally.\n\n**Supported keyword arguments**:\n\n- `duration` | example: `5000` | NO DEFAULT\n  How long (in milliseconds) the fade should last. Passed directly to `.fade()` internally\n\n### AudioSegment(…).fade_in()\n\nFade in (from silent) the beginning of this `AudioSegment`. Uses `.fade()` internally.\n\n**Supported keyword arguments**:\n\n- `duration` | example: `5000` | NO DEFAULT\n  How long (in milliseconds) the fade should last. Passed directly to `.fade()` internally\n\n### AudioSegment(…).reverse()\n\nMake a copy of this `AudioSegment` that plays backwards. Useful for Pink Floyd, screwing around, and some audio processing algorithms.\n\n### AudioSegment(…).set_sample_width()\n\nCreates an equivalent version of this `AudioSegment` with the specified sample width (in bytes). Increasing this value does not generally cause a reduction in quality. Reducing it *definitely* does cause a loss in quality. Higher Sample width means more dynamic range.\n\n### AudioSegment(…).set_frame_rate()\n\nCreates an equivalent version of this `AudioSegment` with the specified frame rate (in Hz). Increasing this value does not generally cause a reduction in quality. Reducing it *definitely does* cause a loss in quality. Higher frame rate means larger frequency response (higher frequencies can be represented).\n\n### AudioSegment(…).set_channels()\n\nCreates an equivalent version of this `AudioSegment` with the specified number of channels (1 is Mono, 2 is Stereo). Converting from mono to stereo does not cause any audible change. Converting from stereo to mono may result in loss of quality (but only if the left and right chanels differ).\n\n### AudioSegment(…).split_to_mono()\n\nSplits a stereo `AudioSegment` into two, one for each channel (Left/Right). Returns a list with the new `AudioSegment` objects with the left channel at index 0 and the right channel at index 1.\n\n### AudioSegment(…).apply_gain_stereo()\n\n```python\nfrom pydub import AudioSegment\nsound1 = AudioSegment.from_file(\"sound1.wav\")\n\n# make left channel 6dB quieter and right channe 2dB louder\nstereo_balance_adjusted = sound1.apply_gain_stereo(-6, +2)\n```\nApply gain to the left and right channel of a stereo `AudioSegment`. If the `AudioSegment` is mono, it will be converted to stereo before applying the gain.\n\nBoth gain arguments are specified in dB.\n\n### AudioSegment(…).pan()\n\n```python\nfrom pydub import AudioSegment\nsound1 = AudioSegment.from_file(\"sound1.wav\")\n\n# pan the sound 15% to the right\npanned_right = sound1.pan(+0.15)\n\n# pan the sound 50% to the left\npanned_left = sound1.pan(-0.50)\n```\n\nTakes one positional argument, *pan amount*, which should be between -1.0 (100% left) and +1.0 (100% right)\n\nWhen pan_amount == 0.0 the left/right balance is not changed.\n\nPanning does not alter the *perceived* loundness, but since loudness\nis decreasing on one side, the other side needs to get louder to\ncompensate. When panned hard left, the left channel will be 3dB louder and\nthe right channel will be silent (and vice versa).\n\n### AudioSegment(…).get_array_of_samples()\n\nReturns the raw audio data as an array of (numeric) samples. Note: if the audio has multiple channels, the samples for each channel will be serialized – for example, stereo audio would look like `[sample_1_L, sample_1_R, sample_2_L, sample_2_R, …]`.\n\nThis method is mainly for use in implementing effects, and other processing.\n\n```python\nfrom pydub import AudioSegment\nsound = AudioSegment.from_file(“sound1.wav”)\n\nsamples = sound.get_array_of_samples()\n\n# then modify samples...\n\nnew_sound = sound._spawn(samples)\n```\n\nnote that when using numpy or scipy you will need to convert back to an array before you spawn:\n\n```python\nimport array\nimport numpy as np\nfrom pydub import AudioSegment\n\nsound = AudioSegment.from_file(“sound1.wav”)\nsamples = sound.get_array_of_samples()\n\n# Example operation on audio data\nshifted_samples = np.right_shift(samples, 1)\n\n# now you have to convert back to an array.array\nshifted_samples_array = array.array(sound.array_type, shifted_samples)\n\nnew_sound = sound._spawn(shifted_samples_array)\n```\n\nHere's how to convert to a numpy float32 array:\n\n```python\nimport numpy as np\nfrom pydub import AudioSegment\n\nsound = AudioSegment.from_file(\"sound1.wav\")\nsound = sound.set_frame_rate(16000)\nchannel_sounds = sound.split_to_mono()\nsamples = [s.get_array_of_samples() for s in channel_sounds]\n\nfp_arr = np.array(samples).T.astype(np.float32)\nfp_arr /= np.iinfo(samples[0].typecode).max\n```\n\nAnd how to convert it back to an AudioSegment:\n\n```python\nimport io\nimport scipy.io.wavfile\n\nwav_io = io.BytesIO()\nscipy.io.wavfile.write(wav_io, 16000, fp_arr)\nwav_io.seek(0)\nsound = pydub.AudioSegment.from_wav(wav_io)\n```\n\n### AudioSegment(…).get_dc_offset()\n\nReturns a value between -1.0 and 1.0 representing the DC offset of a channel. This is calculated using `audioop.avg()` and normalizing the result by samples max value.\n\n**Supported keyword arguments**:\n\n- `channel` | example: `2` | default: `1`\n  Selects left (1) or right (2) channel to calculate DC offset. If segment is mono, this value is ignored.\n\n### AudioSegment(…).remove_dc_offset()\n\nRemoves DC offset from channel(s). This is done by using `audioop.bias()`, so watch out for overflows.\n\n**Supported keyword arguments**:\n\n- `channel` | example: `2` | default: None\n  Selects left (1) or right (2) channel remove DC offset. If value if None, removes from all available channels. If segment is mono, this value is ignored.\n\n- `offset` | example: `-0.1` | default: None\n  Offset to be removed from channel(s). Calculates offset if it's None. Offset values must be between -1.0 and 1.0.\n\n## Effects\n\nCollection of DSP effects that are implemented by `AudioSegment` objects.\n\n### AudioSegment(…).invert_phase()\n\nMake a copy of this `AudioSegment` and inverts the phase of the signal. Can generate anti-phase waves for noise suppression or cancellation.\n\n## Silence\n\nVarious functions for finding/manipulating silence in AudioSegments. For creating silent AudioSegments, see AudioSegment.silent().\n\n### silence.detect_silence()\n\nReturns a list of all silent sections [start, end] in milliseconds of audio_segment. Inverse of detect_nonsilent(). Can be very slow since it has to iterate over the whole segment.\n\n```python\nfrom pydub import AudioSegment, silence\n\nprint(silence.detect_silence(AudioSegment.silent(2000)))\n# [[0, 2000]]\n```\n\n**Supported keyword arguments**:\n\n- `min_silence_len` | example: `500` | default: 1000\n  The minimum length for silent sections in milliseconds. If it is greater than the length of the audio segment an empty list will be returned.\n\n- `silence_thresh` | example: `-20` | default: -16\n  The upper bound for how quiet is silent in dBFS.\n\n- `seek_step` | example: `5` | default: 1\n  Size of the step for checking for silence in milliseconds. Smaller is more precise. Must be a positive whole number.\n\n### silence.detect_nonsilent()\n\nReturns a list of all silent sections [start, end] in milliseconds of audio_segment. Inverse of detect_silence() and has all the same arguments. Can be very slow since it has to iterate over the whole segment.\n\n**Supported keyword arguments**:\n\n- `min_silence_len` | example: `500` | default: 1000\n  The minimum length for silent sections in milliseconds. If it is greater than the length of the audio segment an empty list will be returned.\n\n- `silence_thresh` | example: `-20` | default: -16\n  The upper bound for how quiet is silent in dBFS.\n\n- `seek_step` | example: `5` | default: 1\n  Size of the step for checking for silence in milliseconds. Smaller is more precise. Must be a positive whole number.\n\n### silence.split_on_silence()\n\nReturns list of audio segments from splitting audio_segment on silent sections.\n\n**Supported keyword arguments**:\n\n- `min_silence_len` | example: `500` | default: 1000\n  The minimum length for silent sections in milliseconds. If it is greater than the length of the audio segment an empty list will be returned.\n\n- `silence_thresh` | example: `-20` | default: -16\n  The upper bound for how quiet is silent in dBFS.\n\n- `seek_step` | example: `5` | default: 1\n  Size of the step for checking for silence in milliseconds. Smaller is more precise. Must be a positive whole number.\n\n- `keep_silence` ~ example: True | default: 100\n  How much silence to keep in ms or a bool. leave some silence at the beginning and end of the chunks. Keeps the sound from sounding like it is abruptly cut off.\n  When the length of the silence is less than the keep_silence duration it is split evenly between the preceding and following non-silent segments.\n  If True is specified, all the silence is kept, if False none is kept.\n\n### silence.detect_leading_silence()\n\nReturns the millisecond/index that the leading silence ends. If there is no end it will return the length of the audio_segment.\n\n```python\nfrom pydub import AudioSegment, silence\n\nprint(silence.detect_silence(AudioSegment.silent(2000)))\n# 2000\n```\n\n**Supported keyword arguments**:\n\n- `silence_thresh` | example: `-20` | default: -50\n  The upper bound for how quiet is silent in dBFS.\n\n- `chunk_size` | example: `5` | default: 10\n  Size of the step for checking for silence in milliseconds. Smaller is more precise. Must be a positive whole number.\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 1.248046875,
          "content": "James Robert\n    github: jiaaro\n    twitter: @jiaaro\n    web: jiaaro.com\n    email: pydub@jiaaro.com\n\nMarc Webbie\n    github: marcwebbie\n\nJean-philippe Serafin\n    github: jeanphix\n\nAnurag Ramdasan\n    github: AnuragRamdasan\n\nChoongmin Lee\n    github: clee704\n\nPatrick Pittman\n    github: ptpittman\n\nHunter Lang\n    github: hunterlang\n\nAlexey\n    github: nihisil\n\nJaymz Campbell\n    github: jaymzcd\n\nRoss McFarland\n    github: ross\n\nJohn McMellen\n    github: jmcmellen\n\nJohan Lövgren\n    github: dashj\n\nJoachim Krüger\n    github: jkrgr\n\nShichao An\n    github: shichao-an\n\nMichael Bortnyck\n    github: mbortnyck\n\nAndré Cloete\n    github: aj-cloete\n\nDavid Acacio\n    github: dacacioa\n\nThiago Abdnur\n    github: bolaum\n\nAurélien Ooms\n    github: aureooms\n\nMike Mattozzi\n    github: mmattozzi\n\nMarcio Mazza\n    github: marciomazza\n\nSungsu Lim\n    github: proflim\n\nEvandro Myller\n    github: emyller\n\nSérgio Agostinho\n    github: SergioRAgostinho\n\nAntonio Larrosa\n    github: antlarr\n\nAaron Craig\n    github: craigthelinguist\n\nCarlos del Castillo\n    github: greyalien502\n\nYudong Sun\n    github: sunjerry019\n\nJorge Perianez\n    github: JPery\n\nChendi Luo\n    github: Creonalia\n\nDaniel Lefevre\n    gitHub: dplefevre\n\nGrzegorz Kotfis\n    github: gkotfis\n\nPål Orby\n    github: orby"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 10.5283203125,
          "content": "# v0.25.1\n- Fix crashing bug in new scipy-powered EQ effects\n\n# v0.25.0\n- Don't show a runtime warning about the optional ffplay dependency being missing until someone trys to use it\n- Documentation improvements\n- Python 3.9 support\n- Improved efficiency of loading wave files with `pydub.AudioSegment.from_file()`\n- Ensure `pydub.AudioSegment().export()` always retuns files with a seek position at the beginning of the file   \n- Added more EQ effects to `pydub.scipy_effects` (requires scipy to be installed)\n- Fix a packaging bug where the LICENSE file was not included in the source distribution\n- Add a way to instantiate a `pydub.AudioSegment()` with a portion of an audio file via `pydub.AudioSegment().from_file()`\n\n# v0.24.1\n- Fix bug where ffmpeg errors in Python 3 are illegible\n- Fix bug where `split_on_silence` fails when there are one or fewer nonsilent segments\n- Fix bug in fallback audioop implementation\n\n# v0.24.0\n- Fix inconsistent handling of 8-bit audio\n- Fix bug where certain files will fail to parse\n- Fix bug where pyaudio stream is not closed on error\n- Allow codecs and parameters in wav and raw export\n- Fix bug in `pydub.AudioSegment.from_file` where supplied codec is ignored\n- Allow `pydub.silence.split_on_silence` to take a boolean for `keep_silence`\n- Fix bug where `pydub.silence.split_on_silence` sometimes adds non-silence from adjacent segments\n- Fix bug where `pydub.AudioSegment.extract_wav_headers` fails on empty wav files\n- Add new function `pydub.silence.detect_leading_silence`\n- Support conversion between an arbitrary number of channels and mono in `pydub.AudioSegment.set_channels`\n- Fix several issues related to reading from filelike objects\n\n# v0.23.1\n- Fix bug in passing ffmpeg/avconv parameters for `pydub.AudioSegment.from_mp3()`, `pydub.AudioSegment.from_flv()`, `pydub.AudioSegment.from_ogg()`, and `pydub.AudioSegment.from_wav()`\n- Fix logic bug in `pydub.effects.strip_silence()`\n\n# v0.23.0\n- Add support for playback via simpleaudio\n- Allow users to override the type in `pydub.AudioSegment().get_array_of_samples()` (PR #313)\n- Fix a bug where the wrong codec was used for 8-bit audio (PR #309 - issue #308)\n\n# v0.22.1\n- Fix `pydub.utils.mediainfo_json()` to work with newer, backwards-incompatible versions of ffprobe/avprobe\n\n# v0.22.0\n- Adds support for audio with frame rates (sample rates) of 48k and higher (requires scipy) (PR #262, fixes #134, #237, #209)\n- Adds support for PEP 519 File Path protocol (PR #252)\n- Fixes a few places where handles to temporary files are kept open (PR #280)\n- Add the license file to the python package to aid other packaging projects (PR #279, fixes #274)\n- Big fix for `pydub.silence.detect_silence()` (PR #263)\n\n# v0.21.0\n- NOTE: Semi-counterintuitive change: using the a stride when slicing AudioSegment instances (for example, `sound[::5000]`) will return chunks of 5000ms (not 1ms chunks every 5000ms) (#222)\n- Debug output from ffmpeg/avlib is no longer printed to the console unless you set up logging (see README for how to set up logging for your converter) (#223)\n- All pydub exceptions are now subclasses of `pydub.exceptions.PydubException` (PR #244)\n- The utilities in `pydub.silence` now accept a `seek_step`argument which can optionally be passed to improve the performance of silence detection (#211)\n- Fix to `pydub.silence` utilities which allow you to detect perfect silence (#233)\n- Fix a bug where threaded code screws up your terminal session due to ffmpeg inheriting the stdin from the parent process. (#231)\n- Fix a bug where a crashing programs using pydub would leave behind their temporary files (#206)\n\n# v0.20.0\n- Add new parameter `gain_during_overlay` to `pydub.AudioSegment.overlay` which allows users to adjust the volume of the target AudioSegment during the portion of the segment which is overlaid with the additional AudioSegment.\n- `pydub.playback.play()` No longer displays the (very verbose) playback \"banner\" when using ffplay\n- Fix a confusing error message when using invalid crossfade durations (issue #193)\n\n# v0.19.0\n- Allow codec and ffmpeg/avconv parameters to be set in the `pydub.AudioSegment.from_file()` for more control while decoding audio files\n- Allow `AudioSegment` objects with more than two channels to be split using `pydub.AudioSegment().split_to_mono()`\n- Add support for inverting the phase of only one channel in a multi-channel `pydub.AudioSegment` object\n- Fix a bug with the latest avprobe that broke `pydub.utils.mediainfo()`\n- Add tests for webm encoding/decoding\n\n# v0.18.0\n- Add a new constructor: `pydub.AudioSegment.from_mono_audiosegments()` which allows users to create a multi-channel audiosegment out of multiple mono ones.\n- Refactor `pydub.AudioSegment._sync()` to support an arbitrary number of audiosegment arguments.\n\n# v0.17.0\n- Add the ability to add a cover image to MP3 exports via the `cover` keyword argument to `pydub.AudioSegment().export()`\n- Add `pydub.AudioSegment().get_dc_offset()` and `pydub.AudioSegment().remove_dc_offset()` which allow detection and removal of DC offset in audio files.\n- Minor fixes for windows users\n\n# v0.16.7\n- Make `pydub.AudioSegment()._spawn()` accept array.array instances containing audio samples\n\n# v0.16.6\n- Make `pydub.AudioSegment()` objects playable inline in ipython notebooks.\n- Add scipy powered high pass, low pass, and band pass filters, which can be high order filters (they take `order` as a keyword argument). They are used for `pydub.AudioSegment().high_pass_filter()`, `pydub.AudioSegment().low_pass_filter()`, `pydub.AudioSegment().band_pass_filter()` when the `pydub.scipy_effects` module is imported.\n- Fix minor bug in `pydub.silence.detect_silence()`\n\n# v0.16.5\n- Update `pydub.AudioSegment()._spawn()` method to allow user subclassing of `pydub.AudioSegment`\n- Add a workaround for incorrect duration reporting of some mp3 files on macOS\n\n# v0.16.4\n- Add support for radd (basically, allow `sum()` to operate on an iterable of `pydub.AudioSegment()` objects)\n- Fix bug in 24-bit wav support (understatement. It didn't work right at all the first time)\n\n# v0.16.3\n- Add support for python 3.5 (overstatement. We just added python 3.5 to CI and it worked 😄)\n- Add native support for 24-bit wav files (ffmpeg/avconv not required)\n\n# v0.16.2\n- Fix bug where you couldn't directly instantiate `pydub.AudioSegment` with `bytes` data in python 3\n\n# v0.16.1\n- pydub will use any ffmpeg/avconv binary that's in the current directory (as reported by `os.getcwd()`) before searching for a system install\n\n# v0.16.0\n- Make it easier to instantiate `pydub.AudioSegment()` directly when creating audio segments from raw audio data (without having to write it to a file first)\n- Add `pydub.AudioSegment().get_array_of_samples()` method which returns the samples which make up an audio segment (you should usually prefer this over `pydub.AudioSegment().raw_data`)\n- Add `pydub.AudioSegment().raw_data` property which returns the raw audio data for an audio segment as a bytes (python 3) or a bytestring (python 3)\n- Allow users to specify frame rate in `pydub.AudioSegment.silent()` constructor\n\n# v0.15.0\n- Add support for RAW audio (basically WAV format, but without wave headers)\n- Add a new exception `pydub.exceptions.CouldntDecodeError` to indicate a failure of ffmpeg/avconv to decode a file (as indicated by ffmpeg/avconv exit code)\n\n# v0.14.2\n- Fix a bug in python 3.4 which failed to read wave files with no audio data (should have been audio segments with a duration of 0 ms)\n\n# v0.14.1\n- Fix a bug in `pydub.utils.mediainfo()` that caused inputs containing unescaped characters to raise a runtime error (inputs are not supposed to require escaping)\n\n# v0.14.0\n- Rename `pydub.AudioSegment().set_gain()` to `pydub.AudioSegment().apply_gain_stereo()` to better reflect it's place in the world (as a counterpart to `pydub.AudioSegment().apply_gain()`)\n\n# v0.13.0\n- Add `pydub.AudioSegment().pan()` which returns a new stereo audio segment panned left/right as specified.\n\n# v0.12.0\n- Add a logger, `\"pydub.converter\"` which logs the ffmpeg commands being run by pydub.\n- Add `pydub.AudioSegment().split_to_mono()` method which returns a list of mono audio segments. One for each channel in the original audio segment.\n- Fix a bug in `pydub.silence.detect_silence()` which caused the function to break when a silent audio segment was equal in length to the minimum silence length. It should report a single span of silence covering the whole silent audio segment. Now it does.\n- Fix a bug where uncommon wav formats (those not supported by the stdlib wave module) would throw an exception rather than converting to a more common format via ffmpeg/avconv\n\n# v0.11.0\n- Add `pydub.AudioSegment().max_dBFS` which reports the loudness (in dBFS) of the loudest point (i.e., highest amplitude sample) of an audio segment\n\n# v0.10.0\n- Overhaul Documentation\n- Improve performance of `pydub.AudioSegment().overlay()`\n- Add `pydub.AudioSegment().invert_phase()` which (shocker) inverts the phase of an audio segment\n- Fix a type error in `pydub.AudioSegment.get_sample_slice()`\n\n# v0.9.5\n- Add `pydub.generators` module containing simple signal generation functions (white noise, sine, square wave, etc)\n- Add a `loops` keyword argument to `pydub.AudioSegment().overlay()` which allows users to specify that the overlaid audio should be repeated (i.e., looped) a certain number of times, or indefinitely\n\n# 0.9.4\n- Fix a bug in db_to_float() where all values were off by a factor of 2\n\n# 0.9.3\n- Allow users to set the location of their converter by setting `pydub.AudioSegment.converter = \"/path/to/ffmpeg\"` and added a shim to support the old method of assigning to `pydub.AudioSegment.ffmpeg` (which is deprecated now that we support avconv)\n\n# v0.9.2\n- Add support for Python 3.4\n- Audio files opened with format \"wave\" are treated as \"wav\" and \"m4a\" are treated as \"mp4\"\n- Add `pydub.silence` module with simple utilities for detecting and removing silence.\n- Fix a bug affecting auto-detection of ffmpeg/avconv on windows.\n- Fix a bug that caused pydub to only work when ffmpeg/avconv is present (it should be able to work with WAV data without any dependencies)\n\n# v0.9.1\n- Add a runtime warning when ffmpeg/avconv cannot be found to aid debugging\n\n# v0.9.0\n- Added support for pypy (by reimplementing audioop in python). Also, we contributed our implementation to the pypy project, so that's 💯\n- Add support for avconv as an alternative to ffmpeg\n- Add a new helper module `pydub.playback` which allows you to quickly listen to an audio segment using ffplay (or avplay)\n- Add new function `pydub.utils.mediainfo('/path/to/audio/file.ext')` which reports back the results of ffprobe (or avprobe) including codec, bitrate, channels, etc\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.552734375,
          "content": "Pydub loves user contributions. \n\nWe are happy to merge Pull Requests for features and bug fixes, of course. But, also spelling corrections, PEP 8 conformity, and platform-specific fixes.\n\nDon't be shy!\n\n### How to contribute:\n\n1. Fork [pydub on github](https://github.com/jiaaro/pydub)\n2. Commit changes\n3. Send a Pull Request\n\nyou did it! \n\ndon't forget to append your name to the AUTHORS file ;)\n\nThere _are_ a few things that will make your Pull Request more likely to be merged:\n\n1. Maintain backward compatibility\n2. Avoid new dependencies\n3. Include tests (and make sure they pass)\n4. Write a short description of **what** is changed and **why**\n5. Keep your Pull Request small, and focused on fixing one thing. \n\n  Smaller is easier to review, and easier to understand. \n  \n  If you want to fix spelling and PEP 8 violations, send two pull requests :)\n  \n  \n### Want to pitch in?\n  \nTake a look at our issue tracker for anything tagged [`bug`][bugs] or [`todo`][todos] - these are goals of the project and your improvements are _very_ likely to be merged!\n\nThat being said, there are many possible contributions we haven't thought of already. Those are welcome too!\n\nHere are some general topics of interest for future development:\n\n- Make it easier to get started with pydub\n- More/better audio effects\n- Support more audio formats\n- Improve handling of large audio files\n- Make things faster and use less memory.\n\n[bugs]: https://github.com/jiaaro/pydub/issues?q=is%3Aissue+is%3Aopen+label%3Abug\n[todos]: https://github.com/jiaaro/pydub/issues?q=is%3Aissue+is%3Aopen+label%3Atodo\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "Copyright (c) 2011 James Robert, http://jiaaro.com\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.015625,
          "content": "include LICENSE\n"
        },
        {
          "name": "README.markdown",
          "type": "blob",
          "size": 9.5263671875,
          "content": "# Pydub [![Build Status](https://travis-ci.org/jiaaro/pydub.svg?branch=master)](https://travis-ci.org/jiaaro/pydub) [![Build status](https://ci.appveyor.com/api/projects/status/gy1ucp9o5khq7fqi/branch/master?svg=true)](https://ci.appveyor.com/project/jiaaro/pydub/branch/master)\n\nPydub lets you do stuff to audio in a way that isn't stupid.\n\n**Stuff you might be looking for**:\n - [Installing Pydub](https://github.com/jiaaro/pydub#installation)\n - [API Documentation](https://github.com/jiaaro/pydub/blob/master/API.markdown)\n - [Dependencies](https://github.com/jiaaro/pydub#dependencies)\n - [Playback](https://github.com/jiaaro/pydub#playback)\n - [Setting up ffmpeg](https://github.com/jiaaro/pydub#getting-ffmpeg-set-up)\n - [Questions/Bugs](https://github.com/jiaaro/pydub#bugs--questions)\n \n\n##  Quickstart\n\nOpen a WAV file\n\n```python\nfrom pydub import AudioSegment\n\nsong = AudioSegment.from_wav(\"never_gonna_give_you_up.wav\")\n```\n\n...or a mp3\n\n```python\nsong = AudioSegment.from_mp3(\"never_gonna_give_you_up.mp3\")\n```\n\n... or an ogg, or flv, or [anything else ffmpeg supports](http://www.ffmpeg.org/general.html#File-Formats)\n\n```python\nogg_version = AudioSegment.from_ogg(\"never_gonna_give_you_up.ogg\")\nflv_version = AudioSegment.from_flv(\"never_gonna_give_you_up.flv\")\n\nmp4_version = AudioSegment.from_file(\"never_gonna_give_you_up.mp4\", \"mp4\")\nwma_version = AudioSegment.from_file(\"never_gonna_give_you_up.wma\", \"wma\")\naac_version = AudioSegment.from_file(\"never_gonna_give_you_up.aiff\", \"aac\")\n```\n\nSlice audio:\n\n```python\n# pydub does things in milliseconds\nten_seconds = 10 * 1000\n\nfirst_10_seconds = song[:ten_seconds]\n\nlast_5_seconds = song[-5000:]\n```\n\nMake the beginning louder and the end quieter\n\n```python\n# boost volume by 6dB\nbeginning = first_10_seconds + 6\n\n# reduce volume by 3dB\nend = last_5_seconds - 3\n```\n\nConcatenate audio (add one file to the end of another)\n\n```python\nwithout_the_middle = beginning + end\n```\n\nHow long is it?\n\n```python\nwithout_the_middle.duration_seconds == 15.0\n```\n\nAudioSegments are immutable\n\n```python\n# song is not modified\nbackwards = song.reverse()\n```\n\nCrossfade (again, beginning and end are not modified)\n\n```python\n# 1.5 second crossfade\nwith_style = beginning.append(end, crossfade=1500)\n```\n\nRepeat\n\n```python\n# repeat the clip twice\ndo_it_over = with_style * 2\n```\n\nFade (note that you can chain operations because everything returns\nan AudioSegment)\n\n```python\n# 2 sec fade in, 3 sec fade out\nawesome = do_it_over.fade_in(2000).fade_out(3000)\n```\n\nSave the results (again whatever ffmpeg supports)\n\n```python\nawesome.export(\"mashup.mp3\", format=\"mp3\")\n```\n\nSave the results with tags (metadata)\n\n```python\nawesome.export(\"mashup.mp3\", format=\"mp3\", tags={'artist': 'Various artists', 'album': 'Best of 2011', 'comments': 'This album is awesome!'})\n```\n\nYou can pass an optional bitrate argument to export using any syntax ffmpeg \nsupports.\n\n```python\nawesome.export(\"mashup.mp3\", format=\"mp3\", bitrate=\"192k\")\n```\n\nAny further arguments supported by ffmpeg can be passed as a list in a \n'parameters' argument, with switch first, argument second. Note that no \nvalidation takes place on these parameters, and you may be limited by what \nyour particular build of ffmpeg/avlib supports.\n\n```python\n# Use preset mp3 quality 0 (equivalent to lame V0)\nawesome.export(\"mashup.mp3\", format=\"mp3\", parameters=[\"-q:a\", \"0\"])\n\n# Mix down to two channels and set hard output volume\nawesome.export(\"mashup.mp3\", format=\"mp3\", parameters=[\"-ac\", \"2\", \"-vol\", \"150\"])\n```\n\n## Debugging\n\nMost issues people run into are related to converting between formats using\nffmpeg/avlib. Pydub provides a logger that outputs the subprocess calls to \nhelp you track down issues:\n\n```python\n>>> import logging\n\n>>> l = logging.getLogger(\"pydub.converter\")\n>>> l.setLevel(logging.DEBUG)\n>>> l.addHandler(logging.StreamHandler())\n\n>>> AudioSegment.from_file(\"./test/data/test1.mp3\")\nsubprocess.call(['ffmpeg', '-y', '-i', '/var/folders/71/42k8g72x4pq09tfp920d033r0000gn/T/tmpeZTgMy', '-vn', '-f', 'wav', '/var/folders/71/42k8g72x4pq09tfp920d033r0000gn/T/tmpK5aLcZ'])\n<pydub.audio_segment.AudioSegment object at 0x101b43e10>\n```\n\nDon't worry about the temporary files used in the conversion. They're cleaned up \nautomatically.\n\n## Bugs & Questions\n\nYou can file bugs in our [github issues tracker](https://github.com/jiaaro/pydub/issues), \nand ask any technical questions on \n[Stack Overflow using the pydub tag](http://stackoverflow.com/questions/ask?tags=pydub). \nWe keep an eye on both.\n\n## Installation\n\nInstalling pydub is easy, but don't forget to install ffmpeg/avlib (the next section in this doc)\n\n    pip install pydub\n\nOr install the latest dev version from github (or replace `@master` with a [release version like `@v0.12.0`](https://github.com/jiaaro/pydub/releases))…\n\n    pip install git+https://github.com/jiaaro/pydub.git@master\n\n-OR-\n\n    git clone https://github.com/jiaaro/pydub.git\n\n-OR-\n\nCopy the pydub directory into your python path. Zip \n[here](https://github.com/jiaaro/pydub/zipball/master)\n\n## Dependencies\n\nYou can open and save WAV files with pure python. For opening and saving non-wav \nfiles – like mp3 – you'll need [ffmpeg](http://www.ffmpeg.org/) or \n[libav](http://libav.org/).\n\n### Playback\n\nYou can play audio if you have one of these installed (simpleaudio _strongly_ recommended, even if you are installing ffmpeg/libav):\n\n - [simpleaudio](https://simpleaudio.readthedocs.io/en/latest/)\n - [pyaudio](https://people.csail.mit.edu/hubert/pyaudio/docs/#)\n - ffplay (usually bundled with ffmpeg, see the next section)\n - avplay (usually bundled with libav, see the next section)\n \n```python\nfrom pydub import AudioSegment\nfrom pydub.playback import play\n\nsound = AudioSegment.from_file(\"mysound.wav\", format=\"wav\")\nplay(sound)\n```\n\n## Getting ffmpeg set up\n\nYou may use **libav or ffmpeg**.\n\nMac (using [homebrew](http://brew.sh)):\n\n```bash\n# libav\nbrew install libav\n\n####    OR    #####\n\n# ffmpeg\nbrew install ffmpeg\n```\n\nLinux (using aptitude):\n\n```bash\n# libav\napt-get install libav-tools libavcodec-extra\n\n####    OR    #####\n\n# ffmpeg\napt-get install ffmpeg libavcodec-extra\n```\n\nWindows:\n\n1. Download and extract libav from [Windows binaries provided here](http://builds.libav.org/windows/).\n2. Add the libav `/bin` folder to your PATH envvar\n3. `pip install pydub`\n\n## Important Notes\n\n`AudioSegment` objects are [immutable](http://www.devshed.com/c/a/Python/String-and-List-Python-Object-Types/1/)\n\n\n### Ogg exporting and default codecs\n\nThe Ogg specification ([http://tools.ietf.org/html/rfc5334](rfc5334)) does not specify\nthe codec to use, this choice is left up to the user. Vorbis and Theora are just\nsome of a number of potential codecs (see page 3 of the rfc) that can be used for the\nencapsulated data.\n\nWhen no codec is specified exporting to `ogg` will _default_ to using `vorbis`\nas a convenience. That is:\n\n```python\nfrom pydub import AudioSegment\nsong = AudioSegment.from_mp3(\"test/data/test1.mp3\")\nsong.export(\"out.ogg\", format=\"ogg\")  # Is the same as:\nsong.export(\"out.ogg\", format=\"ogg\", codec=\"libvorbis\")\n```\n\n## Example Use\n\nSuppose you have a directory filled with *mp4* and *flv* videos and you want to convert all of them to *mp3* so you can listen to  them on your mp3 player.\n\n```python\nimport os\nimport glob\nfrom pydub import AudioSegment\n\nvideo_dir = '/home/johndoe/downloaded_videos/'  # Path where the videos are located\nextension_list = ('*.mp4', '*.flv')\n\nos.chdir(video_dir)\nfor extension in extension_list:\n    for video in glob.glob(extension):\n        mp3_filename = os.path.splitext(os.path.basename(video))[0] + '.mp3'\n        AudioSegment.from_file(video).export(mp3_filename, format='mp3')\n```\n\n### How about another example?\n\n```python\nfrom glob import glob\nfrom pydub import AudioSegment\n\nplaylist_songs = [AudioSegment.from_mp3(mp3_file) for mp3_file in glob(\"*.mp3\")]\n\nfirst_song = playlist_songs.pop(0)\n\n# let's just include the first 30 seconds of the first song (slicing\n# is done by milliseconds)\nbeginning_of_song = first_song[:30*1000]\n\nplaylist = beginning_of_song\nfor song in playlist_songs:\n\n    # We don't want an abrupt stop at the end, so let's do a 10 second crossfades\n    playlist = playlist.append(song, crossfade=(10 * 1000))\n\n# let's fade out the end of the last song\nplaylist = playlist.fade_out(30)\n\n# hmm I wonder how long it is... ( len(audio_segment) returns milliseconds )\nplaylist_length = len(playlist) / (1000*60)\n\n# lets save it!\nwith open(\"%s_minute_playlist.mp3\" % playlist_length, 'wb') as out_f:\n    playlist.export(out_f, format='mp3')\n```\n\n## License ([MIT License](http://opensource.org/licenses/mit-license.php))\n\nCopyright © 2011 James Robert, http://jiaaro.com\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.8935546875,
          "content": "build: false\nenvironment:\n  matrix:\n    - PYTHON: \"C:/Python27\"\n      FFMPEG: \"4.2.3\"\n    - PYTHON: \"C:/Python34\"\n      FFMPEG: \"4.2.3\"\n    - PYTHON: \"C:/Python35\"\n      FFMPEG: \"4.2.3\"\n    - PYTHON: \"C:/Python36\"\n      FFMPEG: \"4.2.3\"\n    - PYTHON: \"C:/Python36\"\n      FFMPEG: \"latest\"\nmatrix:\n  allow_failures:\n    - FFMPEG: \"latest\"\ninit:\n  - \"ECHO %PYTHON%\"\n  - ps: \"ls C:/Python*\"\ninstall:\n  - \"%PYTHON%/python.exe -m pip install wheel\"\n  - \"%PYTHON%/python.exe -m pip install -e .\"\n  # Install ffmpeg\n  - ps: Start-FileDownload ('https://github.com/advancedfx/ffmpeg.zeranoe.com-builds-mirror/releases/download/20200915/ffmpeg-' + $env:FFMPEG + '-win64-shared.zip') ffmpeg-shared.zip\n  - 7z x ffmpeg-shared.zip > NULL\n  - \"SET PATH=%cd%\\\\ffmpeg-%FFMPEG%-win64-shared\\\\bin;%PATH%\"\n  # check ffmpeg installation (also shows version)\n  - \"ffmpeg.exe -version\"\ntest_script:\n  - \"%PYTHON%/python.exe test/test.py\"\n"
        },
        {
          "name": "pydub",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.05078125,
          "content": "[wheel]\nuniversal = 1\n\n[pep8]\nmax-line-length = 100\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.48828125,
          "content": "__doc__ = \"\"\"\nManipulate audio with an simple and easy high level interface.\n\nSee the README file for details, usage info, and a list of gotchas.\n\"\"\"\n\nfrom setuptools import setup\n\nsetup(\n    name='pydub',\n    version='0.25.1',\n    author='James Robert',\n    author_email='jiaaro@gmail.com',\n    description='Manipulate audio with an simple and easy high level interface',\n    license='MIT',\n    keywords='audio sound high-level',\n    url='http://pydub.com',\n    packages=['pydub'],\n    long_description=__doc__,\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Intended Audience :: Developers',\n        'Operating System :: OS Independent',\n        \"Topic :: Multimedia :: Sound/Audio\",\n        \"Topic :: Multimedia :: Sound/Audio :: Analysis\",\n        \"Topic :: Multimedia :: Sound/Audio :: Conversion\",\n        \"Topic :: Multimedia :: Sound/Audio :: Editors\",\n        \"Topic :: Multimedia :: Sound/Audio :: Mixers\",\n        \"Topic :: Software Development :: Libraries\",\n        'Topic :: Utilities',\n    ]\n)\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}